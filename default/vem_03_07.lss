
vem_03_07.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000130  00800100  000102f0  000103a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000102f0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000bfe  00800230  00800230  000104d4  2**0
                  ALLOC
  3 .eeprom       00000194  00810000  00810000  000104d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  00010668  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000009d8  00000000  00000000  000106c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000145cb  00000000  00000000  0001109c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d8  00000000  00000000  00025667  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e20  00000000  00000000  0002603f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000024d8  00000000  00000000  00029e60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000404a  00000000  00000000  0002c338  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000fe94  00000000  00000000  00030382  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d40  00000000  00000000  00040216  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 74 28 	jmp	0x50e8	; 0x50e8 <__ctors_end>
       4:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
       8:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
       c:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      10:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      14:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      18:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      1c:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      20:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      24:	0c 94 5d 2f 	jmp	0x5eba	; 0x5eba <__vector_9>
      28:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      2c:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      30:	0c 94 7f 2d 	jmp	0x5afe	; 0x5afe <__vector_12>
      34:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      38:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      3c:	0c 94 2d 2f 	jmp	0x5e5a	; 0x5e5a <__vector_15>
      40:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      44:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      48:	0c 94 90 63 	jmp	0xc720	; 0xc720 <__vector_18>
      4c:	0c 94 75 75 	jmp	0xeaea	; 0xeaea <__vector_19>
      50:	0c 94 c2 3b 	jmp	0x7784	; 0x7784 <__vector_20>
      54:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      58:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      5c:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      60:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      64:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      68:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      6c:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      70:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      74:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      78:	0c 94 38 4d 	jmp	0x9a70	; 0x9a70 <__vector_30>
      7c:	0c 94 3c 76 	jmp	0xec78	; 0xec78 <__vector_31>
      80:	0c 94 7b 4d 	jmp	0x9af6	; 0x9af6 <__vector_32>
      84:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      88:	0c 94 93 28 	jmp	0x5126	; 0x5126 <__bad_interrupt>
      8c:	20 33       	cpi	r18, 0x30	; 48
      8e:	20 33       	cpi	r18, 0x30	; 48
      90:	ac 33       	cpi	r26, 0x3C	; 60
      92:	ac 33       	cpi	r26, 0x3C	; 60
      94:	08 35       	cpi	r16, 0x58	; 88
      96:	07 34       	cpi	r16, 0x47	; 71
      98:	08 35       	cpi	r16, 0x58	; 88
      9a:	08 35       	cpi	r16, 0x58	; 88
      9c:	08 35       	cpi	r16, 0x58	; 88
      9e:	08 35       	cpi	r16, 0x58	; 88
      a0:	08 35       	cpi	r16, 0x58	; 88
      a2:	08 35       	cpi	r16, 0x58	; 88
      a4:	08 35       	cpi	r16, 0x58	; 88
      a6:	08 35       	cpi	r16, 0x58	; 88
      a8:	36 34       	cpi	r19, 0x46	; 70
      aa:	af 34       	cpi	r26, 0x4F	; 79
      ac:	a5 36       	cpi	r26, 0x65	; 101
      ae:	a5 36       	cpi	r26, 0x65	; 101
      b0:	3b 37       	cpi	r19, 0x7B	; 123
      b2:	3b 37       	cpi	r19, 0x7B	; 123
      b4:	4c 38       	cpi	r20, 0x8C	; 140
      b6:	a7 37       	cpi	r26, 0x77	; 119
      b8:	4c 38       	cpi	r20, 0x8C	; 140
      ba:	4c 38       	cpi	r20, 0x8C	; 140
      bc:	4c 38       	cpi	r20, 0x8C	; 140
      be:	4c 38       	cpi	r20, 0x8C	; 140
      c0:	4c 38       	cpi	r20, 0x8C	; 140
      c2:	4c 38       	cpi	r20, 0x8C	; 140
      c4:	4c 38       	cpi	r20, 0x8C	; 140
      c6:	4c 38       	cpi	r20, 0x8C	; 140
      c8:	fa 37       	cpi	r31, 0x7A	; 122
      ca:	fa 37       	cpi	r31, 0x7A	; 122
      cc:	98 44       	sbci	r25, 0x48	; 72
      ce:	c3 44       	sbci	r28, 0x43	; 67
      d0:	f7 44       	sbci	r31, 0x47	; 71
      d2:	2d 45       	sbci	r18, 0x5D	; 93
      d4:	98 44       	sbci	r25, 0x48	; 72
      d6:	c3 44       	sbci	r28, 0x43	; 67
      d8:	83 47       	sbci	r24, 0x73	; 115
      da:	4f 45       	sbci	r20, 0x5F	; 95
      dc:	78 45       	sbci	r23, 0x58	; 88
      de:	aa 45       	sbci	r26, 0x5A	; 90
      e0:	e3 45       	sbci	r30, 0x53	; 83
      e2:	4f 45       	sbci	r20, 0x5F	; 95
      e4:	78 45       	sbci	r23, 0x58	; 88
      e6:	0d 46       	sbci	r16, 0x6D	; 109
      e8:	0d 46       	sbci	r16, 0x6D	; 109
      ea:	83 47       	sbci	r24, 0x73	; 115
      ec:	11 46       	sbci	r17, 0x61	; 97
      ee:	1c 46       	sbci	r17, 0x6C	; 108
      f0:	27 46       	sbci	r18, 0x67	; 103
      f2:	5b 46       	sbci	r21, 0x6B	; 107
      f4:	11 46       	sbci	r17, 0x61	; 97
      f6:	1c 46       	sbci	r17, 0x6C	; 108
      f8:	83 47       	sbci	r24, 0x73	; 115
      fa:	83 47       	sbci	r24, 0x73	; 115
      fc:	83 47       	sbci	r24, 0x73	; 115
      fe:	8b 46       	sbci	r24, 0x6B	; 107
     100:	a7 46       	sbci	r26, 0x67	; 103
     102:	8b 46       	sbci	r24, 0x6B	; 107
     104:	a7 46       	sbci	r26, 0x67	; 103
     106:	c5 46       	sbci	r28, 0x65	; 101
     108:	c8 46       	sbci	r28, 0x68	; 104
     10a:	cf 46       	sbci	r28, 0x6F	; 111
     10c:	f1 46       	sbci	r31, 0x61	; 97
     10e:	15 47       	sbci	r17, 0x75	; 117
     110:	4a 47       	sbci	r20, 0x7A	; 122
     112:	fa 47       	sbci	r31, 0x7A	; 122
     114:	fe 47       	sbci	r31, 0x7E	; 126
     116:	03 48       	sbci	r16, 0x83	; 131
     118:	08 48       	sbci	r16, 0x88	; 136
     11a:	0d 48       	sbci	r16, 0x8D	; 141
     11c:	12 48       	sbci	r17, 0x82	; 130
     11e:	16 48       	sbci	r17, 0x86	; 134
     120:	1a 48       	sbci	r17, 0x8A	; 138
     122:	20 48       	sbci	r18, 0x80	; 128
     124:	36 48       	sbci	r19, 0x86	; 134
     126:	3a 48       	sbci	r19, 0x8A	; 138
     128:	3f 48       	sbci	r19, 0x8F	; 143
     12a:	43 48       	sbci	r20, 0x83	; 131
     12c:	48 48       	sbci	r20, 0x88	; 136
     12e:	4d 48       	sbci	r20, 0x8D	; 141
     130:	52 48       	sbci	r21, 0x82	; 130
     132:	57 48       	sbci	r21, 0x87	; 135
     134:	5d 48       	sbci	r21, 0x8D	; 141
     136:	72 48       	sbci	r23, 0x82	; 130
     138:	76 48       	sbci	r23, 0x86	; 134
     13a:	7b 48       	sbci	r23, 0x8B	; 139
     13c:	80 48       	sbci	r24, 0x80	; 128
     13e:	85 48       	sbci	r24, 0x85	; 133
     140:	89 48       	sbci	r24, 0x89	; 137
     142:	8e 48       	sbci	r24, 0x8E	; 142
     144:	93 48       	sbci	r25, 0x83	; 131
     146:	98 48       	sbci	r25, 0x88	; 136
     148:	9e 48       	sbci	r25, 0x8E	; 142
     14a:	5d 4b       	sbci	r21, 0xBD	; 189
     14c:	62 4b       	sbci	r22, 0xB2	; 178
     14e:	67 4b       	sbci	r22, 0xB7	; 183
     150:	7f 4b       	sbci	r23, 0xBF	; 191
     152:	6b 4b       	sbci	r22, 0xBB	; 187
     154:	6f 4b       	sbci	r22, 0xBF	; 191
     156:	73 4b       	sbci	r23, 0xB3	; 179
     158:	77 4b       	sbci	r23, 0xB7	; 183
     15a:	7b 4b       	sbci	r23, 0xBB	; 187
     15c:	0a 58       	subi	r16, 0x8A	; 138
     15e:	0d 58       	subi	r16, 0x8D	; 141
     160:	2a 58       	subi	r18, 0x8A	; 138
     162:	36 58       	subi	r19, 0x86	; 134
     164:	42 58       	subi	r20, 0x82	; 130
     166:	ff 58       	subi	r31, 0x8F	; 143
     168:	0e 59       	subi	r16, 0x9E	; 158
     16a:	f7 5e       	subi	r31, 0xE7	; 231
     16c:	7f 5f       	subi	r23, 0xFF	; 255
     16e:	f3 5e       	subi	r31, 0xE3	; 227
     170:	83 5f       	subi	r24, 0xF3	; 243
     172:	1f 5f       	subi	r17, 0xFF	; 255
     174:	23 5f       	subi	r18, 0xF3	; 243
     176:	27 5f       	subi	r18, 0xF7	; 247
     178:	2b 5f       	subi	r18, 0xFB	; 251
     17a:	2f 5f       	subi	r18, 0xFF	; 255
     17c:	33 5f       	subi	r19, 0xF3	; 243
     17e:	37 5f       	subi	r19, 0xF7	; 247
     180:	3b 5f       	subi	r19, 0xFB	; 251
     182:	3f 5f       	subi	r19, 0xFF	; 255
     184:	43 5f       	subi	r20, 0xF3	; 243
     186:	47 5f       	subi	r20, 0xF7	; 247
     188:	4b 5f       	subi	r20, 0xFB	; 251
     18a:	4f 5f       	subi	r20, 0xFF	; 255
     18c:	53 5f       	subi	r21, 0xF3	; 243
     18e:	57 5f       	subi	r21, 0xF7	; 247
     190:	5b 5f       	subi	r21, 0xFB	; 251
     192:	5f 5f       	subi	r21, 0xFF	; 255
     194:	63 5f       	subi	r22, 0xF3	; 243
     196:	d7 5f       	subi	r29, 0xF7	; 247
     198:	db 5f       	subi	r29, 0xFB	; 251
     19a:	df 5f       	subi	r29, 0xFF	; 255
     19c:	e3 5f       	subi	r30, 0xF3	; 243
     19e:	e7 5f       	subi	r30, 0xF7	; 247
     1a0:	eb 5f       	subi	r30, 0xFB	; 251
     1a2:	ef 5f       	subi	r30, 0xFF	; 255
     1a4:	f3 5f       	subi	r31, 0xF3	; 243
     1a6:	f7 5f       	subi	r31, 0xF7	; 247
     1a8:	fb 5f       	subi	r31, 0xFB	; 251
     1aa:	ff 5f       	subi	r31, 0xFF	; 255
     1ac:	03 60       	ori	r16, 0x03	; 3
     1ae:	64 64       	ori	r22, 0x44	; 68
     1b0:	7d 64       	ori	r23, 0x4D	; 77
     1b2:	8d 64       	ori	r24, 0x4D	; 77
     1b4:	9a 64       	ori	r25, 0x4A	; 74
     1b6:	4e 70       	andi	r20, 0x0E	; 14
     1b8:	4e 70       	andi	r20, 0x0E	; 14
     1ba:	c4 64       	ori	r28, 0x44	; 68
     1bc:	db 64       	ori	r29, 0x4B	; 75
     1be:	eb 64       	ori	r30, 0x4B	; 75
     1c0:	f8 64       	ori	r31, 0x48	; 72
     1c2:	08 65       	ori	r16, 0x58	; 88
     1c4:	15 65       	ori	r17, 0x55	; 85
     1c6:	25 65       	ori	r18, 0x55	; 85
     1c8:	34 65       	ori	r19, 0x54	; 84
     1ca:	b1 65       	ori	r27, 0x51	; 81
     1cc:	c1 65       	ori	r28, 0x51	; 81
     1ce:	ce 65       	ori	r28, 0x5E	; 94
     1d0:	de 65       	ori	r29, 0x5E	; 94
     1d2:	eb 65       	ori	r30, 0x5B	; 91
     1d4:	fb 65       	ori	r31, 0x5B	; 91
     1d6:	0f 66       	ori	r16, 0x6F	; 111
     1d8:	2e 66       	ori	r18, 0x6E	; 110
     1da:	42 66       	ori	r20, 0x62	; 98
     1dc:	58 66       	ori	r21, 0x68	; 104
     1de:	61 66       	ori	r22, 0x61	; 97
     1e0:	73 66       	ori	r23, 0x63	; 99
     1e2:	8a 66       	ori	r24, 0x6A	; 106
     1e4:	02 67       	ori	r16, 0x72	; 114
     1e6:	12 67       	ori	r17, 0x72	; 114
     1e8:	1f 67       	ori	r17, 0x7F	; 127
     1ea:	2f 67       	ori	r18, 0x7F	; 127
     1ec:	3c 67       	ori	r19, 0x7C	; 124
     1ee:	4c 67       	ori	r20, 0x7C	; 124
     1f0:	59 67       	ori	r21, 0x79	; 121
     1f2:	c3 67       	ori	r28, 0x73	; 115
     1f4:	53 68       	ori	r21, 0x83	; 131
     1f6:	61 68       	ori	r22, 0x81	; 129
     1f8:	8f 68       	ori	r24, 0x8F	; 143
     1fa:	d6 68       	ori	r29, 0x86	; 134
     1fc:	e4 68       	ori	r30, 0x84	; 132
     1fe:	f0 68       	ori	r31, 0x80	; 128
     200:	5d 69       	ori	r21, 0x9D	; 157
     202:	ec 69       	ori	r30, 0x9C	; 156
     204:	ab 6a       	ori	r26, 0xAB	; 171
     206:	be 6a       	ori	r27, 0xAE	; 174
     208:	ca 6a       	ori	r28, 0xAA	; 170
     20a:	1f 6b       	ori	r17, 0xBF	; 191
     20c:	89 6b       	ori	r24, 0xB9	; 185
     20e:	11 6c       	ori	r17, 0xC1	; 193
     210:	1e 6c       	ori	r17, 0xCE	; 206
     212:	31 6c       	ori	r19, 0xC1	; 193
     214:	4a 6c       	ori	r20, 0xCA	; 202
     216:	b7 6c       	ori	r27, 0xC7	; 199
     218:	ed 6c       	ori	r30, 0xCD	; 205
     21a:	28 6d       	ori	r18, 0xD8	; 216
     21c:	54 6d       	ori	r21, 0xD4	; 212
     21e:	65 6d       	ori	r22, 0xD5	; 213
     220:	71 6d       	ori	r23, 0xD1	; 209
     222:	4e 70       	andi	r20, 0x0E	; 14
     224:	4e 70       	andi	r20, 0x0E	; 14
     226:	4e 70       	andi	r20, 0x0E	; 14
     228:	4e 70       	andi	r20, 0x0E	; 14
     22a:	4e 70       	andi	r20, 0x0E	; 14
     22c:	4e 70       	andi	r20, 0x0E	; 14
     22e:	4e 70       	andi	r20, 0x0E	; 14
     230:	4e 70       	andi	r20, 0x0E	; 14
     232:	4e 70       	andi	r20, 0x0E	; 14
     234:	4e 70       	andi	r20, 0x0E	; 14
     236:	4e 70       	andi	r20, 0x0E	; 14
     238:	4e 70       	andi	r20, 0x0E	; 14
     23a:	4e 70       	andi	r20, 0x0E	; 14
     23c:	39 6b       	ori	r19, 0xB9	; 185
     23e:	45 6b       	ori	r20, 0xB5	; 181
     240:	51 6b       	ori	r21, 0xB1	; 177
     242:	5d 6b       	ori	r21, 0xBD	; 189
     244:	6b 6b       	ori	r22, 0xBB	; 187
     246:	77 6b       	ori	r23, 0xB7	; 183
     248:	4e 70       	andi	r20, 0x0E	; 14
     24a:	4e 70       	andi	r20, 0x0E	; 14
     24c:	96 6d       	ori	r25, 0xD6	; 214
     24e:	b8 6d       	ori	r27, 0xD8	; 216
     250:	c2 6d       	ori	r28, 0xD2	; 210
     252:	ce 6d       	ori	r28, 0xDE	; 222
     254:	dc 6d       	ori	r29, 0xDC	; 220
     256:	e8 6d       	ori	r30, 0xD8	; 216
     258:	f8 6d       	ori	r31, 0xD8	; 216
     25a:	18 6e       	ori	r17, 0xE8	; 232
     25c:	a4 6e       	ori	r26, 0xE4	; 228
     25e:	f2 6e       	ori	r31, 0xE2	; 226
     260:	00 6f       	ori	r16, 0xF0	; 240
     262:	2c 6f       	ori	r18, 0xFC	; 252
     264:	46 6f       	ori	r20, 0xF6	; 246
     266:	8f 6f       	ori	r24, 0xFF	; 255
     268:	9b 6f       	ori	r25, 0xFB	; 251
     26a:	b0 6f       	ori	r27, 0xF0	; 240
     26c:	bc 6f       	ori	r27, 0xFC	; 252
     26e:	d4 6f       	ori	r29, 0xF4	; 244
     270:	e2 6f       	ori	r30, 0xF2	; 242
     272:	f4 6f       	ori	r31, 0xF4	; 244
     274:	02 70       	andi	r16, 0x02	; 2
     276:	0e 70       	andi	r16, 0x0E	; 14
     278:	21 70       	andi	r18, 0x01	; 1
     27a:	2d 70       	andi	r18, 0x0D	; 13
     27c:	40 70       	andi	r20, 0x00	; 0
     27e:	4e 70       	andi	r20, 0x0E	; 14
     280:	5d 73       	andi	r21, 0x3D	; 61
     282:	5f 73       	andi	r21, 0x3F	; 63
     284:	6a 73       	andi	r22, 0x3A	; 58
     286:	6c 73       	andi	r22, 0x3C	; 60
     288:	79 73       	andi	r23, 0x39	; 57
     28a:	7b 73       	andi	r23, 0x3B	; 59
     28c:	86 73       	andi	r24, 0x36	; 54
     28e:	b8 73       	andi	r27, 0x38	; 56
     290:	bf 73       	andi	r27, 0x3F	; 63
     292:	c7 73       	andi	r28, 0x37	; 55
     294:	ce 73       	andi	r28, 0x3E	; 62
     296:	d6 73       	andi	r29, 0x36	; 54
     298:	dd 73       	andi	r29, 0x3D	; 61
     29a:	b8 73       	andi	r27, 0x38	; 56
     29c:	d6 73       	andi	r29, 0x36	; 54
     29e:	8f 73       	andi	r24, 0x3F	; 63
     2a0:	e5 73       	andi	r30, 0x35	; 53
     2a2:	ea 73       	andi	r30, 0x3A	; 58
     2a4:	f3 73       	andi	r31, 0x33	; 51
     2a6:	f8 73       	andi	r31, 0x38	; 56
     2a8:	01 74       	andi	r16, 0x41	; 65
     2aa:	06 74       	andi	r16, 0x46	; 70
     2ac:	e5 73       	andi	r30, 0x35	; 53
     2ae:	01 74       	andi	r16, 0x41	; 65
     2b0:	9a 73       	andi	r25, 0x3A	; 58
     2b2:	0f 74       	andi	r16, 0x4F	; 79
     2b4:	14 74       	andi	r17, 0x44	; 68
     2b6:	25 74       	andi	r18, 0x45	; 69
     2b8:	2a 74       	andi	r18, 0x4A	; 74
     2ba:	3b 74       	andi	r19, 0x4B	; 75
     2bc:	3d 74       	andi	r19, 0x4D	; 77
     2be:	4b 74       	andi	r20, 0x4B	; 75
     2c0:	55 74       	andi	r21, 0x45	; 69
     2c2:	7b 74       	andi	r23, 0x4B	; 75
     2c4:	82 74       	andi	r24, 0x42	; 66

000002c6 <__trampolines_end>:
     2c6:	ed e5       	ldi	r30, 0x5D	; 93
     2c8:	f2 20       	and	r15, r2
     2ca:	f1 e2       	ldi	r31, 0x21	; 33
     2cc:	ff e7       	ldi	r31, 0x7F	; 127
     2ce:	e8 20       	and	r14, r8
     2d0:	f1 20       	and	r15, r1
     2d2:	dd d1       	rcall	.+954    	; 0x68e <system_page+0x18>
     2d4:	20 00       	.word	0x0020	; ????

000002d6 <__c.5123>:
     2d6:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000002e6 <__c.5121>:
     2e6:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000002f1 <__c.4965>:
     2f1:	25 38 73 00                                         %8s.

000002f5 <__c.4957>:
     2f5:	25 6c 75 64 00                                      %lud.

000002fa <__c.4948>:
     2fa:	25 68 68 75 3a 25 68 68 75 3a 25 68 68 75 00        %hhu:%hhu:%hhu.

00000309 <__c.4940>:
     309:	25 68 68 75 2d 25 68 68 75 2d 25 68 68 75 00        %hhu-%hhu-%hhu.

00000318 <__c.4876>:
     318:	0d 0a 00                                            ...

0000031b <__c.4668>:
     31b:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

00000325 <__c.4666>:
     325:	25 30 38 6c 78 00                                   %08lx.

0000032b <__c.4649>:
     32b:	25 75 0d 0a 00                                      %u...

00000330 <__c.4550>:
     330:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

0000033c <__c.4548>:
     33c:	2f 00                                               /.

0000033e <__c.3706>:
     33e:	50 4f 53 54 00                                      POST.

00000343 <__c.3704>:
     343:	47 45 54 20 00                                      GET .

00000348 <__c.3700>:
     348:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00000358 <__c.3688>:
     358:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
     368:	68 75 00                                            hu.

0000036b <__c.3677>:
     36b:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
     37b:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

00000389 <__c.3652>:
     389:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00000396 <__c.3641>:
     396:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
     3a6:	68 68 75 00                                         hhu.

000003aa <__c.3615>:
     3aa:	25 75 00                                            %u.

000003ad <__c.3613>:
     3ad:	25 6c 75 64 00                                      %lud.

000003b2 <aCRCLo.1930>:
     3b2:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     3c2:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     3d2:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     3e2:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     3f2:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     402:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     412:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     422:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     432:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     442:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     452:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     462:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     472:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     482:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     492:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     4a2:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

000004b2 <aCRCHi.1929>:
     4b2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4c2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4d2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4e2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4f2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     502:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     512:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     522:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     532:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     542:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     552:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     562:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     572:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     582:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     592:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     5a2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

000005b2 <WebSite>:
     5b2:	87 45 c5 48 19 34 b0 39 04 1d 10 17 be 0c c4 05     .E.H.4.9........
     5c2:	e0 32                                               .2

000005c4 <Web_system>:
     5c4:	b2 0c 70 0c 18 00 d1 05 fa 05 76 06 04              ..p.......v..

000005d1 <system_OField>:
     5d1:	70 06 60 06 59 06 49 06 3e 06 2e 06 24 06 14 06     p.`.Y.I.>...$...
     5e1:	0e 06 fe 05 f9 05 e9 05                             ........

000005e9 <Web_Tlow>:
     5e9:	0a 0b 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005f9 <var_Tlow>:
     5f9:	54 6c 6f 77 00                                      Tlow.

000005fe <Web_Thigh>:
     5fe:	0a 0d 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

0000060e <var_Thigh>:
     60e:	54 68 69 67 68 00                                   Thigh.

00000614 <Web_BLupgrade>:
     614:	00 11 06 00 00 00 00 ff 00 00 00 7b 29 00 00 00     ...........{)...

00000624 <var_BLupgrade>:
     624:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

0000062e <Web_Bootloader>:
     62e:	00 11 06 00 00 00 00 ff 00 00 00 48 2a 00 00 00     ...........H*...

0000063e <var_Bootloader>:
     63e:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

00000649 <Web_Reboot>:
     649:	00 11 06 00 00 00 00 ff 00 00 00 75 29 00 00 00     ...........u)...

00000659 <var_Reboot>:
     659:	52 65 62 6f 6f 74 00                                Reboot.

00000660 <Web_Title>:
     660:	22 0f 00 00 00 00 00 02 00 00 00 00 00 00 00 15     "...............

00000670 <var_Title>:
     670:	54 69 74 6c 65 00                                   Title.

00000676 <system_page>:
     676:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     686:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     696:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     6a6:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     6b6:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     6c6:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     6d6:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     6e6:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     6f6:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     706:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     716:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     726:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     736:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     746:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     756:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     766:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     776:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     786:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     796:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     7a6:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     7b6:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     7c6:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     7d6:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     7e6:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     7f6:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     806:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     816:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     826:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     836:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     846:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     856:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     866:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
     876:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
     886:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
     896:	cd e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0     ........ .......
     8a6:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     8b6:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74     'text' name='Tit
     8c6:	6c 65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61     le' size='40' va
     8d6:	6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     lue='{{{{{{{{{{{
     8e6:	7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69     {{{{{{{{{'>...<i
     8f6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     906:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
     916:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
     926:	0d 0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b     ........... :{{{
     936:	7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46     {{{{{{{{ .....<F
     946:	4f 52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     ORM action='/' m
     956:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c     ethod='GET'>...<
     966:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
     976:	69 74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74     it' name='Reboot
     986:	27 20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27     ' value='Reboot'
     996:	3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1     >..</FORM>......
     9a6:	e8 ff 20 cf ce 3a 20 33 2e 30 37 0d 0a 3c 46 4f     .. ..: 3.07..<FO
     9b6:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
     9c6:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
     9d6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     9e6:	74 27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61     t' name='Bootloa
     9f6:	64 65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74     der' value='Boot
     a06:	6c 6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52     loader' color='R
     a16:	45 44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     ED'>..</FORM>..<
     a26:	2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69     /BR>..<FORM acti
     a36:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
     a46:	45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ET'>...<input ty
     a56:	70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65     pe='submit' name
     a66:	3d 27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c     ='BLupgrade' val
     a76:	75 65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d     ue='BLupgrade'>.
     a86:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
     a96:	0a 3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0     .<H2>...........
     aa6:	3c 2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3     </H2>...........
     ab6:	f0 e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43     ..:{{{{{{{&#176C
     ac6:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
     ad6:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
     ae6:	47 45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff     GET'>...........
     af6:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     b06:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69     'text' name='Thi
     b16:	67 68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c     gh' size='5' val
     b26:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31     ue='{{{{{{{'>&#1
     b36:	37 36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     76C...<input typ
     b46:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
     b56:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
     b66:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
     b76:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
     b86:	27 47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff     'GET'>..........
     b96:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     ba6:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f     'text' name='Tlo
     bb6:	77 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     w' size='5' valu
     bc6:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
     bd6:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
     be6:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
     bf6:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
     c06:	3c 2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d     </BR>....... GSM
     c16:	2d 3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32     ->EM: {{{/(max 2
     c26:	35 30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3     50)....</BR>....
     c36:	f4 e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b     ... EM->GSM: {{{
     c46:	2f 28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f     /(max 250)....</
     c56:	42 52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     BR>....</BODY>..
     c66:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00000c70 <system_IField>:
     c70:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
     c80:	00 00 14 04 06 00 00 00 22 0f 00 00 00 15 10 47     ........"......G
     c90:	09 00 00 02 09 e5 05 00 00 01 0a 0d 00 00 00 01     ................
     ca0:	0a 0b 00 00 00 01 00 63 09 00 00 00 00 52 0a 00     .......c.....R..
	...

00000cb2 <name_system>:
     cb2:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000cbe <Web_csd>:
     cbe:	07 17 a7 16 2c 00 cb 0c c7 08 e0 0d 02              ....,........

00000ccb <csd_OField>:
     ccb:	d9 0d c9 0d c4 0d b4 0d af 0d 9f 0d 9a 0d 8a 0d     ................
     cdb:	85 0d 75 0d 70 0d 60 0d 5b 0d 4b 0d 46 0d 36 0d     ..u.p.`.[.K.F.6.
     ceb:	31 0d 21 0d 1c 0d 0c 0d 07 0d f7 0c                 1.!.........

00000cf7 <Web_CSD_Number9>:
     cf7:	22 d6 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d07 <var_CSD_Number9>:
     d07:	43 53 44 39 00                                      CSD9.

00000d0c <Web_CSD_Number8>:
     d0c:	22 c9 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d1c <var_CSD_Number8>:
     d1c:	43 53 44 38 00                                      CSD8.

00000d21 <Web_CSD_Number7>:
     d21:	22 bc 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d31 <var_CSD_Number7>:
     d31:	43 53 44 37 00                                      CSD7.

00000d36 <Web_CSD_Number6>:
     d36:	22 af 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d46 <var_CSD_Number6>:
     d46:	43 53 44 36 00                                      CSD6.

00000d4b <Web_CSD_Number5>:
     d4b:	22 a2 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d5b <var_CSD_Number5>:
     d5b:	43 53 44 35 00                                      CSD5.

00000d60 <Web_CSD_Number4>:
     d60:	22 95 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d70 <var_CSD_Number4>:
     d70:	43 53 44 34 00                                      CSD4.

00000d75 <Web_CSD_Number3>:
     d75:	22 88 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d85 <var_CSD_Number3>:
     d85:	43 53 44 33 00                                      CSD3.

00000d8a <Web_CSD_Number2>:
     d8a:	22 7b 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "{..............

00000d9a <var_CSD_Number2>:
     d9a:	43 53 44 32 00                                      CSD2.

00000d9f <Web_CSD_Number1>:
     d9f:	22 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "n..............

00000daf <var_CSD_Number1>:
     daf:	43 53 44 31 00                                      CSD1.

00000db4 <Web_CSD_Number0>:
     db4:	22 61 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "a..............

00000dc4 <var_CSD_Number0>:
     dc4:	43 53 44 30 00                                      CSD0.

00000dc9 <Web_CLIP>:
     dc9:	01 5f 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ._..............

00000dd9 <var_CLIP>:
     dd9:	43 4c 49 50 4f 6e 00                                CLIPOn.

00000de0 <csd_page>:
     de0:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     df0:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     e00:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     e10:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     e20:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     e30:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     e40:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     e50:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     e60:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     e70:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     e80:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     e90:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     ea0:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     eb0:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     ec0:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     ed0:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     ee0:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     ef0:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     f00:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     f10:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     f20:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     f30:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     f40:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     f50:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     f60:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     f70:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     f80:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     f90:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     fa0:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     fb0:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     fc0:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     fd0:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f     .</a>..<HR>..<fo
     fe0:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
     ff0:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0     thod='GET'>.....
    1000:	ee e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a     ...... ......:..
    1010:	09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43     .<SELECT NAME="C
    1020:	4c 49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49     LIPOn"> ...<OPTI
    1030:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    1040:	7b 7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49     {{{>... ...<OPTI
    1050:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    1060:	7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43     {{{>.....</SELEC
    1070:	54 3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T> ...<input typ
    1080:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    1090:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    10a0:	0a 3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5     .<h3>...........
    10b0:	20 ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52      ......</h3></BR
    10c0:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    10d0:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10e0:	3e 0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75     >....1: ...<inpu
    10f0:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1100:	6d 65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27     me='CSD0' size='
    1110:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1120:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1130:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1140:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1150:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1160:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1170:	47 45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c     GET'>....2: ...<
    1180:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1190:	27 20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69     ' name='CSD1' si
    11a0:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    11b0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    11c0:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    11d0:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    11e0:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    11f0:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1200:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20     od='GET'>....3: 
    1210:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    1220:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32     text' name='CSD2
    1230:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1240:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1250:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1260:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1270:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    1280:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    1290:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    12a0:	b9 34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .4: ...<input ty
    12b0:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    12c0:	43 53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD3' size='12' 
    12d0:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    12e0:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    12f0:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    1300:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    1310:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    1320:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1330:	3e 0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75     >....5: ...<inpu
    1340:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1350:	6d 65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27     me='CSD4' size='
    1360:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1370:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1380:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1390:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    13a0:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    13b0:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    13c0:	47 45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c     GET'>....6: ...<
    13d0:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    13e0:	27 20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69     ' name='CSD5' si
    13f0:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    1400:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    1410:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    1420:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    1430:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    1440:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1450:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20     od='GET'>....7: 
    1460:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    1470:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36     text' name='CSD6
    1480:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1490:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    14a0:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    14b0:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    14c0:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    14d0:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    14e0:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    14f0:	b9 38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .8: ...<input ty
    1500:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    1510:	43 53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD7' size='12' 
    1520:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    1530:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    1540:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    1550:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    1560:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    1570:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1580:	3e 0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75     >....9: ...<inpu
    1590:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    15a0:	6d 65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27     me='CSD8' size='
    15b0:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    15c0:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    15d0:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    15e0:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    15f0:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1600:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1610:	47 45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09     GET'>....10: ...
    1620:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    1630:	74 27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73     t' name='CSD9' s
    1640:	69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27     ize='12' value='
    1650:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a     {{{{{{{{{{{{'>..
    1660:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    1670:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    1680:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    1690:	3e 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     >.. </BODY>..</H
    16a0:	54 4d 4c 3e 0d 0a 00                                TML>...

000016a7 <csd_IField>:
    16a7:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
    16b7:	00 00 14 04 06 00 00 00 1e 5f 00 65 45 00 1e 5f     ........._.eE.._
    16c7:	00 61 45 00 22 61 00 00 00 0d 22 6e 00 00 00 0d     .aE."a...."n....
    16d7:	22 7b 00 00 00 0d 22 88 00 00 00 0d 22 95 00 00     "{...."....."...
    16e7:	00 0d 22 a2 00 00 00 0d 22 af 00 00 00 0d 22 bc     ..".....".....".
    16f7:	00 00 00 0d 22 c9 00 00 00 0d 22 d6 00 00 00 0d     ....".....".....

00001707 <name_csd>:
    1707:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

00001710 <Web_gsm>:
    1710:	fb 1c cb 1c 1c 00 1d 17 cf 04 fc 17 04              .............

0000171d <gsm_OField>:
    171d:	f3 17 e3 17 d0 17 c0 17 b3 17 a3 17 9d 17 8d 17     ................
    172d:	81 17 71 17 65 17 55 17 49 17 39 17                 ..q.e.U.I.9.

00001739 <Web_SMS_Number3>:
    1739:	22 fd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001749 <var_SMS_Number3>:
    1749:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

00001755 <Web_SMS_Number2>:
    1755:	22 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001765 <var_SMS_Number2>:
    1765:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

00001771 <Web_SMS_Number1>:
    1771:	22 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001781 <var_SMS_Number1>:
    1781:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

0000178d <Web_SMS>:
    178d:	01 60 00 00 00 00 00 01 00 00 00 00 00 00 00 00     .`..............

0000179d <var_SMS>:
    179d:	53 4d 53 4f 6e 00                                   SMSOn.

000017a3 <Web_GPRS_apn_psw>:
    17a3:	22 3a 01 00 00 00 00 02 00 00 00 9f 2a 00 00 14     ":..........*...

000017b3 <var_GPRS_apn_psw>:
    17b3:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

000017c0 <Web_GPRS_apn_user_name>:
    17c0:	22 4e 01 00 00 00 00 02 00 00 00 9f 2a 00 00 14     "N..........*...

000017d0 <var_GPRS_apn_user_name>:
    17d0:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    17e0:	6d 65 00                                            me.

000017e3 <Web_GPRS_apn1>:
    17e3:	22 62 01 00 00 00 00 02 00 00 00 9f 2a 00 00 1e     "b..........*...

000017f3 <var_GPRS_apn1>:
    17f3:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000017fc <gsm_page>:
    17fc:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    180c:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    181c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    182c:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    183c:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    184c:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    185c:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    186c:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    187c:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    188c:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    189c:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    18ac:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    18bc:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    18cc:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    18dc:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    18ec:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    18fc:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    190c:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    191c:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    192c:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    193c:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    194c:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    195c:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    196c:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    197c:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    198c:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    199c:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    19ac:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    19bc:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    19cc:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    19dc:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    19ec:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee     .</a>..<HR>.....
    19fc:	e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20     .... ....... {{ 
    1a0c:	28 30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33     (0-31)</BR>..<h3
    1a1c:	3e 47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d     >GPRS</h3></BR>.
    1a2c:	0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f     .<form action='/
    1a3c:	27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d     ' method='GET'>.
    1a4c:	0a 09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c     ..APN name: ...<
    1a5c:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1a6c:	27 20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e     ' name='GPRS_apn
    1a7c:	27 20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75     ' size='29' valu
    1a8c:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    1a9c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    1aac:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    1abc:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    1acc:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    1adc:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    1aec:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1afc:	47 45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d     GET'>...User nam
    1b0c:	65 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     e: ...<input typ
    1b1c:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47     e='text' name='G
    1b2c:	50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d     PRS_apn_user_nam
    1b3c:	65 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     e' size='19' val
    1b4c:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1b5c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1b6c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1b7c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1b8c:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    1b9c:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    1bac:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50     ethod='GET'>...P
    1bbc:	61 73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70     assword: ...<inp
    1bcc:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    1bdc:	61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73     ame='GPRS_apn_ps
    1bec:	77 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     w' size='19' val
    1bfc:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1c0c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1c1c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1c2c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1c3c:	66 6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f     form..</BR>..<FO
    1c4c:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    1c5c:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    1c6c:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    1c7c:	74 27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53     t' name='ResetGS
    1c8c:	4d 27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47     M' value='ResetG
    1c9c:	53 4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     SM'>..</FORM>..<
    1cac:	2f 42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f     /BR></BR>.. </BO
    1cbc:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

00001ccb <gsm_IField>:
    1ccb:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
    1cdb:	00 00 14 04 06 00 00 00 00 17 06 00 00 00 22 62     .............."b
    1ceb:	01 00 00 1e 22 4e 01 00 00 14 22 3a 01 00 00 14     ...."N....":....

00001cfb <name_gsm>:
    1cfb:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

00001d04 <Web_network>:
    1d04:	d3 32 d1 31 a0 00 11 1d 4a 10 87 21 04              .2.1....J..!.

00001d11 <network_OField>:
    1d11:	78 21 68 21 54 21 44 21 32 21 22 21 c1 1d b1 1d     x!h!T!D!2!"!....
    1d21:	19 21 09 21 00 21 f0 20 e7 20 d7 20 ce 20 be 20     .!.!.!. . . . . 
    1d31:	b5 20 a5 20 9c 20 8c 20 83 20 73 20 6a 20 5a 20     . . . . . s j Z 
    1d41:	51 20 41 20 38 20 28 20 1f 20 0f 20 06 20 f6 1f     Q A 8 ( . . . ..
    1d51:	ed 1f dd 1f d4 1f c4 1f bb 1f ab 1f a2 1f 92 1f     ................
    1d61:	8c 1f 7c 1f 76 1f 66 1f 60 1f 50 1f 4a 1f 3a 1f     ..|.v.f.`.P.J.:.
    1d71:	34 1f 24 1f 1e 1f 0e 1f 08 1f f8 1e f2 1e e2 1e     4.$.............
    1d81:	dc 1e cc 1e c6 1e b6 1e b0 1e a0 1e 9a 1e 8a 1e     ................
    1d91:	84 1e 74 1e 6e 1e 5e 1e 58 1e 48 1e 42 1e 32 1e     ..t.n.^.X.H.B.2.
    1da1:	28 1e 18 1e 0e 1e fe 1d f4 1d e4 1d da 1d ca 1d     (...............

00001db1 <Web_ResetGSM>:
    1db1:	00 11 06 00 00 00 00 ff 00 00 00 77 29 00 00 00     ...........w)...

00001dc1 <var_ResetGSM>:
    1dc1:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00001dca <Web_UDP3_Port>:
    1dca:	08 28 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .(..............

00001dda <var_UDP3_Port>:
    1dda:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

00001de4 <Web_UDP2_Port>:
    1de4:	08 26 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .&..............

00001df4 <var_UDP2_Port>:
    1df4:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00001dfe <Web_UDP1_Port>:
    1dfe:	08 24 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .$..............

00001e0e <var_UDP1_Port>:
    1e0e:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

00001e18 <Web_UDP0_Port>:
    1e18:	08 22 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ."..............

00001e28 <var_UDP0_Port>:
    1e28:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

00001e32 <Web_UDP3_IP4>:
    1e32:	01 39 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .9..............

00001e42 <var_UDP3_IP4>:
    1e42:	55 44 50 33 34 00                                   UDP34.

00001e48 <Web_UDP3_IP3>:
    1e48:	01 38 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .8..............

00001e58 <var_UDP3_IP3>:
    1e58:	55 44 50 33 33 00                                   UDP33.

00001e5e <Web_UDP3_IP2>:
    1e5e:	01 37 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .7..............

00001e6e <var_UDP3_IP2>:
    1e6e:	55 44 50 33 32 00                                   UDP32.

00001e74 <Web_UDP3_IP1>:
    1e74:	01 36 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .6..............

00001e84 <var_UDP3_IP1>:
    1e84:	55 44 50 33 31 00                                   UDP31.

00001e8a <Web_UDP2_IP4>:
    1e8a:	01 35 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .5..............

00001e9a <var_UDP2_IP4>:
    1e9a:	55 44 50 32 34 00                                   UDP24.

00001ea0 <Web_UDP2_IP3>:
    1ea0:	01 34 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .4..............

00001eb0 <var_UDP2_IP3>:
    1eb0:	55 44 50 32 33 00                                   UDP23.

00001eb6 <Web_UDP2_IP2>:
    1eb6:	01 33 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .3..............

00001ec6 <var_UDP2_IP2>:
    1ec6:	55 44 50 32 32 00                                   UDP22.

00001ecc <Web_UDP2_IP1>:
    1ecc:	01 32 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .2..............

00001edc <var_UDP2_IP1>:
    1edc:	55 44 50 32 31 00                                   UDP21.

00001ee2 <Web_UDP1_IP4>:
    1ee2:	01 31 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .1..............

00001ef2 <var_UDP1_IP4>:
    1ef2:	55 44 50 31 34 00                                   UDP14.

00001ef8 <Web_UDP1_IP3>:
    1ef8:	01 30 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .0..............

00001f08 <var_UDP1_IP3>:
    1f08:	55 44 50 31 33 00                                   UDP13.

00001f0e <Web_UDP1_IP2>:
    1f0e:	01 2f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ./..............

00001f1e <var_UDP1_IP2>:
    1f1e:	55 44 50 31 32 00                                   UDP12.

00001f24 <Web_UDP1_IP1>:
    1f24:	01 2e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f34 <var_UDP1_IP1>:
    1f34:	55 44 50 31 31 00                                   UDP11.

00001f3a <Web_UDP0_IP4>:
    1f3a:	01 2d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .-..............

00001f4a <var_UDP0_IP4>:
    1f4a:	55 44 50 30 34 00                                   UDP04.

00001f50 <Web_UDP0_IP3>:
    1f50:	01 2c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .,..............

00001f60 <var_UDP0_IP3>:
    1f60:	55 44 50 30 33 00                                   UDP03.

00001f66 <Web_UDP0_IP2>:
    1f66:	01 2b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .+..............

00001f76 <var_UDP0_IP2>:
    1f76:	55 44 50 30 32 00                                   UDP02.

00001f7c <Web_UDP0_IP1>:
    1f7c:	01 2a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .*..............

00001f8c <var_UDP0_IP1>:
    1f8c:	55 44 50 30 31 00                                   UDP01.

00001f92 <Web_Cli3_IP4>:
    1f92:	01 1f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fa2 <var_Cli3_IP4>:
    1fa2:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00001fab <Web_Cli3_IP3>:
    1fab:	01 1e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fbb <var_Cli3_IP3>:
    1fbb:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00001fc4 <Web_Cli3_IP2>:
    1fc4:	01 1d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fd4 <var_Cli3_IP2>:
    1fd4:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00001fdd <Web_Cli3_IP1>:
    1fdd:	01 1c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fed <var_Cli3_IP1>:
    1fed:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00001ff6 <Web_Cli2_IP4>:
    1ff6:	01 1b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002006 <var_Cli2_IP4>:
    2006:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

0000200f <Web_Cli2_IP3>:
    200f:	01 1a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000201f <var_Cli2_IP3>:
    201f:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00002028 <Web_Cli2_IP2>:
    2028:	01 19 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002038 <var_Cli2_IP2>:
    2038:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

00002041 <Web_Cli2_IP1>:
    2041:	01 18 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002051 <var_Cli2_IP1>:
    2051:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

0000205a <Web_Cli1_IP4>:
    205a:	01 17 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000206a <var_Cli1_IP4>:
    206a:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

00002073 <Web_Cli1_IP3>:
    2073:	01 16 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002083 <var_Cli1_IP3>:
    2083:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

0000208c <Web_Cli1_IP2>:
    208c:	01 15 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000209c <var_Cli1_IP2>:
    209c:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

000020a5 <Web_Cli1_IP1>:
    20a5:	01 14 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020b5 <var_Cli1_IP1>:
    20b5:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

000020be <Web_Cli0_IP4>:
    20be:	01 13 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020ce <var_Cli0_IP4>:
    20ce:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

000020d7 <Web_Cli0_IP3>:
    20d7:	01 12 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020e7 <var_Cli0_IP3>:
    20e7:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

000020f0 <Web_Cli0_IP2>:
    20f0:	01 11 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002100 <var_Cli0_IP2>:
    2100:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

00002109 <Web_Cli0_IP1>:
    2109:	01 10 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002119 <var_Cli0_IP1>:
    2119:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

00002122 <Web_WebMaxSessionTime>:
    2122:	11 56 00 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .V........;.....

00002132 <var_WebMaxSessionTime>:
    2132:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    2142:	65 00                                               e.

00002144 <Web_TCP_CONNECT_timeout>:
    2144:	08 0e 01 00 00 00 00 ff ff 00 00 9f 2a 00 00 02     ............*...

00002154 <var_TCP_CONNECT_timeout>:
    2154:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2164:	6f 75 74 00                                         out.

00002168 <Web_TCP_ListenPort>:
    2168:	08 20 01 00 00 00 00 ff ff 00 00 9f 2a 00 00 00     . ..........*...

00002178 <var_TCP_ListenPort>:
    2178:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

00002187 <network_page>:
    2187:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    2197:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    21a7:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    21b7:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    21c7:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    21d7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    21e7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    21f7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    2207:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    2217:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    2227:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    2237:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    2247:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    2257:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    2267:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    2277:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    2287:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    2297:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    22a7:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    22b7:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    22c7:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    22d7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    22e7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    22f7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    2307:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    2317:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    2327:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    2337:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    2347:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    2357:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    2367:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    2377:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
    2387:	68 33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72     h3>TCP/IP Server
    2397:	3c 2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </h3>..<form act
    23a7:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    23b7:	47 45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70     GET'>...Listen p
    23c7:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    23d7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    23e7:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20     TCP_ListenPort' 
    23f7:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2407:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2417:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2427:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2437:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2447:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2457:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50     hod='GET'>...TCP
    2467:	2f 49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74     /IP connection t
    2477:	69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74     imeout:...<input
    2487:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    2497:	65 3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74     e='TCP_CONNECT_t
    24a7:	69 6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27     imeout' size='7'
    24b7:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e      value='{{{{{{'>
    24c7:	73 65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     sec...<input typ
    24d7:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    24e7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    24f7:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
    2507:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2517:	27 47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e     'GET'>...Session
    2527:	20 74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70      timeout:...<inp
    2537:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2547:	61 6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69     ame='WebMaxSessi
    2557:	6f 6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27     onTime' size='7'
    2567:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b      value='{{{{{{{{
    2577:	7b 7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74     {{'>sec...<input
    2587:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2597:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    25a7:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68     rm>..</BR>....<h
    25b7:	33 3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68     3>IP Firewall</h
    25c7:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    25d7:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    25e7:	27 3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70     '>...IP1:...<inp
    25f7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2607:	61 6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73     ame='Cli0_IP1' s
    2617:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    2627:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2637:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2647:	27 43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d     'Cli0_IP2' size=
    2657:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2667:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2677:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    2687:	30 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20     0_IP3' size='3' 
    2697:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    26a7:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    26b7:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50     t' name='Cli0_IP
    26c7:	34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     4' size='3' valu
    26d7:	65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     e='{{{'>...<inpu
    26e7:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    26f7:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    2707:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    2717:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    2727:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50     thod='GET'>...IP
    2737:	32 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     2:...<input type
    2747:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    2757:	69 31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27     i1_IP1' size='3'
    2767:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    2777:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    2787:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49     xt' name='Cli1_I
    2797:	50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P2' size='3' val
    27a7:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    27b7:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    27c7:	6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20     name='Cli1_IP3' 
    27d7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    27e7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    27f7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2807:	3d 27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65     ='Cli1_IP4' size
    2817:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2827:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2837:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2847:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2857:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    2867:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    2877:	45 54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69     ET'>...IP3:...<i
    2887:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2897:	20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27      name='Cli2_IP1'
    28a7:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    28b7:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    28c7:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    28d7:	65 3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a     e='Cli2_IP2' siz
    28e7:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    28f7:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    2907:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    2917:	6c 69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33     li2_IP3' size='3
    2927:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    2937:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2947:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f     ext' name='Cli2_
    2957:	49 50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP4' size='3' va
    2967:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     lue='{{{'>...<in
    2977:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    2987:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    2997:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c     /form>..</BR>..<
    29a7:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    29b7:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    29c7:	49 50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     IP4:...<input ty
    29d7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29e7:	43 6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27     Cli3_IP1' size='
    29f7:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    2a07:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    2a17:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33     text' name='Cli3
    2a27:	5f 49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP2' size='3' v
    2a37:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2a47:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2a57:	27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33     ' name='Cli3_IP3
    2a67:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2a77:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2a87:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a97:	6d 65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69     me='Cli3_IP4' si
    2aa7:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2ab7:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2ac7:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2ad7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2ae7:	0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63     .</BR>..<FORM ac
    2af7:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2b07:	27 47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     'GET'>...<input 
    2b17:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61     type='submit' na
    2b27:	6d 65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61     me='ResetGSM' va
    2b37:	6c 75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d     lue='ResetGSM'>.
    2b47:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
    2b57:	0a 0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0     .....<h3>.......
    2b67:	20 f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a      ....... ......:
    2b77:	3c 2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a     </h3>..</BR>....
    2b87:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    2b97:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    2ba7:	55 44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d     UDP Server1 IP:.
    2bb7:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2bc7:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31     ext' name='UDP01
    2bd7:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2be7:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2bf7:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2c07:	6d 65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d     me='UDP02' size=
    2c17:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2c27:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2c37:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2c47:	30 33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     03' size='3' val
    2c57:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2c67:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2c77:	6e 61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a     name='UDP04' siz
    2c87:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2c97:	27 3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70     '>..Port:...<inp
    2ca7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2cb7:	61 6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20     ame='UDP0_Port' 
    2cc7:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2cd7:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2ce7:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2cf7:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2d07:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2d17:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2d27:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20     hod='GET'>..UDP 
    2d37:	53 65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69     Server2 IP:...<i
    2d47:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2d57:	20 6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69      name='UDP11' si
    2d67:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2d77:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2d87:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2d97:	55 44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20     UDP12' size='3' 
    2da7:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2db7:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2dc7:	74 27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20     t' name='UDP13' 
    2dd7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2de7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2df7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2e07:	3d 27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33     ='UDP14' size='3
    2e17:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a     ' value='{{{'>..
    2e27:	50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74     Port:...<input t
    2e37:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2e47:	27 55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65     'UDP1_Port' size
    2e57:	3d 27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b     ='5' value='{{{{
    2e67:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2e77:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2e87:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2e97:	0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20     .</BR>....<form 
    2ea7:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    2eb7:	64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65     d='GET'>..UDP Se
    2ec7:	72 76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70     rver3 IP:...<inp
    2ed7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2ee7:	61 6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65     ame='UDP21' size
    2ef7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2f07:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    2f17:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2f27:	50 32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P22' size='3' va
    2f37:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    2f47:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2f57:	20 6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69      name='UDP23' si
    2f67:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2f77:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2f87:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2f97:	55 44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20     UDP24' size='3' 
    2fa7:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f     value='{{{'>..Po
    2fb7:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    2fc7:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2fd7:	44 50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27     DP2_Port' size='
    2fe7:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    2ff7:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    3007:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    3017:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    3027:	2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63     /BR>....<form ac
    3037:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    3047:	27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76     'GET'>..UDP Serv
    3057:	65 72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74     er4 IP:...<input
    3067:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3077:	65 3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27     e='UDP31' size='
    3087:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    3097:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    30a7:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    30b7:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    30c7:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    30d7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    30e7:	61 6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65     ame='UDP33' size
    30f7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    3107:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    3117:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    3127:	50 33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P34' size='3' va
    3137:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74     lue='{{{'>..Port
    3147:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    3157:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    3167:	33 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27     3_Port' size='5'
    3177:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d      value='{{{{{'>.
    3187:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    3197:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    31a7:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    31b7:	52 3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a     R>.... </BODY>..
    31c7:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

000031d1 <network_IField>:
    31d1:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
    31e1:	00 00 14 04 06 00 00 00 08 20 01 00 00 00 08 0e     ......... ......
    31f1:	01 00 00 02 11 56 00 00 00 02 01 10 01 00 00 00     .....V..........
    3201:	01 11 01 00 00 00 01 12 01 00 00 00 01 13 01 00     ................
    3211:	00 00 01 14 01 00 00 00 01 15 01 00 00 00 01 16     ................
    3221:	01 00 00 00 01 17 01 00 00 00 01 18 01 00 00 00     ................
    3231:	01 19 01 00 00 00 01 1a 01 00 00 00 01 1b 01 00     ................
    3241:	00 00 01 1c 01 00 00 00 01 1d 01 00 00 00 01 1e     ................
    3251:	01 00 00 00 01 1f 01 00 00 00 01 2a 01 00 00 00     ...........*....
    3261:	01 2b 01 00 00 00 01 2c 01 00 00 00 01 2d 01 00     .+.....,.....-..
    3271:	00 00 08 22 01 00 00 00 01 2e 01 00 00 00 01 2f     ...".........../
    3281:	01 00 00 00 01 30 01 00 00 00 01 31 01 00 00 00     .....0.....1....
    3291:	08 24 01 00 00 00 01 32 01 00 00 00 01 33 01 00     .$.....2.....3..
    32a1:	00 00 01 34 01 00 00 00 01 35 01 00 00 00 08 26     ...4.....5.....&
    32b1:	01 00 00 00 01 36 01 00 00 00 01 37 01 00 00 00     .....6.....7....
    32c1:	01 38 01 00 00 00 01 39 01 00 00 00 08 28 01 00     .8.....9.....(..
	...

000032d3 <name_network>:
    32d3:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

000032e0 <Web_name_access_error>:
    32e0:	07 34 00 00 00 00 00 00 1a 01 ed 32 00              .4.........2.

000032ed <name_access_error_page>:
    32ed:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    32fd:	3c 54 49 54 4c 45 3e ce f8 e8 e1 ea e0 20 e4 ee     <TITLE>...... ..
    330d:	f1 f2 f3 ef e0 3c 2f 54 49 54 4c 45 3e 0d 0a 3c     .....</TITLE>..<
    331d:	6d 65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d     meta http-equiv=
    332d:	22 43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63     "Content-Type" c
    333d:	6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d     ontent="text/htm
    334d:	6c 3b 20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f     l; charset=windo
    335d:	77 73 2d 31 32 35 31 22 3e 0d 0a 3c 2f 48 45 41     ws-1251">..</HEA
    336d:	44 3e 0d 0a 3c 63 65 6e 74 65 72 3e 0d 0a 3c 68     D>..<center>..<h
    337d:	65 61 64 3e 0d 0a 3c 68 33 3e c2 e0 f8 20 f3 f0     ead>..<h3>... ..
    338d:	ee e2 e5 ed fc 20 e4 ee f1 f2 f3 ef e0 20 ed e5     ..... ....... ..
    339d:	20 ef ee e7 e2 ee eb ff e5 f2 20 ef f0 ee f1 ec      ......... .....
    33ad:	e0 f2 f0 e8 e2 e0 f2 fc 20 fd f2 f3 20 f1 f2 f0     ........ ... ...
    33bd:	e0 ed e8 f6 f3 3c 2f 68 33 3e 0d 0a 3c 61 20 68     .....</h3>..<a h
    33cd:	72 65 66 3d 22 69 6e 64 65 78 2e 68 74 6d 6c 22     ref="index.html"
    33dd:	3e cd e0 e7 e0 e4 20 ed e0 20 e3 eb e0 e2 ed f3     >..... .. ......
    33ed:	fe 20 f1 f2 f0 e0 ed e8 f6 f3 3c 2f 61 3e 0d 0a     . ........</a>..
    33fd:	3c 2f 68 74 6d 6c 3e 0d 0a 00                       </html>...

00003407 <name_access_error>:
    3407:	61 63 63 65 73 73 5f 65 72 72 6f 72 2e 68 74 6d     access_error.htm
    3417:	6c 00                                               l.

00003419 <Web_favicon>:
    3419:	a4 39 00 00 00 00 00 00 7e 05 26 34 00              .9......~.&4.

00003426 <favicon>:
    3426:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    3436:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    3446:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    3456:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    3466:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    3476:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    3486:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    3496:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    34a6:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    34b6:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    34c6:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    34d6:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    34e6:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    34f6:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    3862:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3872:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3882:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    3892:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    38a2:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    38b2:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    38c2:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    38d2:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    38e2:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    38f2:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    3902:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    3912:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    3922:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    3932:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    3942:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3952:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3962:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

000039a4 <name_favicon>:
    39a4:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

000039b0 <Web_emeter>:
    39b0:	7b 45 87 43 1c 00 bd 39 00 09 87 3a 02              {E.C...9...:.

000039bd <emeter_OField>:
    39bd:	7c 3a 6c 3a 67 3a 57 3a 51 3a 41 3a 3a 3a 2a 3a     |:l:g:W:Q:A:::*:
    39cd:	21 3a 11 3a e9 39 d9 39 08 3a f8 39                 !:.:.9.9.:.9

000039d9 <Web_CurrDataPeriod>:
    39d9:	08 08 00 3c 00 00 00 ff ff 00 00 00 00 00 00 00     ...<............

000039e9 <var_CurrDataPeriod>:
    39e9:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

000039f8 <Web_AutoSend>:
    39f8:	01 0a 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

00003a08 <var_AutoSend>:
    3a08:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

00003a11 <Web_EM_UART_StopBits>:
    3a11:	00 28 09 00 00 00 00 01 00 00 00 c2 4b 00 00 00     .(..........K...

00003a21 <var_EM_UART_StopBits>:
    3a21:	53 74 6f 70 42 69 74 73 00                          StopBits.

00003a2a <Web_EM_UART_Parity>:
    3a2a:	00 fe 05 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00003a3a <var_EM_UART_Parity>:
    3a3a:	50 61 72 69 74 79 00                                Parity.

00003a41 <Web_EM_UART_BitQt>:
    3a41:	00 56 0a 00 00 00 00 03 00 00 00 00 00 00 00 00     .V..............

00003a51 <var_EM_UART_BitQt>:
    3a51:	42 69 74 51 74 00                                   BitQt.

00003a57 <Web_EM_UART_Rate>:
    3a57:	00 4f 0a 00 00 00 00 08 00 00 00 00 00 00 00 00     .O..............

00003a67 <var_EM_UART_Rate>:
    3a67:	52 61 74 65 00                                      Rate.

00003a6c <Web_EMeterType>:
    3a6c:	01 29 00 00 00 00 00 04 00 00 00 ee 4b 00 00 00     .)..........K...

00003a7c <var_EMeterType>:
    3a7c:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

00003a87 <emeter_page>:
    3a87:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3a97:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3aa7:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3ab7:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3ac7:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3ad7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3ae7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3af7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    3b07:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    3b17:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    3b27:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    3b37:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    3b47:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    3b57:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    3b67:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3b77:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3b87:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3b97:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    3ba7:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    3bb7:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3bc7:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    3bd7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    3be7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    3bf7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    3c07:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    3c17:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    3c27:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    3c37:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    3c47:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    3c57:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    3c67:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    3c77:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    3c87:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    3c97:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    3ca7:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    3cb7:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    3cc7:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    3cd7:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    3ce7:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    3cf7:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42     {{{{ ....*...</B
    3d07:	52 3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea     R>..<h3>... ....
    3d17:	f2 f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33     ...........:</h3
    3d27:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    3d37:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    3d47:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    3d57:	3d 22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d     ="EMeterType"> .
    3d67:	0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    3d77:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    3d87:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    3d97:	7b 7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26     {{{{{{{{>Landis&
    3da7:	47 79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     Gyr..<OPTION VAL
    3db7:	55 45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb     UE=2 {{{{{{{{>..
    3dc7:	c2 c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     .....<OPTION VAL
    3dd7:	55 45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5     UE=3 {{{{{{{{>..
    3de7:	f0 ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49     ......230..<OPTI
    3df7:	4f 4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b     ON VALUE=4 {{{{{
    3e07:	7b 7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d     {{{>..... ......
    3e17:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c     ..</SELECT> ...<
    3e27:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e37:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e47:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d     .</form>..</BR>.
    3e57:	0a 0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb     ...<h3>.........
    3e67:	20 52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68      RS232/RS485:</h
    3e77:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    3e87:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    3e97:	27 3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a     '>.............:
    3ea7:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    3eb7:	22 52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49     "Rate"> ...<OPTI
    3ec7:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    3ed7:	7b 7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f     {{{>1200bps...<O
    3ee7:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b     PTION VALUE=1 {{
    3ef7:	7b 7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a     {{{{{{>2400bps..
    3f07:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32     .<OPTION VALUE=2
    3f17:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70      {{{{{{{{>4800bp
    3f27:	73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     s...<OPTION VALU
    3f37:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30     E=3 {{{{{{{{>960
    3f47:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3f57:	41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=4 {{{{{{{{>
    3f67:	31 34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49     14400bps...<OPTI
    3f77:	4f 4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b     ON VALUE=5 {{{{{
    3f87:	7b 7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c     {{{>19200bps...<
    3f97:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b     OPTION VALUE=6 {
    3fa7:	7b 7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73     {{{{{{{>28800bps
    3fb7:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    3fc7:	3d 37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30     =7 {{{{{{{{>3840
    3fd7:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3fe7:	41 4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=8 {{{{{{{{>
    3ff7:	35 37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c     57600bps...</SEL
    4007:	45 43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1     ECT>............
    4017:	f2 e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45     ... ...:...<SELE
    4027:	43 54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e     CT NAME="BitQt">
    4037:	20 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55      ...<OPTION VALU
    4047:	45 3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a     E=0 {{{{{{{{>5..
    4057:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4067:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f      {{{{{{{{>6...<O
    4077:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4087:	7b 7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49     {{{{{{>7...<OPTI
    4097:	4f 4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b     ON VALUE=3 {{{{{
    40a7:	7b 7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{{>8...</SELECT
    40b7:	3e 20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a     > .............:
    40c7:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    40d7:	22 50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50     "Parity"> ...<OP
    40e7:	54 49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b     TION VALUE=0 {{{
    40f7:	7b 7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54     {{{{{>......<OPT
    4107:	49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b     ION VALUE=1 {{{{
    4117:	7b 7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f     {{{{>.........<O
    4127:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4137:	7b 7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d     {{{{{{>.........
    4147:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a     ..</SELECT> ....
    4157:	09 d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53     .....-....:...<S
    4167:	45 4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70     ELECT NAME="Stop
    4177:	42 69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Bits"> ...<OPTIO
    4187:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    4197:	7b 7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     {{>1...<OPTION V
    41a7:	41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=1 {{{{{{{{>
    41b7:	32 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a     2...</SELECT> ..
    41c7:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    41d7:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    41e7:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    41f7:	42 52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1     BR>..<h3>..... .
    4207:	f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42     .......:</h3></B
    4217:	52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     R>..<form action
    4227:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    4237:	27 3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d     '>...<SELECT NAM
    4247:	45 3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a     E="AutoSend"> ..
    4257:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    4267:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    4277:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4287:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c      {{{{{{{{>.....<
    4297:	2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70     /SELECT> ...<inp
    42a7:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    42b7:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    42c7:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    42d7:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    42e7:	47 45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d     GET'>.. ......:.
    42f7:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    4307:	65 78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44     ext' name='CurrD
    4317:	61 74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d     ataPeriod' size=
    4327:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    4337:	27 3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75     '>.........<inpu
    4347:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    4357:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    4367:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42     orm>..</BR>..</B
    4377:	4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00     ODY>..</HTML>...

00004387 <emeter_IField>:
    4387:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
    4397:	00 00 14 04 06 00 00 00 10 3e 02 00 00 03 10 42     .........>.....B
    43a7:	02 00 00 03 10 46 02 00 00 03 10 4a 02 00 00 03     .....F.....J....
    43b7:	1e 29 00 57 45 00 1e 29 00 4d 45 00 1e 29 00 43     .).WE..).ME..).C
    43c7:	45 00 1e 29 00 39 45 00 1e 29 00 2f 45 00 1d 4f     E..).9E..)./E..O
    43d7:	0a 1d 45 00 1d 4f 0a 0b 45 00 1d 4f 0a f9 44 00     ..E..O..E..O..D.
    43e7:	1d 4f 0a e7 44 00 1d 4f 0a d5 44 00 1d 4f 0a c3     .O..D..O..D..O..
    43f7:	44 00 1d 4f 0a b1 44 00 1d 4f 0a 9f 44 00 1d 4f     D..O..D..O..D..O
    4407:	0a 8d 44 00 1d 56 0a 85 44 00 1d 56 0a 7d 44 00     ..D..V..D..V.}D.
    4417:	1d 56 0a 75 44 00 1d 56 0a 6d 44 00 1d fe 05 67     .V.uD..V.mD....g
    4427:	44 00 1d fe 05 61 44 00 1d fe 05 5b 44 00 1d 28     D....aD....[D..(
    4437:	09 57 44 00 1d 28 09 53 44 00 1e 0a 00 65 45 00     .WD..(.SD....eE.
    4447:	1e 0a 00 61 45 00 08 08 00 00 00 00                 ...aE.......

00004453 <STB_2_List>:
    4453:	72 45 69 45                                         rEiE

00004457 <STB_1_List>:
    4457:	69 45 72 45                                         iErE

0000445b <PAR_O_List>:
    445b:	72 45 72 45 69 45                                   rErEiE

00004461 <PAR_E_List>:
    4461:	72 45 69 45 72 45                                   rEiErE

00004467 <PAR_N_List>:
    4467:	69 45 72 45 72 45                                   iErErE

0000446d <BIT8_List>:
    446d:	72 45 72 45 72 45 69 45                             rErErEiE

00004475 <BIT7_List>:
    4475:	72 45 72 45 69 45 72 45                             rErEiErE

0000447d <BIT6_List>:
    447d:	72 45 69 45 72 45 72 45                             rEiErErE

00004485 <BIT5_List>:
    4485:	69 45 72 45 72 45 72 45                             iErErErE

0000448d <BR57600_List>:
    448d:	72 45 72 45 72 45 72 45 72 45 72 45 72 45 72 45     rErErErErErErErE
    449d:	69 45                                               iE

0000449f <BR34800_List>:
    449f:	72 45 72 45 72 45 72 45 72 45 72 45 72 45 69 45     rErErErErErErEiE
    44af:	72 45                                               rE

000044b1 <BR28800_List>:
    44b1:	72 45 72 45 72 45 72 45 72 45 72 45 69 45 72 45     rErErErErErEiErE
    44c1:	72 45                                               rE

000044c3 <BR19200_List>:
    44c3:	72 45 72 45 72 45 72 45 72 45 69 45 72 45 72 45     rErErErErEiErErE
    44d3:	72 45                                               rE

000044d5 <BR14400_List>:
    44d5:	72 45 72 45 72 45 72 45 69 45 72 45 72 45 72 45     rErErErEiErErErE
    44e5:	72 45                                               rE

000044e7 <BR9600_List>:
    44e7:	72 45 72 45 72 45 69 45 72 45 72 45 72 45 72 45     rErErEiErErErErE
    44f7:	72 45                                               rE

000044f9 <BR4800_List>:
    44f9:	72 45 72 45 69 45 72 45 72 45 72 45 72 45 72 45     rErEiErErErErErE
    4509:	72 45                                               rE

0000450b <BR2400_List>:
    450b:	72 45 69 45 72 45 72 45 72 45 72 45 72 45 72 45     rEiErErErErErErE
    451b:	72 45                                               rE

0000451d <BR1200_List>:
    451d:	69 45 72 45 72 45 72 45 72 45 72 45 72 45 72 45     iErErErErErErErE
    452d:	72 45                                               rE

0000452f <ELVIN_MODEM_List>:
    452f:	72 45 72 45 72 45 72 45 69 45                       rErErErEiE

00004539 <MERCURY_230_List>:
    4539:	72 45 72 45 72 45 69 45 72 45                       rErErEiErE

00004543 <ELVIN_List>:
    4543:	72 45 72 45 69 45 72 45 72 45                       rErEiErErE

0000454d <LANDIS_GYR_ZMR110_List>:
    454d:	72 45 69 45 72 45 72 45 72 45                       rEiErErErE

00004557 <EM_NONE_List>:
    4557:	69 45 72 45 72 45 72 45 72 45                       iErErErErE

00004561 <ON_List>:
    4561:	72 45 69 45                                         rEiE

00004565 <OFF_List>:
    4565:	69 45 72 45                                         iErE

00004569 <Selected_Str>:
    4569:	73 65 6c 65 63 74 65 64 00                          selected.

00004572 <Space_Str>:
    4572:	20 20 20 20 20 20 20 20 00                                  .

0000457b <name_emeter>:
    457b:	65 6d 65 74 65 72 2e 68 74 6d 6c 00                 emeter.html.

00004587 <Web_index>:
    4587:	ba 48 7e 48 00 00 00 00 ea 02 94 45 00              .H~H.......E.

00004594 <index_page>:
    4594:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    45a4:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    45b4:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    45c4:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    45d4:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    45e4:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    45f4:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4604:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    4614:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    4624:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    4634:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    4644:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    4654:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    4664:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    4674:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4684:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4694:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    46a4:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    46b4:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    46c4:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    46d4:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    46e4:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    46f4:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    4704:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    4714:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    4724:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    4734:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    4744:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    4754:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    4764:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    4774:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    4784:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    4794:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    47a4:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    47b4:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    47c4:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    47d4:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    47e4:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    47f4:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    4804:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 68 33     {{{{ ....*...<h3
    4814:	3e d3 f0 ee e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0     >....... .......
    4824:	3a 3c 2f 68 33 3e 0d 0a 20 7b 7b 20 28 30 2d 33     :</h3>.. {{ (0-3
    4834:	31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e cd e0 f0     1)</BR>..<h3>...
    4844:	e0 e1 ee f2 ea e0 20 3a 3c 2f 68 33 3e 0d 0a 7b     ...... :</h3>..{
    4854:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a     {{{{{{{{{{ .....
    4864:	3c 2f 42 52 3e 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     </BR>..</BODY>..
    4874:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

0000487e <index_IField>:
    487e:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 0a 0b 00     ".....".........
    488e:	00 00 14 04 06 00 00 00 10 3e 02 00 00 03 10 42     .........>.....B
    489e:	02 00 00 03 10 46 02 00 00 03 10 4a 02 00 00 03     .....F.....J....
    48ae:	00 17 06 00 00 00 10 47 09 00 00 02                 .......G....

000048ba <name_index>:
    48ba:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

000048c5 <Web_login>:
    48c5:	d4 4b ec 4a 08 00 d2 48 e3 01 09 49 00              .K.J...H...I.

000048d2 <vars_loginOField>:
    48d2:	03 49 f3 48 ea 48 da 48                             .I.H.H.H

000048da <Web_PasswOF>:
    48da:	21 e7 05 00 00 00 00 02 00 00 00 7f 29 00 00 0b     !...........)...

000048ea <vars_Passw>:
    48ea:	70 61 73 73 77 6f 72 64 00                          password.

000048f3 <Web_LoginOF>:
    48f3:	21 db 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !...............

00004903 <vars_Login>:
    4903:	6c 6f 67 69 6e 00                                   login.

00004909 <login_page>:
    4909:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4919:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4929:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4939:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    4949:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    4959:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    4969:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4979:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    4989:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
    4999:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
    49a9:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49b9:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49c9:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49d9:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
    49e9:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
    49f9:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
    4a09:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    4a19:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
    4a29:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
    4a39:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
    4a49:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
    4a59:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
    4a69:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
    4a79:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
    4a89:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
    4a99:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
    4aa9:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    4ab9:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    4ac9:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
    4ad9:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
    4ae9:	0d 0a 00                                            ...

00004aec <login_InField>:
    4aec:	22 0f 00 00 00 15 1d fc 05 04 4b 00 07 0a 0b 00     ".........K.....
    4afc:	00 00 14 04 06 00 00 00                             ........

00004b04 <Web_LoginMsg_List>:
    4b04:	a2 4b 70 4b 3e 4b 0c 4b                             .KpK>K.K

00004b0c <Login_PSW_Str>:
    4b0c:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
    4b1c:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
    4b2c:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b3c:	20 00                                                .

00004b3e <Login_Login_Str>:
    4b3e:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
    4b4e:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
    4b5e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b6e:	20 00                                                .

00004b70 <Login_Busy_Str>:
    4b70:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
    4b80:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
    4b90:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
    4ba0:	2e 00                                               ..

00004ba2 <Login_Welcome_Str>:
    4ba2:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
    4bb2:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
    4bc2:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
    4bd2:	20 00                                                .

00004bd4 <name_login>:
    4bd4:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

00004bdf <EM_END_REQ>:
    4bdf:	42 30 03 75                                         B0.u

00004be3 <EM_RESP_NOCARRIER>:
    4be3:	0d 0a 4e 4f 20 43 41 52 52 49 45 52 0d 0a 00        ..NO CARRIER...

00004bf2 <EM_RESP_CONNECT>:
    4bf2:	0d 0a 43 4f 4e 4e 45 43 54 0d 0a 00                 ..CONNECT...

00004bfe <EM_RESP_RING>:
    4bfe:	0d 0a 52 49 4e 47 0d 0a 00                          ..RING...

00004c07 <EM_RESP_OK>:
    4c07:	0d 0a 4f 4b 0d 0a 00                                ..OK...

00004c0e <EM_RESP_ATA>:
    4c0e:	41 54 41 0d 00                                      ATA..

00004c13 <EM_RESP_ATH>:
    4c13:	2b 2b 2b 41 54 48 0d 00                             +++ATH..

00004c1b <EM_RESP_ATE0>:
    4c1b:	41 54 45 30 0d 00                                   ATE0..

00004c21 <EM_RESP_ATZ>:
    4c21:	41 54 5a 0d 00                                      ATZ..

00004c26 <EM_RESP_AT>:
    4c26:	41 54 0d 00                                         AT..

00004c2a <EM_ACTIVEPOWER_REQ>:
    4c2a:	00 08 16 00 8f 86                                   ......

00004c30 <EM_CURRENT_REQ>:
    4c30:	00 08 16 21 4f 9e                                   ...!O.

00004c36 <EM_VOLTAGE_REQ>:
    4c36:	00 08 16 11 4f 8a                                   ....O.

00004c3c <EM_ENERGY_REQ>:
    4c3c:	00 05 00 00 10 25                                   .....%

00004c42 <EM_OPEN_CH_REQ>:
    4c42:	00 01 01 01 01 01 01 01 01 77 81                    .........w.

00004c4d <EM_READ_DATA_REQ>:
    4c4d:	06 30 35 30 00                                      .050.

00004c52 <EM_REQ>:
    4c52:	2f 3f 21 00                                         /?!.

00004c56 <EM_RESP_F_F_0>:
    4c56:	46 2e 46 2e 30 00                                   F.F.0.

00004c5c <EM_RESP_0_0_0>:
    4c5c:	30 2e 30 2e 30 00                                   0.0.0.

00004c62 <EM_RESP_C_62_2>:
    4c62:	43 2e 36 32 2e 32 00                                C.62.2.

00004c69 <EM_RESP_C_62_0>:
    4c69:	43 2e 36 32 2e 30 00                                C.62.0.

00004c70 <EM_RESP_C_61_2>:
    4c70:	43 2e 36 31 2e 32 00                                C.61.2.

00004c77 <EM_RESP_C_61_0>:
    4c77:	43 2e 36 31 2e 30 00                                C.61.0.

00004c7e <EM_RESP_C_60_2>:
    4c7e:	43 2e 36 30 2e 32 00                                C.60.2.

00004c85 <EM_RESP_C_60_0>:
    4c85:	43 2e 36 30 2e 30 00                                C.60.0.

00004c8c <EM_RESP_16_7_0>:
    4c8c:	31 36 2e 37 2e 30 00                                16.7.0.

00004c93 <EM_RESP_71_7_0>:
    4c93:	37 31 2e 37 2e 30 00                                71.7.0.

00004c9a <EM_RESP_51_7_0>:
    4c9a:	35 31 2e 37 2e 30 00                                51.7.0.

00004ca1 <EM_RESP_31_7_0>:
    4ca1:	33 31 2e 37 2e 30 00                                31.7.0.

00004ca8 <EM_RESP_72_7_0>:
    4ca8:	37 32 2e 37 2e 30 00                                72.7.0.

00004caf <EM_RESP_52_7_0>:
    4caf:	35 32 2e 37 2e 30 00                                52.7.0.

00004cb6 <EM_RESP_32_7_0>:
    4cb6:	33 32 2e 37 2e 30 00                                32.7.0.

00004cbd <EM_RESP_4_8_0>:
    4cbd:	34 2e 38 2e 30 00                                   4.8.0.

00004cc3 <EM_RESP_3_8_0>:
    4cc3:	33 2e 38 2e 30 00                                   3.8.0.

00004cc9 <EM_RESP_2_8_0>:
    4cc9:	32 2e 38 2e 30 00                                   2.8.0.

00004ccf <EM_RESP_1_8_0>:
    4ccf:	31 2e 38 2e 30 00                                   1.8.0.

00004cd5 <EM_RESP_0_9_1>:
    4cd5:	30 2e 39 2e 31 00                                   0.9.1.

00004cdb <EM_RESP_0_9_2>:
    4cdb:	30 2e 39 2e 32 00                                   0.9.2.

00004ce1 <METHOD_POST>:
    4ce1:	50 4f 53 54 20 2f 00                                POST /.

00004ce8 <METHOD_GET>:
    4ce8:	47 45 54 20 2f 00                                   GET /.

00004cee <Web_error_page>:
	...
    4cf6:	75 00 fb 4c 00                                      u..L.

00004cfb <error_page>:
    4cfb:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    4d0b:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
    4d1b:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
    4d2b:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
    4d3b:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
    4d4b:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
    4d5b:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
    4d6b:	2f 68 31 3e 00                                      /h1>.

00004d70 <SESSID_pstr>:
    4d70:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00004d79 <inputSESSID_Str>:
    4d79:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
    4d89:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
    4d99:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

00004da4 <Connection_Close>:
    4da4:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    4db4:	65 0d 0a 0d 0a 00                                   e.....

00004dba <jpeg_str>:
    4dba:	6a 70 65 67 00                                      jpeg.

00004dbf <gif_str>:
    4dbf:	67 69 66 00                                         gif.

00004dc3 <ico_str>:
    4dc3:	69 63 6f 00                                         ico.

00004dc7 <html_str>:
    4dc7:	68 74 6d 6c 00                                      html.

00004dcc <image_str>:
    4dcc:	69 6d 61 67 65 2f 00                                image/.

00004dd3 <html_cp1251_str>:
    4dd3:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
    4de3:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
    4df3:	0a 00                                               ..

00004df5 <Content_Length>:
    4df5:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    4e05:	3a 20 00                                            : .

00004e08 <Content_Type>:
    4e08:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

00004e17 <HTTP_200_OK>:
    4e17:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    4e27:	0a 00                                               ..

00004e29 <MsgErr41>:
    4e29:	29                                                  )

00004e2a <TestMsg_str>:
    4e2a:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
    4e3a:	e8 e5 00                                            ...

00004e3d <MB_Master_List>:
    4e3d:	00 00 00                                            ...

00004e40 <DO_M>:
    4e40:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004e4f <DI_M>:
    4e4f:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4e5f:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004e6f <AT_ATH>:
    4e6f:	41 54 48 00                                         ATH.

00004e73 <AT_ATA>:
    4e73:	41 54 41 00                                         ATA.

00004e77 <AT_CSQ>:
    4e77:	41 54 2b 43 53 51 00                                AT+CSQ.

00004e7e <AT_CGATT_0>:
    4e7e:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

00004e89 <AT_CIPSHUT>:
    4e89:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

00004e94 <AT_CIPCLOSE>:
    4e94:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00004ea2 <AT_CIPCLOSE_1>:
    4ea2:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00004eb2 <AT_CIPSEND>:
    4eb2:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00004ebe <AT_SERVERCLOSE>:
    4ebe:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00004ecd <AT_CIPSERVER>:
    4ecd:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00004edd <AT_CIPSTART>:
    4edd:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
    4eed:	44 50 22 2c 00                                      DP",.

00004ef2 <AT_CIFSR>:
    4ef2:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00004efb <AT_CIICR>:
    4efb:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00004f04 <AT_CSTT>:
    4f04:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00004f0c <AT_CIPCSGP>:
    4f0c:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00004f1b <AT_CGATT>:
    4f1b:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00004f26 <AT_CIPMUX_1>:
    4f26:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

00004f32 <AT_CIPMUX_0>:
    4f32:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00004f3e <AT_CIPMODE_1>:
    4f3e:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00004f4b <AT_CIPMODE_0>:
    4f4b:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

00004f58 <AT_CMGS>:
    4f58:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

00004f63 <AT_CSMP>:
    4f63:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
    4f73:	2c 30 00                                            ,0.

00004f76 <AT_CMGF>:
    4f76:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

00004f80 <AT_CCID>:
    4f80:	41 54 2b 43 43 49 44 00                             AT+CCID.

00004f88 <AT_CLIP>:
    4f88:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00004f92 <AT_CGMM>:
    4f92:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00004f9a <AT_E0>:
    4f9a:	41 54 45 30 00                                      ATE0.

00004f9f <AT_W>:
    4f9f:	41 54 26 57 00                                      AT&W.

00004fa4 <AT_IPR9600>:
    4fa4:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00004fb0 <AT_AT>:
    4fb0:	41 54 00                                            AT.

00004fb3 <ESC_SEQ>:
    4fb3:	2b 2b 2b 00                                         +++.

00004fb7 <RESP_CONNECT_9600>:
    4fb7:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00004fc4 <RESP_SHUT_OK>:
    4fc4:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00004fcc <RESP_CSQ>:
    4fcc:	2b 43 53 51 3a 00                                   +CSQ:.

00004fd2 <RESP_CLOSE_OK_FAST>:
    4fd2:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00004fde <RESP_CLOSE_OK>:
    4fde:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00004fe7 <RESP_SEND_OK>:
    4fe7:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00004ff2 <RESP_SERVER_CLOSE>:
    4ff2:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00004fff <RESP_SERVER_OK>:
    4fff:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00005009 <RESP_CONNECT_OK>:
    5009:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00005017 <RESP_OK>:
    5017:	4f 4b 00                                            OK.

0000501a <URC_NO_CARRIER>:
    501a:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00005025 <URC_RING>:
    5025:	52 49 4e 47 00                                      RING.

0000502a <URC_PDPDEACT>:
    502a:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

00005035 <URC_CLOSED>:
    5035:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

0000503e <URC_RECEIVE>:
    503e:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

00005048 <URC_CONNECT>:
    5048:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00005050 <URC_REMOTE_IP>:
    5050:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

0000505a <URC_SMS_READY>:
    505a:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00005064 <URC_CALL_READY>:
    5064:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

0000506f <URC_RDY>:
    506f:	52 44 59 00                                         RDY.

00005073 <GSM_SIMCOM_SIM800>:
    5073:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00005081 <GSM_SIMCOM_SIM900R>:
    5081:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00005090 <MB_Timer>:
    5090:	52 00 51 00 aa 28 44 00 43 00 b0 28                 R.Q..(D.C..(

0000509c <MB_Port>:
    509c:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 a2 28 a7 28     .............(.(
    50ac:	a8 28 a9 28                                         .(.(

000050b0 <BR_Tbl>:
    50b0:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
    50c0:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

000050cb <Modbus_Map>:
    50cb:	d7 03 08 00 ee 03 08 00 6e 08 26 00 5c 0a 1e 00     ........n.&.\...

000050db <MB_Role>:
	...

000050dc <__c.2299>:
    50dc:	63 64 69 6e 6f 70 73 75 78 58 5b 00                 cdinopsuxX[.

000050e8 <__ctors_end>:
    50e8:	11 24       	eor	r1, r1
    50ea:	1f be       	out	0x3f, r1	; 63
    50ec:	cf ef       	ldi	r28, 0xFF	; 255
    50ee:	d0 e1       	ldi	r29, 0x10	; 16
    50f0:	de bf       	out	0x3e, r29	; 62
    50f2:	cd bf       	out	0x3d, r28	; 61

000050f4 <__do_copy_data>:
    50f4:	12 e0       	ldi	r17, 0x02	; 2
    50f6:	a0 e0       	ldi	r26, 0x00	; 0
    50f8:	b1 e0       	ldi	r27, 0x01	; 1
    50fa:	e0 ef       	ldi	r30, 0xF0	; 240
    50fc:	f2 e0       	ldi	r31, 0x02	; 2
    50fe:	01 e0       	ldi	r16, 0x01	; 1
    5100:	0b bf       	out	0x3b, r16	; 59
    5102:	02 c0       	rjmp	.+4      	; 0x5108 <__do_copy_data+0x14>
    5104:	07 90       	elpm	r0, Z+
    5106:	0d 92       	st	X+, r0
    5108:	a0 33       	cpi	r26, 0x30	; 48
    510a:	b1 07       	cpc	r27, r17
    510c:	d9 f7       	brne	.-10     	; 0x5104 <__do_copy_data+0x10>

0000510e <__do_clear_bss>:
    510e:	2e e0       	ldi	r18, 0x0E	; 14
    5110:	a0 e3       	ldi	r26, 0x30	; 48
    5112:	b2 e0       	ldi	r27, 0x02	; 2
    5114:	01 c0       	rjmp	.+2      	; 0x5118 <.do_clear_bss_start>

00005116 <.do_clear_bss_loop>:
    5116:	1d 92       	st	X+, r1

00005118 <.do_clear_bss_start>:
    5118:	ae 32       	cpi	r26, 0x2E	; 46
    511a:	b2 07       	cpc	r27, r18
    511c:	e1 f7       	brne	.-8      	; 0x5116 <.do_clear_bss_loop>
    511e:	0e 94 05 77 	call	0xee0a	; 0xee0a <main>
    5122:	0c 94 8e 77 	jmp	0xef1c	; 0xef1c <exit>

00005126 <__bad_interrupt>:
    5126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000512a <rrb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
	return *addr;
}
    512a:	fc 01       	movw	r30, r24
    512c:	80 81       	ld	r24, Z
    512e:	08 95       	ret

00005130 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5130:	fc 01       	movw	r30, r24
    5132:	84 91       	lpm	r24, Z
}
    5134:	08 95       	ret

00005136 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    5136:	a0 e0       	ldi	r26, 0x00	; 0
    5138:	b0 e0       	ldi	r27, 0x00	; 0
    513a:	11 96       	adiw	r26, 0x01	; 1
}
    513c:	ab bf       	out	0x3b, r26	; 59
    513e:	fc 01       	movw	r30, r24
    5140:	87 91       	elpm	r24, Z+
    5142:	08 95       	ret

00005144 <RS485_1>:
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
}

void RS485_0(void) {}
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5144:	82 b3       	in	r24, 0x12	; 18
    5146:	90 e1       	ldi	r25, 0x10	; 16
    5148:	89 27       	eor	r24, r25
    514a:	82 bb       	out	0x12, r24	; 18
    514c:	08 95       	ret

0000514e <MB_LED1>:

void MB_LED0(void) {}
void MB_LED1(void) {}
    514e:	08 95       	ret

00005150 <MB_LED_Err_On_1>:

void MB_LED_Err_On_0(void)	{}
void MB_LED_Err_Off_0(void)	{}
void MB_LED_Err_On_1(void)	{}
    5150:	08 95       	ret

00005152 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    5152:	08 95       	ret

00005154 <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    5154:	8f e0       	ldi	r24, 0x0F	; 15
    5156:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    5158:	87 b7       	in	r24, 0x37	; 55
    515a:	82 60       	ori	r24, 0x02	; 2
    515c:	87 bf       	out	0x37, r24	; 55
    515e:	08 95       	ret

00005160 <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    5160:	8d e0       	ldi	r24, 0x0D	; 13
    5162:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    5164:	87 b7       	in	r24, 0x37	; 55
    5166:	80 68       	ori	r24, 0x80	; 128
    5168:	87 bf       	out	0x37, r24	; 55
    516a:	08 95       	ret

0000516c <MB_Timer_ISR>:
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    516c:	60 e0       	ldi	r22, 0x00	; 0
    516e:	76 e0       	ldi	r23, 0x06	; 6
    5170:	26 2f       	mov	r18, r22
    5172:	30 e0       	ldi	r19, 0x00	; 0
    5174:	72 9f       	mul	r23, r18
    5176:	f0 01       	movw	r30, r0
    5178:	73 9f       	mul	r23, r19
    517a:	f0 0d       	add	r31, r0
    517c:	11 24       	eor	r1, r1
    517e:	e0 57       	subi	r30, 0x70	; 112
    5180:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5182:	45 91       	lpm	r20, Z+
    5184:	54 91       	lpm	r21, Z
    5186:	e6 2f       	mov	r30, r22
    5188:	f0 e0       	ldi	r31, 0x00	; 0
    518a:	84 17       	cp	r24, r20
    518c:	95 07       	cpc	r25, r21
    518e:	11 f0       	breq	.+4      	; 0x5194 <MB_Timer_ISR+0x28>
    5190:	6f 5f       	subi	r22, 0xFF	; 255
    5192:	ee cf       	rjmp	.-36     	; 0x5170 <MB_Timer_ISR+0x4>

	
	switch (prb(MB_Role+MB_N)){
    5194:	e5 52       	subi	r30, 0x25	; 37
    5196:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5198:	e4 91       	lpm	r30, Z
    519a:	ee 23       	and	r30, r30
    519c:	19 f0       	breq	.+6      	; 0x51a4 <MB_Timer_ISR+0x38>
    519e:	e1 30       	cpi	r30, 0x01	; 1
    51a0:	f9 f0       	breq	.+62     	; 0x51e0 <MB_Timer_ISR+0x74>
    51a2:	08 95       	ret
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    51a4:	f2 2f       	mov	r31, r18
    51a6:	ee 27       	eor	r30, r30
    51a8:	e6 5d       	subi	r30, 0xD6	; 214
    51aa:	f2 4f       	sbci	r31, 0xF2	; 242
    51ac:	90 81       	ld	r25, Z
    51ae:	f9 01       	movw	r30, r18
    51b0:	e0 51       	subi	r30, 0x10	; 16
    51b2:	fc 4f       	sbci	r31, 0xFC	; 252
    51b4:	80 81       	ld	r24, Z
    51b6:	98 17       	cp	r25, r24
    51b8:	99 f0       	breq	.+38     	; 0x51e0 <MB_Timer_ISR+0x74>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    51ba:	f9 01       	movw	r30, r18
    51bc:	e7 52       	subi	r30, 0x27	; 39
    51be:	fc 4f       	sbci	r31, 0xFC	; 252
    51c0:	81 e0       	ldi	r24, 0x01	; 1
    51c2:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    51c4:	f9 01       	movw	r30, r18
    51c6:	84 e0       	ldi	r24, 0x04	; 4
    51c8:	ee 0f       	add	r30, r30
    51ca:	ff 1f       	adc	r31, r31
    51cc:	8a 95       	dec	r24
    51ce:	e1 f7       	brne	.-8      	; 0x51c8 <MB_Timer_ISR+0x5c>
    51d0:	e4 5f       	subi	r30, 0xF4	; 244
    51d2:	f4 4f       	sbci	r31, 0xF4	; 244
    51d4:	80 81       	ld	r24, Z
    51d6:	91 81       	ldd	r25, Z+1	; 0x01
    51d8:	01 96       	adiw	r24, 0x01	; 1
    51da:	91 83       	std	Z+1, r25	; 0x01
    51dc:	80 83       	st	Z, r24
    51de:	08 95       	ret
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    51e0:	30 91 f6 0a 	lds	r19, 0x0AF6
    51e4:	81 e0       	ldi	r24, 0x01	; 1
    51e6:	90 e0       	ldi	r25, 0x00	; 0
    51e8:	02 2e       	mov	r0, r18
    51ea:	01 c0       	rjmp	.+2      	; 0x51ee <MB_Timer_ISR+0x82>
    51ec:	88 0f       	add	r24, r24
    51ee:	0a 94       	dec	r0
    51f0:	ea f7       	brpl	.-6      	; 0x51ec <MB_Timer_ISR+0x80>
    51f2:	38 2b       	or	r19, r24
    51f4:	30 93 f6 0a 	sts	0x0AF6, r19
    51f8:	08 95       	ret

000051fa <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    51fa:	28 2f       	mov	r18, r24
    51fc:	30 e0       	ldi	r19, 0x00	; 0
    51fe:	94 e1       	ldi	r25, 0x14	; 20
    5200:	89 9f       	mul	r24, r25
    5202:	f0 01       	movw	r30, r0
    5204:	11 24       	eor	r1, r1
    5206:	e2 56       	subi	r30, 0x62	; 98
    5208:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    520a:	a5 91       	lpm	r26, Z+
    520c:	b4 91       	lpm	r27, Z
    520e:	9c 91       	ld	r25, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5210:	f9 01       	movw	r30, r18
    5212:	e1 54       	subi	r30, 0x41	; 65
    5214:	f7 4f       	sbci	r31, 0xF7	; 247
    5216:	40 81       	ld	r20, Z
    5218:	51 e0       	ldi	r21, 0x01	; 1
    521a:	54 0f       	add	r21, r20
    521c:	50 83       	st	Z, r21
    521e:	54 e1       	ldi	r21, 0x14	; 20
    5220:	52 9f       	mul	r21, r18
    5222:	f0 01       	movw	r30, r0
    5224:	53 9f       	mul	r21, r19
    5226:	f0 0d       	add	r31, r0
    5228:	11 24       	eor	r1, r1
    522a:	e4 56       	subi	r30, 0x64	; 100
    522c:	ff 4a       	sbci	r31, 0xAF	; 175
    522e:	a5 91       	lpm	r26, Z+
    5230:	b4 91       	lpm	r27, Z
    5232:	5c 91       	ld	r21, X
    5234:	f2 2f       	mov	r31, r18
    5236:	ee 27       	eor	r30, r30
    5238:	e4 0f       	add	r30, r20
    523a:	f1 1d       	adc	r31, r1
    523c:	e6 5d       	subi	r30, 0xD6	; 214
    523e:	f2 4f       	sbci	r31, 0xF2	; 242
    5240:	50 83       	st	Z, r21
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5242:	93 ff       	sbrs	r25, 3
    5244:	0e c0       	rjmp	.+28     	; 0x5262 <MBRecept+0x68>
		MB_CPT[MB_N][7]++;
    5246:	f9 01       	movw	r30, r18
    5248:	24 e0       	ldi	r18, 0x04	; 4
    524a:	ee 0f       	add	r30, r30
    524c:	ff 1f       	adc	r31, r31
    524e:	2a 95       	dec	r18
    5250:	e1 f7       	brne	.-8      	; 0x524a <MBRecept+0x50>
    5252:	e4 5f       	subi	r30, 0xF4	; 244
    5254:	f4 4f       	sbci	r31, 0xF4	; 244
    5256:	26 85       	ldd	r18, Z+14	; 0x0e
    5258:	37 85       	ldd	r19, Z+15	; 0x0f
    525a:	2f 5f       	subi	r18, 0xFF	; 255
    525c:	3f 4f       	sbci	r19, 0xFF	; 255
    525e:	37 87       	std	Z+15, r19	; 0x0f
    5260:	26 87       	std	Z+14, r18	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5262:	9c 71       	andi	r25, 0x1C	; 28
    5264:	59 f0       	breq	.+22     	; 0x527c <MBRecept+0x82>
		MB_Err |=(1<<MB_N);
    5266:	21 e0       	ldi	r18, 0x01	; 1
    5268:	30 e0       	ldi	r19, 0x00	; 0
    526a:	01 c0       	rjmp	.+2      	; 0x526e <MBRecept+0x74>
    526c:	22 0f       	add	r18, r18
    526e:	8a 95       	dec	r24
    5270:	ea f7       	brpl	.-6      	; 0x526c <MBRecept+0x72>
    5272:	80 91 63 02 	lds	r24, 0x0263
    5276:	82 2b       	or	r24, r18
    5278:	80 93 63 02 	sts	0x0263, r24
    527c:	08 95       	ret

0000527e <GetSlave>:

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    527e:	43 e0       	ldi	r20, 0x03	; 3
    5280:	84 9f       	mul	r24, r20
    5282:	f0 01       	movw	r30, r0
    5284:	11 24       	eor	r1, r1
    5286:	e3 5c       	subi	r30, 0xC3	; 195
    5288:	f1 4b       	sbci	r31, 0xB1	; 177
    528a:	25 91       	lpm	r18, Z+
    528c:	34 91       	lpm	r19, Z
    528e:	e8 2f       	mov	r30, r24
    5290:	f0 e0       	ldi	r31, 0x00	; 0
    5292:	e7 50       	subi	r30, 0x07	; 7
    5294:	fa 4f       	sbci	r31, 0xFA	; 250
    5296:	80 81       	ld	r24, Z
}
    5298:	a9 01       	movw	r20, r18
    529a:	64 e0       	ldi	r22, 0x04	; 4
    529c:	86 9f       	mul	r24, r22
    529e:	40 0d       	add	r20, r0
    52a0:	51 1d       	adc	r21, r1
    52a2:	11 24       	eor	r1, r1
    52a4:	ca 01       	movw	r24, r20
    52a6:	08 95       	ret

000052a8 <DI_Init_Hard>:
static T_DI_M DI_M[] PROGMEM = DI_Map_Own;

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
    52a8:	8f e4       	ldi	r24, 0x4F	; 79
    52aa:	9e e4       	ldi	r25, 0x4E	; 78
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    52ac:	f8 94       	cli
    52ae:	fc 01       	movw	r30, r24
    52b0:	a5 91       	lpm	r26, Z+
    52b2:	b4 91       	lpm	r27, Z
    52b4:	ac 01       	movw	r20, r24
    52b6:	4a 5f       	subi	r20, 0xFA	; 250
    52b8:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52ba:	fa 01       	movw	r30, r20
    52bc:	34 91       	lpm	r19, Z
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    52be:	30 95       	com	r19
    52c0:	2c 91       	ld	r18, X
    52c2:	23 23       	and	r18, r19
    52c4:	2c 93       	st	X, r18
    52c6:	9c 01       	movw	r18, r24
    52c8:	2e 5f       	subi	r18, 0xFE	; 254
    52ca:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    52cc:	f9 01       	movw	r30, r18
    52ce:	a5 91       	lpm	r26, Z+
    52d0:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52d2:	fa 01       	movw	r30, r20
    52d4:	44 91       	lpm	r20, Z
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    52d6:	2c 91       	ld	r18, X
    52d8:	24 2b       	or	r18, r20
    52da:	2c 93       	st	X, r18
		sei();
    52dc:	78 94       	sei
    52de:	08 96       	adiw	r24, 0x08	; 8

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    52e0:	fe e4       	ldi	r31, 0x4E	; 78
    52e2:	8f 36       	cpi	r24, 0x6F	; 111
    52e4:	9f 07       	cpc	r25, r31
    52e6:	11 f7       	brne	.-60     	; 0x52ac <DI_Init_Hard+0x4>
		cli();
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
		sei();
	}
}
    52e8:	08 95       	ret

000052ea <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    52ea:	f8 94       	cli
    52ec:	ff cf       	rjmp	.-2      	; 0x52ec <Reboot+0x2>

000052ee <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    52ee:	8f e4       	ldi	r24, 0x4F	; 79
    52f0:	80 93 19 06 	sts	0x0619, r24
    52f4:	08 95       	ret

000052f6 <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    52f6:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    52f8:	e0 e0       	ldi	r30, 0x00	; 0
    52fa:	ff ef       	ldi	r31, 0xFF	; 255
    52fc:	09 94       	ijmp

000052fe <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    52fe:	81 e0       	ldi	r24, 0x01	; 1
    5300:	80 93 2c 08 	sts	0x082C, r24
    5304:	08 95       	ret

00005306 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5306:	0c 94 37 7f 	jmp	0xfe6e	; 0xfe6e <__eerd_byte_m128>

0000530a <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    530a:	0f 93       	push	r16
    530c:	1f 93       	push	r17
    530e:	cf 93       	push	r28
    5310:	df 93       	push	r29
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5312:	c8 2f       	mov	r28, r24
    5314:	d0 e0       	ldi	r29, 0x00	; 0
    5316:	fe 01       	movw	r30, r28
    5318:	ec 5e       	subi	r30, 0xEC	; 236
    531a:	f9 4f       	sbci	r31, 0xF9	; 249
    531c:	90 81       	ld	r25, Z
    531e:	92 30       	cpi	r25, 0x02	; 2
    5320:	09 f1       	breq	.+66     	; 0x5364 <GetReg+0x5a>
    5322:	fe 01       	movw	r30, r28
    5324:	a4 e0       	ldi	r26, 0x04	; 4
    5326:	ee 0f       	add	r30, r30
    5328:	ff 1f       	adc	r31, r31
    532a:	aa 95       	dec	r26
    532c:	e1 f7       	brne	.-8      	; 0x5326 <GetReg+0x1c>
    532e:	ed 52       	subi	r30, 0x2D	; 45
    5330:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5332:	05 91       	lpm	r16, Z+
    5334:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    5336:	0e 94 3f 29 	call	0x527e	; 0x527e <GetSlave>
    533a:	01 96       	adiw	r24, 0x01	; 1
    533c:	fc 01       	movw	r30, r24
    533e:	85 91       	lpm	r24, Z+
    5340:	94 91       	lpm	r25, Z
    5342:	c1 50       	subi	r28, 0x01	; 1
    5344:	da 4f       	sbci	r29, 0xFA	; 250
    5346:	28 81       	ld	r18, Y
    5348:	fc 01       	movw	r30, r24
    534a:	37 e0       	ldi	r19, 0x07	; 7
    534c:	23 9f       	mul	r18, r19
    534e:	e0 0d       	add	r30, r0
    5350:	f1 1d       	adc	r31, r1
    5352:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5354:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5356:	85 91       	lpm	r24, Z+
    5358:	94 91       	lpm	r25, Z
    535a:	88 0f       	add	r24, r24
    535c:	99 1f       	adc	r25, r25
    535e:	80 0f       	add	r24, r16
    5360:	91 1f       	adc	r25, r17
    5362:	09 c0       	rjmp	.+18     	; 0x5376 <GetReg+0x6c>
    5364:	73 e0       	ldi	r23, 0x03	; 3
    5366:	cc 0f       	add	r28, r28
    5368:	dd 1f       	adc	r29, r29
    536a:	7a 95       	dec	r23
    536c:	e1 f7       	brne	.-8      	; 0x5366 <GetReg+0x5c>
    536e:	c5 5a       	subi	r28, 0xA5	; 165
    5370:	dd 4f       	sbci	r29, 0xFD	; 253
    5372:	8e 81       	ldd	r24, Y+6	; 0x06
    5374:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5376:	df 91       	pop	r29
    5378:	cf 91       	pop	r28
    537a:	1f 91       	pop	r17
    537c:	0f 91       	pop	r16
    537e:	08 95       	ret

00005380 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    5380:	fc 01       	movw	r30, r24
    5382:	65 91       	lpm	r22, Z+
    5384:	75 91       	lpm	r23, Z+
    5386:	85 91       	lpm	r24, Z+
    5388:	94 91       	lpm	r25, Z
}
    538a:	08 95       	ret

0000538c <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    538c:	8f 92       	push	r8
    538e:	9f 92       	push	r9
    5390:	af 92       	push	r10
    5392:	bf 92       	push	r11
    5394:	cf 92       	push	r12
    5396:	df 92       	push	r13
    5398:	ef 92       	push	r14
    539a:	ff 92       	push	r15
    539c:	0f 93       	push	r16
    539e:	1f 93       	push	r17
    53a0:	cf 93       	push	r28
    53a2:	df 93       	push	r29
    53a4:	00 d0       	rcall	.+0      	; 0x53a6 <CRC_Seed+0x1a>
    53a6:	00 d0       	rcall	.+0      	; 0x53a8 <CRC_Seed+0x1c>
    53a8:	cd b7       	in	r28, 0x3d	; 61
    53aa:	de b7       	in	r29, 0x3e	; 62
    53ac:	4c 01       	movw	r8, r24
    53ae:	5b 01       	movw	r10, r22
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    53b0:	c1 2c       	mov	r12, r1
    53b2:	d1 2c       	mov	r13, r1
    53b4:	76 01       	movw	r14, r12
    53b6:	c2 16       	cp	r12, r18
    53b8:	d3 06       	cpc	r13, r19
    53ba:	e4 06       	cpc	r14, r20
    53bc:	f5 06       	cpc	r15, r21
    53be:	f9 f0       	breq	.+62     	; 0x53fe <CRC_Seed+0x72>
    53c0:	c5 01       	movw	r24, r10
    53c2:	8c 0d       	add	r24, r12
    53c4:	9d 1d       	adc	r25, r13
		uint8_t j = CRCLo^GetByte(Block+i);
    53c6:	29 83       	std	Y+1, r18	; 0x01
    53c8:	3a 83       	std	Y+2, r19	; 0x02
    53ca:	4b 83       	std	Y+3, r20	; 0x03
    53cc:	5c 83       	std	Y+4, r21	; 0x04
    53ce:	f4 01       	movw	r30, r8
    53d0:	09 95       	icall
    53d2:	80 27       	eor	r24, r16
		CRCLo = CRCHi^prb(aCRCHi+j);
    53d4:	68 2f       	mov	r22, r24
    53d6:	70 e0       	ldi	r23, 0x00	; 0
    53d8:	fb 01       	movw	r30, r22
    53da:	ee 54       	subi	r30, 0x4E	; 78
    53dc:	fb 4f       	sbci	r31, 0xFB	; 251

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    53de:	04 91       	lpm	r16, Z
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    53e0:	01 27       	eor	r16, r17
		CRCHi = prb(aCRCLo+j);
    53e2:	fb 01       	movw	r30, r22
    53e4:	ee 54       	subi	r30, 0x4E	; 78
    53e6:	fc 4f       	sbci	r31, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    53e8:	14 91       	lpm	r17, Z
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    53ea:	ff ef       	ldi	r31, 0xFF	; 255
    53ec:	cf 1a       	sub	r12, r31
    53ee:	df 0a       	sbc	r13, r31
    53f0:	ef 0a       	sbc	r14, r31
    53f2:	ff 0a       	sbc	r15, r31
    53f4:	5c 81       	ldd	r21, Y+4	; 0x04
    53f6:	4b 81       	ldd	r20, Y+3	; 0x03
    53f8:	3a 81       	ldd	r19, Y+2	; 0x02
    53fa:	29 81       	ldd	r18, Y+1	; 0x01
    53fc:	dc cf       	rjmp	.-72     	; 0x53b6 <CRC_Seed+0x2a>
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
    53fe:	80 2f       	mov	r24, r16
    5400:	90 e0       	ldi	r25, 0x00	; 0
}
    5402:	91 2b       	or	r25, r17
    5404:	0f 90       	pop	r0
    5406:	0f 90       	pop	r0
    5408:	0f 90       	pop	r0
    540a:	0f 90       	pop	r0
    540c:	df 91       	pop	r29
    540e:	cf 91       	pop	r28
    5410:	1f 91       	pop	r17
    5412:	0f 91       	pop	r16
    5414:	ff 90       	pop	r15
    5416:	ef 90       	pop	r14
    5418:	df 90       	pop	r13
    541a:	cf 90       	pop	r12
    541c:	bf 90       	pop	r11
    541e:	af 90       	pop	r10
    5420:	9f 90       	pop	r9
    5422:	8f 90       	pop	r8
    5424:	08 95       	ret

00005426 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    5426:	0f 93       	push	r16
    5428:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    542a:	0f ef       	ldi	r16, 0xFF	; 255
    542c:	1f ef       	ldi	r17, 0xFF	; 255
    542e:	0e 94 c6 29 	call	0x538c	; 0x538c <CRC_Seed>
}
    5432:	1f 91       	pop	r17
    5434:	0f 91       	pop	r16
    5436:	08 95       	ret

00005438 <CRC_EEPROM_calc>:
}

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    5438:	0f 93       	push	r16
    543a:	1f 93       	push	r17
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
    543c:	2f e8       	ldi	r18, 0x8F	; 143
    543e:	31 e0       	ldi	r19, 0x01	; 1
// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
    5440:	40 e0       	ldi	r20, 0x00	; 0
    5442:	50 e0       	ldi	r21, 0x00	; 0
    5444:	60 e0       	ldi	r22, 0x00	; 0
    5446:	70 e0       	ldi	r23, 0x00	; 0
    5448:	83 e8       	ldi	r24, 0x83	; 131
    544a:	99 e2       	ldi	r25, 0x29	; 41
    544c:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
    5450:	2b ef       	ldi	r18, 0xFB	; 251
    5452:	3f e0       	ldi	r19, 0x0F	; 15
    5454:	2f 58       	subi	r18, 0x8F	; 143
    5456:	31 40       	sbci	r19, 0x01	; 1
    5458:	40 e0       	ldi	r20, 0x00	; 0
    545a:	50 e0       	ldi	r21, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
    545c:	8c 01       	movw	r16, r24
    545e:	64 e9       	ldi	r22, 0x94	; 148
    5460:	71 e0       	ldi	r23, 0x01	; 1
    5462:	83 e8       	ldi	r24, 0x83	; 131
    5464:	99 e2       	ldi	r25, 0x29	; 41
    5466:	0e 94 c6 29 	call	0x538c	; 0x538c <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    546a:	1f 91       	pop	r17
    546c:	0f 91       	pop	r16
    546e:	08 95       	ret

00005470 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    5470:	80 91 5b 0a 	lds	r24, 0x0A5B
    5474:	81 fd       	sbrc	r24, 1
    5476:	07 c0       	rjmp	.+14     	; 0x5486 <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5478:	0e 94 1c 2a 	call	0x5438	; 0x5438 <CRC_EEPROM_calc>
    547c:	bc 01       	movw	r22, r24
    547e:	81 e9       	ldi	r24, 0x91	; 145
    5480:	91 e0       	ldi	r25, 0x01	; 1
    5482:	0c 94 6a 7f 	jmp	0xfed4	; 0xfed4 <__eewr_word_m128>
    5486:	08 95       	ret

00005488 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    5488:	0e 94 55 7f 	call	0xfeaa	; 0xfeaa <__eewr_byte_m128>
	CRC_EEPROM_upd();
    548c:	0c 94 38 2a 	jmp	0x5470	; 0x5470 <CRC_EEPROM_upd>

00005490 <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    5490:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    5492:	6f ef       	ldi	r22, 0xFF	; 255
    5494:	8f ef       	ldi	r24, 0xFF	; 255
    5496:	9f e0       	ldi	r25, 0x0F	; 15
    5498:	0e 94 44 2a 	call	0x5488	; 0x5488 <ewb>
    549c:	ff cf       	rjmp	.-2      	; 0x549c <Start_Bootloader+0xc>

0000549e <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    549e:	0e 94 6a 7f 	call	0xfed4	; 0xfed4 <__eewr_word_m128>
	CRC_EEPROM_upd();
    54a2:	0c 94 38 2a 	jmp	0x5470	; 0x5470 <CRC_EEPROM_upd>

000054a6 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    54a6:	0e 94 62 7f 	call	0xfec4	; 0xfec4 <__eewr_dword_m128>
	CRC_EEPROM_upd();
    54aa:	0c 94 38 2a 	jmp	0x5470	; 0x5470 <CRC_EEPROM_upd>

000054ae <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    54ae:	0e 94 4b 7f 	call	0xfe96	; 0xfe96 <__eewr_block_m128>
	CRC_EEPROM_upd();
    54b2:	0c 94 38 2a 	jmp	0x5470	; 0x5470 <CRC_EEPROM_upd>

000054b6 <CRC_Flash_calc>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    54b6:	0f 93       	push	r16
    54b8:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    54ba:	20 e0       	ldi	r18, 0x00	; 0
    54bc:	30 e0       	ldi	r19, 0x00	; 0
    54be:	41 e0       	ldi	r20, 0x01	; 1
    54c0:	50 e0       	ldi	r21, 0x00	; 0
    54c2:	60 e0       	ldi	r22, 0x00	; 0
    54c4:	70 e0       	ldi	r23, 0x00	; 0
    54c6:	88 e9       	ldi	r24, 0x98	; 152
    54c8:	98 e2       	ldi	r25, 0x28	; 40
    54ca:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
    54ce:	8c 01       	movw	r16, r24
    54d0:	20 e0       	ldi	r18, 0x00	; 0
    54d2:	30 e0       	ldi	r19, 0x00	; 0
    54d4:	41 e0       	ldi	r20, 0x01	; 1
    54d6:	50 e0       	ldi	r21, 0x00	; 0
    54d8:	60 e0       	ldi	r22, 0x00	; 0
    54da:	70 e0       	ldi	r23, 0x00	; 0
    54dc:	8b e9       	ldi	r24, 0x9B	; 155
    54de:	98 e2       	ldi	r25, 0x28	; 40
    54e0:	0e 94 c6 29 	call	0x538c	; 0x538c <CRC_Seed>
	#endif
}
    54e4:	1f 91       	pop	r17
    54e6:	0f 91       	pop	r16
    54e8:	08 95       	ret

000054ea <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    54ea:	83 e9       	ldi	r24, 0x93	; 147
    54ec:	91 e0       	ldi	r25, 0x01	; 1
    54ee:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    54f2:	81 11       	cpse	r24, r1
    54f4:	13 c0       	rjmp	.+38     	; 0x551c <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    54f6:	0e 94 5b 2a 	call	0x54b6	; 0x54b6 <CRC_Flash_calc>
    54fa:	bc 01       	movw	r22, r24
    54fc:	8f e8       	ldi	r24, 0x8F	; 143
    54fe:	91 e0       	ldi	r25, 0x01	; 1
    5500:	0e 94 6a 7f 	call	0xfed4	; 0xfed4 <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5504:	0e 94 1c 2a 	call	0x5438	; 0x5438 <CRC_EEPROM_calc>
    5508:	bc 01       	movw	r22, r24
    550a:	81 e9       	ldi	r24, 0x91	; 145
    550c:	91 e0       	ldi	r25, 0x01	; 1
    550e:	0e 94 6a 7f 	call	0xfed4	; 0xfed4 <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    5512:	61 e0       	ldi	r22, 0x01	; 1
    5514:	83 e9       	ldi	r24, 0x93	; 147
    5516:	91 e0       	ldi	r25, 0x01	; 1
    5518:	0c 94 55 7f 	jmp	0xfeaa	; 0xfeaa <__eewr_byte_m128>
    551c:	08 95       	ret

0000551e <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    551e:	8f b7       	in	r24, 0x3f	; 63
    5520:	80 78       	andi	r24, 0x80	; 128
    5522:	80 93 d6 03 	sts	0x03D6, r24
	cli();
    5526:	f8 94       	cli
	return interru_enub_flg;
}
    5528:	80 91 d6 03 	lds	r24, 0x03D6
    552c:	08 95       	ret

0000552e <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    552e:	80 91 d6 03 	lds	r24, 0x03D6
    5532:	88 23       	and	r24, r24
    5534:	09 f0       	breq	.+2      	; 0x5538 <IntOn+0xa>
		sei();
    5536:	78 94       	sei
	return interru_enub_flg;
}
    5538:	80 91 d6 03 	lds	r24, 0x03D6
    553c:	08 95       	ret

0000553e <Modbus_ReadHoldReg>:
	eww(&TCP_ListenPort, MBHoldReg1[36]);
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
}

void Modbus_ReadHoldReg(void){
	IntOff();
    553e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5542:	87 e2       	ldi	r24, 0x27	; 39
    5544:	90 e0       	ldi	r25, 0x00	; 0
    5546:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	MBHoldReg1[0] = erw(&EM_UART_Param);
    554a:	90 93 6f 08 	sts	0x086F, r25
    554e:	80 93 6e 08 	sts	0x086E, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    5552:	4e e1       	ldi	r20, 0x1E	; 30
    5554:	50 e0       	ldi	r21, 0x00	; 0
    5556:	62 e6       	ldi	r22, 0x62	; 98
    5558:	71 e0       	ldi	r23, 0x01	; 1
    555a:	80 e7       	ldi	r24, 0x70	; 112
    555c:	98 e0       	ldi	r25, 0x08	; 8
    555e:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    5562:	44 e1       	ldi	r20, 0x14	; 20
    5564:	50 e0       	ldi	r21, 0x00	; 0
    5566:	6e e4       	ldi	r22, 0x4E	; 78
    5568:	71 e0       	ldi	r23, 0x01	; 1
    556a:	8e e8       	ldi	r24, 0x8E	; 142
    556c:	98 e0       	ldi	r25, 0x08	; 8
    556e:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    5572:	44 e1       	ldi	r20, 0x14	; 20
    5574:	50 e0       	ldi	r21, 0x00	; 0
    5576:	6a e3       	ldi	r22, 0x3A	; 58
    5578:	71 e0       	ldi	r23, 0x01	; 1
    557a:	82 ea       	ldi	r24, 0xA2	; 162
    557c:	98 e0       	ldi	r25, 0x08	; 8
    557e:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5582:	80 e2       	ldi	r24, 0x20	; 32
    5584:	91 e0       	ldi	r25, 0x01	; 1
    5586:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    558a:	90 93 b7 08 	sts	0x08B7, r25
    558e:	80 93 b6 08 	sts	0x08B6, r24
    5592:	8e e0       	ldi	r24, 0x0E	; 14
    5594:	91 e0       	ldi	r25, 0x01	; 1
    5596:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    559a:	90 93 b9 08 	sts	0x08B9, r25
    559e:	80 93 b8 08 	sts	0x08B8, r24
	IntOn();
    55a2:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

000055a6 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    55a6:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    55a8:	2f e0       	ldi	r18, 0x0F	; 15
    55aa:	88 e1       	ldi	r24, 0x18	; 24
    55ac:	90 e0       	ldi	r25, 0x00	; 0
    55ae:	0f b6       	in	r0, 0x3f	; 63
    55b0:	f8 94       	cli
    55b2:	a8 95       	wdr
    55b4:	81 bd       	out	0x21, r24	; 33
    55b6:	0f be       	out	0x3f, r0	; 63
    55b8:	21 bd       	out	0x21, r18	; 33
    55ba:	08 95       	ret

000055bc <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    55bc:	80 91 0d 01 	lds	r24, 0x010D
	VacantTimer16++;
    55c0:	91 e0       	ldi	r25, 0x01	; 1
    55c2:	98 0f       	add	r25, r24
    55c4:	90 93 0d 01 	sts	0x010D, r25
	return N;
}
    55c8:	08 95       	ret

000055ca <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    55ca:	80 91 0c 01 	lds	r24, 0x010C
	VacantTimer32++;
    55ce:	91 e0       	ldi	r25, 0x01	; 1
    55d0:	98 0f       	add	r25, r24
    55d2:	90 93 0c 01 	sts	0x010C, r25
	return N;
}
    55d6:	08 95       	ret

000055d8 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    55d8:	1f 93       	push	r17
    55da:	cf 93       	push	r28
    55dc:	df 93       	push	r29
    55de:	1f 92       	push	r1
    55e0:	cd b7       	in	r28, 0x3d	; 61
    55e2:	de b7       	in	r29, 0x3e	; 62
    55e4:	18 2f       	mov	r17, r24
	IntOff();
    55e6:	69 83       	std	Y+1, r22	; 0x01
    55e8:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	if ((Timer8[TimerN]=Timeout)>0)
    55ec:	e1 2f       	mov	r30, r17
    55ee:	f0 e0       	ldi	r31, 0x00	; 0
    55f0:	e2 56       	subi	r30, 0x62	; 98
    55f2:	fc 4f       	sbci	r31, 0xFC	; 252
    55f4:	69 81       	ldd	r22, Y+1	; 0x01
    55f6:	60 83       	st	Z, r22
    55f8:	e1 2f       	mov	r30, r17
    55fa:	e6 95       	lsr	r30
    55fc:	e6 95       	lsr	r30
    55fe:	e6 95       	lsr	r30
    5600:	17 70       	andi	r17, 0x07	; 7
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5602:	f0 e0       	ldi	r31, 0x00	; 0
    5604:	eb 58       	subi	r30, 0x8B	; 139
    5606:	fd 4f       	sbci	r31, 0xFD	; 253
    5608:	80 81       	ld	r24, Z
    560a:	21 e0       	ldi	r18, 0x01	; 1
    560c:	30 e0       	ldi	r19, 0x00	; 0
    560e:	01 2e       	mov	r0, r17
    5610:	01 c0       	rjmp	.+2      	; 0x5614 <StartTimer8+0x3c>
    5612:	22 0f       	add	r18, r18
    5614:	0a 94       	dec	r0
    5616:	ea f7       	brpl	.-6      	; 0x5612 <StartTimer8+0x3a>

void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    5618:	66 23       	and	r22, r22
    561a:	21 f0       	breq	.+8      	; 0x5624 <StartTimer8+0x4c>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    561c:	20 95       	com	r18
    561e:	28 23       	and	r18, r24
    5620:	20 83       	st	Z, r18
    5622:	02 c0       	rjmp	.+4      	; 0x5628 <StartTimer8+0x50>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    5624:	82 2b       	or	r24, r18
    5626:	80 83       	st	Z, r24
	IntOn();
}
    5628:	0f 90       	pop	r0
    562a:	df 91       	pop	r29
    562c:	cf 91       	pop	r28
    562e:	1f 91       	pop	r17
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5630:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

00005634 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    5634:	1f 93       	push	r17
    5636:	cf 93       	push	r28
    5638:	df 93       	push	r29
    563a:	18 2f       	mov	r17, r24
    563c:	eb 01       	movw	r28, r22
	IntOff();
    563e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	if ((Timer16[TimerN]=Timeout)>0)
    5642:	e1 2f       	mov	r30, r17
    5644:	f0 e0       	ldi	r31, 0x00	; 0
    5646:	ee 0f       	add	r30, r30
    5648:	ff 1f       	adc	r31, r31
    564a:	e2 5e       	subi	r30, 0xE2	; 226
    564c:	fc 4f       	sbci	r31, 0xFC	; 252
    564e:	d1 83       	std	Z+1, r29	; 0x01
    5650:	c0 83       	st	Z, r28
    5652:	e1 2f       	mov	r30, r17
    5654:	e6 95       	lsr	r30
    5656:	e6 95       	lsr	r30
    5658:	e6 95       	lsr	r30
    565a:	17 70       	andi	r17, 0x07	; 7
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    565c:	f0 e0       	ldi	r31, 0x00	; 0
    565e:	e4 59       	subi	r30, 0x94	; 148
    5660:	fd 4f       	sbci	r31, 0xFD	; 253
    5662:	80 81       	ld	r24, Z
    5664:	21 e0       	ldi	r18, 0x01	; 1
    5666:	30 e0       	ldi	r19, 0x00	; 0
    5668:	01 2e       	mov	r0, r17
    566a:	01 c0       	rjmp	.+2      	; 0x566e <StartTimer16+0x3a>
    566c:	22 0f       	add	r18, r18
    566e:	0a 94       	dec	r0
    5670:	ea f7       	brpl	.-6      	; 0x566c <StartTimer16+0x38>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    5672:	cd 2b       	or	r28, r29
    5674:	21 f0       	breq	.+8      	; 0x567e <StartTimer16+0x4a>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    5676:	20 95       	com	r18
    5678:	28 23       	and	r18, r24
    567a:	20 83       	st	Z, r18
    567c:	02 c0       	rjmp	.+4      	; 0x5682 <StartTimer16+0x4e>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    567e:	82 2b       	or	r24, r18
    5680:	80 83       	st	Z, r24
	IntOn();
}
    5682:	df 91       	pop	r29
    5684:	cf 91       	pop	r28
    5686:	1f 91       	pop	r17
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5688:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

0000568c <SlavesOn>:

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    568c:	28 2f       	mov	r18, r24
    568e:	30 e0       	ldi	r19, 0x00	; 0
    5690:	f9 01       	movw	r30, r18
    5692:	ee 0f       	add	r30, r30
    5694:	ff 1f       	adc	r31, r31
    5696:	ee 0f       	add	r30, r30
    5698:	ff 1f       	adc	r31, r31
    569a:	eb 5a       	subi	r30, 0xAB	; 171
    569c:	fd 4f       	sbci	r31, 0xFD	; 253
    569e:	10 82       	st	Z, r1
    56a0:	11 82       	std	Z+1, r1	; 0x01
    56a2:	12 82       	std	Z+2, r1	; 0x02
    56a4:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    56a6:	f9 01       	movw	r30, r18
    56a8:	ee 51       	subi	r30, 0x1E	; 30
    56aa:	fc 4f       	sbci	r31, 0xFC	; 252
    56ac:	60 81       	ld	r22, Z
    56ae:	94 e6       	ldi	r25, 0x64	; 100
    56b0:	69 9f       	mul	r22, r25
    56b2:	b0 01       	movw	r22, r0
    56b4:	11 24       	eor	r1, r1
    56b6:	90 91 54 02 	lds	r25, 0x0254
    56ba:	9f 5f       	subi	r25, 0xFF	; 255
    56bc:	89 0f       	add	r24, r25
    56be:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>

000056c2 <NextSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    56c2:	4f 92       	push	r4
    56c4:	5f 92       	push	r5
    56c6:	6f 92       	push	r6
    56c8:	7f 92       	push	r7
    56ca:	8f 92       	push	r8
    56cc:	9f 92       	push	r9
    56ce:	af 92       	push	r10
    56d0:	bf 92       	push	r11
    56d2:	cf 92       	push	r12
    56d4:	df 92       	push	r13
    56d6:	ef 92       	push	r14
    56d8:	ff 92       	push	r15
    56da:	0f 93       	push	r16
    56dc:	1f 93       	push	r17
    56de:	cf 93       	push	r28
    56e0:	df 93       	push	r29
    56e2:	98 2e       	mov	r9, r24
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
    56e4:	83 e0       	ldi	r24, 0x03	; 3
    56e6:	98 9e       	mul	r9, r24
    56e8:	f0 01       	movw	r30, r0
    56ea:	11 24       	eor	r1, r1
    56ec:	e1 5c       	subi	r30, 0xC1	; 193
    56ee:	f1 4b       	sbci	r31, 0xB1	; 177

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    56f0:	74 90       	lpm	r7, Z
// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	uint8_t i = 0;
    56f2:	81 2c       	mov	r8, r1

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
    56f4:	61 2c       	mov	r6, r1
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    56f6:	09 2d       	mov	r16, r9
    56f8:	10 e0       	ldi	r17, 0x00	; 0
    56fa:	e8 01       	movw	r28, r16
    56fc:	c7 50       	subi	r28, 0x07	; 7
    56fe:	da 4f       	sbci	r29, 0xFA	; 250
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5700:	98 01       	movw	r18, r16
    5702:	22 0f       	add	r18, r18
    5704:	33 1f       	adc	r19, r19
    5706:	f9 01       	movw	r30, r18
    5708:	e1 5d       	subi	r30, 0xD1	; 209
    570a:	f6 4f       	sbci	r31, 0xF6	; 246
    570c:	5f 01       	movw	r10, r30
    570e:	c9 01       	movw	r24, r18
    5710:	83 5d       	subi	r24, 0xD3	; 211
    5712:	97 4f       	sbci	r25, 0xF7	; 247
    5714:	6c 01       	movw	r12, r24
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    5716:	78 01       	movw	r14, r16
    5718:	ee 0c       	add	r14, r14
    571a:	ff 1c       	adc	r15, r15
    571c:	ee 0c       	add	r14, r14
    571e:	ff 1c       	adc	r15, r15
    5720:	f7 01       	movw	r30, r14
    5722:	eb 5a       	subi	r30, 0xAB	; 171
    5724:	fd 4f       	sbci	r31, 0xFD	; 253
    5726:	7f 01       	movw	r14, r30
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    5728:	98 81       	ld	r25, Y
    572a:	9f 5f       	subi	r25, 0xFF	; 255
    572c:	98 83       	st	Y, r25
    572e:	97 11       	cpse	r25, r7
    5730:	27 c0       	rjmp	.+78     	; 0x5780 <NextSlave+0xbe>
			CurrSlave[MB_N] = 0;
    5732:	18 82       	st	Y, r1
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5734:	60 90 54 02 	lds	r6, 0x0254
    5738:	63 94       	inc	r6
    573a:	63 94       	inc	r6
    573c:	69 0c       	add	r6, r9

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    573e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint16_t Time = Timer16[TimerN];
    5742:	a6 2d       	mov	r26, r6
    5744:	b0 e0       	ldi	r27, 0x00	; 0
    5746:	aa 0f       	add	r26, r26
    5748:	bb 1f       	adc	r27, r27
    574a:	a2 5e       	subi	r26, 0xE2	; 226
    574c:	bc 4f       	sbci	r27, 0xFC	; 252
    574e:	4d 90       	ld	r4, X+
    5750:	5c 90       	ld	r5, X
	IntOn();
    5752:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
    5756:	92 01       	movw	r18, r4
    5758:	20 95       	com	r18
    575a:	30 95       	com	r19
    575c:	f5 01       	movw	r30, r10
    575e:	31 83       	std	Z+1, r19	; 0x01
    5760:	20 83       	st	Z, r18
    5762:	f6 01       	movw	r30, r12
    5764:	40 81       	ld	r20, Z
    5766:	51 81       	ldd	r21, Z+1	; 0x01
    5768:	42 17       	cp	r20, r18
    576a:	53 07       	cpc	r21, r19
    576c:	10 f4       	brcc	.+4      	; 0x5772 <NextSlave+0xb0>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    576e:	31 83       	std	Z+1, r19	; 0x01
    5770:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    5772:	6f ef       	ldi	r22, 0xFF	; 255
    5774:	7f ef       	ldi	r23, 0xFF	; 255
    5776:	86 2d       	mov	r24, r6
    5778:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;
    577c:	66 24       	eor	r6, r6
    577e:	63 94       	inc	r6

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    5780:	f7 01       	movw	r30, r14
    5782:	40 81       	ld	r20, Z
    5784:	51 81       	ldd	r21, Z+1	; 0x01
    5786:	62 81       	ldd	r22, Z+2	; 0x02
    5788:	73 81       	ldd	r23, Z+3	; 0x03
    578a:	08 80       	ld	r0, Y
    578c:	04 c0       	rjmp	.+8      	; 0x5796 <NextSlave+0xd4>
    578e:	76 95       	lsr	r23
    5790:	67 95       	ror	r22
    5792:	57 95       	ror	r21
    5794:	47 95       	ror	r20
    5796:	0a 94       	dec	r0
    5798:	d2 f7       	brpl	.-12     	; 0x578e <NextSlave+0xcc>
    579a:	40 ff       	sbrs	r20, 0
    579c:	03 c0       	rjmp	.+6      	; 0x57a4 <NextSlave+0xe2>
    579e:	83 94       	inc	r8
    57a0:	87 14       	cp	r8, r7
    57a2:	10 f2       	brcs	.-124    	; 0x5728 <NextSlave+0x66>
	if (i==SlaveQt) {
    57a4:	87 10       	cpse	r8, r7
    57a6:	09 c0       	rjmp	.+18     	; 0x57ba <NextSlave+0xf8>
		SlavesOn(MB_N);
    57a8:	89 2d       	mov	r24, r9
    57aa:	0e 94 46 2b 	call	0x568c	; 0x568c <SlavesOn>
		if (++CurrSlave[MB_N]==SlaveQt)
    57ae:	98 81       	ld	r25, Y
    57b0:	9f 5f       	subi	r25, 0xFF	; 255
    57b2:	98 83       	st	Y, r25
    57b4:	98 11       	cpse	r25, r8
    57b6:	01 c0       	rjmp	.+2      	; 0x57ba <NextSlave+0xf8>
			CurrSlave[MB_N] = 0;
    57b8:	18 82       	st	Y, r1
	}
	CurrQuery[MB_N] = 0;
    57ba:	f8 01       	movw	r30, r16
    57bc:	e1 50       	subi	r30, 0x01	; 1
    57be:	fa 4f       	sbci	r31, 0xFA	; 250
    57c0:	10 82       	st	Z, r1
	return Over;
}
    57c2:	86 2d       	mov	r24, r6
    57c4:	df 91       	pop	r29
    57c6:	cf 91       	pop	r28
    57c8:	1f 91       	pop	r17
    57ca:	0f 91       	pop	r16
    57cc:	ff 90       	pop	r15
    57ce:	ef 90       	pop	r14
    57d0:	df 90       	pop	r13
    57d2:	cf 90       	pop	r12
    57d4:	bf 90       	pop	r11
    57d6:	af 90       	pop	r10
    57d8:	9f 90       	pop	r9
    57da:	8f 90       	pop	r8
    57dc:	7f 90       	pop	r7
    57de:	6f 90       	pop	r6
    57e0:	5f 90       	pop	r5
    57e2:	4f 90       	pop	r4
    57e4:	08 95       	ret

000057e6 <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    57e6:	0f 93       	push	r16
    57e8:	1f 93       	push	r17
    57ea:	cf 93       	push	r28
    57ec:	df 93       	push	r29
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    57ee:	28 2f       	mov	r18, r24
    57f0:	30 e0       	ldi	r19, 0x00	; 0
    57f2:	f9 01       	movw	r30, r18
    57f4:	ec 5e       	subi	r30, 0xEC	; 236
    57f6:	f9 4f       	sbci	r31, 0xF9	; 249
    57f8:	90 81       	ld	r25, Z
    57fa:	92 30       	cpi	r25, 0x02	; 2
    57fc:	11 f4       	brne	.+4      	; 0x5802 <FailSlave+0x1c>
		MB_SingleState[MB_N] = MB_SingleIdle;
    57fe:	10 82       	st	Z, r1
    5800:	54 c0       	rjmp	.+168    	; 0x58aa <FailSlave+0xc4>
	else{
		MB_CPT[MB_N][4]++;	// -    
    5802:	f9 01       	movw	r30, r18
    5804:	d4 e0       	ldi	r29, 0x04	; 4
    5806:	ee 0f       	add	r30, r30
    5808:	ff 1f       	adc	r31, r31
    580a:	da 95       	dec	r29
    580c:	e1 f7       	brne	.-8      	; 0x5806 <FailSlave+0x20>
    580e:	e4 5f       	subi	r30, 0xF4	; 244
    5810:	f4 4f       	sbci	r31, 0xF4	; 244
    5812:	40 85       	ldd	r20, Z+8	; 0x08
    5814:	51 85       	ldd	r21, Z+9	; 0x09
    5816:	4f 5f       	subi	r20, 0xFF	; 255
    5818:	5f 4f       	sbci	r21, 0xFF	; 255
    581a:	51 87       	std	Z+9, r21	; 0x09
    581c:	40 87       	std	Z+8, r20	; 0x08
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    581e:	f9 01       	movw	r30, r18
    5820:	e7 5a       	subi	r30, 0xA7	; 167
    5822:	fd 4f       	sbci	r31, 0xFD	; 253
    5824:	90 81       	ld	r25, Z
    5826:	9f 5f       	subi	r25, 0xFF	; 255
    5828:	90 83       	st	Z, r25
    582a:	d9 01       	movw	r26, r18
    582c:	a6 54       	subi	r26, 0x46	; 70
    582e:	b7 4f       	sbci	r27, 0xF7	; 247
    5830:	4c 91       	ld	r20, X
    5832:	94 13       	cpse	r25, r20
    5834:	3a c0       	rjmp	.+116    	; 0x58aa <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    5836:	d9 01       	movw	r26, r18
    5838:	a7 50       	subi	r26, 0x07	; 7
    583a:	ba 4f       	sbci	r27, 0xFA	; 250
    583c:	41 e0       	ldi	r20, 0x01	; 1
    583e:	50 e0       	ldi	r21, 0x00	; 0
    5840:	60 e0       	ldi	r22, 0x00	; 0
    5842:	70 e0       	ldi	r23, 0x00	; 0
    5844:	0c 90       	ld	r0, X
    5846:	04 c0       	rjmp	.+8      	; 0x5850 <FailSlave+0x6a>
    5848:	44 0f       	add	r20, r20
    584a:	55 1f       	adc	r21, r21
    584c:	66 1f       	adc	r22, r22
    584e:	77 1f       	adc	r23, r23
    5850:	0a 94       	dec	r0
    5852:	d2 f7       	brpl	.-12     	; 0x5848 <FailSlave+0x62>
			SlaveOff[MB_N] |=S_N;
    5854:	d9 01       	movw	r26, r18
    5856:	aa 0f       	add	r26, r26
    5858:	bb 1f       	adc	r27, r27
    585a:	aa 0f       	add	r26, r26
    585c:	bb 1f       	adc	r27, r27
    585e:	ed 01       	movw	r28, r26
    5860:	c9 50       	subi	r28, 0x09	; 9
    5862:	d5 4f       	sbci	r29, 0xF5	; 245
    5864:	08 81       	ld	r16, Y
    5866:	19 81       	ldd	r17, Y+1	; 0x01
    5868:	2a 81       	ldd	r18, Y+2	; 0x02
    586a:	3b 81       	ldd	r19, Y+3	; 0x03
    586c:	04 2b       	or	r16, r20
    586e:	15 2b       	or	r17, r21
    5870:	26 2b       	or	r18, r22
    5872:	37 2b       	or	r19, r23
    5874:	08 83       	st	Y, r16
    5876:	19 83       	std	Y+1, r17	; 0x01
    5878:	2a 83       	std	Y+2, r18	; 0x02
    587a:	3b 83       	std	Y+3, r19	; 0x03
			SlaveSkip[MB_N] |=S_N;
    587c:	ab 5a       	subi	r26, 0xAB	; 171
    587e:	bd 4f       	sbci	r27, 0xFD	; 253
    5880:	0d 91       	ld	r16, X+
    5882:	1d 91       	ld	r17, X+
    5884:	2d 91       	ld	r18, X+
    5886:	3c 91       	ld	r19, X
    5888:	13 97       	sbiw	r26, 0x03	; 3
    588a:	04 2b       	or	r16, r20
    588c:	15 2b       	or	r17, r21
    588e:	26 2b       	or	r18, r22
    5890:	37 2b       	or	r19, r23
    5892:	0d 93       	st	X+, r16
    5894:	1d 93       	st	X+, r17
    5896:	2d 93       	st	X+, r18
    5898:	3c 93       	st	X, r19
    589a:	13 97       	sbiw	r26, 0x03	; 3
			Try[MB_N] = 0;
    589c:	10 82       	st	Z, r1
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    589e:	df 91       	pop	r29
    58a0:	cf 91       	pop	r28
    58a2:	1f 91       	pop	r17
    58a4:	0f 91       	pop	r16
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
			SlaveOff[MB_N] |=S_N;
			SlaveSkip[MB_N] |=S_N;
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
    58a6:	0c 94 61 2b 	jmp	0x56c2	; 0x56c2 <NextSlave>
		}
	}
	return Over;
}
    58aa:	80 e0       	ldi	r24, 0x00	; 0
    58ac:	df 91       	pop	r29
    58ae:	cf 91       	pop	r28
    58b0:	1f 91       	pop	r17
    58b2:	0f 91       	pop	r16
    58b4:	08 95       	ret

000058b6 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    58b6:	1f 93       	push	r17
    58b8:	cf 93       	push	r28
    58ba:	df 93       	push	r29
    58bc:	00 d0       	rcall	.+0      	; 0x58be <StartTimer32+0x8>
    58be:	00 d0       	rcall	.+0      	; 0x58c0 <StartTimer32+0xa>
    58c0:	cd b7       	in	r28, 0x3d	; 61
    58c2:	de b7       	in	r29, 0x3e	; 62
    58c4:	18 2f       	mov	r17, r24
	IntOff();
    58c6:	49 83       	std	Y+1, r20	; 0x01
    58c8:	5a 83       	std	Y+2, r21	; 0x02
    58ca:	6b 83       	std	Y+3, r22	; 0x03
    58cc:	7c 83       	std	Y+4, r23	; 0x04
    58ce:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	if ((Timer32[TimerN]=Timeout)>0)
    58d2:	84 e0       	ldi	r24, 0x04	; 4
    58d4:	18 9f       	mul	r17, r24
    58d6:	f0 01       	movw	r30, r0
    58d8:	11 24       	eor	r1, r1
    58da:	e2 58       	subi	r30, 0x82	; 130
    58dc:	fd 4f       	sbci	r31, 0xFD	; 253
    58de:	49 81       	ldd	r20, Y+1	; 0x01
    58e0:	5a 81       	ldd	r21, Y+2	; 0x02
    58e2:	6b 81       	ldd	r22, Y+3	; 0x03
    58e4:	7c 81       	ldd	r23, Y+4	; 0x04
    58e6:	40 83       	st	Z, r20
    58e8:	51 83       	std	Z+1, r21	; 0x01
    58ea:	62 83       	std	Z+2, r22	; 0x02
    58ec:	73 83       	std	Z+3, r23	; 0x03
    58ee:	e1 2f       	mov	r30, r17
    58f0:	e6 95       	lsr	r30
    58f2:	e6 95       	lsr	r30
    58f4:	e6 95       	lsr	r30
    58f6:	17 70       	andi	r17, 0x07	; 7
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    58f8:	f0 e0       	ldi	r31, 0x00	; 0
    58fa:	ea 59       	subi	r30, 0x9A	; 154
    58fc:	fd 4f       	sbci	r31, 0xFD	; 253
    58fe:	80 81       	ld	r24, Z
    5900:	21 e0       	ldi	r18, 0x01	; 1
    5902:	30 e0       	ldi	r19, 0x00	; 0
    5904:	01 2e       	mov	r0, r17
    5906:	01 c0       	rjmp	.+2      	; 0x590a <StartTimer32+0x54>
    5908:	22 0f       	add	r18, r18
    590a:	0a 94       	dec	r0
    590c:	ea f7       	brpl	.-6      	; 0x5908 <StartTimer32+0x52>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    590e:	45 2b       	or	r20, r21
    5910:	46 2b       	or	r20, r22
    5912:	47 2b       	or	r20, r23
    5914:	21 f0       	breq	.+8      	; 0x591e <StartTimer32+0x68>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    5916:	20 95       	com	r18
    5918:	28 23       	and	r18, r24
    591a:	20 83       	st	Z, r18
    591c:	02 c0       	rjmp	.+4      	; 0x5922 <StartTimer32+0x6c>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    591e:	82 2b       	or	r24, r18
    5920:	80 83       	st	Z, r24
	IntOn();
}
    5922:	0f 90       	pop	r0
    5924:	0f 90       	pop	r0
    5926:	0f 90       	pop	r0
    5928:	0f 90       	pop	r0
    592a:	df 91       	pop	r29
    592c:	cf 91       	pop	r28
    592e:	1f 91       	pop	r17
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5930:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

00005934 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    5934:	a8 2f       	mov	r26, r24
    5936:	a6 95       	lsr	r26
    5938:	a6 95       	lsr	r26
    593a:	a6 95       	lsr	r26
    593c:	b0 e0       	ldi	r27, 0x00	; 0
    593e:	ab 58       	subi	r26, 0x8B	; 139
    5940:	bd 4f       	sbci	r27, 0xFD	; 253
    5942:	2c 91       	ld	r18, X
    5944:	30 e0       	ldi	r19, 0x00	; 0
    5946:	98 2f       	mov	r25, r24
    5948:	97 70       	andi	r25, 0x07	; 7
    594a:	02 c0       	rjmp	.+4      	; 0x5950 <Timer8Stopp+0x1c>
    594c:	35 95       	asr	r19
    594e:	27 95       	ror	r18
    5950:	9a 95       	dec	r25
    5952:	e2 f7       	brpl	.-8      	; 0x594c <Timer8Stopp+0x18>
    5954:	20 ff       	sbrs	r18, 0
    5956:	07 c0       	rjmp	.+14     	; 0x5966 <Timer8Stopp+0x32>
    5958:	e8 2f       	mov	r30, r24
    595a:	f0 e0       	ldi	r31, 0x00	; 0
    595c:	e2 56       	subi	r30, 0x62	; 98
    595e:	fc 4f       	sbci	r31, 0xFC	; 252
    5960:	90 81       	ld	r25, Z
    5962:	81 e0       	ldi	r24, 0x01	; 1
    5964:	91 11       	cpse	r25, r1
    5966:	80 e0       	ldi	r24, 0x00	; 0
}
    5968:	08 95       	ret

0000596a <Timer16Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
    596a:	cf 93       	push	r28
    596c:	c8 2f       	mov	r28, r24
	IntOff();
    596e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    5972:	ac 2f       	mov	r26, r28
    5974:	a6 95       	lsr	r26
    5976:	a6 95       	lsr	r26
    5978:	a6 95       	lsr	r26
    597a:	b0 e0       	ldi	r27, 0x00	; 0
    597c:	a4 59       	subi	r26, 0x94	; 148
    597e:	bd 4f       	sbci	r27, 0xFD	; 253
    5980:	2c 91       	ld	r18, X
    5982:	30 e0       	ldi	r19, 0x00	; 0
    5984:	8c 2f       	mov	r24, r28
    5986:	87 70       	andi	r24, 0x07	; 7
    5988:	02 c0       	rjmp	.+4      	; 0x598e <Timer16Stopp+0x24>
    598a:	35 95       	asr	r19
    598c:	27 95       	ror	r18
    598e:	8a 95       	dec	r24
    5990:	e2 f7       	brpl	.-8      	; 0x598a <Timer16Stopp+0x20>
    5992:	20 ff       	sbrs	r18, 0
    5994:	0b c0       	rjmp	.+22     	; 0x59ac <Timer16Stopp+0x42>
    5996:	ec 2f       	mov	r30, r28
    5998:	f0 e0       	ldi	r31, 0x00	; 0
    599a:	ee 0f       	add	r30, r30
    599c:	ff 1f       	adc	r31, r31
    599e:	e2 5e       	subi	r30, 0xE2	; 226
    59a0:	fc 4f       	sbci	r31, 0xFC	; 252
    59a2:	20 81       	ld	r18, Z
    59a4:	31 81       	ldd	r19, Z+1	; 0x01
    59a6:	c1 e0       	ldi	r28, 0x01	; 1
    59a8:	23 2b       	or	r18, r19
    59aa:	09 f0       	breq	.+2      	; 0x59ae <Timer16Stopp+0x44>
    59ac:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    59ae:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
	return T_S;
}
    59b2:	8c 2f       	mov	r24, r28
    59b4:	cf 91       	pop	r28
    59b6:	08 95       	ret

000059b8 <Timer32Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
    59b8:	cf 93       	push	r28
    59ba:	c8 2f       	mov	r28, r24
	IntOff();
    59bc:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    59c0:	ac 2f       	mov	r26, r28
    59c2:	a6 95       	lsr	r26
    59c4:	a6 95       	lsr	r26
    59c6:	a6 95       	lsr	r26
    59c8:	b0 e0       	ldi	r27, 0x00	; 0
    59ca:	aa 59       	subi	r26, 0x9A	; 154
    59cc:	bd 4f       	sbci	r27, 0xFD	; 253
    59ce:	2c 91       	ld	r18, X
    59d0:	30 e0       	ldi	r19, 0x00	; 0
    59d2:	8c 2f       	mov	r24, r28
    59d4:	87 70       	andi	r24, 0x07	; 7
    59d6:	02 c0       	rjmp	.+4      	; 0x59dc <Timer32Stopp+0x24>
    59d8:	35 95       	asr	r19
    59da:	27 95       	ror	r18
    59dc:	8a 95       	dec	r24
    59de:	e2 f7       	brpl	.-8      	; 0x59d8 <Timer32Stopp+0x20>
    59e0:	20 ff       	sbrs	r18, 0
    59e2:	0f c0       	rjmp	.+30     	; 0x5a02 <Timer32Stopp+0x4a>
    59e4:	84 e0       	ldi	r24, 0x04	; 4
    59e6:	c8 9f       	mul	r28, r24
    59e8:	f0 01       	movw	r30, r0
    59ea:	11 24       	eor	r1, r1
    59ec:	e2 58       	subi	r30, 0x82	; 130
    59ee:	fd 4f       	sbci	r31, 0xFD	; 253
    59f0:	40 81       	ld	r20, Z
    59f2:	51 81       	ldd	r21, Z+1	; 0x01
    59f4:	62 81       	ldd	r22, Z+2	; 0x02
    59f6:	73 81       	ldd	r23, Z+3	; 0x03
    59f8:	c1 e0       	ldi	r28, 0x01	; 1
    59fa:	45 2b       	or	r20, r21
    59fc:	46 2b       	or	r20, r22
    59fe:	47 2b       	or	r20, r23
    5a00:	09 f0       	breq	.+2      	; 0x5a04 <Timer32Stopp+0x4c>
    5a02:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5a04:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
	return T_S;
}
    5a08:	8c 2f       	mov	r24, r28
    5a0a:	cf 91       	pop	r28
    5a0c:	08 95       	ret

00005a0e <ResetTimer16>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    5a0e:	cf 93       	push	r28
    5a10:	c8 2f       	mov	r28, r24
	IntOff();
    5a12:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    5a16:	ac 2f       	mov	r26, r28
    5a18:	a6 95       	lsr	r26
    5a1a:	a6 95       	lsr	r26
    5a1c:	a6 95       	lsr	r26
    5a1e:	b0 e0       	ldi	r27, 0x00	; 0
    5a20:	a4 59       	subi	r26, 0x94	; 148
    5a22:	bd 4f       	sbci	r27, 0xFD	; 253
    5a24:	8c 91       	ld	r24, X
    5a26:	9c 2f       	mov	r25, r28
    5a28:	97 70       	andi	r25, 0x07	; 7
    5a2a:	21 e0       	ldi	r18, 0x01	; 1
    5a2c:	30 e0       	ldi	r19, 0x00	; 0
    5a2e:	01 c0       	rjmp	.+2      	; 0x5a32 <ResetTimer16+0x24>
    5a30:	22 0f       	add	r18, r18
    5a32:	9a 95       	dec	r25
    5a34:	ea f7       	brpl	.-6      	; 0x5a30 <ResetTimer16+0x22>
    5a36:	82 2b       	or	r24, r18
    5a38:	8c 93       	st	X, r24
	Timer16[TimerN] = 0;
    5a3a:	ec 2f       	mov	r30, r28
    5a3c:	f0 e0       	ldi	r31, 0x00	; 0
    5a3e:	ee 0f       	add	r30, r30
    5a40:	ff 1f       	adc	r31, r31
    5a42:	e2 5e       	subi	r30, 0xE2	; 226
    5a44:	fc 4f       	sbci	r31, 0xFC	; 252
    5a46:	11 82       	std	Z+1, r1	; 0x01
    5a48:	10 82       	st	Z, r1
	IntOn();
}
    5a4a:	cf 91       	pop	r28
ResetTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
	Timer16[TimerN] = 0;
	IntOn();
    5a4c:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

00005a50 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    5a50:	60 91 15 06 	lds	r22, 0x0615
    5a54:	8b e8       	ldi	r24, 0x8B	; 139
    5a56:	91 e0       	ldi	r25, 0x01	; 1
    5a58:	0e 94 44 2a 	call	0x5488	; 0x5488 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    5a5c:	60 91 2a 0e 	lds	r22, 0x0E2A
    5a60:	70 91 2b 0e 	lds	r23, 0x0E2B
    5a64:	89 e8       	ldi	r24, 0x89	; 137
    5a66:	91 e0       	ldi	r25, 0x01	; 1
    5a68:	0c 94 4f 2a 	jmp	0x549e	; 0x549e <eww>

00005a6c <TimeInit>:
		CCP = CCP_IOREG_gc; CLK.CTRL = CLK_SCLKSEL_PLL_gc;
		CCP = CCP_IOREG_gc; CLK.LOCK = CLK_LOCK_bm;
	#endif

	// WDT
	WdtOn();
    5a6c:	0e 94 d3 2a 	call	0x55a6	; 0x55a6 <WdtOn>

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    5a70:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    5a72:	8a ee       	ldi	r24, 0xEA	; 234
    5a74:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
    5a76:	80 e2       	ldi	r24, 0x20	; 32
    5a78:	9e e4       	ldi	r25, 0x4E	; 78
    5a7a:	9b bd       	out	0x2b, r25	; 43
    5a7c:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
    5a7e:	87 b7       	in	r24, 0x37	; 55
    5a80:	80 61       	ori	r24, 0x10	; 16
    5a82:	87 bf       	out	0x37, r24	; 55
    5a84:	80 e0       	ldi	r24, 0x00	; 0
    5a86:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    5a88:	2f ef       	ldi	r18, 0xFF	; 255
    5a8a:	fc 01       	movw	r30, r24
    5a8c:	eb 58       	subi	r30, 0x8B	; 139
    5a8e:	fd 4f       	sbci	r31, 0xFD	; 253
    5a90:	20 83       	st	Z, r18
    5a92:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    5a94:	87 30       	cpi	r24, 0x07	; 7
    5a96:	91 05       	cpc	r25, r1
    5a98:	c1 f7       	brne	.-16     	; 0x5a8a <TimeInit+0x1e>
    5a9a:	80 e0       	ldi	r24, 0x00	; 0
    5a9c:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    5a9e:	3f ef       	ldi	r19, 0xFF	; 255
    5aa0:	fc 01       	movw	r30, r24
    5aa2:	e4 59       	subi	r30, 0x94	; 148
    5aa4:	fd 4f       	sbci	r31, 0xFD	; 253
    5aa6:	2f ef       	ldi	r18, 0xFF	; 255
    5aa8:	30 83       	st	Z, r19
    5aaa:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    5aac:	89 30       	cpi	r24, 0x09	; 9
    5aae:	91 05       	cpc	r25, r1
    5ab0:	b9 f7       	brne	.-18     	; 0x5aa0 <TimeInit+0x34>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    5ab2:	20 93 66 02 	sts	0x0266, r18
    5ab6:	20 93 67 02 	sts	0x0267, r18
    5aba:	20 93 68 02 	sts	0x0268, r18
    5abe:	20 93 69 02 	sts	0x0269, r18
    5ac2:	20 93 6a 02 	sts	0x026A, r18
    5ac6:	20 93 6b 02 	sts	0x026B, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5aca:	8b e8       	ldi	r24, 0x8B	; 139
    5acc:	91 e0       	ldi	r25, 0x01	; 1
    5ace:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    5ad2:	80 93 15 06 	sts	0x0615, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5ad6:	89 e8       	ldi	r24, 0x89	; 137
    5ad8:	91 e0       	ldi	r25, 0x01	; 1
    5ada:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
    5ade:	90 93 2b 0e 	sts	0x0E2B, r25
    5ae2:	80 93 2a 0e 	sts	0x0E2A, r24
    5ae6:	08 95       	ret

00005ae8 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    5ae8:	80 91 0b 01 	lds	r24, 0x010B
	VacantTimer8Sys += n;
    5aec:	91 e0       	ldi	r25, 0x01	; 1
    5aee:	98 0f       	add	r25, r24
    5af0:	90 93 0b 01 	sts	0x010B, r25

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    5af4:	80 93 65 02 	sts	0x0265, r24
	StartTimer8(TD_Scan, 0xFF);
    5af8:	6f ef       	ldi	r22, 0xFF	; 255
    5afa:	0c 94 ec 2a 	jmp	0x55d8	; 0x55d8 <StartTimer8>

00005afe <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    5afe:	1f 92       	push	r1
    5b00:	0f 92       	push	r0
    5b02:	0f b6       	in	r0, 0x3f	; 63
    5b04:	0f 92       	push	r0
    5b06:	11 24       	eor	r1, r1
    5b08:	0b b6       	in	r0, 0x3b	; 59
    5b0a:	0f 92       	push	r0
    5b0c:	2f 93       	push	r18
    5b0e:	3f 93       	push	r19
    5b10:	4f 93       	push	r20
    5b12:	5f 93       	push	r21
    5b14:	6f 93       	push	r22
    5b16:	8f 93       	push	r24
    5b18:	9f 93       	push	r25
    5b1a:	ef 93       	push	r30
    5b1c:	ff 93       	push	r31
	TickCounter++;
    5b1e:	80 91 64 02 	lds	r24, 0x0264
    5b22:	8f 5f       	subi	r24, 0xFF	; 255
    5b24:	80 93 64 02 	sts	0x0264, r24
    5b28:	80 e0       	ldi	r24, 0x00	; 0
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5b2c:	41 e0       	ldi	r20, 0x01	; 1
    5b2e:	50 e0       	ldi	r21, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    5b30:	20 91 7c 02 	lds	r18, 0x027C
    5b34:	30 e0       	ldi	r19, 0x00	; 0
    5b36:	08 2e       	mov	r0, r24
    5b38:	02 c0       	rjmp	.+4      	; 0x5b3e <__vector_12+0x40>
    5b3a:	35 95       	asr	r19
    5b3c:	27 95       	ror	r18
    5b3e:	0a 94       	dec	r0
    5b40:	e2 f7       	brpl	.-8      	; 0x5b3a <__vector_12+0x3c>
    5b42:	20 fd       	sbrc	r18, 0
    5b44:	13 c0       	rjmp	.+38     	; 0x5b6c <__vector_12+0x6e>
    5b46:	fc 01       	movw	r30, r24
    5b48:	e2 53       	subi	r30, 0x32	; 50
    5b4a:	fc 4f       	sbci	r31, 0xFC	; 252
    5b4c:	20 81       	ld	r18, Z
    5b4e:	21 50       	subi	r18, 0x01	; 1
    5b50:	20 83       	st	Z, r18
    5b52:	21 11       	cpse	r18, r1
    5b54:	0b c0       	rjmp	.+22     	; 0x5b6c <__vector_12+0x6e>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5b56:	60 91 7c 02 	lds	r22, 0x027C
    5b5a:	9a 01       	movw	r18, r20
    5b5c:	08 2e       	mov	r0, r24
    5b5e:	01 c0       	rjmp	.+2      	; 0x5b62 <__vector_12+0x64>
    5b60:	22 0f       	add	r18, r18
    5b62:	0a 94       	dec	r0
    5b64:	ea f7       	brpl	.-6      	; 0x5b60 <__vector_12+0x62>
    5b66:	62 2b       	or	r22, r18
    5b68:	60 93 7c 02 	sts	0x027C, r22
    5b6c:	01 96       	adiw	r24, 0x01	; 1
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    5b6e:	88 30       	cpi	r24, 0x08	; 8
    5b70:	91 05       	cpc	r25, r1
    5b72:	f1 f6       	brne	.-68     	; 0x5b30 <__vector_12+0x32>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    5b74:	ff 91       	pop	r31
    5b76:	ef 91       	pop	r30
    5b78:	9f 91       	pop	r25
    5b7a:	8f 91       	pop	r24
    5b7c:	6f 91       	pop	r22
    5b7e:	5f 91       	pop	r21
    5b80:	4f 91       	pop	r20
    5b82:	3f 91       	pop	r19
    5b84:	2f 91       	pop	r18
    5b86:	0f 90       	pop	r0
    5b88:	0b be       	out	0x3b, r0	; 59
    5b8a:	0f 90       	pop	r0
    5b8c:	0f be       	out	0x3f, r0	; 63
    5b8e:	0f 90       	pop	r0
    5b90:	1f 90       	pop	r1
    5b92:	18 95       	reti

00005b94 <TimersInc>:
void 
TimersInc(void)
{
    5b94:	ef 92       	push	r14
    5b96:	ff 92       	push	r15
    5b98:	0f 93       	push	r16
    5b9a:	1f 93       	push	r17
    5b9c:	cf 93       	push	r28
    5b9e:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    5ba0:	f8 94       	cli
	TickCounterVar = TickCounter;
    5ba2:	00 91 64 02 	lds	r16, 0x0264
	TickCounter = 0;
    5ba6:	10 92 64 02 	sts	0x0264, r1
	sei();
    5baa:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    5bac:	10 e0       	ldi	r17, 0x00	; 0
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    5bae:	ee 24       	eor	r14, r14
    5bb0:	e3 94       	inc	r14
    5bb2:	f1 2c       	mov	r15, r1
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5bb4:	10 17       	cp	r17, r16
    5bb6:	09 f4       	brne	.+2      	; 0x5bba <TimersInc+0x26>
    5bb8:	e2 c0       	rjmp	.+452    	; 0x5d7e <TimersInc+0x1ea>
		LiveTime++;
    5bba:	80 91 47 09 	lds	r24, 0x0947
    5bbe:	90 91 48 09 	lds	r25, 0x0948
    5bc2:	a0 91 49 09 	lds	r26, 0x0949
    5bc6:	b0 91 4a 09 	lds	r27, 0x094A
    5bca:	01 96       	adiw	r24, 0x01	; 1
    5bcc:	a1 1d       	adc	r26, r1
    5bce:	b1 1d       	adc	r27, r1
    5bd0:	80 93 47 09 	sts	0x0947, r24
    5bd4:	90 93 48 09 	sts	0x0948, r25
    5bd8:	a0 93 49 09 	sts	0x0949, r26
    5bdc:	b0 93 4a 09 	sts	0x094A, r27
    5be0:	80 e0       	ldi	r24, 0x00	; 0
    5be2:	90 e0       	ldi	r25, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    5be4:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    5be6:	e8 2f       	mov	r30, r24
    5be8:	e6 95       	lsr	r30
    5bea:	e6 95       	lsr	r30
    5bec:	e6 95       	lsr	r30
    5bee:	f0 e0       	ldi	r31, 0x00	; 0
    5bf0:	eb 58       	subi	r30, 0x8B	; 139
    5bf2:	fd 4f       	sbci	r31, 0xFD	; 253
    5bf4:	20 81       	ld	r18, Z
    5bf6:	58 2f       	mov	r21, r24
    5bf8:	57 70       	andi	r21, 0x07	; 7
    5bfa:	30 e0       	ldi	r19, 0x00	; 0
    5bfc:	05 2e       	mov	r0, r21
    5bfe:	02 c0       	rjmp	.+4      	; 0x5c04 <TimersInc+0x70>
    5c00:	35 95       	asr	r19
    5c02:	27 95       	ror	r18
    5c04:	0a 94       	dec	r0
    5c06:	e2 f7       	brpl	.-8      	; 0x5c00 <TimersInc+0x6c>
    5c08:	20 fd       	sbrc	r18, 0
    5c0a:	11 c0       	rjmp	.+34     	; 0x5c2e <TimersInc+0x9a>
    5c0c:	dc 01       	movw	r26, r24
    5c0e:	a2 56       	subi	r26, 0x62	; 98
    5c10:	bc 4f       	sbci	r27, 0xFC	; 252
    5c12:	3c 91       	ld	r19, X
    5c14:	31 50       	subi	r19, 0x01	; 1
    5c16:	3c 93       	st	X, r19
    5c18:	31 11       	cpse	r19, r1
    5c1a:	09 c0       	rjmp	.+18     	; 0x5c2e <TimersInc+0x9a>
				Timer8Flg[i/8] |=(1<<i%8);
    5c1c:	40 81       	ld	r20, Z
    5c1e:	97 01       	movw	r18, r14
    5c20:	05 2e       	mov	r0, r21
    5c22:	01 c0       	rjmp	.+2      	; 0x5c26 <TimersInc+0x92>
    5c24:	22 0f       	add	r18, r18
    5c26:	0a 94       	dec	r0
    5c28:	ea f7       	brpl	.-6      	; 0x5c24 <TimersInc+0x90>
    5c2a:	42 2b       	or	r20, r18
    5c2c:	40 83       	st	Z, r20
			sei();
    5c2e:	78 94       	sei
    5c30:	01 96       	adiw	r24, 0x01	; 1
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    5c32:	80 33       	cpi	r24, 0x30	; 48
    5c34:	91 05       	cpc	r25, r1
    5c36:	b1 f6       	brne	.-84     	; 0x5be4 <TimersInc+0x50>
    5c38:	80 e0       	ldi	r24, 0x00	; 0
    5c3a:	90 e0       	ldi	r25, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    5c3c:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    5c3e:	e8 2f       	mov	r30, r24
    5c40:	e6 95       	lsr	r30
    5c42:	e6 95       	lsr	r30
    5c44:	e6 95       	lsr	r30
    5c46:	f0 e0       	ldi	r31, 0x00	; 0
    5c48:	e4 59       	subi	r30, 0x94	; 148
    5c4a:	fd 4f       	sbci	r31, 0xFD	; 253
    5c4c:	20 81       	ld	r18, Z
    5c4e:	58 2f       	mov	r21, r24
    5c50:	57 70       	andi	r21, 0x07	; 7
    5c52:	30 e0       	ldi	r19, 0x00	; 0
    5c54:	05 2e       	mov	r0, r21
    5c56:	02 c0       	rjmp	.+4      	; 0x5c5c <TimersInc+0xc8>
    5c58:	35 95       	asr	r19
    5c5a:	27 95       	ror	r18
    5c5c:	0a 94       	dec	r0
    5c5e:	e2 f7       	brpl	.-8      	; 0x5c58 <TimersInc+0xc4>
    5c60:	20 fd       	sbrc	r18, 0
    5c62:	18 c0       	rjmp	.+48     	; 0x5c94 <TimersInc+0x100>
    5c64:	dc 01       	movw	r26, r24
    5c66:	aa 0f       	add	r26, r26
    5c68:	bb 1f       	adc	r27, r27
    5c6a:	a2 5e       	subi	r26, 0xE2	; 226
    5c6c:	bc 4f       	sbci	r27, 0xFC	; 252
    5c6e:	2d 91       	ld	r18, X+
    5c70:	3c 91       	ld	r19, X
    5c72:	11 97       	sbiw	r26, 0x01	; 1
    5c74:	21 50       	subi	r18, 0x01	; 1
    5c76:	31 09       	sbc	r19, r1
    5c78:	11 96       	adiw	r26, 0x01	; 1
    5c7a:	3c 93       	st	X, r19
    5c7c:	2e 93       	st	-X, r18
    5c7e:	23 2b       	or	r18, r19
    5c80:	49 f4       	brne	.+18     	; 0x5c94 <TimersInc+0x100>
				Timer16Flg[i/8] |=(1<<i%8);
    5c82:	40 81       	ld	r20, Z
    5c84:	97 01       	movw	r18, r14
    5c86:	05 2e       	mov	r0, r21
    5c88:	01 c0       	rjmp	.+2      	; 0x5c8c <TimersInc+0xf8>
    5c8a:	22 0f       	add	r18, r18
    5c8c:	0a 94       	dec	r0
    5c8e:	ea f7       	brpl	.-6      	; 0x5c8a <TimersInc+0xf6>
    5c90:	42 2b       	or	r20, r18
    5c92:	40 83       	st	Z, r20
			sei();
    5c94:	78 94       	sei
    5c96:	01 96       	adiw	r24, 0x01	; 1
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    5c98:	80 34       	cpi	r24, 0x40	; 64
    5c9a:	91 05       	cpc	r25, r1
    5c9c:	79 f6       	brne	.-98     	; 0x5c3c <TimersInc+0xa8>
    5c9e:	20 e0       	ldi	r18, 0x00	; 0
    5ca0:	30 e0       	ldi	r19, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    5ca2:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    5ca4:	e2 2f       	mov	r30, r18
    5ca6:	e6 95       	lsr	r30
    5ca8:	e6 95       	lsr	r30
    5caa:	e6 95       	lsr	r30
    5cac:	f0 e0       	ldi	r31, 0x00	; 0
    5cae:	ea 59       	subi	r30, 0x9A	; 154
    5cb0:	fd 4f       	sbci	r31, 0xFD	; 253
    5cb2:	80 81       	ld	r24, Z
    5cb4:	62 2f       	mov	r22, r18
    5cb6:	67 70       	andi	r22, 0x07	; 7
    5cb8:	90 e0       	ldi	r25, 0x00	; 0
    5cba:	06 2e       	mov	r0, r22
    5cbc:	02 c0       	rjmp	.+4      	; 0x5cc2 <TimersInc+0x12e>
    5cbe:	95 95       	asr	r25
    5cc0:	87 95       	ror	r24
    5cc2:	0a 94       	dec	r0
    5cc4:	e2 f7       	brpl	.-8      	; 0x5cbe <TimersInc+0x12a>
    5cc6:	80 fd       	sbrc	r24, 0
    5cc8:	20 c0       	rjmp	.+64     	; 0x5d0a <TimersInc+0x176>
    5cca:	a9 01       	movw	r20, r18
    5ccc:	44 0f       	add	r20, r20
    5cce:	55 1f       	adc	r21, r21
    5cd0:	44 0f       	add	r20, r20
    5cd2:	55 1f       	adc	r21, r21
    5cd4:	42 58       	subi	r20, 0x82	; 130
    5cd6:	5d 4f       	sbci	r21, 0xFD	; 253
    5cd8:	ea 01       	movw	r28, r20
    5cda:	88 81       	ld	r24, Y
    5cdc:	99 81       	ldd	r25, Y+1	; 0x01
    5cde:	aa 81       	ldd	r26, Y+2	; 0x02
    5ce0:	bb 81       	ldd	r27, Y+3	; 0x03
    5ce2:	01 97       	sbiw	r24, 0x01	; 1
    5ce4:	a1 09       	sbc	r26, r1
    5ce6:	b1 09       	sbc	r27, r1
    5ce8:	88 83       	st	Y, r24
    5cea:	99 83       	std	Y+1, r25	; 0x01
    5cec:	aa 83       	std	Y+2, r26	; 0x02
    5cee:	bb 83       	std	Y+3, r27	; 0x03
    5cf0:	89 2b       	or	r24, r25
    5cf2:	8a 2b       	or	r24, r26
    5cf4:	8b 2b       	or	r24, r27
    5cf6:	49 f4       	brne	.+18     	; 0x5d0a <TimersInc+0x176>
				Timer32Flg[i/8] |=(1<<i%8);	
    5cf8:	40 81       	ld	r20, Z
    5cfa:	c7 01       	movw	r24, r14
    5cfc:	06 2e       	mov	r0, r22
    5cfe:	01 c0       	rjmp	.+2      	; 0x5d02 <TimersInc+0x16e>
    5d00:	88 0f       	add	r24, r24
    5d02:	0a 94       	dec	r0
    5d04:	ea f7       	brpl	.-6      	; 0x5d00 <TimersInc+0x16c>
    5d06:	48 2b       	or	r20, r24
    5d08:	40 83       	st	Z, r20
			sei();
    5d0a:	78 94       	sei
    5d0c:	2f 5f       	subi	r18, 0xFF	; 255
    5d0e:	3f 4f       	sbci	r19, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    5d10:	28 32       	cpi	r18, 0x28	; 40
    5d12:	31 05       	cpc	r19, r1
    5d14:	31 f6       	brne	.-116    	; 0x5ca2 <TimersInc+0x10e>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    5d16:	80 91 3d 02 	lds	r24, 0x023D
    5d1a:	8f 5f       	subi	r24, 0xFF	; 255
    5d1c:	80 93 3d 02 	sts	0x023D, r24
    5d20:	84 36       	cpi	r24, 0x64	; 100
    5d22:	59 f5       	brne	.+86     	; 0x5d7a <TimersInc+0x1e6>
			Timer10ms = 0;
    5d24:	10 92 3d 02 	sts	0x023D, r1
			ScanPerSec = ScanCount;
    5d28:	80 91 2b 09 	lds	r24, 0x092B
    5d2c:	90 91 2c 09 	lds	r25, 0x092C
    5d30:	90 93 56 09 	sts	0x0956, r25
    5d34:	80 93 55 09 	sts	0x0955, r24
 			ScanCount = 0;
    5d38:	10 92 2c 09 	sts	0x092C, r1
    5d3c:	10 92 2b 09 	sts	0x092B, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    5d40:	80 91 f2 0a 	lds	r24, 0x0AF2
    5d44:	8f 5f       	subi	r24, 0xFF	; 255
    5d46:	80 93 f2 0a 	sts	0x0AF2, r24
    5d4a:	8c 33       	cpi	r24, 0x3C	; 60
    5d4c:	b1 f4       	brne	.+44     	; 0x5d7a <TimersInc+0x1e6>
		Timer1s = 0;
    5d4e:	10 92 f2 0a 	sts	0x0AF2, r1
		if (++Timer1min==60) {
    5d52:	80 91 15 06 	lds	r24, 0x0615
    5d56:	8f 5f       	subi	r24, 0xFF	; 255
    5d58:	80 93 15 06 	sts	0x0615, r24
    5d5c:	8c 33       	cpi	r24, 0x3C	; 60
    5d5e:	69 f4       	brne	.+26     	; 0x5d7a <TimersInc+0x1e6>
			Timer1min = 0;
    5d60:	10 92 15 06 	sts	0x0615, r1
			++Timer1hour;
    5d64:	80 91 2a 0e 	lds	r24, 0x0E2A
    5d68:	90 91 2b 0e 	lds	r25, 0x0E2B
    5d6c:	01 96       	adiw	r24, 0x01	; 1
    5d6e:	90 93 2b 0e 	sts	0x0E2B, r25
    5d72:	80 93 2a 0e 	sts	0x0E2A, r24
			OnTimeSave();
    5d76:	0e 94 28 2d 	call	0x5a50	; 0x5a50 <OnTimeSave>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5d7a:	1f 5f       	subi	r17, 0xFF	; 255
    5d7c:	1b cf       	rjmp	.-458    	; 0x5bb4 <TimersInc+0x20>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    5d7e:	df 91       	pop	r29
    5d80:	cf 91       	pop	r28
    5d82:	1f 91       	pop	r17
    5d84:	0f 91       	pop	r16
    5d86:	ff 90       	pop	r15
    5d88:	ef 90       	pop	r14
    5d8a:	08 95       	ret

00005d8c <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    5d8c:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    5d8e:	80 91 2b 09 	lds	r24, 0x092B
    5d92:	90 91 2c 09 	lds	r25, 0x092C
    5d96:	01 96       	adiw	r24, 0x01	; 1
    5d98:	90 93 2c 09 	sts	0x092C, r25
    5d9c:	80 93 2b 09 	sts	0x092B, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    5da0:	80 91 65 02 	lds	r24, 0x0265
    5da4:	e8 2f       	mov	r30, r24
    5da6:	f0 e0       	ldi	r31, 0x00	; 0
    5da8:	e2 56       	subi	r30, 0x62	; 98
    5daa:	fc 4f       	sbci	r31, 0xFC	; 252
    5dac:	90 81       	ld	r25, Z
    5dae:	90 95       	com	r25
    5db0:	90 93 24 09 	sts	0x0924, r25
    5db4:	20 91 16 06 	lds	r18, 0x0616
    5db8:	29 17       	cp	r18, r25
    5dba:	10 f4       	brcc	.+4      	; 0x5dc0 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    5dbc:	90 93 16 06 	sts	0x0616, r25
	StartTimer8(TD_Scan, 0xFF);
    5dc0:	6f ef       	ldi	r22, 0xFF	; 255
    5dc2:	0c 94 ec 2a 	jmp	0x55d8	; 0x55d8 <StartTimer8>

00005dc6 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    5dc6:	bc 01       	movw	r22, r24
    5dc8:	80 e0       	ldi	r24, 0x00	; 0
    5dca:	90 e0       	ldi	r25, 0x00	; 0
    5dcc:	0e 94 67 79 	call	0xf2ce	; 0xf2ce <__floatunsisf>
    5dd0:	2d ec       	ldi	r18, 0xCD	; 205
    5dd2:	3c ec       	ldi	r19, 0xCC	; 204
    5dd4:	4c e4       	ldi	r20, 0x4C	; 76
    5dd6:	5f e3       	ldi	r21, 0x3F	; 63
    5dd8:	0e 94 f5 79 	call	0xf3ea	; 0xf3ea <__mulsf3>
    5ddc:	0e 94 3b 79 	call	0xf276	; 0xf276 <__fixunssfsi>
	while (Delay--)
    5de0:	61 15       	cp	r22, r1
    5de2:	71 05       	cpc	r23, r1
    5de4:	39 f0       	breq	.+14     	; 0x5df4 <Delay_us+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5de6:	85 e0       	ldi	r24, 0x05	; 5
    5de8:	8a 95       	dec	r24
    5dea:	f1 f7       	brne	.-4      	; 0x5de8 <Delay_us+0x22>
    5dec:	00 00       	nop
    5dee:	61 50       	subi	r22, 0x01	; 1
    5df0:	71 09       	sbc	r23, r1
    5df2:	f6 cf       	rjmp	.-20     	; 0x5de0 <Delay_us+0x1a>
		_delay_us(1);
}
    5df4:	08 95       	ret

00005df6 <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5df6:	8c 9a       	sbi	0x11, 4	; 17
    5df8:	94 98       	cbi	0x12, 4	; 18
    5dfa:	08 95       	ret

00005dfc <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    5dfc:	81 11       	cpse	r24, r1
    5dfe:	0a c0       	rjmp	.+20     	; 0x5e14 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5e00:	80 91 64 00 	lds	r24, 0x0064
    5e04:	81 60       	ori	r24, 0x01	; 1
    5e06:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5e0a:	80 91 65 00 	lds	r24, 0x0065
    5e0e:	8e 7f       	andi	r24, 0xFE	; 254
    5e10:	80 93 65 00 	sts	0x0065, r24
    5e14:	08 95       	ret

00005e16 <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5e16:	81 11       	cpse	r24, r1
    5e18:	0a c0       	rjmp	.+20     	; 0x5e2e <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    5e1a:	80 91 64 00 	lds	r24, 0x0064
    5e1e:	8e 7f       	andi	r24, 0xFE	; 254
    5e20:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5e24:	80 91 65 00 	lds	r24, 0x0065
    5e28:	8e 7f       	andi	r24, 0xFE	; 254
    5e2a:	80 93 65 00 	sts	0x0065, r24
    5e2e:	08 95       	ret

00005e30 <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    5e30:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    5e32:	17 9a       	sbi	0x02, 7	; 2
	sei();
    5e34:	78 94       	sei
    5e36:	08 95       	ret

00005e38 <GSM_PWRCNTRL_OFF>:
}
void GSM_PWRCNTRL_OFF(void){
	cli();
    5e38:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    5e3a:	1f 98       	cbi	0x03, 7	; 3
	sei();
    5e3c:	78 94       	sei
    5e3e:	08 95       	ret

00005e40 <GSM_PWRCNTRL_ON>:
}
void GSM_PWRCNTRL_ON(void){
	cli();
    5e40:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    5e42:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    5e44:	78 94       	sei
    5e46:	08 95       	ret

00005e48 <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    5e48:	8d 9a       	sbi	0x11, 5	; 17
    5e4a:	08 95       	ret

00005e4c <CTS_OFF>:
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    5e4c:	95 98       	cbi	0x12, 5	; 18
    5e4e:	08 95       	ret

00005e50 <CTS_ON>:
}
void CTS_ON(void){
	PORTD|=(1<<PD5);
    5e50:	95 9a       	sbi	0x12, 5	; 18
    5e52:	08 95       	ret

00005e54 <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    5e54:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    5e56:	96 9a       	sbi	0x12, 6	; 18
    5e58:	08 95       	ret

00005e5a <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    5e5a:	1f 92       	push	r1
    5e5c:	0f 92       	push	r0
    5e5e:	0f b6       	in	r0, 0x3f	; 63
    5e60:	0f 92       	push	r0
    5e62:	11 24       	eor	r1, r1
    5e64:	0b b6       	in	r0, 0x3b	; 59
    5e66:	0f 92       	push	r0
    5e68:	2f 93       	push	r18
    5e6a:	3f 93       	push	r19
    5e6c:	4f 93       	push	r20
    5e6e:	5f 93       	push	r21
    5e70:	6f 93       	push	r22
    5e72:	7f 93       	push	r23
    5e74:	8f 93       	push	r24
    5e76:	9f 93       	push	r25
    5e78:	af 93       	push	r26
    5e7a:	bf 93       	push	r27
    5e7c:	ef 93       	push	r30
    5e7e:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5e80:	83 b7       	in	r24, 0x33	; 51
    5e82:	88 7f       	andi	r24, 0xF8	; 248
    5e84:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    5e86:	87 b7       	in	r24, 0x37	; 55
    5e88:	8d 7f       	andi	r24, 0xFD	; 253
    5e8a:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    5e8c:	82 e5       	ldi	r24, 0x52	; 82
    5e8e:	90 e0       	ldi	r25, 0x00	; 0
    5e90:	0e 94 b6 28 	call	0x516c	; 0x516c <MB_Timer_ISR>
}
    5e94:	ff 91       	pop	r31
    5e96:	ef 91       	pop	r30
    5e98:	bf 91       	pop	r27
    5e9a:	af 91       	pop	r26
    5e9c:	9f 91       	pop	r25
    5e9e:	8f 91       	pop	r24
    5ea0:	7f 91       	pop	r23
    5ea2:	6f 91       	pop	r22
    5ea4:	5f 91       	pop	r21
    5ea6:	4f 91       	pop	r20
    5ea8:	3f 91       	pop	r19
    5eaa:	2f 91       	pop	r18
    5eac:	0f 90       	pop	r0
    5eae:	0b be       	out	0x3b, r0	; 59
    5eb0:	0f 90       	pop	r0
    5eb2:	0f be       	out	0x3f, r0	; 63
    5eb4:	0f 90       	pop	r0
    5eb6:	1f 90       	pop	r1
    5eb8:	18 95       	reti

00005eba <__vector_9>:

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    5eba:	1f 92       	push	r1
    5ebc:	0f 92       	push	r0
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	0f 92       	push	r0
    5ec2:	11 24       	eor	r1, r1
    5ec4:	0b b6       	in	r0, 0x3b	; 59
    5ec6:	0f 92       	push	r0
    5ec8:	2f 93       	push	r18
    5eca:	3f 93       	push	r19
    5ecc:	4f 93       	push	r20
    5ece:	5f 93       	push	r21
    5ed0:	6f 93       	push	r22
    5ed2:	7f 93       	push	r23
    5ed4:	8f 93       	push	r24
    5ed6:	9f 93       	push	r25
    5ed8:	af 93       	push	r26
    5eda:	bf 93       	push	r27
    5edc:	ef 93       	push	r30
    5ede:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5ee0:	85 b5       	in	r24, 0x25	; 37
    5ee2:	88 7f       	andi	r24, 0xF8	; 248
    5ee4:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    5ee6:	87 b7       	in	r24, 0x37	; 55
    5ee8:	8f 77       	andi	r24, 0x7F	; 127
    5eea:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    5eec:	84 e4       	ldi	r24, 0x44	; 68
    5eee:	90 e0       	ldi	r25, 0x00	; 0
    5ef0:	0e 94 b6 28 	call	0x516c	; 0x516c <MB_Timer_ISR>
}
    5ef4:	ff 91       	pop	r31
    5ef6:	ef 91       	pop	r30
    5ef8:	bf 91       	pop	r27
    5efa:	af 91       	pop	r26
    5efc:	9f 91       	pop	r25
    5efe:	8f 91       	pop	r24
    5f00:	7f 91       	pop	r23
    5f02:	6f 91       	pop	r22
    5f04:	5f 91       	pop	r21
    5f06:	4f 91       	pop	r20
    5f08:	3f 91       	pop	r19
    5f0a:	2f 91       	pop	r18
    5f0c:	0f 90       	pop	r0
    5f0e:	0b be       	out	0x3b, r0	; 59
    5f10:	0f 90       	pop	r0
    5f12:	0f be       	out	0x3f, r0	; 63
    5f14:	0f 90       	pop	r0
    5f16:	1f 90       	pop	r1
    5f18:	18 95       	reti

00005f1a <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    5f1a:	ff 92       	push	r15
    5f1c:	0f 93       	push	r16
    5f1e:	1f 93       	push	r17
    5f20:	cf 93       	push	r28
    5f22:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    5f24:	08 2f       	mov	r16, r24
    5f26:	10 e0       	ldi	r17, 0x00	; 0
    5f28:	e8 01       	movw	r28, r16
    5f2a:	cc 0f       	add	r28, r28
    5f2c:	dd 1f       	adc	r29, r29
    5f2e:	c0 0f       	add	r28, r16
    5f30:	d1 1f       	adc	r29, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5f32:	ce 01       	movw	r24, r28
    5f34:	8b 57       	subi	r24, 0x7B	; 123
    5f36:	9e 4f       	sbci	r25, 0xFE	; 254
    5f38:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    5f3c:	f8 2e       	mov	r15, r24
    5f3e:	ca 57       	subi	r28, 0x7A	; 122
    5f40:	de 4f       	sbci	r29, 0xFE	; 254
    5f42:	ce 01       	movw	r24, r28
    5f44:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    5f48:	f1 10       	cpse	r15, r1
    5f4a:	04 c0       	rjmp	.+8      	; 0x5f54 <SetParity+0x3a>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    5f4c:	81 30       	cpi	r24, 0x01	; 1
    5f4e:	39 f4       	brne	.+14     	; 0x5f5e <SetParity+0x44>
			case 1:
				ucsrc &=~(1<<3);
    5f50:	96 e8       	ldi	r25, 0x86	; 134
    5f52:	08 c0       	rjmp	.+16     	; 0x5f64 <SetParity+0x4a>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    5f54:	91 e0       	ldi	r25, 0x01	; 1
    5f56:	f9 12       	cpse	r15, r25
    5f58:	04 c0       	rjmp	.+8      	; 0x5f62 <SetParity+0x48>
			case EvenParity:
				ucsrc = (ucsrc |(1<<5)) &~(1<<4);
    5f5a:	96 ea       	ldi	r25, 0xA6	; 166
    5f5c:	03 c0       	rjmp	.+6      	; 0x5f64 <SetParity+0x4a>
{
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
			ucsrc &=~(1<<5) &~(1<<4);
    5f5e:	9e e8       	ldi	r25, 0x8E	; 142
    5f60:	01 c0       	rjmp	.+2      	; 0x5f64 <SetParity+0x4a>
				ucsrc  |=(1<<3);
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
    5f62:	96 eb       	ldi	r25, 0xB6	; 182
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    5f64:	24 e1       	ldi	r18, 0x14	; 20
    5f66:	20 9f       	mul	r18, r16
    5f68:	f0 01       	movw	r30, r0
    5f6a:	21 9f       	mul	r18, r17
    5f6c:	f0 0d       	add	r31, r0
    5f6e:	11 24       	eor	r1, r1
    5f70:	ee 55       	subi	r30, 0x5E	; 94
    5f72:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f74:	a5 91       	lpm	r26, Z+
    5f76:	b4 91       	lpm	r27, Z
    5f78:	9c 93       	st	X, r25
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    5f7a:	ff 20       	and	r15, r15
    5f7c:	59 f0       	breq	.+22     	; 0x5f94 <SetParity+0x7a>
    5f7e:	81 30       	cpi	r24, 0x01	; 1
    5f80:	49 f0       	breq	.+18     	; 0x5f94 <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
    5f82:	61 e0       	ldi	r22, 0x01	; 1
    5f84:	ce 01       	movw	r24, r28
}
    5f86:	df 91       	pop	r29
    5f88:	cf 91       	pop	r28
    5f8a:	1f 91       	pop	r17
    5f8c:	0f 91       	pop	r16
    5f8e:	ff 90       	pop	r15
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
    5f90:	0c 94 44 2a 	jmp	0x5488	; 0x5488 <ewb>
}
    5f94:	df 91       	pop	r29
    5f96:	cf 91       	pop	r28
    5f98:	1f 91       	pop	r17
    5f9a:	0f 91       	pop	r16
    5f9c:	ff 90       	pop	r15
    5f9e:	08 95       	ret

00005fa0 <SetBAUD>:

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    5fa0:	cf 93       	push	r28
    5fa2:	df 93       	push	r29
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    5fa4:	c8 2f       	mov	r28, r24
    5fa6:	d0 e0       	ldi	r29, 0x00	; 0
    5fa8:	ce 01       	movw	r24, r28
    5faa:	88 0f       	add	r24, r24
    5fac:	99 1f       	adc	r25, r25
    5fae:	8c 0f       	add	r24, r28
    5fb0:	9d 1f       	adc	r25, r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5fb2:	89 57       	subi	r24, 0x79	; 121
    5fb4:	9e 4f       	sbci	r25, 0xFE	; 254
    5fb6:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    5fba:	fe 01       	movw	r30, r28
    5fbc:	ed 5a       	subi	r30, 0xAD	; 173
    5fbe:	f6 4f       	sbci	r31, 0xF6	; 246
    5fc0:	80 83       	st	Z, r24
    5fc2:	23 e0       	ldi	r18, 0x03	; 3
    5fc4:	82 9f       	mul	r24, r18
    5fc6:	c0 01       	movw	r24, r0
    5fc8:	11 24       	eor	r1, r1
    5fca:	80 55       	subi	r24, 0x50	; 80
    5fcc:	9f 4a       	sbci	r25, 0xAF	; 175
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    5fce:	24 e1       	ldi	r18, 0x14	; 20
    5fd0:	2c 9f       	mul	r18, r28
    5fd2:	f0 01       	movw	r30, r0
    5fd4:	2d 9f       	mul	r18, r29
    5fd6:	f0 0d       	add	r31, r0
    5fd8:	11 24       	eor	r1, r1
    5fda:	ea 55       	subi	r30, 0x5A	; 90
    5fdc:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fde:	a5 91       	lpm	r26, Z+
    5fe0:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5fe2:	fc 01       	movw	r30, r24
    5fe4:	24 91       	lpm	r18, Z
    5fe6:	2c 93       	st	X, r18
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    5fe8:	24 e1       	ldi	r18, 0x14	; 20
    5fea:	2c 9f       	mul	r18, r28
    5fec:	f0 01       	movw	r30, r0
    5fee:	2d 9f       	mul	r18, r29
    5ff0:	f0 0d       	add	r31, r0
    5ff2:	11 24       	eor	r1, r1
    5ff4:	ec 55       	subi	r30, 0x5C	; 92
    5ff6:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ff8:	a5 91       	lpm	r26, Z+
    5ffa:	b4 91       	lpm	r27, Z
    5ffc:	fc 01       	movw	r30, r24
    5ffe:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6000:	e4 91       	lpm	r30, Z
    6002:	ec 93       	st	X, r30

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    6004:	26 e0       	ldi	r18, 0x06	; 6
    6006:	2c 9f       	mul	r18, r28
    6008:	f0 01       	movw	r30, r0
    600a:	2d 9f       	mul	r18, r29
    600c:	f0 0d       	add	r31, r0
    600e:	11 24       	eor	r1, r1
    6010:	ee 56       	subi	r30, 0x6E	; 110
    6012:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6014:	a5 91       	lpm	r26, Z+
    6016:	b4 91       	lpm	r27, Z
    6018:	fc 01       	movw	r30, r24
    601a:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    601c:	84 91       	lpm	r24, Z
    601e:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    6020:	df 91       	pop	r29
    6022:	cf 91       	pop	r28
    6024:	08 95       	ret

00006026 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    6026:	cf 93       	push	r28
    6028:	df 93       	push	r29
	MB_State[MB_N] = MB_Trans;
    602a:	c8 2f       	mov	r28, r24
    602c:	d0 e0       	ldi	r29, 0x00	; 0
    602e:	fe 01       	movw	r30, r28
    6030:	e7 52       	subi	r30, 0x27	; 39
    6032:	fc 4f       	sbci	r31, 0xFC	; 252
    6034:	83 e0       	ldi	r24, 0x03	; 3
    6036:	80 83       	st	Z, r24
	USART_Func(MB_N, RS485);
    6038:	84 e1       	ldi	r24, 0x14	; 20
    603a:	8c 9f       	mul	r24, r28
    603c:	f0 01       	movw	r30, r0
    603e:	8d 9f       	mul	r24, r29
    6040:	f0 0d       	add	r31, r0
    6042:	11 24       	eor	r1, r1
    6044:	e8 55       	subi	r30, 0x58	; 88
    6046:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6048:	85 91       	lpm	r24, Z+
    604a:	94 91       	lpm	r25, Z
    604c:	fc 01       	movw	r30, r24
    604e:	09 95       	icall
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    6050:	84 e1       	ldi	r24, 0x14	; 20
    6052:	8c 9f       	mul	r24, r28
    6054:	f0 01       	movw	r30, r0
    6056:	8d 9f       	mul	r24, r29
    6058:	f0 0d       	add	r31, r0
    605a:	11 24       	eor	r1, r1
    605c:	e4 56       	subi	r30, 0x64	; 100
    605e:	ff 4a       	sbci	r31, 0xAF	; 175
    6060:	a5 91       	lpm	r26, Z+
    6062:	b4 91       	lpm	r27, Z
    6064:	fc 2f       	mov	r31, r28
    6066:	ee 27       	eor	r30, r30
    6068:	e6 5d       	subi	r30, 0xD6	; 214
    606a:	f2 4f       	sbci	r31, 0xF2	; 242
    606c:	80 81       	ld	r24, Z
    606e:	8c 93       	st	X, r24

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6070:	84 e1       	ldi	r24, 0x14	; 20
    6072:	8c 9f       	mul	r24, r28
    6074:	f0 01       	movw	r30, r0
    6076:	8d 9f       	mul	r24, r29
    6078:	f0 0d       	add	r31, r0
    607a:	11 24       	eor	r1, r1
    607c:	e2 56       	subi	r30, 0x62	; 98
    607e:	ff 4a       	sbci	r31, 0xAF	; 175
    6080:	a5 91       	lpm	r26, Z+
    6082:	b4 91       	lpm	r27, Z
    6084:	8c 91       	ld	r24, X
    6086:	80 64       	ori	r24, 0x40	; 64
    6088:	8c 93       	st	X, r24
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    608a:	84 e1       	ldi	r24, 0x14	; 20
    608c:	8c 9f       	mul	r24, r28
    608e:	f0 01       	movw	r30, r0
    6090:	8d 9f       	mul	r24, r29
    6092:	f0 0d       	add	r31, r0
    6094:	11 24       	eor	r1, r1
    6096:	e0 56       	subi	r30, 0x60	; 96
    6098:	ff 4a       	sbci	r31, 0xAF	; 175
    609a:	a5 91       	lpm	r26, Z+
    609c:	b4 91       	lpm	r27, Z
    609e:	8c 91       	ld	r24, X
    60a0:	80 62       	ori	r24, 0x20	; 32
    60a2:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    60a4:	df 91       	pop	r29
    60a6:	cf 91       	pop	r28
    60a8:	08 95       	ret

000060aa <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    60aa:	cf 93       	push	r28
    60ac:	df 93       	push	r29
    60ae:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    60b0:	80 e0       	ldi	r24, 0x00	; 0
    60b2:	94 e1       	ldi	r25, 0x14	; 20
    60b4:	c8 2f       	mov	r28, r24
    60b6:	d0 e0       	ldi	r29, 0x00	; 0
    60b8:	9c 9f       	mul	r25, r28
    60ba:	f0 01       	movw	r30, r0
    60bc:	9d 9f       	mul	r25, r29
    60be:	f0 0d       	add	r31, r0
    60c0:	11 24       	eor	r1, r1
    60c2:	e4 56       	subi	r30, 0x64	; 100
    60c4:	ff 4a       	sbci	r31, 0xAF	; 175
    60c6:	25 91       	lpm	r18, Z+
    60c8:	34 91       	lpm	r19, Z
    60ca:	a2 17       	cp	r26, r18
    60cc:	b3 07       	cpc	r27, r19
    60ce:	11 f0       	breq	.+4      	; 0x60d4 <Modbus_RX+0x2a>
    60d0:	8f 5f       	subi	r24, 0xFF	; 255
    60d2:	f0 cf       	rjmp	.-32     	; 0x60b4 <Modbus_RX+0xa>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    60d4:	fe 01       	movw	r30, r28
    60d6:	e7 52       	subi	r30, 0x27	; 39
    60d8:	fc 4f       	sbci	r31, 0xFC	; 252
    60da:	90 81       	ld	r25, Z
    60dc:	92 30       	cpi	r25, 0x02	; 2
    60de:	a1 f1       	breq	.+104    	; 0x6148 <Modbus_RX+0x9e>
    60e0:	40 f5       	brcc	.+80     	; 0x6132 <Modbus_RX+0x88>
    60e2:	99 23       	and	r25, r25
    60e4:	51 f1       	breq	.+84     	; 0x613a <Modbus_RX+0x90>
    60e6:	91 30       	cpi	r25, 0x01	; 1
    60e8:	09 f0       	breq	.+2      	; 0x60ec <Modbus_RX+0x42>
    60ea:	3b c0       	rjmp	.+118    	; 0x6162 <Modbus_RX+0xb8>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    60ec:	92 e0       	ldi	r25, 0x02	; 2
    60ee:	90 83       	st	Z, r25
		MB_Err &=~(1<<MB_N);
    60f0:	21 e0       	ldi	r18, 0x01	; 1
    60f2:	30 e0       	ldi	r19, 0x00	; 0
    60f4:	08 2e       	mov	r0, r24
    60f6:	01 c0       	rjmp	.+2      	; 0x60fa <Modbus_RX+0x50>
    60f8:	22 0f       	add	r18, r18
    60fa:	0a 94       	dec	r0
    60fc:	ea f7       	brpl	.-6      	; 0x60f8 <Modbus_RX+0x4e>
    60fe:	20 95       	com	r18
    6100:	90 91 63 02 	lds	r25, 0x0263
    6104:	92 23       	and	r25, r18
    6106:	90 93 63 02 	sts	0x0263, r25
		MB_Frame_Sz[MB_N] = 0;
    610a:	fe 01       	movw	r30, r28
    610c:	e1 54       	subi	r30, 0x41	; 65
    610e:	f7 4f       	sbci	r31, 0xF7	; 247
    6110:	10 82       	st	Z, r1
		MBRecept(MB_N);
    6112:	0e 94 fd 28 	call	0x51fa	; 0x51fa <MBRecept>
		MB_StartTimer(MB_N);
    6116:	86 e0       	ldi	r24, 0x06	; 6
    6118:	8c 9f       	mul	r24, r28
    611a:	f0 01       	movw	r30, r0
    611c:	8d 9f       	mul	r24, r29
    611e:	f0 0d       	add	r31, r0
    6120:	11 24       	eor	r1, r1
    6122:	ec 56       	subi	r30, 0x6C	; 108
    6124:	ff 4a       	sbci	r31, 0xAF	; 175
    6126:	85 91       	lpm	r24, Z+
    6128:	94 91       	lpm	r25, Z
    612a:	fc 01       	movw	r30, r24
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    612c:	df 91       	pop	r29
    612e:	cf 91       	pop	r28
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
		MB_Err &=~(1<<MB_N);
		MB_Frame_Sz[MB_N] = 0;
		MBRecept(MB_N);
		MB_StartTimer(MB_N);
    6130:	09 94       	ijmp
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    6132:	96 30       	cpi	r25, 0x06	; 6
    6134:	b0 f4       	brcc	.+44     	; 0x6162 <Modbus_RX+0xb8>
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    6136:	8c 91       	ld	r24, X
		break;
    6138:	14 c0       	rjmp	.+40     	; 0x6162 <Modbus_RX+0xb8>
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    613a:	8c 91       	ld	r24, X
    613c:	fc 2f       	mov	r31, r28
    613e:	ee 27       	eor	r30, r30
    6140:	e6 5d       	subi	r30, 0xD6	; 214
    6142:	f2 4f       	sbci	r31, 0xF2	; 242
    6144:	80 83       	st	Z, r24
    6146:	02 c0       	rjmp	.+4      	; 0x614c <Modbus_RX+0xa2>
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    6148:	0e 94 fd 28 	call	0x51fa	; 0x51fa <MBRecept>
		MB_ClearTimer(MB_N);
    614c:	86 e0       	ldi	r24, 0x06	; 6
    614e:	8c 9f       	mul	r24, r28
    6150:	f0 01       	movw	r30, r0
    6152:	8d 9f       	mul	r24, r29
    6154:	f0 0d       	add	r31, r0
    6156:	11 24       	eor	r1, r1
    6158:	e0 57       	subi	r30, 0x70	; 112
    615a:	ff 4a       	sbci	r31, 0xAF	; 175
    615c:	a5 91       	lpm	r26, Z+
    615e:	b4 91       	lpm	r27, Z
    6160:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    6162:	df 91       	pop	r29
    6164:	cf 91       	pop	r28
    6166:	08 95       	ret

00006168 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    6168:	0f 93       	push	r16
    616a:	1f 93       	push	r17
    616c:	cf 93       	push	r28
    616e:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    6170:	c8 2f       	mov	r28, r24
    6172:	d0 e0       	ldi	r29, 0x00	; 0
    6174:	fe 01       	movw	r30, r28
    6176:	e1 54       	subi	r30, 0x41	; 65
    6178:	f7 4f       	sbci	r31, 0xF7	; 247
    617a:	90 81       	ld	r25, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    617c:	20 91 63 02 	lds	r18, 0x0263
    6180:	30 e0       	ldi	r19, 0x00	; 0
    6182:	02 c0       	rjmp	.+4      	; 0x6188 <CommErr+0x20>
    6184:	35 95       	asr	r19
    6186:	27 95       	ror	r18
    6188:	8a 95       	dec	r24
    618a:	e2 f7       	brpl	.-8      	; 0x6184 <CommErr+0x1c>
    618c:	20 fd       	sbrc	r18, 0
    618e:	1b c0       	rjmp	.+54     	; 0x61c6 <CommErr+0x5e>
    6190:	93 30       	cpi	r25, 0x03	; 3
    6192:	c8 f0       	brcs	.+50     	; 0x61c6 <CommErr+0x5e>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    6194:	2e ef       	ldi	r18, 0xFE	; 254
    6196:	29 0f       	add	r18, r25
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    6198:	7c 2f       	mov	r23, r28
    619a:	66 27       	eor	r22, r22
    619c:	66 5d       	subi	r22, 0xD6	; 214
    619e:	72 4f       	sbci	r23, 0xF2	; 242
    61a0:	fb 01       	movw	r30, r22
    61a2:	e2 0f       	add	r30, r18
    61a4:	f1 1d       	adc	r31, r1
    61a6:	00 81       	ld	r16, Z
    61a8:	11 81       	ldd	r17, Z+1	; 0x01
    61aa:	30 e0       	ldi	r19, 0x00	; 0
    61ac:	40 e0       	ldi	r20, 0x00	; 0
    61ae:	50 e0       	ldi	r21, 0x00	; 0
    61b0:	85 e9       	ldi	r24, 0x95	; 149
    61b2:	98 e2       	ldi	r25, 0x28	; 40
    61b4:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
    61b8:	21 e0       	ldi	r18, 0x01	; 1
    61ba:	08 17       	cp	r16, r24
    61bc:	19 07       	cpc	r17, r25
    61be:	09 f4       	brne	.+2      	; 0x61c2 <CommErr+0x5a>
    61c0:	20 e0       	ldi	r18, 0x00	; 0
    61c2:	12 2f       	mov	r17, r18
    61c4:	01 c0       	rjmp	.+2      	; 0x61c8 <CommErr+0x60>
    61c6:	11 e0       	ldi	r17, 0x01	; 1
    61c8:	fe 01       	movw	r30, r28
    61ca:	54 e0       	ldi	r21, 0x04	; 4
    61cc:	ee 0f       	add	r30, r30
    61ce:	ff 1f       	adc	r31, r31
    61d0:	5a 95       	dec	r21
    61d2:	e1 f7       	brne	.-8      	; 0x61cc <CommErr+0x64>
	if (Err) {
		MB_CPT[MB_N][1]++;
    61d4:	e4 5f       	subi	r30, 0xF4	; 244
    61d6:	f4 4f       	sbci	r31, 0xF4	; 244
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
	if (Err) {
    61d8:	11 23       	and	r17, r17
    61da:	79 f0       	breq	.+30     	; 0x61fa <CommErr+0x92>
		MB_CPT[MB_N][1]++;
    61dc:	22 81       	ldd	r18, Z+2	; 0x02
    61de:	33 81       	ldd	r19, Z+3	; 0x03
    61e0:	2f 5f       	subi	r18, 0xFF	; 255
    61e2:	3f 4f       	sbci	r19, 0xFF	; 255
    61e4:	33 83       	std	Z+3, r19	; 0x03
    61e6:	22 83       	std	Z+2, r18	; 0x02
		USART_Func(MB_N, LED_Err_On);
    61e8:	84 e1       	ldi	r24, 0x14	; 20
    61ea:	8c 9f       	mul	r24, r28
    61ec:	f0 01       	movw	r30, r0
    61ee:	8d 9f       	mul	r24, r29
    61f0:	f0 0d       	add	r31, r0
    61f2:	11 24       	eor	r1, r1
    61f4:	e4 55       	subi	r30, 0x54	; 84
    61f6:	ff 4a       	sbci	r31, 0xAF	; 175
    61f8:	0e c0       	rjmp	.+28     	; 0x6216 <CommErr+0xae>
	}
	else {
		MB_CPT[MB_N][0]++;
    61fa:	20 81       	ld	r18, Z
    61fc:	31 81       	ldd	r19, Z+1	; 0x01
    61fe:	2f 5f       	subi	r18, 0xFF	; 255
    6200:	3f 4f       	sbci	r19, 0xFF	; 255
    6202:	31 83       	std	Z+1, r19	; 0x01
    6204:	20 83       	st	Z, r18
		USART_Func(MB_N, LED_Err_Off);
    6206:	84 e1       	ldi	r24, 0x14	; 20
    6208:	8c 9f       	mul	r24, r28
    620a:	f0 01       	movw	r30, r0
    620c:	8d 9f       	mul	r24, r29
    620e:	f0 0d       	add	r31, r0
    6210:	11 24       	eor	r1, r1
    6212:	e2 55       	subi	r30, 0x52	; 82
    6214:	ff 4a       	sbci	r31, 0xAF	; 175
    6216:	25 91       	lpm	r18, Z+
    6218:	34 91       	lpm	r19, Z
    621a:	f9 01       	movw	r30, r18
    621c:	09 95       	icall
	}
	return Err;
}
    621e:	81 2f       	mov	r24, r17
    6220:	df 91       	pop	r29
    6222:	cf 91       	pop	r28
    6224:	1f 91       	pop	r17
    6226:	0f 91       	pop	r16
    6228:	08 95       	ret

0000622a <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    622a:	cf 93       	push	r28
    622c:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    622e:	68 2f       	mov	r22, r24
    6230:	70 e0       	ldi	r23, 0x00	; 0
    6232:	fb 01       	movw	r30, r22
    6234:	e1 54       	subi	r30, 0x41	; 65
    6236:	f7 4f       	sbci	r31, 0xF7	; 247
    6238:	20 81       	ld	r18, Z
    623a:	22 50       	subi	r18, 0x02	; 2
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    623c:	76 2f       	mov	r23, r22
    623e:	66 27       	eor	r22, r22
    6240:	66 5d       	subi	r22, 0xD6	; 214
    6242:	72 4f       	sbci	r23, 0xF2	; 242
    6244:	eb 01       	movw	r28, r22
    6246:	c2 0f       	add	r28, r18
    6248:	d1 1d       	adc	r29, r1
    624a:	30 e0       	ldi	r19, 0x00	; 0
    624c:	40 e0       	ldi	r20, 0x00	; 0
    624e:	50 e0       	ldi	r21, 0x00	; 0
    6250:	85 e9       	ldi	r24, 0x95	; 149
    6252:	98 e2       	ldi	r25, 0x28	; 40
    6254:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
    6258:	99 83       	std	Y+1, r25	; 0x01
    625a:	88 83       	st	Y, r24
}
    625c:	df 91       	pop	r29
    625e:	cf 91       	pop	r28
    6260:	08 95       	ret

00006262 <FormData>:
}

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    6262:	bf 92       	push	r11
    6264:	cf 92       	push	r12
    6266:	df 92       	push	r13
    6268:	ef 92       	push	r14
    626a:	ff 92       	push	r15
    626c:	0f 93       	push	r16
    626e:	1f 93       	push	r17
    6270:	cf 93       	push	r28
    6272:	df 93       	push	r29
    6274:	b8 2e       	mov	r11, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    6276:	c8 2f       	mov	r28, r24
    6278:	d0 e0       	ldi	r29, 0x00	; 0
    627a:	dc 2e       	mov	r13, r28
    627c:	cc 24       	eor	r12, r12
    627e:	86 01       	movw	r16, r12
    6280:	06 5d       	subi	r16, 0xD6	; 214
    6282:	12 4f       	sbci	r17, 0xF2	; 242
    6284:	f8 01       	movw	r30, r16
    6286:	81 81       	ldd	r24, Z+1	; 0x01
    6288:	86 30       	cpi	r24, 0x06	; 6
    628a:	f1 f0       	breq	.+60     	; 0x62c8 <FormData+0x66>
    628c:	48 f4       	brcc	.+18     	; 0x62a0 <FormData+0x3e>
    628e:	81 50       	subi	r24, 0x01	; 1
    6290:	84 30       	cpi	r24, 0x04	; 4
    6292:	08 f0       	brcs	.+2      	; 0x6296 <FormData+0x34>
    6294:	c9 c0       	rjmp	.+402    	; 0x6428 <FormData+0x1c6>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    6296:	c1 54       	subi	r28, 0x41	; 65
    6298:	d7 4f       	sbci	r29, 0xF7	; 247
    629a:	88 e0       	ldi	r24, 0x08	; 8
    629c:	88 83       	st	Y, r24
		break;
    629e:	c4 c0       	rjmp	.+392    	; 0x6428 <FormData+0x1c6>
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    62a0:	8f 30       	cpi	r24, 0x0F	; 15
    62a2:	11 f1       	breq	.+68     	; 0x62e8 <FormData+0x86>
    62a4:	80 31       	cpi	r24, 0x10	; 16
    62a6:	09 f0       	breq	.+2      	; 0x62aa <FormData+0x48>
    62a8:	bf c0       	rjmp	.+382    	; 0x6428 <FormData+0x1c6>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    62aa:	f8 01       	movw	r30, r16
    62ac:	85 81       	ldd	r24, Z+5	; 0x05
    62ae:	88 0f       	add	r24, r24
    62b0:	86 83       	std	Z+6, r24	; 0x06
    62b2:	c1 54       	subi	r28, 0x41	; 65
    62b4:	d7 4f       	sbci	r29, 0xF7	; 247
    62b6:	87 5f       	subi	r24, 0xF7	; 247
    62b8:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    62ba:	8b 2d       	mov	r24, r11
    62bc:	0e 94 85 29 	call	0x530a	; 0x530a <GetReg>
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    62c0:	20 e0       	ldi	r18, 0x00	; 0
    62c2:	e8 01       	movw	r28, r16
    62c4:	25 96       	adiw	r28, 0x05	; 5
    62c6:	9a c0       	rjmp	.+308    	; 0x63fc <FormData+0x19a>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    62c8:	c1 54       	subi	r28, 0x41	; 65
    62ca:	d7 4f       	sbci	r29, 0xF7	; 247
    62cc:	88 e0       	ldi	r24, 0x08	; 8
    62ce:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    62d0:	8b 2d       	mov	r24, r11
    62d2:	0e 94 85 29 	call	0x530a	; 0x530a <GetReg>
		MB_Frame[MB_N][4] = *Reg>>8;
    62d6:	fc 01       	movw	r30, r24
    62d8:	21 81       	ldd	r18, Z+1	; 0x01
    62da:	f8 01       	movw	r30, r16
    62dc:	24 83       	std	Z+4, r18	; 0x04
		MB_Frame[MB_N][5] = *Reg;
    62de:	fc 01       	movw	r30, r24
    62e0:	80 81       	ld	r24, Z
    62e2:	f8 01       	movw	r30, r16
    62e4:	85 83       	std	Z+5, r24	; 0x05
		break;
    62e6:	a0 c0       	rjmp	.+320    	; 0x6428 <FormData+0x1c6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    62e8:	f8 01       	movw	r30, r16
    62ea:	e4 80       	ldd	r14, Z+4	; 0x04
    62ec:	f1 2c       	mov	r15, r1
    62ee:	fe 2c       	mov	r15, r14
    62f0:	ee 24       	eor	r14, r14
    62f2:	85 81       	ldd	r24, Z+5	; 0x05
    62f4:	e8 2a       	or	r14, r24
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    62f6:	c7 01       	movw	r24, r14
    62f8:	13 e0       	ldi	r17, 0x03	; 3
    62fa:	96 95       	lsr	r25
    62fc:	87 95       	ror	r24
    62fe:	1a 95       	dec	r17
    6300:	e1 f7       	brne	.-8      	; 0x62fa <FormData+0x98>
    6302:	97 01       	movw	r18, r14
    6304:	27 70       	andi	r18, 0x07	; 7
    6306:	33 27       	eor	r19, r19
    6308:	41 e0       	ldi	r20, 0x01	; 1
    630a:	23 2b       	or	r18, r19
    630c:	09 f4       	brne	.+2      	; 0x6310 <FormData+0xae>
    630e:	40 e0       	ldi	r20, 0x00	; 0
    6310:	24 2f       	mov	r18, r20
    6312:	28 0f       	add	r18, r24
    6314:	f6 01       	movw	r30, r12
    6316:	e6 5d       	subi	r30, 0xD6	; 214
    6318:	f2 4f       	sbci	r31, 0xF2	; 242
    631a:	26 83       	std	Z+6, r18	; 0x06
    631c:	de 01       	movw	r26, r28
    631e:	a1 54       	subi	r26, 0x41	; 65
    6320:	b7 4f       	sbci	r27, 0xF7	; 247
    6322:	27 5f       	subi	r18, 0xF7	; 247
    6324:	2c 93       	st	X, r18
		MB_Frame[MB_N][7+Qt/8] = 0;
    6326:	e8 0f       	add	r30, r24
    6328:	f9 1f       	adc	r31, r25
    632a:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    632c:	fe 01       	movw	r30, r28
    632e:	ec 5e       	subi	r30, 0xEC	; 236
    6330:	f9 4f       	sbci	r31, 0xF9	; 249
    6332:	80 81       	ld	r24, Z
    6334:	82 30       	cpi	r24, 0x02	; 2
    6336:	f9 f0       	breq	.+62     	; 0x6376 <FormData+0x114>
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6338:	fe 01       	movw	r30, r28
    633a:	a4 e0       	ldi	r26, 0x04	; 4
    633c:	ee 0f       	add	r30, r30
    633e:	ff 1f       	adc	r31, r31
    6340:	aa 95       	dec	r26
    6342:	e1 f7       	brne	.-8      	; 0x633c <FormData+0xda>
    6344:	e5 53       	subi	r30, 0x35	; 53
    6346:	ff 4a       	sbci	r31, 0xAF	; 175
    6348:	05 91       	lpm	r16, Z+
    634a:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    634c:	8b 2d       	mov	r24, r11
    634e:	0e 94 3f 29 	call	0x527e	; 0x527e <GetSlave>
    6352:	01 96       	adiw	r24, 0x01	; 1
    6354:	fc 01       	movw	r30, r24
    6356:	85 91       	lpm	r24, Z+
    6358:	94 91       	lpm	r25, Z
    635a:	c1 50       	subi	r28, 0x01	; 1
    635c:	da 4f       	sbci	r29, 0xFA	; 250
    635e:	28 81       	ld	r18, Y
    6360:	fc 01       	movw	r30, r24
    6362:	37 e0       	ldi	r19, 0x07	; 7
    6364:	23 9f       	mul	r18, r19
    6366:	e0 0d       	add	r30, r0
    6368:	f1 1d       	adc	r31, r1
    636a:	11 24       	eor	r1, r1
		MB_Frame[MB_N][7+Qt/8] = 0;
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    636c:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    636e:	85 91       	lpm	r24, Z+
    6370:	94 91       	lpm	r25, Z
    6372:	78 2f       	mov	r23, r24
    6374:	0a c0       	rjmp	.+20     	; 0x638a <FormData+0x128>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    6376:	f3 e0       	ldi	r31, 0x03	; 3
    6378:	cc 0f       	add	r28, r28
    637a:	dd 1f       	adc	r29, r29
    637c:	fa 95       	dec	r31
    637e:	e1 f7       	brne	.-8      	; 0x6378 <FormData+0x116>
    6380:	c5 5a       	subi	r28, 0xA5	; 165
    6382:	dd 4f       	sbci	r29, 0xFD	; 253
    6384:	0e 81       	ldd	r16, Y+6	; 0x06
    6386:	1f 81       	ldd	r17, Y+7	; 0x07
			Pin = 0;
    6388:	70 e0       	ldi	r23, 0x00	; 0
		}
		for (uint8_t i=0; i<Qt; i++) {
    638a:	60 e0       	ldi	r22, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    638c:	41 e0       	ldi	r20, 0x01	; 1
    638e:	50 e0       	ldi	r21, 0x00	; 0
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6390:	26 2f       	mov	r18, r22
    6392:	30 e0       	ldi	r19, 0x00	; 0
    6394:	2e 15       	cp	r18, r14
    6396:	3f 05       	cpc	r19, r15
    6398:	08 f0       	brcs	.+2      	; 0x639c <FormData+0x13a>
    639a:	46 c0       	rjmp	.+140    	; 0x6428 <FormData+0x1c6>
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    639c:	e6 2f       	mov	r30, r22
    639e:	e6 95       	lsr	r30
    63a0:	e6 95       	lsr	r30
    63a2:	e6 95       	lsr	r30
    63a4:	e9 5f       	subi	r30, 0xF9	; 249
    63a6:	86 2f       	mov	r24, r22
    63a8:	87 70       	andi	r24, 0x07	; 7
    63aa:	9a 01       	movw	r18, r20
    63ac:	02 c0       	rjmp	.+4      	; 0x63b2 <FormData+0x150>
    63ae:	22 0f       	add	r18, r18
    63b0:	33 1f       	adc	r19, r19
    63b2:	8a 95       	dec	r24
    63b4:	e2 f7       	brpl	.-8      	; 0x63ae <FormData+0x14c>
    63b6:	c9 01       	movw	r24, r18
			if (Discr[j/8] &(1<<j%8))
    63b8:	f6 2f       	mov	r31, r22
    63ba:	f7 0f       	add	r31, r23
    63bc:	2f 2f       	mov	r18, r31
    63be:	26 95       	lsr	r18
    63c0:	26 95       	lsr	r18
    63c2:	26 95       	lsr	r18
    63c4:	d8 01       	movw	r26, r16
    63c6:	a2 0f       	add	r26, r18
    63c8:	b1 1d       	adc	r27, r1
    63ca:	2c 91       	ld	r18, X
    63cc:	30 e0       	ldi	r19, 0x00	; 0
    63ce:	f7 70       	andi	r31, 0x07	; 7
    63d0:	02 c0       	rjmp	.+4      	; 0x63d6 <FormData+0x174>
    63d2:	35 95       	asr	r19
    63d4:	27 95       	ror	r18
    63d6:	fa 95       	dec	r31
    63d8:	e2 f7       	brpl	.-8      	; 0x63d2 <FormData+0x170>
    63da:	f0 e0       	ldi	r31, 0x00	; 0
				MB_Frame[MB_N][Byte] |=Bit;
    63dc:	ec 0d       	add	r30, r12
    63de:	fd 1d       	adc	r31, r13
    63e0:	e6 5d       	subi	r30, 0xD6	; 214
    63e2:	f2 4f       	sbci	r31, 0xF2	; 242
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
			if (Discr[j/8] &(1<<j%8))
    63e4:	20 ff       	sbrs	r18, 0
    63e6:	04 c0       	rjmp	.+8      	; 0x63f0 <FormData+0x18e>
				MB_Frame[MB_N][Byte] |=Bit;
    63e8:	90 81       	ld	r25, Z
    63ea:	98 2b       	or	r25, r24
    63ec:	90 83       	st	Z, r25
    63ee:	04 c0       	rjmp	.+8      	; 0x63f8 <FormData+0x196>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    63f0:	80 95       	com	r24
    63f2:	90 81       	ld	r25, Z
    63f4:	89 23       	and	r24, r25
    63f6:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    63f8:	6f 5f       	subi	r22, 0xFF	; 255
    63fa:	ca cf       	rjmp	.-108    	; 0x6390 <FormData+0x12e>
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    63fc:	38 81       	ld	r19, Y
    63fe:	23 17       	cp	r18, r19
    6400:	98 f4       	brcc	.+38     	; 0x6428 <FormData+0x1c6>
			uint8_t j = i*2;
    6402:	32 2f       	mov	r19, r18
    6404:	33 0f       	add	r19, r19
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6406:	fc 01       	movw	r30, r24
    6408:	e2 0f       	add	r30, r18
    640a:	f1 1d       	adc	r31, r1
    640c:	e2 0f       	add	r30, r18
    640e:	f1 1d       	adc	r31, r1
    6410:	d8 01       	movw	r26, r16
    6412:	a3 0f       	add	r26, r19
    6414:	b1 1d       	adc	r27, r1
    6416:	31 81       	ldd	r19, Z+1	; 0x01
    6418:	17 96       	adiw	r26, 0x07	; 7
    641a:	3c 93       	st	X, r19
    641c:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    641e:	30 81       	ld	r19, Z
    6420:	18 96       	adiw	r26, 0x08	; 8
    6422:	3c 93       	st	X, r19
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6424:	2f 5f       	subi	r18, 0xFF	; 255
    6426:	ea cf       	rjmp	.-44     	; 0x63fc <FormData+0x19a>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6428:	8b 2d       	mov	r24, r11
}
    642a:	df 91       	pop	r29
    642c:	cf 91       	pop	r28
    642e:	1f 91       	pop	r17
    6430:	0f 91       	pop	r16
    6432:	ff 90       	pop	r15
    6434:	ef 90       	pop	r14
    6436:	df 90       	pop	r13
    6438:	cf 90       	pop	r12
    643a:	bf 90       	pop	r11
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    643c:	0c 94 15 31 	jmp	0x622a	; 0x622a <SetCRC_MB>

00006440 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    6440:	cf 93       	push	r28
    6442:	c8 2f       	mov	r28, r24
	MB_Slave *Slave = GetSlave(MB_N);
    6444:	0e 94 3f 29 	call	0x527e	; 0x527e <GetSlave>
    6448:	bc 01       	movw	r22, r24
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    644a:	fc 01       	movw	r30, r24
    644c:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    644e:	45 91       	lpm	r20, Z+
    6450:	54 91       	lpm	r21, Z
    6452:	2c 2f       	mov	r18, r28
    6454:	30 e0       	ldi	r19, 0x00	; 0
    6456:	f9 01       	movw	r30, r18
    6458:	e1 50       	subi	r30, 0x01	; 1
    645a:	fa 4f       	sbci	r31, 0xFA	; 250
    645c:	80 81       	ld	r24, Z
    645e:	97 e0       	ldi	r25, 0x07	; 7
    6460:	89 9f       	mul	r24, r25
    6462:	40 0d       	add	r20, r0
    6464:	51 1d       	adc	r21, r1
    6466:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6468:	fb 01       	movw	r30, r22
    646a:	64 91       	lpm	r22, Z

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    646c:	b2 2f       	mov	r27, r18
    646e:	aa 27       	eor	r26, r26
    6470:	a6 5d       	subi	r26, 0xD6	; 214
    6472:	b2 4f       	sbci	r27, 0xF2	; 242
    6474:	6c 93       	st	X, r22
    6476:	fa 01       	movw	r30, r20
    6478:	84 91       	lpm	r24, Z
	MB_Frame[MB_N][1] = prb(&Query->Func);
    647a:	f2 2f       	mov	r31, r18
    647c:	ee 27       	eor	r30, r30
    647e:	e6 5d       	subi	r30, 0xD6	; 214
    6480:	f2 4f       	sbci	r31, 0xF2	; 242
    6482:	81 83       	std	Z+1, r24	; 0x01
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    6484:	fa 01       	movw	r30, r20
    6486:	32 96       	adiw	r30, 0x02	; 2
    6488:	e4 91       	lpm	r30, Z
    648a:	b2 2f       	mov	r27, r18
    648c:	aa 27       	eor	r26, r26
    648e:	a6 5d       	subi	r26, 0xD6	; 214
    6490:	b2 4f       	sbci	r27, 0xF2	; 242
    6492:	12 96       	adiw	r26, 0x02	; 2
    6494:	ec 93       	st	X, r30
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6496:	fa 01       	movw	r30, r20
    6498:	31 96       	adiw	r30, 0x01	; 1
    649a:	e4 91       	lpm	r30, Z
    649c:	b2 2f       	mov	r27, r18
    649e:	aa 27       	eor	r26, r26
    64a0:	a6 5d       	subi	r26, 0xD6	; 214
    64a2:	b2 4f       	sbci	r27, 0xF2	; 242
    64a4:	13 96       	adiw	r26, 0x03	; 3
    64a6:	ec 93       	st	X, r30
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    64a8:	fa 01       	movw	r30, r20
    64aa:	34 96       	adiw	r30, 0x04	; 4
    64ac:	e4 91       	lpm	r30, Z
    64ae:	b2 2f       	mov	r27, r18
    64b0:	aa 27       	eor	r26, r26
    64b2:	a6 5d       	subi	r26, 0xD6	; 214
    64b4:	b2 4f       	sbci	r27, 0xF2	; 242
    64b6:	14 96       	adiw	r26, 0x04	; 4
    64b8:	ec 93       	st	X, r30
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    64ba:	fa 01       	movw	r30, r20
    64bc:	33 96       	adiw	r30, 0x03	; 3
    64be:	44 91       	lpm	r20, Z
    64c0:	b2 2f       	mov	r27, r18
    64c2:	aa 27       	eor	r26, r26
    64c4:	a6 5d       	subi	r26, 0xD6	; 214
    64c6:	b2 4f       	sbci	r27, 0xF2	; 242
    64c8:	15 96       	adiw	r26, 0x05	; 5
    64ca:	4c 93       	st	X, r20

	FormData(MB_N);
    64cc:	8c 2f       	mov	r24, r28
}
    64ce:	cf 91       	pop	r28
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);

	FormData(MB_N);
    64d0:	0c 94 31 31 	jmp	0x6262	; 0x6262 <FormData>

000064d4 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    64d4:	28 2f       	mov	r18, r24
    64d6:	30 e0       	ldi	r19, 0x00	; 0
    64d8:	f2 2f       	mov	r31, r18
    64da:	ee 27       	eor	r30, r30
    64dc:	e6 5d       	subi	r30, 0xD6	; 214
    64de:	f2 4f       	sbci	r31, 0xF2	; 242
    64e0:	d9 01       	movw	r26, r18
    64e2:	93 e0       	ldi	r25, 0x03	; 3
    64e4:	aa 0f       	add	r26, r26
    64e6:	bb 1f       	adc	r27, r27
    64e8:	9a 95       	dec	r25
    64ea:	e1 f7       	brne	.-8      	; 0x64e4 <FormSingle+0x10>
    64ec:	a5 5a       	subi	r26, 0xA5	; 165
    64ee:	bd 4f       	sbci	r27, 0xFD	; 253
    64f0:	9c 91       	ld	r25, X
    64f2:	90 83       	st	Z, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    64f4:	11 96       	adiw	r26, 0x01	; 1
    64f6:	9c 91       	ld	r25, X
    64f8:	11 97       	sbiw	r26, 0x01	; 1
    64fa:	91 83       	std	Z+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    64fc:	12 96       	adiw	r26, 0x02	; 2
    64fe:	9c 91       	ld	r25, X
    6500:	12 97       	sbiw	r26, 0x02	; 2
    6502:	13 96       	adiw	r26, 0x03	; 3
    6504:	4c 91       	ld	r20, X
    6506:	13 97       	sbiw	r26, 0x03	; 3
    6508:	42 83       	std	Z+2, r20	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    650a:	93 83       	std	Z+3, r25	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    650c:	14 96       	adiw	r26, 0x04	; 4
    650e:	9c 91       	ld	r25, X
    6510:	14 97       	sbiw	r26, 0x04	; 4
    6512:	15 96       	adiw	r26, 0x05	; 5
    6514:	4c 91       	ld	r20, X
    6516:	44 83       	std	Z+4, r20	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6518:	95 83       	std	Z+5, r25	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    651a:	f9 01       	movw	r30, r18
    651c:	ec 5e       	subi	r30, 0xEC	; 236
    651e:	f9 4f       	sbci	r31, 0xF9	; 249
    6520:	92 e0       	ldi	r25, 0x02	; 2
    6522:	90 83       	st	Z, r25
	FormData(MB_N);
    6524:	0c 94 31 31 	jmp	0x6262	; 0x6262 <FormData>

00006528 <MB_FrameReg>:
    6528:	e8 2f       	mov	r30, r24
    652a:	f0 e0       	ldi	r31, 0x00	; 0
    652c:	70 e0       	ldi	r23, 0x00	; 0
    652e:	fe 2f       	mov	r31, r30
    6530:	ee 27       	eor	r30, r30
    6532:	df 01       	movw	r26, r30
    6534:	a6 5d       	subi	r26, 0xD6	; 214
    6536:	b2 4f       	sbci	r27, 0xF2	; 242
    6538:	a6 0f       	add	r26, r22
    653a:	b7 1f       	adc	r27, r23
    653c:	11 96       	adiw	r26, 0x01	; 1
    653e:	8c 91       	ld	r24, X
    6540:	e6 0f       	add	r30, r22
    6542:	f7 1f       	adc	r31, r23
    6544:	e6 5d       	subi	r30, 0xD6	; 214
    6546:	f2 4f       	sbci	r31, 0xF2	; 242
    6548:	20 81       	ld	r18, Z
    654a:	90 e0       	ldi	r25, 0x00	; 0
}
    654c:	92 2b       	or	r25, r18
    654e:	08 95       	ret

00006550 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    6550:	2f 92       	push	r2
    6552:	3f 92       	push	r3
    6554:	4f 92       	push	r4
    6556:	5f 92       	push	r5
    6558:	6f 92       	push	r6
    655a:	7f 92       	push	r7
    655c:	8f 92       	push	r8
    655e:	9f 92       	push	r9
    6560:	af 92       	push	r10
    6562:	bf 92       	push	r11
    6564:	cf 92       	push	r12
    6566:	df 92       	push	r13
    6568:	ef 92       	push	r14
    656a:	ff 92       	push	r15
    656c:	0f 93       	push	r16
    656e:	1f 93       	push	r17
    6570:	cf 93       	push	r28
    6572:	df 93       	push	r29
    6574:	00 d0       	rcall	.+0      	; 0x6576 <MB_S_Timer_ISR+0x26>
    6576:	00 d0       	rcall	.+0      	; 0x6578 <MB_S_Timer_ISR+0x28>
    6578:	1f 92       	push	r1
    657a:	cd b7       	in	r28, 0x3d	; 61
    657c:	de b7       	in	r29, 0x3e	; 62
    657e:	78 2e       	mov	r7, r24
	switch (MB_State[MB_N]) {
    6580:	c8 2e       	mov	r12, r24
    6582:	d1 2c       	mov	r13, r1
    6584:	96 01       	movw	r18, r12
    6586:	27 52       	subi	r18, 0x27	; 39
    6588:	3c 4f       	sbci	r19, 0xFC	; 252
    658a:	59 01       	movw	r10, r18
    658c:	d9 01       	movw	r26, r18
    658e:	8c 91       	ld	r24, X
    6590:	88 23       	and	r24, r24
    6592:	59 f0       	breq	.+22     	; 0x65aa <MB_S_Timer_ISR+0x5a>
    6594:	82 30       	cpi	r24, 0x02	; 2
    6596:	09 f0       	breq	.+2      	; 0x659a <MB_S_Timer_ISR+0x4a>
    6598:	aa c2       	rjmp	.+1364   	; 0x6aee <MB_S_Timer_ISR+0x59e>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    659a:	84 e0       	ldi	r24, 0x04	; 4
    659c:	d9 01       	movw	r26, r18
    659e:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    65a0:	87 2d       	mov	r24, r7
    65a2:	0e 94 b4 30 	call	0x6168	; 0x6168 <CommErr>
    65a6:	88 23       	and	r24, r24
    65a8:	21 f0       	breq	.+8      	; 0x65b2 <MB_S_Timer_ISR+0x62>
		MB_State[MB_N] = MB_Idle;
    65aa:	81 e0       	ldi	r24, 0x01	; 1
    65ac:	f5 01       	movw	r30, r10
    65ae:	80 83       	st	Z, r24
    65b0:	9e c2       	rjmp	.+1340   	; 0x6aee <MB_S_Timer_ISR+0x59e>
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    65b2:	3c 2d       	mov	r19, r12
    65b4:	22 27       	eor	r18, r18
    65b6:	3d 83       	std	Y+5, r19	; 0x05
    65b8:	2c 83       	std	Y+4, r18	; 0x04
    65ba:	f9 01       	movw	r30, r18
    65bc:	e6 5d       	subi	r30, 0xD6	; 214
    65be:	f2 4f       	sbci	r31, 0xF2	; 242
    65c0:	80 81       	ld	r24, Z
    65c2:	88 23       	and	r24, r24
    65c4:	51 f0       	breq	.+20     	; 0x65da <MB_S_Timer_ISR+0x8a>
    65c6:	f6 01       	movw	r30, r12
    65c8:	e0 51       	subi	r30, 0x10	; 16
    65ca:	fc 4f       	sbci	r31, 0xFC	; 252
    65cc:	90 81       	ld	r25, Z
    65ce:	89 17       	cp	r24, r25
    65d0:	21 f0       	breq	.+8      	; 0x65da <MB_S_Timer_ISR+0x8a>
		MB_State[MB_N] = MB_Idle;
    65d2:	81 e0       	ldi	r24, 0x01	; 1
    65d4:	d5 01       	movw	r26, r10
    65d6:	8c 93       	st	X, r24
    65d8:	8a c2       	rjmp	.+1300   	; 0x6aee <MB_S_Timer_ISR+0x59e>
		return;
	}
	USART_Func(MB_N, LED);
    65da:	84 e1       	ldi	r24, 0x14	; 20
    65dc:	8c 9d       	mul	r24, r12
    65de:	40 01       	movw	r8, r0
    65e0:	8d 9d       	mul	r24, r13
    65e2:	90 0c       	add	r9, r0
    65e4:	11 24       	eor	r1, r1
    65e6:	f4 01       	movw	r30, r8
    65e8:	e6 55       	subi	r30, 0x56	; 86
    65ea:	ff 4a       	sbci	r31, 0xAF	; 175
    65ec:	4f 01       	movw	r8, r30

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    65ee:	25 91       	lpm	r18, Z+
    65f0:	34 91       	lpm	r19, Z
    65f2:	f9 01       	movw	r30, r18
    65f4:	09 95       	icall
	MB_CPT[MB_N][3]++;
    65f6:	86 01       	movw	r16, r12
    65f8:	e4 e0       	ldi	r30, 0x04	; 4
    65fa:	00 0f       	add	r16, r16
    65fc:	11 1f       	adc	r17, r17
    65fe:	ea 95       	dec	r30
    6600:	e1 f7       	brne	.-8      	; 0x65fa <MB_S_Timer_ISR+0xaa>
    6602:	f8 01       	movw	r30, r16
    6604:	e4 5f       	subi	r30, 0xF4	; 244
    6606:	f4 4f       	sbci	r31, 0xF4	; 244
    6608:	86 81       	ldd	r24, Z+6	; 0x06
    660a:	97 81       	ldd	r25, Z+7	; 0x07
    660c:	01 96       	adiw	r24, 0x01	; 1
    660e:	97 83       	std	Z+7, r25	; 0x07
    6610:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6612:	ec 81       	ldd	r30, Y+4	; 0x04
    6614:	fd 81       	ldd	r31, Y+5	; 0x05
    6616:	e6 5d       	subi	r30, 0xD6	; 214
    6618:	f2 4f       	sbci	r31, 0xF2	; 242
    661a:	e2 80       	ldd	r14, Z+2	; 0x02
    661c:	f1 2c       	mov	r15, r1
    661e:	fe 2c       	mov	r15, r14
    6620:	ee 24       	eor	r14, r14
    6622:	83 81       	ldd	r24, Z+3	; 0x03
    6624:	e8 2a       	or	r14, r24
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6626:	61 81       	ldd	r22, Z+1	; 0x01
    6628:	86 2f       	mov	r24, r22
    662a:	90 e0       	ldi	r25, 0x00	; 0
    662c:	fc 01       	movw	r30, r24
    662e:	31 97       	sbiw	r30, 0x01	; 1
    6630:	e0 31       	cpi	r30, 0x10	; 16
    6632:	f1 05       	cpc	r31, r1
    6634:	08 f0       	brcs	.+2      	; 0x6638 <MB_S_Timer_ISR+0xe8>
    6636:	ec c1       	rjmp	.+984    	; 0x6a10 <MB_S_Timer_ISR+0x4c0>
    6638:	ea 5b       	subi	r30, 0xBA	; 186
    663a:	ff 4f       	sbci	r31, 0xFF	; 255
    663c:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6640:	ec 81       	ldd	r30, Y+4	; 0x04
    6642:	fd 81       	ldd	r31, Y+5	; 0x05
    6644:	e6 5d       	subi	r30, 0xD6	; 214
    6646:	f2 4f       	sbci	r31, 0xF2	; 242
    6648:	80 81       	ld	r24, Z
    664a:	88 23       	and	r24, r24
    664c:	09 f4       	brne	.+2      	; 0x6650 <MB_S_Timer_ISR+0x100>
    664e:	dd c0       	rjmp	.+442    	; 0x680a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    6650:	d6 01       	movw	r26, r12
    6652:	a1 54       	subi	r26, 0x41	; 65
    6654:	b7 4f       	sbci	r27, 0xF7	; 247
    6656:	8c 91       	ld	r24, X
    6658:	88 30       	cpi	r24, 0x08	; 8
    665a:	09 f0       	breq	.+2      	; 0x665e <MB_S_Timer_ISR+0x10e>
    665c:	8c c0       	rjmp	.+280    	; 0x6776 <MB_S_Timer_ISR+0x226>
    665e:	24 81       	ldd	r18, Z+4	; 0x04
    6660:	30 e0       	ldi	r19, 0x00	; 0
    6662:	32 2f       	mov	r19, r18
    6664:	22 27       	eor	r18, r18
    6666:	85 81       	ldd	r24, Z+5	; 0x05
    6668:	28 2b       	or	r18, r24
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    666a:	a9 01       	movw	r20, r18
    666c:	4e 0d       	add	r20, r14
    666e:	5f 1d       	adc	r21, r15
    6670:	f8 01       	movw	r30, r16
    6672:	61 30       	cpi	r22, 0x01	; 1
    6674:	61 f4       	brne	.+24     	; 0x668e <MB_S_Timer_ISR+0x13e>
    6676:	e3 53       	subi	r30, 0x33	; 51
    6678:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    667a:	85 91       	lpm	r24, Z+
    667c:	94 91       	lpm	r25, Z
    667e:	84 17       	cp	r24, r20
    6680:	95 07       	cpc	r25, r21
    6682:	08 f4       	brcc	.+2      	; 0x6686 <MB_S_Timer_ISR+0x136>
    6684:	96 c1       	rjmp	.+812    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6686:	f8 01       	movw	r30, r16
    6688:	e5 53       	subi	r30, 0x35	; 53
    668a:	ff 4a       	sbci	r31, 0xAF	; 175
    668c:	0b c0       	rjmp	.+22     	; 0x66a4 <MB_S_Timer_ISR+0x154>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    668e:	ef 52       	subi	r30, 0x2F	; 47
    6690:	ff 4a       	sbci	r31, 0xAF	; 175
    6692:	85 91       	lpm	r24, Z+
    6694:	94 91       	lpm	r25, Z
    6696:	84 17       	cp	r24, r20
    6698:	95 07       	cpc	r25, r21
    669a:	08 f4       	brcc	.+2      	; 0x669e <MB_S_Timer_ISR+0x14e>
    669c:	8a c1       	rjmp	.+788    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    669e:	f8 01       	movw	r30, r16
    66a0:	e1 53       	subi	r30, 0x31	; 49
    66a2:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    66a4:	65 91       	lpm	r22, Z+
    66a6:	74 91       	lpm	r23, Z
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    66a8:	e1 e0       	ldi	r30, 0x01	; 1
    66aa:	a9 01       	movw	r20, r18
    66ac:	47 70       	andi	r20, 0x07	; 7
    66ae:	55 27       	eor	r21, r21
    66b0:	45 2b       	or	r20, r21
    66b2:	09 f4       	brne	.+2      	; 0x66b6 <MB_S_Timer_ISR+0x166>
    66b4:	e0 e0       	ldi	r30, 0x00	; 0
    66b6:	c9 01       	movw	r24, r18
    66b8:	43 e0       	ldi	r20, 0x03	; 3
    66ba:	96 95       	lsr	r25
    66bc:	87 95       	ror	r24
    66be:	4a 95       	dec	r20
    66c0:	e1 f7       	brne	.-8      	; 0x66ba <MB_S_Timer_ISR+0x16a>
    66c2:	8e 0f       	add	r24, r30
    66c4:	ec 81       	ldd	r30, Y+4	; 0x04
    66c6:	fd 81       	ldd	r31, Y+5	; 0x05
    66c8:	e6 5d       	subi	r30, 0xD6	; 214
    66ca:	f2 4f       	sbci	r31, 0xF2	; 242
    66cc:	82 83       	std	Z+2, r24	; 0x02
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    66ce:	8b 5f       	subi	r24, 0xFB	; 251
    66d0:	8c 93       	st	X, r24
	for (uint8_t i=0; i<Qt; i++) {
    66d2:	a0 e0       	ldi	r26, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    66d4:	22 24       	eor	r2, r2
    66d6:	23 94       	inc	r2
    66d8:	31 2c       	mov	r3, r1
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    66da:	4a 2f       	mov	r20, r26
    66dc:	50 e0       	ldi	r21, 0x00	; 0
    66de:	42 17       	cp	r20, r18
    66e0:	53 07       	cpc	r21, r19
    66e2:	08 f0       	brcs	.+2      	; 0x66e6 <MB_S_Timer_ISR+0x196>
    66e4:	93 c1       	rjmp	.+806    	; 0x6a0c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    66e6:	4e 0d       	add	r20, r14
    66e8:	5f 1d       	adc	r21, r15
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    66ea:	ba 2f       	mov	r27, r26
    66ec:	b6 95       	lsr	r27
    66ee:	b6 95       	lsr	r27
    66f0:	b6 95       	lsr	r27
    66f2:	bd 5f       	subi	r27, 0xFD	; 253
    66f4:	8a 2f       	mov	r24, r26
    66f6:	87 70       	andi	r24, 0x07	; 7
    66f8:	21 01       	movw	r4, r2
    66fa:	01 c0       	rjmp	.+2      	; 0x66fe <MB_S_Timer_ISR+0x1ae>
    66fc:	44 0c       	add	r4, r4
    66fe:	8a 95       	dec	r24
    6700:	ea f7       	brpl	.-6      	; 0x66fc <MB_S_Timer_ISR+0x1ac>
		if (Discr[j/8] &(1<<j%8))
    6702:	fa 01       	movw	r30, r20
    6704:	83 e0       	ldi	r24, 0x03	; 3
    6706:	f6 95       	lsr	r31
    6708:	e7 95       	ror	r30
    670a:	8a 95       	dec	r24
    670c:	e1 f7       	brne	.-8      	; 0x6706 <MB_S_Timer_ISR+0x1b6>
    670e:	e6 0f       	add	r30, r22
    6710:	f7 1f       	adc	r31, r23
    6712:	80 81       	ld	r24, Z
    6714:	90 e0       	ldi	r25, 0x00	; 0
    6716:	47 70       	andi	r20, 0x07	; 7
    6718:	55 27       	eor	r21, r21
    671a:	02 c0       	rjmp	.+4      	; 0x6720 <MB_S_Timer_ISR+0x1d0>
    671c:	95 95       	asr	r25
    671e:	87 95       	ror	r24
    6720:	4a 95       	dec	r20
    6722:	e2 f7       	brpl	.-8      	; 0x671c <MB_S_Timer_ISR+0x1cc>
    6724:	eb 2f       	mov	r30, r27
    6726:	f0 e0       	ldi	r31, 0x00	; 0
    6728:	80 ff       	sbrs	r24, 0
    672a:	0a c0       	rjmp	.+20     	; 0x6740 <MB_S_Timer_ISR+0x1f0>
			MB_Frame[MB_N][Byte] |=Bit;
    672c:	8c 81       	ldd	r24, Y+4	; 0x04
    672e:	9d 81       	ldd	r25, Y+5	; 0x05
    6730:	e8 0f       	add	r30, r24
    6732:	f9 1f       	adc	r31, r25
    6734:	e6 5d       	subi	r30, 0xD6	; 214
    6736:	f2 4f       	sbci	r31, 0xF2	; 242
    6738:	80 81       	ld	r24, Z
    673a:	84 29       	or	r24, r4
    673c:	80 83       	st	Z, r24
    673e:	0a c0       	rjmp	.+20     	; 0x6754 <MB_S_Timer_ISR+0x204>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    6740:	8c 81       	ldd	r24, Y+4	; 0x04
    6742:	9d 81       	ldd	r25, Y+5	; 0x05
    6744:	e8 0f       	add	r30, r24
    6746:	f9 1f       	adc	r31, r25
    6748:	e6 5d       	subi	r30, 0xD6	; 214
    674a:	f2 4f       	sbci	r31, 0xF2	; 242
    674c:	40 94       	com	r4
    674e:	80 81       	ld	r24, Z
    6750:	48 22       	and	r4, r24
    6752:	40 82       	st	Z, r4
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    6754:	af 5f       	subi	r26, 0xFF	; 255
    6756:	c1 cf       	rjmp	.-126    	; 0x66da <MB_S_Timer_ISR+0x18a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6758:	ec 81       	ldd	r30, Y+4	; 0x04
    675a:	fd 81       	ldd	r31, Y+5	; 0x05
    675c:	e6 5d       	subi	r30, 0xD6	; 214
    675e:	f2 4f       	sbci	r31, 0xF2	; 242
    6760:	80 81       	ld	r24, Z
    6762:	88 23       	and	r24, r24
    6764:	09 f4       	brne	.+2      	; 0x6768 <MB_S_Timer_ISR+0x218>
    6766:	51 c0       	rjmp	.+162    	; 0x680a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    6768:	96 01       	movw	r18, r12
    676a:	21 54       	subi	r18, 0x41	; 65
    676c:	37 4f       	sbci	r19, 0xF7	; 247
    676e:	d9 01       	movw	r26, r18
    6770:	8c 91       	ld	r24, X
    6772:	88 30       	cpi	r24, 0x08	; 8
    6774:	11 f0       	breq	.+4      	; 0x677a <MB_S_Timer_ISR+0x22a>
		return MB_Frame[MB_N][2]=IllegData;
    6776:	83 e0       	ldi	r24, 0x03	; 3
    6778:	0f c1       	rjmp	.+542    	; 0x6998 <MB_S_Timer_ISR+0x448>
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    677a:	75 81       	ldd	r23, Z+5	; 0x05
    677c:	c7 01       	movw	r24, r14
    677e:	87 0f       	add	r24, r23
    6780:	91 1d       	adc	r25, r1
    6782:	f8 01       	movw	r30, r16
    6784:	63 30       	cpi	r22, 0x03	; 3
    6786:	61 f4       	brne	.+24     	; 0x67a0 <MB_S_Timer_ISR+0x250>
    6788:	eb 52       	subi	r30, 0x2B	; 43
    678a:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    678c:	45 91       	lpm	r20, Z+
    678e:	54 91       	lpm	r21, Z
    6790:	48 17       	cp	r20, r24
    6792:	59 07       	cpc	r21, r25
    6794:	08 f4       	brcc	.+2      	; 0x6798 <MB_S_Timer_ISR+0x248>
    6796:	0d c1       	rjmp	.+538    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6798:	f8 01       	movw	r30, r16
    679a:	ed 52       	subi	r30, 0x2D	; 45
    679c:	ff 4a       	sbci	r31, 0xAF	; 175
    679e:	0b c0       	rjmp	.+22     	; 0x67b6 <MB_S_Timer_ISR+0x266>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    67a0:	e7 52       	subi	r30, 0x27	; 39
    67a2:	ff 4a       	sbci	r31, 0xAF	; 175
    67a4:	45 91       	lpm	r20, Z+
    67a6:	54 91       	lpm	r21, Z
    67a8:	48 17       	cp	r20, r24
    67aa:	59 07       	cpc	r21, r25
    67ac:	08 f4       	brcc	.+2      	; 0x67b0 <MB_S_Timer_ISR+0x260>
    67ae:	01 c1       	rjmp	.+514    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    67b0:	f8 01       	movw	r30, r16
    67b2:	e9 52       	subi	r30, 0x29	; 41
    67b4:	ff 4a       	sbci	r31, 0xAF	; 175
    67b6:	85 91       	lpm	r24, Z+
    67b8:	94 91       	lpm	r25, Z
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    67ba:	77 0f       	add	r23, r23
    67bc:	ac 81       	ldd	r26, Y+4	; 0x04
    67be:	bd 81       	ldd	r27, Y+5	; 0x05
    67c0:	a6 5d       	subi	r26, 0xD6	; 214
    67c2:	b2 4f       	sbci	r27, 0xF2	; 242
    67c4:	12 96       	adiw	r26, 0x02	; 2
    67c6:	7c 93       	st	X, r23
    67c8:	12 97       	sbiw	r26, 0x02	; 2
    67ca:	7b 5f       	subi	r23, 0xFB	; 251
    67cc:	f9 01       	movw	r30, r18
    67ce:	70 83       	st	Z, r23
	uint8_t Qt = MB_Frame[MB_N][5];
    67d0:	15 96       	adiw	r26, 0x05	; 5
    67d2:	5c 91       	ld	r21, X
    67d4:	15 97       	sbiw	r26, 0x05	; 5
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    67d6:	f7 01       	movw	r30, r14
    67d8:	ee 0f       	add	r30, r30
    67da:	ff 1f       	adc	r31, r31
    67dc:	e8 0f       	add	r30, r24
    67de:	f9 1f       	adc	r31, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    67e0:	40 e0       	ldi	r20, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    67e2:	cd 01       	movw	r24, r26
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    67e4:	45 17       	cp	r20, r21
    67e6:	09 f4       	brne	.+2      	; 0x67ea <MB_S_Timer_ISR+0x29a>
    67e8:	11 c1       	rjmp	.+546    	; 0x6a0c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
    67ea:	64 2f       	mov	r22, r20
    67ec:	66 0f       	add	r22, r22
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    67ee:	7c 01       	movw	r14, r24
    67f0:	e6 0e       	add	r14, r22
    67f2:	f1 1c       	adc	r15, r1
    67f4:	61 81       	ldd	r22, Z+1	; 0x01
    67f6:	d7 01       	movw	r26, r14
    67f8:	13 96       	adiw	r26, 0x03	; 3
    67fa:	6c 93       	st	X, r22
		MB_Frame[MB_N][4+j] = Reg[i];
    67fc:	20 81       	ld	r18, Z
    67fe:	32 96       	adiw	r30, 0x02	; 2
    6800:	d7 01       	movw	r26, r14
    6802:	14 96       	adiw	r26, 0x04	; 4
    6804:	2c 93       	st	X, r18
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6806:	4f 5f       	subi	r20, 0xFF	; 255
    6808:	ed cf       	rjmp	.-38     	; 0x67e4 <MB_S_Timer_ISR+0x294>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
    680a:	9f ef       	ldi	r25, 0xFF	; 255
    680c:	08 c1       	rjmp	.+528    	; 0x6a1e <MB_S_Timer_ISR+0x4ce>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    680e:	d6 01       	movw	r26, r12
    6810:	a1 54       	subi	r26, 0x41	; 65
    6812:	b7 4f       	sbci	r27, 0xF7	; 247
    6814:	8c 91       	ld	r24, X
    6816:	88 30       	cpi	r24, 0x08	; 8
    6818:	09 f0       	breq	.+2      	; 0x681c <MB_S_Timer_ISR+0x2cc>
    681a:	b9 c0       	rjmp	.+370    	; 0x698e <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    681c:	f8 01       	movw	r30, r16
    681e:	eb 52       	subi	r30, 0x2B	; 43
    6820:	ff 4a       	sbci	r31, 0xAF	; 175
    6822:	85 91       	lpm	r24, Z+
    6824:	94 91       	lpm	r25, Z
    6826:	97 01       	movw	r18, r14
    6828:	2f 5f       	subi	r18, 0xFF	; 255
    682a:	3f 4f       	sbci	r19, 0xFF	; 255
    682c:	82 17       	cp	r24, r18
    682e:	93 07       	cpc	r25, r19
    6830:	08 f4       	brcc	.+2      	; 0x6834 <MB_S_Timer_ISR+0x2e4>
    6832:	bf c0       	rjmp	.+382    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    6834:	88 e0       	ldi	r24, 0x08	; 8
    6836:	8c 93       	st	X, r24
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    6838:	f8 01       	movw	r30, r16
    683a:	ed 52       	subi	r30, 0x2D	; 45
    683c:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    683e:	85 91       	lpm	r24, Z+
    6840:	94 91       	lpm	r25, Z
    6842:	f7 01       	movw	r30, r14
    6844:	ee 0f       	add	r30, r30
    6846:	ff 1f       	adc	r31, r31
    6848:	e8 0f       	add	r30, r24
    684a:	f9 1f       	adc	r31, r25
    684c:	ac 81       	ldd	r26, Y+4	; 0x04
    684e:	bd 81       	ldd	r27, Y+5	; 0x05
    6850:	a6 5d       	subi	r26, 0xD6	; 214
    6852:	b2 4f       	sbci	r27, 0xF2	; 242
    6854:	14 96       	adiw	r26, 0x04	; 4
    6856:	8c 91       	ld	r24, X
    6858:	14 97       	sbiw	r26, 0x04	; 4
    685a:	90 e0       	ldi	r25, 0x00	; 0
    685c:	98 2f       	mov	r25, r24
    685e:	88 27       	eor	r24, r24
    6860:	15 96       	adiw	r26, 0x05	; 5
    6862:	2c 91       	ld	r18, X
    6864:	82 2b       	or	r24, r18
    6866:	91 83       	std	Z+1, r25	; 0x01
    6868:	80 83       	st	Z, r24
    686a:	d0 c0       	rjmp	.+416    	; 0x6a0c <MB_S_Timer_ISR+0x4bc>
    686c:	ec 81       	ldd	r30, Y+4	; 0x04
    686e:	fd 81       	ldd	r31, Y+5	; 0x05
    6870:	e6 5d       	subi	r30, 0xD6	; 214
    6872:	f2 4f       	sbci	r31, 0xF2	; 242
    6874:	64 80       	ldd	r6, Z+4	; 0x04
    6876:	85 81       	ldd	r24, Z+5	; 0x05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    6878:	66 81       	ldd	r22, Z+6	; 0x06
    687a:	d6 01       	movw	r26, r12
    687c:	a1 54       	subi	r26, 0x41	; 65
    687e:	b7 4f       	sbci	r27, 0xF7	; 247
    6880:	4c 91       	ld	r20, X
    6882:	50 e0       	ldi	r21, 0x00	; 0
    6884:	70 e0       	ldi	r23, 0x00	; 0
    6886:	9b 01       	movw	r18, r22
    6888:	27 5f       	subi	r18, 0xF7	; 247
    688a:	3f 4f       	sbci	r19, 0xFF	; 255
    688c:	42 17       	cp	r20, r18
    688e:	53 07       	cpc	r21, r19
    6890:	09 f0       	breq	.+2      	; 0x6894 <MB_S_Timer_ISR+0x344>
    6892:	7d c0       	rjmp	.+250    	; 0x698e <MB_S_Timer_ISR+0x43e>
    6894:	90 e0       	ldi	r25, 0x00	; 0
    6896:	96 29       	or	r25, r6
    6898:	9c 01       	movw	r18, r24
    689a:	27 70       	andi	r18, 0x07	; 7
    689c:	33 27       	eor	r19, r19
    689e:	41 e0       	ldi	r20, 0x01	; 1
    68a0:	50 e0       	ldi	r21, 0x00	; 0
    68a2:	23 2b       	or	r18, r19
    68a4:	11 f4       	brne	.+4      	; 0x68aa <MB_S_Timer_ISR+0x35a>
    68a6:	40 e0       	ldi	r20, 0x00	; 0
    68a8:	50 e0       	ldi	r21, 0x00	; 0
    68aa:	9c 01       	movw	r18, r24
    68ac:	e3 e0       	ldi	r30, 0x03	; 3
    68ae:	36 95       	lsr	r19
    68b0:	27 95       	ror	r18
    68b2:	ea 95       	dec	r30
    68b4:	e1 f7       	brne	.-8      	; 0x68ae <MB_S_Timer_ISR+0x35e>
    68b6:	24 0f       	add	r18, r20
    68b8:	35 1f       	adc	r19, r21
    68ba:	26 17       	cp	r18, r22
    68bc:	37 07       	cpc	r19, r23
    68be:	09 f0       	breq	.+2      	; 0x68c2 <MB_S_Timer_ISR+0x372>
    68c0:	66 c0       	rjmp	.+204    	; 0x698e <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    68c2:	f8 01       	movw	r30, r16
    68c4:	e3 53       	subi	r30, 0x33	; 51
    68c6:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68c8:	25 91       	lpm	r18, Z+
    68ca:	34 91       	lpm	r19, Z
    68cc:	ac 01       	movw	r20, r24
    68ce:	4e 0d       	add	r20, r14
    68d0:	5f 1d       	adc	r21, r15
    68d2:	24 17       	cp	r18, r20
    68d4:	35 07       	cpc	r19, r21
    68d6:	08 f4       	brcc	.+2      	; 0x68da <MB_S_Timer_ISR+0x38a>
    68d8:	6c c0       	rjmp	.+216    	; 0x69b2 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
    68da:	f8 01       	movw	r30, r16
    68dc:	e5 53       	subi	r30, 0x35	; 53
    68de:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68e0:	25 90       	lpm	r2, Z+
    68e2:	34 90       	lpm	r3, Z
	MB_Frame_Sz[MB_N] = 8;
    68e4:	28 e0       	ldi	r18, 0x08	; 8
    68e6:	2c 93       	st	X, r18
	for (uint8_t i=0; i<Qt; i++) {
    68e8:	51 2c       	mov	r5, r1
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    68ea:	6c 81       	ldd	r22, Y+4	; 0x04
    68ec:	7d 81       	ldd	r23, Y+5	; 0x05
    68ee:	66 5d       	subi	r22, 0xD6	; 214
    68f0:	72 4f       	sbci	r23, 0xF2	; 242
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    68f2:	45 2d       	mov	r20, r5
    68f4:	50 e0       	ldi	r21, 0x00	; 0
    68f6:	48 17       	cp	r20, r24
    68f8:	59 07       	cpc	r21, r25
    68fa:	08 f0       	brcs	.+2      	; 0x68fe <MB_S_Timer_ISR+0x3ae>
    68fc:	87 c0       	rjmp	.+270    	; 0x6a0c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    68fe:	4e 0d       	add	r20, r14
    6900:	5f 1d       	adc	r21, r15
		uint16_t Byte=j/8, Bit=1<<j%8;
    6902:	fa 01       	movw	r30, r20
    6904:	a3 e0       	ldi	r26, 0x03	; 3
    6906:	f6 95       	lsr	r31
    6908:	e7 95       	ror	r30
    690a:	aa 95       	dec	r26
    690c:	e1 f7       	brne	.-8      	; 0x6906 <MB_S_Timer_ISR+0x3b6>
    690e:	47 70       	andi	r20, 0x07	; 7
    6910:	55 27       	eor	r21, r21
    6912:	21 e0       	ldi	r18, 0x01	; 1
    6914:	30 e0       	ldi	r19, 0x00	; 0
    6916:	02 c0       	rjmp	.+4      	; 0x691c <MB_S_Timer_ISR+0x3cc>
    6918:	22 0f       	add	r18, r18
    691a:	33 1f       	adc	r19, r19
    691c:	4a 95       	dec	r20
    691e:	e2 f7       	brpl	.-8      	; 0x6918 <MB_S_Timer_ISR+0x3c8>
    6920:	a9 01       	movw	r20, r18
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6922:	25 2d       	mov	r18, r5
    6924:	26 95       	lsr	r18
    6926:	26 95       	lsr	r18
    6928:	26 95       	lsr	r18
    692a:	db 01       	movw	r26, r22
    692c:	a2 0f       	add	r26, r18
    692e:	b1 1d       	adc	r27, r1
    6930:	17 96       	adiw	r26, 0x07	; 7
    6932:	2c 91       	ld	r18, X
    6934:	30 e0       	ldi	r19, 0x00	; 0
    6936:	a5 2d       	mov	r26, r5
    6938:	a7 70       	andi	r26, 0x07	; 7
    693a:	02 c0       	rjmp	.+4      	; 0x6940 <MB_S_Timer_ISR+0x3f0>
    693c:	35 95       	asr	r19
    693e:	27 95       	ror	r18
    6940:	aa 95       	dec	r26
    6942:	e2 f7       	brpl	.-8      	; 0x693c <MB_S_Timer_ISR+0x3ec>
    6944:	e2 0d       	add	r30, r2
    6946:	f3 1d       	adc	r31, r3
    6948:	20 ff       	sbrs	r18, 0
    694a:	03 c0       	rjmp	.+6      	; 0x6952 <MB_S_Timer_ISR+0x402>
			Coil[Byte] |=Bit;
    694c:	20 81       	ld	r18, Z
    694e:	24 2b       	or	r18, r20
    6950:	03 c0       	rjmp	.+6      	; 0x6958 <MB_S_Timer_ISR+0x408>
		else
			Coil[Byte] &=~Bit;
    6952:	40 95       	com	r20
    6954:	20 81       	ld	r18, Z
    6956:	24 23       	and	r18, r20
    6958:	20 83       	st	Z, r18
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    695a:	53 94       	inc	r5
    695c:	ca cf       	rjmp	.-108    	; 0x68f2 <MB_S_Timer_ISR+0x3a2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    695e:	ec 81       	ldd	r30, Y+4	; 0x04
    6960:	fd 81       	ldd	r31, Y+5	; 0x05
    6962:	e6 5d       	subi	r30, 0xD6	; 214
    6964:	f2 4f       	sbci	r31, 0xF2	; 242
    6966:	46 81       	ldd	r20, Z+6	; 0x06
    6968:	50 e0       	ldi	r21, 0x00	; 0
    696a:	d6 01       	movw	r26, r12
    696c:	a1 54       	subi	r26, 0x41	; 65
    696e:	b7 4f       	sbci	r27, 0xF7	; 247
    6970:	2c 91       	ld	r18, X
    6972:	30 e0       	ldi	r19, 0x00	; 0
    6974:	ca 01       	movw	r24, r20
    6976:	09 96       	adiw	r24, 0x09	; 9
    6978:	28 17       	cp	r18, r24
    697a:	39 07       	cpc	r19, r25
    697c:	41 f4       	brne	.+16     	; 0x698e <MB_S_Timer_ISR+0x43e>
    697e:	85 81       	ldd	r24, Z+5	; 0x05
    6980:	90 e0       	ldi	r25, 0x00	; 0
    6982:	9c 01       	movw	r18, r24
    6984:	22 0f       	add	r18, r18
    6986:	33 1f       	adc	r19, r19
    6988:	24 17       	cp	r18, r20
    698a:	35 07       	cpc	r19, r21
    698c:	41 f0       	breq	.+16     	; 0x699e <MB_S_Timer_ISR+0x44e>
		return MB_Frame[MB_N][2]=IllegData;
    698e:	83 e0       	ldi	r24, 0x03	; 3
    6990:	ec 81       	ldd	r30, Y+4	; 0x04
    6992:	fd 81       	ldd	r31, Y+5	; 0x05
    6994:	e6 5d       	subi	r30, 0xD6	; 214
    6996:	f2 4f       	sbci	r31, 0xF2	; 242
    6998:	82 83       	std	Z+2, r24	; 0x02
    699a:	93 e0       	ldi	r25, 0x03	; 3
    699c:	40 c0       	rjmp	.+128    	; 0x6a1e <MB_S_Timer_ISR+0x4ce>
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    699e:	f8 01       	movw	r30, r16
    69a0:	eb 52       	subi	r30, 0x2B	; 43
    69a2:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    69a4:	25 91       	lpm	r18, Z+
    69a6:	34 91       	lpm	r19, Z
    69a8:	8e 0d       	add	r24, r14
    69aa:	9f 1d       	adc	r25, r15
    69ac:	28 17       	cp	r18, r24
    69ae:	39 07       	cpc	r19, r25
    69b0:	40 f4       	brcc	.+16     	; 0x69c2 <MB_S_Timer_ISR+0x472>
		return MB_Frame[MB_N][2]=IllegAddr;
    69b2:	82 e0       	ldi	r24, 0x02	; 2
    69b4:	ec 81       	ldd	r30, Y+4	; 0x04
    69b6:	fd 81       	ldd	r31, Y+5	; 0x05
    69b8:	e6 5d       	subi	r30, 0xD6	; 214
    69ba:	f2 4f       	sbci	r31, 0xF2	; 242
    69bc:	82 83       	std	Z+2, r24	; 0x02
    69be:	92 e0       	ldi	r25, 0x02	; 2
    69c0:	2e c0       	rjmp	.+92     	; 0x6a1e <MB_S_Timer_ISR+0x4ce>
	MB_Frame_Sz[MB_N] = 8;
    69c2:	88 e0       	ldi	r24, 0x08	; 8
    69c4:	8c 93       	st	X, r24
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    69c6:	f8 01       	movw	r30, r16
    69c8:	ed 52       	subi	r30, 0x2D	; 45
    69ca:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    69cc:	25 90       	lpm	r2, Z+
    69ce:	34 90       	lpm	r3, Z
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    69d0:	61 2c       	mov	r6, r1
    69d2:	2c 81       	ldd	r18, Y+4	; 0x04
    69d4:	3d 81       	ldd	r19, Y+5	; 0x05
    69d6:	21 5d       	subi	r18, 0xD1	; 209
    69d8:	32 4f       	sbci	r19, 0xF2	; 242
    69da:	3a 83       	std	Y+2, r19	; 0x02
    69dc:	29 83       	std	Y+1, r18	; 0x01
    69de:	e9 81       	ldd	r30, Y+1	; 0x01
    69e0:	fa 81       	ldd	r31, Y+2	; 0x02
    69e2:	80 81       	ld	r24, Z
    69e4:	68 16       	cp	r6, r24
    69e6:	90 f4       	brcc	.+36     	; 0x6a0c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    69e8:	27 01       	movw	r4, r14
    69ea:	46 0c       	add	r4, r6
    69ec:	51 1c       	adc	r5, r1
    69ee:	44 0c       	add	r4, r4
    69f0:	55 1c       	adc	r5, r5
    69f2:	42 0c       	add	r4, r2
    69f4:	53 1c       	adc	r5, r3
    69f6:	66 2d       	mov	r22, r6
    69f8:	66 0f       	add	r22, r22
    69fa:	69 5f       	subi	r22, 0xF9	; 249
    69fc:	87 2d       	mov	r24, r7
    69fe:	0e 94 94 32 	call	0x6528	; 0x6528 <MB_FrameReg>
    6a02:	d2 01       	movw	r26, r4
    6a04:	8d 93       	st	X+, r24
    6a06:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6a08:	63 94       	inc	r6
    6a0a:	e9 cf       	rjmp	.-46     	; 0x69de <MB_S_Timer_ISR+0x48e>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
	}
	return 0;
    6a0c:	90 e0       	ldi	r25, 0x00	; 0
    6a0e:	07 c0       	rjmp	.+14     	; 0x6a1e <MB_S_Timer_ISR+0x4ce>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6a10:	81 e0       	ldi	r24, 0x01	; 1
    6a12:	ec 81       	ldd	r30, Y+4	; 0x04
    6a14:	fd 81       	ldd	r31, Y+5	; 0x05
    6a16:	e6 5d       	subi	r30, 0xD6	; 214
    6a18:	f2 4f       	sbci	r31, 0xF2	; 242
    6a1a:	82 83       	std	Z+2, r24	; 0x02
    6a1c:	91 e0       	ldi	r25, 0x01	; 1
		break;
	}
	if (MB_Frame[MB_N][0]) {
    6a1e:	ec 81       	ldd	r30, Y+4	; 0x04
    6a20:	fd 81       	ldd	r31, Y+5	; 0x05
    6a22:	e6 5d       	subi	r30, 0xD6	; 214
    6a24:	f2 4f       	sbci	r31, 0xF2	; 242
    6a26:	80 81       	ld	r24, Z
    6a28:	88 23       	and	r24, r24
    6a2a:	79 f0       	breq	.+30     	; 0x6a4a <MB_S_Timer_ISR+0x4fa>
		if (Err) {
    6a2c:	99 23       	and	r25, r25
    6a2e:	41 f0       	breq	.+16     	; 0x6a40 <MB_S_Timer_ISR+0x4f0>
			MB_Frame[MB_N][1] |=(1<<7);
    6a30:	81 81       	ldd	r24, Z+1	; 0x01
    6a32:	80 68       	ori	r24, 0x80	; 128
    6a34:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    6a36:	f6 01       	movw	r30, r12
    6a38:	e1 54       	subi	r30, 0x41	; 65
    6a3a:	f7 4f       	sbci	r31, 0xF7	; 247
    6a3c:	85 e0       	ldi	r24, 0x05	; 5
    6a3e:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    6a40:	87 2d       	mov	r24, r7
    6a42:	9b 83       	std	Y+3, r25	; 0x03
    6a44:	0e 94 15 31 	call	0x622a	; 0x622a <SetCRC_MB>
    6a48:	9b 81       	ldd	r25, Y+3	; 0x03
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    6a4a:	99 23       	and	r25, r25
    6a4c:	41 f0       	breq	.+16     	; 0x6a5e <MB_S_Timer_ISR+0x50e>
		MB_CPT[MB_N][2]++;
    6a4e:	f8 01       	movw	r30, r16
    6a50:	e4 5f       	subi	r30, 0xF4	; 244
    6a52:	f4 4f       	sbci	r31, 0xF4	; 244
    6a54:	84 81       	ldd	r24, Z+4	; 0x04
    6a56:	95 81       	ldd	r25, Z+5	; 0x05
    6a58:	01 96       	adiw	r24, 0x01	; 1
    6a5a:	95 83       	std	Z+5, r25	; 0x05
    6a5c:	84 83       	std	Z+4, r24	; 0x04
	if (MB_Frame[MB_N][0])
    6a5e:	ec 81       	ldd	r30, Y+4	; 0x04
    6a60:	fd 81       	ldd	r31, Y+5	; 0x05
    6a62:	e6 5d       	subi	r30, 0xD6	; 214
    6a64:	f2 4f       	sbci	r31, 0xF2	; 242
    6a66:	80 81       	ld	r24, Z
    6a68:	88 23       	and	r24, r24
    6a6a:	d1 f0       	breq	.+52     	; 0x6aa0 <MB_S_Timer_ISR+0x550>
		MB_Transm(MB_N);
    6a6c:	87 2d       	mov	r24, r7
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a6e:	0f 90       	pop	r0
    6a70:	0f 90       	pop	r0
    6a72:	0f 90       	pop	r0
    6a74:	0f 90       	pop	r0
    6a76:	0f 90       	pop	r0
    6a78:	df 91       	pop	r29
    6a7a:	cf 91       	pop	r28
    6a7c:	1f 91       	pop	r17
    6a7e:	0f 91       	pop	r16
    6a80:	ff 90       	pop	r15
    6a82:	ef 90       	pop	r14
    6a84:	df 90       	pop	r13
    6a86:	cf 90       	pop	r12
    6a88:	bf 90       	pop	r11
    6a8a:	af 90       	pop	r10
    6a8c:	9f 90       	pop	r9
    6a8e:	8f 90       	pop	r8
    6a90:	7f 90       	pop	r7
    6a92:	6f 90       	pop	r6
    6a94:	5f 90       	pop	r5
    6a96:	4f 90       	pop	r4
    6a98:	3f 90       	pop	r3
    6a9a:	2f 90       	pop	r2
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    6a9c:	0c 94 13 30 	jmp	0x6026	; 0x6026 <MB_Transm>
	else {
		MB_CPT[MB_N][4]++;
    6aa0:	f8 01       	movw	r30, r16
    6aa2:	e4 5f       	subi	r30, 0xF4	; 244
    6aa4:	f4 4f       	sbci	r31, 0xF4	; 244
    6aa6:	80 85       	ldd	r24, Z+8	; 0x08
    6aa8:	91 85       	ldd	r25, Z+9	; 0x09
    6aaa:	01 96       	adiw	r24, 0x01	; 1
    6aac:	91 87       	std	Z+9, r25	; 0x09
    6aae:	80 87       	std	Z+8, r24	; 0x08
		MB_State[MB_N] = MB_Idle;
    6ab0:	81 e0       	ldi	r24, 0x01	; 1
    6ab2:	d5 01       	movw	r26, r10
    6ab4:	8c 93       	st	X, r24
    6ab6:	f4 01       	movw	r30, r8
    6ab8:	85 91       	lpm	r24, Z+
    6aba:	94 91       	lpm	r25, Z
		USART_Func(MB_N, LED);
    6abc:	fc 01       	movw	r30, r24
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6abe:	0f 90       	pop	r0
    6ac0:	0f 90       	pop	r0
    6ac2:	0f 90       	pop	r0
    6ac4:	0f 90       	pop	r0
    6ac6:	0f 90       	pop	r0
    6ac8:	df 91       	pop	r29
    6aca:	cf 91       	pop	r28
    6acc:	1f 91       	pop	r17
    6ace:	0f 91       	pop	r16
    6ad0:	ff 90       	pop	r15
    6ad2:	ef 90       	pop	r14
    6ad4:	df 90       	pop	r13
    6ad6:	cf 90       	pop	r12
    6ad8:	bf 90       	pop	r11
    6ada:	af 90       	pop	r10
    6adc:	9f 90       	pop	r9
    6ade:	8f 90       	pop	r8
    6ae0:	7f 90       	pop	r7
    6ae2:	6f 90       	pop	r6
    6ae4:	5f 90       	pop	r5
    6ae6:	4f 90       	pop	r4
    6ae8:	3f 90       	pop	r3
    6aea:	2f 90       	pop	r2
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
		MB_State[MB_N] = MB_Idle;
		USART_Func(MB_N, LED);
    6aec:	09 94       	ijmp
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6aee:	0f 90       	pop	r0
    6af0:	0f 90       	pop	r0
    6af2:	0f 90       	pop	r0
    6af4:	0f 90       	pop	r0
    6af6:	0f 90       	pop	r0
    6af8:	df 91       	pop	r29
    6afa:	cf 91       	pop	r28
    6afc:	1f 91       	pop	r17
    6afe:	0f 91       	pop	r16
    6b00:	ff 90       	pop	r15
    6b02:	ef 90       	pop	r14
    6b04:	df 90       	pop	r13
    6b06:	cf 90       	pop	r12
    6b08:	bf 90       	pop	r11
    6b0a:	af 90       	pop	r10
    6b0c:	9f 90       	pop	r9
    6b0e:	8f 90       	pop	r8
    6b10:	7f 90       	pop	r7
    6b12:	6f 90       	pop	r6
    6b14:	5f 90       	pop	r5
    6b16:	4f 90       	pop	r4
    6b18:	3f 90       	pop	r3
    6b1a:	2f 90       	pop	r2
    6b1c:	08 95       	ret

00006b1e <MB_S_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6b1e:	24 e1       	ldi	r18, 0x14	; 20
    6b20:	82 9f       	mul	r24, r18
    6b22:	c0 01       	movw	r24, r0
    6b24:	11 24       	eor	r1, r1
    6b26:	86 55       	subi	r24, 0x56	; 86
    6b28:	9f 4a       	sbci	r25, 0xAF	; 175
    6b2a:	fc 01       	movw	r30, r24
    6b2c:	85 91       	lpm	r24, Z+
    6b2e:	94 91       	lpm	r25, Z
    6b30:	fc 01       	movw	r30, r24
    6b32:	09 94       	ijmp

00006b34 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    6b34:	cf 93       	push	r28
    6b36:	df 93       	push	r29
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    6b38:	c8 2f       	mov	r28, r24
    6b3a:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6b3c:	ce 01       	movw	r24, r28
    6b3e:	88 57       	subi	r24, 0x78	; 120
    6b40:	9e 4f       	sbci	r25, 0xFE	; 254
    6b42:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    6b46:	c0 51       	subi	r28, 0x10	; 16
    6b48:	dc 4f       	sbci	r29, 0xFC	; 252
    6b4a:	88 83       	st	Y, r24
	#endif
}
    6b4c:	df 91       	pop	r29
    6b4e:	cf 91       	pop	r28
    6b50:	08 95       	ret

00006b52 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    6b52:	0f 93       	push	r16
    6b54:	1f 93       	push	r17
    6b56:	cf 93       	push	r28
    6b58:	df 93       	push	r29
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    6b5a:	c8 2f       	mov	r28, r24
    6b5c:	d0 e0       	ldi	r29, 0x00	; 0
    6b5e:	95 e0       	ldi	r25, 0x05	; 5
    6b60:	89 9f       	mul	r24, r25
    6b62:	80 01       	movw	r16, r0
    6b64:	11 24       	eor	r1, r1
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    6b66:	c8 01       	movw	r24, r16
    6b68:	80 58       	subi	r24, 0x80	; 128
    6b6a:	9e 4f       	sbci	r25, 0xFE	; 254
    6b6c:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    6b70:	fe 01       	movw	r30, r28
    6b72:	ee 0f       	add	r30, r30
    6b74:	ff 1f       	adc	r31, r31
    6b76:	ee 5e       	subi	r30, 0xEE	; 238
    6b78:	f9 4f       	sbci	r31, 0xF9	; 249
    6b7a:	91 83       	std	Z+1, r25	; 0x01
    6b7c:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6b7e:	c8 01       	movw	r24, r16
    6b80:	8e 57       	subi	r24, 0x7E	; 126
    6b82:	9e 4f       	sbci	r25, 0xFE	; 254
    6b84:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    6b88:	fe 01       	movw	r30, r28
    6b8a:	eb 50       	subi	r30, 0x0B	; 11
    6b8c:	f5 4f       	sbci	r31, 0xF5	; 245
    6b8e:	80 83       	st	Z, r24
    6b90:	c8 01       	movw	r24, r16
    6b92:	8d 57       	subi	r24, 0x7D	; 125
    6b94:	9e 4f       	sbci	r25, 0xFE	; 254
    6b96:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    6b9a:	fe 01       	movw	r30, r28
    6b9c:	e6 54       	subi	r30, 0x46	; 70
    6b9e:	f7 4f       	sbci	r31, 0xF7	; 247
    6ba0:	80 83       	st	Z, r24
    6ba2:	c8 01       	movw	r24, r16
    6ba4:	8c 57       	subi	r24, 0x7C	; 124
    6ba6:	9e 4f       	sbci	r25, 0xFE	; 254
    6ba8:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    6bac:	ce 51       	subi	r28, 0x1E	; 30
    6bae:	dc 4f       	sbci	r29, 0xFC	; 252
    6bb0:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    6bb2:	80 91 0a 01 	lds	r24, 0x010A
	VacantTimer16Sys += n;
    6bb6:	93 e0       	ldi	r25, 0x03	; 3
    6bb8:	98 0f       	add	r25, r24
    6bba:	90 93 0a 01 	sts	0x010A, r25

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    6bbe:	80 93 54 02 	sts	0x0254, r24
}
    6bc2:	df 91       	pop	r29
    6bc4:	cf 91       	pop	r28
    6bc6:	1f 91       	pop	r17
    6bc8:	0f 91       	pop	r16
    6bca:	08 95       	ret

00006bcc <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    6bcc:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    6bd0:	10 92 d9 03 	sts	0x03D9, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6bd4:	ee e9       	ldi	r30, 0x9E	; 158
    6bd6:	f0 e5       	ldi	r31, 0x50	; 80
    6bd8:	a5 91       	lpm	r26, Z+
    6bda:	b4 91       	lpm	r27, Z
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    6bdc:	8c ef       	ldi	r24, 0xFC	; 252
    6bde:	8c 93       	st	X, r24
    6be0:	e0 ea       	ldi	r30, 0xA0	; 160
    6be2:	f0 e5       	ldi	r31, 0x50	; 80
    6be4:	a5 91       	lpm	r26, Z+
    6be6:	b4 91       	lpm	r27, Z
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    6be8:	88 e9       	ldi	r24, 0x98	; 152
    6bea:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    6bec:	80 e0       	ldi	r24, 0x00	; 0
    6bee:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <SetParity>
		SetBAUD(MB_N);
    6bf2:	80 e0       	ldi	r24, 0x00	; 0
    6bf4:	0e 94 d0 2f 	call	0x5fa0	; 0x5fa0 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6bf8:	eb ed       	ldi	r30, 0xDB	; 219
    6bfa:	f0 e5       	ldi	r31, 0x50	; 80
    6bfc:	e4 91       	lpm	r30, Z
		switch (prb(MB_Role+MB_N)) {
    6bfe:	ee 23       	and	r30, r30
    6c00:	31 f0       	breq	.+12     	; 0x6c0e <MB_Init+0x42>
    6c02:	e1 30       	cpi	r30, 0x01	; 1
    6c04:	39 f4       	brne	.+14     	; 0x6c14 <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    6c06:	80 e0       	ldi	r24, 0x00	; 0
    6c08:	0e 94 a9 35 	call	0x6b52	; 0x6b52 <MB_M_Init>
			break;
    6c0c:	03 c0       	rjmp	.+6      	; 0x6c14 <MB_Init+0x48>
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
		case Role_Slave:
			MB_S_Init(MB_N);
    6c0e:	80 e0       	ldi	r24, 0x00	; 0
    6c10:	0e 94 9a 35 	call	0x6b34	; 0x6b34 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6c14:	e4 e9       	ldi	r30, 0x94	; 148
    6c16:	f0 e5       	ldi	r31, 0x50	; 80
    6c18:	25 91       	lpm	r18, Z+
    6c1a:	34 91       	lpm	r19, Z
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    6c1c:	f9 01       	movw	r30, r18
    6c1e:	09 94       	ijmp

00006c20 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6c20:	4f 92       	push	r4
    6c22:	5f 92       	push	r5
    6c24:	7f 92       	push	r7
    6c26:	8f 92       	push	r8
    6c28:	9f 92       	push	r9
    6c2a:	af 92       	push	r10
    6c2c:	bf 92       	push	r11
    6c2e:	cf 92       	push	r12
    6c30:	df 92       	push	r13
    6c32:	ef 92       	push	r14
    6c34:	ff 92       	push	r15
    6c36:	0f 93       	push	r16
    6c38:	1f 93       	push	r17
    6c3a:	cf 93       	push	r28
    6c3c:	df 93       	push	r29
    6c3e:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    6c40:	c8 2f       	mov	r28, r24
    6c42:	d0 e0       	ldi	r29, 0x00	; 0
    6c44:	fe 01       	movw	r30, r28
    6c46:	e7 52       	subi	r30, 0x27	; 39
    6c48:	fc 4f       	sbci	r31, 0xFC	; 252
    6c4a:	80 81       	ld	r24, Z
    6c4c:	88 23       	and	r24, r24
    6c4e:	19 f0       	breq	.+6      	; 0x6c56 <MB_M_Timer_ISR+0x36>
    6c50:	82 30       	cpi	r24, 0x02	; 2
    6c52:	f1 f0       	breq	.+60     	; 0x6c90 <MB_M_Timer_ISR+0x70>
    6c54:	85 c2       	rjmp	.+1290   	; 0x7160 <MB_M_Timer_ISR+0x540>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6c56:	80 91 54 02 	lds	r24, 0x0254
    6c5a:	8e 5f       	subi	r24, 0xFE	; 254
    6c5c:	6f ef       	ldi	r22, 0xFF	; 255
    6c5e:	7f ef       	ldi	r23, 0xFF	; 255
    6c60:	8d 0d       	add	r24, r13
    6c62:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
		FormQuery(MB_N);
    6c66:	8d 2d       	mov	r24, r13
    6c68:	0e 94 20 32 	call	0x6440	; 0x6440 <FormQuery>
		MB_Transm(MB_N);
    6c6c:	8d 2d       	mov	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6c6e:	df 91       	pop	r29
    6c70:	cf 91       	pop	r28
    6c72:	1f 91       	pop	r17
    6c74:	0f 91       	pop	r16
    6c76:	ff 90       	pop	r15
    6c78:	ef 90       	pop	r14
    6c7a:	df 90       	pop	r13
    6c7c:	cf 90       	pop	r12
    6c7e:	bf 90       	pop	r11
    6c80:	af 90       	pop	r10
    6c82:	9f 90       	pop	r9
    6c84:	8f 90       	pop	r8
    6c86:	7f 90       	pop	r7
    6c88:	5f 90       	pop	r5
    6c8a:	4f 90       	pop	r4
{
	switch (MB_State[MB_N]) {
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
    6c8c:	0c 94 13 30 	jmp	0x6026	; 0x6026 <MB_Transm>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6c90:	84 e0       	ldi	r24, 0x04	; 4
    6c92:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6c94:	9e 01       	movw	r18, r28
    6c96:	2c 5e       	subi	r18, 0xEC	; 236
    6c98:	39 4f       	sbci	r19, 0xF9	; 249
    6c9a:	79 01       	movw	r14, r18
    6c9c:	f9 01       	movw	r30, r18
    6c9e:	90 81       	ld	r25, Z
    6ca0:	81 e0       	ldi	r24, 0x01	; 1
    6ca2:	92 30       	cpi	r25, 0x02	; 2
    6ca4:	09 f0       	breq	.+2      	; 0x6ca8 <MB_M_Timer_ISR+0x88>
    6ca6:	80 e0       	ldi	r24, 0x00	; 0
    6ca8:	80 93 5a 02 	sts	0x025A, r24
	if (CommErr(MB_N))
    6cac:	8d 2d       	mov	r24, r13
    6cae:	0e 94 b4 30 	call	0x6168	; 0x6168 <CommErr>
    6cb2:	81 11       	cpse	r24, r1
    6cb4:	ed c1       	rjmp	.+986    	; 0x7090 <MB_M_Timer_ISR+0x470>
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6cb6:	84 e1       	ldi	r24, 0x14	; 20
    6cb8:	8c 9f       	mul	r24, r28
    6cba:	f0 01       	movw	r30, r0
    6cbc:	8d 9f       	mul	r24, r29
    6cbe:	f0 0d       	add	r31, r0
    6cc0:	11 24       	eor	r1, r1
    6cc2:	e6 55       	subi	r30, 0x56	; 86
    6cc4:	ff 4a       	sbci	r31, 0xAF	; 175
    6cc6:	85 91       	lpm	r24, Z+
    6cc8:	94 91       	lpm	r25, Z
    6cca:	fc 01       	movw	r30, r24
    6ccc:	09 95       	icall
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6cce:	80 91 5a 02 	lds	r24, 0x025A
    6cd2:	88 23       	and	r24, r24
    6cd4:	79 f0       	breq	.+30     	; 0x6cf4 <MB_M_Timer_ISR+0xd4>
			Addr = MB_SingleQuery[MB_N].Addr;
    6cd6:	fe 01       	movw	r30, r28
    6cd8:	63 e0       	ldi	r22, 0x03	; 3
    6cda:	ee 0f       	add	r30, r30
    6cdc:	ff 1f       	adc	r31, r31
    6cde:	6a 95       	dec	r22
    6ce0:	e1 f7       	brne	.-8      	; 0x6cda <MB_M_Timer_ISR+0xba>
    6ce2:	e5 5a       	subi	r30, 0xA5	; 165
    6ce4:	fd 4f       	sbci	r31, 0xFD	; 253
    6ce6:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6ce8:	41 81       	ldd	r20, Z+1	; 0x01
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
    6cea:	80 e0       	ldi	r24, 0x00	; 0
    6cec:	90 e0       	ldi	r25, 0x00	; 0
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
    6cee:	00 e0       	ldi	r16, 0x00	; 0
    6cf0:	10 e0       	ldi	r17, 0x00	; 0
    6cf2:	15 c0       	rjmp	.+42     	; 0x6d1e <MB_M_Timer_ISR+0xfe>
		if (LastProcSingle) {
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
    6cf4:	8d 2d       	mov	r24, r13
    6cf6:	0e 94 3f 29 	call	0x527e	; 0x527e <GetSlave>
    6cfa:	8c 01       	movw	r16, r24
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6cfc:	fc 01       	movw	r30, r24
    6cfe:	31 96       	adiw	r30, 0x01	; 1
    6d00:	85 91       	lpm	r24, Z+
    6d02:	94 91       	lpm	r25, Z
    6d04:	fe 01       	movw	r30, r28
    6d06:	e1 50       	subi	r30, 0x01	; 1
    6d08:	fa 4f       	sbci	r31, 0xFA	; 250
    6d0a:	20 81       	ld	r18, Z
    6d0c:	f7 e0       	ldi	r31, 0x07	; 7
    6d0e:	2f 9f       	mul	r18, r31
    6d10:	80 0d       	add	r24, r0
    6d12:	91 1d       	adc	r25, r1
    6d14:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6d16:	f8 01       	movw	r30, r16
    6d18:	24 91       	lpm	r18, Z
    6d1a:	fc 01       	movw	r30, r24
    6d1c:	44 91       	lpm	r20, Z
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6d1e:	bc 2f       	mov	r27, r28
    6d20:	aa 27       	eor	r26, r26
    6d22:	fd 01       	movw	r30, r26
    6d24:	e6 5d       	subi	r30, 0xD6	; 214
    6d26:	f2 4f       	sbci	r31, 0xF2	; 242
    6d28:	30 81       	ld	r19, Z
    6d2a:	32 13       	cpse	r19, r18
    6d2c:	b1 c1       	rjmp	.+866    	; 0x7090 <MB_M_Timer_ISR+0x470>
    6d2e:	c1 80       	ldd	r12, Z+1	; 0x01
    6d30:	c4 12       	cpse	r12, r20
    6d32:	ae c1       	rjmp	.+860    	; 0x7090 <MB_M_Timer_ISR+0x470>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err = 0;
			switch (Func) {
    6d34:	50 e0       	ldi	r21, 0x00	; 0
    6d36:	fa 01       	movw	r30, r20
    6d38:	31 97       	sbiw	r30, 0x01	; 1
    6d3a:	e0 31       	cpi	r30, 0x10	; 16
    6d3c:	f1 05       	cpc	r31, r1
    6d3e:	08 f0       	brcs	.+2      	; 0x6d42 <MB_M_Timer_ISR+0x122>
    6d40:	ab c1       	rjmp	.+854    	; 0x7098 <MB_M_Timer_ISR+0x478>
    6d42:	ea 5a       	subi	r30, 0xAA	; 170
    6d44:	ff 4f       	sbci	r31, 0xFF	; 255
    6d46:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6d4a:	20 91 5a 02 	lds	r18, 0x025A
    6d4e:	22 23       	and	r18, r18
    6d50:	51 f0       	breq	.+20     	; 0x6d66 <MB_M_Timer_ISR+0x146>
    6d52:	fe 01       	movw	r30, r28
    6d54:	43 e0       	ldi	r20, 0x03	; 3
    6d56:	ee 0f       	add	r30, r30
    6d58:	ff 1f       	adc	r31, r31
    6d5a:	4a 95       	dec	r20
    6d5c:	e1 f7       	brne	.-8      	; 0x6d56 <MB_M_Timer_ISR+0x136>
    6d5e:	e5 5a       	subi	r30, 0xA5	; 165
    6d60:	fd 4f       	sbci	r31, 0xFD	; 253
    6d62:	64 81       	ldd	r22, Z+4	; 0x04
    6d64:	03 c0       	rjmp	.+6      	; 0x6d6c <MB_M_Timer_ISR+0x14c>
    6d66:	fc 01       	movw	r30, r24
    6d68:	33 96       	adiw	r30, 0x03	; 3
    6d6a:	64 91       	lpm	r22, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6d6c:	fd 01       	movw	r30, r26
    6d6e:	e6 5d       	subi	r30, 0xD6	; 214
    6d70:	f2 4f       	sbci	r31, 0xF2	; 242
    6d72:	22 81       	ldd	r18, Z+2	; 0x02
    6d74:	30 e0       	ldi	r19, 0x00	; 0
    6d76:	fe 01       	movw	r30, r28
    6d78:	e1 54       	subi	r30, 0x41	; 65
    6d7a:	f7 4f       	sbci	r31, 0xF7	; 247
    6d7c:	e0 81       	ld	r30, Z
    6d7e:	f0 e0       	ldi	r31, 0x00	; 0
    6d80:	a9 01       	movw	r20, r18
    6d82:	4b 5f       	subi	r20, 0xFB	; 251
    6d84:	5f 4f       	sbci	r21, 0xFF	; 255
    6d86:	e4 17       	cp	r30, r20
    6d88:	f5 07       	cpc	r31, r21
    6d8a:	09 f0       	breq	.+2      	; 0x6d8e <MB_M_Timer_ISR+0x16e>
    6d8c:	74 c1       	rjmp	.+744    	; 0x7076 <MB_M_Timer_ISR+0x456>
    6d8e:	e6 2f       	mov	r30, r22
    6d90:	e6 95       	lsr	r30
    6d92:	e6 95       	lsr	r30
    6d94:	e6 95       	lsr	r30
    6d96:	f0 e0       	ldi	r31, 0x00	; 0
    6d98:	41 e0       	ldi	r20, 0x01	; 1
    6d9a:	50 e0       	ldi	r21, 0x00	; 0
    6d9c:	76 2f       	mov	r23, r22
    6d9e:	77 70       	andi	r23, 0x07	; 7
    6da0:	11 f4       	brne	.+4      	; 0x6da6 <MB_M_Timer_ISR+0x186>
    6da2:	40 e0       	ldi	r20, 0x00	; 0
    6da4:	50 e0       	ldi	r21, 0x00	; 0
    6da6:	4e 0f       	add	r20, r30
    6da8:	5f 1f       	adc	r21, r31
    6daa:	42 17       	cp	r20, r18
    6dac:	53 07       	cpc	r21, r19
    6dae:	09 f0       	breq	.+2      	; 0x6db2 <MB_M_Timer_ISR+0x192>
    6db0:	62 c1       	rjmp	.+708    	; 0x7076 <MB_M_Timer_ISR+0x456>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6db2:	20 91 5a 02 	lds	r18, 0x025A
		Discr = MB_SingleQuery[MB_N].Buf;
    6db6:	fe 01       	movw	r30, r28
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6db8:	22 23       	and	r18, r18
    6dba:	59 f0       	breq	.+22     	; 0x6dd2 <MB_M_Timer_ISR+0x1b2>
		Discr = MB_SingleQuery[MB_N].Buf;
    6dbc:	33 e0       	ldi	r19, 0x03	; 3
    6dbe:	ee 0f       	add	r30, r30
    6dc0:	ff 1f       	adc	r31, r31
    6dc2:	3a 95       	dec	r19
    6dc4:	e1 f7       	brne	.-8      	; 0x6dbe <MB_M_Timer_ISR+0x19e>
    6dc6:	e5 5a       	subi	r30, 0xA5	; 165
    6dc8:	fd 4f       	sbci	r31, 0xFD	; 253
    6dca:	46 81       	ldd	r20, Z+6	; 0x06
    6dcc:	57 81       	ldd	r21, Z+7	; 0x07
		Pin = 0;
    6dce:	c1 2c       	mov	r12, r1
    6dd0:	14 c0       	rjmp	.+40     	; 0x6dfa <MB_M_Timer_ISR+0x1da>
    6dd2:	24 e0       	ldi	r18, 0x04	; 4
    6dd4:	ee 0f       	add	r30, r30
    6dd6:	ff 1f       	adc	r31, r31
    6dd8:	2a 95       	dec	r18
    6dda:	e1 f7       	brne	.-8      	; 0x6dd4 <MB_M_Timer_ISR+0x1b4>
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6ddc:	21 e0       	ldi	r18, 0x01	; 1
    6dde:	c2 12       	cpse	r12, r18
    6de0:	03 c0       	rjmp	.+6      	; 0x6de8 <MB_M_Timer_ISR+0x1c8>
    6de2:	e5 53       	subi	r30, 0x35	; 53
    6de4:	ff 4a       	sbci	r31, 0xAF	; 175
    6de6:	02 c0       	rjmp	.+4      	; 0x6dec <MB_M_Timer_ISR+0x1cc>
    6de8:	e1 53       	subi	r30, 0x31	; 49
    6dea:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6dec:	45 91       	lpm	r20, Z+
    6dee:	54 91       	lpm	r21, Z
		Pin = prw(&Query->AllocAddr);
    6df0:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6df2:	fc 01       	movw	r30, r24
    6df4:	85 91       	lpm	r24, Z+
    6df6:	94 91       	lpm	r25, Z
    6df8:	c8 2e       	mov	r12, r24
	}
	for (uint16_t i=0; i<Qt; i++) {
    6dfa:	20 e0       	ldi	r18, 0x00	; 0
    6dfc:	30 e0       	ldi	r19, 0x00	; 0
    6dfe:	86 2e       	mov	r8, r22
    6e00:	91 2c       	mov	r9, r1
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6e02:	aa 24       	eor	r10, r10
    6e04:	a3 94       	inc	r10
    6e06:	b1 2c       	mov	r11, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6e08:	a6 5d       	subi	r26, 0xD6	; 214
    6e0a:	b2 4f       	sbci	r27, 0xF2	; 242
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6e0c:	28 15       	cp	r18, r8
    6e0e:	39 05       	cpc	r19, r9
    6e10:	08 f0       	brcs	.+2      	; 0x6e14 <MB_M_Timer_ISR+0x1f4>
    6e12:	42 c1       	rjmp	.+644    	; 0x7098 <MB_M_Timer_ISR+0x478>
    6e14:	ec 2d       	mov	r30, r12
    6e16:	e2 0f       	add	r30, r18
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6e18:	7e 2e       	mov	r7, r30
    6e1a:	76 94       	lsr	r7
    6e1c:	76 94       	lsr	r7
    6e1e:	76 94       	lsr	r7
    6e20:	e7 70       	andi	r30, 0x07	; 7
    6e22:	25 01       	movw	r4, r10
    6e24:	01 c0       	rjmp	.+2      	; 0x6e28 <MB_M_Timer_ISR+0x208>
    6e26:	44 0c       	add	r4, r4
    6e28:	ea 95       	dec	r30
    6e2a:	ea f7       	brpl	.-6      	; 0x6e26 <MB_M_Timer_ISR+0x206>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6e2c:	c9 01       	movw	r24, r18
    6e2e:	63 e0       	ldi	r22, 0x03	; 3
    6e30:	96 95       	lsr	r25
    6e32:	87 95       	ror	r24
    6e34:	6a 95       	dec	r22
    6e36:	e1 f7       	brne	.-8      	; 0x6e30 <MB_M_Timer_ISR+0x210>
    6e38:	8a 0f       	add	r24, r26
    6e3a:	9b 1f       	adc	r25, r27
    6e3c:	fc 01       	movw	r30, r24
    6e3e:	63 81       	ldd	r22, Z+3	; 0x03
    6e40:	70 e0       	ldi	r23, 0x00	; 0
    6e42:	c9 01       	movw	r24, r18
    6e44:	87 70       	andi	r24, 0x07	; 7
    6e46:	99 27       	eor	r25, r25
    6e48:	02 c0       	rjmp	.+4      	; 0x6e4e <MB_M_Timer_ISR+0x22e>
    6e4a:	75 95       	asr	r23
    6e4c:	67 95       	ror	r22
    6e4e:	8a 95       	dec	r24
    6e50:	e2 f7       	brpl	.-8      	; 0x6e4a <MB_M_Timer_ISR+0x22a>
    6e52:	87 2d       	mov	r24, r7
    6e54:	90 e0       	ldi	r25, 0x00	; 0
			Discr[Byte] |=Bit;
    6e56:	84 0f       	add	r24, r20
    6e58:	95 1f       	adc	r25, r21
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6e5a:	60 ff       	sbrs	r22, 0
    6e5c:	04 c0       	rjmp	.+8      	; 0x6e66 <MB_M_Timer_ISR+0x246>
			Discr[Byte] |=Bit;
    6e5e:	fc 01       	movw	r30, r24
    6e60:	60 81       	ld	r22, Z
    6e62:	64 29       	or	r22, r4
    6e64:	04 c0       	rjmp	.+8      	; 0x6e6e <MB_M_Timer_ISR+0x24e>
		else
			Discr[Byte] &=~Bit;
    6e66:	40 94       	com	r4
    6e68:	fc 01       	movw	r30, r24
    6e6a:	60 81       	ld	r22, Z
    6e6c:	64 21       	and	r22, r4
    6e6e:	60 83       	st	Z, r22
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6e70:	2f 5f       	subi	r18, 0xFF	; 255
    6e72:	3f 4f       	sbci	r19, 0xFF	; 255
    6e74:	cb cf       	rjmp	.-106    	; 0x6e0c <MB_M_Timer_ISR+0x1ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6e76:	a6 5d       	subi	r26, 0xD6	; 214
    6e78:	b2 4f       	sbci	r27, 0xF2	; 242
    6e7a:	12 96       	adiw	r26, 0x02	; 2
    6e7c:	4c 91       	ld	r20, X
    6e7e:	fe 01       	movw	r30, r28
    6e80:	e1 54       	subi	r30, 0x41	; 65
    6e82:	f7 4f       	sbci	r31, 0xF7	; 247
    6e84:	e0 81       	ld	r30, Z
    6e86:	f0 e0       	ldi	r31, 0x00	; 0
    6e88:	64 2f       	mov	r22, r20
    6e8a:	70 e0       	ldi	r23, 0x00	; 0
    6e8c:	9b 01       	movw	r18, r22
    6e8e:	2b 5f       	subi	r18, 0xFB	; 251
    6e90:	3f 4f       	sbci	r19, 0xFF	; 255
    6e92:	e2 17       	cp	r30, r18
    6e94:	f3 07       	cpc	r31, r19
    6e96:	09 f0       	breq	.+2      	; 0x6e9a <MB_M_Timer_ISR+0x27a>
    6e98:	ee c0       	rjmp	.+476    	; 0x7076 <MB_M_Timer_ISR+0x456>
    6e9a:	20 91 5a 02 	lds	r18, 0x025A
    6e9e:	22 23       	and	r18, r18
    6ea0:	59 f0       	breq	.+22     	; 0x6eb8 <MB_M_Timer_ISR+0x298>
    6ea2:	fe 01       	movw	r30, r28
    6ea4:	a3 e0       	ldi	r26, 0x03	; 3
    6ea6:	ee 0f       	add	r30, r30
    6ea8:	ff 1f       	adc	r31, r31
    6eaa:	aa 95       	dec	r26
    6eac:	e1 f7       	brne	.-8      	; 0x6ea6 <MB_M_Timer_ISR+0x286>
    6eae:	e5 5a       	subi	r30, 0xA5	; 165
    6eb0:	fd 4f       	sbci	r31, 0xFD	; 253
    6eb2:	24 81       	ldd	r18, Z+4	; 0x04
    6eb4:	35 81       	ldd	r19, Z+5	; 0x05
    6eb6:	04 c0       	rjmp	.+8      	; 0x6ec0 <MB_M_Timer_ISR+0x2a0>
    6eb8:	fc 01       	movw	r30, r24
    6eba:	33 96       	adiw	r30, 0x03	; 3
    6ebc:	25 91       	lpm	r18, Z+
    6ebe:	34 91       	lpm	r19, Z
    6ec0:	22 0f       	add	r18, r18
    6ec2:	33 1f       	adc	r19, r19
    6ec4:	26 17       	cp	r18, r22
    6ec6:	37 07       	cpc	r19, r23
    6ec8:	09 f0       	breq	.+2      	; 0x6ecc <MB_M_Timer_ISR+0x2ac>
    6eca:	d5 c0       	rjmp	.+426    	; 0x7076 <MB_M_Timer_ISR+0x456>
		return 1;
	uint16_t *Reg = LastProcSingle ?
    6ecc:	20 91 5a 02 	lds	r18, 0x025A
		MB_SingleQuery[MB_N].Buf
	:
    6ed0:	fe 01       	movw	r30, r28
    6ed2:	22 23       	and	r18, r18
    6ed4:	51 f0       	breq	.+20     	; 0x6eea <MB_M_Timer_ISR+0x2ca>
    6ed6:	33 e0       	ldi	r19, 0x03	; 3
    6ed8:	ee 0f       	add	r30, r30
    6eda:	ff 1f       	adc	r31, r31
    6edc:	3a 95       	dec	r19
    6ede:	e1 f7       	brne	.-8      	; 0x6ed8 <MB_M_Timer_ISR+0x2b8>
    6ee0:	e5 5a       	subi	r30, 0xA5	; 165
    6ee2:	fd 4f       	sbci	r31, 0xFD	; 253
    6ee4:	a6 80       	ldd	r10, Z+6	; 0x06
    6ee6:	b7 80       	ldd	r11, Z+7	; 0x07
    6ee8:	17 c0       	rjmp	.+46     	; 0x6f18 <MB_M_Timer_ISR+0x2f8>
    6eea:	24 e0       	ldi	r18, 0x04	; 4
    6eec:	ee 0f       	add	r30, r30
    6eee:	ff 1f       	adc	r31, r31
    6ef0:	2a 95       	dec	r18
    6ef2:	e1 f7       	brne	.-8      	; 0x6eec <MB_M_Timer_ISR+0x2cc>
    6ef4:	23 e0       	ldi	r18, 0x03	; 3
    6ef6:	c2 12       	cpse	r12, r18
    6ef8:	03 c0       	rjmp	.+6      	; 0x6f00 <MB_M_Timer_ISR+0x2e0>
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6efa:	ed 52       	subi	r30, 0x2D	; 45
    6efc:	ff 4a       	sbci	r31, 0xAF	; 175
    6efe:	02 c0       	rjmp	.+4      	; 0x6f04 <MB_M_Timer_ISR+0x2e4>
    6f00:	e9 52       	subi	r30, 0x29	; 41
    6f02:	ff 4a       	sbci	r31, 0xAF	; 175
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6f04:	25 91       	lpm	r18, Z+
    6f06:	34 91       	lpm	r19, Z
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6f08:	05 96       	adiw	r24, 0x05	; 5
    6f0a:	fc 01       	movw	r30, r24
    6f0c:	a5 90       	lpm	r10, Z+
    6f0e:	b4 90       	lpm	r11, Z
    6f10:	aa 0c       	add	r10, r10
    6f12:	bb 1c       	adc	r11, r11
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6f14:	a2 0e       	add	r10, r18
    6f16:	b3 1e       	adc	r11, r19
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6f18:	46 95       	lsr	r20
    6f1a:	cc 24       	eor	r12, r12
    6f1c:	ca 94       	dec	r12
    6f1e:	c4 0e       	add	r12, r20
    6f20:	74 2e       	mov	r7, r20
    6f22:	77 0c       	add	r7, r7
    6f24:	7a 94       	dec	r7
    6f26:	7a 94       	dec	r7
    6f28:	ff ef       	ldi	r31, 0xFF	; 255
    6f2a:	cf 16       	cp	r12, r31
    6f2c:	09 f4       	brne	.+2      	; 0x6f30 <MB_M_Timer_ISR+0x310>
    6f2e:	b4 c0       	rjmp	.+360    	; 0x7098 <MB_M_Timer_ISR+0x478>
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6f30:	8c 2c       	mov	r8, r12
    6f32:	88 0c       	add	r8, r8
    6f34:	99 08       	sbc	r9, r9
    6f36:	8a 0c       	add	r8, r10
    6f38:	9b 1c       	adc	r9, r11
    6f3a:	63 e0       	ldi	r22, 0x03	; 3
    6f3c:	67 0d       	add	r22, r7
    6f3e:	8d 2d       	mov	r24, r13
    6f40:	0e 94 94 32 	call	0x6528	; 0x6528 <MB_FrameReg>
    6f44:	f4 01       	movw	r30, r8
    6f46:	91 83       	std	Z+1, r25	; 0x01
    6f48:	80 83       	st	Z, r24
    6f4a:	ca 94       	dec	r12
    6f4c:	eb cf       	rjmp	.-42     	; 0x6f24 <MB_M_Timer_ISR+0x304>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6f4e:	20 91 5a 02 	lds	r18, 0x025A
    6f52:	22 23       	and	r18, r18
    6f54:	69 f0       	breq	.+26     	; 0x6f70 <MB_M_Timer_ISR+0x350>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6f56:	fe 01       	movw	r30, r28
    6f58:	83 e0       	ldi	r24, 0x03	; 3
    6f5a:	ee 0f       	add	r30, r30
    6f5c:	ff 1f       	adc	r31, r31
    6f5e:	8a 95       	dec	r24
    6f60:	e1 f7       	brne	.-8      	; 0x6f5a <MB_M_Timer_ISR+0x33a>
    6f62:	e5 5a       	subi	r30, 0xA5	; 165
    6f64:	fd 4f       	sbci	r31, 0xFD	; 253
    6f66:	22 81       	ldd	r18, Z+2	; 0x02
    6f68:	33 81       	ldd	r19, Z+3	; 0x03
		Reg = MB_SingleQuery[MB_N].Buf;
    6f6a:	66 81       	ldd	r22, Z+6	; 0x06
    6f6c:	77 81       	ldd	r23, Z+7	; 0x07
    6f6e:	17 c0       	rjmp	.+46     	; 0x6f9e <MB_M_Timer_ISR+0x37e>
	}
	else {
		StartAddr = prw(&Query->StartAddr);
    6f70:	fc 01       	movw	r30, r24
    6f72:	31 96       	adiw	r30, 0x01	; 1
    6f74:	25 91       	lpm	r18, Z+
    6f76:	34 91       	lpm	r19, Z
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6f78:	fe 01       	movw	r30, r28
    6f7a:	54 e0       	ldi	r21, 0x04	; 4
    6f7c:	ee 0f       	add	r30, r30
    6f7e:	ff 1f       	adc	r31, r31
    6f80:	5a 95       	dec	r21
    6f82:	e1 f7       	brne	.-8      	; 0x6f7c <MB_M_Timer_ISR+0x35c>
    6f84:	ed 52       	subi	r30, 0x2D	; 45
    6f86:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6f88:	45 91       	lpm	r20, Z+
    6f8a:	54 91       	lpm	r21, Z
    6f8c:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6f8e:	fc 01       	movw	r30, r24
    6f90:	85 91       	lpm	r24, Z+
    6f92:	94 91       	lpm	r25, Z
    6f94:	bc 01       	movw	r22, r24
    6f96:	66 0f       	add	r22, r22
    6f98:	77 1f       	adc	r23, r23
    6f9a:	64 0f       	add	r22, r20
    6f9c:	75 1f       	adc	r23, r21
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6f9e:	ce 01       	movw	r24, r28
    6fa0:	81 54       	subi	r24, 0x41	; 65
    6fa2:	97 4f       	sbci	r25, 0xF7	; 247
    6fa4:	fc 01       	movw	r30, r24
    6fa6:	80 81       	ld	r24, Z
    6fa8:	88 30       	cpi	r24, 0x08	; 8
    6faa:	09 f0       	breq	.+2      	; 0x6fae <MB_M_Timer_ISR+0x38e>
    6fac:	61 c0       	rjmp	.+194    	; 0x7070 <MB_M_Timer_ISR+0x450>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6fae:	a6 5d       	subi	r26, 0xD6	; 214
    6fb0:	b2 4f       	sbci	r27, 0xF2	; 242
    6fb2:	12 96       	adiw	r26, 0x02	; 2
    6fb4:	8c 91       	ld	r24, X
    6fb6:	12 97       	sbiw	r26, 0x02	; 2
    6fb8:	90 e0       	ldi	r25, 0x00	; 0
    6fba:	98 2f       	mov	r25, r24
    6fbc:	88 27       	eor	r24, r24
    6fbe:	13 96       	adiw	r26, 0x03	; 3
    6fc0:	4c 91       	ld	r20, X
    6fc2:	13 97       	sbiw	r26, 0x03	; 3
    6fc4:	84 2b       	or	r24, r20
    6fc6:	82 17       	cp	r24, r18
    6fc8:	93 07       	cpc	r25, r19
    6fca:	09 f0       	breq	.+2      	; 0x6fce <MB_M_Timer_ISR+0x3ae>
    6fcc:	51 c0       	rjmp	.+162    	; 0x7070 <MB_M_Timer_ISR+0x450>
    6fce:	14 96       	adiw	r26, 0x04	; 4
    6fd0:	8c 91       	ld	r24, X
    6fd2:	14 97       	sbiw	r26, 0x04	; 4
    6fd4:	90 e0       	ldi	r25, 0x00	; 0
    6fd6:	98 2f       	mov	r25, r24
    6fd8:	88 27       	eor	r24, r24
    6fda:	15 96       	adiw	r26, 0x05	; 5
    6fdc:	2c 91       	ld	r18, X
    6fde:	82 2b       	or	r24, r18
    6fe0:	41 e0       	ldi	r20, 0x01	; 1
    6fe2:	fb 01       	movw	r30, r22
    6fe4:	20 81       	ld	r18, Z
    6fe6:	31 81       	ldd	r19, Z+1	; 0x01
    6fe8:	82 17       	cp	r24, r18
    6fea:	93 07       	cpc	r25, r19
    6fec:	09 f4       	brne	.+2      	; 0x6ff0 <MB_M_Timer_ISR+0x3d0>
    6fee:	40 e0       	ldi	r20, 0x00	; 0
    6ff0:	84 2f       	mov	r24, r20
    6ff2:	3f c0       	rjmp	.+126    	; 0x7072 <MB_M_Timer_ISR+0x452>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6ff4:	20 91 5a 02 	lds	r18, 0x025A
    6ff8:	22 23       	and	r18, r18
    6ffa:	69 f0       	breq	.+26     	; 0x7016 <MB_M_Timer_ISR+0x3f6>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6ffc:	fe 01       	movw	r30, r28
    6ffe:	83 e0       	ldi	r24, 0x03	; 3
    7000:	ee 0f       	add	r30, r30
    7002:	ff 1f       	adc	r31, r31
    7004:	8a 95       	dec	r24
    7006:	e1 f7       	brne	.-8      	; 0x7000 <MB_M_Timer_ISR+0x3e0>
    7008:	e5 5a       	subi	r30, 0xA5	; 165
    700a:	fd 4f       	sbci	r31, 0xFD	; 253
    700c:	22 81       	ldd	r18, Z+2	; 0x02
    700e:	33 81       	ldd	r19, Z+3	; 0x03
		Qt				= MB_SingleQuery[MB_N].Qt;
    7010:	44 81       	ldd	r20, Z+4	; 0x04
    7012:	55 81       	ldd	r21, Z+5	; 0x05
    7014:	08 c0       	rjmp	.+16     	; 0x7026 <MB_M_Timer_ISR+0x406>
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
    7016:	fc 01       	movw	r30, r24
    7018:	31 96       	adiw	r30, 0x01	; 1
    701a:	25 91       	lpm	r18, Z+
    701c:	34 91       	lpm	r19, Z
		Qt				= prw(&Query->Qt);
    701e:	03 96       	adiw	r24, 0x03	; 3
    7020:	fc 01       	movw	r30, r24
    7022:	45 91       	lpm	r20, Z+
    7024:	54 91       	lpm	r21, Z
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    7026:	fe 01       	movw	r30, r28
    7028:	e1 54       	subi	r30, 0x41	; 65
    702a:	f7 4f       	sbci	r31, 0xF7	; 247
    702c:	80 81       	ld	r24, Z
    702e:	88 30       	cpi	r24, 0x08	; 8
    7030:	f9 f4       	brne	.+62     	; 0x7070 <MB_M_Timer_ISR+0x450>
    7032:	a6 5d       	subi	r26, 0xD6	; 214
    7034:	b2 4f       	sbci	r27, 0xF2	; 242
    7036:	12 96       	adiw	r26, 0x02	; 2
    7038:	8c 91       	ld	r24, X
    703a:	12 97       	sbiw	r26, 0x02	; 2
    703c:	90 e0       	ldi	r25, 0x00	; 0
    703e:	98 2f       	mov	r25, r24
    7040:	88 27       	eor	r24, r24
    7042:	13 96       	adiw	r26, 0x03	; 3
    7044:	6c 91       	ld	r22, X
    7046:	13 97       	sbiw	r26, 0x03	; 3
    7048:	86 2b       	or	r24, r22
    704a:	82 17       	cp	r24, r18
    704c:	93 07       	cpc	r25, r19
    704e:	81 f4       	brne	.+32     	; 0x7070 <MB_M_Timer_ISR+0x450>
    7050:	14 96       	adiw	r26, 0x04	; 4
    7052:	8c 91       	ld	r24, X
    7054:	14 97       	sbiw	r26, 0x04	; 4
    7056:	90 e0       	ldi	r25, 0x00	; 0
    7058:	98 2f       	mov	r25, r24
    705a:	88 27       	eor	r24, r24
    705c:	15 96       	adiw	r26, 0x05	; 5
    705e:	2c 91       	ld	r18, X
    7060:	82 2b       	or	r24, r18
    7062:	21 e0       	ldi	r18, 0x01	; 1
    7064:	84 17       	cp	r24, r20
    7066:	95 07       	cpc	r25, r21
    7068:	09 f4       	brne	.+2      	; 0x706c <MB_M_Timer_ISR+0x44c>
    706a:	20 e0       	ldi	r18, 0x00	; 0
    706c:	82 2f       	mov	r24, r18
    706e:	01 c0       	rjmp	.+2      	; 0x7072 <MB_M_Timer_ISR+0x452>
    7070:	81 e0       	ldi	r24, 0x01	; 1
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    7072:	88 23       	and	r24, r24
    7074:	89 f0       	breq	.+34     	; 0x7098 <MB_M_Timer_ISR+0x478>
				MB_CPT[MB_N][2]++;
    7076:	fe 01       	movw	r30, r28
    7078:	54 e0       	ldi	r21, 0x04	; 4
    707a:	ee 0f       	add	r30, r30
    707c:	ff 1f       	adc	r31, r31
    707e:	5a 95       	dec	r21
    7080:	e1 f7       	brne	.-8      	; 0x707a <MB_M_Timer_ISR+0x45a>
    7082:	e4 5f       	subi	r30, 0xF4	; 244
    7084:	f4 4f       	sbci	r31, 0xF4	; 244
    7086:	84 81       	ldd	r24, Z+4	; 0x04
    7088:	95 81       	ldd	r25, Z+5	; 0x05
    708a:	01 96       	adiw	r24, 0x01	; 1
    708c:	95 83       	std	Z+5, r25	; 0x05
    708e:	84 83       	std	Z+4, r24	; 0x04
				Over = FailSlave(MB_N);
    7090:	8d 2d       	mov	r24, r13
    7092:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <FailSlave>
    7096:	45 c0       	rjmp	.+138    	; 0x7122 <MB_M_Timer_ISR+0x502>
			}
			else if (LastProcSingle)
    7098:	80 91 5a 02 	lds	r24, 0x025A
    709c:	88 23       	and	r24, r24
    709e:	19 f0       	breq	.+6      	; 0x70a6 <MB_M_Timer_ISR+0x486>
				MB_SingleState[MB_N] = MB_SingleIdle;
    70a0:	f7 01       	movw	r30, r14
    70a2:	10 82       	st	Z, r1
    70a4:	47 c0       	rjmp	.+142    	; 0x7134 <MB_M_Timer_ISR+0x514>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    70a6:	7e 01       	movw	r14, r28
    70a8:	ee 0c       	add	r14, r14
    70aa:	ff 1c       	adc	r15, r15
    70ac:	ee 0c       	add	r14, r14
    70ae:	ff 1c       	adc	r15, r15
    70b0:	97 01       	movw	r18, r14
    70b2:	29 50       	subi	r18, 0x09	; 9
    70b4:	35 4f       	sbci	r19, 0xF5	; 245
    70b6:	79 01       	movw	r14, r18
    70b8:	81 e0       	ldi	r24, 0x01	; 1
    70ba:	90 e0       	ldi	r25, 0x00	; 0
    70bc:	a0 e0       	ldi	r26, 0x00	; 0
    70be:	b0 e0       	ldi	r27, 0x00	; 0
    70c0:	9e 01       	movw	r18, r28
    70c2:	27 50       	subi	r18, 0x07	; 7
    70c4:	3a 4f       	sbci	r19, 0xFA	; 250
    70c6:	f9 01       	movw	r30, r18
    70c8:	00 80       	ld	r0, Z
    70ca:	04 c0       	rjmp	.+8      	; 0x70d4 <MB_M_Timer_ISR+0x4b4>
    70cc:	88 0f       	add	r24, r24
    70ce:	99 1f       	adc	r25, r25
    70d0:	aa 1f       	adc	r26, r26
    70d2:	bb 1f       	adc	r27, r27
    70d4:	0a 94       	dec	r0
    70d6:	d2 f7       	brpl	.-12     	; 0x70cc <MB_M_Timer_ISR+0x4ac>
    70d8:	80 95       	com	r24
    70da:	90 95       	com	r25
    70dc:	a0 95       	com	r26
    70de:	b0 95       	com	r27
    70e0:	f7 01       	movw	r30, r14
    70e2:	40 81       	ld	r20, Z
    70e4:	51 81       	ldd	r21, Z+1	; 0x01
    70e6:	62 81       	ldd	r22, Z+2	; 0x02
    70e8:	73 81       	ldd	r23, Z+3	; 0x03
    70ea:	84 23       	and	r24, r20
    70ec:	95 23       	and	r25, r21
    70ee:	a6 23       	and	r26, r22
    70f0:	b7 23       	and	r27, r23
    70f2:	80 83       	st	Z, r24
    70f4:	91 83       	std	Z+1, r25	; 0x01
    70f6:	a2 83       	std	Z+2, r26	; 0x02
    70f8:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    70fa:	fe 01       	movw	r30, r28
    70fc:	e1 50       	subi	r30, 0x01	; 1
    70fe:	fa 4f       	sbci	r31, 0xFA	; 250
    7100:	80 81       	ld	r24, Z
    7102:	8f 5f       	subi	r24, 0xFF	; 255
    7104:	80 83       	st	Z, r24
    7106:	f8 01       	movw	r30, r16
    7108:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    710a:	04 91       	lpm	r16, Z
    710c:	80 13       	cpse	r24, r16
    710e:	04 c0       	rjmp	.+8      	; 0x7118 <MB_M_Timer_ISR+0x4f8>
					Over = NextSlave(MB_N);
    7110:	8d 2d       	mov	r24, r13
    7112:	0e 94 61 2b 	call	0x56c2	; 0x56c2 <NextSlave>
    7116:	01 c0       	rjmp	.+2      	; 0x711a <MB_M_Timer_ISR+0x4fa>

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
    7118:	80 e0       	ldi	r24, 0x00	; 0
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    711a:	fe 01       	movw	r30, r28
    711c:	e7 5a       	subi	r30, 0xA7	; 167
    711e:	fd 4f       	sbci	r31, 0xFD	; 253
    7120:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    7122:	88 23       	and	r24, r24
    7124:	39 f0       	breq	.+14     	; 0x7134 <MB_M_Timer_ISR+0x514>
    7126:	cc 0f       	add	r28, r28
    7128:	dd 1f       	adc	r29, r29
    712a:	ce 5e       	subi	r28, 0xEE	; 238
    712c:	d9 4f       	sbci	r29, 0xF9	; 249
    712e:	68 81       	ld	r22, Y
    7130:	79 81       	ldd	r23, Y+1	; 0x01
    7132:	02 c0       	rjmp	.+4      	; 0x7138 <MB_M_Timer_ISR+0x518>
    7134:	65 e0       	ldi	r22, 0x05	; 5
    7136:	70 e0       	ldi	r23, 0x00	; 0
    7138:	80 91 54 02 	lds	r24, 0x0254
    713c:	8d 0d       	add	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    713e:	df 91       	pop	r29
    7140:	cf 91       	pop	r28
    7142:	1f 91       	pop	r17
    7144:	0f 91       	pop	r16
    7146:	ff 90       	pop	r15
    7148:	ef 90       	pop	r14
    714a:	df 90       	pop	r13
    714c:	cf 90       	pop	r12
    714e:	bf 90       	pop	r11
    7150:	af 90       	pop	r10
    7152:	9f 90       	pop	r9
    7154:	8f 90       	pop	r8
    7156:	7f 90       	pop	r7
    7158:	5f 90       	pop	r5
    715a:	4f 90       	pop	r4
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    715c:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    7160:	df 91       	pop	r29
    7162:	cf 91       	pop	r28
    7164:	1f 91       	pop	r17
    7166:	0f 91       	pop	r16
    7168:	ff 90       	pop	r15
    716a:	ef 90       	pop	r14
    716c:	df 90       	pop	r13
    716e:	cf 90       	pop	r12
    7170:	bf 90       	pop	r11
    7172:	af 90       	pop	r10
    7174:	9f 90       	pop	r9
    7176:	8f 90       	pop	r8
    7178:	7f 90       	pop	r7
    717a:	5f 90       	pop	r5
    717c:	4f 90       	pop	r4
    717e:	08 95       	ret

00007180 <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    7180:	e8 2f       	mov	r30, r24
    7182:	f0 e0       	ldi	r31, 0x00	; 0
    7184:	eb 50       	subi	r30, 0x0B	; 11
    7186:	f5 4f       	sbci	r31, 0xF5	; 245
    7188:	60 81       	ld	r22, Z
    718a:	70 e0       	ldi	r23, 0x00	; 0
    718c:	90 91 54 02 	lds	r25, 0x0254
    7190:	89 0f       	add	r24, r25
    7192:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>

00007196 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    7196:	bf 92       	push	r11
    7198:	cf 92       	push	r12
    719a:	df 92       	push	r13
    719c:	ef 92       	push	r14
    719e:	ff 92       	push	r15
    71a0:	0f 93       	push	r16
    71a2:	1f 93       	push	r17
    71a4:	cf 93       	push	r28
    71a6:	df 93       	push	r29
    71a8:	1f 92       	push	r1
    71aa:	cd b7       	in	r28, 0x3d	; 61
    71ac:	de b7       	in	r29, 0x3e	; 62
    71ae:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    71b0:	80 e0       	ldi	r24, 0x00	; 0
    71b2:	94 e1       	ldi	r25, 0x14	; 20
    71b4:	c8 2e       	mov	r12, r24
    71b6:	d1 2c       	mov	r13, r1
    71b8:	9c 9d       	mul	r25, r12
    71ba:	f0 01       	movw	r30, r0
    71bc:	9d 9d       	mul	r25, r13
    71be:	f0 0d       	add	r31, r0
    71c0:	11 24       	eor	r1, r1
    71c2:	e4 56       	subi	r30, 0x64	; 100
    71c4:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    71c6:	25 91       	lpm	r18, Z+
    71c8:	34 91       	lpm	r19, Z
    71ca:	e8 2e       	mov	r14, r24
    71cc:	f1 2c       	mov	r15, r1
    71ce:	a2 17       	cp	r26, r18
    71d0:	b3 07       	cpc	r27, r19
    71d2:	11 f0       	breq	.+4      	; 0x71d8 <Modbus_TX+0x42>
    71d4:	8f 5f       	subi	r24, 0xFF	; 255
    71d6:	ee cf       	rjmp	.-36     	; 0x71b4 <Modbus_TX+0x1e>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    71d8:	86 01       	movw	r16, r12
    71da:	04 5c       	subi	r16, 0xC4	; 196
    71dc:	1d 4f       	sbci	r17, 0xFD	; 253
    71de:	f8 01       	movw	r30, r16
    71e0:	90 81       	ld	r25, Z
    71e2:	69 2f       	mov	r22, r25
    71e4:	70 e0       	ldi	r23, 0x00	; 0
    71e6:	a6 01       	movw	r20, r12
    71e8:	41 54       	subi	r20, 0x41	; 65
    71ea:	57 4f       	sbci	r21, 0xF7	; 247
    71ec:	fa 01       	movw	r30, r20
    71ee:	20 81       	ld	r18, Z
    71f0:	30 e0       	ldi	r19, 0x00	; 0
    71f2:	22 50       	subi	r18, 0x02	; 2
    71f4:	31 09       	sbc	r19, r1
    71f6:	62 17       	cp	r22, r18
    71f8:	73 07       	cpc	r23, r19
    71fa:	39 f5       	brne	.+78     	; 0x724a <Modbus_TX+0xb4>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    71fc:	64 e1       	ldi	r22, 0x14	; 20
    71fe:	6c 9d       	mul	r22, r12
    7200:	90 01       	movw	r18, r0
    7202:	6d 9d       	mul	r22, r13
    7204:	30 0d       	add	r19, r0
    7206:	11 24       	eor	r1, r1
    7208:	20 56       	subi	r18, 0x60	; 96
    720a:	3f 4a       	sbci	r19, 0xAF	; 175
    720c:	f9 01       	movw	r30, r18
    720e:	65 91       	lpm	r22, Z+
    7210:	74 91       	lpm	r23, Z
    7212:	fb 01       	movw	r30, r22
    7214:	b0 80       	ld	r11, Z
    7216:	fb 2d       	mov	r31, r11
    7218:	ff 7d       	andi	r31, 0xDF	; 223
    721a:	bf 2e       	mov	r11, r31
    721c:	fb 01       	movw	r30, r22
    721e:	b0 82       	st	Z, r11
    7220:	f9 01       	movw	r30, r18
    7222:	25 91       	lpm	r18, Z+
    7224:	34 91       	lpm	r19, Z
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7226:	f9 01       	movw	r30, r18
    7228:	60 81       	ld	r22, Z
    722a:	60 64       	ori	r22, 0x40	; 64
    722c:	60 83       	st	Z, r22
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    722e:	24 e1       	ldi	r18, 0x14	; 20
    7230:	2c 9d       	mul	r18, r12
    7232:	f0 01       	movw	r30, r0
    7234:	2d 9d       	mul	r18, r13
    7236:	f0 0d       	add	r31, r0
    7238:	11 24       	eor	r1, r1
    723a:	e2 56       	subi	r30, 0x62	; 98
    723c:	ff 4a       	sbci	r31, 0xAF	; 175
    723e:	25 91       	lpm	r18, Z+
    7240:	34 91       	lpm	r19, Z
    7242:	f9 01       	movw	r30, r18
    7244:	60 81       	ld	r22, Z
    7246:	60 64       	ori	r22, 0x40	; 64
    7248:	60 83       	st	Z, r22
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    724a:	9f 5f       	subi	r25, 0xFF	; 255
    724c:	f8 01       	movw	r30, r16
    724e:	90 83       	st	Z, r25
    7250:	fa 01       	movw	r30, r20
    7252:	20 81       	ld	r18, Z
    7254:	92 17       	cp	r25, r18
    7256:	48 f4       	brcc	.+18     	; 0x726a <Modbus_TX+0xd4>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    7258:	fc 2d       	mov	r31, r12
    725a:	ee 27       	eor	r30, r30
    725c:	e9 0f       	add	r30, r25
    725e:	f1 1d       	adc	r31, r1
    7260:	e6 5d       	subi	r30, 0xD6	; 214
    7262:	f2 4f       	sbci	r31, 0xF2	; 242
    7264:	80 81       	ld	r24, Z
    7266:	8c 93       	st	X, r24
		return;
    7268:	43 c0       	rjmp	.+134    	; 0x72f0 <Modbus_TX+0x15a>
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    726a:	94 e1       	ldi	r25, 0x14	; 20
    726c:	9c 9d       	mul	r25, r12
    726e:	f0 01       	movw	r30, r0
    7270:	9d 9d       	mul	r25, r13
    7272:	f0 0d       	add	r31, r0
    7274:	11 24       	eor	r1, r1
    7276:	e0 56       	subi	r30, 0x60	; 96
    7278:	ff 4a       	sbci	r31, 0xAF	; 175
    727a:	a5 91       	lpm	r26, Z+
    727c:	b4 91       	lpm	r27, Z
    727e:	9c 91       	ld	r25, X
    7280:	9f 79       	andi	r25, 0x9F	; 159
    7282:	9c 93       	st	X, r25
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    7284:	94 e1       	ldi	r25, 0x14	; 20
    7286:	9c 9d       	mul	r25, r12
    7288:	90 01       	movw	r18, r0
    728a:	9d 9d       	mul	r25, r13
    728c:	30 0d       	add	r19, r0
    728e:	11 24       	eor	r1, r1
    7290:	28 55       	subi	r18, 0x58	; 88
    7292:	3f 4a       	sbci	r19, 0xAF	; 175
    7294:	f9 01       	movw	r30, r18
    7296:	45 91       	lpm	r20, Z+
    7298:	54 91       	lpm	r21, Z
    729a:	89 83       	std	Y+1, r24	; 0x01
    729c:	fa 01       	movw	r30, r20
    729e:	09 95       	icall
	Count[MB_N] = 0;
    72a0:	d8 01       	movw	r26, r16
    72a2:	1c 92       	st	X, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    72a4:	f6 01       	movw	r30, r12
    72a6:	e7 52       	subi	r30, 0x27	; 39
    72a8:	fc 4f       	sbci	r31, 0xFC	; 252
    72aa:	91 e0       	ldi	r25, 0x01	; 1
    72ac:	90 83       	st	Z, r25
	switch (prb(MB_Role+MB_N)) {
    72ae:	f7 01       	movw	r30, r14
    72b0:	e5 52       	subi	r30, 0x25	; 37
    72b2:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    72b4:	e4 91       	lpm	r30, Z
    72b6:	89 81       	ldd	r24, Y+1	; 0x01
    72b8:	ee 23       	and	r30, r30
    72ba:	71 f0       	breq	.+28     	; 0x72d8 <Modbus_TX+0x142>
    72bc:	e1 30       	cpi	r30, 0x01	; 1
    72be:	c1 f4       	brne	.+48     	; 0x72f0 <Modbus_TX+0x15a>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    72c0:	0f 90       	pop	r0
    72c2:	df 91       	pop	r29
    72c4:	cf 91       	pop	r28
    72c6:	1f 91       	pop	r17
    72c8:	0f 91       	pop	r16
    72ca:	ff 90       	pop	r15
    72cc:	ef 90       	pop	r14
    72ce:	df 90       	pop	r13
    72d0:	cf 90       	pop	r12
    72d2:	bf 90       	pop	r11
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    72d4:	0c 94 c0 38 	jmp	0x7180	; 0x7180 <MB_M_Tx>
		break;
	}
}
    72d8:	0f 90       	pop	r0
    72da:	df 91       	pop	r29
    72dc:	cf 91       	pop	r28
    72de:	1f 91       	pop	r17
    72e0:	0f 91       	pop	r16
    72e2:	ff 90       	pop	r15
    72e4:	ef 90       	pop	r14
    72e6:	df 90       	pop	r13
    72e8:	cf 90       	pop	r12
    72ea:	bf 90       	pop	r11
	Count[MB_N] = 0;
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
    72ec:	0c 94 8f 35 	jmp	0x6b1e	; 0x6b1e <MB_S_Tx>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    72f0:	0f 90       	pop	r0
    72f2:	df 91       	pop	r29
    72f4:	cf 91       	pop	r28
    72f6:	1f 91       	pop	r17
    72f8:	0f 91       	pop	r16
    72fa:	ff 90       	pop	r15
    72fc:	ef 90       	pop	r14
    72fe:	df 90       	pop	r13
    7300:	cf 90       	pop	r12
    7302:	bf 90       	pop	r11
    7304:	08 95       	ret

00007306 <MB_M_Cycle>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    7306:	1f 93       	push	r17
    7308:	cf 93       	push	r28
    730a:	df 93       	push	r29
    730c:	18 2f       	mov	r17, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    730e:	c0 91 54 02 	lds	r28, 0x0254
    7312:	c8 0f       	add	r28, r24
    7314:	81 e0       	ldi	r24, 0x01	; 1
    7316:	8c 0f       	add	r24, r28
    7318:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    731c:	88 23       	and	r24, r24
    731e:	19 f0       	breq	.+6      	; 0x7326 <MB_M_Cycle+0x20>
		SlavesOn(MB_N);
    7320:	81 2f       	mov	r24, r17
    7322:	0e 94 46 2b 	call	0x568c	; 0x568c <SlavesOn>

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    7326:	8c 2f       	mov	r24, r28
    7328:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    732c:	88 23       	and	r24, r24
    732e:	09 f4       	brne	.+2      	; 0x7332 <MB_M_Cycle+0x2c>
    7330:	4f c0       	rjmp	.+158    	; 0x73d0 <MB_M_Cycle+0xca>
		cli();
    7332:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    7334:	c1 2f       	mov	r28, r17
    7336:	d0 e0       	ldi	r29, 0x00	; 0
    7338:	fe 01       	movw	r30, r28
    733a:	e7 52       	subi	r30, 0x27	; 39
    733c:	fc 4f       	sbci	r31, 0xFC	; 252
    733e:	80 81       	ld	r24, Z
    7340:	81 30       	cpi	r24, 0x01	; 1
    7342:	11 f4       	brne	.+4      	; 0x7348 <MB_M_Cycle+0x42>
    7344:	85 e0       	ldi	r24, 0x05	; 5
    7346:	80 83       	st	Z, r24
		sei();
    7348:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    734a:	80 81       	ld	r24, Z
    734c:	84 30       	cpi	r24, 0x04	; 4
    734e:	a1 f0       	breq	.+40     	; 0x7378 <MB_M_Cycle+0x72>
    7350:	85 30       	cpi	r24, 0x05	; 5
    7352:	09 f0       	breq	.+2      	; 0x7356 <MB_M_Cycle+0x50>
    7354:	3d c0       	rjmp	.+122    	; 0x73d0 <MB_M_Cycle+0xca>
	case MB_NoReply:
		FailSlave(MB_N);
    7356:	81 2f       	mov	r24, r17
    7358:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    735c:	fe 01       	movw	r30, r28
    735e:	ec 5e       	subi	r30, 0xEC	; 236
    7360:	f9 4f       	sbci	r31, 0xF9	; 249
    7362:	80 81       	ld	r24, Z
    7364:	88 23       	and	r24, r24
    7366:	09 f1       	breq	.+66     	; 0x73aa <MB_M_Cycle+0xa4>
    7368:	81 30       	cpi	r24, 0x01	; 1
    736a:	31 f5       	brne	.+76     	; 0x73b8 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    736c:	c7 5a       	subi	r28, 0xA7	; 167
    736e:	dd 4f       	sbci	r29, 0xFD	; 253
    7370:	88 81       	ld	r24, Y
    7372:	81 11       	cpse	r24, r1
    7374:	21 c0       	rjmp	.+66     	; 0x73b8 <MB_M_Cycle+0xb2>
    7376:	1d c0       	rjmp	.+58     	; 0x73b2 <MB_M_Cycle+0xac>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    7378:	f8 94       	cli
		USART_Func(MB_N, LED);
    737a:	84 e1       	ldi	r24, 0x14	; 20
    737c:	8c 9f       	mul	r24, r28
    737e:	f0 01       	movw	r30, r0
    7380:	8d 9f       	mul	r24, r29
    7382:	f0 0d       	add	r31, r0
    7384:	11 24       	eor	r1, r1
    7386:	e6 55       	subi	r30, 0x56	; 86
    7388:	ff 4a       	sbci	r31, 0xAF	; 175

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    738a:	25 91       	lpm	r18, Z+
    738c:	34 91       	lpm	r19, Z
    738e:	f9 01       	movw	r30, r18
    7390:	09 95       	icall
		sei();
    7392:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    7394:	cc 5e       	subi	r28, 0xEC	; 236
    7396:	d9 4f       	sbci	r29, 0xF9	; 249
    7398:	88 81       	ld	r24, Y
    739a:	88 23       	and	r24, r24
    739c:	31 f0       	breq	.+12     	; 0x73aa <MB_M_Cycle+0xa4>
    739e:	81 30       	cpi	r24, 0x01	; 1
    73a0:	59 f4       	brne	.+22     	; 0x73b8 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    73a2:	80 91 5a 02 	lds	r24, 0x025A
    73a6:	88 23       	and	r24, r24
    73a8:	21 f0       	breq	.+8      	; 0x73b2 <MB_M_Cycle+0xac>
				FormQuery(MB_N);
    73aa:	81 2f       	mov	r24, r17
    73ac:	0e 94 20 32 	call	0x6440	; 0x6440 <FormQuery>
    73b0:	03 c0       	rjmp	.+6      	; 0x73b8 <MB_M_Cycle+0xb2>
			else
				FormSingle(MB_N);
    73b2:	81 2f       	mov	r24, r17
    73b4:	0e 94 6a 32 	call	0x64d4	; 0x64d4 <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    73b8:	80 91 54 02 	lds	r24, 0x0254
    73bc:	6f ef       	ldi	r22, 0xFF	; 255
    73be:	7f ef       	ldi	r23, 0xFF	; 255
    73c0:	81 0f       	add	r24, r17
    73c2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
		cli();
    73c6:	f8 94       	cli
		MB_Transm(MB_N);
    73c8:	81 2f       	mov	r24, r17
    73ca:	0e 94 13 30 	call	0x6026	; 0x6026 <MB_Transm>
		sei();
    73ce:	78 94       	sei
		break;
	}
}
    73d0:	df 91       	pop	r29
    73d2:	cf 91       	pop	r28
    73d4:	1f 91       	pop	r17
    73d6:	08 95       	ret

000073d8 <MB_Cycle>:
{
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    73d8:	80 91 f6 0a 	lds	r24, 0x0AF6
    73dc:	80 ff       	sbrs	r24, 0
    73de:	15 c0       	rjmp	.+42     	; 0x740a <MB_Cycle+0x32>
			cli();
    73e0:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    73e2:	80 91 f6 0a 	lds	r24, 0x0AF6
    73e6:	8e 7f       	andi	r24, 0xFE	; 254
    73e8:	80 93 f6 0a 	sts	0x0AF6, r24
			sei();
    73ec:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    73ee:	eb ed       	ldi	r30, 0xDB	; 219
    73f0:	f0 e5       	ldi	r31, 0x50	; 80
    73f2:	e4 91       	lpm	r30, Z
			switch (prb(MB_Role+MB_N)) {
    73f4:	ee 23       	and	r30, r30
    73f6:	31 f0       	breq	.+12     	; 0x7404 <MB_Cycle+0x2c>
    73f8:	e1 30       	cpi	r30, 0x01	; 1
    73fa:	39 f4       	brne	.+14     	; 0x740a <MB_Cycle+0x32>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    73fc:	80 e0       	ldi	r24, 0x00	; 0
    73fe:	0e 94 10 36 	call	0x6c20	; 0x6c20 <MB_M_Timer_ISR>
				break;
    7402:	03 c0       	rjmp	.+6      	; 0x740a <MB_Cycle+0x32>
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    7404:	80 e0       	ldi	r24, 0x00	; 0
    7406:	0e 94 a8 32 	call	0x6550	; 0x6550 <MB_S_Timer_ISR>
    740a:	eb ed       	ldi	r30, 0xDB	; 219
    740c:	f0 e5       	ldi	r31, 0x50	; 80
    740e:	e4 91       	lpm	r30, Z
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7410:	e1 30       	cpi	r30, 0x01	; 1
    7412:	19 f4       	brne	.+6      	; 0x741a <MB_Cycle+0x42>
			MB_M_Cycle(MB_N);
    7414:	80 e0       	ldi	r24, 0x00	; 0
    7416:	0c 94 83 39 	jmp	0x7306	; 0x7306 <MB_M_Cycle>
    741a:	08 95       	ret

0000741c <IP_compare_Const>:
	IP->IP1 = IP1;
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    741c:	0f 93       	push	r16
    741e:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7420:	80 81       	ld	r24, Z
    7422:	86 13       	cpse	r24, r22
    7424:	09 c0       	rjmp	.+18     	; 0x7438 <IP_compare_Const+0x1c>
    7426:	81 81       	ldd	r24, Z+1	; 0x01
    7428:	84 13       	cpse	r24, r20
    742a:	06 c0       	rjmp	.+12     	; 0x7438 <IP_compare_Const+0x1c>
    742c:	82 81       	ldd	r24, Z+2	; 0x02
    742e:	82 13       	cpse	r24, r18
    7430:	03 c0       	rjmp	.+6      	; 0x7438 <IP_compare_Const+0x1c>
    7432:	81 e0       	ldi	r24, 0x01	; 1
    7434:	93 81       	ldd	r25, Z+3	; 0x03
    7436:	90 13       	cpse	r25, r16
	else return 0;
    7438:	80 e0       	ldi	r24, 0x00	; 0
}
    743a:	0f 91       	pop	r16
    743c:	08 95       	ret

0000743e <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    743e:	cf 92       	push	r12
    7440:	df 92       	push	r13
    7442:	ff 92       	push	r15
    7444:	0f 93       	push	r16
    7446:	1f 93       	push	r17
    7448:	cf 93       	push	r28
    744a:	df 93       	push	r29
    744c:	1f 92       	push	r1
    744e:	cd b7       	in	r28, 0x3d	; 61
    7450:	de b7       	in	r29, 0x3e	; 62
    7452:	6c 01       	movw	r12, r24
    7454:	f4 2e       	mov	r15, r20
    7456:	12 2f       	mov	r17, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7458:	69 83       	std	Y+1, r22	; 0x01
    745a:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    745e:	69 81       	ldd	r22, Y+1	; 0x01
    7460:	86 13       	cpse	r24, r22
    7462:	12 c0       	rjmp	.+36     	; 0x7488 <IP_E_compare_Const+0x4a>
    7464:	c6 01       	movw	r24, r12
    7466:	01 96       	adiw	r24, 0x01	; 1
    7468:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    746c:	8f 11       	cpse	r24, r15
    746e:	0c c0       	rjmp	.+24     	; 0x7488 <IP_E_compare_Const+0x4a>
    7470:	c6 01       	movw	r24, r12
    7472:	02 96       	adiw	r24, 0x02	; 2
    7474:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7478:	81 13       	cpse	r24, r17
    747a:	06 c0       	rjmp	.+12     	; 0x7488 <IP_E_compare_Const+0x4a>
    747c:	c6 01       	movw	r24, r12
    747e:	03 96       	adiw	r24, 0x03	; 3
    7480:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7484:	91 e0       	ldi	r25, 0x01	; 1
    7486:	80 13       	cpse	r24, r16
	else return 0;
    7488:	90 e0       	ldi	r25, 0x00	; 0
}
    748a:	89 2f       	mov	r24, r25
    748c:	0f 90       	pop	r0
    748e:	df 91       	pop	r29
    7490:	cf 91       	pop	r28
    7492:	1f 91       	pop	r17
    7494:	0f 91       	pop	r16
    7496:	ff 90       	pop	r15
    7498:	df 90       	pop	r13
    749a:	cf 90       	pop	r12
    749c:	08 95       	ret

0000749e <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    749e:	8f ef       	ldi	r24, 0xFF	; 255
    74a0:	80 93 6d 08 	sts	0x086D, r24
	GSM_RX_FIFO_End = 255;
    74a4:	80 93 f8 05 	sts	0x05F8, r24
	GSM_RxCharN = 0;
    74a8:	10 92 27 0d 	sts	0x0D27, r1
    74ac:	08 95       	ret

000074ae <GetByteFromFIFO>:
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    74ae:	fb 01       	movw	r30, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    74b0:	20 81       	ld	r18, Z
    74b2:	24 17       	cp	r18, r20
    74b4:	08 f0       	brcs	.+2      	; 0x74b8 <GetByteFromFIFO+0xa>
		*Index = 0;
    74b6:	10 82       	st	Z, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    74b8:	20 91 6d 08 	lds	r18, 0x086D
    74bc:	a0 91 f8 05 	lds	r26, 0x05F8
    74c0:	a2 17       	cp	r26, r18
    74c2:	08 f5       	brcc	.+66     	; 0x7506 <GetByteFromFIFO+0x58>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    74c4:	af 3f       	cpi	r26, 0xFF	; 255
    74c6:	81 f0       	breq	.+32     	; 0x74e8 <GetByteFromFIFO+0x3a>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    74c8:	40 91 f1 0a 	lds	r20, 0x0AF1
    74cc:	20 91 6d 08 	lds	r18, 0x086D
    74d0:	50 e0       	ldi	r21, 0x00	; 0
    74d2:	30 e0       	ldi	r19, 0x00	; 0
    74d4:	2a 1b       	sub	r18, r26
    74d6:	31 09       	sbc	r19, r1
    74d8:	42 17       	cp	r20, r18
    74da:	53 07       	cpc	r21, r19
    74dc:	2c f4       	brge	.+10     	; 0x74e8 <GetByteFromFIFO+0x3a>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    74de:	20 91 6d 08 	lds	r18, 0x086D
    74e2:	2a 1b       	sub	r18, r26
    74e4:	20 93 f1 0a 	sts	0x0AF1, r18
		GSM_RX_FIFO_End++;
    74e8:	af 5f       	subi	r26, 0xFF	; 255
    74ea:	a0 93 f8 05 	sts	0x05F8, r26
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    74ee:	b0 e0       	ldi	r27, 0x00	; 0
    74f0:	a5 51       	subi	r26, 0x15	; 21
    74f2:	bb 4f       	sbci	r27, 0xFB	; 251
    74f4:	2c 91       	ld	r18, X
    74f6:	30 81       	ld	r19, Z
    74f8:	dc 01       	movw	r26, r24
    74fa:	a3 0f       	add	r26, r19
    74fc:	b1 1d       	adc	r27, r1
    74fe:	2c 93       	st	X, r18
		*Index=*Index+1;
    7500:	20 81       	ld	r18, Z
    7502:	2f 5f       	subi	r18, 0xFF	; 255
    7504:	20 83       	st	Z, r18
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7506:	60 91 f8 05 	lds	r22, 0x05F8
    750a:	20 91 6d 08 	lds	r18, 0x086D
    750e:	26 17       	cp	r18, r22
    7510:	60 f5       	brcc	.+88     	; 0x756a <GetByteFromFIFO+0xbc>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    7512:	6f 3f       	cpi	r22, 0xFF	; 255
    7514:	a1 f0       	breq	.+40     	; 0x753e <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7516:	40 91 f1 0a 	lds	r20, 0x0AF1
    751a:	70 91 6d 08 	lds	r23, 0x086D
    751e:	50 e0       	ldi	r21, 0x00	; 0
    7520:	2a ef       	ldi	r18, 0xFA	; 250
    7522:	30 e0       	ldi	r19, 0x00	; 0
    7524:	26 1b       	sub	r18, r22
    7526:	31 09       	sbc	r19, r1
    7528:	27 0f       	add	r18, r23
    752a:	31 1d       	adc	r19, r1
    752c:	42 17       	cp	r20, r18
    752e:	53 07       	cpc	r21, r19
    7530:	34 f4       	brge	.+12     	; 0x753e <GetByteFromFIFO+0x90>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    7532:	20 91 6d 08 	lds	r18, 0x086D
    7536:	26 50       	subi	r18, 0x06	; 6
    7538:	26 1b       	sub	r18, r22
    753a:	20 93 f1 0a 	sts	0x0AF1, r18
		GSM_RX_FIFO_End++;
    753e:	6f 5f       	subi	r22, 0xFF	; 255
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    7540:	6a 3f       	cpi	r22, 0xFA	; 250
    7542:	18 f4       	brcc	.+6      	; 0x754a <GetByteFromFIFO+0x9c>
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    7544:	60 93 f8 05 	sts	0x05F8, r22
    7548:	02 c0       	rjmp	.+4      	; 0x754e <GetByteFromFIFO+0xa0>
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    754a:	10 92 f8 05 	sts	0x05F8, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    754e:	a0 91 f8 05 	lds	r26, 0x05F8
    7552:	b0 e0       	ldi	r27, 0x00	; 0
    7554:	a5 51       	subi	r26, 0x15	; 21
    7556:	bb 4f       	sbci	r27, 0xFB	; 251
    7558:	2c 91       	ld	r18, X
    755a:	30 81       	ld	r19, Z
    755c:	dc 01       	movw	r26, r24
    755e:	a3 0f       	add	r26, r19
    7560:	b1 1d       	adc	r27, r1
    7562:	2c 93       	st	X, r18
		*Index=*Index+1;
    7564:	80 81       	ld	r24, Z
    7566:	8f 5f       	subi	r24, 0xFF	; 255
    7568:	80 83       	st	Z, r24
    756a:	08 95       	ret

0000756c <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    756c:	90 91 6d 08 	lds	r25, 0x086D
    7570:	80 91 f8 05 	lds	r24, 0x05F8
    7574:	98 17       	cp	r25, r24
    7576:	39 f1       	breq	.+78     	; 0x75c6 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7578:	44 e6       	ldi	r20, 0x64	; 100
    757a:	67 e2       	ldi	r22, 0x27	; 39
    757c:	7d e0       	ldi	r23, 0x0D	; 13
    757e:	8d e6       	ldi	r24, 0x6D	; 109
    7580:	99 e0       	ldi	r25, 0x09	; 9
    7582:	0e 94 57 3a 	call	0x74ae	; 0x74ae <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    7586:	80 91 27 0d 	lds	r24, 0x0D27
    758a:	82 30       	cpi	r24, 0x02	; 2
    758c:	78 f3       	brcs	.-34     	; 0x756c <GetStringFromFIFO>
    758e:	e0 91 27 0d 	lds	r30, 0x0D27
    7592:	f0 e0       	ldi	r31, 0x00	; 0
    7594:	e5 59       	subi	r30, 0x95	; 149
    7596:	f6 4f       	sbci	r31, 0xF6	; 246
    7598:	80 81       	ld	r24, Z
    759a:	8d 30       	cpi	r24, 0x0D	; 13
    759c:	39 f7       	brne	.-50     	; 0x756c <GetStringFromFIFO>
    759e:	e0 91 27 0d 	lds	r30, 0x0D27
    75a2:	f0 e0       	ldi	r31, 0x00	; 0
    75a4:	e4 59       	subi	r30, 0x94	; 148
    75a6:	f6 4f       	sbci	r31, 0xF6	; 246
    75a8:	80 81       	ld	r24, Z
    75aa:	8a 30       	cpi	r24, 0x0A	; 10
    75ac:	f9 f6       	brne	.-66     	; 0x756c <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    75ae:	e0 91 27 0d 	lds	r30, 0x0D27
    75b2:	f0 e0       	ldi	r31, 0x00	; 0
    75b4:	e5 59       	subi	r30, 0x95	; 149
    75b6:	f6 4f       	sbci	r31, 0xF6	; 246
    75b8:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    75ba:	80 91 27 0d 	lds	r24, 0x0D27
			GSM_RxCharN = 0;
    75be:	10 92 27 0d 	sts	0x0D27, r1
    75c2:	81 50       	subi	r24, 0x01	; 1
    75c4:	08 95       	ret
			return StrLength;
		}

	}//while

	return StrLength;
    75c6:	80 e0       	ldi	r24, 0x00	; 0
}
    75c8:	08 95       	ret

000075ca <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    75ca:	80 91 27 0d 	lds	r24, 0x0D27
    75ce:	84 36       	cpi	r24, 0x64	; 100
    75d0:	18 f0       	brcs	.+6      	; 0x75d8 <ForceEndStringFromFIFO+0xe>
    75d2:	83 e6       	ldi	r24, 0x63	; 99
    75d4:	80 93 27 0d 	sts	0x0D27, r24
	StrLength = GSM_RxCharN;
    75d8:	80 91 27 0d 	lds	r24, 0x0D27
	GSM_RxStr[GSM_RxCharN]='\0';
    75dc:	e0 91 27 0d 	lds	r30, 0x0D27
    75e0:	f0 e0       	ldi	r31, 0x00	; 0
    75e2:	e3 59       	subi	r30, 0x93	; 147
    75e4:	f6 4f       	sbci	r31, 0xF6	; 246
    75e6:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    75e8:	10 92 27 0d 	sts	0x0D27, r1
	return StrLength;
}
    75ec:	08 95       	ret

000075ee <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    75ee:	cf 93       	push	r28
    75f0:	c8 2f       	mov	r28, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    75f2:	90 91 6d 08 	lds	r25, 0x086D
    75f6:	80 91 f8 05 	lds	r24, 0x05F8
    75fa:	98 17       	cp	r25, r24
    75fc:	79 f0       	breq	.+30     	; 0x761c <GetDataFromFIFO+0x2e>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    75fe:	44 e6       	ldi	r20, 0x64	; 100
    7600:	67 e2       	ldi	r22, 0x27	; 39
    7602:	7d e0       	ldi	r23, 0x0D	; 13
    7604:	8d e6       	ldi	r24, 0x6D	; 109
    7606:	99 e0       	ldi	r25, 0x09	; 9
    7608:	0e 94 57 3a 	call	0x74ae	; 0x74ae <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    760c:	80 91 27 0d 	lds	r24, 0x0D27
    7610:	8c 17       	cp	r24, r28
    7612:	78 f3       	brcs	.-34     	; 0x75f2 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7614:	10 92 27 0d 	sts	0x0D27, r1
			return Amount;
    7618:	8c 2f       	mov	r24, r28
    761a:	02 c0       	rjmp	.+4      	; 0x7620 <GetDataFromFIFO+0x32>
		}
	}//while
	return GSM_RxCharN;
    761c:	80 91 27 0d 	lds	r24, 0x0D27
}
    7620:	cf 91       	pop	r28
    7622:	08 95       	ret

00007624 <strcpy_EE>:
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    7624:	df 92       	push	r13
    7626:	ef 92       	push	r14
    7628:	ff 92       	push	r15
    762a:	0f 93       	push	r16
    762c:	1f 93       	push	r17
    762e:	cf 93       	push	r28
    7630:	df 93       	push	r29
    7632:	8c 01       	movw	r16, r24
    7634:	7b 01       	movw	r14, r22
	uint8_t i=0;
    7636:	d1 2c       	mov	r13, r1
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    7638:	cd 2d       	mov	r28, r13
    763a:	d0 e0       	ldi	r29, 0x00	; 0
    763c:	c7 01       	movw	r24, r14
    763e:	8c 0f       	add	r24, r28
    7640:	9d 1f       	adc	r25, r29
    7642:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7646:	98 2f       	mov	r25, r24
    7648:	9f 7d       	andi	r25, 0xDF	; 223
    764a:	29 f0       	breq	.+10     	; 0x7656 <strcpy_EE+0x32>
		str_RAM[i] = (char)erb(&str_EE[i]);
    764c:	c0 0f       	add	r28, r16
    764e:	d1 1f       	adc	r29, r17
    7650:	88 83       	st	Y, r24
		i++;
    7652:	d3 94       	inc	r13
    7654:	f1 cf       	rjmp	.-30     	; 0x7638 <strcpy_EE+0x14>
	}
	return i;	
}
    7656:	8d 2d       	mov	r24, r13
    7658:	df 91       	pop	r29
    765a:	cf 91       	pop	r28
    765c:	1f 91       	pop	r17
    765e:	0f 91       	pop	r16
    7660:	ff 90       	pop	r15
    7662:	ef 90       	pop	r14
    7664:	df 90       	pop	r13
    7666:	08 95       	ret

00007668 <GSM_Init>:
}
// ~~~~~~~~~~~
void
GSM_Init(void)
{	
	InitFIFO();
    7668:	0e 94 4f 3a 	call	0x749e	; 0x749e <InitFIFO>
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABl_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    766c:	8c ef       	ldi	r24, 0xFC	; 252
    766e:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7670:	88 e9       	ldi	r24, 0x98	; 152
    7672:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    7674:	86 e8       	ldi	r24, 0x86	; 134
    7676:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    767a:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    767e:	87 e6       	ldi	r24, 0x67	; 103
    7680:	89 b9       	out	0x09, r24	; 9
	#endif

	GSM_PWRCNTRL_Config();
    7682:	0e 94 18 2f 	call	0x5e30	; 0x5e30 <GSM_PWRCNTRL_Config>
	GSM_PWRCNTRL_ON();
    7686:	0e 94 20 2f 	call	0x5e40	; 0x5e40 <GSM_PWRCNTRL_ON>

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    768a:	80 91 0a 01 	lds	r24, 0x010A
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    768e:	80 93 52 02 	sts	0x0252, r24
	VacantTimer16Sys += n;
    7692:	91 e0       	ldi	r25, 0x01	; 1
    7694:	98 0f       	add	r25, r24
	TD_TCP_Connect = Timer16SysAlloc(1);
    7696:	90 93 51 02 	sts	0x0251, r25
    769a:	93 e0       	ldi	r25, 0x03	; 3
    769c:	98 0f       	add	r25, r24
    769e:	90 93 0a 01 	sts	0x010A, r25
    76a2:	8e 5f       	subi	r24, 0xFE	; 254
	TD_RSSI = Timer16SysAlloc(1);
    76a4:	80 93 50 02 	sts	0x0250, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    76a8:	80 91 09 01 	lds	r24, 0x0109
	VacantTimer32Sys += n;
    76ac:	91 e0       	ldi	r25, 0x01	; 1
    76ae:	98 0f       	add	r25, r24
    76b0:	90 93 09 01 	sts	0x0109, r25
	TD_GSM_Reset = Timer32SysAlloc(1);
    76b4:	80 93 4f 02 	sts	0x024F, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    76b8:	10 92 61 09 	sts	0x0961, r1
	GSM_State = GSM_PowerOn;
    76bc:	10 92 19 06 	sts	0x0619, r1
    76c0:	08 95       	ret

000076c2 <GSM_Wait_Response>:
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    76c2:	bc 01       	movw	r22, r24
    76c4:	8d e6       	ldi	r24, 0x6D	; 109
    76c6:	99 e0       	ldi	r25, 0x09	; 9
    76c8:	0e 94 0e 78 	call	0xf01c	; 0xf01c <strcmp>
    76cc:	21 e0       	ldi	r18, 0x01	; 1
    76ce:	89 2b       	or	r24, r25
    76d0:	09 f0       	breq	.+2      	; 0x76d4 <GSM_Wait_Response+0x12>
    76d2:	20 e0       	ldi	r18, 0x00	; 0
	else return 1;
}
    76d4:	82 2f       	mov	r24, r18
    76d6:	08 95       	ret

000076d8 <GSM_Wait_Response_P>:
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    76d8:	0f 93       	push	r16
    76da:	1f 93       	push	r17
    76dc:	cf 93       	push	r28
    76de:	df 93       	push	r29
    76e0:	1f 92       	push	r1
    76e2:	cd b7       	in	r28, 0x3d	; 61
    76e4:	de b7       	in	r29, 0x3e	; 62
    76e6:	8c 01       	movw	r16, r24
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    76e8:	80 91 52 02 	lds	r24, 0x0252
    76ec:	69 83       	std	Y+1, r22	; 0x01
    76ee:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    76f2:	69 81       	ldd	r22, Y+1	; 0x01
    76f4:	88 23       	and	r24, r24
    76f6:	29 f0       	breq	.+10     	; 0x7702 <GSM_Wait_Response_P+0x2a>
    76f8:	66 23       	and	r22, r22
    76fa:	19 f0       	breq	.+6      	; 0x7702 <GSM_Wait_Response_P+0x2a>
		GSM_State = RestoreCMD;
    76fc:	60 93 19 06 	sts	0x0619, r22
    7700:	0c c0       	rjmp	.+24     	; 0x771a <GSM_Wait_Response_P+0x42>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    7702:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    7706:	88 23       	and	r24, r24
    7708:	41 f0       	breq	.+16     	; 0x771a <GSM_Wait_Response_P+0x42>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    770a:	b8 01       	movw	r22, r16
    770c:	8d e6       	ldi	r24, 0x6D	; 109
    770e:	99 e0       	ldi	r25, 0x09	; 9
    7710:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    7714:	21 e0       	ldi	r18, 0x01	; 1
    7716:	89 2b       	or	r24, r25
    7718:	09 f0       	breq	.+2      	; 0x771c <GSM_Wait_Response_P+0x44>
		else return 1;
	}
	else return 0;
    771a:	20 e0       	ldi	r18, 0x00	; 0
}
    771c:	82 2f       	mov	r24, r18
    771e:	0f 90       	pop	r0
    7720:	df 91       	pop	r29
    7722:	cf 91       	pop	r28
    7724:	1f 91       	pop	r17
    7726:	0f 91       	pop	r16
    7728:	08 95       	ret

0000772a <GSM_Wait_Char>:
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    772a:	1f 93       	push	r17
    772c:	cf 93       	push	r28
    772e:	df 93       	push	r29
    7730:	1f 92       	push	r1
    7732:	cd b7       	in	r28, 0x3d	; 61
    7734:	de b7       	in	r29, 0x3e	; 62
    7736:	18 2f       	mov	r17, r24
	if(Timer16Stopp(TD_GSM)){
    7738:	80 91 52 02 	lds	r24, 0x0252
    773c:	69 83       	std	Y+1, r22	; 0x01
    773e:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    7742:	69 81       	ldd	r22, Y+1	; 0x01
    7744:	88 23       	and	r24, r24
    7746:	19 f0       	breq	.+6      	; 0x774e <GSM_Wait_Char+0x24>
		GSM_State = RestoreCMD;
    7748:	60 93 19 06 	sts	0x0619, r22
    774c:	09 c0       	rjmp	.+18     	; 0x7760 <GSM_Wait_Char+0x36>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    774e:	81 e0       	ldi	r24, 0x01	; 1
    7750:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <GetDataFromFIFO>
    7754:	88 23       	and	r24, r24
    7756:	21 f0       	breq	.+8      	; 0x7760 <GSM_Wait_Char+0x36>
		if(GSM_RxStr[0] == Char)	return 1;
    7758:	81 e0       	ldi	r24, 0x01	; 1
    775a:	90 91 6d 09 	lds	r25, 0x096D
    775e:	91 13       	cpse	r25, r17
		else return 0;
	}
	else return 0;
    7760:	80 e0       	ldi	r24, 0x00	; 0
}
    7762:	0f 90       	pop	r0
    7764:	df 91       	pop	r29
    7766:	cf 91       	pop	r28
    7768:	1f 91       	pop	r17
    776a:	08 95       	ret

0000776c <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    776c:	80 91 5a 0a 	lds	r24, 0x0A5A
    7770:	81 11       	cpse	r24, r1
    7772:	05 c0       	rjmp	.+10     	; 0x777e <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    7774:	80 91 08 01 	lds	r24, 0x0108
    7778:	81 60       	ori	r24, 0x01	; 1
    777a:	80 93 08 01 	sts	0x0108, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    777e:	88 e9       	ldi	r24, 0x98	; 152
    7780:	8a b9       	out	0x0a, r24	; 10
    7782:	08 95       	ret

00007784 <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    7784:	1f 92       	push	r1
    7786:	0f 92       	push	r0
    7788:	0f b6       	in	r0, 0x3f	; 63
    778a:	0f 92       	push	r0
    778c:	11 24       	eor	r1, r1
    778e:	0b b6       	in	r0, 0x3b	; 59
    7790:	0f 92       	push	r0
    7792:	2f 93       	push	r18
    7794:	3f 93       	push	r19
    7796:	4f 93       	push	r20
    7798:	5f 93       	push	r21
    779a:	6f 93       	push	r22
    779c:	7f 93       	push	r23
    779e:	8f 93       	push	r24
    77a0:	9f 93       	push	r25
    77a2:	af 93       	push	r26
    77a4:	bf 93       	push	r27
    77a6:	ef 93       	push	r30
    77a8:	ff 93       	push	r31
	GSM_TX();
    77aa:	0e 94 b6 3b 	call	0x776c	; 0x776c <GSM_TX>
	GSM_LED = 1;
    77ae:	81 e0       	ldi	r24, 0x01	; 1
    77b0:	80 93 fd 05 	sts	0x05FD, r24
}
    77b4:	ff 91       	pop	r31
    77b6:	ef 91       	pop	r30
    77b8:	bf 91       	pop	r27
    77ba:	af 91       	pop	r26
    77bc:	9f 91       	pop	r25
    77be:	8f 91       	pop	r24
    77c0:	7f 91       	pop	r23
    77c2:	6f 91       	pop	r22
    77c4:	5f 91       	pop	r21
    77c6:	4f 91       	pop	r20
    77c8:	3f 91       	pop	r19
    77ca:	2f 91       	pop	r18
    77cc:	0f 90       	pop	r0
    77ce:	0b be       	out	0x3b, r0	; 59
    77d0:	0f 90       	pop	r0
    77d2:	0f be       	out	0x3f, r0	; 63
    77d4:	0f 90       	pop	r0
    77d6:	1f 90       	pop	r1
    77d8:	18 95       	reti

000077da <DI_State>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
    77da:	e8 2f       	mov	r30, r24
    77dc:	e6 95       	lsr	r30
    77de:	e6 95       	lsr	r30
    77e0:	e6 95       	lsr	r30
    77e2:	f0 e0       	ldi	r31, 0x00	; 0
    77e4:	e4 54       	subi	r30, 0x44	; 68
    77e6:	f7 4f       	sbci	r31, 0xF7	; 247
    77e8:	20 81       	ld	r18, Z
    77ea:	30 e0       	ldi	r19, 0x00	; 0
    77ec:	87 70       	andi	r24, 0x07	; 7
    77ee:	02 c0       	rjmp	.+4      	; 0x77f4 <DI_State+0x1a>
    77f0:	35 95       	asr	r19
    77f2:	27 95       	ror	r18
    77f4:	8a 95       	dec	r24
    77f6:	e2 f7       	brpl	.-8      	; 0x77f0 <DI_State+0x16>
}
    77f8:	82 2f       	mov	r24, r18
    77fa:	81 70       	andi	r24, 0x01	; 1
    77fc:	08 95       	ret

000077fe <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
    77fe:	e8 2f       	mov	r30, r24
    7800:	e6 95       	lsr	r30
    7802:	e6 95       	lsr	r30
    7804:	e6 95       	lsr	r30
    7806:	f0 e0       	ldi	r31, 0x00	; 0
    7808:	e2 54       	subi	r30, 0x42	; 66
    780a:	f7 4f       	sbci	r31, 0xF7	; 247
    780c:	20 81       	ld	r18, Z
    780e:	30 e0       	ldi	r19, 0x00	; 0
    7810:	87 70       	andi	r24, 0x07	; 7
    7812:	02 c0       	rjmp	.+4      	; 0x7818 <DI_Status+0x1a>
    7814:	35 95       	asr	r19
    7816:	27 95       	ror	r18
    7818:	8a 95       	dec	r24
    781a:	e2 f7       	brpl	.-8      	; 0x7814 <DI_Status+0x16>
}
    781c:	82 2f       	mov	r24, r18
    781e:	81 70       	andi	r24, 0x01	; 1
    7820:	08 95       	ret

00007822 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    7822:	ff 92       	push	r15
    7824:	0f 93       	push	r16
    7826:	1f 93       	push	r17
    7828:	cf 93       	push	r28
    782a:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    782c:	c0 91 bc 08 	lds	r28, 0x08BC
    7830:	c0 93 bd 08 	sts	0x08BD, r28
    7834:	8e e5       	ldi	r24, 0x5E	; 94
    7836:	90 e0       	ldi	r25, 0x00	; 0
    7838:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    783c:	8c 27       	eor	r24, r28
    783e:	80 93 be 08 	sts	0x08BE, r24
    7842:	83 e5       	ldi	r24, 0x53	; 83
    7844:	9e e4       	ldi	r25, 0x4E	; 78
    7846:	20 e0       	ldi	r18, 0x00	; 0
    7848:	30 e0       	ldi	r19, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    784a:	c1 e0       	ldi	r28, 0x01	; 1
    784c:	d0 e0       	ldi	r29, 0x00	; 0
    784e:	ae 01       	movw	r20, r28
    7850:	02 2e       	mov	r0, r18
    7852:	01 c0       	rjmp	.+2      	; 0x7856 <DigitIn+0x34>
    7854:	44 0f       	add	r20, r20
    7856:	0a 94       	dec	r0
    7858:	ea f7       	brpl	.-6      	; 0x7854 <DigitIn+0x32>
    785a:	fc 01       	movw	r30, r24
    785c:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    785e:	e4 91       	lpm	r30, Z
    7860:	dc 01       	movw	r26, r24
    7862:	12 96       	adiw	r26, 0x02	; 2
    7864:	f0 90 bc 08 	lds	r15, 0x08BC
			if(prb(&DI_M[D_N].Inversion)){
    7868:	ee 23       	and	r30, r30
    786a:	51 f0       	breq	.+20     	; 0x7880 <DigitIn+0x5e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    786c:	fc 01       	movw	r30, r24
    786e:	05 91       	lpm	r16, Z+
    7870:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7872:	fd 01       	movw	r30, r26
    7874:	a4 91       	lpm	r26, Z
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    7876:	f8 01       	movw	r30, r16
    7878:	60 81       	ld	r22, Z
    787a:	a6 23       	and	r26, r22
    787c:	51 f0       	breq	.+20     	; 0x7892 <DigitIn+0x70>
    787e:	0c c0       	rjmp	.+24     	; 0x7898 <DigitIn+0x76>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7880:	fc 01       	movw	r30, r24
    7882:	05 91       	lpm	r16, Z+
    7884:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7886:	fd 01       	movw	r30, r26
    7888:	a4 91       	lpm	r26, Z
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    788a:	f8 01       	movw	r30, r16
    788c:	60 81       	ld	r22, Z
    788e:	a6 23       	and	r26, r22
    7890:	19 f0       	breq	.+6      	; 0x7898 <DigitIn+0x76>
					DigInput.State[Byte] &=~Bit;
    7892:	40 95       	com	r20
    7894:	4f 21       	and	r20, r15
    7896:	01 c0       	rjmp	.+2      	; 0x789a <DigitIn+0x78>
				else
					DigInput.State[Byte]  |=Bit;
    7898:	4f 29       	or	r20, r15
    789a:	40 93 bc 08 	sts	0x08BC, r20
    789e:	2f 5f       	subi	r18, 0xFF	; 255
    78a0:	3f 4f       	sbci	r19, 0xFF	; 255
    78a2:	08 96       	adiw	r24, 0x08	; 8
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    78a4:	24 30       	cpi	r18, 0x04	; 4
    78a6:	31 05       	cpc	r19, r1
    78a8:	09 f0       	breq	.+2      	; 0x78ac <DigitIn+0x8a>
    78aa:	d1 cf       	rjmp	.-94     	; 0x784e <DigitIn+0x2c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    78ac:	df 91       	pop	r29
    78ae:	cf 91       	pop	r28
    78b0:	1f 91       	pop	r17
    78b2:	0f 91       	pop	r16
    78b4:	ff 90       	pop	r15
    78b6:	08 95       	ret

000078b8 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    78b8:	e8 2f       	mov	r30, r24
    78ba:	e6 95       	lsr	r30
    78bc:	e6 95       	lsr	r30
    78be:	e6 95       	lsr	r30
    78c0:	f0 e0       	ldi	r31, 0x00	; 0
    78c2:	e7 59       	subi	r30, 0x97	; 151
    78c4:	f6 4f       	sbci	r31, 0xF6	; 246
    78c6:	87 70       	andi	r24, 0x07	; 7
    78c8:	21 e0       	ldi	r18, 0x01	; 1
    78ca:	30 e0       	ldi	r19, 0x00	; 0
    78cc:	01 c0       	rjmp	.+2      	; 0x78d0 <SetDigOut+0x18>
    78ce:	22 0f       	add	r18, r18
    78d0:	8a 95       	dec	r24
    78d2:	ea f7       	brpl	.-6      	; 0x78ce <SetDigOut+0x16>
    78d4:	80 81       	ld	r24, Z
    78d6:	82 2b       	or	r24, r18
    78d8:	80 83       	st	Z, r24
    78da:	08 95       	ret

000078dc <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    78dc:	e8 2f       	mov	r30, r24
    78de:	e6 95       	lsr	r30
    78e0:	e6 95       	lsr	r30
    78e2:	e6 95       	lsr	r30
    78e4:	f0 e0       	ldi	r31, 0x00	; 0
    78e6:	e7 59       	subi	r30, 0x97	; 151
    78e8:	f6 4f       	sbci	r31, 0xF6	; 246
    78ea:	87 70       	andi	r24, 0x07	; 7
    78ec:	21 e0       	ldi	r18, 0x01	; 1
    78ee:	30 e0       	ldi	r19, 0x00	; 0
    78f0:	01 c0       	rjmp	.+2      	; 0x78f4 <ResDigOut+0x18>
    78f2:	22 0f       	add	r18, r18
    78f4:	8a 95       	dec	r24
    78f6:	ea f7       	brpl	.-6      	; 0x78f2 <ResDigOut+0x16>
    78f8:	20 95       	com	r18
    78fa:	80 81       	ld	r24, Z
    78fc:	28 23       	and	r18, r24
    78fe:	20 83       	st	Z, r18
    7900:	08 95       	ret

00007902 <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    7902:	e8 2f       	mov	r30, r24
    7904:	e6 95       	lsr	r30
    7906:	e6 95       	lsr	r30
    7908:	e6 95       	lsr	r30
    790a:	f0 e0       	ldi	r31, 0x00	; 0
    790c:	e7 59       	subi	r30, 0x97	; 151
    790e:	f6 4f       	sbci	r31, 0xF6	; 246
    7910:	87 70       	andi	r24, 0x07	; 7
    7912:	21 e0       	ldi	r18, 0x01	; 1
    7914:	30 e0       	ldi	r19, 0x00	; 0
    7916:	01 c0       	rjmp	.+2      	; 0x791a <TogDigOut+0x18>
    7918:	22 0f       	add	r18, r18
    791a:	8a 95       	dec	r24
    791c:	ea f7       	brpl	.-6      	; 0x7918 <TogDigOut+0x16>
    791e:	80 81       	ld	r24, Z
    7920:	82 27       	eor	r24, r18
    7922:	80 83       	st	Z, r24
    7924:	08 95       	ret

00007926 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7926:	80 91 67 09 	lds	r24, 0x0967
    792a:	80 93 68 09 	sts	0x0968, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    792e:	80 91 69 09 	lds	r24, 0x0969
    7932:	80 93 67 09 	sts	0x0967, r24
    7936:	82 e4       	ldi	r24, 0x42	; 66
    7938:	9e e4       	ldi	r25, 0x4E	; 78
    793a:	20 e0       	ldi	r18, 0x00	; 0
    793c:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    793e:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7940:	40 91 67 09 	lds	r20, 0x0967
    7944:	50 e0       	ldi	r21, 0x00	; 0
    7946:	02 2e       	mov	r0, r18
    7948:	02 c0       	rjmp	.+4      	; 0x794e <DigitOut+0x28>
    794a:	55 95       	asr	r21
    794c:	47 95       	ror	r20
    794e:	0a 94       	dec	r0
    7950:	e2 f7       	brpl	.-8      	; 0x794a <DigitOut+0x24>
    7952:	bc 01       	movw	r22, r24
    7954:	6e 5f       	subi	r22, 0xFE	; 254
    7956:	7f 4f       	sbci	r23, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7958:	fc 01       	movw	r30, r24
    795a:	40 ff       	sbrs	r20, 0
    795c:	07 c0       	rjmp	.+14     	; 0x796c <DigitOut+0x46>
    795e:	a5 91       	lpm	r26, Z+
    7960:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7962:	fb 01       	movw	r30, r22
    7964:	64 91       	lpm	r22, Z
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    7966:	4c 91       	ld	r20, X
    7968:	46 2b       	or	r20, r22
    796a:	07 c0       	rjmp	.+14     	; 0x797a <DigitOut+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    796c:	a5 91       	lpm	r26, Z+
    796e:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7970:	fb 01       	movw	r30, r22
    7972:	64 91       	lpm	r22, Z
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    7974:	60 95       	com	r22
    7976:	4c 91       	ld	r20, X
    7978:	46 23       	and	r20, r22
    797a:	4c 93       	st	X, r20
		sei();
    797c:	78 94       	sei
    797e:	2f 5f       	subi	r18, 0xFF	; 255
    7980:	3f 4f       	sbci	r19, 0xFF	; 255
    7982:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    7984:	23 30       	cpi	r18, 0x03	; 3
    7986:	31 05       	cpc	r19, r1
    7988:	d1 f6       	brne	.-76     	; 0x793e <DigitOut+0x18>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    798a:	08 95       	ret

0000798c <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    798c:	80 e4       	ldi	r24, 0x40	; 64
    798e:	9e e4       	ldi	r25, 0x4E	; 78
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    7990:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7992:	fc 01       	movw	r30, r24
    7994:	a5 91       	lpm	r26, Z+
    7996:	b4 91       	lpm	r27, Z
    7998:	fc 01       	movw	r30, r24
    799a:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    799c:	e4 91       	lpm	r30, Z
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    799e:	2c 91       	ld	r18, X
    79a0:	2e 2b       	or	r18, r30
    79a2:	2c 93       	st	X, r18
		sei();
    79a4:	78 94       	sei
    79a6:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    79a8:	2e e4       	ldi	r18, 0x4E	; 78
    79aa:	8f 34       	cpi	r24, 0x4F	; 79
    79ac:	92 07       	cpc	r25, r18
    79ae:	81 f7       	brne	.-32     	; 0x7990 <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    79b0:	0c 94 93 3c 	jmp	0x7926	; 0x7926 <DigitOut>

000079b4 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    79b4:	28 2f       	mov	r18, r24
	uint16_t Pow = 1;
    79b6:	81 e0       	ldi	r24, 0x01	; 1
    79b8:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
		Pow *= 10;
    79ba:	3a e0       	ldi	r19, 0x0A	; 10
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    79bc:	21 50       	subi	r18, 0x01	; 1
    79be:	38 f0       	brcs	.+14     	; 0x79ce <Pow10+0x1a>
		Pow *= 10;
    79c0:	ac 01       	movw	r20, r24
    79c2:	34 9f       	mul	r19, r20
    79c4:	c0 01       	movw	r24, r0
    79c6:	35 9f       	mul	r19, r21
    79c8:	90 0d       	add	r25, r0
    79ca:	11 24       	eor	r1, r1
    79cc:	f7 cf       	rjmp	.-18     	; 0x79bc <Pow10+0x8>
	return Pow;
}
    79ce:	08 95       	ret

000079d0 <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    79d0:	e8 2f       	mov	r30, r24
	uint32_t Pow = 1;
    79d2:	61 e0       	ldi	r22, 0x01	; 1
    79d4:	70 e0       	ldi	r23, 0x00	; 0
    79d6:	80 e0       	ldi	r24, 0x00	; 0
    79d8:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
    79da:	e1 50       	subi	r30, 0x01	; 1
    79dc:	38 f0       	brcs	.+14     	; 0x79ec <PowL10+0x1c>
		Pow *= 10;
    79de:	aa e0       	ldi	r26, 0x0A	; 10
    79e0:	b0 e0       	ldi	r27, 0x00	; 0
    79e2:	9b 01       	movw	r18, r22
    79e4:	ac 01       	movw	r20, r24
    79e6:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    79ea:	f7 cf       	rjmp	.-18     	; 0x79da <PowL10+0xa>
	return Pow;
}
    79ec:	08 95       	ret

000079ee <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    79ee:	ff 92       	push	r15
    79f0:	0f 93       	push	r16
    79f2:	1f 93       	push	r17
    79f4:	cf 93       	push	r28
    79f6:	df 93       	push	r29
    79f8:	f8 2e       	mov	r15, r24
    79fa:	c0 e0       	ldi	r28, 0x00	; 0
    79fc:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    79fe:	06 2f       	mov	r16, r22
    7a00:	10 e0       	ldi	r17, 0x00	; 0

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    7a02:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7a04:	8f 2d       	mov	r24, r15
    7a06:	0e 94 fe 2e 	call	0x5dfc	; 0x5dfc <OW_MasterPullLowBus>
    7a0a:	8a e1       	ldi	r24, 0x1A	; 26
    7a0c:	8a 95       	dec	r24
    7a0e:	f1 f7       	brne	.-4      	; 0x7a0c <OW_MasterTx_Command+0x1e>
    7a10:	00 c0       	rjmp	.+0      	; 0x7a12 <OW_MasterTx_Command+0x24>
		_delay_us(5);
		if(Command & (1<<i)){
    7a12:	98 01       	movw	r18, r16
    7a14:	0c 2e       	mov	r0, r28
    7a16:	02 c0       	rjmp	.+4      	; 0x7a1c <OW_MasterTx_Command+0x2e>
    7a18:	35 95       	asr	r19
    7a1a:	27 95       	ror	r18
    7a1c:	0a 94       	dec	r0
    7a1e:	e2 f7       	brpl	.-8      	; 0x7a18 <OW_MasterTx_Command+0x2a>
    7a20:	20 ff       	sbrs	r18, 0
    7a22:	0a c0       	rjmp	.+20     	; 0x7a38 <OW_MasterTx_Command+0x4a>
			OW_MasterReleaseBus(CH);
    7a24:	8f 2d       	mov	r24, r15
    7a26:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>
    7a2a:	83 e5       	ldi	r24, 0x53	; 83
    7a2c:	91 e0       	ldi	r25, 0x01	; 1
    7a2e:	01 97       	sbiw	r24, 0x01	; 1
    7a30:	f1 f7       	brne	.-4      	; 0x7a2e <OW_MasterTx_Command+0x40>
    7a32:	00 c0       	rjmp	.+0      	; 0x7a34 <OW_MasterTx_Command+0x46>
    7a34:	00 00       	nop
    7a36:	07 c0       	rjmp	.+14     	; 0x7a46 <OW_MasterTx_Command+0x58>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    7a38:	85 e5       	ldi	r24, 0x55	; 85
    7a3a:	90 e0       	ldi	r25, 0x00	; 0
    7a3c:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>
			OW_MasterReleaseBus(CH);
    7a40:	8f 2d       	mov	r24, r15
    7a42:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>
		}
		sei();
    7a46:	78 94       	sei
    7a48:	9a e1       	ldi	r25, 0x1A	; 26
    7a4a:	9a 95       	dec	r25
    7a4c:	f1 f7       	brne	.-4      	; 0x7a4a <OW_MasterTx_Command+0x5c>
    7a4e:	00 c0       	rjmp	.+0      	; 0x7a50 <OW_MasterTx_Command+0x62>
    7a50:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    7a52:	c8 30       	cpi	r28, 0x08	; 8
    7a54:	d1 05       	cpc	r29, r1
    7a56:	a9 f6       	brne	.-86     	; 0x7a02 <OW_MasterTx_Command+0x14>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    7a58:	df 91       	pop	r29
    7a5a:	cf 91       	pop	r28
    7a5c:	1f 91       	pop	r17
    7a5e:	0f 91       	pop	r16
    7a60:	ff 90       	pop	r15
    7a62:	08 95       	ret

00007a64 <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    7a64:	ef 92       	push	r14
    7a66:	ff 92       	push	r15
    7a68:	0f 93       	push	r16
    7a6a:	1f 93       	push	r17
    7a6c:	cf 93       	push	r28
    7a6e:	df 93       	push	r29
    7a70:	e8 2e       	mov	r14, r24
    7a72:	c0 e0       	ldi	r28, 0x00	; 0
    7a74:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	uint8_t Data = 0;
    7a76:	f1 2c       	mov	r15, r1
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    7a78:	01 e0       	ldi	r16, 0x01	; 1
    7a7a:	10 e0       	ldi	r17, 0x00	; 0
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    7a7c:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7a7e:	8e 2d       	mov	r24, r14
    7a80:	0e 94 fe 2e 	call	0x5dfc	; 0x5dfc <OW_MasterPullLowBus>
    7a84:	8a e1       	ldi	r24, 0x1A	; 26
    7a86:	8a 95       	dec	r24
    7a88:	f1 f7       	brne	.-4      	; 0x7a86 <OW_MasterRx_Data+0x22>
    7a8a:	00 c0       	rjmp	.+0      	; 0x7a8c <OW_MasterRx_Data+0x28>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    7a8c:	8e 2d       	mov	r24, r14
    7a8e:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>
    7a92:	9a e1       	ldi	r25, 0x1A	; 26
    7a94:	9a 95       	dec	r25
    7a96:	f1 f7       	brne	.-4      	; 0x7a94 <OW_MasterRx_Data+0x30>
    7a98:	00 c0       	rjmp	.+0      	; 0x7a9a <OW_MasterRx_Data+0x36>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    7a9a:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    7a9e:	80 ff       	sbrs	r24, 0
    7aa0:	07 c0       	rjmp	.+14     	; 0x7ab0 <OW_MasterRx_Data+0x4c>
    7aa2:	98 01       	movw	r18, r16
    7aa4:	0c 2e       	mov	r0, r28
    7aa6:	01 c0       	rjmp	.+2      	; 0x7aaa <OW_MasterRx_Data+0x46>
    7aa8:	22 0f       	add	r18, r18
    7aaa:	0a 94       	dec	r0
    7aac:	ea f7       	brpl	.-6      	; 0x7aa8 <OW_MasterRx_Data+0x44>
    7aae:	f2 2a       	or	r15, r18
		sei();
    7ab0:	78 94       	sei
    7ab2:	8f ee       	ldi	r24, 0xEF	; 239
    7ab4:	90 e0       	ldi	r25, 0x00	; 0
    7ab6:	01 97       	sbiw	r24, 0x01	; 1
    7ab8:	f1 f7       	brne	.-4      	; 0x7ab6 <OW_MasterRx_Data+0x52>
    7aba:	00 c0       	rjmp	.+0      	; 0x7abc <OW_MasterRx_Data+0x58>
    7abc:	00 00       	nop
    7abe:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    7ac0:	c8 30       	cpi	r28, 0x08	; 8
    7ac2:	d1 05       	cpc	r29, r1
    7ac4:	d9 f6       	brne	.-74     	; 0x7a7c <OW_MasterRx_Data+0x18>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    7ac6:	8f 2d       	mov	r24, r15
    7ac8:	df 91       	pop	r29
    7aca:	cf 91       	pop	r28
    7acc:	1f 91       	pop	r17
    7ace:	0f 91       	pop	r16
    7ad0:	ff 90       	pop	r15
    7ad2:	ef 90       	pop	r14
    7ad4:	08 95       	ret

00007ad6 <OneWire_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7ad6:	80 91 0b 01 	lds	r24, 0x010B
	VacantTimer8Sys += n;
    7ada:	91 e0       	ldi	r25, 0x01	; 1
    7adc:	98 0f       	add	r25, r24
    7ade:	90 93 0b 01 	sts	0x010B, r25


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    7ae2:	80 93 4f 09 	sts	0x094F, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    7ae6:	8a e0       	ldi	r24, 0x0A	; 10
    7ae8:	80 93 ef 03 	sts	0x03EF, r24
    7aec:	08 95       	ret

00007aee <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    7aee:	ff 92       	push	r15
    7af0:	0f 93       	push	r16
    7af2:	1f 93       	push	r17
    7af4:	cf 93       	push	r28
    7af6:	df 93       	push	r29
    7af8:	f8 2e       	mov	r15, r24
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    7afa:	08 2f       	mov	r16, r24
    7afc:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7afe:	c8 01       	movw	r24, r16
    7b00:	83 5a       	subi	r24, 0xA3	; 163
    7b02:	9f 4f       	sbci	r25, 0xFF	; 255
    7b04:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7b08:	e8 01       	movw	r28, r16
    7b0a:	c9 52       	subi	r28, 0x29	; 41
    7b0c:	d6 4f       	sbci	r29, 0xF6	; 246
    7b0e:	81 11       	cpse	r24, r1
    7b10:	0c c0       	rjmp	.+24     	; 0x7b2a <OneWireStartADC+0x3c>
		Temperature[CH] = Therm_Off_Mark;
    7b12:	f8 01       	movw	r30, r16
    7b14:	ee 0f       	add	r30, r30
    7b16:	ff 1f       	adc	r31, r31
    7b18:	eb 51       	subi	r30, 0x1B	; 27
    7b1a:	fa 4f       	sbci	r31, 0xFA	; 250
    7b1c:	80 e0       	ldi	r24, 0x00	; 0
    7b1e:	90 e8       	ldi	r25, 0x80	; 128
    7b20:	91 83       	std	Z+1, r25	; 0x01
    7b22:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    7b24:	82 e0       	ldi	r24, 0x02	; 2
    7b26:	88 83       	st	Y, r24
		return;
    7b28:	37 c0       	rjmp	.+110    	; 0x7b98 <OneWireStartADC+0xaa>
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7b2a:	f8 94       	cli
    7b2c:	8f 2d       	mov	r24, r15
    7b2e:	0e 94 fe 2e 	call	0x5dfc	; 0x5dfc <OW_MasterPullLowBus>
    7b32:	78 94       	sei
	Delay_us(580);	
    7b34:	84 e4       	ldi	r24, 0x44	; 68
    7b36:	92 e0       	ldi	r25, 0x02	; 2
    7b38:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7b3c:	f8 94       	cli
    7b3e:	8f 2d       	mov	r24, r15
    7b40:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>
    7b44:	87 e1       	ldi	r24, 0x17	; 23
    7b46:	91 e0       	ldi	r25, 0x01	; 1
    7b48:	01 97       	sbiw	r24, 0x01	; 1
    7b4a:	f1 f7       	brne	.-4      	; 0x7b48 <OneWireStartADC+0x5a>
    7b4c:	00 c0       	rjmp	.+0      	; 0x7b4e <OneWireStartADC+0x60>
    7b4e:	00 00       	nop
    7b50:	80 91 63 00 	lds	r24, 0x0063
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    7b54:	80 fd       	sbrc	r24, 0
    7b56:	03 c0       	rjmp	.+6      	; 0x7b5e <OneWireStartADC+0x70>
    7b58:	81 e0       	ldi	r24, 0x01	; 1
    7b5a:	88 83       	st	Y, r24
    7b5c:	08 c0       	rjmp	.+16     	; 0x7b6e <OneWireStartADC+0x80>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    7b5e:	82 e0       	ldi	r24, 0x02	; 2
    7b60:	88 83       	st	Y, r24
		DS18B20_Error[CH]++;
    7b62:	f8 01       	movw	r30, r16
    7b64:	e1 51       	subi	r30, 0x11	; 17
    7b66:	fc 4f       	sbci	r31, 0xFC	; 252
    7b68:	80 81       	ld	r24, Z
    7b6a:	8f 5f       	subi	r24, 0xFF	; 255
    7b6c:	80 83       	st	Z, r24
	}
	sei();
    7b6e:	78 94       	sei
	
	Delay_us(510);
    7b70:	8e ef       	ldi	r24, 0xFE	; 254
    7b72:	91 e0       	ldi	r25, 0x01	; 1
    7b74:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7b78:	88 81       	ld	r24, Y
    7b7a:	82 30       	cpi	r24, 0x02	; 2
    7b7c:	69 f0       	breq	.+26     	; 0x7b98 <OneWireStartADC+0xaa>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7b7e:	6c ec       	ldi	r22, 0xCC	; 204
    7b80:	8f 2d       	mov	r24, r15
    7b82:	0e 94 f7 3c 	call	0x79ee	; 0x79ee <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7b86:	64 e4       	ldi	r22, 0x44	; 68
    7b88:	8f 2d       	mov	r24, r15
	}
}
    7b8a:	df 91       	pop	r29
    7b8c:	cf 91       	pop	r28
    7b8e:	1f 91       	pop	r17
    7b90:	0f 91       	pop	r16
    7b92:	ff 90       	pop	r15
	
	Delay_us(510);

	if(DS18B20_Status[CH] != DS18B20_ERROR){
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7b94:	0c 94 f7 3c 	jmp	0x79ee	; 0x79ee <OW_MasterTx_Command>
	}
}
    7b98:	df 91       	pop	r29
    7b9a:	cf 91       	pop	r28
    7b9c:	1f 91       	pop	r17
    7b9e:	0f 91       	pop	r16
    7ba0:	ff 90       	pop	r15
    7ba2:	08 95       	ret

00007ba4 <OneWireReadTemp>:
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    7ba4:	8f 92       	push	r8
    7ba6:	9f 92       	push	r9
    7ba8:	af 92       	push	r10
    7baa:	bf 92       	push	r11
    7bac:	cf 92       	push	r12
    7bae:	df 92       	push	r13
    7bb0:	ef 92       	push	r14
    7bb2:	ff 92       	push	r15
    7bb4:	1f 93       	push	r17
    7bb6:	cf 93       	push	r28
    7bb8:	df 93       	push	r29
    7bba:	18 2f       	mov	r17, r24
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    7bbc:	c8 2f       	mov	r28, r24
    7bbe:	d0 e0       	ldi	r29, 0x00	; 0
    7bc0:	ce 01       	movw	r24, r28
    7bc2:	83 5a       	subi	r24, 0xA3	; 163
    7bc4:	9f 4f       	sbci	r25, 0xFF	; 255
    7bc6:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7bca:	9e 01       	movw	r18, r28
    7bcc:	29 52       	subi	r18, 0x29	; 41
    7bce:	36 4f       	sbci	r19, 0xF6	; 246
    7bd0:	79 01       	movw	r14, r18
    7bd2:	fe 01       	movw	r30, r28
    7bd4:	e1 51       	subi	r30, 0x11	; 17
    7bd6:	fc 4f       	sbci	r31, 0xFC	; 252
    7bd8:	81 11       	cpse	r24, r1
    7bda:	0c c0       	rjmp	.+24     	; 0x7bf4 <OneWireReadTemp+0x50>
		Temperature[CH] = Therm_Off_Mark;
    7bdc:	cc 0f       	add	r28, r28
    7bde:	dd 1f       	adc	r29, r29
    7be0:	cb 51       	subi	r28, 0x1B	; 27
    7be2:	da 4f       	sbci	r29, 0xFA	; 250
    7be4:	80 e0       	ldi	r24, 0x00	; 0
    7be6:	90 e8       	ldi	r25, 0x80	; 128
    7be8:	99 83       	std	Y+1, r25	; 0x01
    7bea:	88 83       	st	Y, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    7bec:	d7 01       	movw	r26, r14
    7bee:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    7bf0:	10 82       	st	Z, r1
		return;
    7bf2:	a0 c0       	rjmp	.+320    	; 0x7d34 <OneWireReadTemp+0x190>
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    7bf4:	d9 01       	movw	r26, r18
    7bf6:	8c 91       	ld	r24, X
    7bf8:	82 30       	cpi	r24, 0x02	; 2
    7bfa:	79 f4       	brne	.+30     	; 0x7c1a <OneWireReadTemp+0x76>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    7bfc:	80 81       	ld	r24, Z
    7bfe:	8a 30       	cpi	r24, 0x0A	; 10
    7c00:	48 f0       	brcs	.+18     	; 0x7c14 <OneWireReadTemp+0x70>
    7c02:	cc 0f       	add	r28, r28
    7c04:	dd 1f       	adc	r29, r29
    7c06:	cb 51       	subi	r28, 0x1B	; 27
    7c08:	da 4f       	sbci	r29, 0xFA	; 250
    7c0a:	81 e0       	ldi	r24, 0x01	; 1
    7c0c:	90 e8       	ldi	r25, 0x80	; 128
    7c0e:	99 83       	std	Y+1, r25	; 0x01
    7c10:	88 83       	st	Y, r24
    7c12:	90 c0       	rjmp	.+288    	; 0x7d34 <OneWireReadTemp+0x190>
		else DS18B20_Error[CH]++;
    7c14:	8f 5f       	subi	r24, 0xFF	; 255
    7c16:	80 83       	st	Z, r24
    7c18:	8d c0       	rjmp	.+282    	; 0x7d34 <OneWireReadTemp+0x190>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    7c1a:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7c1c:	f8 94       	cli
    7c1e:	81 2f       	mov	r24, r17
    7c20:	0e 94 fe 2e 	call	0x5dfc	; 0x5dfc <OW_MasterPullLowBus>
    7c24:	78 94       	sei
	Delay_us(580);
    7c26:	84 e4       	ldi	r24, 0x44	; 68
    7c28:	92 e0       	ldi	r25, 0x02	; 2
    7c2a:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7c2e:	f8 94       	cli
    7c30:	81 2f       	mov	r24, r17
    7c32:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    7c36:	86 e4       	ldi	r24, 0x46	; 70
    7c38:	90 e0       	ldi	r25, 0x00	; 0
    7c3a:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>
    7c3e:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    7c42:	80 ff       	sbrs	r24, 0
    7c44:	03 c0       	rjmp	.+6      	; 0x7c4c <OneWireReadTemp+0xa8>
    7c46:	82 e0       	ldi	r24, 0x02	; 2
    7c48:	f7 01       	movw	r30, r14
    7c4a:	80 83       	st	Z, r24
	sei();
    7c4c:	78 94       	sei
	Delay_us(510);
    7c4e:	8e ef       	ldi	r24, 0xFE	; 254
    7c50:	91 e0       	ldi	r25, 0x01	; 1
    7c52:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7c56:	d7 01       	movw	r26, r14
    7c58:	8c 91       	ld	r24, X
    7c5a:	82 30       	cpi	r24, 0x02	; 2
    7c5c:	09 f4       	brne	.+2      	; 0x7c60 <OneWireReadTemp+0xbc>
    7c5e:	6a c0       	rjmp	.+212    	; 0x7d34 <OneWireReadTemp+0x190>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7c60:	6c ec       	ldi	r22, 0xCC	; 204
    7c62:	81 2f       	mov	r24, r17
    7c64:	0e 94 f7 3c 	call	0x79ee	; 0x79ee <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    7c68:	6e eb       	ldi	r22, 0xBE	; 190
    7c6a:	81 2f       	mov	r24, r17
    7c6c:	0e 94 f7 3c 	call	0x79ee	; 0x79ee <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    7c70:	81 2f       	mov	r24, r17
    7c72:	0e 94 32 3d 	call	0x7a64	; 0x7a64 <OW_MasterRx_Data>
    7c76:	e8 2e       	mov	r14, r24
    7c78:	f1 2c       	mov	r15, r1
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    7c7a:	81 2f       	mov	r24, r17
    7c7c:	0e 94 32 3d 	call	0x7a64	; 0x7a64 <OW_MasterRx_Data>
    7c80:	f8 2a       	or	r15, r24
		Tres = (Tres*10)/16;
    7c82:	8a e0       	ldi	r24, 0x0A	; 10
    7c84:	8e 9d       	mul	r24, r14
    7c86:	b0 01       	movw	r22, r0
    7c88:	8f 9d       	mul	r24, r15
    7c8a:	70 0d       	add	r23, r0
    7c8c:	11 24       	eor	r1, r1
    7c8e:	77 ff       	sbrs	r23, 7
    7c90:	02 c0       	rjmp	.+4      	; 0x7c96 <OneWireReadTemp+0xf2>
    7c92:	61 5f       	subi	r22, 0xF1	; 241
    7c94:	7f 4f       	sbci	r23, 0xFF	; 255
    7c96:	4b 01       	movw	r8, r22
    7c98:	94 e0       	ldi	r25, 0x04	; 4
    7c9a:	95 94       	asr	r9
    7c9c:	87 94       	ror	r8
    7c9e:	9a 95       	dec	r25
    7ca0:	e1 f7       	brne	.-8      	; 0x7c9a <OneWireReadTemp+0xf6>
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    7ca2:	b2 e5       	ldi	r27, 0x52	; 82
    7ca4:	8b 16       	cp	r8, r27
    7ca6:	b3 e0       	ldi	r27, 0x03	; 3
    7ca8:	9b 06       	cpc	r9, r27
    7caa:	b1 f1       	breq	.+108    	; 0x7d18 <OneWireReadTemp+0x174>
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    7cac:	7e 01       	movw	r14, r28
    7cae:	ee 0c       	add	r14, r14
    7cb0:	ff 1c       	adc	r15, r15
    7cb2:	ce 0d       	add	r28, r14
    7cb4:	df 1d       	adc	r29, r15
    7cb6:	ce 01       	movw	r24, r28
    7cb8:	86 5a       	subi	r24, 0xA6	; 166
    7cba:	9f 4f       	sbci	r25, 0xFF	; 255
    7cbc:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    7cc0:	d8 2e       	mov	r13, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    7cc2:	ce 01       	movw	r24, r28
    7cc4:	85 5a       	subi	r24, 0xA5	; 165
    7cc6:	9f 4f       	sbci	r25, 0xFF	; 255
    7cc8:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    7ccc:	5c 01       	movw	r10, r24
    7cce:	e7 01       	movw	r28, r14
    7cd0:	cb 51       	subi	r28, 0x1B	; 27
    7cd2:	da 4f       	sbci	r29, 0xFA	; 250
    7cd4:	b4 01       	movw	r22, r8
    7cd6:	6d 0d       	add	r22, r13
    7cd8:	71 1d       	adc	r23, r1
    7cda:	d7 fc       	sbrc	r13, 7
    7cdc:	7a 95       	dec	r23
    7cde:	88 27       	eor	r24, r24
    7ce0:	77 fd       	sbrc	r23, 7
    7ce2:	80 95       	com	r24
    7ce4:	98 2f       	mov	r25, r24
    7ce6:	0e 94 69 79 	call	0xf2d2	; 0xf2d2 <__floatsisf>
    7cea:	6b 01       	movw	r12, r22
    7cec:	7c 01       	movw	r14, r24
    7cee:	b5 01       	movw	r22, r10
    7cf0:	80 e0       	ldi	r24, 0x00	; 0
    7cf2:	90 e0       	ldi	r25, 0x00	; 0
    7cf4:	0e 94 67 79 	call	0xf2ce	; 0xf2ce <__floatunsisf>
    7cf8:	20 e0       	ldi	r18, 0x00	; 0
    7cfa:	30 e0       	ldi	r19, 0x00	; 0
    7cfc:	4a e7       	ldi	r20, 0x7A	; 122
    7cfe:	54 e4       	ldi	r21, 0x44	; 68
    7d00:	0e 94 ce 78 	call	0xf19c	; 0xf19c <__divsf3>
    7d04:	9b 01       	movw	r18, r22
    7d06:	ac 01       	movw	r20, r24
    7d08:	c7 01       	movw	r24, r14
    7d0a:	b6 01       	movw	r22, r12
    7d0c:	0e 94 f5 79 	call	0xf3ea	; 0xf3ea <__mulsf3>
    7d10:	0e 94 36 79 	call	0xf26c	; 0xf26c <__fixsfsi>
    7d14:	79 83       	std	Y+1, r23	; 0x01
    7d16:	68 83       	st	Y, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    7d18:	f8 94       	cli
    7d1a:	81 2f       	mov	r24, r17
    7d1c:	0e 94 fe 2e 	call	0x5dfc	; 0x5dfc <OW_MasterPullLowBus>
    7d20:	78 94       	sei
		Delay_us(580);	
    7d22:	84 e4       	ldi	r24, 0x44	; 68
    7d24:	92 e0       	ldi	r25, 0x02	; 2
    7d26:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    7d2a:	f8 94       	cli
    7d2c:	81 2f       	mov	r24, r17
    7d2e:	0e 94 0b 2f 	call	0x5e16	; 0x5e16 <OW_MasterReleaseBus>
    7d32:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    7d34:	df 91       	pop	r29
    7d36:	cf 91       	pop	r28
    7d38:	1f 91       	pop	r17
    7d3a:	ff 90       	pop	r15
    7d3c:	ef 90       	pop	r14
    7d3e:	df 90       	pop	r13
    7d40:	cf 90       	pop	r12
    7d42:	bf 90       	pop	r11
    7d44:	af 90       	pop	r10
    7d46:	9f 90       	pop	r9
    7d48:	8f 90       	pop	r8
    7d4a:	08 95       	ret

00007d4c <DS18B20>:
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    7d4c:	80 91 4f 09 	lds	r24, 0x094F
    7d50:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    7d54:	88 23       	and	r24, r24
    7d56:	11 f1       	breq	.+68     	; 0x7d9c <DS18B20+0x50>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    7d58:	80 91 4e 02 	lds	r24, 0x024E
    7d5c:	87 30       	cpi	r24, 0x07	; 7
    7d5e:	18 f0       	brcs	.+6      	; 0x7d66 <DS18B20+0x1a>
    7d60:	81 e0       	ldi	r24, 0x01	; 1
    7d62:	80 93 4e 02 	sts	0x024E, r24
		
			switch(DS18B20_Mode){
    7d66:	80 91 4e 02 	lds	r24, 0x024E
    7d6a:	81 30       	cpi	r24, 0x01	; 1
    7d6c:	39 f0       	breq	.+14     	; 0x7d7c <DS18B20+0x30>
    7d6e:	84 30       	cpi	r24, 0x04	; 4
    7d70:	81 f4       	brne	.+32     	; 0x7d92 <DS18B20+0x46>
				StartTimer8(TD_DS18B20Read, 100);
				DS18B20_Mode = DS18B20_START_ADC3;
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    7d72:	80 e0       	ldi	r24, 0x00	; 0
    7d74:	0e 94 d2 3d 	call	0x7ba4	; 0x7ba4 <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    7d78:	86 e0       	ldi	r24, 0x06	; 6
    7d7a:	09 c0       	rjmp	.+18     	; 0x7d8e <DS18B20+0x42>
			switch(DS18B20_Mode){
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    7d7c:	80 e0       	ldi	r24, 0x00	; 0
    7d7e:	0e 94 77 3d 	call	0x7aee	; 0x7aee <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    7d82:	64 e6       	ldi	r22, 0x64	; 100
    7d84:	80 91 4f 09 	lds	r24, 0x094F
    7d88:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    7d8c:	83 e0       	ldi	r24, 0x03	; 3
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
				DS18B20_Mode = DS18B20_READ_T3;
    7d8e:	80 93 4e 02 	sts	0x024E, r24
				break;
			}
			DS18B20_Mode++;
    7d92:	80 91 4e 02 	lds	r24, 0x024E
    7d96:	8f 5f       	subi	r24, 0xFF	; 255
    7d98:	80 93 4e 02 	sts	0x024E, r24
    7d9c:	08 95       	ret

00007d9e <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7d9e:	cf 93       	push	r28
    7da0:	df 93       	push	r29
    7da2:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7da4:	ec 81       	ldd	r30, Y+4	; 0x04
    7da6:	fd 81       	ldd	r31, Y+5	; 0x05
    7da8:	65 91       	lpm	r22, Z+
    7daa:	74 91       	lpm	r23, Z
	strcpy_P(Param->Pos, prp(Param->Txt));
    7dac:	88 81       	ld	r24, Y
    7dae:	99 81       	ldd	r25, Y+1	; 0x01
    7db0:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7db4:	a8 81       	ld	r26, Y
    7db6:	b9 81       	ldd	r27, Y+1	; 0x01
    7db8:	fd 01       	movw	r30, r26
    7dba:	01 90       	ld	r0, Z+
    7dbc:	00 20       	and	r0, r0
    7dbe:	e9 f7       	brne	.-6      	; 0x7dba <PutEnum+0x1c>
    7dc0:	31 97       	sbiw	r30, 0x01	; 1
    7dc2:	4e 2f       	mov	r20, r30
    7dc4:	4a 1b       	sub	r20, r26
    7dc6:	80 e0       	ldi	r24, 0x00	; 0
    7dc8:	90 e0       	ldi	r25, 0x00	; 0
    7dca:	50 e2       	ldi	r21, 0x20	; 32
    7dcc:	24 2f       	mov	r18, r20
    7dce:	28 0f       	add	r18, r24
    7dd0:	01 96       	adiw	r24, 0x01	; 1
    7dd2:	3b 81       	ldd	r19, Y+3	; 0x03
    7dd4:	23 17       	cp	r18, r19
    7dd6:	30 f4       	brcc	.+12     	; 0x7de4 <PutEnum+0x46>
    7dd8:	e8 81       	ld	r30, Y
    7dda:	f9 81       	ldd	r31, Y+1	; 0x01
    7ddc:	e2 0f       	add	r30, r18
    7dde:	f1 1d       	adc	r31, r1
    7de0:	50 83       	st	Z, r21
    7de2:	f4 cf       	rjmp	.-24     	; 0x7dcc <PutEnum+0x2e>
}
    7de4:	df 91       	pop	r29
    7de6:	cf 91       	pop	r28
    7de8:	08 95       	ret

00007dea <PutVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    7dea:	cf 92       	push	r12
    7dec:	df 92       	push	r13
    7dee:	ef 92       	push	r14
    7df0:	ff 92       	push	r15
    7df2:	0f 93       	push	r16
    7df4:	1f 93       	push	r17
    7df6:	cf 93       	push	r28
    7df8:	df 93       	push	r29
    7dfa:	cd b7       	in	r28, 0x3d	; 61
    7dfc:	de b7       	in	r29, 0x3e	; 62
    7dfe:	29 97       	sbiw	r28, 0x09	; 9
    7e00:	0f b6       	in	r0, 0x3f	; 63
    7e02:	f8 94       	cli
    7e04:	de bf       	out	0x3e, r29	; 62
    7e06:	0f be       	out	0x3f, r0	; 63
    7e08:	cd bf       	out	0x3d, r28	; 61
    7e0a:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7e0c:	67 37       	cpi	r22, 0x77	; 119
    7e0e:	19 f4       	brne	.+6      	; 0x7e16 <PutVal+0x2c>
    7e10:	8f ef       	ldi	r24, 0xFF	; 255
    7e12:	9f ef       	ldi	r25, 0xFF	; 255
    7e14:	02 c0       	rjmp	.+4      	; 0x7e1a <PutVal+0x30>
    7e16:	8f ef       	ldi	r24, 0xFF	; 255
    7e18:	90 e0       	ldi	r25, 0x00	; 0
    7e1a:	8e 19       	sub	r24, r14
    7e1c:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7e1e:	fa 01       	movw	r30, r20
    7e20:	24 81       	ldd	r18, Z+4	; 0x04
    7e22:	35 81       	ldd	r19, Z+5	; 0x05
    7e24:	21 15       	cp	r18, r1
    7e26:	31 05       	cpc	r19, r1
    7e28:	69 f0       	breq	.+26     	; 0x7e44 <PutVal+0x5a>
    7e2a:	82 30       	cpi	r24, 0x02	; 2
    7e2c:	91 05       	cpc	r25, r1
    7e2e:	50 f4       	brcc	.+20     	; 0x7e44 <PutVal+0x5a>
		Param->Txt += Idx;
    7e30:	88 0f       	add	r24, r24
    7e32:	99 1f       	adc	r25, r25
    7e34:	82 0f       	add	r24, r18
    7e36:	93 1f       	adc	r25, r19
    7e38:	95 83       	std	Z+5, r25	; 0x05
    7e3a:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7e3c:	ca 01       	movw	r24, r20
    7e3e:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
    7e42:	3f c0       	rjmp	.+126    	; 0x7ec2 <PutVal+0xd8>
		return;
	}
	char Format[] = "% u.%. u";
    7e44:	89 e0       	ldi	r24, 0x09	; 9
    7e46:	ef e0       	ldi	r30, 0x0F	; 15
    7e48:	f1 e0       	ldi	r31, 0x01	; 1
    7e4a:	8e 01       	movw	r16, r28
    7e4c:	0f 5f       	subi	r16, 0xFF	; 255
    7e4e:	1f 4f       	sbci	r17, 0xFF	; 255
    7e50:	d8 01       	movw	r26, r16
    7e52:	01 90       	ld	r0, Z+
    7e54:	0d 92       	st	X+, r0
    7e56:	8a 95       	dec	r24
    7e58:	e1 f7       	brne	.-8      	; 0x7e52 <PutVal+0x68>
	Format[1] = '0'+Param->Size;
    7e5a:	fa 01       	movw	r30, r20
    7e5c:	93 81       	ldd	r25, Z+3	; 0x03
    7e5e:	90 5d       	subi	r25, 0xD0	; 208
    7e60:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    7e62:	82 81       	ldd	r24, Z+2	; 0x02
    7e64:	c1 80       	ldd	r12, Z+1	; 0x01
    7e66:	d0 80       	ld	r13, Z
    7e68:	88 23       	and	r24, r24
    7e6a:	e1 f0       	breq	.+56     	; 0x7ea4 <PutVal+0xba>
		Format[1] -= Param->Prec+1;
    7e6c:	98 1b       	sub	r25, r24
    7e6e:	91 50       	subi	r25, 0x01	; 1
    7e70:	9a 83       	std	Y+2, r25	; 0x02
		Format[6] = '0'+Param->Prec;
    7e72:	90 e3       	ldi	r25, 0x30	; 48
    7e74:	98 0f       	add	r25, r24
    7e76:	9f 83       	std	Y+7, r25	; 0x07
		uint16_t Div=Pow10(Param->Prec);
    7e78:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <Pow10>
    7e7c:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7e7e:	c7 01       	movw	r24, r14
    7e80:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    7e84:	9f 93       	push	r25
    7e86:	8f 93       	push	r24
    7e88:	7f 93       	push	r23
    7e8a:	6f 93       	push	r22
    7e8c:	1f 93       	push	r17
    7e8e:	0f 93       	push	r16
    7e90:	cf 92       	push	r12
    7e92:	df 92       	push	r13
    7e94:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    7e98:	0f b6       	in	r0, 0x3f	; 63
    7e9a:	f8 94       	cli
    7e9c:	de bf       	out	0x3e, r29	; 62
    7e9e:	0f be       	out	0x3f, r0	; 63
    7ea0:	cd bf       	out	0x3d, r28	; 61
    7ea2:	0f c0       	rjmp	.+30     	; 0x7ec2 <PutVal+0xd8>
	}
	else {
		Format[3] = '\0';
    7ea4:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    7ea6:	ff 92       	push	r15
    7ea8:	ef 92       	push	r14
    7eaa:	1f 93       	push	r17
    7eac:	0f 93       	push	r16
    7eae:	cf 92       	push	r12
    7eb0:	df 92       	push	r13
    7eb2:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    7eb6:	0f 90       	pop	r0
    7eb8:	0f 90       	pop	r0
    7eba:	0f 90       	pop	r0
    7ebc:	0f 90       	pop	r0
    7ebe:	0f 90       	pop	r0
    7ec0:	0f 90       	pop	r0
	}
}
    7ec2:	29 96       	adiw	r28, 0x09	; 9
    7ec4:	0f b6       	in	r0, 0x3f	; 63
    7ec6:	f8 94       	cli
    7ec8:	de bf       	out	0x3e, r29	; 62
    7eca:	0f be       	out	0x3f, r0	; 63
    7ecc:	cd bf       	out	0x3d, r28	; 61
    7ece:	df 91       	pop	r29
    7ed0:	cf 91       	pop	r28
    7ed2:	1f 91       	pop	r17
    7ed4:	0f 91       	pop	r16
    7ed6:	ff 90       	pop	r15
    7ed8:	ef 90       	pop	r14
    7eda:	df 90       	pop	r13
    7edc:	cf 90       	pop	r12
    7ede:	08 95       	ret

00007ee0 <Put_sVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    7ee0:	af 92       	push	r10
    7ee2:	bf 92       	push	r11
    7ee4:	cf 92       	push	r12
    7ee6:	df 92       	push	r13
    7ee8:	ef 92       	push	r14
    7eea:	ff 92       	push	r15
    7eec:	0f 93       	push	r16
    7eee:	1f 93       	push	r17
    7ef0:	cf 93       	push	r28
    7ef2:	df 93       	push	r29
    7ef4:	cd b7       	in	r28, 0x3d	; 61
    7ef6:	de b7       	in	r29, 0x3e	; 62
    7ef8:	2a 97       	sbiw	r28, 0x0a	; 10
    7efa:	0f b6       	in	r0, 0x3f	; 63
    7efc:	f8 94       	cli
    7efe:	de bf       	out	0x3e, r29	; 62
    7f00:	0f be       	out	0x3f, r0	; 63
    7f02:	cd bf       	out	0x3d, r28	; 61
    7f04:	7c 01       	movw	r14, r24
    7f06:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    7f08:	67 37       	cpi	r22, 0x77	; 119
    7f0a:	19 f4       	brne	.+6      	; 0x7f12 <Put_sVal+0x32>
    7f0c:	80 e0       	ldi	r24, 0x00	; 0
    7f0e:	90 e8       	ldi	r25, 0x80	; 128
    7f10:	02 c0       	rjmp	.+4      	; 0x7f16 <Put_sVal+0x36>
    7f12:	80 e8       	ldi	r24, 0x80	; 128
    7f14:	90 e0       	ldi	r25, 0x00	; 0
    7f16:	8e 0d       	add	r24, r14
    7f18:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    7f1a:	d8 01       	movw	r26, r16
    7f1c:	14 96       	adiw	r26, 0x04	; 4
    7f1e:	2d 91       	ld	r18, X+
    7f20:	3c 91       	ld	r19, X
    7f22:	15 97       	sbiw	r26, 0x05	; 5
    7f24:	21 15       	cp	r18, r1
    7f26:	31 05       	cpc	r19, r1
    7f28:	79 f0       	breq	.+30     	; 0x7f48 <Put_sVal+0x68>
    7f2a:	82 30       	cpi	r24, 0x02	; 2
    7f2c:	91 05       	cpc	r25, r1
    7f2e:	60 f4       	brcc	.+24     	; 0x7f48 <Put_sVal+0x68>
		Param->Txt += Idx;
    7f30:	88 0f       	add	r24, r24
    7f32:	99 1f       	adc	r25, r25
    7f34:	82 0f       	add	r24, r18
    7f36:	93 1f       	adc	r25, r19
    7f38:	15 96       	adiw	r26, 0x05	; 5
    7f3a:	9c 93       	st	X, r25
    7f3c:	8e 93       	st	-X, r24
    7f3e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    7f40:	c8 01       	movw	r24, r16
    7f42:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
    7f46:	65 c0       	rjmp	.+202    	; 0x8012 <Put_sVal+0x132>
		return;
	}
	char Format[] = "%+ d.%. u";
    7f48:	8a e0       	ldi	r24, 0x0A	; 10
    7f4a:	e8 e1       	ldi	r30, 0x18	; 24
    7f4c:	f1 e0       	ldi	r31, 0x01	; 1
    7f4e:	9e 01       	movw	r18, r28
    7f50:	2f 5f       	subi	r18, 0xFF	; 255
    7f52:	3f 4f       	sbci	r19, 0xFF	; 255
    7f54:	69 01       	movw	r12, r18
    7f56:	d9 01       	movw	r26, r18
    7f58:	01 90       	ld	r0, Z+
    7f5a:	0d 92       	st	X+, r0
    7f5c:	8a 95       	dec	r24
    7f5e:	e1 f7       	brne	.-8      	; 0x7f58 <Put_sVal+0x78>
	if(Val==0)
    7f60:	e1 14       	cp	r14, r1
    7f62:	f1 04       	cpc	r15, r1
    7f64:	11 f4       	brne	.+4      	; 0x7f6a <Put_sVal+0x8a>
		Format[1] = ' ';
    7f66:	80 e2       	ldi	r24, 0x20	; 32
    7f68:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    7f6a:	d8 01       	movw	r26, r16
    7f6c:	13 96       	adiw	r26, 0x03	; 3
    7f6e:	9c 91       	ld	r25, X
    7f70:	13 97       	sbiw	r26, 0x03	; 3
    7f72:	90 5d       	subi	r25, 0xD0	; 208
    7f74:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7f76:	12 96       	adiw	r26, 0x02	; 2
    7f78:	8c 91       	ld	r24, X
    7f7a:	12 97       	sbiw	r26, 0x02	; 2
    7f7c:	11 96       	adiw	r26, 0x01	; 1
    7f7e:	ac 90       	ld	r10, X
    7f80:	11 97       	sbiw	r26, 0x01	; 1
    7f82:	bc 90       	ld	r11, X
    7f84:	88 23       	and	r24, r24
    7f86:	b1 f1       	breq	.+108    	; 0x7ff4 <Put_sVal+0x114>
		Format[2] -= Param->Prec+1;
    7f88:	98 1b       	sub	r25, r24
    7f8a:	91 50       	subi	r25, 0x01	; 1
    7f8c:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7f8e:	90 e3       	ldi	r25, 0x30	; 48
    7f90:	98 0f       	add	r25, r24
    7f92:	98 87       	std	Y+8, r25	; 0x08
		int16_t Div=Pow10(Param->Prec);
    7f94:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <Pow10>
    7f98:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    7f9a:	c7 01       	movw	r24, r14
    7f9c:	f7 fe       	sbrs	r15, 7
    7f9e:	04 c0       	rjmp	.+8      	; 0x7fa8 <Put_sVal+0xc8>
    7fa0:	88 27       	eor	r24, r24
    7fa2:	99 27       	eor	r25, r25
    7fa4:	8e 19       	sub	r24, r14
    7fa6:	9f 09       	sbc	r25, r15
    7fa8:	b9 01       	movw	r22, r18
    7faa:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    7fae:	9f 93       	push	r25
    7fb0:	8f 93       	push	r24
    7fb2:	c7 01       	movw	r24, r14
    7fb4:	b9 01       	movw	r22, r18
    7fb6:	0e 94 97 80 	call	0x1012e	; 0x1012e <__divmodhi4>
    7fba:	7f 93       	push	r23
    7fbc:	6f 93       	push	r22
    7fbe:	df 92       	push	r13
    7fc0:	cf 92       	push	r12
    7fc2:	af 92       	push	r10
    7fc4:	bf 92       	push	r11
    7fc6:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
		if(Val<0) {
    7fca:	0f b6       	in	r0, 0x3f	; 63
    7fcc:	f8 94       	cli
    7fce:	de bf       	out	0x3e, r29	; 62
    7fd0:	0f be       	out	0x3f, r0	; 63
    7fd2:	cd bf       	out	0x3d, r28	; 61
    7fd4:	f7 fe       	sbrs	r15, 7
    7fd6:	1d c0       	rjmp	.+58     	; 0x8012 <Put_sVal+0x132>
			while(*Param->Pos==' ')
    7fd8:	d8 01       	movw	r26, r16
    7fda:	ed 91       	ld	r30, X+
    7fdc:	fc 91       	ld	r31, X
    7fde:	80 81       	ld	r24, Z
    7fe0:	80 32       	cpi	r24, 0x20	; 32
    7fe2:	29 f4       	brne	.+10     	; 0x7fee <Put_sVal+0x10e>
				Param->Pos++;
    7fe4:	31 96       	adiw	r30, 0x01	; 1
    7fe6:	d8 01       	movw	r26, r16
    7fe8:	ed 93       	st	X+, r30
    7fea:	fc 93       	st	X, r31
    7fec:	f5 cf       	rjmp	.-22     	; 0x7fd8 <Put_sVal+0xf8>
			*Param->Pos = '-';
    7fee:	8d e2       	ldi	r24, 0x2D	; 45
    7ff0:	80 83       	st	Z, r24
    7ff2:	0f c0       	rjmp	.+30     	; 0x8012 <Put_sVal+0x132>
		}
	}
	else {
		Format[4] = '\0';
    7ff4:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7ff6:	ff 92       	push	r15
    7ff8:	ef 92       	push	r14
    7ffa:	df 92       	push	r13
    7ffc:	cf 92       	push	r12
    7ffe:	af 92       	push	r10
    8000:	bf 92       	push	r11
    8002:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8006:	0f 90       	pop	r0
    8008:	0f 90       	pop	r0
    800a:	0f 90       	pop	r0
    800c:	0f 90       	pop	r0
    800e:	0f 90       	pop	r0
    8010:	0f 90       	pop	r0
	}
}
    8012:	2a 96       	adiw	r28, 0x0a	; 10
    8014:	0f b6       	in	r0, 0x3f	; 63
    8016:	f8 94       	cli
    8018:	de bf       	out	0x3e, r29	; 62
    801a:	0f be       	out	0x3f, r0	; 63
    801c:	cd bf       	out	0x3d, r28	; 61
    801e:	df 91       	pop	r29
    8020:	cf 91       	pop	r28
    8022:	1f 91       	pop	r17
    8024:	0f 91       	pop	r16
    8026:	ff 90       	pop	r15
    8028:	ef 90       	pop	r14
    802a:	df 90       	pop	r13
    802c:	cf 90       	pop	r12
    802e:	bf 90       	pop	r11
    8030:	af 90       	pop	r10
    8032:	08 95       	ret

00008034 <Put_zVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    8034:	cf 92       	push	r12
    8036:	df 92       	push	r13
    8038:	ef 92       	push	r14
    803a:	ff 92       	push	r15
    803c:	0f 93       	push	r16
    803e:	1f 93       	push	r17
    8040:	cf 93       	push	r28
    8042:	df 93       	push	r29
    8044:	cd b7       	in	r28, 0x3d	; 61
    8046:	de b7       	in	r29, 0x3e	; 62
    8048:	2a 97       	sbiw	r28, 0x0a	; 10
    804a:	0f b6       	in	r0, 0x3f	; 63
    804c:	f8 94       	cli
    804e:	de bf       	out	0x3e, r29	; 62
    8050:	0f be       	out	0x3f, r0	; 63
    8052:	cd bf       	out	0x3d, r28	; 61
    8054:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    8056:	67 37       	cpi	r22, 0x77	; 119
    8058:	19 f4       	brne	.+6      	; 0x8060 <Put_zVal+0x2c>
    805a:	8f ef       	ldi	r24, 0xFF	; 255
    805c:	9f ef       	ldi	r25, 0xFF	; 255
    805e:	02 c0       	rjmp	.+4      	; 0x8064 <Put_zVal+0x30>
    8060:	8f ef       	ldi	r24, 0xFF	; 255
    8062:	90 e0       	ldi	r25, 0x00	; 0
    8064:	8e 19       	sub	r24, r14
    8066:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    8068:	fa 01       	movw	r30, r20
    806a:	24 81       	ldd	r18, Z+4	; 0x04
    806c:	35 81       	ldd	r19, Z+5	; 0x05
    806e:	21 15       	cp	r18, r1
    8070:	31 05       	cpc	r19, r1
    8072:	69 f0       	breq	.+26     	; 0x808e <Put_zVal+0x5a>
    8074:	82 30       	cpi	r24, 0x02	; 2
    8076:	91 05       	cpc	r25, r1
    8078:	50 f4       	brcc	.+20     	; 0x808e <Put_zVal+0x5a>
		Param->Txt += Idx;
    807a:	88 0f       	add	r24, r24
    807c:	99 1f       	adc	r25, r25
    807e:	82 0f       	add	r24, r18
    8080:	93 1f       	adc	r25, r19
    8082:	95 83       	std	Z+5, r25	; 0x05
    8084:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    8086:	ca 01       	movw	r24, r20
    8088:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
    808c:	3f c0       	rjmp	.+126    	; 0x810c <Put_zVal+0xd8>
		return;
	}
	char Format[] = "%0 u.%. u";
    808e:	8a e0       	ldi	r24, 0x0A	; 10
    8090:	e2 e2       	ldi	r30, 0x22	; 34
    8092:	f1 e0       	ldi	r31, 0x01	; 1
    8094:	8e 01       	movw	r16, r28
    8096:	0f 5f       	subi	r16, 0xFF	; 255
    8098:	1f 4f       	sbci	r17, 0xFF	; 255
    809a:	d8 01       	movw	r26, r16
    809c:	01 90       	ld	r0, Z+
    809e:	0d 92       	st	X+, r0
    80a0:	8a 95       	dec	r24
    80a2:	e1 f7       	brne	.-8      	; 0x809c <Put_zVal+0x68>
	Format[2] = '0'+Param->Size;
    80a4:	fa 01       	movw	r30, r20
    80a6:	93 81       	ldd	r25, Z+3	; 0x03
    80a8:	90 5d       	subi	r25, 0xD0	; 208
    80aa:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    80ac:	82 81       	ldd	r24, Z+2	; 0x02
    80ae:	c1 80       	ldd	r12, Z+1	; 0x01
    80b0:	d0 80       	ld	r13, Z
    80b2:	88 23       	and	r24, r24
    80b4:	e1 f0       	breq	.+56     	; 0x80ee <Put_zVal+0xba>
		Format[2] -= Param->Prec+1;
    80b6:	98 1b       	sub	r25, r24
    80b8:	91 50       	subi	r25, 0x01	; 1
    80ba:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    80bc:	90 e3       	ldi	r25, 0x30	; 48
    80be:	98 0f       	add	r25, r24
    80c0:	98 87       	std	Y+8, r25	; 0x08
		uint16_t Div=Pow10(Param->Prec);
    80c2:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <Pow10>
    80c6:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    80c8:	c7 01       	movw	r24, r14
    80ca:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    80ce:	9f 93       	push	r25
    80d0:	8f 93       	push	r24
    80d2:	7f 93       	push	r23
    80d4:	6f 93       	push	r22
    80d6:	1f 93       	push	r17
    80d8:	0f 93       	push	r16
    80da:	cf 92       	push	r12
    80dc:	df 92       	push	r13
    80de:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    80e2:	0f b6       	in	r0, 0x3f	; 63
    80e4:	f8 94       	cli
    80e6:	de bf       	out	0x3e, r29	; 62
    80e8:	0f be       	out	0x3f, r0	; 63
    80ea:	cd bf       	out	0x3d, r28	; 61
    80ec:	0f c0       	rjmp	.+30     	; 0x810c <Put_zVal+0xd8>
	}
	else {
		Format[4] = '\0';
    80ee:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    80f0:	ff 92       	push	r15
    80f2:	ef 92       	push	r14
    80f4:	1f 93       	push	r17
    80f6:	0f 93       	push	r16
    80f8:	cf 92       	push	r12
    80fa:	df 92       	push	r13
    80fc:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8100:	0f 90       	pop	r0
    8102:	0f 90       	pop	r0
    8104:	0f 90       	pop	r0
    8106:	0f 90       	pop	r0
    8108:	0f 90       	pop	r0
    810a:	0f 90       	pop	r0
	}
}
    810c:	2a 96       	adiw	r28, 0x0a	; 10
    810e:	0f b6       	in	r0, 0x3f	; 63
    8110:	f8 94       	cli
    8112:	de bf       	out	0x3e, r29	; 62
    8114:	0f be       	out	0x3f, r0	; 63
    8116:	cd bf       	out	0x3d, r28	; 61
    8118:	df 91       	pop	r29
    811a:	cf 91       	pop	r28
    811c:	1f 91       	pop	r17
    811e:	0f 91       	pop	r16
    8120:	ff 90       	pop	r15
    8122:	ef 90       	pop	r14
    8124:	df 90       	pop	r13
    8126:	cf 90       	pop	r12
    8128:	08 95       	ret

0000812a <Put_zVal_h>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    812a:	f9 01       	movw	r30, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    812c:	42 36       	cpi	r20, 0x62	; 98
    812e:	29 f4       	brne	.+10     	; 0x813a <Put_zVal_h+0x10>
    8130:	1f 92       	push	r1
    8132:	6f 93       	push	r22
    8134:	8c e2       	ldi	r24, 0x2C	; 44
    8136:	91 e0       	ldi	r25, 0x01	; 1
    8138:	06 c0       	rjmp	.+12     	; 0x8146 <Put_zVal_h+0x1c>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    813a:	47 37       	cpi	r20, 0x77	; 119
    813c:	99 f4       	brne	.+38     	; 0x8164 <Put_zVal_h+0x3a>
    813e:	7f 93       	push	r23
    8140:	6f 93       	push	r22
    8142:	82 e3       	ldi	r24, 0x32	; 50
    8144:	91 e0       	ldi	r25, 0x01	; 1
    8146:	9f 93       	push	r25
    8148:	8f 93       	push	r24
    814a:	81 81       	ldd	r24, Z+1	; 0x01
    814c:	8f 93       	push	r24
    814e:	80 81       	ld	r24, Z
    8150:	8f 93       	push	r24
    8152:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8156:	0f 90       	pop	r0
    8158:	0f 90       	pop	r0
    815a:	0f 90       	pop	r0
    815c:	0f 90       	pop	r0
    815e:	0f 90       	pop	r0
    8160:	0f 90       	pop	r0
    8162:	08 95       	ret
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    8164:	4c 36       	cpi	r20, 0x6C	; 108
    8166:	b1 f4       	brne	.+44     	; 0x8194 <Put_zVal_h+0x6a>
    8168:	9f 93       	push	r25
    816a:	8f 93       	push	r24
    816c:	7f 93       	push	r23
    816e:	6f 93       	push	r22
    8170:	87 e3       	ldi	r24, 0x37	; 55
    8172:	91 e0       	ldi	r25, 0x01	; 1
    8174:	9f 93       	push	r25
    8176:	8f 93       	push	r24
    8178:	81 81       	ldd	r24, Z+1	; 0x01
    817a:	8f 93       	push	r24
    817c:	80 81       	ld	r24, Z
    817e:	8f 93       	push	r24
    8180:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8184:	8d b7       	in	r24, 0x3d	; 61
    8186:	9e b7       	in	r25, 0x3e	; 62
    8188:	08 96       	adiw	r24, 0x08	; 8
    818a:	0f b6       	in	r0, 0x3f	; 63
    818c:	f8 94       	cli
    818e:	9e bf       	out	0x3e, r25	; 62
    8190:	0f be       	out	0x3f, r0	; 63
    8192:	8d bf       	out	0x3d, r24	; 61
    8194:	08 95       	ret

00008196 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    8196:	af 92       	push	r10
    8198:	bf 92       	push	r11
    819a:	cf 92       	push	r12
    819c:	df 92       	push	r13
    819e:	ef 92       	push	r14
    81a0:	ff 92       	push	r15
    81a2:	0f 93       	push	r16
    81a4:	1f 93       	push	r17
    81a6:	cf 93       	push	r28
    81a8:	df 93       	push	r29
    81aa:	cd b7       	in	r28, 0x3d	; 61
    81ac:	de b7       	in	r29, 0x3e	; 62
    81ae:	2b 97       	sbiw	r28, 0x0b	; 11
    81b0:	0f b6       	in	r0, 0x3f	; 63
    81b2:	f8 94       	cli
    81b4:	de bf       	out	0x3e, r29	; 62
    81b6:	0f be       	out	0x3f, r0	; 63
    81b8:	cd bf       	out	0x3d, r28	; 61
    81ba:	6b 01       	movw	r12, r22
    81bc:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    81be:	8b 01       	movw	r16, r22
    81c0:	9c 01       	movw	r18, r24
    81c2:	00 95       	com	r16
    81c4:	10 95       	com	r17
    81c6:	20 95       	com	r18
    81c8:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    81ca:	fa 01       	movw	r30, r20
    81cc:	84 81       	ldd	r24, Z+4	; 0x04
    81ce:	95 81       	ldd	r25, Z+5	; 0x05
    81d0:	00 97       	sbiw	r24, 0x00	; 0
    81d2:	79 f0       	breq	.+30     	; 0x81f2 <PutDVal+0x5c>
    81d4:	02 30       	cpi	r16, 0x02	; 2
    81d6:	11 05       	cpc	r17, r1
    81d8:	21 05       	cpc	r18, r1
    81da:	31 05       	cpc	r19, r1
    81dc:	50 f4       	brcc	.+20     	; 0x81f2 <PutDVal+0x5c>
		Param->Txt += Idx;
    81de:	00 0f       	add	r16, r16
    81e0:	11 1f       	adc	r17, r17
    81e2:	08 0f       	add	r16, r24
    81e4:	19 1f       	adc	r17, r25
    81e6:	15 83       	std	Z+5, r17	; 0x05
    81e8:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    81ea:	ca 01       	movw	r24, r20
    81ec:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
		return;
    81f0:	54 c0       	rjmp	.+168    	; 0x829a <PutDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    81f2:	fa 01       	movw	r30, r20
    81f4:	93 81       	ldd	r25, Z+3	; 0x03
    81f6:	9a 30       	cpi	r25, 0x0A	; 10
    81f8:	81 f4       	brne	.+32     	; 0x821a <PutDVal+0x84>
    81fa:	82 81       	ldd	r24, Z+2	; 0x02
    81fc:	81 11       	cpse	r24, r1
    81fe:	0d c0       	rjmp	.+26     	; 0x821a <PutDVal+0x84>
		sprintf(Param->Pos, "%10lu", Val);
    8200:	ff 92       	push	r15
    8202:	ef 92       	push	r14
    8204:	df 92       	push	r13
    8206:	cf 92       	push	r12
    8208:	8d e3       	ldi	r24, 0x3D	; 61
    820a:	91 e0       	ldi	r25, 0x01	; 1
    820c:	9f 93       	push	r25
    820e:	8f 93       	push	r24
    8210:	81 81       	ldd	r24, Z+1	; 0x01
    8212:	8f 93       	push	r24
    8214:	80 81       	ld	r24, Z
    8216:	8f 93       	push	r24
    8218:	39 c0       	rjmp	.+114    	; 0x828c <PutDVal+0xf6>
		return;
	}
	char Format[] = "% lu.%. lu";
    821a:	8b e0       	ldi	r24, 0x0B	; 11
    821c:	e3 e4       	ldi	r30, 0x43	; 67
    821e:	f1 e0       	ldi	r31, 0x01	; 1
    8220:	8e 01       	movw	r16, r28
    8222:	0f 5f       	subi	r16, 0xFF	; 255
    8224:	1f 4f       	sbci	r17, 0xFF	; 255
    8226:	d8 01       	movw	r26, r16
    8228:	01 90       	ld	r0, Z+
    822a:	0d 92       	st	X+, r0
    822c:	8a 95       	dec	r24
    822e:	e1 f7       	brne	.-8      	; 0x8228 <PutDVal+0x92>
	Format[1] = '0'+Param->Size;
    8230:	90 5d       	subi	r25, 0xD0	; 208
    8232:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    8234:	fa 01       	movw	r30, r20
    8236:	82 81       	ldd	r24, Z+2	; 0x02
    8238:	a1 80       	ldd	r10, Z+1	; 0x01
    823a:	b0 80       	ld	r11, Z
    823c:	88 23       	and	r24, r24
    823e:	e9 f0       	breq	.+58     	; 0x827a <PutDVal+0xe4>
		Format[1] -= Param->Prec+1;
    8240:	98 1b       	sub	r25, r24
    8242:	91 50       	subi	r25, 0x01	; 1
    8244:	9a 83       	std	Y+2, r25	; 0x02
		Format[7] = '0'+Param->Prec;
    8246:	90 e3       	ldi	r25, 0x30	; 48
    8248:	98 0f       	add	r25, r24
    824a:	98 87       	std	Y+8, r25	; 0x08
		uint32_t Div=PowL10(Param->Prec);
    824c:	0e 94 e8 3c 	call	0x79d0	; 0x79d0 <PowL10>
    8250:	9b 01       	movw	r18, r22
    8252:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8254:	c7 01       	movw	r24, r14
    8256:	b6 01       	movw	r22, r12
    8258:	0e 94 ab 80 	call	0x10156	; 0x10156 <__udivmodsi4>
    825c:	9f 93       	push	r25
    825e:	8f 93       	push	r24
    8260:	7f 93       	push	r23
    8262:	6f 93       	push	r22
    8264:	5f 93       	push	r21
    8266:	4f 93       	push	r20
    8268:	3f 93       	push	r19
    826a:	2f 93       	push	r18
    826c:	1f 93       	push	r17
    826e:	0f 93       	push	r16
    8270:	af 92       	push	r10
    8272:	bf 92       	push	r11
    8274:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8278:	0b c0       	rjmp	.+22     	; 0x8290 <PutDVal+0xfa>
	}
	else {
		Format[4] = '\0';
    827a:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    827c:	ff 92       	push	r15
    827e:	ef 92       	push	r14
    8280:	df 92       	push	r13
    8282:	cf 92       	push	r12
    8284:	1f 93       	push	r17
    8286:	0f 93       	push	r16
    8288:	af 92       	push	r10
    828a:	bf 92       	push	r11
    828c:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8290:	0f b6       	in	r0, 0x3f	; 63
    8292:	f8 94       	cli
    8294:	de bf       	out	0x3e, r29	; 62
    8296:	0f be       	out	0x3f, r0	; 63
    8298:	cd bf       	out	0x3d, r28	; 61
	}
}
    829a:	2b 96       	adiw	r28, 0x0b	; 11
    829c:	0f b6       	in	r0, 0x3f	; 63
    829e:	f8 94       	cli
    82a0:	de bf       	out	0x3e, r29	; 62
    82a2:	0f be       	out	0x3f, r0	; 63
    82a4:	cd bf       	out	0x3d, r28	; 61
    82a6:	df 91       	pop	r29
    82a8:	cf 91       	pop	r28
    82aa:	1f 91       	pop	r17
    82ac:	0f 91       	pop	r16
    82ae:	ff 90       	pop	r15
    82b0:	ef 90       	pop	r14
    82b2:	df 90       	pop	r13
    82b4:	cf 90       	pop	r12
    82b6:	bf 90       	pop	r11
    82b8:	af 90       	pop	r10
    82ba:	08 95       	ret

000082bc <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    82bc:	af 92       	push	r10
    82be:	bf 92       	push	r11
    82c0:	cf 92       	push	r12
    82c2:	df 92       	push	r13
    82c4:	ef 92       	push	r14
    82c6:	ff 92       	push	r15
    82c8:	0f 93       	push	r16
    82ca:	1f 93       	push	r17
    82cc:	cf 93       	push	r28
    82ce:	df 93       	push	r29
    82d0:	cd b7       	in	r28, 0x3d	; 61
    82d2:	de b7       	in	r29, 0x3e	; 62
    82d4:	27 97       	sbiw	r28, 0x07	; 7
    82d6:	0f b6       	in	r0, 0x3f	; 63
    82d8:	f8 94       	cli
    82da:	de bf       	out	0x3e, r29	; 62
    82dc:	0f be       	out	0x3f, r0	; 63
    82de:	cd bf       	out	0x3d, r28	; 61
    82e0:	6b 01       	movw	r12, r22
    82e2:	7c 01       	movw	r14, r24
    82e4:	5a 01       	movw	r10, r20
	uint32_t Idx = 0x80000000+Val;
    82e6:	8b 01       	movw	r16, r22
    82e8:	9c 01       	movw	r18, r24
    82ea:	30 58       	subi	r19, 0x80	; 128
	if(Param->Txt && Idx<2) {
    82ec:	da 01       	movw	r26, r20
    82ee:	14 96       	adiw	r26, 0x04	; 4
    82f0:	8d 91       	ld	r24, X+
    82f2:	9c 91       	ld	r25, X
    82f4:	15 97       	sbiw	r26, 0x05	; 5
    82f6:	00 97       	sbiw	r24, 0x00	; 0
    82f8:	89 f0       	breq	.+34     	; 0x831c <Put_sDVal+0x60>
    82fa:	02 30       	cpi	r16, 0x02	; 2
    82fc:	11 05       	cpc	r17, r1
    82fe:	21 05       	cpc	r18, r1
    8300:	31 05       	cpc	r19, r1
    8302:	60 f4       	brcc	.+24     	; 0x831c <Put_sDVal+0x60>
		Param->Txt += Idx;
    8304:	00 0f       	add	r16, r16
    8306:	11 1f       	adc	r17, r17
    8308:	08 0f       	add	r16, r24
    830a:	19 1f       	adc	r17, r25
    830c:	15 96       	adiw	r26, 0x05	; 5
    830e:	1c 93       	st	X, r17
    8310:	0e 93       	st	-X, r16
    8312:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    8314:	ca 01       	movw	r24, r20
    8316:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
		return;
    831a:	b7 c0       	rjmp	.+366    	; 0x848a <Put_sDVal+0x1ce>
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    831c:	f5 01       	movw	r30, r10
    831e:	83 81       	ldd	r24, Z+3	; 0x03
    8320:	9e 01       	movw	r18, r28
    8322:	2f 5f       	subi	r18, 0xFF	; 255
    8324:	3f 4f       	sbci	r19, 0xFF	; 255
    8326:	8a 30       	cpi	r24, 0x0A	; 10
    8328:	70 f0       	brcs	.+28     	; 0x8346 <Put_sDVal+0x8a>
		char Format[] = "%+1 ld";
    832a:	97 e0       	ldi	r25, 0x07	; 7
    832c:	ee e4       	ldi	r30, 0x4E	; 78
    832e:	f1 e0       	ldi	r31, 0x01	; 1
    8330:	d9 01       	movw	r26, r18
    8332:	01 90       	ld	r0, Z+
    8334:	0d 92       	st	X+, r0
    8336:	9a 95       	dec	r25
    8338:	e1 f7       	brne	.-8      	; 0x8332 <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    833a:	6a e0       	ldi	r22, 0x0A	; 10
    833c:	0e 94 77 80 	call	0x100ee	; 0x100ee <__udivmodqi4>
    8340:	90 5d       	subi	r25, 0xD0	; 208
    8342:	9c 83       	std	Y+4, r25	; 0x04
    8344:	0a c0       	rjmp	.+20     	; 0x835a <Put_sDVal+0x9e>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+ ld";
    8346:	96 e0       	ldi	r25, 0x06	; 6
    8348:	e5 e5       	ldi	r30, 0x55	; 85
    834a:	f1 e0       	ldi	r31, 0x01	; 1
    834c:	d9 01       	movw	r26, r18
    834e:	01 90       	ld	r0, Z+
    8350:	0d 92       	st	X+, r0
    8352:	9a 95       	dec	r25
    8354:	e1 f7       	brne	.-8      	; 0x834e <Put_sDVal+0x92>
		Format[2] = '0'+Param->Size;
    8356:	80 5d       	subi	r24, 0xD0	; 208
    8358:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    835a:	ff 92       	push	r15
    835c:	ef 92       	push	r14
    835e:	df 92       	push	r13
    8360:	cf 92       	push	r12
    8362:	3f 93       	push	r19
    8364:	2f 93       	push	r18
    8366:	d5 01       	movw	r26, r10
    8368:	11 96       	adiw	r26, 0x01	; 1
    836a:	8c 91       	ld	r24, X
    836c:	11 97       	sbiw	r26, 0x01	; 1
    836e:	8f 93       	push	r24
    8370:	8c 91       	ld	r24, X
    8372:	8f 93       	push	r24
    8374:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8378:	0f b6       	in	r0, 0x3f	; 63
    837a:	f8 94       	cli
    837c:	de bf       	out	0x3e, r29	; 62
    837e:	0f be       	out	0x3f, r0	; 63
    8380:	cd bf       	out	0x3d, r28	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8382:	c1 14       	cp	r12, r1
    8384:	d1 04       	cpc	r13, r1
    8386:	e1 04       	cpc	r14, r1
    8388:	f1 04       	cpc	r15, r1
    838a:	59 f4       	brne	.+22     	; 0x83a2 <Put_sDVal+0xe6>
    838c:	d5 01       	movw	r26, r10
    838e:	13 96       	adiw	r26, 0x03	; 3
    8390:	8c 91       	ld	r24, X
    8392:	13 97       	sbiw	r26, 0x03	; 3
    8394:	ed 91       	ld	r30, X+
    8396:	fc 91       	ld	r31, X
    8398:	e8 0f       	add	r30, r24
    839a:	f1 1d       	adc	r31, r1
    839c:	32 97       	sbiw	r30, 0x02	; 2
    839e:	80 e2       	ldi	r24, 0x20	; 32
    83a0:	80 83       	st	Z, r24

	if(Param->Prec){
    83a2:	f5 01       	movw	r30, r10
    83a4:	82 81       	ldd	r24, Z+2	; 0x02
    83a6:	88 23       	and	r24, r24
    83a8:	09 f4       	brne	.+2      	; 0x83ac <Put_sDVal+0xf0>
    83aa:	6f c0       	rjmp	.+222    	; 0x848a <Put_sDVal+0x1ce>
    83ac:	60 e0       	ldi	r22, 0x00	; 0
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    83ae:	d5 01       	movw	r26, r10
    83b0:	13 96       	adiw	r26, 0x03	; 3
    83b2:	8c 91       	ld	r24, X
    83b4:	13 97       	sbiw	r26, 0x03	; 3
    83b6:	90 e0       	ldi	r25, 0x00	; 0
    83b8:	12 96       	adiw	r26, 0x02	; 2
    83ba:	2c 91       	ld	r18, X
    83bc:	12 97       	sbiw	r26, 0x02	; 2
    83be:	82 1b       	sub	r24, r18
    83c0:	91 09       	sbc	r25, r1
    83c2:	46 2f       	mov	r20, r22
    83c4:	50 e0       	ldi	r21, 0x00	; 0
    83c6:	2d 91       	ld	r18, X+
    83c8:	3c 91       	ld	r19, X
    83ca:	11 97       	sbiw	r26, 0x01	; 1
			Param->Pos[i] = Param->Pos[i+1];
    83cc:	f9 01       	movw	r30, r18
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    83ce:	48 17       	cp	r20, r24
    83d0:	59 07       	cpc	r21, r25
    83d2:	34 f4       	brge	.+12     	; 0x83e0 <Put_sDVal+0x124>
			Param->Pos[i] = Param->Pos[i+1];
    83d4:	e4 0f       	add	r30, r20
    83d6:	f5 1f       	adc	r31, r21
    83d8:	81 81       	ldd	r24, Z+1	; 0x01
    83da:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    83dc:	6f 5f       	subi	r22, 0xFF	; 255
    83de:	e7 cf       	rjmp	.-50     	; 0x83ae <Put_sDVal+0xf2>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    83e0:	e8 0f       	add	r30, r24
    83e2:	f9 1f       	adc	r31, r25
    83e4:	31 97       	sbiw	r30, 0x01	; 1
    83e6:	2e e2       	ldi	r18, 0x2E	; 46
    83e8:	20 83       	st	Z, r18
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    83ea:	13 96       	adiw	r26, 0x03	; 3
    83ec:	2c 91       	ld	r18, X
    83ee:	13 97       	sbiw	r26, 0x03	; 3
    83f0:	82 2f       	mov	r24, r18
    83f2:	90 e0       	ldi	r25, 0x00	; 0
    83f4:	12 96       	adiw	r26, 0x02	; 2
    83f6:	3c 91       	ld	r19, X
    83f8:	12 97       	sbiw	r26, 0x02	; 2
    83fa:	83 1b       	sub	r24, r19
    83fc:	91 09       	sbc	r25, r1
    83fe:	ed 91       	ld	r30, X+
    8400:	fc 91       	ld	r31, X
    8402:	e8 0f       	add	r30, r24
    8404:	f9 1f       	adc	r31, r25
    8406:	32 97       	sbiw	r30, 0x02	; 2
    8408:	80 81       	ld	r24, Z
		if(c ==' ' || c =='+' || c =='-'){
    840a:	80 32       	cpi	r24, 0x20	; 32
    840c:	21 f0       	breq	.+8      	; 0x8416 <Put_sDVal+0x15a>
    840e:	8b 32       	cpi	r24, 0x2B	; 43
    8410:	11 f0       	breq	.+4      	; 0x8416 <Put_sDVal+0x15a>
    8412:	8d 32       	cpi	r24, 0x2D	; 45
    8414:	d1 f5       	brne	.+116    	; 0x848a <Put_sDVal+0x1ce>
			for(uint8_t i=Param->Size-1; i>1; i--){
    8416:	21 50       	subi	r18, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8418:	40 e3       	ldi	r20, 0x30	; 48
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    841a:	22 30       	cpi	r18, 0x02	; 2
    841c:	b0 f1       	brcs	.+108    	; 0x848a <Put_sDVal+0x1ce>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    841e:	82 2f       	mov	r24, r18
    8420:	90 e0       	ldi	r25, 0x00	; 0
    8422:	d5 01       	movw	r26, r10
    8424:	ed 91       	ld	r30, X+
    8426:	fc 91       	ld	r31, X
    8428:	e8 0f       	add	r30, r24
    842a:	f9 1f       	adc	r31, r25
    842c:	30 81       	ld	r19, Z
    842e:	30 32       	cpi	r19, 0x20	; 32
    8430:	21 f0       	breq	.+8      	; 0x843a <Put_sDVal+0x17e>
    8432:	3b 32       	cpi	r19, 0x2B	; 43
    8434:	11 f0       	breq	.+4      	; 0x843a <Put_sDVal+0x17e>
    8436:	3d 32       	cpi	r19, 0x2D	; 45
    8438:	09 f4       	brne	.+2      	; 0x843c <Put_sDVal+0x180>
    843a:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    843c:	d5 01       	movw	r26, r10
    843e:	ed 91       	ld	r30, X+
    8440:	fc 91       	ld	r31, X
    8442:	11 97       	sbiw	r26, 0x01	; 1
    8444:	e8 0f       	add	r30, r24
    8446:	f9 1f       	adc	r31, r25
    8448:	30 81       	ld	r19, Z
    844a:	3e 32       	cpi	r19, 0x2E	; 46
    844c:	e1 f4       	brne	.+56     	; 0x8486 <Put_sDVal+0x1ca>
					Param->Pos[i-1]='0';
    844e:	31 97       	sbiw	r30, 0x01	; 1
    8450:	20 e3       	ldi	r18, 0x30	; 48
    8452:	20 83       	st	Z, r18
					if(Val>0)Param->Pos[i-2]='+';
    8454:	1c 14       	cp	r1, r12
    8456:	1d 04       	cpc	r1, r13
    8458:	1e 04       	cpc	r1, r14
    845a:	1f 04       	cpc	r1, r15
    845c:	3c f4       	brge	.+14     	; 0x846c <Put_sDVal+0x1b0>
    845e:	ed 91       	ld	r30, X+
    8460:	fc 91       	ld	r31, X
    8462:	e8 0f       	add	r30, r24
    8464:	f9 1f       	adc	r31, r25
    8466:	32 97       	sbiw	r30, 0x02	; 2
    8468:	8b e2       	ldi	r24, 0x2B	; 43
    846a:	0b c0       	rjmp	.+22     	; 0x8482 <Put_sDVal+0x1c6>
					if(Val<0)Param->Pos[i-2]='-';
    846c:	cd 28       	or	r12, r13
    846e:	ce 28       	or	r12, r14
    8470:	cf 28       	or	r12, r15
    8472:	59 f0       	breq	.+22     	; 0x848a <Put_sDVal+0x1ce>
    8474:	d5 01       	movw	r26, r10
    8476:	ed 91       	ld	r30, X+
    8478:	fc 91       	ld	r31, X
    847a:	e8 0f       	add	r30, r24
    847c:	f9 1f       	adc	r31, r25
    847e:	32 97       	sbiw	r30, 0x02	; 2
    8480:	8d e2       	ldi	r24, 0x2D	; 45
    8482:	80 83       	st	Z, r24
    8484:	02 c0       	rjmp	.+4      	; 0x848a <Put_sDVal+0x1ce>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8486:	21 50       	subi	r18, 0x01	; 1
    8488:	c8 cf       	rjmp	.-112    	; 0x841a <Put_sDVal+0x15e>
				}
			}
		}
	}

}
    848a:	27 96       	adiw	r28, 0x07	; 7
    848c:	0f b6       	in	r0, 0x3f	; 63
    848e:	f8 94       	cli
    8490:	de bf       	out	0x3e, r29	; 62
    8492:	0f be       	out	0x3f, r0	; 63
    8494:	cd bf       	out	0x3d, r28	; 61
    8496:	df 91       	pop	r29
    8498:	cf 91       	pop	r28
    849a:	1f 91       	pop	r17
    849c:	0f 91       	pop	r16
    849e:	ff 90       	pop	r15
    84a0:	ef 90       	pop	r14
    84a2:	df 90       	pop	r13
    84a4:	cf 90       	pop	r12
    84a6:	bf 90       	pop	r11
    84a8:	af 90       	pop	r10
    84aa:	08 95       	ret

000084ac <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    84ac:	af 92       	push	r10
    84ae:	bf 92       	push	r11
    84b0:	cf 92       	push	r12
    84b2:	df 92       	push	r13
    84b4:	ef 92       	push	r14
    84b6:	ff 92       	push	r15
    84b8:	0f 93       	push	r16
    84ba:	1f 93       	push	r17
    84bc:	cf 93       	push	r28
    84be:	df 93       	push	r29
    84c0:	cd b7       	in	r28, 0x3d	; 61
    84c2:	de b7       	in	r29, 0x3e	; 62
    84c4:	2c 97       	sbiw	r28, 0x0c	; 12
    84c6:	0f b6       	in	r0, 0x3f	; 63
    84c8:	f8 94       	cli
    84ca:	de bf       	out	0x3e, r29	; 62
    84cc:	0f be       	out	0x3f, r0	; 63
    84ce:	cd bf       	out	0x3d, r28	; 61
    84d0:	6b 01       	movw	r12, r22
    84d2:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    84d4:	8b 01       	movw	r16, r22
    84d6:	9c 01       	movw	r18, r24
    84d8:	00 95       	com	r16
    84da:	10 95       	com	r17
    84dc:	20 95       	com	r18
    84de:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    84e0:	fa 01       	movw	r30, r20
    84e2:	84 81       	ldd	r24, Z+4	; 0x04
    84e4:	95 81       	ldd	r25, Z+5	; 0x05
    84e6:	00 97       	sbiw	r24, 0x00	; 0
    84e8:	79 f0       	breq	.+30     	; 0x8508 <Put_zDVal+0x5c>
    84ea:	02 30       	cpi	r16, 0x02	; 2
    84ec:	11 05       	cpc	r17, r1
    84ee:	21 05       	cpc	r18, r1
    84f0:	31 05       	cpc	r19, r1
    84f2:	50 f4       	brcc	.+20     	; 0x8508 <Put_zDVal+0x5c>
		Param->Txt += Idx;
    84f4:	00 0f       	add	r16, r16
    84f6:	11 1f       	adc	r17, r17
    84f8:	08 0f       	add	r16, r24
    84fa:	19 1f       	adc	r17, r25
    84fc:	15 83       	std	Z+5, r17	; 0x05
    84fe:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    8500:	ca 01       	movw	r24, r20
    8502:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
		return;
    8506:	54 c0       	rjmp	.+168    	; 0x85b0 <Put_zDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    8508:	fa 01       	movw	r30, r20
    850a:	93 81       	ldd	r25, Z+3	; 0x03
    850c:	9a 30       	cpi	r25, 0x0A	; 10
    850e:	81 f4       	brne	.+32     	; 0x8530 <Put_zDVal+0x84>
    8510:	82 81       	ldd	r24, Z+2	; 0x02
    8512:	81 11       	cpse	r24, r1
    8514:	0d c0       	rjmp	.+26     	; 0x8530 <Put_zDVal+0x84>
		sprintf(Param->Pos, "%010lu", Val);
    8516:	ff 92       	push	r15
    8518:	ef 92       	push	r14
    851a:	df 92       	push	r13
    851c:	cf 92       	push	r12
    851e:	8b e5       	ldi	r24, 0x5B	; 91
    8520:	91 e0       	ldi	r25, 0x01	; 1
    8522:	9f 93       	push	r25
    8524:	8f 93       	push	r24
    8526:	81 81       	ldd	r24, Z+1	; 0x01
    8528:	8f 93       	push	r24
    852a:	80 81       	ld	r24, Z
    852c:	8f 93       	push	r24
    852e:	39 c0       	rjmp	.+114    	; 0x85a2 <Put_zDVal+0xf6>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8530:	8c e0       	ldi	r24, 0x0C	; 12
    8532:	e2 e6       	ldi	r30, 0x62	; 98
    8534:	f1 e0       	ldi	r31, 0x01	; 1
    8536:	8e 01       	movw	r16, r28
    8538:	0f 5f       	subi	r16, 0xFF	; 255
    853a:	1f 4f       	sbci	r17, 0xFF	; 255
    853c:	d8 01       	movw	r26, r16
    853e:	01 90       	ld	r0, Z+
    8540:	0d 92       	st	X+, r0
    8542:	8a 95       	dec	r24
    8544:	e1 f7       	brne	.-8      	; 0x853e <Put_zDVal+0x92>
	Format[2] = '0'+Param->Size;
    8546:	90 5d       	subi	r25, 0xD0	; 208
    8548:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    854a:	fa 01       	movw	r30, r20
    854c:	82 81       	ldd	r24, Z+2	; 0x02
    854e:	a1 80       	ldd	r10, Z+1	; 0x01
    8550:	b0 80       	ld	r11, Z
    8552:	88 23       	and	r24, r24
    8554:	e9 f0       	breq	.+58     	; 0x8590 <Put_zDVal+0xe4>
		Format[2] -= Param->Prec+1;
    8556:	98 1b       	sub	r25, r24
    8558:	91 50       	subi	r25, 0x01	; 1
    855a:	9b 83       	std	Y+3, r25	; 0x03
		Format[8] = '0'+Param->Prec;
    855c:	90 e3       	ldi	r25, 0x30	; 48
    855e:	98 0f       	add	r25, r24
    8560:	99 87       	std	Y+9, r25	; 0x09
		uint32_t Div=PowL10(Param->Prec);
    8562:	0e 94 e8 3c 	call	0x79d0	; 0x79d0 <PowL10>
    8566:	9b 01       	movw	r18, r22
    8568:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    856a:	c7 01       	movw	r24, r14
    856c:	b6 01       	movw	r22, r12
    856e:	0e 94 ab 80 	call	0x10156	; 0x10156 <__udivmodsi4>
    8572:	9f 93       	push	r25
    8574:	8f 93       	push	r24
    8576:	7f 93       	push	r23
    8578:	6f 93       	push	r22
    857a:	5f 93       	push	r21
    857c:	4f 93       	push	r20
    857e:	3f 93       	push	r19
    8580:	2f 93       	push	r18
    8582:	1f 93       	push	r17
    8584:	0f 93       	push	r16
    8586:	af 92       	push	r10
    8588:	bf 92       	push	r11
    858a:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    858e:	0b c0       	rjmp	.+22     	; 0x85a6 <Put_zDVal+0xfa>
	}
	else {
		Format[5] = '\0';
    8590:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    8592:	ff 92       	push	r15
    8594:	ef 92       	push	r14
    8596:	df 92       	push	r13
    8598:	cf 92       	push	r12
    859a:	1f 93       	push	r17
    859c:	0f 93       	push	r16
    859e:	af 92       	push	r10
    85a0:	bf 92       	push	r11
    85a2:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    85a6:	0f b6       	in	r0, 0x3f	; 63
    85a8:	f8 94       	cli
    85aa:	de bf       	out	0x3e, r29	; 62
    85ac:	0f be       	out	0x3f, r0	; 63
    85ae:	cd bf       	out	0x3d, r28	; 61
	}
}
    85b0:	2c 96       	adiw	r28, 0x0c	; 12
    85b2:	0f b6       	in	r0, 0x3f	; 63
    85b4:	f8 94       	cli
    85b6:	de bf       	out	0x3e, r29	; 62
    85b8:	0f be       	out	0x3f, r0	; 63
    85ba:	cd bf       	out	0x3d, r28	; 61
    85bc:	df 91       	pop	r29
    85be:	cf 91       	pop	r28
    85c0:	1f 91       	pop	r17
    85c2:	0f 91       	pop	r16
    85c4:	ff 90       	pop	r15
    85c6:	ef 90       	pop	r14
    85c8:	df 90       	pop	r13
    85ca:	cf 90       	pop	r12
    85cc:	bf 90       	pop	r11
    85ce:	af 90       	pop	r10
    85d0:	08 95       	ret

000085d2 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    85d2:	1f 93       	push	r17
    85d4:	cf 93       	push	r28
    85d6:	df 93       	push	r29
    85d8:	cd b7       	in	r28, 0x3d	; 61
    85da:	de b7       	in	r29, 0x3e	; 62
    85dc:	27 97       	sbiw	r28, 0x07	; 7
    85de:	0f b6       	in	r0, 0x3f	; 63
    85e0:	f8 94       	cli
    85e2:	de bf       	out	0x3e, r29	; 62
    85e4:	0f be       	out	0x3f, r0	; 63
    85e6:	cd bf       	out	0x3d, r28	; 61
	char Format[] = "%+ . f";
    85e8:	17 e0       	ldi	r17, 0x07	; 7
    85ea:	ee e6       	ldi	r30, 0x6E	; 110
    85ec:	f1 e0       	ldi	r31, 0x01	; 1
    85ee:	9e 01       	movw	r18, r28
    85f0:	2f 5f       	subi	r18, 0xFF	; 255
    85f2:	3f 4f       	sbci	r19, 0xFF	; 255
    85f4:	d9 01       	movw	r26, r18
    85f6:	01 90       	ld	r0, Z+
    85f8:	0d 92       	st	X+, r0
    85fa:	1a 95       	dec	r17
    85fc:	e1 f7       	brne	.-8      	; 0x85f6 <Put_FFVal+0x24>
	Format[2] = '0'+Param->Size;
    85fe:	da 01       	movw	r26, r20
    8600:	13 96       	adiw	r26, 0x03	; 3
    8602:	ec 91       	ld	r30, X
    8604:	13 97       	sbiw	r26, 0x03	; 3
    8606:	e0 5d       	subi	r30, 0xD0	; 208
    8608:	eb 83       	std	Y+3, r30	; 0x03
	Format[4] = '0'+Param->Prec;	
    860a:	12 96       	adiw	r26, 0x02	; 2
    860c:	ec 91       	ld	r30, X
    860e:	12 97       	sbiw	r26, 0x02	; 2
    8610:	e0 5d       	subi	r30, 0xD0	; 208
    8612:	ed 83       	std	Y+5, r30	; 0x05
	sprintf(Param->Pos, Format, Val);
    8614:	9f 93       	push	r25
    8616:	8f 93       	push	r24
    8618:	7f 93       	push	r23
    861a:	6f 93       	push	r22
    861c:	3f 93       	push	r19
    861e:	2f 93       	push	r18
    8620:	11 96       	adiw	r26, 0x01	; 1
    8622:	8c 91       	ld	r24, X
    8624:	11 97       	sbiw	r26, 0x01	; 1
    8626:	8f 93       	push	r24
    8628:	8c 91       	ld	r24, X
    862a:	8f 93       	push	r24
    862c:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8630:	0f b6       	in	r0, 0x3f	; 63
    8632:	f8 94       	cli
    8634:	de bf       	out	0x3e, r29	; 62
    8636:	0f be       	out	0x3f, r0	; 63
    8638:	cd bf       	out	0x3d, r28	; 61
}
    863a:	27 96       	adiw	r28, 0x07	; 7
    863c:	0f b6       	in	r0, 0x3f	; 63
    863e:	f8 94       	cli
    8640:	de bf       	out	0x3e, r29	; 62
    8642:	0f be       	out	0x3f, r0	; 63
    8644:	cd bf       	out	0x3d, r28	; 61
    8646:	df 91       	pop	r29
    8648:	cf 91       	pop	r28
    864a:	1f 91       	pop	r17
    864c:	08 95       	ret

0000864e <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    864e:	0f 93       	push	r16
    8650:	1f 93       	push	r17
    8652:	cf 93       	push	r28
    8654:	df 93       	push	r29
    8656:	cd b7       	in	r28, 0x3d	; 61
    8658:	de b7       	in	r29, 0x3e	; 62
    865a:	28 97       	sbiw	r28, 0x08	; 8
    865c:	0f b6       	in	r0, 0x3f	; 63
    865e:	f8 94       	cli
    8660:	de bf       	out	0x3e, r29	; 62
    8662:	0f be       	out	0x3f, r0	; 63
    8664:	cd bf       	out	0x3d, r28	; 61
	if(Param->Size < 10){
    8666:	da 01       	movw	r26, r20
    8668:	13 96       	adiw	r26, 0x03	; 3
    866a:	1c 91       	ld	r17, X
    866c:	9e 01       	movw	r18, r28
    866e:	2f 5f       	subi	r18, 0xFF	; 255
    8670:	3f 4f       	sbci	r19, 0xFF	; 255
    8672:	1a 30       	cpi	r17, 0x0A	; 10
    8674:	88 f4       	brcc	.+34     	; 0x8698 <Put_GFVal+0x4a>
		char Format[] = "%+ . g";
    8676:	07 e0       	ldi	r16, 0x07	; 7
    8678:	e5 e7       	ldi	r30, 0x75	; 117
    867a:	f1 e0       	ldi	r31, 0x01	; 1
    867c:	d9 01       	movw	r26, r18
    867e:	01 90       	ld	r0, Z+
    8680:	0d 92       	st	X+, r0
    8682:	0a 95       	dec	r16
    8684:	e1 f7       	brne	.-8      	; 0x867e <Put_GFVal+0x30>
		Format[2] = '0'+Param->Size;
    8686:	10 5d       	subi	r17, 0xD0	; 208
    8688:	1b 83       	std	Y+3, r17	; 0x03
		Format[4] = '0'+Param->Prec;
    868a:	da 01       	movw	r26, r20
    868c:	12 96       	adiw	r26, 0x02	; 2
    868e:	ec 91       	ld	r30, X
    8690:	12 97       	sbiw	r26, 0x02	; 2
    8692:	e0 5d       	subi	r30, 0xD0	; 208
    8694:	ed 83       	std	Y+5, r30	; 0x05
    8696:	10 c0       	rjmp	.+32     	; 0x86b8 <Put_GFVal+0x6a>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    8698:	08 e0       	ldi	r16, 0x08	; 8
    869a:	ec e7       	ldi	r30, 0x7C	; 124
    869c:	f1 e0       	ldi	r31, 0x01	; 1
    869e:	d9 01       	movw	r26, r18
    86a0:	01 90       	ld	r0, Z+
    86a2:	0d 92       	st	X+, r0
    86a4:	0a 95       	dec	r16
    86a6:	e1 f7       	brne	.-8      	; 0x86a0 <Put_GFVal+0x52>
		Format[3] = '0'+Param->Size-10;	
    86a8:	1a 5d       	subi	r17, 0xDA	; 218
    86aa:	1c 83       	std	Y+4, r17	; 0x04
		Format[5] = '0'+Param->Prec;
    86ac:	da 01       	movw	r26, r20
    86ae:	12 96       	adiw	r26, 0x02	; 2
    86b0:	ec 91       	ld	r30, X
    86b2:	12 97       	sbiw	r26, 0x02	; 2
    86b4:	e0 5d       	subi	r30, 0xD0	; 208
    86b6:	ee 83       	std	Y+6, r30	; 0x06
		sprintf(Param->Pos, Format, Val);
    86b8:	9f 93       	push	r25
    86ba:	8f 93       	push	r24
    86bc:	7f 93       	push	r23
    86be:	6f 93       	push	r22
    86c0:	3f 93       	push	r19
    86c2:	2f 93       	push	r18
    86c4:	11 96       	adiw	r26, 0x01	; 1
    86c6:	8c 91       	ld	r24, X
    86c8:	11 97       	sbiw	r26, 0x01	; 1
    86ca:	8f 93       	push	r24
    86cc:	8c 91       	ld	r24, X
    86ce:	8f 93       	push	r24
    86d0:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    86d4:	0f b6       	in	r0, 0x3f	; 63
    86d6:	f8 94       	cli
    86d8:	de bf       	out	0x3e, r29	; 62
    86da:	0f be       	out	0x3f, r0	; 63
    86dc:	cd bf       	out	0x3d, r28	; 61
	}
}
    86de:	28 96       	adiw	r28, 0x08	; 8
    86e0:	0f b6       	in	r0, 0x3f	; 63
    86e2:	f8 94       	cli
    86e4:	de bf       	out	0x3e, r29	; 62
    86e6:	0f be       	out	0x3f, r0	; 63
    86e8:	cd bf       	out	0x3d, r28	; 61
    86ea:	df 91       	pop	r29
    86ec:	cf 91       	pop	r28
    86ee:	1f 91       	pop	r17
    86f0:	0f 91       	pop	r16
    86f2:	08 95       	ret

000086f4 <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    86f4:	cf 92       	push	r12
    86f6:	df 92       	push	r13
    86f8:	ef 92       	push	r14
    86fa:	ff 92       	push	r15
    86fc:	0f 93       	push	r16
    86fe:	1f 93       	push	r17
    8700:	cf 93       	push	r28
    8702:	df 93       	push	r29
    8704:	cd b7       	in	r28, 0x3d	; 61
    8706:	de b7       	in	r29, 0x3e	; 62
    8708:	29 97       	sbiw	r28, 0x09	; 9
    870a:	0f b6       	in	r0, 0x3f	; 63
    870c:	f8 94       	cli
    870e:	de bf       	out	0x3e, r29	; 62
    8710:	0f be       	out	0x3f, r0	; 63
    8712:	cd bf       	out	0x3d, r28	; 61
    8714:	d8 2e       	mov	r13, r24
    8716:	c9 2e       	mov	r12, r25
    8718:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    871a:	fb 01       	movw	r30, r22
    871c:	23 81       	ldd	r18, Z+3	; 0x03
    871e:	1f 92       	push	r1
    8720:	2f 93       	push	r18
    8722:	1f 92       	push	r1
    8724:	2f 93       	push	r18
    8726:	24 e8       	ldi	r18, 0x84	; 132
    8728:	31 e0       	ldi	r19, 0x01	; 1
    872a:	3f 93       	push	r19
    872c:	2f 93       	push	r18
    872e:	8e 01       	movw	r16, r28
    8730:	0f 5f       	subi	r16, 0xFF	; 255
    8732:	1f 4f       	sbci	r17, 0xFF	; 255
    8734:	1f 93       	push	r17
    8736:	0f 93       	push	r16
    8738:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
	sprintf(Param->Pos, Format, Val);
    873c:	cf 92       	push	r12
    873e:	df 92       	push	r13
    8740:	1f 93       	push	r17
    8742:	0f 93       	push	r16
    8744:	f7 01       	movw	r30, r14
    8746:	81 81       	ldd	r24, Z+1	; 0x01
    8748:	8f 93       	push	r24
    874a:	80 81       	ld	r24, Z
    874c:	8f 93       	push	r24
    874e:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    8752:	0f b6       	in	r0, 0x3f	; 63
    8754:	f8 94       	cli
    8756:	de bf       	out	0x3e, r29	; 62
    8758:	0f be       	out	0x3f, r0	; 63
    875a:	cd bf       	out	0x3d, r28	; 61
}
    875c:	29 96       	adiw	r28, 0x09	; 9
    875e:	0f b6       	in	r0, 0x3f	; 63
    8760:	f8 94       	cli
    8762:	de bf       	out	0x3e, r29	; 62
    8764:	0f be       	out	0x3f, r0	; 63
    8766:	cd bf       	out	0x3d, r28	; 61
    8768:	df 91       	pop	r29
    876a:	cf 91       	pop	r28
    876c:	1f 91       	pop	r17
    876e:	0f 91       	pop	r16
    8770:	ff 90       	pop	r15
    8772:	ef 90       	pop	r14
    8774:	df 90       	pop	r13
    8776:	cf 90       	pop	r12
    8778:	08 95       	ret

0000877a <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    877a:	80 91 08 0b 	lds	r24, 0x0B08
    877e:	90 91 09 0b 	lds	r25, 0x0B09
    8782:	89 2b       	or	r24, r25
    8784:	31 f0       	breq	.+12     	; 0x8792 <HideMsg+0x18>
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    8786:	10 92 09 0b 	sts	0x0B09, r1
    878a:	10 92 08 0b 	sts	0x0B08, r1
		return 1;
    878e:	81 e0       	ldi	r24, 0x01	; 1
    8790:	08 95       	ret
	}
	else
		return 0;
    8792:	80 e0       	ldi	r24, 0x00	; 0
}
    8794:	08 95       	ret

00008796 <WebInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    8796:	80 91 0b 01 	lds	r24, 0x010B
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    879a:	80 93 27 09 	sts	0x0927, r24
	VacantTimer8Sys += n;
    879e:	92 e0       	ldi	r25, 0x02	; 2
    87a0:	98 0f       	add	r25, r24
    87a2:	90 93 0b 01 	sts	0x010B, r25
    87a6:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    87a8:	80 93 2a 09 	sts	0x092A, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    87ac:	80 91 0a 01 	lds	r24, 0x010A
	TD_FlowDelay =  Timer16SysAlloc(1);
    87b0:	80 93 35 09 	sts	0x0935, r24
	VacantTimer16Sys += n;
    87b4:	92 e0       	ldi	r25, 0x02	; 2
    87b6:	98 0f       	add	r25, r24
    87b8:	90 93 0a 01 	sts	0x010A, r25
    87bc:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    87be:	80 93 4e 09 	sts	0x094E, r24
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    87c2:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <Timer32Alloc>
    87c6:	80 93 0e 06 	sts	0x060E, r24
	TD_WebSessTimeout	= Timer32Alloc();
    87ca:	0e 94 e5 2a 	call	0x55ca	; 0x55ca <Timer32Alloc>
    87ce:	80 93 4c 09 	sts	0x094C, r24
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    87d2:	80 91 0e 01 	lds	r24, 0x010E
    87d6:	88 31       	cpi	r24, 0x18	; 24
    87d8:	40 f4       	brcc	.+16     	; 0x87ea <WebInit+0x54>
    87da:	80 91 0d 01 	lds	r24, 0x010D
    87de:	88 32       	cpi	r24, 0x28	; 40
    87e0:	20 f4       	brcc	.+8      	; 0x87ea <WebInit+0x54>
    87e2:	80 91 0c 01 	lds	r24, 0x010C
    87e6:	80 32       	cpi	r24, 0x20	; 32
    87e8:	40 f0       	brcs	.+16     	; 0x87fa <WebInit+0x64>

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
    87ea:	0e 94 bd 43 	call	0x877a	; 0x877a <HideMsg>
	CurrMsg = Msg;
    87ee:	89 e2       	ldi	r24, 0x29	; 41
    87f0:	9e e4       	ldi	r25, 0x4E	; 78
    87f2:	90 93 09 0b 	sts	0x0B09, r25
    87f6:	80 93 08 0b 	sts	0x0B08, r24
    87fa:	08 95       	ret

000087fc <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    87fc:	0f 93       	push	r16
    87fe:	1f 93       	push	r17
    8800:	cf 93       	push	r28
    8802:	df 93       	push	r29
    8804:	8b 01       	movw	r16, r22
	if(prb(&Field->Prec)){
    8806:	ec 01       	movw	r28, r24
    8808:	2f 96       	adiw	r28, 0x0f	; 15

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    880a:	fe 01       	movw	r30, r28
    880c:	84 91       	lpm	r24, Z
    880e:	88 23       	and	r24, r24
    8810:	69 f1       	breq	.+90     	; 0x886c <WebPresicionHanler+0x70>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    8812:	6e e2       	ldi	r22, 0x2E	; 46
    8814:	70 e0       	ldi	r23, 0x00	; 0
    8816:	c8 01       	movw	r24, r16
    8818:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
		if(p==NULL){
    881c:	00 97       	sbiw	r24, 0x00	; 0
    881e:	29 f4       	brne	.+10     	; 0x882a <WebPresicionHanler+0x2e>
			p = strchr(BufStr,' ');	//else seek for first space
    8820:	60 e2       	ldi	r22, 0x20	; 32
    8822:	70 e0       	ldi	r23, 0x00	; 0
    8824:	c8 01       	movw	r24, r16
    8826:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    882a:	dc 01       	movw	r26, r24
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    882c:	40 e3       	ldi	r20, 0x30	; 48
    882e:	fe 01       	movw	r30, r28
    8830:	24 91       	lpm	r18, Z
    8832:	3a 2f       	mov	r19, r26
    8834:	38 1b       	sub	r19, r24
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    8836:	32 17       	cp	r19, r18
    8838:	c8 f4       	brcc	.+50     	; 0x886c <WebPresicionHanler+0x70>
			if(*p == ' ') *p='0'; 
    883a:	2c 91       	ld	r18, X
    883c:	20 32       	cpi	r18, 0x20	; 32
    883e:	09 f4       	brne	.+2      	; 0x8842 <WebPresicionHanler+0x46>
    8840:	4c 93       	st	X, r20
			if(*p == '.'){
    8842:	5c 91       	ld	r21, X
    8844:	5e 32       	cpi	r21, 0x2E	; 46
    8846:	81 f4       	brne	.+32     	; 0x8868 <WebPresicionHanler+0x6c>
				if(isdigit(*(p+1))){
    8848:	11 96       	adiw	r26, 0x01	; 1
    884a:	6c 91       	ld	r22, X
    884c:	11 97       	sbiw	r26, 0x01	; 1
    884e:	26 2f       	mov	r18, r22
    8850:	30 e0       	ldi	r19, 0x00	; 0
    8852:	20 53       	subi	r18, 0x30	; 48
    8854:	31 09       	sbc	r19, r1
    8856:	2a 30       	cpi	r18, 0x0A	; 10
    8858:	31 05       	cpc	r19, r1
    885a:	28 f4       	brcc	.+10     	; 0x8866 <WebPresicionHanler+0x6a>
					*p= *(p+1);
    885c:	6c 93       	st	X, r22
					*(p+1) = '.';
    885e:	11 96       	adiw	r26, 0x01	; 1
    8860:	5c 93       	st	X, r21
    8862:	11 97       	sbiw	r26, 0x01	; 1
    8864:	01 c0       	rjmp	.+2      	; 0x8868 <WebPresicionHanler+0x6c>
				}
				else *p='0'; 
    8866:	4c 93       	st	X, r20
			}
			p++;
    8868:	11 96       	adiw	r26, 0x01	; 1
    886a:	e1 cf       	rjmp	.-62     	; 0x882e <WebPresicionHanler+0x32>
		}
	}
	
}
    886c:	df 91       	pop	r29
    886e:	cf 91       	pop	r28
    8870:	1f 91       	pop	r17
    8872:	0f 91       	pop	r16
    8874:	08 95       	ret

00008876 <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    8876:	2f 92       	push	r2
    8878:	3f 92       	push	r3
    887a:	4f 92       	push	r4
    887c:	5f 92       	push	r5
    887e:	6f 92       	push	r6
    8880:	7f 92       	push	r7
    8882:	8f 92       	push	r8
    8884:	9f 92       	push	r9
    8886:	af 92       	push	r10
    8888:	bf 92       	push	r11
    888a:	cf 92       	push	r12
    888c:	df 92       	push	r13
    888e:	ef 92       	push	r14
    8890:	ff 92       	push	r15
    8892:	0f 93       	push	r16
    8894:	1f 93       	push	r17
    8896:	cf 93       	push	r28
    8898:	df 93       	push	r29
    889a:	cd b7       	in	r28, 0x3d	; 61
    889c:	de b7       	in	r29, 0x3e	; 62
    889e:	2e 97       	sbiw	r28, 0x0e	; 14
    88a0:	0f b6       	in	r0, 0x3f	; 63
    88a2:	f8 94       	cli
    88a4:	de bf       	out	0x3e, r29	; 62
    88a6:	0f be       	out	0x3f, r0	; 63
    88a8:	cd bf       	out	0x3d, r28	; 61
    88aa:	6c 01       	movw	r12, r24
    88ac:	8b 01       	movw	r16, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    88ae:	2d b7       	in	r18, 0x3d	; 61
    88b0:	3e b7       	in	r19, 0x3e	; 62
    88b2:	3e 87       	std	Y+14, r19	; 0x0e
    88b4:	2d 87       	std	Y+13, r18	; 0x0d
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
    88b6:	fc 01       	movw	r30, r24
    88b8:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    88ba:	e5 90       	lpm	r14, Z+
    88bc:	f4 90       	lpm	r15, Z
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    88be:	1c 01       	movw	r2, r24
    88c0:	3f e0       	ldi	r19, 0x0F	; 15
    88c2:	23 0e       	add	r2, r19
    88c4:	31 1c       	adc	r3, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    88c6:	f1 01       	movw	r30, r2
    88c8:	84 91       	lpm	r24, Z
    88ca:	98 2f       	mov	r25, r24
    88cc:	97 70       	andi	r25, 0x07	; 7
    88ce:	21 e0       	ldi	r18, 0x01	; 1
    88d0:	30 e0       	ldi	r19, 0x00	; 0
    88d2:	02 c0       	rjmp	.+4      	; 0x88d8 <WebBuf2Field+0x62>
    88d4:	22 0f       	add	r18, r18
    88d6:	33 1f       	adc	r19, r19
    88d8:	9a 95       	dec	r25
    88da:	e2 f7       	brpl	.-8      	; 0x88d4 <WebBuf2Field+0x5e>
    88dc:	3a 87       	std	Y+10, r19	; 0x0a
    88de:	29 87       	std	Y+9, r18	; 0x09
    88e0:	86 95       	lsr	r24
    88e2:	86 95       	lsr	r24
    88e4:	86 95       	lsr	r24
    88e6:	97 01       	movw	r18, r14
    88e8:	28 0f       	add	r18, r24
    88ea:	31 1d       	adc	r19, r1
    88ec:	3c 87       	std	Y+12, r19	; 0x0c
    88ee:	2b 87       	std	Y+11, r18	; 0x0b
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);
    88f0:	c6 01       	movw	r24, r12
    88f2:	03 96       	adiw	r24, 0x03	; 3
    88f4:	0e 94 c0 29 	call	0x5380	; 0x5380 <prd>
    88f8:	2b 01       	movw	r4, r22
    88fa:	3c 01       	movw	r6, r24
    88fc:	c6 01       	movw	r24, r12
    88fe:	07 96       	adiw	r24, 0x07	; 7
    8900:	0e 94 c0 29 	call	0x5380	; 0x5380 <prd>
    8904:	4b 01       	movw	r8, r22
    8906:	5c 01       	movw	r10, r24

	uint32_t Temp=0;
    8908:	1d 82       	std	Y+5, r1	; 0x05
    890a:	1e 82       	std	Y+6, r1	; 0x06
    890c:	1f 82       	std	Y+7, r1	; 0x07
    890e:	18 86       	std	Y+8, r1	; 0x08
	float fTemp=0;
    8910:	19 82       	std	Y+1, r1	; 0x01
    8912:	1a 82       	std	Y+2, r1	; 0x02
    8914:	1b 82       	std	Y+3, r1	; 0x03
    8916:	1c 82       	std	Y+4, r1	; 0x04
    8918:	f6 01       	movw	r30, r12
    891a:	84 91       	lpm	r24, Z


	switch(prb(&Field->Type)) {
    891c:	90 e0       	ldi	r25, 0x00	; 0
    891e:	83 32       	cpi	r24, 0x23	; 35
    8920:	91 05       	cpc	r25, r1
    8922:	08 f0       	brcs	.+2      	; 0x8926 <WebBuf2Field+0xb0>
    8924:	f0 c2       	rjmp	.+1504   	; 0x8f06 <WebBuf2Field+0x690>
    8926:	fc 01       	movw	r30, r24
    8928:	ea 59       	subi	r30, 0x9A	; 154
    892a:	ff 4f       	sbci	r31, 0xFF	; 255
    892c:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8930:	b8 01       	movw	r22, r16
    8932:	c6 01       	movw	r24, r12
    8934:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    8938:	ce 01       	movw	r24, r28
    893a:	05 96       	adiw	r24, 0x05	; 5
    893c:	9f 93       	push	r25
    893e:	8f 93       	push	r24
    8940:	8e e8       	ldi	r24, 0x8E	; 142
    8942:	91 e0       	ldi	r25, 0x01	; 1
    8944:	9f 93       	push	r25
    8946:	8f 93       	push	r24
    8948:	1f 93       	push	r17
    894a:	0f 93       	push	r16
    894c:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		SetField(Temp, uint8_t);
    8950:	8d 81       	ldd	r24, Y+5	; 0x05
    8952:	9e 81       	ldd	r25, Y+6	; 0x06
    8954:	af 81       	ldd	r26, Y+7	; 0x07
    8956:	b8 85       	ldd	r27, Y+8	; 0x08
    8958:	0f 90       	pop	r0
    895a:	0f 90       	pop	r0
    895c:	0f 90       	pop	r0
    895e:	0f 90       	pop	r0
    8960:	0f 90       	pop	r0
    8962:	0f 90       	pop	r0
    8964:	b5 01       	movw	r22, r10
    8966:	a4 01       	movw	r20, r8
    8968:	55 27       	eor	r21, r21
    896a:	66 27       	eor	r22, r22
    896c:	77 27       	eor	r23, r23
    896e:	48 17       	cp	r20, r24
    8970:	59 07       	cpc	r21, r25
    8972:	6a 07       	cpc	r22, r26
    8974:	7b 07       	cpc	r23, r27
    8976:	08 f4       	brcc	.+2      	; 0x897a <WebBuf2Field+0x104>
    8978:	5f c0       	rjmp	.+190    	; 0x8a38 <WebBuf2Field+0x1c2>
    897a:	b3 01       	movw	r22, r6
    897c:	a2 01       	movw	r20, r4
    897e:	55 27       	eor	r21, r21
    8980:	66 27       	eor	r22, r22
    8982:	77 27       	eor	r23, r23
    8984:	61 c0       	rjmp	.+194    	; 0x8a48 <WebBuf2Field+0x1d2>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    8986:	b8 01       	movw	r22, r16
    8988:	c6 01       	movw	r24, r12
    898a:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    898e:	ce 01       	movw	r24, r28
    8990:	05 96       	adiw	r24, 0x05	; 5
    8992:	9f 93       	push	r25
    8994:	8f 93       	push	r24
    8996:	8e e8       	ldi	r24, 0x8E	; 142
    8998:	91 e0       	ldi	r25, 0x01	; 1
    899a:	9f 93       	push	r25
    899c:	8f 93       	push	r24
    899e:	1f 93       	push	r17
    89a0:	0f 93       	push	r16
    89a2:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    89a6:	0f 90       	pop	r0
    89a8:	0f 90       	pop	r0
    89aa:	0f 90       	pop	r0
    89ac:	0f 90       	pop	r0
    89ae:	0f 90       	pop	r0
    89b0:	0f 90       	pop	r0
    89b2:	01 97       	sbiw	r24, 0x01	; 1
    89b4:	09 f0       	breq	.+2      	; 0x89b8 <WebBuf2Field+0x142>
    89b6:	a7 c2       	rjmp	.+1358   	; 0x8f06 <WebBuf2Field+0x690>
			SetEEField(Temp, uint8_t, uint8_t, b);
    89b8:	6d 81       	ldd	r22, Y+5	; 0x05
    89ba:	7e 81       	ldd	r23, Y+6	; 0x06
    89bc:	8f 81       	ldd	r24, Y+7	; 0x07
    89be:	98 85       	ldd	r25, Y+8	; 0x08
    89c0:	95 01       	movw	r18, r10
    89c2:	84 01       	movw	r16, r8
    89c4:	11 27       	eor	r17, r17
    89c6:	22 27       	eor	r18, r18
    89c8:	33 27       	eor	r19, r19
    89ca:	06 17       	cp	r16, r22
    89cc:	17 07       	cpc	r17, r23
    89ce:	28 07       	cpc	r18, r24
    89d0:	39 07       	cpc	r19, r25
    89d2:	08 f4       	brcc	.+2      	; 0x89d6 <WebBuf2Field+0x160>
    89d4:	5e c0       	rjmp	.+188    	; 0x8a92 <WebBuf2Field+0x21c>
    89d6:	93 01       	movw	r18, r6
    89d8:	82 01       	movw	r16, r4
    89da:	11 27       	eor	r17, r17
    89dc:	22 27       	eor	r18, r18
    89de:	33 27       	eor	r19, r19
    89e0:	60 17       	cp	r22, r16
    89e2:	71 07       	cpc	r23, r17
    89e4:	82 07       	cpc	r24, r18
    89e6:	93 07       	cpc	r25, r19
    89e8:	08 f0       	brcs	.+2      	; 0x89ec <WebBuf2Field+0x176>
    89ea:	d7 c1       	rjmp	.+942    	; 0x8d9a <WebBuf2Field+0x524>
    89ec:	d3 c1       	rjmp	.+934    	; 0x8d94 <WebBuf2Field+0x51e>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    89ee:	b8 01       	movw	r22, r16
    89f0:	c6 01       	movw	r24, r12
    89f2:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    89f6:	ce 01       	movw	r24, r28
    89f8:	05 96       	adiw	r24, 0x05	; 5
    89fa:	9f 93       	push	r25
    89fc:	8f 93       	push	r24
    89fe:	83 e9       	ldi	r24, 0x93	; 147
    8a00:	91 e0       	ldi	r25, 0x01	; 1
    8a02:	9f 93       	push	r25
    8a04:	8f 93       	push	r24
    8a06:	1f 93       	push	r17
    8a08:	0f 93       	push	r16
    8a0a:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		SetField(Temp, int8_t);
    8a0e:	8d 81       	ldd	r24, Y+5	; 0x05
    8a10:	9e 81       	ldd	r25, Y+6	; 0x06
    8a12:	af 81       	ldd	r26, Y+7	; 0x07
    8a14:	b8 85       	ldd	r27, Y+8	; 0x08
    8a16:	0f 90       	pop	r0
    8a18:	0f 90       	pop	r0
    8a1a:	0f 90       	pop	r0
    8a1c:	0f 90       	pop	r0
    8a1e:	0f 90       	pop	r0
    8a20:	0f 90       	pop	r0
    8a22:	48 2d       	mov	r20, r8
    8a24:	55 27       	eor	r21, r21
    8a26:	47 fd       	sbrc	r20, 7
    8a28:	50 95       	com	r21
    8a2a:	65 2f       	mov	r22, r21
    8a2c:	75 2f       	mov	r23, r21
    8a2e:	48 17       	cp	r20, r24
    8a30:	59 07       	cpc	r21, r25
    8a32:	6a 07       	cpc	r22, r26
    8a34:	7b 07       	cpc	r23, r27
    8a36:	10 f4       	brcc	.+4      	; 0x8a3c <WebBuf2Field+0x1c6>
    8a38:	f7 01       	movw	r30, r14
    8a3a:	cc c1       	rjmp	.+920    	; 0x8dd4 <WebBuf2Field+0x55e>
    8a3c:	44 2d       	mov	r20, r4
    8a3e:	55 27       	eor	r21, r21
    8a40:	47 fd       	sbrc	r20, 7
    8a42:	50 95       	com	r21
    8a44:	65 2f       	mov	r22, r21
    8a46:	75 2f       	mov	r23, r21
    8a48:	f7 01       	movw	r30, r14
    8a4a:	84 17       	cp	r24, r20
    8a4c:	95 07       	cpc	r25, r21
    8a4e:	a6 07       	cpc	r26, r22
    8a50:	b7 07       	cpc	r27, r23
    8a52:	08 f4       	brcc	.+2      	; 0x8a56 <WebBuf2Field+0x1e0>
    8a54:	9b c1       	rjmp	.+822    	; 0x8d8c <WebBuf2Field+0x516>
    8a56:	80 83       	st	Z, r24
    8a58:	56 c2       	rjmp	.+1196   	; 0x8f06 <WebBuf2Field+0x690>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    8a5a:	b8 01       	movw	r22, r16
    8a5c:	c6 01       	movw	r24, r12
    8a5e:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    8a62:	ce 01       	movw	r24, r28
    8a64:	05 96       	adiw	r24, 0x05	; 5
    8a66:	9f 93       	push	r25
    8a68:	8f 93       	push	r24
    8a6a:	83 e9       	ldi	r24, 0x93	; 147
    8a6c:	91 e0       	ldi	r25, 0x01	; 1
    8a6e:	9f 93       	push	r25
    8a70:	8f 93       	push	r24
    8a72:	1f 93       	push	r17
    8a74:	0f 93       	push	r16
    8a76:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    8a7a:	0f 90       	pop	r0
    8a7c:	0f 90       	pop	r0
    8a7e:	0f 90       	pop	r0
    8a80:	0f 90       	pop	r0
    8a82:	0f 90       	pop	r0
    8a84:	0f 90       	pop	r0
    8a86:	01 97       	sbiw	r24, 0x01	; 1
    8a88:	09 f0       	breq	.+2      	; 0x8a8c <WebBuf2Field+0x216>
    8a8a:	3d c2       	rjmp	.+1146   	; 0x8f06 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    8a8c:	6d 81       	ldd	r22, Y+5	; 0x05
    8a8e:	86 16       	cp	r8, r22
    8a90:	14 f4       	brge	.+4      	; 0x8a96 <WebBuf2Field+0x220>
    8a92:	68 2d       	mov	r22, r8
    8a94:	82 c1       	rjmp	.+772    	; 0x8d9a <WebBuf2Field+0x524>
    8a96:	64 15       	cp	r22, r4
    8a98:	0c f0       	brlt	.+2      	; 0x8a9c <WebBuf2Field+0x226>
    8a9a:	7f c1       	rjmp	.+766    	; 0x8d9a <WebBuf2Field+0x524>
    8a9c:	7b c1       	rjmp	.+758    	; 0x8d94 <WebBuf2Field+0x51e>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8a9e:	b8 01       	movw	r22, r16
    8aa0:	c6 01       	movw	r24, r12
    8aa2:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    8aa6:	ce 01       	movw	r24, r28
    8aa8:	05 96       	adiw	r24, 0x05	; 5
    8aaa:	9f 93       	push	r25
    8aac:	8f 93       	push	r24
    8aae:	87 e9       	ldi	r24, 0x97	; 151
    8ab0:	91 e0       	ldi	r25, 0x01	; 1
    8ab2:	9f 93       	push	r25
    8ab4:	8f 93       	push	r24
    8ab6:	1f 93       	push	r17
    8ab8:	0f 93       	push	r16
    8aba:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		SetField(Temp, uint16_t);
    8abe:	8d 81       	ldd	r24, Y+5	; 0x05
    8ac0:	9e 81       	ldd	r25, Y+6	; 0x06
    8ac2:	af 81       	ldd	r26, Y+7	; 0x07
    8ac4:	b8 85       	ldd	r27, Y+8	; 0x08
    8ac6:	0f 90       	pop	r0
    8ac8:	0f 90       	pop	r0
    8aca:	0f 90       	pop	r0
    8acc:	0f 90       	pop	r0
    8ace:	0f 90       	pop	r0
    8ad0:	0f 90       	pop	r0
    8ad2:	b5 01       	movw	r22, r10
    8ad4:	a4 01       	movw	r20, r8
    8ad6:	66 27       	eor	r22, r22
    8ad8:	77 27       	eor	r23, r23
    8ada:	48 17       	cp	r20, r24
    8adc:	59 07       	cpc	r21, r25
    8ade:	6a 07       	cpc	r22, r26
    8ae0:	7b 07       	cpc	r23, r27
    8ae2:	08 f4       	brcc	.+2      	; 0x8ae6 <WebBuf2Field+0x270>
    8ae4:	5b c0       	rjmp	.+182    	; 0x8b9c <WebBuf2Field+0x326>
    8ae6:	b3 01       	movw	r22, r6
    8ae8:	a2 01       	movw	r20, r4
    8aea:	66 27       	eor	r22, r22
    8aec:	77 27       	eor	r23, r23
    8aee:	5f c0       	rjmp	.+190    	; 0x8bae <WebBuf2Field+0x338>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8af0:	b8 01       	movw	r22, r16
    8af2:	c6 01       	movw	r24, r12
    8af4:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8af8:	ce 01       	movw	r24, r28
    8afa:	05 96       	adiw	r24, 0x05	; 5
    8afc:	9f 93       	push	r25
    8afe:	8f 93       	push	r24
    8b00:	8b e9       	ldi	r24, 0x9B	; 155
    8b02:	91 e0       	ldi	r25, 0x01	; 1
    8b04:	9f 93       	push	r25
    8b06:	8f 93       	push	r24
    8b08:	1f 93       	push	r17
    8b0a:	0f 93       	push	r16
    8b0c:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    8b10:	0f 90       	pop	r0
    8b12:	0f 90       	pop	r0
    8b14:	0f 90       	pop	r0
    8b16:	0f 90       	pop	r0
    8b18:	0f 90       	pop	r0
    8b1a:	0f 90       	pop	r0
    8b1c:	01 97       	sbiw	r24, 0x01	; 1
    8b1e:	09 f0       	breq	.+2      	; 0x8b22 <WebBuf2Field+0x2ac>
    8b20:	f2 c1       	rjmp	.+996    	; 0x8f06 <WebBuf2Field+0x690>
			SetEEField(Temp, uint16_t, uint16_t, w);
    8b22:	6d 81       	ldd	r22, Y+5	; 0x05
    8b24:	7e 81       	ldd	r23, Y+6	; 0x06
    8b26:	8f 81       	ldd	r24, Y+7	; 0x07
    8b28:	98 85       	ldd	r25, Y+8	; 0x08
    8b2a:	95 01       	movw	r18, r10
    8b2c:	84 01       	movw	r16, r8
    8b2e:	22 27       	eor	r18, r18
    8b30:	33 27       	eor	r19, r19
    8b32:	06 17       	cp	r16, r22
    8b34:	17 07       	cpc	r17, r23
    8b36:	28 07       	cpc	r18, r24
    8b38:	39 07       	cpc	r19, r25
    8b3a:	08 f4       	brcc	.+2      	; 0x8b3e <WebBuf2Field+0x2c8>
    8b3c:	64 c0       	rjmp	.+200    	; 0x8c06 <WebBuf2Field+0x390>
    8b3e:	93 01       	movw	r18, r6
    8b40:	82 01       	movw	r16, r4
    8b42:	22 27       	eor	r18, r18
    8b44:	33 27       	eor	r19, r19
    8b46:	60 17       	cp	r22, r16
    8b48:	71 07       	cpc	r23, r17
    8b4a:	82 07       	cpc	r24, r18
    8b4c:	93 07       	cpc	r25, r19
    8b4e:	08 f0       	brcs	.+2      	; 0x8b52 <WebBuf2Field+0x2dc>
    8b50:	60 c0       	rjmp	.+192    	; 0x8c12 <WebBuf2Field+0x39c>
    8b52:	5e c0       	rjmp	.+188    	; 0x8c10 <WebBuf2Field+0x39a>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    8b54:	b8 01       	movw	r22, r16
    8b56:	c6 01       	movw	r24, r12
    8b58:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    8b5c:	ce 01       	movw	r24, r28
    8b5e:	05 96       	adiw	r24, 0x05	; 5
    8b60:	9f 93       	push	r25
    8b62:	8f 93       	push	r24
    8b64:	80 ea       	ldi	r24, 0xA0	; 160
    8b66:	91 e0       	ldi	r25, 0x01	; 1
    8b68:	9f 93       	push	r25
    8b6a:	8f 93       	push	r24
    8b6c:	1f 93       	push	r17
    8b6e:	0f 93       	push	r16
    8b70:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		SetField(Temp, int16_t);
    8b74:	8d 81       	ldd	r24, Y+5	; 0x05
    8b76:	9e 81       	ldd	r25, Y+6	; 0x06
    8b78:	af 81       	ldd	r26, Y+7	; 0x07
    8b7a:	b8 85       	ldd	r27, Y+8	; 0x08
    8b7c:	0f 90       	pop	r0
    8b7e:	0f 90       	pop	r0
    8b80:	0f 90       	pop	r0
    8b82:	0f 90       	pop	r0
    8b84:	0f 90       	pop	r0
    8b86:	0f 90       	pop	r0
    8b88:	a4 01       	movw	r20, r8
    8b8a:	66 27       	eor	r22, r22
    8b8c:	57 fd       	sbrc	r21, 7
    8b8e:	60 95       	com	r22
    8b90:	76 2f       	mov	r23, r22
    8b92:	48 17       	cp	r20, r24
    8b94:	59 07       	cpc	r21, r25
    8b96:	6a 07       	cpc	r22, r26
    8b98:	7b 07       	cpc	r23, r27
    8b9a:	20 f4       	brcc	.+8      	; 0x8ba4 <WebBuf2Field+0x32e>
    8b9c:	f7 01       	movw	r30, r14
    8b9e:	91 82       	std	Z+1, r9	; 0x01
    8ba0:	80 82       	st	Z, r8
    8ba2:	b1 c1       	rjmp	.+866    	; 0x8f06 <WebBuf2Field+0x690>
    8ba4:	a2 01       	movw	r20, r4
    8ba6:	66 27       	eor	r22, r22
    8ba8:	57 fd       	sbrc	r21, 7
    8baa:	60 95       	com	r22
    8bac:	76 2f       	mov	r23, r22
    8bae:	f7 01       	movw	r30, r14
    8bb0:	84 17       	cp	r24, r20
    8bb2:	95 07       	cpc	r25, r21
    8bb4:	a6 07       	cpc	r26, r22
    8bb6:	b7 07       	cpc	r27, r23
    8bb8:	18 f4       	brcc	.+6      	; 0x8bc0 <WebBuf2Field+0x34a>
    8bba:	51 82       	std	Z+1, r5	; 0x01
    8bbc:	40 82       	st	Z, r4
    8bbe:	a3 c1       	rjmp	.+838    	; 0x8f06 <WebBuf2Field+0x690>
    8bc0:	91 83       	std	Z+1, r25	; 0x01
    8bc2:	80 83       	st	Z, r24
    8bc4:	a0 c1       	rjmp	.+832    	; 0x8f06 <WebBuf2Field+0x690>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8bc6:	b8 01       	movw	r22, r16
    8bc8:	c6 01       	movw	r24, r12
    8bca:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    8bce:	ce 01       	movw	r24, r28
    8bd0:	05 96       	adiw	r24, 0x05	; 5
    8bd2:	9f 93       	push	r25
    8bd4:	8f 93       	push	r24
    8bd6:	80 ea       	ldi	r24, 0xA0	; 160
    8bd8:	91 e0       	ldi	r25, 0x01	; 1
    8bda:	9f 93       	push	r25
    8bdc:	8f 93       	push	r24
    8bde:	1f 93       	push	r17
    8be0:	0f 93       	push	r16
    8be2:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    8be6:	0f 90       	pop	r0
    8be8:	0f 90       	pop	r0
    8bea:	0f 90       	pop	r0
    8bec:	0f 90       	pop	r0
    8bee:	0f 90       	pop	r0
    8bf0:	0f 90       	pop	r0
    8bf2:	01 97       	sbiw	r24, 0x01	; 1
    8bf4:	09 f0       	breq	.+2      	; 0x8bf8 <WebBuf2Field+0x382>
    8bf6:	87 c1       	rjmp	.+782    	; 0x8f06 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    8bf8:	6d 81       	ldd	r22, Y+5	; 0x05
    8bfa:	7e 81       	ldd	r23, Y+6	; 0x06
    8bfc:	8f 81       	ldd	r24, Y+7	; 0x07
    8bfe:	98 85       	ldd	r25, Y+8	; 0x08
    8c00:	86 16       	cp	r8, r22
    8c02:	97 06       	cpc	r9, r23
    8c04:	14 f4       	brge	.+4      	; 0x8c0a <WebBuf2Field+0x394>
    8c06:	b4 01       	movw	r22, r8
    8c08:	04 c0       	rjmp	.+8      	; 0x8c12 <WebBuf2Field+0x39c>
    8c0a:	64 15       	cp	r22, r4
    8c0c:	75 05       	cpc	r23, r5
    8c0e:	0c f4       	brge	.+2      	; 0x8c12 <WebBuf2Field+0x39c>
    8c10:	b2 01       	movw	r22, r4
    8c12:	c7 01       	movw	r24, r14
    8c14:	0e 94 4f 2a 	call	0x549e	; 0x549e <eww>
    8c18:	76 c1       	rjmp	.+748    	; 0x8f06 <WebBuf2Field+0x690>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    8c1a:	f7 01       	movw	r30, r14
    8c1c:	11 82       	std	Z+1, r1	; 0x01
    8c1e:	10 82       	st	Z, r1
		break;
    8c20:	72 c1       	rjmp	.+740    	; 0x8f06 <WebBuf2Field+0x690>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8c22:	b8 01       	movw	r22, r16
    8c24:	c6 01       	movw	r24, r12
    8c26:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    8c2a:	ce 01       	movw	r24, r28
    8c2c:	05 96       	adiw	r24, 0x05	; 5
    8c2e:	9f 93       	push	r25
    8c30:	8f 93       	push	r24
    8c32:	8b e9       	ldi	r24, 0x9B	; 155
    8c34:	91 e0       	ldi	r25, 0x01	; 1
    8c36:	15 c0       	rjmp	.+42     	; 0x8c62 <WebBuf2Field+0x3ec>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8c38:	b8 01       	movw	r22, r16
    8c3a:	c6 01       	movw	r24, r12
    8c3c:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8c40:	ce 01       	movw	r24, r28
    8c42:	05 96       	adiw	r24, 0x05	; 5
    8c44:	9f 93       	push	r25
    8c46:	8f 93       	push	r24
    8c48:	8b e9       	ldi	r24, 0x9B	; 155
    8c4a:	91 e0       	ldi	r25, 0x01	; 1
    8c4c:	3e c0       	rjmp	.+124    	; 0x8cca <WebBuf2Field+0x454>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    8c4e:	b8 01       	movw	r22, r16
    8c50:	c6 01       	movw	r24, r12
    8c52:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    8c56:	ce 01       	movw	r24, r28
    8c58:	05 96       	adiw	r24, 0x05	; 5
    8c5a:	9f 93       	push	r25
    8c5c:	8f 93       	push	r24
    8c5e:	83 ea       	ldi	r24, 0xA3	; 163
    8c60:	91 e0       	ldi	r25, 0x01	; 1
    8c62:	9f 93       	push	r25
    8c64:	8f 93       	push	r24
    8c66:	1f 93       	push	r17
    8c68:	0f 93       	push	r16
    8c6a:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		SetField(Temp, int32_t);
    8c6e:	8d 81       	ldd	r24, Y+5	; 0x05
    8c70:	9e 81       	ldd	r25, Y+6	; 0x06
    8c72:	af 81       	ldd	r26, Y+7	; 0x07
    8c74:	b8 85       	ldd	r27, Y+8	; 0x08
    8c76:	0f 90       	pop	r0
    8c78:	0f 90       	pop	r0
    8c7a:	0f 90       	pop	r0
    8c7c:	0f 90       	pop	r0
    8c7e:	0f 90       	pop	r0
    8c80:	0f 90       	pop	r0
    8c82:	f7 01       	movw	r30, r14
    8c84:	88 16       	cp	r8, r24
    8c86:	99 06       	cpc	r9, r25
    8c88:	aa 06       	cpc	r10, r26
    8c8a:	bb 06       	cpc	r11, r27
    8c8c:	28 f4       	brcc	.+10     	; 0x8c98 <WebBuf2Field+0x422>
    8c8e:	80 82       	st	Z, r8
    8c90:	91 82       	std	Z+1, r9	; 0x01
    8c92:	a2 82       	std	Z+2, r10	; 0x02
    8c94:	b3 82       	std	Z+3, r11	; 0x03
    8c96:	37 c1       	rjmp	.+622    	; 0x8f06 <WebBuf2Field+0x690>
    8c98:	84 15       	cp	r24, r4
    8c9a:	95 05       	cpc	r25, r5
    8c9c:	a6 05       	cpc	r26, r6
    8c9e:	b7 05       	cpc	r27, r7
    8ca0:	28 f4       	brcc	.+10     	; 0x8cac <WebBuf2Field+0x436>
    8ca2:	40 82       	st	Z, r4
    8ca4:	51 82       	std	Z+1, r5	; 0x01
    8ca6:	62 82       	std	Z+2, r6	; 0x02
    8ca8:	73 82       	std	Z+3, r7	; 0x03
    8caa:	2d c1       	rjmp	.+602    	; 0x8f06 <WebBuf2Field+0x690>
    8cac:	80 83       	st	Z, r24
    8cae:	91 83       	std	Z+1, r25	; 0x01
    8cb0:	a2 83       	std	Z+2, r26	; 0x02
    8cb2:	b3 83       	std	Z+3, r27	; 0x03
    8cb4:	28 c1       	rjmp	.+592    	; 0x8f06 <WebBuf2Field+0x690>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8cb6:	b8 01       	movw	r22, r16
    8cb8:	c6 01       	movw	r24, r12
    8cba:	0e 94 fe 43 	call	0x87fc	; 0x87fc <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    8cbe:	ce 01       	movw	r24, r28
    8cc0:	05 96       	adiw	r24, 0x05	; 5
    8cc2:	9f 93       	push	r25
    8cc4:	8f 93       	push	r24
    8cc6:	83 ea       	ldi	r24, 0xA3	; 163
    8cc8:	91 e0       	ldi	r25, 0x01	; 1
    8cca:	9f 93       	push	r25
    8ccc:	8f 93       	push	r24
    8cce:	1f 93       	push	r17
    8cd0:	0f 93       	push	r16
    8cd2:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    8cd6:	0f 90       	pop	r0
    8cd8:	0f 90       	pop	r0
    8cda:	0f 90       	pop	r0
    8cdc:	0f 90       	pop	r0
    8cde:	0f 90       	pop	r0
    8ce0:	0f 90       	pop	r0
    8ce2:	01 97       	sbiw	r24, 0x01	; 1
    8ce4:	09 f0       	breq	.+2      	; 0x8ce8 <WebBuf2Field+0x472>
    8ce6:	0f c1       	rjmp	.+542    	; 0x8f06 <WebBuf2Field+0x690>
			SetEEField(Temp, int32_t, uint32_t, d);
    8ce8:	4d 81       	ldd	r20, Y+5	; 0x05
    8cea:	5e 81       	ldd	r21, Y+6	; 0x06
    8cec:	6f 81       	ldd	r22, Y+7	; 0x07
    8cee:	78 85       	ldd	r23, Y+8	; 0x08
    8cf0:	84 16       	cp	r8, r20
    8cf2:	95 06       	cpc	r9, r21
    8cf4:	a6 06       	cpc	r10, r22
    8cf6:	b7 06       	cpc	r11, r23
    8cf8:	18 f4       	brcc	.+6      	; 0x8d00 <WebBuf2Field+0x48a>
    8cfa:	b5 01       	movw	r22, r10
    8cfc:	a4 01       	movw	r20, r8
    8cfe:	07 c0       	rjmp	.+14     	; 0x8d0e <WebBuf2Field+0x498>
    8d00:	44 15       	cp	r20, r4
    8d02:	55 05       	cpc	r21, r5
    8d04:	66 05       	cpc	r22, r6
    8d06:	77 05       	cpc	r23, r7
    8d08:	10 f4       	brcc	.+4      	; 0x8d0e <WebBuf2Field+0x498>
    8d0a:	b3 01       	movw	r22, r6
    8d0c:	a2 01       	movw	r20, r4
    8d0e:	c7 01       	movw	r24, r14
    8d10:	0e 94 53 2a 	call	0x54a6	; 0x54a6 <ewd>
    8d14:	f8 c0       	rjmp	.+496    	; 0x8f06 <WebBuf2Field+0x690>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    8d16:	ce 01       	movw	r24, r28
    8d18:	01 96       	adiw	r24, 0x01	; 1
    8d1a:	9f 93       	push	r25
    8d1c:	8f 93       	push	r24
    8d1e:	87 ea       	ldi	r24, 0xA7	; 167
    8d20:	91 e0       	ldi	r25, 0x01	; 1
    8d22:	9f 93       	push	r25
    8d24:	8f 93       	push	r24
    8d26:	1f 93       	push	r17
    8d28:	0f 93       	push	r16
    8d2a:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		*(float*)Var = fTemp;
    8d2e:	89 81       	ldd	r24, Y+1	; 0x01
    8d30:	9a 81       	ldd	r25, Y+2	; 0x02
    8d32:	ab 81       	ldd	r26, Y+3	; 0x03
    8d34:	bc 81       	ldd	r27, Y+4	; 0x04
    8d36:	f7 01       	movw	r30, r14
    8d38:	80 83       	st	Z, r24
    8d3a:	91 83       	std	Z+1, r25	; 0x01
    8d3c:	a2 83       	std	Z+2, r26	; 0x02
    8d3e:	b3 83       	std	Z+3, r27	; 0x03
		break;
    8d40:	0f 90       	pop	r0
    8d42:	0f 90       	pop	r0
    8d44:	0f 90       	pop	r0
    8d46:	0f 90       	pop	r0
    8d48:	0f 90       	pop	r0
    8d4a:	0f 90       	pop	r0
    8d4c:	dc c0       	rjmp	.+440    	; 0x8f06 <WebBuf2Field+0x690>
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    8d4e:	9e 01       	movw	r18, r28
    8d50:	2f 5f       	subi	r18, 0xFF	; 255
    8d52:	3f 4f       	sbci	r19, 0xFF	; 255
    8d54:	59 01       	movw	r10, r18
    8d56:	bf 92       	push	r11
    8d58:	2f 93       	push	r18
    8d5a:	87 ea       	ldi	r24, 0xA7	; 167
    8d5c:	91 e0       	ldi	r25, 0x01	; 1
    8d5e:	9f 93       	push	r25
    8d60:	8f 93       	push	r24
    8d62:	1f 93       	push	r17
    8d64:	0f 93       	push	r16
    8d66:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
    8d6a:	0f 90       	pop	r0
    8d6c:	0f 90       	pop	r0
    8d6e:	0f 90       	pop	r0
    8d70:	0f 90       	pop	r0
    8d72:	0f 90       	pop	r0
    8d74:	0f 90       	pop	r0
    8d76:	01 97       	sbiw	r24, 0x01	; 1
    8d78:	09 f0       	breq	.+2      	; 0x8d7c <WebBuf2Field+0x506>
    8d7a:	c5 c0       	rjmp	.+394    	; 0x8f06 <WebBuf2Field+0x690>
			ewbl(&fTemp, (float*)Var, 4);
    8d7c:	44 e0       	ldi	r20, 0x04	; 4
    8d7e:	50 e0       	ldi	r21, 0x00	; 0
    8d80:	b7 01       	movw	r22, r14
    8d82:	c5 01       	movw	r24, r10
    8d84:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
    8d88:	be c0       	rjmp	.+380    	; 0x8f06 <WebBuf2Field+0x690>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    8d8a:	f7 01       	movw	r30, r14
    8d8c:	40 82       	st	Z, r4
    8d8e:	bb c0       	rjmp	.+374    	; 0x8f06 <WebBuf2Field+0x690>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    8d90:	44 20       	and	r4, r4
    8d92:	11 f0       	breq	.+4      	; 0x8d98 <WebBuf2Field+0x522>
    8d94:	64 2d       	mov	r22, r4
    8d96:	01 c0       	rjmp	.+2      	; 0x8d9a <WebBuf2Field+0x524>
    8d98:	60 e0       	ldi	r22, 0x00	; 0
    8d9a:	c7 01       	movw	r24, r14
    8d9c:	43 c0       	rjmp	.+134    	; 0x8e24 <WebBuf2Field+0x5ae>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8d9e:	ce 01       	movw	r24, r28
    8da0:	05 96       	adiw	r24, 0x05	; 5
    8da2:	9f 93       	push	r25
    8da4:	8f 93       	push	r24
    8da6:	8e e8       	ldi	r24, 0x8E	; 142
    8da8:	91 e0       	ldi	r25, 0x01	; 1
    8daa:	9f 93       	push	r25
    8dac:	8f 93       	push	r24
    8dae:	1f 93       	push	r17
    8db0:	0f 93       	push	r16
    8db2:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
		if((unsigned short int)Temp)
    8db6:	0f 90       	pop	r0
    8db8:	0f 90       	pop	r0
    8dba:	0f 90       	pop	r0
    8dbc:	0f 90       	pop	r0
    8dbe:	0f 90       	pop	r0
    8dc0:	0f 90       	pop	r0
    8dc2:	8d 81       	ldd	r24, Y+5	; 0x05
    8dc4:	9e 81       	ldd	r25, Y+6	; 0x06
    8dc6:	eb 85       	ldd	r30, Y+11	; 0x0b
    8dc8:	fc 85       	ldd	r31, Y+12	; 0x0c
    8dca:	20 81       	ld	r18, Z
			*BitVar |=Mask;
    8dcc:	89 84       	ldd	r8, Y+9	; 0x09
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
		if((unsigned short int)Temp)
    8dce:	89 2b       	or	r24, r25
    8dd0:	19 f0       	breq	.+6      	; 0x8dd8 <WebBuf2Field+0x562>
			*BitVar |=Mask;
    8dd2:	82 2a       	or	r8, r18
    8dd4:	80 82       	st	Z, r8
    8dd6:	97 c0       	rjmp	.+302    	; 0x8f06 <WebBuf2Field+0x690>
		else
			*BitVar &=~Mask;
    8dd8:	80 94       	com	r8
    8dda:	82 22       	and	r8, r18
    8ddc:	eb 85       	ldd	r30, Y+11	; 0x0b
    8dde:	fc 85       	ldd	r31, Y+12	; 0x0c
    8de0:	f9 cf       	rjmp	.-14     	; 0x8dd4 <WebBuf2Field+0x55e>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8de2:	ce 01       	movw	r24, r28
    8de4:	05 96       	adiw	r24, 0x05	; 5
    8de6:	9f 93       	push	r25
    8de8:	8f 93       	push	r24
    8dea:	8e e8       	ldi	r24, 0x8E	; 142
    8dec:	91 e0       	ldi	r25, 0x01	; 1
    8dee:	9f 93       	push	r25
    8df0:	8f 93       	push	r24
    8df2:	1f 93       	push	r17
    8df4:	0f 93       	push	r16
    8df6:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8dfa:	8b 85       	ldd	r24, Y+11	; 0x0b
    8dfc:	9c 85       	ldd	r25, Y+12	; 0x0c
    8dfe:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    8e02:	0f 90       	pop	r0
    8e04:	0f 90       	pop	r0
    8e06:	0f 90       	pop	r0
    8e08:	0f 90       	pop	r0
    8e0a:	0f 90       	pop	r0
    8e0c:	0f 90       	pop	r0
    8e0e:	2d 81       	ldd	r18, Y+5	; 0x05
    8e10:	3e 81       	ldd	r19, Y+6	; 0x06
    8e12:	69 85       	ldd	r22, Y+9	; 0x09
    8e14:	23 2b       	or	r18, r19
    8e16:	11 f0       	breq	.+4      	; 0x8e1c <WebBuf2Field+0x5a6>
    8e18:	68 2b       	or	r22, r24
    8e1a:	02 c0       	rjmp	.+4      	; 0x8e20 <WebBuf2Field+0x5aa>
    8e1c:	60 95       	com	r22
    8e1e:	68 23       	and	r22, r24
    8e20:	8b 85       	ldd	r24, Y+11	; 0x0b
    8e22:	9c 85       	ldd	r25, Y+12	; 0x0c
    8e24:	0e 94 44 2a 	call	0x5488	; 0x5488 <ewb>
		break;
    8e28:	6e c0       	rjmp	.+220    	; 0x8f06 <WebBuf2Field+0x690>
    8e2a:	ad b6       	in	r10, 0x3d	; 61
    8e2c:	be b6       	in	r11, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8e2e:	f1 01       	movw	r30, r2
    8e30:	24 90       	lpm	r2, Z


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8e32:	31 2c       	mov	r3, r1
    8e34:	2d b7       	in	r18, 0x3d	; 61
    8e36:	3e b7       	in	r19, 0x3e	; 62
    8e38:	22 19       	sub	r18, r2
    8e3a:	33 09       	sbc	r19, r3
    8e3c:	0f b6       	in	r0, 0x3f	; 63
    8e3e:	f8 94       	cli
    8e40:	3e bf       	out	0x3e, r19	; 62
    8e42:	0f be       	out	0x3f, r0	; 63
    8e44:	2d bf       	out	0x3d, r18	; 61
    8e46:	6d b7       	in	r22, 0x3d	; 61
    8e48:	7e b7       	in	r23, 0x3e	; 62
    8e4a:	6f 5f       	subi	r22, 0xFF	; 255
    8e4c:	7f 4f       	sbci	r23, 0xFF	; 255
		uint8_t i=0;
    8e4e:	90 e0       	ldi	r25, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e50:	31 e0       	ldi	r19, 0x01	; 1
    8e52:	23 1a       	sub	r2, r19
    8e54:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e56:	20 e2       	ldi	r18, 0x20	; 32
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e58:	49 2f       	mov	r20, r25
    8e5a:	50 e0       	ldi	r21, 0x00	; 0
    8e5c:	fb 01       	movw	r30, r22
    8e5e:	e4 0f       	add	r30, r20
    8e60:	f5 1f       	adc	r31, r21
    8e62:	42 15       	cp	r20, r2
    8e64:	53 05       	cpc	r21, r3
    8e66:	3c f0       	brlt	.+14     	; 0x8e76 <WebBuf2Field+0x600>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8e68:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    8e6a:	4f 5f       	subi	r20, 0xFF	; 255
    8e6c:	5f 4f       	sbci	r21, 0xFF	; 255
    8e6e:	c7 01       	movw	r24, r14
    8e70:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
    8e74:	33 c0       	rjmp	.+102    	; 0x8edc <WebBuf2Field+0x666>
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e76:	d8 01       	movw	r26, r16
    8e78:	a4 0f       	add	r26, r20
    8e7a:	b5 1f       	adc	r27, r21
    8e7c:	8c 91       	ld	r24, X
    8e7e:	80 32       	cpi	r24, 0x20	; 32
    8e80:	99 f3       	breq	.-26     	; 0x8e68 <WebBuf2Field+0x5f2>
    8e82:	86 32       	cpi	r24, 0x26	; 38
    8e84:	89 f3       	breq	.-30     	; 0x8e68 <WebBuf2Field+0x5f2>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e86:	8b 32       	cpi	r24, 0x2B	; 43
    8e88:	11 f4       	brne	.+4      	; 0x8e8e <WebBuf2Field+0x618>
    8e8a:	20 83       	st	Z, r18
    8e8c:	01 c0       	rjmp	.+2      	; 0x8e90 <WebBuf2Field+0x61a>
			else TempStr[i]=BufStr[i];
    8e8e:	80 83       	st	Z, r24
			i++;
    8e90:	9f 5f       	subi	r25, 0xFF	; 255
    8e92:	e2 cf       	rjmp	.-60     	; 0x8e58 <WebBuf2Field+0x5e2>
    8e94:	ad b6       	in	r10, 0x3d	; 61
    8e96:	be b6       	in	r11, 0x3e	; 62
    8e98:	f1 01       	movw	r30, r2
    8e9a:	24 90       	lpm	r2, Z

		break;
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8e9c:	31 2c       	mov	r3, r1
    8e9e:	2d b7       	in	r18, 0x3d	; 61
    8ea0:	3e b7       	in	r19, 0x3e	; 62
    8ea2:	22 19       	sub	r18, r2
    8ea4:	33 09       	sbc	r19, r3
    8ea6:	0f b6       	in	r0, 0x3f	; 63
    8ea8:	f8 94       	cli
    8eaa:	3e bf       	out	0x3e, r19	; 62
    8eac:	0f be       	out	0x3f, r0	; 63
    8eae:	2d bf       	out	0x3d, r18	; 61
    8eb0:	8d b7       	in	r24, 0x3d	; 61
    8eb2:	9e b7       	in	r25, 0x3e	; 62
    8eb4:	01 96       	adiw	r24, 0x01	; 1
		uint8_t i=0;
    8eb6:	30 e0       	ldi	r19, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8eb8:	e1 e0       	ldi	r30, 0x01	; 1
    8eba:	2e 1a       	sub	r2, r30
    8ebc:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8ebe:	60 e2       	ldi	r22, 0x20	; 32
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8ec0:	43 2f       	mov	r20, r19
    8ec2:	50 e0       	ldi	r21, 0x00	; 0
    8ec4:	fc 01       	movw	r30, r24
    8ec6:	e4 0f       	add	r30, r20
    8ec8:	f5 1f       	adc	r31, r21
    8eca:	42 15       	cp	r20, r2
    8ecc:	53 05       	cpc	r21, r3
    8ece:	64 f0       	brlt	.+24     	; 0x8ee8 <WebBuf2Field+0x672>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8ed0:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    8ed2:	4f 5f       	subi	r20, 0xFF	; 255
    8ed4:	5f 4f       	sbci	r21, 0xFF	; 255
    8ed6:	b7 01       	movw	r22, r14
    8ed8:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
    8edc:	0f b6       	in	r0, 0x3f	; 63
    8ede:	f8 94       	cli
    8ee0:	be be       	out	0x3e, r11	; 62
    8ee2:	0f be       	out	0x3f, r0	; 63
    8ee4:	ad be       	out	0x3d, r10	; 61
		}
		break;
    8ee6:	0f c0       	rjmp	.+30     	; 0x8f06 <WebBuf2Field+0x690>
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8ee8:	d8 01       	movw	r26, r16
    8eea:	a4 0f       	add	r26, r20
    8eec:	b5 1f       	adc	r27, r21
    8eee:	2c 91       	ld	r18, X
    8ef0:	20 32       	cpi	r18, 0x20	; 32
    8ef2:	71 f3       	breq	.-36     	; 0x8ed0 <WebBuf2Field+0x65a>
    8ef4:	26 32       	cpi	r18, 0x26	; 38
    8ef6:	61 f3       	breq	.-40     	; 0x8ed0 <WebBuf2Field+0x65a>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8ef8:	2b 32       	cpi	r18, 0x2B	; 43
    8efa:	11 f4       	brne	.+4      	; 0x8f00 <WebBuf2Field+0x68a>
    8efc:	60 83       	st	Z, r22
    8efe:	01 c0       	rjmp	.+2      	; 0x8f02 <WebBuf2Field+0x68c>
			else TempStr[i]=BufStr[i];
    8f00:	20 83       	st	Z, r18
			i++;
    8f02:	3f 5f       	subi	r19, 0xFF	; 255
    8f04:	dd cf       	rjmp	.-70     	; 0x8ec0 <WebBuf2Field+0x64a>
		ewbl(TempStr, Var, i+1);
		}
		break;
	}

	EventFunc(&Field->Act);
    8f06:	fb e0       	ldi	r31, 0x0B	; 11
    8f08:	cf 0e       	add	r12, r31
    8f0a:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8f0c:	f6 01       	movw	r30, r12
    8f0e:	85 91       	lpm	r24, Z+
    8f10:	94 91       	lpm	r25, Z
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8f12:	00 97       	sbiw	r24, 0x00	; 0
    8f14:	11 f0       	breq	.+4      	; 0x8f1a <WebBuf2Field+0x6a4>
		Func();
    8f16:	fc 01       	movw	r30, r24
    8f18:	09 95       	icall
}
    8f1a:	2d 85       	ldd	r18, Y+13	; 0x0d
    8f1c:	3e 85       	ldd	r19, Y+14	; 0x0e
    8f1e:	0f b6       	in	r0, 0x3f	; 63
    8f20:	f8 94       	cli
    8f22:	3e bf       	out	0x3e, r19	; 62
    8f24:	0f be       	out	0x3f, r0	; 63
    8f26:	2d bf       	out	0x3d, r18	; 61
    8f28:	2e 96       	adiw	r28, 0x0e	; 14
    8f2a:	0f b6       	in	r0, 0x3f	; 63
    8f2c:	f8 94       	cli
    8f2e:	de bf       	out	0x3e, r29	; 62
    8f30:	0f be       	out	0x3f, r0	; 63
    8f32:	cd bf       	out	0x3d, r28	; 61
    8f34:	df 91       	pop	r29
    8f36:	cf 91       	pop	r28
    8f38:	1f 91       	pop	r17
    8f3a:	0f 91       	pop	r16
    8f3c:	ff 90       	pop	r15
    8f3e:	ef 90       	pop	r14
    8f40:	df 90       	pop	r13
    8f42:	cf 90       	pop	r12
    8f44:	bf 90       	pop	r11
    8f46:	af 90       	pop	r10
    8f48:	9f 90       	pop	r9
    8f4a:	8f 90       	pop	r8
    8f4c:	7f 90       	pop	r7
    8f4e:	6f 90       	pop	r6
    8f50:	5f 90       	pop	r5
    8f52:	4f 90       	pop	r4
    8f54:	3f 90       	pop	r3
    8f56:	2f 90       	pop	r2
    8f58:	08 95       	ret

00008f5a <strcmp_PP>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8f5a:	fc 01       	movw	r30, r24
    8f5c:	24 91       	lpm	r18, Z
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    8f5e:	22 23       	and	r18, r18
    8f60:	c1 f0       	breq	.+48     	; 0x8f92 <strcmp_PP+0x38>
    8f62:	fb 01       	movw	r30, r22
    8f64:	24 91       	lpm	r18, Z
    8f66:	22 23       	and	r18, r18
    8f68:	a1 f0       	breq	.+40     	; 0x8f92 <strcmp_PP+0x38>
    8f6a:	fc 01       	movw	r30, r24
    8f6c:	24 91       	lpm	r18, Z
    8f6e:	fb 01       	movw	r30, r22
    8f70:	34 91       	lpm	r19, Z
		if(prb(s1) > prb(s2)) return 1;
    8f72:	32 17       	cp	r19, r18
    8f74:	50 f0       	brcs	.+20     	; 0x8f8a <strcmp_PP+0x30>
    8f76:	fc 01       	movw	r30, r24
    8f78:	24 91       	lpm	r18, Z
    8f7a:	fb 01       	movw	r30, r22
    8f7c:	34 91       	lpm	r19, Z
		if(prb(s1) < prb(s2)) return -1;
    8f7e:	23 17       	cp	r18, r19
    8f80:	30 f0       	brcs	.+12     	; 0x8f8e <strcmp_PP+0x34>
		s1++;
    8f82:	01 96       	adiw	r24, 0x01	; 1
		s2++;
    8f84:	6f 5f       	subi	r22, 0xFF	; 255
    8f86:	7f 4f       	sbci	r23, 0xFF	; 255
    8f88:	e8 cf       	rjmp	.-48     	; 0x8f5a <strcmp_PP>
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    8f8a:	81 e0       	ldi	r24, 0x01	; 1
    8f8c:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    8f8e:	8f ef       	ldi	r24, 0xFF	; 255
    8f90:	08 95       	ret
		s1++;
		s2++;
	}
	return 0;	
    8f92:	80 e0       	ldi	r24, 0x00	; 0
}
    8f94:	08 95       	ret

00008f96 <strcmp_E>:
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    8f96:	ff 92       	push	r15
    8f98:	0f 93       	push	r16
    8f9a:	1f 93       	push	r17
    8f9c:	cf 93       	push	r28
    8f9e:	df 93       	push	r29
    8fa0:	eb 01       	movw	r28, r22
    8fa2:	8c 01       	movw	r16, r24
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8fa4:	f8 01       	movw	r30, r16
    8fa6:	f1 90       	ld	r15, Z+
    8fa8:	8f 01       	movw	r16, r30
    8faa:	ff 20       	and	r15, r15
    8fac:	49 f0       	breq	.+18     	; 0x8fc0 <strcmp_E+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8fae:	ce 01       	movw	r24, r28
    8fb0:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8fb4:	8f 15       	cp	r24, r15
    8fb6:	50 f0       	brcs	.+20     	; 0x8fcc <strcmp_E+0x36>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8fb8:	f8 16       	cp	r15, r24
    8fba:	50 f0       	brcs	.+20     	; 0x8fd0 <strcmp_E+0x3a>
		str_RAM++;
		str_EE++;		
    8fbc:	21 96       	adiw	r28, 0x01	; 1
    8fbe:	f2 cf       	rjmp	.-28     	; 0x8fa4 <strcmp_E+0xe>
    8fc0:	ce 01       	movw	r24, r28
    8fc2:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8fc6:	81 11       	cpse	r24, r1
    8fc8:	f2 cf       	rjmp	.-28     	; 0x8fae <strcmp_E+0x18>
    8fca:	03 c0       	rjmp	.+6      	; 0x8fd2 <strcmp_E+0x3c>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8fcc:	81 e0       	ldi	r24, 0x01	; 1
    8fce:	01 c0       	rjmp	.+2      	; 0x8fd2 <strcmp_E+0x3c>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8fd0:	8f ef       	ldi	r24, 0xFF	; 255
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    8fd2:	df 91       	pop	r29
    8fd4:	cf 91       	pop	r28
    8fd6:	1f 91       	pop	r17
    8fd8:	0f 91       	pop	r16
    8fda:	ff 90       	pop	r15
    8fdc:	08 95       	ret

00008fde <SeekTagFORM>:
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
	static uint8_t match;
	switch(match) {
    8fde:	40 91 3a 02 	lds	r20, 0x023A
    8fe2:	50 e0       	ldi	r21, 0x00	; 0
    8fe4:	49 30       	cpi	r20, 0x09	; 9
    8fe6:	51 05       	cpc	r21, r1
    8fe8:	88 f5       	brcc	.+98     	; 0x904c <SeekTagFORM+0x6e>
    8fea:	fa 01       	movw	r30, r20
    8fec:	e7 57       	subi	r30, 0x77	; 119
    8fee:	ff 4f       	sbci	r31, 0xFF	; 255
    8ff0:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8ff4:	8c 33       	cpi	r24, 0x3C	; 60
    8ff6:	61 f5       	brne	.+88     	; 0x9050 <SeekTagFORM+0x72>
    8ff8:	81 e0       	ldi	r24, 0x01	; 1
    8ffa:	1f c0       	rjmp	.+62     	; 0x903a <SeekTagFORM+0x5c>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    8ffc:	8f 7d       	andi	r24, 0xDF	; 223
    8ffe:	86 34       	cpi	r24, 0x46	; 70
    9000:	29 f5       	brne	.+74     	; 0x904c <SeekTagFORM+0x6e>
    9002:	82 e0       	ldi	r24, 0x02	; 2
    9004:	1a c0       	rjmp	.+52     	; 0x903a <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    9006:	8f 7d       	andi	r24, 0xDF	; 223
    9008:	8f 34       	cpi	r24, 0x4F	; 79
    900a:	01 f5       	brne	.+64     	; 0x904c <SeekTagFORM+0x6e>
    900c:	83 e0       	ldi	r24, 0x03	; 3
    900e:	15 c0       	rjmp	.+42     	; 0x903a <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    9010:	8f 7d       	andi	r24, 0xDF	; 223
    9012:	82 35       	cpi	r24, 0x52	; 82
    9014:	d9 f4       	brne	.+54     	; 0x904c <SeekTagFORM+0x6e>
    9016:	84 e0       	ldi	r24, 0x04	; 4
    9018:	10 c0       	rjmp	.+32     	; 0x903a <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    901a:	8f 7d       	andi	r24, 0xDF	; 223
    901c:	8d 34       	cpi	r24, 0x4D	; 77
    901e:	b1 f4       	brne	.+44     	; 0x904c <SeekTagFORM+0x6e>
    9020:	85 e0       	ldi	r24, 0x05	; 5
    9022:	0b c0       	rjmp	.+22     	; 0x903a <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    9024:	80 32       	cpi	r24, 0x20	; 32
    9026:	91 f4       	brne	.+36     	; 0x904c <SeekTagFORM+0x6e>
    9028:	86 e0       	ldi	r24, 0x06	; 6
    902a:	07 c0       	rjmp	.+14     	; 0x903a <SeekTagFORM+0x5c>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    902c:	8e 33       	cpi	r24, 0x3E	; 62
    902e:	81 f4       	brne	.+32     	; 0x9050 <SeekTagFORM+0x72>
    9030:	87 e0       	ldi	r24, 0x07	; 7
    9032:	03 c0       	rjmp	.+6      	; 0x903a <SeekTagFORM+0x5c>
			break;
		case 7:
			if(ch=='\r') match = 8;
    9034:	8d 30       	cpi	r24, 0x0D	; 13
    9036:	51 f4       	brne	.+20     	; 0x904c <SeekTagFORM+0x6e>
    9038:	88 e0       	ldi	r24, 0x08	; 8
    903a:	80 93 3a 02 	sts	0x023A, r24
    903e:	08 c0       	rjmp	.+16     	; 0x9050 <SeekTagFORM+0x72>
			else match = 0;
			break;
		case 8:
			match = 0;
    9040:	10 92 3a 02 	sts	0x023A, r1
			if(ch=='\n') return 1;
    9044:	91 e0       	ldi	r25, 0x01	; 1
    9046:	8a 30       	cpi	r24, 0x0A	; 10
    9048:	19 f4       	brne	.+6      	; 0x9050 <SeekTagFORM+0x72>
    904a:	03 c0       	rjmp	.+6      	; 0x9052 <SeekTagFORM+0x74>
			break;
		default:
			match = 0;
    904c:	10 92 3a 02 	sts	0x023A, r1
	}
	return 0;
    9050:	90 e0       	ldi	r25, 0x00	; 0

}
    9052:	89 2f       	mov	r24, r25
    9054:	08 95       	ret

00009056 <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    9056:	40 91 39 02 	lds	r20, 0x0239
    905a:	50 e0       	ldi	r21, 0x00	; 0
    905c:	49 30       	cpi	r20, 0x09	; 9
    905e:	51 05       	cpc	r21, r1
    9060:	90 f5       	brcc	.+100    	; 0x90c6 <SeekTagA_HREF+0x70>
    9062:	fa 01       	movw	r30, r20
    9064:	ee 56       	subi	r30, 0x6E	; 110
    9066:	ff 4f       	sbci	r31, 0xFF	; 255
    9068:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    906c:	8c 33       	cpi	r24, 0x3C	; 60
    906e:	69 f5       	brne	.+90     	; 0x90ca <SeekTagA_HREF+0x74>
    9070:	81 e0       	ldi	r24, 0x01	; 1
    9072:	20 c0       	rjmp	.+64     	; 0x90b4 <SeekTagA_HREF+0x5e>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    9074:	8f 7d       	andi	r24, 0xDF	; 223
    9076:	81 34       	cpi	r24, 0x41	; 65
    9078:	31 f5       	brne	.+76     	; 0x90c6 <SeekTagA_HREF+0x70>
    907a:	82 e0       	ldi	r24, 0x02	; 2
    907c:	1b c0       	rjmp	.+54     	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    907e:	80 32       	cpi	r24, 0x20	; 32
    9080:	11 f5       	brne	.+68     	; 0x90c6 <SeekTagA_HREF+0x70>
    9082:	83 e0       	ldi	r24, 0x03	; 3
    9084:	17 c0       	rjmp	.+46     	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    9086:	8f 7d       	andi	r24, 0xDF	; 223
    9088:	88 34       	cpi	r24, 0x48	; 72
    908a:	e9 f4       	brne	.+58     	; 0x90c6 <SeekTagA_HREF+0x70>
    908c:	84 e0       	ldi	r24, 0x04	; 4
    908e:	12 c0       	rjmp	.+36     	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    9090:	8f 7d       	andi	r24, 0xDF	; 223
    9092:	82 35       	cpi	r24, 0x52	; 82
    9094:	c1 f4       	brne	.+48     	; 0x90c6 <SeekTagA_HREF+0x70>
    9096:	85 e0       	ldi	r24, 0x05	; 5
    9098:	0d c0       	rjmp	.+26     	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    909a:	8f 7d       	andi	r24, 0xDF	; 223
    909c:	85 34       	cpi	r24, 0x45	; 69
    909e:	99 f4       	brne	.+38     	; 0x90c6 <SeekTagA_HREF+0x70>
    90a0:	86 e0       	ldi	r24, 0x06	; 6
    90a2:	08 c0       	rjmp	.+16     	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    90a4:	8f 7d       	andi	r24, 0xDF	; 223
    90a6:	86 34       	cpi	r24, 0x46	; 70
    90a8:	71 f4       	brne	.+28     	; 0x90c6 <SeekTagA_HREF+0x70>
    90aa:	87 e0       	ldi	r24, 0x07	; 7
    90ac:	03 c0       	rjmp	.+6      	; 0x90b4 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    90ae:	82 32       	cpi	r24, 0x22	; 34
    90b0:	61 f4       	brne	.+24     	; 0x90ca <SeekTagA_HREF+0x74>
    90b2:	88 e0       	ldi	r24, 0x08	; 8
    90b4:	80 93 39 02 	sts	0x0239, r24
    90b8:	08 c0       	rjmp	.+16     	; 0x90ca <SeekTagA_HREF+0x74>
			break;
		case 8:
			if(ch=='\"'){
    90ba:	82 32       	cpi	r24, 0x22	; 34
    90bc:	31 f4       	brne	.+12     	; 0x90ca <SeekTagA_HREF+0x74>
				match = 0;
    90be:	10 92 39 02 	sts	0x0239, r1
				return 1;
    90c2:	81 e0       	ldi	r24, 0x01	; 1
    90c4:	08 95       	ret
			}
			break;
		default:
			match = 0;
    90c6:	10 92 39 02 	sts	0x0239, r1
	}
	return 0;
    90ca:	80 e0       	ldi	r24, 0x00	; 0
}
    90cc:	08 95       	ret

000090ce <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    90ce:	40 91 38 02 	lds	r20, 0x0238
    90d2:	50 e0       	ldi	r21, 0x00	; 0
    90d4:	4a 30       	cpi	r20, 0x0A	; 10
    90d6:	51 05       	cpc	r21, r1
    90d8:	b8 f5       	brcc	.+110    	; 0x9148 <SeekTagIMG_SRC+0x7a>
    90da:	fa 01       	movw	r30, r20
    90dc:	e5 56       	subi	r30, 0x65	; 101
    90de:	ff 4f       	sbci	r31, 0xFF	; 255
    90e0:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    90e4:	8c 33       	cpi	r24, 0x3C	; 60
    90e6:	91 f5       	brne	.+100    	; 0x914c <SeekTagIMG_SRC+0x7e>
    90e8:	81 e0       	ldi	r24, 0x01	; 1
    90ea:	25 c0       	rjmp	.+74     	; 0x9136 <SeekTagIMG_SRC+0x68>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    90ec:	8f 7d       	andi	r24, 0xDF	; 223
    90ee:	89 34       	cpi	r24, 0x49	; 73
    90f0:	59 f5       	brne	.+86     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    90f2:	82 e0       	ldi	r24, 0x02	; 2
    90f4:	20 c0       	rjmp	.+64     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    90f6:	8f 7d       	andi	r24, 0xDF	; 223
    90f8:	8d 34       	cpi	r24, 0x4D	; 77
    90fa:	31 f5       	brne	.+76     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    90fc:	83 e0       	ldi	r24, 0x03	; 3
    90fe:	1b c0       	rjmp	.+54     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    9100:	8f 7d       	andi	r24, 0xDF	; 223
    9102:	87 34       	cpi	r24, 0x47	; 71
    9104:	09 f5       	brne	.+66     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    9106:	84 e0       	ldi	r24, 0x04	; 4
    9108:	16 c0       	rjmp	.+44     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    910a:	80 32       	cpi	r24, 0x20	; 32
    910c:	e9 f4       	brne	.+58     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    910e:	85 e0       	ldi	r24, 0x05	; 5
    9110:	12 c0       	rjmp	.+36     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    9112:	8f 7d       	andi	r24, 0xDF	; 223
    9114:	83 35       	cpi	r24, 0x53	; 83
    9116:	c1 f4       	brne	.+48     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    9118:	86 e0       	ldi	r24, 0x06	; 6
    911a:	0d c0       	rjmp	.+26     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    911c:	8f 7d       	andi	r24, 0xDF	; 223
    911e:	82 35       	cpi	r24, 0x52	; 82
    9120:	99 f4       	brne	.+38     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    9122:	87 e0       	ldi	r24, 0x07	; 7
    9124:	08 c0       	rjmp	.+16     	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    9126:	8f 7d       	andi	r24, 0xDF	; 223
    9128:	83 34       	cpi	r24, 0x43	; 67
    912a:	71 f4       	brne	.+28     	; 0x9148 <SeekTagIMG_SRC+0x7a>
    912c:	88 e0       	ldi	r24, 0x08	; 8
    912e:	03 c0       	rjmp	.+6      	; 0x9136 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    9130:	82 32       	cpi	r24, 0x22	; 34
    9132:	61 f4       	brne	.+24     	; 0x914c <SeekTagIMG_SRC+0x7e>
    9134:	89 e0       	ldi	r24, 0x09	; 9
    9136:	80 93 38 02 	sts	0x0238, r24
    913a:	08 c0       	rjmp	.+16     	; 0x914c <SeekTagIMG_SRC+0x7e>
			break;
		case 9:
			if(ch=='\"'){
    913c:	82 32       	cpi	r24, 0x22	; 34
    913e:	31 f4       	brne	.+12     	; 0x914c <SeekTagIMG_SRC+0x7e>
				match = 0;
    9140:	10 92 38 02 	sts	0x0238, r1
				return 1;
    9144:	81 e0       	ldi	r24, 0x01	; 1
    9146:	08 95       	ret
			}
			break;
		default:
			match = 0;
    9148:	10 92 38 02 	sts	0x0238, r1
	}
	return 0;
    914c:	80 e0       	ldi	r24, 0x00	; 0
}
    914e:	08 95       	ret

00009150 <WebClose>:
// ~~~~~~~~~~~~~~~~~~
void WebClose(void){
	Web_POST = 0;
    9150:	10 92 51 09 	sts	0x0951, r1
	WebMode = 254;
    9154:	8e ef       	ldi	r24, 0xFE	; 254
    9156:	80 93 06 01 	sts	0x0106, r24
    915a:	08 95       	ret

0000915c <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    915c:	cf 92       	push	r12
    915e:	df 92       	push	r13
    9160:	ef 92       	push	r14
    9162:	ff 92       	push	r15
    9164:	0f 93       	push	r16
    9166:	1f 93       	push	r17
    9168:	cf 93       	push	r28
    916a:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    916c:	80 91 62 09 	lds	r24, 0x0962
    9170:	81 11       	cpse	r24, r1
    9172:	73 c0       	rjmp	.+230    	; 0x925a <Web_Login_Error+0xfe>
//	if(strcmp_E(Web_Passw_Str, Web_Passws) ) return 3;
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
    9174:	10 92 50 0a 	sts	0x0A50, r1
    9178:	00 ef       	ldi	r16, 0xF0	; 240
    917a:	11 e0       	ldi	r17, 0x01	; 1
    917c:	ca e2       	ldi	r28, 0x2A	; 42
    917e:	d0 e0       	ldi	r29, 0x00	; 0
    9180:	ff 24       	eor	r15, r15
    9182:	f3 94       	inc	r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9184:	f8 01       	movw	r30, r16
    9186:	65 91       	lpm	r22, Z+
    9188:	74 91       	lpm	r23, Z
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
    918a:	8b ed       	ldi	r24, 0xDB	; 219
    918c:	99 e0       	ldi	r25, 0x09	; 9
    918e:	0e 94 0e 78 	call	0xf01c	; 0xf01c <strcmp>
    9192:	89 2b       	or	r24, r25
    9194:	49 f4       	brne	.+18     	; 0x91a8 <Web_Login_Error+0x4c>
    9196:	be 01       	movw	r22, r28
    9198:	87 ee       	ldi	r24, 0xE7	; 231
    919a:	95 e0       	ldi	r25, 0x05	; 5
    919c:	0e 94 cb 47 	call	0x8f96	; 0x8f96 <strcmp_E>
    91a0:	81 11       	cpse	r24, r1
    91a2:	02 c0       	rjmp	.+4      	; 0x91a8 <Web_Login_Error+0x4c>
    91a4:	f0 92 50 0a 	sts	0x0A50, r15
    91a8:	f3 94       	inc	r15
    91aa:	00 5f       	subi	r16, 0xF0	; 240
    91ac:	1f 4f       	sbci	r17, 0xFF	; 255
    91ae:	2b 96       	adiw	r28, 0x0b	; 11
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    91b0:	85 e0       	ldi	r24, 0x05	; 5
    91b2:	f8 12       	cpse	r15, r24
    91b4:	e7 cf       	rjmp	.-50     	; 0x9184 <Web_Login_Error+0x28>
		if(!strcmp(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
    91b6:	80 91 50 0a 	lds	r24, 0x0A50
    91ba:	88 23       	and	r24, r24
    91bc:	09 f4       	brne	.+2      	; 0x91c0 <Web_Login_Error+0x64>
    91be:	4f c0       	rjmp	.+158    	; 0x925e <Web_Login_Error+0x102>
	return 2;}


	WebSession = 1;
    91c0:	81 e0       	ldi	r24, 0x01	; 1
    91c2:	80 93 62 09 	sts	0x0962, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    91c6:	c0 91 0e 06 	lds	r28, 0x060E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    91ca:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint32_t Time = Timer32[TimerN];
    91ce:	94 e0       	ldi	r25, 0x04	; 4
    91d0:	c9 9f       	mul	r28, r25
    91d2:	f0 01       	movw	r30, r0
    91d4:	11 24       	eor	r1, r1
    91d6:	e2 58       	subi	r30, 0x82	; 130
    91d8:	fd 4f       	sbci	r31, 0xFD	; 253
    91da:	c0 80       	ld	r12, Z
    91dc:	d1 80       	ldd	r13, Z+1	; 0x01
    91de:	e2 80       	ldd	r14, Z+2	; 0x02
    91e0:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    91e2:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
	srandom(Seed);
    91e6:	c7 01       	movw	r24, r14
    91e8:	b6 01       	movw	r22, r12
    91ea:	0e 94 85 77 	call	0xef0a	; 0xef0a <srandom>
	random();// 
    91ee:	0e 94 81 77 	call	0xef02	; 0xef02 <random>
	Seed = random();
    91f2:	0e 94 81 77 	call	0xef02	; 0xef02 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    91f6:	9f 93       	push	r25
    91f8:	8f 93       	push	r24
    91fa:	7f 93       	push	r23
    91fc:	6f 93       	push	r22
    91fe:	85 e2       	ldi	r24, 0x25	; 37
    9200:	93 e0       	ldi	r25, 0x03	; 3
    9202:	9f 93       	push	r25
    9204:	8f 93       	push	r24
    9206:	8b e1       	ldi	r24, 0x1B	; 27
    9208:	96 e0       	ldi	r25, 0x06	; 6
    920a:	9f 93       	push	r25
    920c:	8f 93       	push	r24
    920e:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
	Seed = random();
    9212:	0e 94 81 77 	call	0xef02	; 0xef02 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    9216:	9f 93       	push	r25
    9218:	8f 93       	push	r24
    921a:	7f 93       	push	r23
    921c:	6f 93       	push	r22
    921e:	8b e1       	ldi	r24, 0x1B	; 27
    9220:	93 e0       	ldi	r25, 0x03	; 3
    9222:	9f 93       	push	r25
    9224:	8f 93       	push	r24
    9226:	83 e2       	ldi	r24, 0x23	; 35
    9228:	96 e0       	ldi	r25, 0x06	; 6
    922a:	9f 93       	push	r25
    922c:	8f 93       	push	r24
    922e:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9232:	86 e5       	ldi	r24, 0x56	; 86
    9234:	90 e0       	ldi	r25, 0x00	; 0
    9236:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <__eerd_dword_m128>
    923a:	ab 01       	movw	r20, r22
    923c:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    923e:	80 91 4c 09 	lds	r24, 0x094C
    9242:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <StartTimer32>
	return 0;
    9246:	8d b7       	in	r24, 0x3d	; 61
    9248:	9e b7       	in	r25, 0x3e	; 62
    924a:	40 96       	adiw	r24, 0x10	; 16
    924c:	0f b6       	in	r0, 0x3f	; 63
    924e:	f8 94       	cli
    9250:	9e bf       	out	0x3e, r25	; 62
    9252:	0f be       	out	0x3f, r0	; 63
    9254:	8d bf       	out	0x3d, r24	; 61
    9256:	80 e0       	ldi	r24, 0x00	; 0
    9258:	03 c0       	rjmp	.+6      	; 0x9260 <Web_Login_Error+0x104>
}
//--Session
uint8_t Web_Login_Error(void){

	//   ?
	if(WebSession) return 1;
    925a:	81 e0       	ldi	r24, 0x01	; 1
    925c:	01 c0       	rjmp	.+2      	; 0x9260 <Web_Login_Error+0x104>
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
	return 2;}
    925e:	82 e0       	ldi	r24, 0x02	; 2
	Seed = random();
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}
    9260:	df 91       	pop	r29
    9262:	cf 91       	pop	r28
    9264:	1f 91       	pop	r17
    9266:	0f 91       	pop	r16
    9268:	ff 90       	pop	r15
    926a:	ef 90       	pop	r14
    926c:	df 90       	pop	r13
    926e:	cf 90       	pop	r12
    9270:	08 95       	ret

00009272 <WebRequest>:
}


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    9272:	2f 92       	push	r2
    9274:	3f 92       	push	r3
    9276:	4f 92       	push	r4
    9278:	5f 92       	push	r5
    927a:	6f 92       	push	r6
    927c:	7f 92       	push	r7
    927e:	8f 92       	push	r8
    9280:	9f 92       	push	r9
    9282:	af 92       	push	r10
    9284:	bf 92       	push	r11
    9286:	cf 92       	push	r12
    9288:	df 92       	push	r13
    928a:	ef 92       	push	r14
    928c:	ff 92       	push	r15
    928e:	0f 93       	push	r16
    9290:	1f 93       	push	r17
    9292:	cf 93       	push	r28
    9294:	df 93       	push	r29
    9296:	cd b7       	in	r28, 0x3d	; 61
    9298:	de b7       	in	r29, 0x3e	; 62
    929a:	2a 97       	sbiw	r28, 0x0a	; 10
    929c:	0f b6       	in	r0, 0x3f	; 63
    929e:	f8 94       	cli
    92a0:	de bf       	out	0x3e, r29	; 62
    92a2:	0f be       	out	0x3f, r0	; 63
    92a4:	cd bf       	out	0x3d, r28	; 61
    92a6:	9a 87       	std	Y+10, r25	; 0x0a
    92a8:	89 87       	std	Y+9, r24	; 0x09
    92aa:	69 83       	std	Y+1, r22	; 0x01
	
	
	WebStrLen = GetStringFromFIFO();
    92ac:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    92b0:	80 93 62 08 	sts	0x0862, r24

	if(Web_POST==2){ 
    92b4:	80 91 51 09 	lds	r24, 0x0951
    92b8:	82 30       	cpi	r24, 0x02	; 2
    92ba:	a1 f4       	brne	.+40     	; 0x92e4 <WebRequest+0x72>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    92bc:	80 91 27 09 	lds	r24, 0x0927
    92c0:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    92c4:	88 23       	and	r24, r24
    92c6:	39 f0       	breq	.+14     	; 0x92d6 <WebRequest+0x64>
			WebStrLen = ForceEndStringFromFIFO();
    92c8:	0e 94 e5 3a 	call	0x75ca	; 0x75ca <ForceEndStringFromFIFO>
    92cc:	80 93 62 08 	sts	0x0862, r24
			Web_POST=3;	
    92d0:	83 e0       	ldi	r24, 0x03	; 3
    92d2:	80 93 51 09 	sts	0x0951, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    92d6:	80 91 62 08 	lds	r24, 0x0862
    92da:	88 23       	and	r24, r24
    92dc:	19 f0       	breq	.+6      	; 0x92e4 <WebRequest+0x72>
    92de:	83 e0       	ldi	r24, 0x03	; 3
    92e0:	80 93 51 09 	sts	0x0951, r24
	}

	//  
	if(WebStrLen){
    92e4:	10 91 62 08 	lds	r17, 0x0862
    92e8:	11 23       	and	r17, r17
    92ea:	f9 f0       	breq	.+62     	; 0x932a <WebRequest+0xb8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    92ec:	e9 85       	ldd	r30, Y+9	; 0x09
    92ee:	fa 85       	ldd	r31, Y+10	; 0x0a
    92f0:	25 90       	lpm	r2, Z+
    92f2:	34 90       	lpm	r3, Z
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    92f4:	61 ee       	ldi	r22, 0xE1	; 225
    92f6:	7c e4       	ldi	r23, 0x4C	; 76
    92f8:	8d e6       	ldi	r24, 0x6D	; 109
    92fa:	99 e0       	ldi	r25, 0x09	; 9
    92fc:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    9300:	89 2b       	or	r24, r25
    9302:	21 f0       	breq	.+8      	; 0x930c <WebRequest+0x9a>

			Web_POST = 1; 
    9304:	81 e0       	ldi	r24, 0x01	; 1
    9306:	80 93 51 09 	sts	0x0951, r24
    930a:	0f c0       	rjmp	.+30     	; 0x932a <WebRequest+0xb8>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    930c:	80 91 51 09 	lds	r24, 0x0951
    9310:	81 30       	cpi	r24, 0x01	; 1
    9312:	71 f4       	brne	.+28     	; 0x9330 <WebRequest+0xbe>
    9314:	11 30       	cpi	r17, 0x01	; 1
    9316:	09 f0       	breq	.+2      	; 0x931a <WebRequest+0xa8>
    9318:	8e c0       	rjmp	.+284    	; 0x9436 <WebRequest+0x1c4>
			Web_POST = 2;
    931a:	82 e0       	ldi	r24, 0x02	; 2
    931c:	80 93 51 09 	sts	0x0951, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    9320:	64 e6       	ldi	r22, 0x64	; 100
    9322:	80 91 27 09 	lds	r24, 0x0927
    9326:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
			return NULL;
    932a:	80 e0       	ldi	r24, 0x00	; 0
    932c:	90 e0       	ldi	r25, 0x00	; 0
    932e:	94 c1       	rjmp	.+808    	; 0x9658 <WebRequest+0x3e6>
		}
		if(Web_POST==3){	//  
    9330:	83 30       	cpi	r24, 0x03	; 3
    9332:	09 f0       	breq	.+2      	; 0x9336 <WebRequest+0xc4>
    9334:	80 c0       	rjmp	.+256    	; 0x9436 <WebRequest+0x1c4>
			Web_POST = 0;
    9336:	10 92 51 09 	sts	0x0951, r1
			url = GSM_RxStr;

			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
    933a:	fe ee       	ldi	r31, 0xEE	; 238
    933c:	cf 2e       	mov	r12, r31
    933e:	fc e4       	ldi	r31, 0x4C	; 76
    9340:	df 2e       	mov	r13, r31
			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//For Debug
			#endif

			//URL 
			url = GSM_RxStr;
    9342:	ad e6       	ldi	r26, 0x6D	; 109
    9344:	ea 2e       	mov	r14, r26
    9346:	a9 e0       	ldi	r26, 0x09	; 9
    9348:	fa 2e       	mov	r15, r26
				varfield = p + 1;
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
    934a:	89 85       	ldd	r24, Y+9	; 0x09
    934c:	9a 85       	ldd	r25, Y+10	; 0x0a
    934e:	02 96       	adiw	r24, 0x02	; 2
    9350:	9a 83       	std	Y+2, r25	; 0x02
    9352:	89 83       	std	Y+1, r24	; 0x01
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    9354:	6d e3       	ldi	r22, 0x3D	; 61
    9356:	70 e0       	ldi	r23, 0x00	; 0
    9358:	c7 01       	movw	r24, r14
    935a:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    935e:	5c 01       	movw	r10, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) {
    9360:	00 97       	sbiw	r24, 0x00	; 0
    9362:	09 f4       	brne	.+2      	; 0x9366 <WebRequest+0xf4>
    9364:	4e c1       	rjmp	.+668    	; 0x9602 <WebRequest+0x390>
				return &Web_login;
				}
				nextvar=strchr(url+1,'&');
    9366:	66 e2       	ldi	r22, 0x26	; 38
    9368:	70 e0       	ldi	r23, 0x00	; 0
    936a:	c7 01       	movw	r24, r14
    936c:	01 96       	adiw	r24, 0x01	; 1
    936e:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    9372:	4c 01       	movw	r8, r24
				varfield = p + 1;
    9374:	85 01       	movw	r16, r10
    9376:	0f 5f       	subi	r16, 0xFF	; 255
    9378:	1f 4f       	sbci	r17, 0xFF	; 255
				*p = '\0';
    937a:	d5 01       	movw	r26, r10
    937c:	1c 92       	st	X, r1
    937e:	e9 81       	ldd	r30, Y+1	; 0x01
    9380:	fa 81       	ldd	r31, Y+2	; 0x02
    9382:	65 90       	lpm	r6, Z+
    9384:	74 90       	lpm	r7, Z
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9386:	20 e0       	ldi	r18, 0x00	; 0
    9388:	13 01       	movw	r2, r6
    938a:	b4 e0       	ldi	r27, 0x04	; 4
    938c:	2b 0e       	add	r2, r27
    938e:	31 1c       	adc	r3, r1
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    9390:	23 01       	movw	r4, r6
    9392:	e6 e0       	ldi	r30, 0x06	; 6
    9394:	4e 0e       	add	r4, r30
    9396:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9398:	f1 01       	movw	r30, r2
    939a:	85 91       	lpm	r24, Z+
    939c:	94 91       	lpm	r25, Z
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    939e:	a2 2e       	mov	r10, r18
    93a0:	b1 2c       	mov	r11, r1
    93a2:	96 95       	lsr	r25
    93a4:	87 95       	ror	r24
    93a6:	96 95       	lsr	r25
    93a8:	87 95       	ror	r24
    93aa:	a8 16       	cp	r10, r24
    93ac:	b9 06       	cpc	r11, r25
    93ae:	50 f5       	brcc	.+84     	; 0x9404 <WebRequest+0x192>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    93b0:	f2 01       	movw	r30, r4
    93b2:	85 91       	lpm	r24, Z+
    93b4:	94 91       	lpm	r25, Z
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    93b6:	00 97       	sbiw	r24, 0x00	; 0
    93b8:	19 f1       	breq	.+70     	; 0x9400 <WebRequest+0x18e>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    93ba:	aa 0c       	add	r10, r10
    93bc:	bb 1c       	adc	r11, r11
    93be:	aa 0c       	add	r10, r10
    93c0:	bb 1c       	adc	r11, r11
    93c2:	a8 0e       	add	r10, r24
    93c4:	b9 1e       	adc	r11, r25
    93c6:	f5 01       	movw	r30, r10
    93c8:	65 91       	lpm	r22, Z+
    93ca:	74 91       	lpm	r23, Z
    93cc:	c7 01       	movw	r24, r14
    93ce:	28 87       	std	Y+8, r18	; 0x08
    93d0:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    93d4:	28 85       	ldd	r18, Y+8	; 0x08
    93d6:	89 2b       	or	r24, r25
    93d8:	99 f4       	brne	.+38     	; 0x9400 <WebRequest+0x18e>
    93da:	c8 01       	movw	r24, r16
    93dc:	8c 01       	movw	r16, r24
    93de:	01 96       	adiw	r24, 0x01	; 1
								while(*varfield=='+') varfield++;	// ignore leading '+'
    93e0:	d8 01       	movw	r26, r16
    93e2:	3c 91       	ld	r19, X
    93e4:	3b 32       	cpi	r19, 0x2B	; 43
    93e6:	d1 f3       	breq	.-12     	; 0x93dc <WebRequest+0x16a>
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield); 
    93e8:	b2 e0       	ldi	r27, 0x02	; 2
    93ea:	ab 0e       	add	r10, r27
    93ec:	b1 1c       	adc	r11, r1
    93ee:	f5 01       	movw	r30, r10
    93f0:	85 91       	lpm	r24, Z+
    93f2:	94 91       	lpm	r25, Z
    93f4:	b8 01       	movw	r22, r16
    93f6:	28 87       	std	Y+8, r18	; 0x08
    93f8:	0e 94 3b 44 	call	0x8876	; 0x8876 <WebBuf2Field>
								ptrPageVar = ptrPage;	//  -    ptrPage
    93fc:	63 01       	movw	r12, r6
    93fe:	28 85       	ldd	r18, Y+8	; 0x08
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9400:	2f 5f       	subi	r18, 0xFF	; 255
    9402:	ca cf       	rjmp	.-108    	; 0x9398 <WebRequest+0x126>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    9404:	74 01       	movw	r14, r8
    9406:	ef ef       	ldi	r30, 0xFF	; 255
    9408:	ee 1a       	sub	r14, r30
    940a:	fe 0a       	sbc	r15, r30
			}while(nextvar);	//     
    940c:	89 28       	or	r8, r9
    940e:	09 f0       	breq	.+2      	; 0x9412 <WebRequest+0x1a0>
    9410:	a1 cf       	rjmp	.-190    	; 0x9354 <WebRequest+0xe2>

			if(Web_LoginAttempt){				
    9412:	80 91 2c 08 	lds	r24, 0x082C
    9416:	88 23       	and	r24, r24
    9418:	09 f4       	brne	.+2      	; 0x941c <WebRequest+0x1aa>
    941a:	18 c1       	rjmp	.+560    	; 0x964c <WebRequest+0x3da>
				Web_LoginAttempt = 0;
    941c:	10 92 2c 08 	sts	0x082C, r1
				Web_Login_Code = Web_Login_Error();
    9420:	0e 94 ae 48 	call	0x915c	; 0x915c <Web_Login_Error>
    9424:	80 93 fc 05 	sts	0x05FC, r24
				if(!Web_Login_Code){ return prp(ptrSite);}
    9428:	81 11       	cpse	r24, r1
    942a:	10 c1       	rjmp	.+544    	; 0x964c <WebRequest+0x3da>
    942c:	e9 85       	ldd	r30, Y+9	; 0x09
    942e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9430:	85 91       	lpm	r24, Z+
    9432:	94 91       	lpm	r25, Z
    9434:	11 c1       	rjmp	.+546    	; 0x9658 <WebRequest+0x3e6>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    9436:	68 ee       	ldi	r22, 0xE8	; 232
    9438:	7c e4       	ldi	r23, 0x4C	; 76
    943a:	8d e6       	ldi	r24, 0x6D	; 109
    943c:	99 e0       	ldi	r25, 0x09	; 9
    943e:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    9442:	89 2b       	or	r24, r25
    9444:	09 f4       	brne	.+2      	; 0x9448 <WebRequest+0x1d6>
    9446:	71 cf       	rjmp	.-286    	; 0x932a <WebRequest+0xb8>
    9448:	60 e2       	ldi	r22, 0x20	; 32
    944a:	70 e0       	ldi	r23, 0x00	; 0
    944c:	81 e7       	ldi	r24, 0x71	; 113
    944e:	99 e0       	ldi	r25, 0x09	; 9
    9450:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    9454:	00 97       	sbiw	r24, 0x00	; 0
    9456:	09 f4       	brne	.+2      	; 0x945a <WebRequest+0x1e8>
    9458:	68 cf       	rjmp	.-304    	; 0x932a <WebRequest+0xb8>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    945a:	dc 01       	movw	r26, r24
    945c:	1c 92       	st	X, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    945e:	64 ea       	ldi	r22, 0xA4	; 164
    9460:	79 e3       	ldi	r23, 0x39	; 57
    9462:	82 e7       	ldi	r24, 0x72	; 114
    9464:	99 e0       	ldi	r25, 0x09	; 9
    9466:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    946a:	89 2b       	or	r24, r25
    946c:	09 f4       	brne	.+2      	; 0x9470 <WebRequest+0x1fe>
    946e:	eb c0       	rjmp	.+470    	; 0x9646 <WebRequest+0x3d4>
			url = strchr(url,'?');
    9470:	6f e3       	ldi	r22, 0x3F	; 63
    9472:	70 e0       	ldi	r23, 0x00	; 0
    9474:	81 e7       	ldi	r24, 0x71	; 113
    9476:	99 e0       	ldi	r25, 0x09	; 9
    9478:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    947c:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    947e:	80 91 62 09 	lds	r24, 0x0962
    9482:	88 23       	and	r24, r24
    9484:	09 f4       	brne	.+2      	; 0x9488 <WebRequest+0x216>
    9486:	bd c0       	rjmp	.+378    	; 0x9602 <WebRequest+0x390>
    9488:	01 15       	cp	r16, r1
    948a:	11 05       	cpc	r17, r1
    948c:	09 f4       	brne	.+2      	; 0x9490 <WebRequest+0x21e>
    948e:	b9 c0       	rjmp	.+370    	; 0x9602 <WebRequest+0x390>
    9490:	48 e0       	ldi	r20, 0x08	; 8
    9492:	50 e0       	ldi	r21, 0x00	; 0
    9494:	60 e7       	ldi	r22, 0x70	; 112
    9496:	7d e4       	ldi	r23, 0x4D	; 77
    9498:	c8 01       	movw	r24, r16
    949a:	0e 94 d2 77 	call	0xefa4	; 0xefa4 <strncmp_P>
    949e:	89 2b       	or	r24, r25
    94a0:	09 f0       	breq	.+2      	; 0x94a4 <WebRequest+0x232>
    94a2:	af c0       	rjmp	.+350    	; 0x9602 <WebRequest+0x390>
    94a4:	40 e1       	ldi	r20, 0x10	; 16
    94a6:	50 e0       	ldi	r21, 0x00	; 0
    94a8:	6b e1       	ldi	r22, 0x1B	; 27
    94aa:	76 e0       	ldi	r23, 0x06	; 6
    94ac:	c8 01       	movw	r24, r16
    94ae:	08 96       	adiw	r24, 0x08	; 8
    94b0:	0e 94 1e 78 	call	0xf03c	; 0xf03c <strncmp>
    94b4:	89 2b       	or	r24, r25
    94b6:	09 f0       	breq	.+2      	; 0x94ba <WebRequest+0x248>
    94b8:	a4 c0       	rjmp	.+328    	; 0x9602 <WebRequest+0x390>
    94ba:	61 01       	movw	r12, r2
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    94bc:	86 e5       	ldi	r24, 0x56	; 86
    94be:	90 e0       	ldi	r25, 0x00	; 0
    94c0:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <__eerd_dword_m128>
    94c4:	ab 01       	movw	r20, r22
    94c6:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    94c8:	80 91 4c 09 	lds	r24, 0x094C
    94cc:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <StartTimer32>
			
			*url = '\0';
    94d0:	f8 01       	movw	r30, r16
    94d2:	11 92       	st	Z+, r1
    94d4:	cf 01       	movw	r24, r30
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    94d6:	66 e2       	ldi	r22, 0x26	; 38
    94d8:	70 e0       	ldi	r23, 0x00	; 0
    94da:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    94de:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    94e0:	00 97       	sbiw	r24, 0x00	; 0
    94e2:	09 f4       	brne	.+2      	; 0x94e6 <WebRequest+0x274>
    94e4:	77 c0       	rjmp	.+238    	; 0x95d4 <WebRequest+0x362>
    94e6:	6e ee       	ldi	r22, 0xEE	; 238
    94e8:	26 2e       	mov	r2, r22
    94ea:	6c e4       	ldi	r22, 0x4C	; 76
    94ec:	36 2e       	mov	r3, r22
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    94ee:	6d e3       	ldi	r22, 0x3D	; 61
    94f0:	70 e0       	ldi	r23, 0x00	; 0
    94f2:	c8 01       	movw	r24, r16
    94f4:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    94f8:	5c 01       	movw	r10, r24
					if(p==NULL) return ptrPage;
    94fa:	00 97       	sbiw	r24, 0x00	; 0
    94fc:	09 f4       	brne	.+2      	; 0x9500 <WebRequest+0x28e>
    94fe:	a6 c0       	rjmp	.+332    	; 0x964c <WebRequest+0x3da>
					nextvar=strchr(url+1,'&');
    9500:	28 01       	movw	r4, r16
    9502:	ff ef       	ldi	r31, 0xFF	; 255
    9504:	4f 1a       	sub	r4, r31
    9506:	5f 0a       	sbc	r5, r31
    9508:	66 e2       	ldi	r22, 0x26	; 38
    950a:	70 e0       	ldi	r23, 0x00	; 0
    950c:	c2 01       	movw	r24, r4
    950e:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    9512:	8c 01       	movw	r16, r24
					varfield = p + 1;
    9514:	75 01       	movw	r14, r10
    9516:	2f ef       	ldi	r18, 0xFF	; 255
    9518:	e2 1a       	sub	r14, r18
    951a:	f2 0a       	sbc	r15, r18
					*p = '\0';
    951c:	d5 01       	movw	r26, r10
    951e:	1c 92       	st	X, r1
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9520:	69 84       	ldd	r6, Y+9	; 0x09
    9522:	7a 84       	ldd	r7, Y+10	; 0x0a
    9524:	30 e0       	ldi	r19, 0x00	; 0
    9526:	29 81       	ldd	r18, Y+1	; 0x01
    9528:	32 17       	cp	r19, r18
    952a:	09 f4       	brne	.+2      	; 0x952e <WebRequest+0x2bc>
    952c:	4e c0       	rjmp	.+156    	; 0x95ca <WebRequest+0x358>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    952e:	f3 01       	movw	r30, r6
    9530:	85 90       	lpm	r8, Z+
    9532:	94 90       	lpm	r9, Z
    9534:	64 01       	movw	r12, r8
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9536:	20 e0       	ldi	r18, 0x00	; 0
    9538:	f4 01       	movw	r30, r8
    953a:	34 96       	adiw	r30, 0x04	; 4
    953c:	fc 83       	std	Y+4, r31	; 0x04
    953e:	eb 83       	std	Y+3, r30	; 0x03
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    9540:	c4 01       	movw	r24, r8
    9542:	06 96       	adiw	r24, 0x06	; 6
    9544:	9e 83       	std	Y+6, r25	; 0x06
    9546:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9548:	eb 81       	ldd	r30, Y+3	; 0x03
    954a:	fc 81       	ldd	r31, Y+4	; 0x04
    954c:	85 91       	lpm	r24, Z+
    954e:	94 91       	lpm	r25, Z
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9550:	a2 2e       	mov	r10, r18
    9552:	b1 2c       	mov	r11, r1
    9554:	96 95       	lsr	r25
    9556:	87 95       	ror	r24
    9558:	96 95       	lsr	r25
    955a:	87 95       	ror	r24
    955c:	a8 16       	cp	r10, r24
    955e:	b9 06       	cpc	r11, r25
    9560:	78 f5       	brcc	.+94     	; 0x95c0 <WebRequest+0x34e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9562:	ed 81       	ldd	r30, Y+5	; 0x05
    9564:	fe 81       	ldd	r31, Y+6	; 0x06
    9566:	85 91       	lpm	r24, Z+
    9568:	94 91       	lpm	r25, Z
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    956a:	00 97       	sbiw	r24, 0x00	; 0
    956c:	39 f1       	breq	.+78     	; 0x95bc <WebRequest+0x34a>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    956e:	aa 0c       	add	r10, r10
    9570:	bb 1c       	adc	r11, r11
    9572:	aa 0c       	add	r10, r10
    9574:	bb 1c       	adc	r11, r11
    9576:	a8 0e       	add	r10, r24
    9578:	b9 1e       	adc	r11, r25
    957a:	f5 01       	movw	r30, r10
    957c:	65 91       	lpm	r22, Z+
    957e:	74 91       	lpm	r23, Z
    9580:	c2 01       	movw	r24, r4
    9582:	28 87       	std	Y+8, r18	; 0x08
    9584:	3f 83       	std	Y+7, r19	; 0x07
    9586:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    958a:	28 85       	ldd	r18, Y+8	; 0x08
    958c:	3f 81       	ldd	r19, Y+7	; 0x07
    958e:	89 2b       	or	r24, r25
    9590:	a9 f4       	brne	.+42     	; 0x95bc <WebRequest+0x34a>
    9592:	c7 01       	movw	r24, r14
    9594:	7c 01       	movw	r14, r24
    9596:	01 96       	adiw	r24, 0x01	; 1
									while(*varfield=='+') varfield++;	// ignore leading '+'
    9598:	d7 01       	movw	r26, r14
    959a:	4c 91       	ld	r20, X
    959c:	4b 32       	cpi	r20, 0x2B	; 43
    959e:	d1 f3       	breq	.-12     	; 0x9594 <WebRequest+0x322>
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    95a0:	b2 e0       	ldi	r27, 0x02	; 2
    95a2:	ab 0e       	add	r10, r27
    95a4:	b1 1c       	adc	r11, r1
    95a6:	f5 01       	movw	r30, r10
    95a8:	85 91       	lpm	r24, Z+
    95aa:	94 91       	lpm	r25, Z
    95ac:	b7 01       	movw	r22, r14
    95ae:	28 87       	std	Y+8, r18	; 0x08
    95b0:	3f 83       	std	Y+7, r19	; 0x07
    95b2:	0e 94 3b 44 	call	0x8876	; 0x8876 <WebBuf2Field>
									ptrPageVar = ptrPage;	//  -    ptrPage
    95b6:	14 01       	movw	r2, r8
    95b8:	3f 81       	ldd	r19, Y+7	; 0x07
    95ba:	28 85       	ldd	r18, Y+8	; 0x08
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    95bc:	2f 5f       	subi	r18, 0xFF	; 255
    95be:	c4 cf       	rjmp	.-120    	; 0x9548 <WebRequest+0x2d6>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    95c0:	3f 5f       	subi	r19, 0xFF	; 255
    95c2:	e2 e0       	ldi	r30, 0x02	; 2
    95c4:	6e 0e       	add	r6, r30
    95c6:	71 1c       	adc	r7, r1
    95c8:	ae cf       	rjmp	.-164    	; 0x9526 <WebRequest+0x2b4>
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    95ca:	01 15       	cp	r16, r1
    95cc:	11 05       	cpc	r17, r1
    95ce:	09 f0       	breq	.+2      	; 0x95d2 <WebRequest+0x360>
    95d0:	8e cf       	rjmp	.-228    	; 0x94ee <WebRequest+0x27c>
    95d2:	3e c0       	rjmp	.+124    	; 0x9650 <WebRequest+0x3de>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    95d4:	6c e3       	ldi	r22, 0x3C	; 60
    95d6:	73 e0       	ldi	r23, 0x03	; 3
    95d8:	81 e7       	ldi	r24, 0x71	; 113
    95da:	99 e0       	ldi	r25, 0x09	; 9
    95dc:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    95e0:	89 2b       	or	r24, r25
    95e2:	09 f4       	brne	.+2      	; 0x95e6 <WebRequest+0x374>
    95e4:	35 c0       	rjmp	.+106    	; 0x9650 <WebRequest+0x3de>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    95e6:	60 e3       	ldi	r22, 0x30	; 48
    95e8:	73 e0       	ldi	r23, 0x03	; 3
    95ea:	82 e7       	ldi	r24, 0x72	; 114
    95ec:	99 e0       	ldi	r25, 0x09	; 9
    95ee:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    95f2:	89 2b       	or	r24, r25
    95f4:	21 f0       	breq	.+8      	; 0x95fe <WebRequest+0x38c>
    95f6:	e9 84       	ldd	r14, Y+9	; 0x09
    95f8:	fa 84       	ldd	r15, Y+10	; 0x0a
    95fa:	10 e0       	ldi	r17, 0x00	; 0
    95fc:	15 c0       	rjmp	.+42     	; 0x9628 <WebRequest+0x3b6>
				WebSession = 0;
    95fe:	10 92 62 09 	sts	0x0962, r1
				return &Web_login;
    9602:	85 ec       	ldi	r24, 0xC5	; 197
    9604:	98 e4       	ldi	r25, 0x48	; 72
    9606:	28 c0       	rjmp	.+80     	; 0x9658 <WebRequest+0x3e6>
    9608:	f7 01       	movw	r30, r14
    960a:	c5 90       	lpm	r12, Z+
    960c:	d4 90       	lpm	r13, Z
    960e:	f6 01       	movw	r30, r12
    9610:	65 91       	lpm	r22, Z+
    9612:	74 91       	lpm	r23, Z
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    9614:	82 e7       	ldi	r24, 0x72	; 114
    9616:	99 e0       	ldi	r25, 0x09	; 9
    9618:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    961c:	a2 e0       	ldi	r26, 0x02	; 2
    961e:	ea 0e       	add	r14, r26
    9620:	f1 1c       	adc	r15, r1
    9622:	89 2b       	or	r24, r25
    9624:	29 f0       	breq	.+10     	; 0x9630 <WebRequest+0x3be>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    9626:	1f 5f       	subi	r17, 0xFF	; 255
    9628:	29 81       	ldd	r18, Y+1	; 0x01
    962a:	12 13       	cpse	r17, r18
    962c:	ed cf       	rjmp	.-38     	; 0x9608 <WebRequest+0x396>
    962e:	08 c0       	rjmp	.+16     	; 0x9640 <WebRequest+0x3ce>
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9630:	f6 01       	movw	r30, r12
    9632:	3c 96       	adiw	r30, 0x0c	; 12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9634:	e4 91       	lpm	r30, Z
    9636:	80 91 50 0a 	lds	r24, 0x0A50
    963a:	8e 17       	cp	r24, r30
    963c:	58 f0       	brcs	.+22     	; 0x9654 <WebRequest+0x3e2>
    963e:	06 c0       	rjmp	.+12     	; 0x964c <WebRequest+0x3da>
					return ptrPage;				
				}
			}
			
			//  URL
			return &Web_error_page;
    9640:	8e ee       	ldi	r24, 0xEE	; 238
    9642:	9c e4       	ldi	r25, 0x4C	; 76
    9644:	09 c0       	rjmp	.+18     	; 0x9658 <WebRequest+0x3e6>
			#endif

			*p = '\0';

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9646:	89 e1       	ldi	r24, 0x19	; 25
    9648:	94 e3       	ldi	r25, 0x34	; 52
    964a:	06 c0       	rjmp	.+12     	; 0x9658 <WebRequest+0x3e6>
    964c:	c6 01       	movw	r24, r12
    964e:	04 c0       	rjmp	.+8      	; 0x9658 <WebRequest+0x3e6>
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
				return ptrPage;			
    9650:	c1 01       	movw	r24, r2
    9652:	02 c0       	rjmp	.+4      	; 0x9658 <WebRequest+0x3e6>
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9654:	80 ee       	ldi	r24, 0xE0	; 224
    9656:	92 e3       	ldi	r25, 0x32	; 50
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    9658:	2a 96       	adiw	r28, 0x0a	; 10
    965a:	0f b6       	in	r0, 0x3f	; 63
    965c:	f8 94       	cli
    965e:	de bf       	out	0x3e, r29	; 62
    9660:	0f be       	out	0x3f, r0	; 63
    9662:	cd bf       	out	0x3d, r28	; 61
    9664:	df 91       	pop	r29
    9666:	cf 91       	pop	r28
    9668:	1f 91       	pop	r17
    966a:	0f 91       	pop	r16
    966c:	ff 90       	pop	r15
    966e:	ef 90       	pop	r14
    9670:	df 90       	pop	r13
    9672:	cf 90       	pop	r12
    9674:	bf 90       	pop	r11
    9676:	af 90       	pop	r10
    9678:	9f 90       	pop	r9
    967a:	8f 90       	pop	r8
    967c:	7f 90       	pop	r7
    967e:	6f 90       	pop	r6
    9680:	5f 90       	pop	r5
    9682:	4f 90       	pop	r4
    9684:	3f 90       	pop	r3
    9686:	2f 90       	pop	r2
    9688:	08 95       	ret

0000968a <EM_InitFIFO>:
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
    968a:	8f ef       	ldi	r24, 0xFF	; 255
    968c:	80 93 54 09 	sts	0x0954, r24
	EM_RX_FIFO_End = 255;
    9690:	80 93 1b 0d 	sts	0x0D1B, r24
	EMeter_RxCharN = 0;
    9694:	10 92 22 0d 	sts	0x0D22, r1
    9698:	10 92 21 0d 	sts	0x0D21, r1
    969c:	08 95       	ret

0000969e <EM_SetUARTParam>:
		EM_UART_BitQt = 3;		
	}
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
    969e:	29 2f       	mov	r18, r25
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    96a0:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    96a4:	80 93 4f 0a 	sts	0x0A4F, r24

	switch(EM_UART_Rate){
    96a8:	90 e0       	ldi	r25, 0x00	; 0
    96aa:	89 30       	cpi	r24, 0x09	; 9
    96ac:	91 05       	cpc	r25, r1
    96ae:	38 f5       	brcc	.+78     	; 0x96fe <EM_SetUARTParam+0x60>
    96b0:	fc 01       	movw	r30, r24
    96b2:	eb 55       	subi	r30, 0x5B	; 91
    96b4:	ff 4f       	sbci	r31, 0xFF	; 255
    96b6:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    96ba:	83 e0       	ldi	r24, 0x03	; 3
    96bc:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    96c0:	82 e4       	ldi	r24, 0x42	; 66
    96c2:	20 c0       	rjmp	.+64     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    96c4:	81 e0       	ldi	r24, 0x01	; 1
    96c6:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    96ca:	80 ea       	ldi	r24, 0xA0	; 160
    96cc:	1b c0       	rjmp	.+54     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    96ce:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    96d2:	8f ec       	ldi	r24, 0xCF	; 207
    96d4:	17 c0       	rjmp	.+46     	; 0x9704 <EM_SetUARTParam+0x66>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    96d6:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    96da:	84 e4       	ldi	r24, 0x44	; 68
    96dc:	13 c0       	rjmp	.+38     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    96de:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    96e2:	83 e3       	ldi	r24, 0x33	; 51
    96e4:	0f c0       	rjmp	.+30     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    96e6:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    96ea:	82 e2       	ldi	r24, 0x22	; 34
    96ec:	0b c0       	rjmp	.+22     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    96ee:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    96f2:	89 e1       	ldi	r24, 0x19	; 25
    96f4:	07 c0       	rjmp	.+14     	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    96f6:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    96fa:	80 e1       	ldi	r24, 0x10	; 16
    96fc:	03 c0       	rjmp	.+6      	; 0x9704 <EM_SetUARTParam+0x66>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    96fe:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    9702:	87 e6       	ldi	r24, 0x67	; 103
    9704:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    9708:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    970c:	82 2f       	mov	r24, r18
    970e:	83 70       	andi	r24, 0x03	; 3
    9710:	80 93 fe 05 	sts	0x05FE, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    9714:	82 30       	cpi	r24, 0x02	; 2
    9716:	41 f0       	breq	.+16     	; 0x9728 <EM_SetUARTParam+0x8a>
    9718:	83 30       	cpi	r24, 0x03	; 3
    971a:	51 f0       	breq	.+20     	; 0x9730 <EM_SetUARTParam+0x92>
    971c:	81 30       	cpi	r24, 0x01	; 1
    971e:	41 f4       	brne	.+16     	; 0x9730 <EM_SetUARTParam+0x92>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9720:	80 91 9d 00 	lds	r24, 0x009D
    9724:	80 62       	ori	r24, 0x20	; 32
    9726:	06 c0       	rjmp	.+12     	; 0x9734 <EM_SetUARTParam+0x96>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    9728:	80 91 9d 00 	lds	r24, 0x009D
    972c:	80 63       	ori	r24, 0x30	; 48
    972e:	02 c0       	rjmp	.+4      	; 0x9734 <EM_SetUARTParam+0x96>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9730:	80 91 9d 00 	lds	r24, 0x009D
    9734:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    9738:	22 fb       	bst	r18, 2
    973a:	88 27       	eor	r24, r24
    973c:	80 f9       	bld	r24, 0
    973e:	80 93 28 09 	sts	0x0928, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    9742:	81 30       	cpi	r24, 0x01	; 1
    9744:	19 f0       	breq	.+6      	; 0x974c <EM_SetUARTParam+0xae>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    9746:	80 91 9d 00 	lds	r24, 0x009D
    974a:	03 c0       	rjmp	.+6      	; 0x9752 <EM_SetUARTParam+0xb4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    974c:	80 91 9d 00 	lds	r24, 0x009D
    9750:	88 60       	ori	r24, 0x08	; 8
    9752:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    9756:	92 2f       	mov	r25, r18
    9758:	96 95       	lsr	r25
    975a:	96 95       	lsr	r25
    975c:	96 95       	lsr	r25
    975e:	93 70       	andi	r25, 0x03	; 3
    9760:	90 93 56 0a 	sts	0x0A56, r25
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    9764:	80 91 9d 00 	lds	r24, 0x009D
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    9768:	92 30       	cpi	r25, 0x02	; 2
    976a:	31 f0       	breq	.+12     	; 0x9778 <EM_SetUARTParam+0xda>
    976c:	93 30       	cpi	r25, 0x03	; 3
    976e:	31 f0       	breq	.+12     	; 0x977c <EM_SetUARTParam+0xde>
    9770:	91 30       	cpi	r25, 0x01	; 1
    9772:	29 f4       	brne	.+10     	; 0x977e <EM_SetUARTParam+0xe0>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    9774:	82 60       	ori	r24, 0x02	; 2
    9776:	03 c0       	rjmp	.+6      	; 0x977e <EM_SetUARTParam+0xe0>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    9778:	84 60       	ori	r24, 0x04	; 4
    977a:	01 c0       	rjmp	.+2      	; 0x977e <EM_SetUARTParam+0xe0>
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    977c:	86 60       	ori	r24, 0x06	; 6
    977e:	80 93 9d 00 	sts	0x009D, r24
    9782:	08 95       	ret

00009784 <ApplyUARTParam>:
	}
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
    9784:	80 91 4f 0a 	lds	r24, 0x0A4F
    9788:	60 91 fe 05 	lds	r22, 0x05FE
    978c:	70 e0       	ldi	r23, 0x00	; 0
    978e:	76 2f       	mov	r23, r22
    9790:	66 27       	eor	r22, r22
    9792:	68 0f       	add	r22, r24
    9794:	71 1d       	adc	r23, r1
    9796:	80 91 28 09 	lds	r24, 0x0928
    979a:	90 e0       	ldi	r25, 0x00	; 0
    979c:	98 2f       	mov	r25, r24
    979e:	88 27       	eor	r24, r24
    97a0:	99 0f       	add	r25, r25
    97a2:	99 0f       	add	r25, r25
    97a4:	68 0f       	add	r22, r24
    97a6:	79 1f       	adc	r23, r25
    97a8:	80 91 56 0a 	lds	r24, 0x0A56
    97ac:	90 e0       	ldi	r25, 0x00	; 0
    97ae:	98 2f       	mov	r25, r24
    97b0:	88 27       	eor	r24, r24
    97b2:	99 0f       	add	r25, r25
    97b4:	99 0f       	add	r25, r25
    97b6:	99 0f       	add	r25, r25
    97b8:	68 0f       	add	r22, r24
    97ba:	79 1f       	adc	r23, r25
	eww(&EM_UART_Param, Temp16);
    97bc:	87 e2       	ldi	r24, 0x27	; 39
    97be:	90 e0       	ldi	r25, 0x00	; 0
    97c0:	0e 94 4f 2a 	call	0x549e	; 0x549e <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    97c4:	80 91 59 0a 	lds	r24, 0x0A59
    97c8:	81 11       	cpse	r24, r1
    97ca:	06 c0       	rjmp	.+12     	; 0x97d8 <ApplyUARTParam+0x54>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    97cc:	87 e2       	ldi	r24, 0x27	; 39
    97ce:	90 e0       	ldi	r25, 0x00	; 0
    97d0:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    97d4:	0e 94 4f 4b 	call	0x969e	; 0x969e <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    97d8:	0c 94 9f 2a 	jmp	0x553e	; 0x553e <Modbus_ReadHoldReg>

000097dc <ChangeUARTParam>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    97dc:	89 e2       	ldi	r24, 0x29	; 41
    97de:	90 e0       	ldi	r25, 0x00	; 0
    97e0:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    97e4:	81 30       	cpi	r24, 0x01	; 1
    97e6:	51 f4       	brne	.+20     	; 0x97fc <ChangeUARTParam+0x20>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    97e8:	93 e0       	ldi	r25, 0x03	; 3
    97ea:	90 93 4f 0a 	sts	0x0A4F, r25
		EM_UART_Parity = 1;
    97ee:	80 93 fe 05 	sts	0x05FE, r24
		EM_UART_StopBits = 0;
    97f2:	10 92 28 09 	sts	0x0928, r1
		EM_UART_BitQt = 2;
    97f6:	82 e0       	ldi	r24, 0x02	; 2
    97f8:	80 93 56 0a 	sts	0x0A56, r24
    97fc:	89 e2       	ldi	r24, 0x29	; 41
    97fe:	90 e0       	ldi	r25, 0x00	; 0
    9800:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    9804:	82 50       	subi	r24, 0x02	; 2
    9806:	83 30       	cpi	r24, 0x03	; 3
    9808:	48 f4       	brcc	.+18     	; 0x981c <ChangeUARTParam+0x40>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    980a:	83 e0       	ldi	r24, 0x03	; 3
    980c:	80 93 4f 0a 	sts	0x0A4F, r24
		EM_UART_Parity = 0;
    9810:	10 92 fe 05 	sts	0x05FE, r1
		EM_UART_StopBits = 0;
    9814:	10 92 28 09 	sts	0x0928, r1
		EM_UART_BitQt = 3;		
    9818:	80 93 56 0a 	sts	0x0A56, r24
	}
	ApplyUARTParam();
    981c:	0c 94 c2 4b 	jmp	0x9784	; 0x9784 <ApplyUARTParam>

00009820 <EMeter_ReInit>:
	}
}
void EMeter_ReInit(void){

	//RS485
	MB_PLC_Init();
    9820:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <MB_PLC_Init>
	
	#ifdef CTS
		CTS_Config();
    9824:	0e 94 24 2f 	call	0x5e48	; 0x5e48 <CTS_Config>
		CTS_OFF();
    9828:	0e 94 26 2f 	call	0x5e4c	; 0x5e4c <CTS_OFF>
	#endif
	#ifdef RTS
		RTS_Config();
    982c:	0e 94 2a 2f 	call	0x5e54	; 0x5e54 <RTS_Config>
	#endif

	EM_InitFIFO();
    9830:	0e 94 45 4b 	call	0x968a	; 0x968a <EM_InitFIFO>

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9834:	88 e9       	ldi	r24, 0x98	; 152
    9836:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    983a:	80 e4       	ldi	r24, 0x40	; 64
    983c:	80 93 9b 00 	sts	0x009B, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9840:	87 e2       	ldi	r24, 0x27	; 39
    9842:	90 e0       	ldi	r25, 0x00	; 0
    9844:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    9848:	0e 94 4f 4b 	call	0x969e	; 0x969e <EM_SetUARTParam>

	EM_HalfBufferStart= EMeter_RxStr;//----    
    984c:	8e e2       	ldi	r24, 0x2E	; 46
    984e:	97 e0       	ldi	r25, 0x07	; 7
    9850:	90 93 6c 09 	sts	0x096C, r25
    9854:	80 93 6b 09 	sts	0x096B, r24
	EMeter_RxStr_Offset = EMeter_RxStr;
    9858:	90 93 fb 05 	sts	0x05FB, r25
    985c:	80 93 fa 05 	sts	0x05FA, r24
	EM_BufferReadEnable=0;//----- 
    9860:	10 92 36 09 	sts	0x0936, r1
	EMeter_RxCharN=0;
    9864:	10 92 22 0d 	sts	0x0D22, r1
    9868:	10 92 21 0d 	sts	0x0D21, r1
    986c:	08 95       	ret

0000986e <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    986e:	80 91 5a 0a 	lds	r24, 0x0A5A
    9872:	88 23       	and	r24, r24
    9874:	31 f0       	breq	.+12     	; 0x9882 <GSM_CloseTransparent+0x14>
		
		cli();		
    9876:	f8 94       	cli
		Transparent = 0;
    9878:	10 92 5a 0a 	sts	0x0A5A, r1
		EMeter_ReInit();
    987c:	0e 94 10 4c 	call	0x9820	; 0x9820 <EMeter_ReInit>
		sei();
    9880:	78 94       	sei
		
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    9882:	6f ef       	ldi	r22, 0xFF	; 255
    9884:	7f ef       	ldi	r23, 0xFF	; 255
    9886:	80 91 51 02 	lds	r24, 0x0251
    988a:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>

0000988e <GSM_Transparent2Modbus>:
}
// ~~~~~~~~~~~
void GSM_Transparent2Modbus(void)
{
	GSM_CloseTransparent();	
    988e:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
	GSM_State = GSM_Swtch2CommandMode;
    9892:	88 e5       	ldi	r24, 0x58	; 88
    9894:	80 93 19 06 	sts	0x0619, r24
    9898:	08 95       	ret

0000989a <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    989a:	80 91 0a 01 	lds	r24, 0x010A
	VacantTimer16Sys += n;
    989e:	91 e0       	ldi	r25, 0x01	; 1
    98a0:	98 0f       	add	r25, r24
    98a2:	90 93 0a 01 	sts	0x010A, r25

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    98a6:	80 93 1b 0c 	sts	0x0C1B, r24
	EMeter_ReInit();
    98aa:	0e 94 10 4c 	call	0x9820	; 0x9820 <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    98ae:	8a e0       	ldi	r24, 0x0A	; 10
    98b0:	90 e0       	ldi	r25, 0x00	; 0
    98b2:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	if(erb(&AutoSend)){
    98b6:	88 23       	and	r24, r24
    98b8:	49 f0       	breq	.+18     	; 0x98cc <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    98ba:	68 ee       	ldi	r22, 0xE8	; 232
    98bc:	73 e0       	ldi	r23, 0x03	; 3
    98be:	80 91 1b 0c 	lds	r24, 0x0C1B
    98c2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
		EM_Mode = 0;
    98c6:	10 92 55 0a 	sts	0x0A55, r1
    98ca:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    98cc:	8f ef       	ldi	r24, 0xFF	; 255
    98ce:	80 93 55 0a 	sts	0x0A55, r24
    98d2:	08 95       	ret

000098d4 <USART_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    98d4:	80 91 0b 01 	lds	r24, 0x010B
	VacantTimer8Sys += n;
    98d8:	91 e0       	ldi	r25, 0x01	; 1
    98da:	98 0f       	add	r25, r24
    98dc:	90 93 0b 01 	sts	0x010B, r25

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
    98e0:	80 93 32 09 	sts	0x0932, r24

	MB_Init();
    98e4:	0e 94 e6 35 	call	0x6bcc	; 0x6bcc <MB_Init>
	EMeter_Init();
    98e8:	0e 94 4d 4c 	call	0x989a	; 0x989a <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
    98ec:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
    98ee:	d8 9a       	sbi	0x1b, 0	; 27
    98f0:	85 e3       	ldi	r24, 0x35	; 53
    98f2:	8a 95       	dec	r24
    98f4:	f1 f7       	brne	.-4      	; 0x98f2 <USART_Init+0x1e>
    98f6:	00 00       	nop
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
    98f8:	c8 99       	sbic	0x19, 0	; 25
    98fa:	08 c0       	rjmp	.+16     	; 0x990c <USART_Init+0x38>
		MB_Init();
    98fc:	0e 94 e6 35 	call	0x6bcc	; 0x6bcc <MB_Init>
		UART_Soft = 1;
    9900:	81 e0       	ldi	r24, 0x01	; 1
    9902:	80 93 59 0a 	sts	0x0A59, r24
		ModbusMode = 1;
    9906:	80 93 d8 03 	sts	0x03D8, r24
    990a:	06 c0       	rjmp	.+12     	; 0x9918 <USART_Init+0x44>
	}
	else{
		EMeter_ReInit();
    990c:	0e 94 10 4c 	call	0x9820	; 0x9820 <EMeter_ReInit>
		UART_Soft = 0;
    9910:	10 92 59 0a 	sts	0x0A59, r1
		ModbusMode = 0;
    9914:	10 92 d8 03 	sts	0x03D8, r1
	}
	
	GSM_Init();
    9918:	0c 94 34 3b 	jmp	0x7668	; 0x7668 <GSM_Init>

0000991c <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    991c:	80 91 5a 0a 	lds	r24, 0x0A5A
    9920:	88 23       	and	r24, r24
    9922:	19 f1       	breq	.+70     	; 0x996a <EMeter_RX+0x4e>
		char Char = UDR_EMETER;
    9924:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    9928:	80 91 54 09 	lds	r24, 0x0954
    992c:	8f 5f       	subi	r24, 0xFF	; 255
    992e:	80 93 54 09 	sts	0x0954, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    9932:	80 91 54 09 	lds	r24, 0x0954
    9936:	8a 3f       	cpi	r24, 0xFA	; 250
    9938:	10 f0       	brcs	.+4      	; 0x993e <EMeter_RX+0x22>
    993a:	10 92 54 09 	sts	0x0954, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    993e:	e0 91 54 09 	lds	r30, 0x0954
    9942:	f0 e0       	ldi	r31, 0x00	; 0
    9944:	ef 50       	subi	r30, 0x0F	; 15
    9946:	fc 4f       	sbci	r31, 0xFC	; 252
    9948:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    994a:	90 91 54 09 	lds	r25, 0x0954
    994e:	80 91 1b 0d 	lds	r24, 0x0D1B
    9952:	98 13       	cpse	r25, r24
    9954:	06 c0       	rjmp	.+12     	; 0x9962 <EMeter_RX+0x46>
			EM_RX_FIFOOverFlow = 1;
    9956:	81 e0       	ldi	r24, 0x01	; 1
    9958:	80 93 07 0b 	sts	0x0B07, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    995c:	8a ef       	ldi	r24, 0xFA	; 250
    995e:	80 93 52 0a 	sts	0x0A52, r24
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    9962:	88 eb       	ldi	r24, 0xB8	; 184
    9964:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    9966:	5e 9a       	sbi	0x0b, 6	; 11
    9968:	08 95       	ret
	}
	//----- Non transparent
	else{

		if(EMeterTypeRAM == LANDIS_GYR_ZMR110){
    996a:	80 91 e7 03 	lds	r24, 0x03E7
    996e:	81 30       	cpi	r24, 0x01	; 1
    9970:	69 f4       	brne	.+26     	; 0x998c <EMeter_RX+0x70>
			EM_HalfBufferStart[EMeter_RxCharN] = UDR_EMETER;
    9972:	80 91 21 0d 	lds	r24, 0x0D21
    9976:	90 91 22 0d 	lds	r25, 0x0D22
    997a:	e0 91 6b 09 	lds	r30, 0x096B
    997e:	f0 91 6c 09 	lds	r31, 0x096C
    9982:	e8 0f       	add	r30, r24
    9984:	f9 1f       	adc	r31, r25
    9986:	80 91 9c 00 	lds	r24, 0x009C
    998a:	08 c0       	rjmp	.+16     	; 0x999c <EMeter_RX+0x80>
		}
		else
		{
			EMeter_RxStr[EMeter_RxCharN] = UDR_EMETER;
    998c:	e0 91 21 0d 	lds	r30, 0x0D21
    9990:	f0 91 22 0d 	lds	r31, 0x0D22
    9994:	80 91 9c 00 	lds	r24, 0x009C
    9998:	e2 5d       	subi	r30, 0xD2	; 210
    999a:	f8 4f       	sbci	r31, 0xF8	; 248
    999c:	80 83       	st	Z, r24
		}
		
		
		if(EMeterTypeRAM == ELVIN_MODEM){
    999e:	80 91 e7 03 	lds	r24, 0x03E7
    99a2:	84 30       	cpi	r24, 0x04	; 4
    99a4:	b1 f4       	brne	.+44     	; 0x99d2 <EMeter_RX+0xb6>
			EMeter_RxCharN++;
    99a6:	80 91 21 0d 	lds	r24, 0x0D21
    99aa:	90 91 22 0d 	lds	r25, 0x0D22
    99ae:	01 96       	adiw	r24, 0x01	; 1
    99b0:	90 93 22 0d 	sts	0x0D22, r25
    99b4:	80 93 21 0d 	sts	0x0D21, r24
			if(EMeter_RxCharN >= EM_RX_SIZE) EMeter_RxCharN = 0; //     ELVIN_MODEM -   
    99b8:	80 91 21 0d 	lds	r24, 0x0D21
    99bc:	90 91 22 0d 	lds	r25, 0x0D22
    99c0:	8e 3f       	cpi	r24, 0xFE	; 254
    99c2:	91 05       	cpc	r25, r1
    99c4:	08 f4       	brcc	.+2      	; 0x99c8 <EMeter_RX+0xac>
    99c6:	53 c0       	rjmp	.+166    	; 0x9a6e <EMeter_RX+0x152>
    99c8:	10 92 22 0d 	sts	0x0D22, r1
    99cc:	10 92 21 0d 	sts	0x0D21, r1
    99d0:	08 95       	ret
		}
		else{
			if(EMeterTypeRAM == LANDIS_GYR_ZMR110)
    99d2:	81 30       	cpi	r24, 0x01	; 1
    99d4:	e1 f5       	brne	.+120    	; 0x9a4e <EMeter_RX+0x132>
			{
				if( ((EM_HalfBufferStart[EMeter_RxCharN] == 0x0A) && (EMeter_RxCharN >= (EM_RX_SIZE/2 - LG_ZMR110_MAX_STR)))||(EMeter_RxCharN >= EM_RX_SIZE/2-1) ) 
    99d6:	80 91 6b 09 	lds	r24, 0x096B
    99da:	90 91 6c 09 	lds	r25, 0x096C
    99de:	e0 91 21 0d 	lds	r30, 0x0D21
    99e2:	f0 91 22 0d 	lds	r31, 0x0D22
    99e6:	e8 0f       	add	r30, r24
    99e8:	f9 1f       	adc	r31, r25
    99ea:	20 81       	ld	r18, Z
    99ec:	2a 30       	cpi	r18, 0x0A	; 10
    99ee:	39 f4       	brne	.+14     	; 0x99fe <EMeter_RX+0xe2>
    99f0:	20 91 21 0d 	lds	r18, 0x0D21
    99f4:	30 91 22 0d 	lds	r19, 0x0D22
    99f8:	21 36       	cpi	r18, 0x61	; 97
    99fa:	31 05       	cpc	r19, r1
    99fc:	38 f4       	brcc	.+14     	; 0x9a0c <EMeter_RX+0xf0>
    99fe:	20 91 21 0d 	lds	r18, 0x0D21
    9a02:	30 91 22 0d 	lds	r19, 0x0D22
    9a06:	2e 37       	cpi	r18, 0x7E	; 126
    9a08:	31 05       	cpc	r19, r1
    9a0a:	40 f1       	brcs	.+80     	; 0x9a5c <EMeter_RX+0x140>
				{
					EMeter_RxCharN=0;
    9a0c:	10 92 22 0d 	sts	0x0D22, r1
    9a10:	10 92 21 0d 	sts	0x0D21, r1
					if(EM_HalfBufferStart==EMeter_RxStr)
    9a14:	27 e0       	ldi	r18, 0x07	; 7
    9a16:	8e 32       	cpi	r24, 0x2E	; 46
    9a18:	92 07       	cpc	r25, r18
    9a1a:	39 f4       	brne	.+14     	; 0x9a2a <EMeter_RX+0x10e>
					{
						EMeter_RxStr_Offset=EMeter_RxStr;
    9a1c:	90 93 fb 05 	sts	0x05FB, r25
    9a20:	80 93 fa 05 	sts	0x05FA, r24
						EM_HalfBufferStart=&EMeter_RxStr[EM_RX_SIZE/2];
    9a24:	8d ea       	ldi	r24, 0xAD	; 173
    9a26:	97 e0       	ldi	r25, 0x07	; 7
    9a28:	0a c0       	rjmp	.+20     	; 0x9a3e <EMeter_RX+0x122>
										
					}else if(EM_HalfBufferStart==&EMeter_RxStr[EM_RX_SIZE/2])
    9a2a:	27 e0       	ldi	r18, 0x07	; 7
    9a2c:	8d 3a       	cpi	r24, 0xAD	; 173
    9a2e:	92 07       	cpc	r25, r18
    9a30:	51 f4       	brne	.+20     	; 0x9a46 <EMeter_RX+0x12a>
					{	
													
						EMeter_RxStr_Offset=&EMeter_RxStr[EM_RX_SIZE/2];
    9a32:	90 93 fb 05 	sts	0x05FB, r25
    9a36:	80 93 fa 05 	sts	0x05FA, r24
						EM_HalfBufferStart=EMeter_RxStr;						
    9a3a:	8e e2       	ldi	r24, 0x2E	; 46
    9a3c:	97 e0       	ldi	r25, 0x07	; 7
    9a3e:	90 93 6c 09 	sts	0x096C, r25
    9a42:	80 93 6b 09 	sts	0x096B, r24
					}
					EM_BufferReadEnable=1;
    9a46:	81 e0       	ldi	r24, 0x01	; 1
    9a48:	80 93 36 09 	sts	0x0936, r24
    9a4c:	08 95       	ret
					EMeter_RxCharN++;	

					}
			}					
			else{
				if(EMeter_RxCharN < (EM_RX_SIZE-1) )EMeter_RxCharN++;//      - 
    9a4e:	80 91 21 0d 	lds	r24, 0x0D21
    9a52:	90 91 22 0d 	lds	r25, 0x0D22
    9a56:	8d 3f       	cpi	r24, 0xFD	; 253
    9a58:	91 05       	cpc	r25, r1
    9a5a:	48 f4       	brcc	.+18     	; 0x9a6e <EMeter_RX+0x152>
    9a5c:	80 91 21 0d 	lds	r24, 0x0D21
    9a60:	90 91 22 0d 	lds	r25, 0x0D22
    9a64:	01 96       	adiw	r24, 0x01	; 1
    9a66:	90 93 22 0d 	sts	0x0D22, r25
    9a6a:	80 93 21 0d 	sts	0x0D21, r24
    9a6e:	08 95       	ret

00009a70 <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    9a70:	1f 92       	push	r1
    9a72:	0f 92       	push	r0
    9a74:	0f b6       	in	r0, 0x3f	; 63
    9a76:	0f 92       	push	r0
    9a78:	11 24       	eor	r1, r1
    9a7a:	0b b6       	in	r0, 0x3b	; 59
    9a7c:	0f 92       	push	r0
    9a7e:	2f 93       	push	r18
    9a80:	3f 93       	push	r19
    9a82:	4f 93       	push	r20
    9a84:	5f 93       	push	r21
    9a86:	6f 93       	push	r22
    9a88:	7f 93       	push	r23
    9a8a:	8f 93       	push	r24
    9a8c:	9f 93       	push	r25
    9a8e:	af 93       	push	r26
    9a90:	bf 93       	push	r27
    9a92:	ef 93       	push	r30
    9a94:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    9a96:	80 91 d8 03 	lds	r24, 0x03D8
    9a9a:	88 23       	and	r24, r24
    9a9c:	29 f0       	breq	.+10     	; 0x9aa8 <__vector_30+0x38>
    9a9e:	8c e9       	ldi	r24, 0x9C	; 156
    9aa0:	90 e0       	ldi	r25, 0x00	; 0
    9aa2:	0e 94 55 30 	call	0x60aa	; 0x60aa <Modbus_RX>
    9aa6:	02 c0       	rjmp	.+4      	; 0x9aac <__vector_30+0x3c>
	else EMeter_RX();
    9aa8:	0e 94 8e 4c 	call	0x991c	; 0x991c <EMeter_RX>
	COMM_LED = 1;
    9aac:	81 e0       	ldi	r24, 0x01	; 1
    9aae:	80 93 02 06 	sts	0x0602, r24
}	
    9ab2:	ff 91       	pop	r31
    9ab4:	ef 91       	pop	r30
    9ab6:	bf 91       	pop	r27
    9ab8:	af 91       	pop	r26
    9aba:	9f 91       	pop	r25
    9abc:	8f 91       	pop	r24
    9abe:	7f 91       	pop	r23
    9ac0:	6f 91       	pop	r22
    9ac2:	5f 91       	pop	r21
    9ac4:	4f 91       	pop	r20
    9ac6:	3f 91       	pop	r19
    9ac8:	2f 91       	pop	r18
    9aca:	0f 90       	pop	r0
    9acc:	0b be       	out	0x3b, r0	; 59
    9ace:	0f 90       	pop	r0
    9ad0:	0f be       	out	0x3f, r0	; 63
    9ad2:	0f 90       	pop	r0
    9ad4:	1f 90       	pop	r1
    9ad6:	18 95       	reti

00009ad8 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    9ad8:	80 91 5a 0a 	lds	r24, 0x0A5A
    9adc:	88 23       	and	r24, r24
    9ade:	21 f0       	breq	.+8      	; 0x9ae8 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9ae0:	88 e9       	ldi	r24, 0x98	; 152
    9ae2:	80 93 9a 00 	sts	0x009A, r24
    9ae6:	05 c0       	rjmp	.+10     	; 0x9af2 <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9ae8:	88 e9       	ldi	r24, 0x98	; 152
    9aea:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    9aee:	10 92 3e 09 	sts	0x093E, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    9af2:	94 98       	cbi	0x12, 4	; 18
    9af4:	08 95       	ret

00009af6 <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    9af6:	1f 92       	push	r1
    9af8:	0f 92       	push	r0
    9afa:	0f b6       	in	r0, 0x3f	; 63
    9afc:	0f 92       	push	r0
    9afe:	11 24       	eor	r1, r1
    9b00:	0b b6       	in	r0, 0x3b	; 59
    9b02:	0f 92       	push	r0
    9b04:	2f 93       	push	r18
    9b06:	3f 93       	push	r19
    9b08:	4f 93       	push	r20
    9b0a:	5f 93       	push	r21
    9b0c:	6f 93       	push	r22
    9b0e:	7f 93       	push	r23
    9b10:	8f 93       	push	r24
    9b12:	9f 93       	push	r25
    9b14:	af 93       	push	r26
    9b16:	bf 93       	push	r27
    9b18:	ef 93       	push	r30
    9b1a:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    9b1c:	80 91 d8 03 	lds	r24, 0x03D8
    9b20:	88 23       	and	r24, r24
    9b22:	29 f0       	breq	.+10     	; 0x9b2e <__vector_32+0x38>
    9b24:	8c e9       	ldi	r24, 0x9C	; 156
    9b26:	90 e0       	ldi	r25, 0x00	; 0
    9b28:	0e 94 cb 38 	call	0x7196	; 0x7196 <Modbus_TX>
    9b2c:	02 c0       	rjmp	.+4      	; 0x9b32 <__vector_32+0x3c>
	else EMeter_TX();
    9b2e:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <EMeter_TX>
	COMM_LED = 1;
    9b32:	81 e0       	ldi	r24, 0x01	; 1
    9b34:	80 93 02 06 	sts	0x0602, r24
}
    9b38:	ff 91       	pop	r31
    9b3a:	ef 91       	pop	r30
    9b3c:	bf 91       	pop	r27
    9b3e:	af 91       	pop	r26
    9b40:	9f 91       	pop	r25
    9b42:	8f 91       	pop	r24
    9b44:	7f 91       	pop	r23
    9b46:	6f 91       	pop	r22
    9b48:	5f 91       	pop	r21
    9b4a:	4f 91       	pop	r20
    9b4c:	3f 91       	pop	r19
    9b4e:	2f 91       	pop	r18
    9b50:	0f 90       	pop	r0
    9b52:	0b be       	out	0x3b, r0	; 59
    9b54:	0f 90       	pop	r0
    9b56:	0f be       	out	0x3f, r0	; 63
    9b58:	0f 90       	pop	r0
    9b5a:	1f 90       	pop	r1
    9b5c:	18 95       	reti

00009b5e <EMeter_SendFirstChar>:

}

// ~~~~~~~~~
void EMeter_SendFirstChar(void){
	cli();
    9b5e:	f8 94       	cli
	EMeter_TxFlag = 1;
    9b60:	81 e0       	ldi	r24, 0x01	; 1
    9b62:	80 93 3e 09 	sts	0x093E, r24
	UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TXC_EMETER -  pending interrupt	
    9b66:	eb e9       	ldi	r30, 0x9B	; 155
    9b68:	f0 e0       	ldi	r31, 0x00	; 0
    9b6a:	80 81       	ld	r24, Z
    9b6c:	80 64       	ori	r24, 0x40	; 64
    9b6e:	80 83       	st	Z, r24
	PORTD |= (1<<PD4);	// Tx on
    9b70:	94 9a       	sbi	0x12, 4	; 18
	UDR_EMETER = EMeter_TxStr[0];
    9b72:	80 91 dd 0a 	lds	r24, 0x0ADD
    9b76:	80 93 9c 00 	sts	0x009C, r24
	sei();
    9b7a:	78 94       	sei

	EMeter_TxCharN = 1;
    9b7c:	81 e0       	ldi	r24, 0x01	; 1
    9b7e:	80 93 37 09 	sts	0x0937, r24

	cli();
    9b82:	f8 94       	cli
	UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9b84:	88 eb       	ldi	r24, 0xB8	; 184
    9b86:	80 93 9a 00 	sts	0x009A, r24

	EMeter_RxCharN = 0;	//  
    9b8a:	10 92 22 0d 	sts	0x0D22, r1
    9b8e:	10 92 21 0d 	sts	0x0D21, r1
	sei();	
    9b92:	78 94       	sei
    9b94:	08 95       	ret

00009b96 <EMeter_SendCR>:
}
// ~~~~~~~~~
//   + CR
void EMeter_SendCR(prog_char *Str_P){
    9b96:	cf 93       	push	r28
    9b98:	df 93       	push	r29
    9b9a:	ec 01       	movw	r28, r24


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    9b9c:	0e 94 c9 77 	call	0xef92	; 0xef92 <__strlen_P>
	EMeter_TxSz = strlen_P(Str_P);
    9ba0:	80 93 29 0d 	sts	0x0D29, r24
	sprintf_P(EMeter_TxStr, Str_P);
    9ba4:	df 93       	push	r29
    9ba6:	cf 93       	push	r28
    9ba8:	8d ed       	ldi	r24, 0xDD	; 221
    9baa:	9a e0       	ldi	r25, 0x0A	; 10
    9bac:	9f 93       	push	r25
    9bae:	8f 93       	push	r24
    9bb0:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
	sprintf_P(EMeter_TxStr + EMeter_TxSz, PSTR("\r\n"));
    9bb4:	80 91 29 0d 	lds	r24, 0x0D29
    9bb8:	28 e1       	ldi	r18, 0x18	; 24
    9bba:	33 e0       	ldi	r19, 0x03	; 3
    9bbc:	3f 93       	push	r19
    9bbe:	2f 93       	push	r18
    9bc0:	90 e0       	ldi	r25, 0x00	; 0
    9bc2:	83 52       	subi	r24, 0x23	; 35
    9bc4:	95 4f       	sbci	r25, 0xF5	; 245
    9bc6:	9f 93       	push	r25
    9bc8:	8f 93       	push	r24
    9bca:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
	EMeter_TxSz +=2;
    9bce:	80 91 29 0d 	lds	r24, 0x0D29
    9bd2:	8e 5f       	subi	r24, 0xFE	; 254
    9bd4:	80 93 29 0d 	sts	0x0D29, r24
	EMeter_SendFirstChar();
    9bd8:	8d b7       	in	r24, 0x3d	; 61
    9bda:	9e b7       	in	r25, 0x3e	; 62
    9bdc:	08 96       	adiw	r24, 0x08	; 8
    9bde:	0f b6       	in	r0, 0x3f	; 63
    9be0:	f8 94       	cli
    9be2:	9e bf       	out	0x3e, r25	; 62
    9be4:	0f be       	out	0x3f, r0	; 63
    9be6:	8d bf       	out	0x3d, r24	; 61
}
    9be8:	df 91       	pop	r29
    9bea:	cf 91       	pop	r28
void EMeter_SendCR(prog_char *Str_P){
	EMeter_TxSz = strlen_P(Str_P);
	sprintf_P(EMeter_TxStr, Str_P);
	sprintf_P(EMeter_TxStr + EMeter_TxSz, PSTR("\r\n"));
	EMeter_TxSz +=2;
	EMeter_SendFirstChar();
    9bec:	0c 94 af 4d 	jmp	0x9b5e	; 0x9b5e <EMeter_SendFirstChar>

00009bf0 <EMeter_SendData_P>:
}
// ~~~~~~~~~
void EMeter_SendData_P(prog_uint8_t *Data_Out_P, uint8_t Size){
	EMeter_TxSz = Size;
    9bf0:	60 93 29 0d 	sts	0x0D29, r22
	memcpy_P(EMeter_TxStr, Data_Out_P, Size);
    9bf4:	46 2f       	mov	r20, r22
    9bf6:	50 e0       	ldi	r21, 0x00	; 0
    9bf8:	bc 01       	movw	r22, r24
    9bfa:	8d ed       	ldi	r24, 0xDD	; 221
    9bfc:	9a e0       	ldi	r25, 0x0A	; 10
    9bfe:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
	EMeter_SendFirstChar();
    9c02:	0c 94 af 4d 	jmp	0x9b5e	; 0x9b5e <EMeter_SendFirstChar>

00009c06 <EMeter_ClearRXStr>:
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
    9c06:	ee e2       	ldi	r30, 0x2E	; 46
    9c08:	f7 e0       	ldi	r31, 0x07	; 7
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    9c0a:	11 92       	st	Z+, r1
    9c0c:	88 e0       	ldi	r24, 0x08	; 8
    9c0e:	ec 32       	cpi	r30, 0x2C	; 44
    9c10:	f8 07       	cpc	r31, r24
    9c12:	d9 f7       	brne	.-10     	; 0x9c0a <EMeter_ClearRXStr+0x4>
	EMeter_RxCharN = 0;
    9c14:	10 92 22 0d 	sts	0x0D22, r1
    9c18:	10 92 21 0d 	sts	0x0D21, r1
    9c1c:	08 95       	ret

00009c1e <EMeter_Link>:

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    9c1e:	81 e0       	ldi	r24, 0x01	; 1
    9c20:	90 91 05 01 	lds	r25, 0x0105
    9c24:	91 11       	cpse	r25, r1
    9c26:	80 e0       	ldi	r24, 0x00	; 0
	else return 1;
}
    9c28:	08 95       	ret

00009c2a <EMeter_NoLink>:

void EMeter_NoLink(void){
//	if(EM_Retry>10){
	if(EM_Retry>=1){
    9c2a:	80 91 05 01 	lds	r24, 0x0105
    9c2e:	88 23       	and	r24, r24
    9c30:	e9 f1       	breq	.+122    	; 0x9cac <EMeter_NoLink+0x82>
		E_Meter_RAM.Ap = 0;
    9c32:	10 92 3e 02 	sts	0x023E, r1
    9c36:	10 92 3f 02 	sts	0x023F, r1
    9c3a:	10 92 40 02 	sts	0x0240, r1
    9c3e:	10 92 41 02 	sts	0x0241, r1
		E_Meter_RAM.Am = 0;
    9c42:	10 92 42 02 	sts	0x0242, r1
    9c46:	10 92 43 02 	sts	0x0243, r1
    9c4a:	10 92 44 02 	sts	0x0244, r1
    9c4e:	10 92 45 02 	sts	0x0245, r1
		E_Meter_RAM.Rp = 0;
    9c52:	10 92 46 02 	sts	0x0246, r1
    9c56:	10 92 47 02 	sts	0x0247, r1
    9c5a:	10 92 48 02 	sts	0x0248, r1
    9c5e:	10 92 49 02 	sts	0x0249, r1
		E_Meter_RAM.Rm = 0;
    9c62:	10 92 4a 02 	sts	0x024A, r1
    9c66:	10 92 4b 02 	sts	0x024B, r1
    9c6a:	10 92 4c 02 	sts	0x024C, r1
    9c6e:	10 92 4d 02 	sts	0x024D, r1
		Ua = 0;
    9c72:	10 92 24 0d 	sts	0x0D24, r1
    9c76:	10 92 23 0d 	sts	0x0D23, r1
		Ub = 0;
    9c7a:	10 92 dd 03 	sts	0x03DD, r1
    9c7e:	10 92 dc 03 	sts	0x03DC, r1
		Uc = 0;
    9c82:	10 92 58 0a 	sts	0x0A58, r1
    9c86:	10 92 57 0a 	sts	0x0A57, r1
		Ia = 0;
    9c8a:	10 92 eb 03 	sts	0x03EB, r1
    9c8e:	10 92 ea 03 	sts	0x03EA, r1
		Ib = 0;
    9c92:	10 92 2e 09 	sts	0x092E, r1
    9c96:	10 92 2d 09 	sts	0x092D, r1
		Ic = 0;
    9c9a:	10 92 66 09 	sts	0x0966, r1
    9c9e:	10 92 65 09 	sts	0x0965, r1
		EM_PowerActive = 0;
    9ca2:	10 92 54 0a 	sts	0x0A54, r1
    9ca6:	10 92 53 0a 	sts	0x0A53, r1
    9caa:	03 c0       	rjmp	.+6      	; 0x9cb2 <EMeter_NoLink+0x88>
	}
	else EM_Retry++;
    9cac:	81 e0       	ldi	r24, 0x01	; 1
    9cae:	80 93 05 01 	sts	0x0105, r24

	//StartTimer16(TD_EMeter,1000);
	EM_Mode = 255;
    9cb2:	8f ef       	ldi	r24, 0xFF	; 255
    9cb4:	80 93 55 0a 	sts	0x0A55, r24
    9cb8:	08 95       	ret

00009cba <EMeter_ELVIN_Modem_NoLink>:
}
// ~~~~~~~~~
void EMeter_ELVIN_Modem_NoLink(void){
	E_Meter_RAM.Ap = 0;
    9cba:	10 92 3e 02 	sts	0x023E, r1
    9cbe:	10 92 3f 02 	sts	0x023F, r1
    9cc2:	10 92 40 02 	sts	0x0240, r1
    9cc6:	10 92 41 02 	sts	0x0241, r1
	E_Meter_RAM.Am = 0;
    9cca:	10 92 42 02 	sts	0x0242, r1
    9cce:	10 92 43 02 	sts	0x0243, r1
    9cd2:	10 92 44 02 	sts	0x0244, r1
    9cd6:	10 92 45 02 	sts	0x0245, r1
	E_Meter_RAM.Rp = 0;
    9cda:	10 92 46 02 	sts	0x0246, r1
    9cde:	10 92 47 02 	sts	0x0247, r1
    9ce2:	10 92 48 02 	sts	0x0248, r1
    9ce6:	10 92 49 02 	sts	0x0249, r1
	E_Meter_RAM.Rm = 0;
    9cea:	10 92 4a 02 	sts	0x024A, r1
    9cee:	10 92 4b 02 	sts	0x024B, r1
    9cf2:	10 92 4c 02 	sts	0x024C, r1
    9cf6:	10 92 4d 02 	sts	0x024D, r1
    9cfa:	08 95       	ret

00009cfc <EMeter_M230_Data_Convert>:
}
// ~~~~~~~~~
uint32_t EMeter_M230_Data_Convert(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[3] = EMeter_RxStr[Start+1];
    9cfc:	fc 01       	movw	r30, r24
    9cfe:	e2 5d       	subi	r30, 0xD2	; 210
    9d00:	f8 4f       	sbci	r31, 0xF8	; 248
	TempArray[2] = EMeter_RxStr[Start+0];
	TempArray[1] = EMeter_RxStr[Start+3];
	TempArray[0] = EMeter_RxStr[Start+2];
	if(*(uint32_t*)TempArray == 0xFFFFFFFF) return 0;
    9d02:	42 81       	ldd	r20, Z+2	; 0x02
    9d04:	53 81       	ldd	r21, Z+3	; 0x03
    9d06:	60 81       	ld	r22, Z
    9d08:	71 81       	ldd	r23, Z+1	; 0x01
    9d0a:	4f 3f       	cpi	r20, 0xFF	; 255
    9d0c:	8f ef       	ldi	r24, 0xFF	; 255
    9d0e:	58 07       	cpc	r21, r24
    9d10:	68 07       	cpc	r22, r24
    9d12:	78 07       	cpc	r23, r24
    9d14:	29 f4       	brne	.+10     	; 0x9d20 <EMeter_M230_Data_Convert+0x24>
    9d16:	30 e0       	ldi	r19, 0x00	; 0
    9d18:	20 e0       	ldi	r18, 0x00	; 0
    9d1a:	80 e0       	ldi	r24, 0x00	; 0
    9d1c:	90 e0       	ldi	r25, 0x00	; 0
    9d1e:	03 c0       	rjmp	.+6      	; 0x9d26 <EMeter_M230_Data_Convert+0x2a>
    9d20:	34 2f       	mov	r19, r20
    9d22:	25 2f       	mov	r18, r21
    9d24:	cb 01       	movw	r24, r22
	else return *(uint32_t*)TempArray;
}
    9d26:	63 2f       	mov	r22, r19
    9d28:	72 2f       	mov	r23, r18
    9d2a:	08 95       	ret

00009d2c <EMeter_M230_Data_ConvertWord>:
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    9d2c:	fc 01       	movw	r30, r24
    9d2e:	e2 5d       	subi	r30, 0xD2	; 210
    9d30:	f8 4f       	sbci	r31, 0xF8	; 248
	TempArray[1] = EMeter_RxStr[Start+1];
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    9d32:	20 81       	ld	r18, Z
    9d34:	31 81       	ldd	r19, Z+1	; 0x01
    9d36:	2f 3f       	cpi	r18, 0xFF	; 255
    9d38:	8f ef       	ldi	r24, 0xFF	; 255
    9d3a:	38 07       	cpc	r19, r24
    9d3c:	19 f4       	brne	.+6      	; 0x9d44 <EMeter_M230_Data_ConvertWord+0x18>
    9d3e:	80 e0       	ldi	r24, 0x00	; 0
    9d40:	90 e0       	ldi	r25, 0x00	; 0
    9d42:	08 95       	ret
    9d44:	c9 01       	movw	r24, r18
	else return *(uint16_t*)TempArray;
}
    9d46:	08 95       	ret

00009d48 <EMeter_M230_Data_ConvertP>:
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertP(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[3] = 0;
    9d48:	70 e0       	ldi	r23, 0x00	; 0
	TempArray[2] = EMeter_RxStr[Start];
    9d4a:	fc 01       	movw	r30, r24
    9d4c:	e2 5d       	subi	r30, 0xD2	; 210
    9d4e:	f8 4f       	sbci	r31, 0xF8	; 248
    9d50:	60 81       	ld	r22, Z
	TempArray[1] = EMeter_RxStr[Start+2];
    9d52:	52 81       	ldd	r21, Z+2	; 0x02
	TempArray[0] = EMeter_RxStr[Start+1];
    9d54:	41 81       	ldd	r20, Z+1	; 0x01
	return (uint16_t)(((*(uint32_t*)TempArray)&0x3FFFFF)/1000);
    9d56:	cb 01       	movw	r24, r22
    9d58:	ba 01       	movw	r22, r20
    9d5a:	8f 73       	andi	r24, 0x3F	; 63
    9d5c:	99 27       	eor	r25, r25
    9d5e:	28 ee       	ldi	r18, 0xE8	; 232
    9d60:	33 e0       	ldi	r19, 0x03	; 3
    9d62:	40 e0       	ldi	r20, 0x00	; 0
    9d64:	50 e0       	ldi	r21, 0x00	; 0
    9d66:	0e 94 ab 80 	call	0x10156	; 0x10156 <__udivmodsi4>
}
    9d6a:	c9 01       	movw	r24, r18
    9d6c:	08 95       	ret

00009d6e <EMeter_ZMR110_Data_ConvertQ>:

uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
}

uint32_t EMeter_ZMR110_Data_ConvertQ(prog_char *Str_P, uint8_t FlagNum){
    9d6e:	df 92       	push	r13
    9d70:	ef 92       	push	r14
    9d72:	ff 92       	push	r15
    9d74:	0f 93       	push	r16
    9d76:	1f 93       	push	r17
    9d78:	cf 93       	push	r28
    9d7a:	df 93       	push	r29
    9d7c:	00 d0       	rcall	.+0      	; 0x9d7e <EMeter_ZMR110_Data_ConvertQ+0x10>
    9d7e:	00 d0       	rcall	.+0      	; 0x9d80 <EMeter_ZMR110_Data_ConvertQ+0x12>
    9d80:	cd b7       	in	r28, 0x3d	; 61
    9d82:	de b7       	in	r29, 0x3e	; 62
    9d84:	d6 2e       	mov	r13, r22
	uint32_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    9d86:	00 91 fa 05 	lds	r16, 0x05FA
    9d8a:	10 91 fb 05 	lds	r17, 0x05FB
    9d8e:	bc 01       	movw	r22, r24
    9d90:	c8 01       	movw	r24, r16
    9d92:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    9d96:	00 97       	sbiw	r24, 0x00	; 0
    9d98:	09 f4       	brne	.+2      	; 0x9d9c <EMeter_ZMR110_Data_ConvertQ+0x2e>
    9d9a:	91 c0       	rjmp	.+290    	; 0x9ebe <EMeter_ZMR110_Data_ConvertQ+0x150>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    9d9c:	9c 01       	movw	r18, r24
    9d9e:	20 1b       	sub	r18, r16
    9da0:	31 0b       	sbc	r19, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    9da2:	2d 3f       	cpi	r18, 0xFD	; 253
    9da4:	31 05       	cpc	r19, r1
    9da6:	08 f0       	brcs	.+2      	; 0x9daa <EMeter_ZMR110_Data_ConvertQ+0x3c>
    9da8:	8a c0       	rjmp	.+276    	; 0x9ebe <EMeter_ZMR110_Data_ConvertQ+0x150>
			EMeter_RxStr_Offset[Start+12]=	EMeter_RxStr_Offset[Start+13];	//  
    9daa:	79 01       	movw	r14, r18
    9dac:	8d e0       	ldi	r24, 0x0D	; 13
    9dae:	e8 0e       	add	r14, r24
    9db0:	f1 1c       	adc	r15, r1
    9db2:	f8 01       	movw	r30, r16
    9db4:	ee 0d       	add	r30, r14
    9db6:	ff 1d       	adc	r31, r15
    9db8:	80 81       	ld	r24, Z
    9dba:	f8 01       	movw	r30, r16
    9dbc:	e2 0f       	add	r30, r18
    9dbe:	f3 1f       	adc	r31, r19
    9dc0:	84 87       	std	Z+12, r24	; 0x0c
			EMeter_RxStr_Offset[Start+13]=	EMeter_RxStr_Offset[Start+14];
    9dc2:	80 91 fa 05 	lds	r24, 0x05FA
    9dc6:	90 91 fb 05 	lds	r25, 0x05FB
    9dca:	89 01       	movw	r16, r18
    9dcc:	02 5f       	subi	r16, 0xF2	; 242
    9dce:	1f 4f       	sbci	r17, 0xFF	; 255
    9dd0:	fc 01       	movw	r30, r24
    9dd2:	e0 0f       	add	r30, r16
    9dd4:	f1 1f       	adc	r31, r17
    9dd6:	40 81       	ld	r20, Z
    9dd8:	fc 01       	movw	r30, r24
    9dda:	ee 0d       	add	r30, r14
    9ddc:	ff 1d       	adc	r31, r15
    9dde:	40 83       	st	Z, r20
			EMeter_RxStr_Offset[Start+14]=	EMeter_RxStr_Offset[Start+15];
    9de0:	40 91 fa 05 	lds	r20, 0x05FA
    9de4:	50 91 fb 05 	lds	r21, 0x05FB
    9de8:	c9 01       	movw	r24, r18
    9dea:	0f 96       	adiw	r24, 0x0f	; 15
    9dec:	fa 01       	movw	r30, r20
    9dee:	e8 0f       	add	r30, r24
    9df0:	f9 1f       	adc	r31, r25
    9df2:	60 81       	ld	r22, Z
    9df4:	fa 01       	movw	r30, r20
    9df6:	e0 0f       	add	r30, r16
    9df8:	f1 1f       	adc	r31, r17
    9dfa:	60 83       	st	Z, r22
			EMeter_RxStr_Offset[Start+15]= ' ';
    9dfc:	e0 91 fa 05 	lds	r30, 0x05FA
    9e00:	f0 91 fb 05 	lds	r31, 0x05FB
    9e04:	e8 0f       	add	r30, r24
    9e06:	f9 1f       	adc	r31, r25
    9e08:	80 e2       	ldi	r24, 0x20	; 32
    9e0a:	80 83       	st	Z, r24
			sscanf(EMeter_RxStr_Offset+Start+6,"%ld",&Result);
    9e0c:	ce 01       	movw	r24, r28
    9e0e:	01 96       	adiw	r24, 0x01	; 1
    9e10:	9f 93       	push	r25
    9e12:	8f 93       	push	r24
    9e14:	83 ea       	ldi	r24, 0xA3	; 163
    9e16:	91 e0       	ldi	r25, 0x01	; 1
    9e18:	9f 93       	push	r25
    9e1a:	8f 93       	push	r24
    9e1c:	2a 5f       	subi	r18, 0xFA	; 250
    9e1e:	3f 4f       	sbci	r19, 0xFF	; 255
    9e20:	80 91 fa 05 	lds	r24, 0x05FA
    9e24:	90 91 fb 05 	lds	r25, 0x05FB
    9e28:	82 0f       	add	r24, r18
    9e2a:	93 1f       	adc	r25, r19
    9e2c:	9f 93       	push	r25
    9e2e:	8f 93       	push	r24
    9e30:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    9e34:	ed 2d       	mov	r30, r13
    9e36:	e6 95       	lsr	r30
    9e38:	e6 95       	lsr	r30
    9e3a:	e6 95       	lsr	r30
    9e3c:	f0 e0       	ldi	r31, 0x00	; 0
    9e3e:	ec 50       	subi	r30, 0x0C	; 12
    9e40:	fa 4f       	sbci	r31, 0xFA	; 250
    9e42:	2d 2d       	mov	r18, r13
    9e44:	27 70       	andi	r18, 0x07	; 7
    9e46:	81 e0       	ldi	r24, 0x01	; 1
    9e48:	90 e0       	ldi	r25, 0x00	; 0
    9e4a:	02 2e       	mov	r0, r18
    9e4c:	01 c0       	rjmp	.+2      	; 0x9e50 <EMeter_ZMR110_Data_ConvertQ+0xe2>
    9e4e:	88 0f       	add	r24, r24
    9e50:	0a 94       	dec	r0
    9e52:	ea f7       	brpl	.-6      	; 0x9e4e <EMeter_ZMR110_Data_ConvertQ+0xe0>
    9e54:	90 81       	ld	r25, Z
    9e56:	98 2b       	or	r25, r24
    9e58:	90 83       	st	Z, r25
			if(EMeter_RxStr_Offset[Start+13]=='*') Result *=100;
    9e5a:	e0 91 fa 05 	lds	r30, 0x05FA
    9e5e:	f0 91 fb 05 	lds	r31, 0x05FB
    9e62:	df 01       	movw	r26, r30
    9e64:	ae 0d       	add	r26, r14
    9e66:	bf 1d       	adc	r27, r15
    9e68:	0f 90       	pop	r0
    9e6a:	0f 90       	pop	r0
    9e6c:	0f 90       	pop	r0
    9e6e:	0f 90       	pop	r0
    9e70:	0f 90       	pop	r0
    9e72:	0f 90       	pop	r0
    9e74:	8c 91       	ld	r24, X
    9e76:	8a 32       	cpi	r24, 0x2A	; 42
    9e78:	61 f4       	brne	.+24     	; 0x9e92 <EMeter_ZMR110_Data_ConvertQ+0x124>
    9e7a:	29 81       	ldd	r18, Y+1	; 0x01
    9e7c:	3a 81       	ldd	r19, Y+2	; 0x02
    9e7e:	4b 81       	ldd	r20, Y+3	; 0x03
    9e80:	5c 81       	ldd	r21, Y+4	; 0x04
    9e82:	a4 e6       	ldi	r26, 0x64	; 100
    9e84:	b0 e0       	ldi	r27, 0x00	; 0
    9e86:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    9e8a:	69 83       	std	Y+1, r22	; 0x01
    9e8c:	7a 83       	std	Y+2, r23	; 0x02
    9e8e:	8b 83       	std	Y+3, r24	; 0x03
    9e90:	9c 83       	std	Y+4, r25	; 0x04
			if(EMeter_RxStr_Offset[Start+14]=='*') Result *=10;
    9e92:	e0 0f       	add	r30, r16
    9e94:	f1 1f       	adc	r31, r17
    9e96:	80 81       	ld	r24, Z
    9e98:	8a 32       	cpi	r24, 0x2A	; 42
    9e9a:	61 f4       	brne	.+24     	; 0x9eb4 <EMeter_ZMR110_Data_ConvertQ+0x146>
    9e9c:	29 81       	ldd	r18, Y+1	; 0x01
    9e9e:	3a 81       	ldd	r19, Y+2	; 0x02
    9ea0:	4b 81       	ldd	r20, Y+3	; 0x03
    9ea2:	5c 81       	ldd	r21, Y+4	; 0x04
    9ea4:	aa e0       	ldi	r26, 0x0A	; 10
    9ea6:	b0 e0       	ldi	r27, 0x00	; 0
    9ea8:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    9eac:	69 83       	std	Y+1, r22	; 0x01
    9eae:	7a 83       	std	Y+2, r23	; 0x02
    9eb0:	8b 83       	std	Y+3, r24	; 0x03
    9eb2:	9c 83       	std	Y+4, r25	; 0x04
			return Result;
    9eb4:	69 81       	ldd	r22, Y+1	; 0x01
    9eb6:	7a 81       	ldd	r23, Y+2	; 0x02
    9eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    9eba:	9c 81       	ldd	r25, Y+4	; 0x04
    9ebc:	03 c0       	rjmp	.+6      	; 0x9ec4 <EMeter_ZMR110_Data_ConvertQ+0x156>
		}
	}	
	return 0;
    9ebe:	60 e0       	ldi	r22, 0x00	; 0
    9ec0:	70 e0       	ldi	r23, 0x00	; 0
    9ec2:	cb 01       	movw	r24, r22
}
    9ec4:	0f 90       	pop	r0
    9ec6:	0f 90       	pop	r0
    9ec8:	0f 90       	pop	r0
    9eca:	0f 90       	pop	r0
    9ecc:	df 91       	pop	r29
    9ece:	cf 91       	pop	r28
    9ed0:	1f 91       	pop	r17
    9ed2:	0f 91       	pop	r16
    9ed4:	ff 90       	pop	r15
    9ed6:	ef 90       	pop	r14
    9ed8:	df 90       	pop	r13
    9eda:	08 95       	ret

00009edc <EMeter_ZMR110_Read_Word>:
// ~~~~~~~~~
uint16_t EMeter_ZMR110_Read_Word(prog_char *Str_P, uint8_t FlagNum){
    9edc:	bf 92       	push	r11
    9ede:	cf 92       	push	r12
    9ee0:	df 92       	push	r13
    9ee2:	ef 92       	push	r14
    9ee4:	ff 92       	push	r15
    9ee6:	0f 93       	push	r16
    9ee8:	1f 93       	push	r17
    9eea:	cf 93       	push	r28
    9eec:	df 93       	push	r29
    9eee:	00 d0       	rcall	.+0      	; 0x9ef0 <EMeter_ZMR110_Read_Word+0x14>
    9ef0:	cd b7       	in	r28, 0x3d	; 61
    9ef2:	de b7       	in	r29, 0x3e	; 62
    9ef4:	7c 01       	movw	r14, r24
    9ef6:	b6 2e       	mov	r11, r22
	uint16_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    9ef8:	00 91 fa 05 	lds	r16, 0x05FA
    9efc:	10 91 fb 05 	lds	r17, 0x05FB
    9f00:	bc 01       	movw	r22, r24
    9f02:	c8 01       	movw	r24, r16
    9f04:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    9f08:	00 97       	sbiw	r24, 0x00	; 0
    9f0a:	c9 f1       	breq	.+114    	; 0x9f7e <EMeter_ZMR110_Read_Word+0xa2>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    9f0c:	6c 01       	movw	r12, r24
    9f0e:	c0 1a       	sub	r12, r16
    9f10:	d1 0a       	sbc	r13, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    9f12:	8d ef       	ldi	r24, 0xFD	; 253
    9f14:	c8 16       	cp	r12, r24
    9f16:	d1 04       	cpc	r13, r1
    9f18:	90 f5       	brcc	.+100    	; 0x9f7e <EMeter_ZMR110_Read_Word+0xa2>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    9f1a:	eb 2d       	mov	r30, r11
    9f1c:	e6 95       	lsr	r30
    9f1e:	e6 95       	lsr	r30
    9f20:	e6 95       	lsr	r30
    9f22:	f0 e0       	ldi	r31, 0x00	; 0
    9f24:	ec 50       	subi	r30, 0x0C	; 12
    9f26:	fa 4f       	sbci	r31, 0xFA	; 250
    9f28:	8b 2d       	mov	r24, r11
    9f2a:	87 70       	andi	r24, 0x07	; 7
    9f2c:	41 e0       	ldi	r20, 0x01	; 1
    9f2e:	50 e0       	ldi	r21, 0x00	; 0
    9f30:	01 c0       	rjmp	.+2      	; 0x9f34 <EMeter_ZMR110_Read_Word+0x58>
    9f32:	44 0f       	add	r20, r20
    9f34:	8a 95       	dec	r24
    9f36:	ea f7       	brpl	.-6      	; 0x9f32 <EMeter_ZMR110_Read_Word+0x56>
    9f38:	80 81       	ld	r24, Z
    9f3a:	84 2b       	or	r24, r20
    9f3c:	80 83       	st	Z, r24
    9f3e:	c7 01       	movw	r24, r14
    9f40:	0e 94 c9 77 	call	0xef92	; 0xef92 <__strlen_P>
			//sscanf(EMeter_RxStr_Offset+Start+7,"%u",&Result);
			sscanf(EMeter_RxStr_Offset+Start+strlen_P(Str_P)+1,"%u",&Result);							
    9f44:	9e 01       	movw	r18, r28
    9f46:	2f 5f       	subi	r18, 0xFF	; 255
    9f48:	3f 4f       	sbci	r19, 0xFF	; 255
    9f4a:	3f 93       	push	r19
    9f4c:	2f 93       	push	r18
    9f4e:	2a ea       	ldi	r18, 0xAA	; 170
    9f50:	31 e0       	ldi	r19, 0x01	; 1
    9f52:	3f 93       	push	r19
    9f54:	2f 93       	push	r18
    9f56:	96 01       	movw	r18, r12
    9f58:	2f 5f       	subi	r18, 0xFF	; 255
    9f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    9f5c:	28 0f       	add	r18, r24
    9f5e:	39 1f       	adc	r19, r25
    9f60:	20 0f       	add	r18, r16
    9f62:	31 1f       	adc	r19, r17
    9f64:	3f 93       	push	r19
    9f66:	2f 93       	push	r18
    9f68:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
			return Result;
    9f6c:	89 81       	ldd	r24, Y+1	; 0x01
    9f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    9f70:	0f 90       	pop	r0
    9f72:	0f 90       	pop	r0
    9f74:	0f 90       	pop	r0
    9f76:	0f 90       	pop	r0
    9f78:	0f 90       	pop	r0
    9f7a:	0f 90       	pop	r0
    9f7c:	02 c0       	rjmp	.+4      	; 0x9f82 <EMeter_ZMR110_Read_Word+0xa6>
		}
	}	
	return 0;
    9f7e:	80 e0       	ldi	r24, 0x00	; 0
    9f80:	90 e0       	ldi	r25, 0x00	; 0
}
    9f82:	0f 90       	pop	r0
    9f84:	0f 90       	pop	r0
    9f86:	df 91       	pop	r29
    9f88:	cf 91       	pop	r28
    9f8a:	1f 91       	pop	r17
    9f8c:	0f 91       	pop	r16
    9f8e:	ff 90       	pop	r15
    9f90:	ef 90       	pop	r14
    9f92:	df 90       	pop	r13
    9f94:	cf 90       	pop	r12
    9f96:	bf 90       	pop	r11
    9f98:	08 95       	ret

00009f9a <EMeter_ZMR110_Data_ConvertI>:
// ~~~~~~~~~
uint16_t EMeter_ZMR110_Data_ConvertI(prog_char *Str_P, uint8_t FlagNum){
    9f9a:	ff 92       	push	r15
    9f9c:	0f 93       	push	r16
    9f9e:	1f 93       	push	r17
    9fa0:	cf 93       	push	r28
    9fa2:	df 93       	push	r29
    9fa4:	00 d0       	rcall	.+0      	; 0x9fa6 <EMeter_ZMR110_Data_ConvertI+0xc>
    9fa6:	cd b7       	in	r28, 0x3d	; 61
    9fa8:	de b7       	in	r29, 0x3e	; 62
    9faa:	f6 2e       	mov	r15, r22
	uint16_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    9fac:	00 91 fa 05 	lds	r16, 0x05FA
    9fb0:	10 91 fb 05 	lds	r17, 0x05FB
    9fb4:	bc 01       	movw	r22, r24
    9fb6:	c8 01       	movw	r24, r16
    9fb8:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    9fbc:	00 97       	sbiw	r24, 0x00	; 0
    9fbe:	09 f4       	brne	.+2      	; 0x9fc2 <EMeter_ZMR110_Data_ConvertI+0x28>
    9fc0:	58 c0       	rjmp	.+176    	; 0xa072 <EMeter_ZMR110_Data_ConvertI+0xd8>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    9fc2:	9c 01       	movw	r18, r24
    9fc4:	20 1b       	sub	r18, r16
    9fc6:	31 0b       	sbc	r19, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    9fc8:	2d 3f       	cpi	r18, 0xFD	; 253
    9fca:	31 05       	cpc	r19, r1
    9fcc:	08 f0       	brcs	.+2      	; 0x9fd0 <EMeter_ZMR110_Data_ConvertI+0x36>
    9fce:	51 c0       	rjmp	.+162    	; 0xa072 <EMeter_ZMR110_Data_ConvertI+0xd8>
			EMeter_RxStr_Offset[Start+10]=	EMeter_RxStr_Offset[Start+11];	//  
    9fd0:	a9 01       	movw	r20, r18
    9fd2:	45 5f       	subi	r20, 0xF5	; 245
    9fd4:	5f 4f       	sbci	r21, 0xFF	; 255
    9fd6:	f8 01       	movw	r30, r16
    9fd8:	e4 0f       	add	r30, r20
    9fda:	f5 1f       	adc	r31, r21
    9fdc:	80 81       	ld	r24, Z
    9fde:	f8 01       	movw	r30, r16
    9fe0:	e2 0f       	add	r30, r18
    9fe2:	f3 1f       	adc	r31, r19
    9fe4:	82 87       	std	Z+10, r24	; 0x0a
			EMeter_RxStr_Offset[Start+11]=	EMeter_RxStr_Offset[Start+12];
    9fe6:	60 91 fa 05 	lds	r22, 0x05FA
    9fea:	70 91 fb 05 	lds	r23, 0x05FB
    9fee:	c9 01       	movw	r24, r18
    9ff0:	0c 96       	adiw	r24, 0x0c	; 12
    9ff2:	fb 01       	movw	r30, r22
    9ff4:	e8 0f       	add	r30, r24
    9ff6:	f9 1f       	adc	r31, r25
    9ff8:	e0 81       	ld	r30, Z
    9ffa:	db 01       	movw	r26, r22
    9ffc:	a4 0f       	add	r26, r20
    9ffe:	b5 1f       	adc	r27, r21
    a000:	ec 93       	st	X, r30
			EMeter_RxStr_Offset[Start+12]= ' ';
    a002:	e0 91 fa 05 	lds	r30, 0x05FA
    a006:	f0 91 fb 05 	lds	r31, 0x05FB
    a00a:	e8 0f       	add	r30, r24
    a00c:	f9 1f       	adc	r31, r25
    a00e:	80 e2       	ldi	r24, 0x20	; 32
    a010:	80 83       	st	Z, r24
			sscanf(EMeter_RxStr_Offset+Start+7,"%u",&Result);
    a012:	ce 01       	movw	r24, r28
    a014:	01 96       	adiw	r24, 0x01	; 1
    a016:	9f 93       	push	r25
    a018:	8f 93       	push	r24
    a01a:	8a ea       	ldi	r24, 0xAA	; 170
    a01c:	91 e0       	ldi	r25, 0x01	; 1
    a01e:	9f 93       	push	r25
    a020:	8f 93       	push	r24
    a022:	29 5f       	subi	r18, 0xF9	; 249
    a024:	3f 4f       	sbci	r19, 0xFF	; 255
    a026:	80 91 fa 05 	lds	r24, 0x05FA
    a02a:	90 91 fb 05 	lds	r25, 0x05FB
    a02e:	82 0f       	add	r24, r18
    a030:	93 1f       	adc	r25, r19
    a032:	9f 93       	push	r25
    a034:	8f 93       	push	r24
    a036:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    a03a:	ef 2d       	mov	r30, r15
    a03c:	e6 95       	lsr	r30
    a03e:	e6 95       	lsr	r30
    a040:	e6 95       	lsr	r30
    a042:	f0 e0       	ldi	r31, 0x00	; 0
    a044:	ec 50       	subi	r30, 0x0C	; 12
    a046:	fa 4f       	sbci	r31, 0xFA	; 250
    a048:	2f 2d       	mov	r18, r15
    a04a:	27 70       	andi	r18, 0x07	; 7
    a04c:	81 e0       	ldi	r24, 0x01	; 1
    a04e:	90 e0       	ldi	r25, 0x00	; 0
    a050:	02 2e       	mov	r0, r18
    a052:	01 c0       	rjmp	.+2      	; 0xa056 <EMeter_ZMR110_Data_ConvertI+0xbc>
    a054:	88 0f       	add	r24, r24
    a056:	0a 94       	dec	r0
    a058:	ea f7       	brpl	.-6      	; 0xa054 <EMeter_ZMR110_Data_ConvertI+0xba>
    a05a:	90 81       	ld	r25, Z
    a05c:	98 2b       	or	r25, r24
    a05e:	90 83       	st	Z, r25
			return Result;
    a060:	89 81       	ldd	r24, Y+1	; 0x01
    a062:	9a 81       	ldd	r25, Y+2	; 0x02
    a064:	0f 90       	pop	r0
    a066:	0f 90       	pop	r0
    a068:	0f 90       	pop	r0
    a06a:	0f 90       	pop	r0
    a06c:	0f 90       	pop	r0
    a06e:	0f 90       	pop	r0
    a070:	02 c0       	rjmp	.+4      	; 0xa076 <EMeter_ZMR110_Data_ConvertI+0xdc>
		}
	}	
	return 0;
    a072:	80 e0       	ldi	r24, 0x00	; 0
    a074:	90 e0       	ldi	r25, 0x00	; 0
}
    a076:	0f 90       	pop	r0
    a078:	0f 90       	pop	r0
    a07a:	df 91       	pop	r29
    a07c:	cf 91       	pop	r28
    a07e:	1f 91       	pop	r17
    a080:	0f 91       	pop	r16
    a082:	ff 90       	pop	r15
    a084:	08 95       	ret

0000a086 <EMeter_ZMR110_Read_Date>:
// ~~~~~~~~~
void EMeter_ZMR110_Read_Date(prog_char *Str_P, uint8_t FlagNum){
    a086:	1f 93       	push	r17
    a088:	cf 93       	push	r28
    a08a:	df 93       	push	r29
    a08c:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    a08e:	c0 91 fa 05 	lds	r28, 0x05FA
    a092:	d0 91 fb 05 	lds	r29, 0x05FB
    a096:	bc 01       	movw	r22, r24
    a098:	ce 01       	movw	r24, r28
    a09a:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    a09e:	00 97       	sbiw	r24, 0x00	; 0
    a0a0:	b9 f1       	breq	.+110    	; 0xa110 <EMeter_ZMR110_Read_Date+0x8a>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    a0a2:	9c 01       	movw	r18, r24
    a0a4:	2c 1b       	sub	r18, r28
    a0a6:	3d 0b       	sbc	r19, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    a0a8:	2d 3f       	cpi	r18, 0xFD	; 253
    a0aa:	31 05       	cpc	r19, r1
    a0ac:	88 f5       	brcc	.+98     	; 0xa110 <EMeter_ZMR110_Read_Date+0x8a>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    a0ae:	e1 2f       	mov	r30, r17
    a0b0:	e6 95       	lsr	r30
    a0b2:	e6 95       	lsr	r30
    a0b4:	e6 95       	lsr	r30
    a0b6:	f0 e0       	ldi	r31, 0x00	; 0
    a0b8:	ec 50       	subi	r30, 0x0C	; 12
    a0ba:	fa 4f       	sbci	r31, 0xFA	; 250
    a0bc:	17 70       	andi	r17, 0x07	; 7
    a0be:	41 e0       	ldi	r20, 0x01	; 1
    a0c0:	50 e0       	ldi	r21, 0x00	; 0
    a0c2:	01 c0       	rjmp	.+2      	; 0xa0c6 <EMeter_ZMR110_Read_Date+0x40>
    a0c4:	44 0f       	add	r20, r20
    a0c6:	1a 95       	dec	r17
    a0c8:	ea f7       	brpl	.-6      	; 0xa0c4 <EMeter_ZMR110_Read_Date+0x3e>
    a0ca:	80 81       	ld	r24, Z
    a0cc:	84 2b       	or	r24, r20
    a0ce:	80 83       	st	Z, r24
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%hhu-%hhu-%hhu"),&EM_Year, &EM_Month, &EM_Day);
    a0d0:	8a ed       	ldi	r24, 0xDA	; 218
    a0d2:	93 e0       	ldi	r25, 0x03	; 3
    a0d4:	9f 93       	push	r25
    a0d6:	8f 93       	push	r24
    a0d8:	81 ed       	ldi	r24, 0xD1	; 209
    a0da:	99 e0       	ldi	r25, 0x09	; 9
    a0dc:	9f 93       	push	r25
    a0de:	8f 93       	push	r24
    a0e0:	8a e6       	ldi	r24, 0x6A	; 106
    a0e2:	99 e0       	ldi	r25, 0x09	; 9
    a0e4:	9f 93       	push	r25
    a0e6:	8f 93       	push	r24
    a0e8:	89 e0       	ldi	r24, 0x09	; 9
    a0ea:	93 e0       	ldi	r25, 0x03	; 3
    a0ec:	9f 93       	push	r25
    a0ee:	8f 93       	push	r24
    a0f0:	2a 5f       	subi	r18, 0xFA	; 250
    a0f2:	3f 4f       	sbci	r19, 0xFF	; 255
    a0f4:	2c 0f       	add	r18, r28
    a0f6:	3d 1f       	adc	r19, r29
    a0f8:	3f 93       	push	r19
    a0fa:	2f 93       	push	r18
    a0fc:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
    a100:	8d b7       	in	r24, 0x3d	; 61
    a102:	9e b7       	in	r25, 0x3e	; 62
    a104:	0a 96       	adiw	r24, 0x0a	; 10
    a106:	0f b6       	in	r0, 0x3f	; 63
    a108:	f8 94       	cli
    a10a:	9e bf       	out	0x3e, r25	; 62
    a10c:	0f be       	out	0x3f, r0	; 63
    a10e:	8d bf       	out	0x3d, r24	; 61
		}
	}	
}
    a110:	df 91       	pop	r29
    a112:	cf 91       	pop	r28
    a114:	1f 91       	pop	r17
    a116:	08 95       	ret

0000a118 <EMeter_ZMR110_Read_Time>:

// ~~~~~~~~~
void EMeter_ZMR110_Read_Time(prog_char *Str_P, uint8_t FlagNum){
    a118:	1f 93       	push	r17
    a11a:	cf 93       	push	r28
    a11c:	df 93       	push	r29
    a11e:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    a120:	c0 91 fa 05 	lds	r28, 0x05FA
    a124:	d0 91 fb 05 	lds	r29, 0x05FB
    a128:	bc 01       	movw	r22, r24
    a12a:	ce 01       	movw	r24, r28
    a12c:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    a130:	00 97       	sbiw	r24, 0x00	; 0
    a132:	b9 f1       	breq	.+110    	; 0xa1a2 <EMeter_ZMR110_Read_Time+0x8a>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    a134:	9c 01       	movw	r18, r24
    a136:	2c 1b       	sub	r18, r28
    a138:	3d 0b       	sbc	r19, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    a13a:	2d 3f       	cpi	r18, 0xFD	; 253
    a13c:	31 05       	cpc	r19, r1
    a13e:	88 f5       	brcc	.+98     	; 0xa1a2 <EMeter_ZMR110_Read_Time+0x8a>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    a140:	e1 2f       	mov	r30, r17
    a142:	e6 95       	lsr	r30
    a144:	e6 95       	lsr	r30
    a146:	e6 95       	lsr	r30
    a148:	f0 e0       	ldi	r31, 0x00	; 0
    a14a:	ec 50       	subi	r30, 0x0C	; 12
    a14c:	fa 4f       	sbci	r31, 0xFA	; 250
    a14e:	17 70       	andi	r17, 0x07	; 7
    a150:	41 e0       	ldi	r20, 0x01	; 1
    a152:	50 e0       	ldi	r21, 0x00	; 0
    a154:	01 c0       	rjmp	.+2      	; 0xa158 <EMeter_ZMR110_Read_Time+0x40>
    a156:	44 0f       	add	r20, r20
    a158:	1a 95       	dec	r17
    a15a:	ea f7       	brpl	.-6      	; 0xa156 <EMeter_ZMR110_Read_Time+0x3e>
    a15c:	80 81       	ld	r24, Z
    a15e:	84 2b       	or	r24, r20
    a160:	80 83       	st	Z, r24
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%hhu:%hhu:%hhu"),&EM_Hour, &EM_Min, &EM_Sec);
    a162:	80 e0       	ldi	r24, 0x00	; 0
    a164:	96 e0       	ldi	r25, 0x06	; 6
    a166:	9f 93       	push	r25
    a168:	8f 93       	push	r24
    a16a:	83 e3       	ldi	r24, 0x33	; 51
    a16c:	99 e0       	ldi	r25, 0x09	; 9
    a16e:	9f 93       	push	r25
    a170:	8f 93       	push	r24
    a172:	82 e5       	ldi	r24, 0x52	; 82
    a174:	99 e0       	ldi	r25, 0x09	; 9
    a176:	9f 93       	push	r25
    a178:	8f 93       	push	r24
    a17a:	8a ef       	ldi	r24, 0xFA	; 250
    a17c:	92 e0       	ldi	r25, 0x02	; 2
    a17e:	9f 93       	push	r25
    a180:	8f 93       	push	r24
    a182:	2a 5f       	subi	r18, 0xFA	; 250
    a184:	3f 4f       	sbci	r19, 0xFF	; 255
    a186:	2c 0f       	add	r18, r28
    a188:	3d 1f       	adc	r19, r29
    a18a:	3f 93       	push	r19
    a18c:	2f 93       	push	r18
    a18e:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
    a192:	8d b7       	in	r24, 0x3d	; 61
    a194:	9e b7       	in	r25, 0x3e	; 62
    a196:	0a 96       	adiw	r24, 0x0a	; 10
    a198:	0f b6       	in	r0, 0x3f	; 63
    a19a:	f8 94       	cli
    a19c:	9e bf       	out	0x3e, r25	; 62
    a19e:	0f be       	out	0x3f, r0	; 63
    a1a0:	8d bf       	out	0x3d, r24	; 61
		}
	}	
}
    a1a2:	df 91       	pop	r29
    a1a4:	cf 91       	pop	r28
    a1a6:	1f 91       	pop	r17
    a1a8:	08 95       	ret

0000a1aa <EMeter_ZMR110_Read_DWord>:
// ~~~~~~~~~
uint32_t EMeter_ZMR110_Read_DWord(prog_char *Str_P, uint8_t FlagNum){
    a1aa:	bf 92       	push	r11
    a1ac:	cf 92       	push	r12
    a1ae:	df 92       	push	r13
    a1b0:	ef 92       	push	r14
    a1b2:	ff 92       	push	r15
    a1b4:	0f 93       	push	r16
    a1b6:	1f 93       	push	r17
    a1b8:	cf 93       	push	r28
    a1ba:	df 93       	push	r29
    a1bc:	00 d0       	rcall	.+0      	; 0xa1be <EMeter_ZMR110_Read_DWord+0x14>
    a1be:	00 d0       	rcall	.+0      	; 0xa1c0 <EMeter_ZMR110_Read_DWord+0x16>
    a1c0:	cd b7       	in	r28, 0x3d	; 61
    a1c2:	de b7       	in	r29, 0x3e	; 62
    a1c4:	7c 01       	movw	r14, r24
    a1c6:	b6 2e       	mov	r11, r22
	uint32_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    a1c8:	00 91 fa 05 	lds	r16, 0x05FA
    a1cc:	10 91 fb 05 	lds	r17, 0x05FB
    a1d0:	bc 01       	movw	r22, r24
    a1d2:	c8 01       	movw	r24, r16
    a1d4:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    a1d8:	00 97       	sbiw	r24, 0x00	; 0
    a1da:	e1 f1       	breq	.+120    	; 0xa254 <EMeter_ZMR110_Read_DWord+0xaa>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    a1dc:	6c 01       	movw	r12, r24
    a1de:	c0 1a       	sub	r12, r16
    a1e0:	d1 0a       	sbc	r13, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    a1e2:	8d ef       	ldi	r24, 0xFD	; 253
    a1e4:	c8 16       	cp	r12, r24
    a1e6:	d1 04       	cpc	r13, r1
    a1e8:	a8 f5       	brcc	.+106    	; 0xa254 <EMeter_ZMR110_Read_DWord+0xaa>
    a1ea:	c7 01       	movw	r24, r14
    a1ec:	0e 94 c9 77 	call	0xef92	; 0xef92 <__strlen_P>
			sscanf_P(EMeter_RxStr_Offset+Start+strlen_P(Str_P)+1,PSTR("%lud"),&Result);
    a1f0:	9e 01       	movw	r18, r28
    a1f2:	2f 5f       	subi	r18, 0xFF	; 255
    a1f4:	3f 4f       	sbci	r19, 0xFF	; 255
    a1f6:	3f 93       	push	r19
    a1f8:	2f 93       	push	r18
    a1fa:	25 ef       	ldi	r18, 0xF5	; 245
    a1fc:	32 e0       	ldi	r19, 0x02	; 2
    a1fe:	3f 93       	push	r19
    a200:	2f 93       	push	r18
    a202:	96 01       	movw	r18, r12
    a204:	2f 5f       	subi	r18, 0xFF	; 255
    a206:	3f 4f       	sbci	r19, 0xFF	; 255
    a208:	28 0f       	add	r18, r24
    a20a:	39 1f       	adc	r19, r25
    a20c:	20 0f       	add	r18, r16
    a20e:	31 1f       	adc	r19, r17
    a210:	3f 93       	push	r19
    a212:	2f 93       	push	r18
    a214:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    a218:	eb 2d       	mov	r30, r11
    a21a:	e6 95       	lsr	r30
    a21c:	e6 95       	lsr	r30
    a21e:	e6 95       	lsr	r30
    a220:	f0 e0       	ldi	r31, 0x00	; 0
    a222:	ec 50       	subi	r30, 0x0C	; 12
    a224:	fa 4f       	sbci	r31, 0xFA	; 250
    a226:	2b 2d       	mov	r18, r11
    a228:	27 70       	andi	r18, 0x07	; 7
    a22a:	81 e0       	ldi	r24, 0x01	; 1
    a22c:	90 e0       	ldi	r25, 0x00	; 0
    a22e:	02 2e       	mov	r0, r18
    a230:	01 c0       	rjmp	.+2      	; 0xa234 <EMeter_ZMR110_Read_DWord+0x8a>
    a232:	88 0f       	add	r24, r24
    a234:	0a 94       	dec	r0
    a236:	ea f7       	brpl	.-6      	; 0xa232 <EMeter_ZMR110_Read_DWord+0x88>
    a238:	90 81       	ld	r25, Z
    a23a:	98 2b       	or	r25, r24
    a23c:	90 83       	st	Z, r25
			return Result;
    a23e:	69 81       	ldd	r22, Y+1	; 0x01
    a240:	7a 81       	ldd	r23, Y+2	; 0x02
    a242:	8b 81       	ldd	r24, Y+3	; 0x03
    a244:	9c 81       	ldd	r25, Y+4	; 0x04
    a246:	0f 90       	pop	r0
    a248:	0f 90       	pop	r0
    a24a:	0f 90       	pop	r0
    a24c:	0f 90       	pop	r0
    a24e:	0f 90       	pop	r0
    a250:	0f 90       	pop	r0
    a252:	03 c0       	rjmp	.+6      	; 0xa25a <EMeter_ZMR110_Read_DWord+0xb0>
		}
	}	
	return 0;
    a254:	60 e0       	ldi	r22, 0x00	; 0
    a256:	70 e0       	ldi	r23, 0x00	; 0
    a258:	cb 01       	movw	r24, r22
}
    a25a:	0f 90       	pop	r0
    a25c:	0f 90       	pop	r0
    a25e:	0f 90       	pop	r0
    a260:	0f 90       	pop	r0
    a262:	df 91       	pop	r29
    a264:	cf 91       	pop	r28
    a266:	1f 91       	pop	r17
    a268:	0f 91       	pop	r16
    a26a:	ff 90       	pop	r15
    a26c:	ef 90       	pop	r14
    a26e:	df 90       	pop	r13
    a270:	cf 90       	pop	r12
    a272:	bf 90       	pop	r11
    a274:	08 95       	ret

0000a276 <EMeter_ZMR110_Read_ID1_1>:
// ~~~~~~~~~
void EMeter_ZMR110_Read_ID1_1(prog_char *Str_P, uint8_t FlagNum){
    a276:	1f 93       	push	r17
    a278:	cf 93       	push	r28
    a27a:	df 93       	push	r29
    a27c:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    a27e:	c0 91 fa 05 	lds	r28, 0x05FA
    a282:	d0 91 fb 05 	lds	r29, 0x05FB
    a286:	bc 01       	movw	r22, r24
    a288:	ce 01       	movw	r24, r28
    a28a:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
	if(temp_ptr != NULL){
    a28e:	00 97       	sbiw	r24, 0x00	; 0
    a290:	69 f1       	breq	.+90     	; 0xa2ec <EMeter_ZMR110_Read_ID1_1+0x76>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    a292:	9c 01       	movw	r18, r24
    a294:	2c 1b       	sub	r18, r28
    a296:	3d 0b       	sbc	r19, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    a298:	2d 3f       	cpi	r18, 0xFD	; 253
    a29a:	31 05       	cpc	r19, r1
    a29c:	38 f5       	brcc	.+78     	; 0xa2ec <EMeter_ZMR110_Read_ID1_1+0x76>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    a29e:	e1 2f       	mov	r30, r17
    a2a0:	e6 95       	lsr	r30
    a2a2:	e6 95       	lsr	r30
    a2a4:	e6 95       	lsr	r30
    a2a6:	f0 e0       	ldi	r31, 0x00	; 0
    a2a8:	ec 50       	subi	r30, 0x0C	; 12
    a2aa:	fa 4f       	sbci	r31, 0xFA	; 250
    a2ac:	17 70       	andi	r17, 0x07	; 7
    a2ae:	41 e0       	ldi	r20, 0x01	; 1
    a2b0:	50 e0       	ldi	r21, 0x00	; 0
    a2b2:	01 c0       	rjmp	.+2      	; 0xa2b6 <EMeter_ZMR110_Read_ID1_1+0x40>
    a2b4:	44 0f       	add	r20, r20
    a2b6:	1a 95       	dec	r17
    a2b8:	ea f7       	brpl	.-6      	; 0xa2b4 <EMeter_ZMR110_Read_ID1_1+0x3e>
    a2ba:	80 81       	ld	r24, Z
    a2bc:	84 2b       	or	r24, r20
    a2be:	80 83       	st	Z, r24
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%8s"), EM_ID_Str);
    a2c0:	84 e6       	ldi	r24, 0x64	; 100
    a2c2:	98 e0       	ldi	r25, 0x08	; 8
    a2c4:	9f 93       	push	r25
    a2c6:	8f 93       	push	r24
    a2c8:	81 ef       	ldi	r24, 0xF1	; 241
    a2ca:	92 e0       	ldi	r25, 0x02	; 2
    a2cc:	9f 93       	push	r25
    a2ce:	8f 93       	push	r24
    a2d0:	2a 5f       	subi	r18, 0xFA	; 250
    a2d2:	3f 4f       	sbci	r19, 0xFF	; 255
    a2d4:	2c 0f       	add	r18, r28
    a2d6:	3d 1f       	adc	r19, r29
    a2d8:	3f 93       	push	r19
    a2da:	2f 93       	push	r18
    a2dc:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
    a2e0:	0f 90       	pop	r0
    a2e2:	0f 90       	pop	r0
    a2e4:	0f 90       	pop	r0
    a2e6:	0f 90       	pop	r0
    a2e8:	0f 90       	pop	r0
    a2ea:	0f 90       	pop	r0
		}
	}	
}
    a2ec:	df 91       	pop	r29
    a2ee:	cf 91       	pop	r28
    a2f0:	1f 91       	pop	r17
    a2f2:	08 95       	ret

0000a2f4 <IsEMReady>:
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    a2f4:	81 e0       	ldi	r24, 0x01	; 1
    a2f6:	90 91 55 0a 	lds	r25, 0x0A55
    a2fa:	9f 3f       	cpi	r25, 0xFF	; 255
    a2fc:	09 f0       	breq	.+2      	; 0xa300 <IsEMReady+0xc>
    a2fe:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    a300:	08 95       	ret

0000a302 <EMRead>:
    a302:	89 e2       	ldi	r24, 0x29	; 41
    a304:	90 e0       	ldi	r25, 0x00	; 0
    a306:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    a30a:	84 30       	cpi	r24, 0x04	; 4
    a30c:	11 f0       	breq	.+4      	; 0xa312 <EMRead+0x10>
    a30e:	10 92 55 0a 	sts	0x0A55, r1
    a312:	08 95       	ret

0000a314 <EMeter_Cycle>:
}

// ~~~~~~~~~
void EMeter_Cycle(void){
    a314:	cf 92       	push	r12
    a316:	df 92       	push	r13
    a318:	ef 92       	push	r14
    a31a:	ff 92       	push	r15
    a31c:	0f 93       	push	r16
    a31e:	1f 93       	push	r17
    a320:	cf 93       	push	r28
    a322:	df 93       	push	r29
    a324:	cd b7       	in	r28, 0x3d	; 61
    a326:	de b7       	in	r29, 0x3e	; 62
    a328:	2b 97       	sbiw	r28, 0x0b	; 11
    a32a:	0f b6       	in	r0, 0x3f	; 63
    a32c:	f8 94       	cli
    a32e:	de bf       	out	0x3e, r29	; 62
    a330:	0f be       	out	0x3f, r0	; 63
    a332:	cd bf       	out	0x3d, r28	; 61
    a334:	89 e2       	ldi	r24, 0x29	; 41
    a336:	90 e0       	ldi	r25, 0x00	; 0
    a338:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>

	static uint8_t RING_Retry;	//  ELVIN_MODEM

	EMeterTypeRAM = erb(&EMeterType);
    a33c:	80 93 e7 03 	sts	0x03E7, r24


	if(UART_Soft || Transparent){
    a340:	80 91 59 0a 	lds	r24, 0x0A59
    a344:	81 11       	cpse	r24, r1
    a346:	7b c7       	rjmp	.+3830   	; 0xb23e <EMeter_Cycle+0xf2a>
    a348:	80 91 5a 0a 	lds	r24, 0x0A5A
    a34c:	81 11       	cpse	r24, r1
    a34e:	77 c7       	rjmp	.+3822   	; 0xb23e <EMeter_Cycle+0xf2a>
    a350:	89 e2       	ldi	r24, 0x29	; 41
    a352:	90 e0       	ldi	r25, 0x00	; 0
    a354:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	
	
	}
	else{

		if( erb(&EMeterType) == EM_NONE){
    a358:	81 11       	cpse	r24, r1
    a35a:	06 c0       	rjmp	.+12     	; 0xa368 <EMeter_Cycle+0x54>
			EMeter_RxCharN = 0;
    a35c:	10 92 22 0d 	sts	0x0D22, r1
    a360:	10 92 21 0d 	sts	0x0D21, r1
			EMeter_ELVIN_Modem_NoLink();
    a364:	0e 94 5d 4e 	call	0x9cba	; 0x9cba <EMeter_ELVIN_Modem_NoLink>
    a368:	89 e2       	ldi	r24, 0x29	; 41
    a36a:	90 e0       	ldi	r25, 0x00	; 0
    a36c:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    a370:	18 2f       	mov	r17, r24
		}

		//--- Landis&Gyr ZMR110
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    a372:	81 30       	cpi	r24, 0x01	; 1
    a374:	09 f0       	breq	.+2      	; 0xa378 <EMeter_Cycle+0x64>
    a376:	a3 c2       	rjmp	.+1350   	; 0xa8be <EMeter_Cycle+0x5aa>
			switch(EM_Mode){
    a378:	90 91 55 0a 	lds	r25, 0x0A55
    a37c:	92 30       	cpi	r25, 0x02	; 2
    a37e:	09 f4       	brne	.+2      	; 0xa382 <EMeter_Cycle+0x6e>
    a380:	45 c0       	rjmp	.+138    	; 0xa40c <EMeter_Cycle+0xf8>
    a382:	9f 3f       	cpi	r25, 0xFF	; 255
    a384:	09 f4       	brne	.+2      	; 0xa388 <EMeter_Cycle+0x74>
    a386:	9b c2       	rjmp	.+1334   	; 0xa8be <EMeter_Cycle+0x5aa>
    a388:	91 30       	cpi	r25, 0x01	; 1
    a38a:	09 f0       	breq	.+2      	; 0xa38e <EMeter_Cycle+0x7a>
    a38c:	84 c2       	rjmp	.+1288   	; 0xa896 <EMeter_Cycle+0x582>

				case 1:	
						cli();
    a38e:	f8 94       	cli
						EM_HalfBufferStart= EMeter_RxStr;//----    
    a390:	8e e2       	ldi	r24, 0x2E	; 46
    a392:	97 e0       	ldi	r25, 0x07	; 7
    a394:	90 93 6c 09 	sts	0x096C, r25
    a398:	80 93 6b 09 	sts	0x096B, r24
						EMeter_RxStr_Offset = EMeter_RxStr;
    a39c:	90 93 fb 05 	sts	0x05FB, r25
    a3a0:	80 93 fa 05 	sts	0x05FA, r24
						EM_BufferReadEnable=0;//----- 
    a3a4:	10 92 36 09 	sts	0x0936, r1
						EMeter_RxCharN=0;
    a3a8:	10 92 22 0d 	sts	0x0D22, r1
    a3ac:	10 92 21 0d 	sts	0x0D21, r1
						sei();	
    a3b0:	78 94       	sei
					if(Timer16Stopp(TD_EMeter)){
    a3b2:	80 91 1b 0c 	lds	r24, 0x0C1B
    a3b6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    a3ba:	88 23       	and	r24, r24
    a3bc:	09 f4       	brne	.+2      	; 0xa3c0 <EMeter_Cycle+0xac>
    a3be:	7f c2       	rjmp	.+1278   	; 0xa8be <EMeter_Cycle+0x5aa>
						EMeter_SendCR(EM_READ_DATA_REQ);
    a3c0:	8d e4       	ldi	r24, 0x4D	; 77
    a3c2:	9c e4       	ldi	r25, 0x4C	; 76
    a3c4:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
						StartTimer16(TD_EMeter,1000);
    a3c8:	68 ee       	ldi	r22, 0xE8	; 232
    a3ca:	73 e0       	ldi	r23, 0x03	; 3
    a3cc:	80 91 1b 0c 	lds	r24, 0x0C1B
    a3d0:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) LG_ZMR110_READ_FLAG[i] = 0;
    a3d4:	10 92 f4 05 	sts	0x05F4, r1
    a3d8:	10 92 f5 05 	sts	0x05F5, r1
    a3dc:	10 92 f6 05 	sts	0x05F6, r1
    a3e0:	10 92 f7 05 	sts	0x05F7, r1
						//EMeter_ClearRXStr();
						
						
						
							cli();
    a3e4:	f8 94       	cli
						EM_HalfBufferStart= EMeter_RxStr;//----    
    a3e6:	8e e2       	ldi	r24, 0x2E	; 46
    a3e8:	97 e0       	ldi	r25, 0x07	; 7
    a3ea:	90 93 6c 09 	sts	0x096C, r25
    a3ee:	80 93 6b 09 	sts	0x096B, r24
						EMeter_RxStr_Offset = EMeter_RxStr;
    a3f2:	90 93 fb 05 	sts	0x05FB, r25
    a3f6:	80 93 fa 05 	sts	0x05FA, r24
						EM_BufferReadEnable=0;//----- 
    a3fa:	10 92 36 09 	sts	0x0936, r1
						EMeter_RxCharN=0;
    a3fe:	10 92 22 0d 	sts	0x0D22, r1
    a402:	10 92 21 0d 	sts	0x0D21, r1
						sei();
    a406:	78 94       	sei


						EM_Mode = 2;
    a408:	82 e0       	ldi	r24, 0x02	; 2
    a40a:	42 c2       	rjmp	.+1156   	; 0xa890 <EMeter_Cycle+0x57c>
					}
					break;
				case 2:
					if(EM_BufferReadEnable==1)
    a40c:	80 91 36 09 	lds	r24, 0x0936
    a410:	81 30       	cpi	r24, 0x01	; 1
    a412:	09 f0       	breq	.+2      	; 0xa416 <EMeter_Cycle+0x102>
    a414:	22 c2       	rjmp	.+1092   	; 0xa85a <EMeter_Cycle+0x546>
					{
												cli();
    a416:	f8 94       	cli
												EMeter_RxStr[EM_RX_SIZE-1] = '\0';
    a418:	10 92 2b 08 	sts	0x082B, r1
												EMeter_RxStr[EM_RX_SIZE/2-1]='\0';//  
    a41c:	10 92 ac 07 	sts	0x07AC, r1
												 //read & analyze data
					


												char *p; 
												p=strchr(EMeter_RxStr_Offset,'\n');
    a420:	6a e0       	ldi	r22, 0x0A	; 10
    a422:	70 e0       	ldi	r23, 0x00	; 0
    a424:	80 91 fa 05 	lds	r24, 0x05FA
    a428:	90 91 fb 05 	lds	r25, 0x05FB
    a42c:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    a430:	8c 01       	movw	r16, r24
												sei();
    a432:	78 94       	sei
												if(p != NULL){
    a434:	00 97       	sbiw	r24, 0x00	; 0
    a436:	09 f4       	brne	.+2      	; 0xa43a <EMeter_Cycle+0x126>
    a438:	10 c2       	rjmp	.+1056   	; 0xa85a <EMeter_Cycle+0x546>
													*p = '\0';
    a43a:	dc 01       	movw	r26, r24
    a43c:	1c 92       	st	X, r1

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a43e:	80 91 f4 05 	lds	r24, 0x05F4
												p=strchr(EMeter_RxStr_Offset,'\n');
												sei();
												if(p != NULL){
													*p = '\0';
													// search for OBIS code
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_2)) 
    a442:	80 fd       	sbrc	r24, 0
    a444:	05 c0       	rjmp	.+10     	; 0xa450 <EMeter_Cycle+0x13c>
														EMeter_ZMR110_Read_Date(EM_RESP_0_9_2, flg_OBIS_0_9_2);
    a446:	60 e0       	ldi	r22, 0x00	; 0
    a448:	8b ed       	ldi	r24, 0xDB	; 219
    a44a:	9c e4       	ldi	r25, 0x4C	; 76
    a44c:	0e 94 43 50 	call	0xa086	; 0xa086 <EMeter_ZMR110_Read_Date>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a450:	80 91 f4 05 	lds	r24, 0x05F4
												if(p != NULL){
													*p = '\0';
													// search for OBIS code
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_2)) 
														EMeter_ZMR110_Read_Date(EM_RESP_0_9_2, flg_OBIS_0_9_2);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_1)) 
    a454:	81 fd       	sbrc	r24, 1
    a456:	05 c0       	rjmp	.+10     	; 0xa462 <EMeter_Cycle+0x14e>
														EMeter_ZMR110_Read_Time(EM_RESP_0_9_1, flg_OBIS_0_9_1);
    a458:	61 e0       	ldi	r22, 0x01	; 1
    a45a:	85 ed       	ldi	r24, 0xD5	; 213
    a45c:	9c e4       	ldi	r25, 0x4C	; 76
    a45e:	0e 94 8c 50 	call	0xa118	; 0xa118 <EMeter_ZMR110_Read_Time>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a462:	80 91 f4 05 	lds	r24, 0x05F4
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_2)) 
														EMeter_ZMR110_Read_Date(EM_RESP_0_9_2, flg_OBIS_0_9_2);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_1)) 
														EMeter_ZMR110_Read_Time(EM_RESP_0_9_1, flg_OBIS_0_9_1);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_1_8_0)) 
    a466:	82 fd       	sbrc	r24, 2
    a468:	0d c0       	rjmp	.+26     	; 0xa484 <EMeter_Cycle+0x170>
														E_Meter_RAM.Ap = EMeter_ZMR110_Data_ConvertQ(EM_RESP_1_8_0, flg_OBIS_1_8_0);
    a46a:	62 e0       	ldi	r22, 0x02	; 2
    a46c:	8f ec       	ldi	r24, 0xCF	; 207
    a46e:	9c e4       	ldi	r25, 0x4C	; 76
    a470:	0e 94 b7 4e 	call	0x9d6e	; 0x9d6e <EMeter_ZMR110_Data_ConvertQ>
    a474:	60 93 3e 02 	sts	0x023E, r22
    a478:	70 93 3f 02 	sts	0x023F, r23
    a47c:	80 93 40 02 	sts	0x0240, r24
    a480:	90 93 41 02 	sts	0x0241, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a484:	80 91 f4 05 	lds	r24, 0x05F4
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_1)) 
														EMeter_ZMR110_Read_Time(EM_RESP_0_9_1, flg_OBIS_0_9_1);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_1_8_0)) 
														E_Meter_RAM.Ap = EMeter_ZMR110_Data_ConvertQ(EM_RESP_1_8_0, flg_OBIS_1_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_2_8_0)) 
    a488:	85 fd       	sbrc	r24, 5
    a48a:	0d c0       	rjmp	.+26     	; 0xa4a6 <EMeter_Cycle+0x192>
														E_Meter_RAM.Am = EMeter_ZMR110_Data_ConvertQ(EM_RESP_2_8_0, flg_OBIS_2_8_0);
    a48c:	65 e0       	ldi	r22, 0x05	; 5
    a48e:	89 ec       	ldi	r24, 0xC9	; 201
    a490:	9c e4       	ldi	r25, 0x4C	; 76
    a492:	0e 94 b7 4e 	call	0x9d6e	; 0x9d6e <EMeter_ZMR110_Data_ConvertQ>
    a496:	60 93 42 02 	sts	0x0242, r22
    a49a:	70 93 43 02 	sts	0x0243, r23
    a49e:	80 93 44 02 	sts	0x0244, r24
    a4a2:	90 93 45 02 	sts	0x0245, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a4a6:	80 91 f4 05 	lds	r24, 0x05F4

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_1_8_0)) 
														E_Meter_RAM.Ap = EMeter_ZMR110_Data_ConvertQ(EM_RESP_1_8_0, flg_OBIS_1_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_2_8_0)) 
														E_Meter_RAM.Am = EMeter_ZMR110_Data_ConvertQ(EM_RESP_2_8_0, flg_OBIS_2_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_3_8_0)) 
    a4aa:	83 fd       	sbrc	r24, 3
    a4ac:	0d c0       	rjmp	.+26     	; 0xa4c8 <EMeter_Cycle+0x1b4>
														E_Meter_RAM.Rp = EMeter_ZMR110_Data_ConvertQ(EM_RESP_3_8_0, flg_OBIS_3_8_0);
    a4ae:	63 e0       	ldi	r22, 0x03	; 3
    a4b0:	83 ec       	ldi	r24, 0xC3	; 195
    a4b2:	9c e4       	ldi	r25, 0x4C	; 76
    a4b4:	0e 94 b7 4e 	call	0x9d6e	; 0x9d6e <EMeter_ZMR110_Data_ConvertQ>
    a4b8:	60 93 46 02 	sts	0x0246, r22
    a4bc:	70 93 47 02 	sts	0x0247, r23
    a4c0:	80 93 48 02 	sts	0x0248, r24
    a4c4:	90 93 49 02 	sts	0x0249, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a4c8:	80 91 f4 05 	lds	r24, 0x05F4
														E_Meter_RAM.Ap = EMeter_ZMR110_Data_ConvertQ(EM_RESP_1_8_0, flg_OBIS_1_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_2_8_0)) 
														E_Meter_RAM.Am = EMeter_ZMR110_Data_ConvertQ(EM_RESP_2_8_0, flg_OBIS_2_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_3_8_0)) 
														E_Meter_RAM.Rp = EMeter_ZMR110_Data_ConvertQ(EM_RESP_3_8_0, flg_OBIS_3_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_4_8_0)) 
    a4cc:	84 fd       	sbrc	r24, 4
    a4ce:	0d c0       	rjmp	.+26     	; 0xa4ea <EMeter_Cycle+0x1d6>
														E_Meter_RAM.Rm = EMeter_ZMR110_Data_ConvertQ(EM_RESP_4_8_0, flg_OBIS_4_8_0);
    a4d0:	64 e0       	ldi	r22, 0x04	; 4
    a4d2:	8d eb       	ldi	r24, 0xBD	; 189
    a4d4:	9c e4       	ldi	r25, 0x4C	; 76
    a4d6:	0e 94 b7 4e 	call	0x9d6e	; 0x9d6e <EMeter_ZMR110_Data_ConvertQ>
    a4da:	60 93 4a 02 	sts	0x024A, r22
    a4de:	70 93 4b 02 	sts	0x024B, r23
    a4e2:	80 93 4c 02 	sts	0x024C, r24
    a4e6:	90 93 4d 02 	sts	0x024D, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a4ea:	80 91 f4 05 	lds	r24, 0x05F4
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_3_8_0)) 
														E_Meter_RAM.Rp = EMeter_ZMR110_Data_ConvertQ(EM_RESP_3_8_0, flg_OBIS_3_8_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_4_8_0)) 
														E_Meter_RAM.Rm = EMeter_ZMR110_Data_ConvertQ(EM_RESP_4_8_0, flg_OBIS_4_8_0);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_32_7_0)) 
    a4ee:	86 fd       	sbrc	r24, 6
    a4f0:	09 c0       	rjmp	.+18     	; 0xa504 <EMeter_Cycle+0x1f0>
														Ua = EMeter_ZMR110_Read_Word(EM_RESP_32_7_0, flg_OBIS_32_7_0);
    a4f2:	66 e0       	ldi	r22, 0x06	; 6
    a4f4:	86 eb       	ldi	r24, 0xB6	; 182
    a4f6:	9c e4       	ldi	r25, 0x4C	; 76
    a4f8:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>
    a4fc:	90 93 24 0d 	sts	0x0D24, r25
    a500:	80 93 23 0d 	sts	0x0D23, r24
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_52_7_0)) 							
    a504:	80 91 f4 05 	lds	r24, 0x05F4
    a508:	87 fd       	sbrc	r24, 7
    a50a:	09 c0       	rjmp	.+18     	; 0xa51e <EMeter_Cycle+0x20a>
														Ub = EMeter_ZMR110_Read_Word(EM_RESP_52_7_0, flg_OBIS_52_7_0);
    a50c:	67 e0       	ldi	r22, 0x07	; 7
    a50e:	8f ea       	ldi	r24, 0xAF	; 175
    a510:	9c e4       	ldi	r25, 0x4C	; 76
    a512:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>
    a516:	90 93 dd 03 	sts	0x03DD, r25
    a51a:	80 93 dc 03 	sts	0x03DC, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a51e:	80 91 f5 05 	lds	r24, 0x05F5

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_32_7_0)) 
														Ua = EMeter_ZMR110_Read_Word(EM_RESP_32_7_0, flg_OBIS_32_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_52_7_0)) 							
														Ub = EMeter_ZMR110_Read_Word(EM_RESP_52_7_0, flg_OBIS_52_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_72_7_0)) 
    a522:	80 fd       	sbrc	r24, 0
    a524:	09 c0       	rjmp	.+18     	; 0xa538 <EMeter_Cycle+0x224>
														Uc = EMeter_ZMR110_Read_Word(EM_RESP_72_7_0, flg_OBIS_72_7_0);
    a526:	68 e0       	ldi	r22, 0x08	; 8
    a528:	88 ea       	ldi	r24, 0xA8	; 168
    a52a:	9c e4       	ldi	r25, 0x4C	; 76
    a52c:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>
    a530:	90 93 58 0a 	sts	0x0A58, r25
    a534:	80 93 57 0a 	sts	0x0A57, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a538:	80 91 f5 05 	lds	r24, 0x05F5
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_52_7_0)) 							
														Ub = EMeter_ZMR110_Read_Word(EM_RESP_52_7_0, flg_OBIS_52_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_72_7_0)) 
														Uc = EMeter_ZMR110_Read_Word(EM_RESP_72_7_0, flg_OBIS_72_7_0);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_31_7_0)) 
    a53c:	81 fd       	sbrc	r24, 1
    a53e:	09 c0       	rjmp	.+18     	; 0xa552 <EMeter_Cycle+0x23e>
														Ia = EMeter_ZMR110_Data_ConvertI(EM_RESP_31_7_0, flg_OBIS_31_7_0);
    a540:	69 e0       	ldi	r22, 0x09	; 9
    a542:	81 ea       	ldi	r24, 0xA1	; 161
    a544:	9c e4       	ldi	r25, 0x4C	; 76
    a546:	0e 94 cd 4f 	call	0x9f9a	; 0x9f9a <EMeter_ZMR110_Data_ConvertI>
    a54a:	90 93 eb 03 	sts	0x03EB, r25
    a54e:	80 93 ea 03 	sts	0x03EA, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a552:	80 91 f5 05 	lds	r24, 0x05F5
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_72_7_0)) 
														Uc = EMeter_ZMR110_Read_Word(EM_RESP_72_7_0, flg_OBIS_72_7_0);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_31_7_0)) 
														Ia = EMeter_ZMR110_Data_ConvertI(EM_RESP_31_7_0, flg_OBIS_31_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_51_7_0)) 
    a556:	82 fd       	sbrc	r24, 2
    a558:	09 c0       	rjmp	.+18     	; 0xa56c <EMeter_Cycle+0x258>
														Ib = EMeter_ZMR110_Data_ConvertI(EM_RESP_51_7_0, flg_OBIS_51_7_0);
    a55a:	6a e0       	ldi	r22, 0x0A	; 10
    a55c:	8a e9       	ldi	r24, 0x9A	; 154
    a55e:	9c e4       	ldi	r25, 0x4C	; 76
    a560:	0e 94 cd 4f 	call	0x9f9a	; 0x9f9a <EMeter_ZMR110_Data_ConvertI>
    a564:	90 93 2e 09 	sts	0x092E, r25
    a568:	80 93 2d 09 	sts	0x092D, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a56c:	80 91 f5 05 	lds	r24, 0x05F5

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_31_7_0)) 
														Ia = EMeter_ZMR110_Data_ConvertI(EM_RESP_31_7_0, flg_OBIS_31_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_51_7_0)) 
														Ib = EMeter_ZMR110_Data_ConvertI(EM_RESP_51_7_0, flg_OBIS_51_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_71_7_0)) 
    a570:	83 fd       	sbrc	r24, 3
    a572:	09 c0       	rjmp	.+18     	; 0xa586 <EMeter_Cycle+0x272>
														Ic = EMeter_ZMR110_Data_ConvertI(EM_RESP_71_7_0, flg_OBIS_71_7_0);
    a574:	6b e0       	ldi	r22, 0x0B	; 11
    a576:	83 e9       	ldi	r24, 0x93	; 147
    a578:	9c e4       	ldi	r25, 0x4C	; 76
    a57a:	0e 94 cd 4f 	call	0x9f9a	; 0x9f9a <EMeter_ZMR110_Data_ConvertI>
    a57e:	90 93 66 09 	sts	0x0966, r25
    a582:	80 93 65 09 	sts	0x0965, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a586:	80 91 f5 05 	lds	r24, 0x05F5
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_51_7_0)) 
														Ib = EMeter_ZMR110_Data_ConvertI(EM_RESP_51_7_0, flg_OBIS_51_7_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_71_7_0)) 
														Ic = EMeter_ZMR110_Data_ConvertI(EM_RESP_71_7_0, flg_OBIS_71_7_0);

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_16_7_0)) 
    a58a:	85 fd       	sbrc	r24, 5
    a58c:	09 c0       	rjmp	.+18     	; 0xa5a0 <EMeter_Cycle+0x28c>
														EM_PowerActive = EMeter_ZMR110_Data_ConvertI(EM_RESP_16_7_0, flg_OBIS_16_7_0);
    a58e:	6d e0       	ldi	r22, 0x0D	; 13
    a590:	8c e8       	ldi	r24, 0x8C	; 140
    a592:	9c e4       	ldi	r25, 0x4C	; 76
    a594:	0e 94 cd 4f 	call	0x9f9a	; 0x9f9a <EMeter_ZMR110_Data_ConvertI>
    a598:	90 93 54 0a 	sts	0x0A54, r25
    a59c:	80 93 53 0a 	sts	0x0A53, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a5a0:	80 91 f5 05 	lds	r24, 0x05F5

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_16_7_0)) 
														EM_PowerActive = EMeter_ZMR110_Data_ConvertI(EM_RESP_16_7_0, flg_OBIS_16_7_0);
						
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_0)){
    a5a4:	86 fd       	sbrc	r24, 6
    a5a6:	21 c0       	rjmp	.+66     	; 0xa5ea <EMeter_Cycle+0x2d6>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_60_0, flg_OBIS_C_60_0);
    a5a8:	6e e0       	ldi	r22, 0x0E	; 14
    a5aa:	85 e8       	ldi	r24, 0x85	; 133
    a5ac:	9c e4       	ldi	r25, 0x4C	; 76
    a5ae:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a5b2:	20 91 f5 05 	lds	r18, 0x05F5
														EM_PowerActive = EMeter_ZMR110_Data_ConvertI(EM_RESP_16_7_0, flg_OBIS_16_7_0);
						
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_0)){
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_60_0, flg_OBIS_C_60_0);
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_0)){
    a5b6:	26 ff       	sbrs	r18, 6
    a5b8:	18 c0       	rjmp	.+48     	; 0xa5ea <EMeter_Cycle+0x2d6>
															if(EM_Magnit_Cnt_new == 0){
    a5ba:	20 91 25 09 	lds	r18, 0x0925
    a5be:	30 91 26 09 	lds	r19, 0x0926
    a5c2:	21 15       	cp	r18, r1
    a5c4:	31 05       	cpc	r19, r1
    a5c6:	49 f4       	brne	.+18     	; 0xa5da <EMeter_Cycle+0x2c6>
																EM_Magnit_Cnt_prev = EM_Magnit_Cnt_new = Temp;
    a5c8:	90 93 26 09 	sts	0x0926, r25
    a5cc:	80 93 25 09 	sts	0x0925, r24
    a5d0:	90 93 da 09 	sts	0x09DA, r25
    a5d4:	80 93 d9 09 	sts	0x09D9, r24
    a5d8:	08 c0       	rjmp	.+16     	; 0xa5ea <EMeter_Cycle+0x2d6>
															}
															else{
																EM_Magnit_Cnt_prev = EM_Magnit_Cnt_new;
    a5da:	30 93 da 09 	sts	0x09DA, r19
    a5de:	20 93 d9 09 	sts	0x09D9, r18
																EM_Magnit_Cnt_new = Temp;								
    a5e2:	90 93 26 09 	sts	0x0926, r25
    a5e6:	80 93 25 09 	sts	0x0925, r24
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_2)){
    a5ea:	80 91 f5 05 	lds	r24, 0x05F5
    a5ee:	87 fd       	sbrc	r24, 7
    a5f0:	37 c0       	rjmp	.+110    	; 0xa660 <EMeter_Cycle+0x34c>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_60_2, flg_OBIS_C_60_2);
    a5f2:	6f e0       	ldi	r22, 0x0F	; 15
    a5f4:	8e e7       	ldi	r24, 0x7E	; 126
    a5f6:	9c e4       	ldi	r25, 0x4C	; 76
    a5f8:	0e 94 d5 50 	call	0xa1aa	; 0xa1aa <EMeter_ZMR110_Read_DWord>
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_2)){
    a5fc:	20 91 f5 05 	lds	r18, 0x05F5
    a600:	27 ff       	sbrs	r18, 7
    a602:	2e c0       	rjmp	.+92     	; 0xa660 <EMeter_Cycle+0x34c>
															if(EM_Magnit_Min_new	 == 0){
    a604:	c0 90 43 09 	lds	r12, 0x0943
    a608:	d0 90 44 09 	lds	r13, 0x0944
    a60c:	e0 90 45 09 	lds	r14, 0x0945
    a610:	f0 90 46 09 	lds	r15, 0x0946
    a614:	c1 14       	cp	r12, r1
    a616:	d1 04       	cpc	r13, r1
    a618:	e1 04       	cpc	r14, r1
    a61a:	f1 04       	cpc	r15, r1
    a61c:	89 f4       	brne	.+34     	; 0xa640 <EMeter_Cycle+0x32c>
																EM_Magnit_Min_prev = EM_Magnit_Min_new = Temp;
    a61e:	60 93 43 09 	sts	0x0943, r22
    a622:	70 93 44 09 	sts	0x0944, r23
    a626:	80 93 45 09 	sts	0x0945, r24
    a62a:	90 93 46 09 	sts	0x0946, r25
    a62e:	60 93 ec 0a 	sts	0x0AEC, r22
    a632:	70 93 ed 0a 	sts	0x0AED, r23
    a636:	80 93 ee 0a 	sts	0x0AEE, r24
    a63a:	90 93 ef 0a 	sts	0x0AEF, r25
    a63e:	10 c0       	rjmp	.+32     	; 0xa660 <EMeter_Cycle+0x34c>
															}
															else{
																EM_Magnit_Min_prev = EM_Magnit_Min_new;
    a640:	c0 92 ec 0a 	sts	0x0AEC, r12
    a644:	d0 92 ed 0a 	sts	0x0AED, r13
    a648:	e0 92 ee 0a 	sts	0x0AEE, r14
    a64c:	f0 92 ef 0a 	sts	0x0AEF, r15
																EM_Magnit_Min_new = Temp;								
    a650:	60 93 43 09 	sts	0x0943, r22
    a654:	70 93 44 09 	sts	0x0944, r23
    a658:	80 93 45 09 	sts	0x0945, r24
    a65c:	90 93 46 09 	sts	0x0946, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a660:	80 91 f6 05 	lds	r24, 0x05F6
															}
														}
													} 

													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_0)){
    a664:	80 fd       	sbrc	r24, 0
    a666:	21 c0       	rjmp	.+66     	; 0xa6aa <EMeter_Cycle+0x396>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_61_0, flg_OBIS_C_61_0);
    a668:	60 e1       	ldi	r22, 0x10	; 16
    a66a:	87 e7       	ldi	r24, 0x77	; 119
    a66c:	9c e4       	ldi	r25, 0x4C	; 76
    a66e:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a672:	20 91 f6 05 	lds	r18, 0x05F6
													} 

													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_0)){
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_61_0, flg_OBIS_C_61_0);
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_0)){
    a676:	20 ff       	sbrs	r18, 0
    a678:	18 c0       	rjmp	.+48     	; 0xa6aa <EMeter_Cycle+0x396>
															if(EM_Klemm_Cnt_new	 == 0){
    a67a:	20 91 0c 06 	lds	r18, 0x060C
    a67e:	30 91 0d 06 	lds	r19, 0x060D
    a682:	21 15       	cp	r18, r1
    a684:	31 05       	cpc	r19, r1
    a686:	49 f4       	brne	.+18     	; 0xa69a <EMeter_Cycle+0x386>
																EM_Klemm_Cnt_prev = EM_Klemm_Cnt_new = Temp;
    a688:	90 93 0d 06 	sts	0x060D, r25
    a68c:	80 93 0c 06 	sts	0x060C, r24
    a690:	90 93 ed 03 	sts	0x03ED, r25
    a694:	80 93 ec 03 	sts	0x03EC, r24
    a698:	08 c0       	rjmp	.+16     	; 0xa6aa <EMeter_Cycle+0x396>
															}
															else{
																EM_Klemm_Cnt_prev = EM_Klemm_Cnt_new;
    a69a:	30 93 ed 03 	sts	0x03ED, r19
    a69e:	20 93 ec 03 	sts	0x03EC, r18
																EM_Klemm_Cnt_new = Temp;								
    a6a2:	90 93 0d 06 	sts	0x060D, r25
    a6a6:	80 93 0c 06 	sts	0x060C, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a6aa:	80 91 f6 05 	lds	r24, 0x05F6
																EM_Klemm_Cnt_prev = EM_Klemm_Cnt_new;
																EM_Klemm_Cnt_new = Temp;								
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_2)){
    a6ae:	81 fd       	sbrc	r24, 1
    a6b0:	37 c0       	rjmp	.+110    	; 0xa720 <EMeter_Cycle+0x40c>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_61_2, flg_OBIS_C_61_2);
    a6b2:	61 e1       	ldi	r22, 0x11	; 17
    a6b4:	80 e7       	ldi	r24, 0x70	; 112
    a6b6:	9c e4       	ldi	r25, 0x4C	; 76
    a6b8:	0e 94 d5 50 	call	0xa1aa	; 0xa1aa <EMeter_ZMR110_Read_DWord>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a6bc:	20 91 f6 05 	lds	r18, 0x05F6
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_2)){
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_61_2, flg_OBIS_C_61_2);
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_2)){
    a6c0:	21 ff       	sbrs	r18, 1
    a6c2:	2e c0       	rjmp	.+92     	; 0xa720 <EMeter_Cycle+0x40c>
															if(EM_Klemm_Min_new	 == 0){
    a6c4:	c0 90 03 0b 	lds	r12, 0x0B03
    a6c8:	d0 90 04 0b 	lds	r13, 0x0B04
    a6cc:	e0 90 05 0b 	lds	r14, 0x0B05
    a6d0:	f0 90 06 0b 	lds	r15, 0x0B06
    a6d4:	c1 14       	cp	r12, r1
    a6d6:	d1 04       	cpc	r13, r1
    a6d8:	e1 04       	cpc	r14, r1
    a6da:	f1 04       	cpc	r15, r1
    a6dc:	89 f4       	brne	.+34     	; 0xa700 <EMeter_Cycle+0x3ec>
																EM_Klemm_Min_prev = EM_Klemm_Min_new = Temp;
    a6de:	60 93 03 0b 	sts	0x0B03, r22
    a6e2:	70 93 04 0b 	sts	0x0B04, r23
    a6e6:	80 93 05 0b 	sts	0x0B05, r24
    a6ea:	90 93 06 0b 	sts	0x0B06, r25
    a6ee:	60 93 d2 09 	sts	0x09D2, r22
    a6f2:	70 93 d3 09 	sts	0x09D3, r23
    a6f6:	80 93 d4 09 	sts	0x09D4, r24
    a6fa:	90 93 d5 09 	sts	0x09D5, r25
    a6fe:	10 c0       	rjmp	.+32     	; 0xa720 <EMeter_Cycle+0x40c>
															}
															else{
																EM_Klemm_Min_prev = EM_Klemm_Min_new;
    a700:	c0 92 d2 09 	sts	0x09D2, r12
    a704:	d0 92 d3 09 	sts	0x09D3, r13
    a708:	e0 92 d4 09 	sts	0x09D4, r14
    a70c:	f0 92 d5 09 	sts	0x09D5, r15
																EM_Klemm_Min_new = Temp;								
    a710:	60 93 03 0b 	sts	0x0B03, r22
    a714:	70 93 04 0b 	sts	0x0B04, r23
    a718:	80 93 05 0b 	sts	0x0B05, r24
    a71c:	90 93 06 0b 	sts	0x0B06, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a720:	80 91 f6 05 	lds	r24, 0x05F6
																EM_Klemm_Min_new = Temp;								
															}
														}
													} 
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_0)){
    a724:	82 fd       	sbrc	r24, 2
    a726:	21 c0       	rjmp	.+66     	; 0xa76a <EMeter_Cycle+0x456>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_62_0, flg_OBIS_C_62_0);
    a728:	62 e1       	ldi	r22, 0x12	; 18
    a72a:	89 e6       	ldi	r24, 0x69	; 105
    a72c:	9c e4       	ldi	r25, 0x4C	; 76
    a72e:	0e 94 6e 4f 	call	0x9edc	; 0x9edc <EMeter_ZMR110_Read_Word>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a732:	20 91 f6 05 	lds	r18, 0x05F6
														}
													} 
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_0)){
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_62_0, flg_OBIS_C_62_0);
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_0)){
    a736:	22 ff       	sbrs	r18, 2
    a738:	18 c0       	rjmp	.+48     	; 0xa76a <EMeter_Cycle+0x456>
															if(EM_Korpus_Cnt_new	 == 0){
    a73a:	20 91 fd 0a 	lds	r18, 0x0AFD
    a73e:	30 91 fe 0a 	lds	r19, 0x0AFE
    a742:	21 15       	cp	r18, r1
    a744:	31 05       	cpc	r19, r1
    a746:	49 f4       	brne	.+18     	; 0xa75a <EMeter_Cycle+0x446>
																EM_Korpus_Cnt_prev = EM_Korpus_Cnt_new = Temp;
    a748:	90 93 fe 0a 	sts	0x0AFE, r25
    a74c:	80 93 fd 0a 	sts	0x0AFD, r24
    a750:	90 93 26 0d 	sts	0x0D26, r25
    a754:	80 93 25 0d 	sts	0x0D25, r24
    a758:	08 c0       	rjmp	.+16     	; 0xa76a <EMeter_Cycle+0x456>
															}
															else{
																EM_Korpus_Cnt_prev = EM_Korpus_Cnt_new;
    a75a:	30 93 26 0d 	sts	0x0D26, r19
    a75e:	20 93 25 0d 	sts	0x0D25, r18
																EM_Korpus_Cnt_new = Temp;								
    a762:	90 93 fe 0a 	sts	0x0AFE, r25
    a766:	80 93 fd 0a 	sts	0x0AFD, r24

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a76a:	80 91 f6 05 	lds	r24, 0x05F6
																EM_Korpus_Cnt_prev = EM_Korpus_Cnt_new;
																EM_Korpus_Cnt_new = Temp;								
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_2)){
    a76e:	83 fd       	sbrc	r24, 3
    a770:	37 c0       	rjmp	.+110    	; 0xa7e0 <EMeter_Cycle+0x4cc>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_62_2, flg_OBIS_C_62_2);
    a772:	63 e1       	ldi	r22, 0x13	; 19
    a774:	82 e6       	ldi	r24, 0x62	; 98
    a776:	9c e4       	ldi	r25, 0x4C	; 76
    a778:	0e 94 d5 50 	call	0xa1aa	; 0xa1aa <EMeter_ZMR110_Read_DWord>

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a77c:	20 91 f6 05 	lds	r18, 0x05F6
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_2)){
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_62_2, flg_OBIS_C_62_2);
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_2)){
    a780:	23 ff       	sbrs	r18, 3
    a782:	2e c0       	rjmp	.+92     	; 0xa7e0 <EMeter_Cycle+0x4cc>
															if(EM_Korpus_Min_new	 == 0){
    a784:	c0 90 e3 03 	lds	r12, 0x03E3
    a788:	d0 90 e4 03 	lds	r13, 0x03E4
    a78c:	e0 90 e5 03 	lds	r14, 0x03E5
    a790:	f0 90 e6 03 	lds	r15, 0x03E6
    a794:	c1 14       	cp	r12, r1
    a796:	d1 04       	cpc	r13, r1
    a798:	e1 04       	cpc	r14, r1
    a79a:	f1 04       	cpc	r15, r1
    a79c:	89 f4       	brne	.+34     	; 0xa7c0 <EMeter_Cycle+0x4ac>
																EM_Korpus_Min_prev = EM_Korpus_Min_new = Temp;
    a79e:	60 93 e3 03 	sts	0x03E3, r22
    a7a2:	70 93 e4 03 	sts	0x03E4, r23
    a7a6:	80 93 e5 03 	sts	0x03E5, r24
    a7aa:	90 93 e6 03 	sts	0x03E6, r25
    a7ae:	60 93 08 06 	sts	0x0608, r22
    a7b2:	70 93 09 06 	sts	0x0609, r23
    a7b6:	80 93 0a 06 	sts	0x060A, r24
    a7ba:	90 93 0b 06 	sts	0x060B, r25
    a7be:	10 c0       	rjmp	.+32     	; 0xa7e0 <EMeter_Cycle+0x4cc>
															}
															else{
																EM_Korpus_Min_prev = EM_Korpus_Min_new;
    a7c0:	c0 92 08 06 	sts	0x0608, r12
    a7c4:	d0 92 09 06 	sts	0x0609, r13
    a7c8:	e0 92 0a 06 	sts	0x060A, r14
    a7cc:	f0 92 0b 06 	sts	0x060B, r15
																EM_Korpus_Min_new = Temp;								
    a7d0:	60 93 e3 03 	sts	0x03E3, r22
    a7d4:	70 93 e4 03 	sts	0x03E4, r23
    a7d8:	80 93 e5 03 	sts	0x03E5, r24
    a7dc:	90 93 e6 03 	sts	0x03E6, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a7e0:	80 91 f6 05 	lds	r24, 0x05F6
															}
														}
													} 
													//-----

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_F_F_0)) 
    a7e4:	84 fd       	sbrc	r24, 4
    a7e6:	0d c0       	rjmp	.+26     	; 0xa802 <EMeter_Cycle+0x4ee>
														EM_FailCode = EMeter_ZMR110_Read_DWord(EM_RESP_F_F_0, flg_OBIS_F_F_0);
    a7e8:	64 e1       	ldi	r22, 0x14	; 20
    a7ea:	86 e5       	ldi	r24, 0x56	; 86
    a7ec:	9c e4       	ldi	r25, 0x4C	; 76
    a7ee:	0e 94 d5 50 	call	0xa1aa	; 0xa1aa <EMeter_ZMR110_Read_DWord>
    a7f2:	60 93 38 09 	sts	0x0938, r22
    a7f6:	70 93 39 09 	sts	0x0939, r23
    a7fa:	80 93 3a 09 	sts	0x093A, r24
    a7fe:	90 93 3b 09 	sts	0x093B, r25

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
    a802:	80 91 f6 05 	lds	r24, 0x05F6
													} 
													//-----

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_F_F_0)) 
														EM_FailCode = EMeter_ZMR110_Read_DWord(EM_RESP_F_F_0, flg_OBIS_F_F_0);
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_0_0)) 
    a806:	85 fd       	sbrc	r24, 5
    a808:	05 c0       	rjmp	.+10     	; 0xa814 <EMeter_Cycle+0x500>
														EMeter_ZMR110_Read_ID1_1(EM_RESP_0_0_0, flg_OBIS_0_0_0);
    a80a:	65 e1       	ldi	r22, 0x15	; 21
    a80c:	8c e5       	ldi	r24, 0x5C	; 92
    a80e:	9c e4       	ldi	r25, 0x4C	; 76
    a810:	0e 94 3b 51 	call	0xa276	; 0xa276 <EMeter_ZMR110_Read_ID1_1>

													/*
													if(p >= EMeter_RxStr + EM_RX_SIZE - LG_ZMR110_MAX_STR) EMeter_RxStr_Offset = EMeter_RxStr;
													else EMeter_RxStr_Offset = p+1;
													*/
													cli();
    a814:	f8 94       	cli
													{
														EMeter_RxStr_Offset = p+1;
													}
													*/

												if(EM_HalfBufferStart==EMeter_RxStr)
    a816:	80 91 6b 09 	lds	r24, 0x096B
    a81a:	90 91 6c 09 	lds	r25, 0x096C
    a81e:	8e 52       	subi	r24, 0x2E	; 46
    a820:	97 40       	sbci	r25, 0x07	; 7
    a822:	49 f4       	brne	.+18     	; 0xa836 <EMeter_Cycle+0x522>
													{
														if((p >= (EMeter_RxStr + EM_RX_SIZE/2 - LG_ZMR110_MAX_STR))&&(p<&EMeter_RxStr[EM_RX_SIZE/2]))
    a824:	e7 e0       	ldi	r30, 0x07	; 7
    a826:	0f 38       	cpi	r16, 0x8F	; 143
    a828:	1e 07       	cpc	r17, r30
    a82a:	80 f0       	brcs	.+32     	; 0xa84c <EMeter_Cycle+0x538>
    a82c:	f7 e0       	ldi	r31, 0x07	; 7
    a82e:	0d 3a       	cpi	r16, 0xAD	; 173
    a830:	1f 07       	cpc	r17, r31
    a832:	60 f4       	brcc	.+24     	; 0xa84c <EMeter_Cycle+0x538>
    a834:	08 c0       	rjmp	.+16     	; 0xa846 <EMeter_Cycle+0x532>
															}
				
													}
												else
													{								
														if((p >= (EMeter_RxStr + EM_RX_SIZE - LG_ZMR110_MAX_STR))&&(p<&EMeter_RxStr[EM_RX_SIZE]))
    a836:	28 e0       	ldi	r18, 0x08	; 8
    a838:	0e 30       	cpi	r16, 0x0E	; 14
    a83a:	12 07       	cpc	r17, r18
    a83c:	38 f0       	brcs	.+14     	; 0xa84c <EMeter_Cycle+0x538>
    a83e:	88 e0       	ldi	r24, 0x08	; 8
    a840:	0c 32       	cpi	r16, 0x2C	; 44
    a842:	18 07       	cpc	r17, r24
    a844:	18 f4       	brcc	.+6      	; 0xa84c <EMeter_Cycle+0x538>
															{
																EM_BufferReadEnable=0;				
    a846:	10 92 36 09 	sts	0x0936, r1
    a84a:	06 c0       	rjmp	.+12     	; 0xa858 <EMeter_Cycle+0x544>
															}
														else
															{
																EMeter_RxStr_Offset = p+1;
    a84c:	0f 5f       	subi	r16, 0xFF	; 255
    a84e:	1f 4f       	sbci	r17, 0xFF	; 255
    a850:	10 93 fb 05 	sts	0x05FB, r17
    a854:	00 93 fa 05 	sts	0x05FA, r16
															}	
													}
													sei();
    a858:	78 94       	sei

												}
					}

					 //check EM link
					if(Timer16Stopp(TD_EMeter)){
    a85a:	80 91 1b 0c 	lds	r24, 0x0C1B
    a85e:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    a862:	88 23       	and	r24, r24
    a864:	61 f1       	breq	.+88     	; 0xa8be <EMeter_Cycle+0x5aa>
    a866:	e4 ef       	ldi	r30, 0xF4	; 244
    a868:	f5 e0       	ldi	r31, 0x05	; 5
    a86a:	80 e0       	ldi	r24, 0x00	; 0
						
						uint8_t read_flag = 0;
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) 
							if(LG_ZMR110_READ_FLAG[i]) read_flag = 1;
    a86c:	91 91       	ld	r25, Z+
    a86e:	91 11       	cpse	r25, r1
    a870:	81 e0       	ldi	r24, 0x01	; 1

					 //check EM link
					if(Timer16Stopp(TD_EMeter)){
						
						uint8_t read_flag = 0;
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) 
    a872:	95 e0       	ldi	r25, 0x05	; 5
    a874:	e8 3f       	cpi	r30, 0xF8	; 248
    a876:	f9 07       	cpc	r31, r25
    a878:	c9 f7       	brne	.-14     	; 0xa86c <EMeter_Cycle+0x558>
							if(LG_ZMR110_READ_FLAG[i]) read_flag = 1;
						if(read_flag){
    a87a:	88 23       	and	r24, r24
    a87c:	19 f0       	breq	.+6      	; 0xa884 <EMeter_Cycle+0x570>
							EM_Retry = 0;
    a87e:	10 92 05 01 	sts	0x0105, r1
    a882:	05 c0       	rjmp	.+10     	; 0xa88e <EMeter_Cycle+0x57a>
						}
						else{
							EMeter_NoLink();
    a884:	0e 94 15 4e 	call	0x9c2a	; 0x9c2a <EMeter_NoLink>
							EM_Retry = 1;
    a888:	81 e0       	ldi	r24, 0x01	; 1
    a88a:	80 93 05 01 	sts	0x0105, r24
						}
						EM_Mode = 255;
    a88e:	8f ef       	ldi	r24, 0xFF	; 255
    a890:	80 93 55 0a 	sts	0x0A55, r24
    a894:	14 c0       	rjmp	.+40     	; 0xa8be <EMeter_Cycle+0x5aa>
				case 255:
					//      
					break;
			
				default: 
					if(Timer16Stopp(TD_EMeter)){
    a896:	80 91 1b 0c 	lds	r24, 0x0C1B
    a89a:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    a89e:	88 23       	and	r24, r24
    a8a0:	71 f0       	breq	.+28     	; 0xa8be <EMeter_Cycle+0x5aa>
						EMeter_ClearRXStr();
    a8a2:	0e 94 03 4e 	call	0x9c06	; 0x9c06 <EMeter_ClearRXStr>
						EMeter_SendCR(EM_REQ);
    a8a6:	82 e5       	ldi	r24, 0x52	; 82
    a8a8:	9c e4       	ldi	r25, 0x4C	; 76
    a8aa:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
						//StartTimer16(TD_EMeter,200);	//TODO  ?
						//StartTimer16(TD_EMeter,230);	//TODO  ?
						StartTimer16(TD_EMeter,170);	//TODO  ?
    a8ae:	6a ea       	ldi	r22, 0xAA	; 170
    a8b0:	70 e0       	ldi	r23, 0x00	; 0
    a8b2:	80 91 1b 0c 	lds	r24, 0x0C1B
    a8b6:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					//	StartTimer16(TD_EMeter,100);	//TODO  ?
						EM_Mode = 1;
    a8ba:	10 93 55 0a 	sts	0x0A55, r17
    a8be:	89 e2       	ldi	r24, 0x29	; 41
    a8c0:	90 e0       	ldi	r25, 0x00	; 0
    a8c2:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    a8c6:	18 2f       	mov	r17, r24
					break;
			}		
		}

		//--- 
		if(erb(&EMeterType) == ELVIN){
    a8c8:	82 30       	cpi	r24, 0x02	; 2
    a8ca:	09 f0       	breq	.+2      	; 0xa8ce <EMeter_Cycle+0x5ba>
    a8cc:	5c c1       	rjmp	.+696    	; 0xab86 <EMeter_Cycle+0x872>
			switch(EM_Mode){
    a8ce:	90 91 55 0a 	lds	r25, 0x0A55
    a8d2:	92 30       	cpi	r25, 0x02	; 2
    a8d4:	d1 f0       	breq	.+52     	; 0xa90a <EMeter_Cycle+0x5f6>
    a8d6:	9f 3f       	cpi	r25, 0xFF	; 255
    a8d8:	09 f4       	brne	.+2      	; 0xa8dc <EMeter_Cycle+0x5c8>
    a8da:	55 c1       	rjmp	.+682    	; 0xab86 <EMeter_Cycle+0x872>
	
				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    a8dc:	80 91 1b 0c 	lds	r24, 0x0C1B
			}		
		}

		//--- 
		if(erb(&EMeterType) == ELVIN){
			switch(EM_Mode){
    a8e0:	91 30       	cpi	r25, 0x01	; 1
    a8e2:	09 f0       	breq	.+2      	; 0xa8e6 <EMeter_Cycle+0x5d2>
    a8e4:	3f c1       	rjmp	.+638    	; 0xab64 <EMeter_Cycle+0x850>
	
				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    a8e6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    a8ea:	88 23       	and	r24, r24
    a8ec:	09 f4       	brne	.+2      	; 0xa8f0 <EMeter_Cycle+0x5dc>
    a8ee:	4b c1       	rjmp	.+662    	; 0xab86 <EMeter_Cycle+0x872>
						EMeter_SendCR(EM_READ_DATA_REQ);
    a8f0:	8d e4       	ldi	r24, 0x4D	; 77
    a8f2:	9c e4       	ldi	r25, 0x4C	; 76
    a8f4:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
						StartTimer16(TD_EMeter,100);
    a8f8:	64 e6       	ldi	r22, 0x64	; 100
    a8fa:	70 e0       	ldi	r23, 0x00	; 0
    a8fc:	80 91 1b 0c 	lds	r24, 0x0C1B
    a900:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 2;
    a904:	10 93 55 0a 	sts	0x0A55, r17
    a908:	3e c1       	rjmp	.+636    	; 0xab86 <EMeter_Cycle+0x872>
					}
					break;
				case 2:
					if(Timer16Stopp(TD_EMeter)){	
    a90a:	80 91 1b 0c 	lds	r24, 0x0C1B
    a90e:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    a912:	88 23       	and	r24, r24
    a914:	09 f4       	brne	.+2      	; 0xa918 <EMeter_Cycle+0x604>
    a916:	37 c1       	rjmp	.+622    	; 0xab86 <EMeter_Cycle+0x872>
				
						 //read data

						// check frame
						if(EMeter_RxCharN != 40){
    a918:	80 91 21 0d 	lds	r24, 0x0D21
    a91c:	90 91 22 0d 	lds	r25, 0x0D22
    a920:	88 97       	sbiw	r24, 0x28	; 40
    a922:	19 f0       	breq	.+6      	; 0xa92a <EMeter_Cycle+0x616>
							EMeter_NoLink();
    a924:	0e 94 15 4e 	call	0x9c2a	; 0x9c2a <EMeter_NoLink>
    a928:	2e c1       	rjmp	.+604    	; 0xab86 <EMeter_Cycle+0x872>
    a92a:	ef e2       	ldi	r30, 0x2F	; 47
    a92c:	f7 e0       	ldi	r31, 0x07	; 7
					if(Timer16Stopp(TD_EMeter)){	
				
						 //read data

						// check frame
						if(EMeter_RxCharN != 40){
    a92e:	90 e0       	ldi	r25, 0x00	; 0
							EMeter_NoLink();
							break;
						}
						EM_BCC = 0;
						for(uint8_t i=1; i<39; i++) EM_BCC += EMeter_RxStr[i];
    a930:	81 91       	ld	r24, Z+
    a932:	89 0f       	add	r24, r25
    a934:	a7 e0       	ldi	r26, 0x07	; 7
    a936:	e5 35       	cpi	r30, 0x55	; 85
    a938:	fa 07       	cpc	r31, r26
    a93a:	11 f0       	breq	.+4      	; 0xa940 <EMeter_Cycle+0x62c>
    a93c:	98 2f       	mov	r25, r24
    a93e:	f8 cf       	rjmp	.-16     	; 0xa930 <EMeter_Cycle+0x61c>
						EM_BCC &= 0b01111111;
    a940:	8f 77       	andi	r24, 0x7F	; 127
    a942:	80 93 3d 09 	sts	0x093D, r24
						if(EM_BCC != EMeter_RxStr[39]){
    a946:	90 91 55 07 	lds	r25, 0x0755
    a94a:	89 13       	cpse	r24, r25
    a94c:	eb cf       	rjmp	.-42     	; 0xa924 <EMeter_Cycle+0x610>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x02 || EMeter_RxStr[1]!='(' || EMeter_RxStr[34] != ')' || EMeter_RxStr[35] != '!' ||
    a94e:	80 91 2e 07 	lds	r24, 0x072E
    a952:	82 30       	cpi	r24, 0x02	; 2
    a954:	39 f7       	brne	.-50     	; 0xa924 <EMeter_Cycle+0x610>
    a956:	80 91 2f 07 	lds	r24, 0x072F
    a95a:	88 32       	cpi	r24, 0x28	; 40
    a95c:	19 f7       	brne	.-58     	; 0xa924 <EMeter_Cycle+0x610>
    a95e:	80 91 50 07 	lds	r24, 0x0750
    a962:	89 32       	cpi	r24, 0x29	; 41
    a964:	f9 f6       	brne	.-66     	; 0xa924 <EMeter_Cycle+0x610>
    a966:	80 91 51 07 	lds	r24, 0x0751
    a96a:	81 32       	cpi	r24, 0x21	; 33
    a96c:	d9 f6       	brne	.-74     	; 0xa924 <EMeter_Cycle+0x610>
    a96e:	80 91 52 07 	lds	r24, 0x0752
    a972:	8d 30       	cpi	r24, 0x0D	; 13
    a974:	b9 f6       	brne	.-82     	; 0xa924 <EMeter_Cycle+0x610>
							EMeter_RxStr[36] != '\r' || EMeter_RxStr[37] != '\n'|| EMeter_RxStr[38] != 0x03){
    a976:	80 91 53 07 	lds	r24, 0x0753
    a97a:	8a 30       	cpi	r24, 0x0A	; 10
    a97c:	99 f6       	brne	.-90     	; 0xa924 <EMeter_Cycle+0x610>
    a97e:	80 91 54 07 	lds	r24, 0x0754
    a982:	83 30       	cpi	r24, 0x03	; 3
    a984:	79 f6       	brne	.-98     	; 0xa924 <EMeter_Cycle+0x610>
							EMeter_NoLink();
							break;
						}
						//process data
						char TempStr[11];
						TempStr[0] = '0';
    a986:	80 e3       	ldi	r24, 0x30	; 48
    a988:	89 83       	std	Y+1, r24	; 0x01
						TempStr[1] = 'x';
    a98a:	88 e7       	ldi	r24, 0x78	; 120
    a98c:	8a 83       	std	Y+2, r24	; 0x02
						TempStr[10] = 0;
    a98e:	1b 86       	std	Y+11, r1	; 0x0b

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    a990:	80 91 36 07 	lds	r24, 0x0736
    a994:	8b 83       	std	Y+3, r24	; 0x03
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    a996:	80 91 37 07 	lds	r24, 0x0737
    a99a:	8c 83       	std	Y+4, r24	; 0x04
						TempStr[1] = 'x';
						TempStr[10] = 0;

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    a99c:	80 91 34 07 	lds	r24, 0x0734
    a9a0:	8d 83       	std	Y+5, r24	; 0x05
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    a9a2:	80 91 35 07 	lds	r24, 0x0735
    a9a6:	8e 83       	std	Y+6, r24	; 0x06
						TempStr[1] = 'x';
						TempStr[10] = 0;

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    a9a8:	80 91 32 07 	lds	r24, 0x0732
    a9ac:	8f 83       	std	Y+7, r24	; 0x07
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    a9ae:	80 91 33 07 	lds	r24, 0x0733
    a9b2:	88 87       	std	Y+8, r24	; 0x08
						TempStr[1] = 'x';
						TempStr[10] = 0;

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    a9b4:	80 91 30 07 	lds	r24, 0x0730
    a9b8:	89 87       	std	Y+9, r24	; 0x09
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    a9ba:	80 91 31 07 	lds	r24, 0x0731
    a9be:	8a 87       	std	Y+10, r24	; 0x0a
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
    a9c0:	8e e3       	ldi	r24, 0x3E	; 62
    a9c2:	92 e0       	ldi	r25, 0x02	; 2
    a9c4:	9f 93       	push	r25
    a9c6:	8f 93       	push	r24
    a9c8:	ed ea       	ldi	r30, 0xAD	; 173
    a9ca:	ee 2e       	mov	r14, r30
    a9cc:	e1 e0       	ldi	r30, 0x01	; 1
    a9ce:	fe 2e       	mov	r15, r30
    a9d0:	ff 92       	push	r15
    a9d2:	ef 92       	push	r14
    a9d4:	8e 01       	movw	r16, r28
    a9d6:	0f 5f       	subi	r16, 0xFF	; 255
    a9d8:	1f 4f       	sbci	r17, 0xFF	; 255
    a9da:	1f 93       	push	r17
    a9dc:	0f 93       	push	r16
    a9de:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
						E_Meter_RAM.Ap *=10;
    a9e2:	20 91 3e 02 	lds	r18, 0x023E
    a9e6:	30 91 3f 02 	lds	r19, 0x023F
    a9ea:	40 91 40 02 	lds	r20, 0x0240
    a9ee:	50 91 41 02 	lds	r21, 0x0241
    a9f2:	aa e0       	ldi	r26, 0x0A	; 10
    a9f4:	b0 e0       	ldi	r27, 0x00	; 0
    a9f6:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    a9fa:	60 93 3e 02 	sts	0x023E, r22
    a9fe:	70 93 3f 02 	sts	0x023F, r23
    aa02:	80 93 40 02 	sts	0x0240, r24
    aa06:	90 93 41 02 	sts	0x0241, r25
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa0a:	80 91 3e 07 	lds	r24, 0x073E
    aa0e:	8b 83       	std	Y+3, r24	; 0x03
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa10:	80 91 3f 07 	lds	r24, 0x073F
    aa14:	8c 83       	std	Y+4, r24	; 0x04
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
						E_Meter_RAM.Ap *=10;
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa16:	80 91 3c 07 	lds	r24, 0x073C
    aa1a:	8d 83       	std	Y+5, r24	; 0x05
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa1c:	80 91 3d 07 	lds	r24, 0x073D
    aa20:	8e 83       	std	Y+6, r24	; 0x06
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
						E_Meter_RAM.Ap *=10;
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa22:	80 91 3a 07 	lds	r24, 0x073A
    aa26:	8f 83       	std	Y+7, r24	; 0x07
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa28:	80 91 3b 07 	lds	r24, 0x073B
    aa2c:	88 87       	std	Y+8, r24	; 0x08
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
						E_Meter_RAM.Ap *=10;
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa2e:	80 91 38 07 	lds	r24, 0x0738
    aa32:	89 87       	std	Y+9, r24	; 0x09
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa34:	80 91 39 07 	lds	r24, 0x0739
    aa38:	8a 87       	std	Y+10, r24	; 0x0a
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
    aa3a:	82 e4       	ldi	r24, 0x42	; 66
    aa3c:	92 e0       	ldi	r25, 0x02	; 2
    aa3e:	9f 93       	push	r25
    aa40:	8f 93       	push	r24
    aa42:	ff 92       	push	r15
    aa44:	ef 92       	push	r14
    aa46:	1f 93       	push	r17
    aa48:	0f 93       	push	r16
    aa4a:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
						E_Meter_RAM.Am *=10;
    aa4e:	20 91 42 02 	lds	r18, 0x0242
    aa52:	30 91 43 02 	lds	r19, 0x0243
    aa56:	40 91 44 02 	lds	r20, 0x0244
    aa5a:	50 91 45 02 	lds	r21, 0x0245
    aa5e:	aa e0       	ldi	r26, 0x0A	; 10
    aa60:	b0 e0       	ldi	r27, 0x00	; 0
    aa62:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    aa66:	60 93 42 02 	sts	0x0242, r22
    aa6a:	70 93 43 02 	sts	0x0243, r23
    aa6e:	80 93 44 02 	sts	0x0244, r24
    aa72:	90 93 45 02 	sts	0x0245, r25
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa76:	80 91 46 07 	lds	r24, 0x0746
    aa7a:	8b 83       	std	Y+3, r24	; 0x03
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa7c:	80 91 47 07 	lds	r24, 0x0747
    aa80:	8c 83       	std	Y+4, r24	; 0x04
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
						E_Meter_RAM.Am *=10;
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa82:	80 91 44 07 	lds	r24, 0x0744
    aa86:	8d 83       	std	Y+5, r24	; 0x05
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa88:	80 91 45 07 	lds	r24, 0x0745
    aa8c:	8e 83       	std	Y+6, r24	; 0x06
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
						E_Meter_RAM.Am *=10;
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa8e:	80 91 42 07 	lds	r24, 0x0742
    aa92:	8f 83       	std	Y+7, r24	; 0x07
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aa94:	80 91 43 07 	lds	r24, 0x0743
    aa98:	88 87       	std	Y+8, r24	; 0x08
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
						E_Meter_RAM.Am *=10;
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aa9a:	80 91 40 07 	lds	r24, 0x0740
    aa9e:	89 87       	std	Y+9, r24	; 0x09
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aaa0:	80 91 41 07 	lds	r24, 0x0741
    aaa4:	8a 87       	std	Y+10, r24	; 0x0a
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
    aaa6:	86 e4       	ldi	r24, 0x46	; 70
    aaa8:	92 e0       	ldi	r25, 0x02	; 2
    aaaa:	9f 93       	push	r25
    aaac:	8f 93       	push	r24
    aaae:	ff 92       	push	r15
    aab0:	ef 92       	push	r14
    aab2:	1f 93       	push	r17
    aab4:	0f 93       	push	r16
    aab6:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
						E_Meter_RAM.Rp *=10;
    aaba:	20 91 46 02 	lds	r18, 0x0246
    aabe:	30 91 47 02 	lds	r19, 0x0247
    aac2:	40 91 48 02 	lds	r20, 0x0248
    aac6:	50 91 49 02 	lds	r21, 0x0249
    aaca:	aa e0       	ldi	r26, 0x0A	; 10
    aacc:	b0 e0       	ldi	r27, 0x00	; 0
    aace:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    aad2:	60 93 46 02 	sts	0x0246, r22
    aad6:	70 93 47 02 	sts	0x0247, r23
    aada:	80 93 48 02 	sts	0x0248, r24
    aade:	90 93 49 02 	sts	0x0249, r25
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aae2:	80 91 4e 07 	lds	r24, 0x074E
    aae6:	8b 83       	std	Y+3, r24	; 0x03
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aae8:	80 91 4f 07 	lds	r24, 0x074F
    aaec:	8c 83       	std	Y+4, r24	; 0x04
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
						E_Meter_RAM.Rp *=10;
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aaee:	80 91 4c 07 	lds	r24, 0x074C
    aaf2:	8d 83       	std	Y+5, r24	; 0x05
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    aaf4:	80 91 4d 07 	lds	r24, 0x074D
    aaf8:	8e 83       	std	Y+6, r24	; 0x06
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
						E_Meter_RAM.Rp *=10;
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    aafa:	80 91 4a 07 	lds	r24, 0x074A
    aafe:	8f 83       	std	Y+7, r24	; 0x07
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    ab00:	80 91 4b 07 	lds	r24, 0x074B
    ab04:	88 87       	std	Y+8, r24	; 0x08
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
						E_Meter_RAM.Rp *=10;
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    ab06:	80 91 48 07 	lds	r24, 0x0748
    ab0a:	89 87       	std	Y+9, r24	; 0x09
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    ab0c:	80 91 49 07 	lds	r24, 0x0749
    ab10:	8a 87       	std	Y+10, r24	; 0x0a
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rm);
    ab12:	8a e4       	ldi	r24, 0x4A	; 74
    ab14:	92 e0       	ldi	r25, 0x02	; 2
    ab16:	9f 93       	push	r25
    ab18:	8f 93       	push	r24
    ab1a:	ff 92       	push	r15
    ab1c:	ef 92       	push	r14
    ab1e:	1f 93       	push	r17
    ab20:	0f 93       	push	r16
    ab22:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
						E_Meter_RAM.Rm *=10;
    ab26:	20 91 4a 02 	lds	r18, 0x024A
    ab2a:	30 91 4b 02 	lds	r19, 0x024B
    ab2e:	40 91 4c 02 	lds	r20, 0x024C
    ab32:	50 91 4d 02 	lds	r21, 0x024D
    ab36:	aa e0       	ldi	r26, 0x0A	; 10
    ab38:	b0 e0       	ldi	r27, 0x00	; 0
    ab3a:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    ab3e:	60 93 4a 02 	sts	0x024A, r22
    ab42:	70 93 4b 02 	sts	0x024B, r23
    ab46:	80 93 4c 02 	sts	0x024C, r24
    ab4a:	90 93 4d 02 	sts	0x024D, r25
				
						//StartTimer16(TD_EMeter,1000);
						EM_Retry = 0;
    ab4e:	10 92 05 01 	sts	0x0105, r1
						EM_Mode = 255;
    ab52:	8f ef       	ldi	r24, 0xFF	; 255
    ab54:	80 93 55 0a 	sts	0x0A55, r24
    ab58:	0f b6       	in	r0, 0x3f	; 63
    ab5a:	f8 94       	cli
    ab5c:	de bf       	out	0x3e, r29	; 62
    ab5e:	0f be       	out	0x3f, r0	; 63
    ab60:	cd bf       	out	0x3d, r28	; 61
    ab62:	11 c0       	rjmp	.+34     	; 0xab86 <EMeter_Cycle+0x872>
					break;
				case 255:
					//      
					break;
				default: 
					if(Timer16Stopp(TD_EMeter)){
    ab64:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ab68:	88 23       	and	r24, r24
    ab6a:	69 f0       	breq	.+26     	; 0xab86 <EMeter_Cycle+0x872>
						EMeter_SendCR(EM_REQ);
    ab6c:	82 e5       	ldi	r24, 0x52	; 82
    ab6e:	9c e4       	ldi	r25, 0x4C	; 76
    ab70:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
						StartTimer16(TD_EMeter,100);
    ab74:	64 e6       	ldi	r22, 0x64	; 100
    ab76:	70 e0       	ldi	r23, 0x00	; 0
    ab78:	80 91 1b 0c 	lds	r24, 0x0C1B
    ab7c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 1;
    ab80:	81 e0       	ldi	r24, 0x01	; 1
    ab82:	80 93 55 0a 	sts	0x0A55, r24
    ab86:	89 e2       	ldi	r24, 0x29	; 41
    ab88:	90 e0       	ldi	r25, 0x00	; 0
    ab8a:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    ab8e:	18 2f       	mov	r17, r24
					break;
			}
		}

		// ---  230
		if(erb(&EMeterType) == MERCURY_230){
    ab90:	83 30       	cpi	r24, 0x03	; 3
    ab92:	09 f0       	breq	.+2      	; 0xab96 <EMeter_Cycle+0x882>
    ab94:	c3 c1       	rjmp	.+902    	; 0xaf1c <EMeter_Cycle+0xc08>
			switch(EM_Mode){
    ab96:	80 91 55 0a 	lds	r24, 0x0A55
    ab9a:	85 30       	cpi	r24, 0x05	; 5
    ab9c:	09 f4       	brne	.+2      	; 0xaba0 <EMeter_Cycle+0x88c>
    ab9e:	f9 c0       	rjmp	.+498    	; 0xad92 <EMeter_Cycle+0xa7e>
    aba0:	68 f4       	brcc	.+26     	; 0xabbc <EMeter_Cycle+0x8a8>
    aba2:	82 30       	cpi	r24, 0x02	; 2
    aba4:	59 f1       	breq	.+86     	; 0xabfc <EMeter_Cycle+0x8e8>
    aba6:	18 f4       	brcc	.+6      	; 0xabae <EMeter_Cycle+0x89a>
    aba8:	81 30       	cpi	r24, 0x01	; 1
    abaa:	a1 f0       	breq	.+40     	; 0xabd4 <EMeter_Cycle+0x8c0>
    abac:	a3 c1       	rjmp	.+838    	; 0xaef4 <EMeter_Cycle+0xbe0>
    abae:	83 30       	cpi	r24, 0x03	; 3
    abb0:	09 f4       	brne	.+2      	; 0xabb4 <EMeter_Cycle+0x8a0>
    abb2:	87 c0       	rjmp	.+270    	; 0xacc2 <EMeter_Cycle+0x9ae>
    abb4:	84 30       	cpi	r24, 0x04	; 4
    abb6:	09 f4       	brne	.+2      	; 0xabba <EMeter_Cycle+0x8a6>
    abb8:	98 c0       	rjmp	.+304    	; 0xacea <EMeter_Cycle+0x9d6>
    abba:	9c c1       	rjmp	.+824    	; 0xaef4 <EMeter_Cycle+0xbe0>
    abbc:	87 30       	cpi	r24, 0x07	; 7
    abbe:	09 f4       	brne	.+2      	; 0xabc2 <EMeter_Cycle+0x8ae>
    abc0:	50 c1       	rjmp	.+672    	; 0xae62 <EMeter_Cycle+0xb4e>
    abc2:	08 f4       	brcc	.+2      	; 0xabc6 <EMeter_Cycle+0x8b2>
    abc4:	fa c0       	rjmp	.+500    	; 0xadba <EMeter_Cycle+0xaa6>
    abc6:	88 30       	cpi	r24, 0x08	; 8
    abc8:	09 f4       	brne	.+2      	; 0xabcc <EMeter_Cycle+0x8b8>
    abca:	5f c1       	rjmp	.+702    	; 0xae8a <EMeter_Cycle+0xb76>
    abcc:	8f 3f       	cpi	r24, 0xFF	; 255
    abce:	09 f4       	brne	.+2      	; 0xabd2 <EMeter_Cycle+0x8be>
    abd0:	a5 c1       	rjmp	.+842    	; 0xaf1c <EMeter_Cycle+0xc08>
    abd2:	90 c1       	rjmp	.+800    	; 0xaef4 <EMeter_Cycle+0xbe0>

				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    abd4:	80 91 1b 0c 	lds	r24, 0x0C1B
    abd8:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    abdc:	88 23       	and	r24, r24
    abde:	09 f4       	brne	.+2      	; 0xabe2 <EMeter_Cycle+0x8ce>
    abe0:	9d c1       	rjmp	.+826    	; 0xaf1c <EMeter_Cycle+0xc08>
						EMeter_SendData_P(EM_ENERGY_REQ, sizeof(EM_ENERGY_REQ));
    abe2:	66 e0       	ldi	r22, 0x06	; 6
    abe4:	8c e3       	ldi	r24, 0x3C	; 60
    abe6:	9c e4       	ldi	r25, 0x4C	; 76
    abe8:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    abec:	64 e6       	ldi	r22, 0x64	; 100
    abee:	70 e0       	ldi	r23, 0x00	; 0
    abf0:	80 91 1b 0c 	lds	r24, 0x0C1B
    abf4:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 2;
    abf8:	82 e0       	ldi	r24, 0x02	; 2
    abfa:	8e c1       	rjmp	.+796    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;
				case 2:
					if(Timer16Stopp(TD_EMeter)){	
    abfc:	80 91 1b 0c 	lds	r24, 0x0C1B
    ac00:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ac04:	88 23       	and	r24, r24
    ac06:	09 f4       	brne	.+2      	; 0xac0a <EMeter_Cycle+0x8f6>
    ac08:	89 c1       	rjmp	.+786    	; 0xaf1c <EMeter_Cycle+0xc08>
				
						 //read data

						// check frame
						if(EMeter_RxCharN != 19){
    ac0a:	80 91 21 0d 	lds	r24, 0x0D21
    ac0e:	90 91 22 0d 	lds	r25, 0x0D22
    ac12:	43 97       	sbiw	r24, 0x13	; 19
    ac14:	19 f0       	breq	.+6      	; 0xac1c <EMeter_Cycle+0x908>
							EMeter_NoLink();
    ac16:	0e 94 15 4e 	call	0x9c2a	; 0x9c2a <EMeter_NoLink>
							break;
    ac1a:	80 c1       	rjmp	.+768    	; 0xaf1c <EMeter_Cycle+0xc08>
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 17);
    ac1c:	21 e1       	ldi	r18, 0x11	; 17
    ac1e:	30 e0       	ldi	r19, 0x00	; 0
    ac20:	40 e0       	ldi	r20, 0x00	; 0
    ac22:	50 e0       	ldi	r21, 0x00	; 0
    ac24:	6e e2       	ldi	r22, 0x2E	; 46
    ac26:	77 e0       	ldi	r23, 0x07	; 7
    ac28:	85 e9       	ldi	r24, 0x95	; 149
    ac2a:	98 e2       	ldi	r25, 0x28	; 40
    ac2c:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[18]<<8) + EMeter_RxStr[17];
    ac30:	20 91 40 07 	lds	r18, 0x0740
    ac34:	30 e0       	ldi	r19, 0x00	; 0
    ac36:	32 2f       	mov	r19, r18
    ac38:	22 27       	eor	r18, r18
    ac3a:	40 91 3f 07 	lds	r20, 0x073F
    ac3e:	24 0f       	add	r18, r20
    ac40:	31 1d       	adc	r19, r1
						if(MyCRC != EM_CRC){
    ac42:	82 17       	cp	r24, r18
    ac44:	93 07       	cpc	r25, r19
    ac46:	39 f7       	brne	.-50     	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    ac48:	80 91 2e 07 	lds	r24, 0x072E
    ac4c:	81 11       	cpse	r24, r1
    ac4e:	e3 cf       	rjmp	.-58     	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						//process data
						E_Meter_RAM.Ap = EMeter_M230_Data_Convert(1);
    ac50:	81 e0       	ldi	r24, 0x01	; 1
    ac52:	90 e0       	ldi	r25, 0x00	; 0
    ac54:	0e 94 7e 4e 	call	0x9cfc	; 0x9cfc <EMeter_M230_Data_Convert>
    ac58:	60 93 3e 02 	sts	0x023E, r22
    ac5c:	70 93 3f 02 	sts	0x023F, r23
    ac60:	80 93 40 02 	sts	0x0240, r24
    ac64:	90 93 41 02 	sts	0x0241, r25
						E_Meter_RAM.Am = EMeter_M230_Data_Convert(5);
    ac68:	85 e0       	ldi	r24, 0x05	; 5
    ac6a:	90 e0       	ldi	r25, 0x00	; 0
    ac6c:	0e 94 7e 4e 	call	0x9cfc	; 0x9cfc <EMeter_M230_Data_Convert>
    ac70:	60 93 42 02 	sts	0x0242, r22
    ac74:	70 93 43 02 	sts	0x0243, r23
    ac78:	80 93 44 02 	sts	0x0244, r24
    ac7c:	90 93 45 02 	sts	0x0245, r25
						E_Meter_RAM.Rp = EMeter_M230_Data_Convert(9);
    ac80:	89 e0       	ldi	r24, 0x09	; 9
    ac82:	90 e0       	ldi	r25, 0x00	; 0
    ac84:	0e 94 7e 4e 	call	0x9cfc	; 0x9cfc <EMeter_M230_Data_Convert>
    ac88:	60 93 46 02 	sts	0x0246, r22
    ac8c:	70 93 47 02 	sts	0x0247, r23
    ac90:	80 93 48 02 	sts	0x0248, r24
    ac94:	90 93 49 02 	sts	0x0249, r25
						E_Meter_RAM.Rm = EMeter_M230_Data_Convert(13);
    ac98:	8d e0       	ldi	r24, 0x0D	; 13
    ac9a:	90 e0       	ldi	r25, 0x00	; 0
    ac9c:	0e 94 7e 4e 	call	0x9cfc	; 0x9cfc <EMeter_M230_Data_Convert>
    aca0:	60 93 4a 02 	sts	0x024A, r22
    aca4:	70 93 4b 02 	sts	0x024B, r23
    aca8:	80 93 4c 02 	sts	0x024C, r24
    acac:	90 93 4d 02 	sts	0x024D, r25

						//StartTimer16(TD_EMeter,1000);
						
						//EM_Mode = 255;

						StartTimer16(TD_EMeter,100);
    acb0:	64 e6       	ldi	r22, 0x64	; 100
    acb2:	70 e0       	ldi	r23, 0x00	; 0
    acb4:	80 91 1b 0c 	lds	r24, 0x0C1B
    acb8:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 3;
    acbc:	10 93 55 0a 	sts	0x0A55, r17
    acc0:	2d c1       	rjmp	.+602    	; 0xaf1c <EMeter_Cycle+0xc08>
					}
					break;
				case 3:
					if(Timer16Stopp(TD_EMeter)){
    acc2:	80 91 1b 0c 	lds	r24, 0x0C1B
    acc6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    acca:	88 23       	and	r24, r24
    accc:	09 f4       	brne	.+2      	; 0xacd0 <EMeter_Cycle+0x9bc>
    acce:	26 c1       	rjmp	.+588    	; 0xaf1c <EMeter_Cycle+0xc08>
						EMeter_SendData_P(EM_VOLTAGE_REQ, sizeof(EM_VOLTAGE_REQ));
    acd0:	66 e0       	ldi	r22, 0x06	; 6
    acd2:	86 e3       	ldi	r24, 0x36	; 54
    acd4:	9c e4       	ldi	r25, 0x4C	; 76
    acd6:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    acda:	64 e6       	ldi	r22, 0x64	; 100
    acdc:	70 e0       	ldi	r23, 0x00	; 0
    acde:	80 91 1b 0c 	lds	r24, 0x0C1B
    ace2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 4;							
    ace6:	84 e0       	ldi	r24, 0x04	; 4
    ace8:	17 c1       	rjmp	.+558    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;

				case 4:
					if(Timer16Stopp(TD_EMeter)){
    acea:	80 91 1b 0c 	lds	r24, 0x0C1B
    acee:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    acf2:	88 23       	and	r24, r24
    acf4:	09 f4       	brne	.+2      	; 0xacf8 <EMeter_Cycle+0x9e4>
    acf6:	12 c1       	rjmp	.+548    	; 0xaf1c <EMeter_Cycle+0xc08>
						if(EMeter_RxCharN != 12){
    acf8:	80 91 21 0d 	lds	r24, 0x0D21
    acfc:	90 91 22 0d 	lds	r25, 0x0D22
    ad00:	0c 97       	sbiw	r24, 0x0c	; 12
    ad02:	09 f0       	breq	.+2      	; 0xad06 <EMeter_Cycle+0x9f2>
    ad04:	88 cf       	rjmp	.-240    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 10);
    ad06:	2a e0       	ldi	r18, 0x0A	; 10
    ad08:	30 e0       	ldi	r19, 0x00	; 0
    ad0a:	40 e0       	ldi	r20, 0x00	; 0
    ad0c:	50 e0       	ldi	r21, 0x00	; 0
    ad0e:	6e e2       	ldi	r22, 0x2E	; 46
    ad10:	77 e0       	ldi	r23, 0x07	; 7
    ad12:	85 e9       	ldi	r24, 0x95	; 149
    ad14:	98 e2       	ldi	r25, 0x28	; 40
    ad16:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[11]<<8) + EMeter_RxStr[10];
    ad1a:	20 91 39 07 	lds	r18, 0x0739
    ad1e:	30 e0       	ldi	r19, 0x00	; 0
    ad20:	32 2f       	mov	r19, r18
    ad22:	22 27       	eor	r18, r18
    ad24:	40 91 38 07 	lds	r20, 0x0738
    ad28:	24 0f       	add	r18, r20
    ad2a:	31 1d       	adc	r19, r1
						if(MyCRC != EM_CRC){
    ad2c:	82 17       	cp	r24, r18
    ad2e:	93 07       	cpc	r25, r19
    ad30:	09 f0       	breq	.+2      	; 0xad34 <EMeter_Cycle+0xa20>
    ad32:	71 cf       	rjmp	.-286    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    ad34:	80 91 2e 07 	lds	r24, 0x072E
    ad38:	81 11       	cpse	r24, r1
    ad3a:	6d cf       	rjmp	.-294    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						Ua=EMeter_M230_Data_ConvertWord(2)/100;
    ad3c:	82 e0       	ldi	r24, 0x02	; 2
    ad3e:	90 e0       	ldi	r25, 0x00	; 0
    ad40:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ad44:	04 e6       	ldi	r16, 0x64	; 100
    ad46:	10 e0       	ldi	r17, 0x00	; 0
    ad48:	b8 01       	movw	r22, r16
    ad4a:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ad4e:	70 93 24 0d 	sts	0x0D24, r23
    ad52:	60 93 23 0d 	sts	0x0D23, r22
						Ub=EMeter_M230_Data_ConvertWord(5)/100;
    ad56:	85 e0       	ldi	r24, 0x05	; 5
    ad58:	90 e0       	ldi	r25, 0x00	; 0
    ad5a:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ad5e:	b8 01       	movw	r22, r16
    ad60:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ad64:	70 93 dd 03 	sts	0x03DD, r23
    ad68:	60 93 dc 03 	sts	0x03DC, r22
						Uc=EMeter_M230_Data_ConvertWord(8)/100;
    ad6c:	88 e0       	ldi	r24, 0x08	; 8
    ad6e:	90 e0       	ldi	r25, 0x00	; 0
    ad70:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ad74:	b8 01       	movw	r22, r16
    ad76:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ad7a:	70 93 58 0a 	sts	0x0A58, r23
    ad7e:	60 93 57 0a 	sts	0x0A57, r22
						StartTimer16(TD_EMeter,100);
    ad82:	64 e6       	ldi	r22, 0x64	; 100
    ad84:	70 e0       	ldi	r23, 0x00	; 0
    ad86:	80 91 1b 0c 	lds	r24, 0x0C1B
    ad8a:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 5;						
    ad8e:	85 e0       	ldi	r24, 0x05	; 5
    ad90:	c3 c0       	rjmp	.+390    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;

				case 5:
					if(Timer16Stopp(TD_EMeter)){
    ad92:	80 91 1b 0c 	lds	r24, 0x0C1B
    ad96:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ad9a:	88 23       	and	r24, r24
    ad9c:	09 f4       	brne	.+2      	; 0xada0 <EMeter_Cycle+0xa8c>
    ad9e:	be c0       	rjmp	.+380    	; 0xaf1c <EMeter_Cycle+0xc08>
						EMeter_SendData_P(EM_CURRENT_REQ, sizeof(EM_CURRENT_REQ));
    ada0:	66 e0       	ldi	r22, 0x06	; 6
    ada2:	80 e3       	ldi	r24, 0x30	; 48
    ada4:	9c e4       	ldi	r25, 0x4C	; 76
    ada6:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    adaa:	64 e6       	ldi	r22, 0x64	; 100
    adac:	70 e0       	ldi	r23, 0x00	; 0
    adae:	80 91 1b 0c 	lds	r24, 0x0C1B
    adb2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 6;							
    adb6:	86 e0       	ldi	r24, 0x06	; 6
    adb8:	af c0       	rjmp	.+350    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;

				case 6:
					if(Timer16Stopp(TD_EMeter)){
    adba:	80 91 1b 0c 	lds	r24, 0x0C1B
    adbe:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    adc2:	88 23       	and	r24, r24
    adc4:	09 f4       	brne	.+2      	; 0xadc8 <EMeter_Cycle+0xab4>
    adc6:	aa c0       	rjmp	.+340    	; 0xaf1c <EMeter_Cycle+0xc08>
						if(EMeter_RxCharN != 12){
    adc8:	80 91 21 0d 	lds	r24, 0x0D21
    adcc:	90 91 22 0d 	lds	r25, 0x0D22
    add0:	0c 97       	sbiw	r24, 0x0c	; 12
    add2:	09 f0       	breq	.+2      	; 0xadd6 <EMeter_Cycle+0xac2>
    add4:	20 cf       	rjmp	.-448    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 10);
    add6:	2a e0       	ldi	r18, 0x0A	; 10
    add8:	30 e0       	ldi	r19, 0x00	; 0
    adda:	40 e0       	ldi	r20, 0x00	; 0
    addc:	50 e0       	ldi	r21, 0x00	; 0
    adde:	6e e2       	ldi	r22, 0x2E	; 46
    ade0:	77 e0       	ldi	r23, 0x07	; 7
    ade2:	85 e9       	ldi	r24, 0x95	; 149
    ade4:	98 e2       	ldi	r25, 0x28	; 40
    ade6:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[11]<<8) + EMeter_RxStr[10];
    adea:	20 91 39 07 	lds	r18, 0x0739
    adee:	30 e0       	ldi	r19, 0x00	; 0
    adf0:	32 2f       	mov	r19, r18
    adf2:	22 27       	eor	r18, r18
    adf4:	40 91 38 07 	lds	r20, 0x0738
    adf8:	24 0f       	add	r18, r20
    adfa:	31 1d       	adc	r19, r1
						if(MyCRC != EM_CRC){
    adfc:	82 17       	cp	r24, r18
    adfe:	93 07       	cpc	r25, r19
    ae00:	09 f0       	breq	.+2      	; 0xae04 <EMeter_Cycle+0xaf0>
    ae02:	09 cf       	rjmp	.-494    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    ae04:	80 91 2e 07 	lds	r24, 0x072E
    ae08:	81 11       	cpse	r24, r1
    ae0a:	05 cf       	rjmp	.-502    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						Ia=EMeter_M230_Data_ConvertWord(2)/10;
    ae0c:	82 e0       	ldi	r24, 0x02	; 2
    ae0e:	90 e0       	ldi	r25, 0x00	; 0
    ae10:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ae14:	0a e0       	ldi	r16, 0x0A	; 10
    ae16:	10 e0       	ldi	r17, 0x00	; 0
    ae18:	b8 01       	movw	r22, r16
    ae1a:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ae1e:	70 93 eb 03 	sts	0x03EB, r23
    ae22:	60 93 ea 03 	sts	0x03EA, r22
						Ib=EMeter_M230_Data_ConvertWord(5)/10;
    ae26:	85 e0       	ldi	r24, 0x05	; 5
    ae28:	90 e0       	ldi	r25, 0x00	; 0
    ae2a:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ae2e:	b8 01       	movw	r22, r16
    ae30:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ae34:	70 93 2e 09 	sts	0x092E, r23
    ae38:	60 93 2d 09 	sts	0x092D, r22
						Ic=EMeter_M230_Data_ConvertWord(8)/10;
    ae3c:	88 e0       	ldi	r24, 0x08	; 8
    ae3e:	90 e0       	ldi	r25, 0x00	; 0
    ae40:	0e 94 96 4e 	call	0x9d2c	; 0x9d2c <EMeter_M230_Data_ConvertWord>
    ae44:	b8 01       	movw	r22, r16
    ae46:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
    ae4a:	70 93 66 09 	sts	0x0966, r23
    ae4e:	60 93 65 09 	sts	0x0965, r22
						StartTimer16(TD_EMeter,100);
    ae52:	64 e6       	ldi	r22, 0x64	; 100
    ae54:	70 e0       	ldi	r23, 0x00	; 0
    ae56:	80 91 1b 0c 	lds	r24, 0x0C1B
    ae5a:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 7;						
    ae5e:	87 e0       	ldi	r24, 0x07	; 7
    ae60:	5b c0       	rjmp	.+182    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;

				case 7:
					if(Timer16Stopp(TD_EMeter)){
    ae62:	80 91 1b 0c 	lds	r24, 0x0C1B
    ae66:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ae6a:	88 23       	and	r24, r24
    ae6c:	09 f4       	brne	.+2      	; 0xae70 <EMeter_Cycle+0xb5c>
    ae6e:	56 c0       	rjmp	.+172    	; 0xaf1c <EMeter_Cycle+0xc08>
						EMeter_SendData_P(EM_ACTIVEPOWER_REQ, sizeof(EM_ACTIVEPOWER_REQ));
    ae70:	66 e0       	ldi	r22, 0x06	; 6
    ae72:	8a e2       	ldi	r24, 0x2A	; 42
    ae74:	9c e4       	ldi	r25, 0x4C	; 76
    ae76:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    ae7a:	64 e6       	ldi	r22, 0x64	; 100
    ae7c:	70 e0       	ldi	r23, 0x00	; 0
    ae7e:	80 91 1b 0c 	lds	r24, 0x0C1B
    ae82:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 8;							
    ae86:	88 e0       	ldi	r24, 0x08	; 8
    ae88:	47 c0       	rjmp	.+142    	; 0xaf18 <EMeter_Cycle+0xc04>
					}
					break;

				case 8:
					if(Timer16Stopp(TD_EMeter)){
    ae8a:	80 91 1b 0c 	lds	r24, 0x0C1B
    ae8e:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ae92:	88 23       	and	r24, r24
    ae94:	09 f4       	brne	.+2      	; 0xae98 <EMeter_Cycle+0xb84>
    ae96:	42 c0       	rjmp	.+132    	; 0xaf1c <EMeter_Cycle+0xc08>
						if(EMeter_RxCharN != 15){
    ae98:	80 91 21 0d 	lds	r24, 0x0D21
    ae9c:	90 91 22 0d 	lds	r25, 0x0D22
    aea0:	0f 97       	sbiw	r24, 0x0f	; 15
    aea2:	09 f0       	breq	.+2      	; 0xaea6 <EMeter_Cycle+0xb92>
    aea4:	b8 ce       	rjmp	.-656    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 13);
    aea6:	2d e0       	ldi	r18, 0x0D	; 13
    aea8:	30 e0       	ldi	r19, 0x00	; 0
    aeaa:	40 e0       	ldi	r20, 0x00	; 0
    aeac:	50 e0       	ldi	r21, 0x00	; 0
    aeae:	6e e2       	ldi	r22, 0x2E	; 46
    aeb0:	77 e0       	ldi	r23, 0x07	; 7
    aeb2:	85 e9       	ldi	r24, 0x95	; 149
    aeb4:	98 e2       	ldi	r25, 0x28	; 40
    aeb6:	0e 94 13 2a 	call	0x5426	; 0x5426 <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[14]<<8) + EMeter_RxStr[13];
    aeba:	20 91 3c 07 	lds	r18, 0x073C
    aebe:	30 e0       	ldi	r19, 0x00	; 0
    aec0:	32 2f       	mov	r19, r18
    aec2:	22 27       	eor	r18, r18
    aec4:	40 91 3b 07 	lds	r20, 0x073B
    aec8:	24 0f       	add	r18, r20
    aeca:	31 1d       	adc	r19, r1
						if(MyCRC != EM_CRC){
    aecc:	82 17       	cp	r24, r18
    aece:	93 07       	cpc	r25, r19
    aed0:	09 f0       	breq	.+2      	; 0xaed4 <EMeter_Cycle+0xbc0>
    aed2:	a1 ce       	rjmp	.-702    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    aed4:	80 91 2e 07 	lds	r24, 0x072E
    aed8:	81 11       	cpse	r24, r1
    aeda:	9d ce       	rjmp	.-710    	; 0xac16 <EMeter_Cycle+0x902>
							EMeter_NoLink();
							break;
						}
						EM_PowerActive = EMeter_M230_Data_ConvertP(1);
    aedc:	81 e0       	ldi	r24, 0x01	; 1
    aede:	90 e0       	ldi	r25, 0x00	; 0
    aee0:	0e 94 a4 4e 	call	0x9d48	; 0x9d48 <EMeter_M230_Data_ConvertP>
    aee4:	90 93 54 0a 	sts	0x0A54, r25
    aee8:	80 93 53 0a 	sts	0x0A53, r24

						EM_Retry = 0;
    aeec:	10 92 05 01 	sts	0x0105, r1
						EM_Mode = 255;						
    aef0:	8f ef       	ldi	r24, 0xFF	; 255
    aef2:	12 c0       	rjmp	.+36     	; 0xaf18 <EMeter_Cycle+0xc04>
					break;
				case 255:
					//      
					break;
				default: 
					if(Timer16Stopp(TD_EMeter)){
    aef4:	80 91 1b 0c 	lds	r24, 0x0C1B
    aef8:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    aefc:	88 23       	and	r24, r24
    aefe:	71 f0       	breq	.+28     	; 0xaf1c <EMeter_Cycle+0xc08>
						EMeter_SendData_P(EM_OPEN_CH_REQ, sizeof(EM_OPEN_CH_REQ));
    af00:	6b e0       	ldi	r22, 0x0B	; 11
    af02:	82 e4       	ldi	r24, 0x42	; 66
    af04:	9c e4       	ldi	r25, 0x4C	; 76
    af06:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    af0a:	64 e6       	ldi	r22, 0x64	; 100
    af0c:	70 e0       	ldi	r23, 0x00	; 0
    af0e:	80 91 1b 0c 	lds	r24, 0x0C1B
    af12:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						EM_Mode = 1;
    af16:	81 e0       	ldi	r24, 0x01	; 1
    af18:	80 93 55 0a 	sts	0x0A55, r24
    af1c:	89 e2       	ldi	r24, 0x29	; 41
    af1e:	90 e0       	ldi	r25, 0x00	; 0
    af20:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		// EM_Mode = 0 -  .   ATZ
		// EM_Mode = 1 -      ATE0  AT,     
		//   1  RING ( 5   5 )  30 
		// EM_Mode = 2 -    (/?!)   ATA
		// 
		if(erb(&EMeterType) == ELVIN_MODEM){
    af24:	84 30       	cpi	r24, 0x04	; 4
    af26:	09 f0       	breq	.+2      	; 0xaf2a <EMeter_Cycle+0xc16>
    af28:	8a c1       	rjmp	.+788    	; 0xb23e <EMeter_Cycle+0xf2a>
		
			#ifdef CTS
				cli();
    af2a:	f8 94       	cli
				CTS_ON();	// Clear RTS pin
    af2c:	0e 94 28 2f 	call	0x5e50	; 0x5e50 <CTS_ON>
				sei();
    af30:	78 94       	sei
			#endif

			if(EM_Retry>10){
    af32:	80 91 05 01 	lds	r24, 0x0105
    af36:	8b 30       	cpi	r24, 0x0B	; 11
    af38:	28 f0       	brcs	.+10     	; 0xaf44 <EMeter_Cycle+0xc30>
				EMeter_ELVIN_Modem_NoLink();
    af3a:	0e 94 5d 4e 	call	0x9cba	; 0x9cba <EMeter_ELVIN_Modem_NoLink>
				EM_Retry = 10;
    af3e:	8a e0       	ldi	r24, 0x0A	; 10
    af40:	80 93 05 01 	sts	0x0105, r24
			}
			
			if(!EMeter_TxFlag){		//   
    af44:	80 91 3e 09 	lds	r24, 0x093E
    af48:	81 11       	cpse	r24, r1
    af4a:	79 c1       	rjmp	.+754    	; 0xb23e <EMeter_Cycle+0xf2a>

				//   ATZ
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATZ) != NULL) ){
    af4c:	61 e2       	ldi	r22, 0x21	; 33
    af4e:	7c e4       	ldi	r23, 0x4C	; 76
    af50:	8e e2       	ldi	r24, 0x2E	; 46
    af52:	97 e0       	ldi	r25, 0x07	; 7
    af54:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    af58:	89 2b       	or	r24, r25
    af5a:	99 f0       	breq	.+38     	; 0xaf82 <EMeter_Cycle+0xc6e>
					EMeter_ClearRXStr();
    af5c:	0e 94 03 4e 	call	0x9c06	; 0x9c06 <EMeter_ClearRXStr>
					EMeter_SendData_P(EM_RESP_OK, sizeof(EM_RESP_OK)-1);
    af60:	66 e0       	ldi	r22, 0x06	; 6
    af62:	87 e0       	ldi	r24, 0x07	; 7
    af64:	9c e4       	ldi	r25, 0x4C	; 76
    af66:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
					StartTimer16(TD_EMeter, 1500);	// 40
    af6a:	6c ed       	ldi	r22, 0xDC	; 220
    af6c:	75 e0       	ldi	r23, 0x05	; 5
    af6e:	80 91 1b 0c 	lds	r24, 0x0C1B
    af72:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					EM_Retry++;	
    af76:	80 91 05 01 	lds	r24, 0x0105
    af7a:	8f 5f       	subi	r24, 0xFF	; 255
    af7c:	80 93 05 01 	sts	0x0105, r24
    af80:	5c c1       	rjmp	.+696    	; 0xb23a <EMeter_Cycle+0xf26>
					EM_Mode = 0;
					return;
				}

				//   ATE0
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATE0) != NULL) ){
    af82:	6b e1       	ldi	r22, 0x1B	; 27
    af84:	7c e4       	ldi	r23, 0x4C	; 76
    af86:	8e e2       	ldi	r24, 0x2E	; 46
    af88:	97 e0       	ldi	r25, 0x07	; 7
    af8a:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    af8e:	89 2b       	or	r24, r25
    af90:	41 f0       	breq	.+16     	; 0xafa2 <EMeter_Cycle+0xc8e>
					EMeter_ClearRXStr();
    af92:	0e 94 03 4e 	call	0x9c06	; 0x9c06 <EMeter_ClearRXStr>
					EMeter_SendData_P(EM_RESP_OK, sizeof(EM_RESP_OK)-1);
    af96:	66 e0       	ldi	r22, 0x06	; 6
    af98:	87 e0       	ldi	r24, 0x07	; 7
    af9a:	9c e4       	ldi	r25, 0x4C	; 76
    af9c:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
    afa0:	48 c1       	rjmp	.+656    	; 0xb232 <EMeter_Cycle+0xf1e>
					EM_Mode = 1;
					return;
				}

				//   AT
				if( (strstr_P(EMeter_RxStr, EM_RESP_AT) != NULL) ){
    afa2:	66 e2       	ldi	r22, 0x26	; 38
    afa4:	7c e4       	ldi	r23, 0x4C	; 76
    afa6:	8e e2       	ldi	r24, 0x2E	; 46
    afa8:	97 e0       	ldi	r25, 0x07	; 7
    afaa:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    afae:	89 2b       	or	r24, r25
    afb0:	81 f7       	brne	.-32     	; 0xaf92 <EMeter_Cycle+0xc7e>
					EM_Mode = 1;
					return;
				}

				//   +++ATH
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATH) != NULL) ){
    afb2:	63 e1       	ldi	r22, 0x13	; 19
    afb4:	7c e4       	ldi	r23, 0x4C	; 76
    afb6:	8e e2       	ldi	r24, 0x2E	; 46
    afb8:	97 e0       	ldi	r25, 0x07	; 7
    afba:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    afbe:	89 2b       	or	r24, r25
    afc0:	19 f0       	breq	.+6      	; 0xafc8 <EMeter_Cycle+0xcb4>
					EMeter_ClearRXStr();
    afc2:	0e 94 03 4e 	call	0x9c06	; 0x9c06 <EMeter_ClearRXStr>
    afc6:	35 c1       	rjmp	.+618    	; 0xb232 <EMeter_Cycle+0xf1e>
					EM_Mode = 1;
					return;
				}

				//   ATA
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATA) != NULL) ){
    afc8:	6e e0       	ldi	r22, 0x0E	; 14
    afca:	7c e4       	ldi	r23, 0x4C	; 76
    afcc:	8e e2       	ldi	r24, 0x2E	; 46
    afce:	97 e0       	ldi	r25, 0x07	; 7
    afd0:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    afd4:	89 2b       	or	r24, r25
    afd6:	59 f0       	breq	.+22     	; 0xafee <EMeter_Cycle+0xcda>
					EMeter_ClearRXStr();
    afd8:	0e 94 03 4e 	call	0x9c06	; 0x9c06 <EMeter_ClearRXStr>
					EMeter_SendData_P(EM_RESP_CONNECT, sizeof(EM_RESP_CONNECT)-1);
    afdc:	6b e0       	ldi	r22, 0x0B	; 11
    afde:	82 ef       	ldi	r24, 0xF2	; 242
    afe0:	9b e4       	ldi	r25, 0x4B	; 75
    afe2:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
					RING_Retry = 0;
    afe6:	10 92 30 02 	sts	0x0230, r1
					EM_Mode = 2;
    afea:	82 e0       	ldi	r24, 0x02	; 2
    afec:	23 c1       	rjmp	.+582    	; 0xb234 <EMeter_Cycle+0xf20>
					return;
				}
			

				if(Timer16Stopp(TD_EMeter)){
    afee:	80 91 1b 0c 	lds	r24, 0x0C1B
    aff2:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    aff6:	88 23       	and	r24, r24
    aff8:	09 f4       	brne	.+2      	; 0xaffc <EMeter_Cycle+0xce8>
    affa:	21 c1       	rjmp	.+578    	; 0xb23e <EMeter_Cycle+0xf2a>
					switch(EM_Mode){
    affc:	80 91 55 0a 	lds	r24, 0x0A55
    b000:	90 e0       	ldi	r25, 0x00	; 0
    b002:	87 30       	cpi	r24, 0x07	; 7
    b004:	91 05       	cpc	r25, r1
    b006:	08 f0       	brcs	.+2      	; 0xb00a <EMeter_Cycle+0xcf6>
    b008:	18 c1       	rjmp	.+560    	; 0xb23a <EMeter_Cycle+0xf26>
    b00a:	fc 01       	movw	r30, r24
    b00c:	e2 55       	subi	r30, 0x52	; 82
    b00e:	ff 4f       	sbci	r31, 0xFF	; 255
    b010:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
						case 0:
							EMeter_ELVIN_Modem_NoLink();
    b014:	0e 94 5d 4e 	call	0x9cba	; 0x9cba <EMeter_ELVIN_Modem_NoLink>
							break;
    b018:	12 c1       	rjmp	.+548    	; 0xb23e <EMeter_Cycle+0xf2a>
						case 1:
							if(RING_Retry++>5){ 
    b01a:	80 91 30 02 	lds	r24, 0x0230
    b01e:	91 e0       	ldi	r25, 0x01	; 1
    b020:	98 0f       	add	r25, r24
    b022:	90 93 30 02 	sts	0x0230, r25
    b026:	86 30       	cpi	r24, 0x06	; 6
    b028:	48 f0       	brcs	.+18     	; 0xb03c <EMeter_Cycle+0xd28>
								EM_Mode = 5;
    b02a:	85 e0       	ldi	r24, 0x05	; 5
    b02c:	80 93 55 0a 	sts	0x0A55, r24
								EM_Retry++;
    b030:	80 91 05 01 	lds	r24, 0x0105
    b034:	8f 5f       	subi	r24, 0xFF	; 255
    b036:	80 93 05 01 	sts	0x0105, r24
    b03a:	01 c1       	rjmp	.+514    	; 0xb23e <EMeter_Cycle+0xf2a>
							}
							else{
								EMeter_SendData_P(EM_RESP_RING, sizeof(EM_RESP_RING)-1);
    b03c:	68 e0       	ldi	r22, 0x08	; 8
    b03e:	8e ef       	ldi	r24, 0xFE	; 254
    b040:	9b e4       	ldi	r25, 0x4B	; 75
    b042:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
								StartTimer16(TD_EMeter, 500);
    b046:	64 ef       	ldi	r22, 0xF4	; 244
    b048:	71 e0       	ldi	r23, 0x01	; 1
    b04a:	80 91 1b 0c 	lds	r24, 0x0C1B
    b04e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    b052:	f5 c0       	rjmp	.+490    	; 0xb23e <EMeter_Cycle+0xf2a>
							}
							break;
						case 2:	
							EMeter_SendCR(EM_REQ);
    b054:	82 e5       	ldi	r24, 0x52	; 82
    b056:	9c e4       	ldi	r25, 0x4C	; 76
    b058:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
							StartTimer16(TD_EMeter, 300);
    b05c:	6c e2       	ldi	r22, 0x2C	; 44
    b05e:	71 e0       	ldi	r23, 0x01	; 1
    b060:	80 91 1b 0c 	lds	r24, 0x0C1B
    b064:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
							EM_Mode = 3;
    b068:	83 e0       	ldi	r24, 0x03	; 3
    b06a:	e4 c0       	rjmp	.+456    	; 0xb234 <EMeter_Cycle+0xf20>
							break;
						case 3:
							EMeter_SendCR(EM_READ_DATA_REQ);
    b06c:	8d e4       	ldi	r24, 0x4D	; 77
    b06e:	9c e4       	ldi	r25, 0x4C	; 76
    b070:	0e 94 cb 4d 	call	0x9b96	; 0x9b96 <EMeter_SendCR>
							StartTimer16(TD_EMeter,300);
    b074:	6c e2       	ldi	r22, 0x2C	; 44
    b076:	71 e0       	ldi	r23, 0x01	; 1
    b078:	80 91 1b 0c 	lds	r24, 0x0C1B
    b07c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
							EM_Mode = 4;
    b080:	84 e0       	ldi	r24, 0x04	; 4
    b082:	d8 c0       	rjmp	.+432    	; 0xb234 <EMeter_Cycle+0xf20>
							break;
						case 4:
							// Read data
						
							// check frame
							if(EMeter_RxCharN != 24){
    b084:	80 91 21 0d 	lds	r24, 0x0D21
    b088:	90 91 22 0d 	lds	r25, 0x0D22
    b08c:	48 97       	sbiw	r24, 0x18	; 24
    b08e:	91 f4       	brne	.+36     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b090:	ef e2       	ldi	r30, 0x2F	; 47
    b092:	f7 e0       	ldi	r31, 0x07	; 7
    b094:	90 e0       	ldi	r25, 0x00	; 0
								EM_Retry++;
								EM_Mode = 5;
								break;
							}
							EM_BCC = 0;
							for(uint8_t i=1; i<23; i++) EM_BCC += EMeter_RxStr[i];
    b096:	81 91       	ld	r24, Z+
    b098:	89 0f       	add	r24, r25
    b09a:	27 e0       	ldi	r18, 0x07	; 7
    b09c:	e5 34       	cpi	r30, 0x45	; 69
    b09e:	f2 07       	cpc	r31, r18
    b0a0:	11 f0       	breq	.+4      	; 0xb0a6 <EMeter_Cycle+0xd92>
    b0a2:	98 2f       	mov	r25, r24
    b0a4:	f8 cf       	rjmp	.-16     	; 0xb096 <EMeter_Cycle+0xd82>
							EM_BCC &= 0b01111111;
    b0a6:	8f 77       	andi	r24, 0x7F	; 127
    b0a8:	80 93 3d 09 	sts	0x093D, r24
							if(EM_BCC != EMeter_RxStr[23]){
    b0ac:	90 91 45 07 	lds	r25, 0x0745
    b0b0:	89 17       	cp	r24, r25
    b0b2:	39 f0       	breq	.+14     	; 0xb0c2 <EMeter_Cycle+0xdae>
								EM_Retry++;
    b0b4:	80 91 05 01 	lds	r24, 0x0105
    b0b8:	8f 5f       	subi	r24, 0xFF	; 255
    b0ba:	80 93 05 01 	sts	0x0105, r24
								EM_Mode = 5;
    b0be:	85 e0       	ldi	r24, 0x05	; 5
    b0c0:	b9 c0       	rjmp	.+370    	; 0xb234 <EMeter_Cycle+0xf20>
								break;
							}
							if( EMeter_RxStr[0]!=0x02 || EMeter_RxStr[1]!='(' || EMeter_RxStr[18] != ')' || EMeter_RxStr[19] != '!' ||
    b0c2:	80 91 2e 07 	lds	r24, 0x072E
    b0c6:	82 30       	cpi	r24, 0x02	; 2
    b0c8:	a9 f7       	brne	.-22     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b0ca:	80 91 2f 07 	lds	r24, 0x072F
    b0ce:	88 32       	cpi	r24, 0x28	; 40
    b0d0:	89 f7       	brne	.-30     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b0d2:	80 91 40 07 	lds	r24, 0x0740
    b0d6:	89 32       	cpi	r24, 0x29	; 41
    b0d8:	69 f7       	brne	.-38     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b0da:	80 91 41 07 	lds	r24, 0x0741
    b0de:	81 32       	cpi	r24, 0x21	; 33
    b0e0:	49 f7       	brne	.-46     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b0e2:	80 91 42 07 	lds	r24, 0x0742
    b0e6:	8d 30       	cpi	r24, 0x0D	; 13
    b0e8:	29 f7       	brne	.-54     	; 0xb0b4 <EMeter_Cycle+0xda0>
								EMeter_RxStr[20] != '\r' || EMeter_RxStr[21] != '\n'|| EMeter_RxStr[22] != 0x03){
    b0ea:	80 91 43 07 	lds	r24, 0x0743
    b0ee:	8a 30       	cpi	r24, 0x0A	; 10
    b0f0:	09 f7       	brne	.-62     	; 0xb0b4 <EMeter_Cycle+0xda0>
    b0f2:	80 91 44 07 	lds	r24, 0x0744
    b0f6:	83 30       	cpi	r24, 0x03	; 3
    b0f8:	e9 f6       	brne	.-70     	; 0xb0b4 <EMeter_Cycle+0xda0>
								break;
							}
						
							{//process data
								char TempStr[9];
								TempStr[8] = 0;
    b0fa:	19 86       	std	Y+9, r1	; 0x09
    b0fc:	66 e3       	ldi	r22, 0x36	; 54
    b0fe:	77 e0       	ldi	r23, 0x07	; 7
    b100:	87 e3       	ldi	r24, 0x37	; 55
    b102:	97 e0       	ldi	r25, 0x07	; 7
    b104:	de 01       	movw	r26, r28
    b106:	12 96       	adiw	r26, 0x02	; 2
    b108:	9d 01       	movw	r18, r26
    b10a:	21 50       	subi	r18, 0x01	; 1
    b10c:	31 09       	sbc	r19, r1

								uint8_t Start = 2;
								for(uint8_t i=0; i<8; i=i+2){
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
    b10e:	fb 01       	movw	r30, r22
    b110:	40 81       	ld	r20, Z
    b112:	f9 01       	movw	r30, r18
    b114:	40 83       	st	Z, r20
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
    b116:	fc 01       	movw	r30, r24
    b118:	20 81       	ld	r18, Z
    b11a:	2c 93       	st	X, r18
    b11c:	62 50       	subi	r22, 0x02	; 2
    b11e:	71 09       	sbc	r23, r1
    b120:	02 97       	sbiw	r24, 0x02	; 2
    b122:	12 96       	adiw	r26, 0x02	; 2
							{//process data
								char TempStr[9];
								TempStr[8] = 0;

								uint8_t Start = 2;
								for(uint8_t i=0; i<8; i=i+2){
    b124:	f7 e0       	ldi	r31, 0x07	; 7
    b126:	6e 32       	cpi	r22, 0x2E	; 46
    b128:	7f 07       	cpc	r23, r31
    b12a:	71 f7       	brne	.-36     	; 0xb108 <EMeter_Cycle+0xdf4>
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Ap);		
    b12c:	8e e3       	ldi	r24, 0x3E	; 62
    b12e:	92 e0       	ldi	r25, 0x02	; 2
    b130:	9f 93       	push	r25
    b132:	8f 93       	push	r24
    b134:	83 ea       	ldi	r24, 0xA3	; 163
    b136:	91 e0       	ldi	r25, 0x01	; 1
    b138:	9f 93       	push	r25
    b13a:	8f 93       	push	r24
    b13c:	8e 01       	movw	r16, r28
    b13e:	0f 5f       	subi	r16, 0xFF	; 255
    b140:	1f 4f       	sbci	r17, 0xFF	; 255
    b142:	1f 93       	push	r17
    b144:	0f 93       	push	r16
    b146:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
								E_Meter_RAM.Ap *=10;
    b14a:	20 91 3e 02 	lds	r18, 0x023E
    b14e:	30 91 3f 02 	lds	r19, 0x023F
    b152:	40 91 40 02 	lds	r20, 0x0240
    b156:	50 91 41 02 	lds	r21, 0x0241
    b15a:	aa e0       	ldi	r26, 0x0A	; 10
    b15c:	b0 e0       	ldi	r27, 0x00	; 0
    b15e:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    b162:	60 93 3e 02 	sts	0x023E, r22
    b166:	70 93 3f 02 	sts	0x023F, r23
    b16a:	80 93 40 02 	sts	0x0240, r24
    b16e:	90 93 41 02 	sts	0x0241, r25
    b172:	ef e3       	ldi	r30, 0x3F	; 63
    b174:	f7 e0       	ldi	r31, 0x07	; 7
    b176:	0f 90       	pop	r0
    b178:	0f 90       	pop	r0
    b17a:	0f 90       	pop	r0
    b17c:	0f 90       	pop	r0
    b17e:	0f 90       	pop	r0
    b180:	0f 90       	pop	r0
    b182:	ae 01       	movw	r20, r28
    b184:	4e 5f       	subi	r20, 0xFE	; 254
    b186:	5f 4f       	sbci	r21, 0xFF	; 255
    b188:	ca 01       	movw	r24, r20
    b18a:	01 97       	sbiw	r24, 0x01	; 1
    b18c:	9f 01       	movw	r18, r30
    b18e:	21 50       	subi	r18, 0x01	; 1
    b190:	31 09       	sbc	r19, r1
								Start = 10;
								for(uint8_t i=0; i<8; i=i+2){
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
    b192:	d9 01       	movw	r26, r18
    b194:	2c 91       	ld	r18, X
    b196:	dc 01       	movw	r26, r24
    b198:	2c 93       	st	X, r18
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
    b19a:	80 81       	ld	r24, Z
    b19c:	da 01       	movw	r26, r20
    b19e:	8c 93       	st	X, r24
    b1a0:	32 97       	sbiw	r30, 0x02	; 2
    b1a2:	4e 5f       	subi	r20, 0xFE	; 254
    b1a4:	5f 4f       	sbci	r21, 0xFF	; 255
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Ap);		
								E_Meter_RAM.Ap *=10;
								Start = 10;
								for(uint8_t i=0; i<8; i=i+2){
    b1a6:	b7 e0       	ldi	r27, 0x07	; 7
    b1a8:	e7 33       	cpi	r30, 0x37	; 55
    b1aa:	fb 07       	cpc	r31, r27
    b1ac:	69 f7       	brne	.-38     	; 0xb188 <EMeter_Cycle+0xe74>
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Am);
    b1ae:	82 e4       	ldi	r24, 0x42	; 66
    b1b0:	92 e0       	ldi	r25, 0x02	; 2
    b1b2:	9f 93       	push	r25
    b1b4:	8f 93       	push	r24
    b1b6:	83 ea       	ldi	r24, 0xA3	; 163
    b1b8:	91 e0       	ldi	r25, 0x01	; 1
    b1ba:	9f 93       	push	r25
    b1bc:	8f 93       	push	r24
    b1be:	1f 93       	push	r17
    b1c0:	0f 93       	push	r16
    b1c2:	0e 94 8a 78 	call	0xf114	; 0xf114 <sscanf>
								E_Meter_RAM.Am *=10;
    b1c6:	20 91 42 02 	lds	r18, 0x0242
    b1ca:	30 91 43 02 	lds	r19, 0x0243
    b1ce:	40 91 44 02 	lds	r20, 0x0244
    b1d2:	50 91 45 02 	lds	r21, 0x0245
    b1d6:	aa e0       	ldi	r26, 0x0A	; 10
    b1d8:	b0 e0       	ldi	r27, 0x00	; 0
    b1da:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    b1de:	60 93 42 02 	sts	0x0242, r22
    b1e2:	70 93 43 02 	sts	0x0243, r23
    b1e6:	80 93 44 02 	sts	0x0244, r24
    b1ea:	90 93 45 02 	sts	0x0245, r25
							}
							EM_Retry = 0;
    b1ee:	10 92 05 01 	sts	0x0105, r1
    b1f2:	0f 90       	pop	r0
    b1f4:	0f 90       	pop	r0
    b1f6:	0f 90       	pop	r0
    b1f8:	0f 90       	pop	r0
    b1fa:	0f 90       	pop	r0
    b1fc:	0f 90       	pop	r0
						case 5:												
							EMeter_SendData_P(EM_END_REQ, sizeof(EM_END_REQ));				
    b1fe:	64 e0       	ldi	r22, 0x04	; 4
    b200:	8f ed       	ldi	r24, 0xDF	; 223
    b202:	9b e4       	ldi	r25, 0x4B	; 75
    b204:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
							StartTimer16(TD_EMeter,200);
    b208:	68 ec       	ldi	r22, 0xC8	; 200
    b20a:	70 e0       	ldi	r23, 0x00	; 0
    b20c:	80 91 1b 0c 	lds	r24, 0x0C1B
    b210:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
							RING_Retry = 0;
    b214:	10 92 30 02 	sts	0x0230, r1
							EM_Mode = 6;
    b218:	86 e0       	ldi	r24, 0x06	; 6
    b21a:	0c c0       	rjmp	.+24     	; 0xb234 <EMeter_Cycle+0xf20>
							break;
						case 6:
							EMeter_SendData_P(EM_RESP_NOCARRIER, sizeof(EM_RESP_NOCARRIER)-1);
    b21c:	6e e0       	ldi	r22, 0x0E	; 14
    b21e:	83 ee       	ldi	r24, 0xE3	; 227
    b220:	9b e4       	ldi	r25, 0x4B	; 75
    b222:	0e 94 f8 4d 	call	0x9bf0	; 0x9bf0 <EMeter_SendData_P>
							StartTimer16(TD_EMeter,3000);
    b226:	68 eb       	ldi	r22, 0xB8	; 184
    b228:	7b e0       	ldi	r23, 0x0B	; 11
    b22a:	80 91 1b 0c 	lds	r24, 0x0C1B
    b22e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
							EM_Mode = 1;
    b232:	81 e0       	ldi	r24, 0x01	; 1
    b234:	80 93 55 0a 	sts	0x0A55, r24
							break;
    b238:	02 c0       	rjmp	.+4      	; 0xb23e <EMeter_Cycle+0xf2a>
						default: 
							EM_Mode = 0;
    b23a:	10 92 55 0a 	sts	0x0A55, r1
			}//EMeter_TxFlag

		}
	// ---
	}//NonTransparent
}
    b23e:	2b 96       	adiw	r28, 0x0b	; 11
    b240:	0f b6       	in	r0, 0x3f	; 63
    b242:	f8 94       	cli
    b244:	de bf       	out	0x3e, r29	; 62
    b246:	0f be       	out	0x3f, r0	; 63
    b248:	cd bf       	out	0x3d, r28	; 61
    b24a:	df 91       	pop	r29
    b24c:	cf 91       	pop	r28
    b24e:	1f 91       	pop	r17
    b250:	0f 91       	pop	r16
    b252:	ff 90       	pop	r15
    b254:	ef 90       	pop	r14
    b256:	df 90       	pop	r13
    b258:	cf 90       	pop	r12
    b25a:	08 95       	ret

0000b25c <GPRS_AppInit>:

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    b25c:	0e 94 de 2a 	call	0x55bc	; 0x55bc <Timer16Alloc>
    b260:	80 93 01 06 	sts	0x0601, r24
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    b264:	0e 94 de 2a 	call	0x55bc	; 0x55bc <Timer16Alloc>
    b268:	80 93 34 09 	sts	0x0934, r24
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    b26c:	0e 94 de 2a 	call	0x55bc	; 0x55bc <Timer16Alloc>
    b270:	80 93 f0 0a 	sts	0x0AF0, r24
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    b274:	6f ef       	ldi	r22, 0xFF	; 255
    b276:	7f ef       	ldi	r23, 0xFF	; 255
    b278:	80 91 34 09 	lds	r24, 0x0934
    b27c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    b280:	80 91 0d 01 	lds	r24, 0x010D
    b284:	88 32       	cpi	r24, 0x28	; 40
    b286:	28 f0       	brcs	.+10     	; 0xb292 <GPRS_AppInit+0x36>
    b288:	80 91 4d 09 	lds	r24, 0x094D
    b28c:	81 60       	ori	r24, 0x01	; 1
    b28e:	80 93 4d 09 	sts	0x094D, r24
    b292:	08 95       	ret

0000b294 <GPRS_AddHeader>:
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    b294:	0f 93       	push	r16
    b296:	1f 93       	push	r17
    b298:	cf 93       	push	r28
    b29a:	df 93       	push	r29
    b29c:	00 d0       	rcall	.+0      	; 0xb29e <GPRS_AddHeader+0xa>
    b29e:	1f 92       	push	r1
    b2a0:	cd b7       	in	r28, 0x3d	; 61
    b2a2:	de b7       	in	r29, 0x3e	; 62
    b2a4:	8c 01       	movw	r16, r24

	Buf[0] = 5;	
    b2a6:	85 e0       	ldi	r24, 0x05	; 5
    b2a8:	f8 01       	movw	r30, r16
    b2aa:	80 83       	st	Z, r24
	Buf[1] = 1;	
    b2ac:	81 e0       	ldi	r24, 0x01	; 1
    b2ae:	81 83       	std	Z+1, r24	; 0x01
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b2b0:	8c e0       	ldi	r24, 0x0C	; 12
    b2b2:	91 e0       	ldi	r25, 0x01	; 1
    b2b4:	2b 83       	std	Y+3, r18	; 0x03
    b2b6:	4a 83       	std	Y+2, r20	; 0x02
    b2b8:	69 83       	std	Y+1, r22	; 0x01
    b2ba:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    b2be:	f8 01       	movw	r30, r16
    b2c0:	92 83       	std	Z+2, r25	; 0x02
    b2c2:	8c e0       	ldi	r24, 0x0C	; 12
    b2c4:	91 e0       	ldi	r25, 0x01	; 1
    b2c6:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    b2ca:	f8 01       	movw	r30, r16
    b2cc:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    b2ce:	69 81       	ldd	r22, Y+1	; 0x01
    b2d0:	64 83       	std	Z+4, r22	; 0x04
	Buf[5] = Size;	// -       
    b2d2:	2b 81       	ldd	r18, Y+3	; 0x03
    b2d4:	25 83       	std	Z+5, r18	; 0x05
	Buf[6] = Func;		
    b2d6:	4a 81       	ldd	r20, Y+2	; 0x02
    b2d8:	46 83       	std	Z+6, r20	; 0x06
}
    b2da:	0f 90       	pop	r0
    b2dc:	0f 90       	pop	r0
    b2de:	0f 90       	pop	r0
    b2e0:	df 91       	pop	r29
    b2e2:	cf 91       	pop	r28
    b2e4:	1f 91       	pop	r17
    b2e6:	0f 91       	pop	r16
    b2e8:	08 95       	ret

0000b2ea <GPRS_CurDataSend>:

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    b2ea:	cf 92       	push	r12
    b2ec:	df 92       	push	r13
    b2ee:	ef 92       	push	r14
    b2f0:	ff 92       	push	r15
    b2f2:	0f 93       	push	r16
    b2f4:	1f 93       	push	r17
    b2f6:	cf 93       	push	r28
    b2f8:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    b2fa:	86 e0       	ldi	r24, 0x06	; 6
    b2fc:	80 93 1c 0b 	sts	0x0B1C, r24
	GPRS_Data_Out[1] = 1;	//   
    b300:	81 e0       	ldi	r24, 0x01	; 1
    b302:	80 93 1d 0b 	sts	0x0B1D, r24
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    b306:	90 91 5e 09 	lds	r25, 0x095E
    b30a:	90 93 1e 0b 	sts	0x0B1E, r25
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    b30e:	90 91 5d 09 	lds	r25, 0x095D
    b312:	90 93 1f 0b 	sts	0x0B1F, r25
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    b316:	90 91 5c 09 	lds	r25, 0x095C
    b31a:	90 93 20 0b 	sts	0x0B20, r25
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    b31e:	90 91 5b 09 	lds	r25, 0x095B
    b322:	90 93 21 0b 	sts	0x0B21, r25
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    b326:	90 91 5a 09 	lds	r25, 0x095A
    b32a:	90 93 22 0b 	sts	0x0B22, r25
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    b32e:	90 91 59 09 	lds	r25, 0x0959
    b332:	90 93 23 0b 	sts	0x0B23, r25
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    b336:	90 91 58 09 	lds	r25, 0x0958
    b33a:	90 93 24 0b 	sts	0x0B24, r25
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    b33e:	90 91 57 09 	lds	r25, 0x0957
    b342:	90 93 25 0b 	sts	0x0B25, r25

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    b346:	80 93 26 0b 	sts	0x0B26, r24
	GPRS_Data_Out[11] = SW_VERSION;		//   
    b34a:	83 e0       	ldi	r24, 0x03	; 3
    b34c:	80 93 27 0b 	sts	0x0B27, r24
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    b350:	87 e0       	ldi	r24, 0x07	; 7
    b352:	80 93 28 0b 	sts	0x0B28, r24

	GPRS_Data_Out[13] = 60;			// -       
    b356:	8c e3       	ldi	r24, 0x3C	; 60
    b358:	80 93 29 0b 	sts	0x0B29, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    b35c:	80 91 ff 0a 	lds	r24, 0x0AFF
    b360:	80 93 2a 0b 	sts	0x0B2A, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    b364:	80 91 00 0b 	lds	r24, 0x0B00
    b368:	80 93 2b 0b 	sts	0x0B2B, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    b36c:	80 91 01 0b 	lds	r24, 0x0B01
    b370:	80 93 2c 0b 	sts	0x0B2C, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    b374:	80 91 02 0b 	lds	r24, 0x0B02
    b378:	80 93 2d 0b 	sts	0x0B2D, r24

	if(EMeter_Link()){
    b37c:	0e 94 0f 4e 	call	0x9c1e	; 0x9c1e <EMeter_Link>
    b380:	88 23       	and	r24, r24
    b382:	f1 f0       	breq	.+60     	; 0xb3c0 <GPRS_CurDataSend+0xd6>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b384:	89 e2       	ldi	r24, 0x29	; 41
    b386:	90 e0       	ldi	r25, 0x00	; 0
    b388:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    b38c:	81 30       	cpi	r24, 0x01	; 1
    b38e:	a9 f4       	brne	.+42     	; 0xb3ba <GPRS_CurDataSend+0xd0>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    b390:	84 e6       	ldi	r24, 0x64	; 100
    b392:	98 e0       	ldi	r25, 0x08	; 8
    b394:	9f 93       	push	r25
    b396:	8f 93       	push	r24
    b398:	86 ee       	ldi	r24, 0xE6	; 230
    b39a:	92 e0       	ldi	r25, 0x02	; 2
    b39c:	9f 93       	push	r25
    b39e:	8f 93       	push	r24
    b3a0:	8e e2       	ldi	r24, 0x2E	; 46
    b3a2:	9b e0       	ldi	r25, 0x0B	; 11
    b3a4:	9f 93       	push	r25
    b3a6:	8f 93       	push	r24
    b3a8:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
    b3ac:	0f 90       	pop	r0
    b3ae:	0f 90       	pop	r0
    b3b0:	0f 90       	pop	r0
    b3b2:	0f 90       	pop	r0
    b3b4:	0f 90       	pop	r0
    b3b6:	0f 90       	pop	r0
    b3b8:	11 c0       	rjmp	.+34     	; 0xb3dc <GPRS_CurDataSend+0xf2>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    b3ba:	86 ed       	ldi	r24, 0xD6	; 214
    b3bc:	92 e0       	ldi	r25, 0x02	; 2
    b3be:	02 c0       	rjmp	.+4      	; 0xb3c4 <GPRS_CurDataSend+0xda>
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    b3c0:	86 ec       	ldi	r24, 0xC6	; 198
    b3c2:	92 e0       	ldi	r25, 0x02	; 2
    b3c4:	9f 93       	push	r25
    b3c6:	8f 93       	push	r24
    b3c8:	8e e2       	ldi	r24, 0x2E	; 46
    b3ca:	9b e0       	ldi	r25, 0x0B	; 11
    b3cc:	9f 93       	push	r25
    b3ce:	8f 93       	push	r24
    b3d0:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
    b3d4:	0f 90       	pop	r0
    b3d6:	0f 90       	pop	r0
    b3d8:	0f 90       	pop	r0
    b3da:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    b3dc:	10 92 3e 0b 	sts	0x0B3E, r1
    b3e0:	10 92 3d 0b 	sts	0x0B3D, r1
	if(!EMeter_Link()){
    b3e4:	0e 94 0f 4e 	call	0x9c1e	; 0x9c1e <EMeter_Link>
    b3e8:	e0 90 23 0d 	lds	r14, 0x0D23
    b3ec:	f0 90 24 0d 	lds	r15, 0x0D24
    b3f0:	00 91 dc 03 	lds	r16, 0x03DC
    b3f4:	10 91 dd 03 	lds	r17, 0x03DD
    b3f8:	c0 91 57 0a 	lds	r28, 0x0A57
    b3fc:	d0 91 58 0a 	lds	r29, 0x0A58
    b400:	81 11       	cpse	r24, r1
    b402:	03 c0       	rjmp	.+6      	; 0xb40a <GPRS_CurDataSend+0x120>
		ptr[0] |= (1<<0);
    b404:	81 e0       	ldi	r24, 0x01	; 1
    b406:	90 e0       	ldi	r25, 0x00	; 0
    b408:	ac c0       	rjmp	.+344    	; 0xb562 <GPRS_CurDataSend+0x278>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    b40a:	e1 14       	cp	r14, r1
    b40c:	f1 04       	cpc	r15, r1
    b40e:	31 f4       	brne	.+12     	; 0xb41c <GPRS_CurDataSend+0x132>
    b410:	80 e2       	ldi	r24, 0x20	; 32
    b412:	90 e0       	ldi	r25, 0x00	; 0
    b414:	90 93 3e 0b 	sts	0x0B3E, r25
    b418:	80 93 3d 0b 	sts	0x0B3D, r24
		if(Ub==0) ptr[0] |= (1<<6);
    b41c:	01 15       	cp	r16, r1
    b41e:	11 05       	cpc	r17, r1
    b420:	49 f4       	brne	.+18     	; 0xb434 <GPRS_CurDataSend+0x14a>
    b422:	80 91 3d 0b 	lds	r24, 0x0B3D
    b426:	90 91 3e 0b 	lds	r25, 0x0B3E
    b42a:	80 64       	ori	r24, 0x40	; 64
    b42c:	90 93 3e 0b 	sts	0x0B3E, r25
    b430:	80 93 3d 0b 	sts	0x0B3D, r24
		if(Uc==0) ptr[0] |= (1<<7);
    b434:	20 97       	sbiw	r28, 0x00	; 0
    b436:	49 f4       	brne	.+18     	; 0xb44a <GPRS_CurDataSend+0x160>
    b438:	80 91 3d 0b 	lds	r24, 0x0B3D
    b43c:	90 91 3e 0b 	lds	r25, 0x0B3E
    b440:	80 68       	ori	r24, 0x80	; 128
    b442:	90 93 3e 0b 	sts	0x0B3E, r25
    b446:	80 93 3d 0b 	sts	0x0B3D, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    b44a:	40 91 43 09 	lds	r20, 0x0943
    b44e:	50 91 44 09 	lds	r21, 0x0944
    b452:	60 91 45 09 	lds	r22, 0x0945
    b456:	70 91 46 09 	lds	r23, 0x0946
    b45a:	80 91 ec 0a 	lds	r24, 0x0AEC
    b45e:	90 91 ed 0a 	lds	r25, 0x0AED
    b462:	a0 91 ee 0a 	lds	r26, 0x0AEE
    b466:	b0 91 ef 0a 	lds	r27, 0x0AEF
    b46a:	48 17       	cp	r20, r24
    b46c:	59 07       	cpc	r21, r25
    b46e:	6a 07       	cpc	r22, r26
    b470:	7b 07       	cpc	r23, r27
    b472:	59 f4       	brne	.+22     	; 0xb48a <GPRS_CurDataSend+0x1a0>
    b474:	20 91 25 09 	lds	r18, 0x0925
    b478:	30 91 26 09 	lds	r19, 0x0926
    b47c:	80 91 d9 09 	lds	r24, 0x09D9
    b480:	90 91 da 09 	lds	r25, 0x09DA
    b484:	28 17       	cp	r18, r24
    b486:	39 07       	cpc	r19, r25
    b488:	49 f0       	breq	.+18     	; 0xb49c <GPRS_CurDataSend+0x1b2>
    b48a:	80 91 3d 0b 	lds	r24, 0x0B3D
    b48e:	90 91 3e 0b 	lds	r25, 0x0B3E
    b492:	91 60       	ori	r25, 0x01	; 1
    b494:	90 93 3e 0b 	sts	0x0B3E, r25
    b498:	80 93 3d 0b 	sts	0x0B3D, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    b49c:	40 91 03 0b 	lds	r20, 0x0B03
    b4a0:	50 91 04 0b 	lds	r21, 0x0B04
    b4a4:	60 91 05 0b 	lds	r22, 0x0B05
    b4a8:	70 91 06 0b 	lds	r23, 0x0B06
    b4ac:	80 91 d2 09 	lds	r24, 0x09D2
    b4b0:	90 91 d3 09 	lds	r25, 0x09D3
    b4b4:	a0 91 d4 09 	lds	r26, 0x09D4
    b4b8:	b0 91 d5 09 	lds	r27, 0x09D5
    b4bc:	48 17       	cp	r20, r24
    b4be:	59 07       	cpc	r21, r25
    b4c0:	6a 07       	cpc	r22, r26
    b4c2:	7b 07       	cpc	r23, r27
    b4c4:	59 f4       	brne	.+22     	; 0xb4dc <GPRS_CurDataSend+0x1f2>
    b4c6:	20 91 0c 06 	lds	r18, 0x060C
    b4ca:	30 91 0d 06 	lds	r19, 0x060D
    b4ce:	80 91 ec 03 	lds	r24, 0x03EC
    b4d2:	90 91 ed 03 	lds	r25, 0x03ED
    b4d6:	28 17       	cp	r18, r24
    b4d8:	39 07       	cpc	r19, r25
    b4da:	49 f0       	breq	.+18     	; 0xb4ee <GPRS_CurDataSend+0x204>
    b4dc:	80 91 3d 0b 	lds	r24, 0x0B3D
    b4e0:	90 91 3e 0b 	lds	r25, 0x0B3E
    b4e4:	92 60       	ori	r25, 0x02	; 2
    b4e6:	90 93 3e 0b 	sts	0x0B3E, r25
    b4ea:	80 93 3d 0b 	sts	0x0B3D, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    b4ee:	40 91 e3 03 	lds	r20, 0x03E3
    b4f2:	50 91 e4 03 	lds	r21, 0x03E4
    b4f6:	60 91 e5 03 	lds	r22, 0x03E5
    b4fa:	70 91 e6 03 	lds	r23, 0x03E6
    b4fe:	80 91 08 06 	lds	r24, 0x0608
    b502:	90 91 09 06 	lds	r25, 0x0609
    b506:	a0 91 0a 06 	lds	r26, 0x060A
    b50a:	b0 91 0b 06 	lds	r27, 0x060B
    b50e:	48 17       	cp	r20, r24
    b510:	59 07       	cpc	r21, r25
    b512:	6a 07       	cpc	r22, r26
    b514:	7b 07       	cpc	r23, r27
    b516:	59 f4       	brne	.+22     	; 0xb52e <GPRS_CurDataSend+0x244>
    b518:	20 91 fd 0a 	lds	r18, 0x0AFD
    b51c:	30 91 fe 0a 	lds	r19, 0x0AFE
    b520:	80 91 25 0d 	lds	r24, 0x0D25
    b524:	90 91 26 0d 	lds	r25, 0x0D26
    b528:	28 17       	cp	r18, r24
    b52a:	39 07       	cpc	r19, r25
    b52c:	49 f0       	breq	.+18     	; 0xb540 <GPRS_CurDataSend+0x256>
    b52e:	80 91 3d 0b 	lds	r24, 0x0B3D
    b532:	90 91 3e 0b 	lds	r25, 0x0B3E
    b536:	94 60       	ori	r25, 0x04	; 4
    b538:	90 93 3e 0b 	sts	0x0B3E, r25
    b53c:	80 93 3d 0b 	sts	0x0B3D, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    b540:	80 91 38 09 	lds	r24, 0x0938
    b544:	90 91 39 09 	lds	r25, 0x0939
    b548:	a0 91 3a 09 	lds	r26, 0x093A
    b54c:	b0 91 3b 09 	lds	r27, 0x093B
    b550:	89 2b       	or	r24, r25
    b552:	8a 2b       	or	r24, r26
    b554:	8b 2b       	or	r24, r27
    b556:	49 f0       	breq	.+18     	; 0xb56a <GPRS_CurDataSend+0x280>
    b558:	80 91 3d 0b 	lds	r24, 0x0B3D
    b55c:	90 91 3e 0b 	lds	r25, 0x0B3E
    b560:	98 60       	ori	r25, 0x08	; 8
    b562:	90 93 3e 0b 	sts	0x0B3E, r25
    b566:	80 93 3d 0b 	sts	0x0B3D, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    b56a:	80 e0       	ldi	r24, 0x00	; 0
    b56c:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <DI_Status>
    b570:	81 11       	cpse	r24, r1
    b572:	09 c0       	rjmp	.+18     	; 0xb586 <GPRS_CurDataSend+0x29c>
    b574:	80 91 3d 0b 	lds	r24, 0x0B3D
    b578:	90 91 3e 0b 	lds	r25, 0x0B3E
    b57c:	82 60       	ori	r24, 0x02	; 2
    b57e:	90 93 3e 0b 	sts	0x0B3E, r25
    b582:	80 93 3d 0b 	sts	0x0B3D, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    b586:	81 e0       	ldi	r24, 0x01	; 1
    b588:	0e 94 ff 3b 	call	0x77fe	; 0x77fe <DI_Status>
    b58c:	81 11       	cpse	r24, r1
    b58e:	09 c0       	rjmp	.+18     	; 0xb5a2 <GPRS_CurDataSend+0x2b8>
    b590:	80 91 3d 0b 	lds	r24, 0x0B3D
    b594:	90 91 3e 0b 	lds	r25, 0x0B3E
    b598:	84 60       	ori	r24, 0x04	; 4
    b59a:	90 93 3e 0b 	sts	0x0B3E, r25
    b59e:	80 93 3d 0b 	sts	0x0B3D, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    b5a2:	c0 90 e5 05 	lds	r12, 0x05E5
    b5a6:	d0 90 e6 05 	lds	r13, 0x05E6
    b5aa:	c6 01       	movw	r24, r12
    b5ac:	90 58       	subi	r25, 0x80	; 128
    b5ae:	02 97       	sbiw	r24, 0x02	; 2
    b5b0:	00 f1       	brcs	.+64     	; 0xb5f2 <GPRS_CurDataSend+0x308>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b5b2:	8d e0       	ldi	r24, 0x0D	; 13
    b5b4:	90 e0       	ldi	r25, 0x00	; 0
    b5b6:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    b5ba:	c8 16       	cp	r12, r24
    b5bc:	d9 06       	cpc	r13, r25
    b5be:	4c f0       	brlt	.+18     	; 0xb5d2 <GPRS_CurDataSend+0x2e8>
    b5c0:	80 91 3d 0b 	lds	r24, 0x0B3D
    b5c4:	90 91 3e 0b 	lds	r25, 0x0B3E
    b5c8:	88 60       	ori	r24, 0x08	; 8
    b5ca:	90 93 3e 0b 	sts	0x0B3E, r25
    b5ce:	80 93 3d 0b 	sts	0x0B3D, r24
    b5d2:	8b e0       	ldi	r24, 0x0B	; 11
    b5d4:	90 e0       	ldi	r25, 0x00	; 0
    b5d6:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    b5da:	8c 15       	cp	r24, r12
    b5dc:	9d 05       	cpc	r25, r13
    b5de:	4c f0       	brlt	.+18     	; 0xb5f2 <GPRS_CurDataSend+0x308>
    b5e0:	80 91 3d 0b 	lds	r24, 0x0B3D
    b5e4:	90 91 3e 0b 	lds	r25, 0x0B3E
    b5e8:	80 61       	ori	r24, 0x10	; 16
    b5ea:	90 93 3e 0b 	sts	0x0B3E, r25
    b5ee:	80 93 3d 0b 	sts	0x0B3D, r24
	}

	ptr[1] = Temperature[0];
    b5f2:	d0 92 40 0b 	sts	0x0B40, r13
    b5f6:	c0 92 3f 0b 	sts	0x0B3F, r12

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    b5fa:	80 91 3e 02 	lds	r24, 0x023E
    b5fe:	90 91 3f 02 	lds	r25, 0x023F
    b602:	a0 91 40 02 	lds	r26, 0x0240
    b606:	b0 91 41 02 	lds	r27, 0x0241
    b60a:	80 93 41 0b 	sts	0x0B41, r24
    b60e:	90 93 42 0b 	sts	0x0B42, r25
    b612:	a0 93 43 0b 	sts	0x0B43, r26
    b616:	b0 93 44 0b 	sts	0x0B44, r27
	pi4[1] = E_Meter_RAM.Am;
    b61a:	80 91 42 02 	lds	r24, 0x0242
    b61e:	90 91 43 02 	lds	r25, 0x0243
    b622:	a0 91 44 02 	lds	r26, 0x0244
    b626:	b0 91 45 02 	lds	r27, 0x0245
    b62a:	80 93 45 0b 	sts	0x0B45, r24
    b62e:	90 93 46 0b 	sts	0x0B46, r25
    b632:	a0 93 47 0b 	sts	0x0B47, r26
    b636:	b0 93 48 0b 	sts	0x0B48, r27
	pi4[2] = E_Meter_RAM.Rp;
    b63a:	80 91 46 02 	lds	r24, 0x0246
    b63e:	90 91 47 02 	lds	r25, 0x0247
    b642:	a0 91 48 02 	lds	r26, 0x0248
    b646:	b0 91 49 02 	lds	r27, 0x0249
    b64a:	80 93 49 0b 	sts	0x0B49, r24
    b64e:	90 93 4a 0b 	sts	0x0B4A, r25
    b652:	a0 93 4b 0b 	sts	0x0B4B, r26
    b656:	b0 93 4c 0b 	sts	0x0B4C, r27
	pi4[3] = E_Meter_RAM.Rm;
    b65a:	80 91 4a 02 	lds	r24, 0x024A
    b65e:	90 91 4b 02 	lds	r25, 0x024B
    b662:	a0 91 4c 02 	lds	r26, 0x024C
    b666:	b0 91 4d 02 	lds	r27, 0x024D
    b66a:	80 93 4d 0b 	sts	0x0B4D, r24
    b66e:	90 93 4e 0b 	sts	0x0B4E, r25
    b672:	a0 93 4f 0b 	sts	0x0B4F, r26
    b676:	b0 93 50 0b 	sts	0x0B50, r27

	GPRS_Data_Out[53] = EM_Year;
    b67a:	80 91 6a 09 	lds	r24, 0x096A
    b67e:	80 93 51 0b 	sts	0x0B51, r24
	GPRS_Data_Out[54] = EM_Month;
    b682:	80 91 d1 09 	lds	r24, 0x09D1
    b686:	80 93 52 0b 	sts	0x0B52, r24
	GPRS_Data_Out[55] = EM_Day;
    b68a:	80 91 da 03 	lds	r24, 0x03DA
    b68e:	80 93 53 0b 	sts	0x0B53, r24
	GPRS_Data_Out[56] = EM_Hour;
    b692:	80 91 52 09 	lds	r24, 0x0952
    b696:	80 93 54 0b 	sts	0x0B54, r24
	GPRS_Data_Out[57] = EM_Min;
    b69a:	80 91 33 09 	lds	r24, 0x0933
    b69e:	80 93 55 0b 	sts	0x0B55, r24
	GPRS_Data_Out[58] = EM_Sec;
    b6a2:	80 91 00 06 	lds	r24, 0x0600
    b6a6:	80 93 56 0b 	sts	0x0B56, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
	ptr[0] = EM_PowerActive;
    b6aa:	80 91 53 0a 	lds	r24, 0x0A53
    b6ae:	90 91 54 0a 	lds	r25, 0x0A54
    b6b2:	90 93 58 0b 	sts	0x0B58, r25
    b6b6:	80 93 57 0b 	sts	0x0B57, r24
	ptr[1] = Ua;
    b6ba:	f0 92 5a 0b 	sts	0x0B5A, r15
    b6be:	e0 92 59 0b 	sts	0x0B59, r14
	ptr[2] = Ub;
    b6c2:	10 93 5c 0b 	sts	0x0B5C, r17
    b6c6:	00 93 5b 0b 	sts	0x0B5B, r16
	ptr[3] = Uc;
    b6ca:	d0 93 5e 0b 	sts	0x0B5E, r29
    b6ce:	c0 93 5d 0b 	sts	0x0B5D, r28
	ptr[4] = Ia;
    b6d2:	80 91 ea 03 	lds	r24, 0x03EA
    b6d6:	90 91 eb 03 	lds	r25, 0x03EB
    b6da:	90 93 60 0b 	sts	0x0B60, r25
    b6de:	80 93 5f 0b 	sts	0x0B5F, r24
	ptr[5] = Ib;
    b6e2:	80 91 2d 09 	lds	r24, 0x092D
    b6e6:	90 91 2e 09 	lds	r25, 0x092E
    b6ea:	90 93 62 0b 	sts	0x0B62, r25
    b6ee:	80 93 61 0b 	sts	0x0B61, r24
	ptr[6] = Ic;
    b6f2:	80 91 65 09 	lds	r24, 0x0965
    b6f6:	90 91 66 09 	lds	r25, 0x0966
    b6fa:	90 93 64 0b 	sts	0x0B64, r25
    b6fe:	80 93 63 0b 	sts	0x0B63, r24

	GPRS_Data_Out[73] = GSM_RSSI;
    b702:	80 91 17 06 	lds	r24, 0x0617
    b706:	80 93 65 0b 	sts	0x0B65, r24

	GPRS_FlgSz_Out = 74;	//    .     
    b70a:	8a e4       	ldi	r24, 0x4A	; 74
    b70c:	80 93 29 09 	sts	0x0929, r24
}
    b710:	df 91       	pop	r29
    b712:	cf 91       	pop	r28
    b714:	1f 91       	pop	r17
    b716:	0f 91       	pop	r16
    b718:	ff 90       	pop	r15
    b71a:	ef 90       	pop	r14
    b71c:	df 90       	pop	r13
    b71e:	cf 90       	pop	r12
    b720:	08 95       	ret

0000b722 <GPRS_SendData>:

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    b722:	cf 93       	push	r28
    b724:	df 93       	push	r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b726:	8a e0       	ldi	r24, 0x0A	; 10
    b728:	90 e0       	ldi	r25, 0x00	; 0
    b72a:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    b72e:	88 23       	and	r24, r24
    b730:	09 f4       	brne	.+2      	; 0xb734 <GPRS_SendData+0x12>
    b732:	59 c0       	rjmp	.+178    	; 0xb7e6 <GPRS_SendData+0xc4>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b734:	88 e0       	ldi	r24, 0x08	; 8
    b736:	90 e0       	ldi	r25, 0x00	; 0
    b738:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    b73c:	cc 97       	sbiw	r24, 0x3c	; 60
    b73e:	08 f4       	brcc	.+2      	; 0xb742 <GPRS_SendData+0x20>
    b740:	52 c0       	rjmp	.+164    	; 0xb7e6 <GPRS_SendData+0xc4>
		if(Timer1s != Timer1sOld){
    b742:	80 91 f2 0a 	lds	r24, 0x0AF2
    b746:	90 91 64 09 	lds	r25, 0x0964
    b74a:	89 17       	cp	r24, r25
    b74c:	91 f0       	breq	.+36     	; 0xb772 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    b74e:	80 93 64 09 	sts	0x0964, r24
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    b752:	c0 91 fb 0a 	lds	r28, 0x0AFB
    b756:	d0 91 fc 0a 	lds	r29, 0x0AFC
    b75a:	88 e0       	ldi	r24, 0x08	; 8
    b75c:	90 e0       	ldi	r25, 0x00	; 0
    b75e:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    b762:	c8 17       	cp	r28, r24
    b764:	d9 07       	cpc	r29, r25
    b766:	28 f4       	brcc	.+10     	; 0xb772 <GPRS_SendData+0x50>
    b768:	21 96       	adiw	r28, 0x01	; 1
    b76a:	d0 93 fc 0a 	sts	0x0AFC, r29
    b76e:	c0 93 fb 0a 	sts	0x0AFB, r28
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    b772:	c0 91 fb 0a 	lds	r28, 0x0AFB
    b776:	d0 91 fc 0a 	lds	r29, 0x0AFC
    b77a:	88 e0       	ldi	r24, 0x08	; 8
    b77c:	90 e0       	ldi	r25, 0x00	; 0
    b77e:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    b782:	4e 97       	sbiw	r24, 0x1e	; 30
    b784:	c8 17       	cp	r28, r24
    b786:	d9 07       	cpc	r29, r25
    b788:	29 f4       	brne	.+10     	; 0xb794 <GPRS_SendData+0x72>
			if(IsEMReady()) EMRead();			
    b78a:	0e 94 7a 51 	call	0xa2f4	; 0xa2f4 <IsEMReady>
    b78e:	81 11       	cpse	r24, r1
    b790:	0e 94 81 51 	call	0xa302	; 0xa302 <EMRead>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    b794:	c0 91 fb 0a 	lds	r28, 0x0AFB
    b798:	d0 91 fc 0a 	lds	r29, 0x0AFC
    b79c:	88 e0       	ldi	r24, 0x08	; 8
    b79e:	90 e0       	ldi	r25, 0x00	; 0
    b7a0:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    b7a4:	0f 97       	sbiw	r24, 0x0f	; 15
    b7a6:	c8 17       	cp	r28, r24
    b7a8:	d9 07       	cpc	r29, r25
    b7aa:	49 f4       	brne	.+18     	; 0xb7be <GPRS_SendData+0x9c>
			if(!EMeter_Link()){
    b7ac:	0e 94 0f 4e 	call	0x9c1e	; 0x9c1e <EMeter_Link>
    b7b0:	81 11       	cpse	r24, r1
    b7b2:	05 c0       	rjmp	.+10     	; 0xb7be <GPRS_SendData+0x9c>
				if(IsEMReady()) EMRead();
    b7b4:	0e 94 7a 51 	call	0xa2f4	; 0xa2f4 <IsEMReady>
    b7b8:	81 11       	cpse	r24, r1
    b7ba:	0e 94 81 51 	call	0xa302	; 0xa302 <EMRead>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    b7be:	c0 91 fb 0a 	lds	r28, 0x0AFB
    b7c2:	d0 91 fc 0a 	lds	r29, 0x0AFC
    b7c6:	88 e0       	ldi	r24, 0x08	; 8
    b7c8:	90 e0       	ldi	r25, 0x00	; 0
    b7ca:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    b7ce:	c8 17       	cp	r28, r24
    b7d0:	d9 07       	cpc	r29, r25
    b7d2:	48 f0       	brcs	.+18     	; 0xb7e6 <GPRS_SendData+0xc4>
			GPRS_DataTimer = 0;
    b7d4:	10 92 fc 0a 	sts	0x0AFC, r1
    b7d8:	10 92 fb 0a 	sts	0x0AFB, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    b7dc:	80 91 41 09 	lds	r24, 0x0941
    b7e0:	81 60       	ori	r24, 0x01	; 1
    b7e2:	80 93 41 09 	sts	0x0941, r24
		}
	}
}
    b7e6:	df 91       	pop	r29
    b7e8:	cf 91       	pop	r28
    b7ea:	08 95       	ret

0000b7ec <GPRS_NewMsg>:

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    b7ec:	90 91 4d 09 	lds	r25, 0x094D
    b7f0:	90 fd       	sbrc	r25, 0
    b7f2:	5b c0       	rjmp	.+182    	; 0xb8aa <GPRS_NewMsg+0xbe>
		GPRS_CrashID++;
    b7f4:	90 91 04 01 	lds	r25, 0x0104
    b7f8:	9f 5f       	subi	r25, 0xFF	; 255
    b7fa:	90 93 04 01 	sts	0x0104, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    b7fe:	26 e0       	ldi	r18, 0x06	; 6
    b800:	20 93 eb 09 	sts	0x09EB, r18
		GPRS_CrashData[1] = 1;	
    b804:	21 e0       	ldi	r18, 0x01	; 1
    b806:	20 93 ec 09 	sts	0x09EC, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    b80a:	30 91 5e 09 	lds	r19, 0x095E
    b80e:	30 93 ed 09 	sts	0x09ED, r19
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    b812:	30 91 5d 09 	lds	r19, 0x095D
    b816:	30 93 ee 09 	sts	0x09EE, r19
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    b81a:	30 91 5c 09 	lds	r19, 0x095C
    b81e:	30 93 ef 09 	sts	0x09EF, r19
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    b822:	30 91 5b 09 	lds	r19, 0x095B
    b826:	30 93 f0 09 	sts	0x09F0, r19
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    b82a:	30 91 5a 09 	lds	r19, 0x095A
    b82e:	30 93 f1 09 	sts	0x09F1, r19
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    b832:	30 91 59 09 	lds	r19, 0x0959
    b836:	30 93 f2 09 	sts	0x09F2, r19
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    b83a:	30 91 58 09 	lds	r19, 0x0958
    b83e:	30 93 f3 09 	sts	0x09F3, r19
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    b842:	30 91 57 09 	lds	r19, 0x0957
    b846:	30 93 f4 09 	sts	0x09F4, r19

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    b84a:	32 e0       	ldi	r19, 0x02	; 2
    b84c:	30 93 f5 09 	sts	0x09F5, r19
		GPRS_CrashData[11] = SW_VERSION;		//   
    b850:	33 e0       	ldi	r19, 0x03	; 3
    b852:	30 93 f6 09 	sts	0x09F6, r19
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    b856:	37 e0       	ldi	r19, 0x07	; 7
    b858:	30 93 f7 09 	sts	0x09F7, r19
		
		GPRS_CrashData[14] = Type;
    b85c:	80 93 f9 09 	sts	0x09F9, r24
		GPRS_CrashData[15] = 1;			//    
    b860:	20 93 fa 09 	sts	0x09FA, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    b864:	90 93 fb 09 	sts	0x09FB, r25

		GPRS_CrashData[17] = 0;
    b868:	10 92 fc 09 	sts	0x09FC, r1
		GPRS_CrashData[18] = 0;
    b86c:	10 92 fd 09 	sts	0x09FD, r1
		GPRS_CrashData[19] = 0;
    b870:	10 92 fe 09 	sts	0x09FE, r1
		GPRS_CrashData[20] = 0;
    b874:	10 92 ff 09 	sts	0x09FF, r1
		GPRS_CrashData[21] = 0;
    b878:	10 92 00 0a 	sts	0x0A00, r1
		GPRS_CrashData[22] = 0;
    b87c:	10 92 01 0a 	sts	0x0A01, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    b880:	42 e3       	ldi	r20, 0x32	; 50
    b882:	50 e0       	ldi	r21, 0x00	; 0
    b884:	82 e0       	ldi	r24, 0x02	; 2
    b886:	9a e0       	ldi	r25, 0x0A	; 10
    b888:	0e 94 b5 77 	call	0xef6a	; 0xef6a <strlcpy_P>
    b88c:	87 5f       	subi	r24, 0xF7	; 247
    b88e:	80 93 f8 09 	sts	0x09F8, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
    b892:	80 91 41 09 	lds	r24, 0x0941
    b896:	8f 7d       	andi	r24, 0xDF	; 223
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    b898:	80 64       	ori	r24, 0x40	; 64
    b89a:	80 93 41 09 	sts	0x0941, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    b89e:	60 ee       	ldi	r22, 0xE0	; 224
    b8a0:	7e e2       	ldi	r23, 0x2E	; 46
    b8a2:	80 91 01 06 	lds	r24, 0x0601
    b8a6:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>
    b8aa:	08 95       	ret

0000b8ac <GPRS_SendNewCrash>:
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    b8ac:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    b8ae:	c0 91 f8 09 	lds	r28, 0x09F8
    b8b2:	c2 5f       	subi	r28, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    b8b4:	4c 2f       	mov	r20, r28
    b8b6:	50 e0       	ldi	r21, 0x00	; 0
    b8b8:	6b ee       	ldi	r22, 0xEB	; 235
    b8ba:	79 e0       	ldi	r23, 0x09	; 9
    b8bc:	8c e1       	ldi	r24, 0x1C	; 28
    b8be:	9b e0       	ldi	r25, 0x0B	; 11
    b8c0:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    b8c4:	c0 93 29 09 	sts	0x0929, r28
}
    b8c8:	cf 91       	pop	r28
    b8ca:	08 95       	ret

0000b8cc <GPRS_SendRepCrash>:
// --      
void GPRS_SendRepCrash(void){
    b8cc:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    b8ce:	c0 91 f8 09 	lds	r28, 0x09F8
    b8d2:	c2 5f       	subi	r28, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    b8d4:	82 e0       	ldi	r24, 0x02	; 2
    b8d6:	80 93 fa 09 	sts	0x09FA, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    b8da:	4c 2f       	mov	r20, r28
    b8dc:	50 e0       	ldi	r21, 0x00	; 0
    b8de:	6b ee       	ldi	r22, 0xEB	; 235
    b8e0:	79 e0       	ldi	r23, 0x09	; 9
    b8e2:	8c e1       	ldi	r24, 0x1C	; 28
    b8e4:	9b e0       	ldi	r25, 0x0B	; 11
    b8e6:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    b8ea:	c0 93 29 09 	sts	0x0929, r28
}
    b8ee:	cf 91       	pop	r28
    b8f0:	08 95       	ret

0000b8f2 <GPRS_Check_PSW>:

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    b8f2:	0f 93       	push	r16
    b8f4:	1f 93       	push	r17
    b8f6:	cf 93       	push	r28
    b8f8:	df 93       	push	r29
    b8fa:	8c 01       	movw	r16, r24
    b8fc:	c0 e0       	ldi	r28, 0x00	; 0
    b8fe:	d0 e0       	ldi	r29, 0x00	; 0
    b900:	ce 01       	movw	r24, r28
    b902:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    b906:	08 17       	cp	r16, r24
    b908:	19 07       	cpc	r17, r25
    b90a:	59 f0       	breq	.+22     	; 0xb922 <GPRS_Check_PSW+0x30>
    b90c:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    b90e:	80 e0       	ldi	r24, 0x00	; 0
    b910:	c8 30       	cpi	r28, 0x08	; 8
    b912:	d8 07       	cpc	r29, r24
    b914:	a9 f7       	brne	.-22     	; 0xb900 <GPRS_Check_PSW+0xe>
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
    b916:	81 e0       	ldi	r24, 0x01	; 1
    b918:	0c 3f       	cpi	r16, 0xFC	; 252
    b91a:	18 45       	sbci	r17, 0x58	; 88
    b91c:	19 f0       	breq	.+6      	; 0xb924 <GPRS_Check_PSW+0x32>
    b91e:	80 e0       	ldi	r24, 0x00	; 0
    b920:	01 c0       	rjmp	.+2      	; 0xb924 <GPRS_Check_PSW+0x32>
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    b922:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(Pass == 22780) return 1;
	return 0;
}
    b924:	df 91       	pop	r29
    b926:	cf 91       	pop	r28
    b928:	1f 91       	pop	r17
    b92a:	0f 91       	pop	r16
    b92c:	08 95       	ret

0000b92e <GPRS_Get_Session_ID>:
	}
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
    b92e:	cf 93       	push	r28
    b930:	df 93       	push	r29
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    b932:	80 91 4d 09 	lds	r24, 0x094D
    b936:	83 ff       	sbrs	r24, 3
    b938:	05 c0       	rjmp	.+10     	; 0xb944 <GPRS_Get_Session_ID+0x16>
    b93a:	10 92 f4 0a 	sts	0x0AF4, r1
    b93e:	10 92 f3 0a 	sts	0x0AF3, r1
    b942:	12 c0       	rjmp	.+36     	; 0xb968 <GPRS_Get_Session_ID+0x3a>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    b944:	c0 91 34 09 	lds	r28, 0x0934

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    b948:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint16_t Time = Timer16[TimerN];
    b94c:	ec 2f       	mov	r30, r28
    b94e:	f0 e0       	ldi	r31, 0x00	; 0
    b950:	ee 0f       	add	r30, r30
    b952:	ff 1f       	adc	r31, r31
    b954:	e2 5e       	subi	r30, 0xE2	; 226
    b956:	fc 4f       	sbci	r31, 0xFC	; 252
    b958:	c0 81       	ld	r28, Z
    b95a:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    b95c:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
    b960:	d0 93 f4 0a 	sts	0x0AF4, r29
    b964:	c0 93 f3 0a 	sts	0x0AF3, r28
	GPRS_Data_Out[0] = 5;	//    
    b968:	85 e0       	ldi	r24, 0x05	; 5
    b96a:	80 93 1c 0b 	sts	0x0B1C, r24
	GPRS_Data_Out[1] = 1;	//   
    b96e:	81 e0       	ldi	r24, 0x01	; 1
    b970:	80 93 1d 0b 	sts	0x0B1D, r24
    b974:	8c e0       	ldi	r24, 0x0C	; 12
    b976:	91 e0       	ldi	r25, 0x01	; 1
    b978:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    b97c:	90 93 1e 0b 	sts	0x0B1E, r25
    b980:	8c e0       	ldi	r24, 0x0C	; 12
    b982:	91 e0       	ldi	r25, 0x01	; 1
    b984:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    b988:	80 93 1f 0b 	sts	0x0B1F, r24
	GPRS_Data_Out[4] = 4;
    b98c:	84 e0       	ldi	r24, 0x04	; 4
    b98e:	80 93 20 0b 	sts	0x0B20, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    b992:	80 91 f3 0a 	lds	r24, 0x0AF3
    b996:	90 91 f4 0a 	lds	r25, 0x0AF4
    b99a:	90 93 21 0b 	sts	0x0B21, r25
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    b99e:	80 93 22 0b 	sts	0x0B22, r24
	GPRS_FlgSz_Out = 7;					//    .     	
    b9a2:	87 e0       	ldi	r24, 0x07	; 7
    b9a4:	80 93 29 09 	sts	0x0929, r24
}
    b9a8:	df 91       	pop	r29
    b9aa:	cf 91       	pop	r28
    b9ac:	08 95       	ret

0000b9ae <GPRS_RemoteDisplayControl>:

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    b9ae:	6f e0       	ldi	r22, 0x0F	; 15
    b9b0:	80 e0       	ldi	r24, 0x00	; 0
    b9b2:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    b9b6:	80 91 4d 09 	lds	r24, 0x094D
    b9ba:	84 60       	ori	r24, 0x04	; 4
    b9bc:	80 93 4d 09 	sts	0x094D, r24
    b9c0:	08 95       	ret

0000b9c2 <GPRS_SendDisplay>:
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
	GPRS_Data_Out[0] = 5;	//    
    b9c2:	85 e0       	ldi	r24, 0x05	; 5
    b9c4:	80 93 1c 0b 	sts	0x0B1C, r24
	GPRS_Data_Out[1] = 1;	//   
    b9c8:	81 e0       	ldi	r24, 0x01	; 1
    b9ca:	80 93 1d 0b 	sts	0x0B1D, r24
    b9ce:	8c e0       	ldi	r24, 0x0C	; 12
    b9d0:	91 e0       	ldi	r25, 0x01	; 1
    b9d2:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    b9d6:	90 93 1e 0b 	sts	0x0B1E, r25
    b9da:	8c e0       	ldi	r24, 0x0C	; 12
    b9dc:	91 e0       	ldi	r25, 0x01	; 1
    b9de:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    b9e2:	80 93 1f 0b 	sts	0x0B1F, r24
	GPRS_Data_Out[4] = 3;
    b9e6:	83 e0       	ldi	r24, 0x03	; 3
    b9e8:	80 93 20 0b 	sts	0x0B20, r24
	GPRS_Data_Out[5] = 34;
    b9ec:	82 e2       	ldi	r24, 0x22	; 34
    b9ee:	80 93 21 0b 	sts	0x0B21, r24
	GPRS_Data_Out[6] = 10;
    b9f2:	8a e0       	ldi	r24, 0x0A	; 10
    b9f4:	80 93 22 0b 	sts	0x0B22, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    b9f8:	80 93 23 0b 	sts	0x0B23, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    b9fc:	88 e2       	ldi	r24, 0x28	; 40
    b9fe:	80 93 29 09 	sts	0x0929, r24
    ba02:	08 95       	ret

0000ba04 <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    ba04:	cf 93       	push	r28
    ba06:	c8 2f       	mov	r28, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    ba08:	48 2f       	mov	r20, r24
    ba0a:	50 e0       	ldi	r21, 0x00	; 0
    ba0c:	6f e2       	ldi	r22, 0x2F	; 47
    ba0e:	76 e0       	ldi	r23, 0x06	; 6
    ba10:	8c e1       	ldi	r24, 0x1C	; 28
    ba12:	9b e0       	ldi	r25, 0x0B	; 11
    ba14:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    ba18:	c0 93 29 09 	sts	0x0929, r28
}
    ba1c:	cf 91       	pop	r28
    ba1e:	08 95       	ret

0000ba20 <GPRS_ReadParamReply>:
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    ba20:	1f 93       	push	r17
    ba22:	cf 93       	push	r28
    ba24:	df 93       	push	r29
    ba26:	00 d0       	rcall	.+0      	; 0xba28 <GPRS_ReadParamReply+0x8>
    ba28:	cd b7       	in	r28, 0x3d	; 61
    ba2a:	de b7       	in	r29, 0x3e	; 62
    ba2c:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    ba2e:	85 e0       	ldi	r24, 0x05	; 5
    ba30:	80 93 2f 06 	sts	0x062F, r24
	GPRS_ChangeData[1] = 1;	
    ba34:	81 e0       	ldi	r24, 0x01	; 1
    ba36:	80 93 30 06 	sts	0x0630, r24
    ba3a:	8c e0       	ldi	r24, 0x0C	; 12
    ba3c:	91 e0       	ldi	r25, 0x01	; 1
    ba3e:	4a 83       	std	Y+2, r20	; 0x02
    ba40:	69 83       	std	Y+1, r22	; 0x01
    ba42:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    ba46:	90 93 31 06 	sts	0x0631, r25
    ba4a:	8c e0       	ldi	r24, 0x0C	; 12
    ba4c:	91 e0       	ldi	r25, 0x01	; 1
    ba4e:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    ba52:	80 93 32 06 	sts	0x0632, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    ba56:	83 e0       	ldi	r24, 0x03	; 3
    ba58:	80 93 33 06 	sts	0x0633, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    ba5c:	4a 81       	ldd	r20, Y+2	; 0x02
    ba5e:	4d 5f       	subi	r20, 0xFD	; 253
    ba60:	40 93 34 06 	sts	0x0634, r20
	GPRS_ChangeData[6] = 7;
    ba64:	87 e0       	ldi	r24, 0x07	; 7
    ba66:	80 93 35 06 	sts	0x0635, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    ba6a:	10 93 36 06 	sts	0x0636, r17
	GPRS_ChangeData[8] = ParamID_Lo;
    ba6e:	69 81       	ldd	r22, Y+1	; 0x01
    ba70:	60 93 37 06 	sts	0x0637, r22
}
    ba74:	0f 90       	pop	r0
    ba76:	0f 90       	pop	r0
    ba78:	df 91       	pop	r29
    ba7a:	cf 91       	pop	r28
    ba7c:	1f 91       	pop	r17
    ba7e:	08 95       	ret

0000ba80 <GPRS_WriteParamReply>:
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    ba80:	1f 93       	push	r17
    ba82:	cf 93       	push	r28
    ba84:	df 93       	push	r29
    ba86:	1f 92       	push	r1
    ba88:	cd b7       	in	r28, 0x3d	; 61
    ba8a:	de b7       	in	r29, 0x3e	; 62
    ba8c:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    ba8e:	85 e0       	ldi	r24, 0x05	; 5
    ba90:	80 93 2f 06 	sts	0x062F, r24
	GPRS_ChangeData[1] = 1;	
    ba94:	81 e0       	ldi	r24, 0x01	; 1
    ba96:	80 93 30 06 	sts	0x0630, r24
    ba9a:	8c e0       	ldi	r24, 0x0C	; 12
    ba9c:	91 e0       	ldi	r25, 0x01	; 1
    ba9e:	69 83       	std	Y+1, r22	; 0x01
    baa0:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    baa4:	90 93 31 06 	sts	0x0631, r25
    baa8:	8c e0       	ldi	r24, 0x0C	; 12
    baaa:	91 e0       	ldi	r25, 0x01	; 1
    baac:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    bab0:	80 93 32 06 	sts	0x0632, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    bab4:	93 e0       	ldi	r25, 0x03	; 3
    bab6:	90 93 33 06 	sts	0x0633, r25
	GPRS_ChangeData[5] = 3;	// -       
    baba:	90 93 34 06 	sts	0x0634, r25
	GPRS_ChangeData[6] = 8;
    babe:	88 e0       	ldi	r24, 0x08	; 8
    bac0:	80 93 35 06 	sts	0x0635, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    bac4:	10 93 36 06 	sts	0x0636, r17
	GPRS_ChangeData[8] = ParamID_Lo;	
    bac8:	69 81       	ldd	r22, Y+1	; 0x01
    baca:	60 93 37 06 	sts	0x0637, r22
}
    bace:	0f 90       	pop	r0
    bad0:	df 91       	pop	r29
    bad2:	cf 91       	pop	r28
    bad4:	1f 91       	pop	r17
    bad6:	08 95       	ret

0000bad8 <GPRS_Param>:

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    bad8:	cf 92       	push	r12
    bada:	ef 92       	push	r14
    badc:	0f 93       	push	r16
    bade:	1f 93       	push	r17
    bae0:	cf 93       	push	r28
    bae2:	df 93       	push	r29
    bae4:	d8 2f       	mov	r29, r24
    bae6:	16 2f       	mov	r17, r22
    bae8:	ca 01       	movw	r24, r20
    baea:	c2 2f       	mov	r28, r18
	if(Cmd==READ_PARAM ){
    baec:	01 3c       	cpi	r16, 0xC1	; 193
    baee:	b9 f4       	brne	.+46     	; 0xbb1e <GPRS_Param+0x46>
		if(MemCopy){
    baf0:	ee 20       	and	r14, r14
    baf2:	61 f0       	breq	.+24     	; 0xbb0c <GPRS_Param+0x34>
    baf4:	42 2f       	mov	r20, r18
    baf6:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    baf8:	bc 01       	movw	r22, r24
    bafa:	88 e3       	ldi	r24, 0x38	; 56
    bafc:	96 e0       	ldi	r25, 0x06	; 6
    bafe:	cc 20       	and	r12, r12
    bb00:	19 f0       	breq	.+6      	; 0xbb08 <GPRS_Param+0x30>
    bb02:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
    bb06:	02 c0       	rjmp	.+4      	; 0xbb0c <GPRS_Param+0x34>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    bb08:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    bb0c:	4c 2f       	mov	r20, r28
    bb0e:	61 2f       	mov	r22, r17
    bb10:	8d 2f       	mov	r24, r29
    bb12:	0e 94 10 5d 	call	0xba20	; 0xba20 <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    bb16:	c7 5f       	subi	r28, 0xF7	; 247
    bb18:	c0 93 03 06 	sts	0x0603, r28
    bb1c:	19 c0       	rjmp	.+50     	; 0xbb50 <GPRS_Param+0x78>
	}
	if(Cmd==WRITE_PARAM){
    bb1e:	0c 34       	cpi	r16, 0x4C	; 76
    bb20:	b9 f4       	brne	.+46     	; 0xbb50 <GPRS_Param+0x78>
		if(MemCopy){
    bb22:	ee 20       	and	r14, r14
    bb24:	71 f0       	breq	.+28     	; 0xbb42 <GPRS_Param+0x6a>
    bb26:	42 2f       	mov	r20, r18
    bb28:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    bb2a:	cc 20       	and	r12, r12
    bb2c:	29 f0       	breq	.+10     	; 0xbb38 <GPRS_Param+0x60>
    bb2e:	6a e3       	ldi	r22, 0x3A	; 58
    bb30:	78 e0       	ldi	r23, 0x08	; 8
    bb32:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
    bb36:	05 c0       	rjmp	.+10     	; 0xbb42 <GPRS_Param+0x6a>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    bb38:	bc 01       	movw	r22, r24
    bb3a:	8a e3       	ldi	r24, 0x3A	; 58
    bb3c:	98 e0       	ldi	r25, 0x08	; 8
    bb3e:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    bb42:	61 2f       	mov	r22, r17
    bb44:	8d 2f       	mov	r24, r29
    bb46:	0e 94 40 5d 	call	0xba80	; 0xba80 <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    bb4a:	89 e0       	ldi	r24, 0x09	; 9
    bb4c:	80 93 03 06 	sts	0x0603, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    bb50:	80 91 41 09 	lds	r24, 0x0941
    bb54:	88 60       	ori	r24, 0x08	; 8
    bb56:	80 93 41 09 	sts	0x0941, r24
}
    bb5a:	df 91       	pop	r29
    bb5c:	cf 91       	pop	r28
    bb5e:	1f 91       	pop	r17
    bb60:	0f 91       	pop	r16
    bb62:	ef 90       	pop	r14
    bb64:	cf 90       	pop	r12
    bb66:	08 95       	ret

0000bb68 <GPRS_CriticalCMD_Process>:

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    bb68:	80 91 db 03 	lds	r24, 0x03DB
    bb6c:	88 23       	and	r24, r24
    bb6e:	f9 f0       	breq	.+62     	; 0xbbae <GPRS_CriticalCMD_Process+0x46>
    bb70:	80 91 f0 0a 	lds	r24, 0x0AF0
    bb74:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    bb78:	88 23       	and	r24, r24
    bb7a:	c9 f0       	breq	.+50     	; 0xbbae <GPRS_CriticalCMD_Process+0x46>
		switch(GPRS_CriticalCMD){
    bb7c:	80 91 db 03 	lds	r24, 0x03DB
    bb80:	82 30       	cpi	r24, 0x02	; 2
    bb82:	69 f0       	breq	.+26     	; 0xbb9e <GPRS_CriticalCMD_Process+0x36>
    bb84:	20 f4       	brcc	.+8      	; 0xbb8e <GPRS_CriticalCMD_Process+0x26>
    bb86:	81 30       	cpi	r24, 0x01	; 1
    bb88:	81 f4       	brne	.+32     	; 0xbbaa <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    bb8a:	f8 94       	cli
    bb8c:	07 c0       	rjmp	.+14     	; 0xbb9c <GPRS_CriticalCMD_Process+0x34>
    bb8e:	83 30       	cpi	r24, 0x03	; 3
    bb90:	51 f0       	breq	.+20     	; 0xbba6 <GPRS_CriticalCMD_Process+0x3e>
    bb92:	84 30       	cpi	r24, 0x04	; 4
    bb94:	51 f4       	brne	.+20     	; 0xbbaa <GPRS_CriticalCMD_Process+0x42>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
			case GPRS_UPDATER:		Start_Updater(); break;
    bb96:	0e 94 7b 29 	call	0x52f6	; 0x52f6 <Start_Updater>
    bb9a:	07 c0       	rjmp	.+14     	; 0xbbaa <GPRS_CriticalCMD_Process+0x42>
    bb9c:	ff cf       	rjmp	.-2      	; 0xbb9c <GPRS_CriticalCMD_Process+0x34>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    bb9e:	8f e4       	ldi	r24, 0x4F	; 79
    bba0:	80 93 19 06 	sts	0x0619, r24
    bba4:	02 c0       	rjmp	.+4      	; 0xbbaa <GPRS_CriticalCMD_Process+0x42>
void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
		switch(GPRS_CriticalCMD){
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    bba6:	0e 94 48 2a 	call	0x5490	; 0x5490 <Start_Bootloader>
			case GPRS_UPDATER:		Start_Updater(); break;
		}
		GPRS_CriticalCMD = 0;
    bbaa:	10 92 db 03 	sts	0x03DB, r1
    bbae:	08 95       	ret

0000bbb0 <GPRS_Param00>:
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    bbb0:	cf 92       	push	r12
    bbb2:	ef 92       	push	r14
    bbb4:	0f 93       	push	r16
    bbb6:	cf 93       	push	r28
    bbb8:	c8 2f       	mov	r28, r24
    bbba:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    bbbc:	84 30       	cpi	r24, 0x04	; 4
    bbbe:	61 f1       	breq	.+88     	; 0xbc18 <GPRS_Param00+0x68>
    bbc0:	28 f4       	brcc	.+10     	; 0xbbcc <GPRS_Param00+0x1c>
    bbc2:	81 30       	cpi	r24, 0x01	; 1
    bbc4:	49 f0       	breq	.+18     	; 0xbbd8 <GPRS_Param00+0x28>
    bbc6:	82 30       	cpi	r24, 0x02	; 2
    bbc8:	89 f0       	breq	.+34     	; 0xbbec <GPRS_Param00+0x3c>
    bbca:	50 c0       	rjmp	.+160    	; 0xbc6c <GPRS_Param00+0xbc>
    bbcc:	86 30       	cpi	r24, 0x06	; 6
    bbce:	a1 f1       	breq	.+104    	; 0xbc38 <GPRS_Param00+0x88>
    bbd0:	58 f1       	brcs	.+86     	; 0xbc28 <GPRS_Param00+0x78>
    bbd2:	87 30       	cpi	r24, 0x07	; 7
    bbd4:	c9 f1       	breq	.+114    	; 0xbc48 <GPRS_Param00+0x98>
    bbd6:	4a c0       	rjmp	.+148    	; 0xbc6c <GPRS_Param00+0xbc>
		case 1:	if(Cmd==READ_PARAM){
    bbd8:	61 3c       	cpi	r22, 0xC1	; 193
    bbda:	09 f0       	breq	.+2      	; 0xbbde <GPRS_Param00+0x2e>
    bbdc:	47 c0       	rjmp	.+142    	; 0xbc6c <GPRS_Param00+0xbc>
					GPRS_ChangeData[9] = SW_VERSION;
    bbde:	83 e0       	ldi	r24, 0x03	; 3
    bbe0:	80 93 38 06 	sts	0x0638, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    bbe4:	87 e0       	ldi	r24, 0x07	; 7
    bbe6:	80 93 39 06 	sts	0x0639, r24
    bbea:	3e c0       	rjmp	.+124    	; 0xbc68 <GPRS_Param00+0xb8>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    bbec:	61 3c       	cpi	r22, 0xC1	; 193
    bbee:	49 f4       	brne	.+18     	; 0xbc02 <GPRS_Param00+0x52>
    bbf0:	42 e0       	ldi	r20, 0x02	; 2
    bbf2:	50 e0       	ldi	r21, 0x00	; 0
    bbf4:	6c e0       	ldi	r22, 0x0C	; 12
    bbf6:	71 e0       	ldi	r23, 0x01	; 1
    bbf8:	88 e3       	ldi	r24, 0x38	; 56
    bbfa:	96 e0       	ldi	r25, 0x06	; 6
    bbfc:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    bc00:	33 c0       	rjmp	.+102    	; 0xbc68 <GPRS_Param00+0xb8>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    bc02:	6c 34       	cpi	r22, 0x4C	; 76
    bc04:	89 f5       	brne	.+98     	; 0xbc68 <GPRS_Param00+0xb8>
    bc06:	42 e0       	ldi	r20, 0x02	; 2
    bc08:	50 e0       	ldi	r21, 0x00	; 0
    bc0a:	6c e0       	ldi	r22, 0x0C	; 12
    bc0c:	71 e0       	ldi	r23, 0x01	; 1
    bc0e:	8a e3       	ldi	r24, 0x3A	; 58
    bc10:	98 e0       	ldi	r25, 0x08	; 8
    bc12:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
    bc16:	28 c0       	rjmp	.+80     	; 0xbc68 <GPRS_Param00+0xb8>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    bc18:	6c 34       	cpi	r22, 0x4C	; 76
    bc1a:	41 f5       	brne	.+80     	; 0xbc6c <GPRS_Param00+0xbc>
    bc1c:	80 91 3a 08 	lds	r24, 0x083A
    bc20:	88 23       	and	r24, r24
    bc22:	21 f1       	breq	.+72     	; 0xbc6c <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    bc24:	81 e0       	ldi	r24, 0x01	; 1
    bc26:	17 c0       	rjmp	.+46     	; 0xbc56 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    bc28:	6c 34       	cpi	r22, 0x4C	; 76
    bc2a:	01 f5       	brne	.+64     	; 0xbc6c <GPRS_Param00+0xbc>
    bc2c:	80 91 3a 08 	lds	r24, 0x083A
    bc30:	88 23       	and	r24, r24
    bc32:	e1 f0       	breq	.+56     	; 0xbc6c <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    bc34:	82 e0       	ldi	r24, 0x02	; 2
    bc36:	0f c0       	rjmp	.+30     	; 0xbc56 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    bc38:	6c 34       	cpi	r22, 0x4C	; 76
    bc3a:	c1 f4       	brne	.+48     	; 0xbc6c <GPRS_Param00+0xbc>
    bc3c:	80 91 3a 08 	lds	r24, 0x083A
    bc40:	88 23       	and	r24, r24
    bc42:	a1 f0       	breq	.+40     	; 0xbc6c <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    bc44:	83 e0       	ldi	r24, 0x03	; 3
    bc46:	07 c0       	rjmp	.+14     	; 0xbc56 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    bc48:	6c 34       	cpi	r22, 0x4C	; 76
    bc4a:	81 f4       	brne	.+32     	; 0xbc6c <GPRS_Param00+0xbc>
    bc4c:	80 91 3a 08 	lds	r24, 0x083A
    bc50:	88 23       	and	r24, r24
    bc52:	61 f0       	breq	.+24     	; 0xbc6c <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    bc54:	84 e0       	ldi	r24, 0x04	; 4
    bc56:	80 93 db 03 	sts	0x03DB, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    bc5a:	60 e9       	ldi	r22, 0x90	; 144
    bc5c:	71 e0       	ldi	r23, 0x01	; 1
    bc5e:	80 91 f0 0a 	lds	r24, 0x0AF0
    bc62:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    bc66:	02 c0       	rjmp	.+4      	; 0xbc6c <GPRS_Param00+0xbc>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
				param_size = sizeof(Vega_SN);
    bc68:	22 e0       	ldi	r18, 0x02	; 2
    bc6a:	01 c0       	rjmp	.+2      	; 0xbc6e <GPRS_Param00+0xbe>
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
	uint8_t param_size = 0;
    bc6c:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    bc6e:	c1 2c       	mov	r12, r1
    bc70:	e1 2c       	mov	r14, r1
    bc72:	40 e0       	ldi	r20, 0x00	; 0
    bc74:	50 e0       	ldi	r21, 0x00	; 0
    bc76:	6c 2f       	mov	r22, r28
    bc78:	80 e0       	ldi	r24, 0x00	; 0
    bc7a:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bc7e:	cf 91       	pop	r28
    bc80:	0f 91       	pop	r16
    bc82:	ef 90       	pop	r14
    bc84:	cf 90       	pop	r12
    bc86:	08 95       	ret

0000bc88 <GPRS_Param01>:
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bc88:	cf 92       	push	r12
    bc8a:	ef 92       	push	r14
    bc8c:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    bc8e:	c1 2c       	mov	r12, r1
    bc90:	e1 2c       	mov	r14, r1
    bc92:	06 2f       	mov	r16, r22
    bc94:	20 e0       	ldi	r18, 0x00	; 0
    bc96:	40 e0       	ldi	r20, 0x00	; 0
    bc98:	50 e0       	ldi	r21, 0x00	; 0
    bc9a:	68 2f       	mov	r22, r24
    bc9c:	81 e0       	ldi	r24, 0x01	; 1
    bc9e:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bca2:	0f 91       	pop	r16
    bca4:	ef 90       	pop	r14
    bca6:	cf 90       	pop	r12
    bca8:	08 95       	ret

0000bcaa <GPRS_Param02>:
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bcaa:	cf 92       	push	r12
    bcac:	ef 92       	push	r14
    bcae:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    bcb0:	c1 2c       	mov	r12, r1
    bcb2:	e1 2c       	mov	r14, r1
    bcb4:	06 2f       	mov	r16, r22
    bcb6:	21 e0       	ldi	r18, 0x01	; 1
    bcb8:	40 e0       	ldi	r20, 0x00	; 0
    bcba:	50 e0       	ldi	r21, 0x00	; 0
    bcbc:	68 2f       	mov	r22, r24
    bcbe:	82 e0       	ldi	r24, 0x02	; 2
    bcc0:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bcc4:	0f 91       	pop	r16
    bcc6:	ef 90       	pop	r14
    bcc8:	cf 90       	pop	r12
    bcca:	08 95       	ret

0000bccc <GPRS_Param03>:
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bccc:	cf 92       	push	r12
    bcce:	ef 92       	push	r14
    bcd0:	0f 93       	push	r16
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bcd2:	c1 2c       	mov	r12, r1
    bcd4:	ee 24       	eor	r14, r14
    bcd6:	e3 94       	inc	r14
    bcd8:	06 2f       	mov	r16, r22
    bcda:	20 e0       	ldi	r18, 0x00	; 0
    bcdc:	40 e0       	ldi	r20, 0x00	; 0
    bcde:	50 e0       	ldi	r21, 0x00	; 0
    bce0:	68 2f       	mov	r22, r24
    bce2:	83 e0       	ldi	r24, 0x03	; 3
    bce4:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bce8:	0f 91       	pop	r16
    bcea:	ef 90       	pop	r14
    bcec:	cf 90       	pop	r12
    bcee:	08 95       	ret

0000bcf0 <GPRS_Param04>:

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bcf0:	cf 92       	push	r12
    bcf2:	ef 92       	push	r14
    bcf4:	0f 93       	push	r16
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bcf6:	c1 2c       	mov	r12, r1
    bcf8:	ee 24       	eor	r14, r14
    bcfa:	e3 94       	inc	r14
    bcfc:	06 2f       	mov	r16, r22
    bcfe:	20 e0       	ldi	r18, 0x00	; 0
    bd00:	40 e0       	ldi	r20, 0x00	; 0
    bd02:	50 e0       	ldi	r21, 0x00	; 0
    bd04:	68 2f       	mov	r22, r24
    bd06:	84 e0       	ldi	r24, 0x04	; 4
    bd08:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bd0c:	0f 91       	pop	r16
    bd0e:	ef 90       	pop	r14
    bd10:	cf 90       	pop	r12
    bd12:	08 95       	ret

0000bd14 <GPRS_Param05>:

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bd14:	cf 92       	push	r12
    bd16:	ef 92       	push	r14
    bd18:	0f 93       	push	r16
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bd1a:	c1 2c       	mov	r12, r1
    bd1c:	ee 24       	eor	r14, r14
    bd1e:	e3 94       	inc	r14
    bd20:	06 2f       	mov	r16, r22
    bd22:	20 e0       	ldi	r18, 0x00	; 0
    bd24:	40 e0       	ldi	r20, 0x00	; 0
    bd26:	50 e0       	ldi	r21, 0x00	; 0
    bd28:	68 2f       	mov	r22, r24
    bd2a:	85 e0       	ldi	r24, 0x05	; 5
    bd2c:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bd30:	0f 91       	pop	r16
    bd32:	ef 90       	pop	r14
    bd34:	cf 90       	pop	r12
    bd36:	08 95       	ret

0000bd38 <GPRS_Param06>:

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bd38:	cf 92       	push	r12
    bd3a:	ef 92       	push	r14
    bd3c:	0f 93       	push	r16
    bd3e:	2f ef       	ldi	r18, 0xFF	; 255
    bd40:	28 0f       	add	r18, r24
    bd42:	27 30       	cpi	r18, 0x07	; 7
    bd44:	68 f4       	brcc	.+26     	; 0xbd60 <GPRS_Param06+0x28>
    bd46:	30 e0       	ldi	r19, 0x00	; 0
    bd48:	f9 01       	movw	r30, r18
    bd4a:	ee 0f       	add	r30, r30
    bd4c:	ff 1f       	adc	r31, r31
    bd4e:	ee 51       	subi	r30, 0x1E	; 30
    bd50:	fe 4f       	sbci	r31, 0xFE	; 254
    bd52:	40 81       	ld	r20, Z
    bd54:	51 81       	ldd	r21, Z+1	; 0x01
    bd56:	f9 01       	movw	r30, r18
    bd58:	e5 52       	subi	r30, 0x25	; 37
    bd5a:	fe 4f       	sbci	r31, 0xFE	; 254
    bd5c:	20 81       	ld	r18, Z
    bd5e:	03 c0       	rjmp	.+6      	; 0xbd66 <GPRS_Param06+0x2e>
    bd60:	20 e0       	ldi	r18, 0x00	; 0
    bd62:	40 e0       	ldi	r20, 0x00	; 0
    bd64:	50 e0       	ldi	r21, 0x00	; 0
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bd66:	c1 2c       	mov	r12, r1
    bd68:	ee 24       	eor	r14, r14
    bd6a:	e3 94       	inc	r14
    bd6c:	06 2f       	mov	r16, r22
    bd6e:	68 2f       	mov	r22, r24
    bd70:	86 e0       	ldi	r24, 0x06	; 6
    bd72:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bd76:	0f 91       	pop	r16
    bd78:	ef 90       	pop	r14
    bd7a:	cf 90       	pop	r12
    bd7c:	08 95       	ret

0000bd7e <GPRS_Param07>:
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bd7e:	cf 92       	push	r12
    bd80:	ef 92       	push	r14
    bd82:	0f 93       	push	r16
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bd84:	c1 2c       	mov	r12, r1
    bd86:	ee 24       	eor	r14, r14
    bd88:	e3 94       	inc	r14
    bd8a:	06 2f       	mov	r16, r22
    bd8c:	20 e0       	ldi	r18, 0x00	; 0
    bd8e:	40 e0       	ldi	r20, 0x00	; 0
    bd90:	50 e0       	ldi	r21, 0x00	; 0
    bd92:	68 2f       	mov	r22, r24
    bd94:	87 e0       	ldi	r24, 0x07	; 7
    bd96:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bd9a:	0f 91       	pop	r16
    bd9c:	ef 90       	pop	r14
    bd9e:	cf 90       	pop	r12
    bda0:	08 95       	ret

0000bda2 <GPRS_Param08>:

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bda2:	cf 92       	push	r12
    bda4:	ef 92       	push	r14
    bda6:	0f 93       	push	r16
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    bda8:	c1 2c       	mov	r12, r1
    bdaa:	ee 24       	eor	r14, r14
    bdac:	e3 94       	inc	r14
    bdae:	06 2f       	mov	r16, r22
    bdb0:	20 e0       	ldi	r18, 0x00	; 0
    bdb2:	40 e0       	ldi	r20, 0x00	; 0
    bdb4:	50 e0       	ldi	r21, 0x00	; 0
    bdb6:	68 2f       	mov	r22, r24
    bdb8:	88 e0       	ldi	r24, 0x08	; 8
    bdba:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bdbe:	0f 91       	pop	r16
    bdc0:	ef 90       	pop	r14
    bdc2:	cf 90       	pop	r12
    bdc4:	08 95       	ret

0000bdc6 <GPRS_Param09>:

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bdc6:	cf 92       	push	r12
    bdc8:	ef 92       	push	r14
    bdca:	0f 93       	push	r16
    bdcc:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    bdce:	48 2f       	mov	r20, r24
    bdd0:	50 e0       	ldi	r21, 0x00	; 0
    bdd2:	fa 01       	movw	r30, r20
    bdd4:	31 97       	sbiw	r30, 0x01	; 1
    bdd6:	e6 31       	cpi	r30, 0x16	; 22
    bdd8:	f1 05       	cpc	r31, r1
    bdda:	08 f0       	brcs	.+2      	; 0xbdde <GPRS_Param09+0x18>
    bddc:	78 c0       	rjmp	.+240    	; 0xbece <GPRS_Param09+0x108>
    bdde:	eb 54       	subi	r30, 0x4B	; 75
    bde0:	ff 4f       	sbci	r31, 0xFF	; 255
    bde2:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
    bde6:	23 e1       	ldi	r18, 0x13	; 19
    bde8:	4a e3       	ldi	r20, 0x3A	; 58
    bdea:	51 e0       	ldi	r21, 0x01	; 1
    bdec:	7b c0       	rjmp	.+246    	; 0xbee4 <GPRS_Param09+0x11e>
void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:
			if(Cmd==READ_PARAM){
    bdee:	61 3c       	cpi	r22, 0xC1	; 193
    bdf0:	91 f4       	brne	.+36     	; 0xbe16 <GPRS_Param09+0x50>
    bdf2:	4f e0       	ldi	r20, 0x0F	; 15
    bdf4:	50 e0       	ldi	r21, 0x00	; 0
    bdf6:	62 e6       	ldi	r22, 0x62	; 98
    bdf8:	71 e0       	ldi	r23, 0x01	; 1
    bdfa:	88 e3       	ldi	r24, 0x38	; 56
    bdfc:	96 e0       	ldi	r25, 0x06	; 6
    bdfe:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    be02:	4f e0       	ldi	r20, 0x0F	; 15
    be04:	50 e0       	ldi	r21, 0x00	; 0
    be06:	60 e8       	ldi	r22, 0x80	; 128
    be08:	71 e0       	ldi	r23, 0x01	; 1
    be0a:	87 e4       	ldi	r24, 0x47	; 71
    be0c:	96 e0       	ldi	r25, 0x06	; 6
    be0e:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
    be12:	2e e1       	ldi	r18, 0x1E	; 30
    be14:	5f c0       	rjmp	.+190    	; 0xbed4 <GPRS_Param09+0x10e>
			}
			if(Cmd==WRITE_PARAM){
    be16:	6c 34       	cpi	r22, 0x4C	; 76
    be18:	09 f0       	breq	.+2      	; 0xbe1c <GPRS_Param09+0x56>
    be1a:	6f c0       	rjmp	.+222    	; 0xbefa <GPRS_Param09+0x134>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    be1c:	4f e0       	ldi	r20, 0x0F	; 15
    be1e:	50 e0       	ldi	r21, 0x00	; 0
    be20:	62 e6       	ldi	r22, 0x62	; 98
    be22:	71 e0       	ldi	r23, 0x01	; 1
    be24:	8a e3       	ldi	r24, 0x3A	; 58
    be26:	98 e0       	ldi	r25, 0x08	; 8
    be28:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    be2c:	4f e0       	ldi	r20, 0x0F	; 15
    be2e:	50 e0       	ldi	r21, 0x00	; 0
    be30:	64 e2       	ldi	r22, 0x24	; 36
    be32:	73 e0       	ldi	r23, 0x03	; 3
    be34:	89 e4       	ldi	r24, 0x49	; 73
    be36:	98 e0       	ldi	r25, 0x08	; 8
    be38:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
    be3c:	5e c0       	rjmp	.+188    	; 0xbefa <GPRS_Param09+0x134>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    be3e:	24 e0       	ldi	r18, 0x04	; 4
    be40:	4e e2       	ldi	r20, 0x2E	; 46
    be42:	51 e0       	ldi	r21, 0x01	; 1
    be44:	4f c0       	rjmp	.+158    	; 0xbee4 <GPRS_Param09+0x11e>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    be46:	24 e0       	ldi	r18, 0x04	; 4
    be48:	42 e3       	ldi	r20, 0x32	; 50
    be4a:	51 e0       	ldi	r21, 0x01	; 1
    be4c:	4b c0       	rjmp	.+150    	; 0xbee4 <GPRS_Param09+0x11e>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    be4e:	24 e0       	ldi	r18, 0x04	; 4
    be50:	46 e3       	ldi	r20, 0x36	; 54
    be52:	51 e0       	ldi	r21, 0x01	; 1
    be54:	47 c0       	rjmp	.+142    	; 0xbee4 <GPRS_Param09+0x11e>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    be56:	22 e0       	ldi	r18, 0x02	; 2
    be58:	42 e2       	ldi	r20, 0x22	; 34
    be5a:	51 e0       	ldi	r21, 0x01	; 1
    be5c:	43 c0       	rjmp	.+134    	; 0xbee4 <GPRS_Param09+0x11e>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    be5e:	22 e0       	ldi	r18, 0x02	; 2
    be60:	44 e2       	ldi	r20, 0x24	; 36
    be62:	51 e0       	ldi	r21, 0x01	; 1
    be64:	3f c0       	rjmp	.+126    	; 0xbee4 <GPRS_Param09+0x11e>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    be66:	22 e0       	ldi	r18, 0x02	; 2
    be68:	46 e2       	ldi	r20, 0x26	; 38
    be6a:	51 e0       	ldi	r21, 0x01	; 1
    be6c:	3b c0       	rjmp	.+118    	; 0xbee4 <GPRS_Param09+0x11e>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    be6e:	22 e0       	ldi	r18, 0x02	; 2
    be70:	48 e2       	ldi	r20, 0x28	; 40
    be72:	51 e0       	ldi	r21, 0x01	; 1
    be74:	37 c0       	rjmp	.+110    	; 0xbee4 <GPRS_Param09+0x11e>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    be76:	24 e0       	ldi	r18, 0x04	; 4
    be78:	40 e1       	ldi	r20, 0x10	; 16
    be7a:	51 e0       	ldi	r21, 0x01	; 1
    be7c:	33 c0       	rjmp	.+102    	; 0xbee4 <GPRS_Param09+0x11e>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    be7e:	24 e0       	ldi	r18, 0x04	; 4
    be80:	44 e1       	ldi	r20, 0x14	; 20
    be82:	51 e0       	ldi	r21, 0x01	; 1
    be84:	2f c0       	rjmp	.+94     	; 0xbee4 <GPRS_Param09+0x11e>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    be86:	24 e0       	ldi	r18, 0x04	; 4
    be88:	48 e1       	ldi	r20, 0x18	; 24
    be8a:	51 e0       	ldi	r21, 0x01	; 1
    be8c:	2b c0       	rjmp	.+86     	; 0xbee4 <GPRS_Param09+0x11e>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    be8e:	24 e0       	ldi	r18, 0x04	; 4
    be90:	4c e1       	ldi	r20, 0x1C	; 28
    be92:	51 e0       	ldi	r21, 0x01	; 1
    be94:	27 c0       	rjmp	.+78     	; 0xbee4 <GPRS_Param09+0x11e>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    be96:	22 e0       	ldi	r18, 0x02	; 2
    be98:	40 e2       	ldi	r20, 0x20	; 32
    be9a:	51 e0       	ldi	r21, 0x01	; 1
    be9c:	23 c0       	rjmp	.+70     	; 0xbee4 <GPRS_Param09+0x11e>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    be9e:	22 e0       	ldi	r18, 0x02	; 2
    bea0:	4e e0       	ldi	r20, 0x0E	; 14
    bea2:	51 e0       	ldi	r21, 0x01	; 1
    bea4:	1f c0       	rjmp	.+62     	; 0xbee4 <GPRS_Param09+0x11e>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    bea6:	21 e0       	ldi	r18, 0x01	; 1
    bea8:	40 e6       	ldi	r20, 0x60	; 96
    beaa:	50 e0       	ldi	r21, 0x00	; 0
    beac:	1b c0       	rjmp	.+54     	; 0xbee4 <GPRS_Param09+0x11e>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    beae:	2c e0       	ldi	r18, 0x0C	; 12
    beb0:	43 ee       	ldi	r20, 0xE3	; 227
    beb2:	50 e0       	ldi	r21, 0x00	; 0
    beb4:	17 c0       	rjmp	.+46     	; 0xbee4 <GPRS_Param09+0x11e>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    beb6:	2c e0       	ldi	r18, 0x0C	; 12
    beb8:	40 ef       	ldi	r20, 0xF0	; 240
    beba:	50 e0       	ldi	r21, 0x00	; 0
    bebc:	13 c0       	rjmp	.+38     	; 0xbee4 <GPRS_Param09+0x11e>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    bebe:	2c e0       	ldi	r18, 0x0C	; 12
    bec0:	4d ef       	ldi	r20, 0xFD	; 253
    bec2:	50 e0       	ldi	r21, 0x00	; 0
    bec4:	0f c0       	rjmp	.+30     	; 0xbee4 <GPRS_Param09+0x11e>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;
    bec6:	22 e0       	ldi	r18, 0x02	; 2
    bec8:	48 e0       	ldi	r20, 0x08	; 8
    beca:	50 e0       	ldi	r21, 0x00	; 0
    becc:	0b c0       	rjmp	.+22     	; 0xbee4 <GPRS_Param09+0x11e>
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    bece:	20 e0       	ldi	r18, 0x00	; 0
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    bed0:	81 30       	cpi	r24, 0x01	; 1
    bed2:	31 f4       	brne	.+12     	; 0xbee0 <GPRS_Param09+0x11a>
    bed4:	c1 2c       	mov	r12, r1
    bed6:	e1 2c       	mov	r14, r1
    bed8:	40 e0       	ldi	r20, 0x00	; 0
    beda:	50 e0       	ldi	r21, 0x00	; 0
    bedc:	61 e0       	ldi	r22, 0x01	; 1
    bede:	06 c0       	rjmp	.+12     	; 0xbeec <GPRS_Param09+0x126>
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    bee0:	40 e0       	ldi	r20, 0x00	; 0
    bee2:	50 e0       	ldi	r21, 0x00	; 0

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bee4:	c1 2c       	mov	r12, r1
    bee6:	ee 24       	eor	r14, r14
    bee8:	e3 94       	inc	r14
    beea:	68 2f       	mov	r22, r24
    beec:	89 e0       	ldi	r24, 0x09	; 9
    beee:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bef2:	0f 91       	pop	r16
    bef4:	ef 90       	pop	r14
    bef6:	cf 90       	pop	r12
    bef8:	08 95       	ret
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    befa:	20 e0       	ldi	r18, 0x00	; 0
    befc:	eb cf       	rjmp	.-42     	; 0xbed4 <GPRS_Param09+0x10e>
			if(Cmd==WRITE_PARAM){
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
    befe:	23 e1       	ldi	r18, 0x13	; 19
    bf00:	4e e4       	ldi	r20, 0x4E	; 78
    bf02:	51 e0       	ldi	r21, 0x01	; 1
    bf04:	ef cf       	rjmp	.-34     	; 0xbee4 <GPRS_Param09+0x11e>
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    bf06:	24 e0       	ldi	r18, 0x04	; 4
    bf08:	4a e2       	ldi	r20, 0x2A	; 42
    bf0a:	51 e0       	ldi	r21, 0x01	; 1
    bf0c:	eb cf       	rjmp	.-42     	; 0xbee4 <GPRS_Param09+0x11e>

0000bf0e <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bf0e:	cf 92       	push	r12
    bf10:	ef 92       	push	r14
    bf12:	0f 93       	push	r16
    bf14:	ef ef       	ldi	r30, 0xFF	; 255
    bf16:	e8 0f       	add	r30, r24
    bf18:	e5 30       	cpi	r30, 0x05	; 5
    bf1a:	48 f4       	brcc	.+18     	; 0xbf2e <GPRS_Param10+0x20>
    bf1c:	f0 e0       	ldi	r31, 0x00	; 0
    bf1e:	ee 0f       	add	r30, r30
    bf20:	ff 1f       	adc	r31, r31
    bf22:	ef 52       	subi	r30, 0x2F	; 47
    bf24:	fe 4f       	sbci	r31, 0xFE	; 254
    bf26:	40 81       	ld	r20, Z
    bf28:	51 81       	ldd	r21, Z+1	; 0x01
    bf2a:	22 e0       	ldi	r18, 0x02	; 2
    bf2c:	03 c0       	rjmp	.+6      	; 0xbf34 <GPRS_Param10+0x26>
    bf2e:	20 e0       	ldi	r18, 0x00	; 0
    bf30:	40 e0       	ldi	r20, 0x00	; 0
    bf32:	50 e0       	ldi	r21, 0x00	; 0
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bf34:	c1 2c       	mov	r12, r1
    bf36:	ee 24       	eor	r14, r14
    bf38:	e3 94       	inc	r14
    bf3a:	06 2f       	mov	r16, r22
    bf3c:	68 2f       	mov	r22, r24
    bf3e:	8a e0       	ldi	r24, 0x0A	; 10
    bf40:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
}
    bf44:	0f 91       	pop	r16
    bf46:	ef 90       	pop	r14
    bf48:	cf 90       	pop	r12
    bf4a:	08 95       	ret

0000bf4c <GPRS_Param11>:
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    bf4c:	cf 92       	push	r12
    bf4e:	ef 92       	push	r14
    bf50:	0f 93       	push	r16
    bf52:	cf 93       	push	r28
    bf54:	c8 2f       	mov	r28, r24
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    bf56:	81 30       	cpi	r24, 0x01	; 1
    bf58:	21 f4       	brne	.+8      	; 0xbf62 <GPRS_Param11+0x16>
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
    bf5a:	21 e0       	ldi	r18, 0x01	; 1
    bf5c:	49 e2       	ldi	r20, 0x29	; 41
    bf5e:	50 e0       	ldi	r21, 0x00	; 0
    bf60:	03 c0       	rjmp	.+6      	; 0xbf68 <GPRS_Param11+0x1c>
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    bf62:	20 e0       	ldi	r18, 0x00	; 0
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    bf64:	40 e0       	ldi	r20, 0x00	; 0
    bf66:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    bf68:	c1 2c       	mov	r12, r1
    bf6a:	ee 24       	eor	r14, r14
    bf6c:	e3 94       	inc	r14
    bf6e:	06 2f       	mov	r16, r22
    bf70:	6c 2f       	mov	r22, r28
    bf72:	8b e0       	ldi	r24, 0x0B	; 11
    bf74:	0e 94 6c 5d 	call	0xbad8	; 0xbad8 <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    bf78:	c1 30       	cpi	r28, 0x01	; 1
    bf7a:	31 f4       	brne	.+12     	; 0xbf88 <GPRS_Param11+0x3c>
#endif
}
    bf7c:	cf 91       	pop	r28
    bf7e:	0f 91       	pop	r16
    bf80:	ef 90       	pop	r14
    bf82:	cf 90       	pop	r12
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    bf84:	0c 94 10 4c 	jmp	0x9820	; 0x9820 <EMeter_ReInit>
#endif
}
    bf88:	cf 91       	pop	r28
    bf8a:	0f 91       	pop	r16
    bf8c:	ef 90       	pop	r14
    bf8e:	cf 90       	pop	r12
    bf90:	08 95       	ret

0000bf92 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
    bf92:	0f 93       	push	r16
    bf94:	1f 93       	push	r17
    bf96:	08 2f       	mov	r16, r24
    bf98:	86 2f       	mov	r24, r22
    bf9a:	64 2f       	mov	r22, r20
	switch(ParamID_Hi){
    bf9c:	10 e0       	ldi	r17, 0x00	; 0
    bf9e:	0c 30       	cpi	r16, 0x0C	; 12
    bfa0:	11 05       	cpc	r17, r1
    bfa2:	a8 f5       	brcc	.+106    	; 0xc00e <GPRS_Parameter+0x7c>
    bfa4:	f8 01       	movw	r30, r16
    bfa6:	e5 53       	subi	r30, 0x35	; 53
    bfa8:	ff 4f       	sbci	r31, 0xFF	; 255
    bfaa:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfae:	1f 91       	pop	r17
    bfb0:	0f 91       	pop	r16
#endif
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    bfb2:	0c 94 d8 5d 	jmp	0xbbb0	; 0xbbb0 <GPRS_Param00>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfb6:	1f 91       	pop	r17
    bfb8:	0f 91       	pop	r16
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    bfba:	0c 94 44 5e 	jmp	0xbc88	; 0xbc88 <GPRS_Param01>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfbe:	1f 91       	pop	r17
    bfc0:	0f 91       	pop	r16

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    bfc2:	0c 94 55 5e 	jmp	0xbcaa	; 0xbcaa <GPRS_Param02>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfc6:	1f 91       	pop	r17
    bfc8:	0f 91       	pop	r16
void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    bfca:	0c 94 66 5e 	jmp	0xbccc	; 0xbccc <GPRS_Param03>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfce:	1f 91       	pop	r17
    bfd0:	0f 91       	pop	r16
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    bfd2:	0c 94 78 5e 	jmp	0xbcf0	; 0xbcf0 <GPRS_Param04>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfd6:	1f 91       	pop	r17
    bfd8:	0f 91       	pop	r16
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    bfda:	0c 94 8a 5e 	jmp	0xbd14	; 0xbd14 <GPRS_Param05>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfde:	1f 91       	pop	r17
    bfe0:	0f 91       	pop	r16
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    bfe2:	0c 94 9c 5e 	jmp	0xbd38	; 0xbd38 <GPRS_Param06>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfe6:	1f 91       	pop	r17
    bfe8:	0f 91       	pop	r16
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    bfea:	0c 94 bf 5e 	jmp	0xbd7e	; 0xbd7e <GPRS_Param07>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bfee:	1f 91       	pop	r17
    bff0:	0f 91       	pop	r16
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    bff2:	0c 94 d1 5e 	jmp	0xbda2	; 0xbda2 <GPRS_Param08>
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bff6:	1f 91       	pop	r17
    bff8:	0f 91       	pop	r16
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    bffa:	0c 94 e3 5e 	jmp	0xbdc6	; 0xbdc6 <GPRS_Param09>
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    bffe:	1f 91       	pop	r17
    c000:	0f 91       	pop	r16
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    c002:	0c 94 87 5f 	jmp	0xbf0e	; 0xbf0e <GPRS_Param10>
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    c006:	1f 91       	pop	r17
    c008:	0f 91       	pop	r16
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    c00a:	0c 94 a6 5f 	jmp	0xbf4c	; 0xbf4c <GPRS_Param11>
	}
}
    c00e:	1f 91       	pop	r17
    c010:	0f 91       	pop	r16
    c012:	08 95       	ret

0000c014 <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    c014:	cf 93       	push	r28
    c016:	c8 2f       	mov	r28, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    c018:	82 30       	cpi	r24, 0x02	; 2
    c01a:	09 f0       	breq	.+2      	; 0xc01e <ReadParamBlock+0xa>
    c01c:	80 c0       	rjmp	.+256    	; 0xc11e <ReadParamBlock+0x10a>
    c01e:	4f e0       	ldi	r20, 0x0F	; 15
    c020:	50 e0       	ldi	r21, 0x00	; 0
    c022:	62 e6       	ldi	r22, 0x62	; 98
    c024:	71 e0       	ldi	r23, 0x01	; 1
    c026:	87 e3       	ldi	r24, 0x37	; 55
    c028:	96 e0       	ldi	r25, 0x06	; 6
    c02a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c02e:	4f e0       	ldi	r20, 0x0F	; 15
    c030:	50 e0       	ldi	r21, 0x00	; 0
    c032:	64 e2       	ldi	r22, 0x24	; 36
    c034:	73 e0       	ldi	r23, 0x03	; 3
    c036:	86 e4       	ldi	r24, 0x46	; 70
    c038:	96 e0       	ldi	r25, 0x06	; 6
    c03a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c03e:	43 e1       	ldi	r20, 0x13	; 19
    c040:	50 e0       	ldi	r21, 0x00	; 0
    c042:	6e e4       	ldi	r22, 0x4E	; 78
    c044:	71 e0       	ldi	r23, 0x01	; 1
    c046:	85 e5       	ldi	r24, 0x55	; 85
    c048:	96 e0       	ldi	r25, 0x06	; 6
    c04a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c04e:	44 e1       	ldi	r20, 0x14	; 20
    c050:	50 e0       	ldi	r21, 0x00	; 0
    c052:	6a e3       	ldi	r22, 0x3A	; 58
    c054:	71 e0       	ldi	r23, 0x01	; 1
    c056:	88 e6       	ldi	r24, 0x68	; 104
    c058:	96 e0       	ldi	r25, 0x06	; 6
    c05a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c05e:	40 e1       	ldi	r20, 0x10	; 16
    c060:	50 e0       	ldi	r21, 0x00	; 0
    c062:	6a e2       	ldi	r22, 0x2A	; 42
    c064:	71 e0       	ldi	r23, 0x01	; 1
    c066:	8b e7       	ldi	r24, 0x7B	; 123
    c068:	96 e0       	ldi	r25, 0x06	; 6
    c06a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c06e:	48 e0       	ldi	r20, 0x08	; 8
    c070:	50 e0       	ldi	r21, 0x00	; 0
    c072:	62 e2       	ldi	r22, 0x22	; 34
    c074:	71 e0       	ldi	r23, 0x01	; 1
    c076:	8b e8       	ldi	r24, 0x8B	; 139
    c078:	96 e0       	ldi	r25, 0x06	; 6
    c07a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c07e:	40 e1       	ldi	r20, 0x10	; 16
    c080:	50 e0       	ldi	r21, 0x00	; 0
    c082:	60 e1       	ldi	r22, 0x10	; 16
    c084:	71 e0       	ldi	r23, 0x01	; 1
    c086:	83 e9       	ldi	r24, 0x93	; 147
    c088:	96 e0       	ldi	r25, 0x06	; 6
    c08a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c08e:	42 e0       	ldi	r20, 0x02	; 2
    c090:	50 e0       	ldi	r21, 0x00	; 0
    c092:	60 e2       	ldi	r22, 0x20	; 32
    c094:	71 e0       	ldi	r23, 0x01	; 1
    c096:	83 ea       	ldi	r24, 0xA3	; 163
    c098:	96 e0       	ldi	r25, 0x06	; 6
    c09a:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c09e:	42 e0       	ldi	r20, 0x02	; 2
    c0a0:	50 e0       	ldi	r21, 0x00	; 0
    c0a2:	6e e0       	ldi	r22, 0x0E	; 14
    c0a4:	71 e0       	ldi	r23, 0x01	; 1
    c0a6:	85 ea       	ldi	r24, 0xA5	; 165
    c0a8:	96 e0       	ldi	r25, 0x06	; 6
    c0aa:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c0ae:	41 e0       	ldi	r20, 0x01	; 1
    c0b0:	50 e0       	ldi	r21, 0x00	; 0
    c0b2:	60 e6       	ldi	r22, 0x60	; 96
    c0b4:	70 e0       	ldi	r23, 0x00	; 0
    c0b6:	87 ea       	ldi	r24, 0xA7	; 167
    c0b8:	96 e0       	ldi	r25, 0x06	; 6
    c0ba:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c0be:	4c e0       	ldi	r20, 0x0C	; 12
    c0c0:	50 e0       	ldi	r21, 0x00	; 0
    c0c2:	63 ee       	ldi	r22, 0xE3	; 227
    c0c4:	70 e0       	ldi	r23, 0x00	; 0
    c0c6:	88 ea       	ldi	r24, 0xA8	; 168
    c0c8:	96 e0       	ldi	r25, 0x06	; 6
    c0ca:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c0ce:	4c e0       	ldi	r20, 0x0C	; 12
    c0d0:	50 e0       	ldi	r21, 0x00	; 0
    c0d2:	60 ef       	ldi	r22, 0xF0	; 240
    c0d4:	70 e0       	ldi	r23, 0x00	; 0
    c0d6:	84 eb       	ldi	r24, 0xB4	; 180
    c0d8:	96 e0       	ldi	r25, 0x06	; 6
    c0da:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c0de:	4c e0       	ldi	r20, 0x0C	; 12
    c0e0:	50 e0       	ldi	r21, 0x00	; 0
    c0e2:	6d ef       	ldi	r22, 0xFD	; 253
    c0e4:	70 e0       	ldi	r23, 0x00	; 0
    c0e6:	80 ec       	ldi	r24, 0xC0	; 192
    c0e8:	96 e0       	ldi	r25, 0x06	; 6
    c0ea:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
    c0ee:	42 e0       	ldi	r20, 0x02	; 2
    c0f0:	50 e0       	ldi	r21, 0x00	; 0
    c0f2:	68 e0       	ldi	r22, 0x08	; 8
    c0f4:	70 e0       	ldi	r23, 0x00	; 0
    c0f6:	8c ec       	ldi	r24, 0xCC	; 204
    c0f8:	96 e0       	ldi	r25, 0x06	; 6
    c0fa:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    c0fe:	c0 93 36 06 	sts	0x0636, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    c102:	29 e9       	ldi	r18, 0x99	; 153
    c104:	41 e1       	ldi	r20, 0x11	; 17
    c106:	63 e0       	ldi	r22, 0x03	; 3
    c108:	8f e2       	ldi	r24, 0x2F	; 47
    c10a:	96 e0       	ldi	r25, 0x06	; 6
    c10c:	0e 94 4a 59 	call	0xb294	; 0xb294 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    c110:	80 91 41 09 	lds	r24, 0x0941
    c114:	88 60       	ori	r24, 0x08	; 8
    c116:	80 93 41 09 	sts	0x0941, r24
		GPRS_ChangeReplySize = blocksize;
    c11a:	8f e9       	ldi	r24, 0x9F	; 159
    c11c:	17 c0       	rjmp	.+46     	; 0xc14c <ReadParamBlock+0x138>
	}

	if(Block == 3){
    c11e:	83 30       	cpi	r24, 0x03	; 3
    c120:	c1 f4       	brne	.+48     	; 0xc152 <ReadParamBlock+0x13e>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c122:	89 e2       	ldi	r24, 0x29	; 41
    c124:	90 e0       	ldi	r25, 0x00	; 0
    c126:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    c12a:	80 93 37 06 	sts	0x0637, r24

		GPRS_ChangeData[7] = Block;
    c12e:	c0 93 36 06 	sts	0x0636, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    c132:	23 e0       	ldi	r18, 0x03	; 3
    c134:	41 e1       	ldi	r20, 0x11	; 17
    c136:	63 e0       	ldi	r22, 0x03	; 3
    c138:	8f e2       	ldi	r24, 0x2F	; 47
    c13a:	96 e0       	ldi	r25, 0x06	; 6
    c13c:	0e 94 4a 59 	call	0xb294	; 0xb294 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    c140:	80 91 41 09 	lds	r24, 0x0941
    c144:	88 60       	ori	r24, 0x08	; 8
    c146:	80 93 41 09 	sts	0x0941, r24
		GPRS_ChangeReplySize = blocksize;
    c14a:	89 e0       	ldi	r24, 0x09	; 9
    c14c:	80 93 03 06 	sts	0x0603, r24
    c150:	01 c0       	rjmp	.+2      	; 0xc154 <ReadParamBlock+0x140>

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){

	uint8_t blocksize=8;
    c152:	88 e0       	ldi	r24, 0x08	; 8
		GPRS_ChangeReplySize = blocksize;
	}

	return blocksize;
	
}
    c154:	cf 91       	pop	r28
    c156:	08 95       	ret

0000c158 <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){
    c158:	cf 93       	push	r28

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    c15a:	c0 91 42 09 	lds	r28, 0x0942
    c15e:	cc 23       	and	r28, r28
    c160:	09 f4       	brne	.+2      	; 0xc164 <GPRS_ReciveData+0xc>
    c162:	8a c0       	rjmp	.+276    	; 0xc278 <GPRS_ReciveData+0x120>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    c164:	80 91 2f 08 	lds	r24, 0x082F
    c168:	85 30       	cpi	r24, 0x05	; 5
    c16a:	09 f0       	breq	.+2      	; 0xc16e <GPRS_ReciveData+0x16>
    c16c:	85 c0       	rjmp	.+266    	; 0xc278 <GPRS_ReciveData+0x120>
    c16e:	80 91 30 08 	lds	r24, 0x0830
    c172:	81 30       	cpi	r24, 0x01	; 1
    c174:	09 f0       	breq	.+2      	; 0xc178 <GPRS_ReciveData+0x20>
    c176:	80 c0       	rjmp	.+256    	; 0xc278 <GPRS_ReciveData+0x120>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
    c178:	80 91 31 08 	lds	r24, 0x0831
    c17c:	90 e0       	ldi	r25, 0x00	; 0
    c17e:	98 2f       	mov	r25, r24
    c180:	88 27       	eor	r24, r24
    c182:	20 91 32 08 	lds	r18, 0x0832
		if(GPRS_Check_PSW(Psw) == 0){
    c186:	82 0f       	add	r24, r18
    c188:	91 1d       	adc	r25, r1
    c18a:	0e 94 79 5c 	call	0xb8f2	; 0xb8f2 <GPRS_Check_PSW>
    c18e:	81 11       	cpse	r24, r1
    c190:	06 c0       	rjmp	.+12     	; 0xc19e <GPRS_ReciveData+0x46>
			GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    c192:	80 91 4d 09 	lds	r24, 0x094D
    c196:	88 60       	ori	r24, 0x08	; 8
    c198:	80 93 4d 09 	sts	0x094D, r24
    c19c:	1b c0       	rjmp	.+54     	; 0xc1d4 <GPRS_ReciveData+0x7c>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    c19e:	80 91 33 08 	lds	r24, 0x0833
    c1a2:	84 30       	cpi	r24, 0x04	; 4
    c1a4:	d9 f4       	brne	.+54     	; 0xc1dc <GPRS_ReciveData+0x84>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c1a6:	8c e0       	ldi	r24, 0x0C	; 12
    c1a8:	91 e0       	ldi	r25, 0x01	; 1
    c1aa:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    c1ae:	20 91 34 08 	lds	r18, 0x0834
    c1b2:	30 e0       	ldi	r19, 0x00	; 0
    c1b4:	32 2f       	mov	r19, r18
    c1b6:	22 27       	eor	r18, r18
    c1b8:	40 91 35 08 	lds	r20, 0x0835
    c1bc:	24 0f       	add	r18, r20
    c1be:	31 1d       	adc	r19, r1
    c1c0:	40 91 4d 09 	lds	r20, 0x094D
    c1c4:	82 17       	cp	r24, r18
    c1c6:	93 07       	cpc	r25, r19
    c1c8:	11 f4       	brne	.+4      	; 0xc1ce <GPRS_ReciveData+0x76>
    c1ca:	47 7f       	andi	r20, 0xF7	; 247
    c1cc:	01 c0       	rjmp	.+2      	; 0xc1d0 <GPRS_ReciveData+0x78>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    c1ce:	48 60       	ori	r20, 0x08	; 8
    c1d0:	40 93 4d 09 	sts	0x094D, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    c1d4:	80 91 41 09 	lds	r24, 0x0941
    c1d8:	80 61       	ori	r24, 0x10	; 16
    c1da:	2e c0       	rjmp	.+92     	; 0xc238 <GPRS_ReciveData+0xe0>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    c1dc:	83 30       	cpi	r24, 0x03	; 3
    c1de:	09 f0       	breq	.+2      	; 0xc1e2 <GPRS_ReciveData+0x8a>
    c1e0:	4b c0       	rjmp	.+150    	; 0xc278 <GPRS_ReciveData+0x120>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    c1e2:	20 91 f3 0a 	lds	r18, 0x0AF3
    c1e6:	30 91 f4 0a 	lds	r19, 0x0AF4
    c1ea:	21 15       	cp	r18, r1
    c1ec:	31 05       	cpc	r19, r1
    c1ee:	89 f2       	breq	.-94     	; 0xc192 <GPRS_ReciveData+0x3a>
    c1f0:	80 91 34 08 	lds	r24, 0x0834
    c1f4:	90 e0       	ldi	r25, 0x00	; 0
    c1f6:	98 2f       	mov	r25, r24
    c1f8:	88 27       	eor	r24, r24
    c1fa:	40 91 35 08 	lds	r20, 0x0835
    c1fe:	84 0f       	add	r24, r20
    c200:	91 1d       	adc	r25, r1
    c202:	28 17       	cp	r18, r24
    c204:	39 07       	cpc	r19, r25
    c206:	29 f6       	brne	.-118    	; 0xc192 <GPRS_ReciveData+0x3a>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    c208:	90 91 36 08 	lds	r25, 0x0836
			
			switch(GPRS_Data_In[8]){
    c20c:	80 91 37 08 	lds	r24, 0x0837
    c210:	88 30       	cpi	r24, 0x08	; 8
    c212:	d9 f0       	breq	.+54     	; 0xc24a <GPRS_ReciveData+0xf2>
    c214:	28 f4       	brcc	.+10     	; 0xc220 <GPRS_ReciveData+0xc8>
    c216:	81 30       	cpi	r24, 0x01	; 1
    c218:	41 f0       	breq	.+16     	; 0xc22a <GPRS_ReciveData+0xd2>
    c21a:	87 30       	cpi	r24, 0x07	; 7
    c21c:	81 f0       	breq	.+32     	; 0xc23e <GPRS_ReciveData+0xe6>
    c21e:	2c c0       	rjmp	.+88     	; 0xc278 <GPRS_ReciveData+0x120>
    c220:	8a 30       	cpi	r24, 0x0A	; 10
    c222:	d9 f0       	breq	.+54     	; 0xc25a <GPRS_ReciveData+0x102>
    c224:	81 31       	cpi	r24, 0x11	; 17
    c226:	01 f1       	breq	.+64     	; 0xc268 <GPRS_ReciveData+0x110>
    c228:	27 c0       	rjmp	.+78     	; 0xc278 <GPRS_ReciveData+0x120>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    c22a:	91 30       	cpi	r25, 0x01	; 1
    c22c:	29 f5       	brne	.+74     	; 0xc278 <GPRS_ReciveData+0x120>
    c22e:	c9 30       	cpi	r28, 0x09	; 9
    c230:	19 f5       	brne	.+70     	; 0xc278 <GPRS_ReciveData+0x120>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    c232:	80 91 41 09 	lds	r24, 0x0941
    c236:	82 60       	ori	r24, 0x02	; 2
    c238:	80 93 41 09 	sts	0x0941, r24
    c23c:	1d c0       	rjmp	.+58     	; 0xc278 <GPRS_ReciveData+0x120>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    c23e:	93 30       	cpi	r25, 0x03	; 3
    c240:	d9 f4       	brne	.+54     	; 0xc278 <GPRS_ReciveData+0x120>
    c242:	cb 30       	cpi	r28, 0x0B	; 11
    c244:	c9 f4       	brne	.+50     	; 0xc278 <GPRS_ReciveData+0x120>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    c246:	41 ec       	ldi	r20, 0xC1	; 193
    c248:	01 c0       	rjmp	.+2      	; 0xc24c <GPRS_ReciveData+0xf4>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    c24a:	4c e4       	ldi	r20, 0x4C	; 76
    c24c:	60 91 39 08 	lds	r22, 0x0839
    c250:	80 91 38 08 	lds	r24, 0x0838
    c254:	0e 94 c9 5f 	call	0xbf92	; 0xbf92 <GPRS_Parameter>
				break;
    c258:	0f c0       	rjmp	.+30     	; 0xc278 <GPRS_ReciveData+0x120>
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    c25a:	92 30       	cpi	r25, 0x02	; 2
    c25c:	69 f4       	brne	.+26     	; 0xc278 <GPRS_ReciveData+0x120>
    c25e:	ca 30       	cpi	r28, 0x0A	; 10
    c260:	59 f4       	brne	.+22     	; 0xc278 <GPRS_ReciveData+0x120>
					GPRS_RemoteDisplayControl();
    c262:	0e 94 d7 5c 	call	0xb9ae	; 0xb9ae <GPRS_RemoteDisplayControl>
    c266:	08 c0       	rjmp	.+16     	; 0xc278 <GPRS_ReciveData+0x120>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    c268:	92 30       	cpi	r25, 0x02	; 2
    c26a:	31 f4       	brne	.+12     	; 0xc278 <GPRS_ReciveData+0x120>
    c26c:	ca 30       	cpi	r28, 0x0A	; 10
    c26e:	21 f4       	brne	.+8      	; 0xc278 <GPRS_ReciveData+0x120>
					ReadParamBlock	(GPRS_Data_In[9]);
    c270:	80 91 38 08 	lds	r24, 0x0838
    c274:	0e 94 0a 60 	call	0xc014	; 0xc014 <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
    c278:	10 92 42 09 	sts	0x0942, r1
	}//   
	else GPRS_FlgSz_In = 0;
}
    c27c:	cf 91       	pop	r28
    c27e:	08 95       	ret

0000c280 <GPRS_Arbitr>:
// -----                  
void GPRS_Arbitr(void){
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    c280:	80 91 41 09 	lds	r24, 0x0941
    c284:	86 ff       	sbrs	r24, 6
    c286:	06 c0       	rjmp	.+12     	; 0xc294 <GPRS_Arbitr+0x14>
		GPRS_SendNewCrash();
    c288:	0e 94 56 5c 	call	0xb8ac	; 0xb8ac <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    c28c:	80 91 41 09 	lds	r24, 0x0941
    c290:	8f 7b       	andi	r24, 0xBF	; 191
    c292:	3d c0       	rjmp	.+122    	; 0xc30e <GPRS_Arbitr+0x8e>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    c294:	85 ff       	sbrs	r24, 5
    c296:	0d c0       	rjmp	.+26     	; 0xc2b2 <GPRS_Arbitr+0x32>
		GPRS_SendRepCrash();
    c298:	0e 94 66 5c 	call	0xb8cc	; 0xb8cc <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    c29c:	80 91 41 09 	lds	r24, 0x0941
    c2a0:	8f 7d       	andi	r24, 0xDF	; 223
    c2a2:	80 93 41 09 	sts	0x0941, r24
		GPRS_Protocol_Out = UDP;
    c2a6:	10 92 60 09 	sts	0x0960, r1
		IP_SendMask = 0b11111110;	//   IP1
    c2aa:	8e ef       	ldi	r24, 0xFE	; 254
    c2ac:	80 93 61 08 	sts	0x0861, r24
    c2b0:	34 c0       	rjmp	.+104    	; 0xc31a <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    c2b2:	84 ff       	sbrs	r24, 4
    c2b4:	06 c0       	rjmp	.+12     	; 0xc2c2 <GPRS_Arbitr+0x42>
		GPRS_Get_Session_ID();
    c2b6:	0e 94 97 5c 	call	0xb92e	; 0xb92e <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    c2ba:	80 91 41 09 	lds	r24, 0x0941
    c2be:	8f 7e       	andi	r24, 0xEF	; 239
    c2c0:	19 c0       	rjmp	.+50     	; 0xc2f4 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    c2c2:	83 ff       	sbrs	r24, 3
    c2c4:	08 c0       	rjmp	.+16     	; 0xc2d6 <GPRS_Arbitr+0x56>
		GPRS_SendChange(GPRS_ChangeReplySize);
    c2c6:	80 91 03 06 	lds	r24, 0x0603
    c2ca:	0e 94 02 5d 	call	0xba04	; 0xba04 <GPRS_SendChange>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    c2ce:	80 91 41 09 	lds	r24, 0x0941
    c2d2:	87 7f       	andi	r24, 0xF7	; 247
    c2d4:	0f c0       	rjmp	.+30     	; 0xc2f4 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    c2d6:	82 ff       	sbrs	r24, 2
    c2d8:	06 c0       	rjmp	.+12     	; 0xc2e6 <GPRS_Arbitr+0x66>
		GPRS_SendDisplay();
    c2da:	0e 94 e1 5c 	call	0xb9c2	; 0xb9c2 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    c2de:	80 91 41 09 	lds	r24, 0x0941
    c2e2:	8b 7f       	andi	r24, 0xFB	; 251
    c2e4:	07 c0       	rjmp	.+14     	; 0xc2f4 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    c2e6:	81 ff       	sbrs	r24, 1
    c2e8:	0b c0       	rjmp	.+22     	; 0xc300 <GPRS_Arbitr+0x80>
		GPRS_CurDataSend();
    c2ea:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    c2ee:	80 91 41 09 	lds	r24, 0x0941
    c2f2:	8d 7f       	andi	r24, 0xFD	; 253
    c2f4:	80 93 41 09 	sts	0x0941, r24
		GPRS_Protocol_Out = TCP;
    c2f8:	81 e0       	ldi	r24, 0x01	; 1
    c2fa:	80 93 60 09 	sts	0x0960, r24
    c2fe:	0d c0       	rjmp	.+26     	; 0xc31a <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    c300:	80 ff       	sbrs	r24, 0
    c302:	0f c0       	rjmp	.+30     	; 0xc322 <GPRS_Arbitr+0xa2>
		GPRS_CurDataSend();
    c304:	0e 94 75 59 	call	0xb2ea	; 0xb2ea <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    c308:	80 91 41 09 	lds	r24, 0x0941
    c30c:	8e 7f       	andi	r24, 0xFE	; 254
    c30e:	80 93 41 09 	sts	0x0941, r24
		GPRS_Protocol_Out = UDP;
    c312:	10 92 60 09 	sts	0x0960, r1
		IP_SendMask = 0;	//   IP
    c316:	10 92 61 08 	sts	0x0861, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    c31a:	80 91 29 09 	lds	r24, 0x0929
    c31e:	80 93 5f 09 	sts	0x095F, r24
    c322:	08 95       	ret

0000c324 <GPRS_App>:
		return;
	}
}
// -----   ApplCycle
void GPRS_App(void){
    c324:	cf 93       	push	r28
    c326:	df 93       	push	r29

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    c328:	c0 91 34 09 	lds	r28, 0x0934

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    c32c:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint16_t Time = Timer16[TimerN];
    c330:	ec 2f       	mov	r30, r28
    c332:	f0 e0       	ldi	r31, 0x00	; 0
    c334:	ee 0f       	add	r30, r30
    c336:	ff 1f       	adc	r31, r31
    c338:	e2 5e       	subi	r30, 0xE2	; 226
    c33a:	fc 4f       	sbci	r31, 0xFC	; 252
    c33c:	c0 81       	ld	r28, Z
    c33e:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    c340:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
    c344:	c8 3c       	cpi	r28, 0xC8	; 200
    c346:	d1 05       	cpc	r29, r1
    c348:	30 f4       	brcc	.+12     	; 0xc356 <GPRS_App+0x32>
    c34a:	6f ef       	ldi	r22, 0xFF	; 255
    c34c:	7f ef       	ldi	r23, 0xFF	; 255
    c34e:	80 91 34 09 	lds	r24, 0x0934
    c352:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    c356:	80 91 07 01 	lds	r24, 0x0107
    c35a:	8f 3f       	cpi	r24, 0xFF	; 255
    c35c:	31 f4       	brne	.+12     	; 0xc36a <GPRS_App+0x46>
		GPRS_Session_ID = 0;
    c35e:	10 92 f4 0a 	sts	0x0AF4, r1
    c362:	10 92 f3 0a 	sts	0x0AF3, r1
		GPRS_LoginLevel = 0;
    c366:	10 92 bb 08 	sts	0x08BB, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    c36a:	c0 91 01 06 	lds	r28, 0x0601

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    c36e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint16_t Time = Timer16[TimerN];
    c372:	ec 2f       	mov	r30, r28
    c374:	f0 e0       	ldi	r31, 0x00	; 0
    c376:	ee 0f       	add	r30, r30
    c378:	ff 1f       	adc	r31, r31
    c37a:	e2 5e       	subi	r30, 0xE2	; 226
    c37c:	fc 4f       	sbci	r31, 0xFC	; 252
    c37e:	c0 81       	ld	r28, Z
    c380:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    c382:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
    c386:	d0 93 f3 05 	sts	0x05F3, r29
    c38a:	c0 93 f2 05 	sts	0x05F2, r28

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    c38e:	80 91 4d 09 	lds	r24, 0x094D
    c392:	80 fd       	sbrc	r24, 0
    c394:	1b c0       	rjmp	.+54     	; 0xc3cc <GPRS_App+0xa8>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    c396:	0e 94 ac 60 	call	0xc158	; 0xc158 <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    c39a:	80 e0       	ldi	r24, 0x00	; 0
    c39c:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    c3a0:	88 23       	and	r24, r24
    c3a2:	61 f0       	breq	.+24     	; 0xc3bc <GPRS_App+0x98>
    c3a4:	90 91 4d 09 	lds	r25, 0x094D
    c3a8:	92 ff       	sbrs	r25, 2
    c3aa:	08 c0       	rjmp	.+16     	; 0xc3bc <GPRS_App+0x98>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    c3ac:	80 91 41 09 	lds	r24, 0x0941
    c3b0:	84 60       	ori	r24, 0x04	; 4
    c3b2:	80 93 41 09 	sts	0x0941, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    c3b6:	9b 7f       	andi	r25, 0xFB	; 251
    c3b8:	90 93 4d 09 	sts	0x094D, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    c3bc:	0e 94 91 5b 	call	0xb722	; 0xb722 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    c3c0:	80 91 29 09 	lds	r24, 0x0929
    c3c4:	81 11       	cpse	r24, r1
    c3c6:	02 c0       	rjmp	.+4      	; 0xc3cc <GPRS_App+0xa8>
    c3c8:	0e 94 40 61 	call	0xc280	; 0xc280 <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
}
    c3cc:	df 91       	pop	r29
    c3ce:	cf 91       	pop	r28
		GPRS_SendData();
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
	}

	GPRS_CriticalCMD_Process();
    c3d0:	0c 94 b4 5d 	jmp	0xbb68	; 0xbb68 <GPRS_CriticalCMD_Process>

0000c3d4 <GSMApply>:
}

void 
GSMApply(void){//=====================================================   GSM

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    c3d4:	4e e1       	ldi	r20, 0x1E	; 30
    c3d6:	50 e0       	ldi	r21, 0x00	; 0
    c3d8:	62 e6       	ldi	r22, 0x62	; 98
    c3da:	71 e0       	ldi	r23, 0x01	; 1
    c3dc:	80 e7       	ldi	r24, 0x70	; 112
    c3de:	98 e0       	ldi	r25, 0x08	; 8
    c3e0:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
	wdt_reset();
    c3e4:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    c3e6:	44 e1       	ldi	r20, 0x14	; 20
    c3e8:	50 e0       	ldi	r21, 0x00	; 0
    c3ea:	6e e4       	ldi	r22, 0x4E	; 78
    c3ec:	71 e0       	ldi	r23, 0x01	; 1
    c3ee:	8e e8       	ldi	r24, 0x8E	; 142
    c3f0:	98 e0       	ldi	r25, 0x08	; 8
    c3f2:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
	wdt_reset();
    c3f6:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    c3f8:	44 e1       	ldi	r20, 0x14	; 20
    c3fa:	50 e0       	ldi	r21, 0x00	; 0
    c3fc:	6a e3       	ldi	r22, 0x3A	; 58
    c3fe:	71 e0       	ldi	r23, 0x01	; 1
    c400:	82 ea       	ldi	r24, 0xA2	; 162
    c402:	98 e0       	ldi	r25, 0x08	; 8
    c404:	0e 94 57 2a 	call	0x54ae	; 0x54ae <ewbl>
	wdt_reset();
    c408:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    c40a:	60 91 b6 08 	lds	r22, 0x08B6
    c40e:	70 91 b7 08 	lds	r23, 0x08B7
    c412:	80 e2       	ldi	r24, 0x20	; 32
    c414:	91 e0       	ldi	r25, 0x01	; 1
    c416:	0e 94 4f 2a 	call	0x549e	; 0x549e <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    c41a:	60 91 b8 08 	lds	r22, 0x08B8
    c41e:	70 91 b9 08 	lds	r23, 0x08B9
    c422:	8e e0       	ldi	r24, 0x0E	; 14
    c424:	91 e0       	ldi	r25, 0x01	; 1
    c426:	0c 94 4f 2a 	jmp	0x549e	; 0x549e <eww>

0000c42a <Modbus_App>:
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    c42a:	cf 93       	push	r28
    c42c:	df 93       	push	r29

	IntOff();
    c42e:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	MBInput1[0] = DigInput.State[0];
    c432:	80 91 bc 08 	lds	r24, 0x08BC
    c436:	80 93 ee 03 	sts	0x03EE, r24

	MBInReg1[0] = (SW_VERSION << 8) + 	SW_SUBVERSION;
    c43a:	87 e0       	ldi	r24, 0x07	; 7
    c43c:	93 e0       	ldi	r25, 0x03	; 3
    c43e:	90 93 5d 0a 	sts	0x0A5D, r25
    c442:	80 93 5c 0a 	sts	0x0A5C, r24
	MBInReg1[1] = MemFail;
    c446:	80 91 5b 0a 	lds	r24, 0x0A5B
    c44a:	90 e0       	ldi	r25, 0x00	; 0
    c44c:	90 93 5f 0a 	sts	0x0A5F, r25
    c450:	80 93 5e 0a 	sts	0x0A5E, r24
	MBInReg1[2] = (uint16_t)(LiveTime & 0x0000FFFF);
    c454:	80 91 47 09 	lds	r24, 0x0947
    c458:	90 91 48 09 	lds	r25, 0x0948
    c45c:	a0 91 49 09 	lds	r26, 0x0949
    c460:	b0 91 4a 09 	lds	r27, 0x094A
    c464:	90 93 61 0a 	sts	0x0A61, r25
    c468:	80 93 60 0a 	sts	0x0A60, r24
	MBInReg1[3] = (uint16_t)(LiveTime>>16);
    c46c:	80 91 47 09 	lds	r24, 0x0947
    c470:	90 91 48 09 	lds	r25, 0x0948
    c474:	a0 91 49 09 	lds	r26, 0x0949
    c478:	b0 91 4a 09 	lds	r27, 0x094A
    c47c:	b0 93 63 0a 	sts	0x0A63, r27
    c480:	a0 93 62 0a 	sts	0x0A62, r26
	MBInReg1[4] = (uint16_t)Temperature[0];	
    c484:	80 91 e5 05 	lds	r24, 0x05E5
    c488:	90 91 e6 05 	lds	r25, 0x05E6
    c48c:	90 93 65 0a 	sts	0x0A65, r25
    c490:	80 93 64 0a 	sts	0x0A64, r24
	MBInReg1[5] = (uint16_t)GSM_State;
    c494:	80 91 19 06 	lds	r24, 0x0619
    c498:	90 e0       	ldi	r25, 0x00	; 0
    c49a:	90 93 67 0a 	sts	0x0A67, r25
    c49e:	80 93 66 0a 	sts	0x0A66, r24
	MBInReg1[6] = GSM_MyIP.IP1;
    c4a2:	80 91 ff 0a 	lds	r24, 0x0AFF
    c4a6:	90 e0       	ldi	r25, 0x00	; 0
    c4a8:	90 93 69 0a 	sts	0x0A69, r25
    c4ac:	80 93 68 0a 	sts	0x0A68, r24
	MBInReg1[7] = GSM_MyIP.IP2;
    c4b0:	80 91 00 0b 	lds	r24, 0x0B00
    c4b4:	90 e0       	ldi	r25, 0x00	; 0
    c4b6:	90 93 6b 0a 	sts	0x0A6B, r25
    c4ba:	80 93 6a 0a 	sts	0x0A6A, r24
	MBInReg1[8] = GSM_MyIP.IP3;
    c4be:	80 91 01 0b 	lds	r24, 0x0B01
    c4c2:	90 e0       	ldi	r25, 0x00	; 0
    c4c4:	90 93 6d 0a 	sts	0x0A6D, r25
    c4c8:	80 93 6c 0a 	sts	0x0A6C, r24
	MBInReg1[9] = GSM_MyIP.IP4;
    c4cc:	80 91 02 0b 	lds	r24, 0x0B02
    c4d0:	90 e0       	ldi	r25, 0x00	; 0
    c4d2:	90 93 6f 0a 	sts	0x0A6F, r25
    c4d6:	80 93 6e 0a 	sts	0x0A6E, r24
	MBInReg1[10] = GSM_ClientIP.IP1;
    c4da:	80 91 1d 0d 	lds	r24, 0x0D1D
    c4de:	90 e0       	ldi	r25, 0x00	; 0
    c4e0:	90 93 71 0a 	sts	0x0A71, r25
    c4e4:	80 93 70 0a 	sts	0x0A70, r24
	MBInReg1[11] = GSM_ClientIP.IP2;
    c4e8:	80 91 1e 0d 	lds	r24, 0x0D1E
    c4ec:	90 e0       	ldi	r25, 0x00	; 0
    c4ee:	90 93 73 0a 	sts	0x0A73, r25
    c4f2:	80 93 72 0a 	sts	0x0A72, r24
	MBInReg1[12] = GSM_ClientIP.IP3;
    c4f6:	80 91 1f 0d 	lds	r24, 0x0D1F
    c4fa:	90 e0       	ldi	r25, 0x00	; 0
    c4fc:	90 93 75 0a 	sts	0x0A75, r25
    c500:	80 93 74 0a 	sts	0x0A74, r24
	MBInReg1[13] = GSM_ClientIP.IP4;
    c504:	80 91 20 0d 	lds	r24, 0x0D20
    c508:	90 e0       	ldi	r25, 0x00	; 0
    c50a:	90 93 77 0a 	sts	0x0A77, r25
    c50e:	80 93 76 0a 	sts	0x0A76, r24
	MBInReg1[14] = GSM_RX_FIFOMax;
    c512:	80 91 f1 0a 	lds	r24, 0x0AF1
    c516:	90 e0       	ldi	r25, 0x00	; 0
    c518:	90 93 79 0a 	sts	0x0A79, r25
    c51c:	80 93 78 0a 	sts	0x0A78, r24
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    c520:	80 91 63 09 	lds	r24, 0x0963
    c524:	90 e0       	ldi	r25, 0x00	; 0
    c526:	90 93 7b 0a 	sts	0x0A7B, r25
    c52a:	80 93 7a 0a 	sts	0x0A7A, r24
	MBInReg1[16] = EM_RX_FIFOMax;
    c52e:	80 91 52 0a 	lds	r24, 0x0A52
    c532:	90 e0       	ldi	r25, 0x00	; 0
    c534:	90 93 7d 0a 	sts	0x0A7D, r25
    c538:	80 93 7c 0a 	sts	0x0A7C, r24
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    c53c:	80 91 57 09 	lds	r24, 0x0957
    c540:	80 93 7e 0a 	sts	0x0A7E, r24
    c544:	80 91 58 09 	lds	r24, 0x0958
    c548:	80 93 7f 0a 	sts	0x0A7F, r24
    c54c:	80 91 59 09 	lds	r24, 0x0959
    c550:	80 93 80 0a 	sts	0x0A80, r24
    c554:	80 91 5a 09 	lds	r24, 0x095A
    c558:	80 93 81 0a 	sts	0x0A81, r24
    c55c:	80 91 5b 09 	lds	r24, 0x095B
    c560:	80 93 82 0a 	sts	0x0A82, r24
    c564:	80 91 5c 09 	lds	r24, 0x095C
    c568:	80 93 83 0a 	sts	0x0A83, r24
    c56c:	80 91 5d 09 	lds	r24, 0x095D
    c570:	80 93 84 0a 	sts	0x0A84, r24
    c574:	80 91 5e 09 	lds	r24, 0x095E
    c578:	80 93 85 0a 	sts	0x0A85, r24
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    c57c:	80 91 40 09 	lds	r24, 0x0940
    c580:	90 e0       	ldi	r25, 0x00	; 0
    c582:	90 93 87 0a 	sts	0x0A87, r25
    c586:	80 93 86 0a 	sts	0x0A86, r24
	MBInReg1[22] = (uint16_t)Web_POST;
    c58a:	80 91 51 09 	lds	r24, 0x0951
    c58e:	90 e0       	ldi	r25, 0x00	; 0
    c590:	90 93 89 0a 	sts	0x0A89, r25
    c594:	80 93 88 0a 	sts	0x0A88, r24
	MBInReg1[23] = (uint16_t)AppProtocol;
    c598:	80 91 d8 09 	lds	r24, 0x09D8
    c59c:	90 e0       	ldi	r25, 0x00	; 0
    c59e:	90 93 8b 0a 	sts	0x0A8B, r25
    c5a2:	80 93 8a 0a 	sts	0x0A8A, r24
	MBInReg1[24] = (uint16_t)WebSession;
    c5a6:	80 91 62 09 	lds	r24, 0x0962
    c5aa:	90 e0       	ldi	r25, 0x00	; 0
    c5ac:	90 93 8d 0a 	sts	0x0A8D, r25
    c5b0:	80 93 8c 0a 	sts	0x0A8C, r24
	MBInReg1[25] = (uint16_t)WebMode;
    c5b4:	80 91 06 01 	lds	r24, 0x0106
    c5b8:	90 e0       	ldi	r25, 0x00	; 0
    c5ba:	90 93 8f 0a 	sts	0x0A8F, r25
    c5be:	80 93 8e 0a 	sts	0x0A8E, r24
	MBInReg1[26] = (uint16_t)WebStrLen;
    c5c2:	80 91 62 08 	lds	r24, 0x0862
    c5c6:	90 e0       	ldi	r25, 0x00	; 0
    c5c8:	90 93 91 0a 	sts	0x0A91, r25
    c5cc:	80 93 90 0a 	sts	0x0A90, r24

	IntOn();
    c5d0:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    c5d4:	80 91 d7 03 	lds	r24, 0x03D7
    c5d8:	80 ff       	sbrs	r24, 0
    c5da:	10 c0       	rjmp	.+32     	; 0xc5fc <Modbus_App+0x1d2>
		GSMApply();						//  MB RAM  EEPROM
    c5dc:	0e 94 ea 61 	call	0xc3d4	; 0xc3d4 <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    c5e0:	0e 94 9f 2a 	call	0x553e	; 0x553e <Modbus_ReadHoldReg>
    c5e4:	8f e4       	ldi	r24, 0x4F	; 79
    c5e6:	80 93 19 06 	sts	0x0619, r24
		ResetGSMState();				// 
		IntOff();
    c5ea:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    c5ee:	80 91 d7 03 	lds	r24, 0x03D7
    c5f2:	8e 7f       	andi	r24, 0xFE	; 254
    c5f4:	80 93 d7 03 	sts	0x03D7, r24
		IntOn();
    c5f8:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
	}
	
	IntOff();
    c5fc:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    c600:	c0 91 6e 08 	lds	r28, 0x086E
    c604:	d0 91 6f 08 	lds	r29, 0x086F
    c608:	87 e2       	ldi	r24, 0x27	; 39
    c60a:	90 e0       	ldi	r25, 0x00	; 0
    c60c:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    c610:	c8 17       	cp	r28, r24
    c612:	d9 07       	cpc	r29, r25
    c614:	29 f0       	breq	.+10     	; 0xc620 <Modbus_App+0x1f6>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    c616:	be 01       	movw	r22, r28
    c618:	87 e2       	ldi	r24, 0x27	; 39
    c61a:	90 e0       	ldi	r25, 0x00	; 0
    c61c:	0e 94 4f 2a 	call	0x549e	; 0x549e <eww>
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    c620:	df 91       	pop	r29
    c622:	cf 91       	pop	r28
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
		eww(&EM_UART_Param, MBHoldReg1[0]);
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
    c624:	0c 94 97 2a 	jmp	0x552e	; 0x552e <IntOn>

0000c628 <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    c628:	81 e0       	ldi	r24, 0x01	; 1
    c62a:	80 93 d6 09 	sts	0x09D6, r24
	ModbusMode = 0;
    c62e:	10 92 d8 03 	sts	0x03D8, r1
	EM_InitFIFO();
    c632:	0e 94 45 4b 	call	0x968a	; 0x968a <EM_InitFIFO>
	cli();
    c636:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    c638:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    c63a:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    c63e:	88 e0       	ldi	r24, 0x08	; 8
    c640:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    c644:	85 e0       	ldi	r24, 0x05	; 5
    c646:	99 e1       	ldi	r25, 0x19	; 25
    c648:	0e 94 4f 4b 	call	0x969e	; 0x969e <EM_SetUARTParam>
	sei();	
    c64c:	78 94       	sei
    c64e:	08 95       	ret

0000c650 <StopDebug>:
}

void StopDebug(void){
	GSM_DebugMode = 0;
    c650:	10 92 d6 09 	sts	0x09D6, r1
	ModbusMode = 1;
    c654:	81 e0       	ldi	r24, 0x01	; 1
    c656:	80 93 d8 03 	sts	0x03D8, r24
	cli();
    c65a:	f8 94       	cli
	MB_Init();
    c65c:	0e 94 e6 35 	call	0x6bcc	; 0x6bcc <MB_Init>
	sei();
    c660:	78 94       	sei
    c662:	08 95       	ret

0000c664 <SendDebug>:
}

//  ISR
void SendDebug(uint8_t Char){
	//---FIFO
	EM_RX_FIFO_Begin++;
    c664:	90 91 54 09 	lds	r25, 0x0954
    c668:	9f 5f       	subi	r25, 0xFF	; 255
    c66a:	90 93 54 09 	sts	0x0954, r25
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    c66e:	90 91 54 09 	lds	r25, 0x0954
    c672:	9a 3f       	cpi	r25, 0xFA	; 250
    c674:	10 f0       	brcs	.+4      	; 0xc67a <SendDebug+0x16>
    c676:	10 92 54 09 	sts	0x0954, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    c67a:	e0 91 54 09 	lds	r30, 0x0954
    c67e:	f0 e0       	ldi	r31, 0x00	; 0
    c680:	ef 50       	subi	r30, 0x0F	; 15
    c682:	fc 4f       	sbci	r31, 0xFC	; 252
    c684:	80 83       	st	Z, r24
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    c686:	90 91 54 09 	lds	r25, 0x0954
    c68a:	80 91 1b 0d 	lds	r24, 0x0D1B
    c68e:	98 13       	cpse	r25, r24
    c690:	06 c0       	rjmp	.+12     	; 0xc69e <SendDebug+0x3a>
		EM_RX_FIFOOverFlow = 1;
    c692:	81 e0       	ldi	r24, 0x01	; 1
    c694:	80 93 07 0b 	sts	0x0B07, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    c698:	8a ef       	ldi	r24, 0xFA	; 250
    c69a:	80 93 52 0a 	sts	0x0A52, r24
    c69e:	08 95       	ret

0000c6a0 <GSM_RX>:
}
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    c6a0:	8c b1       	in	r24, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    c6a2:	90 91 6d 08 	lds	r25, 0x086D
    c6a6:	9f 5f       	subi	r25, 0xFF	; 255
    c6a8:	90 93 6d 08 	sts	0x086D, r25
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    c6ac:	90 91 6d 08 	lds	r25, 0x086D
    c6b0:	9a 3f       	cpi	r25, 0xFA	; 250
    c6b2:	10 f0       	brcs	.+4      	; 0xc6b8 <GSM_RX+0x18>
    c6b4:	10 92 6d 08 	sts	0x086D, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    c6b8:	e0 91 6d 08 	lds	r30, 0x086D
    c6bc:	f0 e0       	ldi	r31, 0x00	; 0
    c6be:	e5 51       	subi	r30, 0x15	; 21
    c6c0:	fb 4f       	sbci	r31, 0xFB	; 251
    c6c2:	80 83       	st	Z, r24
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    c6c4:	20 91 6d 08 	lds	r18, 0x086D
    c6c8:	90 91 f8 05 	lds	r25, 0x05F8
    c6cc:	29 13       	cpse	r18, r25
    c6ce:	06 c0       	rjmp	.+12     	; 0xc6dc <GSM_RX+0x3c>
		GSM_RX_FIFOOverFlow = 1;
    c6d0:	91 e0       	ldi	r25, 0x01	; 1
    c6d2:	90 93 51 0a 	sts	0x0A51, r25
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    c6d6:	9a ef       	ldi	r25, 0xFA	; 250
    c6d8:	90 93 f1 0a 	sts	0x0AF1, r25
	}

	//---In Transparent Mode
	if(Transparent){
    c6dc:	90 91 5a 0a 	lds	r25, 0x0A5A
    c6e0:	99 23       	and	r25, r25
    c6e2:	a1 f0       	breq	.+40     	; 0xc70c <GSM_RX+0x6c>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    c6e4:	98 eb       	ldi	r25, 0xB8	; 184
    c6e6:	90 93 9a 00 	sts	0x009A, r25
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    c6ea:	90 91 9b 00 	lds	r25, 0x009B
    c6ee:	90 64       	ori	r25, 0x40	; 64
    c6f0:	90 93 9b 00 	sts	0x009B, r25

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    c6f4:	20 91 6d 08 	lds	r18, 0x086D
    c6f8:	90 91 dc 0a 	lds	r25, 0x0ADC
    c6fc:	29 13       	cpse	r18, r25
    c6fe:	06 c0       	rjmp	.+12     	; 0xc70c <GSM_RX+0x6c>
			GSM_RX_FIFOOverFlow_Transp = 1;
    c700:	91 e0       	ldi	r25, 0x01	; 1
    c702:	90 93 2c 0e 	sts	0x0E2C, r25
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    c706:	9a ef       	ldi	r25, 0xFA	; 250
    c708:	90 93 63 09 	sts	0x0963, r25
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    c70c:	90 91 d6 09 	lds	r25, 0x09D6
    c710:	99 23       	and	r25, r25
    c712:	29 f0       	breq	.+10     	; 0xc71e <GSM_RX+0x7e>
		SendDebug(Char);
    c714:	0e 94 32 63 	call	0xc664	; 0xc664 <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    c718:	88 e2       	ldi	r24, 0x28	; 40
    c71a:	80 93 9a 00 	sts	0x009A, r24
    c71e:	08 95       	ret

0000c720 <__vector_18>:
}
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    c720:	1f 92       	push	r1
    c722:	0f 92       	push	r0
    c724:	0f b6       	in	r0, 0x3f	; 63
    c726:	0f 92       	push	r0
    c728:	11 24       	eor	r1, r1
    c72a:	0b b6       	in	r0, 0x3b	; 59
    c72c:	0f 92       	push	r0
    c72e:	2f 93       	push	r18
    c730:	3f 93       	push	r19
    c732:	4f 93       	push	r20
    c734:	5f 93       	push	r21
    c736:	6f 93       	push	r22
    c738:	7f 93       	push	r23
    c73a:	8f 93       	push	r24
    c73c:	9f 93       	push	r25
    c73e:	af 93       	push	r26
    c740:	bf 93       	push	r27
    c742:	ef 93       	push	r30
    c744:	ff 93       	push	r31
	GSM_RX();
    c746:	0e 94 50 63 	call	0xc6a0	; 0xc6a0 <GSM_RX>
	GSM_LED = 1;
    c74a:	81 e0       	ldi	r24, 0x01	; 1
    c74c:	80 93 fd 05 	sts	0x05FD, r24
}
    c750:	ff 91       	pop	r31
    c752:	ef 91       	pop	r30
    c754:	bf 91       	pop	r27
    c756:	af 91       	pop	r26
    c758:	9f 91       	pop	r25
    c75a:	8f 91       	pop	r24
    c75c:	7f 91       	pop	r23
    c75e:	6f 91       	pop	r22
    c760:	5f 91       	pop	r21
    c762:	4f 91       	pop	r20
    c764:	3f 91       	pop	r19
    c766:	2f 91       	pop	r18
    c768:	0f 90       	pop	r0
    c76a:	0b be       	out	0x3b, r0	; 59
    c76c:	0f 90       	pop	r0
    c76e:	0f be       	out	0x3f, r0	; 63
    c770:	0f 90       	pop	r0
    c772:	1f 90       	pop	r1
    c774:	18 95       	reti

0000c776 <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    c776:	80 91 1c 0c 	lds	r24, 0x0C1C
    c77a:	8c b9       	out	0x0c, r24	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    c77c:	80 91 d6 09 	lds	r24, 0x09D6
    c780:	88 23       	and	r24, r24
    c782:	49 f0       	breq	.+18     	; 0xc796 <GSM_SendFirstChar+0x20>
		SendDebug(GSM_TxStr[0]);
    c784:	80 91 1c 0c 	lds	r24, 0x0C1C
    c788:	0e 94 32 63 	call	0xc664	; 0xc664 <SendDebug>
		cli();
    c78c:	f8 94       	cli
    c78e:	88 e2       	ldi	r24, 0x28	; 40
    c790:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    c794:	78 94       	sei
	}

	GSM_TxCharN = 1;
    c796:	81 e0       	ldi	r24, 0x01	; 1
    c798:	80 93 28 0d 	sts	0x0D28, r24
	cli();
    c79c:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    c79e:	80 91 08 01 	lds	r24, 0x0108
    c7a2:	8e 7f       	andi	r24, 0xFE	; 254
    c7a4:	80 93 08 01 	sts	0x0108, r24
	sei();
    c7a8:	78 94       	sei
	cli();
    c7aa:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    c7ac:	88 eb       	ldi	r24, 0xB8	; 184
    c7ae:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    c7b0:	78 94       	sei
    c7b2:	08 95       	ret

0000c7b4 <GSM_SendCR>:
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    c7b4:	cf 93       	push	r28
    c7b6:	df 93       	push	r29
    c7b8:	ec 01       	movw	r28, r24
    c7ba:	0e 94 c9 77 	call	0xef92	; 0xef92 <__strlen_P>
	GSMTxSz = strlen_P(Str_P);
    c7be:	80 93 3c 09 	sts	0x093C, r24
	sprintf_P(GSM_TxStr, Str_P);
    c7c2:	df 93       	push	r29
    c7c4:	cf 93       	push	r28
    c7c6:	8c e1       	ldi	r24, 0x1C	; 28
    c7c8:	9c e0       	ldi	r25, 0x0C	; 12
    c7ca:	9f 93       	push	r25
    c7cc:	8f 93       	push	r24
    c7ce:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    c7d2:	80 91 3c 09 	lds	r24, 0x093C
    c7d6:	90 e0       	ldi	r25, 0x00	; 0
    c7d8:	68 ec       	ldi	r22, 0xC8	; 200
    c7da:	71 e0       	ldi	r23, 0x01	; 1
    c7dc:	84 5e       	subi	r24, 0xE4	; 228
    c7de:	93 4f       	sbci	r25, 0xF3	; 243
    c7e0:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
	GSMTxSz++;
    c7e4:	80 91 3c 09 	lds	r24, 0x093C
    c7e8:	8f 5f       	subi	r24, 0xFF	; 255
    c7ea:	80 93 3c 09 	sts	0x093C, r24
	GSM_SendFirstChar();
    c7ee:	0f 90       	pop	r0
    c7f0:	0f 90       	pop	r0
    c7f2:	0f 90       	pop	r0
    c7f4:	0f 90       	pop	r0
}
    c7f6:	df 91       	pop	r29
    c7f8:	cf 91       	pop	r28
void GSM_SendCR(prog_char *Str_P){
	GSMTxSz = strlen_P(Str_P);
	sprintf_P(GSM_TxStr, Str_P);
	sprintf(GSM_TxStr + GSMTxSz, "\r");
	GSMTxSz++;
	GSM_SendFirstChar();
    c7fa:	0c 94 bb 63 	jmp	0xc776	; 0xc776 <GSM_SendFirstChar>

0000c7fe <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    c7fe:	cf 93       	push	r28
    c800:	df 93       	push	r29
    c802:	00 d0       	rcall	.+0      	; 0xc804 <GSM_Execute_Command+0x6>
    c804:	cd b7       	in	r28, 0x3d	; 61
    c806:	de b7       	in	r29, 0x3e	; 62
	if(GSM_Flag & (1<<flg_TxCStr)){
    c808:	20 91 08 01 	lds	r18, 0x0108
    c80c:	20 ff       	sbrs	r18, 0
    c80e:	0e c0       	rjmp	.+28     	; 0xc82c <GSM_Execute_Command+0x2e>
		GSM_SendCR(Str_P);
    c810:	69 83       	std	Y+1, r22	; 0x01
    c812:	7a 83       	std	Y+2, r23	; 0x02
    c814:	0e 94 da 63 	call	0xc7b4	; 0xc7b4 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    c818:	69 81       	ldd	r22, Y+1	; 0x01
    c81a:	7a 81       	ldd	r23, Y+2	; 0x02
    c81c:	80 91 52 02 	lds	r24, 0x0252
	}
}
    c820:	0f 90       	pop	r0
    c822:	0f 90       	pop	r0
    c824:	df 91       	pop	r29
    c826:	cf 91       	pop	r28
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
	if(GSM_Flag & (1<<flg_TxCStr)){
		GSM_SendCR(Str_P);
		StartTimer16(TD_GSM, Timeout);
    c828:	0c 94 1a 2b 	jmp	0x5634	; 0x5634 <StartTimer16>
	}
}
    c82c:	0f 90       	pop	r0
    c82e:	0f 90       	pop	r0
    c830:	df 91       	pop	r29
    c832:	cf 91       	pop	r28
    c834:	08 95       	ret

0000c836 <GSM_AddHeaderSendData>:
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    c836:	60 93 3c 09 	sts	0x093C, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    c83a:	40 91 3c 09 	lds	r20, 0x093C
    c83e:	50 e0       	ldi	r21, 0x00	; 0
    c840:	bc 01       	movw	r22, r24
    c842:	8c e1       	ldi	r24, 0x1C	; 28
    c844:	9c e0       	ldi	r25, 0x0C	; 12
    c846:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
	GSM_SendFirstChar();
    c84a:	0c 94 bb 63 	jmp	0xc776	; 0xc776 <GSM_SendFirstChar>

0000c84e <GSM_SendData>:
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    c84e:	60 93 3c 09 	sts	0x093C, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    c852:	40 91 3c 09 	lds	r20, 0x093C
    c856:	50 e0       	ldi	r21, 0x00	; 0
    c858:	bc 01       	movw	r22, r24
    c85a:	8c e1       	ldi	r24, 0x1C	; 28
    c85c:	9c e0       	ldi	r25, 0x0C	; 12
    c85e:	0e 94 fa 77 	call	0xeff4	; 0xeff4 <memcpy>
	GSM_SendFirstChar();
    c862:	0c 94 bb 63 	jmp	0xc776	; 0xc776 <GSM_SendFirstChar>

0000c866 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    c866:	2f 92       	push	r2
    c868:	3f 92       	push	r3
    c86a:	4f 92       	push	r4
    c86c:	5f 92       	push	r5
    c86e:	6f 92       	push	r6
    c870:	7f 92       	push	r7
    c872:	8f 92       	push	r8
    c874:	9f 92       	push	r9
    c876:	af 92       	push	r10
    c878:	bf 92       	push	r11
    c87a:	cf 92       	push	r12
    c87c:	df 92       	push	r13
    c87e:	ef 92       	push	r14
    c880:	ff 92       	push	r15
    c882:	0f 93       	push	r16
    c884:	1f 93       	push	r17
    c886:	cf 93       	push	r28
    c888:	df 93       	push	r29
    c88a:	cd b7       	in	r28, 0x3d	; 61
    c88c:	de b7       	in	r29, 0x3e	; 62
    c88e:	2e 97       	sbiw	r28, 0x0e	; 14
    c890:	0f b6       	in	r0, 0x3f	; 63
    c892:	f8 94       	cli
    c894:	de bf       	out	0x3e, r29	; 62
    c896:	0f be       	out	0x3f, r0	; 63
    c898:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    c89a:	80 91 61 09 	lds	r24, 0x0961
    c89e:	88 23       	and	r24, r24
    c8a0:	31 f0       	breq	.+12     	; 0xc8ae <GSM_Cycle+0x48>
    c8a2:	82 30       	cpi	r24, 0x02	; 2
    c8a4:	11 f4       	brne	.+4      	; 0xc8aa <GSM_Cycle+0x44>
    c8a6:	0c 94 c8 6f 	jmp	0xdf90	; 0xdf90 <GSM_Cycle+0x172a>
    c8aa:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    c8ae:	80 91 19 06 	lds	r24, 0x0619
    c8b2:	90 e0       	ldi	r25, 0x00	; 0
    c8b4:	80 36       	cpi	r24, 0x60	; 96
    c8b6:	91 05       	cpc	r25, r1
    c8b8:	10 f0       	brcs	.+4      	; 0xc8be <GSM_Cycle+0x58>
    c8ba:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    c8be:	fc 01       	movw	r30, r24
    c8c0:	e9 52       	subi	r30, 0x29	; 41
    c8c2:	ff 4f       	sbci	r31, 0xFF	; 255
    c8c4:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>

		case GSM_PowerOn:
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    c8c8:	60 ed       	ldi	r22, 0xD0	; 208
    c8ca:	77 e0       	ldi	r23, 0x07	; 7
    c8cc:	80 91 52 02 	lds	r24, 0x0252
    c8d0:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    c8d4:	40 e0       	ldi	r20, 0x00	; 0
    c8d6:	56 ed       	ldi	r21, 0xD6	; 214
    c8d8:	63 e8       	ldi	r22, 0x83	; 131
    c8da:	70 e0       	ldi	r23, 0x00	; 0
    c8dc:	80 91 4f 02 	lds	r24, 0x024F
    c8e0:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <StartTimer32>
			GSM_PWRCNTRL_ON();
    c8e4:	0e 94 20 2f 	call	0x5e40	; 0x5e40 <GSM_PWRCNTRL_ON>
			InitFIFO();
    c8e8:	0e 94 4f 3a 	call	0x749e	; 0x749e <InitFIFO>
			GSM_Modem = NOT_RECOGNIZED;
    c8ec:	10 92 63 08 	sts	0x0863, r1
			GSM_State = GSM_WAIT_RDY;
    c8f0:	81 e0       	ldi	r24, 0x01	; 1
    c8f2:	80 93 19 06 	sts	0x0619, r24
    c8f6:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    c8fa:	6f e4       	ldi	r22, 0x4F	; 79
    c8fc:	8f e6       	ldi	r24, 0x6F	; 111
    c8fe:	90 e5       	ldi	r25, 0x50	; 80
    c900:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    c904:	88 23       	and	r24, r24
    c906:	11 f4       	brne	.+4      	; 0xc90c <GSM_Cycle+0xa6>
    c908:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    c90c:	80 91 19 06 	lds	r24, 0x0619
    c910:	8f 5f       	subi	r24, 0xFF	; 255
    c912:	80 93 19 06 	sts	0x0619, r24
    c916:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    c91a:	68 e8       	ldi	r22, 0x88	; 136
    c91c:	73 e1       	ldi	r23, 0x13	; 19
    c91e:	82 e9       	ldi	r24, 0x92	; 146
    c920:	9f e4       	ldi	r25, 0x4F	; 79
    c922:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    c926:	80 91 19 06 	lds	r24, 0x0619
    c92a:	8f 5f       	subi	r24, 0xFF	; 255
    c92c:	80 93 19 06 	sts	0x0619, r24
    c930:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c934:	80 91 52 02 	lds	r24, 0x0252
    c938:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    c93c:	88 23       	and	r24, r24
    c93e:	19 f0       	breq	.+6      	; 0xc946 <GSM_Cycle+0xe0>
    c940:	8f e4       	ldi	r24, 0x4F	; 79
    c942:	80 93 19 06 	sts	0x0619, r24
			if(GetStringFromFIFO()){
    c946:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    c94a:	88 23       	and	r24, r24
    c94c:	e9 f0       	breq	.+58     	; 0xc988 <GSM_Cycle+0x122>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    c94e:	61 e8       	ldi	r22, 0x81	; 129
    c950:	70 e5       	ldi	r23, 0x50	; 80
    c952:	8d e6       	ldi	r24, 0x6D	; 109
    c954:	99 e0       	ldi	r25, 0x09	; 9
    c956:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    c95a:	89 2b       	or	r24, r25
    c95c:	19 f4       	brne	.+6      	; 0xc964 <GSM_Cycle+0xfe>
    c95e:	81 e0       	ldi	r24, 0x01	; 1
    c960:	80 93 63 08 	sts	0x0863, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    c964:	63 e7       	ldi	r22, 0x73	; 115
    c966:	70 e5       	ldi	r23, 0x50	; 80
    c968:	8d e6       	ldi	r24, 0x6D	; 109
    c96a:	99 e0       	ldi	r25, 0x09	; 9
    c96c:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    c970:	89 2b       	or	r24, r25
    c972:	19 f4       	brne	.+6      	; 0xc97a <GSM_Cycle+0x114>
    c974:	82 e0       	ldi	r24, 0x02	; 2
    c976:	80 93 63 08 	sts	0x0863, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    c97a:	80 91 63 08 	lds	r24, 0x0863
    c97e:	88 23       	and	r24, r24
    c980:	19 f0       	breq	.+6      	; 0xc988 <GSM_Cycle+0x122>
    c982:	86 e0       	ldi	r24, 0x06	; 6
    c984:	80 93 19 06 	sts	0x0619, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    c988:	6f e4       	ldi	r22, 0x4F	; 79
    c98a:	84 e6       	ldi	r24, 0x64	; 100
    c98c:	90 e5       	ldi	r25, 0x50	; 80
    c98e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    c992:	88 23       	and	r24, r24
    c994:	11 f4       	brne	.+4      	; 0xc99a <GSM_Cycle+0x134>
    c996:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    c99a:	80 91 63 08 	lds	r24, 0x0863
    c99e:	82 30       	cpi	r24, 0x02	; 2
    c9a0:	29 f4       	brne	.+10     	; 0xc9ac <GSM_Cycle+0x146>
    c9a2:	87 e0       	ldi	r24, 0x07	; 7
    c9a4:	80 93 19 06 	sts	0x0619, r24
    c9a8:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				else GSM_State = GSM_SEND_E0;
    c9ac:	88 e0       	ldi	r24, 0x08	; 8
    c9ae:	80 93 19 06 	sts	0x0619, r24
    c9b2:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    c9b6:	6f e4       	ldi	r22, 0x4F	; 79
    c9b8:	8a e5       	ldi	r24, 0x5A	; 90
    c9ba:	90 e5       	ldi	r25, 0x50	; 80
    c9bc:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    c9c0:	88 23       	and	r24, r24
    c9c2:	11 f4       	brne	.+4      	; 0xc9c8 <GSM_Cycle+0x162>
    c9c4:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    c9c8:	80 91 19 06 	lds	r24, 0x0619
    c9cc:	8f 5f       	subi	r24, 0xFF	; 255
    c9ce:	80 93 19 06 	sts	0x0619, r24
    c9d2:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    c9d6:	64 e6       	ldi	r22, 0x64	; 100
    c9d8:	70 e0       	ldi	r23, 0x00	; 0
    c9da:	8a e9       	ldi	r24, 0x9A	; 154
    c9dc:	9f e4       	ldi	r25, 0x4F	; 79
    c9de:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    c9e2:	80 91 19 06 	lds	r24, 0x0619
    c9e6:	8f 5f       	subi	r24, 0xFF	; 255
    c9e8:	80 93 19 06 	sts	0x0619, r24
    c9ec:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c9f0:	6f e4       	ldi	r22, 0x4F	; 79
    c9f2:	87 e1       	ldi	r24, 0x17	; 23
    c9f4:	90 e5       	ldi	r25, 0x50	; 80
    c9f6:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    c9fa:	88 23       	and	r24, r24
    c9fc:	11 f4       	brne	.+4      	; 0xca02 <GSM_Cycle+0x19c>
    c9fe:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ca02:	80 91 19 06 	lds	r24, 0x0619
    ca06:	8f 5f       	subi	r24, 0xFF	; 255
    ca08:	80 93 19 06 	sts	0x0619, r24
    ca0c:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    ca10:	64 e6       	ldi	r22, 0x64	; 100
    ca12:	70 e0       	ldi	r23, 0x00	; 0
    ca14:	88 e8       	ldi	r24, 0x88	; 136
    ca16:	9f e4       	ldi	r25, 0x4F	; 79
    ca18:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    ca1c:	80 91 19 06 	lds	r24, 0x0619
    ca20:	8f 5f       	subi	r24, 0xFF	; 255
    ca22:	80 93 19 06 	sts	0x0619, r24
    ca26:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ca2a:	6f e4       	ldi	r22, 0x4F	; 79
    ca2c:	87 e1       	ldi	r24, 0x17	; 23
    ca2e:	90 e5       	ldi	r25, 0x50	; 80
    ca30:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    ca34:	88 23       	and	r24, r24
    ca36:	11 f4       	brne	.+4      	; 0xca3c <GSM_Cycle+0x1d6>
    ca38:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ca3c:	80 91 19 06 	lds	r24, 0x0619
    ca40:	8f 5f       	subi	r24, 0xFF	; 255
    ca42:	80 93 19 06 	sts	0x0619, r24
    ca46:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_CCID:
			GSM_RxStr[19] = 0;
    ca4a:	10 92 80 09 	sts	0x0980, r1
			GSM_Execute_Command(AT_CCID,300*GSM_DEBUG_DELAY); GSM_State++;
    ca4e:	6c e2       	ldi	r22, 0x2C	; 44
    ca50:	71 e0       	ldi	r23, 0x01	; 1
    ca52:	80 e8       	ldi	r24, 0x80	; 128
    ca54:	9f e4       	ldi	r25, 0x4F	; 79
    ca56:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    ca5a:	80 91 19 06 	lds	r24, 0x0619
    ca5e:	8f 5f       	subi	r24, 0xFF	; 255
    ca60:	80 93 19 06 	sts	0x0619, r24
    ca64:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CCID_READ:
			//8938001300106446004F
			if(GetStringFromFIFO() && ((GSM_RxStr[19] == 'F')||(GSM_RxStr[19] == 'f')) ){
    ca68:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    ca6c:	88 23       	and	r24, r24
    ca6e:	11 f4       	brne	.+4      	; 0xca74 <GSM_Cycle+0x20e>
    ca70:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ca74:	80 91 80 09 	lds	r24, 0x0980
    ca78:	8f 7d       	andi	r24, 0xDF	; 223
    ca7a:	86 34       	cpi	r24, 0x46	; 70
    ca7c:	11 f0       	breq	.+4      	; 0xca82 <GSM_Cycle+0x21c>
    ca7e:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>



				GSM_RxStr[18] = ' ';
    ca82:	10 e2       	ldi	r17, 0x20	; 32
    ca84:	10 93 7f 09 	sts	0x097F, r17
				sscanf_P(GSM_RxStr+9,PSTR("%lud"), (long unsigned int*)&ICCID2);
    ca88:	84 e0       	ldi	r24, 0x04	; 4
    ca8a:	96 e0       	ldi	r25, 0x06	; 6
    ca8c:	9f 93       	push	r25
    ca8e:	8f 93       	push	r24
    ca90:	8d ea       	ldi	r24, 0xAD	; 173
    ca92:	93 e0       	ldi	r25, 0x03	; 3
    ca94:	9f 93       	push	r25
    ca96:	8f 93       	push	r24
    ca98:	86 e7       	ldi	r24, 0x76	; 118
    ca9a:	99 e0       	ldi	r25, 0x09	; 9
    ca9c:	9f 93       	push	r25
    ca9e:	8f 93       	push	r24
    caa0:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				GSM_RxStr[9] = ' ';
    caa4:	10 93 76 09 	sts	0x0976, r17
				sscanf_P(GSM_RxStr+5,PSTR("%u"), (unsigned int*)&ICCID1);
    caa8:	8a e0       	ldi	r24, 0x0A	; 10
    caaa:	9b e0       	ldi	r25, 0x0B	; 11
    caac:	9f 93       	push	r25
    caae:	8f 93       	push	r24
    cab0:	8a ea       	ldi	r24, 0xAA	; 170
    cab2:	93 e0       	ldi	r25, 0x03	; 3
    cab4:	9f 93       	push	r25
    cab6:	8f 93       	push	r24
    cab8:	82 e7       	ldi	r24, 0x72	; 114
    caba:	99 e0       	ldi	r25, 0x09	; 9
    cabc:	9f 93       	push	r25
    cabe:	8f 93       	push	r24
    cac0:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				if((ICCID1 == 0) || (ICCID2==0)) GSM_State = GSM_ReStart1;
    cac4:	40 91 0a 0b 	lds	r20, 0x0B0A
    cac8:	50 91 0b 0b 	lds	r21, 0x0B0B
    cacc:	0f b6       	in	r0, 0x3f	; 63
    cace:	f8 94       	cli
    cad0:	de bf       	out	0x3e, r29	; 62
    cad2:	0f be       	out	0x3f, r0	; 63
    cad4:	cd bf       	out	0x3d, r28	; 61
    cad6:	41 15       	cp	r20, r1
    cad8:	51 05       	cpc	r21, r1
    cada:	69 f0       	breq	.+26     	; 0xcaf6 <GSM_Cycle+0x290>
    cadc:	40 90 04 06 	lds	r4, 0x0604
    cae0:	50 90 05 06 	lds	r5, 0x0605
    cae4:	60 90 06 06 	lds	r6, 0x0606
    cae8:	70 90 07 06 	lds	r7, 0x0607
    caec:	41 14       	cp	r4, r1
    caee:	51 04       	cpc	r5, r1
    caf0:	61 04       	cpc	r6, r1
    caf2:	71 04       	cpc	r7, r1
    caf4:	29 f4       	brne	.+10     	; 0xcb00 <GSM_Cycle+0x29a>
    caf6:	8f e4       	ldi	r24, 0x4F	; 79
    caf8:	80 93 19 06 	sts	0x0619, r24
    cafc:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				else{
					ICCID = (uint64_t)ICCID1 * 1000000000UL + (uint64_t)ICCID2;
    cb00:	a1 2c       	mov	r10, r1
    cb02:	6a ec       	ldi	r22, 0xCA	; 202
    cb04:	b6 2e       	mov	r11, r22
    cb06:	7a e9       	ldi	r23, 0x9A	; 154
    cb08:	c7 2e       	mov	r12, r23
    cb0a:	eb e3       	ldi	r30, 0x3B	; 59
    cb0c:	de 2e       	mov	r13, r30
    cb0e:	e1 2c       	mov	r14, r1
    cb10:	f1 2c       	mov	r15, r1
    cb12:	00 e0       	ldi	r16, 0x00	; 0
    cb14:	10 e0       	ldi	r17, 0x00	; 0
    cb16:	9a 01       	movw	r18, r20
    cb18:	40 e0       	ldi	r20, 0x00	; 0
    cb1a:	50 e0       	ldi	r21, 0x00	; 0
    cb1c:	60 e0       	ldi	r22, 0x00	; 0
    cb1e:	70 e0       	ldi	r23, 0x00	; 0
    cb20:	80 e0       	ldi	r24, 0x00	; 0
    cb22:	90 e0       	ldi	r25, 0x00	; 0
    cb24:	0e 94 05 81 	call	0x1020a	; 0x1020a <__muldi3>
    cb28:	12 01       	movw	r2, r4
    cb2a:	23 01       	movw	r4, r6
    cb2c:	51 01       	movw	r10, r2
    cb2e:	62 01       	movw	r12, r4
    cb30:	0e 94 5e 81 	call	0x102bc	; 0x102bc <__adddi3>
    cb34:	20 93 57 09 	sts	0x0957, r18
    cb38:	30 93 58 09 	sts	0x0958, r19
    cb3c:	40 93 59 09 	sts	0x0959, r20
    cb40:	50 93 5a 09 	sts	0x095A, r21
    cb44:	60 93 5b 09 	sts	0x095B, r22
    cb48:	70 93 5c 09 	sts	0x095C, r23
    cb4c:	80 93 5d 09 	sts	0x095D, r24
    cb50:	90 93 5e 09 	sts	0x095E, r25
					GSM_State++;
    cb54:	80 91 19 06 	lds	r24, 0x0619
    cb58:	8f 5f       	subi	r24, 0xFF	; 255
    cb5a:	80 93 19 06 	sts	0x0619, r24
    cb5e:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				}
			}
			break;
		case GSM_WAIT_CCID_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cb62:	6f e4       	ldi	r22, 0x4F	; 79
    cb64:	87 e1       	ldi	r24, 0x17	; 23
    cb66:	90 e5       	ldi	r25, 0x50	; 80
    cb68:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    cb6c:	88 23       	and	r24, r24
    cb6e:	11 f4       	brne	.+4      	; 0xcb74 <GSM_Cycle+0x30e>
    cb70:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    cb74:	80 91 19 06 	lds	r24, 0x0619
    cb78:	8f 5f       	subi	r24, 0xFF	; 255
    cb7a:	80 93 19 06 	sts	0x0619, r24
    cb7e:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    cb82:	64 e6       	ldi	r22, 0x64	; 100
    cb84:	70 e0       	ldi	r23, 0x00	; 0
    cb86:	86 e7       	ldi	r24, 0x76	; 118
    cb88:	9f e4       	ldi	r25, 0x4F	; 79
    cb8a:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    cb8e:	80 91 19 06 	lds	r24, 0x0619
    cb92:	8f 5f       	subi	r24, 0xFF	; 255
    cb94:	80 93 19 06 	sts	0x0619, r24
    cb98:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cb9c:	6f e4       	ldi	r22, 0x4F	; 79
    cb9e:	87 e1       	ldi	r24, 0x17	; 23
    cba0:	90 e5       	ldi	r25, 0x50	; 80
    cba2:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    cba6:	88 23       	and	r24, r24
    cba8:	11 f4       	brne	.+4      	; 0xcbae <GSM_Cycle+0x348>
    cbaa:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    cbae:	80 91 19 06 	lds	r24, 0x0619
    cbb2:	8f 5f       	subi	r24, 0xFF	; 255
    cbb4:	80 93 19 06 	sts	0x0619, r24
    cbb8:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    cbbc:	64 e6       	ldi	r22, 0x64	; 100
    cbbe:	70 e0       	ldi	r23, 0x00	; 0
    cbc0:	83 e6       	ldi	r24, 0x63	; 99
    cbc2:	9f e4       	ldi	r25, 0x4F	; 79
    cbc4:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    cbc8:	80 91 19 06 	lds	r24, 0x0619
    cbcc:	8f 5f       	subi	r24, 0xFF	; 255
    cbce:	80 93 19 06 	sts	0x0619, r24
    cbd2:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    cbd6:	6f e4       	ldi	r22, 0x4F	; 79
    cbd8:	87 e1       	ldi	r24, 0x17	; 23
    cbda:	90 e5       	ldi	r25, 0x50	; 80
    cbdc:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    cbe0:	88 23       	and	r24, r24
    cbe2:	11 f4       	brne	.+4      	; 0xcbe8 <GSM_Cycle+0x382>
    cbe4:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    cbe8:	80 91 19 06 	lds	r24, 0x0619
    cbec:	8f 5f       	subi	r24, 0xFF	; 255
    cbee:	80 93 19 06 	sts	0x0619, r24
    cbf2:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    cbf6:	80 91 2d 0e 	lds	r24, 0x0E2D
    cbfa:	64 e6       	ldi	r22, 0x64	; 100
    cbfc:	70 e0       	ldi	r23, 0x00	; 0
    cbfe:	88 23       	and	r24, r24
    cc00:	19 f0       	breq	.+6      	; 0xcc08 <GSM_Cycle+0x3a2>
    cc02:	86 e2       	ldi	r24, 0x26	; 38
    cc04:	9f e4       	ldi	r25, 0x4F	; 79
    cc06:	02 c0       	rjmp	.+4      	; 0xcc0c <GSM_Cycle+0x3a6>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    cc08:	82 e3       	ldi	r24, 0x32	; 50
    cc0a:	9f e4       	ldi	r25, 0x4F	; 79
    cc0c:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
			GSM_State++; 
    cc10:	80 91 19 06 	lds	r24, 0x0619
    cc14:	8f 5f       	subi	r24, 0xFF	; 255
    cc16:	80 93 19 06 	sts	0x0619, r24
    cc1a:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cc1e:	6f e4       	ldi	r22, 0x4F	; 79
    cc20:	87 e1       	ldi	r24, 0x17	; 23
    cc22:	90 e5       	ldi	r25, 0x50	; 80
    cc24:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    cc28:	88 23       	and	r24, r24
    cc2a:	11 f4       	brne	.+4      	; 0xcc30 <GSM_Cycle+0x3ca>
    cc2c:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				if(GSM_MultiCon){
    cc30:	80 91 2d 0e 	lds	r24, 0x0E2D
    cc34:	88 23       	and	r24, r24
    cc36:	59 f0       	breq	.+22     	; 0xcc4e <GSM_Cycle+0x3e8>
					GSM_State = GSM_WAIT_1;
    cc38:	87 e1       	ldi	r24, 0x17	; 23
    cc3a:	80 93 19 06 	sts	0x0619, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    cc3e:	68 ee       	ldi	r22, 0xE8	; 232
    cc40:	73 e0       	ldi	r23, 0x03	; 3
    cc42:	80 91 52 02 	lds	r24, 0x0252
    cc46:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    cc4a:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				}
				else GSM_State++;
    cc4e:	80 91 19 06 	lds	r24, 0x0619
    cc52:	8f 5f       	subi	r24, 0xFF	; 255
    cc54:	80 93 19 06 	sts	0x0619, r24
    cc58:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    cc5c:	80 91 2d 0e 	lds	r24, 0x0E2D
    cc60:	64 e6       	ldi	r22, 0x64	; 100
    cc62:	70 e0       	ldi	r23, 0x00	; 0
    cc64:	88 23       	and	r24, r24
    cc66:	19 f0       	breq	.+6      	; 0xcc6e <GSM_Cycle+0x408>
    cc68:	8b e4       	ldi	r24, 0x4B	; 75
    cc6a:	9f e4       	ldi	r25, 0x4F	; 79
    cc6c:	02 c0       	rjmp	.+4      	; 0xcc72 <GSM_Cycle+0x40c>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    cc6e:	8e e3       	ldi	r24, 0x3E	; 62
    cc70:	9f e4       	ldi	r25, 0x4F	; 79
    cc72:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
			GSM_State++;
    cc76:	80 91 19 06 	lds	r24, 0x0619
    cc7a:	8f 5f       	subi	r24, 0xFF	; 255
    cc7c:	80 93 19 06 	sts	0x0619, r24
    cc80:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    cc84:	6f e4       	ldi	r22, 0x4F	; 79
    cc86:	87 e1       	ldi	r24, 0x17	; 23
    cc88:	90 e5       	ldi	r25, 0x50	; 80
    cc8a:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    cc8e:	88 23       	and	r24, r24
    cc90:	11 f4       	brne	.+4      	; 0xcc96 <GSM_Cycle+0x430>
    cc92:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
				GSM_State++;
    cc96:	80 91 19 06 	lds	r24, 0x0619
    cc9a:	8f 5f       	subi	r24, 0xFF	; 255
    cc9c:	80 93 19 06 	sts	0x0619, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    cca0:	68 ee       	ldi	r22, 0xE8	; 232
    cca2:	73 e0       	ldi	r23, 0x03	; 3
    cca4:	80 91 52 02 	lds	r24, 0x0252
    cca8:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    ccac:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    ccb0:	10 92 de 03 	sts	0x03DE, r1
			GSM_State++;
    ccb4:	80 91 19 06 	lds	r24, 0x0619
    ccb8:	8f 5f       	subi	r24, 0xFF	; 255
    ccba:	80 93 19 06 	sts	0x0619, r24
    ccbe:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    ccc2:	64 ef       	ldi	r22, 0xF4	; 244
    ccc4:	71 e0       	ldi	r23, 0x01	; 1
    ccc6:	8b e1       	ldi	r24, 0x1B	; 27
    ccc8:	9f e4       	ldi	r25, 0x4F	; 79
    ccca:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    ccce:	80 91 de 03 	lds	r24, 0x03DE
    ccd2:	8f 5f       	subi	r24, 0xFF	; 255
    ccd4:	80 93 de 03 	sts	0x03DE, r24
    ccd8:	80 91 19 06 	lds	r24, 0x0619
    ccdc:	8f 5f       	subi	r24, 0xFF	; 255
    ccde:	80 93 19 06 	sts	0x0619, r24
    cce2:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    cce6:	80 91 de 03 	lds	r24, 0x03DE
    ccea:	85 31       	cpi	r24, 0x15	; 21
    ccec:	18 f0       	brcs	.+6      	; 0xccf4 <GSM_Cycle+0x48e>
    ccee:	8f e4       	ldi	r24, 0x4F	; 79
    ccf0:	80 93 19 06 	sts	0x0619, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    ccf4:	68 e1       	ldi	r22, 0x18	; 24
    ccf6:	87 e1       	ldi	r24, 0x17	; 23
    ccf8:	90 e5       	ldi	r25, 0x50	; 80
    ccfa:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    ccfe:	88 23       	and	r24, r24
    cd00:	11 f4       	brne	.+4      	; 0xcd06 <GSM_Cycle+0x4a0>
    cd02:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    cd06:	80 91 19 06 	lds	r24, 0x0619
    cd0a:	8f 5f       	subi	r24, 0xFF	; 255
    cd0c:	80 93 19 06 	sts	0x0619, r24
    cd10:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    cd14:	80 91 08 01 	lds	r24, 0x0108
    cd18:	80 ff       	sbrs	r24, 0
    cd1a:	6d c0       	rjmp	.+218    	; 0xcdf6 <GSM_Cycle+0x590>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    cd1c:	8c e0       	ldi	r24, 0x0C	; 12
    cd1e:	9f e4       	ldi	r25, 0x4F	; 79
    cd20:	9f 93       	push	r25
    cd22:	8f 93       	push	r24
    cd24:	8c e1       	ldi	r24, 0x1C	; 28
    cd26:	9c e0       	ldi	r25, 0x0C	; 12
    cd28:	9f 93       	push	r25
    cd2a:	8f 93       	push	r24
    cd2c:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
    cd30:	8e e0       	ldi	r24, 0x0E	; 14
    cd32:	80 93 3c 09 	sts	0x093C, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    cd36:	10 91 3c 09 	lds	r17, 0x093C
    cd3a:	80 91 3c 09 	lds	r24, 0x093C
    cd3e:	90 e0       	ldi	r25, 0x00	; 0
    cd40:	62 e6       	ldi	r22, 0x62	; 98
    cd42:	71 e0       	ldi	r23, 0x01	; 1
    cd44:	84 5e       	subi	r24, 0xE4	; 228
    cd46:	93 4f       	sbci	r25, 0xF3	; 243
    cd48:	0e 94 12 3b 	call	0x7624	; 0x7624 <strcpy_EE>
    cd4c:	81 0f       	add	r24, r17
    cd4e:	80 93 3c 09 	sts	0x093C, r24
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    cd52:	80 91 3c 09 	lds	r24, 0x093C
    cd56:	90 e0       	ldi	r25, 0x00	; 0
    cd58:	62 eb       	ldi	r22, 0xB2	; 178
    cd5a:	71 e0       	ldi	r23, 0x01	; 1
    cd5c:	84 5e       	subi	r24, 0xE4	; 228
    cd5e:	93 4f       	sbci	r25, 0xF3	; 243
    cd60:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
    cd64:	80 91 3c 09 	lds	r24, 0x093C
    cd68:	8d 5f       	subi	r24, 0xFD	; 253
    cd6a:	80 93 3c 09 	sts	0x093C, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    cd6e:	10 91 3c 09 	lds	r17, 0x093C
    cd72:	80 91 3c 09 	lds	r24, 0x093C
    cd76:	90 e0       	ldi	r25, 0x00	; 0
    cd78:	6e e4       	ldi	r22, 0x4E	; 78
    cd7a:	71 e0       	ldi	r23, 0x01	; 1
    cd7c:	84 5e       	subi	r24, 0xE4	; 228
    cd7e:	93 4f       	sbci	r25, 0xF3	; 243
    cd80:	0e 94 12 3b 	call	0x7624	; 0x7624 <strcpy_EE>
    cd84:	81 0f       	add	r24, r17
    cd86:	80 93 3c 09 	sts	0x093C, r24
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    cd8a:	80 91 3c 09 	lds	r24, 0x093C
    cd8e:	90 e0       	ldi	r25, 0x00	; 0
    cd90:	62 eb       	ldi	r22, 0xB2	; 178
    cd92:	71 e0       	ldi	r23, 0x01	; 1
    cd94:	84 5e       	subi	r24, 0xE4	; 228
    cd96:	93 4f       	sbci	r25, 0xF3	; 243
    cd98:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
    cd9c:	80 91 3c 09 	lds	r24, 0x093C
    cda0:	8d 5f       	subi	r24, 0xFD	; 253
    cda2:	80 93 3c 09 	sts	0x093C, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    cda6:	10 91 3c 09 	lds	r17, 0x093C
    cdaa:	80 91 3c 09 	lds	r24, 0x093C
    cdae:	90 e0       	ldi	r25, 0x00	; 0
    cdb0:	6a e3       	ldi	r22, 0x3A	; 58
    cdb2:	71 e0       	ldi	r23, 0x01	; 1
    cdb4:	84 5e       	subi	r24, 0xE4	; 228
    cdb6:	93 4f       	sbci	r25, 0xF3	; 243
    cdb8:	0e 94 12 3b 	call	0x7624	; 0x7624 <strcpy_EE>
    cdbc:	81 0f       	add	r24, r17
    cdbe:	80 93 3c 09 	sts	0x093C, r24
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    cdc2:	80 91 3c 09 	lds	r24, 0x093C
    cdc6:	90 e0       	ldi	r25, 0x00	; 0
    cdc8:	67 ec       	ldi	r22, 0xC7	; 199
    cdca:	71 e0       	ldi	r23, 0x01	; 1
    cdcc:	84 5e       	subi	r24, 0xE4	; 228
    cdce:	93 4f       	sbci	r25, 0xF3	; 243
    cdd0:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
    cdd4:	80 91 3c 09 	lds	r24, 0x093C
    cdd8:	8e 5f       	subi	r24, 0xFE	; 254
    cdda:	80 93 3c 09 	sts	0x093C, r24
				GSM_SendFirstChar();
    cdde:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    cde2:	6c e2       	ldi	r22, 0x2C	; 44
    cde4:	71 e0       	ldi	r23, 0x01	; 1
    cde6:	80 91 52 02 	lds	r24, 0x0252
    cdea:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    cdee:	0f 90       	pop	r0
    cdf0:	0f 90       	pop	r0
    cdf2:	0f 90       	pop	r0
    cdf4:	0f 90       	pop	r0
			}
			GSM_State++;
    cdf6:	80 91 19 06 	lds	r24, 0x0619
    cdfa:	8f 5f       	subi	r24, 0xFF	; 255
    cdfc:	80 93 19 06 	sts	0x0619, r24
    ce00:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ce04:	6f e4       	ldi	r22, 0x4F	; 79
    ce06:	87 e1       	ldi	r24, 0x17	; 23
    ce08:	90 e5       	ldi	r25, 0x50	; 80
    ce0a:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    ce0e:	88 23       	and	r24, r24
    ce10:	11 f4       	brne	.+4      	; 0xce16 <GSM_Cycle+0x5b0>
    ce12:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ce16:	80 91 19 06 	lds	r24, 0x0619
    ce1a:	8f 5f       	subi	r24, 0xFF	; 255
    ce1c:	80 93 19 06 	sts	0x0619, r24
    ce20:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    ce24:	6c e2       	ldi	r22, 0x2C	; 44
    ce26:	71 e0       	ldi	r23, 0x01	; 1
    ce28:	84 e0       	ldi	r24, 0x04	; 4
    ce2a:	9f e4       	ldi	r25, 0x4F	; 79
    ce2c:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    ce30:	80 91 19 06 	lds	r24, 0x0619
    ce34:	8f 5f       	subi	r24, 0xFF	; 255
    ce36:	80 93 19 06 	sts	0x0619, r24
    ce3a:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ce3e:	6f e4       	ldi	r22, 0x4F	; 79
    ce40:	87 e1       	ldi	r24, 0x17	; 23
    ce42:	90 e5       	ldi	r25, 0x50	; 80
    ce44:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    ce48:	88 23       	and	r24, r24
    ce4a:	11 f4       	brne	.+4      	; 0xce50 <GSM_Cycle+0x5ea>
    ce4c:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ce50:	80 91 19 06 	lds	r24, 0x0619
    ce54:	8f 5f       	subi	r24, 0xFF	; 255
    ce56:	80 93 19 06 	sts	0x0619, r24
    ce5a:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    ce5e:	60 ee       	ldi	r22, 0xE0	; 224
    ce60:	7e e2       	ldi	r23, 0x2E	; 46
    ce62:	8b ef       	ldi	r24, 0xFB	; 251
    ce64:	9e e4       	ldi	r25, 0x4E	; 78
    ce66:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    ce6a:	80 91 19 06 	lds	r24, 0x0619
    ce6e:	8f 5f       	subi	r24, 0xFF	; 255
    ce70:	80 93 19 06 	sts	0x0619, r24
    ce74:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ce78:	6f e4       	ldi	r22, 0x4F	; 79
    ce7a:	87 e1       	ldi	r24, 0x17	; 23
    ce7c:	90 e5       	ldi	r25, 0x50	; 80
    ce7e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    ce82:	88 23       	and	r24, r24
    ce84:	11 f4       	brne	.+4      	; 0xce8a <GSM_Cycle+0x624>
    ce86:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    ce8a:	80 91 19 06 	lds	r24, 0x0619
    ce8e:	8f 5f       	subi	r24, 0xFF	; 255
    ce90:	80 93 19 06 	sts	0x0619, r24
    ce94:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    ce98:	68 ee       	ldi	r22, 0xE8	; 232
    ce9a:	73 e0       	ldi	r23, 0x03	; 3
    ce9c:	82 ef       	ldi	r24, 0xF2	; 242
    ce9e:	9e e4       	ldi	r25, 0x4E	; 78
    cea0:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    cea4:	80 91 19 06 	lds	r24, 0x0619
    cea8:	8f 5f       	subi	r24, 0xFF	; 255
    ceaa:	80 93 19 06 	sts	0x0619, r24
    ceae:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    ceb2:	80 91 52 02 	lds	r24, 0x0252
    ceb6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ceba:	88 23       	and	r24, r24
    cebc:	19 f0       	breq	.+6      	; 0xcec4 <GSM_Cycle+0x65e>
    cebe:	8f e4       	ldi	r24, 0x4F	; 79
    cec0:	80 93 19 06 	sts	0x0619, r24
			if(GetStringFromFIFO()){
    cec4:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    cec8:	88 23       	and	r24, r24
    ceca:	11 f4       	brne	.+4      	; 0xced0 <GSM_Cycle+0x66a>
    cecc:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    ced0:	10 92 ff 0a 	sts	0x0AFF, r1
	IP->IP2 = IP2;
    ced4:	10 92 00 0b 	sts	0x0B00, r1
	IP->IP3 = IP3;
    ced8:	10 92 01 0b 	sts	0x0B01, r1
	IP->IP4 = IP4;
    cedc:	10 92 02 0b 	sts	0x0B02, r1
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    cee0:	40 e0       	ldi	r20, 0x00	; 0
    cee2:	ad e6       	ldi	r26, 0x6D	; 109
    cee4:	b9 e0       	ldi	r27, 0x09	; 9
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    cee6:	50 e2       	ldi	r21, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    cee8:	8d e6       	ldi	r24, 0x6D	; 109
    ceea:	99 e0       	ldi	r25, 0x09	; 9
    ceec:	fd 01       	movw	r30, r26
    ceee:	01 90       	ld	r0, Z+
    cef0:	00 20       	and	r0, r0
    cef2:	e9 f7       	brne	.-6      	; 0xceee <GSM_Cycle+0x688>
    cef4:	31 97       	sbiw	r30, 0x01	; 1
    cef6:	ed 56       	subi	r30, 0x6D	; 109
    cef8:	f9 40       	sbci	r31, 0x09	; 9
    cefa:	24 2f       	mov	r18, r20
    cefc:	30 e0       	ldi	r19, 0x00	; 0
    cefe:	2e 17       	cp	r18, r30
    cf00:	3f 07       	cpc	r19, r31
    cf02:	58 f4       	brcc	.+22     	; 0xcf1a <GSM_Cycle+0x6b4>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    cf04:	f9 01       	movw	r30, r18
    cf06:	e3 59       	subi	r30, 0x93	; 147
    cf08:	f6 4f       	sbci	r31, 0xF6	; 246
    cf0a:	80 81       	ld	r24, Z
    cf0c:	90 e0       	ldi	r25, 0x00	; 0
    cf0e:	c0 97       	sbiw	r24, 0x30	; 48
    cf10:	0a 97       	sbiw	r24, 0x0a	; 10
    cf12:	08 f0       	brcs	.+2      	; 0xcf16 <GSM_Cycle+0x6b0>
    cf14:	50 83       	st	Z, r21
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    cf16:	4f 5f       	subi	r20, 0xFF	; 255
    cf18:	e7 cf       	rjmp	.-50     	; 0xcee8 <GSM_Cycle+0x682>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    cf1a:	22 e0       	ldi	r18, 0x02	; 2
    cf1c:	3b e0       	ldi	r19, 0x0B	; 11
    cf1e:	3f 93       	push	r19
    cf20:	2f 93       	push	r18
    cf22:	21 e0       	ldi	r18, 0x01	; 1
    cf24:	3b e0       	ldi	r19, 0x0B	; 11
    cf26:	3f 93       	push	r19
    cf28:	2f 93       	push	r18
    cf2a:	20 e0       	ldi	r18, 0x00	; 0
    cf2c:	3b e0       	ldi	r19, 0x0B	; 11
    cf2e:	3f 93       	push	r19
    cf30:	2f 93       	push	r18
    cf32:	2f ef       	ldi	r18, 0xFF	; 255
    cf34:	3a e0       	ldi	r19, 0x0A	; 10
    cf36:	3f 93       	push	r19
    cf38:	2f 93       	push	r18
    cf3a:	26 e9       	ldi	r18, 0x96	; 150
    cf3c:	33 e0       	ldi	r19, 0x03	; 3
    cf3e:	3f 93       	push	r19
    cf40:	2f 93       	push	r18
    cf42:	9f 93       	push	r25
    cf44:	8f 93       	push	r24
    cf46:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
    cf4a:	00 e0       	ldi	r16, 0x00	; 0
    cf4c:	20 e0       	ldi	r18, 0x00	; 0
    cf4e:	40 e0       	ldi	r20, 0x00	; 0
    cf50:	60 e0       	ldi	r22, 0x00	; 0
    cf52:	8f ef       	ldi	r24, 0xFF	; 255
    cf54:	9a e0       	ldi	r25, 0x0A	; 10
    cf56:	0e 94 0e 3a 	call	0x741c	; 0x741c <IP_compare_Const>
    cf5a:	0f b6       	in	r0, 0x3f	; 63
    cf5c:	f8 94       	cli
    cf5e:	de bf       	out	0x3e, r29	; 62
    cf60:	0f be       	out	0x3f, r0	; 63
    cf62:	cd bf       	out	0x3d, r28	; 61
    cf64:	81 11       	cpse	r24, r1
    cf66:	0b c0       	rjmp	.+22     	; 0xcf7e <GSM_Cycle+0x718>
					if(GSM_MultiCon) GSM_State++;
    cf68:	80 91 2d 0e 	lds	r24, 0x0E2D
    cf6c:	88 23       	and	r24, r24
    cf6e:	21 f0       	breq	.+8      	; 0xcf78 <GSM_Cycle+0x712>
    cf70:	80 91 19 06 	lds	r24, 0x0619
    cf74:	8f 5f       	subi	r24, 0xFF	; 255
    cf76:	01 c0       	rjmp	.+2      	; 0xcf7a <GSM_Cycle+0x714>
					else GSM_State = GSM_SEND_CIPSERVER;
    cf78:	85 e2       	ldi	r24, 0x25	; 37
    cf7a:	80 93 19 06 	sts	0x0619, r24
				}
				TempNum=0;	//
    cf7e:	10 92 df 03 	sts	0x03DF, r1
    cf82:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    cf86:	10 91 df 03 	lds	r17, 0x03DF
    cf8a:	f4 e0       	ldi	r31, 0x04	; 4
    cf8c:	1f 9f       	mul	r17, r31
    cf8e:	c0 01       	movw	r24, r0
    cf90:	11 24       	eor	r1, r1
    cf92:	00 e0       	ldi	r16, 0x00	; 0
    cf94:	20 e0       	ldi	r18, 0x00	; 0
    cf96:	40 e0       	ldi	r20, 0x00	; 0
    cf98:	60 e0       	ldi	r22, 0x00	; 0
    cf9a:	86 5d       	subi	r24, 0xD6	; 214
    cf9c:	9e 4f       	sbci	r25, 0xFE	; 254
    cf9e:	0e 94 1f 3a 	call	0x743e	; 0x743e <IP_E_compare_Const>
    cfa2:	88 23       	and	r24, r24
    cfa4:	61 f0       	breq	.+24     	; 0xcfbe <GSM_Cycle+0x758>
				TempNum++;
    cfa6:	1f 5f       	subi	r17, 0xFF	; 255
    cfa8:	10 93 df 03 	sts	0x03DF, r17
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    cfac:	14 30       	cpi	r17, 0x04	; 4
    cfae:	10 f4       	brcc	.+4      	; 0xcfb4 <GSM_Cycle+0x74e>
    cfb0:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
    cfb4:	88 e2       	ldi	r24, 0x28	; 40
    cfb6:	80 93 19 06 	sts	0x0619, r24
    cfba:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    cfbe:	80 91 08 01 	lds	r24, 0x0108
    cfc2:	80 fd       	sbrc	r24, 0
    cfc4:	02 c0       	rjmp	.+4      	; 0xcfca <GSM_Cycle+0x764>
    cfc6:	0c 94 4e 70 	jmp	0xe09c	; 0xe09c <GSM_Cycle+0x1836>
					GSMTxSz = strlen_P(AT_CIPSTART);
    cfca:	84 e1       	ldi	r24, 0x14	; 20
    cfcc:	80 93 3c 09 	sts	0x093C, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    cfd0:	8d ed       	ldi	r24, 0xDD	; 221
    cfd2:	9e e4       	ldi	r25, 0x4E	; 78
    cfd4:	9f 93       	push	r25
    cfd6:	8f 93       	push	r24
    cfd8:	8c e1       	ldi	r24, 0x1C	; 28
    cfda:	88 2e       	mov	r8, r24
    cfdc:	8c e0       	ldi	r24, 0x0C	; 12
    cfde:	98 2e       	mov	r9, r24
    cfe0:	9f 92       	push	r9
    cfe2:	8f 92       	push	r8
    cfe4:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    cfe8:	00 91 df 03 	lds	r16, 0x03DF
    cfec:	80 e3       	ldi	r24, 0x30	; 48
    cfee:	80 0f       	add	r24, r16
    cff0:	80 93 28 0c 	sts	0x0C28, r24
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
    cff4:	10 e0       	ldi	r17, 0x00	; 0
    cff6:	c8 01       	movw	r24, r16
    cff8:	88 0f       	add	r24, r24
    cffa:	99 1f       	adc	r25, r25
    cffc:	8e 5d       	subi	r24, 0xDE	; 222
    cffe:	9e 4f       	sbci	r25, 0xFE	; 254
    d000:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
    d004:	48 2e       	mov	r4, r24
    d006:	39 2e       	mov	r3, r25
    d008:	00 0f       	add	r16, r16
    d00a:	11 1f       	adc	r17, r17
    d00c:	00 0f       	add	r16, r16
    d00e:	11 1f       	adc	r17, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d010:	c8 01       	movw	r24, r16
    d012:	83 5d       	subi	r24, 0xD3	; 211
    d014:	9e 4f       	sbci	r25, 0xFE	; 254
    d016:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    d01a:	58 2e       	mov	r5, r24
    d01c:	c8 01       	movw	r24, r16
    d01e:	84 5d       	subi	r24, 0xD4	; 212
    d020:	9e 4f       	sbci	r25, 0xFE	; 254
    d022:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    d026:	68 2e       	mov	r6, r24
    d028:	c8 01       	movw	r24, r16
    d02a:	85 5d       	subi	r24, 0xD5	; 213
    d02c:	9e 4f       	sbci	r25, 0xFE	; 254
    d02e:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    d032:	78 2e       	mov	r7, r24
    d034:	c8 01       	movw	r24, r16
    d036:	86 5d       	subi	r24, 0xD6	; 214
    d038:	9e 4f       	sbci	r25, 0xFE	; 254
    d03a:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
					GSMTxSz = strlen_P(AT_CIPSTART);
					sprintf_P(GSM_TxStr, AT_CIPSTART);
					GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    d03e:	90 91 3c 09 	lds	r25, 0x093C
    d042:	3f 92       	push	r3
    d044:	4f 92       	push	r4
    d046:	1f 92       	push	r1
    d048:	5f 92       	push	r5
    d04a:	1f 92       	push	r1
    d04c:	6f 92       	push	r6
    d04e:	1f 92       	push	r1
    d050:	7f 92       	push	r7
    d052:	1f 92       	push	r1
    d054:	8f 93       	push	r24
    d056:	26 eb       	ldi	r18, 0xB6	; 182
    d058:	31 e0       	ldi	r19, 0x01	; 1
    d05a:	3f 93       	push	r19
    d05c:	2f 93       	push	r18
    d05e:	89 2f       	mov	r24, r25
    d060:	90 e0       	ldi	r25, 0x00	; 0
    d062:	84 5e       	subi	r24, 0xE4	; 228
    d064:	93 4f       	sbci	r25, 0xF3	; 243
    d066:	9f 93       	push	r25
    d068:	8f 93       	push	r24
    d06a:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    d06e:	f4 01       	movw	r30, r8
    d070:	01 90       	ld	r0, Z+
    d072:	00 20       	and	r0, r0
    d074:	e9 f7       	brne	.-6      	; 0xd070 <GSM_Cycle+0x80a>
    d076:	31 97       	sbiw	r30, 0x01	; 1
    d078:	ec 51       	subi	r30, 0x1C	; 28
    d07a:	fc 40       	sbci	r31, 0x0C	; 12
    d07c:	e0 93 3c 09 	sts	0x093C, r30
					GSM_SendFirstChar();
    d080:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d084:	64 ef       	ldi	r22, 0xF4	; 244
    d086:	71 e0       	ldi	r23, 0x01	; 1
    d088:	80 91 52 02 	lds	r24, 0x0252
    d08c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					GSM_State++;
    d090:	80 91 19 06 	lds	r24, 0x0619
    d094:	8f 5f       	subi	r24, 0xFF	; 255
    d096:	80 93 19 06 	sts	0x0619, r24
    d09a:	0f b6       	in	r0, 0x3f	; 63
    d09c:	f8 94       	cli
    d09e:	de bf       	out	0x3e, r29	; 62
    d0a0:	0f be       	out	0x3f, r0	; 63
    d0a2:	cd bf       	out	0x3d, r28	; 61
    d0a4:	fb c7       	rjmp	.+4086   	; 0xe09c <GSM_Cycle+0x1836>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d0a6:	6f e4       	ldi	r22, 0x4F	; 79
    d0a8:	87 e1       	ldi	r24, 0x17	; 23
    d0aa:	90 e5       	ldi	r25, 0x50	; 80
    d0ac:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d0b0:	88 23       	and	r24, r24
    d0b2:	09 f4       	brne	.+2      	; 0xd0b6 <GSM_Cycle+0x850>
    d0b4:	f3 c7       	rjmp	.+4070   	; 0xe09c <GSM_Cycle+0x1836>
    d0b6:	80 91 19 06 	lds	r24, 0x0619
    d0ba:	8f 5f       	subi	r24, 0xFF	; 255
    d0bc:	80 93 19 06 	sts	0x0619, r24
    d0c0:	ed c7       	rjmp	.+4058   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    d0c2:	80 91 52 02 	lds	r24, 0x0252
    d0c6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d0ca:	88 23       	and	r24, r24
    d0cc:	19 f0       	breq	.+6      	; 0xd0d4 <GSM_Cycle+0x86e>
    d0ce:	8f e4       	ldi	r24, 0x4F	; 79
    d0d0:	80 93 19 06 	sts	0x0619, r24
			if(GetStringFromFIFO()){
    d0d4:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    d0d8:	88 23       	and	r24, r24
    d0da:	09 f4       	brne	.+2      	; 0xd0de <GSM_Cycle+0x878>
    d0dc:	df c7       	rjmp	.+4030   	; 0xe09c <GSM_Cycle+0x1836>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    d0de:	69 e0       	ldi	r22, 0x09	; 9
    d0e0:	70 e5       	ldi	r23, 0x50	; 80
    d0e2:	ce 01       	movw	r24, r28
    d0e4:	01 96       	adiw	r24, 0x01	; 1
    d0e6:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    d0ea:	10 91 df 03 	lds	r17, 0x03DF
    d0ee:	80 e3       	ldi	r24, 0x30	; 48
    d0f0:	81 0f       	add	r24, r17
    d0f2:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    d0f4:	6f e4       	ldi	r22, 0x4F	; 79
    d0f6:	ce 01       	movw	r24, r28
    d0f8:	01 96       	adiw	r24, 0x01	; 1
    d0fa:	0e 94 61 3b 	call	0x76c2	; 0x76c2 <GSM_Wait_Response>
    d0fe:	88 23       	and	r24, r24
    d100:	09 f4       	brne	.+2      	; 0xd104 <GSM_Cycle+0x89e>
    d102:	cc c7       	rjmp	.+3992   	; 0xe09c <GSM_Cycle+0x1836>
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    d104:	1f 5f       	subi	r17, 0xFF	; 255
    d106:	10 93 df 03 	sts	0x03DF, r17
    d10a:	14 30       	cpi	r17, 0x04	; 4
    d10c:	20 f0       	brcs	.+8      	; 0xd116 <GSM_Cycle+0x8b0>
    d10e:	88 e2       	ldi	r24, 0x28	; 40
    d110:	80 93 19 06 	sts	0x0619, r24
    d114:	c3 c7       	rjmp	.+3974   	; 0xe09c <GSM_Cycle+0x1836>
					else GSM_State = GSM_SEND_CIPSTART;
    d116:	82 e2       	ldi	r24, 0x22	; 34
    d118:	80 93 19 06 	sts	0x0619, r24
    d11c:	bf c7       	rjmp	.+3966   	; 0xe09c <GSM_Cycle+0x1836>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    d11e:	80 91 08 01 	lds	r24, 0x0108
    d122:	80 ff       	sbrs	r24, 0
    d124:	bb c7       	rjmp	.+3958   	; 0xe09c <GSM_Cycle+0x1836>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    d126:	8f e0       	ldi	r24, 0x0F	; 15
    d128:	80 93 3c 09 	sts	0x093C, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    d12c:	8d ec       	ldi	r24, 0xCD	; 205
    d12e:	9e e4       	ldi	r25, 0x4E	; 78
    d130:	9f 93       	push	r25
    d132:	8f 93       	push	r24
    d134:	0c e1       	ldi	r16, 0x1C	; 28
    d136:	1c e0       	ldi	r17, 0x0C	; 12
    d138:	1f 93       	push	r17
    d13a:	0f 93       	push	r16
    d13c:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d140:	80 e2       	ldi	r24, 0x20	; 32
    d142:	91 e0       	ldi	r25, 0x01	; 1
    d144:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    d148:	40 91 3c 09 	lds	r20, 0x093C
    d14c:	9f 93       	push	r25
    d14e:	8f 93       	push	r24
    d150:	2d ec       	ldi	r18, 0xCD	; 205
    d152:	31 e0       	ldi	r19, 0x01	; 1
    d154:	3f 93       	push	r19
    d156:	2f 93       	push	r18
    d158:	84 2f       	mov	r24, r20
    d15a:	90 e0       	ldi	r25, 0x00	; 0
    d15c:	84 5e       	subi	r24, 0xE4	; 228
    d15e:	93 4f       	sbci	r25, 0xF3	; 243
    d160:	9f 93       	push	r25
    d162:	8f 93       	push	r24
    d164:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    d168:	f8 01       	movw	r30, r16
    d16a:	01 90       	ld	r0, Z+
    d16c:	00 20       	and	r0, r0
    d16e:	e9 f7       	brne	.-6      	; 0xd16a <GSM_Cycle+0x904>
    d170:	31 97       	sbiw	r30, 0x01	; 1
    d172:	ec 51       	subi	r30, 0x1C	; 28
    d174:	fc 40       	sbci	r31, 0x0C	; 12
    d176:	e0 93 3c 09 	sts	0x093C, r30
				GSM_SendFirstChar();
    d17a:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d17e:	64 ef       	ldi	r22, 0xF4	; 244
    d180:	71 e0       	ldi	r23, 0x01	; 1
    d182:	80 91 52 02 	lds	r24, 0x0252
    d186:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State++;
    d18a:	80 91 19 06 	lds	r24, 0x0619
    d18e:	8f 5f       	subi	r24, 0xFF	; 255
    d190:	80 93 19 06 	sts	0x0619, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    d194:	6f ef       	ldi	r22, 0xFF	; 255
    d196:	7f ef       	ldi	r23, 0xFF	; 255
    d198:	80 91 51 02 	lds	r24, 0x0251
    d19c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    d1a0:	0f b6       	in	r0, 0x3f	; 63
    d1a2:	f8 94       	cli
    d1a4:	de bf       	out	0x3e, r29	; 62
    d1a6:	0f be       	out	0x3f, r0	; 63
    d1a8:	cd bf       	out	0x3d, r28	; 61
    d1aa:	78 c7       	rjmp	.+3824   	; 0xe09c <GSM_Cycle+0x1836>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    d1ac:	6f e4       	ldi	r22, 0x4F	; 79
    d1ae:	87 e1       	ldi	r24, 0x17	; 23
    d1b0:	90 e5       	ldi	r25, 0x50	; 80
    d1b2:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d1b6:	88 23       	and	r24, r24
    d1b8:	09 f4       	brne	.+2      	; 0xd1bc <GSM_Cycle+0x956>
    d1ba:	70 c7       	rjmp	.+3808   	; 0xe09c <GSM_Cycle+0x1836>
    d1bc:	80 91 19 06 	lds	r24, 0x0619
    d1c0:	8f 5f       	subi	r24, 0xFF	; 255
    d1c2:	80 93 19 06 	sts	0x0619, r24
    d1c6:	6a c7       	rjmp	.+3796   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    d1c8:	6f e4       	ldi	r22, 0x4F	; 79
    d1ca:	8f ef       	ldi	r24, 0xFF	; 255
    d1cc:	9f e4       	ldi	r25, 0x4F	; 79
    d1ce:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d1d2:	88 23       	and	r24, r24
    d1d4:	09 f4       	brne	.+2      	; 0xd1d8 <GSM_Cycle+0x972>
    d1d6:	62 c7       	rjmp	.+3780   	; 0xe09c <GSM_Cycle+0x1836>
    d1d8:	88 e2       	ldi	r24, 0x28	; 40
    d1da:	80 93 19 06 	sts	0x0619, r24
    d1de:	5e c7       	rjmp	.+3772   	; 0xe09c <GSM_Cycle+0x1836>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    d1e0:	80 91 62 09 	lds	r24, 0x0962
    d1e4:	81 11       	cpse	r24, r1
    d1e6:	3c c0       	rjmp	.+120    	; 0xd260 <GSM_Cycle+0x9fa>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    d1e8:	80 91 29 09 	lds	r24, 0x0929
    d1ec:	88 23       	and	r24, r24
    d1ee:	41 f1       	breq	.+80     	; 0xd240 <GSM_Cycle+0x9da>
					if(GSM_MultiCon == 1){
    d1f0:	80 91 2d 0e 	lds	r24, 0x0E2D
    d1f4:	81 30       	cpi	r24, 0x01	; 1
    d1f6:	e9 f4       	brne	.+58     	; 0xd232 <GSM_Cycle+0x9cc>
						if(GPRS_Protocol_Out == UDP){
    d1f8:	80 91 60 09 	lds	r24, 0x0960
    d1fc:	81 11       	cpse	r24, r1
    d1fe:	09 c0       	rjmp	.+18     	; 0xd212 <GSM_Cycle+0x9ac>
							TempNum = 0;
    d200:	10 92 df 03 	sts	0x03DF, r1
							GSM_State = GSM_SEND_CIPSEND;
    d204:	8a e2       	ldi	r24, 0x2A	; 42
    d206:	80 93 19 06 	sts	0x0619, r24
							ResetTimer16(TD_GSM);
    d20a:	80 91 52 02 	lds	r24, 0x0252
    d20e:	0e 94 07 2d 	call	0x5a0e	; 0x5a0e <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    d212:	80 91 60 09 	lds	r24, 0x0960
    d216:	81 30       	cpi	r24, 0x01	; 1
    d218:	09 f0       	breq	.+2      	; 0xd21c <GSM_Cycle+0x9b6>
    d21a:	40 c7       	rjmp	.+3712   	; 0xe09c <GSM_Cycle+0x1836>
							if(GSM_ActiveConnection == NO_CONNECTION){
    d21c:	80 91 07 01 	lds	r24, 0x0107
    d220:	8f 3f       	cpi	r24, 0xFF	; 255
    d222:	19 f4       	brne	.+6      	; 0xd22a <GSM_Cycle+0x9c4>
								GPRS_FlgSz_Out = 0;
    d224:	10 92 29 09 	sts	0x0929, r1
    d228:	39 c7       	rjmp	.+3698   	; 0xe09c <GSM_Cycle+0x1836>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    d22a:	8a e2       	ldi	r24, 0x2A	; 42
    d22c:	80 93 19 06 	sts	0x0619, r24
    d230:	35 c7       	rjmp	.+3690   	; 0xe09c <GSM_Cycle+0x1836>
						}
					}
					else{
						GSM_MultiCon = 1;
    d232:	81 e0       	ldi	r24, 0x01	; 1
    d234:	80 93 2d 0e 	sts	0x0E2D, r24
						GSM_State = GSM_CIPSHUT;
    d238:	87 e4       	ldi	r24, 0x47	; 71
    d23a:	80 93 19 06 	sts	0x0619, r24
    d23e:	2e c7       	rjmp	.+3676   	; 0xe09c <GSM_Cycle+0x1836>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    d240:	80 91 4b 09 	lds	r24, 0x094B
    d244:	88 23       	and	r24, r24
    d246:	61 f0       	breq	.+24     	; 0xd260 <GSM_Cycle+0x9fa>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d248:	80 e6       	ldi	r24, 0x60	; 96
    d24a:	90 e0       	ldi	r25, 0x00	; 0
    d24c:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    d250:	88 23       	and	r24, r24
    d252:	31 f0       	breq	.+12     	; 0xd260 <GSM_Cycle+0x9fa>
					GSM_State = GSM_SEND_CMGS;
    d254:	8f e2       	ldi	r24, 0x2F	; 47
    d256:	80 93 19 06 	sts	0x0619, r24
					TempNum = 0;
    d25a:	10 92 df 03 	sts	0x03DF, r1
    d25e:	1e c7       	rjmp	.+3644   	; 0xe09c <GSM_Cycle+0x1836>
					break;
				}
			}

			if(GetStringFromFIFO()){
    d260:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    d264:	88 23       	and	r24, r24
    d266:	31 f0       	breq	.+12     	; 0xd274 <GSM_Cycle+0xa0e>
				GSM_State = GSM_AnalyzeURC;
    d268:	89 e2       	ldi	r24, 0x29	; 41
    d26a:	80 93 19 06 	sts	0x0619, r24
				TempNum = 0;
    d26e:	10 92 df 03 	sts	0x03DF, r1
    d272:	14 c7       	rjmp	.+3624   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			if(!IsWebSession()){
    d274:	80 91 62 09 	lds	r24, 0x0962
    d278:	81 11       	cpse	r24, r1
    d27a:	10 c7       	rjmp	.+3616   	; 0xe09c <GSM_Cycle+0x1836>
				if(Timer16Stopp(TD_TCP_Connect) ){
    d27c:	80 91 51 02 	lds	r24, 0x0251
    d280:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d284:	88 23       	and	r24, r24
    d286:	21 f0       	breq	.+8      	; 0xd290 <GSM_Cycle+0xa2a>
					GSM_State = GSM_CIPSHUT;
    d288:	87 e4       	ldi	r24, 0x47	; 71
    d28a:	80 93 19 06 	sts	0x0619, r24
    d28e:	06 c7       	rjmp	.+3596   	; 0xe09c <GSM_Cycle+0x1836>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    d290:	80 91 50 02 	lds	r24, 0x0250
    d294:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d298:	88 23       	and	r24, r24
    d29a:	21 f0       	breq	.+8      	; 0xd2a4 <GSM_Cycle+0xa3e>
					GSM_State = GSM_SEND_CSQ;
    d29c:	84 e5       	ldi	r24, 0x54	; 84
    d29e:	80 93 19 06 	sts	0x0619, r24
    d2a2:	fc c6       	rjmp	.+3576   	; 0xe09c <GSM_Cycle+0x1836>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    d2a4:	80 91 4f 02 	lds	r24, 0x024F
    d2a8:	0e 94 dc 2c 	call	0x59b8	; 0x59b8 <Timer32Stopp>
    d2ac:	88 23       	and	r24, r24
    d2ae:	09 f4       	brne	.+2      	; 0xd2b2 <GSM_Cycle+0xa4c>
    d2b0:	f5 c6       	rjmp	.+3562   	; 0xe09c <GSM_Cycle+0x1836>
					GSM_State = GSM_ReStart1;
    d2b2:	8f e4       	ldi	r24, 0x4F	; 79
    d2b4:	80 93 19 06 	sts	0x0619, r24
    d2b8:	f1 c6       	rjmp	.+3554   	; 0xe09c <GSM_Cycle+0x1836>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    d2ba:	60 e5       	ldi	r22, 0x50	; 80
    d2bc:	70 e5       	ldi	r23, 0x50	; 80
    d2be:	8d e6       	ldi	r24, 0x6D	; 109
    d2c0:	99 e0       	ldi	r25, 0x09	; 9
    d2c2:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d2c6:	89 2b       	or	r24, r25
    d2c8:	21 f0       	breq	.+8      	; 0xd2d2 <GSM_Cycle+0xa6c>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    d2ca:	83 e3       	ldi	r24, 0x33	; 51
    d2cc:	80 93 19 06 	sts	0x0619, r24
    d2d0:	e5 c6       	rjmp	.+3530   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    d2d2:	68 e4       	ldi	r22, 0x48	; 72
    d2d4:	70 e5       	ldi	r23, 0x50	; 80
    d2d6:	8d e6       	ldi	r24, 0x6D	; 109
    d2d8:	99 e0       	ldi	r25, 0x09	; 9
    d2da:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d2de:	89 2b       	or	r24, r25
    d2e0:	61 f0       	breq	.+24     	; 0xd2fa <GSM_Cycle+0xa94>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    d2e2:	68 ee       	ldi	r22, 0xE8	; 232
    d2e4:	73 e0       	ldi	r23, 0x03	; 3
    d2e6:	80 91 51 02 	lds	r24, 0x0251
    d2ea:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_CSD = 0;
    d2ee:	10 92 31 09 	sts	0x0931, r1
				GSM_State = GSM_ProtocolMode;
    d2f2:	86 e5       	ldi	r24, 0x56	; 86
    d2f4:	80 93 19 06 	sts	0x0619, r24
    d2f8:	d1 c6       	rjmp	.+3490   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    d2fa:	65 e2       	ldi	r22, 0x25	; 37
    d2fc:	70 e5       	ldi	r23, 0x50	; 80
    d2fe:	8d e6       	ldi	r24, 0x6D	; 109
    d300:	99 e0       	ldi	r25, 0x09	; 9
    d302:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d306:	89 2b       	or	r24, r25
    d308:	51 f0       	breq	.+20     	; 0xd31e <GSM_Cycle+0xab8>
				StartTimer16(TD_GSM, 150);
    d30a:	66 e9       	ldi	r22, 0x96	; 150
    d30c:	70 e0       	ldi	r23, 0x00	; 0
    d30e:	80 91 52 02 	lds	r24, 0x0252
    d312:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    d316:	8b e5       	ldi	r24, 0x5B	; 91
    d318:	80 93 19 06 	sts	0x0619, r24
    d31c:	bf c6       	rjmp	.+3454   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    d31e:	65 e3       	ldi	r22, 0x35	; 53
    d320:	70 e5       	ldi	r23, 0x50	; 80
    d322:	8d e6       	ldi	r24, 0x6D	; 109
    d324:	99 e0       	ldi	r25, 0x09	; 9
    d326:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d32a:	89 2b       	or	r24, r25
    d32c:	49 f1       	breq	.+82     	; 0xd380 <GSM_Cycle+0xb1a>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    d32e:	8f ed       	ldi	r24, 0xDF	; 223
    d330:	93 e0       	ldi	r25, 0x03	; 3
    d332:	9f 93       	push	r25
    d334:	8f 93       	push	r24
    d336:	89 e8       	ldi	r24, 0x89	; 137
    d338:	93 e0       	ldi	r25, 0x03	; 3
    d33a:	9f 93       	push	r25
    d33c:	8f 93       	push	r24
    d33e:	8d e6       	ldi	r24, 0x6D	; 109
    d340:	99 e0       	ldi	r25, 0x09	; 9
    d342:	9f 93       	push	r25
    d344:	8f 93       	push	r24
    d346:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    d34a:	0f 90       	pop	r0
    d34c:	0f 90       	pop	r0
    d34e:	0f 90       	pop	r0
    d350:	0f 90       	pop	r0
    d352:	0f 90       	pop	r0
    d354:	0f 90       	pop	r0
    d356:	90 91 07 01 	lds	r25, 0x0107
    d35a:	80 91 df 03 	lds	r24, 0x03DF
    d35e:	98 13       	cpse	r25, r24
    d360:	0b c0       	rjmp	.+22     	; 0xd378 <GSM_Cycle+0xb12>
					GSM_ActiveConnection = NO_CONNECTION;
    d362:	8f ef       	ldi	r24, 0xFF	; 255
    d364:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    d368:	10 92 1d 0d 	sts	0x0D1D, r1
	IP->IP2 = IP2;
    d36c:	10 92 1e 0d 	sts	0x0D1E, r1
	IP->IP3 = IP3;
    d370:	10 92 1f 0d 	sts	0x0D1F, r1
	IP->IP4 = IP4;
    d374:	10 92 20 0d 	sts	0x0D20, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    d378:	88 e2       	ldi	r24, 0x28	; 40
    d37a:	80 93 19 06 	sts	0x0619, r24
    d37e:	8e c6       	rjmp	.+3356   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    d380:	6a e2       	ldi	r22, 0x2A	; 42
    d382:	70 e5       	ldi	r23, 0x50	; 80
    d384:	8d e6       	ldi	r24, 0x6D	; 109
    d386:	99 e0       	ldi	r25, 0x09	; 9
    d388:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d38c:	89 2b       	or	r24, r25
    d38e:	21 f0       	breq	.+8      	; 0xd398 <GSM_Cycle+0xb32>
				GSM_State = GSM_SEND_E0;
    d390:	88 e0       	ldi	r24, 0x08	; 8
    d392:	80 93 19 06 	sts	0x0619, r24
    d396:	82 c6       	rjmp	.+3332   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    d398:	6e e3       	ldi	r22, 0x3E	; 62
    d39a:	70 e5       	ldi	r23, 0x50	; 80
    d39c:	8d e6       	ldi	r24, 0x6D	; 109
    d39e:	99 e0       	ldi	r25, 0x09	; 9
    d3a0:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d3a4:	89 2b       	or	r24, r25
    d3a6:	41 f0       	breq	.+16     	; 0xd3b8 <GSM_Cycle+0xb52>
    d3a8:	80 91 42 09 	lds	r24, 0x0942
    d3ac:	81 11       	cpse	r24, r1
    d3ae:	04 c0       	rjmp	.+8      	; 0xd3b8 <GSM_Cycle+0xb52>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    d3b0:	86 e3       	ldi	r24, 0x36	; 54
    d3b2:	80 93 19 06 	sts	0x0619, r24
    d3b6:	72 c6       	rjmp	.+3300   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    d3b8:	6c ec       	ldi	r22, 0xCC	; 204
    d3ba:	7f e4       	ldi	r23, 0x4F	; 79
    d3bc:	8d e6       	ldi	r24, 0x6D	; 109
    d3be:	99 e0       	ldi	r25, 0x09	; 9
    d3c0:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    d3c4:	89 2b       	or	r24, r25
    d3c6:	21 f0       	breq	.+8      	; 0xd3d0 <GSM_Cycle+0xb6a>
				GSM_State = GSM_WAIT_CSQ;
    d3c8:	85 e5       	ldi	r24, 0x55	; 85
    d3ca:	80 93 19 06 	sts	0x0619, r24
    d3ce:	66 c6       	rjmp	.+3276   	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    d3d0:	88 e2       	ldi	r24, 0x28	; 40
    d3d2:	80 93 19 06 	sts	0x0619, r24
    d3d6:	62 c6       	rjmp	.+3268   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    d3d8:	80 91 60 09 	lds	r24, 0x0960
    d3dc:	81 11       	cpse	r24, r1
    d3de:	74 c0       	rjmp	.+232    	; 0xd4c8 <GSM_Cycle+0xc62>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    d3e0:	10 91 df 03 	lds	r17, 0x03DF
    d3e4:	e4 e0       	ldi	r30, 0x04	; 4
    d3e6:	1e 9f       	mul	r17, r30
    d3e8:	c0 01       	movw	r24, r0
    d3ea:	11 24       	eor	r1, r1
    d3ec:	00 e0       	ldi	r16, 0x00	; 0
    d3ee:	20 e0       	ldi	r18, 0x00	; 0
    d3f0:	40 e0       	ldi	r20, 0x00	; 0
    d3f2:	60 e0       	ldi	r22, 0x00	; 0
    d3f4:	86 5d       	subi	r24, 0xD6	; 214
    d3f6:	9e 4f       	sbci	r25, 0xFE	; 254
    d3f8:	0e 94 1f 3a 	call	0x743e	; 0x743e <IP_E_compare_Const>
    d3fc:	81 11       	cpse	r24, r1
    d3fe:	0b c0       	rjmp	.+22     	; 0xd416 <GSM_Cycle+0xbb0>
    d400:	80 91 61 08 	lds	r24, 0x0861
    d404:	90 e0       	ldi	r25, 0x00	; 0
    d406:	01 2e       	mov	r0, r17
    d408:	02 c0       	rjmp	.+4      	; 0xd40e <GSM_Cycle+0xba8>
    d40a:	95 95       	asr	r25
    d40c:	87 95       	ror	r24
    d40e:	0a 94       	dec	r0
    d410:	e2 f7       	brpl	.-8      	; 0xd40a <GSM_Cycle+0xba4>
    d412:	80 ff       	sbrs	r24, 0
    d414:	12 c0       	rjmp	.+36     	; 0xd43a <GSM_Cycle+0xbd4>
					TempNum++;
    d416:	1f 5f       	subi	r17, 0xFF	; 255
    d418:	10 93 df 03 	sts	0x03DF, r17
					if(TempNum>3){
    d41c:	14 30       	cpi	r17, 0x04	; 4
    d41e:	08 f4       	brcc	.+2      	; 0xd422 <GSM_Cycle+0xbbc>
    d420:	53 c0       	rjmp	.+166    	; 0xd4c8 <GSM_Cycle+0xc62>
						StartTimer16(TD_GSM,150);
    d422:	66 e9       	ldi	r22, 0x96	; 150
    d424:	70 e0       	ldi	r23, 0x00	; 0
    d426:	80 91 52 02 	lds	r24, 0x0252
    d42a:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    d42e:	8e e2       	ldi	r24, 0x2E	; 46
    d430:	80 93 19 06 	sts	0x0619, r24
						GPRS_FlgSz_Out = 0;
    d434:	10 92 29 09 	sts	0x0929, r1
    d438:	47 c0       	rjmp	.+142    	; 0xd4c8 <GSM_Cycle+0xc62>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    d43a:	80 91 08 01 	lds	r24, 0x0108
    d43e:	80 ff       	sbrs	r24, 0
    d440:	43 c0       	rjmp	.+134    	; 0xd4c8 <GSM_Cycle+0xc62>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    d442:	80 91 52 02 	lds	r24, 0x0252
    d446:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d44a:	88 23       	and	r24, r24
    d44c:	e9 f1       	breq	.+122    	; 0xd4c8 <GSM_Cycle+0xc62>
							GSMTxSz = strlen_P(AT_CIPSEND);
    d44e:	8b e0       	ldi	r24, 0x0B	; 11
    d450:	80 93 3c 09 	sts	0x093C, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    d454:	82 eb       	ldi	r24, 0xB2	; 178
    d456:	9e e4       	ldi	r25, 0x4E	; 78
    d458:	9f 93       	push	r25
    d45a:	8f 93       	push	r24
    d45c:	0c e1       	ldi	r16, 0x1C	; 28
    d45e:	1c e0       	ldi	r17, 0x0C	; 12
    d460:	1f 93       	push	r17
    d462:	0f 93       	push	r16
    d464:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    d468:	80 91 3c 09 	lds	r24, 0x093C
    d46c:	90 91 29 09 	lds	r25, 0x0929
    d470:	1f 92       	push	r1
    d472:	9f 93       	push	r25
    d474:	90 91 df 03 	lds	r25, 0x03DF
    d478:	1f 92       	push	r1
    d47a:	9f 93       	push	r25
    d47c:	2a ec       	ldi	r18, 0xCA	; 202
    d47e:	31 e0       	ldi	r19, 0x01	; 1
    d480:	3f 93       	push	r19
    d482:	2f 93       	push	r18
    d484:	90 e0       	ldi	r25, 0x00	; 0
    d486:	84 5e       	subi	r24, 0xE4	; 228
    d488:	93 4f       	sbci	r25, 0xF3	; 243
    d48a:	9f 93       	push	r25
    d48c:	8f 93       	push	r24
    d48e:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    d492:	f8 01       	movw	r30, r16
    d494:	01 90       	ld	r0, Z+
    d496:	00 20       	and	r0, r0
    d498:	e9 f7       	brne	.-6      	; 0xd494 <GSM_Cycle+0xc2e>
    d49a:	31 97       	sbiw	r30, 0x01	; 1
    d49c:	ec 51       	subi	r30, 0x1C	; 28
    d49e:	fc 40       	sbci	r31, 0x0C	; 12
    d4a0:	e0 93 3c 09 	sts	0x093C, r30
							GSM_SendFirstChar();
    d4a4:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d4a8:	64 ef       	ldi	r22, 0xF4	; 244
    d4aa:	71 e0       	ldi	r23, 0x01	; 1
    d4ac:	80 91 52 02 	lds	r24, 0x0252
    d4b0:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
							GSM_State++;
    d4b4:	80 91 19 06 	lds	r24, 0x0619
    d4b8:	8f 5f       	subi	r24, 0xFF	; 255
    d4ba:	80 93 19 06 	sts	0x0619, r24
    d4be:	0f b6       	in	r0, 0x3f	; 63
    d4c0:	f8 94       	cli
    d4c2:	de bf       	out	0x3e, r29	; 62
    d4c4:	0f be       	out	0x3f, r0	; 63
    d4c6:	cd bf       	out	0x3d, r28	; 61
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    d4c8:	80 91 60 09 	lds	r24, 0x0960
    d4cc:	81 30       	cpi	r24, 0x01	; 1
    d4ce:	09 f0       	breq	.+2      	; 0xd4d2 <GSM_Cycle+0xc6c>
    d4d0:	e5 c5       	rjmp	.+3018   	; 0xe09c <GSM_Cycle+0x1836>
				if(GSM_Flag & (1<<flg_TxCStr)){
    d4d2:	80 91 08 01 	lds	r24, 0x0108
    d4d6:	80 ff       	sbrs	r24, 0
    d4d8:	e1 c5       	rjmp	.+3010   	; 0xe09c <GSM_Cycle+0x1836>
					GSMTxSz = strlen_P(AT_CIPSEND);
    d4da:	8b e0       	ldi	r24, 0x0B	; 11
    d4dc:	80 93 3c 09 	sts	0x093C, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    d4e0:	82 eb       	ldi	r24, 0xB2	; 178
    d4e2:	9e e4       	ldi	r25, 0x4E	; 78
    d4e4:	9f 93       	push	r25
    d4e6:	8f 93       	push	r24
    d4e8:	0c e1       	ldi	r16, 0x1C	; 28
    d4ea:	1c e0       	ldi	r17, 0x0C	; 12
    d4ec:	1f 93       	push	r17
    d4ee:	0f 93       	push	r16
    d4f0:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    d4f4:	80 91 3c 09 	lds	r24, 0x093C
    d4f8:	90 91 29 09 	lds	r25, 0x0929
    d4fc:	1f 92       	push	r1
    d4fe:	9f 93       	push	r25
    d500:	90 91 07 01 	lds	r25, 0x0107
    d504:	1f 92       	push	r1
    d506:	9f 93       	push	r25
    d508:	2a ec       	ldi	r18, 0xCA	; 202
    d50a:	31 e0       	ldi	r19, 0x01	; 1
    d50c:	3f 93       	push	r19
    d50e:	2f 93       	push	r18
    d510:	90 e0       	ldi	r25, 0x00	; 0
    d512:	84 5e       	subi	r24, 0xE4	; 228
    d514:	93 4f       	sbci	r25, 0xF3	; 243
    d516:	9f 93       	push	r25
    d518:	8f 93       	push	r24
    d51a:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    d51e:	f8 01       	movw	r30, r16
    d520:	01 90       	ld	r0, Z+
    d522:	00 20       	and	r0, r0
    d524:	e9 f7       	brne	.-6      	; 0xd520 <GSM_Cycle+0xcba>
    d526:	31 97       	sbiw	r30, 0x01	; 1
    d528:	ec 51       	subi	r30, 0x1C	; 28
    d52a:	fc 40       	sbci	r31, 0x0C	; 12
    d52c:	e0 93 3c 09 	sts	0x093C, r30
					GSM_SendFirstChar();
    d530:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d534:	64 ef       	ldi	r22, 0xF4	; 244
    d536:	71 e0       	ldi	r23, 0x01	; 1
    d538:	80 91 52 02 	lds	r24, 0x0252
    d53c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					GSM_State++;
    d540:	80 91 19 06 	lds	r24, 0x0619
    d544:	8f 5f       	subi	r24, 0xFF	; 255
    d546:	80 93 19 06 	sts	0x0619, r24
    d54a:	0f b6       	in	r0, 0x3f	; 63
    d54c:	f8 94       	cli
    d54e:	de bf       	out	0x3e, r29	; 62
    d550:	0f be       	out	0x3f, r0	; 63
    d552:	cd bf       	out	0x3d, r28	; 61
    d554:	a3 c5       	rjmp	.+2886   	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    d556:	68 e2       	ldi	r22, 0x28	; 40
    d558:	8e e3       	ldi	r24, 0x3E	; 62
    d55a:	0e 94 95 3b 	call	0x772a	; 0x772a <GSM_Wait_Char>
    d55e:	88 23       	and	r24, r24
    d560:	29 f0       	breq	.+10     	; 0xd56c <GSM_Cycle+0xd06>
    d562:	80 91 19 06 	lds	r24, 0x0619
    d566:	8f 5f       	subi	r24, 0xFF	; 255
    d568:	80 93 19 06 	sts	0x0619, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    d56c:	80 91 19 06 	lds	r24, 0x0619
    d570:	88 32       	cpi	r24, 0x28	; 40
    d572:	09 f0       	breq	.+2      	; 0xd576 <GSM_Cycle+0xd10>
    d574:	93 c5       	rjmp	.+2854   	; 0xe09c <GSM_Cycle+0x1836>
    d576:	10 92 29 09 	sts	0x0929, r1
    d57a:	90 c5       	rjmp	.+2848   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    d57c:	60 91 29 09 	lds	r22, 0x0929
    d580:	8c e1       	ldi	r24, 0x1C	; 28
    d582:	9b e0       	ldi	r25, 0x0B	; 11
    d584:	0e 94 1b 64 	call	0xc836	; 0xc836 <GSM_AddHeaderSendData>
			GSM_State++;
    d588:	80 91 19 06 	lds	r24, 0x0619
    d58c:	8f 5f       	subi	r24, 0xFF	; 255
    d58e:	80 93 19 06 	sts	0x0619, r24
    d592:	84 c5       	rjmp	.+2824   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    d594:	80 91 52 02 	lds	r24, 0x0252
    d598:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d59c:	88 23       	and	r24, r24
    d59e:	29 f0       	breq	.+10     	; 0xd5aa <GSM_Cycle+0xd44>
				GSM_State = GSM_ServerIdle;
    d5a0:	88 e2       	ldi	r24, 0x28	; 40
    d5a2:	80 93 19 06 	sts	0x0619, r24
				GPRS_FlgSz_Out = 0;
    d5a6:	10 92 29 09 	sts	0x0929, r1
			}

			if(GetStringFromFIFO()){
    d5aa:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    d5ae:	88 23       	and	r24, r24
    d5b0:	09 f4       	brne	.+2      	; 0xd5b4 <GSM_Cycle+0xd4e>
    d5b2:	74 c5       	rjmp	.+2792   	; 0xe09c <GSM_Cycle+0x1836>
				if(GPRS_Protocol_Out == UDP){
    d5b4:	80 91 60 09 	lds	r24, 0x0960
    d5b8:	81 11       	cpse	r24, r1
    d5ba:	27 c0       	rjmp	.+78     	; 0xd60a <GSM_Cycle+0xda4>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    d5bc:	67 ee       	ldi	r22, 0xE7	; 231
    d5be:	7f e4       	ldi	r23, 0x4F	; 79
    d5c0:	ce 01       	movw	r24, r28
    d5c2:	01 96       	adiw	r24, 0x01	; 1
    d5c4:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    d5c8:	80 91 df 03 	lds	r24, 0x03DF
    d5cc:	80 5d       	subi	r24, 0xD0	; 208
    d5ce:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    d5d0:	6f e4       	ldi	r22, 0x4F	; 79
    d5d2:	ce 01       	movw	r24, r28
    d5d4:	01 96       	adiw	r24, 0x01	; 1
    d5d6:	0e 94 61 3b 	call	0x76c2	; 0x76c2 <GSM_Wait_Response>
    d5da:	88 23       	and	r24, r24
    d5dc:	b1 f0       	breq	.+44     	; 0xd60a <GSM_Cycle+0xda4>
						StartTimer16(TD_GSM,500);//min~ 2 sec
    d5de:	64 ef       	ldi	r22, 0xF4	; 244
    d5e0:	71 e0       	ldi	r23, 0x01	; 1
    d5e2:	80 91 52 02 	lds	r24, 0x0252
    d5e6:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						if(++TempNum>3){
    d5ea:	80 91 df 03 	lds	r24, 0x03DF
    d5ee:	8f 5f       	subi	r24, 0xFF	; 255
    d5f0:	80 93 df 03 	sts	0x03DF, r24
    d5f4:	84 30       	cpi	r24, 0x04	; 4
    d5f6:	30 f0       	brcs	.+12     	; 0xd604 <GSM_Cycle+0xd9e>
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    d5f8:	8e e2       	ldi	r24, 0x2E	; 46
    d5fa:	80 93 19 06 	sts	0x0619, r24
							GPRS_FlgSz_Out = 0;
    d5fe:	10 92 29 09 	sts	0x0929, r1
    d602:	03 c0       	rjmp	.+6      	; 0xd60a <GSM_Cycle+0xda4>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    d604:	8a e2       	ldi	r24, 0x2A	; 42
    d606:	80 93 19 06 	sts	0x0619, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    d60a:	80 91 60 09 	lds	r24, 0x0960
    d60e:	81 30       	cpi	r24, 0x01	; 1
    d610:	09 f0       	breq	.+2      	; 0xd614 <GSM_Cycle+0xdae>
    d612:	44 c5       	rjmp	.+2696   	; 0xe09c <GSM_Cycle+0x1836>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    d614:	67 ee       	ldi	r22, 0xE7	; 231
    d616:	7f e4       	ldi	r23, 0x4F	; 79
    d618:	ce 01       	movw	r24, r28
    d61a:	01 96       	adiw	r24, 0x01	; 1
    d61c:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    d620:	80 91 07 01 	lds	r24, 0x0107
    d624:	80 5d       	subi	r24, 0xD0	; 208
    d626:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    d628:	6f e4       	ldi	r22, 0x4F	; 79
    d62a:	ce 01       	movw	r24, r28
    d62c:	01 96       	adiw	r24, 0x01	; 1
    d62e:	0e 94 61 3b 	call	0x76c2	; 0x76c2 <GSM_Wait_Response>
    d632:	88 23       	and	r24, r24
    d634:	09 f4       	brne	.+2      	; 0xd638 <GSM_Cycle+0xdd2>
    d636:	32 c5       	rjmp	.+2660   	; 0xe09c <GSM_Cycle+0x1836>
						GPRS_FlgSz_Out = 0;
    d638:	10 92 29 09 	sts	0x0929, r1
    d63c:	2f c5       	rjmp	.+2654   	; 0xe09c <GSM_Cycle+0x1836>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    d63e:	80 91 52 02 	lds	r24, 0x0252
    d642:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d646:	88 23       	and	r24, r24
    d648:	09 f4       	brne	.+2      	; 0xd64c <GSM_Cycle+0xde6>
    d64a:	28 c5       	rjmp	.+2640   	; 0xe09c <GSM_Cycle+0x1836>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    d64c:	10 92 2d 0e 	sts	0x0E2D, r1
				if(sendsWithoutReconnect<3)
    d650:	80 91 53 02 	lds	r24, 0x0253
    d654:	83 30       	cpi	r24, 0x03	; 3
    d656:	10 f4       	brcc	.+4      	; 0xd65c <GSM_Cycle+0xdf6>
				{
					GSM_State = GSM_CIPSHUT;
    d658:	87 e4       	ldi	r24, 0x47	; 71
    d65a:	03 c0       	rjmp	.+6      	; 0xd662 <GSM_Cycle+0xdfc>
				}
				else{
					sendsWithoutReconnect=0;
    d65c:	10 92 53 02 	sts	0x0253, r1
					GSM_State = GSM_CIPSHUT_;
    d660:	89 e4       	ldi	r24, 0x49	; 73
    d662:	80 93 19 06 	sts	0x0619, r24
				}
				sendsWithoutReconnect++;
    d666:	80 91 53 02 	lds	r24, 0x0253
    d66a:	8f 5f       	subi	r24, 0xFF	; 255
    d66c:	80 93 53 02 	sts	0x0253, r24
    d670:	15 c5       	rjmp	.+2602   	; 0xe09c <GSM_Cycle+0x1836>

			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d672:	68 ee       	ldi	r22, 0xE8	; 232
    d674:	73 e0       	ldi	r23, 0x03	; 3
    d676:	89 e8       	ldi	r24, 0x89	; 137
    d678:	9e e4       	ldi	r25, 0x4E	; 78
    d67a:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    d67e:	80 91 19 06 	lds	r24, 0x0619
    d682:	8f 5f       	subi	r24, 0xFF	; 255
    d684:	80 93 19 06 	sts	0x0619, r24
    d688:	09 c5       	rjmp	.+2578   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    d68a:	6f e4       	ldi	r22, 0x4F	; 79
    d68c:	84 ec       	ldi	r24, 0xC4	; 196
    d68e:	9f e4       	ldi	r25, 0x4F	; 79
    d690:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d694:	88 23       	and	r24, r24
    d696:	09 f4       	brne	.+2      	; 0xd69a <GSM_Cycle+0xe34>
    d698:	01 c5       	rjmp	.+2562   	; 0xe09c <GSM_Cycle+0x1836>
    d69a:	83 e1       	ldi	r24, 0x13	; 19
    d69c:	80 93 19 06 	sts	0x0619, r24
    d6a0:	fd c4       	rjmp	.+2554   	; 0xe09c <GSM_Cycle+0x1836>
		//------------------------


				//------------------------  GPRS
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d6a2:	68 ee       	ldi	r22, 0xE8	; 232
    d6a4:	73 e0       	ldi	r23, 0x03	; 3
    d6a6:	89 e8       	ldi	r24, 0x89	; 137
    d6a8:	9e e4       	ldi	r25, 0x4E	; 78
    d6aa:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    d6ae:	80 91 19 06 	lds	r24, 0x0619
    d6b2:	8f 5f       	subi	r24, 0xFF	; 255
    d6b4:	80 93 19 06 	sts	0x0619, r24
    d6b8:	f1 c4       	rjmp	.+2530   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    d6ba:	6f e4       	ldi	r22, 0x4F	; 79
    d6bc:	84 ec       	ldi	r24, 0xC4	; 196
    d6be:	9f e4       	ldi	r25, 0x4F	; 79
    d6c0:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d6c4:	88 23       	and	r24, r24
    d6c6:	09 f4       	brne	.+2      	; 0xd6ca <GSM_Cycle+0xe64>
    d6c8:	e9 c4       	rjmp	.+2514   	; 0xe09c <GSM_Cycle+0x1836>
    d6ca:	80 91 19 06 	lds	r24, 0x0619
    d6ce:	8f 5f       	subi	r24, 0xFF	; 255
    d6d0:	80 93 19 06 	sts	0x0619, r24
    d6d4:	e3 c4       	rjmp	.+2502   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    d6d6:	68 ee       	ldi	r22, 0xE8	; 232
    d6d8:	73 e0       	ldi	r23, 0x03	; 3
    d6da:	8e e7       	ldi	r24, 0x7E	; 126
    d6dc:	9e e4       	ldi	r25, 0x4E	; 78
    d6de:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    d6e2:	80 91 19 06 	lds	r24, 0x0619
    d6e6:	8f 5f       	subi	r24, 0xFF	; 255
    d6e8:	80 93 19 06 	sts	0x0619, r24
    d6ec:	d7 c4       	rjmp	.+2478   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d6ee:	6f e4       	ldi	r22, 0x4F	; 79
    d6f0:	87 e1       	ldi	r24, 0x17	; 23
    d6f2:	90 e5       	ldi	r25, 0x50	; 80
    d6f4:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d6f8:	88 23       	and	r24, r24
    d6fa:	09 f4       	brne	.+2      	; 0xd6fe <GSM_Cycle+0xe98>
    d6fc:	cf c4       	rjmp	.+2462   	; 0xe09c <GSM_Cycle+0x1836>
				StartTimer16(TD_GSM, 1000);
    d6fe:	68 ee       	ldi	r22, 0xE8	; 232
    d700:	73 e0       	ldi	r23, 0x03	; 3
    d702:	80 91 52 02 	lds	r24, 0x0252
    d706:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			 	GSM_State = GSM_SEND_CIPMUX;
    d70a:	83 e1       	ldi	r24, 0x13	; 19
    d70c:	80 93 19 06 	sts	0x0619, r24
    d710:	c5 c4       	rjmp	.+2442   	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    d712:	80 91 08 01 	lds	r24, 0x0108
    d716:	80 ff       	sbrs	r24, 0
    d718:	c1 c4       	rjmp	.+2434   	; 0xe09c <GSM_Cycle+0x1836>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
    d71a:	60 91 df 03 	lds	r22, 0x03DF
    d71e:	9d e0       	ldi	r25, 0x0D	; 13
    d720:	69 9f       	mul	r22, r25
    d722:	b0 01       	movw	r22, r0
    d724:	11 24       	eor	r1, r1
    d726:	6d 51       	subi	r22, 0x1D	; 29
    d728:	7f 4f       	sbci	r23, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d72a:	4d e0       	ldi	r20, 0x0D	; 13
    d72c:	50 e0       	ldi	r21, 0x00	; 0
    d72e:	8c e1       	ldi	r24, 0x1C	; 28
    d730:	9c e0       	ldi	r25, 0x0C	; 12
    d732:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
				GSMTxSz = strlen(GSM_TxStr);
    d736:	ec e1       	ldi	r30, 0x1C	; 28
    d738:	fc e0       	ldi	r31, 0x0C	; 12
    d73a:	01 90       	ld	r0, Z+
    d73c:	00 20       	and	r0, r0
    d73e:	e9 f7       	brne	.-6      	; 0xd73a <GSM_Cycle+0xed4>
    d740:	31 97       	sbiw	r30, 0x01	; 1
    d742:	ec 51       	subi	r30, 0x1C	; 28
    d744:	fc 40       	sbci	r31, 0x0C	; 12
    d746:	e0 93 3c 09 	sts	0x093C, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    d74a:	80 e0       	ldi	r24, 0x00	; 0
		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
    d74c:	90 e0       	ldi	r25, 0x00	; 0
				for(uint8_t i=0; i<GSMTxSz; i++)
    d74e:	20 91 3c 09 	lds	r18, 0x093C
    d752:	82 17       	cp	r24, r18
    d754:	50 f4       	brcc	.+20     	; 0xd76a <GSM_Cycle+0xf04>
					if(GSM_TxStr[i] != '0') j++;
    d756:	e8 2f       	mov	r30, r24
    d758:	f0 e0       	ldi	r31, 0x00	; 0
    d75a:	e4 5e       	subi	r30, 0xE4	; 228
    d75c:	f3 4f       	sbci	r31, 0xF3	; 243
    d75e:	20 81       	ld	r18, Z
    d760:	20 33       	cpi	r18, 0x30	; 48
    d762:	09 f0       	breq	.+2      	; 0xd766 <GSM_Cycle+0xf00>
    d764:	9f 5f       	subi	r25, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    d766:	8f 5f       	subi	r24, 0xFF	; 255
    d768:	f2 cf       	rjmp	.-28     	; 0xd74e <GSM_Cycle+0xee8>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    d76a:	99 23       	and	r25, r25
    d76c:	09 f4       	brne	.+2      	; 0xd770 <GSM_Cycle+0xf0a>
    d76e:	4b c0       	rjmp	.+150    	; 0xd806 <GSM_Cycle+0xfa0>
					GSMTxSz = strlen_P(AT_CMGS);
    d770:	8a e0       	ldi	r24, 0x0A	; 10
    d772:	80 93 3c 09 	sts	0x093C, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    d776:	88 e5       	ldi	r24, 0x58	; 88
    d778:	9f e4       	ldi	r25, 0x4F	; 79
    d77a:	9f 93       	push	r25
    d77c:	8f 93       	push	r24
    d77e:	0c e1       	ldi	r16, 0x1C	; 28
    d780:	1c e0       	ldi	r17, 0x0C	; 12
    d782:	1f 93       	push	r17
    d784:	0f 93       	push	r16
    d786:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    d78a:	60 91 df 03 	lds	r22, 0x03DF
    d78e:	80 91 3c 09 	lds	r24, 0x093C
    d792:	ed e0       	ldi	r30, 0x0D	; 13
    d794:	6e 9f       	mul	r22, r30
    d796:	b0 01       	movw	r22, r0
    d798:	11 24       	eor	r1, r1
    d79a:	6d 51       	subi	r22, 0x1D	; 29
    d79c:	7f 4f       	sbci	r23, 0xFF	; 255
    d79e:	90 e0       	ldi	r25, 0x00	; 0
    d7a0:	4d e0       	ldi	r20, 0x0D	; 13
    d7a2:	50 e0       	ldi	r21, 0x00	; 0
    d7a4:	84 5e       	subi	r24, 0xE4	; 228
    d7a6:	93 4f       	sbci	r25, 0xF3	; 243
    d7a8:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    d7ac:	d8 01       	movw	r26, r16
    d7ae:	0d 90       	ld	r0, X+
    d7b0:	00 20       	and	r0, r0
    d7b2:	e9 f7       	brne	.-6      	; 0xd7ae <GSM_Cycle+0xf48>
    d7b4:	11 97       	sbiw	r26, 0x01	; 1
    d7b6:	ac 51       	subi	r26, 0x1C	; 28
    d7b8:	bc 40       	sbci	r27, 0x0C	; 12
    d7ba:	a0 93 3c 09 	sts	0x093C, r26
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    d7be:	80 91 3c 09 	lds	r24, 0x093C
    d7c2:	90 e0       	ldi	r25, 0x00	; 0
    d7c4:	67 ec       	ldi	r22, 0xC7	; 199
    d7c6:	71 e0       	ldi	r23, 0x01	; 1
    d7c8:	84 5e       	subi	r24, 0xE4	; 228
    d7ca:	93 4f       	sbci	r25, 0xF3	; 243
    d7cc:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    d7d0:	f8 01       	movw	r30, r16
    d7d2:	01 90       	ld	r0, Z+
    d7d4:	00 20       	and	r0, r0
    d7d6:	e9 f7       	brne	.-6      	; 0xd7d2 <GSM_Cycle+0xf6c>
    d7d8:	31 97       	sbiw	r30, 0x01	; 1
    d7da:	ec 51       	subi	r30, 0x1C	; 28
    d7dc:	fc 40       	sbci	r31, 0x0C	; 12
    d7de:	e0 93 3c 09 	sts	0x093C, r30
					GSM_SendFirstChar();
    d7e2:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d7e6:	64 ef       	ldi	r22, 0xF4	; 244
    d7e8:	71 e0       	ldi	r23, 0x01	; 1
    d7ea:	80 91 52 02 	lds	r24, 0x0252
    d7ee:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					GSM_State++;
    d7f2:	80 91 19 06 	lds	r24, 0x0619
    d7f6:	8f 5f       	subi	r24, 0xFF	; 255
    d7f8:	80 93 19 06 	sts	0x0619, r24
    d7fc:	0f 90       	pop	r0
    d7fe:	0f 90       	pop	r0
    d800:	0f 90       	pop	r0
    d802:	0f 90       	pop	r0
    d804:	4b c4       	rjmp	.+2198   	; 0xe09c <GSM_Cycle+0x1836>
				}
				else{
					TempNum++;
    d806:	80 91 df 03 	lds	r24, 0x03DF
    d80a:	8f 5f       	subi	r24, 0xFF	; 255
    d80c:	80 93 df 03 	sts	0x03DF, r24
					if(TempNum>=MaxTelephDirSz){
    d810:	83 30       	cpi	r24, 0x03	; 3
    d812:	08 f4       	brcc	.+2      	; 0xd816 <GSM_Cycle+0xfb0>
    d814:	43 c4       	rjmp	.+2182   	; 0xe09c <GSM_Cycle+0x1836>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    d816:	88 e2       	ldi	r24, 0x28	; 40
    d818:	80 93 19 06 	sts	0x0619, r24
						SMS_FlgSz_Out = 0;
    d81c:	10 92 4b 09 	sts	0x094B, r1
    d820:	3d c4       	rjmp	.+2170   	; 0xe09c <GSM_Cycle+0x1836>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    d822:	6f e4       	ldi	r22, 0x4F	; 79
    d824:	8e e3       	ldi	r24, 0x3E	; 62
    d826:	0e 94 95 3b 	call	0x772a	; 0x772a <GSM_Wait_Char>
    d82a:	88 23       	and	r24, r24
    d82c:	09 f4       	brne	.+2      	; 0xd830 <GSM_Cycle+0xfca>
    d82e:	36 c4       	rjmp	.+2156   	; 0xe09c <GSM_Cycle+0x1836>
    d830:	80 91 19 06 	lds	r24, 0x0619
    d834:	8f 5f       	subi	r24, 0xFF	; 255
    d836:	80 93 19 06 	sts	0x0619, r24
    d83a:	30 c4       	rjmp	.+2144   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    d83c:	60 91 4b 09 	lds	r22, 0x094B
    d840:	e6 2f       	mov	r30, r22
    d842:	f0 e0       	ldi	r31, 0x00	; 0
    d844:	e0 54       	subi	r30, 0x40	; 64
    d846:	f7 4f       	sbci	r31, 0xF7	; 247
    d848:	8a e1       	ldi	r24, 0x1A	; 26
    d84a:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    d84c:	6f 5f       	subi	r22, 0xFF	; 255
    d84e:	80 ec       	ldi	r24, 0xC0	; 192
    d850:	98 e0       	ldi	r25, 0x08	; 8
    d852:	0e 94 27 64 	call	0xc84e	; 0xc84e <GSM_SendData>
			GSM_State++;
    d856:	80 91 19 06 	lds	r24, 0x0619
    d85a:	8f 5f       	subi	r24, 0xFF	; 255
    d85c:	80 93 19 06 	sts	0x0619, r24
    d860:	1d c4       	rjmp	.+2106   	; 0xe09c <GSM_Cycle+0x1836>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    d862:	6f e4       	ldi	r22, 0x4F	; 79
    d864:	87 e1       	ldi	r24, 0x17	; 23
    d866:	90 e5       	ldi	r25, 0x50	; 80
    d868:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    d86c:	88 23       	and	r24, r24
    d86e:	09 f4       	brne	.+2      	; 0xd872 <GSM_Cycle+0x100c>
    d870:	15 c4       	rjmp	.+2090   	; 0xe09c <GSM_Cycle+0x1836>
				if(++TempNum>=MaxTelephDirSz){
    d872:	80 91 df 03 	lds	r24, 0x03DF
    d876:	8f 5f       	subi	r24, 0xFF	; 255
    d878:	80 93 df 03 	sts	0x03DF, r24
    d87c:	83 30       	cpi	r24, 0x03	; 3
    d87e:	30 f0       	brcs	.+12     	; 0xd88c <GSM_Cycle+0x1026>
					GSM_State = GSM_ServerIdle;
    d880:	88 e2       	ldi	r24, 0x28	; 40
    d882:	80 93 19 06 	sts	0x0619, r24
					SMS_FlgSz_Out = 0;
    d886:	10 92 4b 09 	sts	0x094B, r1
    d88a:	08 c4       	rjmp	.+2064   	; 0xe09c <GSM_Cycle+0x1836>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    d88c:	8f e2       	ldi	r24, 0x2F	; 47
    d88e:	80 93 19 06 	sts	0x0619, r24
    d892:	04 c4       	rjmp	.+2056   	; 0xe09c <GSM_Cycle+0x1836>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    d894:	80 e2       	ldi	r24, 0x20	; 32
    d896:	9d e0       	ldi	r25, 0x0D	; 13
    d898:	9f 93       	push	r25
    d89a:	8f 93       	push	r24
    d89c:	8f e1       	ldi	r24, 0x1F	; 31
    d89e:	9d e0       	ldi	r25, 0x0D	; 13
    d8a0:	9f 93       	push	r25
    d8a2:	8f 93       	push	r24
    d8a4:	8e e1       	ldi	r24, 0x1E	; 30
    d8a6:	9d e0       	ldi	r25, 0x0D	; 13
    d8a8:	9f 93       	push	r25
    d8aa:	8f 93       	push	r24
    d8ac:	8d e1       	ldi	r24, 0x1D	; 29
    d8ae:	9d e0       	ldi	r25, 0x0D	; 13
    d8b0:	9f 93       	push	r25
    d8b2:	8f 93       	push	r24
    d8b4:	8b e6       	ldi	r24, 0x6B	; 107
    d8b6:	93 e0       	ldi	r25, 0x03	; 3
    d8b8:	9f 93       	push	r25
    d8ba:	8f 93       	push	r24
    d8bc:	8d e6       	ldi	r24, 0x6D	; 109
    d8be:	99 e0       	ldi	r25, 0x09	; 9
    d8c0:	9f 93       	push	r25
    d8c2:	8f 93       	push	r24
    d8c4:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    d8c8:	10 92 df 03 	sts	0x03DF, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    d8cc:	10 91 20 0d 	lds	r17, 0x0D20
    d8d0:	70 90 1f 0d 	lds	r7, 0x0D1F
    d8d4:	60 90 1e 0d 	lds	r6, 0x0D1E
    d8d8:	50 90 1d 0d 	lds	r5, 0x0D1D
    d8dc:	00 e1       	ldi	r16, 0x10	; 16
    d8de:	80 2e       	mov	r8, r16
    d8e0:	01 e0       	ldi	r16, 0x01	; 1
    d8e2:	90 2e       	mov	r9, r16
    d8e4:	0f b6       	in	r0, 0x3f	; 63
    d8e6:	f8 94       	cli
    d8e8:	de bf       	out	0x3e, r29	; 62
    d8ea:	0f be       	out	0x3f, r0	; 63
    d8ec:	cd bf       	out	0x3d, r28	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    d8ee:	0f ef       	ldi	r16, 0xFF	; 255
    d8f0:	2f ef       	ldi	r18, 0xFF	; 255
    d8f2:	4f ef       	ldi	r20, 0xFF	; 255
    d8f4:	6f ef       	ldi	r22, 0xFF	; 255
    d8f6:	c4 01       	movw	r24, r8
    d8f8:	0e 94 1f 3a 	call	0x743e	; 0x743e <IP_E_compare_Const>
    d8fc:	88 23       	and	r24, r24
    d8fe:	21 f0       	breq	.+8      	; 0xd908 <GSM_Cycle+0x10a2>
					TempNum = 1;
    d900:	81 e0       	ldi	r24, 0x01	; 1
    d902:	80 93 df 03 	sts	0x03DF, r24
    d906:	1a c0       	rjmp	.+52     	; 0xd93c <GSM_Cycle+0x10d6>
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    d908:	00 e0       	ldi	r16, 0x00	; 0
    d90a:	20 e0       	ldi	r18, 0x00	; 0
    d90c:	40 e0       	ldi	r20, 0x00	; 0
    d90e:	60 e0       	ldi	r22, 0x00	; 0
    d910:	c4 01       	movw	r24, r8
    d912:	0e 94 1f 3a 	call	0x743e	; 0x743e <IP_E_compare_Const>
    d916:	81 11       	cpse	r24, r1
    d918:	09 c0       	rjmp	.+18     	; 0xd92c <GSM_Cycle+0x10c6>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    d91a:	01 2f       	mov	r16, r17
    d91c:	27 2d       	mov	r18, r7
    d91e:	46 2d       	mov	r20, r6
    d920:	65 2d       	mov	r22, r5
    d922:	c4 01       	movw	r24, r8
    d924:	0e 94 1f 3a 	call	0x743e	; 0x743e <IP_E_compare_Const>
    d928:	81 11       	cpse	r24, r1
    d92a:	ea cf       	rjmp	.-44     	; 0xd900 <GSM_Cycle+0x109a>
    d92c:	34 e0       	ldi	r19, 0x04	; 4
    d92e:	83 0e       	add	r8, r19
    d930:	91 1c       	adc	r9, r1
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    d932:	80 e2       	ldi	r24, 0x20	; 32
    d934:	88 16       	cp	r8, r24
    d936:	81 e0       	ldi	r24, 0x01	; 1
    d938:	98 06       	cpc	r9, r24
    d93a:	c9 f6       	brne	.-78     	; 0xd8ee <GSM_Cycle+0x1088>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    d93c:	80 91 df 03 	lds	r24, 0x03DF
    d940:	88 23       	and	r24, r24
    d942:	89 f0       	breq	.+34     	; 0xd966 <GSM_Cycle+0x1100>
				GSM_State = GSM_ServerIdle;
    d944:	88 e2       	ldi	r24, 0x28	; 40
    d946:	80 93 19 06 	sts	0x0619, r24
				GSM_ActiveConnection = GSM_Temp;
    d94a:	80 91 de 03 	lds	r24, 0x03DE
    d94e:	80 93 07 01 	sts	0x0107, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d952:	8e e0       	ldi	r24, 0x0E	; 14
    d954:	91 e0       	ldi	r25, 0x01	; 1
    d956:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    d95a:	bc 01       	movw	r22, r24
    d95c:	80 91 51 02 	lds	r24, 0x0251
    d960:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    d964:	9b c3       	rjmp	.+1846   	; 0xe09c <GSM_Cycle+0x1836>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    d966:	84 e3       	ldi	r24, 0x34	; 52
    d968:	80 93 19 06 	sts	0x0619, r24
    d96c:	97 c3       	rjmp	.+1838   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    d96e:	80 91 08 01 	lds	r24, 0x0108
    d972:	80 ff       	sbrs	r24, 0
    d974:	93 c3       	rjmp	.+1830   	; 0xe09c <GSM_Cycle+0x1836>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    d976:	8f e0       	ldi	r24, 0x0F	; 15
    d978:	80 93 3c 09 	sts	0x093C, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    d97c:	82 ea       	ldi	r24, 0xA2	; 162
    d97e:	9e e4       	ldi	r25, 0x4E	; 78
    d980:	9f 93       	push	r25
    d982:	8f 93       	push	r24
    d984:	8c e1       	ldi	r24, 0x1C	; 28
    d986:	9c e0       	ldi	r25, 0x0C	; 12
    d988:	9f 93       	push	r25
    d98a:	8f 93       	push	r24
    d98c:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    d990:	80 91 3c 09 	lds	r24, 0x093C
    d994:	90 e0       	ldi	r25, 0x00	; 0
    d996:	68 ec       	ldi	r22, 0xC8	; 200
    d998:	71 e0       	ldi	r23, 0x01	; 1
    d99a:	84 5e       	subi	r24, 0xE4	; 228
    d99c:	93 4f       	sbci	r25, 0xF3	; 243
    d99e:	0e 94 17 78 	call	0xf02e	; 0xf02e <strcpy>
				GSMTxSz++;
    d9a2:	80 91 3c 09 	lds	r24, 0x093C
    d9a6:	8f 5f       	subi	r24, 0xFF	; 255
    d9a8:	80 93 3c 09 	sts	0x093C, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    d9ac:	80 91 de 03 	lds	r24, 0x03DE
    d9b0:	80 5d       	subi	r24, 0xD0	; 208
    d9b2:	80 93 28 0c 	sts	0x0C28, r24
				GSM_SendFirstChar();
    d9b6:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    d9ba:	64 ef       	ldi	r22, 0xF4	; 244
    d9bc:	71 e0       	ldi	r23, 0x01	; 1
    d9be:	80 91 52 02 	lds	r24, 0x0252
    d9c2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State++;
    d9c6:	80 91 19 06 	lds	r24, 0x0619
    d9ca:	8f 5f       	subi	r24, 0xFF	; 255
    d9cc:	80 93 19 06 	sts	0x0619, r24
    d9d0:	0f 90       	pop	r0
    d9d2:	0f 90       	pop	r0
    d9d4:	0f 90       	pop	r0
    d9d6:	0f 90       	pop	r0
    d9d8:	61 c3       	rjmp	.+1730   	; 0xe09c <GSM_Cycle+0x1836>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    d9da:	80 91 52 02 	lds	r24, 0x0252
    d9de:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    d9e2:	88 23       	and	r24, r24
    d9e4:	19 f0       	breq	.+6      	; 0xd9ec <GSM_Cycle+0x1186>
    d9e6:	8f e4       	ldi	r24, 0x4F	; 79
    d9e8:	80 93 19 06 	sts	0x0619, r24
			if(GetStringFromFIFO()){
    d9ec:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    d9f0:	88 23       	and	r24, r24
    d9f2:	09 f4       	brne	.+2      	; 0xd9f6 <GSM_Cycle+0x1190>
    d9f4:	53 c3       	rjmp	.+1702   	; 0xe09c <GSM_Cycle+0x1836>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    d9f6:	62 ed       	ldi	r22, 0xD2	; 210
    d9f8:	7f e4       	ldi	r23, 0x4F	; 79
    d9fa:	ce 01       	movw	r24, r28
    d9fc:	01 96       	adiw	r24, 0x01	; 1
    d9fe:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    da02:	80 91 de 03 	lds	r24, 0x03DE
    da06:	80 5d       	subi	r24, 0xD0	; 208
    da08:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    da0a:	6f e4       	ldi	r22, 0x4F	; 79
    da0c:	ce 01       	movw	r24, r28
    da0e:	01 96       	adiw	r24, 0x01	; 1
    da10:	0e 94 61 3b 	call	0x76c2	; 0x76c2 <GSM_Wait_Response>
    da14:	88 23       	and	r24, r24
    da16:	09 f4       	brne	.+2      	; 0xda1a <GSM_Cycle+0x11b4>
    da18:	41 c3       	rjmp	.+1666   	; 0xe09c <GSM_Cycle+0x1836>
					GSM_State = GSM_ServerIdle;
    da1a:	88 e2       	ldi	r24, 0x28	; 40
    da1c:	80 93 19 06 	sts	0x0619, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    da20:	80 91 07 01 	lds	r24, 0x0107
    da24:	8f 3f       	cpi	r24, 0xFF	; 255
    da26:	09 f4       	brne	.+2      	; 0xda2a <GSM_Cycle+0x11c4>
    da28:	39 c3       	rjmp	.+1650   	; 0xe09c <GSM_Cycle+0x1836>
    da2a:	80 91 51 02 	lds	r24, 0x0251
    da2e:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    da32:	88 23       	and	r24, r24
    da34:	09 f4       	brne	.+2      	; 0xda38 <GSM_Cycle+0x11d2>
    da36:	32 c3       	rjmp	.+1636   	; 0xe09c <GSM_Cycle+0x1836>
						GSM_ActiveConnection = NO_CONNECTION;
    da38:	8f ef       	ldi	r24, 0xFF	; 255
    da3a:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    da3e:	10 92 1d 0d 	sts	0x0D1D, r1
	IP->IP2 = IP2;
    da42:	10 92 1e 0d 	sts	0x0D1E, r1
	IP->IP3 = IP3;
    da46:	10 92 1f 0d 	sts	0x0D1F, r1
	IP->IP4 = IP4;
    da4a:	10 92 20 0d 	sts	0x0D20, r1
    da4e:	26 c3       	rjmp	.+1612   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    da50:	8e ed       	ldi	r24, 0xDE	; 222
    da52:	93 e0       	ldi	r25, 0x03	; 3
    da54:	9f 93       	push	r25
    da56:	8f 93       	push	r24
    da58:	ce 01       	movw	r24, r28
    da5a:	01 96       	adiw	r24, 0x01	; 1
    da5c:	9f 93       	push	r25
    da5e:	8f 93       	push	r24
    da60:	88 e5       	ldi	r24, 0x58	; 88
    da62:	93 e0       	ldi	r25, 0x03	; 3
    da64:	9f 93       	push	r25
    da66:	8f 93       	push	r24
    da68:	8d e6       	ldi	r24, 0x6D	; 109
    da6a:	99 e0       	ldi	r25, 0x09	; 9
    da6c:	9f 93       	push	r25
    da6e:	8f 93       	push	r24
    da70:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    da74:	0f b6       	in	r0, 0x3f	; 63
    da76:	f8 94       	cli
    da78:	de bf       	out	0x3e, r29	; 62
    da7a:	0f be       	out	0x3f, r0	; 63
    da7c:	cd bf       	out	0x3d, r28	; 61
    da7e:	99 81       	ldd	r25, Y+1	; 0x01
    da80:	80 91 07 01 	lds	r24, 0x0107
    da84:	98 13       	cpse	r25, r24
    da86:	0c c0       	rjmp	.+24     	; 0xdaa0 <GSM_Cycle+0x123a>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    da88:	64 ef       	ldi	r22, 0xF4	; 244
    da8a:	71 e0       	ldi	r23, 0x01	; 1
    da8c:	80 91 52 02 	lds	r24, 0x0252
    da90:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					GSM_State++;
    da94:	80 91 19 06 	lds	r24, 0x0619
    da98:	8f 5f       	subi	r24, 0xFF	; 255
    da9a:	80 93 19 06 	sts	0x0619, r24
    da9e:	fe c2       	rjmp	.+1532   	; 0xe09c <GSM_Cycle+0x1836>
					break;
				}
				GSM_State = GSM_ServerIdle;
    daa0:	88 e2       	ldi	r24, 0x28	; 40
    daa2:	80 93 19 06 	sts	0x0619, r24
    daa6:	fa c2       	rjmp	.+1524   	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    daa8:	80 91 52 02 	lds	r24, 0x0252
    daac:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    dab0:	88 23       	and	r24, r24
    dab2:	19 f0       	breq	.+6      	; 0xdaba <GSM_Cycle+0x1254>
    dab4:	8f e4       	ldi	r24, 0x4F	; 79
    dab6:	80 93 19 06 	sts	0x0619, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    daba:	80 91 de 03 	lds	r24, 0x03DE
    dabe:	80 93 42 09 	sts	0x0942, r24

			GSM_State = GSM_ServerIdle;
    dac2:	88 e2       	ldi	r24, 0x28	; 40
    dac4:	80 93 19 06 	sts	0x0619, r24
    dac8:	e9 c2       	rjmp	.+1490   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    daca:	60 e7       	ldi	r22, 0x70	; 112
    dacc:	77 e1       	ldi	r23, 0x17	; 23
    dace:	84 e9       	ldi	r24, 0x94	; 148
    dad0:	9e e4       	ldi	r25, 0x4E	; 78
    dad2:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    dad6:	80 91 19 06 	lds	r24, 0x0619
    dada:	8f 5f       	subi	r24, 0xFF	; 255
    dadc:	80 93 19 06 	sts	0x0619, r24
    dae0:	dd c2       	rjmp	.+1466   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    dae2:	80 91 52 02 	lds	r24, 0x0252
    dae6:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    daea:	88 23       	and	r24, r24
    daec:	19 f0       	breq	.+6      	; 0xdaf4 <GSM_Cycle+0x128e>
    daee:	8f e4       	ldi	r24, 0x4F	; 79
    daf0:	80 93 19 06 	sts	0x0619, r24
			//  
			if(GetStringFromFIFO()){
    daf4:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    daf8:	88 23       	and	r24, r24
    dafa:	09 f4       	brne	.+2      	; 0xdafe <GSM_Cycle+0x1298>
    dafc:	cf c2       	rjmp	.+1438   	; 0xe09c <GSM_Cycle+0x1836>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
    dafe:	6e ed       	ldi	r22, 0xDE	; 222
    db00:	7f e4       	ldi	r23, 0x4F	; 79
    db02:	8d e6       	ldi	r24, 0x6D	; 109
    db04:	99 e0       	ldi	r25, 0x09	; 9
    db06:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    db0a:	89 2b       	or	r24, r25
    db0c:	49 f0       	breq	.+18     	; 0xdb20 <GSM_Cycle+0x12ba>
    db0e:	67 e3       	ldi	r22, 0x37	; 55
    db10:	70 e5       	ldi	r23, 0x50	; 80
    db12:	8d e6       	ldi	r24, 0x6D	; 109
    db14:	99 e0       	ldi	r25, 0x09	; 9
    db16:	0e 94 a5 77 	call	0xef4a	; 0xef4a <strcmp_P>
    db1a:	89 2b       	or	r24, r25
    db1c:	09 f0       	breq	.+2      	; 0xdb20 <GSM_Cycle+0x12ba>
    db1e:	be c2       	rjmp	.+1404   	; 0xe09c <GSM_Cycle+0x1836>
					GSM_State = GSM_ServerIdle;
    db20:	88 e2       	ldi	r24, 0x28	; 40
    db22:	80 93 19 06 	sts	0x0619, r24
					GPRS_FlgSz_Out = 0;						
    db26:	10 92 29 09 	sts	0x0929, r1
    db2a:	b8 c2       	rjmp	.+1392   	; 0xe09c <GSM_Cycle+0x1836>
		//------------------------

		/*NEW COMMIT*/
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
    db2c:	0e 94 1c 2f 	call	0x5e38	; 0x5e38 <GSM_PWRCNTRL_OFF>
			StartTimer16(TD_GSM,1000);
    db30:	68 ee       	ldi	r22, 0xE8	; 232
    db32:	73 e0       	ldi	r23, 0x03	; 3
    db34:	80 91 52 02 	lds	r24, 0x0252
    db38:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			RxBufOverFlow = 0;
    db3c:	10 92 1c 0d 	sts	0x0D1C, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
    db40:	10 92 4b 09 	sts	0x094B, r1
			GSM_ActiveConnection = NO_CONNECTION;
    db44:	8f ef       	ldi	r24, 0xFF	; 255
    db46:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    db4a:	10 92 1d 0d 	sts	0x0D1D, r1
	IP->IP2 = IP2;
    db4e:	10 92 1e 0d 	sts	0x0D1E, r1
	IP->IP3 = IP3;
    db52:	10 92 1f 0d 	sts	0x0D1F, r1
	IP->IP4 = IP4;
    db56:	10 92 20 0d 	sts	0x0D20, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    db5a:	80 91 08 01 	lds	r24, 0x0108
    db5e:	81 60       	ori	r24, 0x01	; 1
    db60:	80 93 08 01 	sts	0x0108, r24
			GSM_State++;
    db64:	80 91 19 06 	lds	r24, 0x0619
    db68:	8f 5f       	subi	r24, 0xFF	; 255
    db6a:	80 93 19 06 	sts	0x0619, r24
    db6e:	96 c2       	rjmp	.+1324   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    db70:	80 91 52 02 	lds	r24, 0x0252
    db74:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    db78:	88 23       	and	r24, r24
    db7a:	09 f4       	brne	.+2      	; 0xdb7e <GSM_Cycle+0x1318>
    db7c:	8f c2       	rjmp	.+1310   	; 0xe09c <GSM_Cycle+0x1836>
				GSM_State = GSM_PowerOn;
    db7e:	10 92 19 06 	sts	0x0619, r1
    db82:	8c c2       	rjmp	.+1304   	; 0xe09c <GSM_Cycle+0x1836>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
    db84:	64 ef       	ldi	r22, 0xF4	; 244
    db86:	71 e0       	ldi	r23, 0x01	; 1
    db88:	8e eb       	ldi	r24, 0xBE	; 190
    db8a:	9e e4       	ldi	r25, 0x4E	; 78
    db8c:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    db90:	80 91 19 06 	lds	r24, 0x0619
    db94:	8f 5f       	subi	r24, 0xFF	; 255
    db96:	80 93 19 06 	sts	0x0619, r24
    db9a:	80 c2       	rjmp	.+1280   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    db9c:	6f e4       	ldi	r22, 0x4F	; 79
    db9e:	87 e1       	ldi	r24, 0x17	; 23
    dba0:	90 e5       	ldi	r25, 0x50	; 80
    dba2:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    dba6:	88 23       	and	r24, r24
    dba8:	09 f4       	brne	.+2      	; 0xdbac <GSM_Cycle+0x1346>
    dbaa:	78 c2       	rjmp	.+1264   	; 0xe09c <GSM_Cycle+0x1836>
    dbac:	80 91 19 06 	lds	r24, 0x0619
    dbb0:	8f 5f       	subi	r24, 0xFF	; 255
    dbb2:	80 93 19 06 	sts	0x0619, r24
    dbb6:	72 c2       	rjmp	.+1252   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
    dbb8:	6f e4       	ldi	r22, 0x4F	; 79
    dbba:	82 ef       	ldi	r24, 0xF2	; 242
    dbbc:	9f e4       	ldi	r25, 0x4F	; 79
    dbbe:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    dbc2:	88 23       	and	r24, r24
    dbc4:	09 f4       	brne	.+2      	; 0xdbc8 <GSM_Cycle+0x1362>
    dbc6:	6a c2       	rjmp	.+1236   	; 0xe09c <GSM_Cycle+0x1836>
    dbc8:	85 e2       	ldi	r24, 0x25	; 37
    dbca:	80 93 19 06 	sts	0x0619, r24
    dbce:	66 c2       	rjmp	.+1228   	; 0xe09c <GSM_Cycle+0x1836>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    dbd0:	64 ef       	ldi	r22, 0xF4	; 244
    dbd2:	71 e0       	ldi	r23, 0x01	; 1
    dbd4:	87 e7       	ldi	r24, 0x77	; 119
    dbd6:	9e e4       	ldi	r25, 0x4E	; 78
    dbd8:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
    dbdc:	60 e7       	ldi	r22, 0x70	; 112
    dbde:	77 e1       	ldi	r23, 0x17	; 23
    dbe0:	80 91 50 02 	lds	r24, 0x0250
    dbe4:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			GSM_State = GSM_ServerIdle;
    dbe8:	88 e2       	ldi	r24, 0x28	; 40
    dbea:	80 93 19 06 	sts	0x0619, r24
    dbee:	56 c2       	rjmp	.+1196   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
    dbf0:	8f ef       	ldi	r24, 0xFF	; 255
    dbf2:	80 93 17 06 	sts	0x0617, r24
    dbf6:	80 93 50 09 	sts	0x0950, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    dbfa:	80 e5       	ldi	r24, 0x50	; 80
    dbfc:	99 e0       	ldi	r25, 0x09	; 9
    dbfe:	9f 93       	push	r25
    dc00:	8f 93       	push	r24
    dc02:	87 e1       	ldi	r24, 0x17	; 23
    dc04:	96 e0       	ldi	r25, 0x06	; 6
    dc06:	9f 93       	push	r25
    dc08:	8f 93       	push	r24
    dc0a:	88 e4       	ldi	r24, 0x48	; 72
    dc0c:	93 e0       	ldi	r25, 0x03	; 3
    dc0e:	9f 93       	push	r25
    dc10:	8f 93       	push	r24
    dc12:	8d e6       	ldi	r24, 0x6D	; 109
    dc14:	99 e0       	ldi	r25, 0x09	; 9
    dc16:	9f 93       	push	r25
    dc18:	8f 93       	push	r24
    dc1a:	0e 94 ac 78 	call	0xf158	; 0xf158 <sscanf_P>
			GSM_State = GSM_ServerIdle;
    dc1e:	88 e2       	ldi	r24, 0x28	; 40
    dc20:	80 93 19 06 	sts	0x0619, r24
    dc24:	0f b6       	in	r0, 0x3f	; 63
    dc26:	f8 94       	cli
    dc28:	de bf       	out	0x3e, r29	; 62
    dc2a:	0f be       	out	0x3f, r0	; 63
    dc2c:	cd bf       	out	0x3d, r28	; 61
    dc2e:	36 c2       	rjmp	.+1132   	; 0xe09c <GSM_Cycle+0x1836>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			
			if(GSM_CSD == 1){	//  CSD   
    dc30:	10 91 31 09 	lds	r17, 0x0931
    dc34:	11 30       	cpi	r17, 0x01	; 1
    dc36:	61 f5       	brne	.+88     	; 0xdc90 <GSM_Cycle+0x142a>
				AppProtocol=0;	
    dc38:	10 92 d8 09 	sts	0x09D8, r1
				GSM_State = GSM_DataMode;
    dc3c:	87 e5       	ldi	r24, 0x57	; 87
    dc3e:	80 93 19 06 	sts	0x0619, r24
				if(UART_Soft){
    dc42:	80 91 59 0a 	lds	r24, 0x0A59
    dc46:	88 23       	and	r24, r24
    dc48:	21 f0       	breq	.+8      	; 0xdc52 <GSM_Cycle+0x13ec>
					GSM_State = GSM_Swtch2CommandMode;
    dc4a:	88 e5       	ldi	r24, 0x58	; 88
    dc4c:	80 93 19 06 	sts	0x0619, r24
    dc50:	25 c2       	rjmp	.+1098   	; 0xe09c <GSM_Cycle+0x1836>
				}
				else{
					EM_InitFIFO();
    dc52:	0e 94 45 4b 	call	0x968a	; 0x968a <EM_InitFIFO>
					Transparent = 1;
    dc56:	10 93 5a 0a 	sts	0x0A5A, r17
    dc5a:	8e e0       	ldi	r24, 0x0E	; 14
    dc5c:	91 e0       	ldi	r25, 0x01	; 1
    dc5e:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
					StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    dc62:	bc 01       	movw	r22, r24
    dc64:	80 91 51 02 	lds	r24, 0x0251
    dc68:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
    dc6c:	17 c2       	rjmp	.+1070   	; 0xe09c <GSM_Cycle+0x1836>
			}

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
				
				static uint8_t GSM_RX_FIFO_End_old;	//     4 
				if(!GSM_RxCharN) GSM_RX_FIFO_End_old = GSM_RX_FIFO_End;
    dc6e:	90 91 27 0d 	lds	r25, 0x0D27
    dc72:	91 11       	cpse	r25, r1
    dc74:	02 c0       	rjmp	.+4      	; 0xdc7a <GSM_Cycle+0x1414>
    dc76:	80 93 3b 02 	sts	0x023B, r24
				
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    dc7a:	44 e6       	ldi	r20, 0x64	; 100
    dc7c:	67 e2       	ldi	r22, 0x27	; 39
    dc7e:	7d e0       	ldi	r23, 0x0D	; 13
    dc80:	8d e6       	ldi	r24, 0x6D	; 109
    dc82:	99 e0       	ldi	r25, 0x09	; 9
    dc84:	0e 94 57 3a 	call	0x74ae	; 0x74ae <GetByteFromFIFO>
				if(GSM_RxCharN >= 4){
    dc88:	80 91 27 0d 	lds	r24, 0x0D27
    dc8c:	84 30       	cpi	r24, 0x04	; 4
    dc8e:	38 f4       	brcc	.+14     	; 0xdc9e <GSM_Cycle+0x1438>
					StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
				}
				break;						
			}

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    dc90:	90 91 6d 08 	lds	r25, 0x086D
    dc94:	80 91 f8 05 	lds	r24, 0x05F8
    dc98:	98 13       	cpse	r25, r24
    dc9a:	e9 cf       	rjmp	.-46     	; 0xdc6e <GSM_Cycle+0x1408>
    dc9c:	48 c0       	rjmp	.+144    	; 0xdd2e <GSM_Cycle+0x14c8>
				static uint8_t GSM_RX_FIFO_End_old;	//     4 
				if(!GSM_RxCharN) GSM_RX_FIFO_End_old = GSM_RX_FIFO_End;
				
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
				if(GSM_RxCharN >= 4){
					AppProtocol = 0;
    dc9e:	10 92 d8 09 	sts	0x09D8, r1
					if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) AppProtocol = _HTTP;
    dca2:	44 e0       	ldi	r20, 0x04	; 4
    dca4:	50 e0       	ldi	r21, 0x00	; 0
    dca6:	63 e4       	ldi	r22, 0x43	; 67
    dca8:	73 e0       	ldi	r23, 0x03	; 3
    dcaa:	8d e6       	ldi	r24, 0x6D	; 109
    dcac:	99 e0       	ldi	r25, 0x09	; 9
    dcae:	0e 94 d2 77 	call	0xefa4	; 0xefa4 <strncmp_P>
    dcb2:	89 2b       	or	r24, r25
    dcb4:	19 f4       	brne	.+6      	; 0xdcbc <GSM_Cycle+0x1456>
    dcb6:	81 e0       	ldi	r24, 0x01	; 1
    dcb8:	80 93 d8 09 	sts	0x09D8, r24
					if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) AppProtocol = _HTTP;
    dcbc:	44 e0       	ldi	r20, 0x04	; 4
    dcbe:	50 e0       	ldi	r21, 0x00	; 0
    dcc0:	6e e3       	ldi	r22, 0x3E	; 62
    dcc2:	73 e0       	ldi	r23, 0x03	; 3
    dcc4:	8d e6       	ldi	r24, 0x6D	; 109
    dcc6:	99 e0       	ldi	r25, 0x09	; 9
    dcc8:	0e 94 d2 77 	call	0xefa4	; 0xefa4 <strncmp_P>
    dccc:	89 2b       	or	r24, r25
    dcce:	19 f4       	brne	.+6      	; 0xdcd6 <GSM_Cycle+0x1470>
    dcd0:	81 e0       	ldi	r24, 0x01	; 1
    dcd2:	80 93 d8 09 	sts	0x09D8, r24
					if( (GSM_RxStr[0]==5) && (GSM_RxStr[1]==1) ) AppProtocol = _VFCP;
    dcd6:	80 91 6d 09 	lds	r24, 0x096D
    dcda:	85 30       	cpi	r24, 0x05	; 5
    dcdc:	39 f4       	brne	.+14     	; 0xdcec <GSM_Cycle+0x1486>
    dcde:	80 91 6e 09 	lds	r24, 0x096E
    dce2:	81 30       	cpi	r24, 0x01	; 1
    dce4:	19 f4       	brne	.+6      	; 0xdcec <GSM_Cycle+0x1486>
    dce6:	82 e0       	ldi	r24, 0x02	; 2
    dce8:	80 93 d8 09 	sts	0x09D8, r24
					GSM_State = GSM_DataMode;
    dcec:	87 e5       	ldi	r24, 0x57	; 87
    dcee:	80 93 19 06 	sts	0x0619, r24
					
					if(AppProtocol == 0){
    dcf2:	80 91 d8 09 	lds	r24, 0x09D8
    dcf6:	81 11       	cpse	r24, r1
    dcf8:	1a c0       	rjmp	.+52     	; 0xdd2e <GSM_Cycle+0x14c8>
						if(UART_Soft){
    dcfa:	80 91 59 0a 	lds	r24, 0x0A59
    dcfe:	88 23       	and	r24, r24
    dd00:	21 f0       	breq	.+8      	; 0xdd0a <GSM_Cycle+0x14a4>
							GSM_State = GSM_Swtch2CommandMode;
    dd02:	88 e5       	ldi	r24, 0x58	; 88
    dd04:	80 93 19 06 	sts	0x0619, r24
    dd08:	12 c0       	rjmp	.+36     	; 0xdd2e <GSM_Cycle+0x14c8>
						}
						else{
							EM_InitFIFO();
    dd0a:	0e 94 45 4b 	call	0x968a	; 0x968a <EM_InitFIFO>
							GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End_old;	//     4 
    dd0e:	80 91 3b 02 	lds	r24, 0x023B
    dd12:	80 93 dc 0a 	sts	0x0ADC, r24
							Transparent = 1;
    dd16:	81 e0       	ldi	r24, 0x01	; 1
    dd18:	80 93 5a 0a 	sts	0x0A5A, r24
    dd1c:	8e e0       	ldi	r24, 0x0E	; 14
    dd1e:	91 e0       	ldi	r25, 0x01	; 1
    dd20:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
							StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    dd24:	bc 01       	movw	r22, r24
    dd26:	80 91 51 02 	lds	r24, 0x0251
    dd2a:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					}
					break;
				}
			}//while
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    dd2e:	80 91 51 02 	lds	r24, 0x0251
    dd32:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    dd36:	88 23       	and	r24, r24
    dd38:	09 f4       	brne	.+2      	; 0xdd3c <GSM_Cycle+0x14d6>
    dd3a:	b0 c1       	rjmp	.+864    	; 0xe09c <GSM_Cycle+0x1836>
				GSM_State = GSM_Swtch2CommandMode;
    dd3c:	88 e5       	ldi	r24, 0x58	; 88
    dd3e:	80 93 19 06 	sts	0x0619, r24
				GSM_CloseTransparent();
    dd42:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
    dd46:	aa c1       	rjmp	.+852    	; 0xe09c <GSM_Cycle+0x1836>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    dd48:	90 91 6d 08 	lds	r25, 0x086D
    dd4c:	80 91 f8 05 	lds	r24, 0x05F8
    dd50:	98 17       	cp	r25, r24
    dd52:	49 f0       	breq	.+18     	; 0xdd66 <GSM_Cycle+0x1500>
    dd54:	8e e0       	ldi	r24, 0x0E	; 14
    dd56:	91 e0       	ldi	r25, 0x01	; 1
    dd58:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    dd5c:	bc 01       	movw	r22, r24
    dd5e:	80 91 51 02 	lds	r24, 0x0251
    dd62:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
    dd66:	80 91 d8 09 	lds	r24, 0x09D8
    dd6a:	81 30       	cpi	r24, 0x01	; 1
    dd6c:	71 f1       	breq	.+92     	; 0xddca <GSM_Cycle+0x1564>
				if(GetStringFromFIFO()){
    dd6e:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    dd72:	88 23       	and	r24, r24
    dd74:	51 f1       	breq	.+84     	; 0xddca <GSM_Cycle+0x1564>
								
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    dd76:	67 e3       	ldi	r22, 0x37	; 55
    dd78:	70 e5       	ldi	r23, 0x50	; 80
    dd7a:	8d e6       	ldi	r24, 0x6D	; 109
    dd7c:	99 e0       	ldi	r25, 0x09	; 9
    dd7e:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    dd82:	89 2b       	or	r24, r25
    dd84:	31 f0       	breq	.+12     	; 0xdd92 <GSM_Cycle+0x152c>
						GSM_State = GSM_ServerIdle;
    dd86:	88 e2       	ldi	r24, 0x28	; 40
    dd88:	80 93 19 06 	sts	0x0619, r24
						GSM_CloseTransparent();
    dd8c:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
    dd90:	85 c1       	rjmp	.+778    	; 0xe09c <GSM_Cycle+0x1836>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
    dd92:	6a e1       	ldi	r22, 0x1A	; 26
    dd94:	70 e5       	ldi	r23, 0x50	; 80
    dd96:	8d e6       	ldi	r24, 0x6D	; 109
    dd98:	99 e0       	ldi	r25, 0x09	; 9
    dd9a:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    dd9e:	89 2b       	or	r24, r25
    dda0:	31 f0       	breq	.+12     	; 0xddae <GSM_Cycle+0x1548>
						GSM_State = GSM_ServerIdle;
    dda2:	88 e2       	ldi	r24, 0x28	; 40
    dda4:	80 93 19 06 	sts	0x0619, r24
						GSM_CloseTransparent();
    dda8:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
    ddac:	77 c1       	rjmp	.+750    	; 0xe09c <GSM_Cycle+0x1836>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    ddae:	6a e2       	ldi	r22, 0x2A	; 42
    ddb0:	70 e5       	ldi	r23, 0x50	; 80
    ddb2:	8d e6       	ldi	r24, 0x6D	; 109
    ddb4:	99 e0       	ldi	r25, 0x09	; 9
    ddb6:	0e 94 e0 77 	call	0xefc0	; 0xefc0 <strstr_P>
    ddba:	89 2b       	or	r24, r25
    ddbc:	31 f0       	breq	.+12     	; 0xddca <GSM_Cycle+0x1564>
						GSM_State = GSM_SEND_E0;
    ddbe:	88 e0       	ldi	r24, 0x08	; 8
    ddc0:	80 93 19 06 	sts	0x0619, r24
						GSM_CloseTransparent();
    ddc4:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
    ddc8:	69 c1       	rjmp	.+722    	; 0xe09c <GSM_Cycle+0x1836>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    ddca:	80 91 51 02 	lds	r24, 0x0251
    ddce:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ddd2:	88 23       	and	r24, r24
    ddd4:	09 f4       	brne	.+2      	; 0xddd8 <GSM_Cycle+0x1572>
    ddd6:	62 c1       	rjmp	.+708    	; 0xe09c <GSM_Cycle+0x1836>
				GSM_State = GSM_Swtch2CommandMode;
    ddd8:	88 e5       	ldi	r24, 0x58	; 88
    ddda:	80 93 19 06 	sts	0x0619, r24
				GSM_CloseTransparent();
    ddde:	0e 94 37 4c 	call	0x986e	; 0x986e <GSM_CloseTransparent>
    dde2:	5c c1       	rjmp	.+696    	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}
			break;

		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
    dde4:	6e e6       	ldi	r22, 0x6E	; 110
    dde6:	70 e0       	ldi	r23, 0x00	; 0
    dde8:	80 91 52 02 	lds	r24, 0x0252
    ddec:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			WebClose();
    ddf0:	0e 94 a8 48 	call	0x9150	; 0x9150 <WebClose>
			GSM_State++;
    ddf4:	80 91 19 06 	lds	r24, 0x0619
    ddf8:	8f 5f       	subi	r24, 0xFF	; 255
    ddfa:	80 93 19 06 	sts	0x0619, r24
    ddfe:	4e c1       	rjmp	.+668    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    de00:	80 91 52 02 	lds	r24, 0x0252
    de04:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    de08:	88 23       	and	r24, r24
    de0a:	09 f4       	brne	.+2      	; 0xde0e <GSM_Cycle+0x15a8>
    de0c:	47 c1       	rjmp	.+654    	; 0xe09c <GSM_Cycle+0x1836>
				sprintf_P(GSM_TxStr, ESC_SEQ);
    de0e:	83 eb       	ldi	r24, 0xB3	; 179
    de10:	9f e4       	ldi	r25, 0x4F	; 79
    de12:	9f 93       	push	r25
    de14:	8f 93       	push	r24
    de16:	0c e1       	ldi	r16, 0x1C	; 28
    de18:	1c e0       	ldi	r17, 0x0C	; 12
    de1a:	1f 93       	push	r17
    de1c:	0f 93       	push	r16
    de1e:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
    de22:	f8 01       	movw	r30, r16
    de24:	01 90       	ld	r0, Z+
    de26:	00 20       	and	r0, r0
    de28:	e9 f7       	brne	.-6      	; 0xde24 <GSM_Cycle+0x15be>
    de2a:	31 97       	sbiw	r30, 0x01	; 1
    de2c:	ec 51       	subi	r30, 0x1C	; 28
    de2e:	fc 40       	sbci	r31, 0x0C	; 12
    de30:	e0 93 3c 09 	sts	0x093C, r30
				GSM_SendFirstChar();
    de34:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
    de38:	68 ee       	ldi	r22, 0xE8	; 232
    de3a:	73 e0       	ldi	r23, 0x03	; 3
    de3c:	80 91 52 02 	lds	r24, 0x0252
    de40:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State++;
    de44:	80 91 19 06 	lds	r24, 0x0619
    de48:	8f 5f       	subi	r24, 0xFF	; 255
    de4a:	80 93 19 06 	sts	0x0619, r24
    de4e:	0f 90       	pop	r0
    de50:	0f 90       	pop	r0
    de52:	0f 90       	pop	r0
    de54:	0f 90       	pop	r0
    de56:	22 c1       	rjmp	.+580    	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    de58:	6f e4       	ldi	r22, 0x4F	; 79
    de5a:	87 e1       	ldi	r24, 0x17	; 23
    de5c:	90 e5       	ldi	r25, 0x50	; 80
    de5e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    de62:	88 23       	and	r24, r24
    de64:	09 f4       	brne	.+2      	; 0xde68 <GSM_Cycle+0x1602>
    de66:	1a c1       	rjmp	.+564    	; 0xe09c <GSM_Cycle+0x1836>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    de68:	6f ef       	ldi	r22, 0xFF	; 255
    de6a:	7f ef       	ldi	r23, 0xFF	; 255
    de6c:	80 91 51 02 	lds	r24, 0x0251
    de70:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
    de74:	80 91 31 09 	lds	r24, 0x0931
    de78:	81 30       	cpi	r24, 0x01	; 1
    de7a:	21 f4       	brne	.+8      	; 0xde84 <GSM_Cycle+0x161e>
    de7c:	8e e5       	ldi	r24, 0x5E	; 94
    de7e:	80 93 19 06 	sts	0x0619, r24
    de82:	0c c1       	rjmp	.+536    	; 0xe09c <GSM_Cycle+0x1836>
				else GSM_State = GSM_SEND_CIPCLOSE;
    de84:	88 e3       	ldi	r24, 0x38	; 56
    de86:	80 93 19 06 	sts	0x0619, r24
    de8a:	08 c1       	rjmp	.+528    	; 0xe09c <GSM_Cycle+0x1836>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
    de8c:	80 91 52 02 	lds	r24, 0x0252
    de90:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    de94:	88 23       	and	r24, r24
    de96:	19 f0       	breq	.+6      	; 0xde9e <GSM_Cycle+0x1638>
    de98:	8e e5       	ldi	r24, 0x5E	; 94
    de9a:	80 93 19 06 	sts	0x0619, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    de9e:	8f e5       	ldi	r24, 0x5F	; 95
    dea0:	90 e0       	ldi	r25, 0x00	; 0
    dea2:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
    dea6:	81 11       	cpse	r24, r1
    dea8:	04 c0       	rjmp	.+8      	; 0xdeb2 <GSM_Cycle+0x164c>
				GSM_State = GSM_SEND_ATA;
    deaa:	8c e5       	ldi	r24, 0x5C	; 92
    deac:	80 93 19 06 	sts	0x0619, r24
    deb0:	f5 c0       	rjmp	.+490    	; 0xe09c <GSM_Cycle+0x1836>
				break;
			}
			if(GetStringFromFIFO() > 25){
    deb2:	0e 94 b6 3a 	call	0x756c	; 0x756c <GetStringFromFIFO>
    deb6:	8a 31       	cpi	r24, 0x1A	; 26
    deb8:	08 f4       	brcc	.+2      	; 0xdebc <GSM_Cycle+0x1656>
    deba:	f0 c0       	rjmp	.+480    	; 0xe09c <GSM_Cycle+0x1836>
				char *qoute_open = strchr(GSM_RxStr,'"');
    debc:	62 e2       	ldi	r22, 0x22	; 34
    debe:	70 e0       	ldi	r23, 0x00	; 0
    dec0:	8d e6       	ldi	r24, 0x6D	; 109
    dec2:	99 e0       	ldi	r25, 0x09	; 9
    dec4:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
    dec8:	4c 01       	movw	r8, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
    deca:	62 e2       	ldi	r22, 0x22	; 34
    decc:	70 e0       	ldi	r23, 0x00	; 0
    dece:	01 96       	adiw	r24, 0x01	; 1
    ded0:	0e 94 03 78 	call	0xf006	; 0xf006 <strchr>
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
    ded4:	81 14       	cp	r8, r1
    ded6:	91 04       	cpc	r9, r1
    ded8:	11 f0       	breq	.+4      	; 0xdede <GSM_Cycle+0x1678>
    deda:	00 97       	sbiw	r24, 0x00	; 0
    dedc:	21 f4       	brne	.+8      	; 0xdee6 <GSM_Cycle+0x1680>
					GSM_State = GSM_SEND_ATH;
    dede:	8e e5       	ldi	r24, 0x5E	; 94
    dee0:	80 93 19 06 	sts	0x0619, r24
    dee4:	db c0       	rjmp	.+438    	; 0xe09c <GSM_Cycle+0x1836>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
    dee6:	fc 01       	movw	r30, r24
    dee8:	10 82       	st	Z, r1
    deea:	01 e6       	ldi	r16, 0x61	; 97
    deec:	10 e0       	ldi	r17, 0x00	; 0
				for(uint8_t i = 0; i<10; i++){
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
    deee:	f2 e0       	ldi	r31, 0x02	; 2
    def0:	8f 0e       	add	r8, r31
    def2:	91 1c       	adc	r9, r1
    def4:	be e5       	ldi	r27, 0x5E	; 94
    def6:	7b 2e       	mov	r7, r27
    def8:	b8 01       	movw	r22, r16
    defa:	c4 01       	movw	r24, r8
    defc:	0e 94 cb 47 	call	0x8f96	; 0x8f96 <strcmp_E>
    df00:	88 23       	and	r24, r24
    df02:	49 f0       	breq	.+18     	; 0xdf16 <GSM_Cycle+0x16b0>
    df04:	70 92 19 06 	sts	0x0619, r7
    df08:	03 5f       	subi	r16, 0xF3	; 243
    df0a:	1f 4f       	sbci	r17, 0xFF	; 255
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
    df0c:	20 e0       	ldi	r18, 0x00	; 0
    df0e:	03 3e       	cpi	r16, 0xE3	; 227
    df10:	12 07       	cpc	r17, r18
    df12:	91 f7       	brne	.-28     	; 0xdef8 <GSM_Cycle+0x1692>
    df14:	c3 c0       	rjmp	.+390    	; 0xe09c <GSM_Cycle+0x1836>
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
    df16:	8c e5       	ldi	r24, 0x5C	; 92
    df18:	80 93 19 06 	sts	0x0619, r24
    df1c:	bf c0       	rjmp	.+382    	; 0xe09c <GSM_Cycle+0x1836>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 6000*GSM_DEBUG_DELAY); GSM_State++;
    df1e:	60 e7       	ldi	r22, 0x70	; 112
    df20:	77 e1       	ldi	r23, 0x17	; 23
    df22:	83 e7       	ldi	r24, 0x73	; 115
    df24:	9e e4       	ldi	r25, 0x4E	; 78
    df26:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    df2a:	80 91 19 06 	lds	r24, 0x0619
    df2e:	8f 5f       	subi	r24, 0xFF	; 255
    df30:	80 93 19 06 	sts	0x0619, r24
    df34:	b3 c0       	rjmp	.+358    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
    df36:	6e e5       	ldi	r22, 0x5E	; 94
    df38:	87 eb       	ldi	r24, 0xB7	; 183
    df3a:	9f e4       	ldi	r25, 0x4F	; 79
    df3c:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    df40:	88 23       	and	r24, r24
    df42:	09 f4       	brne	.+2      	; 0xdf46 <GSM_Cycle+0x16e0>
    df44:	ab c0       	rjmp	.+342    	; 0xe09c <GSM_Cycle+0x1836>
				StartTimer16(TD_TCP_Connect, 500);	//   
    df46:	64 ef       	ldi	r22, 0xF4	; 244
    df48:	71 e0       	ldi	r23, 0x01	; 1
    df4a:	80 91 51 02 	lds	r24, 0x0251
    df4e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_CSD = 1;
    df52:	81 e0       	ldi	r24, 0x01	; 1
    df54:	80 93 31 09 	sts	0x0931, r24
				GSM_State = GSM_ProtocolMode;
    df58:	86 e5       	ldi	r24, 0x56	; 86
    df5a:	80 93 19 06 	sts	0x0619, r24
    df5e:	9e c0       	rjmp	.+316    	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
    df60:	6c e2       	ldi	r22, 0x2C	; 44
    df62:	71 e0       	ldi	r23, 0x01	; 1
    df64:	8f e6       	ldi	r24, 0x6F	; 111
    df66:	9e e4       	ldi	r25, 0x4E	; 78
    df68:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    df6c:	80 91 19 06 	lds	r24, 0x0619
    df70:	8f 5f       	subi	r24, 0xFF	; 255
    df72:	80 93 19 06 	sts	0x0619, r24
    df76:	92 c0       	rjmp	.+292    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    df78:	6f e4       	ldi	r22, 0x4F	; 79
    df7a:	87 e1       	ldi	r24, 0x17	; 23
    df7c:	90 e5       	ldi	r25, 0x50	; 80
    df7e:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    df82:	88 23       	and	r24, r24
    df84:	09 f4       	brne	.+2      	; 0xdf88 <GSM_Cycle+0x1722>
    df86:	8a c0       	rjmp	.+276    	; 0xe09c <GSM_Cycle+0x1836>
    df88:	88 e2       	ldi	r24, 0x28	; 40
    df8a:	80 93 19 06 	sts	0x0619, r24
    df8e:	86 c0       	rjmp	.+268    	; 0xe09c <GSM_Cycle+0x1836>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    df90:	80 91 19 06 	lds	r24, 0x0619
    df94:	90 e0       	ldi	r25, 0x00	; 0
    df96:	89 30       	cpi	r24, 0x09	; 9
    df98:	91 05       	cpc	r25, r1
    df9a:	08 f0       	brcs	.+2      	; 0xdf9e <GSM_Cycle+0x1738>
    df9c:	7d c0       	rjmp	.+250    	; 0xe098 <GSM_Cycle+0x1832>
    df9e:	fc 01       	movw	r30, r24
    dfa0:	e9 5c       	subi	r30, 0xC9	; 201
    dfa2:	fe 4f       	sbci	r31, 0xFE	; 254
    dfa4:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    dfa8:	68 ec       	ldi	r22, 0xC8	; 200
    dfaa:	70 e0       	ldi	r23, 0x00	; 0
    dfac:	80 91 52 02 	lds	r24, 0x0252
    dfb0:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
			GSM_PWRCNTRL_ON();
    dfb4:	0e 94 20 2f 	call	0x5e40	; 0x5e40 <GSM_PWRCNTRL_ON>
			GSM_State++;
    dfb8:	80 91 19 06 	lds	r24, 0x0619
    dfbc:	8f 5f       	subi	r24, 0xFF	; 255
    dfbe:	80 93 19 06 	sts	0x0619, r24
    dfc2:	6c c0       	rjmp	.+216    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    dfc4:	80 91 52 02 	lds	r24, 0x0252
    dfc8:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    dfcc:	88 23       	and	r24, r24
    dfce:	31 f0       	breq	.+12     	; 0xdfdc <GSM_Cycle+0x1776>
    dfd0:	64 e6       	ldi	r22, 0x64	; 100
    dfd2:	70 e0       	ldi	r23, 0x00	; 0
    dfd4:	80 eb       	ldi	r24, 0xB0	; 176
    dfd6:	9f e4       	ldi	r25, 0x4F	; 79
    dfd8:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    dfdc:	80 91 19 06 	lds	r24, 0x0619
    dfe0:	8f 5f       	subi	r24, 0xFF	; 255
    dfe2:	80 93 19 06 	sts	0x0619, r24
    dfe6:	5a c0       	rjmp	.+180    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    dfe8:	61 e0       	ldi	r22, 0x01	; 1
    dfea:	87 e1       	ldi	r24, 0x17	; 23
    dfec:	90 e5       	ldi	r25, 0x50	; 80
    dfee:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    dff2:	88 23       	and	r24, r24
    dff4:	09 f4       	brne	.+2      	; 0xdff8 <GSM_Cycle+0x1792>
    dff6:	52 c0       	rjmp	.+164    	; 0xe09c <GSM_Cycle+0x1836>
    dff8:	80 91 19 06 	lds	r24, 0x0619
    dffc:	8f 5f       	subi	r24, 0xFF	; 255
    dffe:	80 93 19 06 	sts	0x0619, r24
    e002:	4c c0       	rjmp	.+152    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    e004:	64 e6       	ldi	r22, 0x64	; 100
    e006:	70 e0       	ldi	r23, 0x00	; 0
    e008:	84 ea       	ldi	r24, 0xA4	; 164
    e00a:	9f e4       	ldi	r25, 0x4F	; 79
    e00c:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    e010:	80 91 19 06 	lds	r24, 0x0619
    e014:	8f 5f       	subi	r24, 0xFF	; 255
    e016:	80 93 19 06 	sts	0x0619, r24
    e01a:	40 c0       	rjmp	.+128    	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    e01c:	61 e0       	ldi	r22, 0x01	; 1
    e01e:	87 e1       	ldi	r24, 0x17	; 23
    e020:	90 e5       	ldi	r25, 0x50	; 80
    e022:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    e026:	88 23       	and	r24, r24
    e028:	c9 f1       	breq	.+114    	; 0xe09c <GSM_Cycle+0x1836>
				StartTimer16(TD_GSM,200);
    e02a:	68 ec       	ldi	r22, 0xC8	; 200
    e02c:	70 e0       	ldi	r23, 0x00	; 0
    e02e:	80 91 52 02 	lds	r24, 0x0252
    e032:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State++;
    e036:	80 91 19 06 	lds	r24, 0x0619
    e03a:	8f 5f       	subi	r24, 0xFF	; 255
    e03c:	80 93 19 06 	sts	0x0619, r24
    e040:	2d c0       	rjmp	.+90     	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    e042:	64 e6       	ldi	r22, 0x64	; 100
    e044:	70 e0       	ldi	r23, 0x00	; 0
    e046:	8f e9       	ldi	r24, 0x9F	; 159
    e048:	9f e4       	ldi	r25, 0x4F	; 79
    e04a:	0e 94 ff 63 	call	0xc7fe	; 0xc7fe <GSM_Execute_Command>
    e04e:	80 91 19 06 	lds	r24, 0x0619
    e052:	8f 5f       	subi	r24, 0xFF	; 255
    e054:	80 93 19 06 	sts	0x0619, r24
    e058:	21 c0       	rjmp	.+66     	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    e05a:	61 e0       	ldi	r22, 0x01	; 1
    e05c:	87 e1       	ldi	r24, 0x17	; 23
    e05e:	90 e5       	ldi	r25, 0x50	; 80
    e060:	0e 94 6c 3b 	call	0x76d8	; 0x76d8 <GSM_Wait_Response_P>
    e064:	88 23       	and	r24, r24
    e066:	d1 f0       	breq	.+52     	; 0xe09c <GSM_Cycle+0x1836>
				StartTimer16(TD_GSM,200);
    e068:	68 ec       	ldi	r22, 0xC8	; 200
    e06a:	70 e0       	ldi	r23, 0x00	; 0
    e06c:	80 91 52 02 	lds	r24, 0x0252
    e070:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				GSM_State++;
    e074:	80 91 19 06 	lds	r24, 0x0619
    e078:	8f 5f       	subi	r24, 0xFF	; 255
    e07a:	80 93 19 06 	sts	0x0619, r24
    e07e:	0e c0       	rjmp	.+28     	; 0xe09c <GSM_Cycle+0x1836>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    e080:	80 91 52 02 	lds	r24, 0x0252
    e084:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    e088:	88 23       	and	r24, r24
    e08a:	41 f0       	breq	.+16     	; 0xe09c <GSM_Cycle+0x1836>
    e08c:	80 91 19 06 	lds	r24, 0x0619
    e090:	8f 5f       	subi	r24, 0xFF	; 255
    e092:	80 93 19 06 	sts	0x0619, r24
    e096:	02 c0       	rjmp	.+4      	; 0xe09c <GSM_Cycle+0x1836>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    e098:	10 92 19 06 	sts	0x0619, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
    e09c:	80 91 19 06 	lds	r24, 0x0619
    e0a0:	8f 34       	cpi	r24, 0x4F	; 79
    e0a2:	41 f0       	breq	.+16     	; 0xe0b4 <GSM_Cycle+0x184e>
    e0a4:	80 91 19 06 	lds	r24, 0x0619
    e0a8:	80 35       	cpi	r24, 0x50	; 80
    e0aa:	21 f0       	breq	.+8      	; 0xe0b4 <GSM_Cycle+0x184e>
    e0ac:	80 91 19 06 	lds	r24, 0x0619
    e0b0:	80 93 40 09 	sts	0x0940, r24
}
    e0b4:	2e 96       	adiw	r28, 0x0e	; 14
    e0b6:	0f b6       	in	r0, 0x3f	; 63
    e0b8:	f8 94       	cli
    e0ba:	de bf       	out	0x3e, r29	; 62
    e0bc:	0f be       	out	0x3f, r0	; 63
    e0be:	cd bf       	out	0x3d, r28	; 61
    e0c0:	df 91       	pop	r29
    e0c2:	cf 91       	pop	r28
    e0c4:	1f 91       	pop	r17
    e0c6:	0f 91       	pop	r16
    e0c8:	ff 90       	pop	r15
    e0ca:	ef 90       	pop	r14
    e0cc:	df 90       	pop	r13
    e0ce:	cf 90       	pop	r12
    e0d0:	bf 90       	pop	r11
    e0d2:	af 90       	pop	r10
    e0d4:	9f 90       	pop	r9
    e0d6:	8f 90       	pop	r8
    e0d8:	7f 90       	pop	r7
    e0da:	6f 90       	pop	r6
    e0dc:	5f 90       	pop	r5
    e0de:	4f 90       	pop	r4
    e0e0:	3f 90       	pop	r3
    e0e2:	2f 90       	pop	r2
    e0e4:	08 95       	ret

0000e0e6 <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
    e0e6:	80 91 59 0a 	lds	r24, 0x0A59
    e0ea:	88 23       	and	r24, r24
    e0ec:	b9 f0       	breq	.+46     	; 0xe11c <USART_Cycle+0x36>

		if(ModbusMode) MB_Cycle();
    e0ee:	80 91 d8 03 	lds	r24, 0x03D8
    e0f2:	81 11       	cpse	r24, r1
    e0f4:	0e 94 ec 39 	call	0x73d8	; 0x73d8 <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
    e0f8:	c8 9b       	sbis	0x19, 0	; 25
    e0fa:	29 c0       	rjmp	.+82     	; 0xe14e <USART_Cycle+0x68>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
    e0fc:	80 91 32 09 	lds	r24, 0x0932
    e100:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    e104:	88 23       	and	r24, r24
    e106:	41 f1       	breq	.+80     	; 0xe158 <USART_Cycle+0x72>
				cli();
    e108:	f8 94       	cli
				EMeter_ReInit();
    e10a:	0e 94 10 4c 	call	0x9820	; 0x9820 <EMeter_ReInit>
				UART_Soft = 0;
    e10e:	10 92 59 0a 	sts	0x0A59, r1
				ModbusMode = 0;				
    e112:	10 92 d8 03 	sts	0x03D8, r1
				GSM_DebugMode = 0;	
    e116:	10 92 d6 09 	sts	0x09D6, r1
    e11a:	17 c0       	rjmp	.+46     	; 0xe14a <USART_Cycle+0x64>
				sei();
			}
		}
	}
	else{
		EMeter_Cycle();
    e11c:	0e 94 8a 51 	call	0xa314	; 0xa314 <EMeter_Cycle>
		if(!(PINA & (1<<PA0))){
    e120:	c8 99       	sbic	0x19, 0	; 25
    e122:	15 c0       	rjmp	.+42     	; 0xe14e <USART_Cycle+0x68>
			if(Timer8Stopp(TD_UART_Soft)){
    e124:	80 91 32 09 	lds	r24, 0x0932
    e128:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    e12c:	88 23       	and	r24, r24
    e12e:	a1 f0       	breq	.+40     	; 0xe158 <USART_Cycle+0x72>
				if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
    e130:	80 91 5a 0a 	lds	r24, 0x0A5A
    e134:	81 11       	cpse	r24, r1
    e136:	0e 94 47 4c 	call	0x988e	; 0x988e <GSM_Transparent2Modbus>
				cli();
    e13a:	f8 94       	cli
				MB_Init();
    e13c:	0e 94 e6 35 	call	0x6bcc	; 0x6bcc <MB_Init>
				UART_Soft = 1;
    e140:	81 e0       	ldi	r24, 0x01	; 1
    e142:	80 93 59 0a 	sts	0x0A59, r24
				ModbusMode = 1;
    e146:	80 93 d8 03 	sts	0x03D8, r24
				sei();
    e14a:	78 94       	sei
    e14c:	05 c0       	rjmp	.+10     	; 0xe158 <USART_Cycle+0x72>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
    e14e:	6a e0       	ldi	r22, 0x0A	; 10
    e150:	80 91 32 09 	lds	r24, 0x0932
    e154:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
    e158:	0c 94 33 64 	jmp	0xc866	; 0xc866 <GSM_Cycle>

0000e15c <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    e15c:	2f 92       	push	r2
    e15e:	3f 92       	push	r3
    e160:	4f 92       	push	r4
    e162:	5f 92       	push	r5
    e164:	6f 92       	push	r6
    e166:	7f 92       	push	r7
    e168:	8f 92       	push	r8
    e16a:	9f 92       	push	r9
    e16c:	af 92       	push	r10
    e16e:	bf 92       	push	r11
    e170:	cf 92       	push	r12
    e172:	df 92       	push	r13
    e174:	ef 92       	push	r14
    e176:	ff 92       	push	r15
    e178:	0f 93       	push	r16
    e17a:	1f 93       	push	r17
    e17c:	cf 93       	push	r28
    e17e:	df 93       	push	r29
    e180:	cd b7       	in	r28, 0x3d	; 61
    e182:	de b7       	in	r29, 0x3e	; 62
    e184:	2c 97       	sbiw	r28, 0x0c	; 12
    e186:	0f b6       	in	r0, 0x3f	; 63
    e188:	f8 94       	cli
    e18a:	de bf       	out	0x3e, r29	; 62
    e18c:	0f be       	out	0x3f, r0	; 63
    e18e:	cd bf       	out	0x3d, r28	; 61
    e190:	8c 01       	movw	r16, r24
    e192:	b6 2e       	mov	r11, r22
	}
	else{
		StartTimeoutWaitRequest = 0;
	}

}
    e194:	2d b6       	in	r2, 0x3d	; 61
    e196:	3e b6       	in	r3, 0x3e	; 62
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	//static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    e198:	f0 90 0e 06 	lds	r15, 0x060E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    e19c:	0e 94 8f 2a 	call	0x551e	; 0x551e <IntOff>
	uint32_t Time = Timer32[TimerN];
    e1a0:	24 e0       	ldi	r18, 0x04	; 4
    e1a2:	f2 9e       	mul	r15, r18
    e1a4:	f0 01       	movw	r30, r0
    e1a6:	11 24       	eor	r1, r1
    e1a8:	e2 58       	subi	r30, 0x82	; 130
    e1aa:	fd 4f       	sbci	r31, 0xFD	; 253
    e1ac:	c0 80       	ld	r12, Z
    e1ae:	d1 80       	ldd	r13, Z+1	; 0x01
    e1b0:	e2 80       	ldd	r14, Z+2	; 0x02
    e1b2:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    e1b4:	0e 94 97 2a 	call	0x552e	; 0x552e <IntOn>
    e1b8:	38 ec       	ldi	r19, 0xC8	; 200
    e1ba:	c3 16       	cp	r12, r19
    e1bc:	d1 04       	cpc	r13, r1
    e1be:	e1 04       	cpc	r14, r1
    e1c0:	f1 04       	cpc	r15, r1
    e1c2:	38 f4       	brcc	.+14     	; 0xe1d2 <WebServer+0x76>
    e1c4:	4f ef       	ldi	r20, 0xFF	; 255
    e1c6:	5f ef       	ldi	r21, 0xFF	; 255
    e1c8:	ba 01       	movw	r22, r20
    e1ca:	80 91 0e 06 	lds	r24, 0x060E
    e1ce:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    e1d2:	80 91 4c 09 	lds	r24, 0x094C
    e1d6:	0e 94 dc 2c 	call	0x59b8	; 0x59b8 <Timer32Stopp>
    e1da:	81 11       	cpse	r24, r1
    e1dc:	10 92 62 09 	sts	0x0962, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    e1e0:	80 91 19 06 	lds	r24, 0x0619
    e1e4:	87 35       	cpi	r24, 0x57	; 87
    e1e6:	09 f0       	breq	.+2      	; 0xe1ea <WebServer+0x8e>
    e1e8:	e1 c3       	rjmp	.+1986   	; 0xe9ac <WebServer+0x850>
    e1ea:	80 91 d8 09 	lds	r24, 0x09D8
    e1ee:	81 30       	cpi	r24, 0x01	; 1
    e1f0:	09 f0       	breq	.+2      	; 0xe1f4 <WebServer+0x98>
    e1f2:	dc c3       	rjmp	.+1976   	; 0xe9ac <WebServer+0x850>
		
		// 
		if(WebMode == 254){
    e1f4:	80 91 06 01 	lds	r24, 0x0106
    e1f8:	8e 3f       	cpi	r24, 0xFE	; 254
    e1fa:	71 f5       	brne	.+92     	; 0xe258 <WebServer+0xfc>
			ptrPage = WebRequest(ptrSite, SiteSize);
    e1fc:	6b 2d       	mov	r22, r11
    e1fe:	c8 01       	movw	r24, r16
    e200:	0e 94 39 49 	call	0x9272	; 0x9272 <WebRequest>
    e204:	90 93 37 02 	sts	0x0237, r25
    e208:	80 93 36 02 	sts	0x0236, r24
			if(ptrPage != NULL){
    e20c:	89 2b       	or	r24, r25
    e20e:	41 f0       	breq	.+16     	; 0xe220 <WebServer+0xc4>
				WebMode = 255;
    e210:	8f ef       	ldi	r24, 0xFF	; 255
    e212:	80 93 06 01 	sts	0x0106, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    e216:	64 e1       	ldi	r22, 0x14	; 20
    e218:	80 91 2a 09 	lds	r24, 0x092A
    e21c:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    e220:	80 91 35 02 	lds	r24, 0x0235
    e224:	88 23       	and	r24, r24
    e226:	79 f0       	breq	.+30     	; 0xe246 <WebServer+0xea>
				if(Timer16Stopp(TD_WaitReqTimout)){
    e228:	80 91 4e 09 	lds	r24, 0x094E
    e22c:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    e230:	88 23       	and	r24, r24
    e232:	91 f0       	breq	.+36     	; 0xe258 <WebServer+0xfc>
					GSM_State = GSM_Swtch2CommandMode;
    e234:	88 e5       	ldi	r24, 0x58	; 88
    e236:	80 93 19 06 	sts	0x0619, r24
					Web_POST = 0;
    e23a:	10 92 51 09 	sts	0x0951, r1
					WebMode = 254;
    e23e:	8e ef       	ldi	r24, 0xFE	; 254
    e240:	80 93 06 01 	sts	0x0106, r24
					return;				
    e244:	b5 c3       	rjmp	.+1898   	; 0xe9b0 <WebServer+0x854>
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    e246:	68 ee       	ldi	r22, 0xE8	; 232
    e248:	73 e0       	ldi	r23, 0x03	; 3
    e24a:	80 91 4e 09 	lds	r24, 0x094E
    e24e:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				StartTimeoutWaitRequest = 1;
    e252:	81 e0       	ldi	r24, 0x01	; 1
    e254:	80 93 35 02 	sts	0x0235, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    e258:	80 91 08 01 	lds	r24, 0x0108
    e25c:	80 ff       	sbrs	r24, 0
    e25e:	a8 c3       	rjmp	.+1872   	; 0xe9b0 <WebServer+0x854>
    e260:	80 91 35 09 	lds	r24, 0x0935
    e264:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    e268:	88 23       	and	r24, r24
    e26a:	09 f4       	brne	.+2      	; 0xe26e <WebServer+0x112>
    e26c:	a1 c3       	rjmp	.+1858   	; 0xe9b0 <WebServer+0x854>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    e26e:	80 91 06 01 	lds	r24, 0x0106
    e272:	8f 3f       	cpi	r24, 0xFF	; 255
    e274:	39 f4       	brne	.+14     	; 0xe284 <WebServer+0x128>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    e276:	80 91 2a 09 	lds	r24, 0x092A
    e27a:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    e27e:	81 11       	cpse	r24, r1
					WebMode = 0;
    e280:	10 92 06 01 	sts	0x0106, r1
				}
			}

			// 
			if(WebMode == 2){
    e284:	80 91 06 01 	lds	r24, 0x0106
    e288:	82 30       	cpi	r24, 0x02	; 2
    e28a:	59 f4       	brne	.+22     	; 0xe2a2 <WebServer+0x146>
				GSM_State = GSM_Swtch2CommandMode;
    e28c:	88 e5       	ldi	r24, 0x58	; 88
    e28e:	80 93 19 06 	sts	0x0619, r24
				WebMode = 254;
    e292:	8e ef       	ldi	r24, 0xFE	; 254
    e294:	80 93 06 01 	sts	0x0106, r24
				Web_Login_Code = 0;
    e298:	10 92 fc 05 	sts	0x05FC, r1
				Web_POST = 0;
    e29c:	10 92 51 09 	sts	0x0951, r1
				return;
    e2a0:	87 c3       	rjmp	.+1806   	; 0xe9b0 <WebServer+0x854>
			}
			
			//   
			if(WebMode == 0){
    e2a2:	81 11       	cpse	r24, r1
    e2a4:	df c0       	rjmp	.+446    	; 0xe464 <WebServer+0x308>
				//Not Found
				if(ptrPage == &Web_error_page){
    e2a6:	80 91 36 02 	lds	r24, 0x0236
    e2aa:	90 91 37 02 	lds	r25, 0x0237
    e2ae:	8e 5e       	subi	r24, 0xEE	; 238
    e2b0:	9c 44       	sbci	r25, 0x4C	; 76
    e2b2:	b9 f4       	brne	.+46     	; 0xe2e2 <WebServer+0x186>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    e2b4:	44 e7       	ldi	r20, 0x74	; 116
    e2b6:	50 e0       	ldi	r21, 0x00	; 0
    e2b8:	6b ef       	ldi	r22, 0xFB	; 251
    e2ba:	7c e4       	ldi	r23, 0x4C	; 76
    e2bc:	8c e1       	ldi	r24, 0x1C	; 28
    e2be:	9c e0       	ldi	r25, 0x0C	; 12
    e2c0:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    e2c4:	84 e7       	ldi	r24, 0x74	; 116
    e2c6:	80 93 3c 09 	sts	0x093C, r24
					GSM_SendFirstChar();
    e2ca:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    e2ce:	68 ec       	ldi	r22, 0xC8	; 200
    e2d0:	70 e0       	ldi	r23, 0x00	; 0
    e2d2:	80 91 35 09 	lds	r24, 0x0935
    e2d6:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
					WebMode = 2;
    e2da:	82 e0       	ldi	r24, 0x02	; 2
    e2dc:	80 93 06 01 	sts	0x0106, r24
    e2e0:	c1 c0       	rjmp	.+386    	; 0xe464 <WebServer+0x308>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    e2e2:	41 e1       	ldi	r20, 0x11	; 17
    e2e4:	50 e0       	ldi	r21, 0x00	; 0
    e2e6:	67 e1       	ldi	r22, 0x17	; 23
    e2e8:	7e e4       	ldi	r23, 0x4E	; 78
    e2ea:	8c e1       	ldi	r24, 0x1C	; 28
    e2ec:	9c e0       	ldi	r25, 0x0C	; 12
    e2ee:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    e2f2:	4e e0       	ldi	r20, 0x0E	; 14
    e2f4:	50 e0       	ldi	r21, 0x00	; 0
    e2f6:	68 e0       	ldi	r22, 0x08	; 8
    e2f8:	7e e4       	ldi	r23, 0x4E	; 78
    e2fa:	8d e2       	ldi	r24, 0x2D	; 45
    e2fc:	9c e0       	ldi	r25, 0x0C	; 12
    e2fe:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e302:	e0 91 36 02 	lds	r30, 0x0236
    e306:	f0 91 37 02 	lds	r31, 0x0237
    e30a:	85 91       	lpm	r24, Z+
    e30c:	94 91       	lpm	r25, Z
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    e30e:	6e e2       	ldi	r22, 0x2E	; 46
    e310:	70 e0       	ldi	r23, 0x00	; 0
    e312:	0e 94 9a 77 	call	0xef34	; 0xef34 <strchr_P>
					if(ext_point_ptr){ 
    e316:	00 97       	sbiw	r24, 0x00	; 0
    e318:	09 f4       	brne	.+2      	; 0xe31c <WebServer+0x1c0>
    e31a:	89 c0       	rjmp	.+274    	; 0xe42e <WebServer+0x2d2>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    e31c:	7c 01       	movw	r14, r24
    e31e:	5f ef       	ldi	r21, 0xFF	; 255
    e320:	e5 1a       	sub	r14, r21
    e322:	f5 0a       	sbc	r15, r21
    e324:	b7 01       	movw	r22, r14
    e326:	87 ec       	ldi	r24, 0xC7	; 199
    e328:	9d e4       	ldi	r25, 0x4D	; 77
    e32a:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <strcmp_PP>
    e32e:	81 11       	cpse	r24, r1
    e330:	0b c0       	rjmp	.+22     	; 0xe348 <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    e332:	41 e2       	ldi	r20, 0x21	; 33
    e334:	50 e0       	ldi	r21, 0x00	; 0
    e336:	63 ed       	ldi	r22, 0xD3	; 211
    e338:	7d e4       	ldi	r23, 0x4D	; 77
    e33a:	8b e3       	ldi	r24, 0x3B	; 59
    e33c:	9c e0       	ldi	r25, 0x0C	; 12
    e33e:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
							i += sizeof(html_cp1251_str)-1;
    e342:	00 e4       	ldi	r16, 0x40	; 64
    e344:	10 e0       	ldi	r17, 0x00	; 0
    e346:	67 c0       	rjmp	.+206    	; 0xe416 <WebServer+0x2ba>
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    e348:	46 e0       	ldi	r20, 0x06	; 6
    e34a:	50 e0       	ldi	r21, 0x00	; 0
    e34c:	6c ec       	ldi	r22, 0xCC	; 204
    e34e:	7d e4       	ldi	r23, 0x4D	; 77
    e350:	8b e3       	ldi	r24, 0x3B	; 59
    e352:	9c e0       	ldi	r25, 0x0C	; 12
    e354:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    e358:	b7 01       	movw	r22, r14
    e35a:	83 ec       	ldi	r24, 0xC3	; 195
    e35c:	9d e4       	ldi	r25, 0x4D	; 77
    e35e:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <strcmp_PP>
    e362:	81 11       	cpse	r24, r1
    e364:	0b c0       	rjmp	.+22     	; 0xe37c <WebServer+0x220>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    e366:	43 e0       	ldi	r20, 0x03	; 3
    e368:	50 e0       	ldi	r21, 0x00	; 0
    e36a:	63 ec       	ldi	r22, 0xC3	; 195
    e36c:	7d e4       	ldi	r23, 0x4D	; 77
    e36e:	81 e4       	ldi	r24, 0x41	; 65
    e370:	9c e0       	ldi	r25, 0x0C	; 12
    e372:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
								i += sizeof(ico_str)-1;
    e376:	08 e2       	ldi	r16, 0x28	; 40
    e378:	10 e0       	ldi	r17, 0x00	; 0
    e37a:	02 c0       	rjmp	.+4      	; 0xe380 <WebServer+0x224>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
							i += sizeof(image_str)-1;
    e37c:	05 e2       	ldi	r16, 0x25	; 37
    e37e:	10 e0       	ldi	r17, 0x00	; 0
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    e380:	b7 01       	movw	r22, r14
    e382:	8f eb       	ldi	r24, 0xBF	; 191
    e384:	9d e4       	ldi	r25, 0x4D	; 77
    e386:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <strcmp_PP>
    e38a:	81 11       	cpse	r24, r1
    e38c:	0b c0       	rjmp	.+22     	; 0xe3a4 <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    e38e:	43 e0       	ldi	r20, 0x03	; 3
    e390:	50 e0       	ldi	r21, 0x00	; 0
    e392:	6f eb       	ldi	r22, 0xBF	; 191
    e394:	7d e4       	ldi	r23, 0x4D	; 77
    e396:	c8 01       	movw	r24, r16
    e398:	84 5e       	subi	r24, 0xE4	; 228
    e39a:	93 4f       	sbci	r25, 0xF3	; 243
    e39c:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
								i += sizeof(gif_str)-1;								
    e3a0:	0d 5f       	subi	r16, 0xFD	; 253
    e3a2:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    e3a4:	b7 01       	movw	r22, r14
    e3a6:	8a eb       	ldi	r24, 0xBA	; 186
    e3a8:	9d e4       	ldi	r25, 0x4D	; 77
    e3aa:	0e 94 ad 47 	call	0x8f5a	; 0x8f5a <strcmp_PP>
    e3ae:	81 11       	cpse	r24, r1
    e3b0:	0b c0       	rjmp	.+22     	; 0xe3c8 <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    e3b2:	44 e0       	ldi	r20, 0x04	; 4
    e3b4:	50 e0       	ldi	r21, 0x00	; 0
    e3b6:	6a eb       	ldi	r22, 0xBA	; 186
    e3b8:	7d e4       	ldi	r23, 0x4D	; 77
    e3ba:	c8 01       	movw	r24, r16
    e3bc:	84 5e       	subi	r24, 0xE4	; 228
    e3be:	93 4f       	sbci	r25, 0xF3	; 243
    e3c0:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    e3c4:	0c 5f       	subi	r16, 0xFC	; 252
    e3c6:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    e3c8:	42 e1       	ldi	r20, 0x12	; 18
    e3ca:	50 e0       	ldi	r21, 0x00	; 0
    e3cc:	65 ef       	ldi	r22, 0xF5	; 245
    e3ce:	7d e4       	ldi	r23, 0x4D	; 77
    e3d0:	c8 01       	movw	r24, r16
    e3d2:	84 5e       	subi	r24, 0xE4	; 228
    e3d4:	93 4f       	sbci	r25, 0xF3	; 243
    e3d6:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
							i += sizeof(Content_Length)-1;
    e3da:	0e 5e       	subi	r16, 0xEE	; 238
    e3dc:	1f 4f       	sbci	r17, 0xFF	; 255
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    e3de:	e0 91 36 02 	lds	r30, 0x0236
    e3e2:	f0 91 37 02 	lds	r31, 0x0237
    e3e6:	38 96       	adiw	r30, 0x08	; 8

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    e3e8:	85 91       	lpm	r24, Z+
    e3ea:	94 91       	lpm	r25, Z
    e3ec:	9f 93       	push	r25
    e3ee:	8f 93       	push	r24
    e3f0:	8b e2       	ldi	r24, 0x2B	; 43
    e3f2:	93 e0       	ldi	r25, 0x03	; 3
    e3f4:	9f 93       	push	r25
    e3f6:	8f 93       	push	r24
    e3f8:	c8 01       	movw	r24, r16
    e3fa:	84 5e       	subi	r24, 0xE4	; 228
    e3fc:	93 4f       	sbci	r25, 0xF3	; 243
    e3fe:	9f 93       	push	r25
    e400:	8f 93       	push	r24
    e402:	0e 94 5b 78 	call	0xf0b6	; 0xf0b6 <sprintf_P>
    e406:	08 0f       	add	r16, r24
    e408:	19 1f       	adc	r17, r25
    e40a:	0f 90       	pop	r0
    e40c:	0f 90       	pop	r0
    e40e:	0f 90       	pop	r0
    e410:	0f 90       	pop	r0
    e412:	0f 90       	pop	r0
    e414:	0f 90       	pop	r0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    e416:	45 e1       	ldi	r20, 0x15	; 21
    e418:	50 e0       	ldi	r21, 0x00	; 0
    e41a:	64 ea       	ldi	r22, 0xA4	; 164
    e41c:	7d e4       	ldi	r23, 0x4D	; 77
    e41e:	c8 01       	movw	r24, r16
    e420:	84 5e       	subi	r24, 0xE4	; 228
    e422:	93 4f       	sbci	r25, 0xF3	; 243
    e424:	0e 94 91 77 	call	0xef22	; 0xef22 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    e428:	0b 5e       	subi	r16, 0xEB	; 235
    e42a:	1f 4f       	sbci	r17, 0xFF	; 255
    e42c:	02 c0       	rjmp	.+4      	; 0xe432 <WebServer+0x2d6>
					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
					i += sizeof(Content_Type)-1;
    e42e:	0f e1       	ldi	r16, 0x1F	; 31
    e430:	10 e0       	ldi	r17, 0x00	; 0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
						i += sizeof(Connection_Close)-1;

					}
					WebDataCnt = 0;
    e432:	10 92 e9 03 	sts	0x03E9, r1
    e436:	10 92 e8 03 	sts	0x03E8, r1
					WebInputHiddenCnt = 0;
    e43a:	10 92 e1 03 	sts	0x03E1, r1
					WebHrefHiddenCnt = 0;
    e43e:	10 92 1a 06 	sts	0x061A, r1
					WebImgSrcHiddenCnt = 0;
    e442:	10 92 e0 03 	sts	0x03E0, r1
					ptrIF = prp(&ptrPage->IF_List);
    e446:	e0 91 36 02 	lds	r30, 0x0236
    e44a:	f0 91 37 02 	lds	r31, 0x0237
    e44e:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e450:	85 91       	lpm	r24, Z+
    e452:	94 91       	lpm	r25, Z
    e454:	90 93 34 02 	sts	0x0234, r25
    e458:	80 93 33 02 	sts	0x0233, r24
					WebMode = 1;
    e45c:	81 e0       	ldi	r24, 0x01	; 1
    e45e:	80 93 06 01 	sts	0x0106, r24
    e462:	02 c0       	rjmp	.+4      	; 0xe468 <WebServer+0x30c>


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){

			uint16_t i=0;
    e464:	00 e0       	ldi	r16, 0x00	; 0
    e466:	10 e0       	ldi	r17, 0x00	; 0
					WebMode = 1;
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    e468:	80 91 06 01 	lds	r24, 0x0106
    e46c:	81 30       	cpi	r24, 0x01	; 1
    e46e:	09 f0       	breq	.+2      	; 0xe472 <WebServer+0x316>
    e470:	9f c2       	rjmp	.+1342   	; 0xe9b0 <WebServer+0x854>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    e472:	bb 24       	eor	r11, r11
    e474:	b3 94       	inc	r11
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    e476:	0f 3f       	cpi	r16, 0xFF	; 255
    e478:	11 05       	cpc	r17, r1
    e47a:	08 f0       	brcs	.+2      	; 0xe47e <WebServer+0x322>
    e47c:	b0 c0       	rjmp	.+352    	; 0xe5de <WebServer+0x482>
					char ch;
					if(WebImgSrcHiddenCnt){
    e47e:	80 91 e0 03 	lds	r24, 0x03E0
    e482:	c0 90 36 02 	lds	r12, 0x0236
    e486:	d0 90 37 02 	lds	r13, 0x0237
    e48a:	88 23       	and	r24, r24
    e48c:	a1 f0       	breq	.+40     	; 0xe4b6 <WebServer+0x35a>
    e48e:	e8 2f       	mov	r30, r24
    e490:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    e492:	89 30       	cpi	r24, 0x09	; 9
    e494:	20 f0       	brcs	.+8      	; 0xe49e <WebServer+0x342>
    e496:	ee 5e       	subi	r30, 0xEE	; 238
    e498:	f9 4f       	sbci	r31, 0xF9	; 249
    e49a:	a0 80       	ld	r10, Z
    e49c:	03 c0       	rjmp	.+6      	; 0xe4a4 <WebServer+0x348>
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
    e49e:	e1 59       	subi	r30, 0x91	; 145
    e4a0:	f2 4b       	sbci	r31, 0xB2	; 178

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e4a2:	a4 90       	lpm	r10, Z
						WebImgSrcHiddenCnt++ ;
    e4a4:	8f 5f       	subi	r24, 0xFF	; 255
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    e4a6:	89 31       	cpi	r24, 0x19	; 25
    e4a8:	18 f4       	brcc	.+6      	; 0xe4b0 <WebServer+0x354>
					char ch;
					if(WebImgSrcHiddenCnt){
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    e4aa:	80 93 e0 03 	sts	0x03E0, r24
    e4ae:	46 c0       	rjmp	.+140    	; 0xe53c <WebServer+0x3e0>
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    e4b0:	10 92 e0 03 	sts	0x03E0, r1
    e4b4:	43 c0       	rjmp	.+134    	; 0xe53c <WebServer+0x3e0>
					}
					else{
						if(WebHrefHiddenCnt){
    e4b6:	80 91 1a 06 	lds	r24, 0x061A
    e4ba:	88 23       	and	r24, r24
    e4bc:	a1 f0       	breq	.+40     	; 0xe4e6 <WebServer+0x38a>
    e4be:	e8 2f       	mov	r30, r24
    e4c0:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    e4c2:	89 30       	cpi	r24, 0x09	; 9
    e4c4:	20 f0       	brcs	.+8      	; 0xe4ce <WebServer+0x372>
    e4c6:	ee 5e       	subi	r30, 0xEE	; 238
    e4c8:	f9 4f       	sbci	r31, 0xF9	; 249
    e4ca:	a0 80       	ld	r10, Z
    e4cc:	03 c0       	rjmp	.+6      	; 0xe4d4 <WebServer+0x378>
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
    e4ce:	e1 59       	subi	r30, 0x91	; 145
    e4d0:	f2 4b       	sbci	r31, 0xB2	; 178
    e4d2:	a4 90       	lpm	r10, Z
							WebHrefHiddenCnt++ ;
    e4d4:	8f 5f       	subi	r24, 0xFF	; 255
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    e4d6:	89 31       	cpi	r24, 0x19	; 25
    e4d8:	18 f4       	brcc	.+6      	; 0xe4e0 <WebServer+0x384>
					else{
						if(WebHrefHiddenCnt){
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    e4da:	80 93 1a 06 	sts	0x061A, r24
    e4de:	2e c0       	rjmp	.+92     	; 0xe53c <WebServer+0x3e0>
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    e4e0:	10 92 1a 06 	sts	0x061A, r1
    e4e4:	2b c0       	rjmp	.+86     	; 0xe53c <WebServer+0x3e0>
						}
						else{
							if(WebInputHiddenCnt){
    e4e6:	80 91 e1 03 	lds	r24, 0x03E1
    e4ea:	88 23       	and	r24, r24
    e4ec:	a1 f0       	breq	.+40     	; 0xe516 <WebServer+0x3ba>
    e4ee:	e8 2f       	mov	r30, r24
    e4f0:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    e4f2:	8b 32       	cpi	r24, 0x2B	; 43
    e4f4:	20 f0       	brcs	.+8      	; 0xe4fe <WebServer+0x3a2>
    e4f6:	e0 51       	subi	r30, 0x10	; 16
    e4f8:	fa 4f       	sbci	r31, 0xFA	; 250
    e4fa:	a0 80       	ld	r10, Z
    e4fc:	03 c0       	rjmp	.+6      	; 0xe504 <WebServer+0x3a8>
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
    e4fe:	e8 58       	subi	r30, 0x88	; 136
    e500:	f2 4b       	sbci	r31, 0xB2	; 178
    e502:	a4 90       	lpm	r10, Z
								WebInputHiddenCnt++ ;
    e504:	8f 5f       	subi	r24, 0xFF	; 255
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    e506:	8e 33       	cpi	r24, 0x3E	; 62
    e508:	18 f4       	brcc	.+6      	; 0xe510 <WebServer+0x3b4>
						else{
							if(WebInputHiddenCnt){
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    e50a:	80 93 e1 03 	sts	0x03E1, r24
    e50e:	16 c0       	rjmp	.+44     	; 0xe53c <WebServer+0x3e0>
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    e510:	10 92 e1 03 	sts	0x03E1, r1
    e514:	13 c0       	rjmp	.+38     	; 0xe53c <WebServer+0x3e0>
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    e516:	f6 01       	movw	r30, r12
    e518:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e51a:	25 91       	lpm	r18, Z+
    e51c:	34 91       	lpm	r19, Z
    e51e:	80 91 e8 03 	lds	r24, 0x03E8
    e522:	90 91 e9 03 	lds	r25, 0x03E9
    e526:	ac 01       	movw	r20, r24
    e528:	4f 5f       	subi	r20, 0xFF	; 255
    e52a:	5f 4f       	sbci	r21, 0xFF	; 255
    e52c:	50 93 e9 03 	sts	0x03E9, r21
    e530:	40 93 e8 03 	sts	0x03E8, r20
    e534:	f9 01       	movw	r30, r18
    e536:	e8 0f       	add	r30, r24
    e538:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e53a:	a4 90       	lpm	r10, Z
							}
						}
					}

					GSM_TxStr[i++] = ch;
    e53c:	78 01       	movw	r14, r16
    e53e:	8f ef       	ldi	r24, 0xFF	; 255
    e540:	e8 1a       	sub	r14, r24
    e542:	f8 0a       	sbc	r15, r24
    e544:	d8 01       	movw	r26, r16
    e546:	a4 5e       	subi	r26, 0xE4	; 228
    e548:	b3 4f       	sbci	r27, 0xF3	; 243
    e54a:	ac 92       	st	X, r10
					if(ptrPage != &Web_login){	//  login.html   !
    e54c:	95 ec       	ldi	r25, 0xC5	; 197
    e54e:	c9 16       	cp	r12, r25
    e550:	98 e4       	ldi	r25, 0x48	; 72
    e552:	d9 06       	cpc	r13, r25
    e554:	59 f1       	breq	.+86     	; 0xe5ac <WebServer+0x450>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    e556:	8a 2d       	mov	r24, r10
    e558:	0e 94 ef 47 	call	0x8fde	; 0x8fde <SeekTagFORM>
    e55c:	81 11       	cpse	r24, r1
    e55e:	b0 92 e1 03 	sts	0x03E1, r11
						if(SeekTagA_HREF(ch)){ 
    e562:	8a 2d       	mov	r24, r10
    e564:	0e 94 2b 48 	call	0x9056	; 0x9056 <SeekTagA_HREF>
    e568:	88 23       	and	r24, r24
    e56a:	69 f0       	breq	.+26     	; 0xe586 <WebServer+0x42a>
							WebHrefHiddenCnt = 1;
    e56c:	b0 92 1a 06 	sts	0x061A, r11
							i--;
							WebDataCnt--;
    e570:	20 91 e8 03 	lds	r18, 0x03E8
    e574:	30 91 e9 03 	lds	r19, 0x03E9
    e578:	21 50       	subi	r18, 0x01	; 1
    e57a:	31 09       	sbc	r19, r1
    e57c:	30 93 e9 03 	sts	0x03E9, r19
    e580:	20 93 e8 03 	sts	0x03E8, r18
    e584:	78 01       	movw	r14, r16
						}
						if(SeekTagIMG_SRC(ch)){ 
    e586:	8a 2d       	mov	r24, r10
    e588:	0e 94 67 48 	call	0x90ce	; 0x90ce <SeekTagIMG_SRC>
    e58c:	88 23       	and	r24, r24
    e58e:	71 f0       	breq	.+28     	; 0xe5ac <WebServer+0x450>
							WebImgSrcHiddenCnt = 1;
    e590:	b0 92 e0 03 	sts	0x03E0, r11
							i--;
    e594:	e1 e0       	ldi	r30, 0x01	; 1
    e596:	ee 1a       	sub	r14, r30
    e598:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    e59a:	80 91 e8 03 	lds	r24, 0x03E8
    e59e:	90 91 e9 03 	lds	r25, 0x03E9
    e5a2:	01 97       	sbiw	r24, 0x01	; 1
    e5a4:	90 93 e9 03 	sts	0x03E9, r25
    e5a8:	80 93 e8 03 	sts	0x03E8, r24
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    e5ac:	f8 e0       	ldi	r31, 0x08	; 8
    e5ae:	cf 0e       	add	r12, r31
    e5b0:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    e5b2:	f6 01       	movw	r30, r12
    e5b4:	85 91       	lpm	r24, Z+
    e5b6:	94 91       	lpm	r25, Z
    e5b8:	20 91 e8 03 	lds	r18, 0x03E8
    e5bc:	30 91 e9 03 	lds	r19, 0x03E9
    e5c0:	28 17       	cp	r18, r24
    e5c2:	39 07       	cpc	r19, r25
    e5c4:	10 f4       	brcc	.+4      	; 0xe5ca <WebServer+0x46e>
    e5c6:	87 01       	movw	r16, r14
    e5c8:	56 cf       	rjmp	.-340    	; 0xe476 <WebServer+0x31a>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    e5ca:	68 ec       	ldi	r22, 0xC8	; 200
    e5cc:	70 e0       	ldi	r23, 0x00	; 0
    e5ce:	80 91 35 09 	lds	r24, 0x0935
    e5d2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
						WebMode = 2;
    e5d6:	82 e0       	ldi	r24, 0x02	; 2
    e5d8:	80 93 06 01 	sts	0x0106, r24
						break;
    e5dc:	87 01       	movw	r16, r14
					}
				}
				//
				if(ptrIF != NULL){
    e5de:	c0 90 33 02 	lds	r12, 0x0233
    e5e2:	d0 90 34 02 	lds	r13, 0x0234
    e5e6:	c1 14       	cp	r12, r1
    e5e8:	d1 04       	cpc	r13, r1
    e5ea:	09 f4       	brne	.+2      	; 0xe5ee <WebServer+0x492>
    e5ec:	be c1       	rjmp	.+892    	; 0xe96a <WebServer+0x80e>
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    e5ee:	e0 91 36 02 	lds	r30, 0x0236
    e5f2:	f0 91 37 02 	lds	r31, 0x0237
    e5f6:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e5f8:	25 91       	lpm	r18, Z+
    e5fa:	34 91       	lpm	r19, Z
    e5fc:	80 91 e8 03 	lds	r24, 0x03E8
    e600:	90 91 e9 03 	lds	r25, 0x03E9
    e604:	f9 01       	movw	r30, r18
    e606:	e8 0f       	add	r30, r24
    e608:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e60a:	24 91       	lpm	r18, Z
    e60c:	2b 37       	cpi	r18, 0x7B	; 123
    e60e:	a1 f4       	brne	.+40     	; 0xe638 <WebServer+0x4dc>
    e610:	80 1b       	sub	r24, r16
    e612:	91 0b       	sbc	r25, r17
    e614:	ac 01       	movw	r20, r24
    e616:	40 0f       	add	r20, r16
    e618:	51 1f       	adc	r21, r17
						while(GSM_TxStr[i-1] == '{'){
    e61a:	98 01       	movw	r18, r16
    e61c:	21 50       	subi	r18, 0x01	; 1
    e61e:	31 09       	sbc	r19, r1
    e620:	f9 01       	movw	r30, r18
    e622:	e4 5e       	subi	r30, 0xE4	; 228
    e624:	f3 4f       	sbci	r31, 0xF3	; 243
    e626:	60 81       	ld	r22, Z
    e628:	6b 37       	cpi	r22, 0x7B	; 123
    e62a:	11 f4       	brne	.+4      	; 0xe630 <WebServer+0x4d4>
							WebDataCnt--;
							i--;
    e62c:	89 01       	movw	r16, r18
    e62e:	f2 cf       	rjmp	.-28     	; 0xe614 <WebServer+0x4b8>
    e630:	50 93 e9 03 	sts	0x03E9, r21
    e634:	40 93 e8 03 	sts	0x03E8, r20
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    e638:	0b 87       	std	Y+11, r16	; 0x0b
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    e63a:	61 2c       	mov	r6, r1
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    e63c:	aa 24       	eor	r10, r10
    e63e:	a3 94       	inc	r10
    e640:	b1 2c       	mov	r11, r1
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    e642:	a7 e3       	ldi	r26, 0x37	; 55
    e644:	4a 2e       	mov	r4, r26
    e646:	a1 e0       	ldi	r26, 0x01	; 1
    e648:	5a 2e       	mov	r5, r26
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    e64a:	4b 85       	ldd	r20, Y+11	; 0x0b
    e64c:	64 16       	cp	r6, r20
    e64e:	08 f0       	brcs	.+2      	; 0xe652 <WebServer+0x4f6>
    e650:	88 c1       	rjmp	.+784    	; 0xe962 <WebServer+0x806>
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    e652:	e6 2c       	mov	r14, r6
    e654:	f1 2c       	mov	r15, r1
    e656:	97 01       	movw	r18, r14
    e658:	24 5e       	subi	r18, 0xE4	; 228
    e65a:	33 4f       	sbci	r19, 0xF3	; 243
    e65c:	79 01       	movw	r14, r18
    e65e:	3a 83       	std	Y+2, r19	; 0x02
    e660:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
    e662:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    e664:	f9 01       	movw	r30, r18
    e666:	70 80       	ld	r7, Z
    e668:	fb e7       	ldi	r31, 0x7B	; 123
    e66a:	7f 12       	cpse	r7, r31
    e66c:	6f c1       	rjmp	.+734    	; 0xe94c <WebServer+0x7f0>
    e66e:	80 e0       	ldi	r24, 0x00	; 0
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    e670:	8f 5f       	subi	r24, 0xFF	; 255
    e672:	48 2f       	mov	r20, r24
    e674:	50 e0       	ldi	r21, 0x00	; 0
    e676:	f7 01       	movw	r30, r14
    e678:	e4 0f       	add	r30, r20
    e67a:	f5 1f       	adc	r31, r21
    e67c:	70 80       	ld	r7, Z
    e67e:	2b e7       	ldi	r18, 0x7B	; 123
    e680:	72 16       	cp	r7, r18
    e682:	b1 f3       	breq	.-20     	; 0xe670 <WebServer+0x514>
    e684:	8c 83       	std	Y+4, r24	; 0x04
			Param.Prec = prb(&IF->Prec);
    e686:	f6 01       	movw	r30, r12
    e688:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e68a:	e4 91       	lpm	r30, Z
    e68c:	eb 83       	std	Y+3, r30	; 0x03
			Param.Txt = prp(&IF->EnumList);
    e68e:	f6 01       	movw	r30, r12
    e690:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e692:	85 90       	lpm	r8, Z+
    e694:	94 90       	lpm	r9, Z
    e696:	9e 82       	std	Y+6, r9	; 0x06
    e698:	8d 82       	std	Y+5, r8	; 0x05
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    e69a:	f6 01       	movw	r30, r12
    e69c:	31 96       	adiw	r30, 0x01	; 1
    e69e:	a5 91       	lpm	r26, Z+
    e6a0:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e6a2:	f6 01       	movw	r30, r12
    e6a4:	64 91       	lpm	r22, Z
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    e6a6:	70 e0       	ldi	r23, 0x00	; 0
    e6a8:	63 32       	cpi	r22, 0x23	; 35
    e6aa:	71 05       	cpc	r23, r1
    e6ac:	08 f0       	brcs	.+2      	; 0xe6b0 <WebServer+0x554>
    e6ae:	4b c1       	rjmp	.+662    	; 0xe946 <WebServer+0x7ea>
    e6b0:	fb 01       	movw	r30, r22
    e6b2:	e0 5c       	subi	r30, 0xC0	; 192
    e6b4:	fe 4f       	sbci	r31, 0xFE	; 254
    e6b6:	0c 94 ec 80 	jmp	0x101d8	; 0x101d8 <__tablejump2__>
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    e6ba:	8c 91       	ld	r24, X
    e6bc:	03 c0       	rjmp	.+6      	; 0xe6c4 <WebServer+0x568>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e6be:	cd 01       	movw	r24, r26
    e6c0:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    e6c4:	ae 01       	movw	r20, r28
    e6c6:	4f 5f       	subi	r20, 0xFF	; 255
    e6c8:	5f 4f       	sbci	r21, 0xFF	; 255
    e6ca:	62 e6       	ldi	r22, 0x62	; 98
    e6cc:	90 e0       	ldi	r25, 0x00	; 0
    e6ce:	0e 94 f5 3e 	call	0x7dea	; 0x7dea <PutVal>
    e6d2:	39 c1       	rjmp	.+626    	; 0xe946 <WebServer+0x7ea>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    e6d4:	8c 91       	ld	r24, X
    e6d6:	03 c0       	rjmp	.+6      	; 0xe6de <WebServer+0x582>
    e6d8:	cd 01       	movw	r24, r26
    e6da:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    e6de:	ae 01       	movw	r20, r28
    e6e0:	4f 5f       	subi	r20, 0xFF	; 255
    e6e2:	5f 4f       	sbci	r21, 0xFF	; 255
    e6e4:	62 e6       	ldi	r22, 0x62	; 98
    e6e6:	99 27       	eor	r25, r25
    e6e8:	87 fd       	sbrc	r24, 7
    e6ea:	90 95       	com	r25
    e6ec:	0e 94 70 3f 	call	0x7ee0	; 0x7ee0 <Put_sVal>
    e6f0:	2a c1       	rjmp	.+596    	; 0xe946 <WebServer+0x7ea>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    e6f2:	8c 91       	ld	r24, X
    e6f4:	03 c0       	rjmp	.+6      	; 0xe6fc <WebServer+0x5a0>
    e6f6:	cd 01       	movw	r24, r26
    e6f8:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    e6fc:	ae 01       	movw	r20, r28
    e6fe:	4f 5f       	subi	r20, 0xFF	; 255
    e700:	5f 4f       	sbci	r21, 0xFF	; 255
    e702:	62 e6       	ldi	r22, 0x62	; 98
    e704:	90 e0       	ldi	r25, 0x00	; 0
    e706:	0e 94 1a 40 	call	0x8034	; 0x8034 <Put_zVal>
    e70a:	1d c1       	rjmp	.+570    	; 0xe946 <WebServer+0x7ea>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    e70c:	6c 91       	ld	r22, X
    e70e:	70 e0       	ldi	r23, 0x00	; 0
    e710:	80 e0       	ldi	r24, 0x00	; 0
    e712:	90 e0       	ldi	r25, 0x00	; 0
    e714:	9e 01       	movw	r18, r28
    e716:	2f 5f       	subi	r18, 0xFF	; 255
    e718:	3f 4f       	sbci	r19, 0xFF	; 255
    e71a:	42 e6       	ldi	r20, 0x62	; 98
    e71c:	08 c0       	rjmp	.+16     	; 0xe72e <WebServer+0x5d2>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    e71e:	6d 91       	ld	r22, X+
    e720:	7c 91       	ld	r23, X
    e722:	80 e0       	ldi	r24, 0x00	; 0
    e724:	90 e0       	ldi	r25, 0x00	; 0
    e726:	9e 01       	movw	r18, r28
    e728:	2f 5f       	subi	r18, 0xFF	; 255
    e72a:	3f 4f       	sbci	r19, 0xFF	; 255
    e72c:	47 e7       	ldi	r20, 0x77	; 119
    e72e:	0e 94 95 40 	call	0x812a	; 0x812a <Put_zVal_h>
    e732:	09 c1       	rjmp	.+530    	; 0xe946 <WebServer+0x7ea>
    e734:	13 96       	adiw	r26, 0x03	; 3
    e736:	8c 91       	ld	r24, X
    e738:	13 97       	sbiw	r26, 0x03	; 3
    e73a:	8f 93       	push	r24
    e73c:	12 96       	adiw	r26, 0x02	; 2
    e73e:	8c 91       	ld	r24, X
    e740:	12 97       	sbiw	r26, 0x02	; 2
    e742:	8f 93       	push	r24
    e744:	11 96       	adiw	r26, 0x01	; 1
    e746:	8c 91       	ld	r24, X
    e748:	11 97       	sbiw	r26, 0x01	; 1
    e74a:	8f 93       	push	r24
    e74c:	8c 91       	ld	r24, X
    e74e:	8f 93       	push	r24
    e750:	5f 92       	push	r5
    e752:	4f 92       	push	r4
    e754:	ff 92       	push	r15
    e756:	ef 92       	push	r14
    e758:	0e 94 2c 78 	call	0xf058	; 0xf058 <sprintf>
    e75c:	2d b7       	in	r18, 0x3d	; 61
    e75e:	3e b7       	in	r19, 0x3e	; 62
    e760:	28 5f       	subi	r18, 0xF8	; 248
    e762:	3f 4f       	sbci	r19, 0xFF	; 255
    e764:	0f b6       	in	r0, 0x3f	; 63
    e766:	f8 94       	cli
    e768:	3e bf       	out	0x3e, r19	; 62
    e76a:	0f be       	out	0x3f, r0	; 63
    e76c:	2d bf       	out	0x3d, r18	; 61
    e76e:	eb c0       	rjmp	.+470    	; 0xe946 <WebServer+0x7ea>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    e770:	ae 01       	movw	r20, r28
    e772:	4f 5f       	subi	r20, 0xFF	; 255
    e774:	5f 4f       	sbci	r21, 0xFF	; 255
    e776:	67 e7       	ldi	r22, 0x77	; 119
    e778:	8d 91       	ld	r24, X+
    e77a:	9c 91       	ld	r25, X
    e77c:	a8 cf       	rjmp	.-176    	; 0xe6ce <WebServer+0x572>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e77e:	cd 01       	movw	r24, r26
    e780:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    e784:	ae 01       	movw	r20, r28
    e786:	4f 5f       	subi	r20, 0xFF	; 255
    e788:	5f 4f       	sbci	r21, 0xFF	; 255
    e78a:	67 e7       	ldi	r22, 0x77	; 119
    e78c:	a0 cf       	rjmp	.-192    	; 0xe6ce <WebServer+0x572>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    e78e:	ae 01       	movw	r20, r28
    e790:	4f 5f       	subi	r20, 0xFF	; 255
    e792:	5f 4f       	sbci	r21, 0xFF	; 255
    e794:	67 e7       	ldi	r22, 0x77	; 119
    e796:	8d 91       	ld	r24, X+
    e798:	9c 91       	ld	r25, X
    e79a:	a8 cf       	rjmp	.-176    	; 0xe6ec <WebServer+0x590>
    e79c:	cd 01       	movw	r24, r26
    e79e:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    e7a2:	ae 01       	movw	r20, r28
    e7a4:	4f 5f       	subi	r20, 0xFF	; 255
    e7a6:	5f 4f       	sbci	r21, 0xFF	; 255
    e7a8:	67 e7       	ldi	r22, 0x77	; 119
    e7aa:	a0 cf       	rjmp	.-192    	; 0xe6ec <WebServer+0x590>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    e7ac:	ae 01       	movw	r20, r28
    e7ae:	4f 5f       	subi	r20, 0xFF	; 255
    e7b0:	5f 4f       	sbci	r21, 0xFF	; 255
    e7b2:	67 e7       	ldi	r22, 0x77	; 119
    e7b4:	8d 91       	ld	r24, X+
    e7b6:	9c 91       	ld	r25, X
    e7b8:	a6 cf       	rjmp	.-180    	; 0xe706 <WebServer+0x5aa>
    e7ba:	cd 01       	movw	r24, r26
    e7bc:	0e 94 45 7f 	call	0xfe8a	; 0xfe8a <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    e7c0:	ae 01       	movw	r20, r28
    e7c2:	4f 5f       	subi	r20, 0xFF	; 255
    e7c4:	5f 4f       	sbci	r21, 0xFF	; 255
    e7c6:	67 e7       	ldi	r22, 0x77	; 119
    e7c8:	9e cf       	rjmp	.-196    	; 0xe706 <WebServer+0x5aa>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    e7ca:	6d 91       	ld	r22, X+
    e7cc:	7d 91       	ld	r23, X+
    e7ce:	8d 91       	ld	r24, X+
    e7d0:	9c 91       	ld	r25, X
    e7d2:	03 c0       	rjmp	.+6      	; 0xe7da <WebServer+0x67e>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    e7d4:	cd 01       	movw	r24, r26
    e7d6:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    e7da:	ae 01       	movw	r20, r28
    e7dc:	4f 5f       	subi	r20, 0xFF	; 255
    e7de:	5f 4f       	sbci	r21, 0xFF	; 255
    e7e0:	0e 94 cb 40 	call	0x8196	; 0x8196 <PutDVal>
    e7e4:	b0 c0       	rjmp	.+352    	; 0xe946 <WebServer+0x7ea>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    e7e6:	6d 91       	ld	r22, X+
    e7e8:	7d 91       	ld	r23, X+
    e7ea:	8d 91       	ld	r24, X+
    e7ec:	9c 91       	ld	r25, X
    e7ee:	03 c0       	rjmp	.+6      	; 0xe7f6 <WebServer+0x69a>
    e7f0:	cd 01       	movw	r24, r26
    e7f2:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    e7f6:	ae 01       	movw	r20, r28
    e7f8:	4f 5f       	subi	r20, 0xFF	; 255
    e7fa:	5f 4f       	sbci	r21, 0xFF	; 255
    e7fc:	0e 94 5e 41 	call	0x82bc	; 0x82bc <Put_sDVal>
    e800:	a2 c0       	rjmp	.+324    	; 0xe946 <WebServer+0x7ea>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    e802:	6d 91       	ld	r22, X+
    e804:	7d 91       	ld	r23, X+
    e806:	8d 91       	ld	r24, X+
    e808:	9c 91       	ld	r25, X
    e80a:	03 c0       	rjmp	.+6      	; 0xe812 <WebServer+0x6b6>
    e80c:	cd 01       	movw	r24, r26
    e80e:	0e 94 3f 7f 	call	0xfe7e	; 0xfe7e <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    e812:	ae 01       	movw	r20, r28
    e814:	4f 5f       	subi	r20, 0xFF	; 255
    e816:	5f 4f       	sbci	r21, 0xFF	; 255
    e818:	0e 94 56 42 	call	0x84ac	; 0x84ac <Put_zDVal>
    e81c:	94 c0       	rjmp	.+296    	; 0xe946 <WebServer+0x7ea>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    e81e:	6d 91       	ld	r22, X+
    e820:	7d 91       	ld	r23, X+
    e822:	8d 91       	ld	r24, X+
    e824:	9c 91       	ld	r25, X
    e826:	0b c0       	rjmp	.+22     	; 0xe83e <WebServer+0x6e2>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    e828:	44 e0       	ldi	r20, 0x04	; 4
    e82a:	50 e0       	ldi	r21, 0x00	; 0
    e82c:	bd 01       	movw	r22, r26
    e82e:	ce 01       	movw	r24, r28
    e830:	07 96       	adiw	r24, 0x07	; 7
    e832:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    e836:	6f 81       	ldd	r22, Y+7	; 0x07
    e838:	78 85       	ldd	r23, Y+8	; 0x08
    e83a:	89 85       	ldd	r24, Y+9	; 0x09
    e83c:	9a 85       	ldd	r25, Y+10	; 0x0a
    e83e:	ae 01       	movw	r20, r28
    e840:	4f 5f       	subi	r20, 0xFF	; 255
    e842:	5f 4f       	sbci	r21, 0xFF	; 255
    e844:	0e 94 e9 42 	call	0x85d2	; 0x85d2 <Put_FFVal>
    e848:	7e c0       	rjmp	.+252    	; 0xe946 <WebServer+0x7ea>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    e84a:	6d 91       	ld	r22, X+
    e84c:	7d 91       	ld	r23, X+
    e84e:	8d 91       	ld	r24, X+
    e850:	9c 91       	ld	r25, X
    e852:	0b c0       	rjmp	.+22     	; 0xe86a <WebServer+0x70e>
    e854:	44 e0       	ldi	r20, 0x04	; 4
    e856:	50 e0       	ldi	r21, 0x00	; 0
    e858:	bd 01       	movw	r22, r26
    e85a:	ce 01       	movw	r24, r28
    e85c:	07 96       	adiw	r24, 0x07	; 7
    e85e:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    e862:	6f 81       	ldd	r22, Y+7	; 0x07
    e864:	78 85       	ldd	r23, Y+8	; 0x08
    e866:	89 85       	ldd	r24, Y+9	; 0x09
    e868:	9a 85       	ldd	r25, Y+10	; 0x0a
    e86a:	ae 01       	movw	r20, r28
    e86c:	4f 5f       	subi	r20, 0xFF	; 255
    e86e:	5f 4f       	sbci	r21, 0xFF	; 255
    e870:	0e 94 27 43 	call	0x864e	; 0x864e <Put_GFVal>
    e874:	68 c0       	rjmp	.+208    	; 0xe946 <WebServer+0x7ea>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    e876:	8c 91       	ld	r24, X
    e878:	03 c0       	rjmp	.+6      	; 0xe880 <WebServer+0x724>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e87a:	cd 01       	movw	r24, r26
    e87c:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    e880:	88 0e       	add	r8, r24
    e882:	91 1c       	adc	r9, r1
    e884:	88 0e       	add	r8, r24
    e886:	91 1c       	adc	r9, r1
    e888:	9e 82       	std	Y+6, r9	; 0x06
    e88a:	8d 82       	std	Y+5, r8	; 0x05
		PutEnum(Param);
    e88c:	ce 01       	movw	r24, r28
    e88e:	01 96       	adiw	r24, 0x01	; 1
    e890:	0e 94 cf 3e 	call	0x7d9e	; 0x7d9e <PutEnum>
    e894:	58 c0       	rjmp	.+176    	; 0xe946 <WebServer+0x7ea>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    e896:	2b 81       	ldd	r18, Y+3	; 0x03
    e898:	82 2f       	mov	r24, r18
    e89a:	86 95       	lsr	r24
    e89c:	86 95       	lsr	r24
    e89e:	86 95       	lsr	r24
    e8a0:	a8 0f       	add	r26, r24
    e8a2:	b1 1d       	adc	r27, r1
    e8a4:	8c 91       	ld	r24, X
    e8a6:	90 e0       	ldi	r25, 0x00	; 0
    e8a8:	0e c0       	rjmp	.+28     	; 0xe8c6 <WebServer+0x76a>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    e8aa:	2b 81       	ldd	r18, Y+3	; 0x03
    e8ac:	82 2f       	mov	r24, r18
    e8ae:	86 95       	lsr	r24
    e8b0:	86 95       	lsr	r24
    e8b2:	86 95       	lsr	r24
    e8b4:	fd 01       	movw	r30, r26
    e8b6:	e8 0f       	add	r30, r24
    e8b8:	f1 1d       	adc	r31, r1
    e8ba:	cf 01       	movw	r24, r30
    e8bc:	2c 87       	std	Y+12, r18	; 0x0c
    e8be:	0e 94 37 7f 	call	0xfe6e	; 0xfe6e <__eerd_byte_m128>
    e8c2:	90 e0       	ldi	r25, 0x00	; 0
    e8c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    e8c6:	27 70       	andi	r18, 0x07	; 7
    e8c8:	a5 01       	movw	r20, r10
    e8ca:	02 c0       	rjmp	.+4      	; 0xe8d0 <WebServer+0x774>
    e8cc:	44 0f       	add	r20, r20
    e8ce:	55 1f       	adc	r21, r21
    e8d0:	2a 95       	dec	r18
    e8d2:	e2 f7       	brpl	.-8      	; 0xe8cc <WebServer+0x770>
    e8d4:	84 23       	and	r24, r20
    e8d6:	95 23       	and	r25, r21
    e8d8:	89 2b       	or	r24, r25
    e8da:	19 f0       	breq	.+6      	; 0xe8e2 <WebServer+0x786>
    e8dc:	e2 e0       	ldi	r30, 0x02	; 2
    e8de:	f0 e0       	ldi	r31, 0x00	; 0
    e8e0:	02 c0       	rjmp	.+4      	; 0xe8e6 <WebServer+0x78a>
    e8e2:	e0 e0       	ldi	r30, 0x00	; 0
    e8e4:	f0 e0       	ldi	r31, 0x00	; 0
    e8e6:	e8 0d       	add	r30, r8
    e8e8:	f9 1d       	adc	r31, r9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e8ea:	65 91       	lpm	r22, Z+
    e8ec:	74 91       	lpm	r23, Z
    e8ee:	c7 01       	movw	r24, r14
    e8f0:	0e 94 ae 77 	call	0xef5c	; 0xef5c <strcpy_P>
    e8f4:	28 c0       	rjmp	.+80     	; 0xe946 <WebServer+0x7ea>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    e8f6:	be 01       	movw	r22, r28
    e8f8:	6f 5f       	subi	r22, 0xFF	; 255
    e8fa:	7f 4f       	sbci	r23, 0xFF	; 255
    e8fc:	cd 01       	movw	r24, r26
    e8fe:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <Put_TextValAlignLeft>
    e902:	21 c0       	rjmp	.+66     	; 0xe946 <WebServer+0x7ea>
    e904:	8d b6       	in	r8, 0x3d	; 61
    e906:	9e b6       	in	r9, 0x3e	; 62
		break;
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    e908:	ca 01       	movw	r24, r20
    e90a:	01 96       	adiw	r24, 0x01	; 1
    e90c:	ed b7       	in	r30, 0x3d	; 61
    e90e:	fe b7       	in	r31, 0x3e	; 62
    e910:	e8 1b       	sub	r30, r24
    e912:	f9 0b       	sbc	r31, r25
    e914:	0f b6       	in	r0, 0x3f	; 63
    e916:	f8 94       	cli
    e918:	fe bf       	out	0x3e, r31	; 62
    e91a:	0f be       	out	0x3f, r0	; 63
    e91c:	ed bf       	out	0x3d, r30	; 61
    e91e:	2d b7       	in	r18, 0x3d	; 61
    e920:	3e b7       	in	r19, 0x3e	; 62
    e922:	2f 5f       	subi	r18, 0xFF	; 255
    e924:	3f 4f       	sbci	r19, 0xFF	; 255
    e926:	79 01       	movw	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    e928:	bd 01       	movw	r22, r26
    e92a:	c9 01       	movw	r24, r18
    e92c:	0e 94 27 7f 	call	0xfe4e	; 0xfe4e <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    e930:	be 01       	movw	r22, r28
    e932:	6f 5f       	subi	r22, 0xFF	; 255
    e934:	7f 4f       	sbci	r23, 0xFF	; 255
    e936:	c7 01       	movw	r24, r14
    e938:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <Put_TextValAlignLeft>
    e93c:	0f b6       	in	r0, 0x3f	; 63
    e93e:	f8 94       	cli
    e940:	9e be       	out	0x3e, r9	; 62
    e942:	0f be       	out	0x3f, r0	; 63
    e944:	8d be       	out	0x3d, r8	; 61
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    e946:	36 e0       	ldi	r19, 0x06	; 6
    e948:	c3 0e       	add	r12, r19
    e94a:	d1 1c       	adc	r13, r1
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    e94c:	8c 81       	ldd	r24, Y+4	; 0x04
    e94e:	86 0d       	add	r24, r6
    e950:	e8 2f       	mov	r30, r24
    e952:	f0 e0       	ldi	r31, 0x00	; 0
    e954:	e4 5e       	subi	r30, 0xE4	; 228
    e956:	f3 4f       	sbci	r31, 0xF3	; 243
    e958:	70 82       	st	Z, r7
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    e95a:	66 24       	eor	r6, r6
    e95c:	63 94       	inc	r6
    e95e:	68 0e       	add	r6, r24
    e960:	74 ce       	rjmp	.-792    	; 0xe64a <WebServer+0x4ee>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    e962:	d0 92 34 02 	sts	0x0234, r13
    e966:	c0 92 33 02 	sts	0x0233, r12
				}
				GSMTxSz = i;
    e96a:	00 93 3c 09 	sts	0x093C, r16
				//flowcontrol
				PacketByteCount += GSMTxSz;
    e96e:	20 91 3c 09 	lds	r18, 0x093C
    e972:	80 91 31 02 	lds	r24, 0x0231
    e976:	90 91 32 02 	lds	r25, 0x0232
    e97a:	82 0f       	add	r24, r18
    e97c:	91 1d       	adc	r25, r1
				if(PacketByteCount >= MaxPacketSz){
    e97e:	81 15       	cp	r24, r1
    e980:	54 e0       	ldi	r21, 0x04	; 4
    e982:	95 07       	cpc	r25, r21
    e984:	28 f4       	brcc	.+10     	; 0xe990 <WebServer+0x834>
					}
					ptrIF = PutWebLine(ptrIF, i);
				}
				GSMTxSz = i;
				//flowcontrol
				PacketByteCount += GSMTxSz;
    e986:	90 93 32 02 	sts	0x0232, r25
    e98a:	80 93 31 02 	sts	0x0231, r24
    e98e:	0b c0       	rjmp	.+22     	; 0xe9a6 <WebServer+0x84a>
				if(PacketByteCount >= MaxPacketSz){
					PacketByteCount -= MaxPacketSz;
    e990:	94 50       	subi	r25, 0x04	; 4
    e992:	90 93 32 02 	sts	0x0232, r25
    e996:	80 93 31 02 	sts	0x0231, r24
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    e99a:	68 ec       	ldi	r22, 0xC8	; 200
    e99c:	70 e0       	ldi	r23, 0x00	; 0
    e99e:	80 91 35 09 	lds	r24, 0x0935
    e9a2:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
				}
				GSM_SendFirstChar();
    e9a6:	0e 94 bb 63 	call	0xc776	; 0xc776 <GSM_SendFirstChar>
    e9aa:	02 c0       	rjmp	.+4      	; 0xe9b0 <WebServer+0x854>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    e9ac:	10 92 35 02 	sts	0x0235, r1
	}

}
    e9b0:	0f b6       	in	r0, 0x3f	; 63
    e9b2:	f8 94       	cli
    e9b4:	3e be       	out	0x3e, r3	; 62
    e9b6:	0f be       	out	0x3f, r0	; 63
    e9b8:	2d be       	out	0x3d, r2	; 61
    e9ba:	2c 96       	adiw	r28, 0x0c	; 12
    e9bc:	0f b6       	in	r0, 0x3f	; 63
    e9be:	f8 94       	cli
    e9c0:	de bf       	out	0x3e, r29	; 62
    e9c2:	0f be       	out	0x3f, r0	; 63
    e9c4:	cd bf       	out	0x3d, r28	; 61
    e9c6:	df 91       	pop	r29
    e9c8:	cf 91       	pop	r28
    e9ca:	1f 91       	pop	r17
    e9cc:	0f 91       	pop	r16
    e9ce:	ff 90       	pop	r15
    e9d0:	ef 90       	pop	r14
    e9d2:	df 90       	pop	r13
    e9d4:	cf 90       	pop	r12
    e9d6:	bf 90       	pop	r11
    e9d8:	af 90       	pop	r10
    e9da:	9f 90       	pop	r9
    e9dc:	8f 90       	pop	r8
    e9de:	7f 90       	pop	r7
    e9e0:	6f 90       	pop	r6
    e9e2:	5f 90       	pop	r5
    e9e4:	4f 90       	pop	r4
    e9e6:	3f 90       	pop	r3
    e9e8:	2f 90       	pop	r2
    e9ea:	08 95       	ret

0000e9ec <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    e9ec:	80 91 5a 0a 	lds	r24, 0x0A5A
    e9f0:	88 23       	and	r24, r24
    e9f2:	09 f4       	brne	.+2      	; 0xe9f6 <GSM_DRE+0xa>
    e9f4:	55 c0       	rjmp	.+170    	; 0xeaa0 <GSM_DRE+0xb4>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    e9f6:	90 91 54 09 	lds	r25, 0x0954
    e9fa:	80 91 1b 0d 	lds	r24, 0x0D1B
    e9fe:	98 17       	cp	r25, r24
    ea00:	a1 f0       	breq	.+40     	; 0xea2a <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    ea02:	80 91 1b 0d 	lds	r24, 0x0D1B
    ea06:	8f 5f       	subi	r24, 0xFF	; 255
    ea08:	80 93 1b 0d 	sts	0x0D1B, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    ea0c:	80 91 1b 0d 	lds	r24, 0x0D1B
    ea10:	8a 3f       	cpi	r24, 0xFA	; 250
    ea12:	10 f0       	brcs	.+4      	; 0xea18 <GSM_DRE+0x2c>
    ea14:	10 92 1b 0d 	sts	0x0D1B, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    ea18:	e0 91 1b 0d 	lds	r30, 0x0D1B
    ea1c:	f0 e0       	ldi	r31, 0x00	; 0
    ea1e:	ef 50       	subi	r30, 0x0F	; 15
    ea20:	fc 4f       	sbci	r31, 0xFC	; 252
    ea22:	80 81       	ld	r24, Z
    ea24:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    ea26:	5e 9a       	sbi	0x0b, 6	; 11
    ea28:	02 c0       	rjmp	.+4      	; 0xea2e <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    ea2a:	88 ed       	ldi	r24, 0xD8	; 216
    ea2c:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    ea2e:	90 91 54 09 	lds	r25, 0x0954
    ea32:	80 91 1b 0d 	lds	r24, 0x0D1B
    ea36:	89 17       	cp	r24, r25
    ea38:	a0 f4       	brcc	.+40     	; 0xea62 <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    ea3a:	20 91 52 0a 	lds	r18, 0x0A52
    ea3e:	80 91 54 09 	lds	r24, 0x0954
    ea42:	40 91 1b 0d 	lds	r20, 0x0D1B
    ea46:	30 e0       	ldi	r19, 0x00	; 0
    ea48:	90 e0       	ldi	r25, 0x00	; 0
    ea4a:	84 1b       	sub	r24, r20
    ea4c:	91 09       	sbc	r25, r1
    ea4e:	28 17       	cp	r18, r24
    ea50:	39 07       	cpc	r19, r25
    ea52:	3c f4       	brge	.+14     	; 0xea62 <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    ea54:	80 91 54 09 	lds	r24, 0x0954
    ea58:	90 91 1b 0d 	lds	r25, 0x0D1B
    ea5c:	89 1b       	sub	r24, r25
    ea5e:	80 93 52 0a 	sts	0x0A52, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    ea62:	90 91 1b 0d 	lds	r25, 0x0D1B
    ea66:	80 91 54 09 	lds	r24, 0x0954
    ea6a:	89 17       	cp	r24, r25
    ea6c:	e8 f5       	brcc	.+122    	; 0xeae8 <GSM_DRE+0xfc>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    ea6e:	20 91 52 0a 	lds	r18, 0x0A52
    ea72:	50 91 1b 0d 	lds	r21, 0x0D1B
    ea76:	40 91 54 09 	lds	r20, 0x0954
    ea7a:	30 e0       	ldi	r19, 0x00	; 0
    ea7c:	8a ef       	ldi	r24, 0xFA	; 250
    ea7e:	90 e0       	ldi	r25, 0x00	; 0
    ea80:	85 1b       	sub	r24, r21
    ea82:	91 09       	sbc	r25, r1
    ea84:	84 0f       	add	r24, r20
    ea86:	91 1d       	adc	r25, r1
    ea88:	28 17       	cp	r18, r24
    ea8a:	39 07       	cpc	r19, r25
    ea8c:	6c f5       	brge	.+90     	; 0xeae8 <GSM_DRE+0xfc>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    ea8e:	80 91 54 09 	lds	r24, 0x0954
    ea92:	90 91 1b 0d 	lds	r25, 0x0D1B
    ea96:	86 50       	subi	r24, 0x06	; 6
    ea98:	89 1b       	sub	r24, r25
    ea9a:	80 93 52 0a 	sts	0x0A52, r24
    ea9e:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    eaa0:	90 91 28 0d 	lds	r25, 0x0D28
    eaa4:	80 91 3c 09 	lds	r24, 0x093C
    eaa8:	98 17       	cp	r25, r24
    eaaa:	e0 f4       	brcc	.+56     	; 0xeae4 <GSM_DRE+0xf8>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    eaac:	e0 91 28 0d 	lds	r30, 0x0D28
    eab0:	f0 e0       	ldi	r31, 0x00	; 0
    eab2:	e4 5e       	subi	r30, 0xE4	; 228
    eab4:	f3 4f       	sbci	r31, 0xF3	; 243
    eab6:	80 81       	ld	r24, Z
    eab8:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    eaba:	80 91 d6 09 	lds	r24, 0x09D6
    eabe:	88 23       	and	r24, r24
    eac0:	59 f0       	breq	.+22     	; 0xead8 <GSM_DRE+0xec>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    eac2:	e0 91 28 0d 	lds	r30, 0x0D28
    eac6:	f0 e0       	ldi	r31, 0x00	; 0
    eac8:	e4 5e       	subi	r30, 0xE4	; 228
    eaca:	f3 4f       	sbci	r31, 0xF3	; 243
    eacc:	80 81       	ld	r24, Z
    eace:	0e 94 32 63 	call	0xc664	; 0xc664 <SendDebug>
    ead2:	88 e2       	ldi	r24, 0x28	; 40
    ead4:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    ead8:	80 91 28 0d 	lds	r24, 0x0D28
    eadc:	8f 5f       	subi	r24, 0xFF	; 255
    eade:	80 93 28 0d 	sts	0x0D28, r24
    eae2:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    eae4:	88 ed       	ldi	r24, 0xD8	; 216
    eae6:	8a b9       	out	0x0a, r24	; 10
    eae8:	08 95       	ret

0000eaea <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    eaea:	1f 92       	push	r1
    eaec:	0f 92       	push	r0
    eaee:	0f b6       	in	r0, 0x3f	; 63
    eaf0:	0f 92       	push	r0
    eaf2:	11 24       	eor	r1, r1
    eaf4:	0b b6       	in	r0, 0x3b	; 59
    eaf6:	0f 92       	push	r0
    eaf8:	2f 93       	push	r18
    eafa:	3f 93       	push	r19
    eafc:	4f 93       	push	r20
    eafe:	5f 93       	push	r21
    eb00:	6f 93       	push	r22
    eb02:	7f 93       	push	r23
    eb04:	8f 93       	push	r24
    eb06:	9f 93       	push	r25
    eb08:	af 93       	push	r26
    eb0a:	bf 93       	push	r27
    eb0c:	ef 93       	push	r30
    eb0e:	ff 93       	push	r31
	GSM_DRE();
    eb10:	0e 94 f6 74 	call	0xe9ec	; 0xe9ec <GSM_DRE>
	GSM_LED = 1;
    eb14:	81 e0       	ldi	r24, 0x01	; 1
    eb16:	80 93 fd 05 	sts	0x05FD, r24
}
    eb1a:	ff 91       	pop	r31
    eb1c:	ef 91       	pop	r30
    eb1e:	bf 91       	pop	r27
    eb20:	af 91       	pop	r26
    eb22:	9f 91       	pop	r25
    eb24:	8f 91       	pop	r24
    eb26:	7f 91       	pop	r23
    eb28:	6f 91       	pop	r22
    eb2a:	5f 91       	pop	r21
    eb2c:	4f 91       	pop	r20
    eb2e:	3f 91       	pop	r19
    eb30:	2f 91       	pop	r18
    eb32:	0f 90       	pop	r0
    eb34:	0b be       	out	0x3b, r0	; 59
    eb36:	0f 90       	pop	r0
    eb38:	0f be       	out	0x3f, r0	; 63
    eb3a:	0f 90       	pop	r0
    eb3c:	1f 90       	pop	r1
    eb3e:	18 95       	reti

0000eb40 <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    eb40:	90 91 54 09 	lds	r25, 0x0954
    eb44:	80 91 1b 0d 	lds	r24, 0x0D1B
    eb48:	98 17       	cp	r25, r24
    eb4a:	a1 f0       	breq	.+40     	; 0xeb74 <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    eb4c:	80 91 1b 0d 	lds	r24, 0x0D1B
    eb50:	8f 5f       	subi	r24, 0xFF	; 255
    eb52:	80 93 1b 0d 	sts	0x0D1B, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    eb56:	80 91 1b 0d 	lds	r24, 0x0D1B
    eb5a:	8a 3f       	cpi	r24, 0xFA	; 250
    eb5c:	10 f0       	brcs	.+4      	; 0xeb62 <Debug_DRE+0x22>
    eb5e:	10 92 1b 0d 	sts	0x0D1B, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    eb62:	e0 91 1b 0d 	lds	r30, 0x0D1B
    eb66:	f0 e0       	ldi	r31, 0x00	; 0
    eb68:	ef 50       	subi	r30, 0x0F	; 15
    eb6a:	fc 4f       	sbci	r31, 0xFC	; 252
    eb6c:	80 81       	ld	r24, Z
    eb6e:	80 93 9c 00 	sts	0x009C, r24
    eb72:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    eb74:	88 e0       	ldi	r24, 0x08	; 8
    eb76:	80 93 9a 00 	sts	0x009A, r24
    eb7a:	08 95       	ret

0000eb7c <EMeter_DRE>:
	}
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    eb7c:	80 91 d6 09 	lds	r24, 0x09D6
    eb80:	81 11       	cpse	r24, r1
    eb82:	0c 94 a0 75 	jmp	0xeb40	; 0xeb40 <Debug_DRE>
	else{
		if(Transparent){
    eb86:	80 91 5a 0a 	lds	r24, 0x0A5A
    eb8a:	88 23       	and	r24, r24
    eb8c:	09 f4       	brne	.+2      	; 0xeb90 <EMeter_DRE+0x14>
    eb8e:	5c c0       	rjmp	.+184    	; 0xec48 <EMeter_DRE+0xcc>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    eb90:	90 91 6d 08 	lds	r25, 0x086D
    eb94:	80 91 dc 0a 	lds	r24, 0x0ADC
    eb98:	98 17       	cp	r25, r24
    eb9a:	d1 f0       	breq	.+52     	; 0xebd0 <EMeter_DRE+0x54>
		GSM_RX_FIFO_End_Transp++;
    eb9c:	80 91 dc 0a 	lds	r24, 0x0ADC
    eba0:	8f 5f       	subi	r24, 0xFF	; 255
    eba2:	80 93 dc 0a 	sts	0x0ADC, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    eba6:	80 91 dc 0a 	lds	r24, 0x0ADC
    ebaa:	8a 3f       	cpi	r24, 0xFA	; 250
    ebac:	10 f0       	brcs	.+4      	; 0xebb2 <EMeter_DRE+0x36>
    ebae:	10 92 dc 0a 	sts	0x0ADC, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    ebb2:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    ebb4:	e0 91 dc 0a 	lds	r30, 0x0ADC
    ebb8:	f0 e0       	ldi	r31, 0x00	; 0
    ebba:	e5 51       	subi	r30, 0x15	; 21
    ebbc:	fb 4f       	sbci	r31, 0xFB	; 251
    ebbe:	80 81       	ld	r24, Z
    ebc0:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    ebc4:	80 91 9b 00 	lds	r24, 0x009B
    ebc8:	80 64       	ori	r24, 0x40	; 64
    ebca:	80 93 9b 00 	sts	0x009B, r24
    ebce:	03 c0       	rjmp	.+6      	; 0xebd6 <EMeter_DRE+0x5a>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ebd0:	88 ed       	ldi	r24, 0xD8	; 216
    ebd2:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    ebd6:	90 91 6d 08 	lds	r25, 0x086D
    ebda:	80 91 dc 0a 	lds	r24, 0x0ADC
    ebde:	89 17       	cp	r24, r25
    ebe0:	a0 f4       	brcc	.+40     	; 0xec0a <EMeter_DRE+0x8e>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    ebe2:	20 91 63 09 	lds	r18, 0x0963
    ebe6:	80 91 6d 08 	lds	r24, 0x086D
    ebea:	40 91 dc 0a 	lds	r20, 0x0ADC
    ebee:	30 e0       	ldi	r19, 0x00	; 0
    ebf0:	90 e0       	ldi	r25, 0x00	; 0
    ebf2:	84 1b       	sub	r24, r20
    ebf4:	91 09       	sbc	r25, r1
    ebf6:	28 17       	cp	r18, r24
    ebf8:	39 07       	cpc	r19, r25
    ebfa:	3c f4       	brge	.+14     	; 0xec0a <EMeter_DRE+0x8e>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    ebfc:	80 91 6d 08 	lds	r24, 0x086D
    ec00:	90 91 dc 0a 	lds	r25, 0x0ADC
    ec04:	89 1b       	sub	r24, r25
    ec06:	80 93 63 09 	sts	0x0963, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    ec0a:	90 91 dc 0a 	lds	r25, 0x0ADC
    ec0e:	80 91 6d 08 	lds	r24, 0x086D
    ec12:	89 17       	cp	r24, r25
    ec14:	80 f5       	brcc	.+96     	; 0xec76 <EMeter_DRE+0xfa>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    ec16:	20 91 63 09 	lds	r18, 0x0963
    ec1a:	50 91 dc 0a 	lds	r21, 0x0ADC
    ec1e:	40 91 6d 08 	lds	r20, 0x086D
    ec22:	30 e0       	ldi	r19, 0x00	; 0
    ec24:	8a ef       	ldi	r24, 0xFA	; 250
    ec26:	90 e0       	ldi	r25, 0x00	; 0
    ec28:	85 1b       	sub	r24, r21
    ec2a:	91 09       	sbc	r25, r1
    ec2c:	84 0f       	add	r24, r20
    ec2e:	91 1d       	adc	r25, r1
    ec30:	28 17       	cp	r18, r24
    ec32:	39 07       	cpc	r19, r25
    ec34:	04 f5       	brge	.+64     	; 0xec76 <EMeter_DRE+0xfa>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    ec36:	80 91 6d 08 	lds	r24, 0x086D
    ec3a:	90 91 dc 0a 	lds	r25, 0x0ADC
    ec3e:	86 50       	subi	r24, 0x06	; 6
    ec40:	89 1b       	sub	r24, r25
    ec42:	80 93 63 09 	sts	0x0963, r24
    ec46:	08 95       	ret
			GetByteFromGSM_FIFO_Transp();
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    ec48:	90 91 37 09 	lds	r25, 0x0937
    ec4c:	80 91 29 0d 	lds	r24, 0x0D29
    ec50:	98 17       	cp	r25, r24
    ec52:	70 f4       	brcc	.+28     	; 0xec70 <EMeter_DRE+0xf4>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    ec54:	e0 91 37 09 	lds	r30, 0x0937
    ec58:	f0 e0       	ldi	r31, 0x00	; 0
    ec5a:	e3 52       	subi	r30, 0x23	; 35
    ec5c:	f5 4f       	sbci	r31, 0xF5	; 245
    ec5e:	80 81       	ld	r24, Z
    ec60:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    ec64:	80 91 37 09 	lds	r24, 0x0937
    ec68:	8f 5f       	subi	r24, 0xFF	; 255
    ec6a:	80 93 37 09 	sts	0x0937, r24
    ec6e:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ec70:	88 ed       	ldi	r24, 0xD8	; 216
    ec72:	80 93 9a 00 	sts	0x009A, r24
    ec76:	08 95       	ret

0000ec78 <__vector_31>:
}

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    ec78:	1f 92       	push	r1
    ec7a:	0f 92       	push	r0
    ec7c:	0f b6       	in	r0, 0x3f	; 63
    ec7e:	0f 92       	push	r0
    ec80:	11 24       	eor	r1, r1
    ec82:	0b b6       	in	r0, 0x3b	; 59
    ec84:	0f 92       	push	r0
    ec86:	2f 93       	push	r18
    ec88:	3f 93       	push	r19
    ec8a:	4f 93       	push	r20
    ec8c:	5f 93       	push	r21
    ec8e:	6f 93       	push	r22
    ec90:	7f 93       	push	r23
    ec92:	8f 93       	push	r24
    ec94:	9f 93       	push	r25
    ec96:	af 93       	push	r26
    ec98:	bf 93       	push	r27
    ec9a:	ef 93       	push	r30
    ec9c:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    ec9e:	80 91 d8 03 	lds	r24, 0x03D8
    eca2:	88 23       	and	r24, r24
    eca4:	29 f0       	breq	.+10     	; 0xecb0 <__vector_31+0x38>
    eca6:	8c e9       	ldi	r24, 0x9C	; 156
    eca8:	90 e0       	ldi	r25, 0x00	; 0
    ecaa:	0e 94 cb 38 	call	0x7196	; 0x7196 <Modbus_TX>
    ecae:	02 c0       	rjmp	.+4      	; 0xecb4 <__vector_31+0x3c>
	else EMeter_DRE();
    ecb0:	0e 94 be 75 	call	0xeb7c	; 0xeb7c <EMeter_DRE>
	COMM_LED = 1;
    ecb4:	81 e0       	ldi	r24, 0x01	; 1
    ecb6:	80 93 02 06 	sts	0x0602, r24
}
    ecba:	ff 91       	pop	r31
    ecbc:	ef 91       	pop	r30
    ecbe:	bf 91       	pop	r27
    ecc0:	af 91       	pop	r26
    ecc2:	9f 91       	pop	r25
    ecc4:	8f 91       	pop	r24
    ecc6:	7f 91       	pop	r23
    ecc8:	6f 91       	pop	r22
    ecca:	5f 91       	pop	r21
    eccc:	4f 91       	pop	r20
    ecce:	3f 91       	pop	r19
    ecd0:	2f 91       	pop	r18
    ecd2:	0f 90       	pop	r0
    ecd4:	0b be       	out	0x3b, r0	; 59
    ecd6:	0f 90       	pop	r0
    ecd8:	0f be       	out	0x3f, r0	; 63
    ecda:	0f 90       	pop	r0
    ecdc:	1f 90       	pop	r1
    ecde:	18 95       	reti

0000ece0 <ToggleLED>:

//#include "web.h"
#include "web_vem_levels.h"

void ToggleLED(uint8_t DO){
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    ece0:	40 91 47 09 	lds	r20, 0x0947
    ece4:	50 91 48 09 	lds	r21, 0x0948
    ece8:	60 91 49 09 	lds	r22, 0x0949
    ecec:	70 91 4a 09 	lds	r23, 0x094A
    ecf0:	42 fd       	sbrc	r20, 2
    ecf2:	0c 94 6e 3c 	jmp	0x78dc	; 0x78dc <ResDigOut>
	else SetDigOut(DO);
    ecf6:	0c 94 5c 3c 	jmp	0x78b8	; 0x78b8 <SetDigOut>

0000ecfa <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    ecfa:	0e 94 9f 2a 	call	0x553e	; 0x553e <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    ecfe:	0e 94 2e 59 	call	0xb25c	; 0xb25c <GPRS_AppInit>
	#endif

	WebInit();
    ed02:	0c 94 cb 43 	jmp	0x8796	; 0x8796 <WebInit>

0000ed06 <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
    ed06:	69 e0       	ldi	r22, 0x09	; 9
    ed08:	82 eb       	ldi	r24, 0xB2	; 178
    ed0a:	95 e0       	ldi	r25, 0x05	; 5
    ed0c:	0e 94 ae 70 	call	0xe15c	; 0xe15c <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
    ed10:	0e 94 92 61 	call	0xc324	; 0xc324 <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
    ed14:	0e 94 15 62 	call	0xc42a	; 0xc42a <Modbus_App>
		}
	*/	


	// GSM_DebugMode
	if(UART_Soft){
    ed18:	80 91 59 0a 	lds	r24, 0x0A59
    ed1c:	88 23       	and	r24, r24
    ed1e:	09 f1       	breq	.+66     	; 0xed62 <ApplCycle+0x5c>
		if(GSM_DebugMode){
    ed20:	80 91 d6 09 	lds	r24, 0x09D6
    ed24:	88 23       	and	r24, r24
    ed26:	81 f0       	breq	.+32     	; 0xed48 <ApplCycle+0x42>
			if( DI_State(DI_BL) ){
    ed28:	83 e0       	ldi	r24, 0x03	; 3
    ed2a:	0e 94 ed 3b 	call	0x77da	; 0x77da <DI_State>
    ed2e:	88 23       	and	r24, r24
    ed30:	41 f0       	breq	.+16     	; 0xed42 <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
    ed32:	81 e0       	ldi	r24, 0x01	; 1
    ed34:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ed38:	88 23       	and	r24, r24
    ed3a:	51 f1       	breq	.+84     	; 0xed90 <ApplCycle+0x8a>
					StopDebug();
    ed3c:	0e 94 28 63 	call	0xc650	; 0xc650 <StopDebug>
    ed40:	22 c0       	rjmp	.+68     	; 0xed86 <ApplCycle+0x80>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
    ed42:	62 e3       	ldi	r22, 0x32	; 50
    ed44:	70 e0       	ldi	r23, 0x00	; 0
    ed46:	21 c0       	rjmp	.+66     	; 0xed8a <ApplCycle+0x84>
		}
		else{
			if( DI_State(DI_BL) ){
    ed48:	83 e0       	ldi	r24, 0x03	; 3
    ed4a:	0e 94 ed 3b 	call	0x77da	; 0x77da <DI_State>
    ed4e:	88 23       	and	r24, r24
    ed50:	69 f0       	breq	.+26     	; 0xed6c <ApplCycle+0x66>
				if(Timer16Stopp(TD_GotoDebug)){
    ed52:	81 e0       	ldi	r24, 0x01	; 1
    ed54:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ed58:	88 23       	and	r24, r24
    ed5a:	d1 f0       	breq	.+52     	; 0xed90 <ApplCycle+0x8a>
					StartDebug();
    ed5c:	0e 94 14 63 	call	0xc628	; 0xc628 <StartDebug>
    ed60:	12 c0       	rjmp	.+36     	; 0xed86 <ApplCycle+0x80>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
    ed62:	83 e0       	ldi	r24, 0x03	; 3
    ed64:	0e 94 ed 3b 	call	0x77da	; 0x77da <DI_State>
    ed68:	81 11       	cpse	r24, r1
    ed6a:	03 c0       	rjmp	.+6      	; 0xed72 <ApplCycle+0x6c>
				if(Timer16Stopp(TD_GotoDebug)){
					StartDebug();
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,100);
    ed6c:	64 e6       	ldi	r22, 0x64	; 100
    ed6e:	70 e0       	ldi	r23, 0x00	; 0
    ed70:	0c c0       	rjmp	.+24     	; 0xed8a <ApplCycle+0x84>
		}
	}
	else{
		if( DI_State(DI_BL) ){
			if(Timer16Stopp(TD_GotoDebug)){
    ed72:	81 e0       	ldi	r24, 0x01	; 1
    ed74:	0e 94 b5 2c 	call	0x596a	; 0x596a <Timer16Stopp>
    ed78:	88 23       	and	r24, r24
    ed7a:	51 f0       	breq	.+20     	; 0xed90 <ApplCycle+0x8a>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
    ed7c:	6a e2       	ldi	r22, 0x2A	; 42
    ed7e:	7e e4       	ldi	r23, 0x4E	; 78
    ed80:	82 e0       	ldi	r24, 0x02	; 2
    ed82:	0e 94 f6 5b 	call	0xb7ec	; 0xb7ec <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
    ed86:	64 ef       	ldi	r22, 0xF4	; 244
    ed88:	71 e0       	ldi	r23, 0x01	; 1
    ed8a:	81 e0       	ldi	r24, 0x01	; 1
    ed8c:	0e 94 1a 2b 	call	0x5634	; 0x5634 <StartTimer16>
		}
		else StartTimer16(TD_GotoDebug,100);
	}

	// DO_BL
	if(GSM_DebugMode){
    ed90:	80 91 d6 09 	lds	r24, 0x09D6
    ed94:	88 23       	and	r24, r24
    ed96:	69 f0       	breq	.+26     	; 0xedb2 <ApplCycle+0xac>
		if(Timer8Stopp(TD_BlinkBL)){
    ed98:	81 e0       	ldi	r24, 0x01	; 1
    ed9a:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    ed9e:	88 23       	and	r24, r24
    eda0:	59 f0       	breq	.+22     	; 0xedb8 <ApplCycle+0xb2>
			StartTimer8(TD_BlinkBL,5);
    eda2:	65 e0       	ldi	r22, 0x05	; 5
    eda4:	81 e0       	ldi	r24, 0x01	; 1
    eda6:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
			TogDigOut(DO_BL);
    edaa:	82 e0       	ldi	r24, 0x02	; 2
    edac:	0e 94 81 3c 	call	0x7902	; 0x7902 <TogDigOut>
    edb0:	03 c0       	rjmp	.+6      	; 0xedb8 <ApplCycle+0xb2>
		}
	}
	else ResDigOut(DO_BL);
    edb2:	82 e0       	ldi	r24, 0x02	; 2
    edb4:	0e 94 6e 3c 	call	0x78dc	; 0x78dc <ResDigOut>

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
    edb8:	80 91 fd 05 	lds	r24, 0x05FD
    edbc:	81 30       	cpi	r24, 0x01	; 1
    edbe:	39 f4       	brne	.+14     	; 0xedce <ApplCycle+0xc8>
		StartTimer8(TD_GSM_LED,5);
    edc0:	65 e0       	ldi	r22, 0x05	; 5
    edc2:	83 e0       	ldi	r24, 0x03	; 3
    edc4:	0e 94 ec 2a 	call	0x55d8	; 0x55d8 <StartTimer8>
		GSM_LED = 2;
    edc8:	82 e0       	ldi	r24, 0x02	; 2
    edca:	80 93 fd 05 	sts	0x05FD, r24
	}
	if(GSM_LED ==2){
    edce:	80 91 fd 05 	lds	r24, 0x05FD
    edd2:	82 30       	cpi	r24, 0x02	; 2
    edd4:	31 f4       	brne	.+12     	; 0xede2 <ApplCycle+0xdc>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
    edd6:	83 e0       	ldi	r24, 0x03	; 3
    edd8:	0e 94 9a 2c 	call	0x5934	; 0x5934 <Timer8Stopp>
    eddc:	81 11       	cpse	r24, r1
    edde:	10 92 fd 05 	sts	0x05FD, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ServerIdle){
    ede2:	80 91 19 06 	lds	r24, 0x0619
    ede6:	88 32       	cpi	r24, 0x28	; 40
    ede8:	51 f4       	brne	.+20     	; 0xedfe <ApplCycle+0xf8>
		if(GSM_LED) ToggleLED(DO_GSM);
    edea:	80 91 fd 05 	lds	r24, 0x05FD
    edee:	88 23       	and	r24, r24
    edf0:	19 f0       	breq	.+6      	; 0xedf8 <ApplCycle+0xf2>
    edf2:	80 e0       	ldi	r24, 0x00	; 0
    edf4:	0c 94 70 76 	jmp	0xece0	; 0xece0 <ToggleLED>
		else SetDigOut(DO_GSM);
    edf8:	80 e0       	ldi	r24, 0x00	; 0
    edfa:	0c 94 5c 3c 	jmp	0x78b8	; 0x78b8 <SetDigOut>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
    edfe:	80 91 fd 05 	lds	r24, 0x05FD
    ee02:	81 11       	cpse	r24, r1
    ee04:	f6 cf       	rjmp	.-20     	; 0xedf2 <ApplCycle+0xec>
		else ResDigOut(DO_GSM);
    ee06:	0c 94 6e 3c 	jmp	0x78dc	; 0x78dc <ResDigOut>

0000ee0a <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimersInc();
    ee0a:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <TimersInc>
	TimeInit();
    ee0e:	0e 94 36 2d 	call	0x5a6c	; 0x5a6c <TimeInit>
	MemCheckInit();
    ee12:	0e 94 75 2a 	call	0x54ea	; 0x54ea <MemCheckInit>

// ~~~~~~~~~~
void
DI_Init(void)
{
	DI_Init_Hard();
    ee16:	0e 94 54 29 	call	0x52a8	; 0x52a8 <DI_Init_Hard>
	LED_Init();
	DigitInit();
    ee1a:	0e 94 c6 3c 	call	0x798c	; 0x798c <DO_Init>
	OneWire_Init();
    ee1e:	0e 94 6b 3d 	call	0x7ad6	; 0x7ad6 <OneWire_Init>
	USART_Init();
    ee22:	0e 94 6a 4c 	call	0x98d4	; 0x98d4 <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    ee26:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {TimersInc();
    ee28:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <TimersInc>
		wdt_reset();
    ee2c:	a8 95       	wdr
		DigitIn();
    ee2e:	0e 94 11 3c 	call	0x7822	; 0x7822 <DigitIn>
		DS18B20();
    ee32:	0e 94 a6 3e 	call	0x7d4c	; 0x7d4c <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
    ee36:	80 91 4e 02 	lds	r24, 0x024E
    ee3a:	87 30       	cpi	r24, 0x07	; 7
    ee3c:	a9 f7       	brne	.-22     	; 0xee28 <main+0x1e>

//	MemCheckMsg();

	ApplInit();
    ee3e:	0e 94 7d 76 	call	0xecfa	; 0xecfa <ApplInit>
	
	ScanCycleInit();
    ee42:	0e 94 74 2d 	call	0x5ae8	; 0x5ae8 <ScanCycleInit>

	for(;;) {TimersInc();
    ee46:	0e 94 ca 2d 	call	0x5b94	; 0x5b94 <TimersInc>
		sei();
    ee4a:	78 94       	sei

		TimeCycle();
    ee4c:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <TimeCycle>
		DigitIn();
    ee50:	0e 94 11 3c 	call	0x7822	; 0x7822 <DigitIn>
		DS18B20();
    ee54:	0e 94 a6 3e 	call	0x7d4c	; 0x7d4c <DS18B20>
		USART_Cycle();
    ee58:	0e 94 73 70 	call	0xe0e6	; 0xe0e6 <USART_Cycle>

		ApplCycle();
    ee5c:	0e 94 83 76 	call	0xed06	; 0xed06 <ApplCycle>

		DigitOut();
    ee60:	0e 94 93 3c 	call	0x7926	; 0x7926 <DigitOut>
    ee64:	f0 cf       	rjmp	.-32     	; 0xee46 <main+0x3c>

0000ee66 <do_random>:
    ee66:	8f 92       	push	r8
    ee68:	9f 92       	push	r9
    ee6a:	af 92       	push	r10
    ee6c:	bf 92       	push	r11
    ee6e:	cf 92       	push	r12
    ee70:	df 92       	push	r13
    ee72:	ef 92       	push	r14
    ee74:	ff 92       	push	r15
    ee76:	cf 93       	push	r28
    ee78:	df 93       	push	r29
    ee7a:	ec 01       	movw	r28, r24
    ee7c:	68 81       	ld	r22, Y
    ee7e:	79 81       	ldd	r23, Y+1	; 0x01
    ee80:	8a 81       	ldd	r24, Y+2	; 0x02
    ee82:	9b 81       	ldd	r25, Y+3	; 0x03
    ee84:	61 15       	cp	r22, r1
    ee86:	71 05       	cpc	r23, r1
    ee88:	81 05       	cpc	r24, r1
    ee8a:	91 05       	cpc	r25, r1
    ee8c:	21 f4       	brne	.+8      	; 0xee96 <do_random+0x30>
    ee8e:	64 e2       	ldi	r22, 0x24	; 36
    ee90:	79 ed       	ldi	r23, 0xD9	; 217
    ee92:	8b e5       	ldi	r24, 0x5B	; 91
    ee94:	97 e0       	ldi	r25, 0x07	; 7
    ee96:	2d e1       	ldi	r18, 0x1D	; 29
    ee98:	33 ef       	ldi	r19, 0xF3	; 243
    ee9a:	41 e0       	ldi	r20, 0x01	; 1
    ee9c:	50 e0       	ldi	r21, 0x00	; 0
    ee9e:	0e 94 cd 80 	call	0x1019a	; 0x1019a <__divmodsi4>
    eea2:	49 01       	movw	r8, r18
    eea4:	5a 01       	movw	r10, r20
    eea6:	9b 01       	movw	r18, r22
    eea8:	ac 01       	movw	r20, r24
    eeaa:	a7 ea       	ldi	r26, 0xA7	; 167
    eeac:	b1 e4       	ldi	r27, 0x41	; 65
    eeae:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
    eeb2:	6b 01       	movw	r12, r22
    eeb4:	7c 01       	movw	r14, r24
    eeb6:	ac ee       	ldi	r26, 0xEC	; 236
    eeb8:	b4 ef       	ldi	r27, 0xF4	; 244
    eeba:	a5 01       	movw	r20, r10
    eebc:	94 01       	movw	r18, r8
    eebe:	0e 94 00 81 	call	0x10200	; 0x10200 <__mulohisi3>
    eec2:	c6 0e       	add	r12, r22
    eec4:	d7 1e       	adc	r13, r23
    eec6:	e8 1e       	adc	r14, r24
    eec8:	f9 1e       	adc	r15, r25
    eeca:	f7 fe       	sbrs	r15, 7
    eecc:	06 c0       	rjmp	.+12     	; 0xeeda <do_random+0x74>
    eece:	81 e0       	ldi	r24, 0x01	; 1
    eed0:	c8 1a       	sub	r12, r24
    eed2:	d1 08       	sbc	r13, r1
    eed4:	e1 08       	sbc	r14, r1
    eed6:	80 e8       	ldi	r24, 0x80	; 128
    eed8:	f8 0a       	sbc	r15, r24
    eeda:	c8 82       	st	Y, r12
    eedc:	d9 82       	std	Y+1, r13	; 0x01
    eede:	ea 82       	std	Y+2, r14	; 0x02
    eee0:	fb 82       	std	Y+3, r15	; 0x03
    eee2:	c7 01       	movw	r24, r14
    eee4:	b6 01       	movw	r22, r12
    eee6:	9f 77       	andi	r25, 0x7F	; 127
    eee8:	df 91       	pop	r29
    eeea:	cf 91       	pop	r28
    eeec:	ff 90       	pop	r15
    eeee:	ef 90       	pop	r14
    eef0:	df 90       	pop	r13
    eef2:	cf 90       	pop	r12
    eef4:	bf 90       	pop	r11
    eef6:	af 90       	pop	r10
    eef8:	9f 90       	pop	r9
    eefa:	8f 90       	pop	r8
    eefc:	08 95       	ret

0000eefe <random_r>:
    eefe:	0c 94 33 77 	jmp	0xee66	; 0xee66 <do_random>

0000ef02 <random>:
    ef02:	80 e0       	ldi	r24, 0x00	; 0
    ef04:	91 e0       	ldi	r25, 0x01	; 1
    ef06:	0c 94 33 77 	jmp	0xee66	; 0xee66 <do_random>

0000ef0a <srandom>:
    ef0a:	60 93 00 01 	sts	0x0100, r22
    ef0e:	70 93 01 01 	sts	0x0101, r23
    ef12:	80 93 02 01 	sts	0x0102, r24
    ef16:	90 93 03 01 	sts	0x0103, r25
    ef1a:	08 95       	ret

0000ef1c <exit>:
    ef1c:	f8 94       	cli
    ef1e:	0c 94 76 81 	jmp	0x102ec	; 0x102ec <_exit>

0000ef22 <memcpy_P>:
    ef22:	fb 01       	movw	r30, r22
    ef24:	dc 01       	movw	r26, r24
    ef26:	02 c0       	rjmp	.+4      	; 0xef2c <memcpy_P+0xa>
    ef28:	05 90       	lpm	r0, Z+
    ef2a:	0d 92       	st	X+, r0
    ef2c:	41 50       	subi	r20, 0x01	; 1
    ef2e:	50 40       	sbci	r21, 0x00	; 0
    ef30:	d8 f7       	brcc	.-10     	; 0xef28 <memcpy_P+0x6>
    ef32:	08 95       	ret

0000ef34 <strchr_P>:
    ef34:	fc 01       	movw	r30, r24
    ef36:	05 90       	lpm	r0, Z+
    ef38:	06 16       	cp	r0, r22
    ef3a:	21 f0       	breq	.+8      	; 0xef44 <strchr_P+0x10>
    ef3c:	00 20       	and	r0, r0
    ef3e:	d9 f7       	brne	.-10     	; 0xef36 <strchr_P+0x2>
    ef40:	c0 01       	movw	r24, r0
    ef42:	08 95       	ret
    ef44:	31 97       	sbiw	r30, 0x01	; 1
    ef46:	cf 01       	movw	r24, r30
    ef48:	08 95       	ret

0000ef4a <strcmp_P>:
    ef4a:	fb 01       	movw	r30, r22
    ef4c:	dc 01       	movw	r26, r24
    ef4e:	8d 91       	ld	r24, X+
    ef50:	05 90       	lpm	r0, Z+
    ef52:	80 19       	sub	r24, r0
    ef54:	01 10       	cpse	r0, r1
    ef56:	d9 f3       	breq	.-10     	; 0xef4e <strcmp_P+0x4>
    ef58:	99 0b       	sbc	r25, r25
    ef5a:	08 95       	ret

0000ef5c <strcpy_P>:
    ef5c:	fb 01       	movw	r30, r22
    ef5e:	dc 01       	movw	r26, r24
    ef60:	05 90       	lpm	r0, Z+
    ef62:	0d 92       	st	X+, r0
    ef64:	00 20       	and	r0, r0
    ef66:	e1 f7       	brne	.-8      	; 0xef60 <strcpy_P+0x4>
    ef68:	08 95       	ret

0000ef6a <strlcpy_P>:
    ef6a:	dc 01       	movw	r26, r24
    ef6c:	fb 01       	movw	r30, r22
    ef6e:	41 50       	subi	r20, 0x01	; 1
    ef70:	50 40       	sbci	r21, 0x00	; 0
    ef72:	58 f0       	brcs	.+22     	; 0xef8a <strlcpy_P+0x20>
    ef74:	49 f0       	breq	.+18     	; 0xef88 <strlcpy_P+0x1e>
    ef76:	05 90       	lpm	r0, Z+
    ef78:	0d 92       	st	X+, r0
    ef7a:	00 20       	and	r0, r0
    ef7c:	c1 f7       	brne	.-16     	; 0xef6e <strlcpy_P+0x4>
    ef7e:	e6 1b       	sub	r30, r22
    ef80:	f7 0b       	sbc	r31, r23
    ef82:	31 97       	sbiw	r30, 0x01	; 1
    ef84:	cf 01       	movw	r24, r30
    ef86:	08 95       	ret
    ef88:	1c 92       	st	X, r1
    ef8a:	05 90       	lpm	r0, Z+
    ef8c:	00 20       	and	r0, r0
    ef8e:	e9 f7       	brne	.-6      	; 0xef8a <strlcpy_P+0x20>
    ef90:	f6 cf       	rjmp	.-20     	; 0xef7e <strlcpy_P+0x14>

0000ef92 <__strlen_P>:
    ef92:	fc 01       	movw	r30, r24
    ef94:	05 90       	lpm	r0, Z+
    ef96:	00 20       	and	r0, r0
    ef98:	e9 f7       	brne	.-6      	; 0xef94 <__strlen_P+0x2>
    ef9a:	80 95       	com	r24
    ef9c:	90 95       	com	r25
    ef9e:	8e 0f       	add	r24, r30
    efa0:	9f 1f       	adc	r25, r31
    efa2:	08 95       	ret

0000efa4 <strncmp_P>:
    efa4:	fb 01       	movw	r30, r22
    efa6:	dc 01       	movw	r26, r24
    efa8:	41 50       	subi	r20, 0x01	; 1
    efaa:	50 40       	sbci	r21, 0x00	; 0
    efac:	30 f0       	brcs	.+12     	; 0xefba <strncmp_P+0x16>
    efae:	8d 91       	ld	r24, X+
    efb0:	05 90       	lpm	r0, Z+
    efb2:	80 19       	sub	r24, r0
    efb4:	19 f4       	brne	.+6      	; 0xefbc <strncmp_P+0x18>
    efb6:	00 20       	and	r0, r0
    efb8:	b9 f7       	brne	.-18     	; 0xefa8 <strncmp_P+0x4>
    efba:	88 1b       	sub	r24, r24
    efbc:	99 0b       	sbc	r25, r25
    efbe:	08 95       	ret

0000efc0 <strstr_P>:
    efc0:	fb 01       	movw	r30, r22
    efc2:	55 91       	lpm	r21, Z+
    efc4:	55 23       	and	r21, r21
    efc6:	a9 f0       	breq	.+42     	; 0xeff2 <strstr_P+0x32>
    efc8:	bf 01       	movw	r22, r30
    efca:	dc 01       	movw	r26, r24
    efcc:	4d 91       	ld	r20, X+
    efce:	45 17       	cp	r20, r21
    efd0:	41 11       	cpse	r20, r1
    efd2:	e1 f7       	brne	.-8      	; 0xefcc <strstr_P+0xc>
    efd4:	59 f4       	brne	.+22     	; 0xefec <strstr_P+0x2c>
    efd6:	cd 01       	movw	r24, r26
    efd8:	05 90       	lpm	r0, Z+
    efda:	00 20       	and	r0, r0
    efdc:	49 f0       	breq	.+18     	; 0xeff0 <strstr_P+0x30>
    efde:	4d 91       	ld	r20, X+
    efe0:	40 15       	cp	r20, r0
    efe2:	41 11       	cpse	r20, r1
    efe4:	c9 f3       	breq	.-14     	; 0xefd8 <strstr_P+0x18>
    efe6:	fb 01       	movw	r30, r22
    efe8:	41 11       	cpse	r20, r1
    efea:	ef cf       	rjmp	.-34     	; 0xefca <strstr_P+0xa>
    efec:	81 e0       	ldi	r24, 0x01	; 1
    efee:	90 e0       	ldi	r25, 0x00	; 0
    eff0:	01 97       	sbiw	r24, 0x01	; 1
    eff2:	08 95       	ret

0000eff4 <memcpy>:
    eff4:	fb 01       	movw	r30, r22
    eff6:	dc 01       	movw	r26, r24
    eff8:	02 c0       	rjmp	.+4      	; 0xeffe <memcpy+0xa>
    effa:	01 90       	ld	r0, Z+
    effc:	0d 92       	st	X+, r0
    effe:	41 50       	subi	r20, 0x01	; 1
    f000:	50 40       	sbci	r21, 0x00	; 0
    f002:	d8 f7       	brcc	.-10     	; 0xeffa <memcpy+0x6>
    f004:	08 95       	ret

0000f006 <strchr>:
    f006:	fc 01       	movw	r30, r24
    f008:	81 91       	ld	r24, Z+
    f00a:	86 17       	cp	r24, r22
    f00c:	21 f0       	breq	.+8      	; 0xf016 <strchr+0x10>
    f00e:	88 23       	and	r24, r24
    f010:	d9 f7       	brne	.-10     	; 0xf008 <strchr+0x2>
    f012:	99 27       	eor	r25, r25
    f014:	08 95       	ret
    f016:	31 97       	sbiw	r30, 0x01	; 1
    f018:	cf 01       	movw	r24, r30
    f01a:	08 95       	ret

0000f01c <strcmp>:
    f01c:	fb 01       	movw	r30, r22
    f01e:	dc 01       	movw	r26, r24
    f020:	8d 91       	ld	r24, X+
    f022:	01 90       	ld	r0, Z+
    f024:	80 19       	sub	r24, r0
    f026:	01 10       	cpse	r0, r1
    f028:	d9 f3       	breq	.-10     	; 0xf020 <strcmp+0x4>
    f02a:	99 0b       	sbc	r25, r25
    f02c:	08 95       	ret

0000f02e <strcpy>:
    f02e:	fb 01       	movw	r30, r22
    f030:	dc 01       	movw	r26, r24
    f032:	01 90       	ld	r0, Z+
    f034:	0d 92       	st	X+, r0
    f036:	00 20       	and	r0, r0
    f038:	e1 f7       	brne	.-8      	; 0xf032 <strcpy+0x4>
    f03a:	08 95       	ret

0000f03c <strncmp>:
    f03c:	fb 01       	movw	r30, r22
    f03e:	dc 01       	movw	r26, r24
    f040:	41 50       	subi	r20, 0x01	; 1
    f042:	50 40       	sbci	r21, 0x00	; 0
    f044:	30 f0       	brcs	.+12     	; 0xf052 <strncmp+0x16>
    f046:	8d 91       	ld	r24, X+
    f048:	01 90       	ld	r0, Z+
    f04a:	80 19       	sub	r24, r0
    f04c:	19 f4       	brne	.+6      	; 0xf054 <strncmp+0x18>
    f04e:	00 20       	and	r0, r0
    f050:	b9 f7       	brne	.-18     	; 0xf040 <strncmp+0x4>
    f052:	88 1b       	sub	r24, r24
    f054:	99 0b       	sbc	r25, r25
    f056:	08 95       	ret

0000f058 <sprintf>:
    f058:	0f 93       	push	r16
    f05a:	1f 93       	push	r17
    f05c:	cf 93       	push	r28
    f05e:	df 93       	push	r29
    f060:	cd b7       	in	r28, 0x3d	; 61
    f062:	de b7       	in	r29, 0x3e	; 62
    f064:	2e 97       	sbiw	r28, 0x0e	; 14
    f066:	0f b6       	in	r0, 0x3f	; 63
    f068:	f8 94       	cli
    f06a:	de bf       	out	0x3e, r29	; 62
    f06c:	0f be       	out	0x3f, r0	; 63
    f06e:	cd bf       	out	0x3d, r28	; 61
    f070:	0d 89       	ldd	r16, Y+21	; 0x15
    f072:	1e 89       	ldd	r17, Y+22	; 0x16
    f074:	86 e0       	ldi	r24, 0x06	; 6
    f076:	8c 83       	std	Y+4, r24	; 0x04
    f078:	1a 83       	std	Y+2, r17	; 0x02
    f07a:	09 83       	std	Y+1, r16	; 0x01
    f07c:	8f ef       	ldi	r24, 0xFF	; 255
    f07e:	9f e7       	ldi	r25, 0x7F	; 127
    f080:	9e 83       	std	Y+6, r25	; 0x06
    f082:	8d 83       	std	Y+5, r24	; 0x05
    f084:	ae 01       	movw	r20, r28
    f086:	47 5e       	subi	r20, 0xE7	; 231
    f088:	5f 4f       	sbci	r21, 0xFF	; 255
    f08a:	6f 89       	ldd	r22, Y+23	; 0x17
    f08c:	78 8d       	ldd	r23, Y+24	; 0x18
    f08e:	ce 01       	movw	r24, r28
    f090:	01 96       	adiw	r24, 0x01	; 1
    f092:	0e 94 58 7a 	call	0xf4b0	; 0xf4b0 <vfprintf>
    f096:	ef 81       	ldd	r30, Y+7	; 0x07
    f098:	f8 85       	ldd	r31, Y+8	; 0x08
    f09a:	e0 0f       	add	r30, r16
    f09c:	f1 1f       	adc	r31, r17
    f09e:	10 82       	st	Z, r1
    f0a0:	2e 96       	adiw	r28, 0x0e	; 14
    f0a2:	0f b6       	in	r0, 0x3f	; 63
    f0a4:	f8 94       	cli
    f0a6:	de bf       	out	0x3e, r29	; 62
    f0a8:	0f be       	out	0x3f, r0	; 63
    f0aa:	cd bf       	out	0x3d, r28	; 61
    f0ac:	df 91       	pop	r29
    f0ae:	cf 91       	pop	r28
    f0b0:	1f 91       	pop	r17
    f0b2:	0f 91       	pop	r16
    f0b4:	08 95       	ret

0000f0b6 <sprintf_P>:
    f0b6:	0f 93       	push	r16
    f0b8:	1f 93       	push	r17
    f0ba:	cf 93       	push	r28
    f0bc:	df 93       	push	r29
    f0be:	cd b7       	in	r28, 0x3d	; 61
    f0c0:	de b7       	in	r29, 0x3e	; 62
    f0c2:	2e 97       	sbiw	r28, 0x0e	; 14
    f0c4:	0f b6       	in	r0, 0x3f	; 63
    f0c6:	f8 94       	cli
    f0c8:	de bf       	out	0x3e, r29	; 62
    f0ca:	0f be       	out	0x3f, r0	; 63
    f0cc:	cd bf       	out	0x3d, r28	; 61
    f0ce:	0d 89       	ldd	r16, Y+21	; 0x15
    f0d0:	1e 89       	ldd	r17, Y+22	; 0x16
    f0d2:	8e e0       	ldi	r24, 0x0E	; 14
    f0d4:	8c 83       	std	Y+4, r24	; 0x04
    f0d6:	1a 83       	std	Y+2, r17	; 0x02
    f0d8:	09 83       	std	Y+1, r16	; 0x01
    f0da:	8f ef       	ldi	r24, 0xFF	; 255
    f0dc:	9f e7       	ldi	r25, 0x7F	; 127
    f0de:	9e 83       	std	Y+6, r25	; 0x06
    f0e0:	8d 83       	std	Y+5, r24	; 0x05
    f0e2:	ae 01       	movw	r20, r28
    f0e4:	47 5e       	subi	r20, 0xE7	; 231
    f0e6:	5f 4f       	sbci	r21, 0xFF	; 255
    f0e8:	6f 89       	ldd	r22, Y+23	; 0x17
    f0ea:	78 8d       	ldd	r23, Y+24	; 0x18
    f0ec:	ce 01       	movw	r24, r28
    f0ee:	01 96       	adiw	r24, 0x01	; 1
    f0f0:	0e 94 58 7a 	call	0xf4b0	; 0xf4b0 <vfprintf>
    f0f4:	ef 81       	ldd	r30, Y+7	; 0x07
    f0f6:	f8 85       	ldd	r31, Y+8	; 0x08
    f0f8:	e0 0f       	add	r30, r16
    f0fa:	f1 1f       	adc	r31, r17
    f0fc:	10 82       	st	Z, r1
    f0fe:	2e 96       	adiw	r28, 0x0e	; 14
    f100:	0f b6       	in	r0, 0x3f	; 63
    f102:	f8 94       	cli
    f104:	de bf       	out	0x3e, r29	; 62
    f106:	0f be       	out	0x3f, r0	; 63
    f108:	cd bf       	out	0x3d, r28	; 61
    f10a:	df 91       	pop	r29
    f10c:	cf 91       	pop	r28
    f10e:	1f 91       	pop	r17
    f110:	0f 91       	pop	r16
    f112:	08 95       	ret

0000f114 <sscanf>:
    f114:	cf 93       	push	r28
    f116:	df 93       	push	r29
    f118:	cd b7       	in	r28, 0x3d	; 61
    f11a:	de b7       	in	r29, 0x3e	; 62
    f11c:	2e 97       	sbiw	r28, 0x0e	; 14
    f11e:	0f b6       	in	r0, 0x3f	; 63
    f120:	f8 94       	cli
    f122:	de bf       	out	0x3e, r29	; 62
    f124:	0f be       	out	0x3f, r0	; 63
    f126:	cd bf       	out	0x3d, r28	; 61
    f128:	85 e0       	ldi	r24, 0x05	; 5
    f12a:	8c 83       	std	Y+4, r24	; 0x04
    f12c:	8b 89       	ldd	r24, Y+19	; 0x13
    f12e:	9c 89       	ldd	r25, Y+20	; 0x14
    f130:	9a 83       	std	Y+2, r25	; 0x02
    f132:	89 83       	std	Y+1, r24	; 0x01
    f134:	ae 01       	movw	r20, r28
    f136:	49 5e       	subi	r20, 0xE9	; 233
    f138:	5f 4f       	sbci	r21, 0xFF	; 255
    f13a:	6d 89       	ldd	r22, Y+21	; 0x15
    f13c:	7e 89       	ldd	r23, Y+22	; 0x16
    f13e:	ce 01       	movw	r24, r28
    f140:	01 96       	adiw	r24, 0x01	; 1
    f142:	0e 94 f0 7d 	call	0xfbe0	; 0xfbe0 <vfscanf>
    f146:	2e 96       	adiw	r28, 0x0e	; 14
    f148:	0f b6       	in	r0, 0x3f	; 63
    f14a:	f8 94       	cli
    f14c:	de bf       	out	0x3e, r29	; 62
    f14e:	0f be       	out	0x3f, r0	; 63
    f150:	cd bf       	out	0x3d, r28	; 61
    f152:	df 91       	pop	r29
    f154:	cf 91       	pop	r28
    f156:	08 95       	ret

0000f158 <sscanf_P>:
    f158:	cf 93       	push	r28
    f15a:	df 93       	push	r29
    f15c:	cd b7       	in	r28, 0x3d	; 61
    f15e:	de b7       	in	r29, 0x3e	; 62
    f160:	2e 97       	sbiw	r28, 0x0e	; 14
    f162:	0f b6       	in	r0, 0x3f	; 63
    f164:	f8 94       	cli
    f166:	de bf       	out	0x3e, r29	; 62
    f168:	0f be       	out	0x3f, r0	; 63
    f16a:	cd bf       	out	0x3d, r28	; 61
    f16c:	8d e0       	ldi	r24, 0x0D	; 13
    f16e:	8c 83       	std	Y+4, r24	; 0x04
    f170:	8b 89       	ldd	r24, Y+19	; 0x13
    f172:	9c 89       	ldd	r25, Y+20	; 0x14
    f174:	9a 83       	std	Y+2, r25	; 0x02
    f176:	89 83       	std	Y+1, r24	; 0x01
    f178:	ae 01       	movw	r20, r28
    f17a:	49 5e       	subi	r20, 0xE9	; 233
    f17c:	5f 4f       	sbci	r21, 0xFF	; 255
    f17e:	6d 89       	ldd	r22, Y+21	; 0x15
    f180:	7e 89       	ldd	r23, Y+22	; 0x16
    f182:	ce 01       	movw	r24, r28
    f184:	01 96       	adiw	r24, 0x01	; 1
    f186:	0e 94 f0 7d 	call	0xfbe0	; 0xfbe0 <vfscanf>
    f18a:	2e 96       	adiw	r28, 0x0e	; 14
    f18c:	0f b6       	in	r0, 0x3f	; 63
    f18e:	f8 94       	cli
    f190:	de bf       	out	0x3e, r29	; 62
    f192:	0f be       	out	0x3f, r0	; 63
    f194:	cd bf       	out	0x3d, r28	; 61
    f196:	df 91       	pop	r29
    f198:	cf 91       	pop	r28
    f19a:	08 95       	ret

0000f19c <__divsf3>:
    f19c:	0c d0       	rcall	.+24     	; 0xf1b6 <__divsf3x>
    f19e:	eb c0       	rjmp	.+470    	; 0xf376 <__fp_round>
    f1a0:	e3 d0       	rcall	.+454    	; 0xf368 <__fp_pscB>
    f1a2:	40 f0       	brcs	.+16     	; 0xf1b4 <__divsf3+0x18>
    f1a4:	da d0       	rcall	.+436    	; 0xf35a <__fp_pscA>
    f1a6:	30 f0       	brcs	.+12     	; 0xf1b4 <__divsf3+0x18>
    f1a8:	21 f4       	brne	.+8      	; 0xf1b2 <__divsf3+0x16>
    f1aa:	5f 3f       	cpi	r21, 0xFF	; 255
    f1ac:	19 f0       	breq	.+6      	; 0xf1b4 <__divsf3+0x18>
    f1ae:	cc c0       	rjmp	.+408    	; 0xf348 <__fp_inf>
    f1b0:	51 11       	cpse	r21, r1
    f1b2:	15 c1       	rjmp	.+554    	; 0xf3de <__fp_szero>
    f1b4:	cf c0       	rjmp	.+414    	; 0xf354 <__fp_nan>

0000f1b6 <__divsf3x>:
    f1b6:	f0 d0       	rcall	.+480    	; 0xf398 <__fp_split3>
    f1b8:	98 f3       	brcs	.-26     	; 0xf1a0 <__divsf3+0x4>

0000f1ba <__divsf3_pse>:
    f1ba:	99 23       	and	r25, r25
    f1bc:	c9 f3       	breq	.-14     	; 0xf1b0 <__divsf3+0x14>
    f1be:	55 23       	and	r21, r21
    f1c0:	b1 f3       	breq	.-20     	; 0xf1ae <__divsf3+0x12>
    f1c2:	95 1b       	sub	r25, r21
    f1c4:	55 0b       	sbc	r21, r21
    f1c6:	bb 27       	eor	r27, r27
    f1c8:	aa 27       	eor	r26, r26
    f1ca:	62 17       	cp	r22, r18
    f1cc:	73 07       	cpc	r23, r19
    f1ce:	84 07       	cpc	r24, r20
    f1d0:	38 f0       	brcs	.+14     	; 0xf1e0 <__divsf3_pse+0x26>
    f1d2:	9f 5f       	subi	r25, 0xFF	; 255
    f1d4:	5f 4f       	sbci	r21, 0xFF	; 255
    f1d6:	22 0f       	add	r18, r18
    f1d8:	33 1f       	adc	r19, r19
    f1da:	44 1f       	adc	r20, r20
    f1dc:	aa 1f       	adc	r26, r26
    f1de:	a9 f3       	breq	.-22     	; 0xf1ca <__divsf3_pse+0x10>
    f1e0:	33 d0       	rcall	.+102    	; 0xf248 <__divsf3_pse+0x8e>
    f1e2:	0e 2e       	mov	r0, r30
    f1e4:	3a f0       	brmi	.+14     	; 0xf1f4 <__divsf3_pse+0x3a>
    f1e6:	e0 e8       	ldi	r30, 0x80	; 128
    f1e8:	30 d0       	rcall	.+96     	; 0xf24a <__divsf3_pse+0x90>
    f1ea:	91 50       	subi	r25, 0x01	; 1
    f1ec:	50 40       	sbci	r21, 0x00	; 0
    f1ee:	e6 95       	lsr	r30
    f1f0:	00 1c       	adc	r0, r0
    f1f2:	ca f7       	brpl	.-14     	; 0xf1e6 <__divsf3_pse+0x2c>
    f1f4:	29 d0       	rcall	.+82     	; 0xf248 <__divsf3_pse+0x8e>
    f1f6:	fe 2f       	mov	r31, r30
    f1f8:	27 d0       	rcall	.+78     	; 0xf248 <__divsf3_pse+0x8e>
    f1fa:	66 0f       	add	r22, r22
    f1fc:	77 1f       	adc	r23, r23
    f1fe:	88 1f       	adc	r24, r24
    f200:	bb 1f       	adc	r27, r27
    f202:	26 17       	cp	r18, r22
    f204:	37 07       	cpc	r19, r23
    f206:	48 07       	cpc	r20, r24
    f208:	ab 07       	cpc	r26, r27
    f20a:	b0 e8       	ldi	r27, 0x80	; 128
    f20c:	09 f0       	breq	.+2      	; 0xf210 <__divsf3_pse+0x56>
    f20e:	bb 0b       	sbc	r27, r27
    f210:	80 2d       	mov	r24, r0
    f212:	bf 01       	movw	r22, r30
    f214:	ff 27       	eor	r31, r31
    f216:	93 58       	subi	r25, 0x83	; 131
    f218:	5f 4f       	sbci	r21, 0xFF	; 255
    f21a:	2a f0       	brmi	.+10     	; 0xf226 <__divsf3_pse+0x6c>
    f21c:	9e 3f       	cpi	r25, 0xFE	; 254
    f21e:	51 05       	cpc	r21, r1
    f220:	68 f0       	brcs	.+26     	; 0xf23c <__divsf3_pse+0x82>
    f222:	92 c0       	rjmp	.+292    	; 0xf348 <__fp_inf>
    f224:	dc c0       	rjmp	.+440    	; 0xf3de <__fp_szero>
    f226:	5f 3f       	cpi	r21, 0xFF	; 255
    f228:	ec f3       	brlt	.-6      	; 0xf224 <__divsf3_pse+0x6a>
    f22a:	98 3e       	cpi	r25, 0xE8	; 232
    f22c:	dc f3       	brlt	.-10     	; 0xf224 <__divsf3_pse+0x6a>
    f22e:	86 95       	lsr	r24
    f230:	77 95       	ror	r23
    f232:	67 95       	ror	r22
    f234:	b7 95       	ror	r27
    f236:	f7 95       	ror	r31
    f238:	9f 5f       	subi	r25, 0xFF	; 255
    f23a:	c9 f7       	brne	.-14     	; 0xf22e <__divsf3_pse+0x74>
    f23c:	88 0f       	add	r24, r24
    f23e:	91 1d       	adc	r25, r1
    f240:	96 95       	lsr	r25
    f242:	87 95       	ror	r24
    f244:	97 f9       	bld	r25, 7
    f246:	08 95       	ret
    f248:	e1 e0       	ldi	r30, 0x01	; 1
    f24a:	66 0f       	add	r22, r22
    f24c:	77 1f       	adc	r23, r23
    f24e:	88 1f       	adc	r24, r24
    f250:	bb 1f       	adc	r27, r27
    f252:	62 17       	cp	r22, r18
    f254:	73 07       	cpc	r23, r19
    f256:	84 07       	cpc	r24, r20
    f258:	ba 07       	cpc	r27, r26
    f25a:	20 f0       	brcs	.+8      	; 0xf264 <__divsf3_pse+0xaa>
    f25c:	62 1b       	sub	r22, r18
    f25e:	73 0b       	sbc	r23, r19
    f260:	84 0b       	sbc	r24, r20
    f262:	ba 0b       	sbc	r27, r26
    f264:	ee 1f       	adc	r30, r30
    f266:	88 f7       	brcc	.-30     	; 0xf24a <__divsf3_pse+0x90>
    f268:	e0 95       	com	r30
    f26a:	08 95       	ret

0000f26c <__fixsfsi>:
    f26c:	04 d0       	rcall	.+8      	; 0xf276 <__fixunssfsi>
    f26e:	68 94       	set
    f270:	b1 11       	cpse	r27, r1
    f272:	b5 c0       	rjmp	.+362    	; 0xf3de <__fp_szero>
    f274:	08 95       	ret

0000f276 <__fixunssfsi>:
    f276:	98 d0       	rcall	.+304    	; 0xf3a8 <__fp_splitA>
    f278:	88 f0       	brcs	.+34     	; 0xf29c <__fixunssfsi+0x26>
    f27a:	9f 57       	subi	r25, 0x7F	; 127
    f27c:	90 f0       	brcs	.+36     	; 0xf2a2 <__fixunssfsi+0x2c>
    f27e:	b9 2f       	mov	r27, r25
    f280:	99 27       	eor	r25, r25
    f282:	b7 51       	subi	r27, 0x17	; 23
    f284:	a0 f0       	brcs	.+40     	; 0xf2ae <__fixunssfsi+0x38>
    f286:	d1 f0       	breq	.+52     	; 0xf2bc <__fixunssfsi+0x46>
    f288:	66 0f       	add	r22, r22
    f28a:	77 1f       	adc	r23, r23
    f28c:	88 1f       	adc	r24, r24
    f28e:	99 1f       	adc	r25, r25
    f290:	1a f0       	brmi	.+6      	; 0xf298 <__fixunssfsi+0x22>
    f292:	ba 95       	dec	r27
    f294:	c9 f7       	brne	.-14     	; 0xf288 <__fixunssfsi+0x12>
    f296:	12 c0       	rjmp	.+36     	; 0xf2bc <__fixunssfsi+0x46>
    f298:	b1 30       	cpi	r27, 0x01	; 1
    f29a:	81 f0       	breq	.+32     	; 0xf2bc <__fixunssfsi+0x46>
    f29c:	9f d0       	rcall	.+318    	; 0xf3dc <__fp_zero>
    f29e:	b1 e0       	ldi	r27, 0x01	; 1
    f2a0:	08 95       	ret
    f2a2:	9c c0       	rjmp	.+312    	; 0xf3dc <__fp_zero>
    f2a4:	67 2f       	mov	r22, r23
    f2a6:	78 2f       	mov	r23, r24
    f2a8:	88 27       	eor	r24, r24
    f2aa:	b8 5f       	subi	r27, 0xF8	; 248
    f2ac:	39 f0       	breq	.+14     	; 0xf2bc <__fixunssfsi+0x46>
    f2ae:	b9 3f       	cpi	r27, 0xF9	; 249
    f2b0:	cc f3       	brlt	.-14     	; 0xf2a4 <__fixunssfsi+0x2e>
    f2b2:	86 95       	lsr	r24
    f2b4:	77 95       	ror	r23
    f2b6:	67 95       	ror	r22
    f2b8:	b3 95       	inc	r27
    f2ba:	d9 f7       	brne	.-10     	; 0xf2b2 <__fixunssfsi+0x3c>
    f2bc:	3e f4       	brtc	.+14     	; 0xf2cc <__fixunssfsi+0x56>
    f2be:	90 95       	com	r25
    f2c0:	80 95       	com	r24
    f2c2:	70 95       	com	r23
    f2c4:	61 95       	neg	r22
    f2c6:	7f 4f       	sbci	r23, 0xFF	; 255
    f2c8:	8f 4f       	sbci	r24, 0xFF	; 255
    f2ca:	9f 4f       	sbci	r25, 0xFF	; 255
    f2cc:	08 95       	ret

0000f2ce <__floatunsisf>:
    f2ce:	e8 94       	clt
    f2d0:	09 c0       	rjmp	.+18     	; 0xf2e4 <__floatsisf+0x12>

0000f2d2 <__floatsisf>:
    f2d2:	97 fb       	bst	r25, 7
    f2d4:	3e f4       	brtc	.+14     	; 0xf2e4 <__floatsisf+0x12>
    f2d6:	90 95       	com	r25
    f2d8:	80 95       	com	r24
    f2da:	70 95       	com	r23
    f2dc:	61 95       	neg	r22
    f2de:	7f 4f       	sbci	r23, 0xFF	; 255
    f2e0:	8f 4f       	sbci	r24, 0xFF	; 255
    f2e2:	9f 4f       	sbci	r25, 0xFF	; 255
    f2e4:	99 23       	and	r25, r25
    f2e6:	a9 f0       	breq	.+42     	; 0xf312 <__floatsisf+0x40>
    f2e8:	f9 2f       	mov	r31, r25
    f2ea:	96 e9       	ldi	r25, 0x96	; 150
    f2ec:	bb 27       	eor	r27, r27
    f2ee:	93 95       	inc	r25
    f2f0:	f6 95       	lsr	r31
    f2f2:	87 95       	ror	r24
    f2f4:	77 95       	ror	r23
    f2f6:	67 95       	ror	r22
    f2f8:	b7 95       	ror	r27
    f2fa:	f1 11       	cpse	r31, r1
    f2fc:	f8 cf       	rjmp	.-16     	; 0xf2ee <__floatsisf+0x1c>
    f2fe:	fa f4       	brpl	.+62     	; 0xf33e <__floatsisf+0x6c>
    f300:	bb 0f       	add	r27, r27
    f302:	11 f4       	brne	.+4      	; 0xf308 <__floatsisf+0x36>
    f304:	60 ff       	sbrs	r22, 0
    f306:	1b c0       	rjmp	.+54     	; 0xf33e <__floatsisf+0x6c>
    f308:	6f 5f       	subi	r22, 0xFF	; 255
    f30a:	7f 4f       	sbci	r23, 0xFF	; 255
    f30c:	8f 4f       	sbci	r24, 0xFF	; 255
    f30e:	9f 4f       	sbci	r25, 0xFF	; 255
    f310:	16 c0       	rjmp	.+44     	; 0xf33e <__floatsisf+0x6c>
    f312:	88 23       	and	r24, r24
    f314:	11 f0       	breq	.+4      	; 0xf31a <__floatsisf+0x48>
    f316:	96 e9       	ldi	r25, 0x96	; 150
    f318:	11 c0       	rjmp	.+34     	; 0xf33c <__floatsisf+0x6a>
    f31a:	77 23       	and	r23, r23
    f31c:	21 f0       	breq	.+8      	; 0xf326 <__floatsisf+0x54>
    f31e:	9e e8       	ldi	r25, 0x8E	; 142
    f320:	87 2f       	mov	r24, r23
    f322:	76 2f       	mov	r23, r22
    f324:	05 c0       	rjmp	.+10     	; 0xf330 <__floatsisf+0x5e>
    f326:	66 23       	and	r22, r22
    f328:	71 f0       	breq	.+28     	; 0xf346 <__floatsisf+0x74>
    f32a:	96 e8       	ldi	r25, 0x86	; 134
    f32c:	86 2f       	mov	r24, r22
    f32e:	70 e0       	ldi	r23, 0x00	; 0
    f330:	60 e0       	ldi	r22, 0x00	; 0
    f332:	2a f0       	brmi	.+10     	; 0xf33e <__floatsisf+0x6c>
    f334:	9a 95       	dec	r25
    f336:	66 0f       	add	r22, r22
    f338:	77 1f       	adc	r23, r23
    f33a:	88 1f       	adc	r24, r24
    f33c:	da f7       	brpl	.-10     	; 0xf334 <__floatsisf+0x62>
    f33e:	88 0f       	add	r24, r24
    f340:	96 95       	lsr	r25
    f342:	87 95       	ror	r24
    f344:	97 f9       	bld	r25, 7
    f346:	08 95       	ret

0000f348 <__fp_inf>:
    f348:	97 f9       	bld	r25, 7
    f34a:	9f 67       	ori	r25, 0x7F	; 127
    f34c:	80 e8       	ldi	r24, 0x80	; 128
    f34e:	70 e0       	ldi	r23, 0x00	; 0
    f350:	60 e0       	ldi	r22, 0x00	; 0
    f352:	08 95       	ret

0000f354 <__fp_nan>:
    f354:	9f ef       	ldi	r25, 0xFF	; 255
    f356:	80 ec       	ldi	r24, 0xC0	; 192
    f358:	08 95       	ret

0000f35a <__fp_pscA>:
    f35a:	00 24       	eor	r0, r0
    f35c:	0a 94       	dec	r0
    f35e:	16 16       	cp	r1, r22
    f360:	17 06       	cpc	r1, r23
    f362:	18 06       	cpc	r1, r24
    f364:	09 06       	cpc	r0, r25
    f366:	08 95       	ret

0000f368 <__fp_pscB>:
    f368:	00 24       	eor	r0, r0
    f36a:	0a 94       	dec	r0
    f36c:	12 16       	cp	r1, r18
    f36e:	13 06       	cpc	r1, r19
    f370:	14 06       	cpc	r1, r20
    f372:	05 06       	cpc	r0, r21
    f374:	08 95       	ret

0000f376 <__fp_round>:
    f376:	09 2e       	mov	r0, r25
    f378:	03 94       	inc	r0
    f37a:	00 0c       	add	r0, r0
    f37c:	11 f4       	brne	.+4      	; 0xf382 <__fp_round+0xc>
    f37e:	88 23       	and	r24, r24
    f380:	52 f0       	brmi	.+20     	; 0xf396 <__fp_round+0x20>
    f382:	bb 0f       	add	r27, r27
    f384:	40 f4       	brcc	.+16     	; 0xf396 <__fp_round+0x20>
    f386:	bf 2b       	or	r27, r31
    f388:	11 f4       	brne	.+4      	; 0xf38e <__fp_round+0x18>
    f38a:	60 ff       	sbrs	r22, 0
    f38c:	04 c0       	rjmp	.+8      	; 0xf396 <__fp_round+0x20>
    f38e:	6f 5f       	subi	r22, 0xFF	; 255
    f390:	7f 4f       	sbci	r23, 0xFF	; 255
    f392:	8f 4f       	sbci	r24, 0xFF	; 255
    f394:	9f 4f       	sbci	r25, 0xFF	; 255
    f396:	08 95       	ret

0000f398 <__fp_split3>:
    f398:	57 fd       	sbrc	r21, 7
    f39a:	90 58       	subi	r25, 0x80	; 128
    f39c:	44 0f       	add	r20, r20
    f39e:	55 1f       	adc	r21, r21
    f3a0:	59 f0       	breq	.+22     	; 0xf3b8 <__fp_splitA+0x10>
    f3a2:	5f 3f       	cpi	r21, 0xFF	; 255
    f3a4:	71 f0       	breq	.+28     	; 0xf3c2 <__fp_splitA+0x1a>
    f3a6:	47 95       	ror	r20

0000f3a8 <__fp_splitA>:
    f3a8:	88 0f       	add	r24, r24
    f3aa:	97 fb       	bst	r25, 7
    f3ac:	99 1f       	adc	r25, r25
    f3ae:	61 f0       	breq	.+24     	; 0xf3c8 <__fp_splitA+0x20>
    f3b0:	9f 3f       	cpi	r25, 0xFF	; 255
    f3b2:	79 f0       	breq	.+30     	; 0xf3d2 <__fp_splitA+0x2a>
    f3b4:	87 95       	ror	r24
    f3b6:	08 95       	ret
    f3b8:	12 16       	cp	r1, r18
    f3ba:	13 06       	cpc	r1, r19
    f3bc:	14 06       	cpc	r1, r20
    f3be:	55 1f       	adc	r21, r21
    f3c0:	f2 cf       	rjmp	.-28     	; 0xf3a6 <__fp_split3+0xe>
    f3c2:	46 95       	lsr	r20
    f3c4:	f1 df       	rcall	.-30     	; 0xf3a8 <__fp_splitA>
    f3c6:	08 c0       	rjmp	.+16     	; 0xf3d8 <__fp_splitA+0x30>
    f3c8:	16 16       	cp	r1, r22
    f3ca:	17 06       	cpc	r1, r23
    f3cc:	18 06       	cpc	r1, r24
    f3ce:	99 1f       	adc	r25, r25
    f3d0:	f1 cf       	rjmp	.-30     	; 0xf3b4 <__fp_splitA+0xc>
    f3d2:	86 95       	lsr	r24
    f3d4:	71 05       	cpc	r23, r1
    f3d6:	61 05       	cpc	r22, r1
    f3d8:	08 94       	sec
    f3da:	08 95       	ret

0000f3dc <__fp_zero>:
    f3dc:	e8 94       	clt

0000f3de <__fp_szero>:
    f3de:	bb 27       	eor	r27, r27
    f3e0:	66 27       	eor	r22, r22
    f3e2:	77 27       	eor	r23, r23
    f3e4:	cb 01       	movw	r24, r22
    f3e6:	97 f9       	bld	r25, 7
    f3e8:	08 95       	ret

0000f3ea <__mulsf3>:
    f3ea:	0b d0       	rcall	.+22     	; 0xf402 <__mulsf3x>
    f3ec:	c4 cf       	rjmp	.-120    	; 0xf376 <__fp_round>
    f3ee:	b5 df       	rcall	.-150    	; 0xf35a <__fp_pscA>
    f3f0:	28 f0       	brcs	.+10     	; 0xf3fc <__mulsf3+0x12>
    f3f2:	ba df       	rcall	.-140    	; 0xf368 <__fp_pscB>
    f3f4:	18 f0       	brcs	.+6      	; 0xf3fc <__mulsf3+0x12>
    f3f6:	95 23       	and	r25, r21
    f3f8:	09 f0       	breq	.+2      	; 0xf3fc <__mulsf3+0x12>
    f3fa:	a6 cf       	rjmp	.-180    	; 0xf348 <__fp_inf>
    f3fc:	ab cf       	rjmp	.-170    	; 0xf354 <__fp_nan>
    f3fe:	11 24       	eor	r1, r1
    f400:	ee cf       	rjmp	.-36     	; 0xf3de <__fp_szero>

0000f402 <__mulsf3x>:
    f402:	ca df       	rcall	.-108    	; 0xf398 <__fp_split3>
    f404:	a0 f3       	brcs	.-24     	; 0xf3ee <__mulsf3+0x4>

0000f406 <__mulsf3_pse>:
    f406:	95 9f       	mul	r25, r21
    f408:	d1 f3       	breq	.-12     	; 0xf3fe <__mulsf3+0x14>
    f40a:	95 0f       	add	r25, r21
    f40c:	50 e0       	ldi	r21, 0x00	; 0
    f40e:	55 1f       	adc	r21, r21
    f410:	62 9f       	mul	r22, r18
    f412:	f0 01       	movw	r30, r0
    f414:	72 9f       	mul	r23, r18
    f416:	bb 27       	eor	r27, r27
    f418:	f0 0d       	add	r31, r0
    f41a:	b1 1d       	adc	r27, r1
    f41c:	63 9f       	mul	r22, r19
    f41e:	aa 27       	eor	r26, r26
    f420:	f0 0d       	add	r31, r0
    f422:	b1 1d       	adc	r27, r1
    f424:	aa 1f       	adc	r26, r26
    f426:	64 9f       	mul	r22, r20
    f428:	66 27       	eor	r22, r22
    f42a:	b0 0d       	add	r27, r0
    f42c:	a1 1d       	adc	r26, r1
    f42e:	66 1f       	adc	r22, r22
    f430:	82 9f       	mul	r24, r18
    f432:	22 27       	eor	r18, r18
    f434:	b0 0d       	add	r27, r0
    f436:	a1 1d       	adc	r26, r1
    f438:	62 1f       	adc	r22, r18
    f43a:	73 9f       	mul	r23, r19
    f43c:	b0 0d       	add	r27, r0
    f43e:	a1 1d       	adc	r26, r1
    f440:	62 1f       	adc	r22, r18
    f442:	83 9f       	mul	r24, r19
    f444:	a0 0d       	add	r26, r0
    f446:	61 1d       	adc	r22, r1
    f448:	22 1f       	adc	r18, r18
    f44a:	74 9f       	mul	r23, r20
    f44c:	33 27       	eor	r19, r19
    f44e:	a0 0d       	add	r26, r0
    f450:	61 1d       	adc	r22, r1
    f452:	23 1f       	adc	r18, r19
    f454:	84 9f       	mul	r24, r20
    f456:	60 0d       	add	r22, r0
    f458:	21 1d       	adc	r18, r1
    f45a:	82 2f       	mov	r24, r18
    f45c:	76 2f       	mov	r23, r22
    f45e:	6a 2f       	mov	r22, r26
    f460:	11 24       	eor	r1, r1
    f462:	9f 57       	subi	r25, 0x7F	; 127
    f464:	50 40       	sbci	r21, 0x00	; 0
    f466:	8a f0       	brmi	.+34     	; 0xf48a <__mulsf3_pse+0x84>
    f468:	e1 f0       	breq	.+56     	; 0xf4a2 <__mulsf3_pse+0x9c>
    f46a:	88 23       	and	r24, r24
    f46c:	4a f0       	brmi	.+18     	; 0xf480 <__mulsf3_pse+0x7a>
    f46e:	ee 0f       	add	r30, r30
    f470:	ff 1f       	adc	r31, r31
    f472:	bb 1f       	adc	r27, r27
    f474:	66 1f       	adc	r22, r22
    f476:	77 1f       	adc	r23, r23
    f478:	88 1f       	adc	r24, r24
    f47a:	91 50       	subi	r25, 0x01	; 1
    f47c:	50 40       	sbci	r21, 0x00	; 0
    f47e:	a9 f7       	brne	.-22     	; 0xf46a <__mulsf3_pse+0x64>
    f480:	9e 3f       	cpi	r25, 0xFE	; 254
    f482:	51 05       	cpc	r21, r1
    f484:	70 f0       	brcs	.+28     	; 0xf4a2 <__mulsf3_pse+0x9c>
    f486:	60 cf       	rjmp	.-320    	; 0xf348 <__fp_inf>
    f488:	aa cf       	rjmp	.-172    	; 0xf3de <__fp_szero>
    f48a:	5f 3f       	cpi	r21, 0xFF	; 255
    f48c:	ec f3       	brlt	.-6      	; 0xf488 <__mulsf3_pse+0x82>
    f48e:	98 3e       	cpi	r25, 0xE8	; 232
    f490:	dc f3       	brlt	.-10     	; 0xf488 <__mulsf3_pse+0x82>
    f492:	86 95       	lsr	r24
    f494:	77 95       	ror	r23
    f496:	67 95       	ror	r22
    f498:	b7 95       	ror	r27
    f49a:	f7 95       	ror	r31
    f49c:	e7 95       	ror	r30
    f49e:	9f 5f       	subi	r25, 0xFF	; 255
    f4a0:	c1 f7       	brne	.-16     	; 0xf492 <__mulsf3_pse+0x8c>
    f4a2:	fe 2b       	or	r31, r30
    f4a4:	88 0f       	add	r24, r24
    f4a6:	91 1d       	adc	r25, r1
    f4a8:	96 95       	lsr	r25
    f4aa:	87 95       	ror	r24
    f4ac:	97 f9       	bld	r25, 7
    f4ae:	08 95       	ret

0000f4b0 <vfprintf>:
    f4b0:	2f 92       	push	r2
    f4b2:	3f 92       	push	r3
    f4b4:	4f 92       	push	r4
    f4b6:	5f 92       	push	r5
    f4b8:	6f 92       	push	r6
    f4ba:	7f 92       	push	r7
    f4bc:	8f 92       	push	r8
    f4be:	9f 92       	push	r9
    f4c0:	af 92       	push	r10
    f4c2:	bf 92       	push	r11
    f4c4:	cf 92       	push	r12
    f4c6:	df 92       	push	r13
    f4c8:	ef 92       	push	r14
    f4ca:	ff 92       	push	r15
    f4cc:	0f 93       	push	r16
    f4ce:	1f 93       	push	r17
    f4d0:	cf 93       	push	r28
    f4d2:	df 93       	push	r29
    f4d4:	cd b7       	in	r28, 0x3d	; 61
    f4d6:	de b7       	in	r29, 0x3e	; 62
    f4d8:	2c 97       	sbiw	r28, 0x0c	; 12
    f4da:	0f b6       	in	r0, 0x3f	; 63
    f4dc:	f8 94       	cli
    f4de:	de bf       	out	0x3e, r29	; 62
    f4e0:	0f be       	out	0x3f, r0	; 63
    f4e2:	cd bf       	out	0x3d, r28	; 61
    f4e4:	7c 01       	movw	r14, r24
    f4e6:	6b 01       	movw	r12, r22
    f4e8:	8a 01       	movw	r16, r20
    f4ea:	fc 01       	movw	r30, r24
    f4ec:	17 82       	std	Z+7, r1	; 0x07
    f4ee:	16 82       	std	Z+6, r1	; 0x06
    f4f0:	83 81       	ldd	r24, Z+3	; 0x03
    f4f2:	81 ff       	sbrs	r24, 1
    f4f4:	bd c1       	rjmp	.+890    	; 0xf870 <vfprintf+0x3c0>
    f4f6:	ce 01       	movw	r24, r28
    f4f8:	01 96       	adiw	r24, 0x01	; 1
    f4fa:	4c 01       	movw	r8, r24
    f4fc:	f7 01       	movw	r30, r14
    f4fe:	93 81       	ldd	r25, Z+3	; 0x03
    f500:	f6 01       	movw	r30, r12
    f502:	93 fd       	sbrc	r25, 3
    f504:	85 91       	lpm	r24, Z+
    f506:	93 ff       	sbrs	r25, 3
    f508:	81 91       	ld	r24, Z+
    f50a:	6f 01       	movw	r12, r30
    f50c:	88 23       	and	r24, r24
    f50e:	09 f4       	brne	.+2      	; 0xf512 <vfprintf+0x62>
    f510:	ab c1       	rjmp	.+854    	; 0xf868 <vfprintf+0x3b8>
    f512:	85 32       	cpi	r24, 0x25	; 37
    f514:	39 f4       	brne	.+14     	; 0xf524 <vfprintf+0x74>
    f516:	93 fd       	sbrc	r25, 3
    f518:	85 91       	lpm	r24, Z+
    f51a:	93 ff       	sbrs	r25, 3
    f51c:	81 91       	ld	r24, Z+
    f51e:	6f 01       	movw	r12, r30
    f520:	85 32       	cpi	r24, 0x25	; 37
    f522:	29 f4       	brne	.+10     	; 0xf52e <vfprintf+0x7e>
    f524:	b7 01       	movw	r22, r14
    f526:	90 e0       	ldi	r25, 0x00	; 0
    f528:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f52c:	e7 cf       	rjmp	.-50     	; 0xf4fc <vfprintf+0x4c>
    f52e:	51 2c       	mov	r5, r1
    f530:	31 2c       	mov	r3, r1
    f532:	20 e0       	ldi	r18, 0x00	; 0
    f534:	20 32       	cpi	r18, 0x20	; 32
    f536:	a0 f4       	brcc	.+40     	; 0xf560 <vfprintf+0xb0>
    f538:	8b 32       	cpi	r24, 0x2B	; 43
    f53a:	69 f0       	breq	.+26     	; 0xf556 <vfprintf+0xa6>
    f53c:	30 f4       	brcc	.+12     	; 0xf54a <vfprintf+0x9a>
    f53e:	80 32       	cpi	r24, 0x20	; 32
    f540:	59 f0       	breq	.+22     	; 0xf558 <vfprintf+0xa8>
    f542:	83 32       	cpi	r24, 0x23	; 35
    f544:	69 f4       	brne	.+26     	; 0xf560 <vfprintf+0xb0>
    f546:	20 61       	ori	r18, 0x10	; 16
    f548:	2c c0       	rjmp	.+88     	; 0xf5a2 <vfprintf+0xf2>
    f54a:	8d 32       	cpi	r24, 0x2D	; 45
    f54c:	39 f0       	breq	.+14     	; 0xf55c <vfprintf+0xac>
    f54e:	80 33       	cpi	r24, 0x30	; 48
    f550:	39 f4       	brne	.+14     	; 0xf560 <vfprintf+0xb0>
    f552:	21 60       	ori	r18, 0x01	; 1
    f554:	26 c0       	rjmp	.+76     	; 0xf5a2 <vfprintf+0xf2>
    f556:	22 60       	ori	r18, 0x02	; 2
    f558:	24 60       	ori	r18, 0x04	; 4
    f55a:	23 c0       	rjmp	.+70     	; 0xf5a2 <vfprintf+0xf2>
    f55c:	28 60       	ori	r18, 0x08	; 8
    f55e:	21 c0       	rjmp	.+66     	; 0xf5a2 <vfprintf+0xf2>
    f560:	27 fd       	sbrc	r18, 7
    f562:	27 c0       	rjmp	.+78     	; 0xf5b2 <vfprintf+0x102>
    f564:	30 ed       	ldi	r19, 0xD0	; 208
    f566:	38 0f       	add	r19, r24
    f568:	3a 30       	cpi	r19, 0x0A	; 10
    f56a:	78 f4       	brcc	.+30     	; 0xf58a <vfprintf+0xda>
    f56c:	26 ff       	sbrs	r18, 6
    f56e:	06 c0       	rjmp	.+12     	; 0xf57c <vfprintf+0xcc>
    f570:	fa e0       	ldi	r31, 0x0A	; 10
    f572:	5f 9e       	mul	r5, r31
    f574:	30 0d       	add	r19, r0
    f576:	11 24       	eor	r1, r1
    f578:	53 2e       	mov	r5, r19
    f57a:	13 c0       	rjmp	.+38     	; 0xf5a2 <vfprintf+0xf2>
    f57c:	8a e0       	ldi	r24, 0x0A	; 10
    f57e:	38 9e       	mul	r3, r24
    f580:	30 0d       	add	r19, r0
    f582:	11 24       	eor	r1, r1
    f584:	33 2e       	mov	r3, r19
    f586:	20 62       	ori	r18, 0x20	; 32
    f588:	0c c0       	rjmp	.+24     	; 0xf5a2 <vfprintf+0xf2>
    f58a:	8e 32       	cpi	r24, 0x2E	; 46
    f58c:	21 f4       	brne	.+8      	; 0xf596 <vfprintf+0xe6>
    f58e:	26 fd       	sbrc	r18, 6
    f590:	6b c1       	rjmp	.+726    	; 0xf868 <vfprintf+0x3b8>
    f592:	20 64       	ori	r18, 0x40	; 64
    f594:	06 c0       	rjmp	.+12     	; 0xf5a2 <vfprintf+0xf2>
    f596:	8c 36       	cpi	r24, 0x6C	; 108
    f598:	11 f4       	brne	.+4      	; 0xf59e <vfprintf+0xee>
    f59a:	20 68       	ori	r18, 0x80	; 128
    f59c:	02 c0       	rjmp	.+4      	; 0xf5a2 <vfprintf+0xf2>
    f59e:	88 36       	cpi	r24, 0x68	; 104
    f5a0:	41 f4       	brne	.+16     	; 0xf5b2 <vfprintf+0x102>
    f5a2:	f6 01       	movw	r30, r12
    f5a4:	93 fd       	sbrc	r25, 3
    f5a6:	85 91       	lpm	r24, Z+
    f5a8:	93 ff       	sbrs	r25, 3
    f5aa:	81 91       	ld	r24, Z+
    f5ac:	6f 01       	movw	r12, r30
    f5ae:	81 11       	cpse	r24, r1
    f5b0:	c1 cf       	rjmp	.-126    	; 0xf534 <vfprintf+0x84>
    f5b2:	98 2f       	mov	r25, r24
    f5b4:	9f 7d       	andi	r25, 0xDF	; 223
    f5b6:	95 54       	subi	r25, 0x45	; 69
    f5b8:	93 30       	cpi	r25, 0x03	; 3
    f5ba:	28 f4       	brcc	.+10     	; 0xf5c6 <vfprintf+0x116>
    f5bc:	0c 5f       	subi	r16, 0xFC	; 252
    f5be:	1f 4f       	sbci	r17, 0xFF	; 255
    f5c0:	ff e3       	ldi	r31, 0x3F	; 63
    f5c2:	f9 83       	std	Y+1, r31	; 0x01
    f5c4:	0d c0       	rjmp	.+26     	; 0xf5e0 <vfprintf+0x130>
    f5c6:	83 36       	cpi	r24, 0x63	; 99
    f5c8:	31 f0       	breq	.+12     	; 0xf5d6 <vfprintf+0x126>
    f5ca:	83 37       	cpi	r24, 0x73	; 115
    f5cc:	71 f0       	breq	.+28     	; 0xf5ea <vfprintf+0x13a>
    f5ce:	83 35       	cpi	r24, 0x53	; 83
    f5d0:	09 f0       	breq	.+2      	; 0xf5d4 <vfprintf+0x124>
    f5d2:	5b c0       	rjmp	.+182    	; 0xf68a <vfprintf+0x1da>
    f5d4:	22 c0       	rjmp	.+68     	; 0xf61a <vfprintf+0x16a>
    f5d6:	f8 01       	movw	r30, r16
    f5d8:	80 81       	ld	r24, Z
    f5da:	89 83       	std	Y+1, r24	; 0x01
    f5dc:	0e 5f       	subi	r16, 0xFE	; 254
    f5de:	1f 4f       	sbci	r17, 0xFF	; 255
    f5e0:	44 24       	eor	r4, r4
    f5e2:	43 94       	inc	r4
    f5e4:	51 2c       	mov	r5, r1
    f5e6:	54 01       	movw	r10, r8
    f5e8:	15 c0       	rjmp	.+42     	; 0xf614 <vfprintf+0x164>
    f5ea:	38 01       	movw	r6, r16
    f5ec:	f2 e0       	ldi	r31, 0x02	; 2
    f5ee:	6f 0e       	add	r6, r31
    f5f0:	71 1c       	adc	r7, r1
    f5f2:	f8 01       	movw	r30, r16
    f5f4:	a0 80       	ld	r10, Z
    f5f6:	b1 80       	ldd	r11, Z+1	; 0x01
    f5f8:	26 ff       	sbrs	r18, 6
    f5fa:	03 c0       	rjmp	.+6      	; 0xf602 <vfprintf+0x152>
    f5fc:	65 2d       	mov	r22, r5
    f5fe:	70 e0       	ldi	r23, 0x00	; 0
    f600:	02 c0       	rjmp	.+4      	; 0xf606 <vfprintf+0x156>
    f602:	6f ef       	ldi	r22, 0xFF	; 255
    f604:	7f ef       	ldi	r23, 0xFF	; 255
    f606:	c5 01       	movw	r24, r10
    f608:	2c 87       	std	Y+12, r18	; 0x0c
    f60a:	0e 94 82 7f 	call	0xff04	; 0xff04 <strnlen>
    f60e:	2c 01       	movw	r4, r24
    f610:	83 01       	movw	r16, r6
    f612:	2c 85       	ldd	r18, Y+12	; 0x0c
    f614:	2f 77       	andi	r18, 0x7F	; 127
    f616:	22 2e       	mov	r2, r18
    f618:	17 c0       	rjmp	.+46     	; 0xf648 <vfprintf+0x198>
    f61a:	38 01       	movw	r6, r16
    f61c:	f2 e0       	ldi	r31, 0x02	; 2
    f61e:	6f 0e       	add	r6, r31
    f620:	71 1c       	adc	r7, r1
    f622:	f8 01       	movw	r30, r16
    f624:	a0 80       	ld	r10, Z
    f626:	b1 80       	ldd	r11, Z+1	; 0x01
    f628:	26 ff       	sbrs	r18, 6
    f62a:	03 c0       	rjmp	.+6      	; 0xf632 <vfprintf+0x182>
    f62c:	65 2d       	mov	r22, r5
    f62e:	70 e0       	ldi	r23, 0x00	; 0
    f630:	02 c0       	rjmp	.+4      	; 0xf636 <vfprintf+0x186>
    f632:	6f ef       	ldi	r22, 0xFF	; 255
    f634:	7f ef       	ldi	r23, 0xFF	; 255
    f636:	c5 01       	movw	r24, r10
    f638:	2c 87       	std	Y+12, r18	; 0x0c
    f63a:	0e 94 77 7f 	call	0xfeee	; 0xfeee <strnlen_P>
    f63e:	2c 01       	movw	r4, r24
    f640:	2c 85       	ldd	r18, Y+12	; 0x0c
    f642:	20 68       	ori	r18, 0x80	; 128
    f644:	22 2e       	mov	r2, r18
    f646:	83 01       	movw	r16, r6
    f648:	23 fc       	sbrc	r2, 3
    f64a:	1b c0       	rjmp	.+54     	; 0xf682 <vfprintf+0x1d2>
    f64c:	83 2d       	mov	r24, r3
    f64e:	90 e0       	ldi	r25, 0x00	; 0
    f650:	48 16       	cp	r4, r24
    f652:	59 06       	cpc	r5, r25
    f654:	b0 f4       	brcc	.+44     	; 0xf682 <vfprintf+0x1d2>
    f656:	b7 01       	movw	r22, r14
    f658:	80 e2       	ldi	r24, 0x20	; 32
    f65a:	90 e0       	ldi	r25, 0x00	; 0
    f65c:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f660:	3a 94       	dec	r3
    f662:	f4 cf       	rjmp	.-24     	; 0xf64c <vfprintf+0x19c>
    f664:	f5 01       	movw	r30, r10
    f666:	27 fc       	sbrc	r2, 7
    f668:	85 91       	lpm	r24, Z+
    f66a:	27 fe       	sbrs	r2, 7
    f66c:	81 91       	ld	r24, Z+
    f66e:	5f 01       	movw	r10, r30
    f670:	b7 01       	movw	r22, r14
    f672:	90 e0       	ldi	r25, 0x00	; 0
    f674:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f678:	31 10       	cpse	r3, r1
    f67a:	3a 94       	dec	r3
    f67c:	f1 e0       	ldi	r31, 0x01	; 1
    f67e:	4f 1a       	sub	r4, r31
    f680:	51 08       	sbc	r5, r1
    f682:	41 14       	cp	r4, r1
    f684:	51 04       	cpc	r5, r1
    f686:	71 f7       	brne	.-36     	; 0xf664 <vfprintf+0x1b4>
    f688:	e5 c0       	rjmp	.+458    	; 0xf854 <vfprintf+0x3a4>
    f68a:	84 36       	cpi	r24, 0x64	; 100
    f68c:	11 f0       	breq	.+4      	; 0xf692 <vfprintf+0x1e2>
    f68e:	89 36       	cpi	r24, 0x69	; 105
    f690:	39 f5       	brne	.+78     	; 0xf6e0 <vfprintf+0x230>
    f692:	f8 01       	movw	r30, r16
    f694:	27 ff       	sbrs	r18, 7
    f696:	07 c0       	rjmp	.+14     	; 0xf6a6 <vfprintf+0x1f6>
    f698:	60 81       	ld	r22, Z
    f69a:	71 81       	ldd	r23, Z+1	; 0x01
    f69c:	82 81       	ldd	r24, Z+2	; 0x02
    f69e:	93 81       	ldd	r25, Z+3	; 0x03
    f6a0:	0c 5f       	subi	r16, 0xFC	; 252
    f6a2:	1f 4f       	sbci	r17, 0xFF	; 255
    f6a4:	08 c0       	rjmp	.+16     	; 0xf6b6 <vfprintf+0x206>
    f6a6:	60 81       	ld	r22, Z
    f6a8:	71 81       	ldd	r23, Z+1	; 0x01
    f6aa:	88 27       	eor	r24, r24
    f6ac:	77 fd       	sbrc	r23, 7
    f6ae:	80 95       	com	r24
    f6b0:	98 2f       	mov	r25, r24
    f6b2:	0e 5f       	subi	r16, 0xFE	; 254
    f6b4:	1f 4f       	sbci	r17, 0xFF	; 255
    f6b6:	2f 76       	andi	r18, 0x6F	; 111
    f6b8:	b2 2e       	mov	r11, r18
    f6ba:	97 ff       	sbrs	r25, 7
    f6bc:	09 c0       	rjmp	.+18     	; 0xf6d0 <vfprintf+0x220>
    f6be:	90 95       	com	r25
    f6c0:	80 95       	com	r24
    f6c2:	70 95       	com	r23
    f6c4:	61 95       	neg	r22
    f6c6:	7f 4f       	sbci	r23, 0xFF	; 255
    f6c8:	8f 4f       	sbci	r24, 0xFF	; 255
    f6ca:	9f 4f       	sbci	r25, 0xFF	; 255
    f6cc:	20 68       	ori	r18, 0x80	; 128
    f6ce:	b2 2e       	mov	r11, r18
    f6d0:	2a e0       	ldi	r18, 0x0A	; 10
    f6d2:	30 e0       	ldi	r19, 0x00	; 0
    f6d4:	a4 01       	movw	r20, r8
    f6d6:	0e 94 16 80 	call	0x1002c	; 0x1002c <__ultoa_invert>
    f6da:	a8 2e       	mov	r10, r24
    f6dc:	a8 18       	sub	r10, r8
    f6de:	44 c0       	rjmp	.+136    	; 0xf768 <vfprintf+0x2b8>
    f6e0:	85 37       	cpi	r24, 0x75	; 117
    f6e2:	29 f4       	brne	.+10     	; 0xf6ee <vfprintf+0x23e>
    f6e4:	2f 7e       	andi	r18, 0xEF	; 239
    f6e6:	b2 2e       	mov	r11, r18
    f6e8:	2a e0       	ldi	r18, 0x0A	; 10
    f6ea:	30 e0       	ldi	r19, 0x00	; 0
    f6ec:	25 c0       	rjmp	.+74     	; 0xf738 <vfprintf+0x288>
    f6ee:	f2 2f       	mov	r31, r18
    f6f0:	f9 7f       	andi	r31, 0xF9	; 249
    f6f2:	bf 2e       	mov	r11, r31
    f6f4:	8f 36       	cpi	r24, 0x6F	; 111
    f6f6:	c1 f0       	breq	.+48     	; 0xf728 <vfprintf+0x278>
    f6f8:	18 f4       	brcc	.+6      	; 0xf700 <vfprintf+0x250>
    f6fa:	88 35       	cpi	r24, 0x58	; 88
    f6fc:	79 f0       	breq	.+30     	; 0xf71c <vfprintf+0x26c>
    f6fe:	b4 c0       	rjmp	.+360    	; 0xf868 <vfprintf+0x3b8>
    f700:	80 37       	cpi	r24, 0x70	; 112
    f702:	19 f0       	breq	.+6      	; 0xf70a <vfprintf+0x25a>
    f704:	88 37       	cpi	r24, 0x78	; 120
    f706:	21 f0       	breq	.+8      	; 0xf710 <vfprintf+0x260>
    f708:	af c0       	rjmp	.+350    	; 0xf868 <vfprintf+0x3b8>
    f70a:	2f 2f       	mov	r18, r31
    f70c:	20 61       	ori	r18, 0x10	; 16
    f70e:	b2 2e       	mov	r11, r18
    f710:	b4 fe       	sbrs	r11, 4
    f712:	0d c0       	rjmp	.+26     	; 0xf72e <vfprintf+0x27e>
    f714:	8b 2d       	mov	r24, r11
    f716:	84 60       	ori	r24, 0x04	; 4
    f718:	b8 2e       	mov	r11, r24
    f71a:	09 c0       	rjmp	.+18     	; 0xf72e <vfprintf+0x27e>
    f71c:	24 ff       	sbrs	r18, 4
    f71e:	0a c0       	rjmp	.+20     	; 0xf734 <vfprintf+0x284>
    f720:	9f 2f       	mov	r25, r31
    f722:	96 60       	ori	r25, 0x06	; 6
    f724:	b9 2e       	mov	r11, r25
    f726:	06 c0       	rjmp	.+12     	; 0xf734 <vfprintf+0x284>
    f728:	28 e0       	ldi	r18, 0x08	; 8
    f72a:	30 e0       	ldi	r19, 0x00	; 0
    f72c:	05 c0       	rjmp	.+10     	; 0xf738 <vfprintf+0x288>
    f72e:	20 e1       	ldi	r18, 0x10	; 16
    f730:	30 e0       	ldi	r19, 0x00	; 0
    f732:	02 c0       	rjmp	.+4      	; 0xf738 <vfprintf+0x288>
    f734:	20 e1       	ldi	r18, 0x10	; 16
    f736:	32 e0       	ldi	r19, 0x02	; 2
    f738:	f8 01       	movw	r30, r16
    f73a:	b7 fe       	sbrs	r11, 7
    f73c:	07 c0       	rjmp	.+14     	; 0xf74c <vfprintf+0x29c>
    f73e:	60 81       	ld	r22, Z
    f740:	71 81       	ldd	r23, Z+1	; 0x01
    f742:	82 81       	ldd	r24, Z+2	; 0x02
    f744:	93 81       	ldd	r25, Z+3	; 0x03
    f746:	0c 5f       	subi	r16, 0xFC	; 252
    f748:	1f 4f       	sbci	r17, 0xFF	; 255
    f74a:	06 c0       	rjmp	.+12     	; 0xf758 <vfprintf+0x2a8>
    f74c:	60 81       	ld	r22, Z
    f74e:	71 81       	ldd	r23, Z+1	; 0x01
    f750:	80 e0       	ldi	r24, 0x00	; 0
    f752:	90 e0       	ldi	r25, 0x00	; 0
    f754:	0e 5f       	subi	r16, 0xFE	; 254
    f756:	1f 4f       	sbci	r17, 0xFF	; 255
    f758:	a4 01       	movw	r20, r8
    f75a:	0e 94 16 80 	call	0x1002c	; 0x1002c <__ultoa_invert>
    f75e:	a8 2e       	mov	r10, r24
    f760:	a8 18       	sub	r10, r8
    f762:	fb 2d       	mov	r31, r11
    f764:	ff 77       	andi	r31, 0x7F	; 127
    f766:	bf 2e       	mov	r11, r31
    f768:	b6 fe       	sbrs	r11, 6
    f76a:	0b c0       	rjmp	.+22     	; 0xf782 <vfprintf+0x2d2>
    f76c:	2b 2d       	mov	r18, r11
    f76e:	2e 7f       	andi	r18, 0xFE	; 254
    f770:	a5 14       	cp	r10, r5
    f772:	50 f4       	brcc	.+20     	; 0xf788 <vfprintf+0x2d8>
    f774:	b4 fe       	sbrs	r11, 4
    f776:	0a c0       	rjmp	.+20     	; 0xf78c <vfprintf+0x2dc>
    f778:	b2 fc       	sbrc	r11, 2
    f77a:	08 c0       	rjmp	.+16     	; 0xf78c <vfprintf+0x2dc>
    f77c:	2b 2d       	mov	r18, r11
    f77e:	2e 7e       	andi	r18, 0xEE	; 238
    f780:	05 c0       	rjmp	.+10     	; 0xf78c <vfprintf+0x2dc>
    f782:	7a 2c       	mov	r7, r10
    f784:	2b 2d       	mov	r18, r11
    f786:	03 c0       	rjmp	.+6      	; 0xf78e <vfprintf+0x2de>
    f788:	7a 2c       	mov	r7, r10
    f78a:	01 c0       	rjmp	.+2      	; 0xf78e <vfprintf+0x2de>
    f78c:	75 2c       	mov	r7, r5
    f78e:	24 ff       	sbrs	r18, 4
    f790:	0d c0       	rjmp	.+26     	; 0xf7ac <vfprintf+0x2fc>
    f792:	fe 01       	movw	r30, r28
    f794:	ea 0d       	add	r30, r10
    f796:	f1 1d       	adc	r31, r1
    f798:	80 81       	ld	r24, Z
    f79a:	80 33       	cpi	r24, 0x30	; 48
    f79c:	11 f4       	brne	.+4      	; 0xf7a2 <vfprintf+0x2f2>
    f79e:	29 7e       	andi	r18, 0xE9	; 233
    f7a0:	09 c0       	rjmp	.+18     	; 0xf7b4 <vfprintf+0x304>
    f7a2:	22 ff       	sbrs	r18, 2
    f7a4:	06 c0       	rjmp	.+12     	; 0xf7b2 <vfprintf+0x302>
    f7a6:	73 94       	inc	r7
    f7a8:	73 94       	inc	r7
    f7aa:	04 c0       	rjmp	.+8      	; 0xf7b4 <vfprintf+0x304>
    f7ac:	82 2f       	mov	r24, r18
    f7ae:	86 78       	andi	r24, 0x86	; 134
    f7b0:	09 f0       	breq	.+2      	; 0xf7b4 <vfprintf+0x304>
    f7b2:	73 94       	inc	r7
    f7b4:	23 fd       	sbrc	r18, 3
    f7b6:	13 c0       	rjmp	.+38     	; 0xf7de <vfprintf+0x32e>
    f7b8:	20 ff       	sbrs	r18, 0
    f7ba:	06 c0       	rjmp	.+12     	; 0xf7c8 <vfprintf+0x318>
    f7bc:	5a 2c       	mov	r5, r10
    f7be:	73 14       	cp	r7, r3
    f7c0:	18 f4       	brcc	.+6      	; 0xf7c8 <vfprintf+0x318>
    f7c2:	53 0c       	add	r5, r3
    f7c4:	57 18       	sub	r5, r7
    f7c6:	73 2c       	mov	r7, r3
    f7c8:	73 14       	cp	r7, r3
    f7ca:	68 f4       	brcc	.+26     	; 0xf7e6 <vfprintf+0x336>
    f7cc:	b7 01       	movw	r22, r14
    f7ce:	80 e2       	ldi	r24, 0x20	; 32
    f7d0:	90 e0       	ldi	r25, 0x00	; 0
    f7d2:	2c 87       	std	Y+12, r18	; 0x0c
    f7d4:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f7d8:	73 94       	inc	r7
    f7da:	2c 85       	ldd	r18, Y+12	; 0x0c
    f7dc:	f5 cf       	rjmp	.-22     	; 0xf7c8 <vfprintf+0x318>
    f7de:	73 14       	cp	r7, r3
    f7e0:	10 f4       	brcc	.+4      	; 0xf7e6 <vfprintf+0x336>
    f7e2:	37 18       	sub	r3, r7
    f7e4:	01 c0       	rjmp	.+2      	; 0xf7e8 <vfprintf+0x338>
    f7e6:	31 2c       	mov	r3, r1
    f7e8:	24 ff       	sbrs	r18, 4
    f7ea:	12 c0       	rjmp	.+36     	; 0xf810 <vfprintf+0x360>
    f7ec:	b7 01       	movw	r22, r14
    f7ee:	80 e3       	ldi	r24, 0x30	; 48
    f7f0:	90 e0       	ldi	r25, 0x00	; 0
    f7f2:	2c 87       	std	Y+12, r18	; 0x0c
    f7f4:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f7f8:	2c 85       	ldd	r18, Y+12	; 0x0c
    f7fa:	22 ff       	sbrs	r18, 2
    f7fc:	17 c0       	rjmp	.+46     	; 0xf82c <vfprintf+0x37c>
    f7fe:	21 ff       	sbrs	r18, 1
    f800:	03 c0       	rjmp	.+6      	; 0xf808 <vfprintf+0x358>
    f802:	88 e5       	ldi	r24, 0x58	; 88
    f804:	90 e0       	ldi	r25, 0x00	; 0
    f806:	02 c0       	rjmp	.+4      	; 0xf80c <vfprintf+0x35c>
    f808:	88 e7       	ldi	r24, 0x78	; 120
    f80a:	90 e0       	ldi	r25, 0x00	; 0
    f80c:	b7 01       	movw	r22, r14
    f80e:	0c c0       	rjmp	.+24     	; 0xf828 <vfprintf+0x378>
    f810:	82 2f       	mov	r24, r18
    f812:	86 78       	andi	r24, 0x86	; 134
    f814:	59 f0       	breq	.+22     	; 0xf82c <vfprintf+0x37c>
    f816:	21 fd       	sbrc	r18, 1
    f818:	02 c0       	rjmp	.+4      	; 0xf81e <vfprintf+0x36e>
    f81a:	80 e2       	ldi	r24, 0x20	; 32
    f81c:	01 c0       	rjmp	.+2      	; 0xf820 <vfprintf+0x370>
    f81e:	8b e2       	ldi	r24, 0x2B	; 43
    f820:	27 fd       	sbrc	r18, 7
    f822:	8d e2       	ldi	r24, 0x2D	; 45
    f824:	b7 01       	movw	r22, r14
    f826:	90 e0       	ldi	r25, 0x00	; 0
    f828:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f82c:	a5 14       	cp	r10, r5
    f82e:	38 f4       	brcc	.+14     	; 0xf83e <vfprintf+0x38e>
    f830:	b7 01       	movw	r22, r14
    f832:	80 e3       	ldi	r24, 0x30	; 48
    f834:	90 e0       	ldi	r25, 0x00	; 0
    f836:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f83a:	5a 94       	dec	r5
    f83c:	f7 cf       	rjmp	.-18     	; 0xf82c <vfprintf+0x37c>
    f83e:	aa 94       	dec	r10
    f840:	f4 01       	movw	r30, r8
    f842:	ea 0d       	add	r30, r10
    f844:	f1 1d       	adc	r31, r1
    f846:	80 81       	ld	r24, Z
    f848:	b7 01       	movw	r22, r14
    f84a:	90 e0       	ldi	r25, 0x00	; 0
    f84c:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f850:	a1 10       	cpse	r10, r1
    f852:	f5 cf       	rjmp	.-22     	; 0xf83e <vfprintf+0x38e>
    f854:	33 20       	and	r3, r3
    f856:	09 f4       	brne	.+2      	; 0xf85a <vfprintf+0x3aa>
    f858:	51 ce       	rjmp	.-862    	; 0xf4fc <vfprintf+0x4c>
    f85a:	b7 01       	movw	r22, r14
    f85c:	80 e2       	ldi	r24, 0x20	; 32
    f85e:	90 e0       	ldi	r25, 0x00	; 0
    f860:	0e 94 cb 7f 	call	0xff96	; 0xff96 <fputc>
    f864:	3a 94       	dec	r3
    f866:	f6 cf       	rjmp	.-20     	; 0xf854 <vfprintf+0x3a4>
    f868:	f7 01       	movw	r30, r14
    f86a:	86 81       	ldd	r24, Z+6	; 0x06
    f86c:	97 81       	ldd	r25, Z+7	; 0x07
    f86e:	02 c0       	rjmp	.+4      	; 0xf874 <vfprintf+0x3c4>
    f870:	8f ef       	ldi	r24, 0xFF	; 255
    f872:	9f ef       	ldi	r25, 0xFF	; 255
    f874:	2c 96       	adiw	r28, 0x0c	; 12
    f876:	0f b6       	in	r0, 0x3f	; 63
    f878:	f8 94       	cli
    f87a:	de bf       	out	0x3e, r29	; 62
    f87c:	0f be       	out	0x3f, r0	; 63
    f87e:	cd bf       	out	0x3d, r28	; 61
    f880:	df 91       	pop	r29
    f882:	cf 91       	pop	r28
    f884:	1f 91       	pop	r17
    f886:	0f 91       	pop	r16
    f888:	ff 90       	pop	r15
    f88a:	ef 90       	pop	r14
    f88c:	df 90       	pop	r13
    f88e:	cf 90       	pop	r12
    f890:	bf 90       	pop	r11
    f892:	af 90       	pop	r10
    f894:	9f 90       	pop	r9
    f896:	8f 90       	pop	r8
    f898:	7f 90       	pop	r7
    f89a:	6f 90       	pop	r6
    f89c:	5f 90       	pop	r5
    f89e:	4f 90       	pop	r4
    f8a0:	3f 90       	pop	r3
    f8a2:	2f 90       	pop	r2
    f8a4:	08 95       	ret

0000f8a6 <putval>:
    f8a6:	20 fd       	sbrc	r18, 0
    f8a8:	09 c0       	rjmp	.+18     	; 0xf8bc <putval+0x16>
    f8aa:	fc 01       	movw	r30, r24
    f8ac:	23 fd       	sbrc	r18, 3
    f8ae:	05 c0       	rjmp	.+10     	; 0xf8ba <putval+0x14>
    f8b0:	22 ff       	sbrs	r18, 2
    f8b2:	02 c0       	rjmp	.+4      	; 0xf8b8 <putval+0x12>
    f8b4:	73 83       	std	Z+3, r23	; 0x03
    f8b6:	62 83       	std	Z+2, r22	; 0x02
    f8b8:	51 83       	std	Z+1, r21	; 0x01
    f8ba:	40 83       	st	Z, r20
    f8bc:	08 95       	ret

0000f8be <mulacc>:
    f8be:	44 fd       	sbrc	r20, 4
    f8c0:	10 c0       	rjmp	.+32     	; 0xf8e2 <mulacc+0x24>
    f8c2:	46 fd       	sbrc	r20, 6
    f8c4:	10 c0       	rjmp	.+32     	; 0xf8e6 <mulacc+0x28>
    f8c6:	db 01       	movw	r26, r22
    f8c8:	fc 01       	movw	r30, r24
    f8ca:	aa 0f       	add	r26, r26
    f8cc:	bb 1f       	adc	r27, r27
    f8ce:	ee 1f       	adc	r30, r30
    f8d0:	ff 1f       	adc	r31, r31
    f8d2:	10 94       	com	r1
    f8d4:	d1 f7       	brne	.-12     	; 0xf8ca <mulacc+0xc>
    f8d6:	6a 0f       	add	r22, r26
    f8d8:	7b 1f       	adc	r23, r27
    f8da:	8e 1f       	adc	r24, r30
    f8dc:	9f 1f       	adc	r25, r31
    f8de:	31 e0       	ldi	r19, 0x01	; 1
    f8e0:	03 c0       	rjmp	.+6      	; 0xf8e8 <mulacc+0x2a>
    f8e2:	33 e0       	ldi	r19, 0x03	; 3
    f8e4:	01 c0       	rjmp	.+2      	; 0xf8e8 <mulacc+0x2a>
    f8e6:	34 e0       	ldi	r19, 0x04	; 4
    f8e8:	66 0f       	add	r22, r22
    f8ea:	77 1f       	adc	r23, r23
    f8ec:	88 1f       	adc	r24, r24
    f8ee:	99 1f       	adc	r25, r25
    f8f0:	31 50       	subi	r19, 0x01	; 1
    f8f2:	d1 f7       	brne	.-12     	; 0xf8e8 <mulacc+0x2a>
    f8f4:	62 0f       	add	r22, r18
    f8f6:	71 1d       	adc	r23, r1
    f8f8:	81 1d       	adc	r24, r1
    f8fa:	91 1d       	adc	r25, r1
    f8fc:	08 95       	ret

0000f8fe <skip_spaces>:
    f8fe:	0f 93       	push	r16
    f900:	1f 93       	push	r17
    f902:	cf 93       	push	r28
    f904:	df 93       	push	r29
    f906:	8c 01       	movw	r16, r24
    f908:	c8 01       	movw	r24, r16
    f90a:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    f90e:	ec 01       	movw	r28, r24
    f910:	97 fd       	sbrc	r25, 7
    f912:	08 c0       	rjmp	.+16     	; 0xf924 <skip_spaces+0x26>
    f914:	0e 94 6f 7f 	call	0xfede	; 0xfede <isspace>
    f918:	89 2b       	or	r24, r25
    f91a:	b1 f7       	brne	.-20     	; 0xf908 <skip_spaces+0xa>
    f91c:	b8 01       	movw	r22, r16
    f91e:	ce 01       	movw	r24, r28
    f920:	0e 94 fd 7f 	call	0xfffa	; 0xfffa <ungetc>
    f924:	ce 01       	movw	r24, r28
    f926:	df 91       	pop	r29
    f928:	cf 91       	pop	r28
    f92a:	1f 91       	pop	r17
    f92c:	0f 91       	pop	r16
    f92e:	08 95       	ret

0000f930 <conv_int>:
    f930:	8f 92       	push	r8
    f932:	9f 92       	push	r9
    f934:	af 92       	push	r10
    f936:	cf 92       	push	r12
    f938:	df 92       	push	r13
    f93a:	ef 92       	push	r14
    f93c:	ff 92       	push	r15
    f93e:	0f 93       	push	r16
    f940:	1f 93       	push	r17
    f942:	cf 93       	push	r28
    f944:	df 93       	push	r29
    f946:	ec 01       	movw	r28, r24
    f948:	a6 2e       	mov	r10, r22
    f94a:	4a 01       	movw	r8, r20
    f94c:	02 2f       	mov	r16, r18
    f94e:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    f952:	ac 01       	movw	r20, r24
    f954:	55 27       	eor	r21, r21
    f956:	4b 32       	cpi	r20, 0x2B	; 43
    f958:	51 05       	cpc	r21, r1
    f95a:	21 f0       	breq	.+8      	; 0xf964 <conv_int+0x34>
    f95c:	4d 32       	cpi	r20, 0x2D	; 45
    f95e:	51 05       	cpc	r21, r1
    f960:	51 f4       	brne	.+20     	; 0xf976 <conv_int+0x46>
    f962:	00 68       	ori	r16, 0x80	; 128
    f964:	aa 94       	dec	r10
    f966:	11 f4       	brne	.+4      	; 0xf96c <conv_int+0x3c>
    f968:	80 e0       	ldi	r24, 0x00	; 0
    f96a:	67 c0       	rjmp	.+206    	; 0xfa3a <conv_int+0x10a>
    f96c:	ce 01       	movw	r24, r28
    f96e:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    f972:	97 fd       	sbrc	r25, 7
    f974:	f9 cf       	rjmp	.-14     	; 0xf968 <conv_int+0x38>
    f976:	10 2f       	mov	r17, r16
    f978:	1d 7f       	andi	r17, 0xFD	; 253
    f97a:	30 2f       	mov	r19, r16
    f97c:	30 73       	andi	r19, 0x30	; 48
    f97e:	01 f5       	brne	.+64     	; 0xf9c0 <conv_int+0x90>
    f980:	80 33       	cpi	r24, 0x30	; 48
    f982:	f1 f4       	brne	.+60     	; 0xf9c0 <conv_int+0x90>
    f984:	ff 24       	eor	r15, r15
    f986:	fa 94       	dec	r15
    f988:	fa 0c       	add	r15, r10
    f98a:	09 f4       	brne	.+2      	; 0xf98e <conv_int+0x5e>
    f98c:	42 c0       	rjmp	.+132    	; 0xfa12 <conv_int+0xe2>
    f98e:	ce 01       	movw	r24, r28
    f990:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    f994:	97 fd       	sbrc	r25, 7
    f996:	3d c0       	rjmp	.+122    	; 0xfa12 <conv_int+0xe2>
    f998:	38 2f       	mov	r19, r24
    f99a:	3f 7d       	andi	r19, 0xDF	; 223
    f99c:	38 35       	cpi	r19, 0x58	; 88
    f99e:	51 f4       	brne	.+20     	; 0xf9b4 <conv_int+0x84>
    f9a0:	12 64       	ori	r17, 0x42	; 66
    f9a2:	aa 94       	dec	r10
    f9a4:	aa 94       	dec	r10
    f9a6:	a9 f1       	breq	.+106    	; 0xfa12 <conv_int+0xe2>
    f9a8:	ce 01       	movw	r24, r28
    f9aa:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    f9ae:	97 ff       	sbrs	r25, 7
    f9b0:	07 c0       	rjmp	.+14     	; 0xf9c0 <conv_int+0x90>
    f9b2:	2f c0       	rjmp	.+94     	; 0xfa12 <conv_int+0xe2>
    f9b4:	06 ff       	sbrs	r16, 6
    f9b6:	02 c0       	rjmp	.+4      	; 0xf9bc <conv_int+0x8c>
    f9b8:	12 60       	ori	r17, 0x02	; 2
    f9ba:	01 c0       	rjmp	.+2      	; 0xf9be <conv_int+0x8e>
    f9bc:	12 61       	ori	r17, 0x12	; 18
    f9be:	af 2c       	mov	r10, r15
    f9c0:	c1 2c       	mov	r12, r1
    f9c2:	d1 2c       	mov	r13, r1
    f9c4:	76 01       	movw	r14, r12
    f9c6:	20 ed       	ldi	r18, 0xD0	; 208
    f9c8:	28 0f       	add	r18, r24
    f9ca:	28 30       	cpi	r18, 0x08	; 8
    f9cc:	80 f0       	brcs	.+32     	; 0xf9ee <conv_int+0xbe>
    f9ce:	14 ff       	sbrs	r17, 4
    f9d0:	04 c0       	rjmp	.+8      	; 0xf9da <conv_int+0xaa>
    f9d2:	be 01       	movw	r22, r28
    f9d4:	0e 94 fd 7f 	call	0xfffa	; 0xfffa <ungetc>
    f9d8:	19 c0       	rjmp	.+50     	; 0xfa0c <conv_int+0xdc>
    f9da:	2a 30       	cpi	r18, 0x0A	; 10
    f9dc:	40 f0       	brcs	.+16     	; 0xf9ee <conv_int+0xbe>
    f9de:	16 ff       	sbrs	r17, 6
    f9e0:	f8 cf       	rjmp	.-16     	; 0xf9d2 <conv_int+0xa2>
    f9e2:	2f 7d       	andi	r18, 0xDF	; 223
    f9e4:	3f ee       	ldi	r19, 0xEF	; 239
    f9e6:	32 0f       	add	r19, r18
    f9e8:	36 30       	cpi	r19, 0x06	; 6
    f9ea:	98 f7       	brcc	.-26     	; 0xf9d2 <conv_int+0xa2>
    f9ec:	27 50       	subi	r18, 0x07	; 7
    f9ee:	41 2f       	mov	r20, r17
    f9f0:	c7 01       	movw	r24, r14
    f9f2:	b6 01       	movw	r22, r12
    f9f4:	0e 94 5f 7c 	call	0xf8be	; 0xf8be <mulacc>
    f9f8:	6b 01       	movw	r12, r22
    f9fa:	7c 01       	movw	r14, r24
    f9fc:	12 60       	ori	r17, 0x02	; 2
    f9fe:	aa 94       	dec	r10
    fa00:	59 f0       	breq	.+22     	; 0xfa18 <conv_int+0xe8>
    fa02:	ce 01       	movw	r24, r28
    fa04:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    fa08:	97 ff       	sbrs	r25, 7
    fa0a:	dd cf       	rjmp	.-70     	; 0xf9c6 <conv_int+0x96>
    fa0c:	11 fd       	sbrc	r17, 1
    fa0e:	04 c0       	rjmp	.+8      	; 0xfa18 <conv_int+0xe8>
    fa10:	ab cf       	rjmp	.-170    	; 0xf968 <conv_int+0x38>
    fa12:	c1 2c       	mov	r12, r1
    fa14:	d1 2c       	mov	r13, r1
    fa16:	76 01       	movw	r14, r12
    fa18:	17 ff       	sbrs	r17, 7
    fa1a:	08 c0       	rjmp	.+16     	; 0xfa2c <conv_int+0xfc>
    fa1c:	f0 94       	com	r15
    fa1e:	e0 94       	com	r14
    fa20:	d0 94       	com	r13
    fa22:	c0 94       	com	r12
    fa24:	c1 1c       	adc	r12, r1
    fa26:	d1 1c       	adc	r13, r1
    fa28:	e1 1c       	adc	r14, r1
    fa2a:	f1 1c       	adc	r15, r1
    fa2c:	21 2f       	mov	r18, r17
    fa2e:	b7 01       	movw	r22, r14
    fa30:	a6 01       	movw	r20, r12
    fa32:	c4 01       	movw	r24, r8
    fa34:	0e 94 53 7c 	call	0xf8a6	; 0xf8a6 <putval>
    fa38:	81 e0       	ldi	r24, 0x01	; 1
    fa3a:	df 91       	pop	r29
    fa3c:	cf 91       	pop	r28
    fa3e:	1f 91       	pop	r17
    fa40:	0f 91       	pop	r16
    fa42:	ff 90       	pop	r15
    fa44:	ef 90       	pop	r14
    fa46:	df 90       	pop	r13
    fa48:	cf 90       	pop	r12
    fa4a:	af 90       	pop	r10
    fa4c:	9f 90       	pop	r9
    fa4e:	8f 90       	pop	r8
    fa50:	08 95       	ret

0000fa52 <conv_brk>:
    fa52:	7f 92       	push	r7
    fa54:	8f 92       	push	r8
    fa56:	9f 92       	push	r9
    fa58:	af 92       	push	r10
    fa5a:	bf 92       	push	r11
    fa5c:	cf 92       	push	r12
    fa5e:	df 92       	push	r13
    fa60:	ef 92       	push	r14
    fa62:	ff 92       	push	r15
    fa64:	0f 93       	push	r16
    fa66:	1f 93       	push	r17
    fa68:	cf 93       	push	r28
    fa6a:	df 93       	push	r29
    fa6c:	cd b7       	in	r28, 0x3d	; 61
    fa6e:	de b7       	in	r29, 0x3e	; 62
    fa70:	a1 97       	sbiw	r28, 0x21	; 33
    fa72:	0f b6       	in	r0, 0x3f	; 63
    fa74:	f8 94       	cli
    fa76:	de bf       	out	0x3e, r29	; 62
    fa78:	0f be       	out	0x3f, r0	; 63
    fa7a:	cd bf       	out	0x3d, r28	; 61
    fa7c:	5c 01       	movw	r10, r24
    fa7e:	7a 01       	movw	r14, r20
    fa80:	8e 01       	movw	r16, r28
    fa82:	0f 5f       	subi	r16, 0xFF	; 255
    fa84:	1f 4f       	sbci	r17, 0xFF	; 255
    fa86:	68 01       	movw	r12, r16
    fa88:	80 e2       	ldi	r24, 0x20	; 32
    fa8a:	d8 01       	movw	r26, r16
    fa8c:	1d 92       	st	X+, r1
    fa8e:	8a 95       	dec	r24
    fa90:	e9 f7       	brne	.-6      	; 0xfa8c <conv_brk+0x3a>
    fa92:	f5 01       	movw	r30, r10
    fa94:	73 80       	ldd	r7, Z+3	; 0x03
    fa96:	40 e0       	ldi	r20, 0x00	; 0
    fa98:	50 e0       	ldi	r21, 0x00	; 0
    fa9a:	81 2c       	mov	r8, r1
    fa9c:	b0 e0       	ldi	r27, 0x00	; 0
    fa9e:	91 2c       	mov	r9, r1
    faa0:	81 e0       	ldi	r24, 0x01	; 1
    faa2:	90 e0       	ldi	r25, 0x00	; 0
    faa4:	f9 01       	movw	r30, r18
    faa6:	73 fc       	sbrc	r7, 3
    faa8:	a5 91       	lpm	r26, Z+
    faaa:	73 fe       	sbrs	r7, 3
    faac:	a1 91       	ld	r26, Z+
    faae:	8f 01       	movw	r16, r30
    fab0:	7a 2f       	mov	r23, r26
    fab2:	9f 01       	movw	r18, r30
    fab4:	a1 11       	cpse	r26, r1
    fab6:	03 c0       	rjmp	.+6      	; 0xfabe <conv_brk+0x6c>
    fab8:	80 e0       	ldi	r24, 0x00	; 0
    faba:	90 e0       	ldi	r25, 0x00	; 0
    fabc:	7d c0       	rjmp	.+250    	; 0xfbb8 <conv_brk+0x166>
    fabe:	ae 35       	cpi	r26, 0x5E	; 94
    fac0:	19 f4       	brne	.+6      	; 0xfac8 <conv_brk+0x76>
    fac2:	41 15       	cp	r20, r1
    fac4:	51 05       	cpc	r21, r1
    fac6:	59 f1       	breq	.+86     	; 0xfb1e <conv_brk+0xcc>
    fac8:	e9 2d       	mov	r30, r9
    faca:	f0 e0       	ldi	r31, 0x00	; 0
    facc:	e4 17       	cp	r30, r20
    face:	f5 07       	cpc	r31, r21
    fad0:	3c f4       	brge	.+14     	; 0xfae0 <conv_brk+0x8e>
    fad2:	ad 35       	cpi	r26, 0x5D	; 93
    fad4:	69 f1       	breq	.+90     	; 0xfb30 <conv_brk+0xde>
    fad6:	ad 32       	cpi	r26, 0x2D	; 45
    fad8:	19 f4       	brne	.+6      	; 0xfae0 <conv_brk+0x8e>
    fada:	bb 23       	and	r27, r27
    fadc:	19 f1       	breq	.+70     	; 0xfb24 <conv_brk+0xd2>
    fade:	03 c0       	rjmp	.+6      	; 0xfae6 <conv_brk+0x94>
    fae0:	b1 11       	cpse	r27, r1
    fae2:	01 c0       	rjmp	.+2      	; 0xfae6 <conv_brk+0x94>
    fae4:	8a 2e       	mov	r8, r26
    fae6:	e7 2f       	mov	r30, r23
    fae8:	e6 95       	lsr	r30
    faea:	e6 95       	lsr	r30
    faec:	e6 95       	lsr	r30
    faee:	86 01       	movw	r16, r12
    faf0:	0e 0f       	add	r16, r30
    faf2:	11 1d       	adc	r17, r1
    faf4:	f8 01       	movw	r30, r16
    faf6:	a7 2f       	mov	r26, r23
    faf8:	a7 70       	andi	r26, 0x07	; 7
    fafa:	8c 01       	movw	r16, r24
    fafc:	02 c0       	rjmp	.+4      	; 0xfb02 <conv_brk+0xb0>
    fafe:	00 0f       	add	r16, r16
    fb00:	11 1f       	adc	r17, r17
    fb02:	aa 95       	dec	r26
    fb04:	e2 f7       	brpl	.-8      	; 0xfafe <conv_brk+0xac>
    fb06:	d8 01       	movw	r26, r16
    fb08:	b0 81       	ld	r27, Z
    fb0a:	ba 2b       	or	r27, r26
    fb0c:	b0 83       	st	Z, r27
    fb0e:	78 15       	cp	r23, r8
    fb10:	59 f0       	breq	.+22     	; 0xfb28 <conv_brk+0xd6>
    fb12:	78 15       	cp	r23, r8
    fb14:	10 f4       	brcc	.+4      	; 0xfb1a <conv_brk+0xc8>
    fb16:	7f 5f       	subi	r23, 0xFF	; 255
    fb18:	e6 cf       	rjmp	.-52     	; 0xfae6 <conv_brk+0x94>
    fb1a:	71 50       	subi	r23, 0x01	; 1
    fb1c:	e4 cf       	rjmp	.-56     	; 0xfae6 <conv_brk+0x94>
    fb1e:	99 24       	eor	r9, r9
    fb20:	93 94       	inc	r9
    fb22:	03 c0       	rjmp	.+6      	; 0xfb2a <conv_brk+0xd8>
    fb24:	b1 e0       	ldi	r27, 0x01	; 1
    fb26:	01 c0       	rjmp	.+2      	; 0xfb2a <conv_brk+0xd8>
    fb28:	b0 e0       	ldi	r27, 0x00	; 0
    fb2a:	4f 5f       	subi	r20, 0xFF	; 255
    fb2c:	5f 4f       	sbci	r21, 0xFF	; 255
    fb2e:	ba cf       	rjmp	.-140    	; 0xfaa4 <conv_brk+0x52>
    fb30:	bb 23       	and	r27, r27
    fb32:	19 f0       	breq	.+6      	; 0xfb3a <conv_brk+0xe8>
    fb34:	8e 81       	ldd	r24, Y+6	; 0x06
    fb36:	80 62       	ori	r24, 0x20	; 32
    fb38:	8e 83       	std	Y+6, r24	; 0x06
    fb3a:	91 10       	cpse	r9, r1
    fb3c:	03 c0       	rjmp	.+6      	; 0xfb44 <conv_brk+0xf2>
    fb3e:	99 24       	eor	r9, r9
    fb40:	93 94       	inc	r9
    fb42:	15 c0       	rjmp	.+42     	; 0xfb6e <conv_brk+0x11c>
    fb44:	f6 01       	movw	r30, r12
    fb46:	ce 01       	movw	r24, r28
    fb48:	81 96       	adiw	r24, 0x21	; 33
    fb4a:	20 81       	ld	r18, Z
    fb4c:	20 95       	com	r18
    fb4e:	21 93       	st	Z+, r18
    fb50:	e8 17       	cp	r30, r24
    fb52:	f9 07       	cpc	r31, r25
    fb54:	d1 f7       	brne	.-12     	; 0xfb4a <conv_brk+0xf8>
    fb56:	f3 cf       	rjmp	.-26     	; 0xfb3e <conv_brk+0xec>
    fb58:	e1 14       	cp	r14, r1
    fb5a:	f1 04       	cpc	r15, r1
    fb5c:	29 f0       	breq	.+10     	; 0xfb68 <conv_brk+0x116>
    fb5e:	d7 01       	movw	r26, r14
    fb60:	8c 93       	st	X, r24
    fb62:	f7 01       	movw	r30, r14
    fb64:	31 96       	adiw	r30, 0x01	; 1
    fb66:	7f 01       	movw	r14, r30
    fb68:	61 50       	subi	r22, 0x01	; 1
    fb6a:	01 f1       	breq	.+64     	; 0xfbac <conv_brk+0x15a>
    fb6c:	91 2c       	mov	r9, r1
    fb6e:	c5 01       	movw	r24, r10
    fb70:	69 a3       	std	Y+33, r22	; 0x21
    fb72:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    fb76:	69 a1       	ldd	r22, Y+33	; 0x21
    fb78:	97 fd       	sbrc	r25, 7
    fb7a:	16 c0       	rjmp	.+44     	; 0xfba8 <conv_brk+0x156>
    fb7c:	28 2f       	mov	r18, r24
    fb7e:	26 95       	lsr	r18
    fb80:	26 95       	lsr	r18
    fb82:	26 95       	lsr	r18
    fb84:	f6 01       	movw	r30, r12
    fb86:	e2 0f       	add	r30, r18
    fb88:	f1 1d       	adc	r31, r1
    fb8a:	20 81       	ld	r18, Z
    fb8c:	30 e0       	ldi	r19, 0x00	; 0
    fb8e:	ac 01       	movw	r20, r24
    fb90:	47 70       	andi	r20, 0x07	; 7
    fb92:	55 27       	eor	r21, r21
    fb94:	02 c0       	rjmp	.+4      	; 0xfb9a <conv_brk+0x148>
    fb96:	35 95       	asr	r19
    fb98:	27 95       	ror	r18
    fb9a:	4a 95       	dec	r20
    fb9c:	e2 f7       	brpl	.-8      	; 0xfb96 <conv_brk+0x144>
    fb9e:	20 fd       	sbrc	r18, 0
    fba0:	db cf       	rjmp	.-74     	; 0xfb58 <conv_brk+0x106>
    fba2:	b5 01       	movw	r22, r10
    fba4:	0e 94 fd 7f 	call	0xfffa	; 0xfffa <ungetc>
    fba8:	91 10       	cpse	r9, r1
    fbaa:	86 cf       	rjmp	.-244    	; 0xfab8 <conv_brk+0x66>
    fbac:	e1 14       	cp	r14, r1
    fbae:	f1 04       	cpc	r15, r1
    fbb0:	11 f0       	breq	.+4      	; 0xfbb6 <conv_brk+0x164>
    fbb2:	d7 01       	movw	r26, r14
    fbb4:	1c 92       	st	X, r1
    fbb6:	c8 01       	movw	r24, r16
    fbb8:	a1 96       	adiw	r28, 0x21	; 33
    fbba:	0f b6       	in	r0, 0x3f	; 63
    fbbc:	f8 94       	cli
    fbbe:	de bf       	out	0x3e, r29	; 62
    fbc0:	0f be       	out	0x3f, r0	; 63
    fbc2:	cd bf       	out	0x3d, r28	; 61
    fbc4:	df 91       	pop	r29
    fbc6:	cf 91       	pop	r28
    fbc8:	1f 91       	pop	r17
    fbca:	0f 91       	pop	r16
    fbcc:	ff 90       	pop	r15
    fbce:	ef 90       	pop	r14
    fbd0:	df 90       	pop	r13
    fbd2:	cf 90       	pop	r12
    fbd4:	bf 90       	pop	r11
    fbd6:	af 90       	pop	r10
    fbd8:	9f 90       	pop	r9
    fbda:	8f 90       	pop	r8
    fbdc:	7f 90       	pop	r7
    fbde:	08 95       	ret

0000fbe0 <vfscanf>:
    fbe0:	4f 92       	push	r4
    fbe2:	5f 92       	push	r5
    fbe4:	7f 92       	push	r7
    fbe6:	8f 92       	push	r8
    fbe8:	9f 92       	push	r9
    fbea:	af 92       	push	r10
    fbec:	bf 92       	push	r11
    fbee:	cf 92       	push	r12
    fbf0:	df 92       	push	r13
    fbf2:	ef 92       	push	r14
    fbf4:	ff 92       	push	r15
    fbf6:	0f 93       	push	r16
    fbf8:	1f 93       	push	r17
    fbfa:	cf 93       	push	r28
    fbfc:	df 93       	push	r29
    fbfe:	1f 92       	push	r1
    fc00:	cd b7       	in	r28, 0x3d	; 61
    fc02:	de b7       	in	r29, 0x3e	; 62
    fc04:	8c 01       	movw	r16, r24
    fc06:	2b 01       	movw	r4, r22
    fc08:	7a 01       	movw	r14, r20
    fc0a:	fc 01       	movw	r30, r24
    fc0c:	17 82       	std	Z+7, r1	; 0x07
    fc0e:	16 82       	std	Z+6, r1	; 0x06
    fc10:	a1 2c       	mov	r10, r1
    fc12:	f8 01       	movw	r30, r16
    fc14:	d3 80       	ldd	r13, Z+3	; 0x03
    fc16:	f2 01       	movw	r30, r4
    fc18:	d3 fc       	sbrc	r13, 3
    fc1a:	85 91       	lpm	r24, Z+
    fc1c:	d3 fe       	sbrs	r13, 3
    fc1e:	81 91       	ld	r24, Z+
    fc20:	38 2f       	mov	r19, r24
    fc22:	2f 01       	movw	r4, r30
    fc24:	88 23       	and	r24, r24
    fc26:	09 f4       	brne	.+2      	; 0xfc2a <vfscanf+0x4a>
    fc28:	fc c0       	rjmp	.+504    	; 0xfe22 <vfscanf+0x242>
    fc2a:	90 e0       	ldi	r25, 0x00	; 0
    fc2c:	39 83       	std	Y+1, r19	; 0x01
    fc2e:	0e 94 6f 7f 	call	0xfede	; 0xfede <isspace>
    fc32:	39 81       	ldd	r19, Y+1	; 0x01
    fc34:	89 2b       	or	r24, r25
    fc36:	21 f0       	breq	.+8      	; 0xfc40 <vfscanf+0x60>
    fc38:	c8 01       	movw	r24, r16
    fc3a:	0e 94 7f 7c 	call	0xf8fe	; 0xf8fe <skip_spaces>
    fc3e:	e9 cf       	rjmp	.-46     	; 0xfc12 <vfscanf+0x32>
    fc40:	35 32       	cpi	r19, 0x25	; 37
    fc42:	41 f4       	brne	.+16     	; 0xfc54 <vfscanf+0x74>
    fc44:	f2 01       	movw	r30, r4
    fc46:	d3 fc       	sbrc	r13, 3
    fc48:	35 91       	lpm	r19, Z+
    fc4a:	d3 fe       	sbrs	r13, 3
    fc4c:	31 91       	ld	r19, Z+
    fc4e:	2f 01       	movw	r4, r30
    fc50:	35 32       	cpi	r19, 0x25	; 37
    fc52:	69 f4       	brne	.+26     	; 0xfc6e <vfscanf+0x8e>
    fc54:	c8 01       	movw	r24, r16
    fc56:	39 83       	std	Y+1, r19	; 0x01
    fc58:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    fc5c:	39 81       	ldd	r19, Y+1	; 0x01
    fc5e:	97 fd       	sbrc	r25, 7
    fc60:	de c0       	rjmp	.+444    	; 0xfe1e <vfscanf+0x23e>
    fc62:	38 17       	cp	r19, r24
    fc64:	b1 f2       	breq	.-84     	; 0xfc12 <vfscanf+0x32>
    fc66:	b8 01       	movw	r22, r16
    fc68:	0e 94 fd 7f 	call	0xfffa	; 0xfffa <ungetc>
    fc6c:	da c0       	rjmp	.+436    	; 0xfe22 <vfscanf+0x242>
    fc6e:	3a 32       	cpi	r19, 0x2A	; 42
    fc70:	41 f4       	brne	.+16     	; 0xfc82 <vfscanf+0xa2>
    fc72:	d3 fc       	sbrc	r13, 3
    fc74:	35 91       	lpm	r19, Z+
    fc76:	d3 fe       	sbrs	r13, 3
    fc78:	31 91       	ld	r19, Z+
    fc7a:	2f 01       	movw	r4, r30
    fc7c:	bb 24       	eor	r11, r11
    fc7e:	b3 94       	inc	r11
    fc80:	01 c0       	rjmp	.+2      	; 0xfc84 <vfscanf+0xa4>
    fc82:	b1 2c       	mov	r11, r1
    fc84:	71 2c       	mov	r7, r1
    fc86:	20 ed       	ldi	r18, 0xD0	; 208
    fc88:	23 0f       	add	r18, r19
    fc8a:	2a 30       	cpi	r18, 0x0A	; 10
    fc8c:	90 f4       	brcc	.+36     	; 0xfcb2 <vfscanf+0xd2>
    fc8e:	fb 2d       	mov	r31, r11
    fc90:	f2 60       	ori	r31, 0x02	; 2
    fc92:	bf 2e       	mov	r11, r31
    fc94:	67 2d       	mov	r22, r7
    fc96:	70 e0       	ldi	r23, 0x00	; 0
    fc98:	80 e0       	ldi	r24, 0x00	; 0
    fc9a:	90 e0       	ldi	r25, 0x00	; 0
    fc9c:	40 e2       	ldi	r20, 0x20	; 32
    fc9e:	0e 94 5f 7c 	call	0xf8be	; 0xf8be <mulacc>
    fca2:	76 2e       	mov	r7, r22
    fca4:	f2 01       	movw	r30, r4
    fca6:	d3 fc       	sbrc	r13, 3
    fca8:	35 91       	lpm	r19, Z+
    fcaa:	d3 fe       	sbrs	r13, 3
    fcac:	31 91       	ld	r19, Z+
    fcae:	2f 01       	movw	r4, r30
    fcb0:	ea cf       	rjmp	.-44     	; 0xfc86 <vfscanf+0xa6>
    fcb2:	b1 fe       	sbrs	r11, 1
    fcb4:	03 c0       	rjmp	.+6      	; 0xfcbc <vfscanf+0xdc>
    fcb6:	71 10       	cpse	r7, r1
    fcb8:	03 c0       	rjmp	.+6      	; 0xfcc0 <vfscanf+0xe0>
    fcba:	b3 c0       	rjmp	.+358    	; 0xfe22 <vfscanf+0x242>
    fcbc:	77 24       	eor	r7, r7
    fcbe:	7a 94       	dec	r7
    fcc0:	38 36       	cpi	r19, 0x68	; 104
    fcc2:	19 f0       	breq	.+6      	; 0xfcca <vfscanf+0xea>
    fcc4:	3c 36       	cpi	r19, 0x6C	; 108
    fcc6:	61 f0       	breq	.+24     	; 0xfce0 <vfscanf+0x100>
    fcc8:	14 c0       	rjmp	.+40     	; 0xfcf2 <vfscanf+0x112>
    fcca:	f2 01       	movw	r30, r4
    fccc:	d3 fc       	sbrc	r13, 3
    fcce:	35 91       	lpm	r19, Z+
    fcd0:	d3 fe       	sbrs	r13, 3
    fcd2:	31 91       	ld	r19, Z+
    fcd4:	2f 01       	movw	r4, r30
    fcd6:	38 36       	cpi	r19, 0x68	; 104
    fcd8:	61 f4       	brne	.+24     	; 0xfcf2 <vfscanf+0x112>
    fcda:	fb 2d       	mov	r31, r11
    fcdc:	f8 60       	ori	r31, 0x08	; 8
    fcde:	bf 2e       	mov	r11, r31
    fce0:	8b 2d       	mov	r24, r11
    fce2:	84 60       	ori	r24, 0x04	; 4
    fce4:	b8 2e       	mov	r11, r24
    fce6:	f2 01       	movw	r30, r4
    fce8:	d3 fc       	sbrc	r13, 3
    fcea:	35 91       	lpm	r19, Z+
    fcec:	d3 fe       	sbrs	r13, 3
    fcee:	31 91       	ld	r19, Z+
    fcf0:	2f 01       	movw	r4, r30
    fcf2:	33 23       	and	r19, r19
    fcf4:	09 f4       	brne	.+2      	; 0xfcf8 <vfscanf+0x118>
    fcf6:	95 c0       	rjmp	.+298    	; 0xfe22 <vfscanf+0x242>
    fcf8:	63 2f       	mov	r22, r19
    fcfa:	70 e0       	ldi	r23, 0x00	; 0
    fcfc:	8c ed       	ldi	r24, 0xDC	; 220
    fcfe:	90 e5       	ldi	r25, 0x50	; 80
    fd00:	39 83       	std	Y+1, r19	; 0x01
    fd02:	0e 94 9a 77 	call	0xef34	; 0xef34 <strchr_P>
    fd06:	39 81       	ldd	r19, Y+1	; 0x01
    fd08:	89 2b       	or	r24, r25
    fd0a:	09 f4       	brne	.+2      	; 0xfd0e <vfscanf+0x12e>
    fd0c:	8a c0       	rjmp	.+276    	; 0xfe22 <vfscanf+0x242>
    fd0e:	b0 fc       	sbrc	r11, 0
    fd10:	07 c0       	rjmp	.+14     	; 0xfd20 <vfscanf+0x140>
    fd12:	f7 01       	movw	r30, r14
    fd14:	c0 80       	ld	r12, Z
    fd16:	d1 80       	ldd	r13, Z+1	; 0x01
    fd18:	c7 01       	movw	r24, r14
    fd1a:	02 96       	adiw	r24, 0x02	; 2
    fd1c:	7c 01       	movw	r14, r24
    fd1e:	02 c0       	rjmp	.+4      	; 0xfd24 <vfscanf+0x144>
    fd20:	c1 2c       	mov	r12, r1
    fd22:	d1 2c       	mov	r13, r1
    fd24:	3e 36       	cpi	r19, 0x6E	; 110
    fd26:	51 f4       	brne	.+20     	; 0xfd3c <vfscanf+0x15c>
    fd28:	f8 01       	movw	r30, r16
    fd2a:	46 81       	ldd	r20, Z+6	; 0x06
    fd2c:	57 81       	ldd	r21, Z+7	; 0x07
    fd2e:	60 e0       	ldi	r22, 0x00	; 0
    fd30:	70 e0       	ldi	r23, 0x00	; 0
    fd32:	2b 2d       	mov	r18, r11
    fd34:	c6 01       	movw	r24, r12
    fd36:	0e 94 53 7c 	call	0xf8a6	; 0xf8a6 <putval>
    fd3a:	6b cf       	rjmp	.-298    	; 0xfc12 <vfscanf+0x32>
    fd3c:	33 36       	cpi	r19, 0x63	; 99
    fd3e:	a1 f4       	brne	.+40     	; 0xfd68 <vfscanf+0x188>
    fd40:	b1 fc       	sbrc	r11, 1
    fd42:	02 c0       	rjmp	.+4      	; 0xfd48 <vfscanf+0x168>
    fd44:	77 24       	eor	r7, r7
    fd46:	73 94       	inc	r7
    fd48:	c8 01       	movw	r24, r16
    fd4a:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    fd4e:	97 fd       	sbrc	r25, 7
    fd50:	66 c0       	rjmp	.+204    	; 0xfe1e <vfscanf+0x23e>
    fd52:	c1 14       	cp	r12, r1
    fd54:	d1 04       	cpc	r13, r1
    fd56:	29 f0       	breq	.+10     	; 0xfd62 <vfscanf+0x182>
    fd58:	f6 01       	movw	r30, r12
    fd5a:	80 83       	st	Z, r24
    fd5c:	c6 01       	movw	r24, r12
    fd5e:	01 96       	adiw	r24, 0x01	; 1
    fd60:	6c 01       	movw	r12, r24
    fd62:	7a 94       	dec	r7
    fd64:	89 f7       	brne	.-30     	; 0xfd48 <vfscanf+0x168>
    fd66:	57 c0       	rjmp	.+174    	; 0xfe16 <vfscanf+0x236>
    fd68:	3b 35       	cpi	r19, 0x5B	; 91
    fd6a:	59 f4       	brne	.+22     	; 0xfd82 <vfscanf+0x1a2>
    fd6c:	92 01       	movw	r18, r4
    fd6e:	a6 01       	movw	r20, r12
    fd70:	67 2d       	mov	r22, r7
    fd72:	c8 01       	movw	r24, r16
    fd74:	0e 94 29 7d 	call	0xfa52	; 0xfa52 <conv_brk>
    fd78:	2c 01       	movw	r4, r24
    fd7a:	00 97       	sbiw	r24, 0x00	; 0
    fd7c:	09 f0       	breq	.+2      	; 0xfd80 <vfscanf+0x1a0>
    fd7e:	4b c0       	rjmp	.+150    	; 0xfe16 <vfscanf+0x236>
    fd80:	45 c0       	rjmp	.+138    	; 0xfe0c <vfscanf+0x22c>
    fd82:	c8 01       	movw	r24, r16
    fd84:	39 83       	std	Y+1, r19	; 0x01
    fd86:	0e 94 7f 7c 	call	0xf8fe	; 0xf8fe <skip_spaces>
    fd8a:	39 81       	ldd	r19, Y+1	; 0x01
    fd8c:	97 fd       	sbrc	r25, 7
    fd8e:	47 c0       	rjmp	.+142    	; 0xfe1e <vfscanf+0x23e>
    fd90:	3f 36       	cpi	r19, 0x6F	; 111
    fd92:	69 f1       	breq	.+90     	; 0xfdee <vfscanf+0x20e>
    fd94:	28 f4       	brcc	.+10     	; 0xfda0 <vfscanf+0x1c0>
    fd96:	34 36       	cpi	r19, 0x64	; 100
    fd98:	31 f1       	breq	.+76     	; 0xfde6 <vfscanf+0x206>
    fd9a:	39 36       	cpi	r19, 0x69	; 105
    fd9c:	79 f1       	breq	.+94     	; 0xfdfc <vfscanf+0x21c>
    fd9e:	2b c0       	rjmp	.+86     	; 0xfdf6 <vfscanf+0x216>
    fda0:	33 37       	cpi	r19, 0x73	; 115
    fda2:	69 f0       	breq	.+26     	; 0xfdbe <vfscanf+0x1de>
    fda4:	35 37       	cpi	r19, 0x75	; 117
    fda6:	f9 f0       	breq	.+62     	; 0xfde6 <vfscanf+0x206>
    fda8:	26 c0       	rjmp	.+76     	; 0xfdf6 <vfscanf+0x216>
    fdaa:	c1 14       	cp	r12, r1
    fdac:	d1 04       	cpc	r13, r1
    fdae:	29 f0       	breq	.+10     	; 0xfdba <vfscanf+0x1da>
    fdb0:	f6 01       	movw	r30, r12
    fdb2:	80 82       	st	Z, r8
    fdb4:	c6 01       	movw	r24, r12
    fdb6:	01 96       	adiw	r24, 0x01	; 1
    fdb8:	6c 01       	movw	r12, r24
    fdba:	7a 94       	dec	r7
    fdbc:	71 f0       	breq	.+28     	; 0xfdda <vfscanf+0x1fa>
    fdbe:	c8 01       	movw	r24, r16
    fdc0:	0e 94 8d 7f 	call	0xff1a	; 0xff1a <fgetc>
    fdc4:	4c 01       	movw	r8, r24
    fdc6:	97 fd       	sbrc	r25, 7
    fdc8:	08 c0       	rjmp	.+16     	; 0xfdda <vfscanf+0x1fa>
    fdca:	0e 94 6f 7f 	call	0xfede	; 0xfede <isspace>
    fdce:	89 2b       	or	r24, r25
    fdd0:	61 f3       	breq	.-40     	; 0xfdaa <vfscanf+0x1ca>
    fdd2:	b8 01       	movw	r22, r16
    fdd4:	c4 01       	movw	r24, r8
    fdd6:	0e 94 fd 7f 	call	0xfffa	; 0xfffa <ungetc>
    fdda:	c1 14       	cp	r12, r1
    fddc:	d1 04       	cpc	r13, r1
    fdde:	d9 f0       	breq	.+54     	; 0xfe16 <vfscanf+0x236>
    fde0:	f6 01       	movw	r30, r12
    fde2:	10 82       	st	Z, r1
    fde4:	18 c0       	rjmp	.+48     	; 0xfe16 <vfscanf+0x236>
    fde6:	fb 2d       	mov	r31, r11
    fde8:	f0 62       	ori	r31, 0x20	; 32
    fdea:	bf 2e       	mov	r11, r31
    fdec:	07 c0       	rjmp	.+14     	; 0xfdfc <vfscanf+0x21c>
    fdee:	8b 2d       	mov	r24, r11
    fdf0:	80 61       	ori	r24, 0x10	; 16
    fdf2:	b8 2e       	mov	r11, r24
    fdf4:	03 c0       	rjmp	.+6      	; 0xfdfc <vfscanf+0x21c>
    fdf6:	9b 2d       	mov	r25, r11
    fdf8:	90 64       	ori	r25, 0x40	; 64
    fdfa:	b9 2e       	mov	r11, r25
    fdfc:	2b 2d       	mov	r18, r11
    fdfe:	a6 01       	movw	r20, r12
    fe00:	67 2d       	mov	r22, r7
    fe02:	c8 01       	movw	r24, r16
    fe04:	0e 94 98 7c 	call	0xf930	; 0xf930 <conv_int>
    fe08:	81 11       	cpse	r24, r1
    fe0a:	05 c0       	rjmp	.+10     	; 0xfe16 <vfscanf+0x236>
    fe0c:	f8 01       	movw	r30, r16
    fe0e:	83 81       	ldd	r24, Z+3	; 0x03
    fe10:	80 73       	andi	r24, 0x30	; 48
    fe12:	29 f4       	brne	.+10     	; 0xfe1e <vfscanf+0x23e>
    fe14:	06 c0       	rjmp	.+12     	; 0xfe22 <vfscanf+0x242>
    fe16:	b0 fc       	sbrc	r11, 0
    fe18:	fc ce       	rjmp	.-520    	; 0xfc12 <vfscanf+0x32>
    fe1a:	a3 94       	inc	r10
    fe1c:	fa ce       	rjmp	.-524    	; 0xfc12 <vfscanf+0x32>
    fe1e:	aa 20       	and	r10, r10
    fe20:	19 f0       	breq	.+6      	; 0xfe28 <vfscanf+0x248>
    fe22:	8a 2d       	mov	r24, r10
    fe24:	90 e0       	ldi	r25, 0x00	; 0
    fe26:	02 c0       	rjmp	.+4      	; 0xfe2c <vfscanf+0x24c>
    fe28:	8f ef       	ldi	r24, 0xFF	; 255
    fe2a:	9f ef       	ldi	r25, 0xFF	; 255
    fe2c:	0f 90       	pop	r0
    fe2e:	df 91       	pop	r29
    fe30:	cf 91       	pop	r28
    fe32:	1f 91       	pop	r17
    fe34:	0f 91       	pop	r16
    fe36:	ff 90       	pop	r15
    fe38:	ef 90       	pop	r14
    fe3a:	df 90       	pop	r13
    fe3c:	cf 90       	pop	r12
    fe3e:	bf 90       	pop	r11
    fe40:	af 90       	pop	r10
    fe42:	9f 90       	pop	r9
    fe44:	8f 90       	pop	r8
    fe46:	7f 90       	pop	r7
    fe48:	5f 90       	pop	r5
    fe4a:	4f 90       	pop	r4
    fe4c:	08 95       	ret

0000fe4e <__eerd_block_m128>:
    fe4e:	dc 01       	movw	r26, r24
    fe50:	cb 01       	movw	r24, r22

0000fe52 <__eerd_blraw_m128>:
    fe52:	fc 01       	movw	r30, r24
    fe54:	e1 99       	sbic	0x1c, 1	; 28
    fe56:	fe cf       	rjmp	.-4      	; 0xfe54 <__eerd_blraw_m128+0x2>
    fe58:	06 c0       	rjmp	.+12     	; 0xfe66 <__eerd_blraw_m128+0x14>
    fe5a:	ff bb       	out	0x1f, r31	; 31
    fe5c:	ee bb       	out	0x1e, r30	; 30
    fe5e:	e0 9a       	sbi	0x1c, 0	; 28
    fe60:	31 96       	adiw	r30, 0x01	; 1
    fe62:	0d b2       	in	r0, 0x1d	; 29
    fe64:	0d 92       	st	X+, r0
    fe66:	41 50       	subi	r20, 0x01	; 1
    fe68:	50 40       	sbci	r21, 0x00	; 0
    fe6a:	b8 f7       	brcc	.-18     	; 0xfe5a <__eerd_blraw_m128+0x8>
    fe6c:	08 95       	ret

0000fe6e <__eerd_byte_m128>:
    fe6e:	e1 99       	sbic	0x1c, 1	; 28
    fe70:	fe cf       	rjmp	.-4      	; 0xfe6e <__eerd_byte_m128>
    fe72:	9f bb       	out	0x1f, r25	; 31
    fe74:	8e bb       	out	0x1e, r24	; 30
    fe76:	e0 9a       	sbi	0x1c, 0	; 28
    fe78:	99 27       	eor	r25, r25
    fe7a:	8d b3       	in	r24, 0x1d	; 29
    fe7c:	08 95       	ret

0000fe7e <__eerd_dword_m128>:
    fe7e:	a6 e1       	ldi	r26, 0x16	; 22
    fe80:	b0 e0       	ldi	r27, 0x00	; 0
    fe82:	44 e0       	ldi	r20, 0x04	; 4
    fe84:	50 e0       	ldi	r21, 0x00	; 0
    fe86:	0c 94 29 7f 	jmp	0xfe52	; 0xfe52 <__eerd_blraw_m128>

0000fe8a <__eerd_word_m128>:
    fe8a:	a8 e1       	ldi	r26, 0x18	; 24
    fe8c:	b0 e0       	ldi	r27, 0x00	; 0
    fe8e:	42 e0       	ldi	r20, 0x02	; 2
    fe90:	50 e0       	ldi	r21, 0x00	; 0
    fe92:	0c 94 29 7f 	jmp	0xfe52	; 0xfe52 <__eerd_blraw_m128>

0000fe96 <__eewr_block_m128>:
    fe96:	dc 01       	movw	r26, r24
    fe98:	cb 01       	movw	r24, r22
    fe9a:	03 c0       	rjmp	.+6      	; 0xfea2 <__eewr_block_m128+0xc>
    fe9c:	2d 91       	ld	r18, X+
    fe9e:	0e 94 56 7f 	call	0xfeac	; 0xfeac <__eewr_r18_m128>
    fea2:	41 50       	subi	r20, 0x01	; 1
    fea4:	50 40       	sbci	r21, 0x00	; 0
    fea6:	d0 f7       	brcc	.-12     	; 0xfe9c <__eewr_block_m128+0x6>
    fea8:	08 95       	ret

0000feaa <__eewr_byte_m128>:
    feaa:	26 2f       	mov	r18, r22

0000feac <__eewr_r18_m128>:
    feac:	e1 99       	sbic	0x1c, 1	; 28
    feae:	fe cf       	rjmp	.-4      	; 0xfeac <__eewr_r18_m128>
    feb0:	9f bb       	out	0x1f, r25	; 31
    feb2:	8e bb       	out	0x1e, r24	; 30
    feb4:	2d bb       	out	0x1d, r18	; 29
    feb6:	0f b6       	in	r0, 0x3f	; 63
    feb8:	f8 94       	cli
    feba:	e2 9a       	sbi	0x1c, 2	; 28
    febc:	e1 9a       	sbi	0x1c, 1	; 28
    febe:	0f be       	out	0x3f, r0	; 63
    fec0:	01 96       	adiw	r24, 0x01	; 1
    fec2:	08 95       	ret

0000fec4 <__eewr_dword_m128>:
    fec4:	24 2f       	mov	r18, r20
    fec6:	0e 94 56 7f 	call	0xfeac	; 0xfeac <__eewr_r18_m128>
    feca:	25 2f       	mov	r18, r21
    fecc:	0e 94 56 7f 	call	0xfeac	; 0xfeac <__eewr_r18_m128>
    fed0:	0c 94 6a 7f 	jmp	0xfed4	; 0xfed4 <__eewr_word_m128>

0000fed4 <__eewr_word_m128>:
    fed4:	0e 94 55 7f 	call	0xfeaa	; 0xfeaa <__eewr_byte_m128>
    fed8:	27 2f       	mov	r18, r23
    feda:	0c 94 56 7f 	jmp	0xfeac	; 0xfeac <__eewr_r18_m128>

0000fede <isspace>:
    fede:	91 11       	cpse	r25, r1
    fee0:	03 c1       	rjmp	.+518    	; 0x100e8 <__ctype_isfalse>
    fee2:	80 32       	cpi	r24, 0x20	; 32
    fee4:	19 f0       	breq	.+6      	; 0xfeec <isspace+0xe>
    fee6:	89 50       	subi	r24, 0x09	; 9
    fee8:	85 50       	subi	r24, 0x05	; 5
    feea:	d0 f7       	brcc	.-12     	; 0xfee0 <isspace+0x2>
    feec:	08 95       	ret

0000feee <strnlen_P>:
    feee:	fc 01       	movw	r30, r24
    fef0:	05 90       	lpm	r0, Z+
    fef2:	61 50       	subi	r22, 0x01	; 1
    fef4:	70 40       	sbci	r23, 0x00	; 0
    fef6:	01 10       	cpse	r0, r1
    fef8:	d8 f7       	brcc	.-10     	; 0xfef0 <strnlen_P+0x2>
    fefa:	80 95       	com	r24
    fefc:	90 95       	com	r25
    fefe:	8e 0f       	add	r24, r30
    ff00:	9f 1f       	adc	r25, r31
    ff02:	08 95       	ret

0000ff04 <strnlen>:
    ff04:	fc 01       	movw	r30, r24
    ff06:	61 50       	subi	r22, 0x01	; 1
    ff08:	70 40       	sbci	r23, 0x00	; 0
    ff0a:	01 90       	ld	r0, Z+
    ff0c:	01 10       	cpse	r0, r1
    ff0e:	d8 f7       	brcc	.-10     	; 0xff06 <strnlen+0x2>
    ff10:	80 95       	com	r24
    ff12:	90 95       	com	r25
    ff14:	8e 0f       	add	r24, r30
    ff16:	9f 1f       	adc	r25, r31
    ff18:	08 95       	ret

0000ff1a <fgetc>:
    ff1a:	cf 93       	push	r28
    ff1c:	df 93       	push	r29
    ff1e:	ec 01       	movw	r28, r24
    ff20:	2b 81       	ldd	r18, Y+3	; 0x03
    ff22:	20 ff       	sbrs	r18, 0
    ff24:	33 c0       	rjmp	.+102    	; 0xff8c <fgetc+0x72>
    ff26:	26 ff       	sbrs	r18, 6
    ff28:	0a c0       	rjmp	.+20     	; 0xff3e <fgetc+0x24>
    ff2a:	2f 7b       	andi	r18, 0xBF	; 191
    ff2c:	2b 83       	std	Y+3, r18	; 0x03
    ff2e:	8e 81       	ldd	r24, Y+6	; 0x06
    ff30:	9f 81       	ldd	r25, Y+7	; 0x07
    ff32:	01 96       	adiw	r24, 0x01	; 1
    ff34:	9f 83       	std	Y+7, r25	; 0x07
    ff36:	8e 83       	std	Y+6, r24	; 0x06
    ff38:	8a 81       	ldd	r24, Y+2	; 0x02
    ff3a:	90 e0       	ldi	r25, 0x00	; 0
    ff3c:	29 c0       	rjmp	.+82     	; 0xff90 <fgetc+0x76>
    ff3e:	22 ff       	sbrs	r18, 2
    ff40:	0f c0       	rjmp	.+30     	; 0xff60 <fgetc+0x46>
    ff42:	e8 81       	ld	r30, Y
    ff44:	f9 81       	ldd	r31, Y+1	; 0x01
    ff46:	80 81       	ld	r24, Z
    ff48:	99 27       	eor	r25, r25
    ff4a:	87 fd       	sbrc	r24, 7
    ff4c:	90 95       	com	r25
    ff4e:	00 97       	sbiw	r24, 0x00	; 0
    ff50:	19 f4       	brne	.+6      	; 0xff58 <fgetc+0x3e>
    ff52:	20 62       	ori	r18, 0x20	; 32
    ff54:	2b 83       	std	Y+3, r18	; 0x03
    ff56:	1a c0       	rjmp	.+52     	; 0xff8c <fgetc+0x72>
    ff58:	31 96       	adiw	r30, 0x01	; 1
    ff5a:	f9 83       	std	Y+1, r31	; 0x01
    ff5c:	e8 83       	st	Y, r30
    ff5e:	0e c0       	rjmp	.+28     	; 0xff7c <fgetc+0x62>
    ff60:	ea 85       	ldd	r30, Y+10	; 0x0a
    ff62:	fb 85       	ldd	r31, Y+11	; 0x0b
    ff64:	09 95       	icall
    ff66:	97 ff       	sbrs	r25, 7
    ff68:	09 c0       	rjmp	.+18     	; 0xff7c <fgetc+0x62>
    ff6a:	2b 81       	ldd	r18, Y+3	; 0x03
    ff6c:	01 96       	adiw	r24, 0x01	; 1
    ff6e:	11 f4       	brne	.+4      	; 0xff74 <fgetc+0x5a>
    ff70:	80 e1       	ldi	r24, 0x10	; 16
    ff72:	01 c0       	rjmp	.+2      	; 0xff76 <fgetc+0x5c>
    ff74:	80 e2       	ldi	r24, 0x20	; 32
    ff76:	82 2b       	or	r24, r18
    ff78:	8b 83       	std	Y+3, r24	; 0x03
    ff7a:	08 c0       	rjmp	.+16     	; 0xff8c <fgetc+0x72>
    ff7c:	2e 81       	ldd	r18, Y+6	; 0x06
    ff7e:	3f 81       	ldd	r19, Y+7	; 0x07
    ff80:	2f 5f       	subi	r18, 0xFF	; 255
    ff82:	3f 4f       	sbci	r19, 0xFF	; 255
    ff84:	3f 83       	std	Y+7, r19	; 0x07
    ff86:	2e 83       	std	Y+6, r18	; 0x06
    ff88:	99 27       	eor	r25, r25
    ff8a:	02 c0       	rjmp	.+4      	; 0xff90 <fgetc+0x76>
    ff8c:	8f ef       	ldi	r24, 0xFF	; 255
    ff8e:	9f ef       	ldi	r25, 0xFF	; 255
    ff90:	df 91       	pop	r29
    ff92:	cf 91       	pop	r28
    ff94:	08 95       	ret

0000ff96 <fputc>:
    ff96:	0f 93       	push	r16
    ff98:	1f 93       	push	r17
    ff9a:	cf 93       	push	r28
    ff9c:	df 93       	push	r29
    ff9e:	18 2f       	mov	r17, r24
    ffa0:	09 2f       	mov	r16, r25
    ffa2:	eb 01       	movw	r28, r22
    ffa4:	8b 81       	ldd	r24, Y+3	; 0x03
    ffa6:	81 fd       	sbrc	r24, 1
    ffa8:	03 c0       	rjmp	.+6      	; 0xffb0 <fputc+0x1a>
    ffaa:	8f ef       	ldi	r24, 0xFF	; 255
    ffac:	9f ef       	ldi	r25, 0xFF	; 255
    ffae:	20 c0       	rjmp	.+64     	; 0xfff0 <fputc+0x5a>
    ffb0:	82 ff       	sbrs	r24, 2
    ffb2:	10 c0       	rjmp	.+32     	; 0xffd4 <fputc+0x3e>
    ffb4:	4e 81       	ldd	r20, Y+6	; 0x06
    ffb6:	5f 81       	ldd	r21, Y+7	; 0x07
    ffb8:	2c 81       	ldd	r18, Y+4	; 0x04
    ffba:	3d 81       	ldd	r19, Y+5	; 0x05
    ffbc:	42 17       	cp	r20, r18
    ffbe:	53 07       	cpc	r21, r19
    ffc0:	7c f4       	brge	.+30     	; 0xffe0 <fputc+0x4a>
    ffc2:	e8 81       	ld	r30, Y
    ffc4:	f9 81       	ldd	r31, Y+1	; 0x01
    ffc6:	9f 01       	movw	r18, r30
    ffc8:	2f 5f       	subi	r18, 0xFF	; 255
    ffca:	3f 4f       	sbci	r19, 0xFF	; 255
    ffcc:	39 83       	std	Y+1, r19	; 0x01
    ffce:	28 83       	st	Y, r18
    ffd0:	10 83       	st	Z, r17
    ffd2:	06 c0       	rjmp	.+12     	; 0xffe0 <fputc+0x4a>
    ffd4:	e8 85       	ldd	r30, Y+8	; 0x08
    ffd6:	f9 85       	ldd	r31, Y+9	; 0x09
    ffd8:	81 2f       	mov	r24, r17
    ffda:	09 95       	icall
    ffdc:	89 2b       	or	r24, r25
    ffde:	29 f7       	brne	.-54     	; 0xffaa <fputc+0x14>
    ffe0:	2e 81       	ldd	r18, Y+6	; 0x06
    ffe2:	3f 81       	ldd	r19, Y+7	; 0x07
    ffe4:	2f 5f       	subi	r18, 0xFF	; 255
    ffe6:	3f 4f       	sbci	r19, 0xFF	; 255
    ffe8:	3f 83       	std	Y+7, r19	; 0x07
    ffea:	2e 83       	std	Y+6, r18	; 0x06
    ffec:	81 2f       	mov	r24, r17
    ffee:	90 2f       	mov	r25, r16
    fff0:	df 91       	pop	r29
    fff2:	cf 91       	pop	r28
    fff4:	1f 91       	pop	r17
    fff6:	0f 91       	pop	r16
    fff8:	08 95       	ret

0000fffa <ungetc>:
    fffa:	fb 01       	movw	r30, r22
    fffc:	23 81       	ldd	r18, Z+3	; 0x03
    fffe:	20 ff       	sbrs	r18, 0
   10000:	12 c0       	rjmp	.+36     	; 0x10026 <ungetc+0x2c>
   10002:	26 fd       	sbrc	r18, 6
   10004:	10 c0       	rjmp	.+32     	; 0x10026 <ungetc+0x2c>
   10006:	8f 3f       	cpi	r24, 0xFF	; 255
   10008:	3f ef       	ldi	r19, 0xFF	; 255
   1000a:	93 07       	cpc	r25, r19
   1000c:	61 f0       	breq	.+24     	; 0x10026 <ungetc+0x2c>
   1000e:	82 83       	std	Z+2, r24	; 0x02
   10010:	2f 7d       	andi	r18, 0xDF	; 223
   10012:	20 64       	ori	r18, 0x40	; 64
   10014:	23 83       	std	Z+3, r18	; 0x03
   10016:	26 81       	ldd	r18, Z+6	; 0x06
   10018:	37 81       	ldd	r19, Z+7	; 0x07
   1001a:	21 50       	subi	r18, 0x01	; 1
   1001c:	31 09       	sbc	r19, r1
   1001e:	37 83       	std	Z+7, r19	; 0x07
   10020:	26 83       	std	Z+6, r18	; 0x06
   10022:	99 27       	eor	r25, r25
   10024:	08 95       	ret
   10026:	8f ef       	ldi	r24, 0xFF	; 255
   10028:	9f ef       	ldi	r25, 0xFF	; 255
   1002a:	08 95       	ret

0001002c <__ultoa_invert>:
   1002c:	fa 01       	movw	r30, r20
   1002e:	aa 27       	eor	r26, r26
   10030:	28 30       	cpi	r18, 0x08	; 8
   10032:	51 f1       	breq	.+84     	; 0x10088 <__ultoa_invert+0x5c>
   10034:	20 31       	cpi	r18, 0x10	; 16
   10036:	81 f1       	breq	.+96     	; 0x10098 <__ultoa_invert+0x6c>
   10038:	e8 94       	clt
   1003a:	6f 93       	push	r22
   1003c:	6e 7f       	andi	r22, 0xFE	; 254
   1003e:	6e 5f       	subi	r22, 0xFE	; 254
   10040:	7f 4f       	sbci	r23, 0xFF	; 255
   10042:	8f 4f       	sbci	r24, 0xFF	; 255
   10044:	9f 4f       	sbci	r25, 0xFF	; 255
   10046:	af 4f       	sbci	r26, 0xFF	; 255
   10048:	b1 e0       	ldi	r27, 0x01	; 1
   1004a:	3e d0       	rcall	.+124    	; 0x100c8 <__ultoa_invert+0x9c>
   1004c:	b4 e0       	ldi	r27, 0x04	; 4
   1004e:	3c d0       	rcall	.+120    	; 0x100c8 <__ultoa_invert+0x9c>
   10050:	67 0f       	add	r22, r23
   10052:	78 1f       	adc	r23, r24
   10054:	89 1f       	adc	r24, r25
   10056:	9a 1f       	adc	r25, r26
   10058:	a1 1d       	adc	r26, r1
   1005a:	68 0f       	add	r22, r24
   1005c:	79 1f       	adc	r23, r25
   1005e:	8a 1f       	adc	r24, r26
   10060:	91 1d       	adc	r25, r1
   10062:	a1 1d       	adc	r26, r1
   10064:	6a 0f       	add	r22, r26
   10066:	71 1d       	adc	r23, r1
   10068:	81 1d       	adc	r24, r1
   1006a:	91 1d       	adc	r25, r1
   1006c:	a1 1d       	adc	r26, r1
   1006e:	20 d0       	rcall	.+64     	; 0x100b0 <__ultoa_invert+0x84>
   10070:	09 f4       	brne	.+2      	; 0x10074 <__ultoa_invert+0x48>
   10072:	68 94       	set
   10074:	3f 91       	pop	r19
   10076:	2a e0       	ldi	r18, 0x0A	; 10
   10078:	26 9f       	mul	r18, r22
   1007a:	11 24       	eor	r1, r1
   1007c:	30 19       	sub	r19, r0
   1007e:	30 5d       	subi	r19, 0xD0	; 208
   10080:	31 93       	st	Z+, r19
   10082:	de f6       	brtc	.-74     	; 0x1003a <__ultoa_invert+0xe>
   10084:	cf 01       	movw	r24, r30
   10086:	08 95       	ret
   10088:	46 2f       	mov	r20, r22
   1008a:	47 70       	andi	r20, 0x07	; 7
   1008c:	40 5d       	subi	r20, 0xD0	; 208
   1008e:	41 93       	st	Z+, r20
   10090:	b3 e0       	ldi	r27, 0x03	; 3
   10092:	0f d0       	rcall	.+30     	; 0x100b2 <__ultoa_invert+0x86>
   10094:	c9 f7       	brne	.-14     	; 0x10088 <__ultoa_invert+0x5c>
   10096:	f6 cf       	rjmp	.-20     	; 0x10084 <__ultoa_invert+0x58>
   10098:	46 2f       	mov	r20, r22
   1009a:	4f 70       	andi	r20, 0x0F	; 15
   1009c:	40 5d       	subi	r20, 0xD0	; 208
   1009e:	4a 33       	cpi	r20, 0x3A	; 58
   100a0:	18 f0       	brcs	.+6      	; 0x100a8 <__ultoa_invert+0x7c>
   100a2:	49 5d       	subi	r20, 0xD9	; 217
   100a4:	31 fd       	sbrc	r19, 1
   100a6:	40 52       	subi	r20, 0x20	; 32
   100a8:	41 93       	st	Z+, r20
   100aa:	02 d0       	rcall	.+4      	; 0x100b0 <__ultoa_invert+0x84>
   100ac:	a9 f7       	brne	.-22     	; 0x10098 <__ultoa_invert+0x6c>
   100ae:	ea cf       	rjmp	.-44     	; 0x10084 <__ultoa_invert+0x58>
   100b0:	b4 e0       	ldi	r27, 0x04	; 4
   100b2:	a6 95       	lsr	r26
   100b4:	97 95       	ror	r25
   100b6:	87 95       	ror	r24
   100b8:	77 95       	ror	r23
   100ba:	67 95       	ror	r22
   100bc:	ba 95       	dec	r27
   100be:	c9 f7       	brne	.-14     	; 0x100b2 <__ultoa_invert+0x86>
   100c0:	00 97       	sbiw	r24, 0x00	; 0
   100c2:	61 05       	cpc	r22, r1
   100c4:	71 05       	cpc	r23, r1
   100c6:	08 95       	ret
   100c8:	9b 01       	movw	r18, r22
   100ca:	ac 01       	movw	r20, r24
   100cc:	0a 2e       	mov	r0, r26
   100ce:	06 94       	lsr	r0
   100d0:	57 95       	ror	r21
   100d2:	47 95       	ror	r20
   100d4:	37 95       	ror	r19
   100d6:	27 95       	ror	r18
   100d8:	ba 95       	dec	r27
   100da:	c9 f7       	brne	.-14     	; 0x100ce <__ultoa_invert+0xa2>
   100dc:	62 0f       	add	r22, r18
   100de:	73 1f       	adc	r23, r19
   100e0:	84 1f       	adc	r24, r20
   100e2:	95 1f       	adc	r25, r21
   100e4:	a0 1d       	adc	r26, r0
   100e6:	08 95       	ret

000100e8 <__ctype_isfalse>:
   100e8:	99 27       	eor	r25, r25
   100ea:	88 27       	eor	r24, r24

000100ec <__ctype_istrue>:
   100ec:	08 95       	ret

000100ee <__udivmodqi4>:
   100ee:	99 1b       	sub	r25, r25
   100f0:	79 e0       	ldi	r23, 0x09	; 9
   100f2:	04 c0       	rjmp	.+8      	; 0x100fc <__udivmodqi4_ep>

000100f4 <__udivmodqi4_loop>:
   100f4:	99 1f       	adc	r25, r25
   100f6:	96 17       	cp	r25, r22
   100f8:	08 f0       	brcs	.+2      	; 0x100fc <__udivmodqi4_ep>
   100fa:	96 1b       	sub	r25, r22

000100fc <__udivmodqi4_ep>:
   100fc:	88 1f       	adc	r24, r24
   100fe:	7a 95       	dec	r23
   10100:	c9 f7       	brne	.-14     	; 0x100f4 <__udivmodqi4_loop>
   10102:	80 95       	com	r24
   10104:	08 95       	ret

00010106 <__udivmodhi4>:
   10106:	aa 1b       	sub	r26, r26
   10108:	bb 1b       	sub	r27, r27
   1010a:	51 e1       	ldi	r21, 0x11	; 17
   1010c:	07 c0       	rjmp	.+14     	; 0x1011c <__udivmodhi4_ep>

0001010e <__udivmodhi4_loop>:
   1010e:	aa 1f       	adc	r26, r26
   10110:	bb 1f       	adc	r27, r27
   10112:	a6 17       	cp	r26, r22
   10114:	b7 07       	cpc	r27, r23
   10116:	10 f0       	brcs	.+4      	; 0x1011c <__udivmodhi4_ep>
   10118:	a6 1b       	sub	r26, r22
   1011a:	b7 0b       	sbc	r27, r23

0001011c <__udivmodhi4_ep>:
   1011c:	88 1f       	adc	r24, r24
   1011e:	99 1f       	adc	r25, r25
   10120:	5a 95       	dec	r21
   10122:	a9 f7       	brne	.-22     	; 0x1010e <__udivmodhi4_loop>
   10124:	80 95       	com	r24
   10126:	90 95       	com	r25
   10128:	bc 01       	movw	r22, r24
   1012a:	cd 01       	movw	r24, r26
   1012c:	08 95       	ret

0001012e <__divmodhi4>:
   1012e:	97 fb       	bst	r25, 7
   10130:	07 2e       	mov	r0, r23
   10132:	16 f4       	brtc	.+4      	; 0x10138 <__divmodhi4+0xa>
   10134:	00 94       	com	r0
   10136:	07 d0       	rcall	.+14     	; 0x10146 <__divmodhi4_neg1>
   10138:	77 fd       	sbrc	r23, 7
   1013a:	09 d0       	rcall	.+18     	; 0x1014e <__divmodhi4_neg2>
   1013c:	0e 94 83 80 	call	0x10106	; 0x10106 <__udivmodhi4>
   10140:	07 fc       	sbrc	r0, 7
   10142:	05 d0       	rcall	.+10     	; 0x1014e <__divmodhi4_neg2>
   10144:	3e f4       	brtc	.+14     	; 0x10154 <__divmodhi4_exit>

00010146 <__divmodhi4_neg1>:
   10146:	90 95       	com	r25
   10148:	81 95       	neg	r24
   1014a:	9f 4f       	sbci	r25, 0xFF	; 255
   1014c:	08 95       	ret

0001014e <__divmodhi4_neg2>:
   1014e:	70 95       	com	r23
   10150:	61 95       	neg	r22
   10152:	7f 4f       	sbci	r23, 0xFF	; 255

00010154 <__divmodhi4_exit>:
   10154:	08 95       	ret

00010156 <__udivmodsi4>:
   10156:	a1 e2       	ldi	r26, 0x21	; 33
   10158:	1a 2e       	mov	r1, r26
   1015a:	aa 1b       	sub	r26, r26
   1015c:	bb 1b       	sub	r27, r27
   1015e:	fd 01       	movw	r30, r26
   10160:	0d c0       	rjmp	.+26     	; 0x1017c <__udivmodsi4_ep>

00010162 <__udivmodsi4_loop>:
   10162:	aa 1f       	adc	r26, r26
   10164:	bb 1f       	adc	r27, r27
   10166:	ee 1f       	adc	r30, r30
   10168:	ff 1f       	adc	r31, r31
   1016a:	a2 17       	cp	r26, r18
   1016c:	b3 07       	cpc	r27, r19
   1016e:	e4 07       	cpc	r30, r20
   10170:	f5 07       	cpc	r31, r21
   10172:	20 f0       	brcs	.+8      	; 0x1017c <__udivmodsi4_ep>
   10174:	a2 1b       	sub	r26, r18
   10176:	b3 0b       	sbc	r27, r19
   10178:	e4 0b       	sbc	r30, r20
   1017a:	f5 0b       	sbc	r31, r21

0001017c <__udivmodsi4_ep>:
   1017c:	66 1f       	adc	r22, r22
   1017e:	77 1f       	adc	r23, r23
   10180:	88 1f       	adc	r24, r24
   10182:	99 1f       	adc	r25, r25
   10184:	1a 94       	dec	r1
   10186:	69 f7       	brne	.-38     	; 0x10162 <__udivmodsi4_loop>
   10188:	60 95       	com	r22
   1018a:	70 95       	com	r23
   1018c:	80 95       	com	r24
   1018e:	90 95       	com	r25
   10190:	9b 01       	movw	r18, r22
   10192:	ac 01       	movw	r20, r24
   10194:	bd 01       	movw	r22, r26
   10196:	cf 01       	movw	r24, r30
   10198:	08 95       	ret

0001019a <__divmodsi4>:
   1019a:	05 2e       	mov	r0, r21
   1019c:	97 fb       	bst	r25, 7
   1019e:	1e f4       	brtc	.+6      	; 0x101a6 <__divmodsi4+0xc>
   101a0:	00 94       	com	r0
   101a2:	0e 94 e4 80 	call	0x101c8	; 0x101c8 <__negsi2>
   101a6:	57 fd       	sbrc	r21, 7
   101a8:	07 d0       	rcall	.+14     	; 0x101b8 <__divmodsi4_neg2>
   101aa:	0e 94 ab 80 	call	0x10156	; 0x10156 <__udivmodsi4>
   101ae:	07 fc       	sbrc	r0, 7
   101b0:	03 d0       	rcall	.+6      	; 0x101b8 <__divmodsi4_neg2>
   101b2:	4e f4       	brtc	.+18     	; 0x101c6 <__divmodsi4_exit>
   101b4:	0c 94 e4 80 	jmp	0x101c8	; 0x101c8 <__negsi2>

000101b8 <__divmodsi4_neg2>:
   101b8:	50 95       	com	r21
   101ba:	40 95       	com	r20
   101bc:	30 95       	com	r19
   101be:	21 95       	neg	r18
   101c0:	3f 4f       	sbci	r19, 0xFF	; 255
   101c2:	4f 4f       	sbci	r20, 0xFF	; 255
   101c4:	5f 4f       	sbci	r21, 0xFF	; 255

000101c6 <__divmodsi4_exit>:
   101c6:	08 95       	ret

000101c8 <__negsi2>:
   101c8:	90 95       	com	r25
   101ca:	80 95       	com	r24
   101cc:	70 95       	com	r23
   101ce:	61 95       	neg	r22
   101d0:	7f 4f       	sbci	r23, 0xFF	; 255
   101d2:	8f 4f       	sbci	r24, 0xFF	; 255
   101d4:	9f 4f       	sbci	r25, 0xFF	; 255
   101d6:	08 95       	ret

000101d8 <__tablejump2__>:
   101d8:	ee 0f       	add	r30, r30
   101da:	ff 1f       	adc	r31, r31

000101dc <__tablejump__>:
   101dc:	05 90       	lpm	r0, Z+
   101de:	f4 91       	lpm	r31, Z
   101e0:	e0 2d       	mov	r30, r0
   101e2:	09 94       	ijmp

000101e4 <__muluhisi3>:
   101e4:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   101e8:	a5 9f       	mul	r26, r21
   101ea:	90 0d       	add	r25, r0
   101ec:	b4 9f       	mul	r27, r20
   101ee:	90 0d       	add	r25, r0
   101f0:	a4 9f       	mul	r26, r20
   101f2:	80 0d       	add	r24, r0
   101f4:	91 1d       	adc	r25, r1
   101f6:	11 24       	eor	r1, r1
   101f8:	08 95       	ret

000101fa <__mulshisi3>:
   101fa:	b7 ff       	sbrs	r27, 7
   101fc:	0c 94 f2 80 	jmp	0x101e4	; 0x101e4 <__muluhisi3>

00010200 <__mulohisi3>:
   10200:	0e 94 f2 80 	call	0x101e4	; 0x101e4 <__muluhisi3>
   10204:	82 1b       	sub	r24, r18
   10206:	93 0b       	sbc	r25, r19
   10208:	08 95       	ret

0001020a <__muldi3>:
   1020a:	df 93       	push	r29
   1020c:	cf 93       	push	r28
   1020e:	1f 93       	push	r17
   10210:	0f 93       	push	r16
   10212:	9a 9d       	mul	r25, r10
   10214:	f0 2d       	mov	r31, r0
   10216:	21 9f       	mul	r18, r17
   10218:	f0 0d       	add	r31, r0
   1021a:	8b 9d       	mul	r24, r11
   1021c:	f0 0d       	add	r31, r0
   1021e:	8a 9d       	mul	r24, r10
   10220:	e0 2d       	mov	r30, r0
   10222:	f1 0d       	add	r31, r1
   10224:	03 9f       	mul	r16, r19
   10226:	f0 0d       	add	r31, r0
   10228:	02 9f       	mul	r16, r18
   1022a:	e0 0d       	add	r30, r0
   1022c:	f1 1d       	adc	r31, r1
   1022e:	4e 9d       	mul	r20, r14
   10230:	e0 0d       	add	r30, r0
   10232:	f1 1d       	adc	r31, r1
   10234:	5e 9d       	mul	r21, r14
   10236:	f0 0d       	add	r31, r0
   10238:	4f 9d       	mul	r20, r15
   1023a:	f0 0d       	add	r31, r0
   1023c:	7f 93       	push	r23
   1023e:	6f 93       	push	r22
   10240:	bf 92       	push	r11
   10242:	af 92       	push	r10
   10244:	5f 93       	push	r21
   10246:	4f 93       	push	r20
   10248:	d5 01       	movw	r26, r10
   1024a:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   1024e:	8b 01       	movw	r16, r22
   10250:	ac 01       	movw	r20, r24
   10252:	d7 01       	movw	r26, r14
   10254:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   10258:	eb 01       	movw	r28, r22
   1025a:	e8 0f       	add	r30, r24
   1025c:	f9 1f       	adc	r31, r25
   1025e:	d6 01       	movw	r26, r12
   10260:	0e 94 55 81 	call	0x102aa	; 0x102aa <__muldi3_6>
   10264:	2f 91       	pop	r18
   10266:	3f 91       	pop	r19
   10268:	d6 01       	movw	r26, r12
   1026a:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   1026e:	c6 0f       	add	r28, r22
   10270:	d7 1f       	adc	r29, r23
   10272:	e8 1f       	adc	r30, r24
   10274:	f9 1f       	adc	r31, r25
   10276:	af 91       	pop	r26
   10278:	bf 91       	pop	r27
   1027a:	0e 94 55 81 	call	0x102aa	; 0x102aa <__muldi3_6>
   1027e:	2f 91       	pop	r18
   10280:	3f 91       	pop	r19
   10282:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   10286:	c6 0f       	add	r28, r22
   10288:	d7 1f       	adc	r29, r23
   1028a:	e8 1f       	adc	r30, r24
   1028c:	f9 1f       	adc	r31, r25
   1028e:	d6 01       	movw	r26, r12
   10290:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   10294:	e6 0f       	add	r30, r22
   10296:	f7 1f       	adc	r31, r23
   10298:	98 01       	movw	r18, r16
   1029a:	be 01       	movw	r22, r28
   1029c:	cf 01       	movw	r24, r30
   1029e:	11 24       	eor	r1, r1
   102a0:	0f 91       	pop	r16
   102a2:	1f 91       	pop	r17
   102a4:	cf 91       	pop	r28
   102a6:	df 91       	pop	r29
   102a8:	08 95       	ret

000102aa <__muldi3_6>:
   102aa:	0e 94 67 81 	call	0x102ce	; 0x102ce <__umulhisi3>
   102ae:	46 0f       	add	r20, r22
   102b0:	57 1f       	adc	r21, r23
   102b2:	c8 1f       	adc	r28, r24
   102b4:	d9 1f       	adc	r29, r25
   102b6:	08 f4       	brcc	.+2      	; 0x102ba <__muldi3_6+0x10>
   102b8:	31 96       	adiw	r30, 0x01	; 1
   102ba:	08 95       	ret

000102bc <__adddi3>:
   102bc:	2a 0d       	add	r18, r10
   102be:	3b 1d       	adc	r19, r11
   102c0:	4c 1d       	adc	r20, r12
   102c2:	5d 1d       	adc	r21, r13
   102c4:	6e 1d       	adc	r22, r14
   102c6:	7f 1d       	adc	r23, r15
   102c8:	80 1f       	adc	r24, r16
   102ca:	91 1f       	adc	r25, r17
   102cc:	08 95       	ret

000102ce <__umulhisi3>:
   102ce:	a2 9f       	mul	r26, r18
   102d0:	b0 01       	movw	r22, r0
   102d2:	b3 9f       	mul	r27, r19
   102d4:	c0 01       	movw	r24, r0
   102d6:	a3 9f       	mul	r26, r19
   102d8:	70 0d       	add	r23, r0
   102da:	81 1d       	adc	r24, r1
   102dc:	11 24       	eor	r1, r1
   102de:	91 1d       	adc	r25, r1
   102e0:	b2 9f       	mul	r27, r18
   102e2:	70 0d       	add	r23, r0
   102e4:	81 1d       	adc	r24, r1
   102e6:	11 24       	eor	r1, r1
   102e8:	91 1d       	adc	r25, r1
   102ea:	08 95       	ret

000102ec <_exit>:
   102ec:	f8 94       	cli

000102ee <__stop_program>:
   102ee:	ff cf       	rjmp	.-2      	; 0x102ee <__stop_program>
