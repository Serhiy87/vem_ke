
vem_03_05.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000da  00800100  00012366  0001241a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00012366  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000bd9  008001da  008001da  000124f4  2**0
                  ALLOC
  3 .eeprom       00000194  00810000  00810000  000124f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000040  00000000  00000000  00012688  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 0000377c  00000000  00000000  000126c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e9d8  00000000  00000000  00015e44  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000757  00000000  00000000  0002481c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00008c77  00000000  00000000  00024f73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012f0  00000000  00000000  0002dbec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003bb7  00000000  00000000  0002eedc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000076c1  00000000  00000000  00032a93  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006e0  00000000  00000000  0003a154  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fd 25 	jmp	0x4bfa	; 0x4bfa <__ctors_end>
       4:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
       8:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
       c:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      10:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      14:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      18:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      1c:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      20:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      24:	0c 94 83 35 	jmp	0x6b06	; 0x6b06 <__vector_9>
      28:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      2c:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      30:	0c 94 a0 52 	jmp	0xa540	; 0xa540 <__vector_12>
      34:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      38:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      3c:	0c 94 b3 35 	jmp	0x6b66	; 0x6b66 <__vector_15>
      40:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      44:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      48:	0c 94 5c 44 	jmp	0x88b8	; 0x88b8 <__vector_18>
      4c:	0c 94 d2 43 	jmp	0x87a4	; 0x87a4 <__vector_19>
      50:	0c 94 4a 39 	jmp	0x7294	; 0x7294 <__vector_20>
      54:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      58:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      5c:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      60:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      64:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      68:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      6c:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      70:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      74:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      78:	0c 94 45 41 	jmp	0x828a	; 0x828a <__vector_30>
      7c:	0c 94 24 45 	jmp	0x8a48	; 0x8a48 <__vector_31>
      80:	0c 94 88 41 	jmp	0x8310	; 0x8310 <__vector_32>
      84:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      88:	0c 94 1c 26 	jmp	0x4c38	; 0x4c38 <__bad_interrupt>
      8c:	0e 56       	subi	r16, 0x6E	; 110
      8e:	8a 56       	subi	r24, 0x6A	; 106
      90:	0b 56       	subi	r16, 0x6B	; 107
      92:	36 56       	subi	r19, 0x66	; 102
      94:	39 56       	subi	r19, 0x69	; 105
      96:	3c 56       	subi	r19, 0x6C	; 108
      98:	3f 56       	subi	r19, 0x6F	; 111
      9a:	42 56       	subi	r20, 0x62	; 98
      9c:	45 56       	subi	r20, 0x65	; 101
      9e:	48 56       	subi	r20, 0x68	; 104
      a0:	4b 56       	subi	r20, 0x6B	; 107
      a2:	4e 56       	subi	r20, 0x6E	; 110
      a4:	51 56       	subi	r21, 0x61	; 97
      a6:	54 56       	subi	r21, 0x64	; 100
      a8:	57 56       	subi	r21, 0x67	; 103
      aa:	5b 56       	subi	r21, 0x6B	; 107
      ac:	5e 56       	subi	r21, 0x6E	; 110
      ae:	61 56       	subi	r22, 0x61	; 97
      b0:	65 56       	subi	r22, 0x65	; 101
      b2:	68 56       	subi	r22, 0x68	; 104
      b4:	6c 56       	subi	r22, 0x6C	; 108
      b6:	6f 56       	subi	r22, 0x6F	; 111
      b8:	0c 68       	ori	r16, 0x8C	; 140
      ba:	0f 68       	ori	r16, 0x8F	; 143
      bc:	18 68       	ori	r17, 0x88	; 136
      be:	1b 68       	ori	r17, 0x8B	; 139
      c0:	26 68       	ori	r18, 0x86	; 134
      c2:	29 68       	ori	r18, 0x89	; 137
      c4:	32 68       	ori	r19, 0x82	; 130
      c6:	4a 68       	ori	r20, 0x8A	; 138
      c8:	4e 68       	ori	r20, 0x8E	; 142
      ca:	53 68       	ori	r21, 0x83	; 131
      cc:	57 68       	ori	r21, 0x87	; 135
      ce:	5c 68       	ori	r21, 0x8C	; 140
      d0:	60 68       	ori	r22, 0x80	; 128
      d2:	4a 68       	ori	r20, 0x8A	; 138
      d4:	5c 68       	ori	r21, 0x8C	; 140
      d6:	39 68       	ori	r19, 0x89	; 137
      d8:	65 68       	ori	r22, 0x85	; 133
      da:	6b 68       	ori	r22, 0x8B	; 139
      dc:	72 68       	ori	r23, 0x82	; 130
      de:	78 68       	ori	r23, 0x88	; 136
      e0:	7f 68       	ori	r23, 0x8F	; 143
      e2:	85 68       	ori	r24, 0x85	; 133
      e4:	65 68       	ori	r22, 0x85	; 133
      e6:	7f 68       	ori	r23, 0x8F	; 143
      e8:	43 68       	ori	r20, 0x83	; 131
      ea:	8c 68       	ori	r24, 0x8C	; 140
      ec:	92 68       	ori	r25, 0x82	; 130
      ee:	a0 68       	ori	r26, 0x80	; 128
      f0:	a6 68       	ori	r26, 0x86	; 134
      f2:	b4 68       	ori	r27, 0x84	; 132
      f4:	c1 68       	ori	r28, 0x81	; 129
      f6:	d2 68       	ori	r29, 0x82	; 130
      f8:	fa 68       	ori	r31, 0x8A	; 138
      fa:	26 69       	ori	r18, 0x96	; 150
      fc:	2b 69       	ori	r18, 0x9B	; 155
      fe:	98 6a       	ori	r25, 0xA8	; 168
     100:	c3 6a       	ori	r28, 0xA3	; 163
     102:	ed 6a       	ori	r30, 0xAD	; 173
     104:	26 6b       	ori	r18, 0xB6	; 182
     106:	98 6a       	ori	r25, 0xA8	; 168
     108:	c3 6a       	ori	r28, 0xA3	; 163
     10a:	5a 6e       	ori	r21, 0xEA	; 234
     10c:	54 6b       	ori	r21, 0xB4	; 180
     10e:	87 6b       	ori	r24, 0xB7	; 183
     110:	c3 6b       	ori	r28, 0xB3	; 179
     112:	09 6c       	ori	r16, 0xC9	; 201
     114:	54 6b       	ori	r21, 0xB4	; 180
     116:	87 6b       	ori	r24, 0xB7	; 183
     118:	43 6c       	ori	r20, 0xC3	; 195
     11a:	43 6c       	ori	r20, 0xC3	; 195
     11c:	5a 6e       	ori	r21, 0xEA	; 234
     11e:	4b 6c       	ori	r20, 0xCB	; 203
     120:	5e 6c       	ori	r21, 0xCE	; 206
     122:	71 6c       	ori	r23, 0xC1	; 193
     124:	b4 6c       	ori	r27, 0xC4	; 196
     126:	4b 6c       	ori	r20, 0xCB	; 203
     128:	5e 6c       	ori	r21, 0xCE	; 206
     12a:	5a 6e       	ori	r21, 0xEA	; 234
     12c:	5a 6e       	ori	r21, 0xEA	; 234
     12e:	5a 6e       	ori	r21, 0xEA	; 234
     130:	f3 6c       	ori	r31, 0xC3	; 195
     132:	1c 6d       	ori	r17, 0xDC	; 220
     134:	f3 6c       	ori	r31, 0xC3	; 195
     136:	1c 6d       	ori	r17, 0xDC	; 220
     138:	45 6d       	ori	r20, 0xD5	; 213
     13a:	67 6d       	ori	r22, 0xD7	; 215
     13c:	8a 6d       	ori	r24, 0xDA	; 218
     13e:	b6 6d       	ori	r27, 0xD6	; 214
     140:	e6 6d       	ori	r30, 0xD6	; 214
     142:	1e 6e       	ori	r17, 0xEE	; 238
     144:	00 76       	andi	r16, 0x60	; 96
     146:	1f 76       	andi	r17, 0x6F	; 111
     148:	2f 76       	andi	r18, 0x6F	; 111
     14a:	3c 76       	andi	r19, 0x6C	; 108
     14c:	f3 82       	std	Z+3, r15	; 0x03
     14e:	f3 82       	std	Z+3, r15	; 0x03
     150:	66 76       	andi	r22, 0x66	; 102
     152:	7d 76       	andi	r23, 0x6D	; 109
     154:	8d 76       	andi	r24, 0x6D	; 109
     156:	9a 76       	andi	r25, 0x6A	; 106
     158:	aa 76       	andi	r26, 0x6A	; 106
     15a:	b7 76       	andi	r27, 0x67	; 103
     15c:	c7 76       	andi	r28, 0x67	; 103
     15e:	d6 76       	andi	r29, 0x66	; 102
     160:	a2 77       	andi	r26, 0x72	; 114
     162:	b2 77       	andi	r27, 0x72	; 114
     164:	bf 77       	andi	r27, 0x7F	; 127
     166:	cf 77       	andi	r28, 0x7F	; 127
     168:	dc 77       	andi	r29, 0x7C	; 124
     16a:	ec 77       	andi	r30, 0x7C	; 124
     16c:	00 78       	andi	r16, 0x80	; 128
     16e:	1f 78       	andi	r17, 0x8F	; 143
     170:	33 78       	andi	r19, 0x83	; 131
     172:	49 78       	andi	r20, 0x89	; 137
     174:	52 78       	andi	r21, 0x82	; 130
     176:	64 78       	andi	r22, 0x84	; 132
     178:	7b 78       	andi	r23, 0x8B	; 139
     17a:	fd 78       	andi	r31, 0x8D	; 141
     17c:	0d 79       	andi	r16, 0x9D	; 157
     17e:	1a 79       	andi	r17, 0x9A	; 154
     180:	2a 79       	andi	r18, 0x9A	; 154
     182:	37 79       	andi	r19, 0x97	; 151
     184:	47 79       	andi	r20, 0x97	; 151
     186:	54 79       	andi	r21, 0x94	; 148
     188:	d6 79       	andi	r29, 0x96	; 150
     18a:	8f 7a       	andi	r24, 0xAF	; 175
     18c:	9f 7a       	andi	r25, 0xAF	; 175
     18e:	d2 7a       	andi	r29, 0xA2	; 162
     190:	38 7b       	andi	r19, 0xB8	; 184
     192:	46 7b       	andi	r20, 0xB6	; 182
     194:	52 7b       	andi	r21, 0xB2	; 178
     196:	c0 7b       	andi	r28, 0xB0	; 176
     198:	55 7c       	andi	r21, 0xC5	; 197
     19a:	4f 7d       	andi	r20, 0xDF	; 223
     19c:	62 7d       	andi	r22, 0xD2	; 210
     19e:	6e 7d       	andi	r22, 0xDE	; 222
     1a0:	b9 7d       	andi	r27, 0xD9	; 217
     1a2:	de 7d       	andi	r29, 0xDE	; 222
     1a4:	72 7e       	andi	r23, 0xE2	; 226
     1a6:	7f 7e       	andi	r23, 0xEF	; 239
     1a8:	92 7e       	andi	r25, 0xE2	; 226
     1aa:	ab 7e       	andi	r26, 0xEB	; 235
     1ac:	26 7f       	andi	r18, 0xF6	; 246
     1ae:	66 7f       	andi	r22, 0xF6	; 246
     1b0:	9c 7f       	andi	r25, 0xFC	; 252
     1b2:	d8 7f       	andi	r29, 0xF8	; 248
     1b4:	e9 7f       	andi	r30, 0xF9	; 249
     1b6:	f5 7f       	andi	r31, 0xF5	; 245
     1b8:	f3 82       	std	Z+3, r15	; 0x03
     1ba:	f3 82       	std	Z+3, r15	; 0x03
     1bc:	f3 82       	std	Z+3, r15	; 0x03
     1be:	f3 82       	std	Z+3, r15	; 0x03
     1c0:	f3 82       	std	Z+3, r15	; 0x03
     1c2:	f3 82       	std	Z+3, r15	; 0x03
     1c4:	f3 82       	std	Z+3, r15	; 0x03
     1c6:	f3 82       	std	Z+3, r15	; 0x03
     1c8:	f3 82       	std	Z+3, r15	; 0x03
     1ca:	f3 82       	std	Z+3, r15	; 0x03
     1cc:	f3 82       	std	Z+3, r15	; 0x03
     1ce:	f3 82       	std	Z+3, r15	; 0x03
     1d0:	f3 82       	std	Z+3, r15	; 0x03
     1d2:	c6 7d       	andi	r28, 0xD6	; 214
     1d4:	d2 7d       	andi	r29, 0xD2	; 210
     1d6:	f3 82       	std	Z+3, r15	; 0x03
     1d8:	f3 82       	std	Z+3, r15	; 0x03
     1da:	1a 80       	ldd	r1, Y+2	; 0x02
     1dc:	3d 80       	ldd	r3, Y+5	; 0x05
     1de:	47 80       	ldd	r4, Z+7	; 0x07
     1e0:	53 80       	ldd	r5, Z+3	; 0x03
     1e2:	61 80       	ldd	r6, Z+1	; 0x01
     1e4:	6d 80       	ldd	r6, Y+5	; 0x05
     1e6:	7d 80       	ldd	r7, Y+5	; 0x05
     1e8:	b0 80       	ld	r11, Z
     1ea:	4d 81       	ldd	r20, Y+5	; 0x05
     1ec:	9b 81       	ldd	r25, Y+3	; 0x03
     1ee:	ac 81       	ldd	r26, Y+4	; 0x04
     1f0:	e2 81       	ldd	r30, Z+2	; 0x02
     1f2:	fc 81       	ldd	r31, Y+4	; 0x04
     1f4:	49 82       	std	Y+1, r4	; 0x01
     1f6:	55 82       	std	Z+5, r5	; 0x05
     1f8:	6a 82       	std	Y+2, r6	; 0x02
     1fa:	76 82       	std	Z+6, r7	; 0x06

000001fc <Modbus_Map>:
     1fc:	62 03 08 00 79 03 08 00 f8 07 26 00 e2 09 1e 00     b...y.....&.....

0000020c <BR_Tbl>:
     20c:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
     21c:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00000227 <GSM_SIMCOM_SIM900R>:
     227:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00000236 <GSM_SIMCOM_SIM800>:
     236:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00000244 <URC_RDY>:
     244:	52 44 59 00                                         RDY.

00000248 <URC_CFUN>:
     248:	2b 43 46 55 4e 3a 20 31 00                          +CFUN: 1.

00000251 <URC_CPIN_READY>:
     251:	2b 43 50 49 4e 3a 20 52 45 41 44 59 00              +CPIN: READY.

0000025e <URC_CALL_READY>:
     25e:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

00000269 <URC_SMS_READY>:
     269:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00000273 <URC_REMOTE_IP>:
     273:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

0000027d <URC_CONNECT>:
     27d:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00000285 <URC_RECEIVE>:
     285:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

0000028f <URC_CLOSED>:
     28f:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

00000298 <URC_PDPDEACT>:
     298:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

000002a3 <URC_RING>:
     2a3:	52 49 4e 47 00                                      RING.

000002a8 <URC_NO_CARRIER>:
     2a8:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

000002b3 <RESP_OK>:
     2b3:	4f 4b 00                                            OK.

000002b6 <RESP_CONNECT_OK>:
     2b6:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

000002c4 <RESP_SERVER_OK>:
     2c4:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

000002ce <RESP_SERVER_CLOSE>:
     2ce:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

000002db <RESP_Invitation>:
     2db:	3e 00                                               >.

000002dd <RESP_SEND_OK>:
     2dd:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

000002e8 <RESP_CLOSE_OK>:
     2e8:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

000002f1 <RESP_CLOSE_OK_FAST>:
     2f1:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

000002fd <RESP_CSQ>:
     2fd:	2b 43 53 51 3a 00                                   +CSQ:.

00000303 <RESP_SHUT_OK>:
     303:	53 48 55 54 20 4f 4b 00                             SHUT OK.

0000030b <RESP_CONNECT_9600>:
     30b:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00000318 <ESC_SEQ>:
     318:	2b 2b 2b 00                                         +++.

0000031c <AT_AT>:
     31c:	41 54 00                                            AT.

0000031f <AT_IPR9600>:
     31f:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

0000032b <AT_E0>:
     32b:	41 54 45 30 00                                      ATE0.

00000330 <AT_CGMM>:
     330:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00000338 <AT_CLIP>:
     338:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00000342 <AT_CCID>:
     342:	41 54 2b 43 43 49 44 00                             AT+CCID.

0000034a <AT_IFC>:
     34a:	41 54 2b 49 46 43 3d 32 2c 32 00                    AT+IFC=2,2.

00000355 <AT_CMGF>:
     355:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

0000035f <AT_CSMP>:
     35f:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
     36f:	2c 30 00                                            ,0.

00000372 <AT_CMGS>:
     372:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

0000037d <AT_CIPMODE_0>:
     37d:	41 54 2b 43 49 50 4d 4f 44 45 3d 30 00              AT+CIPMODE=0.

0000038a <AT_CIPMODE_1>:
     38a:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00000397 <AT_CIPMUX_0>:
     397:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

000003a3 <AT_CIPMUX_1>:
     3a3:	41 54 2b 43 49 50 4d 55 58 3d 31 00                 AT+CIPMUX=1.

000003af <AT_CGATT>:
     3af:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

000003ba <AT_CIPCSGP>:
     3ba:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

000003c9 <AT_CSTT>:
     3c9:	41 54 2b 43 53 54 54 00                             AT+CSTT.

000003d1 <AT_CIICR>:
     3d1:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

000003da <AT_CIFSR>:
     3da:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

000003e3 <AT_CIPSTART>:
     3e3:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
     3f3:	44 50 22 2c 00                                      DP",.

000003f8 <AT_CIPSERVER>:
     3f8:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00000408 <AT_SERVERCLOSE>:
     408:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00000417 <AT_CIPSEND>:
     417:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00000423 <AT_CIPCLOSE_1>:
     423:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00000433 <AT_CIPCLOSE>:
     433:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00000441 <AT_CIPSHUT>:
     441:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

0000044c <AT_CSQ>:
     44c:	41 54 2b 43 53 51 00                                AT+CSQ.

00000453 <AT_ATA>:
     453:	41 54 41 00                                         ATA.

00000457 <AT_ATH>:
     457:	41 54 48 00                                         ATH.

0000045b <ThermFami>:
     45b:	02                                                  .

0000045c <TermisLim>:
     45c:	00 00 00 00 0c fe 08 07 0c fe 08 07 0c fe 70 17     ..............p.
     46c:	0c fe 70 17 0c fe 70 17 0c fe 70 17 0c fe 08 07     ..p...p...p.....

0000047c <TermocLim>:
     47c:	00 00 00 00 30 f8 e0 2e 70 17 50 46 30 f8 4c 1d     ....0...p.PF0.L.
     48c:	30 f8 70 17                                         0.p.

00000490 <TerDS18B20Lim>:
     490:	00 00 00 00 da fd e2 04                             ........

00000498 <MB_Master_List>:
     498:	00 00 00                                            ...

0000049b <TestMsg_str>:
     49b:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
     4ab:	e8 e5 00                                            ...

000004ae <Symbols_P>:
     4ae:	30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66     0123456789abcdef
     4be:	67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76     ghijklmnopqrstuv
     4ce:	77 78 79 7a 41 42 43 44 45 46 47 48 49 4a 4b 4c     wxyzABCDEFGHIJKL
     4de:	4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a e0 e1     MNOPQRSTUVWXYZ..
     4ee:	e2 e3 e4 e5 b8 ba e6 e7 e8 b3 bf e9 ea eb ec ed     ................
     4fe:	ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd     ................
     50e:	fe ff c0 c1 c2 c3 c4 c5 a8 aa c6 c7 c8 b2 af c9     ................
     51e:	ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9     ................
     52e:	da db dc dd de df 20 2b 2d 3d 3c 3e 24 25 26 2e     ...... +-=<>$%&.
     53e:	2c 3f 21 27 40 3a 28 29 22 7c 2a 23 2f 00           ,?!'@:()"|*#/.

0000054c <OnlyDigits_P>:
     54c:	30 31 32 33 34 35 36 37 38 39 00                    0123456789.

00000557 <Digits_P>:
     557:	30 31 32 33 34 35 36 37 38 39 65 2b 2d 2e 00        0123456789e+-..

00000566 <Msg_FlashFail>:
     566:	0c                                                  .

00000567 <Msg_EEPROMFail>:
     567:	0d                                                  .

00000568 <Msg_FlashEEPROMFail>:
     568:	0e                                                  .

00000569 <MsgErr41>:
     569:	29                                                  )

0000056a <Web_Logins>:
     56a:	75 73 65 72 00 00 00 00 00 00 00 00 00 00 00 00     user............
     57a:	73 75 70 65 72 75 73 65 72 00 00 00 00 00 00 00     superuser.......
     58a:	73 65 72 76 69 63 65 00 00 00 00 00 00 00 00 00     service.........
     59a:	61 64 6d 69 6e 00 00 00 00 00 00 00 00 00 00 00     admin...........

000005aa <HTTP_200_OK>:
     5aa:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     5ba:	0a 00                                               ..

000005bc <Content_Type>:
     5bc:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

000005cb <Content_Length>:
     5cb:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
     5db:	3a 20 00                                            : .

000005de <html_cp1251_str>:
     5de:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
     5ee:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
     5fe:	0a 00                                               ..

00000600 <image_str>:
     600:	69 6d 61 67 65 2f 00                                image/.

00000607 <html_str>:
     607:	68 74 6d 6c 00                                      html.

0000060c <ico_str>:
     60c:	69 63 6f 00                                         ico.

00000610 <gif_str>:
     610:	67 69 66 00                                         gif.

00000614 <jpeg_str>:
     614:	6a 70 65 67 00                                      jpeg.

00000619 <Connection_Close>:
     619:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
     629:	65 0d 0a 0d 0a 00                                   e.....

0000062f <inputSESSID_Str>:
     62f:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
     63f:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
     64f:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

0000065a <SESSID_pstr>:
     65a:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00000663 <error_page>:
     663:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
     673:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
     683:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
     693:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
     6a3:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
     6b3:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
     6c3:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
     6d3:	2f 68 31 3e 00                                      /h1>.

000006d8 <Web_error_page>:
	...
     6e0:	75 00 63 06                                         u.c.

000006e4 <METHOD_GET>:
     6e4:	47 45 54 20 2f 00                                   GET /.

000006ea <METHOD_POST>:
     6ea:	50 4f 53 54 20 2f 00                                POST /.

000006f1 <EM_RESP_0_9_2>:
     6f1:	30 2e 39 2e 32 00                                   0.9.2.

000006f7 <EM_RESP_0_9_1>:
     6f7:	30 2e 39 2e 31 00                                   0.9.1.

000006fd <EM_RESP_1_8_0>:
     6fd:	31 2e 38 2e 30 00                                   1.8.0.

00000703 <EM_RESP_2_8_0>:
     703:	32 2e 38 2e 30 00                                   2.8.0.

00000709 <EM_RESP_3_8_0>:
     709:	33 2e 38 2e 30 00                                   3.8.0.

0000070f <EM_RESP_4_8_0>:
     70f:	34 2e 38 2e 30 00                                   4.8.0.

00000715 <EM_RESP_32_7_0>:
     715:	33 32 2e 37 2e 30 00                                32.7.0.

0000071c <EM_RESP_52_7_0>:
     71c:	35 32 2e 37 2e 30 00                                52.7.0.

00000723 <EM_RESP_72_7_0>:
     723:	37 32 2e 37 2e 30 00                                72.7.0.

0000072a <EM_RESP_31_7_0>:
     72a:	33 31 2e 37 2e 30 00                                31.7.0.

00000731 <EM_RESP_51_7_0>:
     731:	35 31 2e 37 2e 30 00                                51.7.0.

00000738 <EM_RESP_71_7_0>:
     738:	37 31 2e 37 2e 30 00                                71.7.0.

0000073f <EM_RESP_16_7_0>:
     73f:	31 36 2e 37 2e 30 00                                16.7.0.

00000746 <EM_RESP_C_60_0>:
     746:	43 2e 36 30 2e 30 00                                C.60.0.

0000074d <EM_RESP_C_60_2>:
     74d:	43 2e 36 30 2e 32 00                                C.60.2.

00000754 <EM_RESP_C_61_0>:
     754:	43 2e 36 31 2e 30 00                                C.61.0.

0000075b <EM_RESP_C_61_2>:
     75b:	43 2e 36 31 2e 32 00                                C.61.2.

00000762 <EM_RESP_C_62_0>:
     762:	43 2e 36 32 2e 30 00                                C.62.0.

00000769 <EM_RESP_C_62_2>:
     769:	43 2e 36 32 2e 32 00                                C.62.2.

00000770 <EM_RESP_0_0_0>:
     770:	30 2e 30 2e 30 00                                   0.0.0.

00000776 <EM_RESP_F_F_0>:
     776:	46 2e 46 2e 30 00                                   F.F.0.

0000077c <EM_REQ>:
     77c:	2f 3f 21 00                                         /?!.

00000780 <EM_READ_DATA_REQ>:
     780:	06 30 35 30 00                                      .050.

00000785 <EM_OPEN_CH_REQ>:
     785:	00 01 01 01 01 01 01 01 01 77 81                    .........w.

00000790 <EM_ENERGY_REQ>:
     790:	00 05 00 00 10 25                                   .....%

00000796 <EM_VOLTAGE_REQ>:
     796:	00 08 16 11 4f 8a                                   ....O.

0000079c <EM_CURRENT_REQ>:
     79c:	00 08 16 21 4f 9e                                   ...!O.

000007a2 <EM_ACTIVEPOWER_REQ>:
     7a2:	00 08 16 00 8f 86                                   ......

000007a8 <EM_RESP_AT>:
     7a8:	41 54 0d 00                                         AT..

000007ac <EM_RESP_ATZ>:
     7ac:	41 54 5a 0d 00                                      ATZ..

000007b1 <EM_RESP_ATE0>:
     7b1:	41 54 45 30 0d 00                                   ATE0..

000007b7 <EM_RESP_ATH>:
     7b7:	2b 2b 2b 41 54 48 0d 00                             +++ATH..

000007bf <EM_RESP_ATA>:
     7bf:	41 54 41 0d 00                                      ATA..

000007c4 <EM_RESP_OK>:
     7c4:	0d 0a 4f 4b 0d 0a 00                                ..OK...

000007cb <EM_RESP_RING>:
     7cb:	0d 0a 52 49 4e 47 0d 0a 00                          ..RING...

000007d4 <EM_RESP_CONNECT>:
     7d4:	0d 0a 43 4f 4e 4e 45 43 54 0d 0a 00                 ..CONNECT...

000007e0 <EM_RESP_NOCARRIER>:
     7e0:	0d 0a 4e 4f 20 43 41 52 52 49 45 52 0d 0a 00        ..NO CARRIER...

000007ef <EM_END_REQ>:
     7ef:	42 30 03 75                                         B0.u

000007f3 <name_login>:
     7f3:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

000007fe <Login_Welcome_Str>:
     7fe:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
     80e:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
     81e:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
     82e:	20 00                                                .

00000830 <Login_Busy_Str>:
     830:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
     840:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
     850:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
     860:	2e 00                                               ..

00000862 <Login_Login_Str>:
     862:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
     872:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
     882:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     892:	20 00                                                .

00000894 <Login_PSW_Str>:
     894:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
     8a4:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
     8b4:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     8c4:	20 00                                                .

000008c6 <Web_LoginMsg_List>:
     8c6:	fe 07 30 08 62 08 94 08                             ..0.b...

000008ce <login_InField>:
     8ce:	22 62 01 00 00 15 1d 87 05 c6 08 00 07 8f 0a 00     "b..............
     8de:	00 00 14 8f 05 00 00 00                             ........

000008e6 <login_page>:
     8e6:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     8f6:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     906:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     916:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     926:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     936:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     946:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     956:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     966:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
     976:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
     986:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
     996:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
     9a6:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
     9b6:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
     9c6:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
     9d6:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
     9e6:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
     9f6:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
     a06:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
     a16:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
     a26:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
     a36:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
     a46:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
     a56:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
     a66:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
     a76:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
     a86:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
     a96:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
     aa6:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
     ab6:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
     ac6:	0d 0a 00                                            ...

00000ac9 <vars_Login>:
     ac9:	6c 6f 67 69 6e 00                                   login.

00000acf <Web_LoginOF>:
     acf:	21 62 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !b..............

00000adf <vars_Passw>:
     adf:	70 61 73 73 77 6f 72 64 00                          password.

00000ae8 <Web_PasswOF>:
     ae8:	21 72 05 00 00 00 00 02 00 00 00 48 3f 00 00 0b     !r.........H?...

00000af8 <vars_loginOField>:
     af8:	c9 0a cf 0a df 0a e8 0a                             ........

00000b00 <Web_login>:
     b00:	f3 07 ce 08 08 00 f8 0a e3 01 e6 08                 ............

00000b0c <name_index>:
     b0c:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

00000b17 <Space_Str>:
     b17:	20 20 20 20 20 20 20 20 00                                  .

00000b20 <Selected_Str>:
     b20:	73 65 6c 65 63 74 65 64 00                          selected.

00000b29 <OFF_List>:
     b29:	20 0b 17 0b                                          ...

00000b2d <ON_List>:
     b2d:	17 0b 20 0b                                         .. .

00000b31 <EM_NONE_List>:
     b31:	20 0b 17 0b 17 0b 17 0b 17 0b                        .........

00000b3b <LANDIS_GYR_ZMR110_List>:
     b3b:	17 0b 20 0b 17 0b 17 0b 17 0b                       .. .......

00000b45 <ELVIN_List>:
     b45:	17 0b 17 0b 20 0b 17 0b 17 0b                       .... .....

00000b4f <MERCURY_230_List>:
     b4f:	17 0b 17 0b 17 0b 20 0b 17 0b                       ...... ...

00000b59 <ELVIN_MODEM_List>:
     b59:	17 0b 17 0b 17 0b 17 0b 20 0b                       ........ .

00000b63 <BR1200_List>:
     b63:	20 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b      ...............
     b73:	17 0b                                               ..

00000b75 <BR2400_List>:
     b75:	17 0b 20 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b     .. .............
     b85:	17 0b                                               ..

00000b87 <BR4800_List>:
     b87:	17 0b 17 0b 20 0b 17 0b 17 0b 17 0b 17 0b 17 0b     .... ...........
     b97:	17 0b                                               ..

00000b99 <BR9600_List>:
     b99:	17 0b 17 0b 17 0b 20 0b 17 0b 17 0b 17 0b 17 0b     ...... .........
     ba9:	17 0b                                               ..

00000bab <BR14400_List>:
     bab:	17 0b 17 0b 17 0b 17 0b 20 0b 17 0b 17 0b 17 0b     ........ .......
     bbb:	17 0b                                               ..

00000bbd <BR19200_List>:
     bbd:	17 0b 17 0b 17 0b 17 0b 17 0b 20 0b 17 0b 17 0b     .......... .....
     bcd:	17 0b                                               ..

00000bcf <BR28800_List>:
     bcf:	17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 20 0b 17 0b     ............ ...
     bdf:	17 0b                                               ..

00000be1 <BR34800_List>:
     be1:	17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 20 0b     .............. .
     bf1:	17 0b                                               ..

00000bf3 <BR57600_List>:
     bf3:	17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b 17 0b     ................
     c03:	20 0b                                                .

00000c05 <BIT5_List>:
     c05:	20 0b 17 0b 17 0b 17 0b                              .......

00000c0d <BIT6_List>:
     c0d:	17 0b 20 0b 17 0b 17 0b                             .. .....

00000c15 <BIT7_List>:
     c15:	17 0b 17 0b 20 0b 17 0b                             .... ...

00000c1d <BIT8_List>:
     c1d:	17 0b 17 0b 17 0b 20 0b                             ...... .

00000c25 <PAR_N_List>:
     c25:	20 0b 17 0b 17 0b                                    .....

00000c2b <PAR_E_List>:
     c2b:	17 0b 20 0b 17 0b                                   .. ...

00000c31 <PAR_O_List>:
     c31:	17 0b 17 0b 20 0b                                   .... .

00000c37 <STB_1_List>:
     c37:	20 0b 17 0b                                          ...

00000c3b <STB_2_List>:
     c3b:	17 0b 20 0b                                         .. .

00000c3f <index_IField>:
     c3f:	22 62 01 00 00 15 22 62 01 00 00 15 07 8f 0a 00     "b...."b........
     c4f:	00 00 14 8f 05 00 00 00 10 db 01 00 00 03 10 df     ................
     c5f:	01 00 00 03 10 e3 01 00 00 03 10 e7 01 00 00 03     ................
     c6f:	1e 5c 01 31 0b 00 1e 5c 01 3b 0b 00 1e 5c 01 45     .\.1...\.;...\.E
     c7f:	0b 00 1e 5c 01 4f 0b 00 1e 5c 01 59 0b 00 1d d6     ...\.O...\.Y....
     c8f:	09 63 0b 00 1d d6 09 75 0b 00 1d d6 09 87 0b 00     .c.....u........
     c9f:	1d d6 09 99 0b 00 1d d6 09 ab 0b 00 1d d6 09 bd     ................
     caf:	0b 00 1d d6 09 cf 0b 00 1d d6 09 e1 0b 00 1d d6     ................
     cbf:	09 f3 0b 00 1d dc 09 05 0c 00 1d dc 09 0d 0c 00     ................
     ccf:	1d dc 09 15 0c 00 1d dc 09 1d 0c 00 1d 89 05 25     ...............%
     cdf:	0c 00 1d 89 05 2b 0c 00 1d 89 05 31 0c 00 1d b3     .....+.....1....
     cef:	08 37 0c 00 1d b3 08 3b 0c 00 1e 7b 01 29 0b 00     .7.....;...{.)..
     cff:	1e 7b 01 2d 0b 00 08 7c 01 00 00 00                 .{.-...|....

00000d0b <index_page>:
     d0b:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     d1b:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     d2b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     d3b:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     d4b:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     d5b:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     d6b:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     d7b:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     d8b:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     d9b:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     dab:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     dbb:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     dcb:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     ddb:	09 53 57 3a 20 33 2e 30 35 3c 2f 42 52 3e 0d 0a     .SW: 3.05</BR>..
     deb:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     dfb:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     e0b:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     e1b:	65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d 6c     ef="network.html
     e2b:	22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0 ee     ">....... ......
     e3b:	e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     e4b:	72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e 47     ref="gsm.html">G
     e5b:	53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d 0a     SM/GPRS</a> | ..
     e6b:	3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74 6d     <a href="csd.htm
     e7b:	6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a 3c     l">CSD</a> | ..<
     e8b:	61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e 68     a href="system.h
     e9b:	74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61 3e     tml">.......</a>
     eab:	20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c 6f      | ..<a href="lo
     ebb:	67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee e4     gout.html">.....
     ecb:	3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33 3e     </a>..<HR>..<h3>
     edb:	d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0 ee     ........ .......
     eeb:	fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a 41     .......:</h3>..A
     efb:	2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2     + {{{{{{{{{{{ ..
     f0b:	f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | A- {{{{{{{
     f1b:	7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b 20     {{{{ ...*. | R+ 
     f2b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0 f0     {{{{{{{{{{{ ....
     f3b:	2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b 7b     *. | R- {{{{{{{{
     f4b:	7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42 52     {{{ ....*...</BR
     f5b:	3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea f2     >..<h3>... .....
     f6b:	f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e     ..........:</h3>
     f7b:	0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27     ..<form action='
     f8b:	2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e     /' method='GET'>
     f9b:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
     fab:	22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d 0a     "EMeterType"> ..
     fbb:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30 20     <OPTION VALUE=0 
     fcb:	7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a 3c     {{{{{{{{>... ..<
     fdb:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b     OPTION VALUE=1 {
     feb:	7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26 47     {{{{{{{>Landis&G
     ffb:	79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     yr..<OPTION VALU
    100b:	45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb c2     E=2 {{{{{{{{>...
    101b:	c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     ....<OPTION VALU
    102b:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5 f0     E=3 {{{{{{{{>...
    103b:	ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49 4f     .....230..<OPTIO
    104b:	4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b     N VALUE=4 {{{{{{
    105b:	7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d 0a     {{>..... .......
    106b:	09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69     .</SELECT> ...<i
    107b:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    108b:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
    109b:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
    10ab:	0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb 20     ..<h3>......... 
    10bb:	52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68 33     RS232/RS485:</h3
    10cb:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    10db:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10eb:	3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a 0d     >.............:.
    10fb:	0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22     ..<SELECT NAME="
    110b:	52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Rate"> ...<OPTIO
    111b:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    112b:	7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f 50     {{>1200bps...<OP
    113b:	54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b     TION VALUE=1 {{{
    114b:	7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a 09     {{{{{>2400bps...
    115b:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20     <OPTION VALUE=2 
    116b:	7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70 73     {{{{{{{{>4800bps
    117b:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    118b:	3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30 30     =3 {{{{{{{{>9600
    119b:	62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41     bps...<OPTION VA
    11ab:	4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 31     LUE=4 {{{{{{{{>1
    11bb:	34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f     4400bps...<OPTIO
    11cb:	4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b 7b     N VALUE=5 {{{{{{
    11db:	7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c 4f     {{>19200bps...<O
    11eb:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b 7b     PTION VALUE=6 {{
    11fb:	7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73 0d     {{{{{{>28800bps.
    120b:	0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d     ..<OPTION VALUE=
    121b:	37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30 30     7 {{{{{{{{>38400
    122b:	62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41     bps...<OPTION VA
    123b:	4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35     LUE=8 {{{{{{{{>5
    124b:	37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c 45     7600bps...</SELE
    125b:	43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1 f2     CT>.............
    126b:	e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45 43     .. ...:...<SELEC
    127b:	54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e 20     T NAME="BitQt"> 
    128b:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    129b:	3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a 09     =0 {{{{{{{{>5...
    12ab:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    12bb:	7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f 50     {{{{{{{{>6...<OP
    12cb:	54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b 7b     TION VALUE=2 {{{
    12db:	7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49 4f     {{{{{>7...<OPTIO
    12eb:	4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b 7b     N VALUE=3 {{{{{{
    12fb:	7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e     {{>8...</SELECT>
    130b:	20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a 0d      .............:.
    131b:	0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22     ..<SELECT NAME="
    132b:	50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50 54     Parity"> ...<OPT
    133b:	49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b     ION VALUE=0 {{{{
    134b:	7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54 49     {{{{>......<OPTI
    135b:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    136b:	7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f 50     {{{>.........<OP
    137b:	54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b 7b     TION VALUE=2 {{{
    138b:	7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d 0a     {{{{{>..........
    139b:	09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a 09     .</SELECT> .....
    13ab:	d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53 45     ....-....:...<SE
    13bb:	4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70 42     LECT NAME="StopB
    13cb:	69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f 4e     its"> ...<OPTION
    13db:	20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b 7b      VALUE=0 {{{{{{{
    13eb:	7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41     {>1...<OPTION VA
    13fb:	4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 32     LUE=1 {{{{{{{{>2
    140b:	0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d     ...</SELECT> ...
    141b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    142b:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    143b:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    144b:	52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1 f7     R>..<h3>..... ..
    145b:	b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42 52     ......:</h3></BR
    146b:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    147b:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    148b:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    149b:	3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a 09     ="AutoSend"> ...
    14ab:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30 20     <OPTION VALUE=0 
    14bb:	7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a 09     {{{{{{{{>... ...
    14cb:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    14db:	7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f     {{{{{{{{>.....</
    14eb:	53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70 75     SELECT> ...<inpu
    14fb:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    150b:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    151b:	6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     orm>..<form acti
    152b:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    153b:	45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d 0a     ET'>.. ......:..
    154b:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    155b:	78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44 61     xt' name='CurrDa
    156b:	74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d 27     taPeriod' size='
    157b:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    158b:	3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75 74     >.........<input
    159b:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    15ab:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    15bb:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42 4f     rm>..</BR>..</BO
    15cb:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

000015da <var_EMeterType>:
    15da:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

000015e5 <Web_EMeterType>:
    15e5:	01 5c 01 00 00 00 00 04 00 00 00 c1 67 00 00 00     .\..........g...

000015f5 <var_EM_UART_Rate>:
    15f5:	52 61 74 65 00                                      Rate.

000015fa <Web_EM_UART_Rate>:
    15fa:	00 d6 09 00 00 00 00 08 00 00 00 00 00 00 00 00     ................

0000160a <var_EM_UART_BitQt>:
    160a:	42 69 74 51 74 00                                   BitQt.

00001610 <Web_EM_UART_BitQt>:
    1610:	00 dc 09 00 00 00 00 03 00 00 00 00 00 00 00 00     ................

00001620 <var_EM_UART_Parity>:
    1620:	50 61 72 69 74 79 00                                Parity.

00001627 <Web_EM_UART_Parity>:
    1627:	00 89 05 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00001637 <var_EM_UART_StopBits>:
    1637:	53 74 6f 70 42 69 74 73 00                          StopBits.

00001640 <Web_EM_UART_StopBits>:
    1640:	00 b3 08 00 00 00 00 01 00 00 00 1c 59 00 00 00     ............Y...

00001650 <var_AutoSend>:
    1650:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

00001659 <Web_AutoSend>:
    1659:	01 7b 01 00 00 00 00 01 00 00 00 00 00 00 00 00     .{..............

00001669 <var_CurrDataPeriod>:
    1669:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

00001678 <Web_CurrDataPeriod>:
    1678:	08 7c 01 3c 00 00 00 ff ff 00 00 00 00 00 00 00     .|.<............

00001688 <index_OField>:
    1688:	da 15 e5 15 f5 15 fa 15 0a 16 10 16 20 16 27 16     ............ .'.
    1698:	37 16 40 16 69 16 78 16 50 16 59 16                 7.@.i.x.P.Y.

000016a4 <Web_index>:
    16a4:	0c 0b 3f 0c 1c 00 88 16 cf 08 0b 0d                 ..?.........

000016b0 <name_favicon>:
    16b0:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

000016bc <favicon>:
    16bc:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    16cc:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    16dc:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    16ec:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    16fc:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    170c:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    171c:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    172c:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    173c:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    174c:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    175c:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    176c:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    177c:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    178c:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1af8:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    1b08:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    1b18:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    1b28:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    1b38:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    1b48:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    1b58:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    1b68:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    1b78:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    1b88:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    1b98:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    1ba8:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    1bb8:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    1bc8:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    1bd8:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    1be8:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    1bf8:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00001c3a <Web_favicon>:
    1c3a:	b0 16 00 00 00 00 00 00 7e 05 bc 16                 ........~...

00001c46 <name_network>:
    1c46:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

00001c53 <network_IField>:
    1c53:	22 62 01 00 00 15 22 62 01 00 00 15 07 8f 0a 00     "b...."b........
    1c63:	00 00 14 8f 05 00 00 00 08 64 00 00 00 00 08 76     .........d.....v
    1c73:	00 00 00 02 11 2c 01 00 00 02 01 66 00 00 00 00     .....,.....f....
    1c83:	01 67 00 00 00 00 01 68 00 00 00 00 01 69 00 00     .g.....h.....i..
    1c93:	00 00 01 6a 00 00 00 00 01 6b 00 00 00 00 01 6c     ...j.....k.....l
    1ca3:	00 00 00 00 01 6d 00 00 00 00 01 6e 00 00 00 00     .....m.....n....
    1cb3:	01 6f 00 00 00 00 01 70 00 00 00 00 01 71 00 00     .o.....p.....q..
    1cc3:	00 00 01 72 00 00 00 00 01 73 00 00 00 00 01 74     ...r.....s.....t
    1cd3:	00 00 00 00 01 75 00 00 00 00 01 4c 00 00 00 00     .....u.....L....
    1ce3:	01 4d 00 00 00 00 01 4e 00 00 00 00 01 4f 00 00     .M.....N.....O..
    1cf3:	00 00 08 5c 00 00 00 00 01 50 00 00 00 00 01 51     ...\.....P.....Q
    1d03:	00 00 00 00 01 52 00 00 00 00 01 53 00 00 00 00     .....R.....S....
    1d13:	08 5e 00 00 00 00 01 54 00 00 00 00 01 55 00 00     .^.....T.....U..
    1d23:	00 00 01 56 00 00 00 00 01 57 00 00 00 00 08 60     ...V.....W.....`
    1d33:	00 00 00 00 01 58 00 00 00 00 01 59 00 00 00 00     .....X.....Y....
    1d43:	01 5a 00 00 00 00 01 5b 00 00 00 00 08 62 00 00     .Z.....[.....b..
	...

00001d55 <network_page>:
    1d55:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    1d65:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    1d75:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    1d85:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    1d95:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    1da5:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    1db5:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    1dc5:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    1dd5:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    1de5:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    1df5:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    1e05:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    1e15:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    1e25:	09 53 57 3a 20 33 2e 30 35 3c 2f 42 52 3e 0d 0a     .SW: 3.05</BR>..
    1e35:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    1e45:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    1e55:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    1e65:	65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d 6c     ef="network.html
    1e75:	22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0 ee     ">....... ......
    1e85:	e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    1e95:	72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e 47     ref="gsm.html">G
    1ea5:	53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d 0a     SM/GPRS</a> | ..
    1eb5:	3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74 6d     <a href="csd.htm
    1ec5:	6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a 3c     l">CSD</a> | ..<
    1ed5:	61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e 68     a href="system.h
    1ee5:	74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61 3e     tml">.......</a>
    1ef5:	20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c 6f      | ..<a href="lo
    1f05:	67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee e4     gout.html">.....
    1f15:	3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c 68     </a>..<HR>....<h
    1f25:	33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72 3c     3>TCP/IP Server<
    1f35:	2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /h3>..<form acti
    1f45:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    1f55:	45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70 6f     ET'>...Listen po
    1f65:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    1f75:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54     e='text' name='T
    1f85:	43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20 73     CP_ListenPort' s
    1f95:	69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27 7b     ize='5' value='{
    1fa5:	7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     {{{{'>...<input 
    1fb5:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61     type='submit' va
    1fc5:	6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72     lue='OK'>..</for
    1fd5:	6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d     m>..</BR>..<form
    1fe5:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1ff5:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50 2f     od='GET'>...TCP/
    2005:	49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74 69     IP connection ti
    2015:	6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74 20     meout:...<input 
    2025:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2035:	3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69     ='TCP_CONNECT_ti
    2045:	6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27 20     meout' size='7' 
    2055:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e 73     value='{{{{{{'>s
    2065:	65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     ec...<input type
    2075:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    2085:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    2095:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    20a5:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    20b5:	47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e 20     GET'>...Session 
    20c5:	74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75     timeout:...<inpu
    20d5:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    20e5:	6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69 6f     me='WebMaxSessio
    20f5:	6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27 20     nTime' size='7' 
    2105:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    2115:	7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74 20     {'>sec...<input 
    2125:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61     type='submit' va
    2135:	6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72     lue='OK'>..</for
    2145:	6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68 33     m>..</BR>....<h3
    2155:	3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68 33     >IP Firewall</h3
    2165:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    2175:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    2185:	3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70 75     >...IP1:...<inpu
    2195:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    21a5:	6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73 69     me='Cli0_IP1' si
    21b5:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    21c5:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    21d5:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    21e5:	43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d 27     Cli0_IP2' size='
    21f5:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    2205:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    2215:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 30     text' name='Cli0
    2225:	5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP3' size='3' v
    2235:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2245:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2255:	27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50 34     ' name='Cli0_IP4
    2265:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2275:	3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     ='{{{'>...<input
    2285:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2295:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    22a5:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    22b5:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    22c5:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50 32     hod='GET'>...IP2
    22d5:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    22e5:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    22f5:	31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27 20     1_IP1' size='3' 
    2305:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2315:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2325:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50     t' name='Cli1_IP
    2335:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    2345:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    2355:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2365:	61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20 73     ame='Cli1_IP3' s
    2375:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    2385:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2395:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    23a5:	27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65 3d     'Cli1_IP4' size=
    23b5:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    23c5:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    23d5:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    23e5:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    23f5:	42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f     BR>..<form actio
    2405:	6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45     n='/' method='GE
    2415:	54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69 6e     T'>...IP3:...<in
    2425:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2435:	6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27 20     name='Cli2_IP1' 
    2445:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2455:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2465:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2475:	3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a 65     ='Cli2_IP2' size
    2485:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2495:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    24a5:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    24b5:	69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27     i2_IP3' size='3'
    24c5:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    24d5:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    24e5:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49     xt' name='Cli2_I
    24f5:	50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P4' size='3' val
    2505:	75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     ue='{{{'>...<inp
    2515:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    2525:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    2535:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    2545:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    2555:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49     ethod='GET'>...I
    2565:	50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     P4:...<input typ
    2575:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    2585:	6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27 33     li3_IP1' size='3
    2595:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    25a5:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    25b5:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f     ext' name='Cli3_
    25c5:	49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP2' size='3' va
    25d5:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    25e5:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    25f5:	20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33 27      name='Cli3_IP3'
    2605:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    2615:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    2625:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    2635:	65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69 7a     e='Cli3_IP4' siz
    2645:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2655:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    2665:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    2675:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    2685:	3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74     </BR>..<FORM act
    2695:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    26a5:	47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     GET'>...<input t
    26b5:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d     ype='submit' nam
    26c5:	65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61 6c     e='ResetGSM' val
    26d5:	75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d 0a     ue='ResetGSM'>..
    26e5:	3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </FORM>..</BR>..
    26f5:	0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0 20     ....<h3>....... 
    2705:	f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a 3c     ....... ......:<
    2715:	2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c     /h3>..</BR>....<
    2725:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    2735:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55     method='GET'>..U
    2745:	44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d 0a     DP Server1 IP:..
    2755:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    2765:	78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31 27     xt' name='UDP01'
    2775:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    2785:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    2795:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    27a5:	65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d 27     e='UDP02' size='
    27b5:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    27c5:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    27d5:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30     text' name='UDP0
    27e5:	33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     3' size='3' valu
    27f5:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    2805:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2815:	61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a 65     ame='UDP04' size
    2825:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2835:	3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75     >..Port:...<inpu
    2845:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2855:	6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20 73     me='UDP0_Port' s
    2865:	69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27 7b     ize='5' value='{
    2875:	7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     {{{{'>...<input 
    2885:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61     type='submit' va
    2895:	6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72     lue='OK'>..</for
    28a5:	6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d     m>..</BR>..<form
    28b5:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    28c5:	6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53     od='GET'>..UDP S
    28d5:	65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69 6e     erver2 IP:...<in
    28e5:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    28f5:	6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69 7a     name='UDP11' siz
    2905:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2915:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    2925:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2935:	44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20 76     DP12' size='3' v
    2945:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2955:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2965:	27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20 73     ' name='UDP13' s
    2975:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    2985:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2995:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    29a5:	27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33 27     'UDP14' size='3'
    29b5:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50      value='{{{'>..P
    29c5:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    29d5:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29e5:	55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65 3d     UDP1_Port' size=
    29f5:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    2a05:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    2a15:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    2a25:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    2a35:	3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61     </BR>....<form a
    2a45:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    2a55:	3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72     ='GET'>..UDP Ser
    2a65:	76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70 75     ver3 IP:...<inpu
    2a75:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a85:	6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65 3d     me='UDP21' size=
    2a95:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2aa5:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2ab5:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2ac5:	32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     22' size='3' val
    2ad5:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2ae5:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2af5:	6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69 7a     name='UDP23' siz
    2b05:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2b15:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    2b25:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2b35:	44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20 76     DP24' size='3' v
    2b45:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72     alue='{{{'>..Por
    2b55:	74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     t:...<input type
    2b65:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2b75:	50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35     P2_Port' size='5
    2b85:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e     ' value='{{{{{'>
    2b95:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    2ba5:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    2bb5:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    2bc5:	42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63 74     BR>....<form act
    2bd5:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    2be5:	47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76 65     GET'>..UDP Serve
    2bf5:	72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74 20     r4 IP:...<input 
    2c05:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2c15:	3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27 33     ='UDP31' size='3
    2c25:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    2c35:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2c45:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33 32     ext' name='UDP32
    2c55:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2c65:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2c75:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2c85:	6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65 3d     me='UDP33' size=
    2c95:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2ca5:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2cb5:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2cc5:	33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     34' size='3' val
    2cd5:	75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74 3a     ue='{{{'>..Port:
    2ce5:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    2cf5:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    2d05:	5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27 20     _Port' size='5' 
    2d15:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d 0a     value='{{{{{'>..
    2d25:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    2d35:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    2d45:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    2d55:	3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c     >.... </BODY>..<
    2d65:	2f 48 54 4d 4c 3e 0d 0a 00                          /HTML>...

00002d6e <var_TCP_ListenPort>:
    2d6e:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

00002d7d <Web_TCP_ListenPort>:
    2d7d:	08 64 00 00 00 00 00 ff ff 00 00 f1 53 00 00 00     .d..........S...

00002d8d <var_TCP_CONNECT_timeout>:
    2d8d:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2d9d:	6f 75 74 00                                         out.

00002da1 <Web_TCP_CONNECT_timeout>:
    2da1:	08 76 00 00 00 00 00 ff ff 00 00 f1 53 00 00 02     .v..........S...

00002db1 <var_WebMaxSessionTime>:
    2db1:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    2dc1:	65 00                                               e.

00002dc3 <Web_WebMaxSessionTime>:
    2dc3:	11 2c 01 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .,........;.....

00002dd3 <var_Cli0_IP1>:
    2dd3:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

00002ddc <Web_Cli0_IP1>:
    2ddc:	01 66 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .f..............

00002dec <var_Cli0_IP2>:
    2dec:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

00002df5 <Web_Cli0_IP2>:
    2df5:	01 67 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .g..............

00002e05 <var_Cli0_IP3>:
    2e05:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

00002e0e <Web_Cli0_IP3>:
    2e0e:	01 68 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .h..............

00002e1e <var_Cli0_IP4>:
    2e1e:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

00002e27 <Web_Cli0_IP4>:
    2e27:	01 69 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .i..............

00002e37 <var_Cli1_IP1>:
    2e37:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

00002e40 <Web_Cli1_IP1>:
    2e40:	01 6a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .j..............

00002e50 <var_Cli1_IP2>:
    2e50:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

00002e59 <Web_Cli1_IP2>:
    2e59:	01 6b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .k..............

00002e69 <var_Cli1_IP3>:
    2e69:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

00002e72 <Web_Cli1_IP3>:
    2e72:	01 6c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .l..............

00002e82 <var_Cli1_IP4>:
    2e82:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

00002e8b <Web_Cli1_IP4>:
    2e8b:	01 6d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .m..............

00002e9b <var_Cli2_IP1>:
    2e9b:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

00002ea4 <Web_Cli2_IP1>:
    2ea4:	01 6e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .n..............

00002eb4 <var_Cli2_IP2>:
    2eb4:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

00002ebd <Web_Cli2_IP2>:
    2ebd:	01 6f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .o..............

00002ecd <var_Cli2_IP3>:
    2ecd:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00002ed6 <Web_Cli2_IP3>:
    2ed6:	01 70 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .p..............

00002ee6 <var_Cli2_IP4>:
    2ee6:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

00002eef <Web_Cli2_IP4>:
    2eef:	01 71 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .q..............

00002eff <var_Cli3_IP1>:
    2eff:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00002f08 <Web_Cli3_IP1>:
    2f08:	01 72 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .r..............

00002f18 <var_Cli3_IP2>:
    2f18:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00002f21 <Web_Cli3_IP2>:
    2f21:	01 73 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .s..............

00002f31 <var_Cli3_IP3>:
    2f31:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00002f3a <Web_Cli3_IP3>:
    2f3a:	01 74 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .t..............

00002f4a <var_Cli3_IP4>:
    2f4a:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00002f53 <Web_Cli3_IP4>:
    2f53:	01 75 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .u..............

00002f63 <var_UDP0_IP1>:
    2f63:	55 44 50 30 31 00                                   UDP01.

00002f69 <Web_UDP0_IP1>:
    2f69:	01 4c 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .L..............

00002f79 <var_UDP0_IP2>:
    2f79:	55 44 50 30 32 00                                   UDP02.

00002f7f <Web_UDP0_IP2>:
    2f7f:	01 4d 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .M..............

00002f8f <var_UDP0_IP3>:
    2f8f:	55 44 50 30 33 00                                   UDP03.

00002f95 <Web_UDP0_IP3>:
    2f95:	01 4e 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .N..............

00002fa5 <var_UDP0_IP4>:
    2fa5:	55 44 50 30 34 00                                   UDP04.

00002fab <Web_UDP0_IP4>:
    2fab:	01 4f 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .O..............

00002fbb <var_UDP1_IP1>:
    2fbb:	55 44 50 31 31 00                                   UDP11.

00002fc1 <Web_UDP1_IP1>:
    2fc1:	01 50 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .P..............

00002fd1 <var_UDP1_IP2>:
    2fd1:	55 44 50 31 32 00                                   UDP12.

00002fd7 <Web_UDP1_IP2>:
    2fd7:	01 51 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Q..............

00002fe7 <var_UDP1_IP3>:
    2fe7:	55 44 50 31 33 00                                   UDP13.

00002fed <Web_UDP1_IP3>:
    2fed:	01 52 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .R..............

00002ffd <var_UDP1_IP4>:
    2ffd:	55 44 50 31 34 00                                   UDP14.

00003003 <Web_UDP1_IP4>:
    3003:	01 53 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .S..............

00003013 <var_UDP2_IP1>:
    3013:	55 44 50 32 31 00                                   UDP21.

00003019 <Web_UDP2_IP1>:
    3019:	01 54 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .T..............

00003029 <var_UDP2_IP2>:
    3029:	55 44 50 32 32 00                                   UDP22.

0000302f <Web_UDP2_IP2>:
    302f:	01 55 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .U..............

0000303f <var_UDP2_IP3>:
    303f:	55 44 50 32 33 00                                   UDP23.

00003045 <Web_UDP2_IP3>:
    3045:	01 56 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .V..............

00003055 <var_UDP2_IP4>:
    3055:	55 44 50 32 34 00                                   UDP24.

0000305b <Web_UDP2_IP4>:
    305b:	01 57 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .W..............

0000306b <var_UDP3_IP1>:
    306b:	55 44 50 33 31 00                                   UDP31.

00003071 <Web_UDP3_IP1>:
    3071:	01 58 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .X..............

00003081 <var_UDP3_IP2>:
    3081:	55 44 50 33 32 00                                   UDP32.

00003087 <Web_UDP3_IP2>:
    3087:	01 59 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Y..............

00003097 <var_UDP3_IP3>:
    3097:	55 44 50 33 33 00                                   UDP33.

0000309d <Web_UDP3_IP3>:
    309d:	01 5a 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Z..............

000030ad <var_UDP3_IP4>:
    30ad:	55 44 50 33 34 00                                   UDP34.

000030b3 <Web_UDP3_IP4>:
    30b3:	01 5b 00 00 00 00 00 ff 00 00 00 00 00 00 00 00     .[..............

000030c3 <var_UDP0_Port>:
    30c3:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

000030cd <Web_UDP0_Port>:
    30cd:	08 5c 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     .\..............

000030dd <var_UDP1_Port>:
    30dd:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

000030e7 <Web_UDP1_Port>:
    30e7:	08 5e 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     .^..............

000030f7 <var_UDP2_Port>:
    30f7:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00003101 <Web_UDP2_Port>:
    3101:	08 60 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     .`..............

00003111 <var_UDP3_Port>:
    3111:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

0000311b <Web_UDP3_Port>:
    311b:	08 62 00 00 00 00 00 ff ff 00 00 00 00 00 00 00     .b..............

0000312b <var_ResetGSM>:
    312b:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00003134 <Web_ResetGSM>:
    3134:	00 9c 05 00 00 00 00 ff 00 00 00 d9 3d 00 00 00     ............=...

00003144 <network_OField>:
    3144:	6e 2d 7d 2d 8d 2d a1 2d b1 2d c3 2d 2b 31 34 31     n-}-.-.-.-.-+141
    3154:	d3 2d dc 2d ec 2d f5 2d 05 2e 0e 2e 1e 2e 27 2e     .-.-.-.-......'.
    3164:	37 2e 40 2e 50 2e 59 2e 69 2e 72 2e 82 2e 8b 2e     7.@.P.Y.i.r.....
    3174:	9b 2e a4 2e b4 2e bd 2e cd 2e d6 2e e6 2e ef 2e     ................
    3184:	ff 2e 08 2f 18 2f 21 2f 31 2f 3a 2f 4a 2f 53 2f     ..././!/1/:/J/S/
    3194:	63 2f 69 2f 79 2f 7f 2f 8f 2f 95 2f a5 2f ab 2f     c/i/y/./././././
    31a4:	bb 2f c1 2f d1 2f d7 2f e7 2f ed 2f fd 2f 03 30     ./././././././.0
    31b4:	13 30 19 30 29 30 2f 30 3f 30 45 30 55 30 5b 30     .0.0)0/0?0E0U0[0
    31c4:	6b 30 71 30 81 30 87 30 97 30 9d 30 ad 30 b3 30     k0q0.0.0.0.0.0.0
    31d4:	c3 30 cd 30 dd 30 e7 30 f7 30 01 31 11 31 1b 31     .0.0.0.0.0.1.1.1

000031e4 <Web_network>:
    31e4:	46 1c 53 1c a0 00 44 31 19 10 55 1d                 F.S...D1..U.

000031f0 <name_gsm>:
    31f0:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

000031f9 <gsm_IField>:
    31f9:	22 62 01 00 00 15 22 62 01 00 00 15 07 8f 0a 00     "b...."b........
    3209:	00 00 14 8f 05 00 00 00 00 a2 05 00 00 00 22 06     ..............".
    3219:	00 00 00 1e 22 24 00 00 00 14 22 38 00 00 00 14     ...."$...."8....

00003229 <gsm_page>:
    3229:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3239:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3249:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3259:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3269:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3279:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3289:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3299:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    32a9:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    32b9:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    32c9:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    32d9:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    32e9:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    32f9:	09 53 57 3a 20 33 2e 30 35 3c 2f 42 52 3e 0d 0a     .SW: 3.05</BR>..
    3309:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3319:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3329:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3339:	65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d 6c     ef="network.html
    3349:	22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0 ee     ">....... ......
    3359:	e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3369:	72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e 47     ref="gsm.html">G
    3379:	53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d 0a     SM/GPRS</a> | ..
    3389:	3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74 6d     <a href="csd.htm
    3399:	6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a 3c     l">CSD</a> | ..<
    33a9:	61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e 68     a href="system.h
    33b9:	74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61 3e     tml">.......</a>
    33c9:	20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c 6f      | ..<a href="lo
    33d9:	67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee e4     gout.html">.....
    33e9:	3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee e2     </a>..<HR>......
    33f9:	e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20 28     ... ....... {{ (
    3409:	30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e     0-31)</BR>..<h3>
    3419:	47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d 0a     GPRS</h3></BR>..
    3429:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    3439:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    3449:	09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c 69     .APN name: ...<i
    3459:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    3469:	20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 27      name='GPRS_apn'
    3479:	20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75 65      size='29' value
    3489:	3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ='{{{{{{{{{{{{{{
    3499:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     {{{{{{{{{{{{{{{'
    34a9:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    34b9:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    34c9:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    34d9:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    34e9:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    34f9:	45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d 65     ET'>...User name
    3509:	3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     : ...<input type
    3519:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47 50     ='text' name='GP
    3529:	52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d 65     RS_apn_user_name
    3539:	27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c 75     ' size='19' valu
    3549:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    3559:	7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     {{{{{{'>...<inpu
    3569:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    3579:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    3589:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    3599:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    35a9:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50 61     thod='GET'>...Pa
    35b9:	73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70 75     ssword: ...<inpu
    35c9:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    35d9:	6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73 77     me='GPRS_apn_psw
    35e9:	27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c 75     ' size='19' valu
    35f9:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    3609:	7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     {{{{{{'>...<inpu
    3619:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    3629:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    3639:	6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52     orm..</BR>..<FOR
    3649:	4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     M action='/' met
    3659:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69 6e     hod='GET'>...<in
    3669:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    3679:	27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53 4d     ' name='ResetGSM
    3689:	27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47 53     ' value='ResetGS
    3699:	4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f     M'>..</FORM>..</
    36a9:	42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f 44     BR></BR>.. </BOD
    36b9:	59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00           Y>..</HTML>...

000036c7 <var_GPRS_apn1>:
    36c7:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000036d0 <Web_GPRS_apn1>:
    36d0:	22 06 00 00 00 00 00 02 00 00 00 f1 53 00 00 1e     "...........S...

000036e0 <var_GPRS_apn_user_name>:
    36e0:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    36f0:	6d 65 00                                            me.

000036f3 <Web_GPRS_apn_user_name>:
    36f3:	22 24 00 00 00 00 00 02 00 00 00 f1 53 00 00 14     "$..........S...

00003703 <var_GPRS_apn_psw>:
    3703:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

00003710 <Web_GPRS_apn_psw>:
    3710:	22 38 00 00 00 00 00 02 00 00 00 f1 53 00 00 14     "8..........S...

00003720 <var_SMS>:
    3720:	53 4d 53 4f 6e 00                                   SMSOn.

00003726 <Web_SMS>:
    3726:	01 25 01 00 00 00 00 01 00 00 00 00 00 00 00 00     .%..............

00003736 <var_SMS_Number1>:
    3736:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

00003742 <Web_SMS_Number1>:
    3742:	22 7c 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "|..............

00003752 <var_SMS_Number2>:
    3752:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

0000375e <Web_SMS_Number2>:
    375e:	22 89 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000376e <var_SMS_Number3>:
    376e:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

0000377a <Web_SMS_Number3>:
    377a:	22 96 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000378a <gsm_OField>:
    378a:	c7 36 d0 36 e0 36 f3 36 03 37 10 37 20 37 26 37     .6.6.6.6.7.7 7&7
    379a:	36 37 42 37 52 37 5e 37 6e 37 7a 37                 67B7R7^7n7z7

000037a6 <Web_gsm>:
    37a6:	f0 31 f9 31 1c 00 8a 37 9e 04 29 32                 .1.1...7..)2

000037b2 <name_csd>:
    37b2:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

000037bb <csd_IField>:
    37bb:	22 62 01 00 00 15 22 62 01 00 00 15 07 8f 0a 00     "b...."b........
    37cb:	00 00 14 8f 05 00 00 00 1e 26 01 29 0b 00 1e 26     .........&.)...&
    37db:	01 2d 0b 00 22 a3 00 00 00 0d 22 b0 00 00 00 0d     .-..".....".....
    37eb:	22 bd 00 00 00 0d 22 ca 00 00 00 0d 22 d7 00 00     "....."....."...
    37fb:	00 0d 22 e4 00 00 00 0d 22 f1 00 00 00 0d 22 fe     ..".....".....".
    380b:	00 00 00 0d 22 0b 01 00 00 0d 22 18 01 00 00 0d     ....".....".....

0000381b <csd_page>:
    381b:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    382b:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    383b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    384b:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    385b:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    386b:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    387b:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    388b:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    389b:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    38ab:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    38bb:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    38cb:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    38db:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    38eb:	09 53 57 3a 20 33 2e 30 35 3c 2f 42 52 3e 0d 0a     .SW: 3.05</BR>..
    38fb:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    390b:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    391b:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    392b:	65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d 6c     ef="network.html
    393b:	22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0 ee     ">....... ......
    394b:	e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    395b:	72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e 47     ref="gsm.html">G
    396b:	53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d 0a     SM/GPRS</a> | ..
    397b:	3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74 6d     <a href="csd.htm
    398b:	6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a 3c     l">CSD</a> | ..<
    399b:	61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e 68     a href="system.h
    39ab:	74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61 3e     tml">.......</a>
    39bb:	20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c 6f      | ..<a href="lo
    39cb:	67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee e4     gout.html">.....
    39db:	3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f 72     </a>..<HR>..<for
    39eb:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    39fb:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0 ee     hod='GET'>......
    3a0b:	e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a 09     ..... ......:...
    3a1b:	3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43 4c     <SELECT NAME="CL
    3a2b:	49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     IPOn"> ...<OPTIO
    3a3b:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    3a4b:	7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49 4f     {{>... ...<OPTIO
    3a5b:	4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b     N VALUE=1 {{{{{{
    3a6b:	7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{>.....</SELECT
    3a7b:	3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     > ...<input type
    3a8b:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    3a9b:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    3aab:	3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5 20     <h3>........... 
    3abb:	ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52 3e     ......</h3></BR>
    3acb:	0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27     ..<form action='
    3adb:	2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e     /' method='GET'>
    3aeb:	0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75 74     ....1: ...<input
    3afb:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3b0b:	65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27 31     e='CSD0' size='1
    3b1b:	32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b     2' value='{{{{{{
    3b2b:	7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     {{{{{{'>...<inpu
    3b3b:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    3b4b:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    3b5b:	6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     orm>..<form acti
    3b6b:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    3b7b:	45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c 69     ET'>....2: ...<i
    3b8b:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    3b9b:	20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69 7a      name='CSD1' siz
    3bab:	65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b 7b     e='12' value='{{
    3bbb:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c     {{{{{{{{{{'>...<
    3bcb:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3bdb:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3beb:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20     .</form>..<form 
    3bfb:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    3c0b:	64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20 0d     d='GET'>....3: .
    3c1b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    3c2b:	65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32 27     ext' name='CSD2'
    3c3b:	20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65      size='12' value
    3c4b:	3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e     ='{{{{{{{{{{{{'>
    3c5b:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    3c6b:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    3c7b:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66     K'>..</form>..<f
    3c8b:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    3c9b:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9     ethod='GET'>....
    3cab:	34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     4: ...<input typ
    3cbb:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    3ccb:	53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20 76     SD3' size='12' v
    3cdb:	61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     alue='{{{{{{{{{{
    3ceb:	7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {{'>...<input ty
    3cfb:	70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75     pe='submit' valu
    3d0b:	65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e     e='OK'>..</form>
    3d1b:	0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27     ..<form action='
    3d2b:	2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e     /' method='GET'>
    3d3b:	0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75 74     ....5: ...<input
    3d4b:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3d5b:	65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27 31     e='CSD4' size='1
    3d6b:	32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b     2' value='{{{{{{
    3d7b:	7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     {{{{{{'>...<inpu
    3d8b:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    3d9b:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    3dab:	6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     orm>..<form acti
    3dbb:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    3dcb:	45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c 69     ET'>....6: ...<i
    3ddb:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    3deb:	20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69 7a      name='CSD5' siz
    3dfb:	65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b 7b     e='12' value='{{
    3e0b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c     {{{{{{{{{{'>...<
    3e1b:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e2b:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e3b:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20     .</form>..<form 
    3e4b:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    3e5b:	64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20 0d     d='GET'>....7: .
    3e6b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    3e7b:	65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36 27     ext' name='CSD6'
    3e8b:	20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65      size='12' value
    3e9b:	3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e     ='{{{{{{{{{{{{'>
    3eab:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    3ebb:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    3ecb:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66     K'>..</form>..<f
    3edb:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    3eeb:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9     ethod='GET'>....
    3efb:	38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     8: ...<input typ
    3f0b:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    3f1b:	53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20 76     SD7' size='12' v
    3f2b:	61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     alue='{{{{{{{{{{
    3f3b:	7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {{'>...<input ty
    3f4b:	70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75     pe='submit' valu
    3f5b:	65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e     e='OK'>..</form>
    3f6b:	0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27     ..<form action='
    3f7b:	2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e     /' method='GET'>
    3f8b:	0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75 74     ....9: ...<input
    3f9b:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3fab:	65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27 31     e='CSD8' size='1
    3fbb:	32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b     2' value='{{{{{{
    3fcb:	7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     {{{{{{'>...<inpu
    3fdb:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    3feb:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    3ffb:	6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     orm>..<form acti
    400b:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    401b:	45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09 3c     ET'>....10: ...<
    402b:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    403b:	27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73 69     ' name='CSD9' si
    404b:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    405b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    406b:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    407b:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    408b:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e     ..</form>..</BR>
    409b:	0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54     .. </BODY>..</HT
    40ab:	4d 4c 3e 0d 0a 00                                   ML>...

000040b1 <var_CLIP>:
    40b1:	43 4c 49 50 4f 6e 00                                CLIPOn.

000040b8 <Web_CLIP>:
    40b8:	01 26 01 00 00 00 00 01 00 00 00 00 00 00 00 00     .&..............

000040c8 <var_CSD_Number0>:
    40c8:	43 53 44 30 00                                      CSD0.

000040cd <Web_CSD_Number0>:
    40cd:	22 a3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

000040dd <var_CSD_Number1>:
    40dd:	43 53 44 31 00                                      CSD1.

000040e2 <Web_CSD_Number1>:
    40e2:	22 b0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

000040f2 <var_CSD_Number2>:
    40f2:	43 53 44 32 00                                      CSD2.

000040f7 <Web_CSD_Number2>:
    40f7:	22 bd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00004107 <var_CSD_Number3>:
    4107:	43 53 44 33 00                                      CSD3.

0000410c <Web_CSD_Number3>:
    410c:	22 ca 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000411c <var_CSD_Number4>:
    411c:	43 53 44 34 00                                      CSD4.

00004121 <Web_CSD_Number4>:
    4121:	22 d7 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00004131 <var_CSD_Number5>:
    4131:	43 53 44 35 00                                      CSD5.

00004136 <Web_CSD_Number5>:
    4136:	22 e4 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00004146 <var_CSD_Number6>:
    4146:	43 53 44 36 00                                      CSD6.

0000414b <Web_CSD_Number6>:
    414b:	22 f1 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000415b <var_CSD_Number7>:
    415b:	43 53 44 37 00                                      CSD7.

00004160 <Web_CSD_Number7>:
    4160:	22 fe 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00004170 <var_CSD_Number8>:
    4170:	43 53 44 38 00                                      CSD8.

00004175 <Web_CSD_Number8>:
    4175:	22 0b 01 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00004185 <var_CSD_Number9>:
    4185:	43 53 44 39 00                                      CSD9.

0000418a <Web_CSD_Number9>:
    418a:	22 18 01 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000419a <csd_OField>:
    419a:	b1 40 b8 40 c8 40 cd 40 dd 40 e2 40 f2 40 f7 40     .@.@.@.@.@.@.@.@
    41aa:	07 41 0c 41 1c 41 21 41 31 41 36 41 46 41 4b 41     .A.A.A!A1A6AFAKA
    41ba:	5b 41 60 41 70 41 75 41 85 41 8a 41                 [A`ApAuA.A.A

000041c6 <Web_csd>:
    41c6:	b2 37 bb 37 2c 00 9a 41 96 08 1b 38                 .7.7,..A...8

000041d2 <name_system>:
    41d2:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

000041de <system_IField>:
    41de:	22 62 01 00 00 15 22 62 01 00 00 15 07 8f 0a 00     "b...."b........
    41ee:	00 00 14 8f 05 00 00 00 22 62 01 00 00 15 10 d0     ........"b......
    41fe:	08 00 00 02 09 70 05 00 00 01 0a 77 01 00 00 01     .....p.....w....
    420e:	0a 79 01 00 00 01 00 ea 08 00 00 00 00 d8 09 00     .y..............
	...

00004220 <system_page>:
    4220:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4230:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4240:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4250:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    4260:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    4270:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    4280:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4290:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    42a0:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    42b0:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    42c0:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    42d0:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    42e0:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    42f0:	09 53 57 3a 20 33 2e 30 35 3c 2f 42 52 3e 0d 0a     .SW: 3.05</BR>..
    4300:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4310:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4320:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    4330:	65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d 6c     ef="network.html
    4340:	22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0 ee     ">....... ......
    4350:	e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    4360:	72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e 47     ref="gsm.html">G
    4370:	53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d 0a     SM/GPRS</a> | ..
    4380:	3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74 6d     <a href="csd.htm
    4390:	6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a 3c     l">CSD</a> | ..<
    43a0:	61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e 68     a href="system.h
    43b0:	74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61 3e     tml">.......</a>
    43c0:	20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c 6f      | ..<a href="lo
    43d0:	67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee e4     gout.html">.....
    43e0:	3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c 66     </a>..<HR>....<f
    43f0:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    4400:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cd     ethod='GET'>....
    4410:	e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0 3a     ....... .......:
    4420:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    4430:	74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74 6c     text' name='Titl
    4440:	65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61 6c     e' size='40' val
    4450:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    4460:	7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     {{{{{{{{'>...<in
    4470:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    4480:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    4490:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d     /form>..</BR>...
    44a0:	0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b 7b     .......... :{{{{
    44b0:	7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46 4f     {{{{{{{ .....<FO
    44c0:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    44d0:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    44e0:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    44f0:	74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74 27     t' name='Reboot'
    4500:	20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27 3e      value='Reboot'>
    4510:	0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1 e8     ..</FORM>.......
    4520:	ff 20 cf ce 3a 20 33 2e 30 35 0d 0a 3c 46 4f 52     . ..: 3.05..<FOR
    4530:	4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     M action='/' met
    4540:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69 6e     hod='GET'>...<in
    4550:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    4560:	27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61 64     ' name='Bootload
    4570:	65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74 6c     er' value='Bootl
    4580:	6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52 45     oader' color='RE
    4590:	44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f     D'>..</FORM>..</
    45a0:	42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69 6f     BR>..<FORM actio
    45b0:	6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45     n='/' method='GE
    45c0:	54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T'>...<input typ
    45d0:	65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65 3d     e='submit' name=
    45e0:	27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c 75     'BLupgrade' valu
    45f0:	65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d 0a     e='BLupgrade'>..
    4600:	3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </FORM>..</BR>..
    4610:	3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0 3c     <H2>...........<
    4620:	2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3 f0     /H2>............
    4630:	e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43 3c     .:{{{{{{{&#176C<
    4640:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    4650:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    4660:	45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff 3a     ET'>...........:
    4670:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    4680:	74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69 67     text' name='Thig
    4690:	68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     h' size='5' valu
    46a0:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
    46b0:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
    46c0:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    46d0:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    46e0:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    46f0:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    4700:	47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff 3a     GET'>..........:
    4710:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    4720:	74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f 77     text' name='Tlow
    4730:	27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65     ' size='5' value
    4740:	3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37 36     ='{{{{{{{'>&#176
    4750:	43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     C...<input type=
    4760:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    4770:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    4780:	2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d 2d     /BR>....... GSM-
    4790:	3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32 35     >EM: {{{/(max 25
    47a0:	30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3 f4     0)....</BR>.....
    47b0:	e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b 2f     .. EM->GSM: {{{/
    47c0:	28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f 42     (max 250)....</B
    47d0:	52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a 3c     R>....</BODY>..<
    47e0:	2f 48 54 4d 4c 3e 0d 0a 00                          /HTML>...

000047e9 <var_Title>:
    47e9:	54 69 74 6c 65 00                                   Title.

000047ef <Web_Title>:
    47ef:	22 62 01 00 00 00 00 02 00 00 00 00 00 00 00 15     "b..............

000047ff <var_Reboot>:
    47ff:	52 65 62 6f 6f 74 00                                Reboot.

00004806 <Web_Reboot>:
    4806:	00 9c 05 00 00 00 00 ff 00 00 00 d7 3d 00 00 00     ............=...

00004816 <var_Bootloader>:
    4816:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

00004821 <Web_Bootloader>:
    4821:	00 9c 05 00 00 00 00 ff 00 00 00 26 52 00 00 00     ...........&R...

00004831 <var_BLupgrade>:
    4831:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

0000483b <Web_BLupgrade>:
    483b:	00 9c 05 00 00 00 00 ff 00 00 00 dd 3d 00 00 00     ............=...

0000484b <var_Thigh>:
    484b:	54 68 69 67 68 00                                   Thigh.

00004851 <Web_Thigh>:
    4851:	0a 77 01 18 fc ff ff dc 05 00 00 00 00 00 00 01     .w..............

00004861 <var_Tlow>:
    4861:	54 6c 6f 77 00                                      Tlow.

00004866 <Web_Tlow>:
    4866:	0a 79 01 18 fc ff ff dc 05 00 00 00 00 00 00 01     .y..............

00004876 <system_OField>:
    4876:	e9 47 ef 47 ff 47 06 48 16 48 21 48 31 48 3b 48     .G.G.G.H.H!H1H;H
    4886:	4b 48 51 48 61 48 66 48                             KHQHaHfH

0000488e <Web_system>:
    488e:	d2 41 de 41 18 00 76 48 c9 05 20 42                 .A.A..vH.. B

0000489a <WebSite>:
    489a:	a4 16 00 0b 3a 1c e4 31 a6 37 c6 41 8e 48           ....:..1.7.A.H

000048a8 <__c.8282>:
    48a8:	ed e5 f2 20 f1 e2 ff e7 e8 20 f1 20 dd d1 20 00     ... ..... . .. .

000048b8 <__c.8280>:
    48b8:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000048c8 <__c.8278>:
    48c8:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000048d3 <__c.7862>:
    48d3:	25 38 73 00                                         %8s.

000048d7 <__c.7835>:
    48d7:	25 6c 75 64 00                                      %lud.

000048dc <__c.7810>:
    48dc:	25 68 68 75 3a 25 68 68 75 3a 25 68 68 75 00        %hhu:%hhu:%hhu.

000048eb <__c.7786>:
    48eb:	25 68 68 75 2d 25 68 68 75 2d 25 68 68 75 00        %hhu-%hhu-%hhu.

000048fa <__c.7596>:
    48fa:	0d 0a 00                                            ...

000048fd <__c.7144>:
    48fd:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

00004907 <__c.7142>:
    4907:	25 30 38 6c 78 00                                   %08lx.

0000490d <__c.7033>:
    490d:	25 75 0d 0a 00                                      %u...

00004912 <__c.6773>:
    4912:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

0000491e <__c.6771>:
    491e:	2f 00                                               /.

00004920 <MaxThermType>:
    4920:	07 02 01                                            ...

00004923 <TerLimType>:
    4923:	5c 04 7c 04 90 04                                   \.|...

00004929 <DO_M>:
    4929:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004938 <DI_M>:
    4938:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4948:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004958 <__c.4665>:
    4958:	50 4f 53 54 00                                      POST.

0000495d <__c.4663>:
    495d:	47 45 54 20 00                                      GET .

00004962 <__c.4659>:
    4962:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00004972 <__c.4647>:
    4972:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
    4982:	68 75 00                                            hu.

00004985 <__c.4636>:
    4985:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
    4995:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

000049a3 <__c.4615>:
    49a3:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

000049b0 <__c.4604>:
    49b0:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
    49c0:	68 68 75 00                                         hhu.

000049c4 <__c.4578>:
    49c4:	25 75 00                                            %u.

000049c7 <__c.4576>:
    49c7:	25 6c 75 64 00                                      %lud.

000049cc <MB_Port>:
    49cc:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 b4 29 ba 29     .............).)
    49dc:	bd 29 be 29                                         .).)

000049e0 <MB_Role>:
	...

000049e1 <MB_Timer>:
    49e1:	52 00 51 00 f5 29 44 00 43 00 fb 29                 R.Q..)D.C..)

000049ed <aCRCLo.1604>:
    49ed:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
    49fd:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
    4a0d:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
    4a1d:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
    4a2d:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
    4a3d:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
    4a4d:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
    4a5d:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
    4a6d:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
    4a7d:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
    4a8d:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
    4a9d:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
    4aad:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
    4abd:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
    4acd:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
    4add:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00004aed <aCRCHi.1603>:
    4aed:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4afd:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4b0d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4b1d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4b2d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4b3d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4b4d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4b5d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4b6d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4b7d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4b8d:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4b9d:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4bad:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
    4bbd:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4bcd:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
    4bdd:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00004bed <__c.1988>:
    4bed:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00004bfa <__ctors_end>:
    4bfa:	11 24       	eor	r1, r1
    4bfc:	1f be       	out	0x3f, r1	; 63
    4bfe:	cf ef       	ldi	r28, 0xFF	; 255
    4c00:	d0 e1       	ldi	r29, 0x10	; 16
    4c02:	de bf       	out	0x3e, r29	; 62
    4c04:	cd bf       	out	0x3d, r28	; 61

00004c06 <__do_copy_data>:
    4c06:	11 e0       	ldi	r17, 0x01	; 1
    4c08:	a0 e0       	ldi	r26, 0x00	; 0
    4c0a:	b1 e0       	ldi	r27, 0x01	; 1
    4c0c:	e6 e6       	ldi	r30, 0x66	; 102
    4c0e:	f3 e2       	ldi	r31, 0x23	; 35
    4c10:	01 e0       	ldi	r16, 0x01	; 1
    4c12:	0b bf       	out	0x3b, r16	; 59
    4c14:	02 c0       	rjmp	.+4      	; 0x4c1a <__do_copy_data+0x14>
    4c16:	07 90       	elpm	r0, Z+
    4c18:	0d 92       	st	X+, r0
    4c1a:	aa 3d       	cpi	r26, 0xDA	; 218
    4c1c:	b1 07       	cpc	r27, r17
    4c1e:	d9 f7       	brne	.-10     	; 0x4c16 <__do_copy_data+0x10>

00004c20 <__do_clear_bss>:
    4c20:	1d e0       	ldi	r17, 0x0D	; 13
    4c22:	aa ed       	ldi	r26, 0xDA	; 218
    4c24:	b1 e0       	ldi	r27, 0x01	; 1
    4c26:	01 c0       	rjmp	.+2      	; 0x4c2a <.do_clear_bss_start>

00004c28 <.do_clear_bss_loop>:
    4c28:	1d 92       	st	X+, r1

00004c2a <.do_clear_bss_start>:
    4c2a:	a3 3b       	cpi	r26, 0xB3	; 179
    4c2c:	b1 07       	cpc	r27, r17
    4c2e:	e1 f7       	brne	.-8      	; 0x4c28 <.do_clear_bss_loop>
    4c30:	0e 94 e9 85 	call	0x10bd2	; 0x10bd2 <main>
    4c34:	0c 94 8f 87 	jmp	0x10f1e	; 0x10f1e <exit>

00004c38 <__bad_interrupt>:
    4c38:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00004c3c <rrb>:
#include <stdint.h>

// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
    4c3c:	fc 01       	movw	r30, r24
	return *addr;
}
    4c3e:	80 81       	ld	r24, Z
    4c40:	08 95       	ret

00004c42 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4c42:	fc 01       	movw	r30, r24
    4c44:	84 91       	lpm	r24, Z+
}
    4c46:	08 95       	ret

00004c48 <prw>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    4c48:	fc 01       	movw	r30, r24
    4c4a:	25 91       	lpm	r18, Z+
    4c4c:	34 91       	lpm	r19, Z+
}
    4c4e:	c9 01       	movw	r24, r18
    4c50:	08 95       	ret

00004c52 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    4c52:	fc 01       	movw	r30, r24
    4c54:	25 91       	lpm	r18, Z+
    4c56:	35 91       	lpm	r19, Z+
    4c58:	45 91       	lpm	r20, Z+
    4c5a:	54 91       	lpm	r21, Z+
}
    4c5c:	b9 01       	movw	r22, r18
    4c5e:	ca 01       	movw	r24, r20
    4c60:	08 95       	ret

00004c62 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    4c62:	a0 e0       	ldi	r26, 0x00	; 0
    4c64:	b0 e0       	ldi	r27, 0x00	; 0
    4c66:	80 50       	subi	r24, 0x00	; 0
    4c68:	90 40       	sbci	r25, 0x00	; 0
    4c6a:	af 4f       	sbci	r26, 0xFF	; 255
    4c6c:	bf 4f       	sbci	r27, 0xFF	; 255
}
    4c6e:	ab bf       	out	0x3b, r26	; 59
    4c70:	fc 01       	movw	r30, r24
    4c72:	87 91       	elpm	r24, Z+
    4c74:	08 95       	ret

00004c76 <prc>:

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    4c76:	fc 01       	movw	r30, r24
    4c78:	84 91       	lpm	r24, Z+
}
    4c7a:	08 95       	ret

00004c7c <prp>:

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    4c7c:	fc 01       	movw	r30, r24
    4c7e:	25 91       	lpm	r18, Z+
    4c80:	34 91       	lpm	r19, Z+
}
    4c82:	c9 01       	movw	r24, r18
    4c84:	08 95       	ret

00004c86 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    4c86:	6f 92       	push	r6
    4c88:	7f 92       	push	r7
    4c8a:	8f 92       	push	r8
    4c8c:	9f 92       	push	r9
    4c8e:	af 92       	push	r10
    4c90:	bf 92       	push	r11
    4c92:	cf 92       	push	r12
    4c94:	df 92       	push	r13
    4c96:	ef 92       	push	r14
    4c98:	ff 92       	push	r15
    4c9a:	0f 93       	push	r16
    4c9c:	1f 93       	push	r17
    4c9e:	cf 93       	push	r28
    4ca0:	df 93       	push	r29
    4ca2:	3c 01       	movw	r6, r24
    4ca4:	eb 01       	movw	r28, r22
    4ca6:	49 01       	movw	r8, r18
    4ca8:	5a 01       	movw	r10, r20
    4caa:	c1 2e       	mov	r12, r17
		0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54,
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
    4cac:	d0 2e       	mov	r13, r16
    4cae:	ee 24       	eor	r14, r14
    4cb0:	ff 24       	eor	r15, r15
    4cb2:	87 01       	movw	r16, r14
    4cb4:	17 c0       	rjmp	.+46     	; 0x4ce4 <CRC_Seed+0x5e>
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
    4cb6:	ce 01       	movw	r24, r28
    4cb8:	8e 0d       	add	r24, r14
    4cba:	9f 1d       	adc	r25, r15
    4cbc:	f3 01       	movw	r30, r6
    4cbe:	09 95       	icall
		CRCLo = CRCHi^prb(aCRCHi+j);
    4cc0:	d8 26       	eor	r13, r24
    4cc2:	2d 2d       	mov	r18, r13
    4cc4:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4cc6:	c9 01       	movw	r24, r18
    4cc8:	83 51       	subi	r24, 0x13	; 19
    4cca:	95 4b       	sbci	r25, 0xB5	; 181
    4ccc:	fc 01       	movw	r30, r24
    4cce:	d4 90       	lpm	r13, Z+
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    4cd0:	dc 24       	eor	r13, r12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    4cd2:	23 51       	subi	r18, 0x13	; 19
    4cd4:	36 4b       	sbci	r19, 0xB6	; 182
    4cd6:	f9 01       	movw	r30, r18
    4cd8:	c4 90       	lpm	r12, Z+
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    4cda:	08 94       	sec
    4cdc:	e1 1c       	adc	r14, r1
    4cde:	f1 1c       	adc	r15, r1
    4ce0:	01 1d       	adc	r16, r1
    4ce2:	11 1d       	adc	r17, r1
    4ce4:	e8 14       	cp	r14, r8
    4ce6:	f9 04       	cpc	r15, r9
    4ce8:	0a 05       	cpc	r16, r10
    4cea:	1b 05       	cpc	r17, r11
    4cec:	20 f3       	brcs	.-56     	; 0x4cb6 <CRC_Seed+0x30>
    4cee:	9c 2d       	mov	r25, r12
    4cf0:	80 e0       	ldi	r24, 0x00	; 0
    4cf2:	2d 2d       	mov	r18, r13
    4cf4:	30 e0       	ldi	r19, 0x00	; 0
    4cf6:	28 2b       	or	r18, r24
    4cf8:	39 2b       	or	r19, r25
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
}
    4cfa:	c9 01       	movw	r24, r18
    4cfc:	df 91       	pop	r29
    4cfe:	cf 91       	pop	r28
    4d00:	1f 91       	pop	r17
    4d02:	0f 91       	pop	r16
    4d04:	ff 90       	pop	r15
    4d06:	ef 90       	pop	r14
    4d08:	df 90       	pop	r13
    4d0a:	cf 90       	pop	r12
    4d0c:	bf 90       	pop	r11
    4d0e:	af 90       	pop	r10
    4d10:	9f 90       	pop	r9
    4d12:	8f 90       	pop	r8
    4d14:	7f 90       	pop	r7
    4d16:	6f 90       	pop	r6
    4d18:	08 95       	ret

00004d1a <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    4d1a:	0f 93       	push	r16
    4d1c:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    4d1e:	0f ef       	ldi	r16, 0xFF	; 255
    4d20:	1f ef       	ldi	r17, 0xFF	; 255
    4d22:	0e 94 43 26 	call	0x4c86	; 0x4c86 <CRC_Seed>
}
    4d26:	1f 91       	pop	r17
    4d28:	0f 91       	pop	r16
    4d2a:	08 95       	ret

00004d2c <CRC_Flash_calc>:

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    4d2c:	0f 93       	push	r16
    4d2e:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    4d30:	81 e2       	ldi	r24, 0x21	; 33
    4d32:	96 e2       	ldi	r25, 0x26	; 38
    4d34:	60 e0       	ldi	r22, 0x00	; 0
    4d36:	70 e0       	ldi	r23, 0x00	; 0
    4d38:	20 e0       	ldi	r18, 0x00	; 0
    4d3a:	30 e0       	ldi	r19, 0x00	; 0
    4d3c:	41 e0       	ldi	r20, 0x01	; 1
    4d3e:	50 e0       	ldi	r21, 0x00	; 0
    4d40:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
    4d44:	8c 01       	movw	r16, r24
    4d46:	81 e3       	ldi	r24, 0x31	; 49
    4d48:	96 e2       	ldi	r25, 0x26	; 38
    4d4a:	60 e0       	ldi	r22, 0x00	; 0
    4d4c:	70 e0       	ldi	r23, 0x00	; 0
    4d4e:	20 e0       	ldi	r18, 0x00	; 0
    4d50:	30 e0       	ldi	r19, 0x00	; 0
    4d52:	41 e0       	ldi	r20, 0x01	; 1
    4d54:	50 e0       	ldi	r21, 0x00	; 0
    4d56:	0e 94 43 26 	call	0x4c86	; 0x4c86 <CRC_Seed>
	#endif
}
    4d5a:	1f 91       	pop	r17
    4d5c:	0f 91       	pop	r16
    4d5e:	08 95       	ret

00004d60 <CRC_EEPROM_calc>:

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    4d60:	cf 92       	push	r12
    4d62:	df 92       	push	r13
    4d64:	ef 92       	push	r14
    4d66:	ff 92       	push	r15
    4d68:	0f 93       	push	r16
    4d6a:	1f 93       	push	r17
	return
    4d6c:	9e e1       	ldi	r25, 0x1E	; 30
    4d6e:	c9 2e       	mov	r12, r25
    4d70:	9a e5       	ldi	r25, 0x5A	; 90
    4d72:	d9 2e       	mov	r13, r25
    4d74:	8c e8       	ldi	r24, 0x8C	; 140
    4d76:	e8 2e       	mov	r14, r24
    4d78:	81 e0       	ldi	r24, 0x01	; 1
    4d7a:	f8 2e       	mov	r15, r24
    4d7c:	97 01       	movw	r18, r14
    4d7e:	40 e0       	ldi	r20, 0x00	; 0
    4d80:	50 e0       	ldi	r21, 0x00	; 0
    4d82:	c6 01       	movw	r24, r12
    4d84:	60 e0       	ldi	r22, 0x00	; 0
    4d86:	70 e0       	ldi	r23, 0x00	; 0
    4d88:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
    4d8c:	8c 01       	movw	r16, r24
    4d8e:	2b ef       	ldi	r18, 0xFB	; 251
    4d90:	3f e0       	ldi	r19, 0x0F	; 15
    4d92:	2e 19       	sub	r18, r14
    4d94:	3f 09       	sbc	r19, r15
    4d96:	40 e0       	ldi	r20, 0x00	; 0
    4d98:	50 e0       	ldi	r21, 0x00	; 0
    4d9a:	c6 01       	movw	r24, r12
    4d9c:	65 e0       	ldi	r22, 0x05	; 5
    4d9e:	70 e0       	ldi	r23, 0x00	; 0
    4da0:	e6 0e       	add	r14, r22
    4da2:	f7 1e       	adc	r15, r23
    4da4:	b7 01       	movw	r22, r14
    4da6:	0e 94 43 26 	call	0x4c86	; 0x4c86 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    4daa:	1f 91       	pop	r17
    4dac:	0f 91       	pop	r16
    4dae:	ff 90       	pop	r15
    4db0:	ef 90       	pop	r14
    4db2:	df 90       	pop	r13
    4db4:	cf 90       	pop	r12
    4db6:	08 95       	ret

00004db8 <InterruInit>:
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    4db8:	78 94       	sei
}
    4dba:	08 95       	ret

00004dbc <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4dbc:	8f b7       	in	r24, 0x3f	; 63
    4dbe:	80 78       	andi	r24, 0x80	; 128
    4dc0:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    4dc4:	f8 94       	cli
	return interru_enub_flg;
}
    4dc6:	08 95       	ret

00004dc8 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4dc8:	80 91 fc 01 	lds	r24, 0x01FC
    4dcc:	88 23       	and	r24, r24
    4dce:	09 f0       	breq	.+2      	; 0x4dd2 <IntOn+0xa>
		sei();
    4dd0:	78 94       	sei
	return interru_enub_flg;
}
    4dd2:	08 95       	ret

00004dd4 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    4dd4:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    4dd6:	2f e0       	ldi	r18, 0x0F	; 15
    4dd8:	88 e1       	ldi	r24, 0x18	; 24
    4dda:	90 e0       	ldi	r25, 0x00	; 0
    4ddc:	0f b6       	in	r0, 0x3f	; 63
    4dde:	f8 94       	cli
    4de0:	a8 95       	wdr
    4de2:	81 bd       	out	0x21, r24	; 33
    4de4:	0f be       	out	0x3f, r0	; 63
    4de6:	21 bd       	out	0x21, r18	; 33
}
    4de8:	08 95       	ret

00004dea <Timer8Alloc>:

// ~~~~~~~~~~~~~~
uint8_t
Timer8Alloc(void)
{
	uint8_t N = VacantTimer8;
    4dea:	80 91 cb 01 	lds	r24, 0x01CB
	VacantTimer8++;
    4dee:	8f 5f       	subi	r24, 0xFF	; 255
    4df0:	80 93 cb 01 	sts	0x01CB, r24
    4df4:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4df6:	08 95       	ret

00004df8 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    4df8:	80 91 cc 01 	lds	r24, 0x01CC
	VacantTimer16++;
    4dfc:	8f 5f       	subi	r24, 0xFF	; 255
    4dfe:	80 93 cc 01 	sts	0x01CC, r24
    4e02:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4e04:	08 95       	ret

00004e06 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    4e06:	80 91 cd 01 	lds	r24, 0x01CD
	VacantTimer32++;
    4e0a:	8f 5f       	subi	r24, 0xFF	; 255
    4e0c:	80 93 cd 01 	sts	0x01CD, r24
    4e10:	81 50       	subi	r24, 0x01	; 1
	return N;
}
    4e12:	08 95       	ret

00004e14 <Timer8AppAlloc>:
// ~~~~~~~~~~~~~~
uint8_t
Timer8AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4e14:	88 23       	and	r24, r24
    4e16:	11 f4       	brne	.+4      	; 0x4e1c <Timer8AppAlloc+0x8>
    4e18:	90 e0       	ldi	r25, 0x00	; 0
    4e1a:	05 c0       	rjmp	.+10     	; 0x4e26 <Timer8AppAlloc+0x12>
	uint8_t N = VacantTimer8;
    4e1c:	90 91 cb 01 	lds	r25, 0x01CB
	VacantTimer8+=n;
    4e20:	89 0f       	add	r24, r25
    4e22:	80 93 cb 01 	sts	0x01CB, r24
	return N;
}
    4e26:	89 2f       	mov	r24, r25
    4e28:	08 95       	ret

00004e2a <Timer16AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4e2a:	88 23       	and	r24, r24
    4e2c:	11 f4       	brne	.+4      	; 0x4e32 <Timer16AppAlloc+0x8>
    4e2e:	90 e0       	ldi	r25, 0x00	; 0
    4e30:	05 c0       	rjmp	.+10     	; 0x4e3c <Timer16AppAlloc+0x12>
	uint8_t N = VacantTimer16;
    4e32:	90 91 cc 01 	lds	r25, 0x01CC
	VacantTimer16+=n;
    4e36:	89 0f       	add	r24, r25
    4e38:	80 93 cc 01 	sts	0x01CC, r24
	return N;
}
    4e3c:	89 2f       	mov	r24, r25
    4e3e:	08 95       	ret

00004e40 <Timer32AppAlloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32AppAlloc(uint8_t n)
{
	if(n==0)return 0;
    4e40:	88 23       	and	r24, r24
    4e42:	11 f4       	brne	.+4      	; 0x4e48 <Timer32AppAlloc+0x8>
    4e44:	90 e0       	ldi	r25, 0x00	; 0
    4e46:	05 c0       	rjmp	.+10     	; 0x4e52 <Timer32AppAlloc+0x12>
	uint8_t N = VacantTimer32;
    4e48:	90 91 cd 01 	lds	r25, 0x01CD
	VacantTimer32+=n;
    4e4c:	89 0f       	add	r24, r25
    4e4e:	80 93 cd 01 	sts	0x01CD, r24
	return N;
}
    4e52:	89 2f       	mov	r24, r25
    4e54:	08 95       	ret

00004e56 <Timer8SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    4e56:	90 91 ce 01 	lds	r25, 0x01CE
	VacantTimer8Sys += n;
    4e5a:	89 0f       	add	r24, r25
    4e5c:	80 93 ce 01 	sts	0x01CE, r24
	return N;
}
    4e60:	89 2f       	mov	r24, r25
    4e62:	08 95       	ret

00004e64 <Timer16SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    4e64:	90 91 cf 01 	lds	r25, 0x01CF
	VacantTimer16Sys += n;
    4e68:	89 0f       	add	r24, r25
    4e6a:	80 93 cf 01 	sts	0x01CF, r24
	return N;
}
    4e6e:	89 2f       	mov	r24, r25
    4e70:	08 95       	ret

00004e72 <Timer32SysAlloc>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    4e72:	90 91 d0 01 	lds	r25, 0x01D0
	VacantTimer32Sys += n;
    4e76:	89 0f       	add	r24, r25
    4e78:	80 93 d0 01 	sts	0x01D0, r24
	return N;
}
    4e7c:	89 2f       	mov	r24, r25
    4e7e:	08 95       	ret

00004e80 <StartTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4e80:	7f b7       	in	r23, 0x3f	; 63
    4e82:	70 78       	andi	r23, 0x80	; 128
    4e84:	70 93 fc 01 	sts	0x01FC, r23
	cli();
    4e88:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    4e8a:	28 2f       	mov	r18, r24
    4e8c:	30 e0       	ldi	r19, 0x00	; 0
    4e8e:	f9 01       	movw	r30, r18
    4e90:	e3 50       	subi	r30, 0x03	; 3
    4e92:	fe 4f       	sbci	r31, 0xFE	; 254
    4e94:	60 83       	st	Z, r22
    4e96:	90 81       	ld	r25, Z
    4e98:	86 95       	lsr	r24
    4e9a:	86 95       	lsr	r24
    4e9c:	86 95       	lsr	r24
    4e9e:	a9 01       	movw	r20, r18
    4ea0:	47 70       	andi	r20, 0x07	; 7
    4ea2:	50 70       	andi	r21, 0x00	; 0
    4ea4:	99 23       	and	r25, r25
    4ea6:	81 f0       	breq	.+32     	; 0x4ec8 <StartTimer8+0x48>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    4ea8:	e8 2f       	mov	r30, r24
    4eaa:	f0 e0       	ldi	r31, 0x00	; 0
    4eac:	eb 5c       	subi	r30, 0xCB	; 203
    4eae:	fc 4f       	sbci	r31, 0xFC	; 252
    4eb0:	20 81       	ld	r18, Z
    4eb2:	81 e0       	ldi	r24, 0x01	; 1
    4eb4:	90 e0       	ldi	r25, 0x00	; 0
    4eb6:	02 c0       	rjmp	.+4      	; 0x4ebc <StartTimer8+0x3c>
    4eb8:	88 0f       	add	r24, r24
    4eba:	99 1f       	adc	r25, r25
    4ebc:	4a 95       	dec	r20
    4ebe:	e2 f7       	brpl	.-8      	; 0x4eb8 <StartTimer8+0x38>
    4ec0:	80 95       	com	r24
    4ec2:	82 23       	and	r24, r18
    4ec4:	80 83       	st	Z, r24
    4ec6:	0e c0       	rjmp	.+28     	; 0x4ee4 <StartTimer8+0x64>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    4ec8:	e8 2f       	mov	r30, r24
    4eca:	f0 e0       	ldi	r31, 0x00	; 0
    4ecc:	eb 5c       	subi	r30, 0xCB	; 203
    4ece:	fc 4f       	sbci	r31, 0xFC	; 252
    4ed0:	20 81       	ld	r18, Z
    4ed2:	81 e0       	ldi	r24, 0x01	; 1
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	02 c0       	rjmp	.+4      	; 0x4edc <StartTimer8+0x5c>
    4ed8:	88 0f       	add	r24, r24
    4eda:	99 1f       	adc	r25, r25
    4edc:	4a 95       	dec	r20
    4ede:	e2 f7       	brpl	.-8      	; 0x4ed8 <StartTimer8+0x58>
    4ee0:	28 2b       	or	r18, r24
    4ee2:	20 83       	st	Z, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4ee4:	77 23       	and	r23, r23
    4ee6:	09 f0       	breq	.+2      	; 0x4eea <StartTimer8+0x6a>
		sei();
    4ee8:	78 94       	sei
    4eea:	08 95       	ret

00004eec <StartTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4eec:	af b7       	in	r26, 0x3f	; 63
    4eee:	a0 78       	andi	r26, 0x80	; 128
    4ef0:	a0 93 fc 01 	sts	0x01FC, r26
	cli();
    4ef4:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    4ef6:	48 2f       	mov	r20, r24
    4ef8:	50 e0       	ldi	r21, 0x00	; 0
    4efa:	fa 01       	movw	r30, r20
    4efc:	ee 0f       	add	r30, r30
    4efe:	ff 1f       	adc	r31, r31
    4f00:	eb 5d       	subi	r30, 0xDB	; 219
    4f02:	fd 4f       	sbci	r31, 0xFD	; 253
    4f04:	71 83       	std	Z+1, r23	; 0x01
    4f06:	60 83       	st	Z, r22
    4f08:	20 81       	ld	r18, Z
    4f0a:	31 81       	ldd	r19, Z+1	; 0x01
    4f0c:	86 95       	lsr	r24
    4f0e:	86 95       	lsr	r24
    4f10:	86 95       	lsr	r24
    4f12:	47 70       	andi	r20, 0x07	; 7
    4f14:	50 70       	andi	r21, 0x00	; 0
    4f16:	23 2b       	or	r18, r19
    4f18:	81 f0       	breq	.+32     	; 0x4f3a <StartTimer16+0x4e>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    4f1a:	e8 2f       	mov	r30, r24
    4f1c:	f0 e0       	ldi	r31, 0x00	; 0
    4f1e:	e5 5c       	subi	r30, 0xC5	; 197
    4f20:	fc 4f       	sbci	r31, 0xFC	; 252
    4f22:	20 81       	ld	r18, Z
    4f24:	81 e0       	ldi	r24, 0x01	; 1
    4f26:	90 e0       	ldi	r25, 0x00	; 0
    4f28:	02 c0       	rjmp	.+4      	; 0x4f2e <StartTimer16+0x42>
    4f2a:	88 0f       	add	r24, r24
    4f2c:	99 1f       	adc	r25, r25
    4f2e:	4a 95       	dec	r20
    4f30:	e2 f7       	brpl	.-8      	; 0x4f2a <StartTimer16+0x3e>
    4f32:	80 95       	com	r24
    4f34:	82 23       	and	r24, r18
    4f36:	80 83       	st	Z, r24
    4f38:	0e c0       	rjmp	.+28     	; 0x4f56 <StartTimer16+0x6a>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    4f3a:	e8 2f       	mov	r30, r24
    4f3c:	f0 e0       	ldi	r31, 0x00	; 0
    4f3e:	e5 5c       	subi	r30, 0xC5	; 197
    4f40:	fc 4f       	sbci	r31, 0xFC	; 252
    4f42:	20 81       	ld	r18, Z
    4f44:	81 e0       	ldi	r24, 0x01	; 1
    4f46:	90 e0       	ldi	r25, 0x00	; 0
    4f48:	02 c0       	rjmp	.+4      	; 0x4f4e <StartTimer16+0x62>
    4f4a:	88 0f       	add	r24, r24
    4f4c:	99 1f       	adc	r25, r25
    4f4e:	4a 95       	dec	r20
    4f50:	e2 f7       	brpl	.-8      	; 0x4f4a <StartTimer16+0x5e>
    4f52:	28 2b       	or	r18, r24
    4f54:	20 83       	st	Z, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4f56:	aa 23       	and	r26, r26
    4f58:	09 f0       	breq	.+2      	; 0x4f5c <StartTimer16+0x70>
		sei();
    4f5a:	78 94       	sei
    4f5c:	08 95       	ret

00004f5e <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    4f5e:	1f 93       	push	r17

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4f60:	1f b7       	in	r17, 0x3f	; 63
    4f62:	10 78       	andi	r17, 0x80	; 128
    4f64:	10 93 fc 01 	sts	0x01FC, r17
	cli();
    4f68:	f8 94       	cli
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    4f6a:	a8 2f       	mov	r26, r24
    4f6c:	b0 e0       	ldi	r27, 0x00	; 0
    4f6e:	fd 01       	movw	r30, r26
    4f70:	ee 0f       	add	r30, r30
    4f72:	ff 1f       	adc	r31, r31
    4f74:	ee 0f       	add	r30, r30
    4f76:	ff 1f       	adc	r31, r31
    4f78:	eb 56       	subi	r30, 0x6B	; 107
    4f7a:	fd 4f       	sbci	r31, 0xFD	; 253
    4f7c:	40 83       	st	Z, r20
    4f7e:	51 83       	std	Z+1, r21	; 0x01
    4f80:	62 83       	std	Z+2, r22	; 0x02
    4f82:	73 83       	std	Z+3, r23	; 0x03
    4f84:	20 81       	ld	r18, Z
    4f86:	31 81       	ldd	r19, Z+1	; 0x01
    4f88:	42 81       	ldd	r20, Z+2	; 0x02
    4f8a:	53 81       	ldd	r21, Z+3	; 0x03
    4f8c:	86 95       	lsr	r24
    4f8e:	86 95       	lsr	r24
    4f90:	86 95       	lsr	r24
    4f92:	a7 70       	andi	r26, 0x07	; 7
    4f94:	b0 70       	andi	r27, 0x00	; 0
    4f96:	21 15       	cp	r18, r1
    4f98:	31 05       	cpc	r19, r1
    4f9a:	41 05       	cpc	r20, r1
    4f9c:	51 05       	cpc	r21, r1
    4f9e:	81 f0       	breq	.+32     	; 0x4fc0 <StartTimer32+0x62>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    4fa0:	e8 2f       	mov	r30, r24
    4fa2:	f0 e0       	ldi	r31, 0x00	; 0
    4fa4:	ed 5b       	subi	r30, 0xBD	; 189
    4fa6:	fc 4f       	sbci	r31, 0xFC	; 252
    4fa8:	20 81       	ld	r18, Z
    4faa:	81 e0       	ldi	r24, 0x01	; 1
    4fac:	90 e0       	ldi	r25, 0x00	; 0
    4fae:	02 c0       	rjmp	.+4      	; 0x4fb4 <StartTimer32+0x56>
    4fb0:	88 0f       	add	r24, r24
    4fb2:	99 1f       	adc	r25, r25
    4fb4:	aa 95       	dec	r26
    4fb6:	e2 f7       	brpl	.-8      	; 0x4fb0 <StartTimer32+0x52>
    4fb8:	80 95       	com	r24
    4fba:	82 23       	and	r24, r18
    4fbc:	80 83       	st	Z, r24
    4fbe:	0e c0       	rjmp	.+28     	; 0x4fdc <StartTimer32+0x7e>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    4fc0:	e8 2f       	mov	r30, r24
    4fc2:	f0 e0       	ldi	r31, 0x00	; 0
    4fc4:	ed 5b       	subi	r30, 0xBD	; 189
    4fc6:	fc 4f       	sbci	r31, 0xFC	; 252
    4fc8:	20 81       	ld	r18, Z
    4fca:	81 e0       	ldi	r24, 0x01	; 1
    4fcc:	90 e0       	ldi	r25, 0x00	; 0
    4fce:	02 c0       	rjmp	.+4      	; 0x4fd4 <StartTimer32+0x76>
    4fd0:	88 0f       	add	r24, r24
    4fd2:	99 1f       	adc	r25, r25
    4fd4:	aa 95       	dec	r26
    4fd6:	e2 f7       	brpl	.-8      	; 0x4fd0 <StartTimer32+0x72>
    4fd8:	28 2b       	or	r18, r24
    4fda:	20 83       	st	Z, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    4fdc:	11 23       	and	r17, r17
    4fde:	09 f0       	breq	.+2      	; 0x4fe2 <StartTimer32+0x84>
		sei();
    4fe0:	78 94       	sei
	IntOn();
}
    4fe2:	1f 91       	pop	r17
    4fe4:	08 95       	ret

00004fe6 <StopTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    4fe6:	4f b7       	in	r20, 0x3f	; 63
    4fe8:	40 78       	andi	r20, 0x80	; 128
    4fea:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    4fee:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    4ff0:	e8 2f       	mov	r30, r24
    4ff2:	e6 95       	lsr	r30
    4ff4:	e6 95       	lsr	r30
    4ff6:	e6 95       	lsr	r30
    4ff8:	f0 e0       	ldi	r31, 0x00	; 0
    4ffa:	eb 5c       	subi	r30, 0xCB	; 203
    4ffc:	fc 4f       	sbci	r31, 0xFC	; 252
    4ffe:	90 81       	ld	r25, Z
    5000:	87 70       	andi	r24, 0x07	; 7
    5002:	21 e0       	ldi	r18, 0x01	; 1
    5004:	30 e0       	ldi	r19, 0x00	; 0
    5006:	02 c0       	rjmp	.+4      	; 0x500c <StopTimer8+0x26>
    5008:	22 0f       	add	r18, r18
    500a:	33 1f       	adc	r19, r19
    500c:	8a 95       	dec	r24
    500e:	e2 f7       	brpl	.-8      	; 0x5008 <StopTimer8+0x22>
    5010:	92 2b       	or	r25, r18
    5012:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5014:	44 23       	and	r20, r20
    5016:	09 f0       	breq	.+2      	; 0x501a <StopTimer8+0x34>
		sei();
    5018:	78 94       	sei
    501a:	08 95       	ret

0000501c <StopTimer16>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    501c:	4f b7       	in	r20, 0x3f	; 63
    501e:	40 78       	andi	r20, 0x80	; 128
    5020:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    5024:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    5026:	e8 2f       	mov	r30, r24
    5028:	e6 95       	lsr	r30
    502a:	e6 95       	lsr	r30
    502c:	e6 95       	lsr	r30
    502e:	f0 e0       	ldi	r31, 0x00	; 0
    5030:	e5 5c       	subi	r30, 0xC5	; 197
    5032:	fc 4f       	sbci	r31, 0xFC	; 252
    5034:	90 81       	ld	r25, Z
    5036:	87 70       	andi	r24, 0x07	; 7
    5038:	21 e0       	ldi	r18, 0x01	; 1
    503a:	30 e0       	ldi	r19, 0x00	; 0
    503c:	02 c0       	rjmp	.+4      	; 0x5042 <StopTimer16+0x26>
    503e:	22 0f       	add	r18, r18
    5040:	33 1f       	adc	r19, r19
    5042:	8a 95       	dec	r24
    5044:	e2 f7       	brpl	.-8      	; 0x503e <StopTimer16+0x22>
    5046:	92 2b       	or	r25, r18
    5048:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    504a:	44 23       	and	r20, r20
    504c:	09 f0       	breq	.+2      	; 0x5050 <StopTimer16+0x34>
		sei();
    504e:	78 94       	sei
    5050:	08 95       	ret

00005052 <StopTimer32>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5052:	4f b7       	in	r20, 0x3f	; 63
    5054:	40 78       	andi	r20, 0x80	; 128
    5056:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    505a:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
StopTimer32(uint8_t TimerN)
{
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    505c:	e8 2f       	mov	r30, r24
    505e:	e6 95       	lsr	r30
    5060:	e6 95       	lsr	r30
    5062:	e6 95       	lsr	r30
    5064:	f0 e0       	ldi	r31, 0x00	; 0
    5066:	ed 5b       	subi	r30, 0xBD	; 189
    5068:	fc 4f       	sbci	r31, 0xFC	; 252
    506a:	90 81       	ld	r25, Z
    506c:	87 70       	andi	r24, 0x07	; 7
    506e:	21 e0       	ldi	r18, 0x01	; 1
    5070:	30 e0       	ldi	r19, 0x00	; 0
    5072:	02 c0       	rjmp	.+4      	; 0x5078 <StopTimer32+0x26>
    5074:	22 0f       	add	r18, r18
    5076:	33 1f       	adc	r19, r19
    5078:	8a 95       	dec	r24
    507a:	e2 f7       	brpl	.-8      	; 0x5074 <StopTimer32+0x22>
    507c:	92 2b       	or	r25, r18
    507e:	90 83       	st	Z, r25

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5080:	44 23       	and	r20, r20
    5082:	09 f0       	breq	.+2      	; 0x5086 <StopTimer32+0x34>
		sei();
    5084:	78 94       	sei
    5086:	08 95       	ret

00005088 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    5088:	e8 2f       	mov	r30, r24
    508a:	e6 95       	lsr	r30
    508c:	e6 95       	lsr	r30
    508e:	e6 95       	lsr	r30
    5090:	f0 e0       	ldi	r31, 0x00	; 0
    5092:	eb 5c       	subi	r30, 0xCB	; 203
    5094:	fc 4f       	sbci	r31, 0xFC	; 252
    5096:	20 81       	ld	r18, Z
    5098:	e8 2f       	mov	r30, r24
    509a:	f0 e0       	ldi	r31, 0x00	; 0
    509c:	30 e0       	ldi	r19, 0x00	; 0
    509e:	cf 01       	movw	r24, r30
    50a0:	87 70       	andi	r24, 0x07	; 7
    50a2:	90 70       	andi	r25, 0x00	; 0
    50a4:	02 c0       	rjmp	.+4      	; 0x50aa <Timer8Stopp+0x22>
    50a6:	35 95       	asr	r19
    50a8:	27 95       	ror	r18
    50aa:	8a 95       	dec	r24
    50ac:	e2 f7       	brpl	.-8      	; 0x50a6 <Timer8Stopp+0x1e>
    50ae:	20 fd       	sbrc	r18, 0
    50b0:	03 c0       	rjmp	.+6      	; 0x50b8 <Timer8Stopp+0x30>
    50b2:	80 e0       	ldi	r24, 0x00	; 0
    50b4:	90 e0       	ldi	r25, 0x00	; 0
    50b6:	08 95       	ret
    50b8:	e3 50       	subi	r30, 0x03	; 3
    50ba:	fe 4f       	sbci	r31, 0xFE	; 254
    50bc:	80 81       	ld	r24, Z
    50be:	20 e0       	ldi	r18, 0x00	; 0
    50c0:	81 11       	cpse	r24, r1
    50c2:	21 e0       	ldi	r18, 0x01	; 1
    50c4:	81 e0       	ldi	r24, 0x01	; 1
    50c6:	28 27       	eor	r18, r24
    50c8:	82 2f       	mov	r24, r18
}
    50ca:	08 95       	ret

000050cc <Timer16Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    50cc:	4f b7       	in	r20, 0x3f	; 63
    50ce:	40 78       	andi	r20, 0x80	; 128
    50d0:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    50d4:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    50d6:	e8 2f       	mov	r30, r24
    50d8:	e6 95       	lsr	r30
    50da:	e6 95       	lsr	r30
    50dc:	e6 95       	lsr	r30
    50de:	f0 e0       	ldi	r31, 0x00	; 0
    50e0:	e5 5c       	subi	r30, 0xC5	; 197
    50e2:	fc 4f       	sbci	r31, 0xFC	; 252
    50e4:	20 81       	ld	r18, Z
    50e6:	e8 2f       	mov	r30, r24
    50e8:	f0 e0       	ldi	r31, 0x00	; 0
    50ea:	30 e0       	ldi	r19, 0x00	; 0
    50ec:	cf 01       	movw	r24, r30
    50ee:	87 70       	andi	r24, 0x07	; 7
    50f0:	90 70       	andi	r25, 0x00	; 0
    50f2:	02 c0       	rjmp	.+4      	; 0x50f8 <Timer16Stopp+0x2c>
    50f4:	35 95       	asr	r19
    50f6:	27 95       	ror	r18
    50f8:	8a 95       	dec	r24
    50fa:	e2 f7       	brpl	.-8      	; 0x50f4 <Timer16Stopp+0x28>
    50fc:	20 fd       	sbrc	r18, 0
    50fe:	03 c0       	rjmp	.+6      	; 0x5106 <Timer16Stopp+0x3a>
    5100:	80 e0       	ldi	r24, 0x00	; 0
    5102:	90 e0       	ldi	r25, 0x00	; 0
    5104:	0d c0       	rjmp	.+26     	; 0x5120 <Timer16Stopp+0x54>
    5106:	ee 0f       	add	r30, r30
    5108:	ff 1f       	adc	r31, r31
    510a:	eb 5d       	subi	r30, 0xDB	; 219
    510c:	fd 4f       	sbci	r31, 0xFD	; 253
    510e:	80 81       	ld	r24, Z
    5110:	91 81       	ldd	r25, Z+1	; 0x01
    5112:	20 e0       	ldi	r18, 0x00	; 0
    5114:	89 2b       	or	r24, r25
    5116:	09 f0       	breq	.+2      	; 0x511a <Timer16Stopp+0x4e>
    5118:	21 e0       	ldi	r18, 0x01	; 1
    511a:	81 e0       	ldi	r24, 0x01	; 1
    511c:	28 27       	eor	r18, r24
    511e:	82 2f       	mov	r24, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5120:	44 23       	and	r20, r20
    5122:	09 f0       	breq	.+2      	; 0x5126 <Timer16Stopp+0x5a>
		sei();
    5124:	78 94       	sei
	IntOn();
	return T_S;
}
    5126:	08 95       	ret

00005128 <Timer32Stopp>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5128:	4f b7       	in	r20, 0x3f	; 63
    512a:	40 78       	andi	r20, 0x80	; 128
    512c:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    5130:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
	IntOff();
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    5132:	e8 2f       	mov	r30, r24
    5134:	e6 95       	lsr	r30
    5136:	e6 95       	lsr	r30
    5138:	e6 95       	lsr	r30
    513a:	f0 e0       	ldi	r31, 0x00	; 0
    513c:	ed 5b       	subi	r30, 0xBD	; 189
    513e:	fc 4f       	sbci	r31, 0xFC	; 252
    5140:	20 81       	ld	r18, Z
    5142:	e8 2f       	mov	r30, r24
    5144:	f0 e0       	ldi	r31, 0x00	; 0
    5146:	30 e0       	ldi	r19, 0x00	; 0
    5148:	cf 01       	movw	r24, r30
    514a:	87 70       	andi	r24, 0x07	; 7
    514c:	90 70       	andi	r25, 0x00	; 0
    514e:	02 c0       	rjmp	.+4      	; 0x5154 <Timer32Stopp+0x2c>
    5150:	35 95       	asr	r19
    5152:	27 95       	ror	r18
    5154:	8a 95       	dec	r24
    5156:	e2 f7       	brpl	.-8      	; 0x5150 <Timer32Stopp+0x28>
    5158:	20 fd       	sbrc	r18, 0
    515a:	03 c0       	rjmp	.+6      	; 0x5162 <Timer32Stopp+0x3a>
    515c:	80 e0       	ldi	r24, 0x00	; 0
    515e:	90 e0       	ldi	r25, 0x00	; 0
    5160:	13 c0       	rjmp	.+38     	; 0x5188 <Timer32Stopp+0x60>
    5162:	ee 0f       	add	r30, r30
    5164:	ff 1f       	adc	r31, r31
    5166:	ee 0f       	add	r30, r30
    5168:	ff 1f       	adc	r31, r31
    516a:	eb 56       	subi	r30, 0x6B	; 107
    516c:	fd 4f       	sbci	r31, 0xFD	; 253
    516e:	80 81       	ld	r24, Z
    5170:	91 81       	ldd	r25, Z+1	; 0x01
    5172:	a2 81       	ldd	r26, Z+2	; 0x02
    5174:	b3 81       	ldd	r27, Z+3	; 0x03
    5176:	20 e0       	ldi	r18, 0x00	; 0
    5178:	00 97       	sbiw	r24, 0x00	; 0
    517a:	a1 05       	cpc	r26, r1
    517c:	b1 05       	cpc	r27, r1
    517e:	09 f0       	breq	.+2      	; 0x5182 <Timer32Stopp+0x5a>
    5180:	21 e0       	ldi	r18, 0x01	; 1
    5182:	81 e0       	ldi	r24, 0x01	; 1
    5184:	28 27       	eor	r18, r24
    5186:	82 2f       	mov	r24, r18

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5188:	44 23       	and	r20, r20
    518a:	09 f0       	breq	.+2      	; 0x518e <Timer32Stopp+0x66>
		sei();
    518c:	78 94       	sei
	IntOn();
	return T_S;
}
    518e:	08 95       	ret

00005190 <ResetTimer8>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5190:	5f b7       	in	r21, 0x3f	; 63
    5192:	50 78       	andi	r21, 0x80	; 128
    5194:	50 93 fc 01 	sts	0x01FC, r21
	cli();
    5198:	f8 94       	cli
//~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer8(uint8_t TimerN)
{
	IntOff();
	Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    519a:	e8 2f       	mov	r30, r24
    519c:	e6 95       	lsr	r30
    519e:	e6 95       	lsr	r30
    51a0:	e6 95       	lsr	r30
    51a2:	f0 e0       	ldi	r31, 0x00	; 0
    51a4:	eb 5c       	subi	r30, 0xCB	; 203
    51a6:	fc 4f       	sbci	r31, 0xFC	; 252
    51a8:	40 81       	ld	r20, Z
    51aa:	a8 2f       	mov	r26, r24
    51ac:	b0 e0       	ldi	r27, 0x00	; 0
    51ae:	9d 01       	movw	r18, r26
    51b0:	27 70       	andi	r18, 0x07	; 7
    51b2:	30 70       	andi	r19, 0x00	; 0
    51b4:	81 e0       	ldi	r24, 0x01	; 1
    51b6:	90 e0       	ldi	r25, 0x00	; 0
    51b8:	02 c0       	rjmp	.+4      	; 0x51be <ResetTimer8+0x2e>
    51ba:	88 0f       	add	r24, r24
    51bc:	99 1f       	adc	r25, r25
    51be:	2a 95       	dec	r18
    51c0:	e2 f7       	brpl	.-8      	; 0x51ba <ResetTimer8+0x2a>
    51c2:	48 2b       	or	r20, r24
    51c4:	40 83       	st	Z, r20

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    51c6:	55 23       	and	r21, r21
    51c8:	09 f0       	breq	.+2      	; 0x51cc <ResetTimer8+0x3c>
		sei();
    51ca:	78 94       	sei
	IntOn();
	Timer8[TimerN] = 0;
    51cc:	a3 50       	subi	r26, 0x03	; 3
    51ce:	be 4f       	sbci	r27, 0xFE	; 254
    51d0:	1c 92       	st	X, r1
}
    51d2:	08 95       	ret

000051d4 <ResetTimer16>:

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    51d4:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    51d6:	5f b7       	in	r21, 0x3f	; 63
    51d8:	50 78       	andi	r21, 0x80	; 128
    51da:	50 93 fc 01 	sts	0x01FC, r21
	cli();
    51de:	f8 94       	cli
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    51e0:	a8 2f       	mov	r26, r24
    51e2:	a6 95       	lsr	r26
    51e4:	a6 95       	lsr	r26
    51e6:	a6 95       	lsr	r26
    51e8:	b0 e0       	ldi	r27, 0x00	; 0
    51ea:	a5 5c       	subi	r26, 0xC5	; 197
    51ec:	bc 4f       	sbci	r27, 0xFC	; 252
    51ee:	4c 91       	ld	r20, X
    51f0:	f0 e0       	ldi	r31, 0x00	; 0
    51f2:	9f 01       	movw	r18, r30
    51f4:	27 70       	andi	r18, 0x07	; 7
    51f6:	30 70       	andi	r19, 0x00	; 0
    51f8:	81 e0       	ldi	r24, 0x01	; 1
    51fa:	90 e0       	ldi	r25, 0x00	; 0
    51fc:	02 c0       	rjmp	.+4      	; 0x5202 <ResetTimer16+0x2e>
    51fe:	88 0f       	add	r24, r24
    5200:	99 1f       	adc	r25, r25
    5202:	2a 95       	dec	r18
    5204:	e2 f7       	brpl	.-8      	; 0x51fe <ResetTimer16+0x2a>
    5206:	48 2b       	or	r20, r24
    5208:	4c 93       	st	X, r20
	Timer16[TimerN] = 0;
    520a:	ee 0f       	add	r30, r30
    520c:	ff 1f       	adc	r31, r31
    520e:	eb 5d       	subi	r30, 0xDB	; 219
    5210:	fd 4f       	sbci	r31, 0xFD	; 253
    5212:	11 82       	std	Z+1, r1	; 0x01
    5214:	10 82       	st	Z, r1

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5216:	55 23       	and	r21, r21
    5218:	09 f0       	breq	.+2      	; 0x521c <ResetTimer16+0x48>
		sei();
    521a:	78 94       	sei
    521c:	08 95       	ret

0000521e <ResetTimer32>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer32(uint8_t TimerN)
{
    521e:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5220:	5f b7       	in	r21, 0x3f	; 63
    5222:	50 78       	andi	r21, 0x80	; 128
    5224:	50 93 fc 01 	sts	0x01FC, r21
	cli();
    5228:	f8 94       	cli
	IntOff();
	Timer32Flg[TimerN/8] |=1<<TimerN%8;
    522a:	a8 2f       	mov	r26, r24
    522c:	a6 95       	lsr	r26
    522e:	a6 95       	lsr	r26
    5230:	a6 95       	lsr	r26
    5232:	b0 e0       	ldi	r27, 0x00	; 0
    5234:	ad 5b       	subi	r26, 0xBD	; 189
    5236:	bc 4f       	sbci	r27, 0xFC	; 252
    5238:	4c 91       	ld	r20, X
    523a:	f0 e0       	ldi	r31, 0x00	; 0
    523c:	9f 01       	movw	r18, r30
    523e:	27 70       	andi	r18, 0x07	; 7
    5240:	30 70       	andi	r19, 0x00	; 0
    5242:	81 e0       	ldi	r24, 0x01	; 1
    5244:	90 e0       	ldi	r25, 0x00	; 0
    5246:	02 c0       	rjmp	.+4      	; 0x524c <ResetTimer32+0x2e>
    5248:	88 0f       	add	r24, r24
    524a:	99 1f       	adc	r25, r25
    524c:	2a 95       	dec	r18
    524e:	e2 f7       	brpl	.-8      	; 0x5248 <ResetTimer32+0x2a>
    5250:	48 2b       	or	r20, r24
    5252:	4c 93       	st	X, r20
	Timer32[TimerN] = 0;
    5254:	ee 0f       	add	r30, r30
    5256:	ff 1f       	adc	r31, r31
    5258:	ee 0f       	add	r30, r30
    525a:	ff 1f       	adc	r31, r31
    525c:	eb 56       	subi	r30, 0x6B	; 107
    525e:	fd 4f       	sbci	r31, 0xFD	; 253
    5260:	10 82       	st	Z, r1
    5262:	11 82       	std	Z+1, r1	; 0x01
    5264:	12 82       	std	Z+2, r1	; 0x02
    5266:	13 82       	std	Z+3, r1	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5268:	55 23       	and	r21, r21
    526a:	09 f0       	breq	.+2      	; 0x526e <ResetTimer32+0x50>
		sei();
    526c:	78 94       	sei
    526e:	08 95       	ret

00005270 <GetTimer8>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
GetTimer8(uint8_t TimerN)
{
	return Timer8[TimerN];
    5270:	ed ef       	ldi	r30, 0xFD	; 253
    5272:	f1 e0       	ldi	r31, 0x01	; 1
    5274:	e8 0f       	add	r30, r24
    5276:	f1 1d       	adc	r31, r1
    5278:	80 81       	ld	r24, Z
}
    527a:	08 95       	ret

0000527c <GetTimer16>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
    527c:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    527e:	8f b7       	in	r24, 0x3f	; 63
    5280:	80 78       	andi	r24, 0x80	; 128
    5282:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    5286:	f8 94       	cli
	IntOff();
	uint16_t Time = Timer16[TimerN];
    5288:	f0 e0       	ldi	r31, 0x00	; 0
    528a:	ee 0f       	add	r30, r30
    528c:	ff 1f       	adc	r31, r31
    528e:	eb 5d       	subi	r30, 0xDB	; 219
    5290:	fd 4f       	sbci	r31, 0xFD	; 253
    5292:	01 90       	ld	r0, Z+
    5294:	f0 81       	ld	r31, Z
    5296:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5298:	88 23       	and	r24, r24
    529a:	09 f0       	breq	.+2      	; 0x529e <GetTimer16+0x22>
		sei();
    529c:	78 94       	sei
	IntOn();
	return Time;
}
    529e:	cf 01       	movw	r24, r30
    52a0:	08 95       	ret

000052a2 <GetTimer32>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
    52a2:	e8 2f       	mov	r30, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    52a4:	8f b7       	in	r24, 0x3f	; 63
    52a6:	80 78       	andi	r24, 0x80	; 128
    52a8:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    52ac:	f8 94       	cli
	IntOff();
	uint32_t Time = Timer32[TimerN];
    52ae:	f0 e0       	ldi	r31, 0x00	; 0
    52b0:	ee 0f       	add	r30, r30
    52b2:	ff 1f       	adc	r31, r31
    52b4:	ee 0f       	add	r30, r30
    52b6:	ff 1f       	adc	r31, r31
    52b8:	eb 56       	subi	r30, 0x6B	; 107
    52ba:	fd 4f       	sbci	r31, 0xFD	; 253
    52bc:	20 81       	ld	r18, Z
    52be:	31 81       	ldd	r19, Z+1	; 0x01
    52c0:	42 81       	ldd	r20, Z+2	; 0x02
    52c2:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    52c4:	88 23       	and	r24, r24
    52c6:	09 f0       	breq	.+2      	; 0x52ca <GetTimer32+0x28>
		sei();
    52c8:	78 94       	sei
	IntOn();
	return Time;
}
    52ca:	b9 01       	movw	r22, r18
    52cc:	ca 01       	movw	r24, r20
    52ce:	08 95       	ret

000052d0 <ScanCycleInit>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    52d0:	80 91 ce 01 	lds	r24, 0x01CE
	VacantTimer8Sys += n;
    52d4:	8f 5f       	subi	r24, 0xFF	; 255
    52d6:	80 93 ce 01 	sts	0x01CE, r24
    52da:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    52dc:	80 93 49 03 	sts	0x0349, r24
	StartTimer8(TD_Scan, 0xFF);
    52e0:	6f ef       	ldi	r22, 0xFF	; 255
    52e2:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
}
    52e6:	08 95       	ret

000052e8 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    52e8:	a8 95       	wdr

	// Scan cycle
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    52ea:	90 91 49 03 	lds	r25, 0x0349
    52ee:	e9 2f       	mov	r30, r25
    52f0:	f0 e0       	ldi	r31, 0x00	; 0
    52f2:	e3 50       	subi	r30, 0x03	; 3
    52f4:	fe 4f       	sbci	r31, 0xFE	; 254
    52f6:	e0 81       	ld	r30, Z
    52f8:	e0 95       	com	r30
    52fa:	e0 93 af 08 	sts	0x08AF, r30
    52fe:	80 91 a1 05 	lds	r24, 0x05A1
    5302:	8e 17       	cp	r24, r30
    5304:	10 f4       	brcc	.+4      	; 0x530a <TimeCycle+0x22>
		MaxScanCycle = ScanCycle;
    5306:	e0 93 a1 05 	sts	0x05A1, r30
	StartTimer8(TD_Scan, 0xFF);
    530a:	89 2f       	mov	r24, r25
    530c:	6f ef       	ldi	r22, 0xFF	; 255
    530e:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
}
    5312:	08 95       	ret

00005314 <MaxScanCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MaxScanCycle_Clear(void)
{
	MaxScanCycle = 0;
    5314:	10 92 a1 05 	sts	0x05A1, r1
}
    5318:	08 95       	ret

0000531a <Delay_ms>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    531a:	20 ea       	ldi	r18, 0xA0	; 160
    531c:	3f e0       	ldi	r19, 0x0F	; 15
    531e:	04 c0       	rjmp	.+8      	; 0x5328 <Delay_ms+0xe>
    5320:	f9 01       	movw	r30, r18
    5322:	31 97       	sbiw	r30, 0x01	; 1
    5324:	f1 f7       	brne	.-4      	; 0x5322 <Delay_ms+0x8>
    5326:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~
void
Delay_ms(uint8_t Delay)
{
	while (Delay--)
    5328:	88 23       	and	r24, r24
    532a:	d1 f7       	brne	.-12     	; 0x5320 <Delay_ms+0x6>
		_delay_ms(1);
}
    532c:	08 95       	ret

0000532e <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    532e:	a0 e0       	ldi	r26, 0x00	; 0
    5330:	b0 e0       	ldi	r27, 0x00	; 0
    5332:	bc 01       	movw	r22, r24
    5334:	cd 01       	movw	r24, r26
    5336:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__floatunsisf>
    533a:	2d ec       	ldi	r18, 0xCD	; 205
    533c:	3c ec       	ldi	r19, 0xCC	; 204
    533e:	4c e4       	ldi	r20, 0x4C	; 76
    5340:	5f e3       	ldi	r21, 0x3F	; 63
    5342:	0e 94 61 8a 	call	0x114c2	; 0x114c2 <__mulsf3>
    5346:	0e 94 a7 89 	call	0x1134e	; 0x1134e <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    534a:	95 e0       	ldi	r25, 0x05	; 5
    534c:	05 c0       	rjmp	.+10     	; 0x5358 <Delay_us+0x2a>
    534e:	89 2f       	mov	r24, r25
    5350:	8a 95       	dec	r24
    5352:	f1 f7       	brne	.-4      	; 0x5350 <Delay_us+0x22>
    5354:	61 50       	subi	r22, 0x01	; 1
    5356:	70 40       	sbci	r23, 0x00	; 0
	while (Delay--)
    5358:	61 15       	cp	r22, r1
    535a:	71 05       	cpc	r23, r1
    535c:	c1 f7       	brne	.-16     	; 0x534e <Delay_us+0x20>
		_delay_us(1);
}
    535e:	08 95       	ret

00005360 <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5360:	8c 9a       	sbi	0x11, 4	; 17
    5362:	94 98       	cbi	0x12, 4	; 18
}
    5364:	08 95       	ret

00005366 <RS485_0>:

void RS485_0(void) {}
    5366:	08 95       	ret

00005368 <RS485_1>:
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5368:	82 b3       	in	r24, 0x12	; 18
    536a:	90 e1       	ldi	r25, 0x10	; 16
    536c:	89 27       	eor	r24, r25
    536e:	82 bb       	out	0x12, r24	; 18
    5370:	08 95       	ret

00005372 <MB_LED0>:

void MB_LED0(void) {}
    5372:	08 95       	ret

00005374 <MB_LED1>:
void MB_LED1(void) {}
    5374:	08 95       	ret

00005376 <MB_LED_Err_On_0>:

void MB_LED_Err_On_0(void)	{}
    5376:	08 95       	ret

00005378 <MB_LED_Err_Off_0>:
void MB_LED_Err_Off_0(void)	{}
    5378:	08 95       	ret

0000537a <MB_LED_Err_On_1>:
void MB_LED_Err_On_1(void)	{}
    537a:	08 95       	ret

0000537c <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    537c:	08 95       	ret

0000537e <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    537e:	88 23       	and	r24, r24
    5380:	51 f4       	brne	.+20     	; 0x5396 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5382:	80 91 64 00 	lds	r24, 0x0064
    5386:	81 60       	ori	r24, 0x01	; 1
    5388:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    538c:	80 91 65 00 	lds	r24, 0x0065
    5390:	8e 7f       	andi	r24, 0xFE	; 254
    5392:	80 93 65 00 	sts	0x0065, r24
    5396:	08 95       	ret

00005398 <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5398:	88 23       	and	r24, r24
    539a:	51 f4       	brne	.+20     	; 0x53b0 <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    539c:	80 91 64 00 	lds	r24, 0x0064
    53a0:	8e 7f       	andi	r24, 0xFE	; 254
    53a2:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    53a6:	80 91 65 00 	lds	r24, 0x0065
    53aa:	8e 7f       	andi	r24, 0xFE	; 254
    53ac:	80 93 65 00 	sts	0x0065, r24
    53b0:	08 95       	ret

000053b2 <OW_MasterReadBus>:
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    53b2:	80 91 63 00 	lds	r24, 0x0063
	}
}
    53b6:	81 70       	andi	r24, 0x01	; 1
    53b8:	08 95       	ret

000053ba <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    53ba:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    53bc:	17 9a       	sbi	0x02, 7	; 2
	sei();
    53be:	78 94       	sei
}
    53c0:	08 95       	ret

000053c2 <GSM_PWRCNTRL_OFF>:
void GSM_PWRCNTRL_OFF(void){
	cli();
    53c2:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    53c4:	1f 98       	cbi	0x03, 7	; 3
	sei();
    53c6:	78 94       	sei
}
    53c8:	08 95       	ret

000053ca <GSM_PWRCNTRL_ON>:
void GSM_PWRCNTRL_ON(void){
	cli();
    53ca:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    53cc:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    53ce:	78 94       	sei
}
    53d0:	08 95       	ret

000053d2 <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    53d2:	8d 9a       	sbi	0x11, 5	; 17
}
    53d4:	08 95       	ret

000053d6 <CTS_OFF>:
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    53d6:	95 98       	cbi	0x12, 5	; 18
}
    53d8:	08 95       	ret

000053da <CTS_ON>:
void CTS_ON(void){
	PORTD|=(1<<PD5);
    53da:	95 9a       	sbi	0x12, 5	; 18
}
    53dc:	08 95       	ret

000053de <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    53de:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    53e0:	96 9a       	sbi	0x12, 6	; 18
}
    53e2:	08 95       	ret

000053e4 <RTS_Read>:
uint8_t RTS_Read(void){
	return (PIND & (1<<PD6));	
    53e4:	80 b3       	in	r24, 0x10	; 16
}
    53e6:	80 74       	andi	r24, 0x40	; 64
    53e8:	08 95       	ret

000053ea <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    53ea:	8f e0       	ldi	r24, 0x0F	; 15
    53ec:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    53ee:	87 b7       	in	r24, 0x37	; 55
    53f0:	82 60       	ori	r24, 0x02	; 2
    53f2:	87 bf       	out	0x37, r24	; 55
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK0 |=(1<<OCIE0A);
	#endif
}
    53f4:	08 95       	ret

000053f6 <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    53f6:	8d e0       	ldi	r24, 0x0D	; 13
    53f8:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    53fa:	87 b7       	in	r24, 0x37	; 55
    53fc:	80 68       	ori	r24, 0x80	; 128
    53fe:	87 bf       	out	0x37, r24	; 55
	#elif  defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TIMSK2 |=(1<<OCIE2A);
	#endif
}
    5400:	08 95       	ret

00005402 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    5402:	68 2f       	mov	r22, r24
    5404:	70 e0       	ldi	r23, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5406:	9b 01       	movw	r18, r22
    5408:	22 0f       	add	r18, r18
    540a:	33 1f       	adc	r19, r19
    540c:	cb 01       	movw	r24, r22
    540e:	a3 e0       	ldi	r26, 0x03	; 3
    5410:	88 0f       	add	r24, r24
    5412:	99 1f       	adc	r25, r25
    5414:	aa 95       	dec	r26
    5416:	e1 f7       	brne	.-8      	; 0x5410 <MBRecept+0xe>
    5418:	28 0f       	add	r18, r24
    541a:	39 1f       	adc	r19, r25
    541c:	22 0f       	add	r18, r18
    541e:	33 1f       	adc	r19, r19
    5420:	22 53       	subi	r18, 0x32	; 50
    5422:	36 4b       	sbci	r19, 0xB6	; 182
    5424:	f9 01       	movw	r30, r18
    5426:	a5 91       	lpm	r26, Z+
    5428:	b4 91       	lpm	r27, Z+
    542a:	3c 91       	ld	r19, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    542c:	ab 01       	movw	r20, r22
    542e:	46 5b       	subi	r20, 0xB6	; 182
    5430:	57 4f       	sbci	r21, 0xF7	; 247
    5432:	fa 01       	movw	r30, r20
    5434:	20 81       	ld	r18, Z
    5436:	84 e1       	ldi	r24, 0x14	; 20
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	68 9f       	mul	r22, r24
    543c:	f0 01       	movw	r30, r0
    543e:	69 9f       	mul	r22, r25
    5440:	f0 0d       	add	r31, r0
    5442:	78 9f       	mul	r23, r24
    5444:	f0 0d       	add	r31, r0
    5446:	11 24       	eor	r1, r1
    5448:	e4 53       	subi	r30, 0x34	; 52
    544a:	f6 4b       	sbci	r31, 0xB6	; 182
    544c:	a5 91       	lpm	r26, Z+
    544e:	b4 91       	lpm	r27, Z+
    5450:	f6 2f       	mov	r31, r22
    5452:	ee 27       	eor	r30, r30
    5454:	e2 0f       	add	r30, r18
    5456:	f1 1d       	adc	r31, r1
    5458:	e1 55       	subi	r30, 0x51	; 81
    545a:	f3 4f       	sbci	r31, 0xF3	; 243
    545c:	8c 91       	ld	r24, X
    545e:	80 83       	st	Z, r24
    5460:	2f 5f       	subi	r18, 0xFF	; 255
    5462:	fa 01       	movw	r30, r20
    5464:	20 83       	st	Z, r18
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5466:	23 2f       	mov	r18, r19
    5468:	30 e0       	ldi	r19, 0x00	; 0
    546a:	23 ff       	sbrs	r18, 3
    546c:	0d c0       	rjmp	.+26     	; 0x5488 <MBRecept+0x86>
		MB_CPT[MB_N][7]++;
    546e:	fb 01       	movw	r30, r22
    5470:	44 e0       	ldi	r20, 0x04	; 4
    5472:	ee 0f       	add	r30, r30
    5474:	ff 1f       	adc	r31, r31
    5476:	4a 95       	dec	r20
    5478:	e1 f7       	brne	.-8      	; 0x5472 <MBRecept+0x70>
    547a:	ef 56       	subi	r30, 0x6F	; 111
    547c:	f5 4f       	sbci	r31, 0xF5	; 245
    547e:	86 85       	ldd	r24, Z+14	; 0x0e
    5480:	97 85       	ldd	r25, Z+15	; 0x0f
    5482:	01 96       	adiw	r24, 0x01	; 1
    5484:	97 87       	std	Z+15, r25	; 0x0f
    5486:	86 87       	std	Z+14, r24	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5488:	2c 71       	andi	r18, 0x1C	; 28
    548a:	30 70       	andi	r19, 0x00	; 0
    548c:	23 2b       	or	r18, r19
    548e:	61 f0       	breq	.+24     	; 0x54a8 <MBRecept+0xa6>
		MB_Err |=(1<<MB_N);
    5490:	81 e0       	ldi	r24, 0x01	; 1
    5492:	90 e0       	ldi	r25, 0x00	; 0
    5494:	02 c0       	rjmp	.+4      	; 0x549a <MBRecept+0x98>
    5496:	88 0f       	add	r24, r24
    5498:	99 1f       	adc	r25, r25
    549a:	6a 95       	dec	r22
    549c:	e2 f7       	brpl	.-8      	; 0x5496 <MBRecept+0x94>
    549e:	20 91 4a 03 	lds	r18, 0x034A
    54a2:	28 2b       	or	r18, r24
    54a4:	20 93 4a 03 	sts	0x034A, r18
    54a8:	08 95       	ret

000054aa <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    54aa:	cf 92       	push	r12
    54ac:	df 92       	push	r13
    54ae:	ef 92       	push	r14
    54b0:	ff 92       	push	r15
    54b2:	0f 93       	push	r16
    54b4:	1f 93       	push	r17
	MB_State[MB_N] = MB_Trans;
    54b6:	e8 2e       	mov	r14, r24
    54b8:	ff 24       	eor	r15, r15
    54ba:	f7 01       	movw	r30, r14
    54bc:	ec 59       	subi	r30, 0x9C	; 156
    54be:	fc 4f       	sbci	r31, 0xFC	; 252
    54c0:	83 e0       	ldi	r24, 0x03	; 3
    54c2:	80 83       	st	Z, r24
    54c4:	84 e1       	ldi	r24, 0x14	; 20
    54c6:	90 e0       	ldi	r25, 0x00	; 0
    54c8:	e8 9e       	mul	r14, r24
    54ca:	80 01       	movw	r16, r0
    54cc:	e9 9e       	mul	r14, r25
    54ce:	10 0d       	add	r17, r0
    54d0:	f8 9e       	mul	r15, r24
    54d2:	10 0d       	add	r17, r0
    54d4:	11 24       	eor	r1, r1
    54d6:	04 5f       	subi	r16, 0xF4	; 244
    54d8:	1f 4f       	sbci	r17, 0xFF	; 255
    54da:	7c ec       	ldi	r23, 0xCC	; 204
    54dc:	c7 2e       	mov	r12, r23
    54de:	79 e4       	ldi	r23, 0x49	; 73
    54e0:	d7 2e       	mov	r13, r23
    54e2:	c6 01       	movw	r24, r12
    54e4:	80 0f       	add	r24, r16
    54e6:	91 1f       	adc	r25, r17
    54e8:	0c 50       	subi	r16, 0x0C	; 12
    54ea:	10 40       	sbci	r17, 0x00	; 0
    54ec:	fc 01       	movw	r30, r24
    54ee:	25 91       	lpm	r18, Z+
    54f0:	34 91       	lpm	r19, Z+
	USART_Func(MB_N, RS485);
    54f2:	f9 01       	movw	r30, r18
    54f4:	09 95       	icall
    54f6:	f6 01       	movw	r30, r12
    54f8:	e0 0f       	add	r30, r16
    54fa:	f1 1f       	adc	r31, r17
    54fc:	a5 91       	lpm	r26, Z+
    54fe:	b4 91       	lpm	r27, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5500:	fe 2d       	mov	r31, r14
    5502:	ee 27       	eor	r30, r30
    5504:	e1 55       	subi	r30, 0x51	; 81
    5506:	f3 4f       	sbci	r31, 0xF3	; 243
    5508:	80 81       	ld	r24, Z
    550a:	8c 93       	st	X, r24
    550c:	97 01       	movw	r18, r14
    550e:	22 0f       	add	r18, r18
    5510:	33 1f       	adc	r19, r19
    5512:	c7 01       	movw	r24, r14
    5514:	43 e0       	ldi	r20, 0x03	; 3
    5516:	88 0f       	add	r24, r24
    5518:	99 1f       	adc	r25, r25
    551a:	4a 95       	dec	r20
    551c:	e1 f7       	brne	.-8      	; 0x5516 <MB_Transm+0x6c>
    551e:	28 0f       	add	r18, r24
    5520:	39 1f       	adc	r19, r25
    5522:	2f 5f       	subi	r18, 0xFF	; 255
    5524:	3f 4f       	sbci	r19, 0xFF	; 255
    5526:	22 0f       	add	r18, r18
    5528:	33 1f       	adc	r19, r19
    552a:	2c 0d       	add	r18, r12
    552c:	3d 1d       	adc	r19, r13
    552e:	f9 01       	movw	r30, r18
    5530:	a5 91       	lpm	r26, Z+
    5532:	b4 91       	lpm	r27, Z+

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5534:	8c 91       	ld	r24, X
    5536:	80 64       	ori	r24, 0x40	; 64
    5538:	8c 93       	st	X, r24
    553a:	c7 01       	movw	r24, r14
    553c:	88 0f       	add	r24, r24
    553e:	99 1f       	adc	r25, r25
    5540:	88 0f       	add	r24, r24
    5542:	99 1f       	adc	r25, r25
    5544:	8e 0d       	add	r24, r14
    5546:	9f 1d       	adc	r25, r15
    5548:	01 96       	adiw	r24, 0x01	; 1
    554a:	88 0f       	add	r24, r24
    554c:	99 1f       	adc	r25, r25
    554e:	88 0f       	add	r24, r24
    5550:	99 1f       	adc	r25, r25
    5552:	8c 0d       	add	r24, r12
    5554:	9d 1d       	adc	r25, r13
    5556:	fc 01       	movw	r30, r24
    5558:	a5 91       	lpm	r26, Z+
    555a:	b4 91       	lpm	r27, Z+
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    555c:	8c 91       	ld	r24, X
    555e:	80 62       	ori	r24, 0x20	; 32
    5560:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5562:	1f 91       	pop	r17
    5564:	0f 91       	pop	r16
    5566:	ff 90       	pop	r15
    5568:	ef 90       	pop	r14
    556a:	df 90       	pop	r13
    556c:	cf 90       	pop	r12
    556e:	08 95       	ret

00005570 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5570:	cf 93       	push	r28
    5572:	df 93       	push	r29
    5574:	dc 01       	movw	r26, r24
    5576:	30 e0       	ldi	r19, 0x00	; 0
    5578:	44 e1       	ldi	r20, 0x14	; 20
    557a:	50 e0       	ldi	r21, 0x00	; 0
    557c:	01 c0       	rjmp	.+2      	; 0x5580 <Modbus_RX+0x10>
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    557e:	3f 5f       	subi	r19, 0xFF	; 255
    5580:	c3 2f       	mov	r28, r19
    5582:	d0 e0       	ldi	r29, 0x00	; 0
    5584:	c4 9f       	mul	r28, r20
    5586:	f0 01       	movw	r30, r0
    5588:	c5 9f       	mul	r28, r21
    558a:	f0 0d       	add	r31, r0
    558c:	d4 9f       	mul	r29, r20
    558e:	f0 0d       	add	r31, r0
    5590:	11 24       	eor	r1, r1
    5592:	e4 53       	subi	r30, 0x34	; 52
    5594:	f6 4b       	sbci	r31, 0xB6	; 182
    5596:	85 91       	lpm	r24, Z+
    5598:	94 91       	lpm	r25, Z+
    559a:	a8 17       	cp	r26, r24
    559c:	b9 07       	cpc	r27, r25
    559e:	79 f7       	brne	.-34     	; 0x557e <Modbus_RX+0xe>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    55a0:	fe 01       	movw	r30, r28
    55a2:	ec 59       	subi	r30, 0x9C	; 156
    55a4:	fc 4f       	sbci	r31, 0xFC	; 252
    55a6:	80 81       	ld	r24, Z
    55a8:	82 30       	cpi	r24, 0x02	; 2
    55aa:	c9 f1       	breq	.+114    	; 0x561e <Modbus_RX+0xae>
    55ac:	83 30       	cpi	r24, 0x03	; 3
    55ae:	30 f4       	brcc	.+12     	; 0x55bc <Modbus_RX+0x4c>
    55b0:	88 23       	and	r24, r24
    55b2:	41 f0       	breq	.+16     	; 0x55c4 <Modbus_RX+0x54>
    55b4:	81 30       	cpi	r24, 0x01	; 1
    55b6:	09 f0       	breq	.+2      	; 0x55ba <Modbus_RX+0x4a>
    55b8:	49 c0       	rjmp	.+146    	; 0x564c <Modbus_RX+0xdc>
    55ba:	0b c0       	rjmp	.+22     	; 0x55d2 <Modbus_RX+0x62>
    55bc:	85 30       	cpi	r24, 0x05	; 5
    55be:	08 f0       	brcs	.+2      	; 0x55c2 <Modbus_RX+0x52>
    55c0:	45 c0       	rjmp	.+138    	; 0x564c <Modbus_RX+0xdc>
    55c2:	3e c0       	rjmp	.+124    	; 0x5640 <Modbus_RX+0xd0>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    55c4:	8c 91       	ld	r24, X
    55c6:	fc 2f       	mov	r31, r28
    55c8:	ee 27       	eor	r30, r30
    55ca:	e1 55       	subi	r30, 0x51	; 81
    55cc:	f3 4f       	sbci	r31, 0xF3	; 243
    55ce:	80 83       	st	Z, r24
    55d0:	29 c0       	rjmp	.+82     	; 0x5624 <Modbus_RX+0xb4>
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle:
		MB_State[MB_N] = MB_Recept;
    55d2:	82 e0       	ldi	r24, 0x02	; 2
    55d4:	80 83       	st	Z, r24
		MB_Err &=~(1<<MB_N);
    55d6:	81 e0       	ldi	r24, 0x01	; 1
    55d8:	90 e0       	ldi	r25, 0x00	; 0
    55da:	03 2e       	mov	r0, r19
    55dc:	02 c0       	rjmp	.+4      	; 0x55e2 <Modbus_RX+0x72>
    55de:	88 0f       	add	r24, r24
    55e0:	99 1f       	adc	r25, r25
    55e2:	0a 94       	dec	r0
    55e4:	e2 f7       	brpl	.-8      	; 0x55de <Modbus_RX+0x6e>
    55e6:	80 95       	com	r24
    55e8:	20 91 4a 03 	lds	r18, 0x034A
    55ec:	28 23       	and	r18, r24
    55ee:	20 93 4a 03 	sts	0x034A, r18
		MB_Frame_Sz[MB_N] = 0;
    55f2:	fe 01       	movw	r30, r28
    55f4:	e6 5b       	subi	r30, 0xB6	; 182
    55f6:	f7 4f       	sbci	r31, 0xF7	; 247
    55f8:	10 82       	st	Z, r1
		MBRecept(MB_N);
    55fa:	83 2f       	mov	r24, r19
    55fc:	0e 94 01 2a 	call	0x5402	; 0x5402 <MBRecept>
    5600:	ce 01       	movw	r24, r28
    5602:	88 0f       	add	r24, r24
    5604:	99 1f       	adc	r25, r25
    5606:	8c 0f       	add	r24, r28
    5608:	9d 1f       	adc	r25, r29
    560a:	88 0f       	add	r24, r24
    560c:	99 1f       	adc	r25, r25
    560e:	8b 51       	subi	r24, 0x1B	; 27
    5610:	96 4b       	sbci	r25, 0xB6	; 182
    5612:	fc 01       	movw	r30, r24
    5614:	25 91       	lpm	r18, Z+
    5616:	34 91       	lpm	r19, Z+
		MB_StartTimer(MB_N);
    5618:	f9 01       	movw	r30, r18
    561a:	09 95       	icall
    561c:	17 c0       	rjmp	.+46     	; 0x564c <Modbus_RX+0xdc>
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    561e:	83 2f       	mov	r24, r19
    5620:	0e 94 01 2a 	call	0x5402	; 0x5402 <MBRecept>
    5624:	ce 01       	movw	r24, r28
    5626:	88 0f       	add	r24, r24
    5628:	99 1f       	adc	r25, r25
    562a:	8c 0f       	add	r24, r28
    562c:	9d 1f       	adc	r25, r29
    562e:	88 0f       	add	r24, r24
    5630:	99 1f       	adc	r25, r25
    5632:	8f 51       	subi	r24, 0x1F	; 31
    5634:	96 4b       	sbci	r25, 0xB6	; 182
    5636:	fc 01       	movw	r30, r24
    5638:	a5 91       	lpm	r26, Z+
    563a:	b4 91       	lpm	r27, Z+
		MB_ClearTimer(MB_N);
    563c:	1c 92       	st	X, r1
    563e:	06 c0       	rjmp	.+12     	; 0x564c <Modbus_RX+0xdc>
		break;
	case MB_Trans: case MB_Proc:
		MB_Frame[MB_N][0] = usart_data(usart);
    5640:	8c 91       	ld	r24, X
    5642:	fc 2f       	mov	r31, r28
    5644:	ee 27       	eor	r30, r30
    5646:	e1 55       	subi	r30, 0x51	; 81
    5648:	f3 4f       	sbci	r31, 0xF3	; 243
    564a:	80 83       	st	Z, r24
		break;
	}
}
    564c:	df 91       	pop	r29
    564e:	cf 91       	pop	r28
    5650:	08 95       	ret

00005652 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    5652:	0f 93       	push	r16
    5654:	1f 93       	push	r17
    5656:	cf 93       	push	r28
    5658:	df 93       	push	r29
    565a:	38 2f       	mov	r19, r24
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    565c:	c8 2f       	mov	r28, r24
    565e:	d0 e0       	ldi	r29, 0x00	; 0
    5660:	fe 01       	movw	r30, r28
    5662:	e6 5b       	subi	r30, 0xB6	; 182
    5664:	f7 4f       	sbci	r31, 0xF7	; 247
    5666:	20 81       	ld	r18, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5668:	80 91 4a 03 	lds	r24, 0x034A
    566c:	90 e0       	ldi	r25, 0x00	; 0
    566e:	03 2e       	mov	r0, r19
    5670:	02 c0       	rjmp	.+4      	; 0x5676 <CommErr+0x24>
    5672:	95 95       	asr	r25
    5674:	87 95       	ror	r24
    5676:	0a 94       	dec	r0
    5678:	e2 f7       	brpl	.-8      	; 0x5672 <CommErr+0x20>
    567a:	80 fd       	sbrc	r24, 0
    567c:	1b c0       	rjmp	.+54     	; 0x56b4 <CommErr+0x62>
    567e:	23 30       	cpi	r18, 0x03	; 3
    5680:	c8 f0       	brcs	.+50     	; 0x56b4 <CommErr+0x62>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5682:	22 50       	subi	r18, 0x02	; 2
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    5684:	73 2f       	mov	r23, r19
    5686:	60 e0       	ldi	r22, 0x00	; 0
    5688:	fb 01       	movw	r30, r22
    568a:	e2 0f       	add	r30, r18
    568c:	f1 1d       	adc	r31, r1
    568e:	e1 55       	subi	r30, 0x51	; 81
    5690:	f3 4f       	sbci	r31, 0xF3	; 243
    5692:	00 81       	ld	r16, Z
    5694:	11 81       	ldd	r17, Z+1	; 0x01
    5696:	61 55       	subi	r22, 0x51	; 81
    5698:	73 4f       	sbci	r23, 0xF3	; 243
    569a:	30 e0       	ldi	r19, 0x00	; 0
    569c:	40 e0       	ldi	r20, 0x00	; 0
    569e:	50 e0       	ldi	r21, 0x00	; 0
    56a0:	8e e1       	ldi	r24, 0x1E	; 30
    56a2:	96 e2       	ldi	r25, 0x26	; 38
    56a4:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
    56a8:	08 17       	cp	r16, r24
    56aa:	19 07       	cpc	r17, r25
    56ac:	19 f4       	brne	.+6      	; 0x56b4 <CommErr+0x62>
    56ae:	80 e0       	ldi	r24, 0x00	; 0
    56b0:	90 e0       	ldi	r25, 0x00	; 0
    56b2:	02 c0       	rjmp	.+4      	; 0x56b8 <CommErr+0x66>
    56b4:	81 e0       	ldi	r24, 0x01	; 1
    56b6:	90 e0       	ldi	r25, 0x00	; 0
    56b8:	08 2f       	mov	r16, r24
	if (Err) {
    56ba:	88 23       	and	r24, r24
    56bc:	c9 f0       	breq	.+50     	; 0x56f0 <CommErr+0x9e>
		MB_CPT[MB_N][1]++;
    56be:	fe 01       	movw	r30, r28
    56c0:	54 e0       	ldi	r21, 0x04	; 4
    56c2:	ee 0f       	add	r30, r30
    56c4:	ff 1f       	adc	r31, r31
    56c6:	5a 95       	dec	r21
    56c8:	e1 f7       	brne	.-8      	; 0x56c2 <CommErr+0x70>
    56ca:	ed 56       	subi	r30, 0x6D	; 109
    56cc:	f5 4f       	sbci	r31, 0xF5	; 245
    56ce:	80 81       	ld	r24, Z
    56d0:	91 81       	ldd	r25, Z+1	; 0x01
    56d2:	01 96       	adiw	r24, 0x01	; 1
    56d4:	91 83       	std	Z+1, r25	; 0x01
    56d6:	80 83       	st	Z, r24
    56d8:	84 e1       	ldi	r24, 0x14	; 20
    56da:	90 e0       	ldi	r25, 0x00	; 0
    56dc:	c8 9f       	mul	r28, r24
    56de:	90 01       	movw	r18, r0
    56e0:	c9 9f       	mul	r28, r25
    56e2:	30 0d       	add	r19, r0
    56e4:	d8 9f       	mul	r29, r24
    56e6:	30 0d       	add	r19, r0
    56e8:	11 24       	eor	r1, r1
    56ea:	24 52       	subi	r18, 0x24	; 36
    56ec:	36 4b       	sbci	r19, 0xB6	; 182
    56ee:	18 c0       	rjmp	.+48     	; 0x5720 <CommErr+0xce>
		USART_Func(MB_N, LED_Err_On);
	}
	else {
		MB_CPT[MB_N][0]++;
    56f0:	fe 01       	movw	r30, r28
    56f2:	44 e0       	ldi	r20, 0x04	; 4
    56f4:	ee 0f       	add	r30, r30
    56f6:	ff 1f       	adc	r31, r31
    56f8:	4a 95       	dec	r20
    56fa:	e1 f7       	brne	.-8      	; 0x56f4 <CommErr+0xa2>
    56fc:	ef 56       	subi	r30, 0x6F	; 111
    56fe:	f5 4f       	sbci	r31, 0xF5	; 245
    5700:	80 81       	ld	r24, Z
    5702:	91 81       	ldd	r25, Z+1	; 0x01
    5704:	01 96       	adiw	r24, 0x01	; 1
    5706:	91 83       	std	Z+1, r25	; 0x01
    5708:	80 83       	st	Z, r24
    570a:	84 e1       	ldi	r24, 0x14	; 20
    570c:	90 e0       	ldi	r25, 0x00	; 0
    570e:	c8 9f       	mul	r28, r24
    5710:	90 01       	movw	r18, r0
    5712:	c9 9f       	mul	r28, r25
    5714:	30 0d       	add	r19, r0
    5716:	d8 9f       	mul	r29, r24
    5718:	30 0d       	add	r19, r0
    571a:	11 24       	eor	r1, r1
    571c:	22 52       	subi	r18, 0x22	; 34
    571e:	36 4b       	sbci	r19, 0xB6	; 182
    5720:	f9 01       	movw	r30, r18
    5722:	85 91       	lpm	r24, Z+
    5724:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED_Err_Off);
    5726:	fc 01       	movw	r30, r24
    5728:	09 95       	icall
	}
	return Err;
}
    572a:	80 2f       	mov	r24, r16
    572c:	df 91       	pop	r29
    572e:	cf 91       	pop	r28
    5730:	1f 91       	pop	r17
    5732:	0f 91       	pop	r16
    5734:	08 95       	ret

00005736 <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    5736:	df 92       	push	r13
    5738:	ef 92       	push	r14
    573a:	ff 92       	push	r15
    573c:	0f 93       	push	r16
    573e:	1f 93       	push	r17
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    5740:	ea e4       	ldi	r30, 0x4A	; 74
    5742:	f8 e0       	ldi	r31, 0x08	; 8
    5744:	e8 0f       	add	r30, r24
    5746:	f1 1d       	adc	r31, r1
    5748:	d0 80       	ld	r13, Z
    574a:	9e ef       	ldi	r25, 0xFE	; 254
    574c:	d9 0e       	add	r13, r25
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    574e:	18 2f       	mov	r17, r24
    5750:	00 e0       	ldi	r16, 0x00	; 0
    5752:	6f ea       	ldi	r22, 0xAF	; 175
    5754:	e6 2e       	mov	r14, r22
    5756:	6c e0       	ldi	r22, 0x0C	; 12
    5758:	f6 2e       	mov	r15, r22
    575a:	b7 01       	movw	r22, r14
    575c:	60 0f       	add	r22, r16
    575e:	71 1f       	adc	r23, r17
    5760:	2d 2d       	mov	r18, r13
    5762:	30 e0       	ldi	r19, 0x00	; 0
    5764:	40 e0       	ldi	r20, 0x00	; 0
    5766:	50 e0       	ldi	r21, 0x00	; 0
    5768:	8e e1       	ldi	r24, 0x1E	; 30
    576a:	96 e2       	ldi	r25, 0x26	; 38
    576c:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
    5770:	0d 0d       	add	r16, r13
    5772:	11 1d       	adc	r17, r1
    5774:	e0 0e       	add	r14, r16
    5776:	f1 1e       	adc	r15, r17
    5778:	f7 01       	movw	r30, r14
    577a:	91 83       	std	Z+1, r25	; 0x01
    577c:	80 83       	st	Z, r24
}
    577e:	1f 91       	pop	r17
    5780:	0f 91       	pop	r16
    5782:	ff 90       	pop	r15
    5784:	ef 90       	pop	r14
    5786:	df 90       	pop	r13
    5788:	08 95       	ret

0000578a <MB_FrameReg>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    578a:	70 e0       	ldi	r23, 0x00	; 0
    578c:	af ea       	ldi	r26, 0xAF	; 175
    578e:	bc e0       	ldi	r27, 0x0C	; 12
    5790:	f8 2f       	mov	r31, r24
    5792:	e0 e0       	ldi	r30, 0x00	; 0
    5794:	ea 0f       	add	r30, r26
    5796:	fb 1f       	adc	r31, r27
    5798:	e6 0f       	add	r30, r22
    579a:	f7 1f       	adc	r31, r23
    579c:	41 81       	ldd	r20, Z+1	; 0x01
    579e:	50 e0       	ldi	r21, 0x00	; 0
    57a0:	38 2f       	mov	r19, r24
    57a2:	20 e0       	ldi	r18, 0x00	; 0
    57a4:	26 0f       	add	r18, r22
    57a6:	37 1f       	adc	r19, r23
    57a8:	a2 0f       	add	r26, r18
    57aa:	b3 1f       	adc	r27, r19
    57ac:	9c 91       	ld	r25, X
    57ae:	80 e0       	ldi	r24, 0x00	; 0
    57b0:	48 2b       	or	r20, r24
    57b2:	59 2b       	or	r21, r25
}
    57b4:	ca 01       	movw	r24, r20
    57b6:	08 95       	ret

000057b8 <MB_CPT_Clear>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_CPT_Clear(uint8_t MB_N)
{
    57b8:	20 e0       	ldi	r18, 0x00	; 0
    57ba:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i=0; i<8; MB_CPT[MB_N][i++]=0);
    57bc:	90 e0       	ldi	r25, 0x00	; 0
    57be:	e3 e0       	ldi	r30, 0x03	; 3
    57c0:	88 0f       	add	r24, r24
    57c2:	99 1f       	adc	r25, r25
    57c4:	ea 95       	dec	r30
    57c6:	e1 f7       	brne	.-8      	; 0x57c0 <MB_CPT_Clear+0x8>
    57c8:	fc 01       	movw	r30, r24
    57ca:	e2 0f       	add	r30, r18
    57cc:	f3 1f       	adc	r31, r19
    57ce:	ee 0f       	add	r30, r30
    57d0:	ff 1f       	adc	r31, r31
    57d2:	ef 56       	subi	r30, 0x6F	; 111
    57d4:	f5 4f       	sbci	r31, 0xF5	; 245
    57d6:	11 82       	std	Z+1, r1	; 0x01
    57d8:	10 82       	st	Z, r1
    57da:	2f 5f       	subi	r18, 0xFF	; 255
    57dc:	3f 4f       	sbci	r19, 0xFF	; 255
    57de:	28 30       	cpi	r18, 0x08	; 8
    57e0:	31 05       	cpc	r19, r1
    57e2:	91 f7       	brne	.-28     	; 0x57c8 <MB_CPT_Clear+0x10>
}
    57e4:	08 95       	ret

000057e6 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    57e6:	3f 92       	push	r3
    57e8:	4f 92       	push	r4
    57ea:	5f 92       	push	r5
    57ec:	6f 92       	push	r6
    57ee:	7f 92       	push	r7
    57f0:	8f 92       	push	r8
    57f2:	9f 92       	push	r9
    57f4:	af 92       	push	r10
    57f6:	bf 92       	push	r11
    57f8:	cf 92       	push	r12
    57fa:	df 92       	push	r13
    57fc:	ef 92       	push	r14
    57fe:	ff 92       	push	r15
    5800:	0f 93       	push	r16
    5802:	1f 93       	push	r17
    5804:	cf 93       	push	r28
    5806:	df 93       	push	r29
    5808:	38 2e       	mov	r3, r24
	switch (MB_State[MB_N]) {
    580a:	c8 2f       	mov	r28, r24
    580c:	d0 e0       	ldi	r29, 0x00	; 0
    580e:	8e 01       	movw	r16, r28
    5810:	0c 59       	subi	r16, 0x9C	; 156
    5812:	1c 4f       	sbci	r17, 0xFC	; 252
    5814:	f8 01       	movw	r30, r16
    5816:	80 81       	ld	r24, Z
    5818:	88 23       	and	r24, r24
    581a:	c1 f0       	breq	.+48     	; 0x584c <MB_S_Timer_ISR+0x66>
    581c:	82 30       	cpi	r24, 0x02	; 2
    581e:	09 f0       	breq	.+2      	; 0x5822 <MB_S_Timer_ISR+0x3c>
    5820:	ef c2       	rjmp	.+1502   	; 0x5e00 <MB_S_Timer_ISR+0x61a>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    5822:	84 e0       	ldi	r24, 0x04	; 4
    5824:	f8 01       	movw	r30, r16
    5826:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    5828:	83 2d       	mov	r24, r3
    582a:	0e 94 29 2b 	call	0x5652	; 0x5652 <CommErr>
    582e:	88 23       	and	r24, r24
    5830:	69 f4       	brne	.+26     	; 0x584c <MB_S_Timer_ISR+0x66>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    5832:	fc 2f       	mov	r31, r28
    5834:	ee 27       	eor	r30, r30
    5836:	e1 55       	subi	r30, 0x51	; 81
    5838:	f3 4f       	sbci	r31, 0xF3	; 243
    583a:	90 81       	ld	r25, Z
    583c:	99 23       	and	r25, r25
    583e:	51 f0       	breq	.+20     	; 0x5854 <MB_S_Timer_ISR+0x6e>
    5840:	fe 01       	movw	r30, r28
    5842:	e5 58       	subi	r30, 0x85	; 133
    5844:	fc 4f       	sbci	r31, 0xFC	; 252
    5846:	80 81       	ld	r24, Z
    5848:	98 17       	cp	r25, r24
    584a:	21 f0       	breq	.+8      	; 0x5854 <MB_S_Timer_ISR+0x6e>
		MB_State[MB_N] = MB_Idle;
    584c:	81 e0       	ldi	r24, 0x01	; 1
    584e:	f8 01       	movw	r30, r16
    5850:	80 83       	st	Z, r24
    5852:	d6 c2       	rjmp	.+1452   	; 0x5e00 <MB_S_Timer_ISR+0x61a>
    5854:	84 e1       	ldi	r24, 0x14	; 20
    5856:	90 e0       	ldi	r25, 0x00	; 0
    5858:	c8 9f       	mul	r28, r24
    585a:	20 01       	movw	r4, r0
    585c:	c9 9f       	mul	r28, r25
    585e:	50 0c       	add	r5, r0
    5860:	d8 9f       	mul	r29, r24
    5862:	50 0c       	add	r5, r0
    5864:	11 24       	eor	r1, r1
    5866:	8a ed       	ldi	r24, 0xDA	; 218
    5868:	99 e4       	ldi	r25, 0x49	; 73
    586a:	48 0e       	add	r4, r24
    586c:	59 1e       	adc	r5, r25
    586e:	f2 01       	movw	r30, r4
    5870:	25 91       	lpm	r18, Z+
    5872:	34 91       	lpm	r19, Z+
		return;
	}
	USART_Func(MB_N, LED);
    5874:	f9 01       	movw	r30, r18
    5876:	09 95       	icall
	MB_CPT[MB_N][3]++;
    5878:	6e 01       	movw	r12, r28
    587a:	b4 e0       	ldi	r27, 0x04	; 4
    587c:	cc 0c       	add	r12, r12
    587e:	dd 1c       	adc	r13, r13
    5880:	ba 95       	dec	r27
    5882:	e1 f7       	brne	.-8      	; 0x587c <MB_S_Timer_ISR+0x96>
    5884:	f6 01       	movw	r30, r12
    5886:	ef 56       	subi	r30, 0x6F	; 111
    5888:	f5 4f       	sbci	r31, 0xF5	; 245
    588a:	86 81       	ldd	r24, Z+6	; 0x06
    588c:	97 81       	ldd	r25, Z+7	; 0x07
    588e:	01 96       	adiw	r24, 0x01	; 1
    5890:	97 83       	std	Z+7, r25	; 0x07
    5892:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    5894:	5c 2f       	mov	r21, r28
    5896:	44 27       	eor	r20, r20
    5898:	4f 54       	subi	r20, 0x4F	; 79
    589a:	53 4f       	sbci	r21, 0xF3	; 243
    589c:	fa 01       	movw	r30, r20
    589e:	90 81       	ld	r25, Z
    58a0:	80 e0       	ldi	r24, 0x00	; 0
    58a2:	9c 2e       	mov	r9, r28
    58a4:	88 24       	eor	r8, r8
    58a6:	d4 01       	movw	r26, r8
    58a8:	a1 55       	subi	r26, 0x51	; 81
    58aa:	b3 4f       	sbci	r27, 0xF3	; 243
    58ac:	13 96       	adiw	r26, 0x03	; 3
    58ae:	2c 91       	ld	r18, X
    58b0:	13 97       	sbiw	r26, 0x03	; 3
    58b2:	02 2f       	mov	r16, r18
    58b4:	10 e0       	ldi	r17, 0x00	; 0
    58b6:	08 2b       	or	r16, r24
    58b8:	19 2b       	or	r17, r25
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    58ba:	11 96       	adiw	r26, 0x01	; 1
    58bc:	6c 91       	ld	r22, X
    58be:	11 97       	sbiw	r26, 0x01	; 1
    58c0:	65 30       	cpi	r22, 0x05	; 5
    58c2:	38 f4       	brcc	.+14     	; 0x58d2 <MB_S_Timer_ISR+0xec>
    58c4:	63 30       	cpi	r22, 0x03	; 3
    58c6:	08 f0       	brcs	.+2      	; 0x58ca <MB_S_Timer_ISR+0xe4>
    58c8:	b1 c0       	rjmp	.+354    	; 0x5a2c <MB_S_Timer_ISR+0x246>
    58ca:	61 30       	cpi	r22, 0x01	; 1
    58cc:	08 f4       	brcc	.+2      	; 0x58d0 <MB_S_Timer_ISR+0xea>
    58ce:	49 c2       	rjmp	.+1170   	; 0x5d62 <MB_S_Timer_ISR+0x57c>
    58d0:	0a c0       	rjmp	.+20     	; 0x58e6 <MB_S_Timer_ISR+0x100>
    58d2:	6f 30       	cpi	r22, 0x0F	; 15
    58d4:	09 f4       	brne	.+2      	; 0x58d8 <MB_S_Timer_ISR+0xf2>
    58d6:	3e c1       	rjmp	.+636    	; 0x5b54 <MB_S_Timer_ISR+0x36e>
    58d8:	60 31       	cpi	r22, 0x10	; 16
    58da:	09 f4       	brne	.+2      	; 0x58de <MB_S_Timer_ISR+0xf8>
    58dc:	d1 c1       	rjmp	.+930    	; 0x5c80 <MB_S_Timer_ISR+0x49a>
    58de:	66 30       	cpi	r22, 0x06	; 6
    58e0:	09 f0       	breq	.+2      	; 0x58e4 <MB_S_Timer_ISR+0xfe>
    58e2:	3f c2       	rjmp	.+1150   	; 0x5d62 <MB_S_Timer_ISR+0x57c>
    58e4:	02 c1       	rjmp	.+516    	; 0x5aea <MB_S_Timer_ISR+0x304>
#endif
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    58e6:	8c 91       	ld	r24, X
    58e8:	88 23       	and	r24, r24
    58ea:	09 f4       	brne	.+2      	; 0x58ee <MB_S_Timer_ISR+0x108>
    58ec:	42 c2       	rjmp	.+1156   	; 0x5d72 <MB_S_Timer_ISR+0x58c>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    58ee:	fe 01       	movw	r30, r28
    58f0:	e6 5b       	subi	r30, 0xB6	; 182
    58f2:	f7 4f       	sbci	r31, 0xF7	; 247
    58f4:	80 81       	ld	r24, Z
    58f6:	88 30       	cpi	r24, 0x08	; 8
    58f8:	09 f0       	breq	.+2      	; 0x58fc <MB_S_Timer_ISR+0x116>
    58fa:	ff c0       	rjmp	.+510    	; 0x5afa <MB_S_Timer_ISR+0x314>
    58fc:	fc 2f       	mov	r31, r28
    58fe:	ee 27       	eor	r30, r30
    5900:	ed 54       	subi	r30, 0x4D	; 77
    5902:	f3 4f       	sbci	r31, 0xF3	; 243
    5904:	90 81       	ld	r25, Z
    5906:	80 e0       	ldi	r24, 0x00	; 0
    5908:	15 96       	adiw	r26, 0x05	; 5
    590a:	2c 91       	ld	r18, X
    590c:	e2 2e       	mov	r14, r18
    590e:	ff 24       	eor	r15, r15
    5910:	e8 2a       	or	r14, r24
    5912:	f9 2a       	or	r15, r25
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    5914:	61 30       	cpi	r22, 0x01	; 1
    5916:	49 f4       	brne	.+18     	; 0x592a <MB_S_Timer_ISR+0x144>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5918:	fe 01       	movw	r30, r28
    591a:	74 e0       	ldi	r23, 0x04	; 4
    591c:	ee 0f       	add	r30, r30
    591e:	ff 1f       	adc	r31, r31
    5920:	7a 95       	dec	r23
    5922:	e1 f7       	brne	.-8      	; 0x591c <MB_S_Timer_ISR+0x136>
    5924:	e2 50       	subi	r30, 0x02	; 2
    5926:	fe 4f       	sbci	r31, 0xFE	; 254
    5928:	03 c0       	rjmp	.+6      	; 0x5930 <MB_S_Timer_ISR+0x14a>
    592a:	f6 01       	movw	r30, r12
    592c:	ee 5f       	subi	r30, 0xFE	; 254
    592e:	fd 4f       	sbci	r31, 0xFD	; 253
    5930:	25 91       	lpm	r18, Z+
    5932:	34 91       	lpm	r19, Z+
    5934:	c7 01       	movw	r24, r14
    5936:	80 0f       	add	r24, r16
    5938:	91 1f       	adc	r25, r17
    593a:	28 17       	cp	r18, r24
    593c:	39 07       	cpc	r19, r25
    593e:	08 f4       	brcc	.+2      	; 0x5942 <MB_S_Timer_ISR+0x15c>
    5940:	4c c1       	rjmp	.+664    	; 0x5bda <MB_S_Timer_ISR+0x3f4>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    5942:	61 30       	cpi	r22, 0x01	; 1
    5944:	49 f4       	brne	.+18     	; 0x5958 <MB_S_Timer_ISR+0x172>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5946:	fe 01       	movw	r30, r28
    5948:	64 e0       	ldi	r22, 0x04	; 4
    594a:	ee 0f       	add	r30, r30
    594c:	ff 1f       	adc	r31, r31
    594e:	6a 95       	dec	r22
    5950:	e1 f7       	brne	.-8      	; 0x594a <MB_S_Timer_ISR+0x164>
    5952:	e4 50       	subi	r30, 0x04	; 4
    5954:	fe 4f       	sbci	r31, 0xFE	; 254
    5956:	08 c0       	rjmp	.+16     	; 0x5968 <MB_S_Timer_ISR+0x182>
    5958:	fe 01       	movw	r30, r28
    595a:	54 e0       	ldi	r21, 0x04	; 4
    595c:	ee 0f       	add	r30, r30
    595e:	ff 1f       	adc	r31, r31
    5960:	5a 95       	dec	r21
    5962:	e1 f7       	brne	.-8      	; 0x595c <MB_S_Timer_ISR+0x176>
    5964:	e0 50       	subi	r30, 0x00	; 0
    5966:	fe 4f       	sbci	r31, 0xFE	; 254
    5968:	85 91       	lpm	r24, Z+
    596a:	94 91       	lpm	r25, Z+
    596c:	28 2f       	mov	r18, r24
    596e:	a2 2f       	mov	r26, r18
    5970:	b9 2f       	mov	r27, r25
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    5972:	20 e0       	ldi	r18, 0x00	; 0
    5974:	c7 01       	movw	r24, r14
    5976:	87 70       	andi	r24, 0x07	; 7
    5978:	90 70       	andi	r25, 0x00	; 0
    597a:	89 2b       	or	r24, r25
    597c:	09 f0       	breq	.+2      	; 0x5980 <MB_S_Timer_ISR+0x19a>
    597e:	21 e0       	ldi	r18, 0x01	; 1
    5980:	c7 01       	movw	r24, r14
    5982:	43 e0       	ldi	r20, 0x03	; 3
    5984:	96 95       	lsr	r25
    5986:	87 95       	ror	r24
    5988:	4a 95       	dec	r20
    598a:	e1 f7       	brne	.-8      	; 0x5984 <MB_S_Timer_ISR+0x19e>
    598c:	82 0f       	add	r24, r18
    598e:	fc 2f       	mov	r31, r28
    5990:	ee 27       	eor	r30, r30
    5992:	ef 54       	subi	r30, 0x4F	; 79
    5994:	f3 4f       	sbci	r31, 0xF3	; 243
    5996:	80 83       	st	Z, r24
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    5998:	fe 01       	movw	r30, r28
    599a:	e6 5b       	subi	r30, 0xB6	; 182
    599c:	f7 4f       	sbci	r31, 0xF7	; 247
    599e:	8b 5f       	subi	r24, 0xFB	; 251
    59a0:	80 83       	st	Z, r24
    59a2:	70 e0       	ldi	r23, 0x00	; 0
	for (uint8_t i=0; i<Qt; i++) {
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    59a4:	21 e0       	ldi	r18, 0x01	; 1
    59a6:	a2 2e       	mov	r10, r18
    59a8:	b1 2c       	mov	r11, r1
    59aa:	dc 2e       	mov	r13, r28
    59ac:	cc 24       	eor	r12, r12
    59ae:	38 c0       	rjmp	.+112    	; 0x5a20 <MB_S_Timer_ISR+0x23a>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
		uint16_t j = StartAddr+i;
    59b0:	9c 01       	movw	r18, r24
    59b2:	20 0f       	add	r18, r16
    59b4:	31 1f       	adc	r19, r17
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    59b6:	47 2f       	mov	r20, r23
    59b8:	46 95       	lsr	r20
    59ba:	46 95       	lsr	r20
    59bc:	46 95       	lsr	r20
    59be:	4d 5f       	subi	r20, 0xFD	; 253
    59c0:	87 70       	andi	r24, 0x07	; 7
    59c2:	90 70       	andi	r25, 0x00	; 0
    59c4:	f5 01       	movw	r30, r10
    59c6:	02 c0       	rjmp	.+4      	; 0x59cc <MB_S_Timer_ISR+0x1e6>
    59c8:	ee 0f       	add	r30, r30
    59ca:	ff 1f       	adc	r31, r31
    59cc:	8a 95       	dec	r24
    59ce:	e2 f7       	brpl	.-8      	; 0x59c8 <MB_S_Timer_ISR+0x1e2>
    59d0:	6e 2f       	mov	r22, r30
		if (Discr[j/8] &(1<<j%8))
    59d2:	f9 01       	movw	r30, r18
    59d4:	83 e0       	ldi	r24, 0x03	; 3
    59d6:	f6 95       	lsr	r31
    59d8:	e7 95       	ror	r30
    59da:	8a 95       	dec	r24
    59dc:	e1 f7       	brne	.-8      	; 0x59d6 <MB_S_Timer_ISR+0x1f0>
    59de:	ea 0f       	add	r30, r26
    59e0:	fb 1f       	adc	r31, r27
    59e2:	80 81       	ld	r24, Z
    59e4:	90 e0       	ldi	r25, 0x00	; 0
    59e6:	27 70       	andi	r18, 0x07	; 7
    59e8:	30 70       	andi	r19, 0x00	; 0
    59ea:	02 c0       	rjmp	.+4      	; 0x59f0 <MB_S_Timer_ISR+0x20a>
    59ec:	95 95       	asr	r25
    59ee:	87 95       	ror	r24
    59f0:	2a 95       	dec	r18
    59f2:	e2 f7       	brpl	.-8      	; 0x59ec <MB_S_Timer_ISR+0x206>
    59f4:	50 e0       	ldi	r21, 0x00	; 0
    59f6:	80 ff       	sbrs	r24, 0
    59f8:	09 c0       	rjmp	.+18     	; 0x5a0c <MB_S_Timer_ISR+0x226>
			MB_Frame[MB_N][Byte] |=Bit;
    59fa:	f6 01       	movw	r30, r12
    59fc:	e4 0f       	add	r30, r20
    59fe:	f5 1f       	adc	r31, r21
    5a00:	e1 55       	subi	r30, 0x51	; 81
    5a02:	f3 4f       	sbci	r31, 0xF3	; 243
    5a04:	80 81       	ld	r24, Z
    5a06:	86 2b       	or	r24, r22
    5a08:	80 83       	st	Z, r24
    5a0a:	09 c0       	rjmp	.+18     	; 0x5a1e <MB_S_Timer_ISR+0x238>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    5a0c:	f6 01       	movw	r30, r12
    5a0e:	e4 0f       	add	r30, r20
    5a10:	f5 1f       	adc	r31, r21
    5a12:	e1 55       	subi	r30, 0x51	; 81
    5a14:	f3 4f       	sbci	r31, 0xF3	; 243
    5a16:	60 95       	com	r22
    5a18:	80 81       	ld	r24, Z
    5a1a:	68 23       	and	r22, r24
    5a1c:	60 83       	st	Z, r22
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    5a1e:	7f 5f       	subi	r23, 0xFF	; 255
    5a20:	87 2f       	mov	r24, r23
    5a22:	90 e0       	ldi	r25, 0x00	; 0
    5a24:	8e 15       	cp	r24, r14
    5a26:	9f 05       	cpc	r25, r15
    5a28:	18 f2       	brcs	.-122    	; 0x59b0 <MB_S_Timer_ISR+0x1ca>
    5a2a:	a5 c1       	rjmp	.+842    	; 0x5d76 <MB_S_Timer_ISR+0x590>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    5a2c:	8c 91       	ld	r24, X
    5a2e:	88 23       	and	r24, r24
    5a30:	09 f4       	brne	.+2      	; 0x5a34 <MB_S_Timer_ISR+0x24e>
    5a32:	9f c1       	rjmp	.+830    	; 0x5d72 <MB_S_Timer_ISR+0x58c>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    5a34:	fe 01       	movw	r30, r28
    5a36:	e6 5b       	subi	r30, 0xB6	; 182
    5a38:	f7 4f       	sbci	r31, 0xF7	; 247
    5a3a:	80 81       	ld	r24, Z
    5a3c:	88 30       	cpi	r24, 0x08	; 8
    5a3e:	09 f0       	breq	.+2      	; 0x5a42 <MB_S_Timer_ISR+0x25c>
    5a40:	5c c0       	rjmp	.+184    	; 0x5afa <MB_S_Timer_ISR+0x314>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    5a42:	15 96       	adiw	r26, 0x05	; 5
    5a44:	4c 91       	ld	r20, X
    5a46:	63 30       	cpi	r22, 0x03	; 3
    5a48:	21 f4       	brne	.+8      	; 0x5a52 <MB_S_Timer_ISR+0x26c>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5a4a:	f6 01       	movw	r30, r12
    5a4c:	ea 5f       	subi	r30, 0xFA	; 250
    5a4e:	fd 4f       	sbci	r31, 0xFD	; 253
    5a50:	03 c0       	rjmp	.+6      	; 0x5a58 <MB_S_Timer_ISR+0x272>
    5a52:	f6 01       	movw	r30, r12
    5a54:	e6 5f       	subi	r30, 0xF6	; 246
    5a56:	fd 4f       	sbci	r31, 0xFD	; 253
    5a58:	25 91       	lpm	r18, Z+
    5a5a:	34 91       	lpm	r19, Z+
    5a5c:	c8 01       	movw	r24, r16
    5a5e:	84 0f       	add	r24, r20
    5a60:	91 1d       	adc	r25, r1
    5a62:	28 17       	cp	r18, r24
    5a64:	39 07       	cpc	r19, r25
    5a66:	08 f4       	brcc	.+2      	; 0x5a6a <MB_S_Timer_ISR+0x284>
    5a68:	b8 c0       	rjmp	.+368    	; 0x5bda <MB_S_Timer_ISR+0x3f4>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    5a6a:	63 30       	cpi	r22, 0x03	; 3
    5a6c:	49 f4       	brne	.+18     	; 0x5a80 <MB_S_Timer_ISR+0x29a>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5a6e:	fe 01       	movw	r30, r28
    5a70:	b4 e0       	ldi	r27, 0x04	; 4
    5a72:	ee 0f       	add	r30, r30
    5a74:	ff 1f       	adc	r31, r31
    5a76:	ba 95       	dec	r27
    5a78:	e1 f7       	brne	.-8      	; 0x5a72 <MB_S_Timer_ISR+0x28c>
    5a7a:	ec 5f       	subi	r30, 0xFC	; 252
    5a7c:	fd 4f       	sbci	r31, 0xFD	; 253
    5a7e:	08 c0       	rjmp	.+16     	; 0x5a90 <MB_S_Timer_ISR+0x2aa>
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    5a80:	fe 01       	movw	r30, r28
    5a82:	a4 e0       	ldi	r26, 0x04	; 4
    5a84:	ee 0f       	add	r30, r30
    5a86:	ff 1f       	adc	r31, r31
    5a88:	aa 95       	dec	r26
    5a8a:	e1 f7       	brne	.-8      	; 0x5a84 <MB_S_Timer_ISR+0x29e>
    5a8c:	e8 5f       	subi	r30, 0xF8	; 248
    5a8e:	fd 4f       	sbci	r31, 0xFD	; 253
    5a90:	25 91       	lpm	r18, Z+
    5a92:	34 91       	lpm	r19, Z+
    5a94:	84 2f       	mov	r24, r20
    5a96:	90 e0       	ldi	r25, 0x00	; 0
    5a98:	88 0f       	add	r24, r24
    5a9a:	99 1f       	adc	r25, r25
    5a9c:	fc 2f       	mov	r31, r28
    5a9e:	ee 27       	eor	r30, r30
    5aa0:	ef 54       	subi	r30, 0x4F	; 79
    5aa2:	f3 4f       	sbci	r31, 0xF3	; 243
    5aa4:	80 83       	st	Z, r24
    5aa6:	fe 01       	movw	r30, r28
    5aa8:	e6 5b       	subi	r30, 0xB6	; 182
    5aaa:	f7 4f       	sbci	r31, 0xF7	; 247
    5aac:	8b 5f       	subi	r24, 0xFB	; 251
    5aae:	80 83       	st	Z, r24
	uint8_t Qt = MB_Frame[MB_N][5];
    5ab0:	fc 2f       	mov	r31, r28
    5ab2:	ee 27       	eor	r30, r30
    5ab4:	e1 55       	subi	r30, 0x51	; 81
    5ab6:	f3 4f       	sbci	r31, 0xF3	; 243
    5ab8:	45 81       	ldd	r20, Z+5	; 0x05
    5aba:	d8 01       	movw	r26, r16
    5abc:	aa 0f       	add	r26, r26
    5abe:	bb 1f       	adc	r27, r27
    5ac0:	a2 0f       	add	r26, r18
    5ac2:	b3 1f       	adc	r27, r19
    5ac4:	90 e0       	ldi	r25, 0x00	; 0
	for (uint8_t i=0; i<Qt; i++) {
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    5ac6:	9f 01       	movw	r18, r30
    5ac8:	0d c0       	rjmp	.+26     	; 0x5ae4 <MB_S_Timer_ISR+0x2fe>
    5aca:	89 2f       	mov	r24, r25
    5acc:	88 0f       	add	r24, r24
    5ace:	f9 01       	movw	r30, r18
    5ad0:	e8 0f       	add	r30, r24
    5ad2:	f1 1d       	adc	r31, r1
    5ad4:	11 96       	adiw	r26, 0x01	; 1
    5ad6:	8c 91       	ld	r24, X
    5ad8:	11 97       	sbiw	r26, 0x01	; 1
    5ada:	83 83       	std	Z+3, r24	; 0x03
		MB_Frame[MB_N][4+j] = Reg[i];
    5adc:	8c 91       	ld	r24, X
    5ade:	84 83       	std	Z+4, r24	; 0x04
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    5ae0:	9f 5f       	subi	r25, 0xFF	; 255
    5ae2:	12 96       	adiw	r26, 0x02	; 2
    5ae4:	94 17       	cp	r25, r20
    5ae6:	88 f3       	brcs	.-30     	; 0x5aca <MB_S_Timer_ISR+0x2e4>
    5ae8:	46 c1       	rjmp	.+652    	; 0x5d76 <MB_S_Timer_ISR+0x590>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    5aea:	be 01       	movw	r22, r28
    5aec:	66 5b       	subi	r22, 0xB6	; 182
    5aee:	77 4f       	sbci	r23, 0xF7	; 247
    5af0:	fb 01       	movw	r30, r22
    5af2:	f0 80       	ld	r15, Z
    5af4:	f8 e0       	ldi	r31, 0x08	; 8
    5af6:	ff 16       	cp	r15, r31
    5af8:	19 f0       	breq	.+6      	; 0x5b00 <MB_S_Timer_ISR+0x31a>
		return MB_Frame[MB_N][2]=IllegData;
    5afa:	83 e0       	ldi	r24, 0x03	; 3
    5afc:	fa 01       	movw	r30, r20
    5afe:	e9 c0       	rjmp	.+466    	; 0x5cd2 <MB_S_Timer_ISR+0x4ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5b00:	f6 01       	movw	r30, r12
    5b02:	ea 5f       	subi	r30, 0xFA	; 250
    5b04:	fd 4f       	sbci	r31, 0xFD	; 253
    5b06:	25 91       	lpm	r18, Z+
    5b08:	34 91       	lpm	r19, Z+
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5b0a:	c8 01       	movw	r24, r16
    5b0c:	01 96       	adiw	r24, 0x01	; 1
    5b0e:	28 17       	cp	r18, r24
    5b10:	39 07       	cpc	r19, r25
    5b12:	08 f4       	brcc	.+2      	; 0x5b16 <MB_S_Timer_ISR+0x330>
    5b14:	eb c0       	rjmp	.+470    	; 0x5cec <MB_S_Timer_ISR+0x506>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    5b16:	fb 01       	movw	r30, r22
    5b18:	f0 82       	st	Z, r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5b1a:	fe 01       	movw	r30, r28
    5b1c:	34 e0       	ldi	r19, 0x04	; 4
    5b1e:	ee 0f       	add	r30, r30
    5b20:	ff 1f       	adc	r31, r31
    5b22:	3a 95       	dec	r19
    5b24:	e1 f7       	brne	.-8      	; 0x5b1e <MB_S_Timer_ISR+0x338>
    5b26:	ec 5f       	subi	r30, 0xFC	; 252
    5b28:	fd 4f       	sbci	r31, 0xFD	; 253
    5b2a:	85 91       	lpm	r24, Z+
    5b2c:	94 91       	lpm	r25, Z+
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    5b2e:	00 0f       	add	r16, r16
    5b30:	11 1f       	adc	r17, r17
    5b32:	08 0f       	add	r16, r24
    5b34:	19 1f       	adc	r17, r25
    5b36:	fc 2f       	mov	r31, r28
    5b38:	ee 27       	eor	r30, r30
    5b3a:	ed 54       	subi	r30, 0x4D	; 77
    5b3c:	f3 4f       	sbci	r31, 0xF3	; 243
    5b3e:	90 81       	ld	r25, Z
    5b40:	80 e0       	ldi	r24, 0x00	; 0
    5b42:	15 96       	adiw	r26, 0x05	; 5
    5b44:	2c 91       	ld	r18, X
    5b46:	30 e0       	ldi	r19, 0x00	; 0
    5b48:	82 2b       	or	r24, r18
    5b4a:	93 2b       	or	r25, r19
    5b4c:	f8 01       	movw	r30, r16
    5b4e:	91 83       	std	Z+1, r25	; 0x01
    5b50:	80 83       	st	Z, r24
    5b52:	11 c1       	rjmp	.+546    	; 0x5d76 <MB_S_Timer_ISR+0x590>
    5b54:	fc 2f       	mov	r31, r28
    5b56:	ee 27       	eor	r30, r30
    5b58:	ed 54       	subi	r30, 0x4D	; 77
    5b5a:	f3 4f       	sbci	r31, 0xF3	; 243
    5b5c:	40 81       	ld	r20, Z
    5b5e:	15 96       	adiw	r26, 0x05	; 5
    5b60:	5c 91       	ld	r21, X
    5b62:	15 97       	sbiw	r26, 0x05	; 5
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    5b64:	16 96       	adiw	r26, 0x06	; 6
    5b66:	6c 91       	ld	r22, X
    5b68:	fe 01       	movw	r30, r28
    5b6a:	e6 5b       	subi	r30, 0xB6	; 182
    5b6c:	f7 4f       	sbci	r31, 0xF7	; 247
    5b6e:	20 81       	ld	r18, Z
    5b70:	30 e0       	ldi	r19, 0x00	; 0
    5b72:	86 2f       	mov	r24, r22
    5b74:	90 e0       	ldi	r25, 0x00	; 0
    5b76:	09 96       	adiw	r24, 0x09	; 9
    5b78:	28 17       	cp	r18, r24
    5b7a:	39 07       	cpc	r19, r25
    5b7c:	09 f0       	breq	.+2      	; 0x5b80 <MB_S_Timer_ISR+0x39a>
    5b7e:	a4 c0       	rjmp	.+328    	; 0x5cc8 <MB_S_Timer_ISR+0x4e2>
    5b80:	94 2f       	mov	r25, r20
    5b82:	80 e0       	ldi	r24, 0x00	; 0
    5b84:	a5 2f       	mov	r26, r21
    5b86:	b0 e0       	ldi	r27, 0x00	; 0
    5b88:	a8 2b       	or	r26, r24
    5b8a:	b9 2b       	or	r27, r25
    5b8c:	20 e0       	ldi	r18, 0x00	; 0
    5b8e:	30 e0       	ldi	r19, 0x00	; 0
    5b90:	cd 01       	movw	r24, r26
    5b92:	87 70       	andi	r24, 0x07	; 7
    5b94:	90 70       	andi	r25, 0x00	; 0
    5b96:	89 2b       	or	r24, r25
    5b98:	11 f0       	breq	.+4      	; 0x5b9e <MB_S_Timer_ISR+0x3b8>
    5b9a:	21 e0       	ldi	r18, 0x01	; 1
    5b9c:	30 e0       	ldi	r19, 0x00	; 0
    5b9e:	cd 01       	movw	r24, r26
    5ba0:	73 e0       	ldi	r23, 0x03	; 3
    5ba2:	96 95       	lsr	r25
    5ba4:	87 95       	ror	r24
    5ba6:	7a 95       	dec	r23
    5ba8:	e1 f7       	brne	.-8      	; 0x5ba2 <MB_S_Timer_ISR+0x3bc>
    5baa:	28 0f       	add	r18, r24
    5bac:	39 1f       	adc	r19, r25
    5bae:	86 2f       	mov	r24, r22
    5bb0:	90 e0       	ldi	r25, 0x00	; 0
    5bb2:	28 17       	cp	r18, r24
    5bb4:	39 07       	cpc	r19, r25
    5bb6:	09 f0       	breq	.+2      	; 0x5bba <MB_S_Timer_ISR+0x3d4>
    5bb8:	87 c0       	rjmp	.+270    	; 0x5cc8 <MB_S_Timer_ISR+0x4e2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5bba:	fe 01       	movw	r30, r28
    5bbc:	64 e0       	ldi	r22, 0x04	; 4
    5bbe:	ee 0f       	add	r30, r30
    5bc0:	ff 1f       	adc	r31, r31
    5bc2:	6a 95       	dec	r22
    5bc4:	e1 f7       	brne	.-8      	; 0x5bbe <MB_S_Timer_ISR+0x3d8>
    5bc6:	e2 50       	subi	r30, 0x02	; 2
    5bc8:	fe 4f       	sbci	r31, 0xFE	; 254
    5bca:	25 91       	lpm	r18, Z+
    5bcc:	34 91       	lpm	r19, Z+
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    5bce:	cd 01       	movw	r24, r26
    5bd0:	80 0f       	add	r24, r16
    5bd2:	91 1f       	adc	r25, r17
    5bd4:	28 17       	cp	r18, r24
    5bd6:	39 07       	cpc	r19, r25
    5bd8:	30 f4       	brcc	.+12     	; 0x5be6 <MB_S_Timer_ISR+0x400>
		return MB_Frame[MB_N][2]=IllegAddr;
    5bda:	fc 2f       	mov	r31, r28
    5bdc:	ee 27       	eor	r30, r30
    5bde:	ef 54       	subi	r30, 0x4F	; 79
    5be0:	f3 4f       	sbci	r31, 0xF3	; 243
    5be2:	82 e0       	ldi	r24, 0x02	; 2
    5be4:	85 c0       	rjmp	.+266    	; 0x5cf0 <MB_S_Timer_ISR+0x50a>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5be6:	fe 01       	movw	r30, r28
    5be8:	44 e0       	ldi	r20, 0x04	; 4
    5bea:	ee 0f       	add	r30, r30
    5bec:	ff 1f       	adc	r31, r31
    5bee:	4a 95       	dec	r20
    5bf0:	e1 f7       	brne	.-8      	; 0x5bea <MB_S_Timer_ISR+0x404>
    5bf2:	e4 50       	subi	r30, 0x04	; 4
    5bf4:	fe 4f       	sbci	r31, 0xFE	; 254
    5bf6:	a5 90       	lpm	r10, Z+
    5bf8:	b4 90       	lpm	r11, Z+
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
    5bfa:	fe 01       	movw	r30, r28
    5bfc:	e6 5b       	subi	r30, 0xB6	; 182
    5bfe:	f7 4f       	sbci	r31, 0xF7	; 247
    5c00:	88 e0       	ldi	r24, 0x08	; 8
    5c02:	80 83       	st	Z, r24
    5c04:	dd 24       	eor	r13, r13
	for (uint8_t i=0; i<Qt; i++) {
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5c06:	31 e0       	ldi	r19, 0x01	; 1
    5c08:	83 2e       	mov	r8, r19
    5c0a:	91 2c       	mov	r9, r1
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5c0c:	7c 2f       	mov	r23, r28
    5c0e:	66 27       	eor	r22, r22
    5c10:	61 55       	subi	r22, 0x51	; 81
    5c12:	73 4f       	sbci	r23, 0xF3	; 243
    5c14:	2f c0       	rjmp	.+94     	; 0x5c74 <MB_S_Timer_ISR+0x48e>
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
		uint16_t j = StartAddr+i;
    5c16:	9a 01       	movw	r18, r20
    5c18:	20 0f       	add	r18, r16
    5c1a:	31 1f       	adc	r19, r17
		uint16_t Byte=j/8, Bit=1<<j%8;
    5c1c:	c9 01       	movw	r24, r18
    5c1e:	87 70       	andi	r24, 0x07	; 7
    5c20:	90 70       	andi	r25, 0x00	; 0
    5c22:	74 01       	movw	r14, r8
    5c24:	02 c0       	rjmp	.+4      	; 0x5c2a <MB_S_Timer_ISR+0x444>
    5c26:	ee 0c       	add	r14, r14
    5c28:	ff 1c       	adc	r15, r15
    5c2a:	8a 95       	dec	r24
    5c2c:	e2 f7       	brpl	.-8      	; 0x5c26 <MB_S_Timer_ISR+0x440>
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5c2e:	8d 2d       	mov	r24, r13
    5c30:	86 95       	lsr	r24
    5c32:	86 95       	lsr	r24
    5c34:	86 95       	lsr	r24
    5c36:	fb 01       	movw	r30, r22
    5c38:	e8 0f       	add	r30, r24
    5c3a:	f1 1d       	adc	r31, r1
    5c3c:	87 81       	ldd	r24, Z+7	; 0x07
    5c3e:	90 e0       	ldi	r25, 0x00	; 0
    5c40:	47 70       	andi	r20, 0x07	; 7
    5c42:	50 70       	andi	r21, 0x00	; 0
    5c44:	02 c0       	rjmp	.+4      	; 0x5c4a <MB_S_Timer_ISR+0x464>
    5c46:	95 95       	asr	r25
    5c48:	87 95       	ror	r24
    5c4a:	4a 95       	dec	r20
    5c4c:	e2 f7       	brpl	.-8      	; 0x5c46 <MB_S_Timer_ISR+0x460>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
    5c4e:	93 e0       	ldi	r25, 0x03	; 3
    5c50:	36 95       	lsr	r19
    5c52:	27 95       	ror	r18
    5c54:	9a 95       	dec	r25
    5c56:	e1 f7       	brne	.-8      	; 0x5c50 <MB_S_Timer_ISR+0x46a>
    5c58:	f5 01       	movw	r30, r10
    5c5a:	e2 0f       	add	r30, r18
    5c5c:	f3 1f       	adc	r31, r19
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    5c5e:	80 ff       	sbrs	r24, 0
    5c60:	03 c0       	rjmp	.+6      	; 0x5c68 <MB_S_Timer_ISR+0x482>
			Coil[Byte] |=Bit;
    5c62:	80 81       	ld	r24, Z
    5c64:	8e 29       	or	r24, r14
    5c66:	04 c0       	rjmp	.+8      	; 0x5c70 <MB_S_Timer_ISR+0x48a>
		else
			Coil[Byte] &=~Bit;
    5c68:	9e 2d       	mov	r25, r14
    5c6a:	90 95       	com	r25
    5c6c:	80 81       	ld	r24, Z
    5c6e:	89 23       	and	r24, r25
    5c70:	80 83       	st	Z, r24
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    5c72:	d3 94       	inc	r13
    5c74:	4d 2d       	mov	r20, r13
    5c76:	50 e0       	ldi	r21, 0x00	; 0
    5c78:	4a 17       	cp	r20, r26
    5c7a:	5b 07       	cpc	r21, r27
    5c7c:	60 f2       	brcs	.-104    	; 0x5c16 <MB_S_Timer_ISR+0x430>
    5c7e:	7b c0       	rjmp	.+246    	; 0x5d76 <MB_S_Timer_ISR+0x590>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    5c80:	16 96       	adiw	r26, 0x06	; 6
    5c82:	8c 91       	ld	r24, X
    5c84:	16 97       	sbiw	r26, 0x06	; 6
    5c86:	68 2f       	mov	r22, r24
    5c88:	70 e0       	ldi	r23, 0x00	; 0
    5c8a:	8a e4       	ldi	r24, 0x4A	; 74
    5c8c:	e8 2e       	mov	r14, r24
    5c8e:	88 e0       	ldi	r24, 0x08	; 8
    5c90:	f8 2e       	mov	r15, r24
    5c92:	ec 0e       	add	r14, r28
    5c94:	fd 1e       	adc	r15, r29
    5c96:	f7 01       	movw	r30, r14
    5c98:	80 81       	ld	r24, Z
    5c9a:	90 e0       	ldi	r25, 0x00	; 0
    5c9c:	9b 01       	movw	r18, r22
    5c9e:	27 5f       	subi	r18, 0xF7	; 247
    5ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    5ca2:	82 17       	cp	r24, r18
    5ca4:	93 07       	cpc	r25, r19
    5ca6:	81 f4       	brne	.+32     	; 0x5cc8 <MB_S_Timer_ISR+0x4e2>
    5ca8:	f5 e0       	ldi	r31, 0x05	; 5
    5caa:	af 2e       	mov	r10, r31
    5cac:	b1 2c       	mov	r11, r1
    5cae:	aa 0e       	add	r10, r26
    5cb0:	bb 1e       	adc	r11, r27
    5cb2:	15 96       	adiw	r26, 0x05	; 5
    5cb4:	8c 91       	ld	r24, X
    5cb6:	15 97       	sbiw	r26, 0x05	; 5
    5cb8:	28 2f       	mov	r18, r24
    5cba:	30 e0       	ldi	r19, 0x00	; 0
    5cbc:	c9 01       	movw	r24, r18
    5cbe:	88 0f       	add	r24, r24
    5cc0:	99 1f       	adc	r25, r25
    5cc2:	86 17       	cp	r24, r22
    5cc4:	97 07       	cpc	r25, r23
    5cc6:	41 f0       	breq	.+16     	; 0x5cd8 <MB_S_Timer_ISR+0x4f2>
		return MB_Frame[MB_N][2]=IllegData;
    5cc8:	fc 2f       	mov	r31, r28
    5cca:	ee 27       	eor	r30, r30
    5ccc:	ef 54       	subi	r30, 0x4F	; 79
    5cce:	f3 4f       	sbci	r31, 0xF3	; 243
    5cd0:	83 e0       	ldi	r24, 0x03	; 3
    5cd2:	80 83       	st	Z, r24
    5cd4:	13 e0       	ldi	r17, 0x03	; 3
    5cd6:	50 c0       	rjmp	.+160    	; 0x5d78 <MB_S_Timer_ISR+0x592>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5cd8:	f6 01       	movw	r30, r12
    5cda:	ea 5f       	subi	r30, 0xFA	; 250
    5cdc:	fd 4f       	sbci	r31, 0xFD	; 253
    5cde:	85 91       	lpm	r24, Z+
    5ce0:	94 91       	lpm	r25, Z+
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    5ce2:	20 0f       	add	r18, r16
    5ce4:	31 1f       	adc	r19, r17
    5ce6:	82 17       	cp	r24, r18
    5ce8:	93 07       	cpc	r25, r19
    5cea:	28 f4       	brcc	.+10     	; 0x5cf6 <MB_S_Timer_ISR+0x510>
		return MB_Frame[MB_N][2]=IllegAddr;
    5cec:	82 e0       	ldi	r24, 0x02	; 2
    5cee:	fa 01       	movw	r30, r20
    5cf0:	80 83       	st	Z, r24
    5cf2:	12 e0       	ldi	r17, 0x02	; 2
    5cf4:	41 c0       	rjmp	.+130    	; 0x5d78 <MB_S_Timer_ISR+0x592>
	MB_Frame_Sz[MB_N] = 8;
    5cf6:	88 e0       	ldi	r24, 0x08	; 8
    5cf8:	f7 01       	movw	r30, r14
    5cfa:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5cfc:	fe 01       	movw	r30, r28
    5cfe:	34 e0       	ldi	r19, 0x04	; 4
    5d00:	ee 0f       	add	r30, r30
    5d02:	ff 1f       	adc	r31, r31
    5d04:	3a 95       	dec	r19
    5d06:	e1 f7       	brne	.-8      	; 0x5d00 <MB_S_Timer_ISR+0x51a>
    5d08:	ec 5f       	subi	r30, 0xFC	; 252
    5d0a:	fd 4f       	sbci	r31, 0xFD	; 253
    5d0c:	65 90       	lpm	r6, Z+
    5d0e:	74 90       	lpm	r7, Z+
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    5d10:	40 e0       	ldi	r20, 0x00	; 0
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5d12:	64 01       	movw	r12, r8
    5d14:	7d 01       	movw	r14, r26
    5d16:	b5 01       	movw	r22, r10
    5d18:	1f c0       	rjmp	.+62     	; 0x5d58 <MB_S_Timer_ISR+0x572>
    5d1a:	a4 2f       	mov	r26, r20
    5d1c:	b0 e0       	ldi	r27, 0x00	; 0
    5d1e:	cd 01       	movw	r24, r26
    5d20:	88 0f       	add	r24, r24
    5d22:	99 1f       	adc	r25, r25
    5d24:	89 5f       	subi	r24, 0xF9	; 249
    5d26:	28 2f       	mov	r18, r24
    5d28:	30 e0       	ldi	r19, 0x00	; 0
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    5d2a:	a0 0f       	add	r26, r16
    5d2c:	b1 1f       	adc	r27, r17
    5d2e:	aa 0f       	add	r26, r26
    5d30:	bb 1f       	adc	r27, r27
    5d32:	a6 0d       	add	r26, r6
    5d34:	b7 1d       	adc	r27, r7
    5d36:	f7 01       	movw	r30, r14
    5d38:	e2 0f       	add	r30, r18
    5d3a:	f3 1f       	adc	r31, r19
    5d3c:	81 81       	ldd	r24, Z+1	; 0x01
    5d3e:	90 e0       	ldi	r25, 0x00	; 0
    5d40:	2c 0d       	add	r18, r12
    5d42:	3d 1d       	adc	r19, r13
    5d44:	21 55       	subi	r18, 0x51	; 81
    5d46:	33 4f       	sbci	r19, 0xF3	; 243
    5d48:	f9 01       	movw	r30, r18
    5d4a:	30 81       	ld	r19, Z
    5d4c:	20 e0       	ldi	r18, 0x00	; 0
    5d4e:	82 2b       	or	r24, r18
    5d50:	93 2b       	or	r25, r19
    5d52:	8d 93       	st	X+, r24
    5d54:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    5d56:	4f 5f       	subi	r20, 0xFF	; 255
    5d58:	fb 01       	movw	r30, r22
    5d5a:	80 81       	ld	r24, Z
    5d5c:	48 17       	cp	r20, r24
    5d5e:	e8 f2       	brcs	.-70     	; 0x5d1a <MB_S_Timer_ISR+0x534>
    5d60:	0a c0       	rjmp	.+20     	; 0x5d76 <MB_S_Timer_ISR+0x590>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    5d62:	fc 2f       	mov	r31, r28
    5d64:	ee 27       	eor	r30, r30
    5d66:	ef 54       	subi	r30, 0x4F	; 79
    5d68:	f3 4f       	sbci	r31, 0xF3	; 243
    5d6a:	81 e0       	ldi	r24, 0x01	; 1
    5d6c:	80 83       	st	Z, r24
    5d6e:	11 e0       	ldi	r17, 0x01	; 1
    5d70:	03 c0       	rjmp	.+6      	; 0x5d78 <MB_S_Timer_ISR+0x592>
    5d72:	1f ef       	ldi	r17, 0xFF	; 255
    5d74:	01 c0       	rjmp	.+2      	; 0x5d78 <MB_S_Timer_ISR+0x592>
    5d76:	10 e0       	ldi	r17, 0x00	; 0
		break;
	}
	if (MB_Frame[MB_N][0]) {
    5d78:	fc 2f       	mov	r31, r28
    5d7a:	ee 27       	eor	r30, r30
    5d7c:	e1 55       	subi	r30, 0x51	; 81
    5d7e:	f3 4f       	sbci	r31, 0xF3	; 243
    5d80:	80 81       	ld	r24, Z
    5d82:	88 23       	and	r24, r24
    5d84:	69 f0       	breq	.+26     	; 0x5da0 <MB_S_Timer_ISR+0x5ba>
		if (Err) {
    5d86:	11 23       	and	r17, r17
    5d88:	41 f0       	breq	.+16     	; 0x5d9a <MB_S_Timer_ISR+0x5b4>
			MB_Frame[MB_N][1] |=(1<<7);
    5d8a:	81 81       	ldd	r24, Z+1	; 0x01
    5d8c:	80 68       	ori	r24, 0x80	; 128
    5d8e:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    5d90:	fe 01       	movw	r30, r28
    5d92:	e6 5b       	subi	r30, 0xB6	; 182
    5d94:	f7 4f       	sbci	r31, 0xF7	; 247
    5d96:	85 e0       	ldi	r24, 0x05	; 5
    5d98:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    5d9a:	83 2d       	mov	r24, r3
    5d9c:	0e 94 9b 2b 	call	0x5736	; 0x5736 <SetCRC_MB>
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    5da0:	11 23       	and	r17, r17
    5da2:	69 f0       	breq	.+26     	; 0x5dbe <MB_S_Timer_ISR+0x5d8>
		MB_CPT[MB_N][2]++;
    5da4:	fe 01       	movw	r30, r28
    5da6:	14 e0       	ldi	r17, 0x04	; 4
    5da8:	ee 0f       	add	r30, r30
    5daa:	ff 1f       	adc	r31, r31
    5dac:	1a 95       	dec	r17
    5dae:	e1 f7       	brne	.-8      	; 0x5da8 <MB_S_Timer_ISR+0x5c2>
    5db0:	eb 56       	subi	r30, 0x6B	; 107
    5db2:	f5 4f       	sbci	r31, 0xF5	; 245
    5db4:	80 81       	ld	r24, Z
    5db6:	91 81       	ldd	r25, Z+1	; 0x01
    5db8:	01 96       	adiw	r24, 0x01	; 1
    5dba:	91 83       	std	Z+1, r25	; 0x01
    5dbc:	80 83       	st	Z, r24
	if (MB_Frame[MB_N][0])
    5dbe:	fc 2f       	mov	r31, r28
    5dc0:	ee 27       	eor	r30, r30
    5dc2:	e1 55       	subi	r30, 0x51	; 81
    5dc4:	f3 4f       	sbci	r31, 0xF3	; 243
    5dc6:	80 81       	ld	r24, Z
    5dc8:	88 23       	and	r24, r24
    5dca:	21 f0       	breq	.+8      	; 0x5dd4 <MB_S_Timer_ISR+0x5ee>
		MB_Transm(MB_N);
    5dcc:	83 2d       	mov	r24, r3
    5dce:	0e 94 55 2a 	call	0x54aa	; 0x54aa <MB_Transm>
    5dd2:	16 c0       	rjmp	.+44     	; 0x5e00 <MB_S_Timer_ISR+0x61a>
	else {
		MB_CPT[MB_N][4]++;
    5dd4:	fe 01       	movw	r30, r28
    5dd6:	a4 e0       	ldi	r26, 0x04	; 4
    5dd8:	ee 0f       	add	r30, r30
    5dda:	ff 1f       	adc	r31, r31
    5ddc:	aa 95       	dec	r26
    5dde:	e1 f7       	brne	.-8      	; 0x5dd8 <MB_S_Timer_ISR+0x5f2>
    5de0:	e7 56       	subi	r30, 0x67	; 103
    5de2:	f5 4f       	sbci	r31, 0xF5	; 245
    5de4:	80 81       	ld	r24, Z
    5de6:	91 81       	ldd	r25, Z+1	; 0x01
    5de8:	01 96       	adiw	r24, 0x01	; 1
    5dea:	91 83       	std	Z+1, r25	; 0x01
    5dec:	80 83       	st	Z, r24
		MB_State[MB_N] = MB_Idle;
    5dee:	cc 59       	subi	r28, 0x9C	; 156
    5df0:	dc 4f       	sbci	r29, 0xFC	; 252
    5df2:	81 e0       	ldi	r24, 0x01	; 1
    5df4:	88 83       	st	Y, r24
    5df6:	f2 01       	movw	r30, r4
    5df8:	85 91       	lpm	r24, Z+
    5dfa:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    5dfc:	fc 01       	movw	r30, r24
    5dfe:	09 95       	icall
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    5e00:	df 91       	pop	r29
    5e02:	cf 91       	pop	r28
    5e04:	1f 91       	pop	r17
    5e06:	0f 91       	pop	r16
    5e08:	ff 90       	pop	r15
    5e0a:	ef 90       	pop	r14
    5e0c:	df 90       	pop	r13
    5e0e:	cf 90       	pop	r12
    5e10:	bf 90       	pop	r11
    5e12:	af 90       	pop	r10
    5e14:	9f 90       	pop	r9
    5e16:	8f 90       	pop	r8
    5e18:	7f 90       	pop	r7
    5e1a:	6f 90       	pop	r6
    5e1c:	5f 90       	pop	r5
    5e1e:	4f 90       	pop	r4
    5e20:	3f 90       	pop	r3
    5e22:	08 95       	ret

00005e24 <MB_S_Tx>:
    5e24:	94 e1       	ldi	r25, 0x14	; 20
    5e26:	89 9f       	mul	r24, r25
    5e28:	c0 01       	movw	r24, r0
    5e2a:	11 24       	eor	r1, r1
    5e2c:	86 52       	subi	r24, 0x26	; 38
    5e2e:	96 4b       	sbci	r25, 0xB6	; 182
    5e30:	fc 01       	movw	r30, r24
    5e32:	25 91       	lpm	r18, Z+
    5e34:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    5e36:	f9 01       	movw	r30, r18
    5e38:	09 95       	icall
}
    5e3a:	08 95       	ret

00005e3c <MB_Slave_Off>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
MB_Slave_Off(uint8_t MB_N, uint8_t S_N)
{
    5e3c:	21 e0       	ldi	r18, 0x01	; 1
    5e3e:	30 e0       	ldi	r19, 0x00	; 0
    5e40:	40 e0       	ldi	r20, 0x00	; 0
    5e42:	50 e0       	ldi	r21, 0x00	; 0
    5e44:	04 c0       	rjmp	.+8      	; 0x5e4e <MB_Slave_Off+0x12>
    5e46:	22 0f       	add	r18, r18
    5e48:	33 1f       	adc	r19, r19
    5e4a:	44 1f       	adc	r20, r20
    5e4c:	55 1f       	adc	r21, r21
    5e4e:	6a 95       	dec	r22
    5e50:	d2 f7       	brpl	.-12     	; 0x5e46 <MB_Slave_Off+0xa>
    5e52:	e8 2f       	mov	r30, r24
    5e54:	f0 e0       	ldi	r31, 0x00	; 0
    5e56:	ee 0f       	add	r30, r30
    5e58:	ff 1f       	adc	r31, r31
    5e5a:	ee 0f       	add	r30, r30
    5e5c:	ff 1f       	adc	r31, r31
    5e5e:	e4 58       	subi	r30, 0x84	; 132
    5e60:	f5 4f       	sbci	r31, 0xF5	; 245
    5e62:	80 81       	ld	r24, Z
    5e64:	91 81       	ldd	r25, Z+1	; 0x01
    5e66:	a2 81       	ldd	r26, Z+2	; 0x02
    5e68:	b3 81       	ldd	r27, Z+3	; 0x03
    5e6a:	28 23       	and	r18, r24
    5e6c:	39 23       	and	r19, r25
    5e6e:	4a 23       	and	r20, r26
    5e70:	5b 23       	and	r21, r27
	return SlaveOff[MB_N] &((uint32_t)1<<S_N);
}
    5e72:	b9 01       	movw	r22, r18
    5e74:	ca 01       	movw	r24, r20
    5e76:	08 95       	ret

00005e78 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5e78:	98 2f       	mov	r25, r24
	return MB_SingleState[MB_N]==MB_SingleIdle?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5e7a:	a8 2f       	mov	r26, r24
    5e7c:	b0 e0       	ldi	r27, 0x00	; 0
    5e7e:	fd 01       	movw	r30, r26
    5e80:	e1 56       	subi	r30, 0x61	; 97
    5e82:	fa 4f       	sbci	r31, 0xFA	; 250
    5e84:	80 81       	ld	r24, Z
    5e86:	88 23       	and	r24, r24
    5e88:	09 f0       	breq	.+2      	; 0x5e8c <GetReg+0x14>
    5e8a:	35 c0       	rjmp	.+106    	; 0x5ef6 <GetReg+0x7e>
    5e8c:	fd 01       	movw	r30, r26
    5e8e:	74 e0       	ldi	r23, 0x04	; 4
    5e90:	ee 0f       	add	r30, r30
    5e92:	ff 1f       	adc	r31, r31
    5e94:	7a 95       	dec	r23
    5e96:	e1 f7       	brne	.-8      	; 0x5e90 <GetReg+0x18>
    5e98:	ec 5f       	subi	r30, 0xFC	; 252
    5e9a:	fd 4f       	sbci	r31, 0xFD	; 253
    5e9c:	45 91       	lpm	r20, Z+
    5e9e:	54 91       	lpm	r21, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5ea0:	83 e0       	ldi	r24, 0x03	; 3
    5ea2:	98 9f       	mul	r25, r24
    5ea4:	f0 01       	movw	r30, r0
    5ea6:	11 24       	eor	r1, r1
    5ea8:	e8 56       	subi	r30, 0x68	; 104
    5eaa:	fb 4f       	sbci	r31, 0xFB	; 251
    5eac:	25 91       	lpm	r18, Z+
    5eae:	34 91       	lpm	r19, Z+
    5eb0:	fd 01       	movw	r30, r26
    5eb2:	ec 57       	subi	r30, 0x7C	; 124
    5eb4:	fa 4f       	sbci	r31, 0xFA	; 250
    5eb6:	80 81       	ld	r24, Z
    5eb8:	90 e0       	ldi	r25, 0x00	; 0
    5eba:	88 0f       	add	r24, r24
    5ebc:	99 1f       	adc	r25, r25
    5ebe:	88 0f       	add	r24, r24
    5ec0:	99 1f       	adc	r25, r25
    5ec2:	28 0f       	add	r18, r24
    5ec4:	39 1f       	adc	r19, r25
    5ec6:	2f 5f       	subi	r18, 0xFF	; 255
    5ec8:	3f 4f       	sbci	r19, 0xFF	; 255
    5eca:	f9 01       	movw	r30, r18
    5ecc:	65 91       	lpm	r22, Z+
    5ece:	74 91       	lpm	r23, Z+
    5ed0:	a6 57       	subi	r26, 0x76	; 118
    5ed2:	ba 4f       	sbci	r27, 0xFA	; 250
    5ed4:	8c 91       	ld	r24, X
    5ed6:	27 e0       	ldi	r18, 0x07	; 7
    5ed8:	82 9f       	mul	r24, r18
    5eda:	c0 01       	movw	r24, r0
    5edc:	11 24       	eor	r1, r1
    5ede:	68 0f       	add	r22, r24
    5ee0:	79 1f       	adc	r23, r25
    5ee2:	6b 5f       	subi	r22, 0xFB	; 251
    5ee4:	7f 4f       	sbci	r23, 0xFF	; 255
    5ee6:	fb 01       	movw	r30, r22
    5ee8:	85 91       	lpm	r24, Z+
    5eea:	94 91       	lpm	r25, Z+
    5eec:	88 0f       	add	r24, r24
    5eee:	99 1f       	adc	r25, r25
    5ef0:	48 0f       	add	r20, r24
    5ef2:	59 1f       	adc	r21, r25
    5ef4:	0b c0       	rjmp	.+22     	; 0x5f0c <GetReg+0x94>
    5ef6:	23 e0       	ldi	r18, 0x03	; 3
    5ef8:	aa 0f       	add	r26, r26
    5efa:	bb 1f       	adc	r27, r27
    5efc:	2a 95       	dec	r18
    5efe:	e1 f7       	brne	.-8      	; 0x5ef8 <GetReg+0x80>
    5f00:	a5 5b       	subi	r26, 0xB5	; 181
    5f02:	bc 4f       	sbci	r27, 0xFC	; 252
    5f04:	16 96       	adiw	r26, 0x06	; 6
    5f06:	4d 91       	ld	r20, X+
    5f08:	5c 91       	ld	r21, X
    5f0a:	17 97       	sbiw	r26, 0x07	; 7
}
    5f0c:	ca 01       	movw	r24, r20
    5f0e:	08 95       	ret

00005f10 <FormData>:

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    5f10:	af 92       	push	r10
    5f12:	bf 92       	push	r11
    5f14:	df 92       	push	r13
    5f16:	ef 92       	push	r14
    5f18:	ff 92       	push	r15
    5f1a:	0f 93       	push	r16
    5f1c:	1f 93       	push	r17
    5f1e:	cf 93       	push	r28
    5f20:	df 93       	push	r29
    5f22:	d8 2e       	mov	r13, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    5f24:	c8 2f       	mov	r28, r24
    5f26:	d0 e0       	ldi	r29, 0x00	; 0
    5f28:	fc 2e       	mov	r15, r28
    5f2a:	ee 24       	eor	r14, r14
    5f2c:	8f ea       	ldi	r24, 0xAF	; 175
    5f2e:	9c e0       	ldi	r25, 0x0C	; 12
    5f30:	e8 0e       	add	r14, r24
    5f32:	f9 1e       	adc	r15, r25
    5f34:	f7 01       	movw	r30, r14
    5f36:	81 81       	ldd	r24, Z+1	; 0x01
    5f38:	86 30       	cpi	r24, 0x06	; 6
    5f3a:	91 f0       	breq	.+36     	; 0x5f60 <FormData+0x50>
    5f3c:	87 30       	cpi	r24, 0x07	; 7
    5f3e:	28 f4       	brcc	.+10     	; 0x5f4a <FormData+0x3a>
    5f40:	81 50       	subi	r24, 0x01	; 1
    5f42:	84 30       	cpi	r24, 0x04	; 4
    5f44:	08 f0       	brcs	.+2      	; 0x5f48 <FormData+0x38>
    5f46:	fb c0       	rjmp	.+502    	; 0x613e <FormData+0x22e>
    5f48:	06 c0       	rjmp	.+12     	; 0x5f56 <FormData+0x46>
    5f4a:	8f 30       	cpi	r24, 0x0F	; 15
    5f4c:	f1 f0       	breq	.+60     	; 0x5f8a <FormData+0x7a>
    5f4e:	80 31       	cpi	r24, 0x10	; 16
    5f50:	09 f0       	breq	.+2      	; 0x5f54 <FormData+0x44>
    5f52:	f5 c0       	rjmp	.+490    	; 0x613e <FormData+0x22e>
    5f54:	ca c0       	rjmp	.+404    	; 0x60ea <FormData+0x1da>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    5f56:	c6 5b       	subi	r28, 0xB6	; 182
    5f58:	d7 4f       	sbci	r29, 0xF7	; 247
    5f5a:	88 e0       	ldi	r24, 0x08	; 8
    5f5c:	88 83       	st	Y, r24
    5f5e:	ef c0       	rjmp	.+478    	; 0x613e <FormData+0x22e>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    5f60:	fe 01       	movw	r30, r28
    5f62:	e6 5b       	subi	r30, 0xB6	; 182
    5f64:	f7 4f       	sbci	r31, 0xF7	; 247
    5f66:	88 e0       	ldi	r24, 0x08	; 8
    5f68:	80 83       	st	Z, r24
		Reg = GetReg(MB_N);
    5f6a:	8d 2d       	mov	r24, r13
    5f6c:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <GetReg>
    5f70:	dc 01       	movw	r26, r24
		MB_Frame[MB_N][4] = *Reg>>8;
    5f72:	fc 2f       	mov	r31, r28
    5f74:	ee 27       	eor	r30, r30
    5f76:	ed 54       	subi	r30, 0x4D	; 77
    5f78:	f3 4f       	sbci	r31, 0xF3	; 243
    5f7a:	11 96       	adiw	r26, 0x01	; 1
    5f7c:	8c 91       	ld	r24, X
    5f7e:	11 97       	sbiw	r26, 0x01	; 1
    5f80:	80 83       	st	Z, r24
		MB_Frame[MB_N][5] = *Reg;
    5f82:	8c 91       	ld	r24, X
    5f84:	f7 01       	movw	r30, r14
    5f86:	85 83       	std	Z+5, r24	; 0x05
    5f88:	da c0       	rjmp	.+436    	; 0x613e <FormData+0x22e>
    5f8a:	fc 2f       	mov	r31, r28
    5f8c:	ee 27       	eor	r30, r30
    5f8e:	ed 54       	subi	r30, 0x4D	; 77
    5f90:	f3 4f       	sbci	r31, 0xF3	; 243
    5f92:	90 81       	ld	r25, Z
    5f94:	80 e0       	ldi	r24, 0x00	; 0
    5f96:	f7 01       	movw	r30, r14
    5f98:	25 81       	ldd	r18, Z+5	; 0x05
    5f9a:	62 2f       	mov	r22, r18
    5f9c:	70 e0       	ldi	r23, 0x00	; 0
    5f9e:	68 2b       	or	r22, r24
    5fa0:	79 2b       	or	r23, r25
		break;
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    5fa2:	ab 01       	movw	r20, r22
    5fa4:	f3 e0       	ldi	r31, 0x03	; 3
    5fa6:	56 95       	lsr	r21
    5fa8:	47 95       	ror	r20
    5faa:	fa 95       	dec	r31
    5fac:	e1 f7       	brne	.-8      	; 0x5fa6 <FormData+0x96>
    5fae:	20 e0       	ldi	r18, 0x00	; 0
    5fb0:	cb 01       	movw	r24, r22
    5fb2:	87 70       	andi	r24, 0x07	; 7
    5fb4:	90 70       	andi	r25, 0x00	; 0
    5fb6:	89 2b       	or	r24, r25
    5fb8:	09 f0       	breq	.+2      	; 0x5fbc <FormData+0xac>
    5fba:	21 e0       	ldi	r18, 0x01	; 1
    5fbc:	82 2f       	mov	r24, r18
    5fbe:	84 0f       	add	r24, r20
    5fc0:	fc 2f       	mov	r31, r28
    5fc2:	ee 27       	eor	r30, r30
    5fc4:	e1 55       	subi	r30, 0x51	; 81
    5fc6:	f3 4f       	sbci	r31, 0xF3	; 243
    5fc8:	86 83       	std	Z+6, r24	; 0x06
    5fca:	de 01       	movw	r26, r28
    5fcc:	a6 5b       	subi	r26, 0xB6	; 182
    5fce:	b7 4f       	sbci	r27, 0xF7	; 247
    5fd0:	87 5f       	subi	r24, 0xF7	; 247
    5fd2:	8c 93       	st	X, r24
		MB_Frame[MB_N][7+Qt/8] = 0;
    5fd4:	e4 0f       	add	r30, r20
    5fd6:	f5 1f       	adc	r31, r21
    5fd8:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]==MB_SingleIdle) {
    5fda:	fe 01       	movw	r30, r28
    5fdc:	e1 56       	subi	r30, 0x61	; 97
    5fde:	fa 4f       	sbci	r31, 0xFA	; 250
    5fe0:	80 81       	ld	r24, Z
    5fe2:	88 23       	and	r24, r24
    5fe4:	09 f0       	breq	.+2      	; 0x5fe8 <FormData+0xd8>
    5fe6:	33 c0       	rjmp	.+102    	; 0x604e <FormData+0x13e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fe8:	fe 01       	movw	r30, r28
    5fea:	54 e0       	ldi	r21, 0x04	; 4
    5fec:	ee 0f       	add	r30, r30
    5fee:	ff 1f       	adc	r31, r31
    5ff0:	5a 95       	dec	r21
    5ff2:	e1 f7       	brne	.-8      	; 0x5fec <FormData+0xdc>
    5ff4:	e4 50       	subi	r30, 0x04	; 4
    5ff6:	fe 4f       	sbci	r31, 0xFE	; 254
			Discr = prp(&Modbus_Map[MB_N].Coil);
    5ff8:	e5 90       	lpm	r14, Z+
    5ffa:	f4 90       	lpm	r15, Z+
    5ffc:	83 e0       	ldi	r24, 0x03	; 3
    5ffe:	d8 9e       	mul	r13, r24
    6000:	f0 01       	movw	r30, r0
    6002:	11 24       	eor	r1, r1
    6004:	e8 56       	subi	r30, 0x68	; 104
    6006:	fb 4f       	sbci	r31, 0xFB	; 251
    6008:	25 91       	lpm	r18, Z+
    600a:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    600c:	fe 01       	movw	r30, r28
    600e:	ec 57       	subi	r30, 0x7C	; 124
    6010:	fa 4f       	sbci	r31, 0xFA	; 250
    6012:	80 81       	ld	r24, Z
    6014:	90 e0       	ldi	r25, 0x00	; 0
    6016:	88 0f       	add	r24, r24
    6018:	99 1f       	adc	r25, r25
    601a:	88 0f       	add	r24, r24
    601c:	99 1f       	adc	r25, r25
    601e:	28 0f       	add	r18, r24
    6020:	39 1f       	adc	r19, r25
    6022:	2f 5f       	subi	r18, 0xFF	; 255
    6024:	3f 4f       	sbci	r19, 0xFF	; 255
    6026:	f9 01       	movw	r30, r18
    6028:	45 91       	lpm	r20, Z+
    602a:	54 91       	lpm	r21, Z+
    602c:	fe 01       	movw	r30, r28
    602e:	e6 57       	subi	r30, 0x76	; 118
    6030:	fa 4f       	sbci	r31, 0xFA	; 250
    6032:	80 81       	ld	r24, Z
    6034:	27 e0       	ldi	r18, 0x07	; 7
    6036:	82 9f       	mul	r24, r18
    6038:	c0 01       	movw	r24, r0
    603a:	11 24       	eor	r1, r1
    603c:	48 0f       	add	r20, r24
    603e:	59 1f       	adc	r21, r25
    6040:	4b 5f       	subi	r20, 0xFB	; 251
    6042:	5f 4f       	sbci	r21, 0xFF	; 255
    6044:	fa 01       	movw	r30, r20
    6046:	85 91       	lpm	r24, Z+
    6048:	94 91       	lpm	r25, Z+
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    604a:	08 2f       	mov	r16, r24
    604c:	0b c0       	rjmp	.+22     	; 0x6064 <FormData+0x154>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    604e:	fe 01       	movw	r30, r28
    6050:	03 e0       	ldi	r16, 0x03	; 3
    6052:	ee 0f       	add	r30, r30
    6054:	ff 1f       	adc	r31, r31
    6056:	0a 95       	dec	r16
    6058:	e1 f7       	brne	.-8      	; 0x6052 <FormData+0x142>
    605a:	e5 5b       	subi	r30, 0xB5	; 181
    605c:	fc 4f       	sbci	r31, 0xFC	; 252
    605e:	e6 80       	ldd	r14, Z+6	; 0x06
    6060:	f7 80       	ldd	r15, Z+7	; 0x07
    6062:	00 e0       	ldi	r16, 0x00	; 0
    6064:	50 e0       	ldi	r21, 0x00	; 0
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6066:	11 e0       	ldi	r17, 0x01	; 1
    6068:	a1 2e       	mov	r10, r17
    606a:	b1 2c       	mov	r11, r1
    606c:	bc 2f       	mov	r27, r28
    606e:	aa 27       	eor	r26, r26
    6070:	36 c0       	rjmp	.+108    	; 0x60de <FormData+0x1ce>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6072:	25 2f       	mov	r18, r21
    6074:	20 0f       	add	r18, r16
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6076:	35 2f       	mov	r19, r21
    6078:	36 95       	lsr	r19
    607a:	36 95       	lsr	r19
    607c:	36 95       	lsr	r19
    607e:	39 5f       	subi	r19, 0xF9	; 249
    6080:	87 70       	andi	r24, 0x07	; 7
    6082:	90 70       	andi	r25, 0x00	; 0
    6084:	f5 01       	movw	r30, r10
    6086:	02 c0       	rjmp	.+4      	; 0x608c <FormData+0x17c>
    6088:	ee 0f       	add	r30, r30
    608a:	ff 1f       	adc	r31, r31
    608c:	8a 95       	dec	r24
    608e:	e2 f7       	brpl	.-8      	; 0x6088 <FormData+0x178>
    6090:	4e 2f       	mov	r20, r30
			if (Discr[j/8] &(1<<j%8))
    6092:	82 2f       	mov	r24, r18
    6094:	86 95       	lsr	r24
    6096:	86 95       	lsr	r24
    6098:	86 95       	lsr	r24
    609a:	f7 01       	movw	r30, r14
    609c:	e8 0f       	add	r30, r24
    609e:	f1 1d       	adc	r31, r1
    60a0:	80 81       	ld	r24, Z
    60a2:	90 e0       	ldi	r25, 0x00	; 0
    60a4:	27 70       	andi	r18, 0x07	; 7
    60a6:	02 c0       	rjmp	.+4      	; 0x60ac <FormData+0x19c>
    60a8:	95 95       	asr	r25
    60aa:	87 95       	ror	r24
    60ac:	2a 95       	dec	r18
    60ae:	e2 f7       	brpl	.-8      	; 0x60a8 <FormData+0x198>
    60b0:	23 2f       	mov	r18, r19
    60b2:	30 e0       	ldi	r19, 0x00	; 0
    60b4:	80 ff       	sbrs	r24, 0
    60b6:	09 c0       	rjmp	.+18     	; 0x60ca <FormData+0x1ba>
				MB_Frame[MB_N][Byte] |=Bit;
    60b8:	fd 01       	movw	r30, r26
    60ba:	e2 0f       	add	r30, r18
    60bc:	f3 1f       	adc	r31, r19
    60be:	e1 55       	subi	r30, 0x51	; 81
    60c0:	f3 4f       	sbci	r31, 0xF3	; 243
    60c2:	80 81       	ld	r24, Z
    60c4:	84 2b       	or	r24, r20
    60c6:	80 83       	st	Z, r24
    60c8:	09 c0       	rjmp	.+18     	; 0x60dc <FormData+0x1cc>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    60ca:	fd 01       	movw	r30, r26
    60cc:	e2 0f       	add	r30, r18
    60ce:	f3 1f       	adc	r31, r19
    60d0:	e1 55       	subi	r30, 0x51	; 81
    60d2:	f3 4f       	sbci	r31, 0xF3	; 243
    60d4:	40 95       	com	r20
    60d6:	80 81       	ld	r24, Z
    60d8:	48 23       	and	r20, r24
    60da:	40 83       	st	Z, r20
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    60dc:	5f 5f       	subi	r21, 0xFF	; 255
    60de:	85 2f       	mov	r24, r21
    60e0:	90 e0       	ldi	r25, 0x00	; 0
    60e2:	86 17       	cp	r24, r22
    60e4:	97 07       	cpc	r25, r23
    60e6:	28 f2       	brcs	.-118    	; 0x6072 <FormData+0x162>
    60e8:	2a c0       	rjmp	.+84     	; 0x613e <FormData+0x22e>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    60ea:	87 01       	movw	r16, r14
    60ec:	0b 5f       	subi	r16, 0xFB	; 251
    60ee:	1f 4f       	sbci	r17, 0xFF	; 255
    60f0:	f7 01       	movw	r30, r14
    60f2:	85 81       	ldd	r24, Z+5	; 0x05
    60f4:	90 e0       	ldi	r25, 0x00	; 0
    60f6:	88 0f       	add	r24, r24
    60f8:	99 1f       	adc	r25, r25
    60fa:	86 83       	std	Z+6, r24	; 0x06
    60fc:	c6 5b       	subi	r28, 0xB6	; 182
    60fe:	d7 4f       	sbci	r29, 0xF7	; 247
    6100:	87 5f       	subi	r24, 0xF7	; 247
    6102:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6104:	8d 2d       	mov	r24, r13
    6106:	0e 94 3c 2f 	call	0x5e78	; 0x5e78 <GetReg>
    610a:	bc 01       	movw	r22, r24
    610c:	20 e0       	ldi	r18, 0x00	; 0
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    610e:	a7 01       	movw	r20, r14
    6110:	e8 01       	movw	r28, r16
    6112:	12 c0       	rjmp	.+36     	; 0x6138 <FormData+0x228>
			uint8_t j = i*2;
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6114:	82 2f       	mov	r24, r18
    6116:	90 e0       	ldi	r25, 0x00	; 0
    6118:	88 0f       	add	r24, r24
    611a:	99 1f       	adc	r25, r25
    611c:	fb 01       	movw	r30, r22
    611e:	e8 0f       	add	r30, r24
    6120:	f9 1f       	adc	r31, r25
    6122:	da 01       	movw	r26, r20
    6124:	a8 0f       	add	r26, r24
    6126:	b1 1d       	adc	r27, r1
    6128:	81 81       	ldd	r24, Z+1	; 0x01
    612a:	17 96       	adiw	r26, 0x07	; 7
    612c:	8c 93       	st	X, r24
    612e:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    6130:	80 81       	ld	r24, Z
    6132:	18 96       	adiw	r26, 0x08	; 8
    6134:	8c 93       	st	X, r24
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6136:	2f 5f       	subi	r18, 0xFF	; 255
    6138:	88 81       	ld	r24, Y
    613a:	28 17       	cp	r18, r24
    613c:	58 f3       	brcs	.-42     	; 0x6114 <FormData+0x204>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    613e:	8d 2d       	mov	r24, r13
    6140:	0e 94 9b 2b 	call	0x5736	; 0x5736 <SetCRC_MB>
}
    6144:	df 91       	pop	r29
    6146:	cf 91       	pop	r28
    6148:	1f 91       	pop	r17
    614a:	0f 91       	pop	r16
    614c:	ff 90       	pop	r15
    614e:	ef 90       	pop	r14
    6150:	df 90       	pop	r13
    6152:	bf 90       	pop	r11
    6154:	af 90       	pop	r10
    6156:	08 95       	ret

00006158 <FormQuery>:

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    6158:	cf 93       	push	r28
    615a:	df 93       	push	r29

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    615c:	93 e0       	ldi	r25, 0x03	; 3
    615e:	89 9f       	mul	r24, r25
    6160:	f0 01       	movw	r30, r0
    6162:	11 24       	eor	r1, r1
    6164:	e8 56       	subi	r30, 0x68	; 104
    6166:	fb 4f       	sbci	r31, 0xFB	; 251
    6168:	65 91       	lpm	r22, Z+
    616a:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    616c:	48 2f       	mov	r20, r24
    616e:	50 e0       	ldi	r21, 0x00	; 0
    6170:	fa 01       	movw	r30, r20
    6172:	ec 57       	subi	r30, 0x7C	; 124
    6174:	fa 4f       	sbci	r31, 0xFA	; 250
    6176:	20 81       	ld	r18, Z
    6178:	30 e0       	ldi	r19, 0x00	; 0
    617a:	22 0f       	add	r18, r18
    617c:	33 1f       	adc	r19, r19
    617e:	22 0f       	add	r18, r18
    6180:	33 1f       	adc	r19, r19
    6182:	62 0f       	add	r22, r18
    6184:	73 1f       	adc	r23, r19
    6186:	fb 01       	movw	r30, r22
    6188:	31 96       	adiw	r30, 0x01	; 1
    618a:	c5 91       	lpm	r28, Z+
    618c:	d4 91       	lpm	r29, Z+
// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
	MB_Slave *Slave = GetSlave(MB_N);
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    618e:	fa 01       	movw	r30, r20
    6190:	e6 57       	subi	r30, 0x76	; 118
    6192:	fa 4f       	sbci	r31, 0xFA	; 250
    6194:	20 81       	ld	r18, Z
    6196:	97 e0       	ldi	r25, 0x07	; 7
    6198:	29 9f       	mul	r18, r25
    619a:	90 01       	movw	r18, r0
    619c:	11 24       	eor	r1, r1
    619e:	c2 0f       	add	r28, r18
    61a0:	d3 1f       	adc	r29, r19

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    61a2:	fb 01       	movw	r30, r22
    61a4:	94 91       	lpm	r25, Z+

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    61a6:	2f ea       	ldi	r18, 0xAF	; 175
    61a8:	3c e0       	ldi	r19, 0x0C	; 12
    61aa:	b4 2f       	mov	r27, r20
    61ac:	aa 27       	eor	r26, r26
    61ae:	a2 0f       	add	r26, r18
    61b0:	b3 1f       	adc	r27, r19
    61b2:	9c 93       	st	X, r25
    61b4:	fe 01       	movw	r30, r28
    61b6:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][1] = prb(&Query->Func);
    61b8:	11 96       	adiw	r26, 0x01	; 1
    61ba:	9c 93       	st	X, r25
    61bc:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    61be:	be 01       	movw	r22, r28
    61c0:	6f 5f       	subi	r22, 0xFF	; 255
    61c2:	7f 4f       	sbci	r23, 0xFF	; 255
    61c4:	6f 5f       	subi	r22, 0xFF	; 255
    61c6:	7f 4f       	sbci	r23, 0xFF	; 255
    61c8:	fb 01       	movw	r30, r22
    61ca:	94 91       	lpm	r25, Z+
    61cc:	61 50       	subi	r22, 0x01	; 1
    61ce:	70 40       	sbci	r23, 0x00	; 0
    61d0:	fd 01       	movw	r30, r26
    61d2:	92 83       	std	Z+2, r25	; 0x02
    61d4:	fb 01       	movw	r30, r22
    61d6:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    61d8:	13 96       	adiw	r26, 0x03	; 3
    61da:	9c 93       	st	X, r25
    61dc:	13 97       	sbiw	r26, 0x03	; 3
    61de:	24 96       	adiw	r28, 0x04	; 4
    61e0:	fe 01       	movw	r30, r28
    61e2:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    61e4:	fd 01       	movw	r30, r26
    61e6:	94 83       	std	Z+4, r25	; 0x04
    61e8:	21 97       	sbiw	r28, 0x01	; 1
    61ea:	fe 01       	movw	r30, r28
    61ec:	94 91       	lpm	r25, Z+
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    61ee:	15 96       	adiw	r26, 0x05	; 5
    61f0:	9c 93       	st	X, r25

	FormData(MB_N);
    61f2:	0e 94 88 2f 	call	0x5f10	; 0x5f10 <FormData>
}
    61f6:	df 91       	pop	r29
    61f8:	cf 91       	pop	r28
    61fa:	08 95       	ret

000061fc <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
    61fc:	0f 93       	push	r16
    61fe:	1f 93       	push	r17
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6200:	08 2f       	mov	r16, r24
    6202:	10 e0       	ldi	r17, 0x00	; 0
    6204:	4f ea       	ldi	r20, 0xAF	; 175
    6206:	5c e0       	ldi	r21, 0x0C	; 12
    6208:	b0 2f       	mov	r27, r16
    620a:	aa 27       	eor	r26, r26
    620c:	a4 0f       	add	r26, r20
    620e:	b5 1f       	adc	r27, r21
    6210:	2b e4       	ldi	r18, 0x4B	; 75
    6212:	33 e0       	ldi	r19, 0x03	; 3
    6214:	f8 01       	movw	r30, r16
    6216:	63 e0       	ldi	r22, 0x03	; 3
    6218:	ee 0f       	add	r30, r30
    621a:	ff 1f       	adc	r31, r31
    621c:	6a 95       	dec	r22
    621e:	e1 f7       	brne	.-8      	; 0x6218 <FormSingle+0x1c>
    6220:	e2 0f       	add	r30, r18
    6222:	f3 1f       	adc	r31, r19
    6224:	90 81       	ld	r25, Z
    6226:	9c 93       	st	X, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    6228:	91 81       	ldd	r25, Z+1	; 0x01
    622a:	11 96       	adiw	r26, 0x01	; 1
    622c:	9c 93       	st	X, r25
    622e:	11 97       	sbiw	r26, 0x01	; 1
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    6230:	f8 01       	movw	r30, r16
    6232:	53 e0       	ldi	r21, 0x03	; 3
    6234:	ee 0f       	add	r30, r30
    6236:	ff 1f       	adc	r31, r31
    6238:	5a 95       	dec	r21
    623a:	e1 f7       	brne	.-8      	; 0x6234 <FormSingle+0x38>
    623c:	32 96       	adiw	r30, 0x02	; 2
    623e:	e2 0f       	add	r30, r18
    6240:	f3 1f       	adc	r31, r19
    6242:	60 81       	ld	r22, Z
    6244:	91 81       	ldd	r25, Z+1	; 0x01
    6246:	fd 01       	movw	r30, r26
    6248:	92 83       	std	Z+2, r25	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    624a:	13 96       	adiw	r26, 0x03	; 3
    624c:	6c 93       	st	X, r22
    624e:	13 97       	sbiw	r26, 0x03	; 3
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    6250:	f8 01       	movw	r30, r16
    6252:	93 e0       	ldi	r25, 0x03	; 3
    6254:	ee 0f       	add	r30, r30
    6256:	ff 1f       	adc	r31, r31
    6258:	9a 95       	dec	r25
    625a:	e1 f7       	brne	.-8      	; 0x6254 <FormSingle+0x58>
    625c:	34 96       	adiw	r30, 0x04	; 4
    625e:	e2 0f       	add	r30, r18
    6260:	f3 1f       	adc	r31, r19
    6262:	60 81       	ld	r22, Z
    6264:	91 81       	ldd	r25, Z+1	; 0x01
    6266:	fd 01       	movw	r30, r26
    6268:	94 83       	std	Z+4, r25	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    626a:	15 96       	adiw	r26, 0x05	; 5
    626c:	6c 93       	st	X, r22

	FormData(MB_N);
    626e:	0e 94 88 2f 	call	0x5f10	; 0x5f10 <FormData>
	MB_SingleState[MB_N] = MB_SingleExec;
    6272:	01 56       	subi	r16, 0x61	; 97
    6274:	1a 4f       	sbci	r17, 0xFA	; 250
    6276:	82 e0       	ldi	r24, 0x02	; 2
    6278:	f8 01       	movw	r30, r16
    627a:	80 83       	st	Z, r24
}
    627c:	1f 91       	pop	r17
    627e:	0f 91       	pop	r16
    6280:	08 95       	ret

00006282 <NextSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    6282:	2f 92       	push	r2
    6284:	3f 92       	push	r3
    6286:	4f 92       	push	r4
    6288:	5f 92       	push	r5
    628a:	6f 92       	push	r6
    628c:	7f 92       	push	r7
    628e:	8f 92       	push	r8
    6290:	9f 92       	push	r9
    6292:	af 92       	push	r10
    6294:	bf 92       	push	r11
    6296:	cf 92       	push	r12
    6298:	df 92       	push	r13
    629a:	ef 92       	push	r14
    629c:	ff 92       	push	r15
    629e:	0f 93       	push	r16
    62a0:	1f 93       	push	r17
    62a2:	cf 93       	push	r28
    62a4:	df 93       	push	r29
    62a6:	68 2e       	mov	r6, r24
    62a8:	e3 e0       	ldi	r30, 0x03	; 3
    62aa:	8e 9f       	mul	r24, r30
    62ac:	f0 01       	movw	r30, r0
    62ae:	11 24       	eor	r1, r1
    62b0:	e6 56       	subi	r30, 0x66	; 102
    62b2:	fb 4f       	sbci	r31, 0xFB	; 251
    62b4:	74 90       	lpm	r7, Z+
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    62b6:	b0 90 59 03 	lds	r11, 0x0359
    62ba:	82 e0       	ldi	r24, 0x02	; 2
    62bc:	b8 0e       	add	r11, r24
    62be:	3b 2c       	mov	r3, r11
    62c0:	36 0c       	add	r3, r6
    62c2:	9e ef       	ldi	r25, 0xFE	; 254
    62c4:	b9 0e       	add	r11, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    62c6:	03 2d       	mov	r16, r3
    62c8:	10 e0       	ldi	r17, 0x00	; 0
    62ca:	22 24       	eor	r2, r2
    62cc:	aa 24       	eor	r10, r10
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    62ce:	c6 2d       	mov	r28, r6
    62d0:	d0 e0       	ldi	r29, 0x00	; 0
    62d2:	64 e8       	ldi	r22, 0x84	; 132
    62d4:	e6 2e       	mov	r14, r22
    62d6:	65 e0       	ldi	r22, 0x05	; 5
    62d8:	f6 2e       	mov	r15, r22
    62da:	ec 0e       	add	r14, r28
    62dc:	fd 1e       	adc	r15, r29
    62de:	00 0f       	add	r16, r16
    62e0:	11 1f       	adc	r17, r17
    62e2:	0b 5d       	subi	r16, 0xDB	; 219
    62e4:	1d 4f       	sbci	r17, 0xFD	; 253
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    62e6:	ce 01       	movw	r24, r28
    62e8:	88 0f       	add	r24, r24
    62ea:	99 1f       	adc	r25, r25
    62ec:	38 eb       	ldi	r19, 0xB8	; 184
    62ee:	43 2e       	mov	r4, r19
    62f0:	38 e0       	ldi	r19, 0x08	; 8
    62f2:	53 2e       	mov	r5, r19
    62f4:	48 0e       	add	r4, r24
    62f6:	59 1e       	adc	r5, r25
    62f8:	28 eb       	ldi	r18, 0xB8	; 184
    62fa:	82 2e       	mov	r8, r18
    62fc:	27 e0       	ldi	r18, 0x07	; 7
    62fe:	92 2e       	mov	r9, r18
    6300:	88 0e       	add	r8, r24
    6302:	99 1e       	adc	r9, r25
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    6304:	6e 01       	movw	r12, r28
    6306:	cc 0c       	add	r12, r12
    6308:	dd 1c       	adc	r13, r13
    630a:	cc 0c       	add	r12, r12
    630c:	dd 1c       	adc	r13, r13
    630e:	e5 e5       	ldi	r30, 0x55	; 85
    6310:	f3 e0       	ldi	r31, 0x03	; 3
    6312:	ce 0e       	add	r12, r30
    6314:	df 1e       	adc	r13, r31
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    6316:	f7 01       	movw	r30, r14
    6318:	80 81       	ld	r24, Z
    631a:	8f 5f       	subi	r24, 0xFF	; 255
    631c:	80 83       	st	Z, r24
    631e:	87 15       	cp	r24, r7
    6320:	01 f5       	brne	.+64     	; 0x6362 <NextSlave+0xe0>
			CurrSlave[MB_N] = 0;
    6322:	10 82       	st	Z, r1

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6324:	8f b7       	in	r24, 0x3f	; 63
    6326:	80 78       	andi	r24, 0x80	; 128
    6328:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    632c:	f8 94       	cli
    632e:	f8 01       	movw	r30, r16
    6330:	20 81       	ld	r18, Z
    6332:	31 81       	ldd	r19, Z+1	; 0x01

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6334:	88 23       	and	r24, r24
    6336:	09 f0       	breq	.+2      	; 0x633a <NextSlave+0xb8>
		sei();
    6338:	78 94       	sei
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    633a:	20 95       	com	r18
    633c:	30 95       	com	r19
    633e:	f2 01       	movw	r30, r4
    6340:	31 83       	std	Z+1, r19	; 0x01
    6342:	20 83       	st	Z, r18
    6344:	f4 01       	movw	r30, r8
    6346:	80 81       	ld	r24, Z
    6348:	91 81       	ldd	r25, Z+1	; 0x01
    634a:	82 17       	cp	r24, r18
    634c:	93 07       	cpc	r25, r19
    634e:	10 f4       	brcc	.+4      	; 0x6354 <NextSlave+0xd2>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    6350:	31 83       	std	Z+1, r19	; 0x01
    6352:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6354:	83 2d       	mov	r24, r3
    6356:	6f ef       	ldi	r22, 0xFF	; 255
    6358:	7f ef       	ldi	r23, 0xFF	; 255
    635a:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    635e:	22 24       	eor	r2, r2
    6360:	23 94       	inc	r2
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    6362:	f6 01       	movw	r30, r12
    6364:	80 81       	ld	r24, Z
    6366:	91 81       	ldd	r25, Z+1	; 0x01
    6368:	a2 81       	ldd	r26, Z+2	; 0x02
    636a:	b3 81       	ldd	r27, Z+3	; 0x03
    636c:	f7 01       	movw	r30, r14
    636e:	00 80       	ld	r0, Z
    6370:	04 c0       	rjmp	.+8      	; 0x637a <NextSlave+0xf8>
    6372:	b6 95       	lsr	r27
    6374:	a7 95       	ror	r26
    6376:	97 95       	ror	r25
    6378:	87 95       	ror	r24
    637a:	0a 94       	dec	r0
    637c:	d2 f7       	brpl	.-12     	; 0x6372 <NextSlave+0xf0>
    637e:	81 70       	andi	r24, 0x01	; 1
    6380:	90 70       	andi	r25, 0x00	; 0
    6382:	88 23       	and	r24, r24
    6384:	19 f0       	breq	.+6      	; 0x638c <NextSlave+0x10a>
    6386:	a3 94       	inc	r10
    6388:	a7 14       	cp	r10, r7
    638a:	28 f2       	brcs	.-118    	; 0x6316 <NextSlave+0x94>
	if (i==SlaveQt) {
    638c:	a7 14       	cp	r10, r7
    638e:	09 f5       	brne	.+66     	; 0x63d2 <NextSlave+0x150>

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6390:	fe 01       	movw	r30, r28
    6392:	ee 0f       	add	r30, r30
    6394:	ff 1f       	adc	r31, r31
    6396:	ee 0f       	add	r30, r30
    6398:	ff 1f       	adc	r31, r31
    639a:	eb 5a       	subi	r30, 0xAB	; 171
    639c:	fc 4f       	sbci	r31, 0xFC	; 252
    639e:	10 82       	st	Z, r1
    63a0:	11 82       	std	Z+1, r1	; 0x01
    63a2:	12 82       	std	Z+2, r1	; 0x02
    63a4:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    63a6:	b3 94       	inc	r11
    63a8:	fe 01       	movw	r30, r28
    63aa:	e3 59       	subi	r30, 0x93	; 147
    63ac:	fc 4f       	sbci	r31, 0xFC	; 252
    63ae:	60 81       	ld	r22, Z
    63b0:	84 e6       	ldi	r24, 0x64	; 100
    63b2:	68 9f       	mul	r22, r24
    63b4:	b0 01       	movw	r22, r0
    63b6:	11 24       	eor	r1, r1
    63b8:	8b 2d       	mov	r24, r11
    63ba:	86 0d       	add	r24, r6
    63bc:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
	if (i==SlaveQt) {
		SlavesOn(MB_N);
		if (++CurrSlave[MB_N]==SlaveQt)
    63c0:	fe 01       	movw	r30, r28
    63c2:	ec 57       	subi	r30, 0x7C	; 124
    63c4:	fa 4f       	sbci	r31, 0xFA	; 250
    63c6:	80 81       	ld	r24, Z
    63c8:	8f 5f       	subi	r24, 0xFF	; 255
    63ca:	80 83       	st	Z, r24
    63cc:	8a 15       	cp	r24, r10
    63ce:	09 f4       	brne	.+2      	; 0x63d2 <NextSlave+0x150>
			CurrSlave[MB_N] = 0;
    63d0:	10 82       	st	Z, r1
	}
	CurrQuery[MB_N] = 0;
    63d2:	c6 57       	subi	r28, 0x76	; 118
    63d4:	da 4f       	sbci	r29, 0xFA	; 250
    63d6:	18 82       	st	Y, r1
	return Over;
}
    63d8:	82 2d       	mov	r24, r2
    63da:	df 91       	pop	r29
    63dc:	cf 91       	pop	r28
    63de:	1f 91       	pop	r17
    63e0:	0f 91       	pop	r16
    63e2:	ff 90       	pop	r15
    63e4:	ef 90       	pop	r14
    63e6:	df 90       	pop	r13
    63e8:	cf 90       	pop	r12
    63ea:	bf 90       	pop	r11
    63ec:	af 90       	pop	r10
    63ee:	9f 90       	pop	r9
    63f0:	8f 90       	pop	r8
    63f2:	7f 90       	pop	r7
    63f4:	6f 90       	pop	r6
    63f6:	5f 90       	pop	r5
    63f8:	4f 90       	pop	r4
    63fa:	3f 90       	pop	r3
    63fc:	2f 90       	pop	r2
    63fe:	08 95       	ret

00006400 <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    6400:	ef 92       	push	r14
    6402:	ff 92       	push	r15
    6404:	1f 93       	push	r17
    6406:	cf 93       	push	r28
    6408:	df 93       	push	r29
    640a:	18 2f       	mov	r17, r24
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    640c:	68 2f       	mov	r22, r24
    640e:	70 e0       	ldi	r23, 0x00	; 0
    6410:	fb 01       	movw	r30, r22
    6412:	e1 56       	subi	r30, 0x61	; 97
    6414:	fa 4f       	sbci	r31, 0xFA	; 250
    6416:	80 81       	ld	r24, Z
    6418:	82 30       	cpi	r24, 0x02	; 2
    641a:	11 f4       	brne	.+4      	; 0x6420 <FailSlave+0x20>
		MB_SingleState[MB_N] = MB_SingleIdle;
    641c:	10 82       	st	Z, r1
    641e:	19 c0       	rjmp	.+50     	; 0x6452 <FailSlave+0x52>
	else{
		MB_CPT[MB_N][4]++;	// -    
    6420:	fb 01       	movw	r30, r22
    6422:	a4 e0       	ldi	r26, 0x04	; 4
    6424:	ee 0f       	add	r30, r30
    6426:	ff 1f       	adc	r31, r31
    6428:	aa 95       	dec	r26
    642a:	e1 f7       	brne	.-8      	; 0x6424 <FailSlave+0x24>
    642c:	e7 56       	subi	r30, 0x67	; 103
    642e:	f5 4f       	sbci	r31, 0xF5	; 245
    6430:	80 81       	ld	r24, Z
    6432:	91 81       	ldd	r25, Z+1	; 0x01
    6434:	01 96       	adiw	r24, 0x01	; 1
    6436:	91 83       	std	Z+1, r25	; 0x01
    6438:	80 83       	st	Z, r24
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    643a:	eb 01       	movw	r28, r22
    643c:	cc 5a       	subi	r28, 0xAC	; 172
    643e:	dc 4f       	sbci	r29, 0xFC	; 252
    6440:	88 81       	ld	r24, Y
    6442:	8f 5f       	subi	r24, 0xFF	; 255
    6444:	88 83       	st	Y, r24
    6446:	fb 01       	movw	r30, r22
    6448:	eb 5b       	subi	r30, 0xBB	; 187
    644a:	f7 4f       	sbci	r31, 0xF7	; 247
    644c:	90 81       	ld	r25, Z
    644e:	89 17       	cp	r24, r25
    6450:	11 f0       	breq	.+4      	; 0x6456 <FailSlave+0x56>
    6452:	80 e0       	ldi	r24, 0x00	; 0
    6454:	37 c0       	rjmp	.+110    	; 0x64c4 <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    6456:	fb 01       	movw	r30, r22
    6458:	ec 57       	subi	r30, 0x7C	; 124
    645a:	fa 4f       	sbci	r31, 0xFA	; 250
    645c:	21 e0       	ldi	r18, 0x01	; 1
    645e:	30 e0       	ldi	r19, 0x00	; 0
    6460:	40 e0       	ldi	r20, 0x00	; 0
    6462:	50 e0       	ldi	r21, 0x00	; 0
    6464:	00 80       	ld	r0, Z
    6466:	04 c0       	rjmp	.+8      	; 0x6470 <FailSlave+0x70>
    6468:	22 0f       	add	r18, r18
    646a:	33 1f       	adc	r19, r19
    646c:	44 1f       	adc	r20, r20
    646e:	55 1f       	adc	r21, r21
    6470:	0a 94       	dec	r0
    6472:	d2 f7       	brpl	.-12     	; 0x6468 <FailSlave+0x68>
			SlaveOff[MB_N] |=S_N;
    6474:	7b 01       	movw	r14, r22
    6476:	ee 0c       	add	r14, r14
    6478:	ff 1c       	adc	r15, r15
    647a:	ee 0c       	add	r14, r14
    647c:	ff 1c       	adc	r15, r15
    647e:	b7 01       	movw	r22, r14
    6480:	64 58       	subi	r22, 0x84	; 132
    6482:	75 4f       	sbci	r23, 0xF5	; 245
    6484:	fb 01       	movw	r30, r22
    6486:	80 81       	ld	r24, Z
    6488:	91 81       	ldd	r25, Z+1	; 0x01
    648a:	a2 81       	ldd	r26, Z+2	; 0x02
    648c:	b3 81       	ldd	r27, Z+3	; 0x03
    648e:	82 2b       	or	r24, r18
    6490:	93 2b       	or	r25, r19
    6492:	a4 2b       	or	r26, r20
    6494:	b5 2b       	or	r27, r21
    6496:	80 83       	st	Z, r24
    6498:	91 83       	std	Z+1, r25	; 0x01
    649a:	a2 83       	std	Z+2, r26	; 0x02
    649c:	b3 83       	std	Z+3, r27	; 0x03
			SlaveSkip[MB_N] |=S_N;
    649e:	f7 01       	movw	r30, r14
    64a0:	eb 5a       	subi	r30, 0xAB	; 171
    64a2:	fc 4f       	sbci	r31, 0xFC	; 252
    64a4:	80 81       	ld	r24, Z
    64a6:	91 81       	ldd	r25, Z+1	; 0x01
    64a8:	a2 81       	ldd	r26, Z+2	; 0x02
    64aa:	b3 81       	ldd	r27, Z+3	; 0x03
    64ac:	28 2b       	or	r18, r24
    64ae:	39 2b       	or	r19, r25
    64b0:	4a 2b       	or	r20, r26
    64b2:	5b 2b       	or	r21, r27
    64b4:	20 83       	st	Z, r18
    64b6:	31 83       	std	Z+1, r19	; 0x01
    64b8:	42 83       	std	Z+2, r20	; 0x02
    64ba:	53 83       	std	Z+3, r21	; 0x03
			Try[MB_N] = 0;
    64bc:	18 82       	st	Y, r1
			Over = NextSlave(MB_N);
    64be:	81 2f       	mov	r24, r17
    64c0:	0e 94 41 31 	call	0x6282	; 0x6282 <NextSlave>
		}
	}
	return Over;
}
    64c4:	df 91       	pop	r29
    64c6:	cf 91       	pop	r28
    64c8:	1f 91       	pop	r17
    64ca:	ff 90       	pop	r15
    64cc:	ef 90       	pop	r14
    64ce:	08 95       	ret

000064d0 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    64d0:	6f 92       	push	r6
    64d2:	7f 92       	push	r7
    64d4:	9f 92       	push	r9
    64d6:	af 92       	push	r10
    64d8:	bf 92       	push	r11
    64da:	cf 92       	push	r12
    64dc:	df 92       	push	r13
    64de:	ef 92       	push	r14
    64e0:	ff 92       	push	r15
    64e2:	0f 93       	push	r16
    64e4:	1f 93       	push	r17
    64e6:	cf 93       	push	r28
    64e8:	df 93       	push	r29
    64ea:	98 2e       	mov	r9, r24
	switch (MB_State[MB_N]) {
    64ec:	c8 2f       	mov	r28, r24
    64ee:	d0 e0       	ldi	r29, 0x00	; 0
    64f0:	fe 01       	movw	r30, r28
    64f2:	ec 59       	subi	r30, 0x9C	; 156
    64f4:	fc 4f       	sbci	r31, 0xFC	; 252
    64f6:	80 81       	ld	r24, Z
    64f8:	88 23       	and	r24, r24
    64fa:	21 f0       	breq	.+8      	; 0x6504 <MB_M_Timer_ISR+0x34>
    64fc:	82 30       	cpi	r24, 0x02	; 2
    64fe:	09 f0       	breq	.+2      	; 0x6502 <MB_M_Timer_ISR+0x32>
    6500:	d3 c2       	rjmp	.+1446   	; 0x6aa8 <MB_M_Timer_ISR+0x5d8>
    6502:	0f c0       	rjmp	.+30     	; 0x6522 <MB_M_Timer_ISR+0x52>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6504:	80 91 59 03 	lds	r24, 0x0359
    6508:	8e 5f       	subi	r24, 0xFE	; 254
    650a:	89 0d       	add	r24, r9
    650c:	6f ef       	ldi	r22, 0xFF	; 255
    650e:	7f ef       	ldi	r23, 0xFF	; 255
    6510:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
		FormQuery(MB_N);
    6514:	89 2d       	mov	r24, r9
    6516:	0e 94 ac 30 	call	0x6158	; 0x6158 <FormQuery>
		MB_Transm(MB_N);
    651a:	89 2d       	mov	r24, r9
    651c:	0e 94 55 2a 	call	0x54aa	; 0x54aa <MB_Transm>
    6520:	c3 c2       	rjmp	.+1414   	; 0x6aa8 <MB_M_Timer_ISR+0x5d8>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6522:	84 e0       	ldi	r24, 0x04	; 4
    6524:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6526:	fe 01       	movw	r30, r28
    6528:	e1 56       	subi	r30, 0x61	; 97
    652a:	fa 4f       	sbci	r31, 0xFA	; 250
    652c:	80 81       	ld	r24, Z
    652e:	90 e0       	ldi	r25, 0x00	; 0
    6530:	82 30       	cpi	r24, 0x02	; 2
    6532:	09 f4       	brne	.+2      	; 0x6536 <MB_M_Timer_ISR+0x66>
    6534:	91 e0       	ldi	r25, 0x01	; 1
    6536:	90 93 53 03 	sts	0x0353, r25
	if (CommErr(MB_N))
    653a:	89 2d       	mov	r24, r9
    653c:	0e 94 29 2b 	call	0x5652	; 0x5652 <CommErr>
    6540:	88 23       	and	r24, r24
    6542:	09 f0       	breq	.+2      	; 0x6546 <MB_M_Timer_ISR+0x76>
    6544:	53 c2       	rjmp	.+1190   	; 0x69ec <MB_M_Timer_ISR+0x51c>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6546:	84 e1       	ldi	r24, 0x14	; 20
    6548:	90 e0       	ldi	r25, 0x00	; 0
    654a:	c8 9f       	mul	r28, r24
    654c:	90 01       	movw	r18, r0
    654e:	c9 9f       	mul	r28, r25
    6550:	30 0d       	add	r19, r0
    6552:	d8 9f       	mul	r29, r24
    6554:	30 0d       	add	r19, r0
    6556:	11 24       	eor	r1, r1
    6558:	26 52       	subi	r18, 0x26	; 38
    655a:	36 4b       	sbci	r19, 0xB6	; 182
    655c:	f9 01       	movw	r30, r18
    655e:	85 91       	lpm	r24, Z+
    6560:	94 91       	lpm	r25, Z+
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6562:	fc 01       	movw	r30, r24
    6564:	09 95       	icall
		MB_Slave *Slave;
		MB_Query *Query;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6566:	80 91 53 03 	lds	r24, 0x0353
    656a:	88 23       	and	r24, r24
    656c:	79 f0       	breq	.+30     	; 0x658c <MB_M_Timer_ISR+0xbc>
			Addr = MB_SingleQuery[MB_N].Addr;
    656e:	fe 01       	movw	r30, r28
    6570:	33 e0       	ldi	r19, 0x03	; 3
    6572:	ee 0f       	add	r30, r30
    6574:	ff 1f       	adc	r31, r31
    6576:	3a 95       	dec	r19
    6578:	e1 f7       	brne	.-8      	; 0x6572 <MB_M_Timer_ISR+0xa2>
    657a:	e5 5b       	subi	r30, 0xB5	; 181
    657c:	fc 4f       	sbci	r31, 0xFC	; 252
    657e:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6580:	91 81       	ldd	r25, Z+1	; 0x01
    6582:	40 e0       	ldi	r20, 0x00	; 0
    6584:	50 e0       	ldi	r21, 0x00	; 0
    6586:	cc 24       	eor	r12, r12
    6588:	dd 24       	eor	r13, r13
    658a:	25 c0       	rjmp	.+74     	; 0x65d6 <MB_M_Timer_ISR+0x106>
    658c:	83 e0       	ldi	r24, 0x03	; 3
    658e:	98 9e       	mul	r9, r24
    6590:	f0 01       	movw	r30, r0
    6592:	11 24       	eor	r1, r1
    6594:	e8 56       	subi	r30, 0x68	; 104
    6596:	fb 4f       	sbci	r31, 0xFB	; 251
    6598:	c5 90       	lpm	r12, Z+
    659a:	d4 90       	lpm	r13, Z+

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    659c:	fe 01       	movw	r30, r28
    659e:	ec 57       	subi	r30, 0x7C	; 124
    65a0:	fa 4f       	sbci	r31, 0xFA	; 250
    65a2:	80 81       	ld	r24, Z
    65a4:	90 e0       	ldi	r25, 0x00	; 0
    65a6:	88 0f       	add	r24, r24
    65a8:	99 1f       	adc	r25, r25
    65aa:	88 0f       	add	r24, r24
    65ac:	99 1f       	adc	r25, r25
    65ae:	c8 0e       	add	r12, r24
    65b0:	d9 1e       	adc	r13, r25
    65b2:	f6 01       	movw	r30, r12
    65b4:	31 96       	adiw	r30, 0x01	; 1
    65b6:	45 91       	lpm	r20, Z+
    65b8:	54 91       	lpm	r21, Z+
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    65ba:	fe 01       	movw	r30, r28
    65bc:	e6 57       	subi	r30, 0x76	; 118
    65be:	fa 4f       	sbci	r31, 0xFA	; 250
    65c0:	80 81       	ld	r24, Z
    65c2:	27 e0       	ldi	r18, 0x07	; 7
    65c4:	82 9f       	mul	r24, r18
    65c6:	c0 01       	movw	r24, r0
    65c8:	11 24       	eor	r1, r1
    65ca:	48 0f       	add	r20, r24
    65cc:	59 1f       	adc	r21, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    65ce:	f6 01       	movw	r30, r12
    65d0:	24 91       	lpm	r18, Z+
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    65d2:	fa 01       	movw	r30, r20
    65d4:	94 91       	lpm	r25, Z+
    65d6:	fc 2f       	mov	r31, r28
    65d8:	ee 27       	eor	r30, r30
    65da:	e1 55       	subi	r30, 0x51	; 81
    65dc:	f3 4f       	sbci	r31, 0xF3	; 243
    65de:	80 81       	ld	r24, Z
    65e0:	82 17       	cp	r24, r18
    65e2:	09 f0       	breq	.+2      	; 0x65e6 <MB_M_Timer_ISR+0x116>
    65e4:	03 c2       	rjmp	.+1030   	; 0x69ec <MB_M_Timer_ISR+0x51c>
    65e6:	b1 81       	ldd	r27, Z+1	; 0x01
    65e8:	b9 17       	cp	r27, r25
    65ea:	09 f0       	breq	.+2      	; 0x65ee <MB_M_Timer_ISR+0x11e>
    65ec:	ff c1       	rjmp	.+1022   	; 0x69ec <MB_M_Timer_ISR+0x51c>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err;
			switch (Func) {
    65ee:	95 30       	cpi	r25, 0x05	; 5
    65f0:	38 f4       	brcc	.+14     	; 0x6600 <MB_M_Timer_ISR+0x130>
    65f2:	93 30       	cpi	r25, 0x03	; 3
    65f4:	08 f0       	brcs	.+2      	; 0x65f8 <MB_M_Timer_ISR+0x128>
    65f6:	ba c0       	rjmp	.+372    	; 0x676c <MB_M_Timer_ISR+0x29c>
    65f8:	91 30       	cpi	r25, 0x01	; 1
    65fa:	08 f4       	brcc	.+2      	; 0x65fe <MB_M_Timer_ISR+0x12e>
    65fc:	fb c1       	rjmp	.+1014   	; 0x69f4 <MB_M_Timer_ISR+0x524>
    65fe:	0b c0       	rjmp	.+22     	; 0x6616 <MB_M_Timer_ISR+0x146>
    6600:	96 30       	cpi	r25, 0x06	; 6
    6602:	09 f4       	brne	.+2      	; 0x6606 <MB_M_Timer_ISR+0x136>
    6604:	39 c1       	rjmp	.+626    	; 0x6878 <MB_M_Timer_ISR+0x3a8>
    6606:	96 30       	cpi	r25, 0x06	; 6
    6608:	08 f4       	brcc	.+2      	; 0x660c <MB_M_Timer_ISR+0x13c>
    660a:	f4 c1       	rjmp	.+1000   	; 0x69f4 <MB_M_Timer_ISR+0x524>
    660c:	9f 50       	subi	r25, 0x0F	; 15
    660e:	92 30       	cpi	r25, 0x02	; 2
    6610:	08 f0       	brcs	.+2      	; 0x6614 <MB_M_Timer_ISR+0x144>
    6612:	f0 c1       	rjmp	.+992    	; 0x69f4 <MB_M_Timer_ISR+0x524>
    6614:	90 c1       	rjmp	.+800    	; 0x6936 <MB_M_Timer_ISR+0x466>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6616:	80 91 53 03 	lds	r24, 0x0353
    661a:	88 23       	and	r24, r24
    661c:	51 f0       	breq	.+20     	; 0x6632 <MB_M_Timer_ISR+0x162>
    661e:	fe 01       	movw	r30, r28
    6620:	03 e0       	ldi	r16, 0x03	; 3
    6622:	ee 0f       	add	r30, r30
    6624:	ff 1f       	adc	r31, r31
    6626:	0a 95       	dec	r16
    6628:	e1 f7       	brne	.-8      	; 0x6622 <MB_M_Timer_ISR+0x152>
    662a:	e1 5b       	subi	r30, 0xB1	; 177
    662c:	fc 4f       	sbci	r31, 0xFC	; 252
    662e:	a0 81       	ld	r26, Z
    6630:	06 c0       	rjmp	.+12     	; 0x663e <MB_M_Timer_ISR+0x16e>
    6632:	4d 5f       	subi	r20, 0xFD	; 253
    6634:	5f 4f       	sbci	r21, 0xFF	; 255
    6636:	fa 01       	movw	r30, r20
    6638:	a4 91       	lpm	r26, Z+
    663a:	43 50       	subi	r20, 0x03	; 3
    663c:	50 40       	sbci	r21, 0x00	; 0
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    663e:	fc 2f       	mov	r31, r28
    6640:	ee 27       	eor	r30, r30
    6642:	ef 54       	subi	r30, 0x4F	; 79
    6644:	f3 4f       	sbci	r31, 0xF3	; 243
    6646:	80 81       	ld	r24, Z
    6648:	68 2f       	mov	r22, r24
    664a:	70 e0       	ldi	r23, 0x00	; 0
    664c:	fe 01       	movw	r30, r28
    664e:	e6 5b       	subi	r30, 0xB6	; 182
    6650:	f7 4f       	sbci	r31, 0xF7	; 247
    6652:	80 81       	ld	r24, Z
    6654:	90 e0       	ldi	r25, 0x00	; 0
    6656:	9b 01       	movw	r18, r22
    6658:	2b 5f       	subi	r18, 0xFB	; 251
    665a:	3f 4f       	sbci	r19, 0xFF	; 255
    665c:	82 17       	cp	r24, r18
    665e:	93 07       	cpc	r25, r19
    6660:	09 f0       	breq	.+2      	; 0x6664 <MB_M_Timer_ISR+0x194>
    6662:	b7 c1       	rjmp	.+878    	; 0x69d2 <MB_M_Timer_ISR+0x502>
    6664:	20 e0       	ldi	r18, 0x00	; 0
    6666:	30 e0       	ldi	r19, 0x00	; 0
    6668:	8a 2f       	mov	r24, r26
    666a:	90 e0       	ldi	r25, 0x00	; 0
    666c:	87 70       	andi	r24, 0x07	; 7
    666e:	90 70       	andi	r25, 0x00	; 0
    6670:	18 16       	cp	r1, r24
    6672:	19 06       	cpc	r1, r25
    6674:	14 f4       	brge	.+4      	; 0x667a <MB_M_Timer_ISR+0x1aa>
    6676:	21 e0       	ldi	r18, 0x01	; 1
    6678:	30 e0       	ldi	r19, 0x00	; 0
    667a:	8a 2f       	mov	r24, r26
    667c:	86 95       	lsr	r24
    667e:	86 95       	lsr	r24
    6680:	86 95       	lsr	r24
    6682:	28 0f       	add	r18, r24
    6684:	31 1d       	adc	r19, r1
    6686:	26 17       	cp	r18, r22
    6688:	37 07       	cpc	r19, r23
    668a:	09 f0       	breq	.+2      	; 0x668e <MB_M_Timer_ISR+0x1be>
    668c:	a2 c1       	rjmp	.+836    	; 0x69d2 <MB_M_Timer_ISR+0x502>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    668e:	80 91 53 03 	lds	r24, 0x0353
    6692:	88 23       	and	r24, r24
    6694:	61 f0       	breq	.+24     	; 0x66ae <MB_M_Timer_ISR+0x1de>
		Discr = MB_SingleQuery[MB_N].Buf;
    6696:	fe 01       	movw	r30, r28
    6698:	b3 e0       	ldi	r27, 0x03	; 3
    669a:	ee 0f       	add	r30, r30
    669c:	ff 1f       	adc	r31, r31
    669e:	ba 95       	dec	r27
    66a0:	e1 f7       	brne	.-8      	; 0x669a <MB_M_Timer_ISR+0x1ca>
    66a2:	e5 5b       	subi	r30, 0xB5	; 181
    66a4:	fc 4f       	sbci	r31, 0xFC	; 252
    66a6:	e6 80       	ldd	r14, Z+6	; 0x06
    66a8:	f7 80       	ldd	r15, Z+7	; 0x07
    66aa:	b0 e0       	ldi	r27, 0x00	; 0
    66ac:	1f c0       	rjmp	.+62     	; 0x66ec <MB_M_Timer_ISR+0x21c>
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    66ae:	b1 30       	cpi	r27, 0x01	; 1
    66b0:	49 f4       	brne	.+18     	; 0x66c4 <MB_M_Timer_ISR+0x1f4>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    66b2:	fe 01       	movw	r30, r28
    66b4:	74 e0       	ldi	r23, 0x04	; 4
    66b6:	ee 0f       	add	r30, r30
    66b8:	ff 1f       	adc	r31, r31
    66ba:	7a 95       	dec	r23
    66bc:	e1 f7       	brne	.-8      	; 0x66b6 <MB_M_Timer_ISR+0x1e6>
    66be:	e4 50       	subi	r30, 0x04	; 4
    66c0:	fe 4f       	sbci	r31, 0xFE	; 254
    66c2:	08 c0       	rjmp	.+16     	; 0x66d4 <MB_M_Timer_ISR+0x204>
    66c4:	fe 01       	movw	r30, r28
    66c6:	64 e0       	ldi	r22, 0x04	; 4
    66c8:	ee 0f       	add	r30, r30
    66ca:	ff 1f       	adc	r31, r31
    66cc:	6a 95       	dec	r22
    66ce:	e1 f7       	brne	.-8      	; 0x66c8 <MB_M_Timer_ISR+0x1f8>
    66d0:	e0 50       	subi	r30, 0x00	; 0
    66d2:	fe 4f       	sbci	r31, 0xFE	; 254
    66d4:	85 91       	lpm	r24, Z+
    66d6:	94 91       	lpm	r25, Z+
    66d8:	68 2f       	mov	r22, r24
    66da:	26 2f       	mov	r18, r22
    66dc:	39 2f       	mov	r19, r25
    66de:	c9 01       	movw	r24, r18
    66e0:	7c 01       	movw	r14, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    66e2:	fa 01       	movw	r30, r20
    66e4:	35 96       	adiw	r30, 0x05	; 5
    66e6:	85 91       	lpm	r24, Z+
    66e8:	94 91       	lpm	r25, Z+
		Pin = prw(&Query->AllocAddr);
    66ea:	b8 2f       	mov	r27, r24
    66ec:	60 e0       	ldi	r22, 0x00	; 0
    66ee:	70 e0       	ldi	r23, 0x00	; 0
	}
	for (uint16_t i=0; i<Qt; i++) {
    66f0:	aa 2e       	mov	r10, r26
    66f2:	bb 24       	eor	r11, r11
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    66f4:	41 e0       	ldi	r20, 0x01	; 1
    66f6:	64 2e       	mov	r6, r20
    66f8:	71 2c       	mov	r7, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    66fa:	1c 2f       	mov	r17, r28
    66fc:	00 27       	eor	r16, r16
    66fe:	01 55       	subi	r16, 0x51	; 81
    6700:	13 4f       	sbci	r17, 0xF3	; 243
    6702:	30 c0       	rjmp	.+96     	; 0x6764 <MB_M_Timer_ISR+0x294>
		Discr = MB_SingleQuery[MB_N].Buf;
		Pin = 0;
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
    6704:	4b 2f       	mov	r20, r27
    6706:	46 0f       	add	r20, r22
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6708:	84 2f       	mov	r24, r20
    670a:	87 70       	andi	r24, 0x07	; 7
    670c:	a6 2d       	mov	r26, r6
    670e:	01 c0       	rjmp	.+2      	; 0x6712 <MB_M_Timer_ISR+0x242>
    6710:	aa 0f       	add	r26, r26
    6712:	8a 95       	dec	r24
    6714:	ea f7       	brpl	.-6      	; 0x6710 <MB_M_Timer_ISR+0x240>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6716:	fb 01       	movw	r30, r22
    6718:	23 e0       	ldi	r18, 0x03	; 3
    671a:	f6 95       	lsr	r31
    671c:	e7 95       	ror	r30
    671e:	2a 95       	dec	r18
    6720:	e1 f7       	brne	.-8      	; 0x671a <MB_M_Timer_ISR+0x24a>
    6722:	e0 0f       	add	r30, r16
    6724:	f1 1f       	adc	r31, r17
    6726:	83 81       	ldd	r24, Z+3	; 0x03
    6728:	90 e0       	ldi	r25, 0x00	; 0
    672a:	9b 01       	movw	r18, r22
    672c:	27 70       	andi	r18, 0x07	; 7
    672e:	30 70       	andi	r19, 0x00	; 0
    6730:	02 c0       	rjmp	.+4      	; 0x6736 <MB_M_Timer_ISR+0x266>
    6732:	95 95       	asr	r25
    6734:	87 95       	ror	r24
    6736:	2a 95       	dec	r18
    6738:	e2 f7       	brpl	.-8      	; 0x6732 <MB_M_Timer_ISR+0x262>
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    673a:	46 95       	lsr	r20
    673c:	46 95       	lsr	r20
    673e:	46 95       	lsr	r20
    6740:	50 e0       	ldi	r21, 0x00	; 0
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6742:	80 ff       	sbrs	r24, 0
    6744:	06 c0       	rjmp	.+12     	; 0x6752 <MB_M_Timer_ISR+0x282>
			Discr[Byte] |=Bit;
    6746:	f7 01       	movw	r30, r14
    6748:	e4 0f       	add	r30, r20
    674a:	f5 1f       	adc	r31, r21
    674c:	80 81       	ld	r24, Z
    674e:	8a 2b       	or	r24, r26
    6750:	06 c0       	rjmp	.+12     	; 0x675e <MB_M_Timer_ISR+0x28e>
		else
			Discr[Byte] &=~Bit;
    6752:	f7 01       	movw	r30, r14
    6754:	e4 0f       	add	r30, r20
    6756:	f5 1f       	adc	r31, r21
    6758:	a0 95       	com	r26
    675a:	80 81       	ld	r24, Z
    675c:	8a 23       	and	r24, r26
    675e:	80 83       	st	Z, r24
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6760:	6f 5f       	subi	r22, 0xFF	; 255
    6762:	7f 4f       	sbci	r23, 0xFF	; 255
    6764:	6a 15       	cp	r22, r10
    6766:	7b 05       	cpc	r23, r11
    6768:	68 f2       	brcs	.-102    	; 0x6704 <MB_M_Timer_ISR+0x234>
    676a:	44 c1       	rjmp	.+648    	; 0x69f4 <MB_M_Timer_ISR+0x524>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    676c:	fc 2f       	mov	r31, r28
    676e:	ee 27       	eor	r30, r30
    6770:	ef 54       	subi	r30, 0x4F	; 79
    6772:	f3 4f       	sbci	r31, 0xF3	; 243
    6774:	60 81       	ld	r22, Z
    6776:	fe 01       	movw	r30, r28
    6778:	e6 5b       	subi	r30, 0xB6	; 182
    677a:	f7 4f       	sbci	r31, 0xF7	; 247
    677c:	20 81       	ld	r18, Z
    677e:	30 e0       	ldi	r19, 0x00	; 0
    6780:	86 2f       	mov	r24, r22
    6782:	90 e0       	ldi	r25, 0x00	; 0
    6784:	05 96       	adiw	r24, 0x05	; 5
    6786:	28 17       	cp	r18, r24
    6788:	39 07       	cpc	r19, r25
    678a:	09 f0       	breq	.+2      	; 0x678e <MB_M_Timer_ISR+0x2be>
    678c:	22 c1       	rjmp	.+580    	; 0x69d2 <MB_M_Timer_ISR+0x502>
    678e:	80 91 53 03 	lds	r24, 0x0353
    6792:	88 23       	and	r24, r24
    6794:	59 f0       	breq	.+22     	; 0x67ac <MB_M_Timer_ISR+0x2dc>
    6796:	fe 01       	movw	r30, r28
    6798:	83 e0       	ldi	r24, 0x03	; 3
    679a:	ee 0f       	add	r30, r30
    679c:	ff 1f       	adc	r31, r31
    679e:	8a 95       	dec	r24
    67a0:	e1 f7       	brne	.-8      	; 0x679a <MB_M_Timer_ISR+0x2ca>
    67a2:	e1 5b       	subi	r30, 0xB1	; 177
    67a4:	fc 4f       	sbci	r31, 0xFC	; 252
    67a6:	20 81       	ld	r18, Z
    67a8:	31 81       	ldd	r19, Z+1	; 0x01
    67aa:	05 c0       	rjmp	.+10     	; 0x67b6 <MB_M_Timer_ISR+0x2e6>
    67ac:	ca 01       	movw	r24, r20
    67ae:	03 96       	adiw	r24, 0x03	; 3
    67b0:	fc 01       	movw	r30, r24
    67b2:	25 91       	lpm	r18, Z+
    67b4:	34 91       	lpm	r19, Z+
    67b6:	22 0f       	add	r18, r18
    67b8:	33 1f       	adc	r19, r19
    67ba:	86 2f       	mov	r24, r22
    67bc:	90 e0       	ldi	r25, 0x00	; 0
    67be:	28 17       	cp	r18, r24
    67c0:	39 07       	cpc	r19, r25
    67c2:	09 f0       	breq	.+2      	; 0x67c6 <MB_M_Timer_ISR+0x2f6>
    67c4:	06 c1       	rjmp	.+524    	; 0x69d2 <MB_M_Timer_ISR+0x502>
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    67c6:	80 91 53 03 	lds	r24, 0x0353
    67ca:	88 23       	and	r24, r24
    67cc:	59 f0       	breq	.+22     	; 0x67e4 <MB_M_Timer_ISR+0x314>
    67ce:	fe 01       	movw	r30, r28
    67d0:	13 e0       	ldi	r17, 0x03	; 3
    67d2:	ee 0f       	add	r30, r30
    67d4:	ff 1f       	adc	r31, r31
    67d6:	1a 95       	dec	r17
    67d8:	e1 f7       	brne	.-8      	; 0x67d2 <MB_M_Timer_ISR+0x302>
    67da:	e5 5b       	subi	r30, 0xB5	; 181
    67dc:	fc 4f       	sbci	r31, 0xFC	; 252
    67de:	26 81       	ldd	r18, Z+6	; 0x06
    67e0:	37 81       	ldd	r19, Z+7	; 0x07
    67e2:	1d c0       	rjmp	.+58     	; 0x681e <MB_M_Timer_ISR+0x34e>
    67e4:	b3 30       	cpi	r27, 0x03	; 3
    67e6:	49 f4       	brne	.+18     	; 0x67fa <MB_M_Timer_ISR+0x32a>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    67e8:	fe 01       	movw	r30, r28
    67ea:	b4 e0       	ldi	r27, 0x04	; 4
    67ec:	ee 0f       	add	r30, r30
    67ee:	ff 1f       	adc	r31, r31
    67f0:	ba 95       	dec	r27
    67f2:	e1 f7       	brne	.-8      	; 0x67ec <MB_M_Timer_ISR+0x31c>
    67f4:	ec 5f       	subi	r30, 0xFC	; 252
    67f6:	fd 4f       	sbci	r31, 0xFD	; 253
    67f8:	08 c0       	rjmp	.+16     	; 0x680a <MB_M_Timer_ISR+0x33a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    67fa:	fe 01       	movw	r30, r28
    67fc:	a4 e0       	ldi	r26, 0x04	; 4
    67fe:	ee 0f       	add	r30, r30
    6800:	ff 1f       	adc	r31, r31
    6802:	aa 95       	dec	r26
    6804:	e1 f7       	brne	.-8      	; 0x67fe <MB_M_Timer_ISR+0x32e>
    6806:	e8 5f       	subi	r30, 0xF8	; 248
    6808:	fd 4f       	sbci	r31, 0xFD	; 253
    680a:	85 91       	lpm	r24, Z+
    680c:	94 91       	lpm	r25, Z+
    680e:	fa 01       	movw	r30, r20
    6810:	35 96       	adiw	r30, 0x05	; 5
    6812:	25 91       	lpm	r18, Z+
    6814:	34 91       	lpm	r19, Z+
    6816:	22 0f       	add	r18, r18
    6818:	33 1f       	adc	r19, r19
    681a:	28 0f       	add	r18, r24
    681c:	39 1f       	adc	r19, r25
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    681e:	46 2f       	mov	r20, r22
    6820:	46 95       	lsr	r20
    6822:	41 50       	subi	r20, 0x01	; 1
    6824:	84 2f       	mov	r24, r20
    6826:	99 27       	eor	r25, r25
    6828:	87 fd       	sbrc	r24, 7
    682a:	90 95       	com	r25
    682c:	88 0f       	add	r24, r24
    682e:	99 1f       	adc	r25, r25
    6830:	58 2f       	mov	r21, r24
    6832:	5d 5f       	subi	r21, 0xFD	; 253
    6834:	28 0f       	add	r18, r24
    6836:	39 1f       	adc	r19, r25
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6838:	7c 2f       	mov	r23, r28
    683a:	66 27       	eor	r22, r22
    683c:	8b 01       	movw	r16, r22
    683e:	01 55       	subi	r16, 0x51	; 81
    6840:	13 4f       	sbci	r17, 0xF3	; 243
    6842:	17 c0       	rjmp	.+46     	; 0x6872 <MB_M_Timer_ISR+0x3a2>
    6844:	e5 2f       	mov	r30, r21
    6846:	f0 e0       	ldi	r31, 0x00	; 0
    6848:	d8 01       	movw	r26, r16
    684a:	ae 0f       	add	r26, r30
    684c:	bf 1f       	adc	r27, r31
    684e:	11 96       	adiw	r26, 0x01	; 1
    6850:	8c 91       	ld	r24, X
    6852:	90 e0       	ldi	r25, 0x00	; 0
    6854:	e6 0f       	add	r30, r22
    6856:	f7 1f       	adc	r31, r23
    6858:	e1 55       	subi	r30, 0x51	; 81
    685a:	f3 4f       	sbci	r31, 0xF3	; 243
    685c:	f0 81       	ld	r31, Z
    685e:	e0 e0       	ldi	r30, 0x00	; 0
    6860:	8e 2b       	or	r24, r30
    6862:	9f 2b       	or	r25, r31
    6864:	d9 01       	movw	r26, r18
    6866:	8d 93       	st	X+, r24
    6868:	9c 93       	st	X, r25
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    686a:	41 50       	subi	r20, 0x01	; 1
    686c:	52 50       	subi	r21, 0x02	; 2
    686e:	22 50       	subi	r18, 0x02	; 2
    6870:	30 40       	sbci	r19, 0x00	; 0
    6872:	47 ff       	sbrs	r20, 7
    6874:	e7 cf       	rjmp	.-50     	; 0x6844 <MB_M_Timer_ISR+0x374>
    6876:	be c0       	rjmp	.+380    	; 0x69f4 <MB_M_Timer_ISR+0x524>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6878:	80 91 53 03 	lds	r24, 0x0353
    687c:	88 23       	and	r24, r24
    687e:	a9 f0       	breq	.+42     	; 0x68aa <MB_M_Timer_ISR+0x3da>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6880:	fe 01       	movw	r30, r28
    6882:	93 e0       	ldi	r25, 0x03	; 3
    6884:	ee 0f       	add	r30, r30
    6886:	ff 1f       	adc	r31, r31
    6888:	9a 95       	dec	r25
    688a:	e1 f7       	brne	.-8      	; 0x6884 <MB_M_Timer_ISR+0x3b4>
    688c:	e3 5b       	subi	r30, 0xB3	; 179
    688e:	fc 4f       	sbci	r31, 0xFC	; 252
    6890:	00 81       	ld	r16, Z
    6892:	11 81       	ldd	r17, Z+1	; 0x01
		Reg = MB_SingleQuery[MB_N].Buf;
    6894:	fe 01       	movw	r30, r28
    6896:	83 e0       	ldi	r24, 0x03	; 3
    6898:	ee 0f       	add	r30, r30
    689a:	ff 1f       	adc	r31, r31
    689c:	8a 95       	dec	r24
    689e:	e1 f7       	brne	.-8      	; 0x6898 <MB_M_Timer_ISR+0x3c8>
    68a0:	e5 5b       	subi	r30, 0xB5	; 181
    68a2:	fc 4f       	sbci	r31, 0xFC	; 252
    68a4:	66 81       	ldd	r22, Z+6	; 0x06
    68a6:	77 81       	ldd	r23, Z+7	; 0x07
    68a8:	16 c0       	rjmp	.+44     	; 0x68d6 <MB_M_Timer_ISR+0x406>
    68aa:	fa 01       	movw	r30, r20
    68ac:	31 96       	adiw	r30, 0x01	; 1
    68ae:	05 91       	lpm	r16, Z+
    68b0:	14 91       	lpm	r17, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68b2:	fe 01       	movw	r30, r28
    68b4:	b4 e0       	ldi	r27, 0x04	; 4
    68b6:	ee 0f       	add	r30, r30
    68b8:	ff 1f       	adc	r31, r31
    68ba:	ba 95       	dec	r27
    68bc:	e1 f7       	brne	.-8      	; 0x68b6 <MB_M_Timer_ISR+0x3e6>
    68be:	ec 5f       	subi	r30, 0xFC	; 252
    68c0:	fd 4f       	sbci	r31, 0xFD	; 253
    68c2:	65 91       	lpm	r22, Z+
    68c4:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68c6:	fa 01       	movw	r30, r20
    68c8:	35 96       	adiw	r30, 0x05	; 5
    68ca:	85 91       	lpm	r24, Z+
    68cc:	94 91       	lpm	r25, Z+
	}
	else {
		StartAddr = prw(&Query->StartAddr);
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    68ce:	88 0f       	add	r24, r24
    68d0:	99 1f       	adc	r25, r25
    68d2:	68 0f       	add	r22, r24
    68d4:	79 1f       	adc	r23, r25
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    68d6:	fe 01       	movw	r30, r28
    68d8:	e6 5b       	subi	r30, 0xB6	; 182
    68da:	f7 4f       	sbci	r31, 0xF7	; 247
    68dc:	80 81       	ld	r24, Z
    68de:	88 30       	cpi	r24, 0x08	; 8
    68e0:	09 f0       	breq	.+2      	; 0x68e4 <MB_M_Timer_ISR+0x414>
    68e2:	73 c0       	rjmp	.+230    	; 0x69ca <MB_M_Timer_ISR+0x4fa>
    68e4:	fc 2f       	mov	r31, r28
    68e6:	ee 27       	eor	r30, r30
    68e8:	ef 54       	subi	r30, 0x4F	; 79
    68ea:	f3 4f       	sbci	r31, 0xF3	; 243
    68ec:	30 81       	ld	r19, Z
    68ee:	20 e0       	ldi	r18, 0x00	; 0
    68f0:	bc 2f       	mov	r27, r28
    68f2:	aa 27       	eor	r26, r26
    68f4:	a1 55       	subi	r26, 0x51	; 81
    68f6:	b3 4f       	sbci	r27, 0xF3	; 243
    68f8:	13 96       	adiw	r26, 0x03	; 3
    68fa:	8c 91       	ld	r24, X
    68fc:	13 97       	sbiw	r26, 0x03	; 3
    68fe:	90 e0       	ldi	r25, 0x00	; 0
    6900:	28 2b       	or	r18, r24
    6902:	39 2b       	or	r19, r25
    6904:	20 17       	cp	r18, r16
    6906:	31 07       	cpc	r19, r17
    6908:	09 f0       	breq	.+2      	; 0x690c <MB_M_Timer_ISR+0x43c>
    690a:	5f c0       	rjmp	.+190    	; 0x69ca <MB_M_Timer_ISR+0x4fa>
    690c:	40 e0       	ldi	r20, 0x00	; 0
    690e:	50 e0       	ldi	r21, 0x00	; 0
    6910:	fc 2f       	mov	r31, r28
    6912:	ee 27       	eor	r30, r30
    6914:	ed 54       	subi	r30, 0x4D	; 77
    6916:	f3 4f       	sbci	r31, 0xF3	; 243
    6918:	30 81       	ld	r19, Z
    691a:	20 e0       	ldi	r18, 0x00	; 0
    691c:	15 96       	adiw	r26, 0x05	; 5
    691e:	8c 91       	ld	r24, X
    6920:	90 e0       	ldi	r25, 0x00	; 0
    6922:	28 2b       	or	r18, r24
    6924:	39 2b       	or	r19, r25
    6926:	fb 01       	movw	r30, r22
    6928:	80 81       	ld	r24, Z
    692a:	91 81       	ldd	r25, Z+1	; 0x01
    692c:	28 17       	cp	r18, r24
    692e:	39 07       	cpc	r19, r25
    6930:	09 f0       	breq	.+2      	; 0x6934 <MB_M_Timer_ISR+0x464>
    6932:	4b c0       	rjmp	.+150    	; 0x69ca <MB_M_Timer_ISR+0x4fa>
    6934:	4c c0       	rjmp	.+152    	; 0x69ce <MB_M_Timer_ISR+0x4fe>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6936:	80 91 53 03 	lds	r24, 0x0353
    693a:	88 23       	and	r24, r24
    693c:	a9 f0       	breq	.+42     	; 0x6968 <MB_M_Timer_ISR+0x498>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    693e:	fe 01       	movw	r30, r28
    6940:	43 e0       	ldi	r20, 0x03	; 3
    6942:	ee 0f       	add	r30, r30
    6944:	ff 1f       	adc	r31, r31
    6946:	4a 95       	dec	r20
    6948:	e1 f7       	brne	.-8      	; 0x6942 <MB_M_Timer_ISR+0x472>
    694a:	e3 5b       	subi	r30, 0xB3	; 179
    694c:	fc 4f       	sbci	r31, 0xFC	; 252
    694e:	60 81       	ld	r22, Z
    6950:	71 81       	ldd	r23, Z+1	; 0x01
		Qt				= MB_SingleQuery[MB_N].Qt;
    6952:	fe 01       	movw	r30, r28
    6954:	33 e0       	ldi	r19, 0x03	; 3
    6956:	ee 0f       	add	r30, r30
    6958:	ff 1f       	adc	r31, r31
    695a:	3a 95       	dec	r19
    695c:	e1 f7       	brne	.-8      	; 0x6956 <MB_M_Timer_ISR+0x486>
    695e:	e1 5b       	subi	r30, 0xB1	; 177
    6960:	fc 4f       	sbci	r31, 0xFC	; 252
    6962:	00 81       	ld	r16, Z
    6964:	11 81       	ldd	r17, Z+1	; 0x01
    6966:	08 c0       	rjmp	.+16     	; 0x6978 <MB_M_Timer_ISR+0x4a8>
    6968:	fa 01       	movw	r30, r20
    696a:	31 96       	adiw	r30, 0x01	; 1
    696c:	65 91       	lpm	r22, Z+
    696e:	74 91       	lpm	r23, Z+
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
		Qt				= prw(&Query->Qt);
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6970:	fa 01       	movw	r30, r20
    6972:	33 96       	adiw	r30, 0x03	; 3
    6974:	05 91       	lpm	r16, Z+
    6976:	14 91       	lpm	r17, Z+
    6978:	fe 01       	movw	r30, r28
    697a:	e6 5b       	subi	r30, 0xB6	; 182
    697c:	f7 4f       	sbci	r31, 0xF7	; 247
    697e:	80 81       	ld	r24, Z
    6980:	88 30       	cpi	r24, 0x08	; 8
    6982:	19 f5       	brne	.+70     	; 0x69ca <MB_M_Timer_ISR+0x4fa>
    6984:	fc 2f       	mov	r31, r28
    6986:	ee 27       	eor	r30, r30
    6988:	ef 54       	subi	r30, 0x4F	; 79
    698a:	f3 4f       	sbci	r31, 0xF3	; 243
    698c:	30 81       	ld	r19, Z
    698e:	20 e0       	ldi	r18, 0x00	; 0
    6990:	bc 2f       	mov	r27, r28
    6992:	aa 27       	eor	r26, r26
    6994:	a1 55       	subi	r26, 0x51	; 81
    6996:	b3 4f       	sbci	r27, 0xF3	; 243
    6998:	13 96       	adiw	r26, 0x03	; 3
    699a:	8c 91       	ld	r24, X
    699c:	13 97       	sbiw	r26, 0x03	; 3
    699e:	90 e0       	ldi	r25, 0x00	; 0
    69a0:	28 2b       	or	r18, r24
    69a2:	39 2b       	or	r19, r25
    69a4:	26 17       	cp	r18, r22
    69a6:	37 07       	cpc	r19, r23
    69a8:	81 f4       	brne	.+32     	; 0x69ca <MB_M_Timer_ISR+0x4fa>
    69aa:	40 e0       	ldi	r20, 0x00	; 0
    69ac:	50 e0       	ldi	r21, 0x00	; 0
    69ae:	fc 2f       	mov	r31, r28
    69b0:	ee 27       	eor	r30, r30
    69b2:	ed 54       	subi	r30, 0x4D	; 77
    69b4:	f3 4f       	sbci	r31, 0xF3	; 243
    69b6:	90 81       	ld	r25, Z
    69b8:	80 e0       	ldi	r24, 0x00	; 0
    69ba:	15 96       	adiw	r26, 0x05	; 5
    69bc:	2c 91       	ld	r18, X
    69be:	30 e0       	ldi	r19, 0x00	; 0
    69c0:	82 2b       	or	r24, r18
    69c2:	93 2b       	or	r25, r19
    69c4:	80 17       	cp	r24, r16
    69c6:	91 07       	cpc	r25, r17
    69c8:	11 f0       	breq	.+4      	; 0x69ce <MB_M_Timer_ISR+0x4fe>
    69ca:	41 e0       	ldi	r20, 0x01	; 1
    69cc:	50 e0       	ldi	r21, 0x00	; 0
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    69ce:	44 23       	and	r20, r20
    69d0:	89 f0       	breq	.+34     	; 0x69f4 <MB_M_Timer_ISR+0x524>
				MB_CPT[MB_N][2]++;
    69d2:	fe 01       	movw	r30, r28
    69d4:	04 e0       	ldi	r16, 0x04	; 4
    69d6:	ee 0f       	add	r30, r30
    69d8:	ff 1f       	adc	r31, r31
    69da:	0a 95       	dec	r16
    69dc:	e1 f7       	brne	.-8      	; 0x69d6 <MB_M_Timer_ISR+0x506>
    69de:	eb 56       	subi	r30, 0x6B	; 107
    69e0:	f5 4f       	sbci	r31, 0xF5	; 245
    69e2:	80 81       	ld	r24, Z
    69e4:	91 81       	ldd	r25, Z+1	; 0x01
    69e6:	01 96       	adiw	r24, 0x01	; 1
    69e8:	91 83       	std	Z+1, r25	; 0x01
    69ea:	80 83       	st	Z, r24
				Over = FailSlave(MB_N);
    69ec:	89 2d       	mov	r24, r9
    69ee:	0e 94 00 32 	call	0x6400	; 0x6400 <FailSlave>
    69f2:	49 c0       	rjmp	.+146    	; 0x6a86 <MB_M_Timer_ISR+0x5b6>
			}
			else if (LastProcSingle)
    69f4:	80 91 53 03 	lds	r24, 0x0353
    69f8:	88 23       	and	r24, r24
    69fa:	31 f0       	breq	.+12     	; 0x6a08 <MB_M_Timer_ISR+0x538>
				MB_SingleState[MB_N] = MB_SingleIdle;
    69fc:	fe 01       	movw	r30, r28
    69fe:	e1 56       	subi	r30, 0x61	; 97
    6a00:	fa 4f       	sbci	r31, 0xFA	; 250
    6a02:	10 82       	st	Z, r1
    6a04:	80 e0       	ldi	r24, 0x00	; 0
    6a06:	3f c0       	rjmp	.+126    	; 0x6a86 <MB_M_Timer_ISR+0x5b6>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6a08:	be 01       	movw	r22, r28
    6a0a:	66 0f       	add	r22, r22
    6a0c:	77 1f       	adc	r23, r23
    6a0e:	66 0f       	add	r22, r22
    6a10:	77 1f       	adc	r23, r23
    6a12:	64 58       	subi	r22, 0x84	; 132
    6a14:	75 4f       	sbci	r23, 0xF5	; 245
    6a16:	9e 01       	movw	r18, r28
    6a18:	2c 57       	subi	r18, 0x7C	; 124
    6a1a:	3a 4f       	sbci	r19, 0xFA	; 250
    6a1c:	81 e0       	ldi	r24, 0x01	; 1
    6a1e:	90 e0       	ldi	r25, 0x00	; 0
    6a20:	a0 e0       	ldi	r26, 0x00	; 0
    6a22:	b0 e0       	ldi	r27, 0x00	; 0
    6a24:	f9 01       	movw	r30, r18
    6a26:	00 80       	ld	r0, Z
    6a28:	04 c0       	rjmp	.+8      	; 0x6a32 <MB_M_Timer_ISR+0x562>
    6a2a:	88 0f       	add	r24, r24
    6a2c:	99 1f       	adc	r25, r25
    6a2e:	aa 1f       	adc	r26, r26
    6a30:	bb 1f       	adc	r27, r27
    6a32:	0a 94       	dec	r0
    6a34:	d2 f7       	brpl	.-12     	; 0x6a2a <MB_M_Timer_ISR+0x55a>
    6a36:	80 95       	com	r24
    6a38:	90 95       	com	r25
    6a3a:	a0 95       	com	r26
    6a3c:	b0 95       	com	r27
    6a3e:	fb 01       	movw	r30, r22
    6a40:	20 81       	ld	r18, Z
    6a42:	31 81       	ldd	r19, Z+1	; 0x01
    6a44:	42 81       	ldd	r20, Z+2	; 0x02
    6a46:	53 81       	ldd	r21, Z+3	; 0x03
    6a48:	82 23       	and	r24, r18
    6a4a:	93 23       	and	r25, r19
    6a4c:	a4 23       	and	r26, r20
    6a4e:	b5 23       	and	r27, r21
    6a50:	80 83       	st	Z, r24
    6a52:	91 83       	std	Z+1, r25	; 0x01
    6a54:	a2 83       	std	Z+2, r26	; 0x02
    6a56:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    6a58:	fe 01       	movw	r30, r28
    6a5a:	e6 57       	subi	r30, 0x76	; 118
    6a5c:	fa 4f       	sbci	r31, 0xFA	; 250
    6a5e:	80 81       	ld	r24, Z
    6a60:	8f 5f       	subi	r24, 0xFF	; 255
    6a62:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6a64:	23 e0       	ldi	r18, 0x03	; 3
    6a66:	30 e0       	ldi	r19, 0x00	; 0
    6a68:	c2 0e       	add	r12, r18
    6a6a:	d3 1e       	adc	r13, r19
    6a6c:	f6 01       	movw	r30, r12
    6a6e:	94 91       	lpm	r25, Z+
    6a70:	89 17       	cp	r24, r25
    6a72:	11 f0       	breq	.+4      	; 0x6a78 <MB_M_Timer_ISR+0x5a8>
    6a74:	80 e0       	ldi	r24, 0x00	; 0
    6a76:	03 c0       	rjmp	.+6      	; 0x6a7e <MB_M_Timer_ISR+0x5ae>
					Over = NextSlave(MB_N);
    6a78:	89 2d       	mov	r24, r9
    6a7a:	0e 94 41 31 	call	0x6282	; 0x6282 <NextSlave>
				Try[MB_N] = 0;
    6a7e:	fe 01       	movw	r30, r28
    6a80:	ec 5a       	subi	r30, 0xAC	; 172
    6a82:	fc 4f       	sbci	r31, 0xFC	; 252
    6a84:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    6a86:	90 91 59 03 	lds	r25, 0x0359
    6a8a:	88 23       	and	r24, r24
    6a8c:	19 f4       	brne	.+6      	; 0x6a94 <MB_M_Timer_ISR+0x5c4>
    6a8e:	65 e0       	ldi	r22, 0x05	; 5
    6a90:	70 e0       	ldi	r23, 0x00	; 0
    6a92:	06 c0       	rjmp	.+12     	; 0x6aa0 <MB_M_Timer_ISR+0x5d0>
    6a94:	cc 0f       	add	r28, r28
    6a96:	dd 1f       	adc	r29, r29
    6a98:	c3 56       	subi	r28, 0x63	; 99
    6a9a:	da 4f       	sbci	r29, 0xFA	; 250
    6a9c:	68 81       	ld	r22, Y
    6a9e:	79 81       	ldd	r23, Y+1	; 0x01
    6aa0:	89 2d       	mov	r24, r9
    6aa2:	89 0f       	add	r24, r25
    6aa4:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6aa8:	df 91       	pop	r29
    6aaa:	cf 91       	pop	r28
    6aac:	1f 91       	pop	r17
    6aae:	0f 91       	pop	r16
    6ab0:	ff 90       	pop	r15
    6ab2:	ef 90       	pop	r14
    6ab4:	df 90       	pop	r13
    6ab6:	cf 90       	pop	r12
    6ab8:	bf 90       	pop	r11
    6aba:	af 90       	pop	r10
    6abc:	9f 90       	pop	r9
    6abe:	7f 90       	pop	r7
    6ac0:	6f 90       	pop	r6
    6ac2:	08 95       	ret

00006ac4 <MB_Timer_ISR>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~
static void
MB_Timer_ISR(tc_t *tc)
{
    6ac4:	ac 01       	movw	r20, r24
    6ac6:	20 e0       	ldi	r18, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ac8:	36 e0       	ldi	r19, 0x06	; 6
    6aca:	01 c0       	rjmp	.+2      	; 0x6ace <MB_Timer_ISR+0xa>
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    6acc:	2f 5f       	subi	r18, 0xFF	; 255
    6ace:	23 9f       	mul	r18, r19
    6ad0:	f0 01       	movw	r30, r0
    6ad2:	11 24       	eor	r1, r1
    6ad4:	ef 51       	subi	r30, 0x1F	; 31
    6ad6:	f6 4b       	sbci	r31, 0xB6	; 182
    6ad8:	85 91       	lpm	r24, Z+
    6ada:	94 91       	lpm	r25, Z+
    6adc:	48 17       	cp	r20, r24
    6ade:	59 07       	cpc	r21, r25
    6ae0:	a9 f7       	brne	.-22     	; 0x6acc <MB_Timer_ISR+0x8>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6ae2:	e2 2f       	mov	r30, r18
    6ae4:	f0 e0       	ldi	r31, 0x00	; 0
    6ae6:	e0 52       	subi	r30, 0x20	; 32
    6ae8:	f6 4b       	sbci	r31, 0xB6	; 182
    6aea:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6aec:	88 23       	and	r24, r24
    6aee:	19 f0       	breq	.+6      	; 0x6af6 <MB_Timer_ISR+0x32>
    6af0:	81 30       	cpi	r24, 0x01	; 1
    6af2:	41 f4       	brne	.+16     	; 0x6b04 <MB_Timer_ISR+0x40>
    6af4:	04 c0       	rjmp	.+8      	; 0x6afe <MB_Timer_ISR+0x3a>
	case Role_Slave:
		MB_S_Timer_ISR(MB_N);
    6af6:	82 2f       	mov	r24, r18
    6af8:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <MB_S_Timer_ISR>
    6afc:	08 95       	ret
		break;
	case Role_Master:
		MB_M_Timer_ISR(MB_N);
    6afe:	82 2f       	mov	r24, r18
    6b00:	0e 94 68 32 	call	0x64d0	; 0x64d0 <MB_M_Timer_ISR>
    6b04:	08 95       	ret

00006b06 <__vector_9>:
	MB_Timer_ISR(&TCNT0);
}

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    6b06:	1f 92       	push	r1
    6b08:	0f 92       	push	r0
    6b0a:	0f b6       	in	r0, 0x3f	; 63
    6b0c:	0f 92       	push	r0
    6b0e:	0b b6       	in	r0, 0x3b	; 59
    6b10:	0f 92       	push	r0
    6b12:	11 24       	eor	r1, r1
    6b14:	2f 93       	push	r18
    6b16:	3f 93       	push	r19
    6b18:	4f 93       	push	r20
    6b1a:	5f 93       	push	r21
    6b1c:	6f 93       	push	r22
    6b1e:	7f 93       	push	r23
    6b20:	8f 93       	push	r24
    6b22:	9f 93       	push	r25
    6b24:	af 93       	push	r26
    6b26:	bf 93       	push	r27
    6b28:	ef 93       	push	r30
    6b2a:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    6b2c:	85 b5       	in	r24, 0x25	; 37
    6b2e:	88 7f       	andi	r24, 0xF8	; 248
    6b30:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    6b32:	87 b7       	in	r24, 0x37	; 55
    6b34:	8f 77       	andi	r24, 0x7F	; 127
    6b36:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    6b38:	84 e4       	ldi	r24, 0x44	; 68
    6b3a:	90 e0       	ldi	r25, 0x00	; 0
    6b3c:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <MB_Timer_ISR>
}
    6b40:	ff 91       	pop	r31
    6b42:	ef 91       	pop	r30
    6b44:	bf 91       	pop	r27
    6b46:	af 91       	pop	r26
    6b48:	9f 91       	pop	r25
    6b4a:	8f 91       	pop	r24
    6b4c:	7f 91       	pop	r23
    6b4e:	6f 91       	pop	r22
    6b50:	5f 91       	pop	r21
    6b52:	4f 91       	pop	r20
    6b54:	3f 91       	pop	r19
    6b56:	2f 91       	pop	r18
    6b58:	0f 90       	pop	r0
    6b5a:	0b be       	out	0x3b, r0	; 59
    6b5c:	0f 90       	pop	r0
    6b5e:	0f be       	out	0x3f, r0	; 63
    6b60:	0f 90       	pop	r0
    6b62:	1f 90       	pop	r1
    6b64:	18 95       	reti

00006b66 <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    6b66:	1f 92       	push	r1
    6b68:	0f 92       	push	r0
    6b6a:	0f b6       	in	r0, 0x3f	; 63
    6b6c:	0f 92       	push	r0
    6b6e:	0b b6       	in	r0, 0x3b	; 59
    6b70:	0f 92       	push	r0
    6b72:	11 24       	eor	r1, r1
    6b74:	2f 93       	push	r18
    6b76:	3f 93       	push	r19
    6b78:	4f 93       	push	r20
    6b7a:	5f 93       	push	r21
    6b7c:	6f 93       	push	r22
    6b7e:	7f 93       	push	r23
    6b80:	8f 93       	push	r24
    6b82:	9f 93       	push	r25
    6b84:	af 93       	push	r26
    6b86:	bf 93       	push	r27
    6b88:	ef 93       	push	r30
    6b8a:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    6b8c:	83 b7       	in	r24, 0x33	; 51
    6b8e:	88 7f       	andi	r24, 0xF8	; 248
    6b90:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    6b92:	87 b7       	in	r24, 0x37	; 55
    6b94:	8d 7f       	andi	r24, 0xFD	; 253
    6b96:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    6b98:	82 e5       	ldi	r24, 0x52	; 82
    6b9a:	90 e0       	ldi	r25, 0x00	; 0
    6b9c:	0e 94 62 35 	call	0x6ac4	; 0x6ac4 <MB_Timer_ISR>
}
    6ba0:	ff 91       	pop	r31
    6ba2:	ef 91       	pop	r30
    6ba4:	bf 91       	pop	r27
    6ba6:	af 91       	pop	r26
    6ba8:	9f 91       	pop	r25
    6baa:	8f 91       	pop	r24
    6bac:	7f 91       	pop	r23
    6bae:	6f 91       	pop	r22
    6bb0:	5f 91       	pop	r21
    6bb2:	4f 91       	pop	r20
    6bb4:	3f 91       	pop	r19
    6bb6:	2f 91       	pop	r18
    6bb8:	0f 90       	pop	r0
    6bba:	0b be       	out	0x3b, r0	; 59
    6bbc:	0f 90       	pop	r0
    6bbe:	0f be       	out	0x3f, r0	; 63
    6bc0:	0f 90       	pop	r0
    6bc2:	1f 90       	pop	r1
    6bc4:	18 95       	reti

00006bc6 <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    6bc6:	90 91 59 03 	lds	r25, 0x0359
    6bca:	eb e7       	ldi	r30, 0x7B	; 123
    6bcc:	fa e0       	ldi	r31, 0x0A	; 10
    6bce:	e8 0f       	add	r30, r24
    6bd0:	f1 1d       	adc	r31, r1
    6bd2:	60 81       	ld	r22, Z
    6bd4:	89 0f       	add	r24, r25
    6bd6:	70 e0       	ldi	r23, 0x00	; 0
    6bd8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
}
    6bdc:	08 95       	ret

00006bde <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    6bde:	df 92       	push	r13
    6be0:	ef 92       	push	r14
    6be2:	ff 92       	push	r15
    6be4:	0f 93       	push	r16
    6be6:	1f 93       	push	r17
    6be8:	cf 93       	push	r28
    6bea:	df 93       	push	r29
    6bec:	dc 01       	movw	r26, r24
    6bee:	dd 24       	eor	r13, r13

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6bf0:	24 e1       	ldi	r18, 0x14	; 20
    6bf2:	30 e0       	ldi	r19, 0x00	; 0
    6bf4:	01 c0       	rjmp	.+2      	; 0x6bf8 <Modbus_TX+0x1a>
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6bf6:	d3 94       	inc	r13
    6bf8:	cd 2d       	mov	r28, r13
    6bfa:	d0 e0       	ldi	r29, 0x00	; 0
    6bfc:	c2 9f       	mul	r28, r18
    6bfe:	f0 01       	movw	r30, r0
    6c00:	c3 9f       	mul	r28, r19
    6c02:	f0 0d       	add	r31, r0
    6c04:	d2 9f       	mul	r29, r18
    6c06:	f0 0d       	add	r31, r0
    6c08:	11 24       	eor	r1, r1
    6c0a:	e4 53       	subi	r30, 0x34	; 52
    6c0c:	f6 4b       	sbci	r31, 0xB6	; 182
    6c0e:	85 91       	lpm	r24, Z+
    6c10:	94 91       	lpm	r25, Z+
    6c12:	a8 17       	cp	r26, r24
    6c14:	b9 07       	cpc	r27, r25
    6c16:	79 f7       	brne	.-34     	; 0x6bf6 <Modbus_TX+0x18>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    6c18:	fe 01       	movw	r30, r28
    6c1a:	e6 50       	subi	r30, 0x06	; 6
    6c1c:	fe 4f       	sbci	r31, 0xFE	; 254
    6c1e:	40 81       	ld	r20, Z
    6c20:	24 2f       	mov	r18, r20
    6c22:	30 e0       	ldi	r19, 0x00	; 0
    6c24:	fe 01       	movw	r30, r28
    6c26:	e6 5b       	subi	r30, 0xB6	; 182
    6c28:	f7 4f       	sbci	r31, 0xF7	; 247
    6c2a:	80 81       	ld	r24, Z
    6c2c:	90 e0       	ldi	r25, 0x00	; 0
    6c2e:	02 97       	sbiw	r24, 0x02	; 2
    6c30:	28 17       	cp	r18, r24
    6c32:	39 07       	cpc	r19, r25
    6c34:	51 f5       	brne	.+84     	; 0x6c8a <Modbus_TX+0xac>
    6c36:	fe 01       	movw	r30, r28
    6c38:	ee 0f       	add	r30, r30
    6c3a:	ff 1f       	adc	r31, r31
    6c3c:	ee 0f       	add	r30, r30
    6c3e:	ff 1f       	adc	r31, r31
    6c40:	ec 0f       	add	r30, r28
    6c42:	fd 1f       	adc	r31, r29
    6c44:	ee 0f       	add	r30, r30
    6c46:	ff 1f       	adc	r31, r31
    6c48:	ee 0f       	add	r30, r30
    6c4a:	ff 1f       	adc	r31, r31
    6c4c:	e0 53       	subi	r30, 0x30	; 48
    6c4e:	f6 4b       	sbci	r31, 0xB6	; 182
    6c50:	25 91       	lpm	r18, Z+
    6c52:	34 91       	lpm	r19, Z+
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    6c54:	f9 01       	movw	r30, r18
    6c56:	80 81       	ld	r24, Z
    6c58:	8f 7d       	andi	r24, 0xDF	; 223
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    6c5a:	80 64       	ori	r24, 0x40	; 64
    6c5c:	80 83       	st	Z, r24
    6c5e:	9e 01       	movw	r18, r28
    6c60:	22 0f       	add	r18, r18
    6c62:	33 1f       	adc	r19, r19
    6c64:	ce 01       	movw	r24, r28
    6c66:	f3 e0       	ldi	r31, 0x03	; 3
    6c68:	88 0f       	add	r24, r24
    6c6a:	99 1f       	adc	r25, r25
    6c6c:	fa 95       	dec	r31
    6c6e:	e1 f7       	brne	.-8      	; 0x6c68 <Modbus_TX+0x8a>
    6c70:	28 0f       	add	r18, r24
    6c72:	39 1f       	adc	r19, r25
    6c74:	22 0f       	add	r18, r18
    6c76:	33 1f       	adc	r19, r19
    6c78:	22 53       	subi	r18, 0x32	; 50
    6c7a:	36 4b       	sbci	r19, 0xB6	; 182
    6c7c:	f9 01       	movw	r30, r18
    6c7e:	65 91       	lpm	r22, Z+
    6c80:	74 91       	lpm	r23, Z+
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    6c82:	fb 01       	movw	r30, r22
    6c84:	80 81       	ld	r24, Z
    6c86:	80 64       	ori	r24, 0x40	; 64
    6c88:	80 83       	st	Z, r24
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    6c8a:	24 2f       	mov	r18, r20
    6c8c:	2f 5f       	subi	r18, 0xFF	; 255
    6c8e:	7a ef       	ldi	r23, 0xFA	; 250
    6c90:	e7 2e       	mov	r14, r23
    6c92:	71 e0       	ldi	r23, 0x01	; 1
    6c94:	f7 2e       	mov	r15, r23
    6c96:	ec 0e       	add	r14, r28
    6c98:	fd 1e       	adc	r15, r29
    6c9a:	f7 01       	movw	r30, r14
    6c9c:	20 83       	st	Z, r18
    6c9e:	fe 01       	movw	r30, r28
    6ca0:	e6 5b       	subi	r30, 0xB6	; 182
    6ca2:	f7 4f       	sbci	r31, 0xF7	; 247
    6ca4:	80 81       	ld	r24, Z
    6ca6:	28 17       	cp	r18, r24
    6ca8:	48 f4       	brcc	.+18     	; 0x6cbc <Modbus_TX+0xde>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    6caa:	fc 2f       	mov	r31, r28
    6cac:	ee 27       	eor	r30, r30
    6cae:	e2 0f       	add	r30, r18
    6cb0:	f1 1d       	adc	r31, r1
    6cb2:	e1 55       	subi	r30, 0x51	; 81
    6cb4:	f3 4f       	sbci	r31, 0xF3	; 243
    6cb6:	80 81       	ld	r24, Z
    6cb8:	8c 93       	st	X, r24
    6cba:	40 c0       	rjmp	.+128    	; 0x6d3c <Modbus_TX+0x15e>
    6cbc:	ce 01       	movw	r24, r28
    6cbe:	88 0f       	add	r24, r24
    6cc0:	99 1f       	adc	r25, r25
    6cc2:	88 0f       	add	r24, r24
    6cc4:	99 1f       	adc	r25, r25
    6cc6:	8c 0f       	add	r24, r28
    6cc8:	9d 1f       	adc	r25, r29
    6cca:	88 0f       	add	r24, r24
    6ccc:	99 1f       	adc	r25, r25
    6cce:	88 0f       	add	r24, r24
    6cd0:	99 1f       	adc	r25, r25
    6cd2:	80 53       	subi	r24, 0x30	; 48
    6cd4:	96 4b       	sbci	r25, 0xB6	; 182
    6cd6:	fc 01       	movw	r30, r24
    6cd8:	a5 91       	lpm	r26, Z+
    6cda:	b4 91       	lpm	r27, Z+
		return;
	}
	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~(1<<6);
    6cdc:	8c 91       	ld	r24, X
    6cde:	8f 7b       	andi	r24, 0xBF	; 191
    6ce0:	8c 93       	st	X, r24
    6ce2:	84 e1       	ldi	r24, 0x14	; 20
    6ce4:	90 e0       	ldi	r25, 0x00	; 0
    6ce6:	c8 9f       	mul	r28, r24
    6ce8:	80 01       	movw	r16, r0
    6cea:	c9 9f       	mul	r28, r25
    6cec:	10 0d       	add	r17, r0
    6cee:	d8 9f       	mul	r29, r24
    6cf0:	10 0d       	add	r17, r0
    6cf2:	11 24       	eor	r1, r1
    6cf4:	c8 01       	movw	r24, r16
    6cf6:	88 52       	subi	r24, 0x28	; 40
    6cf8:	96 4b       	sbci	r25, 0xB6	; 182
    6cfa:	fc 01       	movw	r30, r24
    6cfc:	25 91       	lpm	r18, Z+
    6cfe:	34 91       	lpm	r19, Z+
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    6d00:	f9 01       	movw	r30, r18
    6d02:	09 95       	icall
	Count[MB_N] = 0;
    6d04:	f7 01       	movw	r30, r14
    6d06:	10 82       	st	Z, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    6d08:	cc 59       	subi	r28, 0x9C	; 156
    6d0a:	dc 4f       	sbci	r29, 0xFC	; 252
    6d0c:	81 e0       	ldi	r24, 0x01	; 1
    6d0e:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6d10:	ed 2d       	mov	r30, r13
    6d12:	f0 e0       	ldi	r31, 0x00	; 0
    6d14:	e0 52       	subi	r30, 0x20	; 32
    6d16:	f6 4b       	sbci	r31, 0xB6	; 182
    6d18:	84 91       	lpm	r24, Z+
	switch (prb(MB_Role+MB_N)) {
    6d1a:	88 23       	and	r24, r24
    6d1c:	19 f0       	breq	.+6      	; 0x6d24 <Modbus_TX+0x146>
    6d1e:	81 30       	cpi	r24, 0x01	; 1
    6d20:	69 f4       	brne	.+26     	; 0x6d3c <Modbus_TX+0x15e>
    6d22:	09 c0       	rjmp	.+18     	; 0x6d36 <Modbus_TX+0x158>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6d24:	c8 01       	movw	r24, r16
    6d26:	86 52       	subi	r24, 0x26	; 38
    6d28:	96 4b       	sbci	r25, 0xB6	; 182
    6d2a:	fc 01       	movw	r30, r24
    6d2c:	25 91       	lpm	r18, Z+
    6d2e:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6d30:	f9 01       	movw	r30, r18
    6d32:	09 95       	icall
    6d34:	03 c0       	rjmp	.+6      	; 0x6d3c <Modbus_TX+0x15e>
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    6d36:	8d 2d       	mov	r24, r13
    6d38:	0e 94 e3 35 	call	0x6bc6	; 0x6bc6 <MB_M_Tx>
		break;
	}
}
    6d3c:	df 91       	pop	r29
    6d3e:	cf 91       	pop	r28
    6d40:	1f 91       	pop	r17
    6d42:	0f 91       	pop	r16
    6d44:	ff 90       	pop	r15
    6d46:	ef 90       	pop	r14
    6d48:	df 90       	pop	r13
    6d4a:	08 95       	ret

00006d4c <MB_SingleRun>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_SingleRun(uint8_t MB_N, uint8_t Addr, uint8_t Func, uint16_t StartAddr, uint16_t Qt, void *Buf)
{
    6d4c:	df 92       	push	r13
    6d4e:	ef 92       	push	r14
    6d50:	ff 92       	push	r15
    6d52:	0f 93       	push	r16
    6d54:	1f 93       	push	r17
    6d56:	cf 93       	push	r28
    6d58:	df 93       	push	r29
    6d5a:	d8 2e       	mov	r13, r24
    6d5c:	94 2f       	mov	r25, r20
    6d5e:	e9 01       	movw	r28, r18
	if (MB_SingleState[MB_N]!=MB_SingleIdle)
    6d60:	48 2f       	mov	r20, r24
    6d62:	50 e0       	ldi	r21, 0x00	; 0
    6d64:	9a 01       	movw	r18, r20
    6d66:	21 56       	subi	r18, 0x61	; 97
    6d68:	3a 4f       	sbci	r19, 0xFA	; 250
    6d6a:	f9 01       	movw	r30, r18
    6d6c:	80 81       	ld	r24, Z
    6d6e:	88 23       	and	r24, r24
    6d70:	09 f0       	breq	.+2      	; 0x6d74 <MB_SingleRun+0x28>
    6d72:	97 c0       	rjmp	.+302    	; 0x6ea2 <MB_SingleRun+0x156>
		return;

	MB_SingleQuery[MB_N].Addr				= Addr;
    6d74:	da 01       	movw	r26, r20
    6d76:	73 e0       	ldi	r23, 0x03	; 3
    6d78:	aa 0f       	add	r26, r26
    6d7a:	bb 1f       	adc	r27, r27
    6d7c:	7a 95       	dec	r23
    6d7e:	e1 f7       	brne	.-8      	; 0x6d78 <MB_SingleRun+0x2c>
    6d80:	a5 5b       	subi	r26, 0xB5	; 181
    6d82:	bc 4f       	sbci	r27, 0xFC	; 252
    6d84:	6c 93       	st	X, r22
	MB_SingleQuery[MB_N].Func				= Func;
    6d86:	11 96       	adiw	r26, 0x01	; 1
    6d88:	9c 93       	st	X, r25
    6d8a:	11 97       	sbiw	r26, 0x01	; 1
	MB_SingleQuery[MB_N].StartAddr	= StartAddr;
    6d8c:	fa 01       	movw	r30, r20
    6d8e:	83 e0       	ldi	r24, 0x03	; 3
    6d90:	ee 0f       	add	r30, r30
    6d92:	ff 1f       	adc	r31, r31
    6d94:	8a 95       	dec	r24
    6d96:	e1 f7       	brne	.-8      	; 0x6d90 <MB_SingleRun+0x44>
    6d98:	e3 5b       	subi	r30, 0xB3	; 179
    6d9a:	fc 4f       	sbci	r31, 0xFC	; 252
    6d9c:	d1 83       	std	Z+1, r29	; 0x01
    6d9e:	c0 83       	st	Z, r28
	MB_SingleQuery[MB_N].Qt					= Qt;
    6da0:	ea 01       	movw	r28, r20
    6da2:	cc 0f       	add	r28, r28
    6da4:	dd 1f       	adc	r29, r29
    6da6:	fe 01       	movw	r30, r28
    6da8:	ee 0f       	add	r30, r30
    6daa:	ff 1f       	adc	r31, r31
    6dac:	ee 0f       	add	r30, r30
    6dae:	ff 1f       	adc	r31, r31
    6db0:	e1 5b       	subi	r30, 0xB1	; 177
    6db2:	fc 4f       	sbci	r31, 0xFC	; 252
    6db4:	11 83       	std	Z+1, r17	; 0x01
    6db6:	00 83       	st	Z, r16
	MB_SingleQuery[MB_N].Buf				= Buf;
    6db8:	17 96       	adiw	r26, 0x07	; 7
    6dba:	fc 92       	st	X, r15
    6dbc:	ee 92       	st	-X, r14
    6dbe:	16 97       	sbiw	r26, 0x06	; 6

	MB_SingleState[MB_N] = MB_SingleStart;
    6dc0:	81 e0       	ldi	r24, 0x01	; 1
    6dc2:	f9 01       	movw	r30, r18
    6dc4:	80 83       	st	Z, r24
	if (MB_State[MB_N]==MB_Proc && !LastProcSingle) {
    6dc6:	fa 01       	movw	r30, r20
    6dc8:	ec 59       	subi	r30, 0x9C	; 156
    6dca:	fc 4f       	sbci	r31, 0xFC	; 252
    6dcc:	80 81       	ld	r24, Z
    6dce:	84 30       	cpi	r24, 0x04	; 4
    6dd0:	09 f0       	breq	.+2      	; 0x6dd4 <MB_SingleRun+0x88>
    6dd2:	67 c0       	rjmp	.+206    	; 0x6ea2 <MB_SingleRun+0x156>
    6dd4:	80 91 53 03 	lds	r24, 0x0353
    6dd8:	88 23       	and	r24, r24
    6dda:	09 f0       	breq	.+2      	; 0x6dde <MB_SingleRun+0x92>
    6ddc:	62 c0       	rjmp	.+196    	; 0x6ea2 <MB_SingleRun+0x156>
		uint16_t T = (CurrSlave[MB_N]==0 ? MB_M_Period[MB_N] : MB_M_Timeout[MB_N]) - GetTimer16(TD_MB_Idle+MB_N);
    6dde:	fa 01       	movw	r30, r20
    6de0:	ec 57       	subi	r30, 0x7C	; 124
    6de2:	fa 4f       	sbci	r31, 0xFA	; 250
    6de4:	80 81       	ld	r24, Z
    6de6:	88 23       	and	r24, r24
    6de8:	29 f4       	brne	.+10     	; 0x6df4 <MB_SingleRun+0xa8>
    6dea:	c3 56       	subi	r28, 0x63	; 99
    6dec:	da 4f       	sbci	r29, 0xFA	; 250
    6dee:	68 81       	ld	r22, Y
    6df0:	79 81       	ldd	r23, Y+1	; 0x01
    6df2:	06 c0       	rjmp	.+12     	; 0x6e00 <MB_SingleRun+0xb4>
    6df4:	fa 01       	movw	r30, r20
    6df6:	e5 58       	subi	r30, 0x85	; 133
    6df8:	f5 4f       	sbci	r31, 0xF5	; 245
    6dfa:	80 81       	ld	r24, Z
    6dfc:	68 2f       	mov	r22, r24
    6dfe:	70 e0       	ldi	r23, 0x00	; 0
    6e00:	20 91 59 03 	lds	r18, 0x0359
    6e04:	2d 0d       	add	r18, r13

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6e06:	8f b7       	in	r24, 0x3f	; 63
    6e08:	80 78       	andi	r24, 0x80	; 128
    6e0a:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    6e0e:	f8 94       	cli
    6e10:	e2 2f       	mov	r30, r18
    6e12:	f0 e0       	ldi	r31, 0x00	; 0
    6e14:	ee 0f       	add	r30, r30
    6e16:	ff 1f       	adc	r31, r31
    6e18:	eb 5d       	subi	r30, 0xDB	; 219
    6e1a:	fd 4f       	sbci	r31, 0xFD	; 253
    6e1c:	01 90       	ld	r0, Z+
    6e1e:	f0 81       	ld	r31, Z
    6e20:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6e22:	88 23       	and	r24, r24
    6e24:	09 f0       	breq	.+2      	; 0x6e28 <MB_SingleRun+0xdc>
		sei();
    6e26:	78 94       	sei
    6e28:	cb 01       	movw	r24, r22
    6e2a:	8e 1b       	sub	r24, r30
    6e2c:	9f 0b       	sbc	r25, r31
		if (T<MB_M_Pause_Min)
    6e2e:	85 30       	cpi	r24, 0x05	; 5
    6e30:	91 05       	cpc	r25, r1
    6e32:	40 f4       	brcc	.+16     	; 0x6e44 <MB_SingleRun+0xf8>
			StartTimer16(TD_MB_Idle+MB_N, MB_M_Pause_Min-T);
    6e34:	65 e0       	ldi	r22, 0x05	; 5
    6e36:	70 e0       	ldi	r23, 0x00	; 0
    6e38:	68 1b       	sub	r22, r24
    6e3a:	79 0b       	sbc	r23, r25
    6e3c:	82 2f       	mov	r24, r18
    6e3e:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    6e42:	2f c0       	rjmp	.+94     	; 0x6ea2 <MB_SingleRun+0x156>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6e44:	8f b7       	in	r24, 0x3f	; 63
    6e46:	80 78       	andi	r24, 0x80	; 128
    6e48:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    6e4c:	f8 94       	cli
    6e4e:	84 e1       	ldi	r24, 0x14	; 20
    6e50:	90 e0       	ldi	r25, 0x00	; 0
    6e52:	48 9f       	mul	r20, r24
    6e54:	90 01       	movw	r18, r0
    6e56:	49 9f       	mul	r20, r25
    6e58:	30 0d       	add	r19, r0
    6e5a:	58 9f       	mul	r21, r24
    6e5c:	30 0d       	add	r19, r0
    6e5e:	11 24       	eor	r1, r1
    6e60:	26 52       	subi	r18, 0x26	; 38
    6e62:	36 4b       	sbci	r19, 0xB6	; 182
    6e64:	f9 01       	movw	r30, r18
    6e66:	85 91       	lpm	r24, Z+
    6e68:	94 91       	lpm	r25, Z+
		else {
			IntOff();
			USART_Func(MB_N, LED);
    6e6a:	fc 01       	movw	r30, r24
    6e6c:	09 95       	icall

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6e6e:	80 91 fc 01 	lds	r24, 0x01FC
    6e72:	88 23       	and	r24, r24
    6e74:	09 f0       	breq	.+2      	; 0x6e78 <MB_SingleRun+0x12c>
		sei();
    6e76:	78 94       	sei
			IntOn();
			ResetTimer16(TD_MB_Idle+MB_N);
    6e78:	80 91 59 03 	lds	r24, 0x0359
    6e7c:	8d 0d       	add	r24, r13
    6e7e:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <ResetTimer16>
			FormSingle(MB_N);
    6e82:	8d 2d       	mov	r24, r13
    6e84:	0e 94 fe 30 	call	0x61fc	; 0x61fc <FormSingle>

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    6e88:	8f b7       	in	r24, 0x3f	; 63
    6e8a:	80 78       	andi	r24, 0x80	; 128
    6e8c:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    6e90:	f8 94       	cli
			IntOff();
			MB_Transm(MB_N);
    6e92:	8d 2d       	mov	r24, r13
    6e94:	0e 94 55 2a 	call	0x54aa	; 0x54aa <MB_Transm>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    6e98:	80 91 fc 01 	lds	r24, 0x01FC
    6e9c:	88 23       	and	r24, r24
    6e9e:	09 f0       	breq	.+2      	; 0x6ea2 <MB_SingleRun+0x156>
		sei();
    6ea0:	78 94       	sei
			IntOn();
		}
	}
}
    6ea2:	df 91       	pop	r29
    6ea4:	cf 91       	pop	r28
    6ea6:	1f 91       	pop	r17
    6ea8:	0f 91       	pop	r16
    6eaa:	ff 90       	pop	r15
    6eac:	ef 90       	pop	r14
    6eae:	df 90       	pop	r13
    6eb0:	08 95       	ret

00006eb2 <MB_Master_MaxCycle_Clear>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_Master_MaxCycle_Clear(uint8_t MB_N)
{
	MB_Master_MaxCycle[MB_N] = 0;
    6eb2:	e8 2f       	mov	r30, r24
    6eb4:	f0 e0       	ldi	r31, 0x00	; 0
    6eb6:	ee 0f       	add	r30, r30
    6eb8:	ff 1f       	adc	r31, r31
    6eba:	e8 54       	subi	r30, 0x48	; 72
    6ebc:	f8 4f       	sbci	r31, 0xF8	; 248
    6ebe:	11 82       	std	Z+1, r1	; 0x01
    6ec0:	10 82       	st	Z, r1
}
    6ec2:	08 95       	ret

00006ec4 <MB_M_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    6ec4:	ff 92       	push	r15
    6ec6:	0f 93       	push	r16
    6ec8:	1f 93       	push	r17
    6eca:	cf 93       	push	r28
    6ecc:	df 93       	push	r29
    6ece:	08 2f       	mov	r16, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    6ed0:	10 91 59 03 	lds	r17, 0x0359
    6ed4:	18 0f       	add	r17, r24
    6ed6:	f1 2e       	mov	r15, r17
    6ed8:	f3 94       	inc	r15
    6eda:	8f 2d       	mov	r24, r15
    6edc:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    6ee0:	88 23       	and	r24, r24
    6ee2:	b9 f0       	breq	.+46     	; 0x6f12 <MB_M_Cycle+0x4e>

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    6ee4:	a0 2f       	mov	r26, r16
    6ee6:	b0 e0       	ldi	r27, 0x00	; 0
    6ee8:	fd 01       	movw	r30, r26
    6eea:	ee 0f       	add	r30, r30
    6eec:	ff 1f       	adc	r31, r31
    6eee:	ee 0f       	add	r30, r30
    6ef0:	ff 1f       	adc	r31, r31
    6ef2:	eb 5a       	subi	r30, 0xAB	; 171
    6ef4:	fc 4f       	sbci	r31, 0xFC	; 252
    6ef6:	10 82       	st	Z, r1
    6ef8:	11 82       	std	Z+1, r1	; 0x01
    6efa:	12 82       	std	Z+2, r1	; 0x02
    6efc:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    6efe:	a3 59       	subi	r26, 0x93	; 147
    6f00:	bc 4f       	sbci	r27, 0xFC	; 252
    6f02:	6c 91       	ld	r22, X
    6f04:	84 e6       	ldi	r24, 0x64	; 100
    6f06:	68 9f       	mul	r22, r24
    6f08:	b0 01       	movw	r22, r0
    6f0a:	11 24       	eor	r1, r1
    6f0c:	8f 2d       	mov	r24, r15
    6f0e:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
void
MB_M_Cycle(uint8_t MB_N)
{
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
		SlavesOn(MB_N);
	if (!Timer16Stopp(TD_MB_Idle+MB_N))
    6f12:	81 2f       	mov	r24, r17
    6f14:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    6f18:	88 23       	and	r24, r24
    6f1a:	09 f4       	brne	.+2      	; 0x6f1e <MB_M_Cycle+0x5a>
    6f1c:	61 c0       	rjmp	.+194    	; 0x6fe0 <MB_M_Cycle+0x11c>
		return;

	switch (MB_State[MB_N]) {
    6f1e:	c0 2f       	mov	r28, r16
    6f20:	d0 e0       	ldi	r29, 0x00	; 0
    6f22:	fe 01       	movw	r30, r28
    6f24:	ec 59       	subi	r30, 0x9C	; 156
    6f26:	fc 4f       	sbci	r31, 0xFC	; 252
    6f28:	e0 81       	ld	r30, Z
    6f2a:	e1 30       	cpi	r30, 0x01	; 1
    6f2c:	21 f0       	breq	.+8      	; 0x6f36 <MB_M_Cycle+0x72>
    6f2e:	e4 30       	cpi	r30, 0x04	; 4
    6f30:	09 f0       	breq	.+2      	; 0x6f34 <MB_M_Cycle+0x70>
    6f32:	56 c0       	rjmp	.+172    	; 0x6fe0 <MB_M_Cycle+0x11c>
    6f34:	25 c0       	rjmp	.+74     	; 0x6f80 <MB_M_Cycle+0xbc>
	case MB_Idle:
		FailSlave(MB_N);
    6f36:	80 2f       	mov	r24, r16
    6f38:	0e 94 00 32 	call	0x6400	; 0x6400 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    6f3c:	fe 01       	movw	r30, r28
    6f3e:	e1 56       	subi	r30, 0x61	; 97
    6f40:	fa 4f       	sbci	r31, 0xFA	; 250
    6f42:	e0 81       	ld	r30, Z
    6f44:	ee 23       	and	r30, r30
    6f46:	19 f0       	breq	.+6      	; 0x6f4e <MB_M_Cycle+0x8a>
    6f48:	e1 30       	cpi	r30, 0x01	; 1
    6f4a:	69 f4       	brne	.+26     	; 0x6f66 <MB_M_Cycle+0xa2>
    6f4c:	04 c0       	rjmp	.+8      	; 0x6f56 <MB_M_Cycle+0x92>
		case MB_SingleIdle:
			FormQuery(MB_N);
    6f4e:	80 2f       	mov	r24, r16
    6f50:	0e 94 ac 30 	call	0x6158	; 0x6158 <FormQuery>
    6f54:	08 c0       	rjmp	.+16     	; 0x6f66 <MB_M_Cycle+0xa2>
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    6f56:	cc 5a       	subi	r28, 0xAC	; 172
    6f58:	dc 4f       	sbci	r29, 0xFC	; 252
    6f5a:	88 81       	ld	r24, Y
    6f5c:	88 23       	and	r24, r24
    6f5e:	19 f4       	brne	.+6      	; 0x6f66 <MB_M_Cycle+0xa2>
				FormSingle(MB_N);
    6f60:	80 2f       	mov	r24, r16
    6f62:	0e 94 fe 30 	call	0x61fc	; 0x61fc <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6f66:	80 91 59 03 	lds	r24, 0x0359
    6f6a:	80 0f       	add	r24, r16
    6f6c:	6f ef       	ldi	r22, 0xFF	; 255
    6f6e:	7f ef       	ldi	r23, 0xFF	; 255
    6f70:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
		cli();
    6f74:	f8 94       	cli
		MB_Transm(MB_N);
    6f76:	80 2f       	mov	r24, r16
    6f78:	0e 94 55 2a 	call	0x54aa	; 0x54aa <MB_Transm>
		sei();
    6f7c:	78 94       	sei
    6f7e:	30 c0       	rjmp	.+96     	; 0x6fe0 <MB_M_Cycle+0x11c>
		break;
	case MB_Proc:
		cli();
    6f80:	f8 94       	cli
    6f82:	84 e1       	ldi	r24, 0x14	; 20
    6f84:	90 e0       	ldi	r25, 0x00	; 0
    6f86:	c8 9f       	mul	r28, r24
    6f88:	90 01       	movw	r18, r0
    6f8a:	c9 9f       	mul	r28, r25
    6f8c:	30 0d       	add	r19, r0
    6f8e:	d8 9f       	mul	r29, r24
    6f90:	30 0d       	add	r19, r0
    6f92:	11 24       	eor	r1, r1
    6f94:	26 52       	subi	r18, 0x26	; 38
    6f96:	36 4b       	sbci	r19, 0xB6	; 182
    6f98:	f9 01       	movw	r30, r18
    6f9a:	85 91       	lpm	r24, Z+
    6f9c:	94 91       	lpm	r25, Z+
		USART_Func(MB_N, LED);
    6f9e:	fc 01       	movw	r30, r24
    6fa0:	09 95       	icall
		sei();
    6fa2:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    6fa4:	c1 56       	subi	r28, 0x61	; 97
    6fa6:	da 4f       	sbci	r29, 0xFA	; 250
    6fa8:	88 81       	ld	r24, Y
    6faa:	88 23       	and	r24, r24
    6fac:	31 f0       	breq	.+12     	; 0x6fba <MB_M_Cycle+0xf6>
    6fae:	81 30       	cpi	r24, 0x01	; 1
    6fb0:	59 f4       	brne	.+22     	; 0x6fc8 <MB_M_Cycle+0x104>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    6fb2:	80 91 53 03 	lds	r24, 0x0353
    6fb6:	88 23       	and	r24, r24
    6fb8:	21 f0       	breq	.+8      	; 0x6fc2 <MB_M_Cycle+0xfe>
				FormQuery(MB_N);
    6fba:	80 2f       	mov	r24, r16
    6fbc:	0e 94 ac 30 	call	0x6158	; 0x6158 <FormQuery>
    6fc0:	03 c0       	rjmp	.+6      	; 0x6fc8 <MB_M_Cycle+0x104>
			else
				FormSingle(MB_N);
    6fc2:	80 2f       	mov	r24, r16
    6fc4:	0e 94 fe 30 	call	0x61fc	; 0x61fc <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    6fc8:	80 91 59 03 	lds	r24, 0x0359
    6fcc:	80 0f       	add	r24, r16
    6fce:	6f ef       	ldi	r22, 0xFF	; 255
    6fd0:	7f ef       	ldi	r23, 0xFF	; 255
    6fd2:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
		cli();
    6fd6:	f8 94       	cli
		MB_Transm(MB_N);
    6fd8:	80 2f       	mov	r24, r16
    6fda:	0e 94 55 2a 	call	0x54aa	; 0x54aa <MB_Transm>
		sei();
    6fde:	78 94       	sei
		break;
	}
}
    6fe0:	df 91       	pop	r29
    6fe2:	cf 91       	pop	r28
    6fe4:	1f 91       	pop	r17
    6fe6:	0f 91       	pop	r16
    6fe8:	ff 90       	pop	r15
    6fea:	08 95       	ret

00006fec <MB_Cycle>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6fec:	e0 ee       	ldi	r30, 0xE0	; 224
    6fee:	f9 e4       	ldi	r31, 0x49	; 73
    6ff0:	e4 91       	lpm	r30, Z+
MB_Cycle(void)
{
	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    6ff2:	e1 30       	cpi	r30, 0x01	; 1
    6ff4:	19 f4       	brne	.+6      	; 0x6ffc <MB_Cycle+0x10>
			MB_M_Cycle(MB_N);
    6ff6:	80 e0       	ldi	r24, 0x00	; 0
    6ff8:	0e 94 62 37 	call	0x6ec4	; 0x6ec4 <MB_M_Cycle>
    6ffc:	08 95       	ret

00006ffe <SetIP>:
	uint8_t IP3;
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    6ffe:	0f 93       	push	r16
    7000:	fc 01       	movw	r30, r24
	IP->IP1 = IP1;
    7002:	60 83       	st	Z, r22
	IP->IP2 = IP2;
    7004:	41 83       	std	Z+1, r20	; 0x01
	IP->IP3 = IP3;
    7006:	22 83       	std	Z+2, r18	; 0x02
	IP->IP4 = IP4;
    7008:	03 83       	std	Z+3, r16	; 0x03
}
    700a:	0f 91       	pop	r16
    700c:	08 95       	ret

0000700e <IP_compare_Const>:
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    700e:	0f 93       	push	r16
    7010:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7012:	80 81       	ld	r24, Z
    7014:	86 17       	cp	r24, r22
    7016:	69 f4       	brne	.+26     	; 0x7032 <IP_compare_Const+0x24>
    7018:	81 81       	ldd	r24, Z+1	; 0x01
    701a:	84 17       	cp	r24, r20
    701c:	51 f4       	brne	.+20     	; 0x7032 <IP_compare_Const+0x24>
    701e:	82 81       	ldd	r24, Z+2	; 0x02
    7020:	82 17       	cp	r24, r18
    7022:	39 f4       	brne	.+14     	; 0x7032 <IP_compare_Const+0x24>
    7024:	20 e0       	ldi	r18, 0x00	; 0
    7026:	83 81       	ldd	r24, Z+3	; 0x03
    7028:	80 13       	cpse	r24, r16
    702a:	21 e0       	ldi	r18, 0x01	; 1
    702c:	81 e0       	ldi	r24, 0x01	; 1
    702e:	28 27       	eor	r18, r24
    7030:	01 c0       	rjmp	.+2      	; 0x7034 <IP_compare_Const+0x26>
    7032:	20 e0       	ldi	r18, 0x00	; 0
	else return 0;
}
    7034:	82 2f       	mov	r24, r18
    7036:	0f 91       	pop	r16
    7038:	08 95       	ret

0000703a <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    703a:	8f ef       	ldi	r24, 0xFF	; 255
    703c:	80 93 44 08 	sts	0x0844, r24
	GSM_RX_FIFO_End = 255;
    7040:	80 93 83 05 	sts	0x0583, r24
	GSM_RxCharN = 0;
    7044:	10 92 ac 0c 	sts	0x0CAC, r1
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
    7048:	08 95       	ret

0000704a <GetByteFromFIFO>:
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    704a:	0f 93       	push	r16
    704c:	1f 93       	push	r17
    704e:	cf 93       	push	r28
    7050:	df 93       	push	r29
    7052:	8c 01       	movw	r16, r24
    7054:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7056:	88 81       	ld	r24, Y
    7058:	84 17       	cp	r24, r20
    705a:	08 f0       	brcs	.+2      	; 0x705e <GetByteFromFIFO+0x14>
		*Index = 0;
    705c:	18 82       	st	Y, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    705e:	80 91 44 08 	lds	r24, 0x0844
    7062:	e0 91 83 05 	lds	r30, 0x0583
    7066:	e8 17       	cp	r30, r24
    7068:	08 f5       	brcc	.+66     	; 0x70ac <GetByteFromFIFO+0x62>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    706a:	ef 3f       	cpi	r30, 0xFF	; 255
    706c:	81 f0       	breq	.+32     	; 0x708e <GetByteFromFIFO+0x44>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    706e:	20 91 77 0a 	lds	r18, 0x0A77
    7072:	80 91 44 08 	lds	r24, 0x0844
    7076:	30 e0       	ldi	r19, 0x00	; 0
    7078:	90 e0       	ldi	r25, 0x00	; 0
    707a:	8e 1b       	sub	r24, r30
    707c:	91 09       	sbc	r25, r1
    707e:	28 17       	cp	r18, r24
    7080:	39 07       	cpc	r19, r25
    7082:	2c f4       	brge	.+10     	; 0x708e <GetByteFromFIFO+0x44>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    7084:	80 91 44 08 	lds	r24, 0x0844
    7088:	8e 1b       	sub	r24, r30
    708a:	80 93 77 0a 	sts	0x0A77, r24
		GSM_RX_FIFO_End++;
    708e:	ef 5f       	subi	r30, 0xFF	; 255
    7090:	e0 93 83 05 	sts	0x0583, r30
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7094:	88 81       	ld	r24, Y
    7096:	d8 01       	movw	r26, r16
    7098:	a8 0f       	add	r26, r24
    709a:	b1 1d       	adc	r27, r1
    709c:	f0 e0       	ldi	r31, 0x00	; 0
    709e:	ea 58       	subi	r30, 0x8A	; 138
    70a0:	fb 4f       	sbci	r31, 0xFB	; 251
    70a2:	80 81       	ld	r24, Z
    70a4:	8c 93       	st	X, r24
		*Index=*Index+1;
    70a6:	88 81       	ld	r24, Y
    70a8:	8f 5f       	subi	r24, 0xFF	; 255
    70aa:	88 83       	st	Y, r24
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    70ac:	40 91 83 05 	lds	r20, 0x0583
    70b0:	80 91 44 08 	lds	r24, 0x0844
    70b4:	84 17       	cp	r24, r20
    70b6:	58 f5       	brcc	.+86     	; 0x710e <GetByteFromFIFO+0xc4>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    70b8:	4f 3f       	cpi	r20, 0xFF	; 255
    70ba:	99 f0       	breq	.+38     	; 0x70e2 <GetByteFromFIFO+0x98>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    70bc:	20 91 77 0a 	lds	r18, 0x0A77
    70c0:	80 91 44 08 	lds	r24, 0x0844
    70c4:	30 e0       	ldi	r19, 0x00	; 0
    70c6:	90 e0       	ldi	r25, 0x00	; 0
    70c8:	86 50       	subi	r24, 0x06	; 6
    70ca:	9f 4f       	sbci	r25, 0xFF	; 255
    70cc:	84 1b       	sub	r24, r20
    70ce:	91 09       	sbc	r25, r1
    70d0:	28 17       	cp	r18, r24
    70d2:	39 07       	cpc	r19, r25
    70d4:	34 f4       	brge	.+12     	; 0x70e2 <GetByteFromFIFO+0x98>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    70d6:	80 91 44 08 	lds	r24, 0x0844
    70da:	86 50       	subi	r24, 0x06	; 6
    70dc:	84 1b       	sub	r24, r20
    70de:	80 93 77 0a 	sts	0x0A77, r24
		GSM_RX_FIFO_End++;
    70e2:	84 2f       	mov	r24, r20
    70e4:	8f 5f       	subi	r24, 0xFF	; 255
    70e6:	80 93 83 05 	sts	0x0583, r24
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    70ea:	8a 3f       	cpi	r24, 0xFA	; 250
    70ec:	10 f0       	brcs	.+4      	; 0x70f2 <GetByteFromFIFO+0xa8>
    70ee:	10 92 83 05 	sts	0x0583, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    70f2:	88 81       	ld	r24, Y
    70f4:	08 0f       	add	r16, r24
    70f6:	11 1d       	adc	r17, r1
    70f8:	e0 91 83 05 	lds	r30, 0x0583
    70fc:	f0 e0       	ldi	r31, 0x00	; 0
    70fe:	ea 58       	subi	r30, 0x8A	; 138
    7100:	fb 4f       	sbci	r31, 0xFB	; 251
    7102:	80 81       	ld	r24, Z
    7104:	f8 01       	movw	r30, r16
    7106:	80 83       	st	Z, r24
		*Index=*Index+1;
    7108:	88 81       	ld	r24, Y
    710a:	8f 5f       	subi	r24, 0xFF	; 255
    710c:	88 83       	st	Y, r24
	}
}
    710e:	df 91       	pop	r29
    7110:	cf 91       	pop	r28
    7112:	1f 91       	pop	r17
    7114:	0f 91       	pop	r16
    7116:	08 95       	ret

00007118 <GetStringFromFIFO>:
	}
}

// ~~~~~~~~~~~
//        
uint8_t GetStringFromFIFO(void){
    7118:	27 c0       	rjmp	.+78     	; 0x7168 <GetStringFromFIFO+0x50>

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    711a:	84 ef       	ldi	r24, 0xF4	; 244
    711c:	98 e0       	ldi	r25, 0x08	; 8
    711e:	6c ea       	ldi	r22, 0xAC	; 172
    7120:	7c e0       	ldi	r23, 0x0C	; 12
    7122:	44 e6       	ldi	r20, 0x64	; 100
    7124:	0e 94 25 38 	call	0x704a	; 0x704a <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    7128:	80 91 ac 0c 	lds	r24, 0x0CAC
    712c:	82 30       	cpi	r24, 0x02	; 2
    712e:	e0 f0       	brcs	.+56     	; 0x7168 <GetStringFromFIFO+0x50>
    7130:	e0 91 ac 0c 	lds	r30, 0x0CAC
    7134:	f0 e0       	ldi	r31, 0x00	; 0
    7136:	ee 50       	subi	r30, 0x0E	; 14
    7138:	f7 4f       	sbci	r31, 0xF7	; 247
    713a:	80 81       	ld	r24, Z
    713c:	8d 30       	cpi	r24, 0x0D	; 13
    713e:	a1 f4       	brne	.+40     	; 0x7168 <GetStringFromFIFO+0x50>
    7140:	e0 91 ac 0c 	lds	r30, 0x0CAC
    7144:	f0 e0       	ldi	r31, 0x00	; 0
    7146:	ed 50       	subi	r30, 0x0D	; 13
    7148:	f7 4f       	sbci	r31, 0xF7	; 247
    714a:	80 81       	ld	r24, Z
    714c:	8a 30       	cpi	r24, 0x0A	; 10
    714e:	61 f4       	brne	.+24     	; 0x7168 <GetStringFromFIFO+0x50>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7150:	e0 91 ac 0c 	lds	r30, 0x0CAC
    7154:	f0 e0       	ldi	r31, 0x00	; 0
    7156:	ee 50       	subi	r30, 0x0E	; 14
    7158:	f7 4f       	sbci	r31, 0xF7	; 247
    715a:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    715c:	80 91 ac 0c 	lds	r24, 0x0CAC
    7160:	81 50       	subi	r24, 0x01	; 1
			GSM_RxCharN = 0;
    7162:	10 92 ac 0c 	sts	0x0CAC, r1
    7166:	08 95       	ret
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7168:	90 91 44 08 	lds	r25, 0x0844
    716c:	80 91 83 05 	lds	r24, 0x0583
    7170:	98 17       	cp	r25, r24
    7172:	99 f6       	brne	.-90     	; 0x711a <GetStringFromFIFO+0x2>
    7174:	80 e0       	ldi	r24, 0x00	; 0
		}

	}//while

	return StrLength;
}
    7176:	08 95       	ret

00007178 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    7178:	80 91 ac 0c 	lds	r24, 0x0CAC
    717c:	84 36       	cpi	r24, 0x64	; 100
    717e:	18 f0       	brcs	.+6      	; 0x7186 <ForceEndStringFromFIFO+0xe>
    7180:	83 e6       	ldi	r24, 0x63	; 99
    7182:	80 93 ac 0c 	sts	0x0CAC, r24
	StrLength = GSM_RxCharN;
    7186:	80 91 ac 0c 	lds	r24, 0x0CAC
	GSM_RxStr[GSM_RxCharN]='\0';
    718a:	e0 91 ac 0c 	lds	r30, 0x0CAC
    718e:	f0 e0       	ldi	r31, 0x00	; 0
    7190:	ec 50       	subi	r30, 0x0C	; 12
    7192:	f7 4f       	sbci	r31, 0xF7	; 247
    7194:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    7196:	10 92 ac 0c 	sts	0x0CAC, r1
	return StrLength;
}
    719a:	08 95       	ret

0000719c <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    719c:	1f 93       	push	r17
    719e:	18 2f       	mov	r17, r24
    71a0:	0e c0       	rjmp	.+28     	; 0x71be <GetDataFromFIFO+0x22>

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    71a2:	84 ef       	ldi	r24, 0xF4	; 244
    71a4:	98 e0       	ldi	r25, 0x08	; 8
    71a6:	6c ea       	ldi	r22, 0xAC	; 172
    71a8:	7c e0       	ldi	r23, 0x0C	; 12
    71aa:	44 e6       	ldi	r20, 0x64	; 100
    71ac:	0e 94 25 38 	call	0x704a	; 0x704a <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    71b0:	80 91 ac 0c 	lds	r24, 0x0CAC
    71b4:	81 17       	cp	r24, r17
    71b6:	18 f0       	brcs	.+6      	; 0x71be <GetDataFromFIFO+0x22>
			GSM_RxCharN = 0;
    71b8:	10 92 ac 0c 	sts	0x0CAC, r1
    71bc:	08 c0       	rjmp	.+16     	; 0x71ce <GetDataFromFIFO+0x32>
}

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    71be:	90 91 44 08 	lds	r25, 0x0844
    71c2:	80 91 83 05 	lds	r24, 0x0583
    71c6:	98 17       	cp	r25, r24
    71c8:	61 f7       	brne	.-40     	; 0x71a2 <GetDataFromFIFO+0x6>
		if(GSM_RxCharN >= Amount){
			GSM_RxCharN = 0;
			return Amount;
		}
	}//while
	return GSM_RxCharN;
    71ca:	10 91 ac 0c 	lds	r17, 0x0CAC
}
    71ce:	81 2f       	mov	r24, r17
    71d0:	1f 91       	pop	r17
    71d2:	08 95       	ret

000071d4 <GSM_Init>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    71d4:	8f ef       	ldi	r24, 0xFF	; 255
    71d6:	80 93 44 08 	sts	0x0844, r24
	GSM_RX_FIFO_End = 255;
    71da:	80 93 83 05 	sts	0x0583, r24
	GSM_RxCharN = 0;
    71de:	10 92 ac 0c 	sts	0x0CAC, r1
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    71e2:	8c ef       	ldi	r24, 0xFC	; 252
    71e4:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    71e6:	88 e9       	ldi	r24, 0x98	; 152
    71e8:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    71ea:	86 e8       	ldi	r24, 0x86	; 134
    71ec:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    71f0:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    71f4:	87 e6       	ldi	r24, 0x67	; 103
    71f6:	89 b9       	out	0x09, r24	; 9
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    71f8:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    71fa:	17 9a       	sbi	0x02, 7	; 2
	sei();
    71fc:	78 94       	sei
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
	sei();
}
void GSM_PWRCNTRL_ON(void){
	cli();
    71fe:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    7200:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    7202:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7204:	80 91 cf 01 	lds	r24, 0x01CF
	VacantTimer16Sys += n;
    7208:	98 2f       	mov	r25, r24
    720a:	9f 5f       	subi	r25, 0xFF	; 255
	GSM_PWRCNTRL_ON();
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    720c:	80 93 5a 03 	sts	0x035A, r24
    7210:	8e 5f       	subi	r24, 0xFE	; 254
	TD_TCP_Connect = Timer16SysAlloc(1);
    7212:	90 93 5b 03 	sts	0x035B, r25
    7216:	8f 5f       	subi	r24, 0xFF	; 255
    7218:	80 93 cf 01 	sts	0x01CF, r24
    721c:	81 50       	subi	r24, 0x01	; 1
	TD_RSSI = Timer16SysAlloc(1);
    721e:	80 93 5c 03 	sts	0x035C, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    7222:	80 91 d0 01 	lds	r24, 0x01D0
	VacantTimer32Sys += n;
    7226:	8f 5f       	subi	r24, 0xFF	; 255
    7228:	80 93 d0 01 	sts	0x01D0, r24
    722c:	81 50       	subi	r24, 0x01	; 1
	TD_GSM_Reset = Timer32SysAlloc(1);
    722e:	80 93 5d 03 	sts	0x035D, r24

/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    7232:	10 92 e8 08 	sts	0x08E8, r1
	GSM_State = GSM_PowerOn;
    7236:	10 92 a4 05 	sts	0x05A4, r1



}
    723a:	08 95       	ret

0000723c <GSM_Wait_Char>:
		else return 1;
	}
	else return 0;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    723c:	0f 93       	push	r16
    723e:	1f 93       	push	r17
    7240:	08 2f       	mov	r16, r24
    7242:	16 2f       	mov	r17, r22
	if(Timer16Stopp(TD_GSM)){
    7244:	80 91 5a 03 	lds	r24, 0x035A
    7248:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    724c:	88 23       	and	r24, r24
    724e:	19 f0       	breq	.+6      	; 0x7256 <GSM_Wait_Char+0x1a>
		GSM_State = RestoreCMD;
    7250:	10 93 a4 05 	sts	0x05A4, r17
    7254:	05 c0       	rjmp	.+10     	; 0x7260 <GSM_Wait_Char+0x24>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7256:	81 e0       	ldi	r24, 0x01	; 1
    7258:	0e 94 ce 38 	call	0x719c	; 0x719c <GetDataFromFIFO>
    725c:	88 23       	and	r24, r24
    725e:	11 f4       	brne	.+4      	; 0x7264 <GSM_Wait_Char+0x28>
    7260:	90 e0       	ldi	r25, 0x00	; 0
    7262:	06 c0       	rjmp	.+12     	; 0x7270 <GSM_Wait_Char+0x34>
    7264:	90 e0       	ldi	r25, 0x00	; 0
    7266:	80 91 f4 08 	lds	r24, 0x08F4
    726a:	80 17       	cp	r24, r16
    726c:	09 f4       	brne	.+2      	; 0x7270 <GSM_Wait_Char+0x34>
    726e:	91 e0       	ldi	r25, 0x01	; 1
		if(GSM_RxStr[0] == Char)	return 1;
		else return 0;
	}
	else return 0;
}
    7270:	89 2f       	mov	r24, r25
    7272:	1f 91       	pop	r17
    7274:	0f 91       	pop	r16
    7276:	08 95       	ret

00007278 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    7278:	80 91 e0 09 	lds	r24, 0x09E0
    727c:	88 23       	and	r24, r24
    727e:	29 f4       	brne	.+10     	; 0x728a <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    7280:	80 91 d1 01 	lds	r24, 0x01D1
    7284:	81 60       	ori	r24, 0x01	; 1
    7286:	80 93 d1 01 	sts	0x01D1, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    728a:	88 e9       	ldi	r24, 0x98	; 152
    728c:	8a b9       	out	0x0a, r24	; 10
    728e:	08 95       	ret

00007290 <GSM_Reset>:
GSM_Reset(void)
{
/*	IntOff();
	GSM_State = GSM_Restart;
	IntOn();*/
}
    7290:	08 95       	ret

00007292 <GPRS_ServerAddr_Save>:
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GPRS_ServerAddr_Save(void)
{

}
    7292:	08 95       	ret

00007294 <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    7294:	1f 92       	push	r1
    7296:	0f 92       	push	r0
    7298:	0f b6       	in	r0, 0x3f	; 63
    729a:	0f 92       	push	r0
    729c:	0b b6       	in	r0, 0x3b	; 59
    729e:	0f 92       	push	r0
    72a0:	11 24       	eor	r1, r1
    72a2:	2f 93       	push	r18
    72a4:	3f 93       	push	r19
    72a6:	4f 93       	push	r20
    72a8:	5f 93       	push	r21
    72aa:	6f 93       	push	r22
    72ac:	7f 93       	push	r23
    72ae:	8f 93       	push	r24
    72b0:	9f 93       	push	r25
    72b2:	af 93       	push	r26
    72b4:	bf 93       	push	r27
    72b6:	ef 93       	push	r30
    72b8:	ff 93       	push	r31
	GSM_TX();
    72ba:	0e 94 3c 39 	call	0x7278	; 0x7278 <GSM_TX>
	GSM_LED = 1;
    72be:	81 e0       	ldi	r24, 0x01	; 1
    72c0:	80 93 88 05 	sts	0x0588, r24
}
    72c4:	ff 91       	pop	r31
    72c6:	ef 91       	pop	r30
    72c8:	bf 91       	pop	r27
    72ca:	af 91       	pop	r26
    72cc:	9f 91       	pop	r25
    72ce:	8f 91       	pop	r24
    72d0:	7f 91       	pop	r23
    72d2:	6f 91       	pop	r22
    72d4:	5f 91       	pop	r21
    72d6:	4f 91       	pop	r20
    72d8:	3f 91       	pop	r19
    72da:	2f 91       	pop	r18
    72dc:	0f 90       	pop	r0
    72de:	0b be       	out	0x3b, r0	; 59
    72e0:	0f 90       	pop	r0
    72e2:	0f be       	out	0x3f, r0	; 63
    72e4:	0f 90       	pop	r0
    72e6:	1f 90       	pop	r1
    72e8:	18 95       	reti

000072ea <DI_State>:
} DigInput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
    72ea:	28 2f       	mov	r18, r24
    72ec:	86 95       	lsr	r24
    72ee:	86 95       	lsr	r24
    72f0:	86 95       	lsr	r24
    72f2:	e7 e4       	ldi	r30, 0x47	; 71
    72f4:	f8 e0       	ldi	r31, 0x08	; 8
    72f6:	e8 0f       	add	r30, r24
    72f8:	f1 1d       	adc	r31, r1
    72fa:	80 81       	ld	r24, Z
    72fc:	90 e0       	ldi	r25, 0x00	; 0
    72fe:	27 70       	andi	r18, 0x07	; 7
    7300:	02 c0       	rjmp	.+4      	; 0x7306 <DI_State+0x1c>
    7302:	95 95       	asr	r25
    7304:	87 95       	ror	r24
    7306:	2a 95       	dec	r18
    7308:	e2 f7       	brpl	.-8      	; 0x7302 <DI_State+0x18>
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
}
    730a:	81 70       	andi	r24, 0x01	; 1
    730c:	08 95       	ret

0000730e <DI_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_Front(uint8_t D_N)
{
    730e:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7310:	28 2f       	mov	r18, r24
    7312:	27 70       	andi	r18, 0x07	; 7
    7314:	81 e0       	ldi	r24, 0x01	; 1
    7316:	90 e0       	ldi	r25, 0x00	; 0
    7318:	01 c0       	rjmp	.+2      	; 0x731c <DI_Front+0xe>
    731a:	88 0f       	add	r24, r24
    731c:	2a 95       	dec	r18
    731e:	ea f7       	brpl	.-6      	; 0x731a <DI_Front+0xc>
	uint8_t State = DigInput.State[Byte] &Bit;
    7320:	e6 95       	lsr	r30
    7322:	e6 95       	lsr	r30
    7324:	e6 95       	lsr	r30
    7326:	f0 e0       	ldi	r31, 0x00	; 0
    7328:	e9 5b       	subi	r30, 0xB9	; 185
    732a:	f7 4f       	sbci	r31, 0xF7	; 247
    732c:	90 81       	ld	r25, Z
    732e:	98 23       	and	r25, r24
	return DigInput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    7330:	21 81       	ldd	r18, Z+1	; 0x01
    7332:	82 23       	and	r24, r18
    7334:	31 f0       	breq	.+12     	; 0x7342 <DI_Front+0x34>
    7336:	99 23       	and	r25, r25
    7338:	11 f4       	brne	.+4      	; 0x733e <DI_Front+0x30>
    733a:	82 e0       	ldi	r24, 0x02	; 2
    733c:	08 95       	ret
    733e:	80 e0       	ldi	r24, 0x00	; 0
    7340:	08 95       	ret
    7342:	89 2f       	mov	r24, r25
    7344:	91 11       	cpse	r25, r1
    7346:	81 e0       	ldi	r24, 0x01	; 1
}
    7348:	08 95       	ret

0000734a <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
    734a:	28 2f       	mov	r18, r24
    734c:	86 95       	lsr	r24
    734e:	86 95       	lsr	r24
    7350:	86 95       	lsr	r24
    7352:	e7 e4       	ldi	r30, 0x47	; 71
    7354:	f8 e0       	ldi	r31, 0x08	; 8
    7356:	e8 0f       	add	r30, r24
    7358:	f1 1d       	adc	r31, r1
    735a:	82 81       	ldd	r24, Z+2	; 0x02
    735c:	90 e0       	ldi	r25, 0x00	; 0
    735e:	27 70       	andi	r18, 0x07	; 7
    7360:	02 c0       	rjmp	.+4      	; 0x7366 <DI_Status+0x1c>
    7362:	95 95       	asr	r25
    7364:	87 95       	ror	r24
    7366:	2a 95       	dec	r18
    7368:	e2 f7       	brpl	.-8      	; 0x7362 <DI_Status+0x18>
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
}
    736a:	81 70       	andi	r24, 0x01	; 1
    736c:	08 95       	ret

0000736e <DI_Init>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~
void
DI_Init(void)
{
    736e:	20 e0       	ldi	r18, 0x00	; 0
    7370:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    7372:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7374:	a9 01       	movw	r20, r18
    7376:	63 e0       	ldi	r22, 0x03	; 3
    7378:	44 0f       	add	r20, r20
    737a:	55 1f       	adc	r21, r21
    737c:	6a 95       	dec	r22
    737e:	e1 f7       	brne	.-8      	; 0x7378 <DI_Init+0xa>
    7380:	ca 01       	movw	r24, r20
    7382:	88 5c       	subi	r24, 0xC8	; 200
    7384:	96 4b       	sbci	r25, 0xB6	; 182
    7386:	fc 01       	movw	r30, r24
    7388:	a5 91       	lpm	r26, Z+
    738a:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    738c:	42 5c       	subi	r20, 0xC2	; 194
    738e:	56 4b       	sbci	r21, 0xB6	; 182
    7390:	fa 01       	movw	r30, r20
    7392:	44 91       	lpm	r20, Z+
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    7394:	94 2f       	mov	r25, r20
    7396:	90 95       	com	r25
    7398:	8c 91       	ld	r24, X
    739a:	89 23       	and	r24, r25
    739c:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    739e:	c9 01       	movw	r24, r18
    73a0:	53 e0       	ldi	r21, 0x03	; 3
    73a2:	88 0f       	add	r24, r24
    73a4:	99 1f       	adc	r25, r25
    73a6:	5a 95       	dec	r21
    73a8:	e1 f7       	brne	.-8      	; 0x73a2 <DI_Init+0x34>
    73aa:	86 5c       	subi	r24, 0xC6	; 198
    73ac:	96 4b       	sbci	r25, 0xB6	; 182
    73ae:	fc 01       	movw	r30, r24
    73b0:	a5 91       	lpm	r26, Z+
    73b2:	b4 91       	lpm	r27, Z+
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    73b4:	8c 91       	ld	r24, X
    73b6:	84 2b       	or	r24, r20
    73b8:	8c 93       	st	X, r24
		sei();
    73ba:	78 94       	sei
    73bc:	2f 5f       	subi	r18, 0xFF	; 255
    73be:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    73c0:	24 30       	cpi	r18, 0x04	; 4
    73c2:	31 05       	cpc	r19, r1
    73c4:	b1 f6       	brne	.-84     	; 0x7372 <DI_Init+0x4>
{
	DI_Init_Hard();
	#ifdef HSC_Reg
		HSC_Init();
	#endif
}
    73c6:	08 95       	ret

000073c8 <DO_State>:
} DigOutput;

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_State(uint8_t D_N)
{
    73c8:	90 e0       	ldi	r25, 0x00	; 0
    73ca:	e8 2f       	mov	r30, r24
    73cc:	e6 95       	lsr	r30
    73ce:	e6 95       	lsr	r30
    73d0:	e6 95       	lsr	r30
    73d2:	f0 e0       	ldi	r31, 0x00	; 0
    73d4:	e2 51       	subi	r30, 0x12	; 18
    73d6:	f7 4f       	sbci	r31, 0xF7	; 247
    73d8:	40 81       	ld	r20, Z
    73da:	50 e0       	ldi	r21, 0x00	; 0
    73dc:	87 70       	andi	r24, 0x07	; 7
    73de:	21 e0       	ldi	r18, 0x01	; 1
    73e0:	30 e0       	ldi	r19, 0x00	; 0
    73e2:	02 c0       	rjmp	.+4      	; 0x73e8 <DO_State+0x20>
    73e4:	22 0f       	add	r18, r18
    73e6:	33 1f       	adc	r19, r19
    73e8:	8a 95       	dec	r24
    73ea:	e2 f7       	brpl	.-8      	; 0x73e4 <DO_State+0x1c>
    73ec:	42 23       	and	r20, r18
    73ee:	53 23       	and	r21, r19
    73f0:	14 16       	cp	r1, r20
    73f2:	15 06       	cpc	r1, r21
    73f4:	0c f4       	brge	.+2      	; 0x73f8 <DO_State+0x30>
    73f6:	91 e0       	ldi	r25, 0x01	; 1
	return (DigOutput.State[D_N/8] &(1<<D_N%8)) > 0;
}
    73f8:	89 2f       	mov	r24, r25
    73fa:	08 95       	ret

000073fc <DO_Front>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DO_Front(uint8_t D_N)
{
    73fc:	e8 2f       	mov	r30, r24
	uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    73fe:	28 2f       	mov	r18, r24
    7400:	27 70       	andi	r18, 0x07	; 7
    7402:	81 e0       	ldi	r24, 0x01	; 1
    7404:	90 e0       	ldi	r25, 0x00	; 0
    7406:	01 c0       	rjmp	.+2      	; 0x740a <DO_Front+0xe>
    7408:	88 0f       	add	r24, r24
    740a:	2a 95       	dec	r18
    740c:	ea f7       	brpl	.-6      	; 0x7408 <DO_Front+0xc>
	uint8_t State = DigOutput.State[Byte] &Bit;
    740e:	e6 95       	lsr	r30
    7410:	e6 95       	lsr	r30
    7412:	e6 95       	lsr	r30
    7414:	f0 e0       	ldi	r31, 0x00	; 0
    7416:	e2 51       	subi	r30, 0x12	; 18
    7418:	f7 4f       	sbci	r31, 0xF7	; 247
    741a:	90 81       	ld	r25, Z
    741c:	98 23       	and	r25, r24
	return DigOutput.StateOld[Byte] &Bit ? State?NoFront:FallFront : State?RiseFront:NoFront;
    741e:	21 81       	ldd	r18, Z+1	; 0x01
    7420:	82 23       	and	r24, r18
    7422:	31 f0       	breq	.+12     	; 0x7430 <DO_Front+0x34>
    7424:	99 23       	and	r25, r25
    7426:	11 f4       	brne	.+4      	; 0x742c <DO_Front+0x30>
    7428:	82 e0       	ldi	r24, 0x02	; 2
    742a:	08 95       	ret
    742c:	80 e0       	ldi	r24, 0x00	; 0
    742e:	08 95       	ret
    7430:	89 2f       	mov	r24, r25
    7432:	91 11       	cpse	r25, r1
    7434:	81 e0       	ldi	r24, 0x01	; 1
}
    7436:	08 95       	ret

00007438 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7438:	98 2f       	mov	r25, r24
    743a:	96 95       	lsr	r25
    743c:	96 95       	lsr	r25
    743e:	96 95       	lsr	r25
    7440:	ee ee       	ldi	r30, 0xEE	; 238
    7442:	f8 e0       	ldi	r31, 0x08	; 8
    7444:	e9 0f       	add	r30, r25
    7446:	f1 1d       	adc	r31, r1
    7448:	87 70       	andi	r24, 0x07	; 7
    744a:	21 e0       	ldi	r18, 0x01	; 1
    744c:	30 e0       	ldi	r19, 0x00	; 0
    744e:	02 c0       	rjmp	.+4      	; 0x7454 <SetDigOut+0x1c>
    7450:	22 0f       	add	r18, r18
    7452:	33 1f       	adc	r19, r19
    7454:	8a 95       	dec	r24
    7456:	e2 f7       	brpl	.-8      	; 0x7450 <SetDigOut+0x18>
    7458:	82 81       	ldd	r24, Z+2	; 0x02
    745a:	82 2b       	or	r24, r18
    745c:	82 83       	std	Z+2, r24	; 0x02
}
    745e:	08 95       	ret

00007460 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7460:	98 2f       	mov	r25, r24
    7462:	96 95       	lsr	r25
    7464:	96 95       	lsr	r25
    7466:	96 95       	lsr	r25
    7468:	ee ee       	ldi	r30, 0xEE	; 238
    746a:	f8 e0       	ldi	r31, 0x08	; 8
    746c:	e9 0f       	add	r30, r25
    746e:	f1 1d       	adc	r31, r1
    7470:	87 70       	andi	r24, 0x07	; 7
    7472:	21 e0       	ldi	r18, 0x01	; 1
    7474:	30 e0       	ldi	r19, 0x00	; 0
    7476:	02 c0       	rjmp	.+4      	; 0x747c <ResDigOut+0x1c>
    7478:	22 0f       	add	r18, r18
    747a:	33 1f       	adc	r19, r19
    747c:	8a 95       	dec	r24
    747e:	e2 f7       	brpl	.-8      	; 0x7478 <ResDigOut+0x18>
    7480:	20 95       	com	r18
    7482:	82 81       	ldd	r24, Z+2	; 0x02
    7484:	28 23       	and	r18, r24
    7486:	22 83       	std	Z+2, r18	; 0x02
}
    7488:	08 95       	ret

0000748a <TogDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
TogDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] ^=(1<<D_N%8);
    748a:	98 2f       	mov	r25, r24
    748c:	96 95       	lsr	r25
    748e:	96 95       	lsr	r25
    7490:	96 95       	lsr	r25
    7492:	ee ee       	ldi	r30, 0xEE	; 238
    7494:	f8 e0       	ldi	r31, 0x08	; 8
    7496:	e9 0f       	add	r30, r25
    7498:	f1 1d       	adc	r31, r1
    749a:	87 70       	andi	r24, 0x07	; 7
    749c:	21 e0       	ldi	r18, 0x01	; 1
    749e:	30 e0       	ldi	r19, 0x00	; 0
    74a0:	02 c0       	rjmp	.+4      	; 0x74a6 <TogDigOut+0x1c>
    74a2:	22 0f       	add	r18, r18
    74a4:	33 1f       	adc	r19, r19
    74a6:	8a 95       	dec	r24
    74a8:	e2 f7       	brpl	.-8      	; 0x74a2 <TogDigOut+0x18>
    74aa:	82 81       	ldd	r24, Z+2	; 0x02
    74ac:	82 27       	eor	r24, r18
    74ae:	82 83       	std	Z+2, r24	; 0x02
}
    74b0:	08 95       	ret

000074b2 <SetAllDigOut>:

// ~~~~~~~~~~~~~~~
void
SetAllDigOut(void)
{
	for (uint8_t i=0; i<DO_Reg; DigOutput.Buf[i++]=0xFF);
    74b2:	8f ef       	ldi	r24, 0xFF	; 255
    74b4:	80 93 f0 08 	sts	0x08F0, r24
}
    74b8:	08 95       	ret

000074ba <DO_Enable>:
	#ifdef Enable
		IntOff();
		PortEnable |=Enable;
		IntOn();
	#endif
}
    74ba:	08 95       	ret

000074bc <DO_Disable>:
	#ifdef Enable
		IntOff();
		PortEnable &=~Enable;
		IntOn();
	#endif
}
    74bc:	08 95       	ret

000074be <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    74be:	80 91 ee 08 	lds	r24, 0x08EE
    74c2:	80 93 ef 08 	sts	0x08EF, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    74c6:	80 91 f0 08 	lds	r24, 0x08F0
    74ca:	80 93 ee 08 	sts	0x08EE, r24
    74ce:	40 e0       	ldi	r20, 0x00	; 0
    74d0:	50 e0       	ldi	r21, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    74d2:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    74d4:	80 91 ee 08 	lds	r24, 0x08EE
    74d8:	90 e0       	ldi	r25, 0x00	; 0
    74da:	9a 01       	movw	r18, r20
    74dc:	27 70       	andi	r18, 0x07	; 7
    74de:	30 70       	andi	r19, 0x00	; 0
    74e0:	02 c0       	rjmp	.+4      	; 0x74e6 <DigitOut+0x28>
    74e2:	95 95       	asr	r25
    74e4:	87 95       	ror	r24
    74e6:	2a 95       	dec	r18
    74e8:	e2 f7       	brpl	.-8      	; 0x74e2 <DigitOut+0x24>
    74ea:	fa 01       	movw	r30, r20
    74ec:	ee 0f       	add	r30, r30
    74ee:	ff 1f       	adc	r31, r31
    74f0:	ee 0f       	add	r30, r30
    74f2:	ff 1f       	adc	r31, r31
    74f4:	80 ff       	sbrs	r24, 0
    74f6:	10 c0       	rjmp	.+32     	; 0x7518 <DigitOut+0x5a>
    74f8:	9f 01       	movw	r18, r30
    74fa:	24 0f       	add	r18, r20
    74fc:	35 1f       	adc	r19, r21
    74fe:	c9 01       	movw	r24, r18
    7500:	85 5d       	subi	r24, 0xD5	; 213
    7502:	96 4b       	sbci	r25, 0xB6	; 182
    7504:	fc 01       	movw	r30, r24
    7506:	a5 91       	lpm	r26, Z+
    7508:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    750a:	23 5d       	subi	r18, 0xD3	; 211
    750c:	36 4b       	sbci	r19, 0xB6	; 182
    750e:	f9 01       	movw	r30, r18
    7510:	94 91       	lpm	r25, Z+
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    7512:	8c 91       	ld	r24, X
    7514:	89 2b       	or	r24, r25
    7516:	10 c0       	rjmp	.+32     	; 0x7538 <DigitOut+0x7a>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7518:	9f 01       	movw	r18, r30
    751a:	24 0f       	add	r18, r20
    751c:	35 1f       	adc	r19, r21
    751e:	c9 01       	movw	r24, r18
    7520:	85 5d       	subi	r24, 0xD5	; 213
    7522:	96 4b       	sbci	r25, 0xB6	; 182
    7524:	fc 01       	movw	r30, r24
    7526:	a5 91       	lpm	r26, Z+
    7528:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    752a:	23 5d       	subi	r18, 0xD3	; 211
    752c:	36 4b       	sbci	r19, 0xB6	; 182
    752e:	f9 01       	movw	r30, r18
    7530:	94 91       	lpm	r25, Z+
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    7532:	90 95       	com	r25
    7534:	8c 91       	ld	r24, X
    7536:	89 23       	and	r24, r25
    7538:	8c 93       	st	X, r24
		sei();
    753a:	78 94       	sei
    753c:	4f 5f       	subi	r20, 0xFF	; 255
    753e:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    7540:	43 30       	cpi	r20, 0x03	; 3
    7542:	51 05       	cpc	r21, r1
    7544:	09 f0       	breq	.+2      	; 0x7548 <DigitOut+0x8a>
    7546:	c5 cf       	rjmp	.-118    	; 0x74d2 <DigitOut+0x14>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7548:	08 95       	ret

0000754a <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    754a:	20 e0       	ldi	r18, 0x00	; 0
    754c:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    754e:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7550:	a9 01       	movw	r20, r18
    7552:	44 0f       	add	r20, r20
    7554:	55 1f       	adc	r21, r21
    7556:	44 0f       	add	r20, r20
    7558:	55 1f       	adc	r21, r21
    755a:	42 0f       	add	r20, r18
    755c:	53 1f       	adc	r21, r19
    755e:	ca 01       	movw	r24, r20
    7560:	87 5d       	subi	r24, 0xD7	; 215
    7562:	96 4b       	sbci	r25, 0xB6	; 182
    7564:	fc 01       	movw	r30, r24
    7566:	a5 91       	lpm	r26, Z+
    7568:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    756a:	43 5d       	subi	r20, 0xD3	; 211
    756c:	56 4b       	sbci	r21, 0xB6	; 182
    756e:	fa 01       	movw	r30, r20
    7570:	94 91       	lpm	r25, Z+
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    7572:	8c 91       	ld	r24, X
    7574:	89 2b       	or	r24, r25
    7576:	8c 93       	st	X, r24
		sei();
    7578:	78 94       	sei
    757a:	2f 5f       	subi	r18, 0xFF	; 255
    757c:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    757e:	23 30       	cpi	r18, 0x03	; 3
    7580:	31 05       	cpc	r19, r1
    7582:	29 f7       	brne	.-54     	; 0x754e <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7584:	0e 94 5f 3a 	call	0x74be	; 0x74be <DigitOut>
	DO_Enable();
}
    7588:	08 95       	ret

0000758a <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    758a:	48 2f       	mov	r20, r24
    758c:	21 e0       	ldi	r18, 0x01	; 1
    758e:	30 e0       	ldi	r19, 0x00	; 0
    7590:	0b c0       	rjmp	.+22     	; 0x75a8 <Pow10+0x1e>
	uint16_t Pow = 1;
	while(Exp--)
		Pow *= 10;
    7592:	c9 01       	movw	r24, r18
    7594:	88 0f       	add	r24, r24
    7596:	99 1f       	adc	r25, r25
    7598:	f3 e0       	ldi	r31, 0x03	; 3
    759a:	22 0f       	add	r18, r18
    759c:	33 1f       	adc	r19, r19
    759e:	fa 95       	dec	r31
    75a0:	e1 f7       	brne	.-8      	; 0x759a <Pow10+0x10>
    75a2:	28 0f       	add	r18, r24
    75a4:	39 1f       	adc	r19, r25
    75a6:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    75a8:	44 23       	and	r20, r20
    75aa:	99 f7       	brne	.-26     	; 0x7592 <Pow10+0x8>
		Pow *= 10;
	return Pow;
}
    75ac:	c9 01       	movw	r24, r18
    75ae:	08 95       	ret

000075b0 <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    75b0:	1f 93       	push	r17
    75b2:	18 2f       	mov	r17, r24
    75b4:	21 e0       	ldi	r18, 0x01	; 1
    75b6:	30 e0       	ldi	r19, 0x00	; 0
    75b8:	40 e0       	ldi	r20, 0x00	; 0
    75ba:	50 e0       	ldi	r21, 0x00	; 0
    75bc:	0b c0       	rjmp	.+22     	; 0x75d4 <PowL10+0x24>
	uint32_t Pow = 1;
	while(Exp--)
		Pow *= 10;
    75be:	ca 01       	movw	r24, r20
    75c0:	b9 01       	movw	r22, r18
    75c2:	2a e0       	ldi	r18, 0x0A	; 10
    75c4:	30 e0       	ldi	r19, 0x00	; 0
    75c6:	40 e0       	ldi	r20, 0x00	; 0
    75c8:	50 e0       	ldi	r21, 0x00	; 0
    75ca:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    75ce:	9b 01       	movw	r18, r22
    75d0:	ac 01       	movw	r20, r24
    75d2:	11 50       	subi	r17, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    75d4:	11 23       	and	r17, r17
    75d6:	99 f7       	brne	.-26     	; 0x75be <PowL10+0xe>
		Pow *= 10;
	return Pow;
}
    75d8:	b9 01       	movw	r22, r18
    75da:	ca 01       	movw	r24, r20
    75dc:	1f 91       	pop	r17
    75de:	08 95       	ret

000075e0 <Log10>:
// ~~~~~~~~~~~~~~~~~
uint8_t
Log10(uint32_t Numb)
{
    75e0:	1f 93       	push	r17
    75e2:	10 e0       	ldi	r17, 0x00	; 0
    75e4:	01 c0       	rjmp	.+2      	; 0x75e8 <Log10+0x8>
	uint8_t Pos;
	for(Pos=0; Numb/=10; Pos++);
    75e6:	1f 5f       	subi	r17, 0xFF	; 255
    75e8:	2a e0       	ldi	r18, 0x0A	; 10
    75ea:	30 e0       	ldi	r19, 0x00	; 0
    75ec:	40 e0       	ldi	r20, 0x00	; 0
    75ee:	50 e0       	ldi	r21, 0x00	; 0
    75f0:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    75f4:	c9 01       	movw	r24, r18
    75f6:	da 01       	movw	r26, r20
    75f8:	bc 01       	movw	r22, r24
    75fa:	cd 01       	movw	r24, r26
    75fc:	61 15       	cp	r22, r1
    75fe:	71 05       	cpc	r23, r1
    7600:	81 05       	cpc	r24, r1
    7602:	91 05       	cpc	r25, r1
    7604:	81 f7       	brne	.-32     	; 0x75e6 <Log10+0x6>
	return Pos;
}
    7606:	81 2f       	mov	r24, r17
    7608:	1f 91       	pop	r17
    760a:	08 95       	ret

0000760c <CodBCD>:
// ~~~~~~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~
uint8_t
CodBCD(uint8_t Number)
{
    760c:	28 2f       	mov	r18, r24
    760e:	6a e0       	ldi	r22, 0x0A	; 10
    7610:	0e 94 0a 91 	call	0x12214	; 0x12214 <__udivmodqi4>
    7614:	38 2f       	mov	r19, r24
    7616:	32 95       	swap	r19
    7618:	30 7f       	andi	r19, 0xF0	; 240
    761a:	82 2f       	mov	r24, r18
    761c:	0e 94 0a 91 	call	0x12214	; 0x12214 <__udivmodqi4>
	return (Number/10<<4)+Number%10;
}
    7620:	83 2f       	mov	r24, r19
    7622:	89 0f       	add	r24, r25
    7624:	08 95       	ret

00007626 <DecodBCD>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DecodBCD(uint8_t BCD)
{
    7626:	28 2f       	mov	r18, r24
    7628:	22 95       	swap	r18
    762a:	2f 70       	andi	r18, 0x0F	; 15
    762c:	9a e0       	ldi	r25, 0x0A	; 10
    762e:	29 9f       	mul	r18, r25
    7630:	90 01       	movw	r18, r0
    7632:	11 24       	eor	r1, r1
    7634:	8f 70       	andi	r24, 0x0F	; 15
	return 10*(BCD>>4)+(BCD&0x0F);
}
    7636:	82 0f       	add	r24, r18
    7638:	08 95       	ret

0000763a <LineFunc>:
} uLineGraph;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
LineFunc(const LineGraph *LG, int32_t x)
{
    763a:	2f 92       	push	r2
    763c:	3f 92       	push	r3
    763e:	4f 92       	push	r4
    7640:	5f 92       	push	r5
    7642:	6f 92       	push	r6
    7644:	7f 92       	push	r7
    7646:	8f 92       	push	r8
    7648:	9f 92       	push	r9
    764a:	af 92       	push	r10
    764c:	bf 92       	push	r11
    764e:	cf 92       	push	r12
    7650:	df 92       	push	r13
    7652:	ef 92       	push	r14
    7654:	ff 92       	push	r15
    7656:	0f 93       	push	r16
    7658:	1f 93       	push	r17
    765a:	cf 93       	push	r28
    765c:	df 93       	push	r29
    765e:	ec 01       	movw	r28, r24
    7660:	7a 01       	movw	r14, r20
    7662:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    7664:	28 80       	ld	r2, Y
    7666:	39 80       	ldd	r3, Y+1	; 0x01
    7668:	4a 80       	ldd	r4, Y+2	; 0x02
    766a:	5b 80       	ldd	r5, Y+3	; 0x03
    766c:	6c 81       	ldd	r22, Y+4	; 0x04
    766e:	7d 81       	ldd	r23, Y+5	; 0x05
    7670:	8e 81       	ldd	r24, Y+6	; 0x06
    7672:	9f 81       	ldd	r25, Y+7	; 0x07
    7674:	26 16       	cp	r2, r22
    7676:	37 06       	cpc	r3, r23
    7678:	48 06       	cpc	r4, r24
    767a:	59 06       	cpc	r5, r25
    767c:	19 f4       	brne	.+6      	; 0x7684 <LineFunc+0x4a>
		y = LG->y1;
    767e:	88 85       	ldd	r24, Y+8	; 0x08
    7680:	99 85       	ldd	r25, Y+9	; 0x09
    7682:	45 c0       	rjmp	.+138    	; 0x770e <LineFunc+0xd4>
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    7684:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    7688:	5b 01       	movw	r10, r22
    768a:	6c 01       	movw	r12, r24
    768c:	6a 85       	ldd	r22, Y+10	; 0x0a
    768e:	7b 85       	ldd	r23, Y+11	; 0x0b
    7690:	88 27       	eor	r24, r24
    7692:	77 fd       	sbrc	r23, 7
    7694:	80 95       	com	r24
    7696:	98 2f       	mov	r25, r24
    7698:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    769c:	3b 01       	movw	r6, r22
    769e:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    76a0:	c8 01       	movw	r24, r16
    76a2:	b7 01       	movw	r22, r14
    76a4:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    76a8:	a6 01       	movw	r20, r12
    76aa:	95 01       	movw	r18, r10
    76ac:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    76b0:	7b 01       	movw	r14, r22
    76b2:	8c 01       	movw	r16, r24
    76b4:	68 85       	ldd	r22, Y+8	; 0x08
    76b6:	79 85       	ldd	r23, Y+9	; 0x09
    76b8:	88 27       	eor	r24, r24
    76ba:	77 fd       	sbrc	r23, 7
    76bc:	80 95       	com	r24
    76be:	98 2f       	mov	r25, r24
    76c0:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    76c4:	9b 01       	movw	r18, r22
    76c6:	ac 01       	movw	r20, r24
    76c8:	c4 01       	movw	r24, r8
    76ca:	b3 01       	movw	r22, r6
    76cc:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    76d0:	9b 01       	movw	r18, r22
    76d2:	ac 01       	movw	r20, r24
    76d4:	c8 01       	movw	r24, r16
    76d6:	b7 01       	movw	r22, r14
    76d8:	0e 94 61 8a 	call	0x114c2	; 0x114c2 <__mulsf3>
    76dc:	7b 01       	movw	r14, r22
    76de:	8c 01       	movw	r16, r24
    76e0:	c2 01       	movw	r24, r4
    76e2:	b1 01       	movw	r22, r2
    76e4:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    76e8:	9b 01       	movw	r18, r22
    76ea:	ac 01       	movw	r20, r24
    76ec:	c6 01       	movw	r24, r12
    76ee:	b5 01       	movw	r22, r10
    76f0:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    76f4:	9b 01       	movw	r18, r22
    76f6:	ac 01       	movw	r20, r24
    76f8:	c8 01       	movw	r24, r16
    76fa:	b7 01       	movw	r22, r14
    76fc:	0e 94 3a 89 	call	0x11274	; 0x11274 <__divsf3>
    7700:	a4 01       	movw	r20, r8
    7702:	93 01       	movw	r18, r6
    7704:	0e 94 d6 88 	call	0x111ac	; 0x111ac <__addsf3>
    7708:	0e 94 a2 89 	call	0x11344	; 0x11344 <__fixsfsi>
    770c:	cb 01       	movw	r24, r22
	}
	return y;
}
    770e:	df 91       	pop	r29
    7710:	cf 91       	pop	r28
    7712:	1f 91       	pop	r17
    7714:	0f 91       	pop	r16
    7716:	ff 90       	pop	r15
    7718:	ef 90       	pop	r14
    771a:	df 90       	pop	r13
    771c:	cf 90       	pop	r12
    771e:	bf 90       	pop	r11
    7720:	af 90       	pop	r10
    7722:	9f 90       	pop	r9
    7724:	8f 90       	pop	r8
    7726:	7f 90       	pop	r7
    7728:	6f 90       	pop	r6
    772a:	5f 90       	pop	r5
    772c:	4f 90       	pop	r4
    772e:	3f 90       	pop	r3
    7730:	2f 90       	pop	r2
    7732:	08 95       	ret

00007734 <uLineFunc>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
uLineFunc(const uLineGraph *LG, uint32_t x)
{
    7734:	2f 92       	push	r2
    7736:	3f 92       	push	r3
    7738:	4f 92       	push	r4
    773a:	5f 92       	push	r5
    773c:	6f 92       	push	r6
    773e:	7f 92       	push	r7
    7740:	8f 92       	push	r8
    7742:	9f 92       	push	r9
    7744:	af 92       	push	r10
    7746:	bf 92       	push	r11
    7748:	cf 92       	push	r12
    774a:	df 92       	push	r13
    774c:	ef 92       	push	r14
    774e:	ff 92       	push	r15
    7750:	0f 93       	push	r16
    7752:	1f 93       	push	r17
    7754:	cf 93       	push	r28
    7756:	df 93       	push	r29
    7758:	ec 01       	movw	r28, r24
    775a:	7a 01       	movw	r14, r20
    775c:	8b 01       	movw	r16, r22
	int16_t y;
	if (LG->x1==LG->x2)
    775e:	28 80       	ld	r2, Y
    7760:	39 80       	ldd	r3, Y+1	; 0x01
    7762:	4a 80       	ldd	r4, Y+2	; 0x02
    7764:	5b 80       	ldd	r5, Y+3	; 0x03
    7766:	6c 81       	ldd	r22, Y+4	; 0x04
    7768:	7d 81       	ldd	r23, Y+5	; 0x05
    776a:	8e 81       	ldd	r24, Y+6	; 0x06
    776c:	9f 81       	ldd	r25, Y+7	; 0x07
    776e:	26 16       	cp	r2, r22
    7770:	37 06       	cpc	r3, r23
    7772:	48 06       	cpc	r4, r24
    7774:	59 06       	cpc	r5, r25
    7776:	19 f4       	brne	.+6      	; 0x777e <uLineFunc+0x4a>
		y = LG->y1;
    7778:	88 85       	ldd	r24, Y+8	; 0x08
    777a:	99 85       	ldd	r25, Y+9	; 0x09
    777c:	45 c0       	rjmp	.+138    	; 0x7808 <uLineFunc+0xd4>
	else {
		float x1=LG->x1, x2=LG->x2, y1=LG->y1, y2=LG->y2;
    777e:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__floatunsisf>
    7782:	5b 01       	movw	r10, r22
    7784:	6c 01       	movw	r12, r24
    7786:	6a 85       	ldd	r22, Y+10	; 0x0a
    7788:	7b 85       	ldd	r23, Y+11	; 0x0b
    778a:	88 27       	eor	r24, r24
    778c:	77 fd       	sbrc	r23, 7
    778e:	80 95       	com	r24
    7790:	98 2f       	mov	r25, r24
    7792:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    7796:	3b 01       	movw	r6, r22
    7798:	4c 01       	movw	r8, r24
		y = (x-x2)*(y2-y1)/(x2-x1)+y2;
    779a:	c8 01       	movw	r24, r16
    779c:	b7 01       	movw	r22, r14
    779e:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__floatunsisf>
    77a2:	a6 01       	movw	r20, r12
    77a4:	95 01       	movw	r18, r10
    77a6:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    77aa:	7b 01       	movw	r14, r22
    77ac:	8c 01       	movw	r16, r24
    77ae:	68 85       	ldd	r22, Y+8	; 0x08
    77b0:	79 85       	ldd	r23, Y+9	; 0x09
    77b2:	88 27       	eor	r24, r24
    77b4:	77 fd       	sbrc	r23, 7
    77b6:	80 95       	com	r24
    77b8:	98 2f       	mov	r25, r24
    77ba:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    77be:	9b 01       	movw	r18, r22
    77c0:	ac 01       	movw	r20, r24
    77c2:	c4 01       	movw	r24, r8
    77c4:	b3 01       	movw	r22, r6
    77c6:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    77ca:	9b 01       	movw	r18, r22
    77cc:	ac 01       	movw	r20, r24
    77ce:	c8 01       	movw	r24, r16
    77d0:	b7 01       	movw	r22, r14
    77d2:	0e 94 61 8a 	call	0x114c2	; 0x114c2 <__mulsf3>
    77d6:	7b 01       	movw	r14, r22
    77d8:	8c 01       	movw	r16, r24
    77da:	c2 01       	movw	r24, r4
    77dc:	b1 01       	movw	r22, r2
    77de:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__floatunsisf>
    77e2:	9b 01       	movw	r18, r22
    77e4:	ac 01       	movw	r20, r24
    77e6:	c6 01       	movw	r24, r12
    77e8:	b5 01       	movw	r22, r10
    77ea:	0e 94 d5 88 	call	0x111aa	; 0x111aa <__subsf3>
    77ee:	9b 01       	movw	r18, r22
    77f0:	ac 01       	movw	r20, r24
    77f2:	c8 01       	movw	r24, r16
    77f4:	b7 01       	movw	r22, r14
    77f6:	0e 94 3a 89 	call	0x11274	; 0x11274 <__divsf3>
    77fa:	a4 01       	movw	r20, r8
    77fc:	93 01       	movw	r18, r6
    77fe:	0e 94 d6 88 	call	0x111ac	; 0x111ac <__addsf3>
    7802:	0e 94 a2 89 	call	0x11344	; 0x11344 <__fixsfsi>
    7806:	cb 01       	movw	r24, r22
	}
	return y;
}
    7808:	df 91       	pop	r29
    780a:	cf 91       	pop	r28
    780c:	1f 91       	pop	r17
    780e:	0f 91       	pop	r16
    7810:	ff 90       	pop	r15
    7812:	ef 90       	pop	r14
    7814:	df 90       	pop	r13
    7816:	cf 90       	pop	r12
    7818:	bf 90       	pop	r11
    781a:	af 90       	pop	r10
    781c:	9f 90       	pop	r9
    781e:	8f 90       	pop	r8
    7820:	7f 90       	pop	r7
    7822:	6f 90       	pop	r6
    7824:	5f 90       	pop	r5
    7826:	4f 90       	pop	r4
    7828:	3f 90       	pop	r3
    782a:	2f 90       	pop	r2
    782c:	08 95       	ret

0000782e <PGM_uBrokLine>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int16_t
PGM_uBrokLine(PGM_uDataPoint *Brok, uint16_t x)
{
    782e:	af 92       	push	r10
    7830:	bf 92       	push	r11
    7832:	cf 92       	push	r12
    7834:	df 92       	push	r13
    7836:	ef 92       	push	r14
    7838:	ff 92       	push	r15
    783a:	0f 93       	push	r16
    783c:	1f 93       	push	r17
    783e:	df 93       	push	r29
    7840:	cf 93       	push	r28
    7842:	cd b7       	in	r28, 0x3d	; 61
    7844:	de b7       	in	r29, 0x3e	; 62
    7846:	2c 97       	sbiw	r28, 0x0c	; 12
    7848:	0f b6       	in	r0, 0x3f	; 63
    784a:	f8 94       	cli
    784c:	de bf       	out	0x3e, r29	; 62
    784e:	0f be       	out	0x3f, r0	; 63
    7850:	cd bf       	out	0x3d, r28	; 61
    7852:	dc 01       	movw	r26, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7854:	fc 01       	movw	r30, r24
    7856:	85 91       	lpm	r24, Z+
    7858:	94 91       	lpm	r25, Z+
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
    785a:	7c 01       	movw	r14, r24
    785c:	00 e0       	ldi	r16, 0x00	; 0
    785e:	10 e0       	ldi	r17, 0x00	; 0
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
	} while(x>Segm.x2);
    7860:	5b 01       	movw	r10, r22
    7862:	cc 24       	eor	r12, r12
    7864:	dd 24       	eor	r13, r13
{
	uLineGraph Segm;
	Segm.x2 = prw(&Brok->x);
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = prw(&(++Brok)->x);
    7866:	cd 01       	movw	r24, r26
    7868:	04 96       	adiw	r24, 0x04	; 4
    786a:	fc 01       	movw	r30, r24
    786c:	25 91       	lpm	r18, Z+
    786e:	34 91       	lpm	r19, Z+
	} while(x>Segm.x2);
    7870:	ad 01       	movw	r20, r26
    7872:	b7 01       	movw	r22, r14
    7874:	f8 01       	movw	r30, r16
    7876:	dc 01       	movw	r26, r24
    7878:	79 01       	movw	r14, r18
    787a:	00 e0       	ldi	r16, 0x00	; 0
    787c:	10 e0       	ldi	r17, 0x00	; 0
    787e:	ea 14       	cp	r14, r10
    7880:	fb 04       	cpc	r15, r11
    7882:	0c 05       	cpc	r16, r12
    7884:	1d 05       	cpc	r17, r13
    7886:	78 f3       	brcs	.-34     	; 0x7866 <PGM_uBrokLine+0x38>
    7888:	ca 01       	movw	r24, r20
    788a:	9b 01       	movw	r18, r22
    788c:	af 01       	movw	r20, r30
    788e:	69 83       	std	Y+1, r22	; 0x01
    7890:	3a 83       	std	Y+2, r19	; 0x02
    7892:	eb 83       	std	Y+3, r30	; 0x03
    7894:	5c 83       	std	Y+4, r21	; 0x04
    7896:	ed 82       	std	Y+5, r14	; 0x05
    7898:	fe 82       	std	Y+6, r15	; 0x06
    789a:	0f 83       	std	Y+7, r16	; 0x07
    789c:	18 87       	std	Y+8, r17	; 0x08
    789e:	fc 01       	movw	r30, r24
    78a0:	32 96       	adiw	r30, 0x02	; 2
    78a2:	85 91       	lpm	r24, Z+
    78a4:	94 91       	lpm	r25, Z+
	Segm.y1 = (int16_t)prw(&(Brok-1)->y);
    78a6:	9a 87       	std	Y+10, r25	; 0x0a
    78a8:	89 87       	std	Y+9, r24	; 0x09
    78aa:	fd 01       	movw	r30, r26
    78ac:	32 96       	adiw	r30, 0x02	; 2
    78ae:	85 91       	lpm	r24, Z+
    78b0:	94 91       	lpm	r25, Z+
	Segm.y2 = (int16_t)prw(&Brok->y);
    78b2:	9c 87       	std	Y+12, r25	; 0x0c
    78b4:	8b 87       	std	Y+11, r24	; 0x0b
	return uLineFunc(&Segm, x);
    78b6:	ce 01       	movw	r24, r28
    78b8:	01 96       	adiw	r24, 0x01	; 1
    78ba:	b6 01       	movw	r22, r12
    78bc:	a5 01       	movw	r20, r10
    78be:	0e 94 9a 3b 	call	0x7734	; 0x7734 <uLineFunc>
}
    78c2:	2c 96       	adiw	r28, 0x0c	; 12
    78c4:	0f b6       	in	r0, 0x3f	; 63
    78c6:	f8 94       	cli
    78c8:	de bf       	out	0x3e, r29	; 62
    78ca:	0f be       	out	0x3f, r0	; 63
    78cc:	cd bf       	out	0x3d, r28	; 61
    78ce:	cf 91       	pop	r28
    78d0:	df 91       	pop	r29
    78d2:	1f 91       	pop	r17
    78d4:	0f 91       	pop	r16
    78d6:	ff 90       	pop	r15
    78d8:	ef 90       	pop	r14
    78da:	df 90       	pop	r13
    78dc:	cf 90       	pop	r12
    78de:	bf 90       	pop	r11
    78e0:	af 90       	pop	r10
    78e2:	08 95       	ret

000078e4 <InterBrokLine>:
	uint8_t WiAbsc, int16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, int16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    78e4:	2f 92       	push	r2
    78e6:	3f 92       	push	r3
    78e8:	4f 92       	push	r4
    78ea:	5f 92       	push	r5
    78ec:	6f 92       	push	r6
    78ee:	7f 92       	push	r7
    78f0:	8f 92       	push	r8
    78f2:	9f 92       	push	r9
    78f4:	af 92       	push	r10
    78f6:	bf 92       	push	r11
    78f8:	cf 92       	push	r12
    78fa:	df 92       	push	r13
    78fc:	ef 92       	push	r14
    78fe:	ff 92       	push	r15
    7900:	0f 93       	push	r16
    7902:	1f 93       	push	r17
    7904:	df 93       	push	r29
    7906:	cf 93       	push	r28
    7908:	cd b7       	in	r28, 0x3d	; 61
    790a:	de b7       	in	r29, 0x3e	; 62
    790c:	2e 97       	sbiw	r28, 0x0e	; 14
    790e:	0f b6       	in	r0, 0x3f	; 63
    7910:	f8 94       	cli
    7912:	de bf       	out	0x3e, r29	; 62
    7914:	0f be       	out	0x3f, r0	; 63
    7916:	cd bf       	out	0x3d, r28	; 61
    7918:	2b 01       	movw	r4, r22
    791a:	2d 87       	std	Y+13, r18	; 0x0d
    791c:	18 01       	movw	r2, r16
    791e:	ee 86       	std	Y+14, r14	; 0x0e
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
    7920:	50 e0       	ldi	r21, 0x00	; 0
    7922:	44 0f       	add	r20, r20
    7924:	55 1f       	adc	r21, r21
    7926:	fb 01       	movw	r30, r22
    7928:	e4 0f       	add	r30, r20
    792a:	f5 1f       	adc	r31, r21
    792c:	20 81       	ld	r18, Z
    792e:	31 81       	ldd	r19, Z+1	; 0x01
    7930:	79 01       	movw	r14, r18
    7932:	00 27       	eor	r16, r16
    7934:	f7 fc       	sbrc	r15, 7
    7936:	00 95       	com	r16
    7938:	10 2f       	mov	r17, r16
    793a:	ed 82       	std	Y+5, r14	; 0x05
    793c:	fe 82       	std	Y+6, r15	; 0x06
    793e:	0f 83       	std	Y+7, r16	; 0x07
    7940:	18 87       	std	Y+8, r17	; 0x08
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    7942:	68 2f       	mov	r22, r24
    7944:	70 e0       	ldi	r23, 0x00	; 0
    7946:	66 0f       	add	r22, r22
    7948:	77 1f       	adc	r23, r23
    794a:	dd 24       	eor	r13, r13
    794c:	da 01       	movw	r26, r20
	} while(x>Segm.x2 && i<Len);
    794e:	35 01       	movw	r6, r10
    7950:	88 24       	eor	r8, r8
    7952:	77 fc       	sbrc	r7, 7
    7954:	80 94       	com	r8
    7956:	98 2c       	mov	r9, r8
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2=TblAbsc[0][Absc];
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = TblAbsc[++i][Absc];
    7958:	d3 94       	inc	r13
    795a:	ad 2c       	mov	r10, r13
    795c:	bb 24       	eor	r11, r11
    795e:	a6 9e       	mul	r10, r22
    7960:	f0 01       	movw	r30, r0
    7962:	a7 9e       	mul	r10, r23
    7964:	f0 0d       	add	r31, r0
    7966:	b6 9e       	mul	r11, r22
    7968:	f0 0d       	add	r31, r0
    796a:	11 24       	eor	r1, r1
    796c:	e4 0d       	add	r30, r4
    796e:	f5 1d       	adc	r31, r5
    7970:	ea 0f       	add	r30, r26
    7972:	fb 1f       	adc	r31, r27
    7974:	80 81       	ld	r24, Z
    7976:	91 81       	ldd	r25, Z+1	; 0x01
    7978:	9c 01       	movw	r18, r24
    797a:	44 27       	eor	r20, r20
    797c:	37 fd       	sbrc	r19, 7
    797e:	40 95       	com	r20
    7980:	54 2f       	mov	r21, r20
	} while(x>Segm.x2 && i<Len);
    7982:	26 15       	cp	r18, r6
    7984:	37 05       	cpc	r19, r7
    7986:	48 05       	cpc	r20, r8
    7988:	59 05       	cpc	r21, r9
    798a:	2c f4       	brge	.+10     	; 0x7996 <InterBrokLine+0xb2>
    798c:	dc 14       	cp	r13, r12
    798e:	18 f4       	brcc	.+6      	; 0x7996 <InterBrokLine+0xb2>
    7990:	79 01       	movw	r14, r18
    7992:	8a 01       	movw	r16, r20
    7994:	e1 cf       	rjmp	.-62     	; 0x7958 <InterBrokLine+0x74>
    7996:	e9 82       	std	Y+1, r14	; 0x01
    7998:	fa 82       	std	Y+2, r15	; 0x02
    799a:	0b 83       	std	Y+3, r16	; 0x03
    799c:	1c 83       	std	Y+4, r17	; 0x04
    799e:	2d 83       	std	Y+5, r18	; 0x05
    79a0:	3e 83       	std	Y+6, r19	; 0x06
    79a2:	4f 83       	std	Y+7, r20	; 0x07
    79a4:	58 87       	std	Y+8, r21	; 0x08
	Segm.y1 = TblOrdi[i-1][Ordi];
    79a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    79a8:	28 2f       	mov	r18, r24
    79aa:	30 e0       	ldi	r19, 0x00	; 0
    79ac:	22 0f       	add	r18, r18
    79ae:	33 1f       	adc	r19, r19
    79b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    79b2:	a8 2f       	mov	r26, r24
    79b4:	b0 e0       	ldi	r27, 0x00	; 0
    79b6:	8d 2d       	mov	r24, r13
    79b8:	90 e0       	ldi	r25, 0x00	; 0
    79ba:	01 97       	sbiw	r24, 0x01	; 1
    79bc:	28 9f       	mul	r18, r24
    79be:	f0 01       	movw	r30, r0
    79c0:	29 9f       	mul	r18, r25
    79c2:	f0 0d       	add	r31, r0
    79c4:	38 9f       	mul	r19, r24
    79c6:	f0 0d       	add	r31, r0
    79c8:	11 24       	eor	r1, r1
    79ca:	e2 0d       	add	r30, r2
    79cc:	f3 1d       	adc	r31, r3
    79ce:	aa 0f       	add	r26, r26
    79d0:	bb 1f       	adc	r27, r27
    79d2:	ea 0f       	add	r30, r26
    79d4:	fb 1f       	adc	r31, r27
    79d6:	80 81       	ld	r24, Z
    79d8:	91 81       	ldd	r25, Z+1	; 0x01
    79da:	9a 87       	std	Y+10, r25	; 0x0a
    79dc:	89 87       	std	Y+9, r24	; 0x09
	Segm.y2 = TblOrdi[i][Ordi];
    79de:	2a 9d       	mul	r18, r10
    79e0:	c0 01       	movw	r24, r0
    79e2:	2b 9d       	mul	r18, r11
    79e4:	90 0d       	add	r25, r0
    79e6:	3a 9d       	mul	r19, r10
    79e8:	90 0d       	add	r25, r0
    79ea:	11 24       	eor	r1, r1
    79ec:	82 0d       	add	r24, r2
    79ee:	93 1d       	adc	r25, r3
    79f0:	a8 0f       	add	r26, r24
    79f2:	b9 1f       	adc	r27, r25
    79f4:	8d 91       	ld	r24, X+
    79f6:	9c 91       	ld	r25, X
    79f8:	9c 87       	std	Y+12, r25	; 0x0c
    79fa:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    79fc:	ce 01       	movw	r24, r28
    79fe:	01 96       	adiw	r24, 0x01	; 1
    7a00:	b4 01       	movw	r22, r8
    7a02:	a3 01       	movw	r20, r6
    7a04:	0e 94 1d 3b 	call	0x763a	; 0x763a <LineFunc>
}
    7a08:	2e 96       	adiw	r28, 0x0e	; 14
    7a0a:	0f b6       	in	r0, 0x3f	; 63
    7a0c:	f8 94       	cli
    7a0e:	de bf       	out	0x3e, r29	; 62
    7a10:	0f be       	out	0x3f, r0	; 63
    7a12:	cd bf       	out	0x3d, r28	; 61
    7a14:	cf 91       	pop	r28
    7a16:	df 91       	pop	r29
    7a18:	1f 91       	pop	r17
    7a1a:	0f 91       	pop	r16
    7a1c:	ff 90       	pop	r15
    7a1e:	ef 90       	pop	r14
    7a20:	df 90       	pop	r13
    7a22:	cf 90       	pop	r12
    7a24:	bf 90       	pop	r11
    7a26:	af 90       	pop	r10
    7a28:	9f 90       	pop	r9
    7a2a:	8f 90       	pop	r8
    7a2c:	7f 90       	pop	r7
    7a2e:	6f 90       	pop	r6
    7a30:	5f 90       	pop	r5
    7a32:	4f 90       	pop	r4
    7a34:	3f 90       	pop	r3
    7a36:	2f 90       	pop	r2
    7a38:	08 95       	ret

00007a3a <ThermWrong>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermWrong(uint8_t T_Fami, uint8_t T_Type, int16_t Ter)
{
	uint8_t TW = ThermNorm;
	if (T_Type!=ThermOff && T_Type<=prb(MaxThermType+T_Fami)) {
    7a3a:	66 23       	and	r22, r22
    7a3c:	41 f1       	breq	.+80     	; 0x7a8e <ThermWrong+0x54>
    7a3e:	28 2f       	mov	r18, r24
    7a40:	30 e0       	ldi	r19, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7a42:	f9 01       	movw	r30, r18
    7a44:	e0 5e       	subi	r30, 0xE0	; 224
    7a46:	f6 4b       	sbci	r31, 0xB6	; 182
    7a48:	e4 91       	lpm	r30, Z+
    7a4a:	e6 17       	cp	r30, r22
    7a4c:	00 f1       	brcs	.+64     	; 0x7a8e <ThermWrong+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7a4e:	f9 01       	movw	r30, r18
    7a50:	ee 0f       	add	r30, r30
    7a52:	ff 1f       	adc	r31, r31
    7a54:	ed 5d       	subi	r30, 0xDD	; 221
    7a56:	f6 4b       	sbci	r31, 0xB6	; 182
    7a58:	25 91       	lpm	r18, Z+
    7a5a:	34 91       	lpm	r19, Z+
		TerLim *T_L = prp(TerLimType+T_Fami);
		if (Ter<(int16_t)prw(&T_L[T_Type].Low))
    7a5c:	86 2f       	mov	r24, r22
    7a5e:	90 e0       	ldi	r25, 0x00	; 0
    7a60:	88 0f       	add	r24, r24
    7a62:	99 1f       	adc	r25, r25
    7a64:	88 0f       	add	r24, r24
    7a66:	99 1f       	adc	r25, r25
    7a68:	28 0f       	add	r18, r24
    7a6a:	39 1f       	adc	r19, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    7a6c:	f9 01       	movw	r30, r18
    7a6e:	85 91       	lpm	r24, Z+
    7a70:	94 91       	lpm	r25, Z+
    7a72:	48 17       	cp	r20, r24
    7a74:	59 07       	cpc	r21, r25
    7a76:	14 f4       	brge	.+4      	; 0x7a7c <ThermWrong+0x42>
    7a78:	81 e0       	ldi	r24, 0x01	; 1
    7a7a:	08 95       	ret
    7a7c:	f9 01       	movw	r30, r18
    7a7e:	32 96       	adiw	r30, 0x02	; 2
    7a80:	85 91       	lpm	r24, Z+
    7a82:	94 91       	lpm	r25, Z+
			TW = ThermUnder;
		else if(Ter>(int16_t)prw(&T_L[T_Type].Upp))
    7a84:	84 17       	cp	r24, r20
    7a86:	95 07       	cpc	r25, r21
    7a88:	14 f4       	brge	.+4      	; 0x7a8e <ThermWrong+0x54>
    7a8a:	82 e0       	ldi	r24, 0x02	; 2
    7a8c:	08 95       	ret
    7a8e:	80 e0       	ldi	r24, 0x00	; 0
			TW = ThermOver;
	}
	return TW;
}
    7a90:	08 95       	ret

00007a92 <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    7a92:	cf 92       	push	r12
    7a94:	df 92       	push	r13
    7a96:	ef 92       	push	r14
    7a98:	ff 92       	push	r15
    7a9a:	0f 93       	push	r16
    7a9c:	1f 93       	push	r17
    7a9e:	cf 93       	push	r28
    7aa0:	df 93       	push	r29
    7aa2:	18 2f       	mov	r17, r24
    7aa4:	c0 e0       	ldi	r28, 0x00	; 0
    7aa6:	d0 e0       	ldi	r29, 0x00	; 0
    7aa8:	0a e1       	ldi	r16, 0x1A	; 26
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    7aaa:	e6 2e       	mov	r14, r22
    7aac:	ff 24       	eor	r15, r15
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7aae:	e4 e5       	ldi	r30, 0x54	; 84
    7ab0:	ce 2e       	mov	r12, r30
    7ab2:	e1 e0       	ldi	r30, 0x01	; 1
    7ab4:	de 2e       	mov	r13, r30

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    7ab6:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7ab8:	81 2f       	mov	r24, r17
    7aba:	0e 94 bf 29 	call	0x537e	; 0x537e <OW_MasterPullLowBus>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7abe:	80 2f       	mov	r24, r16
    7ac0:	8a 95       	dec	r24
    7ac2:	f1 f7       	brne	.-4      	; 0x7ac0 <OW_MasterTx_Command+0x2e>
		_delay_us(5);
		if(Command & (1<<i)){
    7ac4:	c7 01       	movw	r24, r14
    7ac6:	0c 2e       	mov	r0, r28
    7ac8:	02 c0       	rjmp	.+4      	; 0x7ace <OW_MasterTx_Command+0x3c>
    7aca:	95 95       	asr	r25
    7acc:	87 95       	ror	r24
    7ace:	0a 94       	dec	r0
    7ad0:	e2 f7       	brpl	.-8      	; 0x7aca <OW_MasterTx_Command+0x38>
    7ad2:	80 ff       	sbrs	r24, 0
    7ad4:	07 c0       	rjmp	.+14     	; 0x7ae4 <OW_MasterTx_Command+0x52>
			OW_MasterReleaseBus(CH);
    7ad6:	81 2f       	mov	r24, r17
    7ad8:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7adc:	c6 01       	movw	r24, r12
    7ade:	01 97       	sbiw	r24, 0x01	; 1
    7ae0:	f1 f7       	brne	.-4      	; 0x7ade <OW_MasterTx_Command+0x4c>
    7ae2:	07 c0       	rjmp	.+14     	; 0x7af2 <OW_MasterTx_Command+0x60>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    7ae4:	85 e5       	ldi	r24, 0x55	; 85
    7ae6:	90 e0       	ldi	r25, 0x00	; 0
    7ae8:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>
			OW_MasterReleaseBus(CH);
    7aec:	81 2f       	mov	r24, r17
    7aee:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>
		}
		sei();
    7af2:	78 94       	sei
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7af4:	80 2f       	mov	r24, r16
    7af6:	8a 95       	dec	r24
    7af8:	f1 f7       	brne	.-4      	; 0x7af6 <OW_MasterTx_Command+0x64>
    7afa:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    7afc:	c8 30       	cpi	r28, 0x08	; 8
    7afe:	d1 05       	cpc	r29, r1
    7b00:	d1 f6       	brne	.-76     	; 0x7ab6 <OW_MasterTx_Command+0x24>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    7b02:	df 91       	pop	r29
    7b04:	cf 91       	pop	r28
    7b06:	1f 91       	pop	r17
    7b08:	0f 91       	pop	r16
    7b0a:	ff 90       	pop	r15
    7b0c:	ef 90       	pop	r14
    7b0e:	df 90       	pop	r13
    7b10:	cf 90       	pop	r12
    7b12:	08 95       	ret

00007b14 <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    7b14:	bf 92       	push	r11
    7b16:	cf 92       	push	r12
    7b18:	df 92       	push	r13
    7b1a:	ef 92       	push	r14
    7b1c:	ff 92       	push	r15
    7b1e:	0f 93       	push	r16
    7b20:	1f 93       	push	r17
    7b22:	cf 93       	push	r28
    7b24:	df 93       	push	r29
    7b26:	08 2f       	mov	r16, r24
    7b28:	10 e0       	ldi	r17, 0x00	; 0
    7b2a:	c0 e0       	ldi	r28, 0x00	; 0
    7b2c:	d0 e0       	ldi	r29, 0x00	; 0
    7b2e:	ba e1       	ldi	r27, 0x1A	; 26
    7b30:	bb 2e       	mov	r11, r27
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    7b32:	a1 e0       	ldi	r26, 0x01	; 1
    7b34:	ca 2e       	mov	r12, r26
    7b36:	d1 2c       	mov	r13, r1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b38:	f0 ef       	ldi	r31, 0xF0	; 240
    7b3a:	ef 2e       	mov	r14, r31
    7b3c:	f1 2c       	mov	r15, r1
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    7b3e:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7b40:	80 2f       	mov	r24, r16
    7b42:	0e 94 bf 29 	call	0x537e	; 0x537e <OW_MasterPullLowBus>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7b46:	8b 2d       	mov	r24, r11
    7b48:	8a 95       	dec	r24
    7b4a:	f1 f7       	brne	.-4      	; 0x7b48 <OW_MasterRx_Data+0x34>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    7b4c:	80 2f       	mov	r24, r16
    7b4e:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>
    7b52:	8b 2d       	mov	r24, r11
    7b54:	8a 95       	dec	r24
    7b56:	f1 f7       	brne	.-4      	; 0x7b54 <OW_MasterRx_Data+0x40>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    7b58:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    7b5c:	80 ff       	sbrs	r24, 0
    7b5e:	08 c0       	rjmp	.+16     	; 0x7b70 <OW_MasterRx_Data+0x5c>
    7b60:	c6 01       	movw	r24, r12
    7b62:	0c 2e       	mov	r0, r28
    7b64:	02 c0       	rjmp	.+4      	; 0x7b6a <OW_MasterRx_Data+0x56>
    7b66:	88 0f       	add	r24, r24
    7b68:	99 1f       	adc	r25, r25
    7b6a:	0a 94       	dec	r0
    7b6c:	e2 f7       	brpl	.-8      	; 0x7b66 <OW_MasterRx_Data+0x52>
    7b6e:	18 2b       	or	r17, r24
		sei();
    7b70:	78 94       	sei
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7b72:	c7 01       	movw	r24, r14
    7b74:	01 97       	sbiw	r24, 0x01	; 1
    7b76:	f1 f7       	brne	.-4      	; 0x7b74 <OW_MasterRx_Data+0x60>
    7b78:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    7b7a:	c8 30       	cpi	r28, 0x08	; 8
    7b7c:	d1 05       	cpc	r29, r1
    7b7e:	f9 f6       	brne	.-66     	; 0x7b3e <OW_MasterRx_Data+0x2a>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    7b80:	81 2f       	mov	r24, r17
    7b82:	df 91       	pop	r29
    7b84:	cf 91       	pop	r28
    7b86:	1f 91       	pop	r17
    7b88:	0f 91       	pop	r16
    7b8a:	ff 90       	pop	r15
    7b8c:	ef 90       	pop	r14
    7b8e:	df 90       	pop	r13
    7b90:	cf 90       	pop	r12
    7b92:	bf 90       	pop	r11
    7b94:	08 95       	ret

00007b96 <OneWire_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7b96:	80 91 ce 01 	lds	r24, 0x01CE
	VacantTimer8Sys += n;
    7b9a:	8f 5f       	subi	r24, 0xFF	; 255
    7b9c:	80 93 ce 01 	sts	0x01CE, r24
    7ba0:	81 50       	subi	r24, 0x01	; 1


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    7ba2:	80 93 d8 08 	sts	0x08D8, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    7ba6:	8a e0       	ldi	r24, 0x0A	; 10
    7ba8:	80 93 7a 03 	sts	0x037A, r24
//To initiate a temperature measurement and A-to-D conversion, the master must issue a Convert T [44h] command.
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
    7bac:	08 95       	ret

00007bae <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    7bae:	f8 94       	cli
    7bb0:	ff cf       	rjmp	.-2      	; 0x7bb0 <Reboot+0x2>

00007bb2 <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    7bb2:	8b e4       	ldi	r24, 0x4B	; 75
    7bb4:	80 93 a4 05 	sts	0x05A4, r24
}
    7bb8:	08 95       	ret

00007bba <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    7bba:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    7bbc:	e0 e0       	ldi	r30, 0x00	; 0
    7bbe:	ff ef       	ldi	r31, 0xFF	; 255
    7bc0:	09 95       	icall
}
    7bc2:	08 95       	ret

00007bc4 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    7bc4:	80 91 8d 0a 	lds	r24, 0x0A8D
    7bc8:	90 91 8e 0a 	lds	r25, 0x0A8E
    7bcc:	89 2b       	or	r24, r25
    7bce:	11 f4       	brne	.+4      	; 0x7bd4 <HideMsg+0x10>
    7bd0:	80 e0       	ldi	r24, 0x00	; 0
    7bd2:	08 95       	ret
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    7bd4:	10 92 8e 0a 	sts	0x0A8E, r1
    7bd8:	10 92 8d 0a 	sts	0x0A8D, r1
    7bdc:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	}
	else
		return 0;
}
    7bde:	08 95       	ret

00007be0 <ShowMsg>:
// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
	CurrMsg = Msg;
    7be0:	90 93 8e 0a 	sts	0x0A8E, r25
    7be4:	80 93 8d 0a 	sts	0x0A8D, r24
	//IntOff();
	//MBInReg0[MB_IR_Message] = prb(&CurrMsg->MsgCode);
	//IntOn();
	//LED_MSG_On();
	//EventFunc(&CurrMsg->Load);
}
    7be8:	08 95       	ret

00007bea <WebInit>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7bea:	90 91 ce 01 	lds	r25, 0x01CE
	VacantTimer8Sys += n;
    7bee:	89 2f       	mov	r24, r25
    7bf0:	8f 5f       	subi	r24, 0xFF	; 255
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    7bf2:	90 93 b2 08 	sts	0x08B2, r25
    7bf6:	8f 5f       	subi	r24, 0xFF	; 255
    7bf8:	80 93 ce 01 	sts	0x01CE, r24
    7bfc:	81 50       	subi	r24, 0x01	; 1
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    7bfe:	80 93 b5 08 	sts	0x08B5, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7c02:	90 91 cf 01 	lds	r25, 0x01CF
	VacantTimer16Sys += n;
    7c06:	89 2f       	mov	r24, r25
    7c08:	8f 5f       	subi	r24, 0xFF	; 255
	TD_FlowDelay =  Timer16SysAlloc(1);
    7c0a:	90 93 be 08 	sts	0x08BE, r25
    7c0e:	8f 5f       	subi	r24, 0xFF	; 255
    7c10:	80 93 cf 01 	sts	0x01CF, r24
    7c14:	81 50       	subi	r24, 0x01	; 1
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    7c16:	80 93 d7 08 	sts	0x08D7, r24

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    7c1a:	80 91 cd 01 	lds	r24, 0x01CD
	VacantTimer32++;
    7c1e:	98 2f       	mov	r25, r24
    7c20:	9f 5f       	subi	r25, 0xFF	; 255
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    7c22:	80 93 99 05 	sts	0x0599, r24
    7c26:	29 2f       	mov	r18, r25
    7c28:	2f 5f       	subi	r18, 0xFF	; 255
    7c2a:	20 93 cd 01 	sts	0x01CD, r18
	TD_WebSessTimeout	= Timer32Alloc();
    7c2e:	90 93 d5 08 	sts	0x08D5, r25
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    7c32:	80 91 cb 01 	lds	r24, 0x01CB
    7c36:	88 31       	cpi	r24, 0x18	; 24
    7c38:	30 f4       	brcc	.+12     	; 0x7c46 <WebInit+0x5c>
    7c3a:	80 91 cc 01 	lds	r24, 0x01CC
    7c3e:	88 32       	cpi	r24, 0x28	; 40
    7c40:	10 f4       	brcc	.+4      	; 0x7c46 <WebInit+0x5c>
    7c42:	20 32       	cpi	r18, 0x20	; 32
    7c44:	30 f0       	brcs	.+12     	; 0x7c52 <WebInit+0x68>
// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
	CurrMsg = Msg;
    7c46:	89 e6       	ldi	r24, 0x69	; 105
    7c48:	95 e0       	ldi	r25, 0x05	; 5
    7c4a:	90 93 8e 0a 	sts	0x0A8E, r25
    7c4e:	80 93 8d 0a 	sts	0x0A8D, r24
    7c52:	08 95       	ret

00007c54 <strcmp_PP>:
	return IF;
}
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
    7c54:	9c 01       	movw	r18, r24
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
    7c56:	ab 01       	movw	r20, r22
    7c58:	0c c0       	rjmp	.+24     	; 0x7c72 <strcmp_PP+0x1e>
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    7c5a:	89 17       	cp	r24, r25
    7c5c:	10 f4       	brcc	.+4      	; 0x7c62 <strcmp_PP+0xe>
    7c5e:	81 e0       	ldi	r24, 0x01	; 1
    7c60:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    7c62:	98 17       	cp	r25, r24
    7c64:	10 f4       	brcc	.+4      	; 0x7c6a <strcmp_PP+0x16>
    7c66:	8f ef       	ldi	r24, 0xFF	; 255
    7c68:	08 95       	ret
		s1++;
    7c6a:	2f 5f       	subi	r18, 0xFF	; 255
    7c6c:	3f 4f       	sbci	r19, 0xFF	; 255
		s2++;
    7c6e:	4f 5f       	subi	r20, 0xFF	; 255
    7c70:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7c72:	f9 01       	movw	r30, r18
    7c74:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    7c76:	99 23       	and	r25, r25
    7c78:	21 f0       	breq	.+8      	; 0x7c82 <strcmp_PP+0x2e>
    7c7a:	fa 01       	movw	r30, r20
    7c7c:	84 91       	lpm	r24, Z+
    7c7e:	88 23       	and	r24, r24
    7c80:	61 f7       	brne	.-40     	; 0x7c5a <strcmp_PP+0x6>
    7c82:	80 e0       	ldi	r24, 0x00	; 0
		if(prb(s1) < prb(s2)) return -1;
		s1++;
		s2++;
	}
	return 0;	
}
    7c84:	08 95       	ret

00007c86 <SeekTagFORM>:
	return 0;
}
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
    7c86:	28 2f       	mov	r18, r24
	static uint8_t match;
	switch(match) {
    7c88:	90 91 f8 01 	lds	r25, 0x01F8
    7c8c:	94 30       	cpi	r25, 0x04	; 4
    7c8e:	51 f1       	breq	.+84     	; 0x7ce4 <SeekTagFORM+0x5e>
    7c90:	95 30       	cpi	r25, 0x05	; 5
    7c92:	48 f4       	brcc	.+18     	; 0x7ca6 <SeekTagFORM+0x20>
    7c94:	91 30       	cpi	r25, 0x01	; 1
    7c96:	a1 f0       	breq	.+40     	; 0x7cc0 <SeekTagFORM+0x3a>
    7c98:	91 30       	cpi	r25, 0x01	; 1
    7c9a:	70 f0       	brcs	.+28     	; 0x7cb8 <SeekTagFORM+0x32>
    7c9c:	92 30       	cpi	r25, 0x02	; 2
    7c9e:	b1 f0       	breq	.+44     	; 0x7ccc <SeekTagFORM+0x46>
    7ca0:	93 30       	cpi	r25, 0x03	; 3
    7ca2:	d9 f5       	brne	.+118    	; 0x7d1a <SeekTagFORM+0x94>
    7ca4:	19 c0       	rjmp	.+50     	; 0x7cd8 <SeekTagFORM+0x52>
    7ca6:	96 30       	cpi	r25, 0x06	; 6
    7ca8:	49 f1       	breq	.+82     	; 0x7cfc <SeekTagFORM+0x76>
    7caa:	96 30       	cpi	r25, 0x06	; 6
    7cac:	08 f1       	brcs	.+66     	; 0x7cf0 <SeekTagFORM+0x6a>
    7cae:	97 30       	cpi	r25, 0x07	; 7
    7cb0:	49 f1       	breq	.+82     	; 0x7d04 <SeekTagFORM+0x7e>
    7cb2:	98 30       	cpi	r25, 0x08	; 8
    7cb4:	91 f5       	brne	.+100    	; 0x7d1a <SeekTagFORM+0x94>
    7cb6:	2a c0       	rjmp	.+84     	; 0x7d0c <SeekTagFORM+0x86>
		case 0:
			if(ch=='<') match = 1;
    7cb8:	8c 33       	cpi	r24, 0x3C	; 60
    7cba:	99 f5       	brne	.+102    	; 0x7d22 <SeekTagFORM+0x9c>
    7cbc:	81 e0       	ldi	r24, 0x01	; 1
    7cbe:	1b c0       	rjmp	.+54     	; 0x7cf6 <SeekTagFORM+0x70>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    7cc0:	86 34       	cpi	r24, 0x46	; 70
    7cc2:	11 f0       	breq	.+4      	; 0x7cc8 <SeekTagFORM+0x42>
    7cc4:	86 36       	cpi	r24, 0x66	; 102
    7cc6:	49 f5       	brne	.+82     	; 0x7d1a <SeekTagFORM+0x94>
    7cc8:	82 e0       	ldi	r24, 0x02	; 2
    7cca:	15 c0       	rjmp	.+42     	; 0x7cf6 <SeekTagFORM+0x70>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    7ccc:	8f 34       	cpi	r24, 0x4F	; 79
    7cce:	11 f0       	breq	.+4      	; 0x7cd4 <SeekTagFORM+0x4e>
    7cd0:	8f 36       	cpi	r24, 0x6F	; 111
    7cd2:	19 f5       	brne	.+70     	; 0x7d1a <SeekTagFORM+0x94>
    7cd4:	83 e0       	ldi	r24, 0x03	; 3
    7cd6:	0f c0       	rjmp	.+30     	; 0x7cf6 <SeekTagFORM+0x70>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    7cd8:	82 35       	cpi	r24, 0x52	; 82
    7cda:	11 f0       	breq	.+4      	; 0x7ce0 <SeekTagFORM+0x5a>
    7cdc:	82 37       	cpi	r24, 0x72	; 114
    7cde:	e9 f4       	brne	.+58     	; 0x7d1a <SeekTagFORM+0x94>
    7ce0:	84 e0       	ldi	r24, 0x04	; 4
    7ce2:	09 c0       	rjmp	.+18     	; 0x7cf6 <SeekTagFORM+0x70>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    7ce4:	8d 34       	cpi	r24, 0x4D	; 77
    7ce6:	11 f0       	breq	.+4      	; 0x7cec <SeekTagFORM+0x66>
    7ce8:	8d 36       	cpi	r24, 0x6D	; 109
    7cea:	b9 f4       	brne	.+46     	; 0x7d1a <SeekTagFORM+0x94>
    7cec:	85 e0       	ldi	r24, 0x05	; 5
    7cee:	03 c0       	rjmp	.+6      	; 0x7cf6 <SeekTagFORM+0x70>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    7cf0:	80 32       	cpi	r24, 0x20	; 32
    7cf2:	99 f4       	brne	.+38     	; 0x7d1a <SeekTagFORM+0x94>
    7cf4:	86 e0       	ldi	r24, 0x06	; 6
    7cf6:	80 93 f8 01 	sts	0x01F8, r24
    7cfa:	11 c0       	rjmp	.+34     	; 0x7d1e <SeekTagFORM+0x98>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    7cfc:	8e 33       	cpi	r24, 0x3E	; 62
    7cfe:	89 f4       	brne	.+34     	; 0x7d22 <SeekTagFORM+0x9c>
    7d00:	87 e0       	ldi	r24, 0x07	; 7
    7d02:	f9 cf       	rjmp	.-14     	; 0x7cf6 <SeekTagFORM+0x70>
			break;
		case 7:
			if(ch=='\r') match = 8;
    7d04:	8d 30       	cpi	r24, 0x0D	; 13
    7d06:	49 f4       	brne	.+18     	; 0x7d1a <SeekTagFORM+0x94>
    7d08:	88 e0       	ldi	r24, 0x08	; 8
    7d0a:	f5 cf       	rjmp	.-22     	; 0x7cf6 <SeekTagFORM+0x70>
			else match = 0;
			break;
		case 8:
			match = 0;
    7d0c:	10 92 f8 01 	sts	0x01F8, r1
    7d10:	80 e0       	ldi	r24, 0x00	; 0
    7d12:	2a 30       	cpi	r18, 0x0A	; 10
    7d14:	39 f4       	brne	.+14     	; 0x7d24 <SeekTagFORM+0x9e>
    7d16:	81 e0       	ldi	r24, 0x01	; 1
    7d18:	08 95       	ret
			if(ch=='\n') return 1;
			break;
		default:
			match = 0;
    7d1a:	10 92 f8 01 	sts	0x01F8, r1
    7d1e:	80 e0       	ldi	r24, 0x00	; 0
    7d20:	08 95       	ret
    7d22:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 0;

}
    7d24:	08 95       	ret

00007d26 <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    7d26:	90 91 f7 01 	lds	r25, 0x01F7
    7d2a:	94 30       	cpi	r25, 0x04	; 4
    7d2c:	41 f1       	breq	.+80     	; 0x7d7e <SeekTagA_HREF+0x58>
    7d2e:	95 30       	cpi	r25, 0x05	; 5
    7d30:	48 f4       	brcc	.+18     	; 0x7d44 <SeekTagA_HREF+0x1e>
    7d32:	91 30       	cpi	r25, 0x01	; 1
    7d34:	a1 f0       	breq	.+40     	; 0x7d5e <SeekTagA_HREF+0x38>
    7d36:	91 30       	cpi	r25, 0x01	; 1
    7d38:	70 f0       	brcs	.+28     	; 0x7d56 <SeekTagA_HREF+0x30>
    7d3a:	92 30       	cpi	r25, 0x02	; 2
    7d3c:	b1 f0       	breq	.+44     	; 0x7d6a <SeekTagA_HREF+0x44>
    7d3e:	93 30       	cpi	r25, 0x03	; 3
    7d40:	e1 f5       	brne	.+120    	; 0x7dba <SeekTagA_HREF+0x94>
    7d42:	17 c0       	rjmp	.+46     	; 0x7d72 <SeekTagA_HREF+0x4c>
    7d44:	96 30       	cpi	r25, 0x06	; 6
    7d46:	39 f1       	breq	.+78     	; 0x7d96 <SeekTagA_HREF+0x70>
    7d48:	96 30       	cpi	r25, 0x06	; 6
    7d4a:	f8 f0       	brcs	.+62     	; 0x7d8a <SeekTagA_HREF+0x64>
    7d4c:	97 30       	cpi	r25, 0x07	; 7
    7d4e:	49 f1       	breq	.+82     	; 0x7da2 <SeekTagA_HREF+0x7c>
    7d50:	98 30       	cpi	r25, 0x08	; 8
    7d52:	99 f5       	brne	.+102    	; 0x7dba <SeekTagA_HREF+0x94>
    7d54:	2c c0       	rjmp	.+88     	; 0x7dae <SeekTagA_HREF+0x88>
		case 0:
			if(ch=='<') match = 1;
    7d56:	8c 33       	cpi	r24, 0x3C	; 60
    7d58:	a1 f5       	brne	.+104    	; 0x7dc2 <SeekTagA_HREF+0x9c>
    7d5a:	81 e0       	ldi	r24, 0x01	; 1
    7d5c:	25 c0       	rjmp	.+74     	; 0x7da8 <SeekTagA_HREF+0x82>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    7d5e:	81 34       	cpi	r24, 0x41	; 65
    7d60:	11 f0       	breq	.+4      	; 0x7d66 <SeekTagA_HREF+0x40>
    7d62:	81 36       	cpi	r24, 0x61	; 97
    7d64:	51 f5       	brne	.+84     	; 0x7dba <SeekTagA_HREF+0x94>
    7d66:	82 e0       	ldi	r24, 0x02	; 2
    7d68:	1f c0       	rjmp	.+62     	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    7d6a:	80 32       	cpi	r24, 0x20	; 32
    7d6c:	31 f5       	brne	.+76     	; 0x7dba <SeekTagA_HREF+0x94>
    7d6e:	83 e0       	ldi	r24, 0x03	; 3
    7d70:	1b c0       	rjmp	.+54     	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    7d72:	88 34       	cpi	r24, 0x48	; 72
    7d74:	11 f0       	breq	.+4      	; 0x7d7a <SeekTagA_HREF+0x54>
    7d76:	88 36       	cpi	r24, 0x68	; 104
    7d78:	01 f5       	brne	.+64     	; 0x7dba <SeekTagA_HREF+0x94>
    7d7a:	84 e0       	ldi	r24, 0x04	; 4
    7d7c:	15 c0       	rjmp	.+42     	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    7d7e:	82 35       	cpi	r24, 0x52	; 82
    7d80:	11 f0       	breq	.+4      	; 0x7d86 <SeekTagA_HREF+0x60>
    7d82:	82 37       	cpi	r24, 0x72	; 114
    7d84:	d1 f4       	brne	.+52     	; 0x7dba <SeekTagA_HREF+0x94>
    7d86:	85 e0       	ldi	r24, 0x05	; 5
    7d88:	0f c0       	rjmp	.+30     	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    7d8a:	85 34       	cpi	r24, 0x45	; 69
    7d8c:	11 f0       	breq	.+4      	; 0x7d92 <SeekTagA_HREF+0x6c>
    7d8e:	85 36       	cpi	r24, 0x65	; 101
    7d90:	a1 f4       	brne	.+40     	; 0x7dba <SeekTagA_HREF+0x94>
    7d92:	86 e0       	ldi	r24, 0x06	; 6
    7d94:	09 c0       	rjmp	.+18     	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    7d96:	86 34       	cpi	r24, 0x46	; 70
    7d98:	11 f0       	breq	.+4      	; 0x7d9e <SeekTagA_HREF+0x78>
    7d9a:	86 36       	cpi	r24, 0x66	; 102
    7d9c:	71 f4       	brne	.+28     	; 0x7dba <SeekTagA_HREF+0x94>
    7d9e:	87 e0       	ldi	r24, 0x07	; 7
    7da0:	03 c0       	rjmp	.+6      	; 0x7da8 <SeekTagA_HREF+0x82>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    7da2:	82 32       	cpi	r24, 0x22	; 34
    7da4:	71 f4       	brne	.+28     	; 0x7dc2 <SeekTagA_HREF+0x9c>
    7da6:	88 e0       	ldi	r24, 0x08	; 8
    7da8:	80 93 f7 01 	sts	0x01F7, r24
    7dac:	08 c0       	rjmp	.+16     	; 0x7dbe <SeekTagA_HREF+0x98>
			break;
		case 8:
			if(ch=='\"'){
    7dae:	82 32       	cpi	r24, 0x22	; 34
    7db0:	41 f4       	brne	.+16     	; 0x7dc2 <SeekTagA_HREF+0x9c>
				match = 0;
    7db2:	10 92 f7 01 	sts	0x01F7, r1
    7db6:	81 e0       	ldi	r24, 0x01	; 1
    7db8:	08 95       	ret
				return 1;
			}
			break;
		default:
			match = 0;
    7dba:	10 92 f7 01 	sts	0x01F7, r1
    7dbe:	80 e0       	ldi	r24, 0x00	; 0
    7dc0:	08 95       	ret
    7dc2:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 0;
}
    7dc4:	08 95       	ret

00007dc6 <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    7dc6:	90 91 f6 01 	lds	r25, 0x01F6
    7dca:	94 30       	cpi	r25, 0x04	; 4
    7dcc:	81 f1       	breq	.+96     	; 0x7e2e <SeekTagIMG_SRC+0x68>
    7dce:	95 30       	cpi	r25, 0x05	; 5
    7dd0:	50 f4       	brcc	.+20     	; 0x7de6 <SeekTagIMG_SRC+0x20>
    7dd2:	91 30       	cpi	r25, 0x01	; 1
    7dd4:	d1 f0       	breq	.+52     	; 0x7e0a <SeekTagIMG_SRC+0x44>
    7dd6:	91 30       	cpi	r25, 0x01	; 1
    7dd8:	a0 f0       	brcs	.+40     	; 0x7e02 <SeekTagIMG_SRC+0x3c>
    7dda:	92 30       	cpi	r25, 0x02	; 2
    7ddc:	e1 f0       	breq	.+56     	; 0x7e16 <SeekTagIMG_SRC+0x50>
    7dde:	93 30       	cpi	r25, 0x03	; 3
    7de0:	09 f0       	breq	.+2      	; 0x7de4 <SeekTagIMG_SRC+0x1e>
    7de2:	47 c0       	rjmp	.+142    	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7de4:	1e c0       	rjmp	.+60     	; 0x7e22 <SeekTagIMG_SRC+0x5c>
    7de6:	97 30       	cpi	r25, 0x07	; 7
    7de8:	91 f1       	breq	.+100    	; 0x7e4e <SeekTagIMG_SRC+0x88>
    7dea:	98 30       	cpi	r25, 0x08	; 8
    7dec:	28 f4       	brcc	.+10     	; 0x7df8 <SeekTagIMG_SRC+0x32>
    7dee:	95 30       	cpi	r25, 0x05	; 5
    7df0:	11 f1       	breq	.+68     	; 0x7e36 <SeekTagIMG_SRC+0x70>
    7df2:	96 30       	cpi	r25, 0x06	; 6
    7df4:	f1 f5       	brne	.+124    	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7df6:	25 c0       	rjmp	.+74     	; 0x7e42 <SeekTagIMG_SRC+0x7c>
    7df8:	98 30       	cpi	r25, 0x08	; 8
    7dfa:	79 f1       	breq	.+94     	; 0x7e5a <SeekTagIMG_SRC+0x94>
    7dfc:	99 30       	cpi	r25, 0x09	; 9
    7dfe:	c9 f5       	brne	.+114    	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e00:	32 c0       	rjmp	.+100    	; 0x7e66 <SeekTagIMG_SRC+0xa0>
		case 0:
			if(ch=='<') match = 1;
    7e02:	8c 33       	cpi	r24, 0x3C	; 60
    7e04:	d1 f5       	brne	.+116    	; 0x7e7a <SeekTagIMG_SRC+0xb4>
    7e06:	81 e0       	ldi	r24, 0x01	; 1
    7e08:	2b c0       	rjmp	.+86     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    7e0a:	89 34       	cpi	r24, 0x49	; 73
    7e0c:	11 f0       	breq	.+4      	; 0x7e12 <SeekTagIMG_SRC+0x4c>
    7e0e:	89 36       	cpi	r24, 0x69	; 105
    7e10:	81 f5       	brne	.+96     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e12:	82 e0       	ldi	r24, 0x02	; 2
    7e14:	25 c0       	rjmp	.+74     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    7e16:	8d 34       	cpi	r24, 0x4D	; 77
    7e18:	11 f0       	breq	.+4      	; 0x7e1e <SeekTagIMG_SRC+0x58>
    7e1a:	8d 36       	cpi	r24, 0x6D	; 109
    7e1c:	51 f5       	brne	.+84     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e1e:	83 e0       	ldi	r24, 0x03	; 3
    7e20:	1f c0       	rjmp	.+62     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    7e22:	87 34       	cpi	r24, 0x47	; 71
    7e24:	11 f0       	breq	.+4      	; 0x7e2a <SeekTagIMG_SRC+0x64>
    7e26:	87 36       	cpi	r24, 0x67	; 103
    7e28:	21 f5       	brne	.+72     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e2a:	84 e0       	ldi	r24, 0x04	; 4
    7e2c:	19 c0       	rjmp	.+50     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    7e2e:	80 32       	cpi	r24, 0x20	; 32
    7e30:	01 f5       	brne	.+64     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e32:	85 e0       	ldi	r24, 0x05	; 5
    7e34:	15 c0       	rjmp	.+42     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    7e36:	83 35       	cpi	r24, 0x53	; 83
    7e38:	11 f0       	breq	.+4      	; 0x7e3e <SeekTagIMG_SRC+0x78>
    7e3a:	83 37       	cpi	r24, 0x73	; 115
    7e3c:	d1 f4       	brne	.+52     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e3e:	86 e0       	ldi	r24, 0x06	; 6
    7e40:	0f c0       	rjmp	.+30     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    7e42:	82 35       	cpi	r24, 0x52	; 82
    7e44:	11 f0       	breq	.+4      	; 0x7e4a <SeekTagIMG_SRC+0x84>
    7e46:	82 37       	cpi	r24, 0x72	; 114
    7e48:	a1 f4       	brne	.+40     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e4a:	87 e0       	ldi	r24, 0x07	; 7
    7e4c:	09 c0       	rjmp	.+18     	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    7e4e:	83 34       	cpi	r24, 0x43	; 67
    7e50:	11 f0       	breq	.+4      	; 0x7e56 <SeekTagIMG_SRC+0x90>
    7e52:	83 36       	cpi	r24, 0x63	; 99
    7e54:	71 f4       	brne	.+28     	; 0x7e72 <SeekTagIMG_SRC+0xac>
    7e56:	88 e0       	ldi	r24, 0x08	; 8
    7e58:	03 c0       	rjmp	.+6      	; 0x7e60 <SeekTagIMG_SRC+0x9a>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    7e5a:	82 32       	cpi	r24, 0x22	; 34
    7e5c:	71 f4       	brne	.+28     	; 0x7e7a <SeekTagIMG_SRC+0xb4>
    7e5e:	89 e0       	ldi	r24, 0x09	; 9
    7e60:	80 93 f6 01 	sts	0x01F6, r24
    7e64:	08 c0       	rjmp	.+16     	; 0x7e76 <SeekTagIMG_SRC+0xb0>
			break;
		case 9:
			if(ch=='\"'){
    7e66:	82 32       	cpi	r24, 0x22	; 34
    7e68:	41 f4       	brne	.+16     	; 0x7e7a <SeekTagIMG_SRC+0xb4>
				match = 0;
    7e6a:	10 92 f6 01 	sts	0x01F6, r1
    7e6e:	81 e0       	ldi	r24, 0x01	; 1
    7e70:	08 95       	ret
				return 1;
			}
			break;
		default:
			match = 0;
    7e72:	10 92 f6 01 	sts	0x01F6, r1
    7e76:	80 e0       	ldi	r24, 0x00	; 0
    7e78:	08 95       	ret
    7e7a:	80 e0       	ldi	r24, 0x00	; 0
	}
	return 0;
}
    7e7c:	08 95       	ret

00007e7e <WebClose>:
// ~~~~~~~~~~~~~~~~~~
void WebClose(void){
	Web_POST = 0;
    7e7e:	10 92 da 08 	sts	0x08DA, r1
	WebMode = 254;
    7e82:	8e ef       	ldi	r24, 0xFE	; 254
    7e84:	80 93 d5 01 	sts	0x01D5, r24
}
    7e88:	08 95       	ret

00007e8a <IsWebSession>:
uint8_t IsWebSession(void){
	return WebSession;
}
    7e8a:	80 91 e9 08 	lds	r24, 0x08E9
    7e8e:	08 95       	ret

00007e90 <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    7e90:	81 e0       	ldi	r24, 0x01	; 1
    7e92:	80 93 b7 07 	sts	0x07B7, r24
}
    7e96:	08 95       	ret

00007e98 <EM_InitFIFO>:
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
    7e98:	8f ef       	ldi	r24, 0xFF	; 255
    7e9a:	80 93 dd 08 	sts	0x08DD, r24
	EM_RX_FIFO_End = 255;
    7e9e:	80 93 a0 0c 	sts	0x0CA0, r24
	EMeter_RxCharN = 0;
    7ea2:	10 92 a7 0c 	sts	0x0CA7, r1
    7ea6:	10 92 a6 0c 	sts	0x0CA6, r1
//	EM_RX_FIFOOverFlow = 0;
//	EM_RX_FIFOMax = 0;
}
    7eaa:	08 95       	ret

00007eac <EM_GetByteFromFIFO>:
// ~~~~~~~~~~~
void EM_GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    7eac:	0f 93       	push	r16
    7eae:	1f 93       	push	r17
    7eb0:	cf 93       	push	r28
    7eb2:	df 93       	push	r29
    7eb4:	8c 01       	movw	r16, r24
    7eb6:	eb 01       	movw	r28, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7eb8:	88 81       	ld	r24, Y
    7eba:	84 17       	cp	r24, r20
    7ebc:	08 f0       	brcs	.+2      	; 0x7ec0 <EM_GetByteFromFIFO+0x14>
		*Index = 0;
    7ebe:	18 82       	st	Y, r1
		//TODO  
	}	

	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    7ec0:	90 91 dd 08 	lds	r25, 0x08DD
    7ec4:	80 91 a0 0c 	lds	r24, 0x0CA0
    7ec8:	89 17       	cp	r24, r25
    7eca:	78 f5       	brcc	.+94     	; 0x7f2a <EM_GetByteFromFIFO+0x7e>
		if((EM_RX_FIFO_End != 255)&&(EM_RX_FIFO_End != 255))			
    7ecc:	80 91 a0 0c 	lds	r24, 0x0CA0
    7ed0:	8f 3f       	cpi	r24, 0xFF	; 255
    7ed2:	c1 f0       	breq	.+48     	; 0x7f04 <EM_GetByteFromFIFO+0x58>
    7ed4:	80 91 a0 0c 	lds	r24, 0x0CA0
    7ed8:	8f 3f       	cpi	r24, 0xFF	; 255
    7eda:	a1 f0       	breq	.+40     	; 0x7f04 <EM_GetByteFromFIFO+0x58>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    7edc:	80 91 d8 09 	lds	r24, 0x09D8
    7ee0:	20 91 dd 08 	lds	r18, 0x08DD
    7ee4:	40 91 a0 0c 	lds	r20, 0x0CA0
    7ee8:	90 e0       	ldi	r25, 0x00	; 0
    7eea:	30 e0       	ldi	r19, 0x00	; 0
    7eec:	24 1b       	sub	r18, r20
    7eee:	31 09       	sbc	r19, r1
    7ef0:	82 17       	cp	r24, r18
    7ef2:	93 07       	cpc	r25, r19
    7ef4:	3c f4       	brge	.+14     	; 0x7f04 <EM_GetByteFromFIFO+0x58>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    7ef6:	80 91 dd 08 	lds	r24, 0x08DD
    7efa:	90 91 a0 0c 	lds	r25, 0x0CA0
    7efe:	89 1b       	sub	r24, r25
    7f00:	80 93 d8 09 	sts	0x09D8, r24
		EM_RX_FIFO_End++;
    7f04:	80 91 a0 0c 	lds	r24, 0x0CA0
    7f08:	8f 5f       	subi	r24, 0xFF	; 255
    7f0a:	80 93 a0 0c 	sts	0x0CA0, r24
		ReadBuf[*Index] = EM_RX_FIFO[EM_RX_FIFO_End];
    7f0e:	e0 91 a0 0c 	lds	r30, 0x0CA0
    7f12:	88 81       	ld	r24, Y
    7f14:	d8 01       	movw	r26, r16
    7f16:	a8 0f       	add	r26, r24
    7f18:	b1 1d       	adc	r27, r1
    7f1a:	f0 e0       	ldi	r31, 0x00	; 0
    7f1c:	e4 58       	subi	r30, 0x84	; 132
    7f1e:	fc 4f       	sbci	r31, 0xFC	; 252
    7f20:	80 81       	ld	r24, Z
    7f22:	8c 93       	st	X, r24
		*Index=*Index+1;
    7f24:	88 81       	ld	r24, Y
    7f26:	8f 5f       	subi	r24, 0xFF	; 255
    7f28:	88 83       	st	Y, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    7f2a:	90 91 a0 0c 	lds	r25, 0x0CA0
    7f2e:	80 91 dd 08 	lds	r24, 0x08DD
    7f32:	89 17       	cp	r24, r25
    7f34:	c0 f5       	brcc	.+112    	; 0x7fa6 <EM_GetByteFromFIFO+0xfa>
		if((EM_RX_FIFO_End != 255)&&(EM_RX_FIFO_End != 255))
    7f36:	80 91 a0 0c 	lds	r24, 0x0CA0
    7f3a:	8f 3f       	cpi	r24, 0xFF	; 255
    7f3c:	d9 f0       	breq	.+54     	; 0x7f74 <EM_GetByteFromFIFO+0xc8>
    7f3e:	80 91 a0 0c 	lds	r24, 0x0CA0
    7f42:	8f 3f       	cpi	r24, 0xFF	; 255
    7f44:	b9 f0       	breq	.+46     	; 0x7f74 <EM_GetByteFromFIFO+0xc8>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End  + EM_RX_FIFO_Begin))
    7f46:	80 91 d8 09 	lds	r24, 0x09D8
    7f4a:	40 91 a0 0c 	lds	r20, 0x0CA0
    7f4e:	20 91 dd 08 	lds	r18, 0x08DD
    7f52:	90 e0       	ldi	r25, 0x00	; 0
    7f54:	30 e0       	ldi	r19, 0x00	; 0
    7f56:	26 50       	subi	r18, 0x06	; 6
    7f58:	3f 4f       	sbci	r19, 0xFF	; 255
    7f5a:	24 1b       	sub	r18, r20
    7f5c:	31 09       	sbc	r19, r1
    7f5e:	82 17       	cp	r24, r18
    7f60:	93 07       	cpc	r25, r19
    7f62:	44 f4       	brge	.+16     	; 0x7f74 <EM_GetByteFromFIFO+0xc8>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End  + EM_RX_FIFO_Begin;
    7f64:	80 91 dd 08 	lds	r24, 0x08DD
    7f68:	90 91 a0 0c 	lds	r25, 0x0CA0
    7f6c:	86 50       	subi	r24, 0x06	; 6
    7f6e:	89 1b       	sub	r24, r25
    7f70:	80 93 d8 09 	sts	0x09D8, r24
		EM_RX_FIFO_End++;
    7f74:	80 91 a0 0c 	lds	r24, 0x0CA0
    7f78:	8f 5f       	subi	r24, 0xFF	; 255
    7f7a:	80 93 a0 0c 	sts	0x0CA0, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    7f7e:	80 91 a0 0c 	lds	r24, 0x0CA0
    7f82:	8a 3f       	cpi	r24, 0xFA	; 250
    7f84:	10 f0       	brcs	.+4      	; 0x7f8a <EM_GetByteFromFIFO+0xde>
    7f86:	10 92 a0 0c 	sts	0x0CA0, r1
		ReadBuf[*Index] = EM_RX_FIFO[EM_RX_FIFO_End];
    7f8a:	e0 91 a0 0c 	lds	r30, 0x0CA0
    7f8e:	88 81       	ld	r24, Y
    7f90:	08 0f       	add	r16, r24
    7f92:	11 1d       	adc	r17, r1
    7f94:	f0 e0       	ldi	r31, 0x00	; 0
    7f96:	e4 58       	subi	r30, 0x84	; 132
    7f98:	fc 4f       	sbci	r31, 0xFC	; 252
    7f9a:	80 81       	ld	r24, Z
    7f9c:	f8 01       	movw	r30, r16
    7f9e:	80 83       	st	Z, r24
		*Index=*Index+1;
    7fa0:	88 81       	ld	r24, Y
    7fa2:	8f 5f       	subi	r24, 0xFF	; 255
    7fa4:	88 83       	st	Y, r24
	}
}
    7fa6:	df 91       	pop	r29
    7fa8:	cf 91       	pop	r28
    7faa:	1f 91       	pop	r17
    7fac:	0f 91       	pop	r16
    7fae:	08 95       	ret

00007fb0 <EM_GetDataFromFIFO>:
// ~~~~~~~~~~~
uint8_t EM_GetDataFromFIFO(const uint8_t Amount){
    7fb0:	1f 93       	push	r17
    7fb2:	cf 93       	push	r28
    7fb4:	df 93       	push	r29
    7fb6:	18 2f       	mov	r17, r24

	while(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
		EM_GetByteFromFIFO((uint8_t *)EMeter_RxStr, (uint8_t *)&EMeter_RxCharN, EM_RX_SIZE);
		if(EMeter_RxCharN >= Amount){
    7fb8:	c8 2f       	mov	r28, r24
    7fba:	d0 e0       	ldi	r29, 0x00	; 0
    7fbc:	13 c0       	rjmp	.+38     	; 0x7fe4 <EM_GetDataFromFIFO+0x34>
}
// ~~~~~~~~~~~
uint8_t EM_GetDataFromFIFO(const uint8_t Amount){

	while(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
		EM_GetByteFromFIFO((uint8_t *)EMeter_RxStr, (uint8_t *)&EMeter_RxCharN, EM_RX_SIZE);
    7fbe:	89 eb       	ldi	r24, 0xB9	; 185
    7fc0:	96 e0       	ldi	r25, 0x06	; 6
    7fc2:	66 ea       	ldi	r22, 0xA6	; 166
    7fc4:	7c e0       	ldi	r23, 0x0C	; 12
    7fc6:	4e ef       	ldi	r20, 0xFE	; 254
    7fc8:	0e 94 56 3f 	call	0x7eac	; 0x7eac <EM_GetByteFromFIFO>
		if(EMeter_RxCharN >= Amount){
    7fcc:	80 91 a6 0c 	lds	r24, 0x0CA6
    7fd0:	90 91 a7 0c 	lds	r25, 0x0CA7
    7fd4:	8c 17       	cp	r24, r28
    7fd6:	9d 07       	cpc	r25, r29
    7fd8:	28 f0       	brcs	.+10     	; 0x7fe4 <EM_GetDataFromFIFO+0x34>
			EMeter_RxCharN = 0;
    7fda:	10 92 a7 0c 	sts	0x0CA7, r1
    7fde:	10 92 a6 0c 	sts	0x0CA6, r1
    7fe2:	0b c0       	rjmp	.+22     	; 0x7ffa <EM_GetDataFromFIFO+0x4a>
	}
}
// ~~~~~~~~~~~
uint8_t EM_GetDataFromFIFO(const uint8_t Amount){

	while(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    7fe4:	90 91 dd 08 	lds	r25, 0x08DD
    7fe8:	80 91 a0 0c 	lds	r24, 0x0CA0
    7fec:	98 17       	cp	r25, r24
    7fee:	39 f7       	brne	.-50     	; 0x7fbe <EM_GetDataFromFIFO+0xe>
		if(EMeter_RxCharN >= Amount){
			EMeter_RxCharN = 0;
			return Amount;
		}
	}//while
	return EMeter_RxCharN;
    7ff0:	80 91 a6 0c 	lds	r24, 0x0CA6
    7ff4:	90 91 a7 0c 	lds	r25, 0x0CA7
    7ff8:	18 2f       	mov	r17, r24
}
    7ffa:	81 2f       	mov	r24, r17
    7ffc:	df 91       	pop	r29
    7ffe:	cf 91       	pop	r28
    8000:	1f 91       	pop	r17
    8002:	08 95       	ret

00008004 <EM_SetUARTParam>:
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    8004:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    8008:	80 93 d6 09 	sts	0x09D6, r24

	switch(EM_UART_Rate){
    800c:	84 30       	cpi	r24, 0x04	; 4
    800e:	f9 f0       	breq	.+62     	; 0x804e <EM_SetUARTParam+0x4a>
    8010:	85 30       	cpi	r24, 0x05	; 5
    8012:	38 f4       	brcc	.+14     	; 0x8022 <EM_SetUARTParam+0x1e>
    8014:	81 30       	cpi	r24, 0x01	; 1
    8016:	99 f0       	breq	.+38     	; 0x803e <EM_SetUARTParam+0x3a>
    8018:	81 30       	cpi	r24, 0x01	; 1
    801a:	60 f0       	brcs	.+24     	; 0x8034 <EM_SetUARTParam+0x30>
    801c:	82 30       	cpi	r24, 0x02	; 2
    801e:	59 f5       	brne	.+86     	; 0x8076 <EM_SetUARTParam+0x72>
    8020:	12 c0       	rjmp	.+36     	; 0x8046 <EM_SetUARTParam+0x42>
    8022:	86 30       	cpi	r24, 0x06	; 6
    8024:	e1 f0       	breq	.+56     	; 0x805e <EM_SetUARTParam+0x5a>
    8026:	86 30       	cpi	r24, 0x06	; 6
    8028:	b0 f0       	brcs	.+44     	; 0x8056 <EM_SetUARTParam+0x52>
    802a:	87 30       	cpi	r24, 0x07	; 7
    802c:	e1 f0       	breq	.+56     	; 0x8066 <EM_SetUARTParam+0x62>
    802e:	88 30       	cpi	r24, 0x08	; 8
    8030:	11 f5       	brne	.+68     	; 0x8076 <EM_SetUARTParam+0x72>
    8032:	1d c0       	rjmp	.+58     	; 0x806e <EM_SetUARTParam+0x6a>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    8034:	83 e0       	ldi	r24, 0x03	; 3
    8036:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    803a:	82 e4       	ldi	r24, 0x42	; 66
    803c:	1f c0       	rjmp	.+62     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    803e:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    8042:	80 ea       	ldi	r24, 0xA0	; 160
    8044:	1b c0       	rjmp	.+54     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    8046:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    804a:	8f ec       	ldi	r24, 0xCF	; 207
    804c:	17 c0       	rjmp	.+46     	; 0x807c <EM_SetUARTParam+0x78>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    804e:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    8052:	84 e4       	ldi	r24, 0x44	; 68
    8054:	13 c0       	rjmp	.+38     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    8056:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    805a:	83 e3       	ldi	r24, 0x33	; 51
    805c:	0f c0       	rjmp	.+30     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    805e:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    8062:	82 e2       	ldi	r24, 0x22	; 34
    8064:	0b c0       	rjmp	.+22     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    8066:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    806a:	89 e1       	ldi	r24, 0x19	; 25
    806c:	07 c0       	rjmp	.+14     	; 0x807c <EM_SetUARTParam+0x78>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    806e:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    8072:	80 e1       	ldi	r24, 0x10	; 16
    8074:	03 c0       	rjmp	.+6      	; 0x807c <EM_SetUARTParam+0x78>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    8076:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    807a:	87 e6       	ldi	r24, 0x67	; 103
    807c:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    8080:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    8084:	89 2f       	mov	r24, r25
    8086:	83 70       	andi	r24, 0x03	; 3
    8088:	80 93 89 05 	sts	0x0589, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    808c:	81 30       	cpi	r24, 0x01	; 1
    808e:	39 f0       	breq	.+14     	; 0x809e <EM_SetUARTParam+0x9a>
    8090:	81 30       	cpi	r24, 0x01	; 1
    8092:	68 f0       	brcs	.+26     	; 0x80ae <EM_SetUARTParam+0xaa>
    8094:	82 30       	cpi	r24, 0x02	; 2
    8096:	39 f0       	breq	.+14     	; 0x80a6 <EM_SetUARTParam+0xa2>
    8098:	83 30       	cpi	r24, 0x03	; 3
    809a:	69 f4       	brne	.+26     	; 0x80b6 <EM_SetUARTParam+0xb2>
    809c:	08 c0       	rjmp	.+16     	; 0x80ae <EM_SetUARTParam+0xaa>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    809e:	80 91 9d 00 	lds	r24, 0x009D
    80a2:	80 62       	ori	r24, 0x20	; 32
    80a4:	06 c0       	rjmp	.+12     	; 0x80b2 <EM_SetUARTParam+0xae>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    80a6:	80 91 9d 00 	lds	r24, 0x009D
    80aa:	80 63       	ori	r24, 0x30	; 48
    80ac:	02 c0       	rjmp	.+4      	; 0x80b2 <EM_SetUARTParam+0xae>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    80ae:	80 91 9d 00 	lds	r24, 0x009D
    80b2:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    80b6:	89 2f       	mov	r24, r25
    80b8:	86 95       	lsr	r24
    80ba:	86 95       	lsr	r24
    80bc:	81 70       	andi	r24, 0x01	; 1
    80be:	80 93 b3 08 	sts	0x08B3, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    80c2:	88 23       	and	r24, r24
    80c4:	19 f0       	breq	.+6      	; 0x80cc <EM_SetUARTParam+0xc8>
    80c6:	81 30       	cpi	r24, 0x01	; 1
    80c8:	49 f4       	brne	.+18     	; 0x80dc <EM_SetUARTParam+0xd8>
    80ca:	03 c0       	rjmp	.+6      	; 0x80d2 <EM_SetUARTParam+0xce>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    80cc:	80 91 9d 00 	lds	r24, 0x009D
    80d0:	03 c0       	rjmp	.+6      	; 0x80d8 <EM_SetUARTParam+0xd4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    80d2:	80 91 9d 00 	lds	r24, 0x009D
    80d6:	88 60       	ori	r24, 0x08	; 8
    80d8:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    80dc:	96 95       	lsr	r25
    80de:	96 95       	lsr	r25
    80e0:	96 95       	lsr	r25
    80e2:	93 70       	andi	r25, 0x03	; 3
    80e4:	90 93 dc 09 	sts	0x09DC, r25
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    80e8:	91 30       	cpi	r25, 0x01	; 1
    80ea:	51 f0       	breq	.+20     	; 0x8100 <EM_SetUARTParam+0xfc>
    80ec:	91 30       	cpi	r25, 0x01	; 1
    80ee:	28 f0       	brcs	.+10     	; 0x80fa <EM_SetUARTParam+0xf6>
    80f0:	92 30       	cpi	r25, 0x02	; 2
    80f2:	51 f0       	breq	.+20     	; 0x8108 <EM_SetUARTParam+0x104>
    80f4:	93 30       	cpi	r25, 0x03	; 3
    80f6:	99 f4       	brne	.+38     	; 0x811e <EM_SetUARTParam+0x11a>
    80f8:	0d c0       	rjmp	.+26     	; 0x8114 <EM_SetUARTParam+0x110>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    80fa:	80 91 9d 00 	lds	r24, 0x009D
    80fe:	07 c0       	rjmp	.+14     	; 0x810e <EM_SetUARTParam+0x10a>
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    8100:	80 91 9d 00 	lds	r24, 0x009D
    8104:	82 60       	ori	r24, 0x02	; 2
    8106:	03 c0       	rjmp	.+6      	; 0x810e <EM_SetUARTParam+0x10a>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    8108:	80 91 9d 00 	lds	r24, 0x009D
    810c:	84 60       	ori	r24, 0x04	; 4
    810e:	80 93 9d 00 	sts	0x009D, r24
    8112:	08 95       	ret
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    8114:	80 91 9d 00 	lds	r24, 0x009D
    8118:	86 60       	ori	r24, 0x06	; 6
    811a:	80 93 9d 00 	sts	0x009D, r24
    811e:	08 95       	ret

00008120 <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    8120:	80 91 e0 09 	lds	r24, 0x09E0
    8124:	88 23       	and	r24, r24
    8126:	19 f1       	breq	.+70     	; 0x816e <EMeter_RX+0x4e>
		char Char = UDR_EMETER;
    8128:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    812c:	80 91 dd 08 	lds	r24, 0x08DD
    8130:	8f 5f       	subi	r24, 0xFF	; 255
    8132:	80 93 dd 08 	sts	0x08DD, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    8136:	80 91 dd 08 	lds	r24, 0x08DD
    813a:	8a 3f       	cpi	r24, 0xFA	; 250
    813c:	10 f0       	brcs	.+4      	; 0x8142 <EMeter_RX+0x22>
    813e:	10 92 dd 08 	sts	0x08DD, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    8142:	e0 91 dd 08 	lds	r30, 0x08DD
    8146:	f0 e0       	ldi	r31, 0x00	; 0
    8148:	e4 58       	subi	r30, 0x84	; 132
    814a:	fc 4f       	sbci	r31, 0xFC	; 252
    814c:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    814e:	90 91 dd 08 	lds	r25, 0x08DD
    8152:	80 91 a0 0c 	lds	r24, 0x0CA0
    8156:	98 17       	cp	r25, r24
    8158:	31 f4       	brne	.+12     	; 0x8166 <EMeter_RX+0x46>
			EM_RX_FIFOOverFlow = 1;
    815a:	81 e0       	ldi	r24, 0x01	; 1
    815c:	80 93 8c 0a 	sts	0x0A8C, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    8160:	8a ef       	ldi	r24, 0xFA	; 250
    8162:	80 93 d8 09 	sts	0x09D8, r24
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    8166:	88 eb       	ldi	r24, 0xB8	; 184
    8168:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    816a:	5e 9a       	sbi	0x0b, 6	; 11
    816c:	08 95       	ret
	}
	//----- Non transparent
	else{

		if(EMeterTypeRAM == LANDIS_GYR_ZMR110){
    816e:	80 91 72 03 	lds	r24, 0x0372
    8172:	81 30       	cpi	r24, 0x01	; 1
    8174:	69 f4       	brne	.+26     	; 0x8190 <EMeter_RX+0x70>
			EM_HalfBufferStart[EMeter_RxCharN] = UDR_EMETER;
    8176:	80 91 a6 0c 	lds	r24, 0x0CA6
    817a:	90 91 a7 0c 	lds	r25, 0x0CA7
    817e:	e0 91 f2 08 	lds	r30, 0x08F2
    8182:	f0 91 f3 08 	lds	r31, 0x08F3
    8186:	e8 0f       	add	r30, r24
    8188:	f9 1f       	adc	r31, r25
    818a:	80 91 9c 00 	lds	r24, 0x009C
    818e:	08 c0       	rjmp	.+16     	; 0x81a0 <EMeter_RX+0x80>
		}
		else
		{
			EMeter_RxStr[EMeter_RxCharN] = UDR_EMETER;
    8190:	e0 91 a6 0c 	lds	r30, 0x0CA6
    8194:	f0 91 a7 0c 	lds	r31, 0x0CA7
    8198:	80 91 9c 00 	lds	r24, 0x009C
    819c:	e7 54       	subi	r30, 0x47	; 71
    819e:	f9 4f       	sbci	r31, 0xF9	; 249
    81a0:	80 83       	st	Z, r24
		}
		
		
		if(EMeterTypeRAM == ELVIN_MODEM){
    81a2:	80 91 72 03 	lds	r24, 0x0372
    81a6:	84 30       	cpi	r24, 0x04	; 4
    81a8:	b1 f4       	brne	.+44     	; 0x81d6 <EMeter_RX+0xb6>
			EMeter_RxCharN++;
    81aa:	80 91 a6 0c 	lds	r24, 0x0CA6
    81ae:	90 91 a7 0c 	lds	r25, 0x0CA7
    81b2:	01 96       	adiw	r24, 0x01	; 1
    81b4:	90 93 a7 0c 	sts	0x0CA7, r25
    81b8:	80 93 a6 0c 	sts	0x0CA6, r24
			if(EMeter_RxCharN >= EM_RX_SIZE) EMeter_RxCharN = 0; //     ELVIN_MODEM -   
    81bc:	80 91 a6 0c 	lds	r24, 0x0CA6
    81c0:	90 91 a7 0c 	lds	r25, 0x0CA7
    81c4:	8e 3f       	cpi	r24, 0xFE	; 254
    81c6:	91 05       	cpc	r25, r1
    81c8:	08 f4       	brcc	.+2      	; 0x81cc <EMeter_RX+0xac>
    81ca:	5e c0       	rjmp	.+188    	; 0x8288 <EMeter_RX+0x168>
    81cc:	10 92 a7 0c 	sts	0x0CA7, r1
    81d0:	10 92 a6 0c 	sts	0x0CA6, r1
    81d4:	08 95       	ret
		}
		else{
			if(EMeterTypeRAM == LANDIS_GYR_ZMR110)
    81d6:	81 30       	cpi	r24, 0x01	; 1
    81d8:	09 f0       	breq	.+2      	; 0x81dc <EMeter_RX+0xbc>
    81da:	46 c0       	rjmp	.+140    	; 0x8268 <EMeter_RX+0x148>
			{
				if( ((EM_HalfBufferStart[EMeter_RxCharN] == 0x0A) && (EMeter_RxCharN >= (EM_RX_SIZE/2 - LG_ZMR110_MAX_STR)))||(EMeter_RxCharN >= EM_RX_SIZE/2-1) ) 
    81dc:	20 91 f2 08 	lds	r18, 0x08F2
    81e0:	30 91 f3 08 	lds	r19, 0x08F3
    81e4:	e0 91 a6 0c 	lds	r30, 0x0CA6
    81e8:	f0 91 a7 0c 	lds	r31, 0x0CA7
    81ec:	e2 0f       	add	r30, r18
    81ee:	f3 1f       	adc	r31, r19
    81f0:	80 81       	ld	r24, Z
    81f2:	8a 30       	cpi	r24, 0x0A	; 10
    81f4:	39 f4       	brne	.+14     	; 0x8204 <EMeter_RX+0xe4>
    81f6:	80 91 a6 0c 	lds	r24, 0x0CA6
    81fa:	90 91 a7 0c 	lds	r25, 0x0CA7
    81fe:	81 36       	cpi	r24, 0x61	; 97
    8200:	91 05       	cpc	r25, r1
    8202:	38 f4       	brcc	.+14     	; 0x8212 <EMeter_RX+0xf2>
    8204:	80 91 a6 0c 	lds	r24, 0x0CA6
    8208:	90 91 a7 0c 	lds	r25, 0x0CA7
    820c:	8e 37       	cpi	r24, 0x7E	; 126
    820e:	91 05       	cpc	r25, r1
    8210:	08 f1       	brcs	.+66     	; 0x8254 <EMeter_RX+0x134>
				{
					EMeter_RxCharN=0;
    8212:	10 92 a7 0c 	sts	0x0CA7, r1
    8216:	10 92 a6 0c 	sts	0x0CA6, r1
					if(EM_HalfBufferStart==EMeter_RxStr)
    821a:	86 e0       	ldi	r24, 0x06	; 6
    821c:	29 3b       	cpi	r18, 0xB9	; 185
    821e:	38 07       	cpc	r19, r24
    8220:	39 f4       	brne	.+14     	; 0x8230 <EMeter_RX+0x110>
					{
						EMeter_RxStr_Offset=EMeter_RxStr;
    8222:	30 93 86 05 	sts	0x0586, r19
    8226:	20 93 85 05 	sts	0x0585, r18
						EM_HalfBufferStart=&EMeter_RxStr[EM_RX_SIZE/2];
    822a:	88 e3       	ldi	r24, 0x38	; 56
    822c:	97 e0       	ldi	r25, 0x07	; 7
    822e:	0a c0       	rjmp	.+20     	; 0x8244 <EMeter_RX+0x124>
										
					}else if(EM_HalfBufferStart==&EMeter_RxStr[EM_RX_SIZE/2])
    8230:	87 e0       	ldi	r24, 0x07	; 7
    8232:	28 33       	cpi	r18, 0x38	; 56
    8234:	38 07       	cpc	r19, r24
    8236:	51 f4       	brne	.+20     	; 0x824c <EMeter_RX+0x12c>
					{	
													
						EMeter_RxStr_Offset=&EMeter_RxStr[EM_RX_SIZE/2];
    8238:	30 93 86 05 	sts	0x0586, r19
    823c:	20 93 85 05 	sts	0x0585, r18
						EM_HalfBufferStart=EMeter_RxStr;						
    8240:	89 eb       	ldi	r24, 0xB9	; 185
    8242:	96 e0       	ldi	r25, 0x06	; 6
    8244:	90 93 f3 08 	sts	0x08F3, r25
    8248:	80 93 f2 08 	sts	0x08F2, r24
					}
					EM_BufferReadEnable=1;
    824c:	81 e0       	ldi	r24, 0x01	; 1
    824e:	80 93 bf 08 	sts	0x08BF, r24
    8252:	08 95       	ret
				}
				else{
					EMeter_RxCharN++;	
    8254:	80 91 a6 0c 	lds	r24, 0x0CA6
    8258:	90 91 a7 0c 	lds	r25, 0x0CA7
    825c:	01 96       	adiw	r24, 0x01	; 1
    825e:	90 93 a7 0c 	sts	0x0CA7, r25
    8262:	80 93 a6 0c 	sts	0x0CA6, r24
    8266:	08 95       	ret

					}
			}					
			else{
				if(EMeter_RxCharN < (EM_RX_SIZE-1) )EMeter_RxCharN++;//      - 
    8268:	80 91 a6 0c 	lds	r24, 0x0CA6
    826c:	90 91 a7 0c 	lds	r25, 0x0CA7
    8270:	8d 3f       	cpi	r24, 0xFD	; 253
    8272:	91 05       	cpc	r25, r1
    8274:	48 f4       	brcc	.+18     	; 0x8288 <EMeter_RX+0x168>
    8276:	80 91 a6 0c 	lds	r24, 0x0CA6
    827a:	90 91 a7 0c 	lds	r25, 0x0CA7
    827e:	01 96       	adiw	r24, 0x01	; 1
    8280:	90 93 a7 0c 	sts	0x0CA7, r25
    8284:	80 93 a6 0c 	sts	0x0CA6, r24
    8288:	08 95       	ret

0000828a <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    828a:	1f 92       	push	r1
    828c:	0f 92       	push	r0
    828e:	0f b6       	in	r0, 0x3f	; 63
    8290:	0f 92       	push	r0
    8292:	0b b6       	in	r0, 0x3b	; 59
    8294:	0f 92       	push	r0
    8296:	11 24       	eor	r1, r1
    8298:	2f 93       	push	r18
    829a:	3f 93       	push	r19
    829c:	4f 93       	push	r20
    829e:	5f 93       	push	r21
    82a0:	6f 93       	push	r22
    82a2:	7f 93       	push	r23
    82a4:	8f 93       	push	r24
    82a6:	9f 93       	push	r25
    82a8:	af 93       	push	r26
    82aa:	bf 93       	push	r27
    82ac:	ef 93       	push	r30
    82ae:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    82b0:	80 91 63 03 	lds	r24, 0x0363
    82b4:	88 23       	and	r24, r24
    82b6:	29 f0       	breq	.+10     	; 0x82c2 <__vector_30+0x38>
    82b8:	8c e9       	ldi	r24, 0x9C	; 156
    82ba:	90 e0       	ldi	r25, 0x00	; 0
    82bc:	0e 94 b8 2a 	call	0x5570	; 0x5570 <Modbus_RX>
    82c0:	02 c0       	rjmp	.+4      	; 0x82c6 <__vector_30+0x3c>
	else EMeter_RX();
    82c2:	0e 94 90 40 	call	0x8120	; 0x8120 <EMeter_RX>
	COMM_LED = 1;
    82c6:	81 e0       	ldi	r24, 0x01	; 1
    82c8:	80 93 8d 05 	sts	0x058D, r24
}	
    82cc:	ff 91       	pop	r31
    82ce:	ef 91       	pop	r30
    82d0:	bf 91       	pop	r27
    82d2:	af 91       	pop	r26
    82d4:	9f 91       	pop	r25
    82d6:	8f 91       	pop	r24
    82d8:	7f 91       	pop	r23
    82da:	6f 91       	pop	r22
    82dc:	5f 91       	pop	r21
    82de:	4f 91       	pop	r20
    82e0:	3f 91       	pop	r19
    82e2:	2f 91       	pop	r18
    82e4:	0f 90       	pop	r0
    82e6:	0b be       	out	0x3b, r0	; 59
    82e8:	0f 90       	pop	r0
    82ea:	0f be       	out	0x3f, r0	; 63
    82ec:	0f 90       	pop	r0
    82ee:	1f 90       	pop	r1
    82f0:	18 95       	reti

000082f2 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    82f2:	80 91 e0 09 	lds	r24, 0x09E0
    82f6:	88 23       	and	r24, r24
    82f8:	21 f0       	breq	.+8      	; 0x8302 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    82fa:	88 e9       	ldi	r24, 0x98	; 152
    82fc:	80 93 9a 00 	sts	0x009A, r24
    8300:	05 c0       	rjmp	.+10     	; 0x830c <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    8302:	88 e9       	ldi	r24, 0x98	; 152
    8304:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    8308:	10 92 c7 08 	sts	0x08C7, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    830c:	94 98       	cbi	0x12, 4	; 18
    830e:	08 95       	ret

00008310 <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    8310:	1f 92       	push	r1
    8312:	0f 92       	push	r0
    8314:	0f b6       	in	r0, 0x3f	; 63
    8316:	0f 92       	push	r0
    8318:	0b b6       	in	r0, 0x3b	; 59
    831a:	0f 92       	push	r0
    831c:	11 24       	eor	r1, r1
    831e:	2f 93       	push	r18
    8320:	3f 93       	push	r19
    8322:	4f 93       	push	r20
    8324:	5f 93       	push	r21
    8326:	6f 93       	push	r22
    8328:	7f 93       	push	r23
    832a:	8f 93       	push	r24
    832c:	9f 93       	push	r25
    832e:	af 93       	push	r26
    8330:	bf 93       	push	r27
    8332:	ef 93       	push	r30
    8334:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    8336:	80 91 63 03 	lds	r24, 0x0363
    833a:	88 23       	and	r24, r24
    833c:	29 f0       	breq	.+10     	; 0x8348 <__vector_32+0x38>
    833e:	8c e9       	ldi	r24, 0x9C	; 156
    8340:	90 e0       	ldi	r25, 0x00	; 0
    8342:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Modbus_TX>
    8346:	02 c0       	rjmp	.+4      	; 0x834c <__vector_32+0x3c>
	else EMeter_TX();
    8348:	0e 94 79 41 	call	0x82f2	; 0x82f2 <EMeter_TX>
	COMM_LED = 1;
    834c:	81 e0       	ldi	r24, 0x01	; 1
    834e:	80 93 8d 05 	sts	0x058D, r24
}
    8352:	ff 91       	pop	r31
    8354:	ef 91       	pop	r30
    8356:	bf 91       	pop	r27
    8358:	af 91       	pop	r26
    835a:	9f 91       	pop	r25
    835c:	8f 91       	pop	r24
    835e:	7f 91       	pop	r23
    8360:	6f 91       	pop	r22
    8362:	5f 91       	pop	r21
    8364:	4f 91       	pop	r20
    8366:	3f 91       	pop	r19
    8368:	2f 91       	pop	r18
    836a:	0f 90       	pop	r0
    836c:	0b be       	out	0x3b, r0	; 59
    836e:	0f 90       	pop	r0
    8370:	0f be       	out	0x3f, r0	; 63
    8372:	0f 90       	pop	r0
    8374:	1f 90       	pop	r1
    8376:	18 95       	reti

00008378 <EMeter_SendFirstChar>:

}

// ~~~~~~~~~
void EMeter_SendFirstChar(void){
	cli();
    8378:	f8 94       	cli
	EMeter_TxFlag = 1;
    837a:	81 e0       	ldi	r24, 0x01	; 1
    837c:	80 93 c7 08 	sts	0x08C7, r24
	UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TXC_EMETER -  pending interrupt	
    8380:	eb e9       	ldi	r30, 0x9B	; 155
    8382:	f0 e0       	ldi	r31, 0x00	; 0
    8384:	80 81       	ld	r24, Z
    8386:	80 64       	ori	r24, 0x40	; 64
    8388:	80 83       	st	Z, r24
	PORTD |= (1<<PD4);	// Tx on
    838a:	94 9a       	sbi	0x12, 4	; 18
	UDR_EMETER = EMeter_TxStr[0];
    838c:	80 91 63 0a 	lds	r24, 0x0A63
    8390:	80 93 9c 00 	sts	0x009C, r24
	sei();
    8394:	78 94       	sei

	EMeter_TxCharN = 1;
    8396:	81 e0       	ldi	r24, 0x01	; 1
    8398:	80 93 c0 08 	sts	0x08C0, r24

	cli();
    839c:	f8 94       	cli
	UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    839e:	88 eb       	ldi	r24, 0xB8	; 184
    83a0:	80 93 9a 00 	sts	0x009A, r24

	EMeter_RxCharN = 0;	//  
    83a4:	10 92 a7 0c 	sts	0x0CA7, r1
    83a8:	10 92 a6 0c 	sts	0x0CA6, r1
	sei();	
    83ac:	78 94       	sei
}
    83ae:	08 95       	ret

000083b0 <EMeter_ClearRXStr>:
	EMeter_TxSz = Size;
	memcpy_P(EMeter_TxStr, Data_Out_P, Size);
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
    83b0:	e9 eb       	ldi	r30, 0xB9	; 185
    83b2:	f6 e0       	ldi	r31, 0x06	; 6
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    83b4:	11 92       	st	Z+, r1
    83b6:	87 e0       	ldi	r24, 0x07	; 7
    83b8:	e7 3b       	cpi	r30, 0xB7	; 183
    83ba:	f8 07       	cpc	r31, r24
    83bc:	d9 f7       	brne	.-10     	; 0x83b4 <EMeter_ClearRXStr+0x4>
	EMeter_RxCharN = 0;
    83be:	10 92 a7 0c 	sts	0x0CA7, r1
    83c2:	10 92 a6 0c 	sts	0x0CA6, r1

}
    83c6:	08 95       	ret

000083c8 <EMeter_Link>:
// ~~~~~~~~~
uint8_t EMeter_Link(void){
    83c8:	90 e0       	ldi	r25, 0x00	; 0
    83ca:	80 91 d3 01 	lds	r24, 0x01D3
    83ce:	88 23       	and	r24, r24
    83d0:	09 f4       	brne	.+2      	; 0x83d4 <EMeter_Link+0xc>
    83d2:	91 e0       	ldi	r25, 0x01	; 1
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
	else return 1;
}
    83d4:	89 2f       	mov	r24, r25
    83d6:	08 95       	ret

000083d8 <EMeter_NoLink>:

void EMeter_NoLink(void){
//	if(EM_Retry>10){
	if(EM_Retry>=1){
    83d8:	80 91 d3 01 	lds	r24, 0x01D3
    83dc:	88 23       	and	r24, r24
    83de:	e9 f1       	breq	.+122    	; 0x845a <EMeter_NoLink+0x82>
		E_Meter_RAM.Ap = 0;
    83e0:	10 92 db 01 	sts	0x01DB, r1
    83e4:	10 92 dc 01 	sts	0x01DC, r1
    83e8:	10 92 dd 01 	sts	0x01DD, r1
    83ec:	10 92 de 01 	sts	0x01DE, r1
		E_Meter_RAM.Am = 0;
    83f0:	10 92 df 01 	sts	0x01DF, r1
    83f4:	10 92 e0 01 	sts	0x01E0, r1
    83f8:	10 92 e1 01 	sts	0x01E1, r1
    83fc:	10 92 e2 01 	sts	0x01E2, r1
		E_Meter_RAM.Rp = 0;
    8400:	10 92 e3 01 	sts	0x01E3, r1
    8404:	10 92 e4 01 	sts	0x01E4, r1
    8408:	10 92 e5 01 	sts	0x01E5, r1
    840c:	10 92 e6 01 	sts	0x01E6, r1
		E_Meter_RAM.Rm = 0;
    8410:	10 92 e7 01 	sts	0x01E7, r1
    8414:	10 92 e8 01 	sts	0x01E8, r1
    8418:	10 92 e9 01 	sts	0x01E9, r1
    841c:	10 92 ea 01 	sts	0x01EA, r1
		Ua = 0;
    8420:	10 92 a9 0c 	sts	0x0CA9, r1
    8424:	10 92 a8 0c 	sts	0x0CA8, r1
		Ub = 0;
    8428:	10 92 68 03 	sts	0x0368, r1
    842c:	10 92 67 03 	sts	0x0367, r1
		Uc = 0;
    8430:	10 92 de 09 	sts	0x09DE, r1
    8434:	10 92 dd 09 	sts	0x09DD, r1
		Ia = 0;
    8438:	10 92 76 03 	sts	0x0376, r1
    843c:	10 92 75 03 	sts	0x0375, r1
		Ib = 0;
    8440:	10 92 b7 08 	sts	0x08B7, r1
    8444:	10 92 b6 08 	sts	0x08B6, r1
		Ic = 0;
    8448:	10 92 ed 08 	sts	0x08ED, r1
    844c:	10 92 ec 08 	sts	0x08EC, r1
		EM_PowerActive = 0;
    8450:	10 92 da 09 	sts	0x09DA, r1
    8454:	10 92 d9 09 	sts	0x09D9, r1
    8458:	03 c0       	rjmp	.+6      	; 0x8460 <EMeter_NoLink+0x88>
	}
	else EM_Retry++;
    845a:	81 e0       	ldi	r24, 0x01	; 1
    845c:	80 93 d3 01 	sts	0x01D3, r24

	//StartTimer16(TD_EMeter,1000);
	EM_Mode = 255;
    8460:	8f ef       	ldi	r24, 0xFF	; 255
    8462:	80 93 db 09 	sts	0x09DB, r24
}
    8466:	08 95       	ret

00008468 <EMeter_ELVIN_Modem_NoLink>:
// ~~~~~~~~~
void EMeter_ELVIN_Modem_NoLink(void){
	E_Meter_RAM.Ap = 0;
    8468:	10 92 db 01 	sts	0x01DB, r1
    846c:	10 92 dc 01 	sts	0x01DC, r1
    8470:	10 92 dd 01 	sts	0x01DD, r1
    8474:	10 92 de 01 	sts	0x01DE, r1
	E_Meter_RAM.Am = 0;
    8478:	10 92 df 01 	sts	0x01DF, r1
    847c:	10 92 e0 01 	sts	0x01E0, r1
    8480:	10 92 e1 01 	sts	0x01E1, r1
    8484:	10 92 e2 01 	sts	0x01E2, r1
	E_Meter_RAM.Rp = 0;
    8488:	10 92 e3 01 	sts	0x01E3, r1
    848c:	10 92 e4 01 	sts	0x01E4, r1
    8490:	10 92 e5 01 	sts	0x01E5, r1
    8494:	10 92 e6 01 	sts	0x01E6, r1
	E_Meter_RAM.Rm = 0;
    8498:	10 92 e7 01 	sts	0x01E7, r1
    849c:	10 92 e8 01 	sts	0x01E8, r1
    84a0:	10 92 e9 01 	sts	0x01E9, r1
    84a4:	10 92 ea 01 	sts	0x01EA, r1
}
    84a8:	08 95       	ret

000084aa <EMeter_M230_Data_Convert>:
// ~~~~~~~~~
uint32_t EMeter_M230_Data_Convert(uint16_t Start){
    84aa:	df 93       	push	r29
    84ac:	cf 93       	push	r28
    84ae:	00 d0       	rcall	.+0      	; 0x84b0 <EMeter_M230_Data_Convert+0x6>
    84b0:	00 d0       	rcall	.+0      	; 0x84b2 <EMeter_M230_Data_Convert+0x8>
    84b2:	cd b7       	in	r28, 0x3d	; 61
    84b4:	de b7       	in	r29, 0x3e	; 62
	uint8_t TempArray[4];
	TempArray[3] = EMeter_RxStr[Start+1];
    84b6:	fc 01       	movw	r30, r24
    84b8:	e7 54       	subi	r30, 0x47	; 71
    84ba:	f9 4f       	sbci	r31, 0xF9	; 249
    84bc:	81 81       	ldd	r24, Z+1	; 0x01
    84be:	8c 83       	std	Y+4, r24	; 0x04
	TempArray[2] = EMeter_RxStr[Start+0];
    84c0:	80 81       	ld	r24, Z
    84c2:	8b 83       	std	Y+3, r24	; 0x03
	TempArray[1] = EMeter_RxStr[Start+3];
    84c4:	83 81       	ldd	r24, Z+3	; 0x03
    84c6:	8a 83       	std	Y+2, r24	; 0x02
	TempArray[0] = EMeter_RxStr[Start+2];
    84c8:	82 81       	ldd	r24, Z+2	; 0x02
    84ca:	89 83       	std	Y+1, r24	; 0x01
	if( *(uint32_t*)TempArray == 0xFFFFFFFF) return 0;
    84cc:	29 81       	ldd	r18, Y+1	; 0x01
    84ce:	3a 81       	ldd	r19, Y+2	; 0x02
    84d0:	4b 81       	ldd	r20, Y+3	; 0x03
    84d2:	5c 81       	ldd	r21, Y+4	; 0x04
    84d4:	2f 3f       	cpi	r18, 0xFF	; 255
    84d6:	8f ef       	ldi	r24, 0xFF	; 255
    84d8:	38 07       	cpc	r19, r24
    84da:	8f ef       	ldi	r24, 0xFF	; 255
    84dc:	48 07       	cpc	r20, r24
    84de:	8f ef       	ldi	r24, 0xFF	; 255
    84e0:	58 07       	cpc	r21, r24
    84e2:	21 f4       	brne	.+8      	; 0x84ec <EMeter_M230_Data_Convert+0x42>
    84e4:	20 e0       	ldi	r18, 0x00	; 0
    84e6:	30 e0       	ldi	r19, 0x00	; 0
    84e8:	40 e0       	ldi	r20, 0x00	; 0
    84ea:	50 e0       	ldi	r21, 0x00	; 0
	else return *(uint32_t*)TempArray;
}
    84ec:	b9 01       	movw	r22, r18
    84ee:	ca 01       	movw	r24, r20
    84f0:	0f 90       	pop	r0
    84f2:	0f 90       	pop	r0
    84f4:	0f 90       	pop	r0
    84f6:	0f 90       	pop	r0
    84f8:	cf 91       	pop	r28
    84fa:	df 91       	pop	r29
    84fc:	08 95       	ret

000084fe <EMeter_M230_Data_ConvertWord>:
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
    84fe:	df 93       	push	r29
    8500:	cf 93       	push	r28
    8502:	00 d0       	rcall	.+0      	; 0x8504 <EMeter_M230_Data_ConvertWord+0x6>
    8504:	00 d0       	rcall	.+0      	; 0x8506 <EMeter_M230_Data_ConvertWord+0x8>
    8506:	cd b7       	in	r28, 0x3d	; 61
    8508:	de b7       	in	r29, 0x3e	; 62
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    850a:	fc 01       	movw	r30, r24
    850c:	e7 54       	subi	r30, 0x47	; 71
    850e:	f9 4f       	sbci	r31, 0xF9	; 249
    8510:	80 81       	ld	r24, Z
    8512:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    8514:	81 81       	ldd	r24, Z+1	; 0x01
    8516:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    8518:	29 81       	ldd	r18, Y+1	; 0x01
    851a:	3a 81       	ldd	r19, Y+2	; 0x02
    851c:	8f ef       	ldi	r24, 0xFF	; 255
    851e:	2f 3f       	cpi	r18, 0xFF	; 255
    8520:	38 07       	cpc	r19, r24
    8522:	11 f4       	brne	.+4      	; 0x8528 <EMeter_M230_Data_ConvertWord+0x2a>
    8524:	20 e0       	ldi	r18, 0x00	; 0
    8526:	30 e0       	ldi	r19, 0x00	; 0
	else return *(uint16_t*)TempArray;
}
    8528:	c9 01       	movw	r24, r18
    852a:	0f 90       	pop	r0
    852c:	0f 90       	pop	r0
    852e:	0f 90       	pop	r0
    8530:	0f 90       	pop	r0
    8532:	cf 91       	pop	r28
    8534:	df 91       	pop	r29
    8536:	08 95       	ret

00008538 <EMeter_M230_Data_ConvertP>:
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertP(uint16_t Start){
    8538:	df 93       	push	r29
    853a:	cf 93       	push	r28
    853c:	00 d0       	rcall	.+0      	; 0x853e <EMeter_M230_Data_ConvertP+0x6>
    853e:	00 d0       	rcall	.+0      	; 0x8540 <EMeter_M230_Data_ConvertP+0x8>
    8540:	cd b7       	in	r28, 0x3d	; 61
    8542:	de b7       	in	r29, 0x3e	; 62
	uint8_t TempArray[4];
	TempArray[3] = 0;
    8544:	1c 82       	std	Y+4, r1	; 0x04
	TempArray[2] = EMeter_RxStr[Start];
    8546:	fc 01       	movw	r30, r24
    8548:	e7 54       	subi	r30, 0x47	; 71
    854a:	f9 4f       	sbci	r31, 0xF9	; 249
    854c:	80 81       	ld	r24, Z
    854e:	8b 83       	std	Y+3, r24	; 0x03
	TempArray[1] = EMeter_RxStr[Start+2];
    8550:	82 81       	ldd	r24, Z+2	; 0x02
    8552:	8a 83       	std	Y+2, r24	; 0x02
	TempArray[0] = EMeter_RxStr[Start+1];
    8554:	81 81       	ldd	r24, Z+1	; 0x01
    8556:	89 83       	std	Y+1, r24	; 0x01
    8558:	69 81       	ldd	r22, Y+1	; 0x01
    855a:	7a 81       	ldd	r23, Y+2	; 0x02
    855c:	8b 81       	ldd	r24, Y+3	; 0x03
    855e:	9c 81       	ldd	r25, Y+4	; 0x04
    8560:	8f 73       	andi	r24, 0x3F	; 63
    8562:	90 70       	andi	r25, 0x00	; 0
    8564:	28 ee       	ldi	r18, 0xE8	; 232
    8566:	33 e0       	ldi	r19, 0x03	; 3
    8568:	40 e0       	ldi	r20, 0x00	; 0
    856a:	50 e0       	ldi	r21, 0x00	; 0
    856c:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    8570:	c9 01       	movw	r24, r18
	return (uint16_t)(((*(uint32_t*)TempArray)&0x3FFFFF)/1000);
}
    8572:	0f 90       	pop	r0
    8574:	0f 90       	pop	r0
    8576:	0f 90       	pop	r0
    8578:	0f 90       	pop	r0
    857a:	cf 91       	pop	r28
    857c:	df 91       	pop	r29
    857e:	08 95       	ret

00008580 <Check_LG_ZMR110_READ_FLAG>:

//~~~~~~


uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
    8580:	98 2f       	mov	r25, r24
    8582:	97 70       	andi	r25, 0x07	; 7
    8584:	21 e0       	ldi	r18, 0x01	; 1
    8586:	30 e0       	ldi	r19, 0x00	; 0
    8588:	02 c0       	rjmp	.+4      	; 0x858e <Check_LG_ZMR110_READ_FLAG+0xe>
    858a:	22 0f       	add	r18, r18
    858c:	33 1f       	adc	r19, r19
    858e:	9a 95       	dec	r25
    8590:	e2 f7       	brpl	.-8      	; 0x858a <Check_LG_ZMR110_READ_FLAG+0xa>
    8592:	86 95       	lsr	r24
    8594:	86 95       	lsr	r24
    8596:	86 95       	lsr	r24
    8598:	ef e7       	ldi	r30, 0x7F	; 127
    859a:	f5 e0       	ldi	r31, 0x05	; 5
    859c:	e8 0f       	add	r30, r24
    859e:	f1 1d       	adc	r31, r1
    85a0:	80 81       	ld	r24, Z
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
}
    85a2:	82 23       	and	r24, r18
    85a4:	08 95       	ret

000085a6 <IsEMReady>:
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%8s"), EM_ID_Str);
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
    85a6:	90 e0       	ldi	r25, 0x00	; 0
    85a8:	80 91 db 09 	lds	r24, 0x09DB
    85ac:	8f 3f       	cpi	r24, 0xFF	; 255
    85ae:	09 f4       	brne	.+2      	; 0x85b2 <IsEMReady+0xc>
    85b0:	91 e0       	ldi	r25, 0x01	; 1
	if(EM_Mode == 255) return 1;
	else return 0;
}
    85b2:	89 2f       	mov	r24, r25
    85b4:	08 95       	ret

000085b6 <GPRS_AppInit>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    85b6:	90 91 cc 01 	lds	r25, 0x01CC
	VacantTimer16++;
    85ba:	89 2f       	mov	r24, r25
    85bc:	8f 5f       	subi	r24, 0xFF	; 255

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    85be:	90 93 8c 05 	sts	0x058C, r25
    85c2:	9e 5f       	subi	r25, 0xFE	; 254
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    85c4:	80 93 bd 08 	sts	0x08BD, r24
    85c8:	9f 5f       	subi	r25, 0xFF	; 255
    85ca:	90 93 cc 01 	sts	0x01CC, r25
    85ce:	91 50       	subi	r25, 0x01	; 1
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    85d0:	90 93 76 0a 	sts	0x0A76, r25
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    85d4:	6f ef       	ldi	r22, 0xFF	; 255
    85d6:	7f ef       	ldi	r23, 0xFF	; 255
    85d8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    85dc:	80 91 cc 01 	lds	r24, 0x01CC
    85e0:	88 32       	cpi	r24, 0x28	; 40
    85e2:	28 f0       	brcs	.+10     	; 0x85ee <GPRS_AppInit+0x38>
    85e4:	80 91 d6 08 	lds	r24, 0x08D6
    85e8:	81 60       	ori	r24, 0x01	; 1
    85ea:	80 93 d6 08 	sts	0x08D6, r24
    85ee:	08 95       	ret

000085f0 <GPRS_RemoteDisplayControl>:
	GPRS_FlgSz_Out = 7;					//    .     	
}

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    85f0:	80 e0       	ldi	r24, 0x00	; 0
    85f2:	6f e0       	ldi	r22, 0x0F	; 15
    85f4:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    85f8:	80 91 d6 08 	lds	r24, 0x08D6
    85fc:	84 60       	ori	r24, 0x04	; 4
    85fe:	80 93 d6 08 	sts	0x08D6, r24
//	if ( (GPRS_Data_In[7]<=6) && (GPRS_Data_In[7]!=0) ) rkey = 1<<(GPRS_Data_In[7]-1);
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
    8602:	08 95       	ret

00008604 <GPRS_ChangeReply>:
}

// -----                     
void GPRS_ChangeReply(uint8_t i){
//
	GPRS_ChangeData[0] = GPRS_CONTROL;	//  
    8604:	93 e0       	ldi	r25, 0x03	; 3
    8606:	90 93 ba 05 	sts	0x05BA, r25
	GPRS_ChangeData[1] = 3;				// -       
    860a:	90 93 bb 05 	sts	0x05BB, r25
	GPRS_ChangeData[2] = i;
    860e:	80 93 bc 05 	sts	0x05BC, r24
	GPRS_ChangeData[3] = GPRS_Data_In[7];
    8612:	80 91 c1 07 	lds	r24, 0x07C1
    8616:	80 93 bd 05 	sts	0x05BD, r24
	GPRS_ChangeData[4] = GPRS_Data_In[8];
    861a:	80 91 c2 07 	lds	r24, 0x07C2
    861e:	80 93 be 05 	sts	0x05BE, r24
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    
    8622:	80 91 ca 08 	lds	r24, 0x08CA
    8626:	88 60       	ori	r24, 0x08	; 8
    8628:	80 93 ca 08 	sts	0x08CA, r24
}
    862c:	08 95       	ret

0000862e <GPRS_Bit>:
//   
void GPRS_Bit(void){
}
    862e:	08 95       	ret

00008630 <GPRS_Reg>:
//   
void GPRS_Reg(void){
}
    8630:	08 95       	ret

00008632 <GPRS_ParamWrite>:
	}
}

void GPRS_ParamWrite(void){

}
    8632:	08 95       	ret

00008634 <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    8634:	81 e0       	ldi	r24, 0x01	; 1
    8636:	80 93 5d 09 	sts	0x095D, r24
	ModbusMode = 0;
    863a:	10 92 63 03 	sts	0x0363, r1
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
    863e:	8f ef       	ldi	r24, 0xFF	; 255
    8640:	80 93 dd 08 	sts	0x08DD, r24
	EM_RX_FIFO_End = 255;
    8644:	80 93 a0 0c 	sts	0x0CA0, r24
	EMeter_RxCharN = 0;
    8648:	10 92 a7 0c 	sts	0x0CA7, r1
    864c:	10 92 a6 0c 	sts	0x0CA6, r1
	EM_InitFIFO();
	cli();
    8650:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    8652:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    8654:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    8658:	88 e0       	ldi	r24, 0x08	; 8
    865a:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    865e:	85 e0       	ldi	r24, 0x05	; 5
    8660:	99 e1       	ldi	r25, 0x19	; 25
    8662:	0e 94 02 40 	call	0x8004	; 0x8004 <EM_SetUARTParam>
	sei();	
    8666:	78 94       	sei
}
    8668:	08 95       	ret

0000866a <SendDebug>:
	EMeter_ReInit();
	sei();*/
}

//  ISR
void SendDebug(uint8_t Char){
    866a:	98 2f       	mov	r25, r24
	//---FIFO
	EM_RX_FIFO_Begin++;
    866c:	80 91 dd 08 	lds	r24, 0x08DD
    8670:	8f 5f       	subi	r24, 0xFF	; 255
    8672:	80 93 dd 08 	sts	0x08DD, r24
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    8676:	80 91 dd 08 	lds	r24, 0x08DD
    867a:	8a 3f       	cpi	r24, 0xFA	; 250
    867c:	10 f0       	brcs	.+4      	; 0x8682 <SendDebug+0x18>
    867e:	10 92 dd 08 	sts	0x08DD, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    8682:	e0 91 dd 08 	lds	r30, 0x08DD
    8686:	f0 e0       	ldi	r31, 0x00	; 0
    8688:	e4 58       	subi	r30, 0x84	; 132
    868a:	fc 4f       	sbci	r31, 0xFC	; 252
    868c:	90 83       	st	Z, r25
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    868e:	90 91 dd 08 	lds	r25, 0x08DD
    8692:	80 91 a0 0c 	lds	r24, 0x0CA0
    8696:	98 17       	cp	r25, r24
    8698:	31 f4       	brne	.+12     	; 0x86a6 <SendDebug+0x3c>
		EM_RX_FIFOOverFlow = 1;
    869a:	81 e0       	ldi	r24, 0x01	; 1
    869c:	80 93 8c 0a 	sts	0x0A8C, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    86a0:	8a ef       	ldi	r24, 0xFA	; 250
    86a2:	80 93 d8 09 	sts	0x09D8, r24
    86a6:	08 95       	ret

000086a8 <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    86a8:	80 91 e0 09 	lds	r24, 0x09E0
    86ac:	88 23       	and	r24, r24
    86ae:	09 f4       	brne	.+2      	; 0x86b2 <GSM_DRE+0xa>
    86b0:	54 c0       	rjmp	.+168    	; 0x875a <GSM_DRE+0xb2>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    86b2:	90 91 dd 08 	lds	r25, 0x08DD
    86b6:	80 91 a0 0c 	lds	r24, 0x0CA0
    86ba:	98 17       	cp	r25, r24
    86bc:	a1 f0       	breq	.+40     	; 0x86e6 <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    86be:	80 91 a0 0c 	lds	r24, 0x0CA0
    86c2:	8f 5f       	subi	r24, 0xFF	; 255
    86c4:	80 93 a0 0c 	sts	0x0CA0, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    86c8:	80 91 a0 0c 	lds	r24, 0x0CA0
    86cc:	8a 3f       	cpi	r24, 0xFA	; 250
    86ce:	10 f0       	brcs	.+4      	; 0x86d4 <GSM_DRE+0x2c>
    86d0:	10 92 a0 0c 	sts	0x0CA0, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    86d4:	e0 91 a0 0c 	lds	r30, 0x0CA0
    86d8:	f0 e0       	ldi	r31, 0x00	; 0
    86da:	e4 58       	subi	r30, 0x84	; 132
    86dc:	fc 4f       	sbci	r31, 0xFC	; 252
    86de:	80 81       	ld	r24, Z
    86e0:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    86e2:	5e 9a       	sbi	0x0b, 6	; 11
    86e4:	02 c0       	rjmp	.+4      	; 0x86ea <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    86e6:	88 ed       	ldi	r24, 0xD8	; 216
    86e8:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    86ea:	90 91 dd 08 	lds	r25, 0x08DD
    86ee:	80 91 a0 0c 	lds	r24, 0x0CA0
    86f2:	89 17       	cp	r24, r25
    86f4:	a0 f4       	brcc	.+40     	; 0x871e <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    86f6:	80 91 d8 09 	lds	r24, 0x09D8
    86fa:	20 91 dd 08 	lds	r18, 0x08DD
    86fe:	40 91 a0 0c 	lds	r20, 0x0CA0
    8702:	90 e0       	ldi	r25, 0x00	; 0
    8704:	30 e0       	ldi	r19, 0x00	; 0
    8706:	24 1b       	sub	r18, r20
    8708:	31 09       	sbc	r19, r1
    870a:	82 17       	cp	r24, r18
    870c:	93 07       	cpc	r25, r19
    870e:	3c f4       	brge	.+14     	; 0x871e <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    8710:	80 91 dd 08 	lds	r24, 0x08DD
    8714:	90 91 a0 0c 	lds	r25, 0x0CA0
    8718:	89 1b       	sub	r24, r25
    871a:	80 93 d8 09 	sts	0x09D8, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    871e:	90 91 a0 0c 	lds	r25, 0x0CA0
    8722:	80 91 dd 08 	lds	r24, 0x08DD
    8726:	89 17       	cp	r24, r25
    8728:	e0 f5       	brcc	.+120    	; 0x87a2 <GSM_DRE+0xfa>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    872a:	80 91 d8 09 	lds	r24, 0x09D8
    872e:	40 91 a0 0c 	lds	r20, 0x0CA0
    8732:	20 91 dd 08 	lds	r18, 0x08DD
    8736:	90 e0       	ldi	r25, 0x00	; 0
    8738:	30 e0       	ldi	r19, 0x00	; 0
    873a:	26 50       	subi	r18, 0x06	; 6
    873c:	3f 4f       	sbci	r19, 0xFF	; 255
    873e:	24 1b       	sub	r18, r20
    8740:	31 09       	sbc	r19, r1
    8742:	82 17       	cp	r24, r18
    8744:	93 07       	cpc	r25, r19
    8746:	6c f5       	brge	.+90     	; 0x87a2 <GSM_DRE+0xfa>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    8748:	80 91 dd 08 	lds	r24, 0x08DD
    874c:	90 91 a0 0c 	lds	r25, 0x0CA0
    8750:	86 50       	subi	r24, 0x06	; 6
    8752:	89 1b       	sub	r24, r25
    8754:	80 93 d8 09 	sts	0x09D8, r24
    8758:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    875a:	90 91 ad 0c 	lds	r25, 0x0CAD
    875e:	80 91 c5 08 	lds	r24, 0x08C5
    8762:	98 17       	cp	r25, r24
    8764:	e0 f4       	brcc	.+56     	; 0x879e <GSM_DRE+0xf6>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    8766:	e0 91 ad 0c 	lds	r30, 0x0CAD
    876a:	f0 e0       	ldi	r31, 0x00	; 0
    876c:	ef 55       	subi	r30, 0x5F	; 95
    876e:	f4 4f       	sbci	r31, 0xF4	; 244
    8770:	80 81       	ld	r24, Z
    8772:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    8774:	80 91 5d 09 	lds	r24, 0x095D
    8778:	88 23       	and	r24, r24
    877a:	59 f0       	breq	.+22     	; 0x8792 <GSM_DRE+0xea>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    877c:	e0 91 ad 0c 	lds	r30, 0x0CAD
    8780:	f0 e0       	ldi	r31, 0x00	; 0
    8782:	ef 55       	subi	r30, 0x5F	; 95
    8784:	f4 4f       	sbci	r31, 0xF4	; 244
    8786:	80 81       	ld	r24, Z
    8788:	0e 94 35 43 	call	0x866a	; 0x866a <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    878c:	88 e2       	ldi	r24, 0x28	; 40
    878e:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    8792:	80 91 ad 0c 	lds	r24, 0x0CAD
    8796:	8f 5f       	subi	r24, 0xFF	; 255
    8798:	80 93 ad 0c 	sts	0x0CAD, r24
    879c:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    879e:	88 ed       	ldi	r24, 0xD8	; 216
    87a0:	8a b9       	out	0x0a, r24	; 10
    87a2:	08 95       	ret

000087a4 <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    87a4:	1f 92       	push	r1
    87a6:	0f 92       	push	r0
    87a8:	0f b6       	in	r0, 0x3f	; 63
    87aa:	0f 92       	push	r0
    87ac:	0b b6       	in	r0, 0x3b	; 59
    87ae:	0f 92       	push	r0
    87b0:	11 24       	eor	r1, r1
    87b2:	2f 93       	push	r18
    87b4:	3f 93       	push	r19
    87b6:	4f 93       	push	r20
    87b8:	5f 93       	push	r21
    87ba:	6f 93       	push	r22
    87bc:	7f 93       	push	r23
    87be:	8f 93       	push	r24
    87c0:	9f 93       	push	r25
    87c2:	af 93       	push	r26
    87c4:	bf 93       	push	r27
    87c6:	ef 93       	push	r30
    87c8:	ff 93       	push	r31
	GSM_DRE();
    87ca:	0e 94 54 43 	call	0x86a8	; 0x86a8 <GSM_DRE>
	GSM_LED = 1;
    87ce:	81 e0       	ldi	r24, 0x01	; 1
    87d0:	80 93 88 05 	sts	0x0588, r24
}
    87d4:	ff 91       	pop	r31
    87d6:	ef 91       	pop	r30
    87d8:	bf 91       	pop	r27
    87da:	af 91       	pop	r26
    87dc:	9f 91       	pop	r25
    87de:	8f 91       	pop	r24
    87e0:	7f 91       	pop	r23
    87e2:	6f 91       	pop	r22
    87e4:	5f 91       	pop	r21
    87e6:	4f 91       	pop	r20
    87e8:	3f 91       	pop	r19
    87ea:	2f 91       	pop	r18
    87ec:	0f 90       	pop	r0
    87ee:	0b be       	out	0x3b, r0	; 59
    87f0:	0f 90       	pop	r0
    87f2:	0f be       	out	0x3f, r0	; 63
    87f4:	0f 90       	pop	r0
    87f6:	1f 90       	pop	r1
    87f8:	18 95       	reti

000087fa <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    87fa:	90 91 a1 0b 	lds	r25, 0x0BA1
    87fe:	9c b9       	out	0x0c, r25	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    8800:	80 91 5d 09 	lds	r24, 0x095D
    8804:	88 23       	and	r24, r24
    8806:	41 f0       	breq	.+16     	; 0x8818 <GSM_SendFirstChar+0x1e>
		SendDebug(GSM_TxStr[0]);
    8808:	89 2f       	mov	r24, r25
    880a:	0e 94 35 43 	call	0x866a	; 0x866a <SendDebug>
		cli();
    880e:	f8 94       	cli
    8810:	88 e2       	ldi	r24, 0x28	; 40
    8812:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    8816:	78 94       	sei
	}

	GSM_TxCharN = 1;
    8818:	81 e0       	ldi	r24, 0x01	; 1
    881a:	80 93 ad 0c 	sts	0x0CAD, r24
	cli();
    881e:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    8820:	80 91 d1 01 	lds	r24, 0x01D1
    8824:	8e 7f       	andi	r24, 0xFE	; 254
    8826:	80 93 d1 01 	sts	0x01D1, r24
	sei();
    882a:	78 94       	sei
	cli();
    882c:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    882e:	88 eb       	ldi	r24, 0xB8	; 184
    8830:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    8832:	78 94       	sei
}
    8834:	08 95       	ret

00008836 <GSM_RX>:
}
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    8836:	2c b1       	in	r18, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    8838:	80 91 44 08 	lds	r24, 0x0844
    883c:	8f 5f       	subi	r24, 0xFF	; 255
    883e:	80 93 44 08 	sts	0x0844, r24
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    8842:	80 91 44 08 	lds	r24, 0x0844
    8846:	8a 3f       	cpi	r24, 0xFA	; 250
    8848:	10 f0       	brcs	.+4      	; 0x884e <GSM_RX+0x18>
    884a:	10 92 44 08 	sts	0x0844, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    884e:	e0 91 44 08 	lds	r30, 0x0844
    8852:	f0 e0       	ldi	r31, 0x00	; 0
    8854:	ea 58       	subi	r30, 0x8A	; 138
    8856:	fb 4f       	sbci	r31, 0xFB	; 251
    8858:	20 83       	st	Z, r18
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    885a:	90 91 44 08 	lds	r25, 0x0844
    885e:	80 91 83 05 	lds	r24, 0x0583
    8862:	98 17       	cp	r25, r24
    8864:	31 f4       	brne	.+12     	; 0x8872 <GSM_RX+0x3c>
		GSM_RX_FIFOOverFlow = 1;
    8866:	81 e0       	ldi	r24, 0x01	; 1
    8868:	80 93 d7 09 	sts	0x09D7, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    886c:	8a ef       	ldi	r24, 0xFA	; 250
    886e:	80 93 77 0a 	sts	0x0A77, r24
	}

	//---In Transparent Mode
	if(Transparent){
    8872:	80 91 e0 09 	lds	r24, 0x09E0
    8876:	88 23       	and	r24, r24
    8878:	a1 f0       	breq	.+40     	; 0x88a2 <GSM_RX+0x6c>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    887a:	88 eb       	ldi	r24, 0xB8	; 184
    887c:	80 93 9a 00 	sts	0x009A, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    8880:	80 91 9b 00 	lds	r24, 0x009B
    8884:	80 64       	ori	r24, 0x40	; 64
    8886:	80 93 9b 00 	sts	0x009B, r24

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    888a:	90 91 44 08 	lds	r25, 0x0844
    888e:	80 91 62 0a 	lds	r24, 0x0A62
    8892:	98 17       	cp	r25, r24
    8894:	31 f4       	brne	.+12     	; 0x88a2 <GSM_RX+0x6c>
			GSM_RX_FIFOOverFlow_Transp = 1;
    8896:	81 e0       	ldi	r24, 0x01	; 1
    8898:	80 93 b1 0d 	sts	0x0DB1, r24
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    889c:	8a ef       	ldi	r24, 0xFA	; 250
    889e:	80 93 ea 08 	sts	0x08EA, r24
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    88a2:	80 91 5d 09 	lds	r24, 0x095D
    88a6:	88 23       	and	r24, r24
    88a8:	31 f0       	breq	.+12     	; 0x88b6 <GSM_RX+0x80>
		SendDebug(Char);
    88aa:	82 2f       	mov	r24, r18
    88ac:	0e 94 35 43 	call	0x866a	; 0x866a <SendDebug>
    88b0:	88 e2       	ldi	r24, 0x28	; 40
    88b2:	80 93 9a 00 	sts	0x009A, r24
    88b6:	08 95       	ret

000088b8 <__vector_18>:
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    88b8:	1f 92       	push	r1
    88ba:	0f 92       	push	r0
    88bc:	0f b6       	in	r0, 0x3f	; 63
    88be:	0f 92       	push	r0
    88c0:	0b b6       	in	r0, 0x3b	; 59
    88c2:	0f 92       	push	r0
    88c4:	11 24       	eor	r1, r1
    88c6:	2f 93       	push	r18
    88c8:	3f 93       	push	r19
    88ca:	4f 93       	push	r20
    88cc:	5f 93       	push	r21
    88ce:	6f 93       	push	r22
    88d0:	7f 93       	push	r23
    88d2:	8f 93       	push	r24
    88d4:	9f 93       	push	r25
    88d6:	af 93       	push	r26
    88d8:	bf 93       	push	r27
    88da:	ef 93       	push	r30
    88dc:	ff 93       	push	r31
	GSM_RX();
    88de:	0e 94 1b 44 	call	0x8836	; 0x8836 <GSM_RX>
	GSM_LED = 1;
    88e2:	81 e0       	ldi	r24, 0x01	; 1
    88e4:	80 93 88 05 	sts	0x0588, r24
}
    88e8:	ff 91       	pop	r31
    88ea:	ef 91       	pop	r30
    88ec:	bf 91       	pop	r27
    88ee:	af 91       	pop	r26
    88f0:	9f 91       	pop	r25
    88f2:	8f 91       	pop	r24
    88f4:	7f 91       	pop	r23
    88f6:	6f 91       	pop	r22
    88f8:	5f 91       	pop	r21
    88fa:	4f 91       	pop	r20
    88fc:	3f 91       	pop	r19
    88fe:	2f 91       	pop	r18
    8900:	0f 90       	pop	r0
    8902:	0b be       	out	0x3b, r0	; 59
    8904:	0f 90       	pop	r0
    8906:	0f be       	out	0x3f, r0	; 63
    8908:	0f 90       	pop	r0
    890a:	1f 90       	pop	r1
    890c:	18 95       	reti

0000890e <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    890e:	90 91 dd 08 	lds	r25, 0x08DD
    8912:	80 91 a0 0c 	lds	r24, 0x0CA0
    8916:	98 17       	cp	r25, r24
    8918:	a1 f0       	breq	.+40     	; 0x8942 <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    891a:	80 91 a0 0c 	lds	r24, 0x0CA0
    891e:	8f 5f       	subi	r24, 0xFF	; 255
    8920:	80 93 a0 0c 	sts	0x0CA0, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    8924:	80 91 a0 0c 	lds	r24, 0x0CA0
    8928:	8a 3f       	cpi	r24, 0xFA	; 250
    892a:	10 f0       	brcs	.+4      	; 0x8930 <Debug_DRE+0x22>
    892c:	10 92 a0 0c 	sts	0x0CA0, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    8930:	e0 91 a0 0c 	lds	r30, 0x0CA0
    8934:	f0 e0       	ldi	r31, 0x00	; 0
    8936:	e4 58       	subi	r30, 0x84	; 132
    8938:	fc 4f       	sbci	r31, 0xFC	; 252
    893a:	80 81       	ld	r24, Z
    893c:	80 93 9c 00 	sts	0x009C, r24
    8940:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    8942:	88 e0       	ldi	r24, 0x08	; 8
    8944:	80 93 9a 00 	sts	0x009A, r24
    8948:	08 95       	ret

0000894a <EMeter_DRE>:
	}
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    894a:	80 91 5d 09 	lds	r24, 0x095D
    894e:	88 23       	and	r24, r24
    8950:	19 f0       	breq	.+6      	; 0x8958 <EMeter_DRE+0xe>
    8952:	0e 94 87 44 	call	0x890e	; 0x890e <Debug_DRE>
    8956:	08 95       	ret
	else{
		if(Transparent){
    8958:	80 91 e0 09 	lds	r24, 0x09E0
    895c:	88 23       	and	r24, r24
    895e:	09 f4       	brne	.+2      	; 0x8962 <EMeter_DRE+0x18>
    8960:	5b c0       	rjmp	.+182    	; 0x8a18 <EMeter_DRE+0xce>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    8962:	90 91 44 08 	lds	r25, 0x0844
    8966:	80 91 62 0a 	lds	r24, 0x0A62
    896a:	98 17       	cp	r25, r24
    896c:	d1 f0       	breq	.+52     	; 0x89a2 <EMeter_DRE+0x58>
		GSM_RX_FIFO_End_Transp++;
    896e:	80 91 62 0a 	lds	r24, 0x0A62
    8972:	8f 5f       	subi	r24, 0xFF	; 255
    8974:	80 93 62 0a 	sts	0x0A62, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    8978:	80 91 62 0a 	lds	r24, 0x0A62
    897c:	8a 3f       	cpi	r24, 0xFA	; 250
    897e:	10 f0       	brcs	.+4      	; 0x8984 <EMeter_DRE+0x3a>
    8980:	10 92 62 0a 	sts	0x0A62, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    8984:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    8986:	e0 91 62 0a 	lds	r30, 0x0A62
    898a:	f0 e0       	ldi	r31, 0x00	; 0
    898c:	ea 58       	subi	r30, 0x8A	; 138
    898e:	fb 4f       	sbci	r31, 0xFB	; 251
    8990:	80 81       	ld	r24, Z
    8992:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    8996:	80 91 9b 00 	lds	r24, 0x009B
    899a:	80 64       	ori	r24, 0x40	; 64
    899c:	80 93 9b 00 	sts	0x009B, r24
    89a0:	03 c0       	rjmp	.+6      	; 0x89a8 <EMeter_DRE+0x5e>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    89a2:	88 ed       	ldi	r24, 0xD8	; 216
    89a4:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    89a8:	90 91 44 08 	lds	r25, 0x0844
    89ac:	80 91 62 0a 	lds	r24, 0x0A62
    89b0:	89 17       	cp	r24, r25
    89b2:	a0 f4       	brcc	.+40     	; 0x89dc <EMeter_DRE+0x92>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    89b4:	80 91 ea 08 	lds	r24, 0x08EA
    89b8:	20 91 44 08 	lds	r18, 0x0844
    89bc:	40 91 62 0a 	lds	r20, 0x0A62
    89c0:	90 e0       	ldi	r25, 0x00	; 0
    89c2:	30 e0       	ldi	r19, 0x00	; 0
    89c4:	24 1b       	sub	r18, r20
    89c6:	31 09       	sbc	r19, r1
    89c8:	82 17       	cp	r24, r18
    89ca:	93 07       	cpc	r25, r19
    89cc:	3c f4       	brge	.+14     	; 0x89dc <EMeter_DRE+0x92>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    89ce:	80 91 44 08 	lds	r24, 0x0844
    89d2:	90 91 62 0a 	lds	r25, 0x0A62
    89d6:	89 1b       	sub	r24, r25
    89d8:	80 93 ea 08 	sts	0x08EA, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    89dc:	90 91 62 0a 	lds	r25, 0x0A62
    89e0:	80 91 44 08 	lds	r24, 0x0844
    89e4:	89 17       	cp	r24, r25
    89e6:	78 f5       	brcc	.+94     	; 0x8a46 <EMeter_DRE+0xfc>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    89e8:	80 91 ea 08 	lds	r24, 0x08EA
    89ec:	40 91 62 0a 	lds	r20, 0x0A62
    89f0:	20 91 44 08 	lds	r18, 0x0844
    89f4:	90 e0       	ldi	r25, 0x00	; 0
    89f6:	30 e0       	ldi	r19, 0x00	; 0
    89f8:	26 50       	subi	r18, 0x06	; 6
    89fa:	3f 4f       	sbci	r19, 0xFF	; 255
    89fc:	24 1b       	sub	r18, r20
    89fe:	31 09       	sbc	r19, r1
    8a00:	82 17       	cp	r24, r18
    8a02:	93 07       	cpc	r25, r19
    8a04:	04 f5       	brge	.+64     	; 0x8a46 <EMeter_DRE+0xfc>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    8a06:	80 91 44 08 	lds	r24, 0x0844
    8a0a:	90 91 62 0a 	lds	r25, 0x0A62
    8a0e:	86 50       	subi	r24, 0x06	; 6
    8a10:	89 1b       	sub	r24, r25
    8a12:	80 93 ea 08 	sts	0x08EA, r24
    8a16:	08 95       	ret
			GetByteFromGSM_FIFO_Transp();
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    8a18:	90 91 c0 08 	lds	r25, 0x08C0
    8a1c:	80 91 ae 0c 	lds	r24, 0x0CAE
    8a20:	98 17       	cp	r25, r24
    8a22:	70 f4       	brcc	.+28     	; 0x8a40 <EMeter_DRE+0xf6>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    8a24:	e0 91 c0 08 	lds	r30, 0x08C0
    8a28:	f0 e0       	ldi	r31, 0x00	; 0
    8a2a:	ed 59       	subi	r30, 0x9D	; 157
    8a2c:	f5 4f       	sbci	r31, 0xF5	; 245
    8a2e:	80 81       	ld	r24, Z
    8a30:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    8a34:	80 91 c0 08 	lds	r24, 0x08C0
    8a38:	8f 5f       	subi	r24, 0xFF	; 255
    8a3a:	80 93 c0 08 	sts	0x08C0, r24
    8a3e:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    8a40:	88 ed       	ldi	r24, 0xD8	; 216
    8a42:	80 93 9a 00 	sts	0x009A, r24
    8a46:	08 95       	ret

00008a48 <__vector_31>:

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    8a48:	1f 92       	push	r1
    8a4a:	0f 92       	push	r0
    8a4c:	0f b6       	in	r0, 0x3f	; 63
    8a4e:	0f 92       	push	r0
    8a50:	0b b6       	in	r0, 0x3b	; 59
    8a52:	0f 92       	push	r0
    8a54:	11 24       	eor	r1, r1
    8a56:	2f 93       	push	r18
    8a58:	3f 93       	push	r19
    8a5a:	4f 93       	push	r20
    8a5c:	5f 93       	push	r21
    8a5e:	6f 93       	push	r22
    8a60:	7f 93       	push	r23
    8a62:	8f 93       	push	r24
    8a64:	9f 93       	push	r25
    8a66:	af 93       	push	r26
    8a68:	bf 93       	push	r27
    8a6a:	ef 93       	push	r30
    8a6c:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    8a6e:	80 91 63 03 	lds	r24, 0x0363
    8a72:	88 23       	and	r24, r24
    8a74:	29 f0       	breq	.+10     	; 0x8a80 <__vector_31+0x38>
    8a76:	8c e9       	ldi	r24, 0x9C	; 156
    8a78:	90 e0       	ldi	r25, 0x00	; 0
    8a7a:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Modbus_TX>
    8a7e:	02 c0       	rjmp	.+4      	; 0x8a84 <__vector_31+0x3c>
	else EMeter_DRE();
    8a80:	0e 94 a5 44 	call	0x894a	; 0x894a <EMeter_DRE>
	COMM_LED = 1;
    8a84:	81 e0       	ldi	r24, 0x01	; 1
    8a86:	80 93 8d 05 	sts	0x058D, r24
}
    8a8a:	ff 91       	pop	r31
    8a8c:	ef 91       	pop	r30
    8a8e:	bf 91       	pop	r27
    8a90:	af 91       	pop	r26
    8a92:	9f 91       	pop	r25
    8a94:	8f 91       	pop	r24
    8a96:	7f 91       	pop	r23
    8a98:	6f 91       	pop	r22
    8a9a:	5f 91       	pop	r21
    8a9c:	4f 91       	pop	r20
    8a9e:	3f 91       	pop	r19
    8aa0:	2f 91       	pop	r18
    8aa2:	0f 90       	pop	r0
    8aa4:	0b be       	out	0x3b, r0	; 59
    8aa6:	0f 90       	pop	r0
    8aa8:	0f be       	out	0x3f, r0	; 63
    8aaa:	0f 90       	pop	r0
    8aac:	1f 90       	pop	r1
    8aae:	18 95       	reti

00008ab0 <ToggleLED>:

#include "vem_debug.h"

#include "web.h"

void ToggleLED(uint8_t DO){
    8ab0:	28 2f       	mov	r18, r24
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    8ab2:	80 91 d0 08 	lds	r24, 0x08D0
    8ab6:	90 91 d1 08 	lds	r25, 0x08D1
    8aba:	a0 91 d2 08 	lds	r26, 0x08D2
    8abe:	b0 91 d3 08 	lds	r27, 0x08D3
    8ac2:	82 ff       	sbrs	r24, 2
    8ac4:	04 c0       	rjmp	.+8      	; 0x8ace <ToggleLED+0x1e>
    8ac6:	82 2f       	mov	r24, r18
    8ac8:	0e 94 30 3a 	call	0x7460	; 0x7460 <ResDigOut>
    8acc:	08 95       	ret
	else SetDigOut(DO);
    8ace:	82 2f       	mov	r24, r18
    8ad0:	0e 94 1c 3a 	call	0x7438	; 0x7438 <SetDigOut>
    8ad4:	08 95       	ret

00008ad6 <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    8ad6:	1f 93       	push	r17
    8ad8:	18 2f       	mov	r17, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    8ada:	21 ea       	ldi	r18, 0xA1	; 161
    8adc:	3a e0       	ldi	r19, 0x0A	; 10
    8ade:	4a eb       	ldi	r20, 0xBA	; 186
    8ae0:	55 e0       	ldi	r21, 0x05	; 5
    8ae2:	c9 01       	movw	r24, r18
    8ae4:	ba 01       	movw	r22, r20
    8ae6:	41 2f       	mov	r20, r17
    8ae8:	50 e0       	ldi	r21, 0x00	; 0
    8aea:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    8aee:	10 93 b4 08 	sts	0x08B4, r17
}
    8af2:	1f 91       	pop	r17
    8af4:	08 95       	ret

00008af6 <GPRS_SendRepCrash>:
	uint8_t size = GPRS_CrashData[13]+14;
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
	GPRS_FlgSz_Out = size;	//    .     
}
// --      
void GPRS_SendRepCrash(void){
    8af6:	1f 93       	push	r17
	uint8_t size = GPRS_CrashData[13]+14;
    8af8:	10 91 7f 09 	lds	r17, 0x097F
    8afc:	12 5f       	subi	r17, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    8afe:	82 e0       	ldi	r24, 0x02	; 2
    8b00:	80 93 81 09 	sts	0x0981, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    8b04:	21 ea       	ldi	r18, 0xA1	; 161
    8b06:	3a e0       	ldi	r19, 0x0A	; 10
    8b08:	42 e7       	ldi	r20, 0x72	; 114
    8b0a:	59 e0       	ldi	r21, 0x09	; 9
    8b0c:	c9 01       	movw	r24, r18
    8b0e:	ba 01       	movw	r22, r20
    8b10:	41 2f       	mov	r20, r17
    8b12:	50 e0       	ldi	r21, 0x00	; 0
    8b14:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    8b18:	10 93 b4 08 	sts	0x08B4, r17
}
    8b1c:	1f 91       	pop	r17
    8b1e:	08 95       	ret

00008b20 <GPRS_SendNewCrash>:

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    8b20:	1f 93       	push	r17
	uint8_t size = GPRS_CrashData[13]+14;
    8b22:	10 91 7f 09 	lds	r17, 0x097F
    8b26:	12 5f       	subi	r17, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    8b28:	21 ea       	ldi	r18, 0xA1	; 161
    8b2a:	3a e0       	ldi	r19, 0x0A	; 10
    8b2c:	42 e7       	ldi	r20, 0x72	; 114
    8b2e:	59 e0       	ldi	r21, 0x09	; 9
    8b30:	c9 01       	movw	r24, r18
    8b32:	ba 01       	movw	r22, r20
    8b34:	41 2f       	mov	r20, r17
    8b36:	50 e0       	ldi	r21, 0x00	; 0
    8b38:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    8b3c:	10 93 b4 08 	sts	0x08B4, r17
}
    8b40:	1f 91       	pop	r17
    8b42:	08 95       	ret

00008b44 <GSM_SendData>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
    8b44:	58 2f       	mov	r21, r24
    8b46:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8b48:	60 93 c5 08 	sts	0x08C5, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8b4c:	40 91 c5 08 	lds	r20, 0x08C5
    8b50:	21 ea       	ldi	r18, 0xA1	; 161
    8b52:	3b e0       	ldi	r19, 0x0B	; 11
    8b54:	c9 01       	movw	r24, r18
    8b56:	65 2f       	mov	r22, r21
    8b58:	50 e0       	ldi	r21, 0x00	; 0
    8b5a:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GSM_SendFirstChar();
    8b5e:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
}
    8b62:	08 95       	ret

00008b64 <GSM_AddHeaderSendData>:
	GSMTxSz++;
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
    8b64:	58 2f       	mov	r21, r24
    8b66:	79 2f       	mov	r23, r25
	GSMTxSz = Size;
    8b68:	60 93 c5 08 	sts	0x08C5, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    8b6c:	40 91 c5 08 	lds	r20, 0x08C5
    8b70:	21 ea       	ldi	r18, 0xA1	; 161
    8b72:	3b e0       	ldi	r19, 0x0B	; 11
    8b74:	c9 01       	movw	r24, r18
    8b76:	65 2f       	mov	r22, r21
    8b78:	50 e0       	ldi	r21, 0x00	; 0
    8b7a:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GSM_SendFirstChar();
    8b7e:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
}
    8b82:	08 95       	ret

00008b84 <GPRS_NewMsg>:
		}
	}
}

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
    8b84:	38 2f       	mov	r19, r24
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    8b86:	80 91 d6 08 	lds	r24, 0x08D6
    8b8a:	80 fd       	sbrc	r24, 0
    8b8c:	5b c0       	rjmp	.+182    	; 0x8c44 <GPRS_NewMsg+0xc0>
		GPRS_CrashID++;
    8b8e:	90 91 d4 01 	lds	r25, 0x01D4
    8b92:	9f 5f       	subi	r25, 0xFF	; 255
    8b94:	90 93 d4 01 	sts	0x01D4, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    8b98:	86 e0       	ldi	r24, 0x06	; 6
    8b9a:	80 93 72 09 	sts	0x0972, r24
		GPRS_CrashData[1] = 1;	
    8b9e:	21 e0       	ldi	r18, 0x01	; 1
    8ba0:	20 93 73 09 	sts	0x0973, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    8ba4:	80 91 e5 08 	lds	r24, 0x08E5
    8ba8:	80 93 74 09 	sts	0x0974, r24
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    8bac:	80 91 e4 08 	lds	r24, 0x08E4
    8bb0:	80 93 75 09 	sts	0x0975, r24
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    8bb4:	80 91 e3 08 	lds	r24, 0x08E3
    8bb8:	80 93 76 09 	sts	0x0976, r24
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    8bbc:	80 91 e2 08 	lds	r24, 0x08E2
    8bc0:	80 93 77 09 	sts	0x0977, r24
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    8bc4:	80 91 e1 08 	lds	r24, 0x08E1
    8bc8:	80 93 78 09 	sts	0x0978, r24
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    8bcc:	80 91 e0 08 	lds	r24, 0x08E0
    8bd0:	80 93 79 09 	sts	0x0979, r24
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    8bd4:	80 91 df 08 	lds	r24, 0x08DF
    8bd8:	80 93 7a 09 	sts	0x097A, r24
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    8bdc:	80 91 de 08 	lds	r24, 0x08DE
    8be0:	80 93 7b 09 	sts	0x097B, r24

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    8be4:	82 e0       	ldi	r24, 0x02	; 2
    8be6:	80 93 7c 09 	sts	0x097C, r24
		GPRS_CrashData[11] = SW_VERSION;		//   
    8bea:	83 e0       	ldi	r24, 0x03	; 3
    8bec:	80 93 7d 09 	sts	0x097D, r24
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    8bf0:	85 e0       	ldi	r24, 0x05	; 5
    8bf2:	80 93 7e 09 	sts	0x097E, r24
		
		GPRS_CrashData[14] = Type;
    8bf6:	30 93 80 09 	sts	0x0980, r19
		GPRS_CrashData[15] = 1;			//    
    8bfa:	20 93 81 09 	sts	0x0981, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    8bfe:	90 93 82 09 	sts	0x0982, r25

		GPRS_CrashData[17] = 0;
    8c02:	10 92 83 09 	sts	0x0983, r1
		GPRS_CrashData[18] = 0;
    8c06:	10 92 84 09 	sts	0x0984, r1
		GPRS_CrashData[19] = 0;
    8c0a:	10 92 85 09 	sts	0x0985, r1
		GPRS_CrashData[20] = 0;
    8c0e:	10 92 86 09 	sts	0x0986, r1
		GPRS_CrashData[21] = 0;
    8c12:	10 92 87 09 	sts	0x0987, r1
		GPRS_CrashData[22] = 0;
    8c16:	10 92 88 09 	sts	0x0988, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    8c1a:	89 e8       	ldi	r24, 0x89	; 137
    8c1c:	99 e0       	ldi	r25, 0x09	; 9
    8c1e:	42 e3       	ldi	r20, 0x32	; 50
    8c20:	50 e0       	ldi	r21, 0x00	; 0
    8c22:	0e 94 b6 87 	call	0x10f6c	; 0x10f6c <strlcpy_P>
    8c26:	87 5f       	subi	r24, 0xF7	; 247
    8c28:	80 93 7f 09 	sts	0x097F, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    8c2c:	80 91 ca 08 	lds	r24, 0x08CA
    8c30:	8f 7d       	andi	r24, 0xDF	; 223
    8c32:	80 64       	ori	r24, 0x40	; 64
    8c34:	80 93 ca 08 	sts	0x08CA, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    8c38:	80 91 8c 05 	lds	r24, 0x058C
    8c3c:	60 ee       	ldi	r22, 0xE0	; 224
    8c3e:	7e e2       	ldi	r23, 0x2E	; 46
    8c40:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    8c44:	08 95       	ret

00008c46 <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8c46:	0f 93       	push	r16
    8c48:	1f 93       	push	r17
    8c4a:	cf 93       	push	r28
    8c4c:	df 93       	push	r29
    8c4e:	eb 01       	movw	r28, r22
    8c50:	8c 01       	movw	r16, r24
    8c52:	01 5f       	subi	r16, 0xF1	; 241
    8c54:	1f 4f       	sbci	r17, 0xFF	; 255
    8c56:	f8 01       	movw	r30, r16
    8c58:	84 91       	lpm	r24, Z+
	if(prb(&Field->Prec)){
    8c5a:	88 23       	and	r24, r24
    8c5c:	69 f1       	breq	.+90     	; 0x8cb8 <WebPresicionHanler+0x72>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    8c5e:	cb 01       	movw	r24, r22
    8c60:	6e e2       	ldi	r22, 0x2E	; 46
    8c62:	70 e0       	ldi	r23, 0x00	; 0
    8c64:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    8c68:	9c 01       	movw	r18, r24
		if(p==NULL){
    8c6a:	00 97       	sbiw	r24, 0x00	; 0
    8c6c:	31 f4       	brne	.+12     	; 0x8c7a <WebPresicionHanler+0x34>
			p = strchr(BufStr,' ');	//else seek for first space
    8c6e:	ce 01       	movw	r24, r28
    8c70:	60 e2       	ldi	r22, 0x20	; 32
    8c72:	70 e0       	ldi	r23, 0x00	; 0
    8c74:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    8c78:	9c 01       	movw	r18, r24
    8c7a:	d9 01       	movw	r26, r18
    8c7c:	f8 01       	movw	r30, r16
    8c7e:	64 91       	lpm	r22, Z+
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    8c80:	70 e3       	ldi	r23, 0x30	; 48
    8c82:	16 c0       	rjmp	.+44     	; 0x8cb0 <WebPresicionHanler+0x6a>
    8c84:	8c 91       	ld	r24, X
    8c86:	80 32       	cpi	r24, 0x20	; 32
    8c88:	09 f4       	brne	.+2      	; 0x8c8c <WebPresicionHanler+0x46>
    8c8a:	7c 93       	st	X, r23
			if(*p == '.'){
    8c8c:	5c 91       	ld	r21, X
    8c8e:	5e 32       	cpi	r21, 0x2E	; 46
    8c90:	71 f4       	brne	.+28     	; 0x8cae <WebPresicionHanler+0x68>
				if(isdigit(*(p+1))){
    8c92:	11 96       	adiw	r26, 0x01	; 1
    8c94:	4c 91       	ld	r20, X
    8c96:	11 97       	sbiw	r26, 0x01	; 1
    8c98:	84 2f       	mov	r24, r20
    8c9a:	90 e0       	ldi	r25, 0x00	; 0
    8c9c:	c0 97       	sbiw	r24, 0x30	; 48
    8c9e:	0a 97       	sbiw	r24, 0x0a	; 10
    8ca0:	28 f4       	brcc	.+10     	; 0x8cac <WebPresicionHanler+0x66>
					*p= *(p+1);
    8ca2:	4c 93       	st	X, r20
					*(p+1) = '.';
    8ca4:	11 96       	adiw	r26, 0x01	; 1
    8ca6:	5c 93       	st	X, r21
    8ca8:	11 97       	sbiw	r26, 0x01	; 1
    8caa:	01 c0       	rjmp	.+2      	; 0x8cae <WebPresicionHanler+0x68>
				}
				else *p='0'; 
    8cac:	7c 93       	st	X, r23
			}
			p++;
    8cae:	11 96       	adiw	r26, 0x01	; 1
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    8cb0:	8a 2f       	mov	r24, r26
    8cb2:	82 1b       	sub	r24, r18
    8cb4:	86 17       	cp	r24, r22
    8cb6:	30 f3       	brcs	.-52     	; 0x8c84 <WebPresicionHanler+0x3e>
			}
			p++;
		}
	}
	
}
    8cb8:	df 91       	pop	r29
    8cba:	cf 91       	pop	r28
    8cbc:	1f 91       	pop	r17
    8cbe:	0f 91       	pop	r16
    8cc0:	08 95       	ret

00008cc2 <EMeter_ZMR110_Data_ConvertI>:
		}
	}	
	return 0;
}
// ~~~~~~~~~
uint16_t EMeter_ZMR110_Data_ConvertI(prog_char *Str_P, uint8_t FlagNum){
    8cc2:	ff 92       	push	r15
    8cc4:	0f 93       	push	r16
    8cc6:	1f 93       	push	r17
    8cc8:	df 93       	push	r29
    8cca:	cf 93       	push	r28
    8ccc:	00 d0       	rcall	.+0      	; 0x8cce <EMeter_ZMR110_Data_ConvertI+0xc>
    8cce:	cd b7       	in	r28, 0x3d	; 61
    8cd0:	de b7       	in	r29, 0x3e	; 62
    8cd2:	9c 01       	movw	r18, r24
    8cd4:	f6 2e       	mov	r15, r22
	uint16_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    8cd6:	00 91 85 05 	lds	r16, 0x0585
    8cda:	10 91 86 05 	lds	r17, 0x0586
    8cde:	c8 01       	movw	r24, r16
    8ce0:	b9 01       	movw	r22, r18
    8ce2:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    8ce6:	00 97       	sbiw	r24, 0x00	; 0
    8ce8:	09 f4       	brne	.+2      	; 0x8cec <EMeter_ZMR110_Data_ConvertI+0x2a>
    8cea:	63 c0       	rjmp	.+198    	; 0x8db2 <EMeter_ZMR110_Data_ConvertI+0xf0>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    8cec:	ac 01       	movw	r20, r24
    8cee:	40 1b       	sub	r20, r16
    8cf0:	51 0b       	sbc	r21, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    8cf2:	4d 3f       	cpi	r20, 0xFD	; 253
    8cf4:	51 05       	cpc	r21, r1
    8cf6:	08 f0       	brcs	.+2      	; 0x8cfa <EMeter_ZMR110_Data_ConvertI+0x38>
    8cf8:	5c c0       	rjmp	.+184    	; 0x8db2 <EMeter_ZMR110_Data_ConvertI+0xf0>
			EMeter_RxStr_Offset[Start+10]=	EMeter_RxStr_Offset[Start+11];	//  
    8cfa:	da 01       	movw	r26, r20
    8cfc:	1b 96       	adiw	r26, 0x0b	; 11
    8cfe:	98 01       	movw	r18, r16
    8d00:	24 0f       	add	r18, r20
    8d02:	35 1f       	adc	r19, r21
    8d04:	0a 0f       	add	r16, r26
    8d06:	1b 1f       	adc	r17, r27
    8d08:	f8 01       	movw	r30, r16
    8d0a:	80 81       	ld	r24, Z
    8d0c:	f9 01       	movw	r30, r18
    8d0e:	82 87       	std	Z+10, r24	; 0x0a
			EMeter_RxStr_Offset[Start+11]=	EMeter_RxStr_Offset[Start+12];
    8d10:	e0 91 85 05 	lds	r30, 0x0585
    8d14:	f0 91 86 05 	lds	r31, 0x0586
    8d18:	9a 01       	movw	r18, r20
    8d1a:	24 5f       	subi	r18, 0xF4	; 244
    8d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    8d1e:	ae 0f       	add	r26, r30
    8d20:	bf 1f       	adc	r27, r31
    8d22:	e2 0f       	add	r30, r18
    8d24:	f3 1f       	adc	r31, r19
    8d26:	80 81       	ld	r24, Z
    8d28:	8c 93       	st	X, r24
			EMeter_RxStr_Offset[Start+12]= ' ';
    8d2a:	e0 91 85 05 	lds	r30, 0x0585
    8d2e:	f0 91 86 05 	lds	r31, 0x0586
    8d32:	e2 0f       	add	r30, r18
    8d34:	f3 1f       	adc	r31, r19
    8d36:	80 e2       	ldi	r24, 0x20	; 32
    8d38:	80 83       	st	Z, r24
			sscanf(EMeter_RxStr_Offset+Start+7,"%u",&Result);
    8d3a:	00 d0       	rcall	.+0      	; 0x8d3c <EMeter_ZMR110_Data_ConvertI+0x7a>
    8d3c:	00 d0       	rcall	.+0      	; 0x8d3e <EMeter_ZMR110_Data_ConvertI+0x7c>
    8d3e:	00 d0       	rcall	.+0      	; 0x8d40 <EMeter_ZMR110_Data_ConvertI+0x7e>
    8d40:	ed b7       	in	r30, 0x3d	; 61
    8d42:	fe b7       	in	r31, 0x3e	; 62
    8d44:	31 96       	adiw	r30, 0x01	; 1
    8d46:	49 5f       	subi	r20, 0xF9	; 249
    8d48:	5f 4f       	sbci	r21, 0xFF	; 255
    8d4a:	80 91 85 05 	lds	r24, 0x0585
    8d4e:	90 91 86 05 	lds	r25, 0x0586
    8d52:	84 0f       	add	r24, r20
    8d54:	95 1f       	adc	r25, r21
    8d56:	ad b7       	in	r26, 0x3d	; 61
    8d58:	be b7       	in	r27, 0x3e	; 62
    8d5a:	12 96       	adiw	r26, 0x02	; 2
    8d5c:	9c 93       	st	X, r25
    8d5e:	8e 93       	st	-X, r24
    8d60:	11 97       	sbiw	r26, 0x01	; 1
    8d62:	80 e0       	ldi	r24, 0x00	; 0
    8d64:	91 e0       	ldi	r25, 0x01	; 1
    8d66:	93 83       	std	Z+3, r25	; 0x03
    8d68:	82 83       	std	Z+2, r24	; 0x02
    8d6a:	ce 01       	movw	r24, r28
    8d6c:	01 96       	adiw	r24, 0x01	; 1
    8d6e:	95 83       	std	Z+5, r25	; 0x05
    8d70:	84 83       	std	Z+4, r24	; 0x04
    8d72:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    8d76:	ef 2d       	mov	r30, r15
    8d78:	e6 95       	lsr	r30
    8d7a:	e6 95       	lsr	r30
    8d7c:	e6 95       	lsr	r30
    8d7e:	f0 e0       	ldi	r31, 0x00	; 0
    8d80:	e1 58       	subi	r30, 0x81	; 129
    8d82:	fa 4f       	sbci	r31, 0xFA	; 250
    8d84:	b7 e0       	ldi	r27, 0x07	; 7
    8d86:	fb 22       	and	r15, r27
    8d88:	81 e0       	ldi	r24, 0x01	; 1
    8d8a:	90 e0       	ldi	r25, 0x00	; 0
    8d8c:	02 c0       	rjmp	.+4      	; 0x8d92 <EMeter_ZMR110_Data_ConvertI+0xd0>
    8d8e:	88 0f       	add	r24, r24
    8d90:	99 1f       	adc	r25, r25
    8d92:	fa 94       	dec	r15
    8d94:	e2 f7       	brpl	.-8      	; 0x8d8e <EMeter_ZMR110_Data_ConvertI+0xcc>
    8d96:	20 81       	ld	r18, Z
    8d98:	28 2b       	or	r18, r24
    8d9a:	20 83       	st	Z, r18
			return Result;
    8d9c:	29 81       	ldd	r18, Y+1	; 0x01
    8d9e:	3a 81       	ldd	r19, Y+2	; 0x02
    8da0:	ed b7       	in	r30, 0x3d	; 61
    8da2:	fe b7       	in	r31, 0x3e	; 62
    8da4:	36 96       	adiw	r30, 0x06	; 6
    8da6:	0f b6       	in	r0, 0x3f	; 63
    8da8:	f8 94       	cli
    8daa:	fe bf       	out	0x3e, r31	; 62
    8dac:	0f be       	out	0x3f, r0	; 63
    8dae:	ed bf       	out	0x3d, r30	; 61
    8db0:	02 c0       	rjmp	.+4      	; 0x8db6 <EMeter_ZMR110_Data_ConvertI+0xf4>
    8db2:	20 e0       	ldi	r18, 0x00	; 0
    8db4:	30 e0       	ldi	r19, 0x00	; 0
		}
	}	
	return 0;
}
    8db6:	c9 01       	movw	r24, r18
    8db8:	0f 90       	pop	r0
    8dba:	0f 90       	pop	r0
    8dbc:	cf 91       	pop	r28
    8dbe:	df 91       	pop	r29
    8dc0:	1f 91       	pop	r17
    8dc2:	0f 91       	pop	r16
    8dc4:	ff 90       	pop	r15
    8dc6:	08 95       	ret

00008dc8 <EMeter_ZMR110_Data_ConvertQ>:

uint8_t Check_LG_ZMR110_READ_FLAG(uint8_t FlagNum){
	return LG_ZMR110_READ_FLAG[FlagNum/8] & (1<<FlagNum%8);
}

uint32_t EMeter_ZMR110_Data_ConvertQ(prog_char *Str_P, uint8_t FlagNum){
    8dc8:	ef 92       	push	r14
    8dca:	ff 92       	push	r15
    8dcc:	0f 93       	push	r16
    8dce:	df 93       	push	r29
    8dd0:	cf 93       	push	r28
    8dd2:	00 d0       	rcall	.+0      	; 0x8dd4 <EMeter_ZMR110_Data_ConvertQ+0xc>
    8dd4:	00 d0       	rcall	.+0      	; 0x8dd6 <EMeter_ZMR110_Data_ConvertQ+0xe>
    8dd6:	00 d0       	rcall	.+0      	; 0x8dd8 <EMeter_ZMR110_Data_ConvertQ+0x10>
    8dd8:	cd b7       	in	r28, 0x3d	; 61
    8dda:	de b7       	in	r29, 0x3e	; 62
    8ddc:	9c 01       	movw	r18, r24
    8dde:	06 2f       	mov	r16, r22
	uint32_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    8de0:	e0 90 85 05 	lds	r14, 0x0585
    8de4:	f0 90 86 05 	lds	r15, 0x0586
    8de8:	c7 01       	movw	r24, r14
    8dea:	b9 01       	movw	r22, r18
    8dec:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    8df0:	00 97       	sbiw	r24, 0x00	; 0
    8df2:	09 f4       	brne	.+2      	; 0x8df6 <EMeter_ZMR110_Data_ConvertQ+0x2e>
    8df4:	8d c0       	rjmp	.+282    	; 0x8f10 <EMeter_ZMR110_Data_ConvertQ+0x148>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    8df6:	ac 01       	movw	r20, r24
    8df8:	4e 19       	sub	r20, r14
    8dfa:	5f 09       	sbc	r21, r15
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    8dfc:	4d 3f       	cpi	r20, 0xFD	; 253
    8dfe:	51 05       	cpc	r21, r1
    8e00:	08 f0       	brcs	.+2      	; 0x8e04 <EMeter_ZMR110_Data_ConvertQ+0x3c>
    8e02:	86 c0       	rjmp	.+268    	; 0x8f10 <EMeter_ZMR110_Data_ConvertQ+0x148>
			EMeter_RxStr_Offset[Start+12]=	EMeter_RxStr_Offset[Start+13];	//  
    8e04:	ca 01       	movw	r24, r20
    8e06:	0d 96       	adiw	r24, 0x0d	; 13
    8e08:	9e 83       	std	Y+6, r25	; 0x06
    8e0a:	8d 83       	std	Y+5, r24	; 0x05
    8e0c:	f7 01       	movw	r30, r14
    8e0e:	e4 0f       	add	r30, r20
    8e10:	f5 1f       	adc	r31, r21
    8e12:	e8 0e       	add	r14, r24
    8e14:	f9 1e       	adc	r15, r25
    8e16:	d7 01       	movw	r26, r14
    8e18:	8c 91       	ld	r24, X
    8e1a:	84 87       	std	Z+12, r24	; 0x0c
			EMeter_RxStr_Offset[Start+13]=	EMeter_RxStr_Offset[Start+14];
    8e1c:	e0 91 85 05 	lds	r30, 0x0585
    8e20:	f0 91 86 05 	lds	r31, 0x0586
    8e24:	da 01       	movw	r26, r20
    8e26:	1e 96       	adiw	r26, 0x0e	; 14
    8e28:	2d 81       	ldd	r18, Y+5	; 0x05
    8e2a:	3e 81       	ldd	r19, Y+6	; 0x06
    8e2c:	2e 0f       	add	r18, r30
    8e2e:	3f 1f       	adc	r19, r31
    8e30:	ea 0f       	add	r30, r26
    8e32:	fb 1f       	adc	r31, r27
    8e34:	80 81       	ld	r24, Z
    8e36:	f9 01       	movw	r30, r18
    8e38:	80 83       	st	Z, r24
			EMeter_RxStr_Offset[Start+14]=	EMeter_RxStr_Offset[Start+15];
    8e3a:	e0 91 85 05 	lds	r30, 0x0585
    8e3e:	f0 91 86 05 	lds	r31, 0x0586
    8e42:	9a 01       	movw	r18, r20
    8e44:	21 5f       	subi	r18, 0xF1	; 241
    8e46:	3f 4f       	sbci	r19, 0xFF	; 255
    8e48:	ae 0f       	add	r26, r30
    8e4a:	bf 1f       	adc	r27, r31
    8e4c:	e2 0f       	add	r30, r18
    8e4e:	f3 1f       	adc	r31, r19
    8e50:	80 81       	ld	r24, Z
    8e52:	8c 93       	st	X, r24
			EMeter_RxStr_Offset[Start+15]= ' ';
    8e54:	e0 91 85 05 	lds	r30, 0x0585
    8e58:	f0 91 86 05 	lds	r31, 0x0586
    8e5c:	e2 0f       	add	r30, r18
    8e5e:	f3 1f       	adc	r31, r19
    8e60:	80 e2       	ldi	r24, 0x20	; 32
    8e62:	80 83       	st	Z, r24
			sscanf(EMeter_RxStr_Offset+Start+6,"%ld",&Result);
    8e64:	00 d0       	rcall	.+0      	; 0x8e66 <EMeter_ZMR110_Data_ConvertQ+0x9e>
    8e66:	00 d0       	rcall	.+0      	; 0x8e68 <EMeter_ZMR110_Data_ConvertQ+0xa0>
    8e68:	00 d0       	rcall	.+0      	; 0x8e6a <EMeter_ZMR110_Data_ConvertQ+0xa2>
    8e6a:	ed b7       	in	r30, 0x3d	; 61
    8e6c:	fe b7       	in	r31, 0x3e	; 62
    8e6e:	31 96       	adiw	r30, 0x01	; 1
    8e70:	4a 5f       	subi	r20, 0xFA	; 250
    8e72:	5f 4f       	sbci	r21, 0xFF	; 255
    8e74:	80 91 85 05 	lds	r24, 0x0585
    8e78:	90 91 86 05 	lds	r25, 0x0586
    8e7c:	84 0f       	add	r24, r20
    8e7e:	95 1f       	adc	r25, r21
    8e80:	ad b7       	in	r26, 0x3d	; 61
    8e82:	be b7       	in	r27, 0x3e	; 62
    8e84:	12 96       	adiw	r26, 0x02	; 2
    8e86:	9c 93       	st	X, r25
    8e88:	8e 93       	st	-X, r24
    8e8a:	11 97       	sbiw	r26, 0x01	; 1
    8e8c:	83 e0       	ldi	r24, 0x03	; 3
    8e8e:	91 e0       	ldi	r25, 0x01	; 1
    8e90:	93 83       	std	Z+3, r25	; 0x03
    8e92:	82 83       	std	Z+2, r24	; 0x02
    8e94:	ce 01       	movw	r24, r28
    8e96:	01 96       	adiw	r24, 0x01	; 1
    8e98:	95 83       	std	Z+5, r25	; 0x05
    8e9a:	84 83       	std	Z+4, r24	; 0x04
    8e9c:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    8ea0:	e0 2f       	mov	r30, r16
    8ea2:	e6 95       	lsr	r30
    8ea4:	e6 95       	lsr	r30
    8ea6:	e6 95       	lsr	r30
    8ea8:	f0 e0       	ldi	r31, 0x00	; 0
    8eaa:	e1 58       	subi	r30, 0x81	; 129
    8eac:	fa 4f       	sbci	r31, 0xFA	; 250
    8eae:	07 70       	andi	r16, 0x07	; 7
    8eb0:	81 e0       	ldi	r24, 0x01	; 1
    8eb2:	90 e0       	ldi	r25, 0x00	; 0
    8eb4:	02 c0       	rjmp	.+4      	; 0x8eba <EMeter_ZMR110_Data_ConvertQ+0xf2>
    8eb6:	88 0f       	add	r24, r24
    8eb8:	99 1f       	adc	r25, r25
    8eba:	0a 95       	dec	r16
    8ebc:	e2 f7       	brpl	.-8      	; 0x8eb6 <EMeter_ZMR110_Data_ConvertQ+0xee>
    8ebe:	20 81       	ld	r18, Z
    8ec0:	28 2b       	or	r18, r24
    8ec2:	20 83       	st	Z, r18
			if(EMeter_RxStr_Offset[Start+13]=='*') Result *=100;
    8ec4:	e0 91 85 05 	lds	r30, 0x0585
    8ec8:	f0 91 86 05 	lds	r31, 0x0586
    8ecc:	8d 81       	ldd	r24, Y+5	; 0x05
    8ece:	9e 81       	ldd	r25, Y+6	; 0x06
    8ed0:	e8 0f       	add	r30, r24
    8ed2:	f9 1f       	adc	r31, r25
    8ed4:	ad b7       	in	r26, 0x3d	; 61
    8ed6:	be b7       	in	r27, 0x3e	; 62
    8ed8:	16 96       	adiw	r26, 0x06	; 6
    8eda:	0f b6       	in	r0, 0x3f	; 63
    8edc:	f8 94       	cli
    8ede:	be bf       	out	0x3e, r27	; 62
    8ee0:	0f be       	out	0x3f, r0	; 63
    8ee2:	ad bf       	out	0x3d, r26	; 61
    8ee4:	80 81       	ld	r24, Z
    8ee6:	8a 32       	cpi	r24, 0x2A	; 42
    8ee8:	71 f4       	brne	.+28     	; 0x8f06 <EMeter_ZMR110_Data_ConvertQ+0x13e>
    8eea:	69 81       	ldd	r22, Y+1	; 0x01
    8eec:	7a 81       	ldd	r23, Y+2	; 0x02
    8eee:	8b 81       	ldd	r24, Y+3	; 0x03
    8ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    8ef2:	24 e6       	ldi	r18, 0x64	; 100
    8ef4:	30 e0       	ldi	r19, 0x00	; 0
    8ef6:	40 e0       	ldi	r20, 0x00	; 0
    8ef8:	50 e0       	ldi	r21, 0x00	; 0
    8efa:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    8efe:	69 83       	std	Y+1, r22	; 0x01
    8f00:	7a 83       	std	Y+2, r23	; 0x02
    8f02:	8b 83       	std	Y+3, r24	; 0x03
    8f04:	9c 83       	std	Y+4, r25	; 0x04
			return Result;
    8f06:	29 81       	ldd	r18, Y+1	; 0x01
    8f08:	3a 81       	ldd	r19, Y+2	; 0x02
    8f0a:	4b 81       	ldd	r20, Y+3	; 0x03
    8f0c:	5c 81       	ldd	r21, Y+4	; 0x04
    8f0e:	04 c0       	rjmp	.+8      	; 0x8f18 <EMeter_ZMR110_Data_ConvertQ+0x150>
    8f10:	20 e0       	ldi	r18, 0x00	; 0
    8f12:	30 e0       	ldi	r19, 0x00	; 0
    8f14:	40 e0       	ldi	r20, 0x00	; 0
    8f16:	50 e0       	ldi	r21, 0x00	; 0
		}
	}	
	return 0;
}
    8f18:	b9 01       	movw	r22, r18
    8f1a:	ca 01       	movw	r24, r20
    8f1c:	26 96       	adiw	r28, 0x06	; 6
    8f1e:	0f b6       	in	r0, 0x3f	; 63
    8f20:	f8 94       	cli
    8f22:	de bf       	out	0x3e, r29	; 62
    8f24:	0f be       	out	0x3f, r0	; 63
    8f26:	cd bf       	out	0x3d, r28	; 61
    8f28:	cf 91       	pop	r28
    8f2a:	df 91       	pop	r29
    8f2c:	0f 91       	pop	r16
    8f2e:	ff 90       	pop	r15
    8f30:	ef 90       	pop	r14
    8f32:	08 95       	ret

00008f34 <EMeter_ZMR110_Read_ID1_1>:
		}
	}	
	return 0;
}
// ~~~~~~~~~
void EMeter_ZMR110_Read_ID1_1(prog_char *Str_P, uint8_t FlagNum){
    8f34:	1f 93       	push	r17
    8f36:	cf 93       	push	r28
    8f38:	df 93       	push	r29
    8f3a:	9c 01       	movw	r18, r24
    8f3c:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    8f3e:	c0 91 85 05 	lds	r28, 0x0585
    8f42:	d0 91 86 05 	lds	r29, 0x0586
    8f46:	ce 01       	movw	r24, r28
    8f48:	b9 01       	movw	r22, r18
    8f4a:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    8f4e:	00 97       	sbiw	r24, 0x00	; 0
    8f50:	d1 f1       	breq	.+116    	; 0x8fc6 <EMeter_ZMR110_Read_ID1_1+0x92>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    8f52:	ac 01       	movw	r20, r24
    8f54:	4c 1b       	sub	r20, r28
    8f56:	5d 0b       	sbc	r21, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    8f58:	4d 3f       	cpi	r20, 0xFD	; 253
    8f5a:	51 05       	cpc	r21, r1
    8f5c:	a0 f5       	brcc	.+104    	; 0x8fc6 <EMeter_ZMR110_Read_ID1_1+0x92>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    8f5e:	e1 2f       	mov	r30, r17
    8f60:	e6 95       	lsr	r30
    8f62:	e6 95       	lsr	r30
    8f64:	e6 95       	lsr	r30
    8f66:	f0 e0       	ldi	r31, 0x00	; 0
    8f68:	e1 58       	subi	r30, 0x81	; 129
    8f6a:	fa 4f       	sbci	r31, 0xFA	; 250
    8f6c:	17 70       	andi	r17, 0x07	; 7
    8f6e:	81 e0       	ldi	r24, 0x01	; 1
    8f70:	90 e0       	ldi	r25, 0x00	; 0
    8f72:	02 c0       	rjmp	.+4      	; 0x8f78 <EMeter_ZMR110_Read_ID1_1+0x44>
    8f74:	88 0f       	add	r24, r24
    8f76:	99 1f       	adc	r25, r25
    8f78:	1a 95       	dec	r17
    8f7a:	e2 f7       	brpl	.-8      	; 0x8f74 <EMeter_ZMR110_Read_ID1_1+0x40>
    8f7c:	20 81       	ld	r18, Z
    8f7e:	28 2b       	or	r18, r24
    8f80:	20 83       	st	Z, r18
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%8s"), EM_ID_Str);
    8f82:	00 d0       	rcall	.+0      	; 0x8f84 <EMeter_ZMR110_Read_ID1_1+0x50>
    8f84:	00 d0       	rcall	.+0      	; 0x8f86 <EMeter_ZMR110_Read_ID1_1+0x52>
    8f86:	00 d0       	rcall	.+0      	; 0x8f88 <EMeter_ZMR110_Read_ID1_1+0x54>
    8f88:	ed b7       	in	r30, 0x3d	; 61
    8f8a:	fe b7       	in	r31, 0x3e	; 62
    8f8c:	31 96       	adiw	r30, 0x01	; 1
    8f8e:	4a 5f       	subi	r20, 0xFA	; 250
    8f90:	5f 4f       	sbci	r21, 0xFF	; 255
    8f92:	c4 0f       	add	r28, r20
    8f94:	d5 1f       	adc	r29, r21
    8f96:	ad b7       	in	r26, 0x3d	; 61
    8f98:	be b7       	in	r27, 0x3e	; 62
    8f9a:	12 96       	adiw	r26, 0x02	; 2
    8f9c:	dc 93       	st	X, r29
    8f9e:	ce 93       	st	-X, r28
    8fa0:	11 97       	sbiw	r26, 0x01	; 1
    8fa2:	83 ed       	ldi	r24, 0xD3	; 211
    8fa4:	98 e4       	ldi	r25, 0x48	; 72
    8fa6:	93 83       	std	Z+3, r25	; 0x03
    8fa8:	82 83       	std	Z+2, r24	; 0x02
    8faa:	8f ee       	ldi	r24, 0xEF	; 239
    8fac:	97 e0       	ldi	r25, 0x07	; 7
    8fae:	95 83       	std	Z+5, r25	; 0x05
    8fb0:	84 83       	std	Z+4, r24	; 0x04
    8fb2:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
    8fb6:	8d b7       	in	r24, 0x3d	; 61
    8fb8:	9e b7       	in	r25, 0x3e	; 62
    8fba:	06 96       	adiw	r24, 0x06	; 6
    8fbc:	0f b6       	in	r0, 0x3f	; 63
    8fbe:	f8 94       	cli
    8fc0:	9e bf       	out	0x3e, r25	; 62
    8fc2:	0f be       	out	0x3f, r0	; 63
    8fc4:	8d bf       	out	0x3d, r24	; 61
		}
	}	
}
    8fc6:	df 91       	pop	r29
    8fc8:	cf 91       	pop	r28
    8fca:	1f 91       	pop	r17
    8fcc:	08 95       	ret

00008fce <EMeter_ZMR110_Read_Time>:
		}
	}	
}

// ~~~~~~~~~
void EMeter_ZMR110_Read_Time(prog_char *Str_P, uint8_t FlagNum){
    8fce:	1f 93       	push	r17
    8fd0:	cf 93       	push	r28
    8fd2:	df 93       	push	r29
    8fd4:	9c 01       	movw	r18, r24
    8fd6:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    8fd8:	c0 91 85 05 	lds	r28, 0x0585
    8fdc:	d0 91 86 05 	lds	r29, 0x0586
    8fe0:	ce 01       	movw	r24, r28
    8fe2:	b9 01       	movw	r22, r18
    8fe4:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    8fe8:	00 97       	sbiw	r24, 0x00	; 0
    8fea:	09 f4       	brne	.+2      	; 0x8fee <EMeter_ZMR110_Read_Time+0x20>
    8fec:	48 c0       	rjmp	.+144    	; 0x907e <EMeter_ZMR110_Read_Time+0xb0>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    8fee:	ac 01       	movw	r20, r24
    8ff0:	4c 1b       	sub	r20, r28
    8ff2:	5d 0b       	sbc	r21, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    8ff4:	4d 3f       	cpi	r20, 0xFD	; 253
    8ff6:	51 05       	cpc	r21, r1
    8ff8:	08 f0       	brcs	.+2      	; 0x8ffc <EMeter_ZMR110_Read_Time+0x2e>
    8ffa:	41 c0       	rjmp	.+130    	; 0x907e <EMeter_ZMR110_Read_Time+0xb0>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    8ffc:	e1 2f       	mov	r30, r17
    8ffe:	e6 95       	lsr	r30
    9000:	e6 95       	lsr	r30
    9002:	e6 95       	lsr	r30
    9004:	f0 e0       	ldi	r31, 0x00	; 0
    9006:	e1 58       	subi	r30, 0x81	; 129
    9008:	fa 4f       	sbci	r31, 0xFA	; 250
    900a:	17 70       	andi	r17, 0x07	; 7
    900c:	81 e0       	ldi	r24, 0x01	; 1
    900e:	90 e0       	ldi	r25, 0x00	; 0
    9010:	02 c0       	rjmp	.+4      	; 0x9016 <EMeter_ZMR110_Read_Time+0x48>
    9012:	88 0f       	add	r24, r24
    9014:	99 1f       	adc	r25, r25
    9016:	1a 95       	dec	r17
    9018:	e2 f7       	brpl	.-8      	; 0x9012 <EMeter_ZMR110_Read_Time+0x44>
    901a:	20 81       	ld	r18, Z
    901c:	28 2b       	or	r18, r24
    901e:	20 83       	st	Z, r18
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%hhu:%hhu:%hhu"),&EM_Hour, &EM_Min, &EM_Sec);
    9020:	8d b7       	in	r24, 0x3d	; 61
    9022:	9e b7       	in	r25, 0x3e	; 62
    9024:	0a 97       	sbiw	r24, 0x0a	; 10
    9026:	0f b6       	in	r0, 0x3f	; 63
    9028:	f8 94       	cli
    902a:	9e bf       	out	0x3e, r25	; 62
    902c:	0f be       	out	0x3f, r0	; 63
    902e:	8d bf       	out	0x3d, r24	; 61
    9030:	ed b7       	in	r30, 0x3d	; 61
    9032:	fe b7       	in	r31, 0x3e	; 62
    9034:	31 96       	adiw	r30, 0x01	; 1
    9036:	4a 5f       	subi	r20, 0xFA	; 250
    9038:	5f 4f       	sbci	r21, 0xFF	; 255
    903a:	c4 0f       	add	r28, r20
    903c:	d5 1f       	adc	r29, r21
    903e:	ad b7       	in	r26, 0x3d	; 61
    9040:	be b7       	in	r27, 0x3e	; 62
    9042:	12 96       	adiw	r26, 0x02	; 2
    9044:	dc 93       	st	X, r29
    9046:	ce 93       	st	-X, r28
    9048:	11 97       	sbiw	r26, 0x01	; 1
    904a:	8c ed       	ldi	r24, 0xDC	; 220
    904c:	98 e4       	ldi	r25, 0x48	; 72
    904e:	93 83       	std	Z+3, r25	; 0x03
    9050:	82 83       	std	Z+2, r24	; 0x02
    9052:	8c ed       	ldi	r24, 0xDC	; 220
    9054:	98 e0       	ldi	r25, 0x08	; 8
    9056:	95 83       	std	Z+5, r25	; 0x05
    9058:	84 83       	std	Z+4, r24	; 0x04
    905a:	8c eb       	ldi	r24, 0xBC	; 188
    905c:	98 e0       	ldi	r25, 0x08	; 8
    905e:	97 83       	std	Z+7, r25	; 0x07
    9060:	86 83       	std	Z+6, r24	; 0x06
    9062:	8b e8       	ldi	r24, 0x8B	; 139
    9064:	95 e0       	ldi	r25, 0x05	; 5
    9066:	91 87       	std	Z+9, r25	; 0x09
    9068:	80 87       	std	Z+8, r24	; 0x08
    906a:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
    906e:	8d b7       	in	r24, 0x3d	; 61
    9070:	9e b7       	in	r25, 0x3e	; 62
    9072:	0a 96       	adiw	r24, 0x0a	; 10
    9074:	0f b6       	in	r0, 0x3f	; 63
    9076:	f8 94       	cli
    9078:	9e bf       	out	0x3e, r25	; 62
    907a:	0f be       	out	0x3f, r0	; 63
    907c:	8d bf       	out	0x3d, r24	; 61
		}
	}	
}
    907e:	df 91       	pop	r29
    9080:	cf 91       	pop	r28
    9082:	1f 91       	pop	r17
    9084:	08 95       	ret

00009086 <EMeter_ZMR110_Read_Date>:
		}
	}	
	return 0;
}
// ~~~~~~~~~
void EMeter_ZMR110_Read_Date(prog_char *Str_P, uint8_t FlagNum){
    9086:	1f 93       	push	r17
    9088:	cf 93       	push	r28
    908a:	df 93       	push	r29
    908c:	9c 01       	movw	r18, r24
    908e:	16 2f       	mov	r17, r22
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    9090:	c0 91 85 05 	lds	r28, 0x0585
    9094:	d0 91 86 05 	lds	r29, 0x0586
    9098:	ce 01       	movw	r24, r28
    909a:	b9 01       	movw	r22, r18
    909c:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    90a0:	00 97       	sbiw	r24, 0x00	; 0
    90a2:	09 f4       	brne	.+2      	; 0x90a6 <EMeter_ZMR110_Read_Date+0x20>
    90a4:	48 c0       	rjmp	.+144    	; 0x9136 <EMeter_ZMR110_Read_Date+0xb0>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    90a6:	ac 01       	movw	r20, r24
    90a8:	4c 1b       	sub	r20, r28
    90aa:	5d 0b       	sbc	r21, r29
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    90ac:	4d 3f       	cpi	r20, 0xFD	; 253
    90ae:	51 05       	cpc	r21, r1
    90b0:	08 f0       	brcs	.+2      	; 0x90b4 <EMeter_ZMR110_Read_Date+0x2e>
    90b2:	41 c0       	rjmp	.+130    	; 0x9136 <EMeter_ZMR110_Read_Date+0xb0>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    90b4:	e1 2f       	mov	r30, r17
    90b6:	e6 95       	lsr	r30
    90b8:	e6 95       	lsr	r30
    90ba:	e6 95       	lsr	r30
    90bc:	f0 e0       	ldi	r31, 0x00	; 0
    90be:	e1 58       	subi	r30, 0x81	; 129
    90c0:	fa 4f       	sbci	r31, 0xFA	; 250
    90c2:	17 70       	andi	r17, 0x07	; 7
    90c4:	81 e0       	ldi	r24, 0x01	; 1
    90c6:	90 e0       	ldi	r25, 0x00	; 0
    90c8:	02 c0       	rjmp	.+4      	; 0x90ce <EMeter_ZMR110_Read_Date+0x48>
    90ca:	88 0f       	add	r24, r24
    90cc:	99 1f       	adc	r25, r25
    90ce:	1a 95       	dec	r17
    90d0:	e2 f7       	brpl	.-8      	; 0x90ca <EMeter_ZMR110_Read_Date+0x44>
    90d2:	20 81       	ld	r18, Z
    90d4:	28 2b       	or	r18, r24
    90d6:	20 83       	st	Z, r18
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%hhu-%hhu-%hhu"),&EM_Year, &EM_Month, &EM_Day);
    90d8:	8d b7       	in	r24, 0x3d	; 61
    90da:	9e b7       	in	r25, 0x3e	; 62
    90dc:	0a 97       	sbiw	r24, 0x0a	; 10
    90de:	0f b6       	in	r0, 0x3f	; 63
    90e0:	f8 94       	cli
    90e2:	9e bf       	out	0x3e, r25	; 62
    90e4:	0f be       	out	0x3f, r0	; 63
    90e6:	8d bf       	out	0x3d, r24	; 61
    90e8:	ed b7       	in	r30, 0x3d	; 61
    90ea:	fe b7       	in	r31, 0x3e	; 62
    90ec:	31 96       	adiw	r30, 0x01	; 1
    90ee:	4a 5f       	subi	r20, 0xFA	; 250
    90f0:	5f 4f       	sbci	r21, 0xFF	; 255
    90f2:	c4 0f       	add	r28, r20
    90f4:	d5 1f       	adc	r29, r21
    90f6:	ad b7       	in	r26, 0x3d	; 61
    90f8:	be b7       	in	r27, 0x3e	; 62
    90fa:	12 96       	adiw	r26, 0x02	; 2
    90fc:	dc 93       	st	X, r29
    90fe:	ce 93       	st	-X, r28
    9100:	11 97       	sbiw	r26, 0x01	; 1
    9102:	8b ee       	ldi	r24, 0xEB	; 235
    9104:	98 e4       	ldi	r25, 0x48	; 72
    9106:	93 83       	std	Z+3, r25	; 0x03
    9108:	82 83       	std	Z+2, r24	; 0x02
    910a:	81 ef       	ldi	r24, 0xF1	; 241
    910c:	98 e0       	ldi	r25, 0x08	; 8
    910e:	95 83       	std	Z+5, r25	; 0x05
    9110:	84 83       	std	Z+4, r24	; 0x04
    9112:	88 e5       	ldi	r24, 0x58	; 88
    9114:	99 e0       	ldi	r25, 0x09	; 9
    9116:	97 83       	std	Z+7, r25	; 0x07
    9118:	86 83       	std	Z+6, r24	; 0x06
    911a:	85 e6       	ldi	r24, 0x65	; 101
    911c:	93 e0       	ldi	r25, 0x03	; 3
    911e:	91 87       	std	Z+9, r25	; 0x09
    9120:	80 87       	std	Z+8, r24	; 0x08
    9122:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
    9126:	8d b7       	in	r24, 0x3d	; 61
    9128:	9e b7       	in	r25, 0x3e	; 62
    912a:	0a 96       	adiw	r24, 0x0a	; 10
    912c:	0f b6       	in	r0, 0x3f	; 63
    912e:	f8 94       	cli
    9130:	9e bf       	out	0x3e, r25	; 62
    9132:	0f be       	out	0x3f, r0	; 63
    9134:	8d bf       	out	0x3d, r24	; 61
		}
	}	
}
    9136:	df 91       	pop	r29
    9138:	cf 91       	pop	r28
    913a:	1f 91       	pop	r17
    913c:	08 95       	ret

0000913e <EMeter_ZMR110_Read_DWord>:
			sscanf_P(EMeter_RxStr_Offset+Start+6,PSTR("%hhu:%hhu:%hhu"),&EM_Hour, &EM_Min, &EM_Sec);
		}
	}	
}
// ~~~~~~~~~
uint32_t EMeter_ZMR110_Read_DWord(prog_char *Str_P, uint8_t FlagNum){
    913e:	bf 92       	push	r11
    9140:	cf 92       	push	r12
    9142:	df 92       	push	r13
    9144:	ef 92       	push	r14
    9146:	ff 92       	push	r15
    9148:	0f 93       	push	r16
    914a:	1f 93       	push	r17
    914c:	df 93       	push	r29
    914e:	cf 93       	push	r28
    9150:	00 d0       	rcall	.+0      	; 0x9152 <EMeter_ZMR110_Read_DWord+0x14>
    9152:	00 d0       	rcall	.+0      	; 0x9154 <EMeter_ZMR110_Read_DWord+0x16>
    9154:	cd b7       	in	r28, 0x3d	; 61
    9156:	de b7       	in	r29, 0x3e	; 62
    9158:	6c 01       	movw	r12, r24
    915a:	b6 2e       	mov	r11, r22
	uint32_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    915c:	00 91 85 05 	lds	r16, 0x0585
    9160:	10 91 86 05 	lds	r17, 0x0586
    9164:	c8 01       	movw	r24, r16
    9166:	b6 01       	movw	r22, r12
    9168:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    916c:	00 97       	sbiw	r24, 0x00	; 0
    916e:	09 f4       	brne	.+2      	; 0x9172 <EMeter_ZMR110_Read_DWord+0x34>
    9170:	46 c0       	rjmp	.+140    	; 0x91fe <EMeter_ZMR110_Read_DWord+0xc0>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    9172:	7c 01       	movw	r14, r24
    9174:	e0 1a       	sub	r14, r16
    9176:	f1 0a       	sbc	r15, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    9178:	8d ef       	ldi	r24, 0xFD	; 253
    917a:	e8 16       	cp	r14, r24
    917c:	f1 04       	cpc	r15, r1
    917e:	08 f0       	brcs	.+2      	; 0x9182 <EMeter_ZMR110_Read_DWord+0x44>
    9180:	3e c0       	rjmp	.+124    	; 0x91fe <EMeter_ZMR110_Read_DWord+0xc0>
			sscanf_P(EMeter_RxStr_Offset+Start+strlen_P(Str_P)+1,PSTR("%lud"),&Result);
    9182:	c6 01       	movw	r24, r12
    9184:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    9188:	00 d0       	rcall	.+0      	; 0x918a <EMeter_ZMR110_Read_DWord+0x4c>
    918a:	00 d0       	rcall	.+0      	; 0x918c <EMeter_ZMR110_Read_DWord+0x4e>
    918c:	00 d0       	rcall	.+0      	; 0x918e <EMeter_ZMR110_Read_DWord+0x50>
    918e:	ed b7       	in	r30, 0x3d	; 61
    9190:	fe b7       	in	r31, 0x3e	; 62
    9192:	31 96       	adiw	r30, 0x01	; 1
    9194:	01 96       	adiw	r24, 0x01	; 1
    9196:	8e 0d       	add	r24, r14
    9198:	9f 1d       	adc	r25, r15
    919a:	08 0f       	add	r16, r24
    919c:	19 1f       	adc	r17, r25
    919e:	ad b7       	in	r26, 0x3d	; 61
    91a0:	be b7       	in	r27, 0x3e	; 62
    91a2:	12 96       	adiw	r26, 0x02	; 2
    91a4:	1c 93       	st	X, r17
    91a6:	0e 93       	st	-X, r16
    91a8:	11 97       	sbiw	r26, 0x01	; 1
    91aa:	87 ed       	ldi	r24, 0xD7	; 215
    91ac:	98 e4       	ldi	r25, 0x48	; 72
    91ae:	93 83       	std	Z+3, r25	; 0x03
    91b0:	82 83       	std	Z+2, r24	; 0x02
    91b2:	ce 01       	movw	r24, r28
    91b4:	01 96       	adiw	r24, 0x01	; 1
    91b6:	95 83       	std	Z+5, r25	; 0x05
    91b8:	84 83       	std	Z+4, r24	; 0x04
    91ba:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    91be:	eb 2d       	mov	r30, r11
    91c0:	e6 95       	lsr	r30
    91c2:	e6 95       	lsr	r30
    91c4:	e6 95       	lsr	r30
    91c6:	f0 e0       	ldi	r31, 0x00	; 0
    91c8:	e1 58       	subi	r30, 0x81	; 129
    91ca:	fa 4f       	sbci	r31, 0xFA	; 250
    91cc:	b7 e0       	ldi	r27, 0x07	; 7
    91ce:	bb 22       	and	r11, r27
    91d0:	81 e0       	ldi	r24, 0x01	; 1
    91d2:	90 e0       	ldi	r25, 0x00	; 0
    91d4:	02 c0       	rjmp	.+4      	; 0x91da <EMeter_ZMR110_Read_DWord+0x9c>
    91d6:	88 0f       	add	r24, r24
    91d8:	99 1f       	adc	r25, r25
    91da:	ba 94       	dec	r11
    91dc:	e2 f7       	brpl	.-8      	; 0x91d6 <EMeter_ZMR110_Read_DWord+0x98>
    91de:	20 81       	ld	r18, Z
    91e0:	28 2b       	or	r18, r24
    91e2:	20 83       	st	Z, r18
			return Result;
    91e4:	29 81       	ldd	r18, Y+1	; 0x01
    91e6:	3a 81       	ldd	r19, Y+2	; 0x02
    91e8:	4b 81       	ldd	r20, Y+3	; 0x03
    91ea:	5c 81       	ldd	r21, Y+4	; 0x04
    91ec:	8d b7       	in	r24, 0x3d	; 61
    91ee:	9e b7       	in	r25, 0x3e	; 62
    91f0:	06 96       	adiw	r24, 0x06	; 6
    91f2:	0f b6       	in	r0, 0x3f	; 63
    91f4:	f8 94       	cli
    91f6:	9e bf       	out	0x3e, r25	; 62
    91f8:	0f be       	out	0x3f, r0	; 63
    91fa:	8d bf       	out	0x3d, r24	; 61
    91fc:	04 c0       	rjmp	.+8      	; 0x9206 <EMeter_ZMR110_Read_DWord+0xc8>
    91fe:	20 e0       	ldi	r18, 0x00	; 0
    9200:	30 e0       	ldi	r19, 0x00	; 0
    9202:	40 e0       	ldi	r20, 0x00	; 0
    9204:	50 e0       	ldi	r21, 0x00	; 0
		}
	}	
	return 0;
}
    9206:	b9 01       	movw	r22, r18
    9208:	ca 01       	movw	r24, r20
    920a:	0f 90       	pop	r0
    920c:	0f 90       	pop	r0
    920e:	0f 90       	pop	r0
    9210:	0f 90       	pop	r0
    9212:	cf 91       	pop	r28
    9214:	df 91       	pop	r29
    9216:	1f 91       	pop	r17
    9218:	0f 91       	pop	r16
    921a:	ff 90       	pop	r15
    921c:	ef 90       	pop	r14
    921e:	df 90       	pop	r13
    9220:	cf 90       	pop	r12
    9222:	bf 90       	pop	r11
    9224:	08 95       	ret

00009226 <EMeter_ZMR110_Read_Word>:
		}
	}	
	return 0;
}
// ~~~~~~~~~
uint16_t EMeter_ZMR110_Read_Word(prog_char *Str_P, uint8_t FlagNum){
    9226:	af 92       	push	r10
    9228:	bf 92       	push	r11
    922a:	cf 92       	push	r12
    922c:	df 92       	push	r13
    922e:	ff 92       	push	r15
    9230:	0f 93       	push	r16
    9232:	1f 93       	push	r17
    9234:	df 93       	push	r29
    9236:	cf 93       	push	r28
    9238:	00 d0       	rcall	.+0      	; 0x923a <EMeter_ZMR110_Read_Word+0x14>
    923a:	cd b7       	in	r28, 0x3d	; 61
    923c:	de b7       	in	r29, 0x3e	; 62
    923e:	5c 01       	movw	r10, r24
    9240:	f6 2e       	mov	r15, r22
	uint16_t Result;
	char* temp_ptr = strstr_P(EMeter_RxStr_Offset, Str_P);
    9242:	00 91 85 05 	lds	r16, 0x0585
    9246:	10 91 86 05 	lds	r17, 0x0586
    924a:	c8 01       	movw	r24, r16
    924c:	b5 01       	movw	r22, r10
    924e:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
	if(temp_ptr != NULL){
    9252:	00 97       	sbiw	r24, 0x00	; 0
    9254:	09 f4       	brne	.+2      	; 0x9258 <EMeter_ZMR110_Read_Word+0x32>
    9256:	43 c0       	rjmp	.+134    	; 0x92de <EMeter_ZMR110_Read_Word+0xb8>
		uint16_t Start = temp_ptr - EMeter_RxStr_Offset;
    9258:	6c 01       	movw	r12, r24
    925a:	c0 1a       	sub	r12, r16
    925c:	d1 0a       	sbc	r13, r17
//		EM_BCC = Start;	//TODO for Debug
		if(Start<(EM_RX_SIZE-1)){
    925e:	8d ef       	ldi	r24, 0xFD	; 253
    9260:	c8 16       	cp	r12, r24
    9262:	d1 04       	cpc	r13, r1
    9264:	e0 f5       	brcc	.+120    	; 0x92de <EMeter_ZMR110_Read_Word+0xb8>
			LG_ZMR110_READ_FLAG[FlagNum/8] |= (1<<FlagNum%8);
    9266:	ef 2d       	mov	r30, r15
    9268:	e6 95       	lsr	r30
    926a:	e6 95       	lsr	r30
    926c:	e6 95       	lsr	r30
    926e:	f0 e0       	ldi	r31, 0x00	; 0
    9270:	e1 58       	subi	r30, 0x81	; 129
    9272:	fa 4f       	sbci	r31, 0xFA	; 250
    9274:	97 e0       	ldi	r25, 0x07	; 7
    9276:	f9 22       	and	r15, r25
    9278:	81 e0       	ldi	r24, 0x01	; 1
    927a:	90 e0       	ldi	r25, 0x00	; 0
    927c:	02 c0       	rjmp	.+4      	; 0x9282 <EMeter_ZMR110_Read_Word+0x5c>
    927e:	88 0f       	add	r24, r24
    9280:	99 1f       	adc	r25, r25
    9282:	fa 94       	dec	r15
    9284:	e2 f7       	brpl	.-8      	; 0x927e <EMeter_ZMR110_Read_Word+0x58>
    9286:	20 81       	ld	r18, Z
    9288:	28 2b       	or	r18, r24
    928a:	20 83       	st	Z, r18
			//sscanf(EMeter_RxStr_Offset+Start+7,"%u",&Result);
			sscanf(EMeter_RxStr_Offset+Start+strlen_P(Str_P)+1,"%u",&Result);							
    928c:	c5 01       	movw	r24, r10
    928e:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    9292:	00 d0       	rcall	.+0      	; 0x9294 <EMeter_ZMR110_Read_Word+0x6e>
    9294:	00 d0       	rcall	.+0      	; 0x9296 <EMeter_ZMR110_Read_Word+0x70>
    9296:	00 d0       	rcall	.+0      	; 0x9298 <EMeter_ZMR110_Read_Word+0x72>
    9298:	ed b7       	in	r30, 0x3d	; 61
    929a:	fe b7       	in	r31, 0x3e	; 62
    929c:	31 96       	adiw	r30, 0x01	; 1
    929e:	01 96       	adiw	r24, 0x01	; 1
    92a0:	8c 0d       	add	r24, r12
    92a2:	9d 1d       	adc	r25, r13
    92a4:	08 0f       	add	r16, r24
    92a6:	19 1f       	adc	r17, r25
    92a8:	ad b7       	in	r26, 0x3d	; 61
    92aa:	be b7       	in	r27, 0x3e	; 62
    92ac:	12 96       	adiw	r26, 0x02	; 2
    92ae:	1c 93       	st	X, r17
    92b0:	0e 93       	st	-X, r16
    92b2:	11 97       	sbiw	r26, 0x01	; 1
    92b4:	80 e0       	ldi	r24, 0x00	; 0
    92b6:	91 e0       	ldi	r25, 0x01	; 1
    92b8:	93 83       	std	Z+3, r25	; 0x03
    92ba:	82 83       	std	Z+2, r24	; 0x02
    92bc:	ce 01       	movw	r24, r28
    92be:	01 96       	adiw	r24, 0x01	; 1
    92c0:	95 83       	std	Z+5, r25	; 0x05
    92c2:	84 83       	std	Z+4, r24	; 0x04
    92c4:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
			return Result;
    92c8:	29 81       	ldd	r18, Y+1	; 0x01
    92ca:	3a 81       	ldd	r19, Y+2	; 0x02
    92cc:	8d b7       	in	r24, 0x3d	; 61
    92ce:	9e b7       	in	r25, 0x3e	; 62
    92d0:	06 96       	adiw	r24, 0x06	; 6
    92d2:	0f b6       	in	r0, 0x3f	; 63
    92d4:	f8 94       	cli
    92d6:	9e bf       	out	0x3e, r25	; 62
    92d8:	0f be       	out	0x3f, r0	; 63
    92da:	8d bf       	out	0x3d, r24	; 61
    92dc:	02 c0       	rjmp	.+4      	; 0x92e2 <EMeter_ZMR110_Read_Word+0xbc>
    92de:	20 e0       	ldi	r18, 0x00	; 0
    92e0:	30 e0       	ldi	r19, 0x00	; 0
		}
	}	
	return 0;
}
    92e2:	c9 01       	movw	r24, r18
    92e4:	0f 90       	pop	r0
    92e6:	0f 90       	pop	r0
    92e8:	cf 91       	pop	r28
    92ea:	df 91       	pop	r29
    92ec:	1f 91       	pop	r17
    92ee:	0f 91       	pop	r16
    92f0:	ff 90       	pop	r15
    92f2:	df 90       	pop	r13
    92f4:	cf 90       	pop	r12
    92f6:	bf 90       	pop	r11
    92f8:	af 90       	pop	r10
    92fa:	08 95       	ret

000092fc <EMeter_SendCR>:
	EMeter_RxCharN = 0;	//  
	sei();	
}
// ~~~~~~~~~
//   + CR
void EMeter_SendCR(prog_char *Str_P){
    92fc:	ef 92       	push	r14
    92fe:	ff 92       	push	r15
    9300:	0f 93       	push	r16
    9302:	1f 93       	push	r17
    9304:	7c 01       	movw	r14, r24
	EMeter_TxSz = strlen_P(Str_P);
    9306:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    930a:	80 93 ae 0c 	sts	0x0CAE, r24
	sprintf_P(EMeter_TxStr, Str_P);
    930e:	00 d0       	rcall	.+0      	; 0x9310 <EMeter_SendCR+0x14>
    9310:	00 d0       	rcall	.+0      	; 0x9312 <EMeter_SendCR+0x16>
    9312:	03 e6       	ldi	r16, 0x63	; 99
    9314:	1a e0       	ldi	r17, 0x0A	; 10
    9316:	ed b7       	in	r30, 0x3d	; 61
    9318:	fe b7       	in	r31, 0x3e	; 62
    931a:	12 83       	std	Z+2, r17	; 0x02
    931c:	01 83       	std	Z+1, r16	; 0x01
    931e:	f4 82       	std	Z+4, r15	; 0x04
    9320:	e3 82       	std	Z+3, r14	; 0x03
    9322:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
	sprintf_P(EMeter_TxStr + EMeter_TxSz, PSTR("\r\n"));
    9326:	80 91 ae 0c 	lds	r24, 0x0CAE
    932a:	08 0f       	add	r16, r24
    932c:	11 1d       	adc	r17, r1
    932e:	ed b7       	in	r30, 0x3d	; 61
    9330:	fe b7       	in	r31, 0x3e	; 62
    9332:	12 83       	std	Z+2, r17	; 0x02
    9334:	01 83       	std	Z+1, r16	; 0x01
    9336:	8a ef       	ldi	r24, 0xFA	; 250
    9338:	98 e4       	ldi	r25, 0x48	; 72
    933a:	94 83       	std	Z+4, r25	; 0x04
    933c:	83 83       	std	Z+3, r24	; 0x03
    933e:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
	EMeter_TxSz +=2;
    9342:	80 91 ae 0c 	lds	r24, 0x0CAE
    9346:	8e 5f       	subi	r24, 0xFE	; 254
    9348:	80 93 ae 0c 	sts	0x0CAE, r24
	EMeter_SendFirstChar();
    934c:	0f 90       	pop	r0
    934e:	0f 90       	pop	r0
    9350:	0f 90       	pop	r0
    9352:	0f 90       	pop	r0
    9354:	0e 94 bc 41 	call	0x8378	; 0x8378 <EMeter_SendFirstChar>
}
    9358:	1f 91       	pop	r17
    935a:	0f 91       	pop	r16
    935c:	ff 90       	pop	r15
    935e:	ef 90       	pop	r14
    9360:	08 95       	ret

00009362 <EMeter_SendData_P>:
// ~~~~~~~~~
void EMeter_SendData_P(prog_uint8_t *Data_Out_P, uint8_t Size){
    9362:	9c 01       	movw	r18, r24
    9364:	46 2f       	mov	r20, r22
	EMeter_TxSz = Size;
    9366:	60 93 ae 0c 	sts	0x0CAE, r22
	memcpy_P(EMeter_TxStr, Data_Out_P, Size);
    936a:	83 e6       	ldi	r24, 0x63	; 99
    936c:	9a e0       	ldi	r25, 0x0A	; 10
    936e:	b9 01       	movw	r22, r18
    9370:	50 e0       	ldi	r21, 0x00	; 0
    9372:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
	EMeter_SendFirstChar();
    9376:	0e 94 bc 41 	call	0x8378	; 0x8378 <EMeter_SendFirstChar>
}
    937a:	08 95       	ret

0000937c <GSM_Wait_Response_P>:
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
	else return 1;
}
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    937c:	1f 93       	push	r17
    937e:	cf 93       	push	r28
    9380:	df 93       	push	r29
    9382:	ec 01       	movw	r28, r24
    9384:	16 2f       	mov	r17, r22
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    9386:	80 91 5a 03 	lds	r24, 0x035A
    938a:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    938e:	88 23       	and	r24, r24
    9390:	29 f0       	breq	.+10     	; 0x939c <GSM_Wait_Response_P+0x20>
    9392:	11 23       	and	r17, r17
    9394:	19 f0       	breq	.+6      	; 0x939c <GSM_Wait_Response_P+0x20>
		GSM_State = RestoreCMD;
    9396:	10 93 a4 05 	sts	0x05A4, r17
    939a:	04 c0       	rjmp	.+8      	; 0x93a4 <GSM_Wait_Response_P+0x28>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    939c:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    93a0:	88 23       	and	r24, r24
    93a2:	11 f4       	brne	.+4      	; 0x93a8 <GSM_Wait_Response_P+0x2c>
    93a4:	20 e0       	ldi	r18, 0x00	; 0
    93a6:	09 c0       	rjmp	.+18     	; 0x93ba <GSM_Wait_Response_P+0x3e>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    93a8:	84 ef       	ldi	r24, 0xF4	; 244
    93aa:	98 e0       	ldi	r25, 0x08	; 8
    93ac:	be 01       	movw	r22, r28
    93ae:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    93b2:	20 e0       	ldi	r18, 0x00	; 0
    93b4:	89 2b       	or	r24, r25
    93b6:	09 f4       	brne	.+2      	; 0x93ba <GSM_Wait_Response_P+0x3e>
    93b8:	21 e0       	ldi	r18, 0x01	; 1
		else return 1;
	}
	else return 0;
}
    93ba:	82 2f       	mov	r24, r18
    93bc:	df 91       	pop	r29
    93be:	cf 91       	pop	r28
    93c0:	1f 91       	pop	r17
    93c2:	08 95       	ret

000093c4 <DigiFilt>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
    93c4:	7f 92       	push	r7
    93c6:	8f 92       	push	r8
    93c8:	9f 92       	push	r9
    93ca:	af 92       	push	r10
    93cc:	bf 92       	push	r11
    93ce:	cf 92       	push	r12
    93d0:	df 92       	push	r13
    93d2:	ef 92       	push	r14
    93d4:	ff 92       	push	r15
    93d6:	0f 93       	push	r16
    93d8:	1f 93       	push	r17
    93da:	df 93       	push	r29
    93dc:	cf 93       	push	r28
    93de:	cd b7       	in	r28, 0x3d	; 61
    93e0:	de b7       	in	r29, 0x3e	; 62
    93e2:	28 2f       	mov	r18, r24
    93e4:	79 2f       	mov	r23, r25
    93e6:	06 2f       	mov	r16, r22
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
	return Sum/(Edge*2);
}
    93e8:	8d b6       	in	r8, 0x3d	; 61
    93ea:	9e b6       	in	r9, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
DigiFilt(const uint16_t *Array, uint8_t Edge)
{
	uint8_t Sz = Edge*4;
    93ec:	a6 2e       	mov	r10, r22
    93ee:	bb 24       	eor	r11, r11
    93f0:	16 2f       	mov	r17, r22
    93f2:	11 0f       	add	r17, r17
    93f4:	11 0f       	add	r17, r17
	uint8_t _Edge = Sz-Edge;
    93f6:	71 2e       	mov	r7, r17
    93f8:	76 1a       	sub	r7, r22
	uint16_t Buf[Sz];
    93fa:	e1 2f       	mov	r30, r17
    93fc:	f0 e0       	ldi	r31, 0x00	; 0
    93fe:	ee 0f       	add	r30, r30
    9400:	ff 1f       	adc	r31, r31
    9402:	8d b7       	in	r24, 0x3d	; 61
    9404:	9e b7       	in	r25, 0x3e	; 62
    9406:	8e 1b       	sub	r24, r30
    9408:	9f 0b       	sbc	r25, r31
    940a:	0f b6       	in	r0, 0x3f	; 63
    940c:	f8 94       	cli
    940e:	9e bf       	out	0x3e, r25	; 62
    9410:	0f be       	out	0x3f, r0	; 63
    9412:	8d bf       	out	0x3d, r24	; 61
    9414:	cd b6       	in	r12, 0x3d	; 61
    9416:	de b6       	in	r13, 0x3e	; 62
    9418:	08 94       	sec
    941a:	c1 1c       	adc	r12, r1
    941c:	d1 1c       	adc	r13, r1
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
    941e:	c6 01       	movw	r24, r12
    9420:	62 2f       	mov	r22, r18
    9422:	af 01       	movw	r20, r30
    9424:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
    9428:	80 e0       	ldi	r24, 0x00	; 0
    942a:	21 c0       	rjmp	.+66     	; 0x946e <DigiFilt+0xaa>
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    942c:	58 2f       	mov	r21, r24
    942e:	5f 5f       	subi	r21, 0xFF	; 255
    9430:	45 2f       	mov	r20, r21
			if(Buf[j] < Buf[i]) {
    9432:	a8 2f       	mov	r26, r24
    9434:	b0 e0       	ldi	r27, 0x00	; 0
    9436:	aa 0f       	add	r26, r26
    9438:	bb 1f       	adc	r27, r27
    943a:	ac 0d       	add	r26, r12
    943c:	bd 1d       	adc	r27, r13
    943e:	14 c0       	rjmp	.+40     	; 0x9468 <DigiFilt+0xa4>
    9440:	e4 2f       	mov	r30, r20
    9442:	f0 e0       	ldi	r31, 0x00	; 0
    9444:	ee 0f       	add	r30, r30
    9446:	ff 1f       	adc	r31, r31
    9448:	ec 0d       	add	r30, r12
    944a:	fd 1d       	adc	r31, r13
    944c:	20 81       	ld	r18, Z
    944e:	31 81       	ldd	r19, Z+1	; 0x01
    9450:	8d 91       	ld	r24, X+
    9452:	9c 91       	ld	r25, X
    9454:	11 97       	sbiw	r26, 0x01	; 1
    9456:	28 17       	cp	r18, r24
    9458:	39 07       	cpc	r19, r25
    945a:	28 f4       	brcc	.+10     	; 0x9466 <DigiFilt+0xa2>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    945c:	11 96       	adiw	r26, 0x01	; 1
    945e:	3c 93       	st	X, r19
    9460:	2e 93       	st	-X, r18
				Buf[j] = Swap;
    9462:	91 83       	std	Z+1, r25	; 0x01
    9464:	80 83       	st	Z, r24
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
		for(j=i+1; j<Sz; j++)
    9466:	4f 5f       	subi	r20, 0xFF	; 255
    9468:	41 17       	cp	r20, r17
    946a:	50 f3       	brcs	.-44     	; 0x9440 <DigiFilt+0x7c>
    946c:	85 2f       	mov	r24, r21
	uint16_t Buf[Sz];
	uint32_t Sum = 0;
	uint16_t Swap;
	uint8_t i, j;
	memcpy(Buf, Array, Sz*2);
	for(i=0; i<Edge; i++)
    946e:	80 17       	cp	r24, r16
    9470:	e8 f2       	brcs	.-70     	; 0x942c <DigiFilt+0x68>
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    9472:	e1 2f       	mov	r30, r17
    9474:	e1 50       	subi	r30, 0x01	; 1
    9476:	1f c0       	rjmp	.+62     	; 0x94b6 <DigiFilt+0xf2>
		for(j=i-1; j>=Edge; j--)
    9478:	5e 2f       	mov	r21, r30
    947a:	51 50       	subi	r21, 0x01	; 1
    947c:	45 2f       	mov	r20, r21
			if(Buf[j] > Buf[i]) {
    947e:	f0 e0       	ldi	r31, 0x00	; 0
    9480:	ee 0f       	add	r30, r30
    9482:	ff 1f       	adc	r31, r31
    9484:	ec 0d       	add	r30, r12
    9486:	fd 1d       	adc	r31, r13
    9488:	13 c0       	rjmp	.+38     	; 0x94b0 <DigiFilt+0xec>
    948a:	a4 2f       	mov	r26, r20
    948c:	b0 e0       	ldi	r27, 0x00	; 0
    948e:	aa 0f       	add	r26, r26
    9490:	bb 1f       	adc	r27, r27
    9492:	ac 0d       	add	r26, r12
    9494:	bd 1d       	adc	r27, r13
    9496:	2d 91       	ld	r18, X+
    9498:	3c 91       	ld	r19, X
    949a:	11 97       	sbiw	r26, 0x01	; 1
    949c:	80 81       	ld	r24, Z
    949e:	91 81       	ldd	r25, Z+1	; 0x01
    94a0:	82 17       	cp	r24, r18
    94a2:	93 07       	cpc	r25, r19
    94a4:	20 f4       	brcc	.+8      	; 0x94ae <DigiFilt+0xea>
				Swap = Buf[i];
				Buf[i] = Buf[j];
    94a6:	31 83       	std	Z+1, r19	; 0x01
    94a8:	20 83       	st	Z, r18
				Buf[j] = Swap;
    94aa:	8d 93       	st	X+, r24
    94ac:	9c 93       	st	X, r25
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
		for(j=i-1; j>=Edge; j--)
    94ae:	41 50       	subi	r20, 0x01	; 1
    94b0:	40 17       	cp	r20, r16
    94b2:	58 f7       	brcc	.-42     	; 0x948a <DigiFilt+0xc6>
    94b4:	e5 2f       	mov	r30, r21
			if(Buf[j] < Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Sz-1; i>=_Edge; i--)
    94b6:	e7 15       	cp	r30, r7
    94b8:	f8 f6       	brcc	.-66     	; 0x9478 <DigiFilt+0xb4>
    94ba:	60 2f       	mov	r22, r16
    94bc:	ee 24       	eor	r14, r14
    94be:	ff 24       	eor	r15, r15
    94c0:	87 01       	movw	r16, r14
    94c2:	0f c0       	rjmp	.+30     	; 0x94e2 <DigiFilt+0x11e>
			if(Buf[j] > Buf[i]) {
				Swap = Buf[i];
				Buf[i] = Buf[j];
				Buf[j] = Swap;
			}
	for(i=Edge; i<_Edge; Sum+=Buf[i++]);
    94c4:	e6 2f       	mov	r30, r22
    94c6:	f0 e0       	ldi	r31, 0x00	; 0
    94c8:	ee 0f       	add	r30, r30
    94ca:	ff 1f       	adc	r31, r31
    94cc:	ec 0d       	add	r30, r12
    94ce:	fd 1d       	adc	r31, r13
    94d0:	80 81       	ld	r24, Z
    94d2:	91 81       	ldd	r25, Z+1	; 0x01
    94d4:	a0 e0       	ldi	r26, 0x00	; 0
    94d6:	b0 e0       	ldi	r27, 0x00	; 0
    94d8:	e8 0e       	add	r14, r24
    94da:	f9 1e       	adc	r15, r25
    94dc:	0a 1f       	adc	r16, r26
    94de:	1b 1f       	adc	r17, r27
    94e0:	6f 5f       	subi	r22, 0xFF	; 255
    94e2:	67 15       	cp	r22, r7
    94e4:	78 f3       	brcs	.-34     	; 0x94c4 <DigiFilt+0x100>
    94e6:	aa 0c       	add	r10, r10
    94e8:	bb 1c       	adc	r11, r11
    94ea:	95 01       	movw	r18, r10
    94ec:	44 27       	eor	r20, r20
    94ee:	37 fd       	sbrc	r19, 7
    94f0:	40 95       	com	r20
    94f2:	54 2f       	mov	r21, r20
    94f4:	c8 01       	movw	r24, r16
    94f6:	b7 01       	movw	r22, r14
    94f8:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    94fc:	c9 01       	movw	r24, r18
	return Sum/(Edge*2);
}
    94fe:	0f b6       	in	r0, 0x3f	; 63
    9500:	f8 94       	cli
    9502:	9e be       	out	0x3e, r9	; 62
    9504:	0f be       	out	0x3f, r0	; 63
    9506:	8d be       	out	0x3d, r8	; 61
    9508:	cf 91       	pop	r28
    950a:	df 91       	pop	r29
    950c:	1f 91       	pop	r17
    950e:	0f 91       	pop	r16
    9510:	ff 90       	pop	r15
    9512:	ef 90       	pop	r14
    9514:	df 90       	pop	r13
    9516:	cf 90       	pop	r12
    9518:	bf 90       	pop	r11
    951a:	af 90       	pop	r10
    951c:	9f 90       	pop	r9
    951e:	8f 90       	pop	r8
    9520:	7f 90       	pop	r7
    9522:	08 95       	ret

00009524 <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    9524:	cf 92       	push	r12
    9526:	df 92       	push	r13
    9528:	ef 92       	push	r14
    952a:	ff 92       	push	r15
    952c:	0f 93       	push	r16
    952e:	1f 93       	push	r17
    9530:	df 93       	push	r29
    9532:	cf 93       	push	r28
    9534:	cd b7       	in	r28, 0x3d	; 61
    9536:	de b7       	in	r29, 0x3e	; 62
    9538:	29 97       	sbiw	r28, 0x09	; 9
    953a:	0f b6       	in	r0, 0x3f	; 63
    953c:	f8 94       	cli
    953e:	de bf       	out	0x3e, r29	; 62
    9540:	0f be       	out	0x3f, r0	; 63
    9542:	cd bf       	out	0x3d, r28	; 61
    9544:	6c 01       	movw	r12, r24
    9546:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    9548:	db 01       	movw	r26, r22
    954a:	13 96       	adiw	r26, 0x03	; 3
    954c:	2c 91       	ld	r18, X
    954e:	ed b7       	in	r30, 0x3d	; 61
    9550:	fe b7       	in	r31, 0x3e	; 62
    9552:	38 97       	sbiw	r30, 0x08	; 8
    9554:	0f b6       	in	r0, 0x3f	; 63
    9556:	f8 94       	cli
    9558:	fe bf       	out	0x3e, r31	; 62
    955a:	0f be       	out	0x3f, r0	; 63
    955c:	ed bf       	out	0x3d, r30	; 61
    955e:	31 96       	adiw	r30, 0x01	; 1
    9560:	8e 01       	movw	r16, r28
    9562:	0f 5f       	subi	r16, 0xFF	; 255
    9564:	1f 4f       	sbci	r17, 0xFF	; 255
    9566:	ad b7       	in	r26, 0x3d	; 61
    9568:	be b7       	in	r27, 0x3e	; 62
    956a:	12 96       	adiw	r26, 0x02	; 2
    956c:	1c 93       	st	X, r17
    956e:	0e 93       	st	-X, r16
    9570:	11 97       	sbiw	r26, 0x01	; 1
    9572:	87 e0       	ldi	r24, 0x07	; 7
    9574:	91 e0       	ldi	r25, 0x01	; 1
    9576:	93 83       	std	Z+3, r25	; 0x03
    9578:	82 83       	std	Z+2, r24	; 0x02
    957a:	24 83       	std	Z+4, r18	; 0x04
    957c:	15 82       	std	Z+5, r1	; 0x05
    957e:	26 83       	std	Z+6, r18	; 0x06
    9580:	17 82       	std	Z+7, r1	; 0x07
    9582:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
	sprintf(Param->Pos, Format, Val);
    9586:	0f 90       	pop	r0
    9588:	0f 90       	pop	r0
    958a:	ed b7       	in	r30, 0x3d	; 61
    958c:	fe b7       	in	r31, 0x3e	; 62
    958e:	31 96       	adiw	r30, 0x01	; 1
    9590:	d7 01       	movw	r26, r14
    9592:	8d 91       	ld	r24, X+
    9594:	9c 91       	ld	r25, X
    9596:	ad b7       	in	r26, 0x3d	; 61
    9598:	be b7       	in	r27, 0x3e	; 62
    959a:	12 96       	adiw	r26, 0x02	; 2
    959c:	9c 93       	st	X, r25
    959e:	8e 93       	st	-X, r24
    95a0:	11 97       	sbiw	r26, 0x01	; 1
    95a2:	13 83       	std	Z+3, r17	; 0x03
    95a4:	02 83       	std	Z+2, r16	; 0x02
    95a6:	d5 82       	std	Z+5, r13	; 0x05
    95a8:	c4 82       	std	Z+4, r12	; 0x04
    95aa:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    95ae:	ed b7       	in	r30, 0x3d	; 61
    95b0:	fe b7       	in	r31, 0x3e	; 62
    95b2:	36 96       	adiw	r30, 0x06	; 6
    95b4:	0f b6       	in	r0, 0x3f	; 63
    95b6:	f8 94       	cli
    95b8:	fe bf       	out	0x3e, r31	; 62
    95ba:	0f be       	out	0x3f, r0	; 63
    95bc:	ed bf       	out	0x3d, r30	; 61
}
    95be:	29 96       	adiw	r28, 0x09	; 9
    95c0:	0f b6       	in	r0, 0x3f	; 63
    95c2:	f8 94       	cli
    95c4:	de bf       	out	0x3e, r29	; 62
    95c6:	0f be       	out	0x3f, r0	; 63
    95c8:	cd bf       	out	0x3d, r28	; 61
    95ca:	cf 91       	pop	r28
    95cc:	df 91       	pop	r29
    95ce:	1f 91       	pop	r17
    95d0:	0f 91       	pop	r16
    95d2:	ff 90       	pop	r15
    95d4:	ef 90       	pop	r14
    95d6:	df 90       	pop	r13
    95d8:	cf 90       	pop	r12
    95da:	08 95       	ret

000095dc <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    95dc:	ef 92       	push	r14
    95de:	ff 92       	push	r15
    95e0:	0f 93       	push	r16
    95e2:	1f 93       	push	r17
    95e4:	df 93       	push	r29
    95e6:	cf 93       	push	r28
    95e8:	cd b7       	in	r28, 0x3d	; 61
    95ea:	de b7       	in	r29, 0x3e	; 62
    95ec:	2f 97       	sbiw	r28, 0x0f	; 15
    95ee:	0f b6       	in	r0, 0x3f	; 63
    95f0:	f8 94       	cli
    95f2:	de bf       	out	0x3e, r29	; 62
    95f4:	0f be       	out	0x3f, r0	; 63
    95f6:	cd bf       	out	0x3d, r28	; 61
    95f8:	7b 01       	movw	r14, r22
    95fa:	8c 01       	movw	r16, r24
    95fc:	da 01       	movw	r26, r20
	if(Param->Size < 10){
    95fe:	13 96       	adiw	r26, 0x03	; 3
    9600:	8c 91       	ld	r24, X
    9602:	13 97       	sbiw	r26, 0x03	; 3
    9604:	8a 30       	cpi	r24, 0x0A	; 10
    9606:	70 f5       	brcc	.+92     	; 0x9664 <Put_GFVal+0x88>
		char Format[] = "%+ . g";
    9608:	9e 01       	movw	r18, r28
    960a:	2f 5f       	subi	r18, 0xFF	; 255
    960c:	3f 4f       	sbci	r19, 0xFF	; 255
    960e:	41 e1       	ldi	r20, 0x11	; 17
    9610:	51 e0       	ldi	r21, 0x01	; 1
    9612:	87 e0       	ldi	r24, 0x07	; 7
    9614:	fa 01       	movw	r30, r20
    9616:	01 90       	ld	r0, Z+
    9618:	af 01       	movw	r20, r30
    961a:	f9 01       	movw	r30, r18
    961c:	01 92       	st	Z+, r0
    961e:	9f 01       	movw	r18, r30
    9620:	81 50       	subi	r24, 0x01	; 1
    9622:	c1 f7       	brne	.-16     	; 0x9614 <Put_GFVal+0x38>
		Format[2] = '0'+Param->Size;
    9624:	13 96       	adiw	r26, 0x03	; 3
    9626:	8c 91       	ld	r24, X
    9628:	13 97       	sbiw	r26, 0x03	; 3
    962a:	80 5d       	subi	r24, 0xD0	; 208
    962c:	8b 83       	std	Y+3, r24	; 0x03
		Format[4] = '0'+Param->Prec;
    962e:	12 96       	adiw	r26, 0x02	; 2
    9630:	8c 91       	ld	r24, X
    9632:	12 97       	sbiw	r26, 0x02	; 2
    9634:	80 5d       	subi	r24, 0xD0	; 208
    9636:	8d 83       	std	Y+5, r24	; 0x05
		sprintf(Param->Pos, Format, Val);
    9638:	8d b7       	in	r24, 0x3d	; 61
    963a:	9e b7       	in	r25, 0x3e	; 62
    963c:	08 97       	sbiw	r24, 0x08	; 8
    963e:	0f b6       	in	r0, 0x3f	; 63
    9640:	f8 94       	cli
    9642:	9e bf       	out	0x3e, r25	; 62
    9644:	0f be       	out	0x3f, r0	; 63
    9646:	8d bf       	out	0x3d, r24	; 61
    9648:	ed b7       	in	r30, 0x3d	; 61
    964a:	fe b7       	in	r31, 0x3e	; 62
    964c:	31 96       	adiw	r30, 0x01	; 1
    964e:	8d 91       	ld	r24, X+
    9650:	9c 91       	ld	r25, X
    9652:	ad b7       	in	r26, 0x3d	; 61
    9654:	be b7       	in	r27, 0x3e	; 62
    9656:	12 96       	adiw	r26, 0x02	; 2
    9658:	9c 93       	st	X, r25
    965a:	8e 93       	st	-X, r24
    965c:	11 97       	sbiw	r26, 0x01	; 1
    965e:	ce 01       	movw	r24, r28
    9660:	01 96       	adiw	r24, 0x01	; 1
    9662:	2d c0       	rjmp	.+90     	; 0x96be <Put_GFVal+0xe2>
	}
	else{
		char Format[] = "%+1 . g";
    9664:	9e 01       	movw	r18, r28
    9666:	28 5f       	subi	r18, 0xF8	; 248
    9668:	3f 4f       	sbci	r19, 0xFF	; 255
    966a:	48 e1       	ldi	r20, 0x18	; 24
    966c:	51 e0       	ldi	r21, 0x01	; 1
    966e:	88 e0       	ldi	r24, 0x08	; 8
    9670:	fa 01       	movw	r30, r20
    9672:	01 90       	ld	r0, Z+
    9674:	af 01       	movw	r20, r30
    9676:	f9 01       	movw	r30, r18
    9678:	01 92       	st	Z+, r0
    967a:	9f 01       	movw	r18, r30
    967c:	81 50       	subi	r24, 0x01	; 1
    967e:	c1 f7       	brne	.-16     	; 0x9670 <Put_GFVal+0x94>
		Format[3] = '0'+Param->Size-10;	
    9680:	13 96       	adiw	r26, 0x03	; 3
    9682:	8c 91       	ld	r24, X
    9684:	13 97       	sbiw	r26, 0x03	; 3
    9686:	8a 5d       	subi	r24, 0xDA	; 218
    9688:	8b 87       	std	Y+11, r24	; 0x0b
		Format[5] = '0'+Param->Prec;
    968a:	12 96       	adiw	r26, 0x02	; 2
    968c:	8c 91       	ld	r24, X
    968e:	12 97       	sbiw	r26, 0x02	; 2
    9690:	80 5d       	subi	r24, 0xD0	; 208
    9692:	8d 87       	std	Y+13, r24	; 0x0d
		sprintf(Param->Pos, Format, Val);
    9694:	8d b7       	in	r24, 0x3d	; 61
    9696:	9e b7       	in	r25, 0x3e	; 62
    9698:	08 97       	sbiw	r24, 0x08	; 8
    969a:	0f b6       	in	r0, 0x3f	; 63
    969c:	f8 94       	cli
    969e:	9e bf       	out	0x3e, r25	; 62
    96a0:	0f be       	out	0x3f, r0	; 63
    96a2:	8d bf       	out	0x3d, r24	; 61
    96a4:	ed b7       	in	r30, 0x3d	; 61
    96a6:	fe b7       	in	r31, 0x3e	; 62
    96a8:	31 96       	adiw	r30, 0x01	; 1
    96aa:	8d 91       	ld	r24, X+
    96ac:	9c 91       	ld	r25, X
    96ae:	ad b7       	in	r26, 0x3d	; 61
    96b0:	be b7       	in	r27, 0x3e	; 62
    96b2:	12 96       	adiw	r26, 0x02	; 2
    96b4:	9c 93       	st	X, r25
    96b6:	8e 93       	st	-X, r24
    96b8:	11 97       	sbiw	r26, 0x01	; 1
    96ba:	ce 01       	movw	r24, r28
    96bc:	08 96       	adiw	r24, 0x08	; 8
    96be:	93 83       	std	Z+3, r25	; 0x03
    96c0:	82 83       	std	Z+2, r24	; 0x02
    96c2:	e4 82       	std	Z+4, r14	; 0x04
    96c4:	f5 82       	std	Z+5, r15	; 0x05
    96c6:	06 83       	std	Z+6, r16	; 0x06
    96c8:	17 83       	std	Z+7, r17	; 0x07
    96ca:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    96ce:	ed b7       	in	r30, 0x3d	; 61
    96d0:	fe b7       	in	r31, 0x3e	; 62
    96d2:	38 96       	adiw	r30, 0x08	; 8
    96d4:	0f b6       	in	r0, 0x3f	; 63
    96d6:	f8 94       	cli
    96d8:	fe bf       	out	0x3e, r31	; 62
    96da:	0f be       	out	0x3f, r0	; 63
    96dc:	ed bf       	out	0x3d, r30	; 61
	}
}
    96de:	2f 96       	adiw	r28, 0x0f	; 15
    96e0:	0f b6       	in	r0, 0x3f	; 63
    96e2:	f8 94       	cli
    96e4:	de bf       	out	0x3e, r29	; 62
    96e6:	0f be       	out	0x3f, r0	; 63
    96e8:	cd bf       	out	0x3d, r28	; 61
    96ea:	cf 91       	pop	r28
    96ec:	df 91       	pop	r29
    96ee:	1f 91       	pop	r17
    96f0:	0f 91       	pop	r16
    96f2:	ff 90       	pop	r15
    96f4:	ef 90       	pop	r14
    96f6:	08 95       	ret

000096f8 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    96f8:	ef 92       	push	r14
    96fa:	ff 92       	push	r15
    96fc:	0f 93       	push	r16
    96fe:	1f 93       	push	r17
    9700:	df 93       	push	r29
    9702:	cf 93       	push	r28
    9704:	cd b7       	in	r28, 0x3d	; 61
    9706:	de b7       	in	r29, 0x3e	; 62
    9708:	27 97       	sbiw	r28, 0x07	; 7
    970a:	0f b6       	in	r0, 0x3f	; 63
    970c:	f8 94       	cli
    970e:	de bf       	out	0x3e, r29	; 62
    9710:	0f be       	out	0x3f, r0	; 63
    9712:	cd bf       	out	0x3d, r28	; 61
    9714:	7b 01       	movw	r14, r22
    9716:	8c 01       	movw	r16, r24
    9718:	da 01       	movw	r26, r20
	char Format[] = "%+ . f";
    971a:	9e 01       	movw	r18, r28
    971c:	2f 5f       	subi	r18, 0xFF	; 255
    971e:	3f 4f       	sbci	r19, 0xFF	; 255
    9720:	40 e2       	ldi	r20, 0x20	; 32
    9722:	51 e0       	ldi	r21, 0x01	; 1
    9724:	87 e0       	ldi	r24, 0x07	; 7
    9726:	fa 01       	movw	r30, r20
    9728:	01 90       	ld	r0, Z+
    972a:	af 01       	movw	r20, r30
    972c:	f9 01       	movw	r30, r18
    972e:	01 92       	st	Z+, r0
    9730:	9f 01       	movw	r18, r30
    9732:	81 50       	subi	r24, 0x01	; 1
    9734:	c1 f7       	brne	.-16     	; 0x9726 <Put_FFVal+0x2e>
	Format[2] = '0'+Param->Size;
    9736:	13 96       	adiw	r26, 0x03	; 3
    9738:	8c 91       	ld	r24, X
    973a:	13 97       	sbiw	r26, 0x03	; 3
    973c:	80 5d       	subi	r24, 0xD0	; 208
    973e:	8b 83       	std	Y+3, r24	; 0x03
	Format[4] = '0'+Param->Prec;	
    9740:	12 96       	adiw	r26, 0x02	; 2
    9742:	8c 91       	ld	r24, X
    9744:	12 97       	sbiw	r26, 0x02	; 2
    9746:	80 5d       	subi	r24, 0xD0	; 208
    9748:	8d 83       	std	Y+5, r24	; 0x05
	sprintf(Param->Pos, Format, Val);
    974a:	8d b7       	in	r24, 0x3d	; 61
    974c:	9e b7       	in	r25, 0x3e	; 62
    974e:	08 97       	sbiw	r24, 0x08	; 8
    9750:	0f b6       	in	r0, 0x3f	; 63
    9752:	f8 94       	cli
    9754:	9e bf       	out	0x3e, r25	; 62
    9756:	0f be       	out	0x3f, r0	; 63
    9758:	8d bf       	out	0x3d, r24	; 61
    975a:	ed b7       	in	r30, 0x3d	; 61
    975c:	fe b7       	in	r31, 0x3e	; 62
    975e:	31 96       	adiw	r30, 0x01	; 1
    9760:	8d 91       	ld	r24, X+
    9762:	9c 91       	ld	r25, X
    9764:	ad b7       	in	r26, 0x3d	; 61
    9766:	be b7       	in	r27, 0x3e	; 62
    9768:	12 96       	adiw	r26, 0x02	; 2
    976a:	9c 93       	st	X, r25
    976c:	8e 93       	st	-X, r24
    976e:	11 97       	sbiw	r26, 0x01	; 1
    9770:	ce 01       	movw	r24, r28
    9772:	01 96       	adiw	r24, 0x01	; 1
    9774:	93 83       	std	Z+3, r25	; 0x03
    9776:	82 83       	std	Z+2, r24	; 0x02
    9778:	e4 82       	std	Z+4, r14	; 0x04
    977a:	f5 82       	std	Z+5, r15	; 0x05
    977c:	06 83       	std	Z+6, r16	; 0x06
    977e:	17 83       	std	Z+7, r17	; 0x07
    9780:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9784:	ed b7       	in	r30, 0x3d	; 61
    9786:	fe b7       	in	r31, 0x3e	; 62
    9788:	38 96       	adiw	r30, 0x08	; 8
    978a:	0f b6       	in	r0, 0x3f	; 63
    978c:	f8 94       	cli
    978e:	fe bf       	out	0x3e, r31	; 62
    9790:	0f be       	out	0x3f, r0	; 63
    9792:	ed bf       	out	0x3d, r30	; 61
}
    9794:	27 96       	adiw	r28, 0x07	; 7
    9796:	0f b6       	in	r0, 0x3f	; 63
    9798:	f8 94       	cli
    979a:	de bf       	out	0x3e, r29	; 62
    979c:	0f be       	out	0x3f, r0	; 63
    979e:	cd bf       	out	0x3d, r28	; 61
    97a0:	cf 91       	pop	r28
    97a2:	df 91       	pop	r29
    97a4:	1f 91       	pop	r17
    97a6:	0f 91       	pop	r16
    97a8:	ff 90       	pop	r15
    97aa:	ef 90       	pop	r14
    97ac:	08 95       	ret

000097ae <Put_zVal_h>:
	}
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    97ae:	1f 93       	push	r17
    97b0:	17 2f       	mov	r17, r23
    97b2:	58 2f       	mov	r21, r24
    97b4:	79 2f       	mov	r23, r25
    97b6:	d9 01       	movw	r26, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    97b8:	42 36       	cpi	r20, 0x62	; 98
    97ba:	a9 f4       	brne	.+42     	; 0x97e6 <Put_zVal_h+0x38>
    97bc:	00 d0       	rcall	.+0      	; 0x97be <Put_zVal_h+0x10>
    97be:	00 d0       	rcall	.+0      	; 0x97c0 <Put_zVal_h+0x12>
    97c0:	00 d0       	rcall	.+0      	; 0x97c2 <Put_zVal_h+0x14>
    97c2:	ed b7       	in	r30, 0x3d	; 61
    97c4:	fe b7       	in	r31, 0x3e	; 62
    97c6:	31 96       	adiw	r30, 0x01	; 1
    97c8:	8d 91       	ld	r24, X+
    97ca:	9c 91       	ld	r25, X
    97cc:	ad b7       	in	r26, 0x3d	; 61
    97ce:	be b7       	in	r27, 0x3e	; 62
    97d0:	12 96       	adiw	r26, 0x02	; 2
    97d2:	9c 93       	st	X, r25
    97d4:	8e 93       	st	-X, r24
    97d6:	11 97       	sbiw	r26, 0x01	; 1
    97d8:	87 e2       	ldi	r24, 0x27	; 39
    97da:	91 e0       	ldi	r25, 0x01	; 1
    97dc:	93 83       	std	Z+3, r25	; 0x03
    97de:	82 83       	std	Z+2, r24	; 0x02
    97e0:	64 83       	std	Z+4, r22	; 0x04
    97e2:	15 82       	std	Z+5, r1	; 0x05
    97e4:	16 c0       	rjmp	.+44     	; 0x9812 <Put_zVal_h+0x64>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    97e6:	47 37       	cpi	r20, 0x77	; 119
    97e8:	d1 f4       	brne	.+52     	; 0x981e <Put_zVal_h+0x70>
    97ea:	00 d0       	rcall	.+0      	; 0x97ec <Put_zVal_h+0x3e>
    97ec:	00 d0       	rcall	.+0      	; 0x97ee <Put_zVal_h+0x40>
    97ee:	00 d0       	rcall	.+0      	; 0x97f0 <Put_zVal_h+0x42>
    97f0:	ed b7       	in	r30, 0x3d	; 61
    97f2:	fe b7       	in	r31, 0x3e	; 62
    97f4:	31 96       	adiw	r30, 0x01	; 1
    97f6:	8d 91       	ld	r24, X+
    97f8:	9c 91       	ld	r25, X
    97fa:	ad b7       	in	r26, 0x3d	; 61
    97fc:	be b7       	in	r27, 0x3e	; 62
    97fe:	12 96       	adiw	r26, 0x02	; 2
    9800:	9c 93       	st	X, r25
    9802:	8e 93       	st	-X, r24
    9804:	11 97       	sbiw	r26, 0x01	; 1
    9806:	8d e2       	ldi	r24, 0x2D	; 45
    9808:	91 e0       	ldi	r25, 0x01	; 1
    980a:	93 83       	std	Z+3, r25	; 0x03
    980c:	82 83       	std	Z+2, r24	; 0x02
    980e:	64 83       	std	Z+4, r22	; 0x04
    9810:	15 83       	std	Z+5, r17	; 0x05
    9812:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9816:	8d b7       	in	r24, 0x3d	; 61
    9818:	9e b7       	in	r25, 0x3e	; 62
    981a:	06 96       	adiw	r24, 0x06	; 6
    981c:	22 c0       	rjmp	.+68     	; 0x9862 <Put_zVal_h+0xb4>
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    981e:	4c 36       	cpi	r20, 0x6C	; 108
    9820:	29 f5       	brne	.+74     	; 0x986c <Put_zVal_h+0xbe>
    9822:	8d b7       	in	r24, 0x3d	; 61
    9824:	9e b7       	in	r25, 0x3e	; 62
    9826:	08 97       	sbiw	r24, 0x08	; 8
    9828:	0f b6       	in	r0, 0x3f	; 63
    982a:	f8 94       	cli
    982c:	9e bf       	out	0x3e, r25	; 62
    982e:	0f be       	out	0x3f, r0	; 63
    9830:	8d bf       	out	0x3d, r24	; 61
    9832:	ed b7       	in	r30, 0x3d	; 61
    9834:	fe b7       	in	r31, 0x3e	; 62
    9836:	31 96       	adiw	r30, 0x01	; 1
    9838:	8d 91       	ld	r24, X+
    983a:	9c 91       	ld	r25, X
    983c:	ad b7       	in	r26, 0x3d	; 61
    983e:	be b7       	in	r27, 0x3e	; 62
    9840:	12 96       	adiw	r26, 0x02	; 2
    9842:	9c 93       	st	X, r25
    9844:	8e 93       	st	-X, r24
    9846:	11 97       	sbiw	r26, 0x01	; 1
    9848:	82 e3       	ldi	r24, 0x32	; 50
    984a:	91 e0       	ldi	r25, 0x01	; 1
    984c:	93 83       	std	Z+3, r25	; 0x03
    984e:	82 83       	std	Z+2, r24	; 0x02
    9850:	64 83       	std	Z+4, r22	; 0x04
    9852:	15 83       	std	Z+5, r17	; 0x05
    9854:	56 83       	std	Z+6, r21	; 0x06
    9856:	77 83       	std	Z+7, r23	; 0x07
    9858:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    985c:	8d b7       	in	r24, 0x3d	; 61
    985e:	9e b7       	in	r25, 0x3e	; 62
    9860:	08 96       	adiw	r24, 0x08	; 8
    9862:	0f b6       	in	r0, 0x3f	; 63
    9864:	f8 94       	cli
    9866:	9e bf       	out	0x3e, r25	; 62
    9868:	0f be       	out	0x3f, r0	; 63
    986a:	8d bf       	out	0x3d, r24	; 61
}
    986c:	1f 91       	pop	r17
    986e:	08 95       	ret

00009870 <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    9870:	cf 93       	push	r28
    9872:	df 93       	push	r29
    9874:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9876:	ec 81       	ldd	r30, Y+4	; 0x04
    9878:	fd 81       	ldd	r31, Y+5	; 0x05
    987a:	65 91       	lpm	r22, Z+
    987c:	74 91       	lpm	r23, Z+
	strcpy_P(Param->Pos, prp(Param->Txt));
    987e:	88 81       	ld	r24, Y
    9880:	99 81       	ldd	r25, Y+1	; 0x01
    9882:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    9886:	a8 81       	ld	r26, Y
    9888:	b9 81       	ldd	r27, Y+1	; 0x01
    988a:	fd 01       	movw	r30, r26
    988c:	01 90       	ld	r0, Z+
    988e:	00 20       	and	r0, r0
    9890:	e9 f7       	brne	.-6      	; 0x988c <PutEnum+0x1c>
    9892:	31 97       	sbiw	r30, 0x01	; 1
    9894:	9e 2f       	mov	r25, r30
    9896:	9a 1b       	sub	r25, r26
    9898:	20 e2       	ldi	r18, 0x20	; 32
    989a:	06 c0       	rjmp	.+12     	; 0x98a8 <PutEnum+0x38>
    989c:	e8 81       	ld	r30, Y
    989e:	f9 81       	ldd	r31, Y+1	; 0x01
    98a0:	e9 0f       	add	r30, r25
    98a2:	f1 1d       	adc	r31, r1
    98a4:	20 83       	st	Z, r18
    98a6:	9f 5f       	subi	r25, 0xFF	; 255
    98a8:	8b 81       	ldd	r24, Y+3	; 0x03
    98aa:	98 17       	cp	r25, r24
    98ac:	b8 f3       	brcs	.-18     	; 0x989c <PutEnum+0x2c>
}
    98ae:	df 91       	pop	r29
    98b0:	cf 91       	pop	r28
    98b2:	08 95       	ret

000098b4 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    98b4:	6f 92       	push	r6
    98b6:	7f 92       	push	r7
    98b8:	8f 92       	push	r8
    98ba:	9f 92       	push	r9
    98bc:	af 92       	push	r10
    98be:	bf 92       	push	r11
    98c0:	cf 92       	push	r12
    98c2:	df 92       	push	r13
    98c4:	ef 92       	push	r14
    98c6:	ff 92       	push	r15
    98c8:	0f 93       	push	r16
    98ca:	1f 93       	push	r17
    98cc:	df 93       	push	r29
    98ce:	cf 93       	push	r28
    98d0:	cd b7       	in	r28, 0x3d	; 61
    98d2:	de b7       	in	r29, 0x3e	; 62
    98d4:	2c 97       	sbiw	r28, 0x0c	; 12
    98d6:	0f b6       	in	r0, 0x3f	; 63
    98d8:	f8 94       	cli
    98da:	de bf       	out	0x3e, r29	; 62
    98dc:	0f be       	out	0x3f, r0	; 63
    98de:	cd bf       	out	0x3d, r28	; 61
    98e0:	3b 01       	movw	r6, r22
    98e2:	4c 01       	movw	r8, r24
    98e4:	5a 01       	movw	r10, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    98e6:	da 01       	movw	r26, r20
    98e8:	14 96       	adiw	r26, 0x04	; 4
    98ea:	2d 91       	ld	r18, X+
    98ec:	3c 91       	ld	r19, X
    98ee:	15 97       	sbiw	r26, 0x05	; 5
    98f0:	21 15       	cp	r18, r1
    98f2:	31 05       	cpc	r19, r1
    98f4:	b1 f0       	breq	.+44     	; 0x9922 <Put_zDVal+0x6e>
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    98f6:	dc 01       	movw	r26, r24
    98f8:	cb 01       	movw	r24, r22
    98fa:	80 95       	com	r24
    98fc:	90 95       	com	r25
    98fe:	a0 95       	com	r26
    9900:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    9902:	82 30       	cpi	r24, 0x02	; 2
    9904:	91 05       	cpc	r25, r1
    9906:	a1 05       	cpc	r26, r1
    9908:	b1 05       	cpc	r27, r1
    990a:	58 f4       	brcc	.+22     	; 0x9922 <Put_zDVal+0x6e>
		Param->Txt += Idx;
    990c:	88 0f       	add	r24, r24
    990e:	99 1f       	adc	r25, r25
    9910:	28 0f       	add	r18, r24
    9912:	39 1f       	adc	r19, r25
    9914:	fa 01       	movw	r30, r20
    9916:	35 83       	std	Z+5, r19	; 0x05
    9918:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    991a:	ca 01       	movw	r24, r20
    991c:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    9920:	ae c0       	rjmp	.+348    	; 0x9a7e <Put_zDVal+0x1ca>
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    9922:	d5 01       	movw	r26, r10
    9924:	13 96       	adiw	r26, 0x03	; 3
    9926:	8c 91       	ld	r24, X
    9928:	13 97       	sbiw	r26, 0x03	; 3
    992a:	8a 30       	cpi	r24, 0x0A	; 10
    992c:	c9 f4       	brne	.+50     	; 0x9960 <Put_zDVal+0xac>
    992e:	12 96       	adiw	r26, 0x02	; 2
    9930:	8c 91       	ld	r24, X
    9932:	12 97       	sbiw	r26, 0x02	; 2
    9934:	88 23       	and	r24, r24
    9936:	a1 f4       	brne	.+40     	; 0x9960 <Put_zDVal+0xac>
		sprintf(Param->Pos, "%010lu", Val);
    9938:	ed b7       	in	r30, 0x3d	; 61
    993a:	fe b7       	in	r31, 0x3e	; 62
    993c:	38 97       	sbiw	r30, 0x08	; 8
    993e:	0f b6       	in	r0, 0x3f	; 63
    9940:	f8 94       	cli
    9942:	fe bf       	out	0x3e, r31	; 62
    9944:	0f be       	out	0x3f, r0	; 63
    9946:	ed bf       	out	0x3d, r30	; 61
    9948:	31 96       	adiw	r30, 0x01	; 1
    994a:	8d 91       	ld	r24, X+
    994c:	9c 91       	ld	r25, X
    994e:	ad b7       	in	r26, 0x3d	; 61
    9950:	be b7       	in	r27, 0x3e	; 62
    9952:	12 96       	adiw	r26, 0x02	; 2
    9954:	9c 93       	st	X, r25
    9956:	8e 93       	st	-X, r24
    9958:	11 97       	sbiw	r26, 0x01	; 1
    995a:	88 e3       	ldi	r24, 0x38	; 56
    995c:	91 e0       	ldi	r25, 0x01	; 1
    995e:	7f c0       	rjmp	.+254    	; 0x9a5e <Put_zDVal+0x1aa>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    9960:	de 01       	movw	r26, r28
    9962:	11 96       	adiw	r26, 0x01	; 1
    9964:	ef e3       	ldi	r30, 0x3F	; 63
    9966:	f1 e0       	ldi	r31, 0x01	; 1
    9968:	8c e0       	ldi	r24, 0x0C	; 12
    996a:	01 90       	ld	r0, Z+
    996c:	0d 92       	st	X+, r0
    996e:	81 50       	subi	r24, 0x01	; 1
    9970:	e1 f7       	brne	.-8      	; 0x996a <Put_zDVal+0xb6>
	Format[2] = '0'+Param->Size;
    9972:	d5 01       	movw	r26, r10
    9974:	13 96       	adiw	r26, 0x03	; 3
    9976:	2c 91       	ld	r18, X
    9978:	13 97       	sbiw	r26, 0x03	; 3
    997a:	20 5d       	subi	r18, 0xD0	; 208
    997c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    997e:	12 96       	adiw	r26, 0x02	; 2
    9980:	9c 91       	ld	r25, X
    9982:	99 23       	and	r25, r25
    9984:	09 f4       	brne	.+2      	; 0x9988 <Put_zDVal+0xd4>
    9986:	54 c0       	rjmp	.+168    	; 0x9a30 <Put_zDVal+0x17c>
		Format[2] -= Param->Prec+1;
    9988:	89 2f       	mov	r24, r25
    998a:	80 95       	com	r24
    998c:	82 0f       	add	r24, r18
    998e:	8b 83       	std	Y+3, r24	; 0x03
		Format[8] = '0'+Param->Prec;
    9990:	90 5d       	subi	r25, 0xD0	; 208
    9992:	99 87       	std	Y+9, r25	; 0x09
    9994:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    9996:	09 2f       	mov	r16, r25
    9998:	b1 e0       	ldi	r27, 0x01	; 1
    999a:	cb 2e       	mov	r12, r27
    999c:	d1 2c       	mov	r13, r1
    999e:	e1 2c       	mov	r14, r1
    99a0:	f1 2c       	mov	r15, r1
    99a2:	0b c0       	rjmp	.+22     	; 0x99ba <Put_zDVal+0x106>
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
		Pow *= 10;
    99a4:	c7 01       	movw	r24, r14
    99a6:	b6 01       	movw	r22, r12
    99a8:	2a e0       	ldi	r18, 0x0A	; 10
    99aa:	30 e0       	ldi	r19, 0x00	; 0
    99ac:	40 e0       	ldi	r20, 0x00	; 0
    99ae:	50 e0       	ldi	r21, 0x00	; 0
    99b0:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    99b4:	6b 01       	movw	r12, r22
    99b6:	7c 01       	movw	r14, r24
    99b8:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    99ba:	00 23       	and	r16, r16
    99bc:	99 f7       	brne	.-26     	; 0x99a4 <Put_zDVal+0xf0>
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    99be:	ed b7       	in	r30, 0x3d	; 61
    99c0:	fe b7       	in	r31, 0x3e	; 62
    99c2:	3c 97       	sbiw	r30, 0x0c	; 12
    99c4:	0f b6       	in	r0, 0x3f	; 63
    99c6:	f8 94       	cli
    99c8:	fe bf       	out	0x3e, r31	; 62
    99ca:	0f be       	out	0x3f, r0	; 63
    99cc:	ed bf       	out	0x3d, r30	; 61
    99ce:	0d b7       	in	r16, 0x3d	; 61
    99d0:	1e b7       	in	r17, 0x3e	; 62
    99d2:	0f 5f       	subi	r16, 0xFF	; 255
    99d4:	1f 4f       	sbci	r17, 0xFF	; 255
    99d6:	d5 01       	movw	r26, r10
    99d8:	8d 91       	ld	r24, X+
    99da:	9c 91       	ld	r25, X
    99dc:	92 83       	std	Z+2, r25	; 0x02
    99de:	81 83       	std	Z+1, r24	; 0x01
    99e0:	ce 01       	movw	r24, r28
    99e2:	01 96       	adiw	r24, 0x01	; 1
    99e4:	f8 01       	movw	r30, r16
    99e6:	93 83       	std	Z+3, r25	; 0x03
    99e8:	82 83       	std	Z+2, r24	; 0x02
    99ea:	c4 01       	movw	r24, r8
    99ec:	b3 01       	movw	r22, r6
    99ee:	a7 01       	movw	r20, r14
    99f0:	96 01       	movw	r18, r12
    99f2:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    99f6:	d8 01       	movw	r26, r16
    99f8:	14 96       	adiw	r26, 0x04	; 4
    99fa:	2d 93       	st	X+, r18
    99fc:	3d 93       	st	X+, r19
    99fe:	4d 93       	st	X+, r20
    9a00:	5c 93       	st	X, r21
    9a02:	17 97       	sbiw	r26, 0x07	; 7
    9a04:	c4 01       	movw	r24, r8
    9a06:	b3 01       	movw	r22, r6
    9a08:	a7 01       	movw	r20, r14
    9a0a:	96 01       	movw	r18, r12
    9a0c:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    9a10:	f8 01       	movw	r30, r16
    9a12:	60 87       	std	Z+8, r22	; 0x08
    9a14:	71 87       	std	Z+9, r23	; 0x09
    9a16:	82 87       	std	Z+10, r24	; 0x0a
    9a18:	93 87       	std	Z+11, r25	; 0x0b
    9a1a:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9a1e:	8d b7       	in	r24, 0x3d	; 61
    9a20:	9e b7       	in	r25, 0x3e	; 62
    9a22:	0c 96       	adiw	r24, 0x0c	; 12
    9a24:	0f b6       	in	r0, 0x3f	; 63
    9a26:	f8 94       	cli
    9a28:	9e bf       	out	0x3e, r25	; 62
    9a2a:	0f be       	out	0x3f, r0	; 63
    9a2c:	8d bf       	out	0x3d, r24	; 61
    9a2e:	27 c0       	rjmp	.+78     	; 0x9a7e <Put_zDVal+0x1ca>
	}
	else {
		Format[5] = '\0';
    9a30:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    9a32:	ad b7       	in	r26, 0x3d	; 61
    9a34:	be b7       	in	r27, 0x3e	; 62
    9a36:	18 97       	sbiw	r26, 0x08	; 8
    9a38:	0f b6       	in	r0, 0x3f	; 63
    9a3a:	f8 94       	cli
    9a3c:	be bf       	out	0x3e, r27	; 62
    9a3e:	0f be       	out	0x3f, r0	; 63
    9a40:	ad bf       	out	0x3d, r26	; 61
    9a42:	ed b7       	in	r30, 0x3d	; 61
    9a44:	fe b7       	in	r31, 0x3e	; 62
    9a46:	31 96       	adiw	r30, 0x01	; 1
    9a48:	d5 01       	movw	r26, r10
    9a4a:	8d 91       	ld	r24, X+
    9a4c:	9c 91       	ld	r25, X
    9a4e:	ad b7       	in	r26, 0x3d	; 61
    9a50:	be b7       	in	r27, 0x3e	; 62
    9a52:	12 96       	adiw	r26, 0x02	; 2
    9a54:	9c 93       	st	X, r25
    9a56:	8e 93       	st	-X, r24
    9a58:	11 97       	sbiw	r26, 0x01	; 1
    9a5a:	ce 01       	movw	r24, r28
    9a5c:	01 96       	adiw	r24, 0x01	; 1
    9a5e:	93 83       	std	Z+3, r25	; 0x03
    9a60:	82 83       	std	Z+2, r24	; 0x02
    9a62:	64 82       	std	Z+4, r6	; 0x04
    9a64:	75 82       	std	Z+5, r7	; 0x05
    9a66:	86 82       	std	Z+6, r8	; 0x06
    9a68:	97 82       	std	Z+7, r9	; 0x07
    9a6a:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9a6e:	ed b7       	in	r30, 0x3d	; 61
    9a70:	fe b7       	in	r31, 0x3e	; 62
    9a72:	38 96       	adiw	r30, 0x08	; 8
    9a74:	0f b6       	in	r0, 0x3f	; 63
    9a76:	f8 94       	cli
    9a78:	fe bf       	out	0x3e, r31	; 62
    9a7a:	0f be       	out	0x3f, r0	; 63
    9a7c:	ed bf       	out	0x3d, r30	; 61
	}
}
    9a7e:	2c 96       	adiw	r28, 0x0c	; 12
    9a80:	0f b6       	in	r0, 0x3f	; 63
    9a82:	f8 94       	cli
    9a84:	de bf       	out	0x3e, r29	; 62
    9a86:	0f be       	out	0x3f, r0	; 63
    9a88:	cd bf       	out	0x3d, r28	; 61
    9a8a:	cf 91       	pop	r28
    9a8c:	df 91       	pop	r29
    9a8e:	1f 91       	pop	r17
    9a90:	0f 91       	pop	r16
    9a92:	ff 90       	pop	r15
    9a94:	ef 90       	pop	r14
    9a96:	df 90       	pop	r13
    9a98:	cf 90       	pop	r12
    9a9a:	bf 90       	pop	r11
    9a9c:	af 90       	pop	r10
    9a9e:	9f 90       	pop	r9
    9aa0:	8f 90       	pop	r8
    9aa2:	7f 90       	pop	r7
    9aa4:	6f 90       	pop	r6
    9aa6:	08 95       	ret

00009aa8 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    9aa8:	cf 92       	push	r12
    9aaa:	df 92       	push	r13
    9aac:	ef 92       	push	r14
    9aae:	ff 92       	push	r15
    9ab0:	0f 93       	push	r16
    9ab2:	1f 93       	push	r17
    9ab4:	df 93       	push	r29
    9ab6:	cf 93       	push	r28
    9ab8:	cd b7       	in	r28, 0x3d	; 61
    9aba:	de b7       	in	r29, 0x3e	; 62
    9abc:	2d 97       	sbiw	r28, 0x0d	; 13
    9abe:	0f b6       	in	r0, 0x3f	; 63
    9ac0:	f8 94       	cli
    9ac2:	de bf       	out	0x3e, r29	; 62
    9ac4:	0f be       	out	0x3f, r0	; 63
    9ac6:	cd bf       	out	0x3d, r28	; 61
    9ac8:	6b 01       	movw	r12, r22
    9aca:	7c 01       	movw	r14, r24
    9acc:	8a 01       	movw	r16, r20
	uint32_t Idx = 0x80000000+Val;
	if(Param->Txt && Idx<2) {
    9ace:	da 01       	movw	r26, r20
    9ad0:	14 96       	adiw	r26, 0x04	; 4
    9ad2:	2d 91       	ld	r18, X+
    9ad4:	3c 91       	ld	r19, X
    9ad6:	15 97       	sbiw	r26, 0x05	; 5
    9ad8:	21 15       	cp	r18, r1
    9ada:	31 05       	cpc	r19, r1
    9adc:	b1 f0       	breq	.+44     	; 0x9b0a <Put_sDVal+0x62>
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
	uint32_t Idx = 0x80000000+Val;
    9ade:	dc 01       	movw	r26, r24
    9ae0:	cb 01       	movw	r24, r22
    9ae2:	80 50       	subi	r24, 0x00	; 0
    9ae4:	90 40       	sbci	r25, 0x00	; 0
    9ae6:	a0 40       	sbci	r26, 0x00	; 0
    9ae8:	b0 48       	sbci	r27, 0x80	; 128
	if(Param->Txt && Idx<2) {
    9aea:	82 30       	cpi	r24, 0x02	; 2
    9aec:	91 05       	cpc	r25, r1
    9aee:	a1 05       	cpc	r26, r1
    9af0:	b1 05       	cpc	r27, r1
    9af2:	58 f4       	brcc	.+22     	; 0x9b0a <Put_sDVal+0x62>
		Param->Txt += Idx;
    9af4:	88 0f       	add	r24, r24
    9af6:	99 1f       	adc	r25, r25
    9af8:	28 0f       	add	r18, r24
    9afa:	39 1f       	adc	r19, r25
    9afc:	f8 01       	movw	r30, r16
    9afe:	35 83       	std	Z+5, r19	; 0x05
    9b00:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9b02:	c8 01       	movw	r24, r16
    9b04:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    9b08:	e1 c0       	rjmp	.+450    	; 0x9ccc <Put_sDVal+0x224>
		return;
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    9b0a:	d8 01       	movw	r26, r16
    9b0c:	13 96       	adiw	r26, 0x03	; 3
    9b0e:	8c 91       	ld	r24, X
    9b10:	8a 30       	cpi	r24, 0x0A	; 10
    9b12:	38 f1       	brcs	.+78     	; 0x9b62 <Put_sDVal+0xba>
		char Format[] = "%+1 ld";
    9b14:	de 01       	movw	r26, r28
    9b16:	17 96       	adiw	r26, 0x07	; 7
    9b18:	eb e4       	ldi	r30, 0x4B	; 75
    9b1a:	f1 e0       	ldi	r31, 0x01	; 1
    9b1c:	87 e0       	ldi	r24, 0x07	; 7
    9b1e:	01 90       	ld	r0, Z+
    9b20:	0d 92       	st	X+, r0
    9b22:	81 50       	subi	r24, 0x01	; 1
    9b24:	e1 f7       	brne	.-8      	; 0x9b1e <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    9b26:	f8 01       	movw	r30, r16
    9b28:	83 81       	ldd	r24, Z+3	; 0x03
    9b2a:	6a e0       	ldi	r22, 0x0A	; 10
    9b2c:	0e 94 0a 91 	call	0x12214	; 0x12214 <__udivmodqi4>
    9b30:	90 5d       	subi	r25, 0xD0	; 208
    9b32:	9a 87       	std	Y+10, r25	; 0x0a
		sprintf(Param->Pos, Format, Val);
    9b34:	8d b7       	in	r24, 0x3d	; 61
    9b36:	9e b7       	in	r25, 0x3e	; 62
    9b38:	08 97       	sbiw	r24, 0x08	; 8
    9b3a:	0f b6       	in	r0, 0x3f	; 63
    9b3c:	f8 94       	cli
    9b3e:	9e bf       	out	0x3e, r25	; 62
    9b40:	0f be       	out	0x3f, r0	; 63
    9b42:	8d bf       	out	0x3d, r24	; 61
    9b44:	ed b7       	in	r30, 0x3d	; 61
    9b46:	fe b7       	in	r31, 0x3e	; 62
    9b48:	31 96       	adiw	r30, 0x01	; 1
    9b4a:	d8 01       	movw	r26, r16
    9b4c:	8d 91       	ld	r24, X+
    9b4e:	9c 91       	ld	r25, X
    9b50:	ad b7       	in	r26, 0x3d	; 61
    9b52:	be b7       	in	r27, 0x3e	; 62
    9b54:	12 96       	adiw	r26, 0x02	; 2
    9b56:	9c 93       	st	X, r25
    9b58:	8e 93       	st	-X, r24
    9b5a:	11 97       	sbiw	r26, 0x01	; 1
    9b5c:	ce 01       	movw	r24, r28
    9b5e:	07 96       	adiw	r24, 0x07	; 7
    9b60:	22 c0       	rjmp	.+68     	; 0x9ba6 <Put_sDVal+0xfe>
	}
	else{
		char Format[] = "%+ ld";
    9b62:	de 01       	movw	r26, r28
    9b64:	11 96       	adiw	r26, 0x01	; 1
    9b66:	e2 e5       	ldi	r30, 0x52	; 82
    9b68:	f1 e0       	ldi	r31, 0x01	; 1
    9b6a:	86 e0       	ldi	r24, 0x06	; 6
    9b6c:	01 90       	ld	r0, Z+
    9b6e:	0d 92       	st	X+, r0
    9b70:	81 50       	subi	r24, 0x01	; 1
    9b72:	e1 f7       	brne	.-8      	; 0x9b6c <Put_sDVal+0xc4>
		Format[2] = '0'+Param->Size;
    9b74:	d8 01       	movw	r26, r16
    9b76:	13 96       	adiw	r26, 0x03	; 3
    9b78:	8c 91       	ld	r24, X
    9b7a:	13 97       	sbiw	r26, 0x03	; 3
    9b7c:	80 5d       	subi	r24, 0xD0	; 208
    9b7e:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    9b80:	ed b7       	in	r30, 0x3d	; 61
    9b82:	fe b7       	in	r31, 0x3e	; 62
    9b84:	38 97       	sbiw	r30, 0x08	; 8
    9b86:	0f b6       	in	r0, 0x3f	; 63
    9b88:	f8 94       	cli
    9b8a:	fe bf       	out	0x3e, r31	; 62
    9b8c:	0f be       	out	0x3f, r0	; 63
    9b8e:	ed bf       	out	0x3d, r30	; 61
    9b90:	31 96       	adiw	r30, 0x01	; 1
    9b92:	8d 91       	ld	r24, X+
    9b94:	9c 91       	ld	r25, X
    9b96:	ad b7       	in	r26, 0x3d	; 61
    9b98:	be b7       	in	r27, 0x3e	; 62
    9b9a:	12 96       	adiw	r26, 0x02	; 2
    9b9c:	9c 93       	st	X, r25
    9b9e:	8e 93       	st	-X, r24
    9ba0:	11 97       	sbiw	r26, 0x01	; 1
    9ba2:	ce 01       	movw	r24, r28
    9ba4:	01 96       	adiw	r24, 0x01	; 1
    9ba6:	93 83       	std	Z+3, r25	; 0x03
    9ba8:	82 83       	std	Z+2, r24	; 0x02
    9baa:	c4 82       	std	Z+4, r12	; 0x04
    9bac:	d5 82       	std	Z+5, r13	; 0x05
    9bae:	e6 82       	std	Z+6, r14	; 0x06
    9bb0:	f7 82       	std	Z+7, r15	; 0x07
    9bb2:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9bb6:	ed b7       	in	r30, 0x3d	; 61
    9bb8:	fe b7       	in	r31, 0x3e	; 62
    9bba:	38 96       	adiw	r30, 0x08	; 8
    9bbc:	0f b6       	in	r0, 0x3f	; 63
    9bbe:	f8 94       	cli
    9bc0:	fe bf       	out	0x3e, r31	; 62
    9bc2:	0f be       	out	0x3f, r0	; 63
    9bc4:	ed bf       	out	0x3d, r30	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    9bc6:	c1 14       	cp	r12, r1
    9bc8:	d1 04       	cpc	r13, r1
    9bca:	e1 04       	cpc	r14, r1
    9bcc:	f1 04       	cpc	r15, r1
    9bce:	59 f4       	brne	.+22     	; 0x9be6 <Put_sDVal+0x13e>
    9bd0:	d8 01       	movw	r26, r16
    9bd2:	13 96       	adiw	r26, 0x03	; 3
    9bd4:	8c 91       	ld	r24, X
    9bd6:	13 97       	sbiw	r26, 0x03	; 3
    9bd8:	ed 91       	ld	r30, X+
    9bda:	fc 91       	ld	r31, X
    9bdc:	e8 0f       	add	r30, r24
    9bde:	f1 1d       	adc	r31, r1
    9be0:	32 97       	sbiw	r30, 0x02	; 2
    9be2:	80 e2       	ldi	r24, 0x20	; 32
    9be4:	80 83       	st	Z, r24

	if(Param->Prec){
    9be6:	f8 01       	movw	r30, r16
    9be8:	82 81       	ldd	r24, Z+2	; 0x02
    9bea:	88 23       	and	r24, r24
    9bec:	09 f4       	brne	.+2      	; 0x9bf0 <Put_sDVal+0x148>
    9bee:	6e c0       	rjmp	.+220    	; 0x9ccc <Put_sDVal+0x224>
    9bf0:	40 e0       	ldi	r20, 0x00	; 0
    9bf2:	05 c0       	rjmp	.+10     	; 0x9bfe <Put_sDVal+0x156>
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
			Param->Pos[i] = Param->Pos[i+1];
    9bf4:	e8 0f       	add	r30, r24
    9bf6:	f9 1f       	adc	r31, r25
    9bf8:	81 81       	ldd	r24, Z+1	; 0x01
    9bfa:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    9bfc:	4f 5f       	subi	r20, 0xFF	; 255
    9bfe:	d8 01       	movw	r26, r16
    9c00:	13 96       	adiw	r26, 0x03	; 3
    9c02:	8c 91       	ld	r24, X
    9c04:	13 97       	sbiw	r26, 0x03	; 3
    9c06:	28 2f       	mov	r18, r24
    9c08:	30 e0       	ldi	r19, 0x00	; 0
    9c0a:	12 96       	adiw	r26, 0x02	; 2
    9c0c:	8c 91       	ld	r24, X
    9c0e:	12 97       	sbiw	r26, 0x02	; 2
    9c10:	28 1b       	sub	r18, r24
    9c12:	31 09       	sbc	r19, r1
    9c14:	84 2f       	mov	r24, r20
    9c16:	90 e0       	ldi	r25, 0x00	; 0
    9c18:	ed 91       	ld	r30, X+
    9c1a:	fc 91       	ld	r31, X
    9c1c:	11 97       	sbiw	r26, 0x01	; 1
    9c1e:	82 17       	cp	r24, r18
    9c20:	93 07       	cpc	r25, r19
    9c22:	44 f3       	brlt	.-48     	; 0x9bf4 <Put_sDVal+0x14c>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    9c24:	e2 0f       	add	r30, r18
    9c26:	f3 1f       	adc	r31, r19
    9c28:	31 97       	sbiw	r30, 0x01	; 1
    9c2a:	8e e2       	ldi	r24, 0x2E	; 46
    9c2c:	80 83       	st	Z, r24
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    9c2e:	13 96       	adiw	r26, 0x03	; 3
    9c30:	3c 91       	ld	r19, X
    9c32:	13 97       	sbiw	r26, 0x03	; 3
    9c34:	83 2f       	mov	r24, r19
    9c36:	90 e0       	ldi	r25, 0x00	; 0
    9c38:	12 96       	adiw	r26, 0x02	; 2
    9c3a:	2c 91       	ld	r18, X
    9c3c:	12 97       	sbiw	r26, 0x02	; 2
    9c3e:	82 1b       	sub	r24, r18
    9c40:	91 09       	sbc	r25, r1
    9c42:	ed 91       	ld	r30, X+
    9c44:	fc 91       	ld	r31, X
    9c46:	e8 0f       	add	r30, r24
    9c48:	f9 1f       	adc	r31, r25
    9c4a:	32 97       	sbiw	r30, 0x02	; 2
    9c4c:	e0 81       	ld	r30, Z
		if(c ==' ' || c =='+' || c =='-'){
    9c4e:	e0 32       	cpi	r30, 0x20	; 32
    9c50:	21 f0       	breq	.+8      	; 0x9c5a <Put_sDVal+0x1b2>
    9c52:	eb 32       	cpi	r30, 0x2B	; 43
    9c54:	11 f0       	breq	.+4      	; 0x9c5a <Put_sDVal+0x1b2>
    9c56:	ed 32       	cpi	r30, 0x2D	; 45
    9c58:	c9 f5       	brne	.+114    	; 0x9ccc <Put_sDVal+0x224>
			for(uint8_t i=Param->Size-1; i>1; i--){
    9c5a:	93 2f       	mov	r25, r19
    9c5c:	91 50       	subi	r25, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    9c5e:	40 e3       	ldi	r20, 0x30	; 48
    9c60:	33 c0       	rjmp	.+102    	; 0x9cc8 <Put_sDVal+0x220>
    9c62:	29 2f       	mov	r18, r25
    9c64:	30 e0       	ldi	r19, 0x00	; 0
    9c66:	d8 01       	movw	r26, r16
    9c68:	ed 91       	ld	r30, X+
    9c6a:	fc 91       	ld	r31, X
    9c6c:	e2 0f       	add	r30, r18
    9c6e:	f3 1f       	adc	r31, r19
    9c70:	80 81       	ld	r24, Z
    9c72:	80 32       	cpi	r24, 0x20	; 32
    9c74:	21 f0       	breq	.+8      	; 0x9c7e <Put_sDVal+0x1d6>
    9c76:	8b 32       	cpi	r24, 0x2B	; 43
    9c78:	11 f0       	breq	.+4      	; 0x9c7e <Put_sDVal+0x1d6>
    9c7a:	8d 32       	cpi	r24, 0x2D	; 45
    9c7c:	09 f4       	brne	.+2      	; 0x9c80 <Put_sDVal+0x1d8>
    9c7e:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    9c80:	d8 01       	movw	r26, r16
    9c82:	ed 91       	ld	r30, X+
    9c84:	fc 91       	ld	r31, X
    9c86:	11 97       	sbiw	r26, 0x01	; 1
    9c88:	e2 0f       	add	r30, r18
    9c8a:	f3 1f       	adc	r31, r19
    9c8c:	80 81       	ld	r24, Z
    9c8e:	8e 32       	cpi	r24, 0x2E	; 46
    9c90:	d1 f4       	brne	.+52     	; 0x9cc6 <Put_sDVal+0x21e>
					Param->Pos[i-1]='0';
    9c92:	31 97       	sbiw	r30, 0x01	; 1
    9c94:	80 e3       	ldi	r24, 0x30	; 48
    9c96:	80 83       	st	Z, r24
					if(Val>0)Param->Pos[i-2]='+';
    9c98:	1c 14       	cp	r1, r12
    9c9a:	1d 04       	cpc	r1, r13
    9c9c:	1e 04       	cpc	r1, r14
    9c9e:	1f 04       	cpc	r1, r15
    9ca0:	3c f4       	brge	.+14     	; 0x9cb0 <Put_sDVal+0x208>
    9ca2:	ed 91       	ld	r30, X+
    9ca4:	fc 91       	ld	r31, X
    9ca6:	e2 0f       	add	r30, r18
    9ca8:	f3 1f       	adc	r31, r19
    9caa:	32 97       	sbiw	r30, 0x02	; 2
    9cac:	8b e2       	ldi	r24, 0x2B	; 43
    9cae:	80 83       	st	Z, r24
					if(Val<0)Param->Pos[i-2]='-';
    9cb0:	f7 fe       	sbrs	r15, 7
    9cb2:	0c c0       	rjmp	.+24     	; 0x9ccc <Put_sDVal+0x224>
    9cb4:	d8 01       	movw	r26, r16
    9cb6:	ed 91       	ld	r30, X+
    9cb8:	fc 91       	ld	r31, X
    9cba:	e2 0f       	add	r30, r18
    9cbc:	f3 1f       	adc	r31, r19
    9cbe:	32 97       	sbiw	r30, 0x02	; 2
    9cc0:	8d e2       	ldi	r24, 0x2D	; 45
    9cc2:	80 83       	st	Z, r24
    9cc4:	03 c0       	rjmp	.+6      	; 0x9ccc <Put_sDVal+0x224>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    9cc6:	91 50       	subi	r25, 0x01	; 1
    9cc8:	92 30       	cpi	r25, 0x02	; 2
    9cca:	58 f6       	brcc	.-106    	; 0x9c62 <Put_sDVal+0x1ba>
				}
			}
		}
	}

}
    9ccc:	2d 96       	adiw	r28, 0x0d	; 13
    9cce:	0f b6       	in	r0, 0x3f	; 63
    9cd0:	f8 94       	cli
    9cd2:	de bf       	out	0x3e, r29	; 62
    9cd4:	0f be       	out	0x3f, r0	; 63
    9cd6:	cd bf       	out	0x3d, r28	; 61
    9cd8:	cf 91       	pop	r28
    9cda:	df 91       	pop	r29
    9cdc:	1f 91       	pop	r17
    9cde:	0f 91       	pop	r16
    9ce0:	ff 90       	pop	r15
    9ce2:	ef 90       	pop	r14
    9ce4:	df 90       	pop	r13
    9ce6:	cf 90       	pop	r12
    9ce8:	08 95       	ret

00009cea <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    9cea:	6f 92       	push	r6
    9cec:	7f 92       	push	r7
    9cee:	8f 92       	push	r8
    9cf0:	9f 92       	push	r9
    9cf2:	af 92       	push	r10
    9cf4:	bf 92       	push	r11
    9cf6:	cf 92       	push	r12
    9cf8:	df 92       	push	r13
    9cfa:	ef 92       	push	r14
    9cfc:	ff 92       	push	r15
    9cfe:	0f 93       	push	r16
    9d00:	1f 93       	push	r17
    9d02:	df 93       	push	r29
    9d04:	cf 93       	push	r28
    9d06:	cd b7       	in	r28, 0x3d	; 61
    9d08:	de b7       	in	r29, 0x3e	; 62
    9d0a:	2b 97       	sbiw	r28, 0x0b	; 11
    9d0c:	0f b6       	in	r0, 0x3f	; 63
    9d0e:	f8 94       	cli
    9d10:	de bf       	out	0x3e, r29	; 62
    9d12:	0f be       	out	0x3f, r0	; 63
    9d14:	cd bf       	out	0x3d, r28	; 61
    9d16:	3b 01       	movw	r6, r22
    9d18:	4c 01       	movw	r8, r24
    9d1a:	5a 01       	movw	r10, r20
	uint32_t Idx = 0xFFFFFFFF-Val;
	if(Param->Txt && Idx<2) {
    9d1c:	da 01       	movw	r26, r20
    9d1e:	14 96       	adiw	r26, 0x04	; 4
    9d20:	2d 91       	ld	r18, X+
    9d22:	3c 91       	ld	r19, X
    9d24:	15 97       	sbiw	r26, 0x05	; 5
    9d26:	21 15       	cp	r18, r1
    9d28:	31 05       	cpc	r19, r1
    9d2a:	b1 f0       	breq	.+44     	; 0x9d58 <PutDVal+0x6e>
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
	uint32_t Idx = 0xFFFFFFFF-Val;
    9d2c:	dc 01       	movw	r26, r24
    9d2e:	cb 01       	movw	r24, r22
    9d30:	80 95       	com	r24
    9d32:	90 95       	com	r25
    9d34:	a0 95       	com	r26
    9d36:	b0 95       	com	r27
	if(Param->Txt && Idx<2) {
    9d38:	82 30       	cpi	r24, 0x02	; 2
    9d3a:	91 05       	cpc	r25, r1
    9d3c:	a1 05       	cpc	r26, r1
    9d3e:	b1 05       	cpc	r27, r1
    9d40:	58 f4       	brcc	.+22     	; 0x9d58 <PutDVal+0x6e>
		Param->Txt += Idx;
    9d42:	88 0f       	add	r24, r24
    9d44:	99 1f       	adc	r25, r25
    9d46:	28 0f       	add	r18, r24
    9d48:	39 1f       	adc	r19, r25
    9d4a:	fa 01       	movw	r30, r20
    9d4c:	35 83       	std	Z+5, r19	; 0x05
    9d4e:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    9d50:	ca 01       	movw	r24, r20
    9d52:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    9d56:	ae c0       	rjmp	.+348    	; 0x9eb4 <PutDVal+0x1ca>
		return;
	}

	if(Param->Size==10 && Param->Prec==0){
    9d58:	d5 01       	movw	r26, r10
    9d5a:	13 96       	adiw	r26, 0x03	; 3
    9d5c:	8c 91       	ld	r24, X
    9d5e:	13 97       	sbiw	r26, 0x03	; 3
    9d60:	8a 30       	cpi	r24, 0x0A	; 10
    9d62:	c9 f4       	brne	.+50     	; 0x9d96 <PutDVal+0xac>
    9d64:	12 96       	adiw	r26, 0x02	; 2
    9d66:	8c 91       	ld	r24, X
    9d68:	12 97       	sbiw	r26, 0x02	; 2
    9d6a:	88 23       	and	r24, r24
    9d6c:	a1 f4       	brne	.+40     	; 0x9d96 <PutDVal+0xac>
		sprintf(Param->Pos, "%10lu", Val);
    9d6e:	ed b7       	in	r30, 0x3d	; 61
    9d70:	fe b7       	in	r31, 0x3e	; 62
    9d72:	38 97       	sbiw	r30, 0x08	; 8
    9d74:	0f b6       	in	r0, 0x3f	; 63
    9d76:	f8 94       	cli
    9d78:	fe bf       	out	0x3e, r31	; 62
    9d7a:	0f be       	out	0x3f, r0	; 63
    9d7c:	ed bf       	out	0x3d, r30	; 61
    9d7e:	31 96       	adiw	r30, 0x01	; 1
    9d80:	8d 91       	ld	r24, X+
    9d82:	9c 91       	ld	r25, X
    9d84:	ad b7       	in	r26, 0x3d	; 61
    9d86:	be b7       	in	r27, 0x3e	; 62
    9d88:	12 96       	adiw	r26, 0x02	; 2
    9d8a:	9c 93       	st	X, r25
    9d8c:	8e 93       	st	-X, r24
    9d8e:	11 97       	sbiw	r26, 0x01	; 1
    9d90:	88 e5       	ldi	r24, 0x58	; 88
    9d92:	91 e0       	ldi	r25, 0x01	; 1
    9d94:	7f c0       	rjmp	.+254    	; 0x9e94 <PutDVal+0x1aa>
		return;
	}
	char Format[] = "% lu.%. lu";
    9d96:	de 01       	movw	r26, r28
    9d98:	11 96       	adiw	r26, 0x01	; 1
    9d9a:	ee e5       	ldi	r30, 0x5E	; 94
    9d9c:	f1 e0       	ldi	r31, 0x01	; 1
    9d9e:	8b e0       	ldi	r24, 0x0B	; 11
    9da0:	01 90       	ld	r0, Z+
    9da2:	0d 92       	st	X+, r0
    9da4:	81 50       	subi	r24, 0x01	; 1
    9da6:	e1 f7       	brne	.-8      	; 0x9da0 <PutDVal+0xb6>
	Format[1] = '0'+Param->Size;
    9da8:	d5 01       	movw	r26, r10
    9daa:	13 96       	adiw	r26, 0x03	; 3
    9dac:	2c 91       	ld	r18, X
    9dae:	13 97       	sbiw	r26, 0x03	; 3
    9db0:	20 5d       	subi	r18, 0xD0	; 208
    9db2:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    9db4:	12 96       	adiw	r26, 0x02	; 2
    9db6:	9c 91       	ld	r25, X
    9db8:	99 23       	and	r25, r25
    9dba:	09 f4       	brne	.+2      	; 0x9dbe <PutDVal+0xd4>
    9dbc:	54 c0       	rjmp	.+168    	; 0x9e66 <PutDVal+0x17c>
		Format[1] -= Param->Prec+1;
    9dbe:	89 2f       	mov	r24, r25
    9dc0:	80 95       	com	r24
    9dc2:	82 0f       	add	r24, r18
    9dc4:	8a 83       	std	Y+2, r24	; 0x02
		Format[7] = '0'+Param->Prec;
    9dc6:	90 5d       	subi	r25, 0xD0	; 208
    9dc8:	98 87       	std	Y+8, r25	; 0x08
    9dca:	90 53       	subi	r25, 0x30	; 48
		uint32_t Div=PowL10(Param->Prec);
    9dcc:	09 2f       	mov	r16, r25
    9dce:	51 e0       	ldi	r21, 0x01	; 1
    9dd0:	c5 2e       	mov	r12, r21
    9dd2:	d1 2c       	mov	r13, r1
    9dd4:	e1 2c       	mov	r14, r1
    9dd6:	f1 2c       	mov	r15, r1
    9dd8:	0b c0       	rjmp	.+22     	; 0x9df0 <PutDVal+0x106>
		Pow *= 10;
    9dda:	c7 01       	movw	r24, r14
    9ddc:	b6 01       	movw	r22, r12
    9dde:	2a e0       	ldi	r18, 0x0A	; 10
    9de0:	30 e0       	ldi	r19, 0x00	; 0
    9de2:	40 e0       	ldi	r20, 0x00	; 0
    9de4:	50 e0       	ldi	r21, 0x00	; 0
    9de6:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    9dea:	6b 01       	movw	r12, r22
    9dec:	7c 01       	movw	r14, r24
    9dee:	01 50       	subi	r16, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
	uint32_t Pow = 1;
	while(Exp--)
    9df0:	00 23       	and	r16, r16
    9df2:	99 f7       	brne	.-26     	; 0x9dda <PutDVal+0xf0>
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9df4:	ed b7       	in	r30, 0x3d	; 61
    9df6:	fe b7       	in	r31, 0x3e	; 62
    9df8:	3c 97       	sbiw	r30, 0x0c	; 12
    9dfa:	0f b6       	in	r0, 0x3f	; 63
    9dfc:	f8 94       	cli
    9dfe:	fe bf       	out	0x3e, r31	; 62
    9e00:	0f be       	out	0x3f, r0	; 63
    9e02:	ed bf       	out	0x3d, r30	; 61
    9e04:	0d b7       	in	r16, 0x3d	; 61
    9e06:	1e b7       	in	r17, 0x3e	; 62
    9e08:	0f 5f       	subi	r16, 0xFF	; 255
    9e0a:	1f 4f       	sbci	r17, 0xFF	; 255
    9e0c:	d5 01       	movw	r26, r10
    9e0e:	8d 91       	ld	r24, X+
    9e10:	9c 91       	ld	r25, X
    9e12:	92 83       	std	Z+2, r25	; 0x02
    9e14:	81 83       	std	Z+1, r24	; 0x01
    9e16:	ce 01       	movw	r24, r28
    9e18:	01 96       	adiw	r24, 0x01	; 1
    9e1a:	f8 01       	movw	r30, r16
    9e1c:	93 83       	std	Z+3, r25	; 0x03
    9e1e:	82 83       	std	Z+2, r24	; 0x02
    9e20:	c4 01       	movw	r24, r8
    9e22:	b3 01       	movw	r22, r6
    9e24:	a7 01       	movw	r20, r14
    9e26:	96 01       	movw	r18, r12
    9e28:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    9e2c:	d8 01       	movw	r26, r16
    9e2e:	14 96       	adiw	r26, 0x04	; 4
    9e30:	2d 93       	st	X+, r18
    9e32:	3d 93       	st	X+, r19
    9e34:	4d 93       	st	X+, r20
    9e36:	5c 93       	st	X, r21
    9e38:	17 97       	sbiw	r26, 0x07	; 7
    9e3a:	c4 01       	movw	r24, r8
    9e3c:	b3 01       	movw	r22, r6
    9e3e:	a7 01       	movw	r20, r14
    9e40:	96 01       	movw	r18, r12
    9e42:	0e 94 3d 91 	call	0x1227a	; 0x1227a <__udivmodsi4>
    9e46:	f8 01       	movw	r30, r16
    9e48:	60 87       	std	Z+8, r22	; 0x08
    9e4a:	71 87       	std	Z+9, r23	; 0x09
    9e4c:	82 87       	std	Z+10, r24	; 0x0a
    9e4e:	93 87       	std	Z+11, r25	; 0x0b
    9e50:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9e54:	8d b7       	in	r24, 0x3d	; 61
    9e56:	9e b7       	in	r25, 0x3e	; 62
    9e58:	0c 96       	adiw	r24, 0x0c	; 12
    9e5a:	0f b6       	in	r0, 0x3f	; 63
    9e5c:	f8 94       	cli
    9e5e:	9e bf       	out	0x3e, r25	; 62
    9e60:	0f be       	out	0x3f, r0	; 63
    9e62:	8d bf       	out	0x3d, r24	; 61
    9e64:	27 c0       	rjmp	.+78     	; 0x9eb4 <PutDVal+0x1ca>
	}
	else {
		Format[4] = '\0';
    9e66:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9e68:	ad b7       	in	r26, 0x3d	; 61
    9e6a:	be b7       	in	r27, 0x3e	; 62
    9e6c:	18 97       	sbiw	r26, 0x08	; 8
    9e6e:	0f b6       	in	r0, 0x3f	; 63
    9e70:	f8 94       	cli
    9e72:	be bf       	out	0x3e, r27	; 62
    9e74:	0f be       	out	0x3f, r0	; 63
    9e76:	ad bf       	out	0x3d, r26	; 61
    9e78:	ed b7       	in	r30, 0x3d	; 61
    9e7a:	fe b7       	in	r31, 0x3e	; 62
    9e7c:	31 96       	adiw	r30, 0x01	; 1
    9e7e:	d5 01       	movw	r26, r10
    9e80:	8d 91       	ld	r24, X+
    9e82:	9c 91       	ld	r25, X
    9e84:	ad b7       	in	r26, 0x3d	; 61
    9e86:	be b7       	in	r27, 0x3e	; 62
    9e88:	12 96       	adiw	r26, 0x02	; 2
    9e8a:	9c 93       	st	X, r25
    9e8c:	8e 93       	st	-X, r24
    9e8e:	11 97       	sbiw	r26, 0x01	; 1
    9e90:	ce 01       	movw	r24, r28
    9e92:	01 96       	adiw	r24, 0x01	; 1
    9e94:	93 83       	std	Z+3, r25	; 0x03
    9e96:	82 83       	std	Z+2, r24	; 0x02
    9e98:	64 82       	std	Z+4, r6	; 0x04
    9e9a:	75 82       	std	Z+5, r7	; 0x05
    9e9c:	86 82       	std	Z+6, r8	; 0x06
    9e9e:	97 82       	std	Z+7, r9	; 0x07
    9ea0:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9ea4:	ed b7       	in	r30, 0x3d	; 61
    9ea6:	fe b7       	in	r31, 0x3e	; 62
    9ea8:	38 96       	adiw	r30, 0x08	; 8
    9eaa:	0f b6       	in	r0, 0x3f	; 63
    9eac:	f8 94       	cli
    9eae:	fe bf       	out	0x3e, r31	; 62
    9eb0:	0f be       	out	0x3f, r0	; 63
    9eb2:	ed bf       	out	0x3d, r30	; 61
	}
}
    9eb4:	2b 96       	adiw	r28, 0x0b	; 11
    9eb6:	0f b6       	in	r0, 0x3f	; 63
    9eb8:	f8 94       	cli
    9eba:	de bf       	out	0x3e, r29	; 62
    9ebc:	0f be       	out	0x3f, r0	; 63
    9ebe:	cd bf       	out	0x3d, r28	; 61
    9ec0:	cf 91       	pop	r28
    9ec2:	df 91       	pop	r29
    9ec4:	1f 91       	pop	r17
    9ec6:	0f 91       	pop	r16
    9ec8:	ff 90       	pop	r15
    9eca:	ef 90       	pop	r14
    9ecc:	df 90       	pop	r13
    9ece:	cf 90       	pop	r12
    9ed0:	bf 90       	pop	r11
    9ed2:	af 90       	pop	r10
    9ed4:	9f 90       	pop	r9
    9ed6:	8f 90       	pop	r8
    9ed8:	7f 90       	pop	r7
    9eda:	6f 90       	pop	r6
    9edc:	08 95       	ret

00009ede <Put_zVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    9ede:	0f 93       	push	r16
    9ee0:	1f 93       	push	r17
    9ee2:	df 93       	push	r29
    9ee4:	cf 93       	push	r28
    9ee6:	cd b7       	in	r28, 0x3d	; 61
    9ee8:	de b7       	in	r29, 0x3e	; 62
    9eea:	2a 97       	sbiw	r28, 0x0a	; 10
    9eec:	0f b6       	in	r0, 0x3f	; 63
    9eee:	f8 94       	cli
    9ef0:	de bf       	out	0x3e, r29	; 62
    9ef2:	0f be       	out	0x3f, r0	; 63
    9ef4:	cd bf       	out	0x3d, r28	; 61
    9ef6:	8c 01       	movw	r16, r24
    9ef8:	da 01       	movw	r26, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9efa:	67 37       	cpi	r22, 0x77	; 119
    9efc:	19 f0       	breq	.+6      	; 0x9f04 <Put_zVal+0x26>
    9efe:	8f ef       	ldi	r24, 0xFF	; 255
    9f00:	90 e0       	ldi	r25, 0x00	; 0
    9f02:	02 c0       	rjmp	.+4      	; 0x9f08 <Put_zVal+0x2a>
    9f04:	8f ef       	ldi	r24, 0xFF	; 255
    9f06:	9f ef       	ldi	r25, 0xFF	; 255
	if(Param->Txt && Idx<2) {
    9f08:	14 96       	adiw	r26, 0x04	; 4
    9f0a:	2d 91       	ld	r18, X+
    9f0c:	3c 91       	ld	r19, X
    9f0e:	15 97       	sbiw	r26, 0x05	; 5
    9f10:	21 15       	cp	r18, r1
    9f12:	31 05       	cpc	r19, r1
    9f14:	89 f0       	breq	.+34     	; 0x9f38 <Put_zVal+0x5a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    9f16:	80 1b       	sub	r24, r16
    9f18:	91 0b       	sbc	r25, r17
	if(Param->Txt && Idx<2) {
    9f1a:	82 30       	cpi	r24, 0x02	; 2
    9f1c:	91 05       	cpc	r25, r1
    9f1e:	60 f4       	brcc	.+24     	; 0x9f38 <Put_zVal+0x5a>
		Param->Txt += Idx;
    9f20:	88 0f       	add	r24, r24
    9f22:	99 1f       	adc	r25, r25
    9f24:	28 0f       	add	r18, r24
    9f26:	39 1f       	adc	r19, r25
    9f28:	15 96       	adiw	r26, 0x05	; 5
    9f2a:	3c 93       	st	X, r19
    9f2c:	2e 93       	st	-X, r18
    9f2e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    9f30:	cd 01       	movw	r24, r26
    9f32:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    9f36:	79 c0       	rjmp	.+242    	; 0xa02a <Put_zVal+0x14c>
		return;
	}
	char Format[] = "%0 u.%. u";
    9f38:	9e 01       	movw	r18, r28
    9f3a:	2f 5f       	subi	r18, 0xFF	; 255
    9f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    9f3e:	49 e6       	ldi	r20, 0x69	; 105
    9f40:	51 e0       	ldi	r21, 0x01	; 1
    9f42:	8a e0       	ldi	r24, 0x0A	; 10
    9f44:	fa 01       	movw	r30, r20
    9f46:	01 90       	ld	r0, Z+
    9f48:	af 01       	movw	r20, r30
    9f4a:	f9 01       	movw	r30, r18
    9f4c:	01 92       	st	Z+, r0
    9f4e:	9f 01       	movw	r18, r30
    9f50:	81 50       	subi	r24, 0x01	; 1
    9f52:	c1 f7       	brne	.-16     	; 0x9f44 <Put_zVal+0x66>
	Format[2] = '0'+Param->Size;
    9f54:	13 96       	adiw	r26, 0x03	; 3
    9f56:	2c 91       	ld	r18, X
    9f58:	13 97       	sbiw	r26, 0x03	; 3
    9f5a:	20 5d       	subi	r18, 0xD0	; 208
    9f5c:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    9f5e:	12 96       	adiw	r26, 0x02	; 2
    9f60:	9c 91       	ld	r25, X
    9f62:	12 97       	sbiw	r26, 0x02	; 2
    9f64:	99 23       	and	r25, r25
    9f66:	09 f4       	brne	.+2      	; 0x9f6a <Put_zVal+0x8c>
    9f68:	41 c0       	rjmp	.+130    	; 0x9fec <Put_zVal+0x10e>
		Format[2] -= Param->Prec+1;
    9f6a:	89 2f       	mov	r24, r25
    9f6c:	80 95       	com	r24
    9f6e:	82 0f       	add	r24, r18
    9f70:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    9f72:	90 5d       	subi	r25, 0xD0	; 208
    9f74:	98 87       	std	Y+8, r25	; 0x08
    9f76:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    9f78:	49 2f       	mov	r20, r25
    9f7a:	21 e0       	ldi	r18, 0x01	; 1
    9f7c:	30 e0       	ldi	r19, 0x00	; 0
    9f7e:	0b c0       	rjmp	.+22     	; 0x9f96 <Put_zVal+0xb8>
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
		Pow *= 10;
    9f80:	c9 01       	movw	r24, r18
    9f82:	88 0f       	add	r24, r24
    9f84:	99 1f       	adc	r25, r25
    9f86:	73 e0       	ldi	r23, 0x03	; 3
    9f88:	22 0f       	add	r18, r18
    9f8a:	33 1f       	adc	r19, r19
    9f8c:	7a 95       	dec	r23
    9f8e:	e1 f7       	brne	.-8      	; 0x9f88 <Put_zVal+0xaa>
    9f90:	28 0f       	add	r18, r24
    9f92:	39 1f       	adc	r19, r25
    9f94:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    9f96:	44 23       	and	r20, r20
    9f98:	99 f7       	brne	.-26     	; 0x9f80 <Put_zVal+0xa2>
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    9f9a:	8d b7       	in	r24, 0x3d	; 61
    9f9c:	9e b7       	in	r25, 0x3e	; 62
    9f9e:	08 97       	sbiw	r24, 0x08	; 8
    9fa0:	0f b6       	in	r0, 0x3f	; 63
    9fa2:	f8 94       	cli
    9fa4:	9e bf       	out	0x3e, r25	; 62
    9fa6:	0f be       	out	0x3f, r0	; 63
    9fa8:	8d bf       	out	0x3d, r24	; 61
    9faa:	ed b7       	in	r30, 0x3d	; 61
    9fac:	fe b7       	in	r31, 0x3e	; 62
    9fae:	31 96       	adiw	r30, 0x01	; 1
    9fb0:	8d 91       	ld	r24, X+
    9fb2:	9c 91       	ld	r25, X
    9fb4:	ad b7       	in	r26, 0x3d	; 61
    9fb6:	be b7       	in	r27, 0x3e	; 62
    9fb8:	12 96       	adiw	r26, 0x02	; 2
    9fba:	9c 93       	st	X, r25
    9fbc:	8e 93       	st	-X, r24
    9fbe:	11 97       	sbiw	r26, 0x01	; 1
    9fc0:	ce 01       	movw	r24, r28
    9fc2:	01 96       	adiw	r24, 0x01	; 1
    9fc4:	93 83       	std	Z+3, r25	; 0x03
    9fc6:	82 83       	std	Z+2, r24	; 0x02
    9fc8:	c8 01       	movw	r24, r16
    9fca:	b9 01       	movw	r22, r18
    9fcc:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    9fd0:	75 83       	std	Z+5, r23	; 0x05
    9fd2:	64 83       	std	Z+4, r22	; 0x04
    9fd4:	c8 01       	movw	r24, r16
    9fd6:	b9 01       	movw	r22, r18
    9fd8:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    9fdc:	97 83       	std	Z+7, r25	; 0x07
    9fde:	86 83       	std	Z+6, r24	; 0x06
    9fe0:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    9fe4:	ed b7       	in	r30, 0x3d	; 61
    9fe6:	fe b7       	in	r31, 0x3e	; 62
    9fe8:	38 96       	adiw	r30, 0x08	; 8
    9fea:	1a c0       	rjmp	.+52     	; 0xa020 <Put_zVal+0x142>
	}
	else {
		Format[4] = '\0';
    9fec:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    9fee:	00 d0       	rcall	.+0      	; 0x9ff0 <Put_zVal+0x112>
    9ff0:	00 d0       	rcall	.+0      	; 0x9ff2 <Put_zVal+0x114>
    9ff2:	00 d0       	rcall	.+0      	; 0x9ff4 <Put_zVal+0x116>
    9ff4:	ed b7       	in	r30, 0x3d	; 61
    9ff6:	fe b7       	in	r31, 0x3e	; 62
    9ff8:	31 96       	adiw	r30, 0x01	; 1
    9ffa:	8d 91       	ld	r24, X+
    9ffc:	9c 91       	ld	r25, X
    9ffe:	ad b7       	in	r26, 0x3d	; 61
    a000:	be b7       	in	r27, 0x3e	; 62
    a002:	12 96       	adiw	r26, 0x02	; 2
    a004:	9c 93       	st	X, r25
    a006:	8e 93       	st	-X, r24
    a008:	11 97       	sbiw	r26, 0x01	; 1
    a00a:	ce 01       	movw	r24, r28
    a00c:	01 96       	adiw	r24, 0x01	; 1
    a00e:	93 83       	std	Z+3, r25	; 0x03
    a010:	82 83       	std	Z+2, r24	; 0x02
    a012:	15 83       	std	Z+5, r17	; 0x05
    a014:	04 83       	std	Z+4, r16	; 0x04
    a016:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    a01a:	ed b7       	in	r30, 0x3d	; 61
    a01c:	fe b7       	in	r31, 0x3e	; 62
    a01e:	36 96       	adiw	r30, 0x06	; 6
    a020:	0f b6       	in	r0, 0x3f	; 63
    a022:	f8 94       	cli
    a024:	fe bf       	out	0x3e, r31	; 62
    a026:	0f be       	out	0x3f, r0	; 63
    a028:	ed bf       	out	0x3d, r30	; 61
	}
}
    a02a:	2a 96       	adiw	r28, 0x0a	; 10
    a02c:	0f b6       	in	r0, 0x3f	; 63
    a02e:	f8 94       	cli
    a030:	de bf       	out	0x3e, r29	; 62
    a032:	0f be       	out	0x3f, r0	; 63
    a034:	cd bf       	out	0x3d, r28	; 61
    a036:	cf 91       	pop	r28
    a038:	df 91       	pop	r29
    a03a:	1f 91       	pop	r17
    a03c:	0f 91       	pop	r16
    a03e:	08 95       	ret

0000a040 <Put_sVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    a040:	ef 92       	push	r14
    a042:	ff 92       	push	r15
    a044:	0f 93       	push	r16
    a046:	1f 93       	push	r17
    a048:	df 93       	push	r29
    a04a:	cf 93       	push	r28
    a04c:	cd b7       	in	r28, 0x3d	; 61
    a04e:	de b7       	in	r29, 0x3e	; 62
    a050:	2a 97       	sbiw	r28, 0x0a	; 10
    a052:	0f b6       	in	r0, 0x3f	; 63
    a054:	f8 94       	cli
    a056:	de bf       	out	0x3e, r29	; 62
    a058:	0f be       	out	0x3f, r0	; 63
    a05a:	cd bf       	out	0x3d, r28	; 61
    a05c:	7c 01       	movw	r14, r24
    a05e:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    a060:	67 37       	cpi	r22, 0x77	; 119
    a062:	19 f0       	breq	.+6      	; 0xa06a <Put_sVal+0x2a>
    a064:	80 e8       	ldi	r24, 0x80	; 128
    a066:	90 e0       	ldi	r25, 0x00	; 0
    a068:	02 c0       	rjmp	.+4      	; 0xa06e <Put_sVal+0x2e>
    a06a:	80 e0       	ldi	r24, 0x00	; 0
    a06c:	90 e8       	ldi	r25, 0x80	; 128
	if(Param->Txt && Idx<2) {
    a06e:	d8 01       	movw	r26, r16
    a070:	14 96       	adiw	r26, 0x04	; 4
    a072:	2d 91       	ld	r18, X+
    a074:	3c 91       	ld	r19, X
    a076:	15 97       	sbiw	r26, 0x05	; 5
    a078:	21 15       	cp	r18, r1
    a07a:	31 05       	cpc	r19, r1
    a07c:	89 f0       	breq	.+34     	; 0xa0a0 <Put_sVal+0x60>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    a07e:	8e 0d       	add	r24, r14
    a080:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    a082:	82 30       	cpi	r24, 0x02	; 2
    a084:	91 05       	cpc	r25, r1
    a086:	60 f4       	brcc	.+24     	; 0xa0a0 <Put_sVal+0x60>
		Param->Txt += Idx;
    a088:	88 0f       	add	r24, r24
    a08a:	99 1f       	adc	r25, r25
    a08c:	28 0f       	add	r18, r24
    a08e:	39 1f       	adc	r19, r25
    a090:	15 96       	adiw	r26, 0x05	; 5
    a092:	3c 93       	st	X, r19
    a094:	2e 93       	st	-X, r18
    a096:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    a098:	c8 01       	movw	r24, r16
    a09a:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    a09e:	92 c0       	rjmp	.+292    	; 0xa1c4 <Put_sVal+0x184>
		return;
	}
	char Format[] = "%+ d.%. u";
    a0a0:	de 01       	movw	r26, r28
    a0a2:	11 96       	adiw	r26, 0x01	; 1
    a0a4:	e3 e7       	ldi	r30, 0x73	; 115
    a0a6:	f1 e0       	ldi	r31, 0x01	; 1
    a0a8:	8a e0       	ldi	r24, 0x0A	; 10
    a0aa:	01 90       	ld	r0, Z+
    a0ac:	0d 92       	st	X+, r0
    a0ae:	81 50       	subi	r24, 0x01	; 1
    a0b0:	e1 f7       	brne	.-8      	; 0xa0aa <Put_sVal+0x6a>
	if(Val==0)
    a0b2:	e1 14       	cp	r14, r1
    a0b4:	f1 04       	cpc	r15, r1
    a0b6:	11 f4       	brne	.+4      	; 0xa0bc <Put_sVal+0x7c>
		Format[1] = ' ';
    a0b8:	80 e2       	ldi	r24, 0x20	; 32
    a0ba:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    a0bc:	f8 01       	movw	r30, r16
    a0be:	23 81       	ldd	r18, Z+3	; 0x03
    a0c0:	20 5d       	subi	r18, 0xD0	; 208
    a0c2:	2b 83       	std	Y+3, r18	; 0x03
	if(Param->Prec) {
    a0c4:	92 81       	ldd	r25, Z+2	; 0x02
    a0c6:	99 23       	and	r25, r25
    a0c8:	09 f4       	brne	.+2      	; 0xa0cc <Put_sVal+0x8c>
    a0ca:	5c c0       	rjmp	.+184    	; 0xa184 <Put_sVal+0x144>
		Format[2] -= Param->Prec+1;
    a0cc:	89 2f       	mov	r24, r25
    a0ce:	80 95       	com	r24
    a0d0:	82 0f       	add	r24, r18
    a0d2:	8b 83       	std	Y+3, r24	; 0x03
		Format[7] = '0'+Param->Prec;
    a0d4:	90 5d       	subi	r25, 0xD0	; 208
    a0d6:	98 87       	std	Y+8, r25	; 0x08
    a0d8:	90 53       	subi	r25, 0x30	; 48
		int16_t Div=Pow10(Param->Prec);
    a0da:	49 2f       	mov	r20, r25
    a0dc:	21 e0       	ldi	r18, 0x01	; 1
    a0de:	30 e0       	ldi	r19, 0x00	; 0
    a0e0:	0b c0       	rjmp	.+22     	; 0xa0f8 <Put_sVal+0xb8>
		Pow *= 10;
    a0e2:	c9 01       	movw	r24, r18
    a0e4:	88 0f       	add	r24, r24
    a0e6:	99 1f       	adc	r25, r25
    a0e8:	a3 e0       	ldi	r26, 0x03	; 3
    a0ea:	22 0f       	add	r18, r18
    a0ec:	33 1f       	adc	r19, r19
    a0ee:	aa 95       	dec	r26
    a0f0:	e1 f7       	brne	.-8      	; 0xa0ea <Put_sVal+0xaa>
    a0f2:	28 0f       	add	r18, r24
    a0f4:	39 1f       	adc	r19, r25
    a0f6:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a0f8:	44 23       	and	r20, r20
    a0fa:	99 f7       	brne	.-26     	; 0xa0e2 <Put_sVal+0xa2>
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    a0fc:	8d b7       	in	r24, 0x3d	; 61
    a0fe:	9e b7       	in	r25, 0x3e	; 62
    a100:	08 97       	sbiw	r24, 0x08	; 8
    a102:	0f b6       	in	r0, 0x3f	; 63
    a104:	f8 94       	cli
    a106:	9e bf       	out	0x3e, r25	; 62
    a108:	0f be       	out	0x3f, r0	; 63
    a10a:	8d bf       	out	0x3d, r24	; 61
    a10c:	ed b7       	in	r30, 0x3d	; 61
    a10e:	fe b7       	in	r31, 0x3e	; 62
    a110:	31 96       	adiw	r30, 0x01	; 1
    a112:	d8 01       	movw	r26, r16
    a114:	8d 91       	ld	r24, X+
    a116:	9c 91       	ld	r25, X
    a118:	ad b7       	in	r26, 0x3d	; 61
    a11a:	be b7       	in	r27, 0x3e	; 62
    a11c:	12 96       	adiw	r26, 0x02	; 2
    a11e:	9c 93       	st	X, r25
    a120:	8e 93       	st	-X, r24
    a122:	11 97       	sbiw	r26, 0x01	; 1
    a124:	ce 01       	movw	r24, r28
    a126:	01 96       	adiw	r24, 0x01	; 1
    a128:	93 83       	std	Z+3, r25	; 0x03
    a12a:	82 83       	std	Z+2, r24	; 0x02
    a12c:	c7 01       	movw	r24, r14
    a12e:	b9 01       	movw	r22, r18
    a130:	0e 94 2a 91 	call	0x12254	; 0x12254 <__divmodhi4>
    a134:	75 83       	std	Z+5, r23	; 0x05
    a136:	64 83       	std	Z+4, r22	; 0x04
    a138:	c7 01       	movw	r24, r14
    a13a:	f7 fe       	sbrs	r15, 7
    a13c:	04 c0       	rjmp	.+8      	; 0xa146 <Put_sVal+0x106>
    a13e:	88 27       	eor	r24, r24
    a140:	99 27       	eor	r25, r25
    a142:	8e 19       	sub	r24, r14
    a144:	9f 09       	sbc	r25, r15
    a146:	b9 01       	movw	r22, r18
    a148:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    a14c:	97 83       	std	Z+7, r25	; 0x07
    a14e:	86 83       	std	Z+6, r24	; 0x06
    a150:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
		if(Val<0) {
    a154:	ed b7       	in	r30, 0x3d	; 61
    a156:	fe b7       	in	r31, 0x3e	; 62
    a158:	38 96       	adiw	r30, 0x08	; 8
    a15a:	0f b6       	in	r0, 0x3f	; 63
    a15c:	f8 94       	cli
    a15e:	fe bf       	out	0x3e, r31	; 62
    a160:	0f be       	out	0x3f, r0	; 63
    a162:	ed bf       	out	0x3d, r30	; 61
    a164:	f7 fe       	sbrs	r15, 7
    a166:	2e c0       	rjmp	.+92     	; 0xa1c4 <Put_sVal+0x184>
    a168:	04 c0       	rjmp	.+8      	; 0xa172 <Put_sVal+0x132>
			while(*Param->Pos==' ')
				Param->Pos++;
    a16a:	31 96       	adiw	r30, 0x01	; 1
    a16c:	d8 01       	movw	r26, r16
    a16e:	ed 93       	st	X+, r30
    a170:	fc 93       	st	X, r31
		Format[2] -= Param->Prec+1;
		Format[7] = '0'+Param->Prec;
		int16_t Div=Pow10(Param->Prec);
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
		if(Val<0) {
			while(*Param->Pos==' ')
    a172:	d8 01       	movw	r26, r16
    a174:	ed 91       	ld	r30, X+
    a176:	fc 91       	ld	r31, X
    a178:	80 81       	ld	r24, Z
    a17a:	80 32       	cpi	r24, 0x20	; 32
    a17c:	b1 f3       	breq	.-20     	; 0xa16a <Put_sVal+0x12a>
				Param->Pos++;
			*Param->Pos = '-';
    a17e:	8d e2       	ldi	r24, 0x2D	; 45
    a180:	80 83       	st	Z, r24
    a182:	20 c0       	rjmp	.+64     	; 0xa1c4 <Put_sVal+0x184>
		}
	}
	else {
		Format[4] = '\0';
    a184:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    a186:	00 d0       	rcall	.+0      	; 0xa188 <Put_sVal+0x148>
    a188:	00 d0       	rcall	.+0      	; 0xa18a <Put_sVal+0x14a>
    a18a:	00 d0       	rcall	.+0      	; 0xa18c <Put_sVal+0x14c>
    a18c:	ed b7       	in	r30, 0x3d	; 61
    a18e:	fe b7       	in	r31, 0x3e	; 62
    a190:	31 96       	adiw	r30, 0x01	; 1
    a192:	d8 01       	movw	r26, r16
    a194:	8d 91       	ld	r24, X+
    a196:	9c 91       	ld	r25, X
    a198:	ad b7       	in	r26, 0x3d	; 61
    a19a:	be b7       	in	r27, 0x3e	; 62
    a19c:	12 96       	adiw	r26, 0x02	; 2
    a19e:	9c 93       	st	X, r25
    a1a0:	8e 93       	st	-X, r24
    a1a2:	11 97       	sbiw	r26, 0x01	; 1
    a1a4:	ce 01       	movw	r24, r28
    a1a6:	01 96       	adiw	r24, 0x01	; 1
    a1a8:	93 83       	std	Z+3, r25	; 0x03
    a1aa:	82 83       	std	Z+2, r24	; 0x02
    a1ac:	f5 82       	std	Z+5, r15	; 0x05
    a1ae:	e4 82       	std	Z+4, r14	; 0x04
    a1b0:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    a1b4:	ed b7       	in	r30, 0x3d	; 61
    a1b6:	fe b7       	in	r31, 0x3e	; 62
    a1b8:	36 96       	adiw	r30, 0x06	; 6
    a1ba:	0f b6       	in	r0, 0x3f	; 63
    a1bc:	f8 94       	cli
    a1be:	fe bf       	out	0x3e, r31	; 62
    a1c0:	0f be       	out	0x3f, r0	; 63
    a1c2:	ed bf       	out	0x3d, r30	; 61
	}
}
    a1c4:	2a 96       	adiw	r28, 0x0a	; 10
    a1c6:	0f b6       	in	r0, 0x3f	; 63
    a1c8:	f8 94       	cli
    a1ca:	de bf       	out	0x3e, r29	; 62
    a1cc:	0f be       	out	0x3f, r0	; 63
    a1ce:	cd bf       	out	0x3d, r28	; 61
    a1d0:	cf 91       	pop	r28
    a1d2:	df 91       	pop	r29
    a1d4:	1f 91       	pop	r17
    a1d6:	0f 91       	pop	r16
    a1d8:	ff 90       	pop	r15
    a1da:	ef 90       	pop	r14
    a1dc:	08 95       	ret

0000a1de <PutVal>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    a1de:	0f 93       	push	r16
    a1e0:	1f 93       	push	r17
    a1e2:	df 93       	push	r29
    a1e4:	cf 93       	push	r28
    a1e6:	cd b7       	in	r28, 0x3d	; 61
    a1e8:	de b7       	in	r29, 0x3e	; 62
    a1ea:	29 97       	sbiw	r28, 0x09	; 9
    a1ec:	0f b6       	in	r0, 0x3f	; 63
    a1ee:	f8 94       	cli
    a1f0:	de bf       	out	0x3e, r29	; 62
    a1f2:	0f be       	out	0x3f, r0	; 63
    a1f4:	cd bf       	out	0x3d, r28	; 61
    a1f6:	8c 01       	movw	r16, r24
    a1f8:	da 01       	movw	r26, r20
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a1fa:	67 37       	cpi	r22, 0x77	; 119
    a1fc:	19 f0       	breq	.+6      	; 0xa204 <PutVal+0x26>
    a1fe:	8f ef       	ldi	r24, 0xFF	; 255
    a200:	90 e0       	ldi	r25, 0x00	; 0
    a202:	02 c0       	rjmp	.+4      	; 0xa208 <PutVal+0x2a>
    a204:	8f ef       	ldi	r24, 0xFF	; 255
    a206:	9f ef       	ldi	r25, 0xFF	; 255
	if(Param->Txt && Idx<2) {
    a208:	14 96       	adiw	r26, 0x04	; 4
    a20a:	2d 91       	ld	r18, X+
    a20c:	3c 91       	ld	r19, X
    a20e:	15 97       	sbiw	r26, 0x05	; 5
    a210:	21 15       	cp	r18, r1
    a212:	31 05       	cpc	r19, r1
    a214:	89 f0       	breq	.+34     	; 0xa238 <PutVal+0x5a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    a216:	80 1b       	sub	r24, r16
    a218:	91 0b       	sbc	r25, r17
	if(Param->Txt && Idx<2) {
    a21a:	82 30       	cpi	r24, 0x02	; 2
    a21c:	91 05       	cpc	r25, r1
    a21e:	60 f4       	brcc	.+24     	; 0xa238 <PutVal+0x5a>
		Param->Txt += Idx;
    a220:	88 0f       	add	r24, r24
    a222:	99 1f       	adc	r25, r25
    a224:	28 0f       	add	r18, r24
    a226:	39 1f       	adc	r19, r25
    a228:	15 96       	adiw	r26, 0x05	; 5
    a22a:	3c 93       	st	X, r19
    a22c:	2e 93       	st	-X, r18
    a22e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    a230:	cd 01       	movw	r24, r26
    a232:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    a236:	79 c0       	rjmp	.+242    	; 0xa32a <PutVal+0x14c>
		return;
	}
	char Format[] = "% u.%. u";
    a238:	9e 01       	movw	r18, r28
    a23a:	2f 5f       	subi	r18, 0xFF	; 255
    a23c:	3f 4f       	sbci	r19, 0xFF	; 255
    a23e:	4d e7       	ldi	r20, 0x7D	; 125
    a240:	51 e0       	ldi	r21, 0x01	; 1
    a242:	89 e0       	ldi	r24, 0x09	; 9
    a244:	fa 01       	movw	r30, r20
    a246:	01 90       	ld	r0, Z+
    a248:	af 01       	movw	r20, r30
    a24a:	f9 01       	movw	r30, r18
    a24c:	01 92       	st	Z+, r0
    a24e:	9f 01       	movw	r18, r30
    a250:	81 50       	subi	r24, 0x01	; 1
    a252:	c1 f7       	brne	.-16     	; 0xa244 <PutVal+0x66>
	Format[1] = '0'+Param->Size;
    a254:	13 96       	adiw	r26, 0x03	; 3
    a256:	2c 91       	ld	r18, X
    a258:	13 97       	sbiw	r26, 0x03	; 3
    a25a:	20 5d       	subi	r18, 0xD0	; 208
    a25c:	2a 83       	std	Y+2, r18	; 0x02
	if(Param->Prec) {
    a25e:	12 96       	adiw	r26, 0x02	; 2
    a260:	9c 91       	ld	r25, X
    a262:	12 97       	sbiw	r26, 0x02	; 2
    a264:	99 23       	and	r25, r25
    a266:	09 f4       	brne	.+2      	; 0xa26a <PutVal+0x8c>
    a268:	41 c0       	rjmp	.+130    	; 0xa2ec <PutVal+0x10e>
		Format[1] -= Param->Prec+1;
    a26a:	89 2f       	mov	r24, r25
    a26c:	80 95       	com	r24
    a26e:	82 0f       	add	r24, r18
    a270:	8a 83       	std	Y+2, r24	; 0x02
		Format[6] = '0'+Param->Prec;
    a272:	90 5d       	subi	r25, 0xD0	; 208
    a274:	9f 83       	std	Y+7, r25	; 0x07
    a276:	90 53       	subi	r25, 0x30	; 48
		uint16_t Div=Pow10(Param->Prec);
    a278:	49 2f       	mov	r20, r25
    a27a:	21 e0       	ldi	r18, 0x01	; 1
    a27c:	30 e0       	ldi	r19, 0x00	; 0
    a27e:	0b c0       	rjmp	.+22     	; 0xa296 <PutVal+0xb8>
		Pow *= 10;
    a280:	c9 01       	movw	r24, r18
    a282:	88 0f       	add	r24, r24
    a284:	99 1f       	adc	r25, r25
    a286:	53 e0       	ldi	r21, 0x03	; 3
    a288:	22 0f       	add	r18, r18
    a28a:	33 1f       	adc	r19, r19
    a28c:	5a 95       	dec	r21
    a28e:	e1 f7       	brne	.-8      	; 0xa288 <PutVal+0xaa>
    a290:	28 0f       	add	r18, r24
    a292:	39 1f       	adc	r19, r25
    a294:	41 50       	subi	r20, 0x01	; 1
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    a296:	44 23       	and	r20, r20
    a298:	99 f7       	brne	.-26     	; 0xa280 <PutVal+0xa2>
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    a29a:	8d b7       	in	r24, 0x3d	; 61
    a29c:	9e b7       	in	r25, 0x3e	; 62
    a29e:	08 97       	sbiw	r24, 0x08	; 8
    a2a0:	0f b6       	in	r0, 0x3f	; 63
    a2a2:	f8 94       	cli
    a2a4:	9e bf       	out	0x3e, r25	; 62
    a2a6:	0f be       	out	0x3f, r0	; 63
    a2a8:	8d bf       	out	0x3d, r24	; 61
    a2aa:	ed b7       	in	r30, 0x3d	; 61
    a2ac:	fe b7       	in	r31, 0x3e	; 62
    a2ae:	31 96       	adiw	r30, 0x01	; 1
    a2b0:	8d 91       	ld	r24, X+
    a2b2:	9c 91       	ld	r25, X
    a2b4:	ad b7       	in	r26, 0x3d	; 61
    a2b6:	be b7       	in	r27, 0x3e	; 62
    a2b8:	12 96       	adiw	r26, 0x02	; 2
    a2ba:	9c 93       	st	X, r25
    a2bc:	8e 93       	st	-X, r24
    a2be:	11 97       	sbiw	r26, 0x01	; 1
    a2c0:	ce 01       	movw	r24, r28
    a2c2:	01 96       	adiw	r24, 0x01	; 1
    a2c4:	93 83       	std	Z+3, r25	; 0x03
    a2c6:	82 83       	std	Z+2, r24	; 0x02
    a2c8:	c8 01       	movw	r24, r16
    a2ca:	b9 01       	movw	r22, r18
    a2cc:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    a2d0:	75 83       	std	Z+5, r23	; 0x05
    a2d2:	64 83       	std	Z+4, r22	; 0x04
    a2d4:	c8 01       	movw	r24, r16
    a2d6:	b9 01       	movw	r22, r18
    a2d8:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    a2dc:	97 83       	std	Z+7, r25	; 0x07
    a2de:	86 83       	std	Z+6, r24	; 0x06
    a2e0:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    a2e4:	ed b7       	in	r30, 0x3d	; 61
    a2e6:	fe b7       	in	r31, 0x3e	; 62
    a2e8:	38 96       	adiw	r30, 0x08	; 8
    a2ea:	1a c0       	rjmp	.+52     	; 0xa320 <PutVal+0x142>
	}
	else {
		Format[3] = '\0';
    a2ec:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    a2ee:	00 d0       	rcall	.+0      	; 0xa2f0 <PutVal+0x112>
    a2f0:	00 d0       	rcall	.+0      	; 0xa2f2 <PutVal+0x114>
    a2f2:	00 d0       	rcall	.+0      	; 0xa2f4 <PutVal+0x116>
    a2f4:	ed b7       	in	r30, 0x3d	; 61
    a2f6:	fe b7       	in	r31, 0x3e	; 62
    a2f8:	31 96       	adiw	r30, 0x01	; 1
    a2fa:	8d 91       	ld	r24, X+
    a2fc:	9c 91       	ld	r25, X
    a2fe:	ad b7       	in	r26, 0x3d	; 61
    a300:	be b7       	in	r27, 0x3e	; 62
    a302:	12 96       	adiw	r26, 0x02	; 2
    a304:	9c 93       	st	X, r25
    a306:	8e 93       	st	-X, r24
    a308:	11 97       	sbiw	r26, 0x01	; 1
    a30a:	ce 01       	movw	r24, r28
    a30c:	01 96       	adiw	r24, 0x01	; 1
    a30e:	93 83       	std	Z+3, r25	; 0x03
    a310:	82 83       	std	Z+2, r24	; 0x02
    a312:	15 83       	std	Z+5, r17	; 0x05
    a314:	04 83       	std	Z+4, r16	; 0x04
    a316:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
    a31a:	ed b7       	in	r30, 0x3d	; 61
    a31c:	fe b7       	in	r31, 0x3e	; 62
    a31e:	36 96       	adiw	r30, 0x06	; 6
    a320:	0f b6       	in	r0, 0x3f	; 63
    a322:	f8 94       	cli
    a324:	fe bf       	out	0x3e, r31	; 62
    a326:	0f be       	out	0x3f, r0	; 63
    a328:	ed bf       	out	0x3d, r30	; 61
	}
}
    a32a:	29 96       	adiw	r28, 0x09	; 9
    a32c:	0f b6       	in	r0, 0x3f	; 63
    a32e:	f8 94       	cli
    a330:	de bf       	out	0x3e, r29	; 62
    a332:	0f be       	out	0x3f, r0	; 63
    a334:	cd bf       	out	0x3d, r28	; 61
    a336:	cf 91       	pop	r28
    a338:	df 91       	pop	r29
    a33a:	1f 91       	pop	r17
    a33c:	0f 91       	pop	r16
    a33e:	08 95       	ret

0000a340 <GSM_SendCR>:
	
	sei();	
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    a340:	ef 92       	push	r14
    a342:	ff 92       	push	r15
    a344:	0f 93       	push	r16
    a346:	1f 93       	push	r17
    a348:	7c 01       	movw	r14, r24
	GSMTxSz = strlen_P(Str_P);
    a34a:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    a34e:	80 93 c5 08 	sts	0x08C5, r24
	sprintf_P(GSM_TxStr, Str_P);
    a352:	00 d0       	rcall	.+0      	; 0xa354 <GSM_SendCR+0x14>
    a354:	00 d0       	rcall	.+0      	; 0xa356 <GSM_SendCR+0x16>
    a356:	01 ea       	ldi	r16, 0xA1	; 161
    a358:	1b e0       	ldi	r17, 0x0B	; 11
    a35a:	ed b7       	in	r30, 0x3d	; 61
    a35c:	fe b7       	in	r31, 0x3e	; 62
    a35e:	12 83       	std	Z+2, r17	; 0x02
    a360:	01 83       	std	Z+1, r16	; 0x01
    a362:	f4 82       	std	Z+4, r15	; 0x04
    a364:	e3 82       	std	Z+3, r14	; 0x03
    a366:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    a36a:	80 91 c5 08 	lds	r24, 0x08C5
    a36e:	0f 90       	pop	r0
    a370:	0f 90       	pop	r0
    a372:	0f 90       	pop	r0
    a374:	0f 90       	pop	r0
    a376:	98 01       	movw	r18, r16
    a378:	28 0f       	add	r18, r24
    a37a:	31 1d       	adc	r19, r1
    a37c:	c9 01       	movw	r24, r18
    a37e:	66 e8       	ldi	r22, 0x86	; 134
    a380:	71 e0       	ldi	r23, 0x01	; 1
    a382:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
	GSMTxSz++;
    a386:	80 91 c5 08 	lds	r24, 0x08C5
    a38a:	8f 5f       	subi	r24, 0xFF	; 255
    a38c:	80 93 c5 08 	sts	0x08C5, r24
	GSM_SendFirstChar();
    a390:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
}
    a394:	1f 91       	pop	r17
    a396:	0f 91       	pop	r16
    a398:	ff 90       	pop	r15
    a39a:	ef 90       	pop	r14
    a39c:	08 95       	ret

0000a39e <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    a39e:	cf 93       	push	r28
    a3a0:	df 93       	push	r29
    a3a2:	9c 01       	movw	r18, r24
    a3a4:	eb 01       	movw	r28, r22
	if(GSM_Flag & (1<<flg_TxCStr)){
    a3a6:	80 91 d1 01 	lds	r24, 0x01D1
    a3aa:	80 ff       	sbrs	r24, 0
    a3ac:	08 c0       	rjmp	.+16     	; 0xa3be <GSM_Execute_Command+0x20>
		GSM_SendCR(Str_P);
    a3ae:	c9 01       	movw	r24, r18
    a3b0:	0e 94 a0 51 	call	0xa340	; 0xa340 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    a3b4:	80 91 5a 03 	lds	r24, 0x035A
    a3b8:	be 01       	movw	r22, r28
    a3ba:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	}
}
    a3be:	df 91       	pop	r29
    a3c0:	cf 91       	pop	r28
    a3c2:	08 95       	ret

0000a3c4 <GSM_Wait_Response>:
	}

}
// ~~~~~~~~~
//   GetStringFromFIFO()!
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
    a3c4:	bc 01       	movw	r22, r24
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    a3c6:	84 ef       	ldi	r24, 0xF4	; 244
    a3c8:	98 e0       	ldi	r25, 0x08	; 8
    a3ca:	0e 94 0f 88 	call	0x1101e	; 0x1101e <strcmp>
    a3ce:	9c 01       	movw	r18, r24
    a3d0:	80 e0       	ldi	r24, 0x00	; 0
    a3d2:	23 2b       	or	r18, r19
    a3d4:	09 f4       	brne	.+2      	; 0xa3d8 <GSM_Wait_Response+0x14>
    a3d6:	81 e0       	ldi	r24, 0x01	; 1
	else return 1;
}
    a3d8:	08 95       	ret

0000a3da <MemFailReset>:

// ~~~~~~~~~~~~~~~
void
MemFailReset(void)
{
	if (MemFail &(1<<MemFail_EEPROM)) {
    a3da:	80 91 e1 09 	lds	r24, 0x09E1
    a3de:	81 ff       	sbrs	r24, 1
    a3e0:	0a c0       	rjmp	.+20     	; 0xa3f6 <MemFailReset+0x1c>
		MemFail &=~(1<<MemFail_EEPROM);
    a3e2:	8d 7f       	andi	r24, 0xFD	; 253
    a3e4:	80 93 e1 09 	sts	0x09E1, r24
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    a3e8:	0e 94 b0 26 	call	0x4d60	; 0x4d60 <CRC_EEPROM_calc>
    a3ec:	bc 01       	movw	r22, r24
    a3ee:	8e e8       	ldi	r24, 0x8E	; 142
    a3f0:	91 e0       	ldi	r25, 0x01	; 1
    a3f2:	0e 94 df 8f 	call	0x11fbe	; 0x11fbe <__eewr_word_m128>
    a3f6:	08 95       	ret

0000a3f8 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    a3f8:	80 91 e1 09 	lds	r24, 0x09E1
    a3fc:	81 fd       	sbrc	r24, 1
    a3fe:	07 c0       	rjmp	.+14     	; 0xa40e <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    a400:	0e 94 b0 26 	call	0x4d60	; 0x4d60 <CRC_EEPROM_calc>
    a404:	bc 01       	movw	r22, r24
    a406:	8e e8       	ldi	r24, 0x8E	; 142
    a408:	91 e0       	ldi	r25, 0x01	; 1
    a40a:	0e 94 df 8f 	call	0x11fbe	; 0x11fbe <__eewr_word_m128>
    a40e:	08 95       	ret

0000a410 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    a410:	0e 94 df 8f 	call	0x11fbe	; 0x11fbe <__eewr_word_m128>
	CRC_EEPROM_upd();
    a414:	0e 94 fc 51 	call	0xa3f8	; 0xa3f8 <CRC_EEPROM_upd>
	//IntOn();
}
    a418:	08 95       	ret

0000a41a <MB_M_Period_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Period_Set(uint8_t MB_N)
{
	eww(&MB_M_Param_EE[MB_N].Period, MB_M_Period[MB_N]);
    a41a:	e8 2f       	mov	r30, r24
    a41c:	f0 e0       	ldi	r31, 0x00	; 0
    a41e:	cf 01       	movw	r24, r30
    a420:	88 0f       	add	r24, r24
    a422:	99 1f       	adc	r25, r25
    a424:	88 0f       	add	r24, r24
    a426:	99 1f       	adc	r25, r25
    a428:	8e 0f       	add	r24, r30
    a42a:	9f 1f       	adc	r25, r31
    a42c:	ee 0f       	add	r30, r30
    a42e:	ff 1f       	adc	r31, r31
    a430:	e3 56       	subi	r30, 0x63	; 99
    a432:	fa 4f       	sbci	r31, 0xFA	; 250
    a434:	60 81       	ld	r22, Z
    a436:	71 81       	ldd	r23, Z+1	; 0x01
    a438:	8a 57       	subi	r24, 0x7A	; 122
    a43a:	9e 4f       	sbci	r25, 0xFE	; 254
    a43c:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
}
    a440:	08 95       	ret

0000a442 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    a442:	0e 94 ca 8f 	call	0x11f94	; 0x11f94 <__eewr_byte_m128>
	CRC_EEPROM_upd();
    a446:	0e 94 fc 51 	call	0xa3f8	; 0xa3f8 <CRC_EEPROM_upd>
	//IntOn();
}
    a44a:	08 95       	ret

0000a44c <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    a44c:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    a44e:	8f ef       	ldi	r24, 0xFF	; 255
    a450:	9f e0       	ldi	r25, 0x0F	; 15
    a452:	6f ef       	ldi	r22, 0xFF	; 255
    a454:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
    a458:	ff cf       	rjmp	.-2      	; 0xa458 <Start_Bootloader+0xc>

0000a45a <GPRS_CriticalCMD_Process>:
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
}

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    a45a:	80 91 66 03 	lds	r24, 0x0366
    a45e:	88 23       	and	r24, r24
    a460:	09 f1       	breq	.+66     	; 0xa4a4 <GPRS_CriticalCMD_Process+0x4a>
    a462:	80 91 76 0a 	lds	r24, 0x0A76
    a466:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    a46a:	88 23       	and	r24, r24
    a46c:	d9 f0       	breq	.+54     	; 0xa4a4 <GPRS_CriticalCMD_Process+0x4a>
		switch(GPRS_CriticalCMD){
    a46e:	80 91 66 03 	lds	r24, 0x0366
    a472:	82 30       	cpi	r24, 0x02	; 2
    a474:	61 f0       	breq	.+24     	; 0xa48e <GPRS_CriticalCMD_Process+0x34>
    a476:	83 30       	cpi	r24, 0x03	; 3
    a478:	18 f4       	brcc	.+6      	; 0xa480 <GPRS_CriticalCMD_Process+0x26>
    a47a:	81 30       	cpi	r24, 0x01	; 1
    a47c:	89 f4       	brne	.+34     	; 0xa4a0 <GPRS_CriticalCMD_Process+0x46>
    a47e:	05 c0       	rjmp	.+10     	; 0xa48a <GPRS_CriticalCMD_Process+0x30>
    a480:	83 30       	cpi	r24, 0x03	; 3
    a482:	49 f0       	breq	.+18     	; 0xa496 <GPRS_CriticalCMD_Process+0x3c>
    a484:	84 30       	cpi	r24, 0x04	; 4
    a486:	61 f4       	brne	.+24     	; 0xa4a0 <GPRS_CriticalCMD_Process+0x46>
    a488:	09 c0       	rjmp	.+18     	; 0xa49c <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    a48a:	f8 94       	cli
    a48c:	ff cf       	rjmp	.-2      	; 0xa48c <GPRS_CriticalCMD_Process+0x32>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    a48e:	8b e4       	ldi	r24, 0x4B	; 75
    a490:	80 93 a4 05 	sts	0x05A4, r24
    a494:	05 c0       	rjmp	.+10     	; 0xa4a0 <GPRS_CriticalCMD_Process+0x46>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    a496:	0e 94 26 52 	call	0xa44c	; 0xa44c <Start_Bootloader>
    a49a:	02 c0       	rjmp	.+4      	; 0xa4a0 <GPRS_CriticalCMD_Process+0x46>
			case GPRS_UPDATER:		Start_Updater(); break;
    a49c:	0e 94 dd 3d 	call	0x7bba	; 0x7bba <Start_Updater>
		}
		GPRS_CriticalCMD = 0;
    a4a0:	10 92 66 03 	sts	0x0366, r1
    a4a4:	08 95       	ret

0000a4a6 <MB_M_TimeOff_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_TimeOff_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].TimeOff, MB_M_TimeOff[MB_N]);
    a4a6:	e8 2f       	mov	r30, r24
    a4a8:	f0 e0       	ldi	r31, 0x00	; 0
    a4aa:	cf 01       	movw	r24, r30
    a4ac:	88 0f       	add	r24, r24
    a4ae:	99 1f       	adc	r25, r25
    a4b0:	88 0f       	add	r24, r24
    a4b2:	99 1f       	adc	r25, r25
    a4b4:	8e 0f       	add	r24, r30
    a4b6:	9f 1f       	adc	r25, r31
    a4b8:	e3 59       	subi	r30, 0x93	; 147
    a4ba:	fc 4f       	sbci	r31, 0xFC	; 252
    a4bc:	86 57       	subi	r24, 0x76	; 118
    a4be:	9e 4f       	sbci	r25, 0xFE	; 254
    a4c0:	60 81       	ld	r22, Z
    a4c2:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
}
    a4c6:	08 95       	ret

0000a4c8 <MB_M_Try_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Try_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Try, MB_M_Try[MB_N]);
    a4c8:	e8 2f       	mov	r30, r24
    a4ca:	f0 e0       	ldi	r31, 0x00	; 0
    a4cc:	cf 01       	movw	r24, r30
    a4ce:	88 0f       	add	r24, r24
    a4d0:	99 1f       	adc	r25, r25
    a4d2:	88 0f       	add	r24, r24
    a4d4:	99 1f       	adc	r25, r25
    a4d6:	8e 0f       	add	r24, r30
    a4d8:	9f 1f       	adc	r25, r31
    a4da:	eb 5b       	subi	r30, 0xBB	; 187
    a4dc:	f7 4f       	sbci	r31, 0xF7	; 247
    a4de:	87 57       	subi	r24, 0x77	; 119
    a4e0:	9e 4f       	sbci	r25, 0xFE	; 254
    a4e2:	60 81       	ld	r22, Z
    a4e4:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
}
    a4e8:	08 95       	ret

0000a4ea <MB_M_Timeout_Set>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timeout_Set(uint8_t MB_N)
{
	ewb(&MB_M_Param_EE[MB_N].Timeout, MB_M_Timeout[MB_N]);
    a4ea:	e8 2f       	mov	r30, r24
    a4ec:	f0 e0       	ldi	r31, 0x00	; 0
    a4ee:	cf 01       	movw	r24, r30
    a4f0:	88 0f       	add	r24, r24
    a4f2:	99 1f       	adc	r25, r25
    a4f4:	88 0f       	add	r24, r24
    a4f6:	99 1f       	adc	r25, r25
    a4f8:	8e 0f       	add	r24, r30
    a4fa:	9f 1f       	adc	r25, r31
    a4fc:	e5 58       	subi	r30, 0x85	; 133
    a4fe:	f5 4f       	sbci	r31, 0xF5	; 245
    a500:	88 57       	subi	r24, 0x78	; 120
    a502:	9e 4f       	sbci	r25, 0xFE	; 254
    a504:	60 81       	ld	r22, Z
    a506:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
}
    a50a:	08 95       	ret

0000a50c <Set_MB_Addr>:
	static uint8_t EEMEM MB_NativeAddr_EE[Modbus_Qt] = Init_MB_NativeAddr;
	// ~~~~~~~~~~~~~~~~~~~~~~
	void
	Set_MB_Addr(uint8_t MB_N)
	{
		ewb(MB_NativeAddr_EE+MB_N, MB_NativeAddr[MB_N]);
    a50c:	e8 2f       	mov	r30, r24
    a50e:	f0 e0       	ldi	r31, 0x00	; 0
    a510:	cf 01       	movw	r24, r30
    a512:	85 57       	subi	r24, 0x75	; 117
    a514:	9e 4f       	sbci	r25, 0xFE	; 254
    a516:	e5 58       	subi	r30, 0x85	; 133
    a518:	fc 4f       	sbci	r31, 0xFC	; 252
    a51a:	60 81       	ld	r22, Z
    a51c:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
	}
    a520:	08 95       	ret

0000a522 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    a522:	81 e9       	ldi	r24, 0x91	; 145
    a524:	91 e0       	ldi	r25, 0x01	; 1
    a526:	60 91 a0 05 	lds	r22, 0x05A0
    a52a:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    a52e:	60 91 af 0d 	lds	r22, 0x0DAF
    a532:	70 91 b0 0d 	lds	r23, 0x0DB0
    a536:	82 e9       	ldi	r24, 0x92	; 146
    a538:	91 e0       	ldi	r25, 0x01	; 1
    a53a:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
}
    a53e:	08 95       	ret

0000a540 <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    a540:	1f 92       	push	r1
    a542:	0f 92       	push	r0
    a544:	0f b6       	in	r0, 0x3f	; 63
    a546:	0f 92       	push	r0
    a548:	0b b6       	in	r0, 0x3b	; 59
    a54a:	0f 92       	push	r0
    a54c:	11 24       	eor	r1, r1
    a54e:	0f 93       	push	r16
    a550:	1f 93       	push	r17
    a552:	2f 93       	push	r18
    a554:	3f 93       	push	r19
    a556:	4f 93       	push	r20
    a558:	5f 93       	push	r21
    a55a:	6f 93       	push	r22
    a55c:	7f 93       	push	r23
    a55e:	8f 93       	push	r24
    a560:	9f 93       	push	r25
    a562:	af 93       	push	r26
    a564:	bf 93       	push	r27
    a566:	cf 93       	push	r28
    a568:	df 93       	push	r29
    a56a:	ef 93       	push	r30
    a56c:	ff 93       	push	r31
	LiveTime++;
    a56e:	80 91 d0 08 	lds	r24, 0x08D0
    a572:	90 91 d1 08 	lds	r25, 0x08D1
    a576:	a0 91 d2 08 	lds	r26, 0x08D2
    a57a:	b0 91 d3 08 	lds	r27, 0x08D3
    a57e:	01 96       	adiw	r24, 0x01	; 1
    a580:	a1 1d       	adc	r26, r1
    a582:	b1 1d       	adc	r27, r1
    a584:	80 93 d0 08 	sts	0x08D0, r24
    a588:	90 93 d1 08 	sts	0x08D1, r25
    a58c:	a0 93 d2 08 	sts	0x08D2, r26
    a590:	b0 93 d3 08 	sts	0x08D3, r27
    a594:	40 e0       	ldi	r20, 0x00	; 0
    a596:	50 e0       	ldi	r21, 0x00	; 0

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<Timer8TotNumber; i++)
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
			Timer8Flg[i/8] |=(1<<i%8);
    a598:	c1 e0       	ldi	r28, 0x01	; 1
    a59a:	d0 e0       	ldi	r29, 0x00	; 0
	LiveTime++;

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<Timer8TotNumber; i++)
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    a59c:	84 2f       	mov	r24, r20
    a59e:	86 95       	lsr	r24
    a5a0:	86 95       	lsr	r24
    a5a2:	86 95       	lsr	r24
    a5a4:	a8 2f       	mov	r26, r24
    a5a6:	b0 e0       	ldi	r27, 0x00	; 0
    a5a8:	ab 5c       	subi	r26, 0xCB	; 203
    a5aa:	bc 4f       	sbci	r27, 0xFC	; 252
    a5ac:	8c 91       	ld	r24, X
    a5ae:	ba 01       	movw	r22, r20
    a5b0:	67 70       	andi	r22, 0x07	; 7
    a5b2:	70 70       	andi	r23, 0x00	; 0
    a5b4:	90 e0       	ldi	r25, 0x00	; 0
    a5b6:	06 2e       	mov	r0, r22
    a5b8:	02 c0       	rjmp	.+4      	; 0xa5be <__vector_12+0x7e>
    a5ba:	95 95       	asr	r25
    a5bc:	87 95       	ror	r24
    a5be:	0a 94       	dec	r0
    a5c0:	e2 f7       	brpl	.-8      	; 0xa5ba <__vector_12+0x7a>
    a5c2:	80 fd       	sbrc	r24, 0
    a5c4:	12 c0       	rjmp	.+36     	; 0xa5ea <__vector_12+0xaa>
    a5c6:	fa 01       	movw	r30, r20
    a5c8:	e3 50       	subi	r30, 0x03	; 3
    a5ca:	fe 4f       	sbci	r31, 0xFE	; 254
    a5cc:	80 81       	ld	r24, Z
    a5ce:	81 50       	subi	r24, 0x01	; 1
    a5d0:	80 83       	st	Z, r24
    a5d2:	80 81       	ld	r24, Z
    a5d4:	88 23       	and	r24, r24
    a5d6:	49 f4       	brne	.+18     	; 0xa5ea <__vector_12+0xaa>
			Timer8Flg[i/8] |=(1<<i%8);
    a5d8:	2c 91       	ld	r18, X
    a5da:	ce 01       	movw	r24, r28
    a5dc:	02 c0       	rjmp	.+4      	; 0xa5e2 <__vector_12+0xa2>
    a5de:	88 0f       	add	r24, r24
    a5e0:	99 1f       	adc	r25, r25
    a5e2:	6a 95       	dec	r22
    a5e4:	e2 f7       	brpl	.-8      	; 0xa5de <__vector_12+0x9e>
    a5e6:	28 2b       	or	r18, r24
    a5e8:	2c 93       	st	X, r18
    a5ea:	4f 5f       	subi	r20, 0xFF	; 255
    a5ec:	5f 4f       	sbci	r21, 0xFF	; 255
{
	LiveTime++;

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<Timer8TotNumber; i++)
    a5ee:	48 32       	cpi	r20, 0x28	; 40
    a5f0:	51 05       	cpc	r21, r1
    a5f2:	a1 f6       	brne	.-88     	; 0xa59c <__vector_12+0x5c>
    a5f4:	40 e0       	ldi	r20, 0x00	; 0
    a5f6:	50 e0       	ldi	r21, 0x00	; 0
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
			Timer8Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer16TotNumber; i++)
		if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
			Timer16Flg[i/8] |=(1<<i%8);
    a5f8:	c1 e0       	ldi	r28, 0x01	; 1
    a5fa:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8TotNumber; i++)
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
			Timer8Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer16TotNumber; i++)
		if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    a5fc:	84 2f       	mov	r24, r20
    a5fe:	86 95       	lsr	r24
    a600:	86 95       	lsr	r24
    a602:	86 95       	lsr	r24
    a604:	a8 2f       	mov	r26, r24
    a606:	b0 e0       	ldi	r27, 0x00	; 0
    a608:	a5 5c       	subi	r26, 0xC5	; 197
    a60a:	bc 4f       	sbci	r27, 0xFC	; 252
    a60c:	8c 91       	ld	r24, X
    a60e:	ba 01       	movw	r22, r20
    a610:	67 70       	andi	r22, 0x07	; 7
    a612:	70 70       	andi	r23, 0x00	; 0
    a614:	90 e0       	ldi	r25, 0x00	; 0
    a616:	06 2e       	mov	r0, r22
    a618:	02 c0       	rjmp	.+4      	; 0xa61e <__vector_12+0xde>
    a61a:	95 95       	asr	r25
    a61c:	87 95       	ror	r24
    a61e:	0a 94       	dec	r0
    a620:	e2 f7       	brpl	.-8      	; 0xa61a <__vector_12+0xda>
    a622:	80 fd       	sbrc	r24, 0
    a624:	17 c0       	rjmp	.+46     	; 0xa654 <__vector_12+0x114>
    a626:	fa 01       	movw	r30, r20
    a628:	ee 0f       	add	r30, r30
    a62a:	ff 1f       	adc	r31, r31
    a62c:	eb 5d       	subi	r30, 0xDB	; 219
    a62e:	fd 4f       	sbci	r31, 0xFD	; 253
    a630:	80 81       	ld	r24, Z
    a632:	91 81       	ldd	r25, Z+1	; 0x01
    a634:	01 97       	sbiw	r24, 0x01	; 1
    a636:	91 83       	std	Z+1, r25	; 0x01
    a638:	80 83       	st	Z, r24
    a63a:	80 81       	ld	r24, Z
    a63c:	91 81       	ldd	r25, Z+1	; 0x01
    a63e:	89 2b       	or	r24, r25
    a640:	49 f4       	brne	.+18     	; 0xa654 <__vector_12+0x114>
			Timer16Flg[i/8] |=(1<<i%8);
    a642:	2c 91       	ld	r18, X
    a644:	ce 01       	movw	r24, r28
    a646:	02 c0       	rjmp	.+4      	; 0xa64c <__vector_12+0x10c>
    a648:	88 0f       	add	r24, r24
    a64a:	99 1f       	adc	r25, r25
    a64c:	6a 95       	dec	r22
    a64e:	e2 f7       	brpl	.-8      	; 0xa648 <__vector_12+0x108>
    a650:	28 2b       	or	r18, r24
    a652:	2c 93       	st	X, r18
    a654:	4f 5f       	subi	r20, 0xFF	; 255
    a656:	5f 4f       	sbci	r21, 0xFF	; 255
	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<Timer8TotNumber; i++)
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
			Timer8Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer16TotNumber; i++)
    a658:	48 33       	cpi	r20, 0x38	; 56
    a65a:	51 05       	cpc	r21, r1
    a65c:	79 f6       	brne	.-98     	; 0xa5fc <__vector_12+0xbc>
    a65e:	40 e0       	ldi	r20, 0x00	; 0
    a660:	50 e0       	ldi	r21, 0x00	; 0
		if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
			Timer16Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer32TotNumber; i++)
		if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
			Timer32Flg[i/8] |=(1<<i%8);
    a662:	01 e0       	ldi	r16, 0x01	; 1
    a664:	10 e0       	ldi	r17, 0x00	; 0
			Timer8Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer16TotNumber; i++)
		if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
			Timer16Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer32TotNumber; i++)
		if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    a666:	84 2f       	mov	r24, r20
    a668:	86 95       	lsr	r24
    a66a:	86 95       	lsr	r24
    a66c:	86 95       	lsr	r24
    a66e:	c8 2f       	mov	r28, r24
    a670:	d0 e0       	ldi	r29, 0x00	; 0
    a672:	cd 5b       	subi	r28, 0xBD	; 189
    a674:	dc 4f       	sbci	r29, 0xFC	; 252
    a676:	88 81       	ld	r24, Y
    a678:	ba 01       	movw	r22, r20
    a67a:	67 70       	andi	r22, 0x07	; 7
    a67c:	70 70       	andi	r23, 0x00	; 0
    a67e:	90 e0       	ldi	r25, 0x00	; 0
    a680:	06 2e       	mov	r0, r22
    a682:	02 c0       	rjmp	.+4      	; 0xa688 <__vector_12+0x148>
    a684:	95 95       	asr	r25
    a686:	87 95       	ror	r24
    a688:	0a 94       	dec	r0
    a68a:	e2 f7       	brpl	.-8      	; 0xa684 <__vector_12+0x144>
    a68c:	80 fd       	sbrc	r24, 0
    a68e:	23 c0       	rjmp	.+70     	; 0xa6d6 <__vector_12+0x196>
    a690:	fa 01       	movw	r30, r20
    a692:	ee 0f       	add	r30, r30
    a694:	ff 1f       	adc	r31, r31
    a696:	ee 0f       	add	r30, r30
    a698:	ff 1f       	adc	r31, r31
    a69a:	eb 56       	subi	r30, 0x6B	; 107
    a69c:	fd 4f       	sbci	r31, 0xFD	; 253
    a69e:	80 81       	ld	r24, Z
    a6a0:	91 81       	ldd	r25, Z+1	; 0x01
    a6a2:	a2 81       	ldd	r26, Z+2	; 0x02
    a6a4:	b3 81       	ldd	r27, Z+3	; 0x03
    a6a6:	01 97       	sbiw	r24, 0x01	; 1
    a6a8:	a1 09       	sbc	r26, r1
    a6aa:	b1 09       	sbc	r27, r1
    a6ac:	80 83       	st	Z, r24
    a6ae:	91 83       	std	Z+1, r25	; 0x01
    a6b0:	a2 83       	std	Z+2, r26	; 0x02
    a6b2:	b3 83       	std	Z+3, r27	; 0x03
    a6b4:	80 81       	ld	r24, Z
    a6b6:	91 81       	ldd	r25, Z+1	; 0x01
    a6b8:	a2 81       	ldd	r26, Z+2	; 0x02
    a6ba:	b3 81       	ldd	r27, Z+3	; 0x03
    a6bc:	00 97       	sbiw	r24, 0x00	; 0
    a6be:	a1 05       	cpc	r26, r1
    a6c0:	b1 05       	cpc	r27, r1
    a6c2:	49 f4       	brne	.+18     	; 0xa6d6 <__vector_12+0x196>
			Timer32Flg[i/8] |=(1<<i%8);
    a6c4:	28 81       	ld	r18, Y
    a6c6:	c8 01       	movw	r24, r16
    a6c8:	02 c0       	rjmp	.+4      	; 0xa6ce <__vector_12+0x18e>
    a6ca:	88 0f       	add	r24, r24
    a6cc:	99 1f       	adc	r25, r25
    a6ce:	6a 95       	dec	r22
    a6d0:	e2 f7       	brpl	.-8      	; 0xa6ca <__vector_12+0x18a>
    a6d2:	28 2b       	or	r18, r24
    a6d4:	28 83       	st	Y, r18
    a6d6:	4f 5f       	subi	r20, 0xFF	; 255
    a6d8:	5f 4f       	sbci	r21, 0xFF	; 255
		if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
			Timer8Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer16TotNumber; i++)
		if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
			Timer16Flg[i/8] |=(1<<i%8);
	for (i=0; i<Timer32TotNumber; i++)
    a6da:	48 32       	cpi	r20, 0x28	; 40
    a6dc:	51 05       	cpc	r21, r1
    a6de:	19 f6       	brne	.-122    	; 0xa666 <__vector_12+0x126>
			Timer32Flg[i/8] |=(1<<i%8);

	// 1 s
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    a6e0:	80 91 fb 01 	lds	r24, 0x01FB
    a6e4:	8f 5f       	subi	r24, 0xFF	; 255
    a6e6:	80 93 fb 01 	sts	0x01FB, r24
    a6ea:	84 36       	cpi	r24, 0x64	; 100
    a6ec:	f9 f4       	brne	.+62     	; 0xa72c <__vector_12+0x1ec>
			Timer10ms = 0;
    a6ee:	10 92 fb 01 	sts	0x01FB, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    a6f2:	80 91 78 0a 	lds	r24, 0x0A78
    a6f6:	8f 5f       	subi	r24, 0xFF	; 255
    a6f8:	80 93 78 0a 	sts	0x0A78, r24
    a6fc:	8c 33       	cpi	r24, 0x3C	; 60
    a6fe:	b1 f4       	brne	.+44     	; 0xa72c <__vector_12+0x1ec>
		Timer1s = 0;
    a700:	10 92 78 0a 	sts	0x0A78, r1
		if (++Timer1min==60) {
    a704:	80 91 a0 05 	lds	r24, 0x05A0
    a708:	8f 5f       	subi	r24, 0xFF	; 255
    a70a:	80 93 a0 05 	sts	0x05A0, r24
    a70e:	8c 33       	cpi	r24, 0x3C	; 60
    a710:	69 f4       	brne	.+26     	; 0xa72c <__vector_12+0x1ec>
			Timer1min = 0;
    a712:	10 92 a0 05 	sts	0x05A0, r1
			++Timer1hour;
    a716:	80 91 af 0d 	lds	r24, 0x0DAF
    a71a:	90 91 b0 0d 	lds	r25, 0x0DB0
    a71e:	01 96       	adiw	r24, 0x01	; 1
    a720:	90 93 b0 0d 	sts	0x0DB0, r25
    a724:	80 93 af 0d 	sts	0x0DAF, r24
			OnTimeSave();
    a728:	0e 94 91 52 	call	0xa522	; 0xa522 <OnTimeSave>
	#endif

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    a72c:	ff 91       	pop	r31
    a72e:	ef 91       	pop	r30
    a730:	df 91       	pop	r29
    a732:	cf 91       	pop	r28
    a734:	bf 91       	pop	r27
    a736:	af 91       	pop	r26
    a738:	9f 91       	pop	r25
    a73a:	8f 91       	pop	r24
    a73c:	7f 91       	pop	r23
    a73e:	6f 91       	pop	r22
    a740:	5f 91       	pop	r21
    a742:	4f 91       	pop	r20
    a744:	3f 91       	pop	r19
    a746:	2f 91       	pop	r18
    a748:	1f 91       	pop	r17
    a74a:	0f 91       	pop	r16
    a74c:	0f 90       	pop	r0
    a74e:	0b be       	out	0x3b, r0	; 59
    a750:	0f 90       	pop	r0
    a752:	0f be       	out	0x3f, r0	; 63
    a754:	0f 90       	pop	r0
    a756:	1f 90       	pop	r1
    a758:	18 95       	reti

0000a75a <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    a75a:	0e 94 c0 8f 	call	0x11f80	; 0x11f80 <__eewr_block_m128>
	CRC_EEPROM_upd();
    a75e:	0e 94 fc 51 	call	0xa3f8	; 0xa3f8 <CRC_EEPROM_upd>
	//IntOn();
}
    a762:	08 95       	ret

0000a764 <GSMApply>:

	Modbus_ReadHoldReg();
}

void 
GSMApply(void){//=====================================================   GSM
    a764:	0f 93       	push	r16
    a766:	1f 93       	push	r17

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    a768:	0a ef       	ldi	r16, 0xFA	; 250
    a76a:	17 e0       	ldi	r17, 0x07	; 7
    a76c:	c8 01       	movw	r24, r16
    a76e:	66 e0       	ldi	r22, 0x06	; 6
    a770:	70 e0       	ldi	r23, 0x00	; 0
    a772:	4e e1       	ldi	r20, 0x1E	; 30
    a774:	50 e0       	ldi	r21, 0x00	; 0
    a776:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
	wdt_reset();
    a77a:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    a77c:	c8 01       	movw	r24, r16
    a77e:	4e 96       	adiw	r24, 0x1e	; 30
    a780:	64 e2       	ldi	r22, 0x24	; 36
    a782:	70 e0       	ldi	r23, 0x00	; 0
    a784:	44 e1       	ldi	r20, 0x14	; 20
    a786:	50 e0       	ldi	r21, 0x00	; 0
    a788:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
	wdt_reset();
    a78c:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    a78e:	c8 01       	movw	r24, r16
    a790:	c2 96       	adiw	r24, 0x32	; 50
    a792:	68 e3       	ldi	r22, 0x38	; 56
    a794:	70 e0       	ldi	r23, 0x00	; 0
    a796:	44 e1       	ldi	r20, 0x14	; 20
    a798:	50 e0       	ldi	r21, 0x00	; 0
    a79a:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
	wdt_reset();
    a79e:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    a7a0:	60 91 40 08 	lds	r22, 0x0840
    a7a4:	70 91 41 08 	lds	r23, 0x0841
    a7a8:	84 e6       	ldi	r24, 0x64	; 100
    a7aa:	90 e0       	ldi	r25, 0x00	; 0
    a7ac:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    a7b0:	60 91 42 08 	lds	r22, 0x0842
    a7b4:	70 91 43 08 	lds	r23, 0x0843
    a7b8:	86 e7       	ldi	r24, 0x76	; 118
    a7ba:	90 e0       	ldi	r25, 0x00	; 0
    a7bc:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
}
    a7c0:	1f 91       	pop	r17
    a7c2:	0f 91       	pop	r16
    a7c4:	08 95       	ret

0000a7c6 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    a7c6:	0e 94 d7 8f 	call	0x11fae	; 0x11fae <__eewr_dword_m128>
	CRC_EEPROM_upd();
    a7ca:	0e 94 fc 51 	call	0xa3f8	; 0xa3f8 <CRC_EEPROM_upd>
	//IntOn();
}
    a7ce:	08 95       	ret

0000a7d0 <erbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a7d0:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
	//IntOn();
}
    a7d4:	08 95       	ret

0000a7d6 <erd>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    a7d6:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
	//IntOn();
	return word;
}
    a7da:	08 95       	ret

0000a7dc <erw>:
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a7dc:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	//IntOn();
	return word;
}
    a7e0:	08 95       	ret

0000a7e2 <Modbus_ReadHoldReg>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    a7e2:	8f b7       	in	r24, 0x3f	; 63
    a7e4:	80 78       	andi	r24, 0x80	; 128
    a7e6:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    a7ea:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a7ec:	8d e5       	ldi	r24, 0x5D	; 93
    a7ee:	91 e0       	ldi	r25, 0x01	; 1
    a7f0:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>

void Modbus_ReadHoldReg(void){
	IntOff();
	MBHoldReg1[0] = erw(&EM_UART_Param);
    a7f4:	90 93 f9 07 	sts	0x07F9, r25
    a7f8:	80 93 f8 07 	sts	0x07F8, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a7fc:	8a ef       	ldi	r24, 0xFA	; 250
    a7fe:	97 e0       	ldi	r25, 0x07	; 7
    a800:	66 e0       	ldi	r22, 0x06	; 6
    a802:	70 e0       	ldi	r23, 0x00	; 0
    a804:	4e e1       	ldi	r20, 0x1E	; 30
    a806:	50 e0       	ldi	r21, 0x00	; 0
    a808:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a80c:	88 e1       	ldi	r24, 0x18	; 24
    a80e:	98 e0       	ldi	r25, 0x08	; 8
    a810:	64 e2       	ldi	r22, 0x24	; 36
    a812:	70 e0       	ldi	r23, 0x00	; 0
    a814:	44 e1       	ldi	r20, 0x14	; 20
    a816:	50 e0       	ldi	r21, 0x00	; 0
    a818:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    a81c:	8c e2       	ldi	r24, 0x2C	; 44
    a81e:	98 e0       	ldi	r25, 0x08	; 8
    a820:	68 e3       	ldi	r22, 0x38	; 56
    a822:	70 e0       	ldi	r23, 0x00	; 0
    a824:	44 e1       	ldi	r20, 0x14	; 20
    a826:	50 e0       	ldi	r21, 0x00	; 0
    a828:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    a82c:	84 e6       	ldi	r24, 0x64	; 100
    a82e:	90 e0       	ldi	r25, 0x00	; 0
    a830:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    a834:	90 93 41 08 	sts	0x0841, r25
    a838:	80 93 40 08 	sts	0x0840, r24
    a83c:	86 e7       	ldi	r24, 0x76	; 118
    a83e:	90 e0       	ldi	r25, 0x00	; 0
    a840:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    a844:	90 93 43 08 	sts	0x0843, r25
    a848:	80 93 42 08 	sts	0x0842, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    a84c:	80 91 fc 01 	lds	r24, 0x01FC
    a850:	88 23       	and	r24, r24
    a852:	09 f0       	breq	.+2      	; 0xa856 <Modbus_ReadHoldReg+0x74>
		sei();
    a854:	78 94       	sei
    a856:	08 95       	ret

0000a858 <Modbus_App_Init>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    a858:	0e 94 f1 53 	call	0xa7e2	; 0xa7e2 <Modbus_ReadHoldReg>
}
    a85c:	08 95       	ret

0000a85e <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    a85e:	0e 94 f1 53 	call	0xa7e2	; 0xa7e2 <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    a862:	0e 94 db 42 	call	0x85b6	; 0x85b6 <GPRS_AppInit>
	#endif

	WebInit();
    a866:	0e 94 f5 3d 	call	0x7bea	; 0x7bea <WebInit>
}
    a86a:	08 95       	ret

0000a86c <Modbus_App>:
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    a86c:	cf 93       	push	r28
    a86e:	df 93       	push	r29

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    a870:	4f b7       	in	r20, 0x3f	; 63
    a872:	40 78       	andi	r20, 0x80	; 128
    a874:	40 93 fc 01 	sts	0x01FC, r20
	cli();
    a878:	f8 94       	cli

	IntOff();
	MBInput1[0] = DigInput.State[0];
    a87a:	80 91 47 08 	lds	r24, 0x0847
    a87e:	80 93 79 03 	sts	0x0379, r24

	MBInReg1[0] = (SW_VERSION << 8) + 	SW_SUBVERSION;
    a882:	85 e0       	ldi	r24, 0x05	; 5
    a884:	93 e0       	ldi	r25, 0x03	; 3
    a886:	90 93 e3 09 	sts	0x09E3, r25
    a88a:	80 93 e2 09 	sts	0x09E2, r24
	MBInReg1[1] = MemFail;
    a88e:	24 ee       	ldi	r18, 0xE4	; 228
    a890:	39 e0       	ldi	r19, 0x09	; 9
    a892:	80 91 e1 09 	lds	r24, 0x09E1
    a896:	80 93 e4 09 	sts	0x09E4, r24
    a89a:	10 92 e5 09 	sts	0x09E5, r1
	MBInReg1[2] = (uint16_t)(LiveTime & 0x0000FFFF);
    a89e:	80 91 d0 08 	lds	r24, 0x08D0
    a8a2:	90 91 d1 08 	lds	r25, 0x08D1
    a8a6:	a0 91 d2 08 	lds	r26, 0x08D2
    a8aa:	b0 91 d3 08 	lds	r27, 0x08D3
    a8ae:	90 93 e7 09 	sts	0x09E7, r25
    a8b2:	80 93 e6 09 	sts	0x09E6, r24
	MBInReg1[3] = (uint16_t)(LiveTime>>16);
    a8b6:	80 91 d0 08 	lds	r24, 0x08D0
    a8ba:	90 91 d1 08 	lds	r25, 0x08D1
    a8be:	a0 91 d2 08 	lds	r26, 0x08D2
    a8c2:	b0 91 d3 08 	lds	r27, 0x08D3
    a8c6:	cd 01       	movw	r24, r26
    a8c8:	aa 27       	eor	r26, r26
    a8ca:	bb 27       	eor	r27, r27
    a8cc:	90 93 e9 09 	sts	0x09E9, r25
    a8d0:	80 93 e8 09 	sts	0x09E8, r24
	MBInReg1[4] = (uint16_t)Temperature[0];	
    a8d4:	80 91 70 05 	lds	r24, 0x0570
    a8d8:	90 91 71 05 	lds	r25, 0x0571
    a8dc:	90 93 eb 09 	sts	0x09EB, r25
    a8e0:	80 93 ea 09 	sts	0x09EA, r24
	MBInReg1[5] = (uint16_t)GSM_State;
    a8e4:	80 91 a4 05 	lds	r24, 0x05A4
    a8e8:	80 93 ec 09 	sts	0x09EC, r24
    a8ec:	f9 01       	movw	r30, r18
    a8ee:	11 86       	std	Z+9, r1	; 0x09
	MBInReg1[6] = GSM_MyIP.IP1;
    a8f0:	80 91 84 0a 	lds	r24, 0x0A84
    a8f4:	80 93 ee 09 	sts	0x09EE, r24
    a8f8:	13 86       	std	Z+11, r1	; 0x0b
	MBInReg1[7] = GSM_MyIP.IP2;
    a8fa:	80 91 85 0a 	lds	r24, 0x0A85
    a8fe:	80 93 f0 09 	sts	0x09F0, r24
    a902:	15 86       	std	Z+13, r1	; 0x0d
	MBInReg1[8] = GSM_MyIP.IP3;
    a904:	80 91 86 0a 	lds	r24, 0x0A86
    a908:	80 93 f2 09 	sts	0x09F2, r24
    a90c:	17 86       	std	Z+15, r1	; 0x0f
	MBInReg1[9] = GSM_MyIP.IP4;
    a90e:	80 91 87 0a 	lds	r24, 0x0A87
    a912:	80 93 f4 09 	sts	0x09F4, r24
    a916:	11 8a       	std	Z+17, r1	; 0x11
	MBInReg1[10] = GSM_ClientIP.IP1;
    a918:	80 91 a2 0c 	lds	r24, 0x0CA2
    a91c:	80 93 f6 09 	sts	0x09F6, r24
    a920:	13 8a       	std	Z+19, r1	; 0x13
	MBInReg1[11] = GSM_ClientIP.IP2;
    a922:	80 91 a3 0c 	lds	r24, 0x0CA3
    a926:	80 93 f8 09 	sts	0x09F8, r24
    a92a:	15 8a       	std	Z+21, r1	; 0x15
	MBInReg1[12] = GSM_ClientIP.IP3;
    a92c:	80 91 a4 0c 	lds	r24, 0x0CA4
    a930:	80 93 fa 09 	sts	0x09FA, r24
    a934:	17 8a       	std	Z+23, r1	; 0x17
	MBInReg1[13] = GSM_ClientIP.IP4;
    a936:	80 91 a5 0c 	lds	r24, 0x0CA5
    a93a:	80 93 fc 09 	sts	0x09FC, r24
    a93e:	11 8e       	std	Z+25, r1	; 0x19
	MBInReg1[14] = GSM_RX_FIFOMax;
    a940:	80 91 77 0a 	lds	r24, 0x0A77
    a944:	80 93 fe 09 	sts	0x09FE, r24
    a948:	13 8e       	std	Z+27, r1	; 0x1b
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    a94a:	80 91 ea 08 	lds	r24, 0x08EA
    a94e:	80 93 00 0a 	sts	0x0A00, r24
    a952:	15 8e       	std	Z+29, r1	; 0x1d
	MBInReg1[16] = EM_RX_FIFOMax;
    a954:	80 91 d8 09 	lds	r24, 0x09D8
    a958:	80 93 02 0a 	sts	0x0A02, r24
    a95c:	17 8e       	std	Z+31, r1	; 0x1f
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    a95e:	b0 96       	adiw	r30, 0x20	; 32
    a960:	80 91 de 08 	lds	r24, 0x08DE
    a964:	80 93 04 0a 	sts	0x0A04, r24
    a968:	80 91 df 08 	lds	r24, 0x08DF
    a96c:	81 83       	std	Z+1, r24	; 0x01
    a96e:	80 91 e0 08 	lds	r24, 0x08E0
    a972:	82 83       	std	Z+2, r24	; 0x02
    a974:	80 91 e1 08 	lds	r24, 0x08E1
    a978:	83 83       	std	Z+3, r24	; 0x03
    a97a:	80 91 e2 08 	lds	r24, 0x08E2
    a97e:	84 83       	std	Z+4, r24	; 0x04
    a980:	80 91 e3 08 	lds	r24, 0x08E3
    a984:	85 83       	std	Z+5, r24	; 0x05
    a986:	80 91 e4 08 	lds	r24, 0x08E4
    a98a:	86 83       	std	Z+6, r24	; 0x06
    a98c:	80 91 e5 08 	lds	r24, 0x08E5
    a990:	87 83       	std	Z+7, r24	; 0x07
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    a992:	80 91 c9 08 	lds	r24, 0x08C9
    a996:	80 93 0c 0a 	sts	0x0A0C, r24
    a99a:	f9 01       	movw	r30, r18
    a99c:	11 a6       	std	Z+41, r1	; 0x29
	MBInReg1[22] = (uint16_t)Web_POST;
    a99e:	80 91 da 08 	lds	r24, 0x08DA
    a9a2:	80 93 0e 0a 	sts	0x0A0E, r24
    a9a6:	13 a6       	std	Z+43, r1	; 0x2b
	MBInReg1[23] = (uint16_t)AppProtocol;
    a9a8:	80 91 5f 09 	lds	r24, 0x095F
    a9ac:	80 93 10 0a 	sts	0x0A10, r24
    a9b0:	15 a6       	std	Z+45, r1	; 0x2d
	MBInReg1[24] = (uint16_t)WebSession;
    a9b2:	80 91 e9 08 	lds	r24, 0x08E9
    a9b6:	80 93 12 0a 	sts	0x0A12, r24
    a9ba:	17 a6       	std	Z+47, r1	; 0x2f
	MBInReg1[25] = (uint16_t)WebMode;
    a9bc:	80 91 d5 01 	lds	r24, 0x01D5
    a9c0:	80 93 14 0a 	sts	0x0A14, r24
    a9c4:	11 aa       	std	Z+49, r1	; 0x31
	MBInReg1[26] = (uint16_t)WebStrLen;
    a9c6:	80 91 ed 07 	lds	r24, 0x07ED
    a9ca:	80 93 16 0a 	sts	0x0A16, r24
    a9ce:	13 aa       	std	Z+51, r1	; 0x33

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    a9d0:	44 23       	and	r20, r20
    a9d2:	09 f0       	breq	.+2      	; 0xa9d6 <Modbus_App+0x16a>
		sei();
    a9d4:	78 94       	sei

	IntOn();
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    a9d6:	80 91 62 03 	lds	r24, 0x0362
    a9da:	80 ff       	sbrs	r24, 0
    a9dc:	14 c0       	rjmp	.+40     	; 0xaa06 <Modbus_App+0x19a>
		GSMApply();						//  MB RAM  EEPROM
    a9de:	0e 94 b2 53 	call	0xa764	; 0xa764 <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    a9e2:	0e 94 f1 53 	call	0xa7e2	; 0xa7e2 <Modbus_ReadHoldReg>
    a9e6:	8b e4       	ldi	r24, 0x4B	; 75
    a9e8:	80 93 a4 05 	sts	0x05A4, r24

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    a9ec:	9f b7       	in	r25, 0x3f	; 63
    a9ee:	90 78       	andi	r25, 0x80	; 128
    a9f0:	90 93 fc 01 	sts	0x01FC, r25
	cli();
    a9f4:	f8 94       	cli
		ResetGSMState();				// 
		IntOff();
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    a9f6:	80 91 62 03 	lds	r24, 0x0362
    a9fa:	8e 7f       	andi	r24, 0xFE	; 254
    a9fc:	80 93 62 03 	sts	0x0362, r24

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    aa00:	99 23       	and	r25, r25
    aa02:	09 f0       	breq	.+2      	; 0xaa06 <Modbus_App+0x19a>
		sei();
    aa04:	78 94       	sei

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    aa06:	8f b7       	in	r24, 0x3f	; 63
    aa08:	80 78       	andi	r24, 0x80	; 128
    aa0a:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    aa0e:	f8 94       	cli
		IntOn();
	}
	
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    aa10:	c0 91 f8 07 	lds	r28, 0x07F8
    aa14:	d0 91 f9 07 	lds	r29, 0x07F9
    aa18:	8d e5       	ldi	r24, 0x5D	; 93
    aa1a:	91 e0       	ldi	r25, 0x01	; 1
    aa1c:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    aa20:	c8 17       	cp	r28, r24
    aa22:	d9 07       	cpc	r29, r25
    aa24:	29 f0       	breq	.+10     	; 0xaa30 <Modbus_App+0x1c4>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    aa26:	8d e5       	ldi	r24, 0x5D	; 93
    aa28:	91 e0       	ldi	r25, 0x01	; 1
    aa2a:	be 01       	movw	r22, r28
    aa2c:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    aa30:	80 91 fc 01 	lds	r24, 0x01FC
    aa34:	88 23       	and	r24, r24
    aa36:	09 f0       	breq	.+2      	; 0xaa3a <Modbus_App+0x1ce>
		sei();
    aa38:	78 94       	sei
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    aa3a:	df 91       	pop	r29
    aa3c:	cf 91       	pop	r28
    aa3e:	08 95       	ret

0000aa40 <GPRS_WriteParamReply>:
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
	GPRS_ChangeData[6] = 7;
	GPRS_ChangeData[7] = ParamID_Hi;
	GPRS_ChangeData[8] = ParamID_Lo;
}
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    aa40:	ef 92       	push	r14
    aa42:	ff 92       	push	r15
    aa44:	0f 93       	push	r16
    aa46:	1f 93       	push	r17
    aa48:	f8 2e       	mov	r15, r24
    aa4a:	e6 2e       	mov	r14, r22
	GPRS_ChangeData[0] = 5;	
    aa4c:	85 e0       	ldi	r24, 0x05	; 5
    aa4e:	80 93 ba 05 	sts	0x05BA, r24
	GPRS_ChangeData[1] = 1;	
    aa52:	81 e0       	ldi	r24, 0x01	; 1
    aa54:	80 93 bb 05 	sts	0x05BB, r24
    aa58:	08 e7       	ldi	r16, 0x78	; 120
    aa5a:	10 e0       	ldi	r17, 0x00	; 0
    aa5c:	c8 01       	movw	r24, r16
    aa5e:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    aa62:	90 93 bc 05 	sts	0x05BC, r25
    aa66:	c8 01       	movw	r24, r16
    aa68:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    aa6c:	80 93 bd 05 	sts	0x05BD, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    aa70:	83 e0       	ldi	r24, 0x03	; 3
    aa72:	80 93 be 05 	sts	0x05BE, r24
	GPRS_ChangeData[5] = 3;	// -       
    aa76:	80 93 bf 05 	sts	0x05BF, r24
	GPRS_ChangeData[6] = 8;
    aa7a:	88 e0       	ldi	r24, 0x08	; 8
    aa7c:	80 93 c0 05 	sts	0x05C0, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    aa80:	f0 92 c1 05 	sts	0x05C1, r15
	GPRS_ChangeData[8] = ParamID_Lo;	
    aa84:	e0 92 c2 05 	sts	0x05C2, r14
}
    aa88:	1f 91       	pop	r17
    aa8a:	0f 91       	pop	r16
    aa8c:	ff 90       	pop	r15
    aa8e:	ef 90       	pop	r14
    aa90:	08 95       	ret

0000aa92 <GPRS_ReadParamReply>:

void GPRS_SendChange(uint8_t Size){
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
	GPRS_FlgSz_Out = Size;					//    .     
}
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    aa92:	df 92       	push	r13
    aa94:	ef 92       	push	r14
    aa96:	ff 92       	push	r15
    aa98:	0f 93       	push	r16
    aa9a:	1f 93       	push	r17
    aa9c:	e8 2e       	mov	r14, r24
    aa9e:	d6 2e       	mov	r13, r22
    aaa0:	f4 2e       	mov	r15, r20
	GPRS_ChangeData[0] = 5;	
    aaa2:	85 e0       	ldi	r24, 0x05	; 5
    aaa4:	80 93 ba 05 	sts	0x05BA, r24
	GPRS_ChangeData[1] = 1;	
    aaa8:	81 e0       	ldi	r24, 0x01	; 1
    aaaa:	80 93 bb 05 	sts	0x05BB, r24
    aaae:	08 e7       	ldi	r16, 0x78	; 120
    aab0:	10 e0       	ldi	r17, 0x00	; 0
    aab2:	c8 01       	movw	r24, r16
    aab4:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    aab8:	90 93 bc 05 	sts	0x05BC, r25
    aabc:	c8 01       	movw	r24, r16
    aabe:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    aac2:	80 93 bd 05 	sts	0x05BD, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    aac6:	83 e0       	ldi	r24, 0x03	; 3
    aac8:	80 93 be 05 	sts	0x05BE, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    aacc:	f8 0e       	add	r15, r24
    aace:	f0 92 bf 05 	sts	0x05BF, r15
	GPRS_ChangeData[6] = 7;
    aad2:	87 e0       	ldi	r24, 0x07	; 7
    aad4:	80 93 c0 05 	sts	0x05C0, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    aad8:	e0 92 c1 05 	sts	0x05C1, r14
	GPRS_ChangeData[8] = ParamID_Lo;
    aadc:	d0 92 c2 05 	sts	0x05C2, r13
}
    aae0:	1f 91       	pop	r17
    aae2:	0f 91       	pop	r16
    aae4:	ff 90       	pop	r15
    aae6:	ef 90       	pop	r14
    aae8:	df 90       	pop	r13
    aaea:	08 95       	ret

0000aaec <GPRS_Param>:
	GPRS_ChangeData[7] = ParamID_Hi;
	GPRS_ChangeData[8] = ParamID_Lo;	
}

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    aaec:	cf 92       	push	r12
    aaee:	df 92       	push	r13
    aaf0:	ef 92       	push	r14
    aaf2:	ff 92       	push	r15
    aaf4:	0f 93       	push	r16
    aaf6:	1f 93       	push	r17
    aaf8:	f8 2e       	mov	r15, r24
    aafa:	d6 2e       	mov	r13, r22
    aafc:	12 2f       	mov	r17, r18
	if(Cmd==READ_PARAM ){
    aafe:	01 3c       	cpi	r16, 0xC1	; 193
    ab00:	e9 f4       	brne	.+58     	; 0xab3c <GPRS_Param+0x50>
		if(MemCopy){
    ab02:	ee 20       	and	r14, r14
    ab04:	91 f0       	breq	.+36     	; 0xab2a <GPRS_Param+0x3e>
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    ab06:	cc 20       	and	r12, r12
    ab08:	49 f0       	breq	.+18     	; 0xab1c <GPRS_Param+0x30>
    ab0a:	23 ec       	ldi	r18, 0xC3	; 195
    ab0c:	35 e0       	ldi	r19, 0x05	; 5
    ab0e:	c9 01       	movw	r24, r18
    ab10:	ba 01       	movw	r22, r20
    ab12:	41 2f       	mov	r20, r17
    ab14:	50 e0       	ldi	r21, 0x00	; 0
    ab16:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
    ab1a:	07 c0       	rjmp	.+14     	; 0xab2a <GPRS_Param+0x3e>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    ab1c:	83 ec       	ldi	r24, 0xC3	; 195
    ab1e:	95 e0       	ldi	r25, 0x05	; 5
    ab20:	ba 01       	movw	r22, r20
    ab22:	42 2f       	mov	r20, r18
    ab24:	50 e0       	ldi	r21, 0x00	; 0
    ab26:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    ab2a:	8f 2d       	mov	r24, r15
    ab2c:	6d 2d       	mov	r22, r13
    ab2e:	41 2f       	mov	r20, r17
    ab30:	0e 94 49 55 	call	0xaa92	; 0xaa92 <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    ab34:	17 5f       	subi	r17, 0xF7	; 247
    ab36:	10 93 8e 05 	sts	0x058E, r17
    ab3a:	1d c0       	rjmp	.+58     	; 0xab76 <GPRS_Param+0x8a>
	}
	if(Cmd==WRITE_PARAM){
    ab3c:	0c 34       	cpi	r16, 0x4C	; 76
    ab3e:	d9 f4       	brne	.+54     	; 0xab76 <GPRS_Param+0x8a>
		if(MemCopy){
    ab40:	ee 20       	and	r14, r14
    ab42:	91 f0       	breq	.+36     	; 0xab68 <GPRS_Param+0x7c>
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    ab44:	cc 20       	and	r12, r12
    ab46:	49 f0       	breq	.+18     	; 0xab5a <GPRS_Param+0x6e>
    ab48:	25 ec       	ldi	r18, 0xC5	; 197
    ab4a:	37 e0       	ldi	r19, 0x07	; 7
    ab4c:	ca 01       	movw	r24, r20
    ab4e:	b9 01       	movw	r22, r18
    ab50:	41 2f       	mov	r20, r17
    ab52:	50 e0       	ldi	r21, 0x00	; 0
    ab54:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
    ab58:	07 c0       	rjmp	.+14     	; 0xab68 <GPRS_Param+0x7c>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    ab5a:	85 ec       	ldi	r24, 0xC5	; 197
    ab5c:	97 e0       	ldi	r25, 0x07	; 7
    ab5e:	ba 01       	movw	r22, r20
    ab60:	42 2f       	mov	r20, r18
    ab62:	50 e0       	ldi	r21, 0x00	; 0
    ab64:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    ab68:	8f 2d       	mov	r24, r15
    ab6a:	6d 2d       	mov	r22, r13
    ab6c:	0e 94 20 55 	call	0xaa40	; 0xaa40 <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    ab70:	89 e0       	ldi	r24, 0x09	; 9
    ab72:	80 93 8e 05 	sts	0x058E, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    ab76:	80 91 ca 08 	lds	r24, 0x08CA
    ab7a:	88 60       	ori	r24, 0x08	; 8
    ab7c:	80 93 ca 08 	sts	0x08CA, r24
}
    ab80:	1f 91       	pop	r17
    ab82:	0f 91       	pop	r16
    ab84:	ff 90       	pop	r15
    ab86:	ef 90       	pop	r14
    ab88:	df 90       	pop	r13
    ab8a:	cf 90       	pop	r12
    ab8c:	08 95       	ret

0000ab8e <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ab8e:	cf 92       	push	r12
    ab90:	ef 92       	push	r14
    ab92:	0f 93       	push	r16
    ab94:	98 2f       	mov	r25, r24
    ab96:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    ab98:	83 30       	cpi	r24, 0x03	; 3
    ab9a:	a9 f0       	breq	.+42     	; 0xabc6 <GPRS_Param10+0x38>
    ab9c:	84 30       	cpi	r24, 0x04	; 4
    ab9e:	28 f4       	brcc	.+10     	; 0xabaa <GPRS_Param10+0x1c>
    aba0:	81 30       	cpi	r24, 0x01	; 1
    aba2:	59 f0       	breq	.+22     	; 0xabba <GPRS_Param10+0x2c>
    aba4:	82 30       	cpi	r24, 0x02	; 2
    aba6:	29 f4       	brne	.+10     	; 0xabb2 <GPRS_Param10+0x24>
    aba8:	0b c0       	rjmp	.+22     	; 0xabc0 <GPRS_Param10+0x32>
    abaa:	84 30       	cpi	r24, 0x04	; 4
    abac:	79 f0       	breq	.+30     	; 0xabcc <GPRS_Param10+0x3e>
    abae:	85 30       	cpi	r24, 0x05	; 5
    abb0:	81 f0       	breq	.+32     	; 0xabd2 <GPRS_Param10+0x44>
    abb2:	40 e0       	ldi	r20, 0x00	; 0
    abb4:	50 e0       	ldi	r21, 0x00	; 0
    abb6:	20 e0       	ldi	r18, 0x00	; 0
    abb8:	0f c0       	rjmp	.+30     	; 0xabd8 <GPRS_Param10+0x4a>
    abba:	4f e5       	ldi	r20, 0x5F	; 95
    abbc:	51 e0       	ldi	r21, 0x01	; 1
    abbe:	0b c0       	rjmp	.+22     	; 0xabd6 <GPRS_Param10+0x48>
    abc0:	4e e7       	ldi	r20, 0x7E	; 126
    abc2:	51 e0       	ldi	r21, 0x01	; 1
    abc4:	08 c0       	rjmp	.+16     	; 0xabd6 <GPRS_Param10+0x48>
		case 1:	param = &User_PSW; 			param_size = sizeof(User_PSW);		break;
		case 2:	param = &Password[0];		param_size = sizeof(Password[0]);	break;
    abc6:	40 e8       	ldi	r20, 0x80	; 128
    abc8:	51 e0       	ldi	r21, 0x01	; 1
    abca:	05 c0       	rjmp	.+10     	; 0xabd6 <GPRS_Param10+0x48>
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
    abcc:	42 e8       	ldi	r20, 0x82	; 130
    abce:	51 e0       	ldi	r21, 0x01	; 1
    abd0:	02 c0       	rjmp	.+4      	; 0xabd6 <GPRS_Param10+0x48>
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
    abd2:	44 e8       	ldi	r20, 0x84	; 132
    abd4:	51 e0       	ldi	r21, 0x01	; 1
    abd6:	22 e0       	ldi	r18, 0x02	; 2
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    abd8:	8a e0       	ldi	r24, 0x0A	; 10
    abda:	69 2f       	mov	r22, r25
    abdc:	ee 24       	eor	r14, r14
    abde:	e3 94       	inc	r14
    abe0:	cc 24       	eor	r12, r12
    abe2:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    abe6:	0f 91       	pop	r16
    abe8:	ef 90       	pop	r14
    abea:	cf 90       	pop	r12
    abec:	08 95       	ret

0000abee <GPRS_Param09>:
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    abee:	cf 92       	push	r12
    abf0:	ef 92       	push	r14
    abf2:	0f 93       	push	r16
    abf4:	38 2f       	mov	r19, r24
    abf6:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    abf8:	90 e0       	ldi	r25, 0x00	; 0
    abfa:	fc 01       	movw	r30, r24
    abfc:	31 97       	sbiw	r30, 0x01	; 1
    abfe:	e6 31       	cpi	r30, 0x16	; 22
    ac00:	f1 05       	cpc	r31, r1
    ac02:	08 f0       	brcs	.+2      	; 0xac06 <GPRS_Param09+0x18>
    ac04:	70 c0       	rjmp	.+224    	; 0xace6 <GPRS_Param09+0xf8>
    ac06:	ea 5b       	subi	r30, 0xBA	; 186
    ac08:	ff 4f       	sbci	r31, 0xFF	; 255
    ac0a:	ee 0f       	add	r30, r30
    ac0c:	ff 1f       	adc	r31, r31
    ac0e:	05 90       	lpm	r0, Z+
    ac10:	f4 91       	lpm	r31, Z+
    ac12:	e0 2d       	mov	r30, r0
    ac14:	09 94       	ijmp
    ac16:	48 e3       	ldi	r20, 0x38	; 56
    ac18:	50 e0       	ldi	r21, 0x00	; 0
    ac1a:	7e c0       	rjmp	.+252    	; 0xad18 <GPRS_Param09+0x12a>
		case 1:
			if(Cmd==READ_PARAM){
    ac1c:	61 3c       	cpi	r22, 0xC1	; 193
    ac1e:	91 f4       	brne	.+36     	; 0xac44 <GPRS_Param09+0x56>
    ac20:	83 ec       	ldi	r24, 0xC3	; 195
    ac22:	95 e0       	ldi	r25, 0x05	; 5
    ac24:	66 e0       	ldi	r22, 0x06	; 6
    ac26:	70 e0       	ldi	r23, 0x00	; 0
    ac28:	4f e0       	ldi	r20, 0x0F	; 15
    ac2a:	50 e0       	ldi	r21, 0x00	; 0
    ac2c:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
			}
			if(Cmd==WRITE_PARAM){
    ac30:	82 ed       	ldi	r24, 0xD2	; 210
    ac32:	95 e0       	ldi	r25, 0x05	; 5
    ac34:	64 e2       	ldi	r22, 0x24	; 36
    ac36:	70 e0       	ldi	r23, 0x00	; 0
    ac38:	4f e0       	ldi	r20, 0x0F	; 15
    ac3a:	50 e0       	ldi	r21, 0x00	; 0
    ac3c:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    ac40:	2e e1       	ldi	r18, 0x1E	; 30
    ac42:	54 c0       	rjmp	.+168    	; 0xacec <GPRS_Param09+0xfe>
    ac44:	6c 34       	cpi	r22, 0x4C	; 76
    ac46:	09 f0       	breq	.+2      	; 0xac4a <GPRS_Param09+0x5c>
    ac48:	50 c0       	rjmp	.+160    	; 0xacea <GPRS_Param09+0xfc>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    ac4a:	85 ec       	ldi	r24, 0xC5	; 197
    ac4c:	97 e0       	ldi	r25, 0x07	; 7
    ac4e:	66 e0       	ldi	r22, 0x06	; 6
    ac50:	70 e0       	ldi	r23, 0x00	; 0
    ac52:	4f e0       	ldi	r20, 0x0F	; 15
    ac54:	50 e0       	ldi	r21, 0x00	; 0
    ac56:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    ac5a:	84 ed       	ldi	r24, 0xD4	; 212
    ac5c:	97 e0       	ldi	r25, 0x07	; 7
    ac5e:	68 ec       	ldi	r22, 0xC8	; 200
    ac60:	71 e0       	ldi	r23, 0x01	; 1
    ac62:	4f e0       	ldi	r20, 0x0F	; 15
    ac64:	50 e0       	ldi	r21, 0x00	; 0
    ac66:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
    ac6a:	3f c0       	rjmp	.+126    	; 0xacea <GPRS_Param09+0xfc>
    ac6c:	4c e4       	ldi	r20, 0x4C	; 76
    ac6e:	50 e0       	ldi	r21, 0x00	; 0
    ac70:	20 c0       	rjmp	.+64     	; 0xacb2 <GPRS_Param09+0xc4>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    ac72:	40 e5       	ldi	r20, 0x50	; 80
    ac74:	50 e0       	ldi	r21, 0x00	; 0
    ac76:	1d c0       	rjmp	.+58     	; 0xacb2 <GPRS_Param09+0xc4>
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    ac78:	44 e5       	ldi	r20, 0x54	; 84
    ac7a:	50 e0       	ldi	r21, 0x00	; 0
    ac7c:	1a c0       	rjmp	.+52     	; 0xacb2 <GPRS_Param09+0xc4>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    ac7e:	48 e5       	ldi	r20, 0x58	; 88
    ac80:	50 e0       	ldi	r21, 0x00	; 0
    ac82:	17 c0       	rjmp	.+46     	; 0xacb2 <GPRS_Param09+0xc4>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    ac84:	4c e5       	ldi	r20, 0x5C	; 92
    ac86:	50 e0       	ldi	r21, 0x00	; 0
    ac88:	2c c0       	rjmp	.+88     	; 0xace2 <GPRS_Param09+0xf4>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    ac8a:	4e e5       	ldi	r20, 0x5E	; 94
    ac8c:	50 e0       	ldi	r21, 0x00	; 0
    ac8e:	29 c0       	rjmp	.+82     	; 0xace2 <GPRS_Param09+0xf4>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    ac90:	40 e6       	ldi	r20, 0x60	; 96
    ac92:	50 e0       	ldi	r21, 0x00	; 0
    ac94:	26 c0       	rjmp	.+76     	; 0xace2 <GPRS_Param09+0xf4>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    ac96:	42 e6       	ldi	r20, 0x62	; 98
    ac98:	50 e0       	ldi	r21, 0x00	; 0
    ac9a:	23 c0       	rjmp	.+70     	; 0xace2 <GPRS_Param09+0xf4>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    ac9c:	46 e6       	ldi	r20, 0x66	; 102
    ac9e:	50 e0       	ldi	r21, 0x00	; 0
    aca0:	08 c0       	rjmp	.+16     	; 0xacb2 <GPRS_Param09+0xc4>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    aca2:	4a e6       	ldi	r20, 0x6A	; 106
    aca4:	50 e0       	ldi	r21, 0x00	; 0
    aca6:	05 c0       	rjmp	.+10     	; 0xacb2 <GPRS_Param09+0xc4>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    aca8:	4e e6       	ldi	r20, 0x6E	; 110
    acaa:	50 e0       	ldi	r21, 0x00	; 0
    acac:	02 c0       	rjmp	.+4      	; 0xacb2 <GPRS_Param09+0xc4>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    acae:	42 e7       	ldi	r20, 0x72	; 114
    acb0:	50 e0       	ldi	r21, 0x00	; 0
    acb2:	24 e0       	ldi	r18, 0x04	; 4
    acb4:	24 c0       	rjmp	.+72     	; 0xacfe <GPRS_Param09+0x110>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    acb6:	44 e6       	ldi	r20, 0x64	; 100
    acb8:	50 e0       	ldi	r21, 0x00	; 0
    acba:	13 c0       	rjmp	.+38     	; 0xace2 <GPRS_Param09+0xf4>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    acbc:	46 e7       	ldi	r20, 0x76	; 118
    acbe:	50 e0       	ldi	r21, 0x00	; 0
    acc0:	10 c0       	rjmp	.+32     	; 0xace2 <GPRS_Param09+0xf4>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    acc2:	45 e2       	ldi	r20, 0x25	; 37
    acc4:	51 e0       	ldi	r21, 0x01	; 1
    acc6:	21 e0       	ldi	r18, 0x01	; 1
    acc8:	1a c0       	rjmp	.+52     	; 0xacfe <GPRS_Param09+0x110>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    acca:	4c e7       	ldi	r20, 0x7C	; 124
    accc:	50 e0       	ldi	r21, 0x00	; 0
    acce:	02 c0       	rjmp	.+4      	; 0xacd4 <GPRS_Param09+0xe6>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    acd0:	49 e8       	ldi	r20, 0x89	; 137
    acd2:	50 e0       	ldi	r21, 0x00	; 0
    acd4:	2c e0       	ldi	r18, 0x0C	; 12
    acd6:	13 c0       	rjmp	.+38     	; 0xacfe <GPRS_Param09+0x110>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    acd8:	46 e9       	ldi	r20, 0x96	; 150
    acda:	50 e0       	ldi	r21, 0x00	; 0
    acdc:	fb cf       	rjmp	.-10     	; 0xacd4 <GPRS_Param09+0xe6>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    acde:	4c e7       	ldi	r20, 0x7C	; 124
    ace0:	51 e0       	ldi	r21, 0x01	; 1
    ace2:	22 e0       	ldi	r18, 0x02	; 2
    ace4:	0c c0       	rjmp	.+24     	; 0xacfe <GPRS_Param09+0x110>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    ace6:	31 30       	cpi	r19, 0x01	; 1
    ace8:	39 f4       	brne	.+14     	; 0xacf8 <GPRS_Param09+0x10a>
    acea:	20 e0       	ldi	r18, 0x00	; 0
    acec:	89 e0       	ldi	r24, 0x09	; 9
    acee:	61 e0       	ldi	r22, 0x01	; 1
    acf0:	40 e0       	ldi	r20, 0x00	; 0
    acf2:	50 e0       	ldi	r21, 0x00	; 0
    acf4:	ee 24       	eor	r14, r14
    acf6:	07 c0       	rjmp	.+14     	; 0xad06 <GPRS_Param09+0x118>
    acf8:	40 e0       	ldi	r20, 0x00	; 0
    acfa:	50 e0       	ldi	r21, 0x00	; 0
    acfc:	20 e0       	ldi	r18, 0x00	; 0
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    acfe:	89 e0       	ldi	r24, 0x09	; 9
    ad00:	63 2f       	mov	r22, r19
    ad02:	ee 24       	eor	r14, r14
    ad04:	e3 94       	inc	r14
    ad06:	cc 24       	eor	r12, r12
    ad08:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ad0c:	0f 91       	pop	r16
    ad0e:	ef 90       	pop	r14
    ad10:	cf 90       	pop	r12
    ad12:	08 95       	ret
    ad14:	44 e2       	ldi	r20, 0x24	; 36
    ad16:	50 e0       	ldi	r21, 0x00	; 0
    ad18:	23 e1       	ldi	r18, 0x13	; 19
    ad1a:	f1 cf       	rjmp	.-30     	; 0xacfe <GPRS_Param09+0x110>

0000ad1c <GPRS_Param08>:
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
}

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ad1c:	cf 92       	push	r12
    ad1e:	ef 92       	push	r14
    ad20:	0f 93       	push	r16
    ad22:	98 2f       	mov	r25, r24
    ad24:	06 2f       	mov	r16, r22
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    ad26:	88 e0       	ldi	r24, 0x08	; 8
    ad28:	69 2f       	mov	r22, r25
    ad2a:	40 e0       	ldi	r20, 0x00	; 0
    ad2c:	50 e0       	ldi	r21, 0x00	; 0
    ad2e:	20 e0       	ldi	r18, 0x00	; 0
    ad30:	ee 24       	eor	r14, r14
    ad32:	e3 94       	inc	r14
    ad34:	cc 24       	eor	r12, r12
    ad36:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ad3a:	0f 91       	pop	r16
    ad3c:	ef 90       	pop	r14
    ad3e:	cf 90       	pop	r12
    ad40:	08 95       	ret

0000ad42 <GPRS_Param07>:
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ad42:	cf 92       	push	r12
    ad44:	ef 92       	push	r14
    ad46:	0f 93       	push	r16
    ad48:	98 2f       	mov	r25, r24
    ad4a:	06 2f       	mov	r16, r22
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    ad4c:	87 e0       	ldi	r24, 0x07	; 7
    ad4e:	69 2f       	mov	r22, r25
    ad50:	40 e0       	ldi	r20, 0x00	; 0
    ad52:	50 e0       	ldi	r21, 0x00	; 0
    ad54:	20 e0       	ldi	r18, 0x00	; 0
    ad56:	ee 24       	eor	r14, r14
    ad58:	e3 94       	inc	r14
    ad5a:	cc 24       	eor	r12, r12
    ad5c:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ad60:	0f 91       	pop	r16
    ad62:	ef 90       	pop	r14
    ad64:	cf 90       	pop	r12
    ad66:	08 95       	ret

0000ad68 <GPRS_Param06>:
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
}

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ad68:	cf 92       	push	r12
    ad6a:	ef 92       	push	r14
    ad6c:	0f 93       	push	r16
    ad6e:	98 2f       	mov	r25, r24
    ad70:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    ad72:	84 30       	cpi	r24, 0x04	; 4
    ad74:	59 f0       	breq	.+22     	; 0xad8c <GPRS_Param06+0x24>
    ad76:	87 30       	cpi	r24, 0x07	; 7
    ad78:	69 f0       	breq	.+26     	; 0xad94 <GPRS_Param06+0x2c>
    ad7a:	81 30       	cpi	r24, 0x01	; 1
    ad7c:	21 f0       	breq	.+8      	; 0xad86 <GPRS_Param06+0x1e>
    ad7e:	40 e0       	ldi	r20, 0x00	; 0
    ad80:	50 e0       	ldi	r21, 0x00	; 0
    ad82:	20 e0       	ldi	r18, 0x00	; 0
    ad84:	0a c0       	rjmp	.+20     	; 0xad9a <GPRS_Param06+0x32>
    ad86:	48 e2       	ldi	r20, 0x28	; 40
    ad88:	51 e0       	ldi	r21, 0x01	; 1
    ad8a:	02 c0       	rjmp	.+4      	; 0xad90 <GPRS_Param06+0x28>
    ad8c:	49 e2       	ldi	r20, 0x29	; 41
    ad8e:	51 e0       	ldi	r21, 0x01	; 1
    ad90:	21 e0       	ldi	r18, 0x01	; 1
    ad92:	03 c0       	rjmp	.+6      	; 0xad9a <GPRS_Param06+0x32>
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
    ad94:	4a e2       	ldi	r20, 0x2A	; 42
    ad96:	51 e0       	ldi	r21, 0x01	; 1
    ad98:	22 e0       	ldi	r18, 0x02	; 2
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    ad9a:	86 e0       	ldi	r24, 0x06	; 6
    ad9c:	69 2f       	mov	r22, r25
    ad9e:	ee 24       	eor	r14, r14
    ada0:	e3 94       	inc	r14
    ada2:	cc 24       	eor	r12, r12
    ada4:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ada8:	0f 91       	pop	r16
    adaa:	ef 90       	pop	r14
    adac:	cf 90       	pop	r12
    adae:	08 95       	ret

0000adb0 <GPRS_Param05>:
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
}

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    adb0:	cf 92       	push	r12
    adb2:	ef 92       	push	r14
    adb4:	0f 93       	push	r16
    adb6:	98 2f       	mov	r25, r24
    adb8:	06 2f       	mov	r16, r22
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    adba:	85 e0       	ldi	r24, 0x05	; 5
    adbc:	69 2f       	mov	r22, r25
    adbe:	40 e0       	ldi	r20, 0x00	; 0
    adc0:	50 e0       	ldi	r21, 0x00	; 0
    adc2:	20 e0       	ldi	r18, 0x00	; 0
    adc4:	ee 24       	eor	r14, r14
    adc6:	e3 94       	inc	r14
    adc8:	cc 24       	eor	r12, r12
    adca:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    adce:	0f 91       	pop	r16
    add0:	ef 90       	pop	r14
    add2:	cf 90       	pop	r12
    add4:	08 95       	ret

0000add6 <GPRS_Param04>:
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
}

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    add6:	cf 92       	push	r12
    add8:	ef 92       	push	r14
    adda:	0f 93       	push	r16
    addc:	98 2f       	mov	r25, r24
    adde:	06 2f       	mov	r16, r22
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    ade0:	84 e0       	ldi	r24, 0x04	; 4
    ade2:	69 2f       	mov	r22, r25
    ade4:	40 e0       	ldi	r20, 0x00	; 0
    ade6:	50 e0       	ldi	r21, 0x00	; 0
    ade8:	20 e0       	ldi	r18, 0x00	; 0
    adea:	ee 24       	eor	r14, r14
    adec:	e3 94       	inc	r14
    adee:	cc 24       	eor	r12, r12
    adf0:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    adf4:	0f 91       	pop	r16
    adf6:	ef 90       	pop	r14
    adf8:	cf 90       	pop	r12
    adfa:	08 95       	ret

0000adfc <GPRS_Param03>:
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
}
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    adfc:	cf 92       	push	r12
    adfe:	ef 92       	push	r14
    ae00:	0f 93       	push	r16
    ae02:	98 2f       	mov	r25, r24
    ae04:	06 2f       	mov	r16, r22
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    ae06:	83 e0       	ldi	r24, 0x03	; 3
    ae08:	69 2f       	mov	r22, r25
    ae0a:	40 e0       	ldi	r20, 0x00	; 0
    ae0c:	50 e0       	ldi	r21, 0x00	; 0
    ae0e:	20 e0       	ldi	r18, 0x00	; 0
    ae10:	ee 24       	eor	r14, r14
    ae12:	e3 94       	inc	r14
    ae14:	cc 24       	eor	r12, r12
    ae16:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ae1a:	0f 91       	pop	r16
    ae1c:	ef 90       	pop	r14
    ae1e:	cf 90       	pop	r12
    ae20:	08 95       	ret

0000ae22 <GPRS_Param02>:
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
}
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ae22:	cf 92       	push	r12
    ae24:	ef 92       	push	r14
    ae26:	0f 93       	push	r16
    ae28:	98 2f       	mov	r25, r24
    ae2a:	06 2f       	mov	r16, r22
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    ae2c:	82 e0       	ldi	r24, 0x02	; 2
    ae2e:	69 2f       	mov	r22, r25
    ae30:	40 e0       	ldi	r20, 0x00	; 0
    ae32:	50 e0       	ldi	r21, 0x00	; 0
    ae34:	21 e0       	ldi	r18, 0x01	; 1
    ae36:	ee 24       	eor	r14, r14
    ae38:	cc 24       	eor	r12, r12
    ae3a:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ae3e:	0f 91       	pop	r16
    ae40:	ef 90       	pop	r14
    ae42:	cf 90       	pop	r12
    ae44:	08 95       	ret

0000ae46 <GPRS_Param01>:
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
}
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    ae46:	cf 92       	push	r12
    ae48:	ef 92       	push	r14
    ae4a:	0f 93       	push	r16
    ae4c:	98 2f       	mov	r25, r24
    ae4e:	06 2f       	mov	r16, r22
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    ae50:	81 e0       	ldi	r24, 0x01	; 1
    ae52:	69 2f       	mov	r22, r25
    ae54:	40 e0       	ldi	r20, 0x00	; 0
    ae56:	50 e0       	ldi	r21, 0x00	; 0
    ae58:	20 e0       	ldi	r18, 0x00	; 0
    ae5a:	ee 24       	eor	r14, r14
    ae5c:	cc 24       	eor	r12, r12
    ae5e:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    ae62:	0f 91       	pop	r16
    ae64:	ef 90       	pop	r14
    ae66:	cf 90       	pop	r12
    ae68:	08 95       	ret

0000ae6a <GPRS_Param00>:
		}
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    ae6a:	cf 92       	push	r12
    ae6c:	ef 92       	push	r14
    ae6e:	0f 93       	push	r16
    ae70:	1f 93       	push	r17
    ae72:	18 2f       	mov	r17, r24
    ae74:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    ae76:	84 30       	cpi	r24, 0x04	; 4
    ae78:	89 f1       	breq	.+98     	; 0xaedc <GPRS_Param00+0x72>
    ae7a:	85 30       	cpi	r24, 0x05	; 5
    ae7c:	30 f4       	brcc	.+12     	; 0xae8a <GPRS_Param00+0x20>
    ae7e:	81 30       	cpi	r24, 0x01	; 1
    ae80:	61 f0       	breq	.+24     	; 0xae9a <GPRS_Param00+0x30>
    ae82:	82 30       	cpi	r24, 0x02	; 2
    ae84:	09 f0       	breq	.+2      	; 0xae88 <GPRS_Param00+0x1e>
    ae86:	51 c0       	rjmp	.+162    	; 0xaf2a <GPRS_Param00+0xc0>
    ae88:	12 c0       	rjmp	.+36     	; 0xaeae <GPRS_Param00+0x44>
    ae8a:	86 30       	cpi	r24, 0x06	; 6
    ae8c:	b9 f1       	breq	.+110    	; 0xaefc <GPRS_Param00+0x92>
    ae8e:	86 30       	cpi	r24, 0x06	; 6
    ae90:	68 f1       	brcs	.+90     	; 0xaeec <GPRS_Param00+0x82>
    ae92:	87 30       	cpi	r24, 0x07	; 7
    ae94:	09 f0       	breq	.+2      	; 0xae98 <GPRS_Param00+0x2e>
    ae96:	49 c0       	rjmp	.+146    	; 0xaf2a <GPRS_Param00+0xc0>
    ae98:	39 c0       	rjmp	.+114    	; 0xaf0c <GPRS_Param00+0xa2>
		case 1:	if(Cmd==READ_PARAM){
    ae9a:	61 3c       	cpi	r22, 0xC1	; 193
    ae9c:	09 f0       	breq	.+2      	; 0xaea0 <GPRS_Param00+0x36>
    ae9e:	45 c0       	rjmp	.+138    	; 0xaf2a <GPRS_Param00+0xc0>
					GPRS_ChangeData[9] = SW_VERSION;
    aea0:	83 e0       	ldi	r24, 0x03	; 3
    aea2:	80 93 c3 05 	sts	0x05C3, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    aea6:	85 e0       	ldi	r24, 0x05	; 5
    aea8:	80 93 c4 05 	sts	0x05C4, r24
    aeac:	15 c0       	rjmp	.+42     	; 0xaed8 <GPRS_Param00+0x6e>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    aeae:	61 3c       	cpi	r22, 0xC1	; 193
    aeb0:	49 f4       	brne	.+18     	; 0xaec4 <GPRS_Param00+0x5a>
    aeb2:	83 ec       	ldi	r24, 0xC3	; 195
    aeb4:	95 e0       	ldi	r25, 0x05	; 5
    aeb6:	68 e7       	ldi	r22, 0x78	; 120
    aeb8:	70 e0       	ldi	r23, 0x00	; 0
    aeba:	42 e0       	ldi	r20, 0x02	; 2
    aebc:	50 e0       	ldi	r21, 0x00	; 0
    aebe:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    aec2:	0a c0       	rjmp	.+20     	; 0xaed8 <GPRS_Param00+0x6e>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    aec4:	6c 34       	cpi	r22, 0x4C	; 76
    aec6:	41 f4       	brne	.+16     	; 0xaed8 <GPRS_Param00+0x6e>
    aec8:	85 ec       	ldi	r24, 0xC5	; 197
    aeca:	97 e0       	ldi	r25, 0x07	; 7
    aecc:	68 e7       	ldi	r22, 0x78	; 120
    aece:	70 e0       	ldi	r23, 0x00	; 0
    aed0:	42 e0       	ldi	r20, 0x02	; 2
    aed2:	50 e0       	ldi	r21, 0x00	; 0
    aed4:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
    aed8:	22 e0       	ldi	r18, 0x02	; 2
    aeda:	28 c0       	rjmp	.+80     	; 0xaf2c <GPRS_Param00+0xc2>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    aedc:	6c 34       	cpi	r22, 0x4C	; 76
    aede:	29 f5       	brne	.+74     	; 0xaf2a <GPRS_Param00+0xc0>
    aee0:	80 91 c5 07 	lds	r24, 0x07C5
    aee4:	88 23       	and	r24, r24
    aee6:	09 f1       	breq	.+66     	; 0xaf2a <GPRS_Param00+0xc0>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    aee8:	81 e0       	ldi	r24, 0x01	; 1
    aeea:	17 c0       	rjmp	.+46     	; 0xaf1a <GPRS_Param00+0xb0>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    aeec:	6c 34       	cpi	r22, 0x4C	; 76
    aeee:	e9 f4       	brne	.+58     	; 0xaf2a <GPRS_Param00+0xc0>
    aef0:	80 91 c5 07 	lds	r24, 0x07C5
    aef4:	88 23       	and	r24, r24
    aef6:	c9 f0       	breq	.+50     	; 0xaf2a <GPRS_Param00+0xc0>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    aef8:	82 e0       	ldi	r24, 0x02	; 2
    aefa:	0f c0       	rjmp	.+30     	; 0xaf1a <GPRS_Param00+0xb0>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    aefc:	6c 34       	cpi	r22, 0x4C	; 76
    aefe:	a9 f4       	brne	.+42     	; 0xaf2a <GPRS_Param00+0xc0>
    af00:	80 91 c5 07 	lds	r24, 0x07C5
    af04:	88 23       	and	r24, r24
    af06:	89 f0       	breq	.+34     	; 0xaf2a <GPRS_Param00+0xc0>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    af08:	83 e0       	ldi	r24, 0x03	; 3
    af0a:	07 c0       	rjmp	.+14     	; 0xaf1a <GPRS_Param00+0xb0>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    af0c:	6c 34       	cpi	r22, 0x4C	; 76
    af0e:	69 f4       	brne	.+26     	; 0xaf2a <GPRS_Param00+0xc0>
    af10:	80 91 c5 07 	lds	r24, 0x07C5
    af14:	88 23       	and	r24, r24
    af16:	49 f0       	breq	.+18     	; 0xaf2a <GPRS_Param00+0xc0>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    af18:	84 e0       	ldi	r24, 0x04	; 4
    af1a:	80 93 66 03 	sts	0x0366, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    af1e:	80 91 76 0a 	lds	r24, 0x0A76
    af22:	60 e9       	ldi	r22, 0x90	; 144
    af24:	71 e0       	ldi	r23, 0x01	; 1
    af26:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    af2a:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    af2c:	80 e0       	ldi	r24, 0x00	; 0
    af2e:	61 2f       	mov	r22, r17
    af30:	40 e0       	ldi	r20, 0x00	; 0
    af32:	50 e0       	ldi	r21, 0x00	; 0
    af34:	ee 24       	eor	r14, r14
    af36:	cc 24       	eor	r12, r12
    af38:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
}
    af3c:	1f 91       	pop	r17
    af3e:	0f 91       	pop	r16
    af40:	ef 90       	pop	r14
    af42:	cf 90       	pop	r12
    af44:	08 95       	ret

0000af46 <GPRS_SendDisplay>:
//	if ( (GPRS_Data_In[7]<=6) && (GPRS_Data_In[7]!=0) ) rkey = 1<<(GPRS_Data_In[7]-1);
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
    af46:	0f 93       	push	r16
    af48:	1f 93       	push	r17
	GPRS_Data_Out[0] = 5;	//    
    af4a:	85 e0       	ldi	r24, 0x05	; 5
    af4c:	80 93 a1 0a 	sts	0x0AA1, r24
	GPRS_Data_Out[1] = 1;	//   
    af50:	81 e0       	ldi	r24, 0x01	; 1
    af52:	80 93 a2 0a 	sts	0x0AA2, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    af56:	08 e7       	ldi	r16, 0x78	; 120
    af58:	10 e0       	ldi	r17, 0x00	; 0
    af5a:	c8 01       	movw	r24, r16
    af5c:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    af60:	90 93 a3 0a 	sts	0x0AA3, r25
    af64:	c8 01       	movw	r24, r16
    af66:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    af6a:	80 93 a4 0a 	sts	0x0AA4, r24
	GPRS_Data_Out[4] = 3;
    af6e:	83 e0       	ldi	r24, 0x03	; 3
    af70:	80 93 a5 0a 	sts	0x0AA5, r24
	GPRS_Data_Out[5] = 34;
    af74:	82 e2       	ldi	r24, 0x22	; 34
    af76:	80 93 a6 0a 	sts	0x0AA6, r24
	GPRS_Data_Out[6] = 10;
    af7a:	8a e0       	ldi	r24, 0x0A	; 10
    af7c:	80 93 a7 0a 	sts	0x0AA7, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    af80:	80 93 a8 0a 	sts	0x0AA8, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    af84:	88 e2       	ldi	r24, 0x28	; 40
    af86:	80 93 b4 08 	sts	0x08B4, r24
}
    af8a:	1f 91       	pop	r17
    af8c:	0f 91       	pop	r16
    af8e:	08 95       	ret

0000af90 <GPRS_Get_Session_ID>:
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    af90:	80 91 d6 08 	lds	r24, 0x08D6
    af94:	83 ff       	sbrs	r24, 3
    af96:	05 c0       	rjmp	.+10     	; 0xafa2 <GPRS_Get_Session_ID+0x12>
    af98:	10 92 7a 0a 	sts	0x0A7A, r1
    af9c:	10 92 79 0a 	sts	0x0A79, r1
    afa0:	16 c0       	rjmp	.+44     	; 0xafce <GPRS_Get_Session_ID+0x3e>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    afa2:	e0 91 bd 08 	lds	r30, 0x08BD

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    afa6:	8f b7       	in	r24, 0x3f	; 63
    afa8:	80 78       	andi	r24, 0x80	; 128
    afaa:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    afae:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
	uint16_t Time = Timer16[TimerN];
    afb0:	f0 e0       	ldi	r31, 0x00	; 0
    afb2:	ee 0f       	add	r30, r30
    afb4:	ff 1f       	adc	r31, r31
    afb6:	eb 5d       	subi	r30, 0xDB	; 219
    afb8:	fd 4f       	sbci	r31, 0xFD	; 253
    afba:	01 90       	ld	r0, Z+
    afbc:	f0 81       	ld	r31, Z
    afbe:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    afc0:	88 23       	and	r24, r24
    afc2:	09 f0       	breq	.+2      	; 0xafc6 <GPRS_Get_Session_ID+0x36>
		sei();
    afc4:	78 94       	sei
    afc6:	f0 93 7a 0a 	sts	0x0A7A, r31
    afca:	e0 93 79 0a 	sts	0x0A79, r30
	GPRS_Data_Out[0] = 5;	//    
    afce:	85 e0       	ldi	r24, 0x05	; 5
    afd0:	80 93 a1 0a 	sts	0x0AA1, r24
	GPRS_Data_Out[1] = 1;	//   
    afd4:	81 e0       	ldi	r24, 0x01	; 1
    afd6:	80 93 a2 0a 	sts	0x0AA2, r24
    afda:	88 e7       	ldi	r24, 0x78	; 120
    afdc:	90 e0       	ldi	r25, 0x00	; 0
    afde:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    afe2:	90 93 a3 0a 	sts	0x0AA3, r25
    afe6:	88 e7       	ldi	r24, 0x78	; 120
    afe8:	90 e0       	ldi	r25, 0x00	; 0
    afea:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    afee:	80 93 a4 0a 	sts	0x0AA4, r24
	GPRS_Data_Out[4] = 4;
    aff2:	84 e0       	ldi	r24, 0x04	; 4
    aff4:	80 93 a5 0a 	sts	0x0AA5, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    aff8:	90 91 79 0a 	lds	r25, 0x0A79
    affc:	80 91 7a 0a 	lds	r24, 0x0A7A
    b000:	80 93 a6 0a 	sts	0x0AA6, r24
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    b004:	90 93 a7 0a 	sts	0x0AA7, r25
	GPRS_FlgSz_Out = 7;					//    .     	
    b008:	87 e0       	ldi	r24, 0x07	; 7
    b00a:	80 93 b4 08 	sts	0x08B4, r24
}
    b00e:	08 95       	ret

0000b010 <GPRS_Check_SN>:
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
	return 0;
}
uint8_t GPRS_Check_SN(const uint16_t Pass){
    b010:	0f 93       	push	r16
    b012:	1f 93       	push	r17
    b014:	cf 93       	push	r28
    b016:	df 93       	push	r29
    b018:	8c 01       	movw	r16, r24
    b01a:	ce e7       	ldi	r28, 0x7E	; 126
    b01c:	d1 e0       	ldi	r29, 0x01	; 1
    b01e:	ce 01       	movw	r24, r28
    b020:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    b024:	08 17       	cp	r16, r24
    b026:	19 07       	cpc	r17, r25
    b028:	49 f0       	breq	.+18     	; 0xb03c <GPRS_Check_SN+0x2c>
    b02a:	22 96       	adiw	r28, 0x02	; 2
	}
	if(Pass == 22780) return 1;
	return 0;
}
uint8_t GPRS_Check_SN(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    b02c:	81 e0       	ldi	r24, 0x01	; 1
    b02e:	c6 38       	cpi	r28, 0x86	; 134
    b030:	d8 07       	cpc	r29, r24
    b032:	a9 f7       	brne	.-22     	; 0xb01e <GPRS_Check_SN+0xe>
    b034:	80 e0       	ldi	r24, 0x00	; 0
    b036:	0c 5f       	subi	r16, 0xFC	; 252
    b038:	18 45       	sbci	r17, 0x58	; 88
    b03a:	09 f4       	brne	.+2      	; 0xb03e <GPRS_Check_SN+0x2e>
    b03c:	81 e0       	ldi	r24, 0x01	; 1
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
	return 0;
}
    b03e:	df 91       	pop	r29
    b040:	cf 91       	pop	r28
    b042:	1f 91       	pop	r17
    b044:	0f 91       	pop	r16
    b046:	08 95       	ret

0000b048 <GPRS_Check_PSW>:
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    b048:	0f 93       	push	r16
    b04a:	1f 93       	push	r17
    b04c:	cf 93       	push	r28
    b04e:	df 93       	push	r29
    b050:	8c 01       	movw	r16, r24
    b052:	ce e7       	ldi	r28, 0x7E	; 126
    b054:	d1 e0       	ldi	r29, 0x01	; 1
    b056:	ce 01       	movw	r24, r28
    b058:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    b05c:	08 17       	cp	r16, r24
    b05e:	19 07       	cpc	r17, r25
    b060:	49 f0       	breq	.+18     	; 0xb074 <GPRS_Check_PSW+0x2c>
    b062:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    b064:	81 e0       	ldi	r24, 0x01	; 1
    b066:	c6 38       	cpi	r28, 0x86	; 134
    b068:	d8 07       	cpc	r29, r24
    b06a:	a9 f7       	brne	.-22     	; 0xb056 <GPRS_Check_PSW+0xe>
    b06c:	80 e0       	ldi	r24, 0x00	; 0
    b06e:	0c 5f       	subi	r16, 0xFC	; 252
    b070:	18 45       	sbci	r17, 0x58	; 88
    b072:	09 f4       	brne	.+2      	; 0xb076 <GPRS_Check_PSW+0x2e>
    b074:	81 e0       	ldi	r24, 0x01	; 1
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
	return 0;
}
    b076:	df 91       	pop	r29
    b078:	cf 91       	pop	r28
    b07a:	1f 91       	pop	r17
    b07c:	0f 91       	pop	r16
    b07e:	08 95       	ret

0000b080 <GPRS_AddHeader>:
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    b080:	bf 92       	push	r11
    b082:	cf 92       	push	r12
    b084:	df 92       	push	r13
    b086:	ef 92       	push	r14
    b088:	ff 92       	push	r15
    b08a:	0f 93       	push	r16
    b08c:	1f 93       	push	r17
    b08e:	8c 01       	movw	r16, r24
    b090:	c6 2e       	mov	r12, r22
    b092:	b4 2e       	mov	r11, r20
    b094:	d2 2e       	mov	r13, r18

	Buf[0] = 5;	
    b096:	85 e0       	ldi	r24, 0x05	; 5
    b098:	f8 01       	movw	r30, r16
    b09a:	80 83       	st	Z, r24
	Buf[1] = 1;	
    b09c:	81 e0       	ldi	r24, 0x01	; 1
    b09e:	81 83       	std	Z+1, r24	; 0x01
    b0a0:	78 e7       	ldi	r23, 0x78	; 120
    b0a2:	e7 2e       	mov	r14, r23
    b0a4:	70 e0       	ldi	r23, 0x00	; 0
    b0a6:	f7 2e       	mov	r15, r23
    b0a8:	c7 01       	movw	r24, r14
    b0aa:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    b0ae:	f8 01       	movw	r30, r16
    b0b0:	92 83       	std	Z+2, r25	; 0x02
    b0b2:	c7 01       	movw	r24, r14
    b0b4:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    b0b8:	f8 01       	movw	r30, r16
    b0ba:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    b0bc:	c4 82       	std	Z+4, r12	; 0x04
	Buf[5] = Size;	// -       
    b0be:	d5 82       	std	Z+5, r13	; 0x05
	Buf[6] = Func;		
    b0c0:	b6 82       	std	Z+6, r11	; 0x06
}
    b0c2:	1f 91       	pop	r17
    b0c4:	0f 91       	pop	r16
    b0c6:	ff 90       	pop	r15
    b0c8:	ef 90       	pop	r14
    b0ca:	df 90       	pop	r13
    b0cc:	cf 90       	pop	r12
    b0ce:	bf 90       	pop	r11
    b0d0:	08 95       	ret

0000b0d2 <EMeter_ReInit>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    b0d2:	8c 9a       	sbi	0x11, 4	; 17
    b0d4:	94 98       	cbi	0x12, 4	; 18
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    b0d6:	8d 9a       	sbi	0x11, 5	; 17
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    b0d8:	95 98       	cbi	0x12, 5	; 18

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    b0da:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    b0dc:	96 9a       	sbi	0x12, 6	; 18
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
    b0de:	8f ef       	ldi	r24, 0xFF	; 255
    b0e0:	80 93 dd 08 	sts	0x08DD, r24
	EM_RX_FIFO_End = 255;
    b0e4:	80 93 a0 0c 	sts	0x0CA0, r24
	EMeter_RxCharN = 0;
    b0e8:	10 92 a7 0c 	sts	0x0CA7, r1
    b0ec:	10 92 a6 0c 	sts	0x0CA6, r1
		RTS_Config();
	#endif

	EM_InitFIFO();

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    b0f0:	88 e9       	ldi	r24, 0x98	; 152
    b0f2:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    b0f6:	80 e4       	ldi	r24, 0x40	; 64
    b0f8:	80 93 9b 00 	sts	0x009B, r24
    b0fc:	8d e5       	ldi	r24, 0x5D	; 93
    b0fe:	91 e0       	ldi	r25, 0x01	; 1
    b100:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    b104:	0e 94 02 40 	call	0x8004	; 0x8004 <EM_SetUARTParam>
}
    b108:	08 95       	ret

0000b10a <GPRS_Param11>:
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    b10a:	cf 92       	push	r12
    b10c:	ef 92       	push	r14
    b10e:	0f 93       	push	r16
    b110:	1f 93       	push	r17
    b112:	18 2f       	mov	r17, r24
    b114:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    b116:	81 30       	cpi	r24, 0x01	; 1
    b118:	21 f0       	breq	.+8      	; 0xb122 <GPRS_Param11+0x18>
    b11a:	40 e0       	ldi	r20, 0x00	; 0
    b11c:	50 e0       	ldi	r21, 0x00	; 0
    b11e:	20 e0       	ldi	r18, 0x00	; 0
    b120:	03 c0       	rjmp	.+6      	; 0xb128 <GPRS_Param11+0x1e>
    b122:	4c e5       	ldi	r20, 0x5C	; 92
    b124:	51 e0       	ldi	r21, 0x01	; 1
    b126:	21 e0       	ldi	r18, 0x01	; 1
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    b128:	8b e0       	ldi	r24, 0x0B	; 11
    b12a:	61 2f       	mov	r22, r17
    b12c:	ee 24       	eor	r14, r14
    b12e:	e3 94       	inc	r14
    b130:	cc 24       	eor	r12, r12
    b132:	0e 94 76 55 	call	0xaaec	; 0xaaec <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    b136:	11 30       	cpi	r17, 0x01	; 1
    b138:	11 f4       	brne	.+4      	; 0xb13e <GPRS_Param11+0x34>
    b13a:	0e 94 69 58 	call	0xb0d2	; 0xb0d2 <EMeter_ReInit>
#endif
}
    b13e:	1f 91       	pop	r17
    b140:	0f 91       	pop	r16
    b142:	ef 90       	pop	r14
    b144:	cf 90       	pop	r12
    b146:	08 95       	ret

0000b148 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
    b148:	85 30       	cpi	r24, 0x05	; 5
    b14a:	e1 f1       	breq	.+120    	; 0xb1c4 <GPRS_Parameter+0x7c>
    b14c:	86 30       	cpi	r24, 0x06	; 6
    b14e:	80 f4       	brcc	.+32     	; 0xb170 <GPRS_Parameter+0x28>
    b150:	82 30       	cpi	r24, 0x02	; 2
    b152:	49 f1       	breq	.+82     	; 0xb1a6 <GPRS_Parameter+0x5e>
    b154:	83 30       	cpi	r24, 0x03	; 3
    b156:	30 f4       	brcc	.+12     	; 0xb164 <GPRS_Parameter+0x1c>
    b158:	88 23       	and	r24, r24
    b15a:	d9 f0       	breq	.+54     	; 0xb192 <GPRS_Parameter+0x4a>
    b15c:	81 30       	cpi	r24, 0x01	; 1
    b15e:	09 f0       	breq	.+2      	; 0xb162 <GPRS_Parameter+0x1a>
    b160:	53 c0       	rjmp	.+166    	; 0xb208 <GPRS_Parameter+0xc0>
    b162:	1c c0       	rjmp	.+56     	; 0xb19c <GPRS_Parameter+0x54>
    b164:	83 30       	cpi	r24, 0x03	; 3
    b166:	21 f1       	breq	.+72     	; 0xb1b0 <GPRS_Parameter+0x68>
    b168:	84 30       	cpi	r24, 0x04	; 4
    b16a:	09 f0       	breq	.+2      	; 0xb16e <GPRS_Parameter+0x26>
    b16c:	4d c0       	rjmp	.+154    	; 0xb208 <GPRS_Parameter+0xc0>
    b16e:	25 c0       	rjmp	.+74     	; 0xb1ba <GPRS_Parameter+0x72>
    b170:	88 30       	cpi	r24, 0x08	; 8
    b172:	b9 f1       	breq	.+110    	; 0xb1e2 <GPRS_Parameter+0x9a>
    b174:	89 30       	cpi	r24, 0x09	; 9
    b176:	30 f4       	brcc	.+12     	; 0xb184 <GPRS_Parameter+0x3c>
    b178:	86 30       	cpi	r24, 0x06	; 6
    b17a:	49 f1       	breq	.+82     	; 0xb1ce <GPRS_Parameter+0x86>
    b17c:	87 30       	cpi	r24, 0x07	; 7
    b17e:	09 f0       	breq	.+2      	; 0xb182 <GPRS_Parameter+0x3a>
    b180:	43 c0       	rjmp	.+134    	; 0xb208 <GPRS_Parameter+0xc0>
    b182:	2a c0       	rjmp	.+84     	; 0xb1d8 <GPRS_Parameter+0x90>
    b184:	8a 30       	cpi	r24, 0x0A	; 10
    b186:	b9 f1       	breq	.+110    	; 0xb1f6 <GPRS_Parameter+0xae>
    b188:	8a 30       	cpi	r24, 0x0A	; 10
    b18a:	80 f1       	brcs	.+96     	; 0xb1ec <GPRS_Parameter+0xa4>
    b18c:	8b 30       	cpi	r24, 0x0B	; 11
    b18e:	e1 f5       	brne	.+120    	; 0xb208 <GPRS_Parameter+0xc0>
    b190:	37 c0       	rjmp	.+110    	; 0xb200 <GPRS_Parameter+0xb8>
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    b192:	86 2f       	mov	r24, r22
    b194:	64 2f       	mov	r22, r20
    b196:	0e 94 35 57 	call	0xae6a	; 0xae6a <GPRS_Param00>
    b19a:	08 95       	ret
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    b19c:	86 2f       	mov	r24, r22
    b19e:	64 2f       	mov	r22, r20
    b1a0:	0e 94 23 57 	call	0xae46	; 0xae46 <GPRS_Param01>
    b1a4:	08 95       	ret
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    b1a6:	86 2f       	mov	r24, r22
    b1a8:	64 2f       	mov	r22, r20
    b1aa:	0e 94 11 57 	call	0xae22	; 0xae22 <GPRS_Param02>
    b1ae:	08 95       	ret
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    b1b0:	86 2f       	mov	r24, r22
    b1b2:	64 2f       	mov	r22, r20
    b1b4:	0e 94 fe 56 	call	0xadfc	; 0xadfc <GPRS_Param03>
    b1b8:	08 95       	ret
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    b1ba:	86 2f       	mov	r24, r22
    b1bc:	64 2f       	mov	r22, r20
    b1be:	0e 94 eb 56 	call	0xadd6	; 0xadd6 <GPRS_Param04>
    b1c2:	08 95       	ret
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    b1c4:	86 2f       	mov	r24, r22
    b1c6:	64 2f       	mov	r22, r20
    b1c8:	0e 94 d8 56 	call	0xadb0	; 0xadb0 <GPRS_Param05>
    b1cc:	08 95       	ret
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    b1ce:	86 2f       	mov	r24, r22
    b1d0:	64 2f       	mov	r22, r20
    b1d2:	0e 94 b4 56 	call	0xad68	; 0xad68 <GPRS_Param06>
    b1d6:	08 95       	ret
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    b1d8:	86 2f       	mov	r24, r22
    b1da:	64 2f       	mov	r22, r20
    b1dc:	0e 94 a1 56 	call	0xad42	; 0xad42 <GPRS_Param07>
    b1e0:	08 95       	ret
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    b1e2:	86 2f       	mov	r24, r22
    b1e4:	64 2f       	mov	r22, r20
    b1e6:	0e 94 8e 56 	call	0xad1c	; 0xad1c <GPRS_Param08>
    b1ea:	08 95       	ret
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    b1ec:	86 2f       	mov	r24, r22
    b1ee:	64 2f       	mov	r22, r20
    b1f0:	0e 94 f7 55 	call	0xabee	; 0xabee <GPRS_Param09>
    b1f4:	08 95       	ret
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    b1f6:	86 2f       	mov	r24, r22
    b1f8:	64 2f       	mov	r22, r20
    b1fa:	0e 94 c7 55 	call	0xab8e	; 0xab8e <GPRS_Param10>
    b1fe:	08 95       	ret
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    b200:	86 2f       	mov	r24, r22
    b202:	64 2f       	mov	r22, r20
    b204:	0e 94 85 58 	call	0xb10a	; 0xb10a <GPRS_Param11>
    b208:	08 95       	ret

0000b20a <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    b20a:	80 91 e0 09 	lds	r24, 0x09E0
    b20e:	88 23       	and	r24, r24
    b210:	31 f0       	breq	.+12     	; 0xb21e <GSM_CloseTransparent+0x14>
		
		cli();		
    b212:	f8 94       	cli
		Transparent = 0;
    b214:	10 92 e0 09 	sts	0x09E0, r1
		EMeter_ReInit();
    b218:	0e 94 69 58 	call	0xb0d2	; 0xb0d2 <EMeter_ReInit>
		sei();
    b21c:	78 94       	sei
		
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    b21e:	80 91 5b 03 	lds	r24, 0x035B
    b222:	6f ef       	ldi	r22, 0xFF	; 255
    b224:	7f ef       	ldi	r23, 0xFF	; 255
    b226:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
}
    b22a:	08 95       	ret

0000b22c <GSM_Transparent2Modbus>:
// ~~~~~~~~~~~
void GSM_Transparent2Modbus(void)
{
	GSM_CloseTransparent();	
    b22c:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
	GSM_State = GSM_Swtch2CommandMode;
    b230:	84 e5       	ldi	r24, 0x54	; 84
    b232:	80 93 a4 05 	sts	0x05A4, r24
}
    b236:	08 95       	ret

0000b238 <ApplyUARTParam>:
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
	eww(&EM_UART_Param, Temp16);
    b238:	70 91 89 05 	lds	r23, 0x0589
    b23c:	60 e0       	ldi	r22, 0x00	; 0
    b23e:	20 91 b3 08 	lds	r18, 0x08B3
    b242:	92 2f       	mov	r25, r18
    b244:	99 0f       	add	r25, r25
    b246:	99 0f       	add	r25, r25
    b248:	80 e0       	ldi	r24, 0x00	; 0
    b24a:	68 0f       	add	r22, r24
    b24c:	79 1f       	adc	r23, r25
    b24e:	80 91 d6 09 	lds	r24, 0x09D6
    b252:	68 0f       	add	r22, r24
    b254:	71 1d       	adc	r23, r1
    b256:	20 91 dc 09 	lds	r18, 0x09DC
    b25a:	92 2f       	mov	r25, r18
    b25c:	99 0f       	add	r25, r25
    b25e:	99 0f       	add	r25, r25
    b260:	99 0f       	add	r25, r25
    b262:	80 e0       	ldi	r24, 0x00	; 0
    b264:	68 0f       	add	r22, r24
    b266:	79 1f       	adc	r23, r25
    b268:	8d e5       	ldi	r24, 0x5D	; 93
    b26a:	91 e0       	ldi	r25, 0x01	; 1
    b26c:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    b270:	80 91 df 09 	lds	r24, 0x09DF
    b274:	88 23       	and	r24, r24
    b276:	31 f4       	brne	.+12     	; 0xb284 <ApplyUARTParam+0x4c>
    b278:	8d e5       	ldi	r24, 0x5D	; 93
    b27a:	91 e0       	ldi	r25, 0x01	; 1
    b27c:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    b280:	0e 94 02 40 	call	0x8004	; 0x8004 <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    b284:	0e 94 f1 53 	call	0xa7e2	; 0xa7e2 <Modbus_ReadHoldReg>
}
    b288:	08 95       	ret

0000b28a <EE_InterBrokLine>:
	uint8_t WiAbsc, uint16_t (*TblAbsc)[WiAbsc], uint8_t Absc,
	uint8_t WiOrdi, uint16_t (*TblOrdi)[WiOrdi], uint8_t Ordi,
	uint8_t Len,
	int16_t x
)
{
    b28a:	2f 92       	push	r2
    b28c:	3f 92       	push	r3
    b28e:	4f 92       	push	r4
    b290:	5f 92       	push	r5
    b292:	6f 92       	push	r6
    b294:	7f 92       	push	r7
    b296:	8f 92       	push	r8
    b298:	9f 92       	push	r9
    b29a:	af 92       	push	r10
    b29c:	bf 92       	push	r11
    b29e:	cf 92       	push	r12
    b2a0:	df 92       	push	r13
    b2a2:	ef 92       	push	r14
    b2a4:	ff 92       	push	r15
    b2a6:	0f 93       	push	r16
    b2a8:	1f 93       	push	r17
    b2aa:	df 93       	push	r29
    b2ac:	cf 93       	push	r28
    b2ae:	cd b7       	in	r28, 0x3d	; 61
    b2b0:	de b7       	in	r29, 0x3e	; 62
    b2b2:	2e 97       	sbiw	r28, 0x0e	; 14
    b2b4:	0f b6       	in	r0, 0x3f	; 63
    b2b6:	f8 94       	cli
    b2b8:	de bf       	out	0x3e, r29	; 62
    b2ba:	0f be       	out	0x3f, r0	; 63
    b2bc:	cd bf       	out	0x3d, r28	; 61
    b2be:	f8 2e       	mov	r15, r24
    b2c0:	2b 01       	movw	r4, r22
    b2c2:	2d 87       	std	Y+13, r18	; 0x0d
    b2c4:	18 01       	movw	r2, r16
    b2c6:	ee 86       	std	Y+14, r14	; 0x0e
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
    b2c8:	04 2f       	mov	r16, r20
    b2ca:	10 e0       	ldi	r17, 0x00	; 0
    b2cc:	c8 01       	movw	r24, r16
    b2ce:	88 0f       	add	r24, r24
    b2d0:	99 1f       	adc	r25, r25
    b2d2:	86 0f       	add	r24, r22
    b2d4:	97 1f       	adc	r25, r23
    b2d6:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    b2da:	aa 27       	eor	r26, r26
    b2dc:	97 fd       	sbrc	r25, 7
    b2de:	a0 95       	com	r26
    b2e0:	ba 2f       	mov	r27, r26
    b2e2:	8d 83       	std	Y+5, r24	; 0x05
    b2e4:	9e 83       	std	Y+6, r25	; 0x06
    b2e6:	af 83       	std	Y+7, r26	; 0x07
    b2e8:	b8 87       	std	Y+8, r27	; 0x08
    b2ea:	dd 24       	eor	r13, r13
    b2ec:	ef 2c       	mov	r14, r15
    b2ee:	ff 24       	eor	r15, r15
	do {
		Segm.x1 = Segm.x2;
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
	} while(x>Segm.x2 && i<Len);
    b2f0:	35 01       	movw	r6, r10
    b2f2:	88 24       	eor	r8, r8
    b2f4:	77 fc       	sbrc	r7, 7
    b2f6:	80 94       	com	r8
    b2f8:	98 2c       	mov	r9, r8
{
	LineGraph Segm;
	uint8_t i = 0;
	Segm.x2 = (int16_t)erw(TblAbsc[0]+Absc);
	do {
		Segm.x1 = Segm.x2;
    b2fa:	8d 81       	ldd	r24, Y+5	; 0x05
    b2fc:	9e 81       	ldd	r25, Y+6	; 0x06
    b2fe:	af 81       	ldd	r26, Y+7	; 0x07
    b300:	b8 85       	ldd	r27, Y+8	; 0x08
    b302:	89 83       	std	Y+1, r24	; 0x01
    b304:	9a 83       	std	Y+2, r25	; 0x02
    b306:	ab 83       	std	Y+3, r26	; 0x03
    b308:	bc 83       	std	Y+4, r27	; 0x04
		Segm.x2 = (int16_t)erw(TblAbsc[++i]+Absc);
    b30a:	d3 94       	inc	r13
    b30c:	ad 2c       	mov	r10, r13
    b30e:	bb 24       	eor	r11, r11
    b310:	ae 9c       	mul	r10, r14
    b312:	c0 01       	movw	r24, r0
    b314:	af 9c       	mul	r10, r15
    b316:	90 0d       	add	r25, r0
    b318:	be 9c       	mul	r11, r14
    b31a:	90 0d       	add	r25, r0
    b31c:	11 24       	eor	r1, r1
    b31e:	80 0f       	add	r24, r16
    b320:	91 1f       	adc	r25, r17
    b322:	88 0f       	add	r24, r24
    b324:	99 1f       	adc	r25, r25
    b326:	84 0d       	add	r24, r4
    b328:	95 1d       	adc	r25, r5
    b32a:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    b32e:	aa 27       	eor	r26, r26
    b330:	97 fd       	sbrc	r25, 7
    b332:	a0 95       	com	r26
    b334:	ba 2f       	mov	r27, r26
    b336:	8d 83       	std	Y+5, r24	; 0x05
    b338:	9e 83       	std	Y+6, r25	; 0x06
    b33a:	af 83       	std	Y+7, r26	; 0x07
    b33c:	b8 87       	std	Y+8, r27	; 0x08
	} while(x>Segm.x2 && i<Len);
    b33e:	86 15       	cp	r24, r6
    b340:	97 05       	cpc	r25, r7
    b342:	a8 05       	cpc	r26, r8
    b344:	b9 05       	cpc	r27, r9
    b346:	14 f4       	brge	.+4      	; 0xb34c <EE_InterBrokLine+0xc2>
    b348:	dc 14       	cp	r13, r12
    b34a:	b8 f2       	brcs	.-82     	; 0xb2fa <EE_InterBrokLine+0x70>
	Segm.y1 = (int16_t)erw(TblOrdi[i-1]+Ordi);
    b34c:	2d 85       	ldd	r18, Y+13	; 0x0d
    b34e:	02 2f       	mov	r16, r18
    b350:	10 e0       	ldi	r17, 0x00	; 0
    b352:	3e 85       	ldd	r19, Y+14	; 0x0e
    b354:	e3 2e       	mov	r14, r19
    b356:	ff 24       	eor	r15, r15
    b358:	8d 2d       	mov	r24, r13
    b35a:	90 e0       	ldi	r25, 0x00	; 0
    b35c:	01 97       	sbiw	r24, 0x01	; 1
    b35e:	9c 01       	movw	r18, r24
    b360:	20 9f       	mul	r18, r16
    b362:	c0 01       	movw	r24, r0
    b364:	21 9f       	mul	r18, r17
    b366:	90 0d       	add	r25, r0
    b368:	30 9f       	mul	r19, r16
    b36a:	90 0d       	add	r25, r0
    b36c:	11 24       	eor	r1, r1
    b36e:	8e 0d       	add	r24, r14
    b370:	9f 1d       	adc	r25, r15
    b372:	88 0f       	add	r24, r24
    b374:	99 1f       	adc	r25, r25
    b376:	82 0d       	add	r24, r2
    b378:	93 1d       	adc	r25, r3
    b37a:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    b37e:	9a 87       	std	Y+10, r25	; 0x0a
    b380:	89 87       	std	Y+9, r24	; 0x09
    b382:	a0 9e       	mul	r10, r16
    b384:	c0 01       	movw	r24, r0
    b386:	a1 9e       	mul	r10, r17
    b388:	90 0d       	add	r25, r0
    b38a:	b0 9e       	mul	r11, r16
    b38c:	90 0d       	add	r25, r0
    b38e:	11 24       	eor	r1, r1
    b390:	8e 0d       	add	r24, r14
    b392:	9f 1d       	adc	r25, r15
    b394:	88 0f       	add	r24, r24
    b396:	99 1f       	adc	r25, r25
    b398:	82 0d       	add	r24, r2
    b39a:	93 1d       	adc	r25, r3
    b39c:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	Segm.y2 = (int16_t)erw(TblOrdi[i]+Ordi);
    b3a0:	9c 87       	std	Y+12, r25	; 0x0c
    b3a2:	8b 87       	std	Y+11, r24	; 0x0b
	return LineFunc(&Segm, x);
    b3a4:	ce 01       	movw	r24, r28
    b3a6:	01 96       	adiw	r24, 0x01	; 1
    b3a8:	b4 01       	movw	r22, r8
    b3aa:	a3 01       	movw	r20, r6
    b3ac:	0e 94 1d 3b 	call	0x763a	; 0x763a <LineFunc>
}
    b3b0:	2e 96       	adiw	r28, 0x0e	; 14
    b3b2:	0f b6       	in	r0, 0x3f	; 63
    b3b4:	f8 94       	cli
    b3b6:	de bf       	out	0x3e, r29	; 62
    b3b8:	0f be       	out	0x3f, r0	; 63
    b3ba:	cd bf       	out	0x3d, r28	; 61
    b3bc:	cf 91       	pop	r28
    b3be:	df 91       	pop	r29
    b3c0:	1f 91       	pop	r17
    b3c2:	0f 91       	pop	r16
    b3c4:	ff 90       	pop	r15
    b3c6:	ef 90       	pop	r14
    b3c8:	df 90       	pop	r13
    b3ca:	cf 90       	pop	r12
    b3cc:	bf 90       	pop	r11
    b3ce:	af 90       	pop	r10
    b3d0:	9f 90       	pop	r9
    b3d2:	8f 90       	pop	r8
    b3d4:	7f 90       	pop	r7
    b3d6:	6f 90       	pop	r6
    b3d8:	5f 90       	pop	r5
    b3da:	4f 90       	pop	r4
    b3dc:	3f 90       	pop	r3
    b3de:	2f 90       	pop	r2
    b3e0:	08 95       	ret

0000b3e2 <MemCheck>:
}

// ~~~~~~~~~~~
uint8_t
MemCheck(void)
{
    b3e2:	0f 93       	push	r16
    b3e4:	1f 93       	push	r17
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    b3e6:	80 91 e1 09 	lds	r24, 0x09E1
    b3ea:	80 fd       	sbrc	r24, 0
    b3ec:	0f c0       	rjmp	.+30     	; 0xb40c <MemCheck+0x2a>
    b3ee:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <CRC_Flash_calc>
    b3f2:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b3f4:	8c e8       	ldi	r24, 0x8C	; 140
    b3f6:	91 e0       	ldi	r25, 0x01	; 1
    b3f8:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
MemCheck(void)
{
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
    b3fc:	08 17       	cp	r16, r24
    b3fe:	19 07       	cpc	r17, r25
    b400:	29 f0       	breq	.+10     	; 0xb40c <MemCheck+0x2a>
			MemFail |=(1<<MemFail_Flash);
    b402:	80 91 e1 09 	lds	r24, 0x09E1
    b406:	81 60       	ori	r24, 0x01	; 1
    b408:	80 93 e1 09 	sts	0x09E1, r24
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    b40c:	80 91 e1 09 	lds	r24, 0x09E1
    b410:	81 fd       	sbrc	r24, 1
    b412:	0f c0       	rjmp	.+30     	; 0xb432 <MemCheck+0x50>
    b414:	0e 94 b0 26 	call	0x4d60	; 0x4d60 <CRC_EEPROM_calc>
    b418:	8c 01       	movw	r16, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b41a:	8e e8       	ldi	r24, 0x8E	; 142
    b41c:	91 e0       	ldi	r25, 0x01	; 1
    b41e:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
//	uint8_t T = Timer32Stopp(TD_Mem);
//	if (T) {
//		StartTimer32(TD_Mem, 360000);
		if (!(MemFail &(1<<MemFail_Flash)) && CRC_Flash_calc()!=erw(&MemCheck_stor.CRC_Flash_stor))
			MemFail |=(1<<MemFail_Flash);
		if (!(MemFail &(1<<MemFail_EEPROM)) && CRC_EEPROM_calc()!=erw(&MemCheck_stor.CRC_EEPROM_stor))
    b422:	08 17       	cp	r16, r24
    b424:	19 07       	cpc	r17, r25
    b426:	29 f0       	breq	.+10     	; 0xb432 <MemCheck+0x50>
			MemFail |=(1<<MemFail_EEPROM);
    b428:	80 91 e1 09 	lds	r24, 0x09E1
    b42c:	82 60       	ori	r24, 0x02	; 2
    b42e:	80 93 e1 09 	sts	0x09E1, r24
//	}
//	return T && MemFail;
	return MemFail;
}
    b432:	80 91 e1 09 	lds	r24, 0x09E1
    b436:	1f 91       	pop	r17
    b438:	0f 91       	pop	r16
    b43a:	08 95       	ret

0000b43c <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b43c:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	//IntOn();
	return byte;
}
    b440:	08 95       	ret

0000b442 <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    b442:	1f 93       	push	r17
    b444:	18 2f       	mov	r17, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    b446:	82 30       	cpi	r24, 0x02	; 2
    b448:	09 f0       	breq	.+2      	; 0xb44c <ReadParamBlock+0xa>
    b44a:	80 c0       	rjmp	.+256    	; 0xb54c <ReadParamBlock+0x10a>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    b44c:	82 ec       	ldi	r24, 0xC2	; 194
    b44e:	95 e0       	ldi	r25, 0x05	; 5
    b450:	66 e0       	ldi	r22, 0x06	; 6
    b452:	70 e0       	ldi	r23, 0x00	; 0
    b454:	4f e0       	ldi	r20, 0x0F	; 15
    b456:	50 e0       	ldi	r21, 0x00	; 0
    b458:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    b45c:	81 ed       	ldi	r24, 0xD1	; 209
    b45e:	95 e0       	ldi	r25, 0x05	; 5
    b460:	68 ec       	ldi	r22, 0xC8	; 200
    b462:	71 e0       	ldi	r23, 0x01	; 1
    b464:	4f e0       	ldi	r20, 0x0F	; 15
    b466:	50 e0       	ldi	r21, 0x00	; 0
    b468:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b46c:	80 ee       	ldi	r24, 0xE0	; 224
    b46e:	95 e0       	ldi	r25, 0x05	; 5
    b470:	64 e2       	ldi	r22, 0x24	; 36
    b472:	70 e0       	ldi	r23, 0x00	; 0
    b474:	43 e1       	ldi	r20, 0x13	; 19
    b476:	50 e0       	ldi	r21, 0x00	; 0
    b478:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b47c:	83 ef       	ldi	r24, 0xF3	; 243
    b47e:	95 e0       	ldi	r25, 0x05	; 5
    b480:	68 e3       	ldi	r22, 0x38	; 56
    b482:	70 e0       	ldi	r23, 0x00	; 0
    b484:	44 e1       	ldi	r20, 0x14	; 20
    b486:	50 e0       	ldi	r21, 0x00	; 0
    b488:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b48c:	86 e0       	ldi	r24, 0x06	; 6
    b48e:	96 e0       	ldi	r25, 0x06	; 6
    b490:	6c e4       	ldi	r22, 0x4C	; 76
    b492:	70 e0       	ldi	r23, 0x00	; 0
    b494:	40 e1       	ldi	r20, 0x10	; 16
    b496:	50 e0       	ldi	r21, 0x00	; 0
    b498:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b49c:	86 e1       	ldi	r24, 0x16	; 22
    b49e:	96 e0       	ldi	r25, 0x06	; 6
    b4a0:	6c e5       	ldi	r22, 0x5C	; 92
    b4a2:	70 e0       	ldi	r23, 0x00	; 0
    b4a4:	48 e0       	ldi	r20, 0x08	; 8
    b4a6:	50 e0       	ldi	r21, 0x00	; 0
    b4a8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4ac:	8e e1       	ldi	r24, 0x1E	; 30
    b4ae:	96 e0       	ldi	r25, 0x06	; 6
    b4b0:	66 e6       	ldi	r22, 0x66	; 102
    b4b2:	70 e0       	ldi	r23, 0x00	; 0
    b4b4:	40 e1       	ldi	r20, 0x10	; 16
    b4b6:	50 e0       	ldi	r21, 0x00	; 0
    b4b8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4bc:	8e e2       	ldi	r24, 0x2E	; 46
    b4be:	96 e0       	ldi	r25, 0x06	; 6
    b4c0:	64 e6       	ldi	r22, 0x64	; 100
    b4c2:	70 e0       	ldi	r23, 0x00	; 0
    b4c4:	42 e0       	ldi	r20, 0x02	; 2
    b4c6:	50 e0       	ldi	r21, 0x00	; 0
    b4c8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4cc:	80 e3       	ldi	r24, 0x30	; 48
    b4ce:	96 e0       	ldi	r25, 0x06	; 6
    b4d0:	66 e7       	ldi	r22, 0x76	; 118
    b4d2:	70 e0       	ldi	r23, 0x00	; 0
    b4d4:	42 e0       	ldi	r20, 0x02	; 2
    b4d6:	50 e0       	ldi	r21, 0x00	; 0
    b4d8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4dc:	82 e3       	ldi	r24, 0x32	; 50
    b4de:	96 e0       	ldi	r25, 0x06	; 6
    b4e0:	65 e2       	ldi	r22, 0x25	; 37
    b4e2:	71 e0       	ldi	r23, 0x01	; 1
    b4e4:	41 e0       	ldi	r20, 0x01	; 1
    b4e6:	50 e0       	ldi	r21, 0x00	; 0
    b4e8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4ec:	83 e3       	ldi	r24, 0x33	; 51
    b4ee:	96 e0       	ldi	r25, 0x06	; 6
    b4f0:	6c e7       	ldi	r22, 0x7C	; 124
    b4f2:	70 e0       	ldi	r23, 0x00	; 0
    b4f4:	4c e0       	ldi	r20, 0x0C	; 12
    b4f6:	50 e0       	ldi	r21, 0x00	; 0
    b4f8:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b4fc:	8f e3       	ldi	r24, 0x3F	; 63
    b4fe:	96 e0       	ldi	r25, 0x06	; 6
    b500:	69 e8       	ldi	r22, 0x89	; 137
    b502:	70 e0       	ldi	r23, 0x00	; 0
    b504:	4c e0       	ldi	r20, 0x0C	; 12
    b506:	50 e0       	ldi	r21, 0x00	; 0
    b508:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b50c:	8b e4       	ldi	r24, 0x4B	; 75
    b50e:	96 e0       	ldi	r25, 0x06	; 6
    b510:	66 e9       	ldi	r22, 0x96	; 150
    b512:	70 e0       	ldi	r23, 0x00	; 0
    b514:	4c e0       	ldi	r20, 0x0C	; 12
    b516:	50 e0       	ldi	r21, 0x00	; 0
    b518:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b51c:	87 e5       	ldi	r24, 0x57	; 87
    b51e:	96 e0       	ldi	r25, 0x06	; 6
    b520:	6c e7       	ldi	r22, 0x7C	; 124
    b522:	71 e0       	ldi	r23, 0x01	; 1
    b524:	42 e0       	ldi	r20, 0x02	; 2
    b526:	50 e0       	ldi	r21, 0x00	; 0
    b528:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
    b52c:	10 93 c1 05 	sts	0x05C1, r17
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    b530:	8a eb       	ldi	r24, 0xBA	; 186
    b532:	95 e0       	ldi	r25, 0x05	; 5
    b534:	63 e0       	ldi	r22, 0x03	; 3
    b536:	41 e1       	ldi	r20, 0x11	; 17
    b538:	29 e9       	ldi	r18, 0x99	; 153
    b53a:	0e 94 40 58 	call	0xb080	; 0xb080 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    b53e:	80 91 ca 08 	lds	r24, 0x08CA
    b542:	88 60       	ori	r24, 0x08	; 8
    b544:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_ChangeReplySize = blocksize;
    b548:	8f e9       	ldi	r24, 0x9F	; 159
    b54a:	19 c0       	rjmp	.+50     	; 0xb57e <ReadParamBlock+0x13c>
	}

	if(Block == 3){
    b54c:	83 30       	cpi	r24, 0x03	; 3
    b54e:	11 f0       	breq	.+4      	; 0xb554 <ReadParamBlock+0x112>
    b550:	88 e0       	ldi	r24, 0x08	; 8
    b552:	17 c0       	rjmp	.+46     	; 0xb582 <ReadParamBlock+0x140>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b554:	8c e5       	ldi	r24, 0x5C	; 92
    b556:	91 e0       	ldi	r25, 0x01	; 1
    b558:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    b55c:	80 93 c2 05 	sts	0x05C2, r24

		GPRS_ChangeData[7] = Block;
    b560:	10 93 c1 05 	sts	0x05C1, r17
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    b564:	8a eb       	ldi	r24, 0xBA	; 186
    b566:	95 e0       	ldi	r25, 0x05	; 5
    b568:	63 e0       	ldi	r22, 0x03	; 3
    b56a:	41 e1       	ldi	r20, 0x11	; 17
    b56c:	23 e0       	ldi	r18, 0x03	; 3
    b56e:	0e 94 40 58 	call	0xb080	; 0xb080 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    b572:	80 91 ca 08 	lds	r24, 0x08CA
    b576:	88 60       	ori	r24, 0x08	; 8
    b578:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_ChangeReplySize = blocksize;
    b57c:	89 e0       	ldi	r24, 0x09	; 9
    b57e:	80 93 8e 05 	sts	0x058E, r24
	}

	return blocksize;
	
}
    b582:	1f 91       	pop	r17
    b584:	08 95       	ret

0000b586 <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    b586:	80 91 cb 08 	lds	r24, 0x08CB
    b58a:	88 23       	and	r24, r24
    b58c:	09 f4       	brne	.+2      	; 0xb590 <GPRS_ReciveData+0xa>
    b58e:	91 c0       	rjmp	.+290    	; 0xb6b2 <GPRS_ReciveData+0x12c>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    b590:	80 91 ba 07 	lds	r24, 0x07BA
    b594:	85 30       	cpi	r24, 0x05	; 5
    b596:	09 f0       	breq	.+2      	; 0xb59a <GPRS_ReciveData+0x14>
    b598:	8c c0       	rjmp	.+280    	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b59a:	80 91 bb 07 	lds	r24, 0x07BB
    b59e:	81 30       	cpi	r24, 0x01	; 1
    b5a0:	09 f0       	breq	.+2      	; 0xb5a4 <GPRS_ReciveData+0x1e>
    b5a2:	87 c0       	rjmp	.+270    	; 0xb6b2 <GPRS_ReciveData+0x12c>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
		if(GPRS_Check_PSW(Psw) == 0){
    b5a4:	90 91 bc 07 	lds	r25, 0x07BC
    b5a8:	80 e0       	ldi	r24, 0x00	; 0
    b5aa:	20 91 bd 07 	lds	r18, 0x07BD
    b5ae:	82 0f       	add	r24, r18
    b5b0:	91 1d       	adc	r25, r1
    b5b2:	0e 94 24 58 	call	0xb048	; 0xb048 <GPRS_Check_PSW>
    b5b6:	88 23       	and	r24, r24
    b5b8:	99 f1       	breq	.+102    	; 0xb620 <GPRS_ReciveData+0x9a>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    b5ba:	80 91 be 07 	lds	r24, 0x07BE
    b5be:	84 30       	cpi	r24, 0x04	; 4
    b5c0:	d9 f4       	brne	.+54     	; 0xb5f8 <GPRS_ReciveData+0x72>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b5c2:	88 e7       	ldi	r24, 0x78	; 120
    b5c4:	90 e0       	ldi	r25, 0x00	; 0
    b5c6:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    b5ca:	30 91 bf 07 	lds	r19, 0x07BF
    b5ce:	20 e0       	ldi	r18, 0x00	; 0
    b5d0:	40 91 c0 07 	lds	r20, 0x07C0
    b5d4:	24 0f       	add	r18, r20
    b5d6:	31 1d       	adc	r19, r1
    b5d8:	40 91 d6 08 	lds	r20, 0x08D6
    b5dc:	82 17       	cp	r24, r18
    b5de:	93 07       	cpc	r25, r19
    b5e0:	11 f4       	brne	.+4      	; 0xb5e6 <GPRS_ReciveData+0x60>
    b5e2:	47 7f       	andi	r20, 0xF7	; 247
    b5e4:	01 c0       	rjmp	.+2      	; 0xb5e8 <GPRS_ReciveData+0x62>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    b5e6:	48 60       	ori	r20, 0x08	; 8
    b5e8:	40 93 d6 08 	sts	0x08D6, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    b5ec:	80 91 ca 08 	lds	r24, 0x08CA
    b5f0:	80 61       	ori	r24, 0x10	; 16
    b5f2:	80 93 ca 08 	sts	0x08CA, r24
    b5f6:	5d c0       	rjmp	.+186    	; 0xb6b2 <GPRS_ReciveData+0x12c>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    b5f8:	83 30       	cpi	r24, 0x03	; 3
    b5fa:	09 f0       	breq	.+2      	; 0xb5fe <GPRS_ReciveData+0x78>
    b5fc:	5a c0       	rjmp	.+180    	; 0xb6b2 <GPRS_ReciveData+0x12c>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    b5fe:	40 91 79 0a 	lds	r20, 0x0A79
    b602:	50 91 7a 0a 	lds	r21, 0x0A7A
    b606:	41 15       	cp	r20, r1
    b608:	51 05       	cpc	r21, r1
    b60a:	51 f0       	breq	.+20     	; 0xb620 <GPRS_ReciveData+0x9a>
    b60c:	90 91 bf 07 	lds	r25, 0x07BF
    b610:	80 e0       	ldi	r24, 0x00	; 0
    b612:	20 91 c0 07 	lds	r18, 0x07C0
    b616:	82 0f       	add	r24, r18
    b618:	91 1d       	adc	r25, r1
    b61a:	48 17       	cp	r20, r24
    b61c:	59 07       	cpc	r21, r25
    b61e:	31 f0       	breq	.+12     	; 0xb62c <GPRS_ReciveData+0xa6>
				//    GPRS_Session_ID
				GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    b620:	80 91 d6 08 	lds	r24, 0x08D6
    b624:	88 60       	ori	r24, 0x08	; 8
    b626:	80 93 d6 08 	sts	0x08D6, r24
    b62a:	e0 cf       	rjmp	.-64     	; 0xb5ec <GPRS_ReciveData+0x66>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    b62c:	90 91 c1 07 	lds	r25, 0x07C1
			
			switch(GPRS_Data_In[8]){
    b630:	80 91 c2 07 	lds	r24, 0x07C2
    b634:	88 30       	cpi	r24, 0x08	; 8
    b636:	11 f1       	breq	.+68     	; 0xb67c <GPRS_ReciveData+0xf6>
    b638:	89 30       	cpi	r24, 0x09	; 9
    b63a:	28 f4       	brcc	.+10     	; 0xb646 <GPRS_ReciveData+0xc0>
    b63c:	81 30       	cpi	r24, 0x01	; 1
    b63e:	41 f0       	breq	.+16     	; 0xb650 <GPRS_ReciveData+0xca>
    b640:	87 30       	cpi	r24, 0x07	; 7
    b642:	b9 f5       	brne	.+110    	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b644:	0f c0       	rjmp	.+30     	; 0xb664 <GPRS_ReciveData+0xde>
    b646:	8a 30       	cpi	r24, 0x0A	; 10
    b648:	09 f1       	breq	.+66     	; 0xb68c <GPRS_ReciveData+0x106>
    b64a:	81 31       	cpi	r24, 0x11	; 17
    b64c:	91 f5       	brne	.+100    	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b64e:	27 c0       	rjmp	.+78     	; 0xb69e <GPRS_ReciveData+0x118>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    b650:	91 30       	cpi	r25, 0x01	; 1
    b652:	79 f5       	brne	.+94     	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b654:	80 91 cb 08 	lds	r24, 0x08CB
    b658:	89 30       	cpi	r24, 0x09	; 9
    b65a:	59 f5       	brne	.+86     	; 0xb6b2 <GPRS_ReciveData+0x12c>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    b65c:	80 91 ca 08 	lds	r24, 0x08CA
    b660:	82 60       	ori	r24, 0x02	; 2
    b662:	c7 cf       	rjmp	.-114    	; 0xb5f2 <GPRS_ReciveData+0x6c>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    b664:	93 30       	cpi	r25, 0x03	; 3
    b666:	29 f5       	brne	.+74     	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b668:	80 91 cb 08 	lds	r24, 0x08CB
    b66c:	8b 30       	cpi	r24, 0x0B	; 11
    b66e:	09 f5       	brne	.+66     	; 0xb6b2 <GPRS_ReciveData+0x12c>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    b670:	80 91 c3 07 	lds	r24, 0x07C3
    b674:	60 91 c4 07 	lds	r22, 0x07C4
    b678:	41 ec       	ldi	r20, 0xC1	; 193
    b67a:	05 c0       	rjmp	.+10     	; 0xb686 <GPRS_ReciveData+0x100>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    b67c:	80 91 c3 07 	lds	r24, 0x07C3
    b680:	60 91 c4 07 	lds	r22, 0x07C4
    b684:	4c e4       	ldi	r20, 0x4C	; 76
    b686:	0e 94 a4 58 	call	0xb148	; 0xb148 <GPRS_Parameter>
    b68a:	13 c0       	rjmp	.+38     	; 0xb6b2 <GPRS_ReciveData+0x12c>
				break;
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    b68c:	92 30       	cpi	r25, 0x02	; 2
    b68e:	89 f4       	brne	.+34     	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b690:	80 91 cb 08 	lds	r24, 0x08CB
    b694:	8a 30       	cpi	r24, 0x0A	; 10
    b696:	69 f4       	brne	.+26     	; 0xb6b2 <GPRS_ReciveData+0x12c>
					GPRS_RemoteDisplayControl();
    b698:	0e 94 f8 42 	call	0x85f0	; 0x85f0 <GPRS_RemoteDisplayControl>
    b69c:	0a c0       	rjmp	.+20     	; 0xb6b2 <GPRS_ReciveData+0x12c>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    b69e:	92 30       	cpi	r25, 0x02	; 2
    b6a0:	41 f4       	brne	.+16     	; 0xb6b2 <GPRS_ReciveData+0x12c>
    b6a2:	80 91 cb 08 	lds	r24, 0x08CB
    b6a6:	8a 30       	cpi	r24, 0x0A	; 10
    b6a8:	21 f4       	brne	.+8      	; 0xb6b2 <GPRS_ReciveData+0x12c>
					ReadParamBlock	(GPRS_Data_In[9]);
    b6aa:	80 91 c3 07 	lds	r24, 0x07C3
    b6ae:	0e 94 21 5a 	call	0xb442	; 0xb442 <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
	}//   
	else GPRS_FlgSz_In = 0;
    b6b2:	10 92 cb 08 	sts	0x08CB, r1
    b6b6:	08 95       	ret

0000b6b8 <GPRS_CurDataSend>:
}

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    b6b8:	cf 93       	push	r28
    b6ba:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    b6bc:	86 e0       	ldi	r24, 0x06	; 6
    b6be:	80 93 a1 0a 	sts	0x0AA1, r24
	GPRS_Data_Out[1] = 1;	//   
    b6c2:	91 e0       	ldi	r25, 0x01	; 1
    b6c4:	90 93 a2 0a 	sts	0x0AA2, r25
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    b6c8:	80 91 e5 08 	lds	r24, 0x08E5
    b6cc:	80 93 a3 0a 	sts	0x0AA3, r24
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    b6d0:	80 91 e4 08 	lds	r24, 0x08E4
    b6d4:	80 93 a4 0a 	sts	0x0AA4, r24
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    b6d8:	80 91 e3 08 	lds	r24, 0x08E3
    b6dc:	80 93 a5 0a 	sts	0x0AA5, r24
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    b6e0:	80 91 e2 08 	lds	r24, 0x08E2
    b6e4:	80 93 a6 0a 	sts	0x0AA6, r24
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    b6e8:	80 91 e1 08 	lds	r24, 0x08E1
    b6ec:	80 93 a7 0a 	sts	0x0AA7, r24
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    b6f0:	80 91 e0 08 	lds	r24, 0x08E0
    b6f4:	80 93 a8 0a 	sts	0x0AA8, r24
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    b6f8:	80 91 df 08 	lds	r24, 0x08DF
    b6fc:	80 93 a9 0a 	sts	0x0AA9, r24
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    b700:	80 91 de 08 	lds	r24, 0x08DE
    b704:	80 93 aa 0a 	sts	0x0AAA, r24

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    b708:	90 93 ab 0a 	sts	0x0AAB, r25
	GPRS_Data_Out[11] = SW_VERSION;		//   
    b70c:	83 e0       	ldi	r24, 0x03	; 3
    b70e:	80 93 ac 0a 	sts	0x0AAC, r24
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    b712:	85 e0       	ldi	r24, 0x05	; 5
    b714:	80 93 ad 0a 	sts	0x0AAD, r24

	GPRS_Data_Out[13] = 60;			// -       
    b718:	8c e3       	ldi	r24, 0x3C	; 60
    b71a:	80 93 ae 0a 	sts	0x0AAE, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    b71e:	80 91 84 0a 	lds	r24, 0x0A84
    b722:	80 93 af 0a 	sts	0x0AAF, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    b726:	80 91 85 0a 	lds	r24, 0x0A85
    b72a:	80 93 b0 0a 	sts	0x0AB0, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    b72e:	80 91 86 0a 	lds	r24, 0x0A86
    b732:	80 93 b1 0a 	sts	0x0AB1, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    b736:	80 91 87 0a 	lds	r24, 0x0A87
    b73a:	80 93 b2 0a 	sts	0x0AB2, r24

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    b73e:	80 91 d3 01 	lds	r24, 0x01D3
    b742:	88 23       	and	r24, r24
    b744:	09 f4       	brne	.+2      	; 0xb748 <GPRS_CurDataSend+0x90>
    b746:	d9 c1       	rjmp	.+946    	; 0xbafa <GPRS_CurDataSend+0x442>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    b748:	00 d0       	rcall	.+0      	; 0xb74a <GPRS_CurDataSend+0x92>
    b74a:	00 d0       	rcall	.+0      	; 0xb74c <GPRS_CurDataSend+0x94>
    b74c:	83 eb       	ldi	r24, 0xB3	; 179
    b74e:	9a e0       	ldi	r25, 0x0A	; 10
    b750:	ad b7       	in	r26, 0x3d	; 61
    b752:	be b7       	in	r27, 0x3e	; 62
    b754:	12 96       	adiw	r26, 0x02	; 2
    b756:	9c 93       	st	X, r25
    b758:	8e 93       	st	-X, r24
    b75a:	11 97       	sbiw	r26, 0x01	; 1
    b75c:	88 ea       	ldi	r24, 0xA8	; 168
    b75e:	98 e4       	ldi	r25, 0x48	; 72
    b760:	29 c0       	rjmp	.+82     	; 0xb7b4 <GPRS_CurDataSend+0xfc>
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       

	if(EMeter_Link()){
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    b762:	00 d0       	rcall	.+0      	; 0xb764 <GPRS_CurDataSend+0xac>
    b764:	00 d0       	rcall	.+0      	; 0xb766 <GPRS_CurDataSend+0xae>
    b766:	00 d0       	rcall	.+0      	; 0xb768 <GPRS_CurDataSend+0xb0>
    b768:	ed b7       	in	r30, 0x3d	; 61
    b76a:	fe b7       	in	r31, 0x3e	; 62
    b76c:	31 96       	adiw	r30, 0x01	; 1
    b76e:	ad b7       	in	r26, 0x3d	; 61
    b770:	be b7       	in	r27, 0x3e	; 62
    b772:	12 96       	adiw	r26, 0x02	; 2
    b774:	3c 93       	st	X, r19
    b776:	2e 93       	st	-X, r18
    b778:	11 97       	sbiw	r26, 0x01	; 1
    b77a:	88 ec       	ldi	r24, 0xC8	; 200
    b77c:	98 e4       	ldi	r25, 0x48	; 72
    b77e:	93 83       	std	Z+3, r25	; 0x03
    b780:	82 83       	std	Z+2, r24	; 0x02
    b782:	8f ee       	ldi	r24, 0xEF	; 239
    b784:	97 e0       	ldi	r25, 0x07	; 7
    b786:	95 83       	std	Z+5, r25	; 0x05
    b788:	84 83       	std	Z+4, r24	; 0x04
    b78a:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
    b78e:	ed b7       	in	r30, 0x3d	; 61
    b790:	fe b7       	in	r31, 0x3e	; 62
    b792:	36 96       	adiw	r30, 0x06	; 6
    b794:	0f b6       	in	r0, 0x3f	; 63
    b796:	f8 94       	cli
    b798:	fe bf       	out	0x3e, r31	; 62
    b79a:	0f be       	out	0x3f, r0	; 63
    b79c:	ed bf       	out	0x3d, r30	; 61
    b79e:	14 c0       	rjmp	.+40     	; 0xb7c8 <GPRS_CurDataSend+0x110>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    b7a0:	00 d0       	rcall	.+0      	; 0xb7a2 <GPRS_CurDataSend+0xea>
    b7a2:	00 d0       	rcall	.+0      	; 0xb7a4 <GPRS_CurDataSend+0xec>
    b7a4:	ad b7       	in	r26, 0x3d	; 61
    b7a6:	be b7       	in	r27, 0x3e	; 62
    b7a8:	12 96       	adiw	r26, 0x02	; 2
    b7aa:	3c 93       	st	X, r19
    b7ac:	2e 93       	st	-X, r18
    b7ae:	11 97       	sbiw	r26, 0x01	; 1
    b7b0:	88 eb       	ldi	r24, 0xB8	; 184
    b7b2:	98 e4       	ldi	r25, 0x48	; 72
    b7b4:	14 96       	adiw	r26, 0x04	; 4
    b7b6:	9c 93       	st	X, r25
    b7b8:	8e 93       	st	-X, r24
    b7ba:	13 97       	sbiw	r26, 0x03	; 3
    b7bc:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
    b7c0:	0f 90       	pop	r0
    b7c2:	0f 90       	pop	r0
    b7c4:	0f 90       	pop	r0
    b7c6:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    b7c8:	10 92 c3 0a 	sts	0x0AC3, r1
    b7cc:	10 92 c2 0a 	sts	0x0AC2, r1
    b7d0:	80 91 d3 01 	lds	r24, 0x01D3
    b7d4:	88 23       	and	r24, r24
    b7d6:	09 f4       	brne	.+2      	; 0xb7da <GPRS_CurDataSend+0x122>
    b7d8:	9a c1       	rjmp	.+820    	; 0xbb0e <GPRS_CurDataSend+0x456>
	if(!EMeter_Link()){
		ptr[0] |= (1<<0);
    b7da:	81 e0       	ldi	r24, 0x01	; 1
    b7dc:	90 e0       	ldi	r25, 0x00	; 0
    b7de:	b0 c0       	rjmp	.+352    	; 0xb940 <GPRS_CurDataSend+0x288>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    b7e0:	80 e2       	ldi	r24, 0x20	; 32
    b7e2:	90 e0       	ldi	r25, 0x00	; 0
    b7e4:	90 93 c3 0a 	sts	0x0AC3, r25
    b7e8:	80 93 c2 0a 	sts	0x0AC2, r24
		if(Ub==0) ptr[0] |= (1<<6);
    b7ec:	80 91 67 03 	lds	r24, 0x0367
    b7f0:	90 91 68 03 	lds	r25, 0x0368
    b7f4:	89 2b       	or	r24, r25
    b7f6:	49 f4       	brne	.+18     	; 0xb80a <GPRS_CurDataSend+0x152>
    b7f8:	80 91 c2 0a 	lds	r24, 0x0AC2
    b7fc:	90 91 c3 0a 	lds	r25, 0x0AC3
    b800:	80 64       	ori	r24, 0x40	; 64
    b802:	90 93 c3 0a 	sts	0x0AC3, r25
    b806:	80 93 c2 0a 	sts	0x0AC2, r24
		if(Uc==0) ptr[0] |= (1<<7);
    b80a:	80 91 dd 09 	lds	r24, 0x09DD
    b80e:	90 91 de 09 	lds	r25, 0x09DE
    b812:	89 2b       	or	r24, r25
    b814:	49 f4       	brne	.+18     	; 0xb828 <GPRS_CurDataSend+0x170>
    b816:	80 91 c2 0a 	lds	r24, 0x0AC2
    b81a:	90 91 c3 0a 	lds	r25, 0x0AC3
    b81e:	80 68       	ori	r24, 0x80	; 128
    b820:	90 93 c3 0a 	sts	0x0AC3, r25
    b824:	80 93 c2 0a 	sts	0x0AC2, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    b828:	20 91 cc 08 	lds	r18, 0x08CC
    b82c:	30 91 cd 08 	lds	r19, 0x08CD
    b830:	40 91 ce 08 	lds	r20, 0x08CE
    b834:	50 91 cf 08 	lds	r21, 0x08CF
    b838:	80 91 72 0a 	lds	r24, 0x0A72
    b83c:	90 91 73 0a 	lds	r25, 0x0A73
    b840:	a0 91 74 0a 	lds	r26, 0x0A74
    b844:	b0 91 75 0a 	lds	r27, 0x0A75
    b848:	28 17       	cp	r18, r24
    b84a:	39 07       	cpc	r19, r25
    b84c:	4a 07       	cpc	r20, r26
    b84e:	5b 07       	cpc	r21, r27
    b850:	59 f4       	brne	.+22     	; 0xb868 <GPRS_CurDataSend+0x1b0>
    b852:	20 91 b0 08 	lds	r18, 0x08B0
    b856:	30 91 b1 08 	lds	r19, 0x08B1
    b85a:	80 91 60 09 	lds	r24, 0x0960
    b85e:	90 91 61 09 	lds	r25, 0x0961
    b862:	28 17       	cp	r18, r24
    b864:	39 07       	cpc	r19, r25
    b866:	49 f0       	breq	.+18     	; 0xb87a <GPRS_CurDataSend+0x1c2>
    b868:	80 91 c2 0a 	lds	r24, 0x0AC2
    b86c:	90 91 c3 0a 	lds	r25, 0x0AC3
    b870:	91 60       	ori	r25, 0x01	; 1
    b872:	90 93 c3 0a 	sts	0x0AC3, r25
    b876:	80 93 c2 0a 	sts	0x0AC2, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    b87a:	20 91 88 0a 	lds	r18, 0x0A88
    b87e:	30 91 89 0a 	lds	r19, 0x0A89
    b882:	40 91 8a 0a 	lds	r20, 0x0A8A
    b886:	50 91 8b 0a 	lds	r21, 0x0A8B
    b88a:	80 91 59 09 	lds	r24, 0x0959
    b88e:	90 91 5a 09 	lds	r25, 0x095A
    b892:	a0 91 5b 09 	lds	r26, 0x095B
    b896:	b0 91 5c 09 	lds	r27, 0x095C
    b89a:	28 17       	cp	r18, r24
    b89c:	39 07       	cpc	r19, r25
    b89e:	4a 07       	cpc	r20, r26
    b8a0:	5b 07       	cpc	r21, r27
    b8a2:	59 f4       	brne	.+22     	; 0xb8ba <GPRS_CurDataSend+0x202>
    b8a4:	20 91 97 05 	lds	r18, 0x0597
    b8a8:	30 91 98 05 	lds	r19, 0x0598
    b8ac:	80 91 77 03 	lds	r24, 0x0377
    b8b0:	90 91 78 03 	lds	r25, 0x0378
    b8b4:	28 17       	cp	r18, r24
    b8b6:	39 07       	cpc	r19, r25
    b8b8:	49 f0       	breq	.+18     	; 0xb8cc <GPRS_CurDataSend+0x214>
    b8ba:	80 91 c2 0a 	lds	r24, 0x0AC2
    b8be:	90 91 c3 0a 	lds	r25, 0x0AC3
    b8c2:	92 60       	ori	r25, 0x02	; 2
    b8c4:	90 93 c3 0a 	sts	0x0AC3, r25
    b8c8:	80 93 c2 0a 	sts	0x0AC2, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    b8cc:	20 91 6e 03 	lds	r18, 0x036E
    b8d0:	30 91 6f 03 	lds	r19, 0x036F
    b8d4:	40 91 70 03 	lds	r20, 0x0370
    b8d8:	50 91 71 03 	lds	r21, 0x0371
    b8dc:	80 91 93 05 	lds	r24, 0x0593
    b8e0:	90 91 94 05 	lds	r25, 0x0594
    b8e4:	a0 91 95 05 	lds	r26, 0x0595
    b8e8:	b0 91 96 05 	lds	r27, 0x0596
    b8ec:	28 17       	cp	r18, r24
    b8ee:	39 07       	cpc	r19, r25
    b8f0:	4a 07       	cpc	r20, r26
    b8f2:	5b 07       	cpc	r21, r27
    b8f4:	59 f4       	brne	.+22     	; 0xb90c <GPRS_CurDataSend+0x254>
    b8f6:	20 91 82 0a 	lds	r18, 0x0A82
    b8fa:	30 91 83 0a 	lds	r19, 0x0A83
    b8fe:	80 91 aa 0c 	lds	r24, 0x0CAA
    b902:	90 91 ab 0c 	lds	r25, 0x0CAB
    b906:	28 17       	cp	r18, r24
    b908:	39 07       	cpc	r19, r25
    b90a:	49 f0       	breq	.+18     	; 0xb91e <GPRS_CurDataSend+0x266>
    b90c:	80 91 c2 0a 	lds	r24, 0x0AC2
    b910:	90 91 c3 0a 	lds	r25, 0x0AC3
    b914:	94 60       	ori	r25, 0x04	; 4
    b916:	90 93 c3 0a 	sts	0x0AC3, r25
    b91a:	80 93 c2 0a 	sts	0x0AC2, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    b91e:	80 91 c1 08 	lds	r24, 0x08C1
    b922:	90 91 c2 08 	lds	r25, 0x08C2
    b926:	a0 91 c3 08 	lds	r26, 0x08C3
    b92a:	b0 91 c4 08 	lds	r27, 0x08C4
    b92e:	00 97       	sbiw	r24, 0x00	; 0
    b930:	a1 05       	cpc	r26, r1
    b932:	b1 05       	cpc	r27, r1
    b934:	49 f0       	breq	.+18     	; 0xb948 <GPRS_CurDataSend+0x290>
    b936:	80 91 c2 0a 	lds	r24, 0x0AC2
    b93a:	90 91 c3 0a 	lds	r25, 0x0AC3
    b93e:	98 60       	ori	r25, 0x08	; 8
    b940:	90 93 c3 0a 	sts	0x0AC3, r25
    b944:	80 93 c2 0a 	sts	0x0AC2, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    b948:	80 e0       	ldi	r24, 0x00	; 0
    b94a:	0e 94 a5 39 	call	0x734a	; 0x734a <DI_Status>
    b94e:	88 23       	and	r24, r24
    b950:	49 f4       	brne	.+18     	; 0xb964 <GPRS_CurDataSend+0x2ac>
    b952:	80 91 c2 0a 	lds	r24, 0x0AC2
    b956:	90 91 c3 0a 	lds	r25, 0x0AC3
    b95a:	82 60       	ori	r24, 0x02	; 2
    b95c:	90 93 c3 0a 	sts	0x0AC3, r25
    b960:	80 93 c2 0a 	sts	0x0AC2, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    b964:	81 e0       	ldi	r24, 0x01	; 1
    b966:	0e 94 a5 39 	call	0x734a	; 0x734a <DI_Status>
    b96a:	88 23       	and	r24, r24
    b96c:	49 f4       	brne	.+18     	; 0xb980 <GPRS_CurDataSend+0x2c8>
    b96e:	80 91 c2 0a 	lds	r24, 0x0AC2
    b972:	90 91 c3 0a 	lds	r25, 0x0AC3
    b976:	84 60       	ori	r24, 0x04	; 4
    b978:	90 93 c3 0a 	sts	0x0AC3, r25
    b97c:	80 93 c2 0a 	sts	0x0AC2, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    b980:	c0 91 70 05 	lds	r28, 0x0570
    b984:	d0 91 71 05 	lds	r29, 0x0571
    b988:	ce 01       	movw	r24, r28
    b98a:	80 50       	subi	r24, 0x00	; 0
    b98c:	90 48       	sbci	r25, 0x80	; 128
    b98e:	02 97       	sbiw	r24, 0x02	; 2
    b990:	00 f1       	brcs	.+64     	; 0xb9d2 <GPRS_CurDataSend+0x31a>
    b992:	87 e7       	ldi	r24, 0x77	; 119
    b994:	91 e0       	ldi	r25, 0x01	; 1
    b996:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    b99a:	c8 17       	cp	r28, r24
    b99c:	d9 07       	cpc	r29, r25
    b99e:	4c f0       	brlt	.+18     	; 0xb9b2 <GPRS_CurDataSend+0x2fa>
    b9a0:	80 91 c2 0a 	lds	r24, 0x0AC2
    b9a4:	90 91 c3 0a 	lds	r25, 0x0AC3
    b9a8:	88 60       	ori	r24, 0x08	; 8
    b9aa:	90 93 c3 0a 	sts	0x0AC3, r25
    b9ae:	80 93 c2 0a 	sts	0x0AC2, r24
    b9b2:	89 e7       	ldi	r24, 0x79	; 121
    b9b4:	91 e0       	ldi	r25, 0x01	; 1
    b9b6:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    b9ba:	8c 17       	cp	r24, r28
    b9bc:	9d 07       	cpc	r25, r29
    b9be:	4c f0       	brlt	.+18     	; 0xb9d2 <GPRS_CurDataSend+0x31a>
    b9c0:	80 91 c2 0a 	lds	r24, 0x0AC2
    b9c4:	90 91 c3 0a 	lds	r25, 0x0AC3
    b9c8:	80 61       	ori	r24, 0x10	; 16
    b9ca:	90 93 c3 0a 	sts	0x0AC3, r25
    b9ce:	80 93 c2 0a 	sts	0x0AC2, r24
	}

	ptr[1] = Temperature[0];
    b9d2:	d0 93 c5 0a 	sts	0x0AC5, r29
    b9d6:	c0 93 c4 0a 	sts	0x0AC4, r28

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    b9da:	80 91 db 01 	lds	r24, 0x01DB
    b9de:	90 91 dc 01 	lds	r25, 0x01DC
    b9e2:	a0 91 dd 01 	lds	r26, 0x01DD
    b9e6:	b0 91 de 01 	lds	r27, 0x01DE
    b9ea:	80 93 c6 0a 	sts	0x0AC6, r24
    b9ee:	90 93 c7 0a 	sts	0x0AC7, r25
    b9f2:	a0 93 c8 0a 	sts	0x0AC8, r26
    b9f6:	b0 93 c9 0a 	sts	0x0AC9, r27
	pi4[1] = E_Meter_RAM.Am;
    b9fa:	80 91 df 01 	lds	r24, 0x01DF
    b9fe:	90 91 e0 01 	lds	r25, 0x01E0
    ba02:	a0 91 e1 01 	lds	r26, 0x01E1
    ba06:	b0 91 e2 01 	lds	r27, 0x01E2
    ba0a:	80 93 ca 0a 	sts	0x0ACA, r24
    ba0e:	90 93 cb 0a 	sts	0x0ACB, r25
    ba12:	a0 93 cc 0a 	sts	0x0ACC, r26
    ba16:	b0 93 cd 0a 	sts	0x0ACD, r27
	pi4[2] = E_Meter_RAM.Rp;
    ba1a:	80 91 e3 01 	lds	r24, 0x01E3
    ba1e:	90 91 e4 01 	lds	r25, 0x01E4
    ba22:	a0 91 e5 01 	lds	r26, 0x01E5
    ba26:	b0 91 e6 01 	lds	r27, 0x01E6
    ba2a:	80 93 ce 0a 	sts	0x0ACE, r24
    ba2e:	90 93 cf 0a 	sts	0x0ACF, r25
    ba32:	a0 93 d0 0a 	sts	0x0AD0, r26
    ba36:	b0 93 d1 0a 	sts	0x0AD1, r27
	pi4[3] = E_Meter_RAM.Rm;
    ba3a:	80 91 e7 01 	lds	r24, 0x01E7
    ba3e:	90 91 e8 01 	lds	r25, 0x01E8
    ba42:	a0 91 e9 01 	lds	r26, 0x01E9
    ba46:	b0 91 ea 01 	lds	r27, 0x01EA
    ba4a:	80 93 d2 0a 	sts	0x0AD2, r24
    ba4e:	90 93 d3 0a 	sts	0x0AD3, r25
    ba52:	a0 93 d4 0a 	sts	0x0AD4, r26
    ba56:	b0 93 d5 0a 	sts	0x0AD5, r27

	GPRS_Data_Out[53] = EM_Year;
    ba5a:	80 91 f1 08 	lds	r24, 0x08F1
    ba5e:	80 93 d6 0a 	sts	0x0AD6, r24
	GPRS_Data_Out[54] = EM_Month;
    ba62:	80 91 58 09 	lds	r24, 0x0958
    ba66:	80 93 d7 0a 	sts	0x0AD7, r24
	GPRS_Data_Out[55] = EM_Day;
    ba6a:	80 91 65 03 	lds	r24, 0x0365
    ba6e:	80 93 d8 0a 	sts	0x0AD8, r24
	GPRS_Data_Out[56] = EM_Hour;
    ba72:	80 91 dc 08 	lds	r24, 0x08DC
    ba76:	80 93 d9 0a 	sts	0x0AD9, r24
	GPRS_Data_Out[57] = EM_Min;
    ba7a:	80 91 bc 08 	lds	r24, 0x08BC
    ba7e:	80 93 da 0a 	sts	0x0ADA, r24
	GPRS_Data_Out[58] = EM_Sec;
    ba82:	80 91 8b 05 	lds	r24, 0x058B
    ba86:	80 93 db 0a 	sts	0x0ADB, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
    ba8a:	ec ed       	ldi	r30, 0xDC	; 220
    ba8c:	fa e0       	ldi	r31, 0x0A	; 10
	ptr[0] = EM_PowerActive;
    ba8e:	80 91 d9 09 	lds	r24, 0x09D9
    ba92:	90 91 da 09 	lds	r25, 0x09DA
    ba96:	90 93 dd 0a 	sts	0x0ADD, r25
    ba9a:	80 93 dc 0a 	sts	0x0ADC, r24
	ptr[1] = Ua;
    ba9e:	80 91 a8 0c 	lds	r24, 0x0CA8
    baa2:	90 91 a9 0c 	lds	r25, 0x0CA9
    baa6:	93 83       	std	Z+3, r25	; 0x03
    baa8:	82 83       	std	Z+2, r24	; 0x02
	ptr[2] = Ub;
    baaa:	80 91 67 03 	lds	r24, 0x0367
    baae:	90 91 68 03 	lds	r25, 0x0368
    bab2:	95 83       	std	Z+5, r25	; 0x05
    bab4:	84 83       	std	Z+4, r24	; 0x04
	ptr[3] = Uc;
    bab6:	80 91 dd 09 	lds	r24, 0x09DD
    baba:	90 91 de 09 	lds	r25, 0x09DE
    babe:	97 83       	std	Z+7, r25	; 0x07
    bac0:	86 83       	std	Z+6, r24	; 0x06
	ptr[4] = Ia;
    bac2:	80 91 75 03 	lds	r24, 0x0375
    bac6:	90 91 76 03 	lds	r25, 0x0376
    baca:	91 87       	std	Z+9, r25	; 0x09
    bacc:	80 87       	std	Z+8, r24	; 0x08
	ptr[5] = Ib;
    bace:	80 91 b6 08 	lds	r24, 0x08B6
    bad2:	90 91 b7 08 	lds	r25, 0x08B7
    bad6:	93 87       	std	Z+11, r25	; 0x0b
    bad8:	82 87       	std	Z+10, r24	; 0x0a
	ptr[6] = Ic;
    bada:	80 91 ec 08 	lds	r24, 0x08EC
    bade:	90 91 ed 08 	lds	r25, 0x08ED
    bae2:	95 87       	std	Z+13, r25	; 0x0d
    bae4:	84 87       	std	Z+12, r24	; 0x0c

	GPRS_Data_Out[73] = GSM_RSSI;
    bae6:	80 91 a2 05 	lds	r24, 0x05A2
    baea:	80 93 ea 0a 	sts	0x0AEA, r24

	GPRS_FlgSz_Out = 74;	//    .     
    baee:	8a e4       	ldi	r24, 0x4A	; 74
    baf0:	80 93 b4 08 	sts	0x08B4, r24
}
    baf4:	df 91       	pop	r29
    baf6:	cf 91       	pop	r28
    baf8:	08 95       	ret
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bafa:	8c e5       	ldi	r24, 0x5C	; 92
    bafc:	91 e0       	ldi	r25, 0x01	; 1
    bafe:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    bb02:	23 eb       	ldi	r18, 0xB3	; 179
    bb04:	3a e0       	ldi	r19, 0x0A	; 10
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       

	if(EMeter_Link()){
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    bb06:	81 30       	cpi	r24, 0x01	; 1
    bb08:	09 f0       	breq	.+2      	; 0xbb0c <GPRS_CurDataSend+0x454>
    bb0a:	4a ce       	rjmp	.-876    	; 0xb7a0 <GPRS_CurDataSend+0xe8>
    bb0c:	2a ce       	rjmp	.-940    	; 0xb762 <GPRS_CurDataSend+0xaa>
	ptr[0] = 0;
	if(!EMeter_Link()){
		ptr[0] |= (1<<0);
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    bb0e:	80 91 a8 0c 	lds	r24, 0x0CA8
    bb12:	90 91 a9 0c 	lds	r25, 0x0CA9
    bb16:	89 2b       	or	r24, r25
    bb18:	09 f4       	brne	.+2      	; 0xbb1c <GPRS_CurDataSend+0x464>
    bb1a:	62 ce       	rjmp	.-828    	; 0xb7e0 <GPRS_CurDataSend+0x128>
    bb1c:	67 ce       	rjmp	.-818    	; 0xb7ec <GPRS_CurDataSend+0x134>

0000bb1e <GPRS_Arbitr>:
		GPRS_FlgSz_In = 0;
	}//   
	else GPRS_FlgSz_In = 0;
}
// -----                  
void GPRS_Arbitr(void){
    bb1e:	1f 93       	push	r17
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    bb20:	80 91 ca 08 	lds	r24, 0x08CA
    bb24:	86 ff       	sbrs	r24, 6
    bb26:	06 c0       	rjmp	.+12     	; 0xbb34 <GPRS_Arbitr+0x16>
		GPRS_SendNewCrash();
    bb28:	0e 94 90 45 	call	0x8b20	; 0x8b20 <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    bb2c:	80 91 ca 08 	lds	r24, 0x08CA
    bb30:	8f 7b       	andi	r24, 0xBF	; 191
    bb32:	4e c0       	rjmp	.+156    	; 0xbbd0 <GPRS_Arbitr+0xb2>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    bb34:	85 ff       	sbrs	r24, 5
    bb36:	0d c0       	rjmp	.+26     	; 0xbb52 <GPRS_Arbitr+0x34>
		GPRS_SendRepCrash();
    bb38:	0e 94 7b 45 	call	0x8af6	; 0x8af6 <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    bb3c:	80 91 ca 08 	lds	r24, 0x08CA
    bb40:	8f 7d       	andi	r24, 0xDF	; 223
    bb42:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_Protocol_Out = UDP;
    bb46:	10 92 e7 08 	sts	0x08E7, r1
		IP_SendMask = 0b11111110;	//   IP1
    bb4a:	8e ef       	ldi	r24, 0xFE	; 254
    bb4c:	80 93 ec 07 	sts	0x07EC, r24
    bb50:	45 c0       	rjmp	.+138    	; 0xbbdc <GPRS_Arbitr+0xbe>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    bb52:	84 ff       	sbrs	r24, 4
    bb54:	06 c0       	rjmp	.+12     	; 0xbb62 <GPRS_Arbitr+0x44>
		GPRS_Get_Session_ID();
    bb56:	0e 94 c8 57 	call	0xaf90	; 0xaf90 <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    bb5a:	80 91 ca 08 	lds	r24, 0x08CA
    bb5e:	8f 7e       	andi	r24, 0xEF	; 239
    bb60:	2a c0       	rjmp	.+84     	; 0xbbb6 <GPRS_Arbitr+0x98>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    bb62:	83 ff       	sbrs	r24, 3
    bb64:	19 c0       	rjmp	.+50     	; 0xbb98 <GPRS_Arbitr+0x7a>
		GPRS_SendChange(GPRS_ChangeReplySize);
    bb66:	10 91 8e 05 	lds	r17, 0x058E
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    bb6a:	21 ea       	ldi	r18, 0xA1	; 161
    bb6c:	3a e0       	ldi	r19, 0x0A	; 10
    bb6e:	4a eb       	ldi	r20, 0xBA	; 186
    bb70:	55 e0       	ldi	r21, 0x05	; 5
    bb72:	c9 01       	movw	r24, r18
    bb74:	ba 01       	movw	r22, r20
    bb76:	41 2f       	mov	r20, r17
    bb78:	50 e0       	ldi	r21, 0x00	; 0
    bb7a:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    bb7e:	10 93 b4 08 	sts	0x08B4, r17
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
		GPRS_SendChange(GPRS_ChangeReplySize);
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    bb82:	80 91 ca 08 	lds	r24, 0x08CA
    bb86:	87 7f       	andi	r24, 0xF7	; 247
    bb88:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_Protocol_Out = TCP;
    bb8c:	81 e0       	ldi	r24, 0x01	; 1
    bb8e:	80 93 e7 08 	sts	0x08E7, r24
		GPRSOutLen = GPRS_FlgSz_Out;
    bb92:	10 93 e6 08 	sts	0x08E6, r17
    bb96:	26 c0       	rjmp	.+76     	; 0xbbe4 <GPRS_Arbitr+0xc6>
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    bb98:	82 ff       	sbrs	r24, 2
    bb9a:	06 c0       	rjmp	.+12     	; 0xbba8 <GPRS_Arbitr+0x8a>
		GPRS_SendDisplay();
    bb9c:	0e 94 a3 57 	call	0xaf46	; 0xaf46 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    bba0:	80 91 ca 08 	lds	r24, 0x08CA
    bba4:	8b 7f       	andi	r24, 0xFB	; 251
    bba6:	07 c0       	rjmp	.+14     	; 0xbbb6 <GPRS_Arbitr+0x98>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    bba8:	81 ff       	sbrs	r24, 1
    bbaa:	0b c0       	rjmp	.+22     	; 0xbbc2 <GPRS_Arbitr+0xa4>
		GPRS_CurDataSend();
    bbac:	0e 94 5c 5b 	call	0xb6b8	; 0xb6b8 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    bbb0:	80 91 ca 08 	lds	r24, 0x08CA
    bbb4:	8d 7f       	andi	r24, 0xFD	; 253
    bbb6:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_Protocol_Out = TCP;
    bbba:	81 e0       	ldi	r24, 0x01	; 1
    bbbc:	80 93 e7 08 	sts	0x08E7, r24
    bbc0:	0d c0       	rjmp	.+26     	; 0xbbdc <GPRS_Arbitr+0xbe>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    bbc2:	80 ff       	sbrs	r24, 0
    bbc4:	0f c0       	rjmp	.+30     	; 0xbbe4 <GPRS_Arbitr+0xc6>
		GPRS_CurDataSend();
    bbc6:	0e 94 5c 5b 	call	0xb6b8	; 0xb6b8 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    bbca:	80 91 ca 08 	lds	r24, 0x08CA
    bbce:	8e 7f       	andi	r24, 0xFE	; 254
    bbd0:	80 93 ca 08 	sts	0x08CA, r24
		GPRS_Protocol_Out = UDP;
    bbd4:	10 92 e7 08 	sts	0x08E7, r1
		IP_SendMask = 0;	//   IP
    bbd8:	10 92 ec 07 	sts	0x07EC, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    bbdc:	80 91 b4 08 	lds	r24, 0x08B4
    bbe0:	80 93 e6 08 	sts	0x08E6, r24
		return;
	}
}
    bbe4:	1f 91       	pop	r17
    bbe6:	08 95       	ret

0000bbe8 <EMeter_Cycle>:
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
}

// ~~~~~~~~~
void EMeter_Cycle(void){
    bbe8:	cf 92       	push	r12
    bbea:	df 92       	push	r13
    bbec:	ef 92       	push	r14
    bbee:	ff 92       	push	r15
    bbf0:	0f 93       	push	r16
    bbf2:	1f 93       	push	r17
    bbf4:	df 93       	push	r29
    bbf6:	cf 93       	push	r28
    bbf8:	cd b7       	in	r28, 0x3d	; 61
    bbfa:	de b7       	in	r29, 0x3e	; 62
    bbfc:	68 97       	sbiw	r28, 0x18	; 24
    bbfe:	0f b6       	in	r0, 0x3f	; 63
    bc00:	f8 94       	cli
    bc02:	de bf       	out	0x3e, r29	; 62
    bc04:	0f be       	out	0x3f, r0	; 63
    bc06:	cd bf       	out	0x3d, r28	; 61
    bc08:	8c e5       	ldi	r24, 0x5C	; 92
    bc0a:	91 e0       	ldi	r25, 0x01	; 1
    bc0c:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>

	static uint8_t RING_Retry;	//  ELVIN_MODEM

	EMeterTypeRAM = erb(&EMeterType);
    bc10:	80 93 72 03 	sts	0x0372, r24


	if(UART_Soft || Transparent){
    bc14:	80 91 df 09 	lds	r24, 0x09DF
    bc18:	88 23       	and	r24, r24
    bc1a:	11 f0       	breq	.+4      	; 0xbc20 <EMeter_Cycle+0x38>
    bc1c:	0c 94 c8 66 	jmp	0xcd90	; 0xcd90 <EMeter_Cycle+0x11a8>
    bc20:	80 91 e0 09 	lds	r24, 0x09E0
    bc24:	88 23       	and	r24, r24
    bc26:	11 f0       	breq	.+4      	; 0xbc2c <EMeter_Cycle+0x44>
    bc28:	0c 94 c8 66 	jmp	0xcd90	; 0xcd90 <EMeter_Cycle+0x11a8>
    bc2c:	8c e5       	ldi	r24, 0x5C	; 92
    bc2e:	91 e0       	ldi	r25, 0x01	; 1
    bc30:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	
	
	}
	else{

		if( erb(&EMeterType) == EM_NONE){
    bc34:	88 23       	and	r24, r24
    bc36:	21 f5       	brne	.+72     	; 0xbc80 <EMeter_Cycle+0x98>
			EMeter_RxCharN = 0;
    bc38:	10 92 a7 0c 	sts	0x0CA7, r1
    bc3c:	10 92 a6 0c 	sts	0x0CA6, r1
	//StartTimer16(TD_EMeter,1000);
	EM_Mode = 255;
}
// ~~~~~~~~~
void EMeter_ELVIN_Modem_NoLink(void){
	E_Meter_RAM.Ap = 0;
    bc40:	10 92 db 01 	sts	0x01DB, r1
    bc44:	10 92 dc 01 	sts	0x01DC, r1
    bc48:	10 92 dd 01 	sts	0x01DD, r1
    bc4c:	10 92 de 01 	sts	0x01DE, r1
	E_Meter_RAM.Am = 0;
    bc50:	10 92 df 01 	sts	0x01DF, r1
    bc54:	10 92 e0 01 	sts	0x01E0, r1
    bc58:	10 92 e1 01 	sts	0x01E1, r1
    bc5c:	10 92 e2 01 	sts	0x01E2, r1
	E_Meter_RAM.Rp = 0;
    bc60:	10 92 e3 01 	sts	0x01E3, r1
    bc64:	10 92 e4 01 	sts	0x01E4, r1
    bc68:	10 92 e5 01 	sts	0x01E5, r1
    bc6c:	10 92 e6 01 	sts	0x01E6, r1
	E_Meter_RAM.Rm = 0;
    bc70:	10 92 e7 01 	sts	0x01E7, r1
    bc74:	10 92 e8 01 	sts	0x01E8, r1
    bc78:	10 92 e9 01 	sts	0x01E9, r1
    bc7c:	10 92 ea 01 	sts	0x01EA, r1
    bc80:	8c e5       	ldi	r24, 0x5C	; 92
    bc82:	91 e0       	ldi	r25, 0x01	; 1
    bc84:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
			EMeter_RxCharN = 0;
			EMeter_ELVIN_Modem_NoLink();
		}

		//--- Landis&Gyr ZMR110
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    bc88:	81 30       	cpi	r24, 0x01	; 1
    bc8a:	09 f0       	breq	.+2      	; 0xbc8e <EMeter_Cycle+0xa6>
    bc8c:	bc c2       	rjmp	.+1400   	; 0xc206 <EMeter_Cycle+0x61e>
			switch(EM_Mode){
    bc8e:	80 91 db 09 	lds	r24, 0x09DB
    bc92:	82 30       	cpi	r24, 0x02	; 2
    bc94:	99 f1       	breq	.+102    	; 0xbcfc <EMeter_Cycle+0x114>
    bc96:	8f 3f       	cpi	r24, 0xFF	; 255
    bc98:	09 f4       	brne	.+2      	; 0xbc9c <EMeter_Cycle+0xb4>
    bc9a:	b5 c2       	rjmp	.+1386   	; 0xc206 <EMeter_Cycle+0x61e>
    bc9c:	81 30       	cpi	r24, 0x01	; 1
    bc9e:	09 f0       	breq	.+2      	; 0xbca2 <EMeter_Cycle+0xba>
    bca0:	94 c2       	rjmp	.+1320   	; 0xc1ca <EMeter_Cycle+0x5e2>

				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    bca2:	80 91 a0 0b 	lds	r24, 0x0BA0
    bca6:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    bcaa:	88 23       	and	r24, r24
    bcac:	09 f4       	brne	.+2      	; 0xbcb0 <EMeter_Cycle+0xc8>
    bcae:	ab c2       	rjmp	.+1366   	; 0xc206 <EMeter_Cycle+0x61e>
						EMeter_SendCR(EM_READ_DATA_REQ);
    bcb0:	80 e8       	ldi	r24, 0x80	; 128
    bcb2:	97 e0       	ldi	r25, 0x07	; 7
    bcb4:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
						StartTimer16(TD_EMeter,1000);
    bcb8:	80 91 a0 0b 	lds	r24, 0x0BA0
    bcbc:	68 ee       	ldi	r22, 0xE8	; 232
    bcbe:	73 e0       	ldi	r23, 0x03	; 3
    bcc0:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) LG_ZMR110_READ_FLAG[i] = 0;
    bcc4:	10 92 7f 05 	sts	0x057F, r1
    bcc8:	10 92 80 05 	sts	0x0580, r1
    bccc:	10 92 81 05 	sts	0x0581, r1
    bcd0:	10 92 82 05 	sts	0x0582, r1
						//EMeter_ClearRXStr();
						
						
						
							cli();
    bcd4:	f8 94       	cli
						EM_HalfBufferStart= EMeter_RxStr;//----    
    bcd6:	89 eb       	ldi	r24, 0xB9	; 185
    bcd8:	96 e0       	ldi	r25, 0x06	; 6
    bcda:	90 93 f3 08 	sts	0x08F3, r25
    bcde:	80 93 f2 08 	sts	0x08F2, r24
						EMeter_RxStr_Offset = EMeter_RxStr;
    bce2:	90 93 86 05 	sts	0x0586, r25
    bce6:	80 93 85 05 	sts	0x0585, r24
						EM_BufferReadEnable=0;//----- 
    bcea:	10 92 bf 08 	sts	0x08BF, r1
						EMeter_RxCharN=0;
    bcee:	10 92 a7 0c 	sts	0x0CA7, r1
    bcf2:	10 92 a6 0c 	sts	0x0CA6, r1
						sei();
    bcf6:	78 94       	sei


						EM_Mode = 2;
    bcf8:	82 e0       	ldi	r24, 0x02	; 2
    bcfa:	83 c2       	rjmp	.+1286   	; 0xc202 <EMeter_Cycle+0x61a>
					}
					break;
				case 2:
					if(EM_BufferReadEnable==1)
    bcfc:	80 91 bf 08 	lds	r24, 0x08BF
    bd00:	81 30       	cpi	r24, 0x01	; 1
    bd02:	09 f0       	breq	.+2      	; 0xbd06 <EMeter_Cycle+0x11e>
    bd04:	45 c2       	rjmp	.+1162   	; 0xc190 <EMeter_Cycle+0x5a8>
					{
												cli();
    bd06:	f8 94       	cli
												EMeter_RxStr[EM_RX_SIZE-1] = '\0';
    bd08:	10 92 b6 07 	sts	0x07B6, r1
												EMeter_RxStr[EM_RX_SIZE/2-1]='\0';//  
    bd0c:	10 92 37 07 	sts	0x0737, r1
												 //read & analyze data
					


												char *p; 
												p=strchr(EMeter_RxStr_Offset,'\n');
    bd10:	80 91 85 05 	lds	r24, 0x0585
    bd14:	90 91 86 05 	lds	r25, 0x0586
    bd18:	6a e0       	ldi	r22, 0x0A	; 10
    bd1a:	70 e0       	ldi	r23, 0x00	; 0
    bd1c:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    bd20:	6c 01       	movw	r12, r24
												sei();
    bd22:	78 94       	sei
												if(p != NULL){
    bd24:	89 2b       	or	r24, r25
    bd26:	09 f4       	brne	.+2      	; 0xbd2a <EMeter_Cycle+0x142>
    bd28:	33 c2       	rjmp	.+1126   	; 0xc190 <EMeter_Cycle+0x5a8>
													*p = '\0';
    bd2a:	d6 01       	movw	r26, r12
    bd2c:	1c 92       	st	X, r1
													// search for OBIS code
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_2)) 
    bd2e:	80 e0       	ldi	r24, 0x00	; 0
    bd30:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bd34:	88 23       	and	r24, r24
    bd36:	29 f4       	brne	.+10     	; 0xbd42 <EMeter_Cycle+0x15a>
														EMeter_ZMR110_Read_Date(EM_RESP_0_9_2, flg_OBIS_0_9_2);
    bd38:	81 ef       	ldi	r24, 0xF1	; 241
    bd3a:	96 e0       	ldi	r25, 0x06	; 6
    bd3c:	60 e0       	ldi	r22, 0x00	; 0
    bd3e:	0e 94 43 48 	call	0x9086	; 0x9086 <EMeter_ZMR110_Read_Date>
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_9_1)) 
    bd42:	81 e0       	ldi	r24, 0x01	; 1
    bd44:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bd48:	88 23       	and	r24, r24
    bd4a:	29 f4       	brne	.+10     	; 0xbd56 <EMeter_Cycle+0x16e>
														EMeter_ZMR110_Read_Time(EM_RESP_0_9_1, flg_OBIS_0_9_1);
    bd4c:	87 ef       	ldi	r24, 0xF7	; 247
    bd4e:	96 e0       	ldi	r25, 0x06	; 6
    bd50:	61 e0       	ldi	r22, 0x01	; 1
    bd52:	0e 94 e7 47 	call	0x8fce	; 0x8fce <EMeter_ZMR110_Read_Time>

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_1_8_0)) 
    bd56:	82 e0       	ldi	r24, 0x02	; 2
    bd58:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bd5c:	88 23       	and	r24, r24
    bd5e:	69 f4       	brne	.+26     	; 0xbd7a <EMeter_Cycle+0x192>
														E_Meter_RAM.Ap = EMeter_ZMR110_Data_ConvertQ(EM_RESP_1_8_0, flg_OBIS_1_8_0);
    bd60:	8d ef       	ldi	r24, 0xFD	; 253
    bd62:	96 e0       	ldi	r25, 0x06	; 6
    bd64:	62 e0       	ldi	r22, 0x02	; 2
    bd66:	0e 94 e4 46 	call	0x8dc8	; 0x8dc8 <EMeter_ZMR110_Data_ConvertQ>
    bd6a:	60 93 db 01 	sts	0x01DB, r22
    bd6e:	70 93 dc 01 	sts	0x01DC, r23
    bd72:	80 93 dd 01 	sts	0x01DD, r24
    bd76:	90 93 de 01 	sts	0x01DE, r25
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_2_8_0)) 
    bd7a:	85 e0       	ldi	r24, 0x05	; 5
    bd7c:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bd80:	88 23       	and	r24, r24
    bd82:	69 f4       	brne	.+26     	; 0xbd9e <EMeter_Cycle+0x1b6>
														E_Meter_RAM.Am = EMeter_ZMR110_Data_ConvertQ(EM_RESP_2_8_0, flg_OBIS_2_8_0);
    bd84:	83 e0       	ldi	r24, 0x03	; 3
    bd86:	97 e0       	ldi	r25, 0x07	; 7
    bd88:	65 e0       	ldi	r22, 0x05	; 5
    bd8a:	0e 94 e4 46 	call	0x8dc8	; 0x8dc8 <EMeter_ZMR110_Data_ConvertQ>
    bd8e:	60 93 df 01 	sts	0x01DF, r22
    bd92:	70 93 e0 01 	sts	0x01E0, r23
    bd96:	80 93 e1 01 	sts	0x01E1, r24
    bd9a:	90 93 e2 01 	sts	0x01E2, r25
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_3_8_0)) 
    bd9e:	83 e0       	ldi	r24, 0x03	; 3
    bda0:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bda4:	88 23       	and	r24, r24
    bda6:	69 f4       	brne	.+26     	; 0xbdc2 <EMeter_Cycle+0x1da>
														E_Meter_RAM.Rp = EMeter_ZMR110_Data_ConvertQ(EM_RESP_3_8_0, flg_OBIS_3_8_0);
    bda8:	89 e0       	ldi	r24, 0x09	; 9
    bdaa:	97 e0       	ldi	r25, 0x07	; 7
    bdac:	63 e0       	ldi	r22, 0x03	; 3
    bdae:	0e 94 e4 46 	call	0x8dc8	; 0x8dc8 <EMeter_ZMR110_Data_ConvertQ>
    bdb2:	60 93 e3 01 	sts	0x01E3, r22
    bdb6:	70 93 e4 01 	sts	0x01E4, r23
    bdba:	80 93 e5 01 	sts	0x01E5, r24
    bdbe:	90 93 e6 01 	sts	0x01E6, r25
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_4_8_0)) 
    bdc2:	84 e0       	ldi	r24, 0x04	; 4
    bdc4:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bdc8:	88 23       	and	r24, r24
    bdca:	69 f4       	brne	.+26     	; 0xbde6 <EMeter_Cycle+0x1fe>
														E_Meter_RAM.Rm = EMeter_ZMR110_Data_ConvertQ(EM_RESP_4_8_0, flg_OBIS_4_8_0);
    bdcc:	8f e0       	ldi	r24, 0x0F	; 15
    bdce:	97 e0       	ldi	r25, 0x07	; 7
    bdd0:	64 e0       	ldi	r22, 0x04	; 4
    bdd2:	0e 94 e4 46 	call	0x8dc8	; 0x8dc8 <EMeter_ZMR110_Data_ConvertQ>
    bdd6:	60 93 e7 01 	sts	0x01E7, r22
    bdda:	70 93 e8 01 	sts	0x01E8, r23
    bdde:	80 93 e9 01 	sts	0x01E9, r24
    bde2:	90 93 ea 01 	sts	0x01EA, r25

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_32_7_0)) 
    bde6:	86 e0       	ldi	r24, 0x06	; 6
    bde8:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bdec:	88 23       	and	r24, r24
    bdee:	49 f4       	brne	.+18     	; 0xbe02 <EMeter_Cycle+0x21a>
														Ua = EMeter_ZMR110_Read_Word(EM_RESP_32_7_0, flg_OBIS_32_7_0);
    bdf0:	85 e1       	ldi	r24, 0x15	; 21
    bdf2:	97 e0       	ldi	r25, 0x07	; 7
    bdf4:	66 e0       	ldi	r22, 0x06	; 6
    bdf6:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    bdfa:	90 93 a9 0c 	sts	0x0CA9, r25
    bdfe:	80 93 a8 0c 	sts	0x0CA8, r24
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_52_7_0)) 							
    be02:	87 e0       	ldi	r24, 0x07	; 7
    be04:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be08:	88 23       	and	r24, r24
    be0a:	49 f4       	brne	.+18     	; 0xbe1e <EMeter_Cycle+0x236>
														Ub = EMeter_ZMR110_Read_Word(EM_RESP_52_7_0, flg_OBIS_52_7_0);
    be0c:	8c e1       	ldi	r24, 0x1C	; 28
    be0e:	97 e0       	ldi	r25, 0x07	; 7
    be10:	67 e0       	ldi	r22, 0x07	; 7
    be12:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    be16:	90 93 68 03 	sts	0x0368, r25
    be1a:	80 93 67 03 	sts	0x0367, r24
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_72_7_0)) 
    be1e:	88 e0       	ldi	r24, 0x08	; 8
    be20:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be24:	88 23       	and	r24, r24
    be26:	49 f4       	brne	.+18     	; 0xbe3a <EMeter_Cycle+0x252>
														Uc = EMeter_ZMR110_Read_Word(EM_RESP_72_7_0, flg_OBIS_72_7_0);
    be28:	83 e2       	ldi	r24, 0x23	; 35
    be2a:	97 e0       	ldi	r25, 0x07	; 7
    be2c:	68 e0       	ldi	r22, 0x08	; 8
    be2e:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    be32:	90 93 de 09 	sts	0x09DE, r25
    be36:	80 93 dd 09 	sts	0x09DD, r24

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_31_7_0)) 
    be3a:	89 e0       	ldi	r24, 0x09	; 9
    be3c:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be40:	88 23       	and	r24, r24
    be42:	49 f4       	brne	.+18     	; 0xbe56 <EMeter_Cycle+0x26e>
														Ia = EMeter_ZMR110_Data_ConvertI(EM_RESP_31_7_0, flg_OBIS_31_7_0);
    be44:	8a e2       	ldi	r24, 0x2A	; 42
    be46:	97 e0       	ldi	r25, 0x07	; 7
    be48:	69 e0       	ldi	r22, 0x09	; 9
    be4a:	0e 94 61 46 	call	0x8cc2	; 0x8cc2 <EMeter_ZMR110_Data_ConvertI>
    be4e:	90 93 76 03 	sts	0x0376, r25
    be52:	80 93 75 03 	sts	0x0375, r24
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_51_7_0)) 
    be56:	8a e0       	ldi	r24, 0x0A	; 10
    be58:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be5c:	88 23       	and	r24, r24
    be5e:	49 f4       	brne	.+18     	; 0xbe72 <EMeter_Cycle+0x28a>
														Ib = EMeter_ZMR110_Data_ConvertI(EM_RESP_51_7_0, flg_OBIS_51_7_0);
    be60:	81 e3       	ldi	r24, 0x31	; 49
    be62:	97 e0       	ldi	r25, 0x07	; 7
    be64:	6a e0       	ldi	r22, 0x0A	; 10
    be66:	0e 94 61 46 	call	0x8cc2	; 0x8cc2 <EMeter_ZMR110_Data_ConvertI>
    be6a:	90 93 b7 08 	sts	0x08B7, r25
    be6e:	80 93 b6 08 	sts	0x08B6, r24
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_71_7_0)) 
    be72:	8b e0       	ldi	r24, 0x0B	; 11
    be74:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be78:	88 23       	and	r24, r24
    be7a:	49 f4       	brne	.+18     	; 0xbe8e <EMeter_Cycle+0x2a6>
														Ic = EMeter_ZMR110_Data_ConvertI(EM_RESP_71_7_0, flg_OBIS_71_7_0);
    be7c:	88 e3       	ldi	r24, 0x38	; 56
    be7e:	97 e0       	ldi	r25, 0x07	; 7
    be80:	6b e0       	ldi	r22, 0x0B	; 11
    be82:	0e 94 61 46 	call	0x8cc2	; 0x8cc2 <EMeter_ZMR110_Data_ConvertI>
    be86:	90 93 ed 08 	sts	0x08ED, r25
    be8a:	80 93 ec 08 	sts	0x08EC, r24

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_16_7_0)) 
    be8e:	8d e0       	ldi	r24, 0x0D	; 13
    be90:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    be94:	88 23       	and	r24, r24
    be96:	49 f4       	brne	.+18     	; 0xbeaa <EMeter_Cycle+0x2c2>
														EM_PowerActive = EMeter_ZMR110_Data_ConvertI(EM_RESP_16_7_0, flg_OBIS_16_7_0);
    be98:	8f e3       	ldi	r24, 0x3F	; 63
    be9a:	97 e0       	ldi	r25, 0x07	; 7
    be9c:	6d e0       	ldi	r22, 0x0D	; 13
    be9e:	0e 94 61 46 	call	0x8cc2	; 0x8cc2 <EMeter_ZMR110_Data_ConvertI>
    bea2:	90 93 da 09 	sts	0x09DA, r25
    bea6:	80 93 d9 09 	sts	0x09D9, r24
						
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_0)){
    beaa:	8e e0       	ldi	r24, 0x0E	; 14
    beac:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    beb0:	88 23       	and	r24, r24
    beb2:	11 f5       	brne	.+68     	; 0xbef8 <EMeter_Cycle+0x310>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_60_0, flg_OBIS_C_60_0);
    beb4:	86 e4       	ldi	r24, 0x46	; 70
    beb6:	97 e0       	ldi	r25, 0x07	; 7
    beb8:	6e e0       	ldi	r22, 0x0E	; 14
    beba:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    bebe:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_0)){
    bec0:	8e e0       	ldi	r24, 0x0E	; 14
    bec2:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bec6:	88 23       	and	r24, r24
    bec8:	b9 f0       	breq	.+46     	; 0xbef8 <EMeter_Cycle+0x310>
															if(EM_Magnit_Cnt_new == 0){
    beca:	80 91 b0 08 	lds	r24, 0x08B0
    bece:	90 91 b1 08 	lds	r25, 0x08B1
    bed2:	00 97       	sbiw	r24, 0x00	; 0
    bed4:	49 f4       	brne	.+18     	; 0xbee8 <EMeter_Cycle+0x300>
																EM_Magnit_Cnt_prev = EM_Magnit_Cnt_new = Temp;
    bed6:	10 93 b1 08 	sts	0x08B1, r17
    beda:	00 93 b0 08 	sts	0x08B0, r16
    bede:	10 93 61 09 	sts	0x0961, r17
    bee2:	00 93 60 09 	sts	0x0960, r16
    bee6:	08 c0       	rjmp	.+16     	; 0xbef8 <EMeter_Cycle+0x310>
															}
															else{
																EM_Magnit_Cnt_prev = EM_Magnit_Cnt_new;
    bee8:	90 93 61 09 	sts	0x0961, r25
    beec:	80 93 60 09 	sts	0x0960, r24
																EM_Magnit_Cnt_new = Temp;								
    bef0:	10 93 b1 08 	sts	0x08B1, r17
    bef4:	00 93 b0 08 	sts	0x08B0, r16
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_2)){
    bef8:	8f e0       	ldi	r24, 0x0F	; 15
    befa:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    befe:	88 23       	and	r24, r24
    bf00:	c9 f5       	brne	.+114    	; 0xbf74 <EMeter_Cycle+0x38c>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_60_2, flg_OBIS_C_60_2);
    bf02:	8d e4       	ldi	r24, 0x4D	; 77
    bf04:	97 e0       	ldi	r25, 0x07	; 7
    bf06:	6f e0       	ldi	r22, 0x0F	; 15
    bf08:	0e 94 9f 48 	call	0x913e	; 0x913e <EMeter_ZMR110_Read_DWord>
    bf0c:	7b 01       	movw	r14, r22
    bf0e:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_60_2)){
    bf10:	8f e0       	ldi	r24, 0x0F	; 15
    bf12:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bf16:	88 23       	and	r24, r24
    bf18:	69 f1       	breq	.+90     	; 0xbf74 <EMeter_Cycle+0x38c>
															if(EM_Magnit_Min_new	 == 0){
    bf1a:	80 91 cc 08 	lds	r24, 0x08CC
    bf1e:	90 91 cd 08 	lds	r25, 0x08CD
    bf22:	a0 91 ce 08 	lds	r26, 0x08CE
    bf26:	b0 91 cf 08 	lds	r27, 0x08CF
    bf2a:	00 97       	sbiw	r24, 0x00	; 0
    bf2c:	a1 05       	cpc	r26, r1
    bf2e:	b1 05       	cpc	r27, r1
    bf30:	89 f4       	brne	.+34     	; 0xbf54 <EMeter_Cycle+0x36c>
																EM_Magnit_Min_prev = EM_Magnit_Min_new = Temp;
    bf32:	e0 92 cc 08 	sts	0x08CC, r14
    bf36:	f0 92 cd 08 	sts	0x08CD, r15
    bf3a:	00 93 ce 08 	sts	0x08CE, r16
    bf3e:	10 93 cf 08 	sts	0x08CF, r17
    bf42:	e0 92 72 0a 	sts	0x0A72, r14
    bf46:	f0 92 73 0a 	sts	0x0A73, r15
    bf4a:	00 93 74 0a 	sts	0x0A74, r16
    bf4e:	10 93 75 0a 	sts	0x0A75, r17
    bf52:	10 c0       	rjmp	.+32     	; 0xbf74 <EMeter_Cycle+0x38c>
															}
															else{
																EM_Magnit_Min_prev = EM_Magnit_Min_new;
    bf54:	80 93 72 0a 	sts	0x0A72, r24
    bf58:	90 93 73 0a 	sts	0x0A73, r25
    bf5c:	a0 93 74 0a 	sts	0x0A74, r26
    bf60:	b0 93 75 0a 	sts	0x0A75, r27
																EM_Magnit_Min_new = Temp;								
    bf64:	e0 92 cc 08 	sts	0x08CC, r14
    bf68:	f0 92 cd 08 	sts	0x08CD, r15
    bf6c:	00 93 ce 08 	sts	0x08CE, r16
    bf70:	10 93 cf 08 	sts	0x08CF, r17
															}
														}
													} 

													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_0)){
    bf74:	80 e1       	ldi	r24, 0x10	; 16
    bf76:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bf7a:	88 23       	and	r24, r24
    bf7c:	11 f5       	brne	.+68     	; 0xbfc2 <EMeter_Cycle+0x3da>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_61_0, flg_OBIS_C_61_0);
    bf7e:	84 e5       	ldi	r24, 0x54	; 84
    bf80:	97 e0       	ldi	r25, 0x07	; 7
    bf82:	60 e1       	ldi	r22, 0x10	; 16
    bf84:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    bf88:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_0)){
    bf8a:	80 e1       	ldi	r24, 0x10	; 16
    bf8c:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bf90:	88 23       	and	r24, r24
    bf92:	b9 f0       	breq	.+46     	; 0xbfc2 <EMeter_Cycle+0x3da>
															if(EM_Klemm_Cnt_new	 == 0){
    bf94:	80 91 97 05 	lds	r24, 0x0597
    bf98:	90 91 98 05 	lds	r25, 0x0598
    bf9c:	00 97       	sbiw	r24, 0x00	; 0
    bf9e:	49 f4       	brne	.+18     	; 0xbfb2 <EMeter_Cycle+0x3ca>
																EM_Klemm_Cnt_prev = EM_Klemm_Cnt_new = Temp;
    bfa0:	10 93 98 05 	sts	0x0598, r17
    bfa4:	00 93 97 05 	sts	0x0597, r16
    bfa8:	10 93 78 03 	sts	0x0378, r17
    bfac:	00 93 77 03 	sts	0x0377, r16
    bfb0:	08 c0       	rjmp	.+16     	; 0xbfc2 <EMeter_Cycle+0x3da>
															}
															else{
																EM_Klemm_Cnt_prev = EM_Klemm_Cnt_new;
    bfb2:	90 93 78 03 	sts	0x0378, r25
    bfb6:	80 93 77 03 	sts	0x0377, r24
																EM_Klemm_Cnt_new = Temp;								
    bfba:	10 93 98 05 	sts	0x0598, r17
    bfbe:	00 93 97 05 	sts	0x0597, r16
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_2)){
    bfc2:	81 e1       	ldi	r24, 0x11	; 17
    bfc4:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bfc8:	88 23       	and	r24, r24
    bfca:	c9 f5       	brne	.+114    	; 0xc03e <EMeter_Cycle+0x456>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_61_2, flg_OBIS_C_61_2);
    bfcc:	8b e5       	ldi	r24, 0x5B	; 91
    bfce:	97 e0       	ldi	r25, 0x07	; 7
    bfd0:	61 e1       	ldi	r22, 0x11	; 17
    bfd2:	0e 94 9f 48 	call	0x913e	; 0x913e <EMeter_ZMR110_Read_DWord>
    bfd6:	7b 01       	movw	r14, r22
    bfd8:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_61_2)){
    bfda:	81 e1       	ldi	r24, 0x11	; 17
    bfdc:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    bfe0:	88 23       	and	r24, r24
    bfe2:	69 f1       	breq	.+90     	; 0xc03e <EMeter_Cycle+0x456>
															if(EM_Klemm_Min_new	 == 0){
    bfe4:	80 91 88 0a 	lds	r24, 0x0A88
    bfe8:	90 91 89 0a 	lds	r25, 0x0A89
    bfec:	a0 91 8a 0a 	lds	r26, 0x0A8A
    bff0:	b0 91 8b 0a 	lds	r27, 0x0A8B
    bff4:	00 97       	sbiw	r24, 0x00	; 0
    bff6:	a1 05       	cpc	r26, r1
    bff8:	b1 05       	cpc	r27, r1
    bffa:	89 f4       	brne	.+34     	; 0xc01e <EMeter_Cycle+0x436>
																EM_Klemm_Min_prev = EM_Klemm_Min_new = Temp;
    bffc:	e0 92 88 0a 	sts	0x0A88, r14
    c000:	f0 92 89 0a 	sts	0x0A89, r15
    c004:	00 93 8a 0a 	sts	0x0A8A, r16
    c008:	10 93 8b 0a 	sts	0x0A8B, r17
    c00c:	e0 92 59 09 	sts	0x0959, r14
    c010:	f0 92 5a 09 	sts	0x095A, r15
    c014:	00 93 5b 09 	sts	0x095B, r16
    c018:	10 93 5c 09 	sts	0x095C, r17
    c01c:	10 c0       	rjmp	.+32     	; 0xc03e <EMeter_Cycle+0x456>
															}
															else{
																EM_Klemm_Min_prev = EM_Klemm_Min_new;
    c01e:	80 93 59 09 	sts	0x0959, r24
    c022:	90 93 5a 09 	sts	0x095A, r25
    c026:	a0 93 5b 09 	sts	0x095B, r26
    c02a:	b0 93 5c 09 	sts	0x095C, r27
																EM_Klemm_Min_new = Temp;								
    c02e:	e0 92 88 0a 	sts	0x0A88, r14
    c032:	f0 92 89 0a 	sts	0x0A89, r15
    c036:	00 93 8a 0a 	sts	0x0A8A, r16
    c03a:	10 93 8b 0a 	sts	0x0A8B, r17
															}
														}
													} 
													//-----
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_0)){
    c03e:	82 e1       	ldi	r24, 0x12	; 18
    c040:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c044:	88 23       	and	r24, r24
    c046:	11 f5       	brne	.+68     	; 0xc08c <EMeter_Cycle+0x4a4>
														uint16_t Temp = EMeter_ZMR110_Read_Word(EM_RESP_C_62_0, flg_OBIS_C_62_0);
    c048:	82 e6       	ldi	r24, 0x62	; 98
    c04a:	97 e0       	ldi	r25, 0x07	; 7
    c04c:	62 e1       	ldi	r22, 0x12	; 18
    c04e:	0e 94 13 49 	call	0x9226	; 0x9226 <EMeter_ZMR110_Read_Word>
    c052:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_0)){
    c054:	82 e1       	ldi	r24, 0x12	; 18
    c056:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c05a:	88 23       	and	r24, r24
    c05c:	b9 f0       	breq	.+46     	; 0xc08c <EMeter_Cycle+0x4a4>
															if(EM_Korpus_Cnt_new	 == 0){
    c05e:	80 91 82 0a 	lds	r24, 0x0A82
    c062:	90 91 83 0a 	lds	r25, 0x0A83
    c066:	00 97       	sbiw	r24, 0x00	; 0
    c068:	49 f4       	brne	.+18     	; 0xc07c <EMeter_Cycle+0x494>
																EM_Korpus_Cnt_prev = EM_Korpus_Cnt_new = Temp;
    c06a:	10 93 83 0a 	sts	0x0A83, r17
    c06e:	00 93 82 0a 	sts	0x0A82, r16
    c072:	10 93 ab 0c 	sts	0x0CAB, r17
    c076:	00 93 aa 0c 	sts	0x0CAA, r16
    c07a:	08 c0       	rjmp	.+16     	; 0xc08c <EMeter_Cycle+0x4a4>
															}
															else{
																EM_Korpus_Cnt_prev = EM_Korpus_Cnt_new;
    c07c:	90 93 ab 0c 	sts	0x0CAB, r25
    c080:	80 93 aa 0c 	sts	0x0CAA, r24
																EM_Korpus_Cnt_new = Temp;								
    c084:	10 93 83 0a 	sts	0x0A83, r17
    c088:	00 93 82 0a 	sts	0x0A82, r16
															}
														}
													} 
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_2)){
    c08c:	83 e1       	ldi	r24, 0x13	; 19
    c08e:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c092:	88 23       	and	r24, r24
    c094:	c9 f5       	brne	.+114    	; 0xc108 <EMeter_Cycle+0x520>
														uint32_t Temp = EMeter_ZMR110_Read_DWord(EM_RESP_C_62_2, flg_OBIS_C_62_2);
    c096:	89 e6       	ldi	r24, 0x69	; 105
    c098:	97 e0       	ldi	r25, 0x07	; 7
    c09a:	63 e1       	ldi	r22, 0x13	; 19
    c09c:	0e 94 9f 48 	call	0x913e	; 0x913e <EMeter_ZMR110_Read_DWord>
    c0a0:	7b 01       	movw	r14, r22
    c0a2:	8c 01       	movw	r16, r24
														if(Check_LG_ZMR110_READ_FLAG(flg_OBIS_C_62_2)){
    c0a4:	83 e1       	ldi	r24, 0x13	; 19
    c0a6:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c0aa:	88 23       	and	r24, r24
    c0ac:	69 f1       	breq	.+90     	; 0xc108 <EMeter_Cycle+0x520>
															if(EM_Korpus_Min_new	 == 0){
    c0ae:	80 91 6e 03 	lds	r24, 0x036E
    c0b2:	90 91 6f 03 	lds	r25, 0x036F
    c0b6:	a0 91 70 03 	lds	r26, 0x0370
    c0ba:	b0 91 71 03 	lds	r27, 0x0371
    c0be:	00 97       	sbiw	r24, 0x00	; 0
    c0c0:	a1 05       	cpc	r26, r1
    c0c2:	b1 05       	cpc	r27, r1
    c0c4:	89 f4       	brne	.+34     	; 0xc0e8 <EMeter_Cycle+0x500>
																EM_Korpus_Min_prev = EM_Korpus_Min_new = Temp;
    c0c6:	e0 92 6e 03 	sts	0x036E, r14
    c0ca:	f0 92 6f 03 	sts	0x036F, r15
    c0ce:	00 93 70 03 	sts	0x0370, r16
    c0d2:	10 93 71 03 	sts	0x0371, r17
    c0d6:	e0 92 93 05 	sts	0x0593, r14
    c0da:	f0 92 94 05 	sts	0x0594, r15
    c0de:	00 93 95 05 	sts	0x0595, r16
    c0e2:	10 93 96 05 	sts	0x0596, r17
    c0e6:	10 c0       	rjmp	.+32     	; 0xc108 <EMeter_Cycle+0x520>
															}
															else{
																EM_Korpus_Min_prev = EM_Korpus_Min_new;
    c0e8:	80 93 93 05 	sts	0x0593, r24
    c0ec:	90 93 94 05 	sts	0x0594, r25
    c0f0:	a0 93 95 05 	sts	0x0595, r26
    c0f4:	b0 93 96 05 	sts	0x0596, r27
																EM_Korpus_Min_new = Temp;								
    c0f8:	e0 92 6e 03 	sts	0x036E, r14
    c0fc:	f0 92 6f 03 	sts	0x036F, r15
    c100:	00 93 70 03 	sts	0x0370, r16
    c104:	10 93 71 03 	sts	0x0371, r17
															}
														}
													} 
													//-----

													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_F_F_0)) 
    c108:	84 e1       	ldi	r24, 0x14	; 20
    c10a:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c10e:	88 23       	and	r24, r24
    c110:	69 f4       	brne	.+26     	; 0xc12c <EMeter_Cycle+0x544>
														EM_FailCode = EMeter_ZMR110_Read_DWord(EM_RESP_F_F_0, flg_OBIS_F_F_0);
    c112:	86 e7       	ldi	r24, 0x76	; 118
    c114:	97 e0       	ldi	r25, 0x07	; 7
    c116:	64 e1       	ldi	r22, 0x14	; 20
    c118:	0e 94 9f 48 	call	0x913e	; 0x913e <EMeter_ZMR110_Read_DWord>
    c11c:	60 93 c1 08 	sts	0x08C1, r22
    c120:	70 93 c2 08 	sts	0x08C2, r23
    c124:	80 93 c3 08 	sts	0x08C3, r24
    c128:	90 93 c4 08 	sts	0x08C4, r25
													if(!Check_LG_ZMR110_READ_FLAG(flg_OBIS_0_0_0)) 
    c12c:	85 e1       	ldi	r24, 0x15	; 21
    c12e:	0e 94 c0 42 	call	0x8580	; 0x8580 <Check_LG_ZMR110_READ_FLAG>
    c132:	88 23       	and	r24, r24
    c134:	29 f4       	brne	.+10     	; 0xc140 <EMeter_Cycle+0x558>
														EMeter_ZMR110_Read_ID1_1(EM_RESP_0_0_0, flg_OBIS_0_0_0);
    c136:	80 e7       	ldi	r24, 0x70	; 112
    c138:	97 e0       	ldi	r25, 0x07	; 7
    c13a:	65 e1       	ldi	r22, 0x15	; 21
    c13c:	0e 94 9a 47 	call	0x8f34	; 0x8f34 <EMeter_ZMR110_Read_ID1_1>

													/*
													if(p >= EMeter_RxStr + EM_RX_SIZE - LG_ZMR110_MAX_STR) EMeter_RxStr_Offset = EMeter_RxStr;
													else EMeter_RxStr_Offset = p+1;
													*/
													cli();
    c140:	f8 94       	cli
													{
														EMeter_RxStr_Offset = p+1;
													}
													*/

												if(EM_HalfBufferStart==EMeter_RxStr)
    c142:	80 91 f2 08 	lds	r24, 0x08F2
    c146:	90 91 f3 08 	lds	r25, 0x08F3
    c14a:	89 5b       	subi	r24, 0xB9	; 185
    c14c:	96 40       	sbci	r25, 0x06	; 6
    c14e:	59 f4       	brne	.+22     	; 0xc166 <EMeter_Cycle+0x57e>
													{
														if((p >= (EMeter_RxStr + EM_RX_SIZE/2 - LG_ZMR110_MAX_STR))&&(p<&EMeter_RxStr[EM_RX_SIZE/2]))
    c150:	ea e1       	ldi	r30, 0x1A	; 26
    c152:	ce 16       	cp	r12, r30
    c154:	e7 e0       	ldi	r30, 0x07	; 7
    c156:	de 06       	cpc	r13, r30
    c158:	98 f0       	brcs	.+38     	; 0xc180 <EMeter_Cycle+0x598>
    c15a:	f8 e3       	ldi	r31, 0x38	; 56
    c15c:	cf 16       	cp	r12, r31
    c15e:	f7 e0       	ldi	r31, 0x07	; 7
    c160:	df 06       	cpc	r13, r31
    c162:	70 f4       	brcc	.+28     	; 0xc180 <EMeter_Cycle+0x598>
    c164:	0a c0       	rjmp	.+20     	; 0xc17a <EMeter_Cycle+0x592>
															}
				
													}
												else
													{								
														if((p >= (EMeter_RxStr + EM_RX_SIZE - LG_ZMR110_MAX_STR))&&(p<&EMeter_RxStr[EM_RX_SIZE]))
    c166:	29 e9       	ldi	r18, 0x99	; 153
    c168:	c2 16       	cp	r12, r18
    c16a:	27 e0       	ldi	r18, 0x07	; 7
    c16c:	d2 06       	cpc	r13, r18
    c16e:	40 f0       	brcs	.+16     	; 0xc180 <EMeter_Cycle+0x598>
    c170:	87 eb       	ldi	r24, 0xB7	; 183
    c172:	c8 16       	cp	r12, r24
    c174:	87 e0       	ldi	r24, 0x07	; 7
    c176:	d8 06       	cpc	r13, r24
    c178:	18 f4       	brcc	.+6      	; 0xc180 <EMeter_Cycle+0x598>
															{
																EM_BufferReadEnable=0;				
    c17a:	10 92 bf 08 	sts	0x08BF, r1
    c17e:	07 c0       	rjmp	.+14     	; 0xc18e <EMeter_Cycle+0x5a6>
															}
														else
															{
																EMeter_RxStr_Offset = p+1;
    c180:	08 94       	sec
    c182:	c1 1c       	adc	r12, r1
    c184:	d1 1c       	adc	r13, r1
    c186:	d0 92 86 05 	sts	0x0586, r13
    c18a:	c0 92 85 05 	sts	0x0585, r12
															}	
													}
													sei();
    c18e:	78 94       	sei

												}
					}

					 //check EM link
					if(Timer16Stopp(TD_EMeter)){
    c190:	80 91 a0 0b 	lds	r24, 0x0BA0
    c194:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c198:	88 23       	and	r24, r24
    c19a:	a9 f1       	breq	.+106    	; 0xc206 <EMeter_Cycle+0x61e>
    c19c:	ef e7       	ldi	r30, 0x7F	; 127
    c19e:	f5 e0       	ldi	r31, 0x05	; 5
    c1a0:	90 e0       	ldi	r25, 0x00	; 0
						
						uint8_t read_flag = 0;
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) 
							if(LG_ZMR110_READ_FLAG[i]) read_flag = 1;
    c1a2:	80 81       	ld	r24, Z
    c1a4:	81 11       	cpse	r24, r1
    c1a6:	91 e0       	ldi	r25, 0x01	; 1
    c1a8:	31 96       	adiw	r30, 0x01	; 1

					 //check EM link
					if(Timer16Stopp(TD_EMeter)){
						
						uint8_t read_flag = 0;
						for(uint8_t i=0;i<sizeof(LG_ZMR110_READ_FLAG); i++) 
    c1aa:	a5 e0       	ldi	r26, 0x05	; 5
    c1ac:	e3 38       	cpi	r30, 0x83	; 131
    c1ae:	fa 07       	cpc	r31, r26
    c1b0:	c1 f7       	brne	.-16     	; 0xc1a2 <EMeter_Cycle+0x5ba>
							if(LG_ZMR110_READ_FLAG[i]) read_flag = 1;
						if(read_flag){
    c1b2:	99 23       	and	r25, r25
    c1b4:	19 f0       	breq	.+6      	; 0xc1bc <EMeter_Cycle+0x5d4>
							EM_Retry = 0;
    c1b6:	10 92 d3 01 	sts	0x01D3, r1
    c1ba:	05 c0       	rjmp	.+10     	; 0xc1c6 <EMeter_Cycle+0x5de>
						}
						else{
							EMeter_NoLink();
    c1bc:	0e 94 ec 41 	call	0x83d8	; 0x83d8 <EMeter_NoLink>
							EM_Retry = 1;
    c1c0:	81 e0       	ldi	r24, 0x01	; 1
    c1c2:	80 93 d3 01 	sts	0x01D3, r24
						}
						EM_Mode = 255;
    c1c6:	8f ef       	ldi	r24, 0xFF	; 255
    c1c8:	1c c0       	rjmp	.+56     	; 0xc202 <EMeter_Cycle+0x61a>
				case 255:
					//      
					break;
			
				default: 
					if(Timer16Stopp(TD_EMeter)){
    c1ca:	80 91 a0 0b 	lds	r24, 0x0BA0
    c1ce:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c1d2:	88 23       	and	r24, r24
    c1d4:	c1 f0       	breq	.+48     	; 0xc206 <EMeter_Cycle+0x61e>
    c1d6:	e9 eb       	ldi	r30, 0xB9	; 185
    c1d8:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    c1da:	11 92       	st	Z+, r1
    c1dc:	b7 e0       	ldi	r27, 0x07	; 7
    c1de:	e7 3b       	cpi	r30, 0xB7	; 183
    c1e0:	fb 07       	cpc	r31, r27
    c1e2:	d9 f7       	brne	.-10     	; 0xc1da <EMeter_Cycle+0x5f2>
	EMeter_RxCharN = 0;
    c1e4:	10 92 a7 0c 	sts	0x0CA7, r1
    c1e8:	10 92 a6 0c 	sts	0x0CA6, r1
					break;
			
				default: 
					if(Timer16Stopp(TD_EMeter)){
						EMeter_ClearRXStr();
						EMeter_SendCR(EM_REQ);
    c1ec:	8c e7       	ldi	r24, 0x7C	; 124
    c1ee:	97 e0       	ldi	r25, 0x07	; 7
    c1f0:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
						//StartTimer16(TD_EMeter,200);	//TODO  ?
						//StartTimer16(TD_EMeter,230);	//TODO  ?
					StartTimer16(TD_EMeter,170);	//TODO  ?
    c1f4:	80 91 a0 0b 	lds	r24, 0x0BA0
    c1f8:	6a ea       	ldi	r22, 0xAA	; 170
    c1fa:	70 e0       	ldi	r23, 0x00	; 0
    c1fc:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					//	StartTimer16(TD_EMeter,100);	//TODO  ?
						EM_Mode = 1;
    c200:	81 e0       	ldi	r24, 0x01	; 1
    c202:	80 93 db 09 	sts	0x09DB, r24
    c206:	8c e5       	ldi	r24, 0x5C	; 92
    c208:	91 e0       	ldi	r25, 0x01	; 1
    c20a:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    c20e:	18 2f       	mov	r17, r24
					break;
			}		
		}

		//--- 
		if(erb(&EMeterType) == ELVIN){
    c210:	82 30       	cpi	r24, 0x02	; 2
    c212:	09 f0       	breq	.+2      	; 0xc216 <EMeter_Cycle+0x62e>
    c214:	9b c1       	rjmp	.+822    	; 0xc54c <EMeter_Cycle+0x964>
			switch(EM_Mode){
    c216:	80 91 db 09 	lds	r24, 0x09DB
    c21a:	82 30       	cpi	r24, 0x02	; 2
    c21c:	d1 f0       	breq	.+52     	; 0xc252 <EMeter_Cycle+0x66a>
    c21e:	8f 3f       	cpi	r24, 0xFF	; 255
    c220:	09 f4       	brne	.+2      	; 0xc224 <EMeter_Cycle+0x63c>
    c222:	94 c1       	rjmp	.+808    	; 0xc54c <EMeter_Cycle+0x964>
    c224:	81 30       	cpi	r24, 0x01	; 1
    c226:	09 f0       	breq	.+2      	; 0xc22a <EMeter_Cycle+0x642>
    c228:	7e c1       	rjmp	.+764    	; 0xc526 <EMeter_Cycle+0x93e>
	
				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    c22a:	80 91 a0 0b 	lds	r24, 0x0BA0
    c22e:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c232:	88 23       	and	r24, r24
    c234:	09 f4       	brne	.+2      	; 0xc238 <EMeter_Cycle+0x650>
    c236:	8a c1       	rjmp	.+788    	; 0xc54c <EMeter_Cycle+0x964>
						EMeter_SendCR(EM_READ_DATA_REQ);
    c238:	80 e8       	ldi	r24, 0x80	; 128
    c23a:	97 e0       	ldi	r25, 0x07	; 7
    c23c:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
						StartTimer16(TD_EMeter,100);
    c240:	80 91 a0 0b 	lds	r24, 0x0BA0
    c244:	64 e6       	ldi	r22, 0x64	; 100
    c246:	70 e0       	ldi	r23, 0x00	; 0
    c248:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 2;
    c24c:	10 93 db 09 	sts	0x09DB, r17
    c250:	7d c1       	rjmp	.+762    	; 0xc54c <EMeter_Cycle+0x964>
					}
					break;
				case 2:
					if(Timer16Stopp(TD_EMeter)){	
    c252:	80 91 a0 0b 	lds	r24, 0x0BA0
    c256:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c25a:	88 23       	and	r24, r24
    c25c:	09 f4       	brne	.+2      	; 0xc260 <EMeter_Cycle+0x678>
    c25e:	76 c1       	rjmp	.+748    	; 0xc54c <EMeter_Cycle+0x964>
				
						 //read data

						// check frame
						if(EMeter_RxCharN != 40){
    c260:	80 91 a6 0c 	lds	r24, 0x0CA6
    c264:	90 91 a7 0c 	lds	r25, 0x0CA7
    c268:	88 97       	sbiw	r24, 0x28	; 40
    c26a:	81 f5       	brne	.+96     	; 0xc2cc <EMeter_Cycle+0x6e4>
							EMeter_NoLink();
							break;
						}
						EM_BCC = 0;
    c26c:	10 92 c6 08 	sts	0x08C6, r1
    c270:	ea eb       	ldi	r30, 0xBA	; 186
    c272:	f6 e0       	ldi	r31, 0x06	; 6
						for(uint8_t i=1; i<39; i++) EM_BCC += EMeter_RxStr[i];
    c274:	90 91 c6 08 	lds	r25, 0x08C6
    c278:	81 91       	ld	r24, Z+
    c27a:	98 0f       	add	r25, r24
    c27c:	90 93 c6 08 	sts	0x08C6, r25
    c280:	26 e0       	ldi	r18, 0x06	; 6
    c282:	e0 3e       	cpi	r30, 0xE0	; 224
    c284:	f2 07       	cpc	r31, r18
    c286:	b1 f7       	brne	.-20     	; 0xc274 <EMeter_Cycle+0x68c>
						EM_BCC &= 0b01111111;
    c288:	9f 77       	andi	r25, 0x7F	; 127
    c28a:	90 93 c6 08 	sts	0x08C6, r25
						if(EM_BCC != EMeter_RxStr[39]){
    c28e:	80 81       	ld	r24, Z
    c290:	98 17       	cp	r25, r24
    c292:	e1 f4       	brne	.+56     	; 0xc2cc <EMeter_Cycle+0x6e4>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x02 || EMeter_RxStr[1]!='(' || EMeter_RxStr[34] != ')' || EMeter_RxStr[35] != '!' ||
    c294:	80 91 b9 06 	lds	r24, 0x06B9
    c298:	82 30       	cpi	r24, 0x02	; 2
    c29a:	c1 f4       	brne	.+48     	; 0xc2cc <EMeter_Cycle+0x6e4>
    c29c:	80 91 ba 06 	lds	r24, 0x06BA
    c2a0:	88 32       	cpi	r24, 0x28	; 40
    c2a2:	a1 f4       	brne	.+40     	; 0xc2cc <EMeter_Cycle+0x6e4>
    c2a4:	80 91 db 06 	lds	r24, 0x06DB
    c2a8:	89 32       	cpi	r24, 0x29	; 41
    c2aa:	81 f4       	brne	.+32     	; 0xc2cc <EMeter_Cycle+0x6e4>
    c2ac:	80 91 dc 06 	lds	r24, 0x06DC
    c2b0:	81 32       	cpi	r24, 0x21	; 33
    c2b2:	61 f4       	brne	.+24     	; 0xc2cc <EMeter_Cycle+0x6e4>
    c2b4:	80 91 dd 06 	lds	r24, 0x06DD
    c2b8:	8d 30       	cpi	r24, 0x0D	; 13
    c2ba:	41 f4       	brne	.+16     	; 0xc2cc <EMeter_Cycle+0x6e4>
    c2bc:	80 91 de 06 	lds	r24, 0x06DE
    c2c0:	8a 30       	cpi	r24, 0x0A	; 10
    c2c2:	21 f4       	brne	.+8      	; 0xc2cc <EMeter_Cycle+0x6e4>
    c2c4:	80 91 df 06 	lds	r24, 0x06DF
    c2c8:	83 30       	cpi	r24, 0x03	; 3
    c2ca:	19 f0       	breq	.+6      	; 0xc2d2 <EMeter_Cycle+0x6ea>
							EMeter_RxStr[36] != '\r' || EMeter_RxStr[37] != '\n'|| EMeter_RxStr[38] != 0x03){
							EMeter_NoLink();
    c2cc:	0e 94 ec 41 	call	0x83d8	; 0x83d8 <EMeter_NoLink>
    c2d0:	3d c1       	rjmp	.+634    	; 0xc54c <EMeter_Cycle+0x964>
							break;
						}
						//process data
						char TempStr[11];
						TempStr[0] = '0';
    c2d2:	80 e3       	ldi	r24, 0x30	; 48
    c2d4:	8e 87       	std	Y+14, r24	; 0x0e
						TempStr[1] = 'x';
    c2d6:	88 e7       	ldi	r24, 0x78	; 120
    c2d8:	8f 87       	std	Y+15, r24	; 0x0f
						TempStr[10] = 0;
    c2da:	18 8e       	std	Y+24, r1	; 0x18
    c2dc:	8f 01       	movw	r16, r30
    c2de:	0f 51       	subi	r16, 0x1F	; 31
    c2e0:	10 40       	sbci	r17, 0x00	; 0
    c2e2:	90 e1       	ldi	r25, 0x10	; 16
    c2e4:	e9 2e       	mov	r14, r25
    c2e6:	f1 2c       	mov	r15, r1
    c2e8:	ec 0e       	add	r14, r28
    c2ea:	fd 1e       	adc	r15, r29
    c2ec:	f7 01       	movw	r30, r14

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    c2ee:	d8 01       	movw	r26, r16
    c2f0:	8c 91       	ld	r24, X
    c2f2:	80 83       	st	Z, r24
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    c2f4:	11 96       	adiw	r26, 0x01	; 1
    c2f6:	8c 91       	ld	r24, X
    c2f8:	81 83       	std	Z+1, r24	; 0x01
    c2fa:	02 50       	subi	r16, 0x02	; 2
    c2fc:	10 40       	sbci	r17, 0x00	; 0
    c2fe:	32 96       	adiw	r30, 0x02	; 2
						TempStr[0] = '0';
						TempStr[1] = 'x';
						TempStr[10] = 0;

						uint8_t Start = 2;
						for(uint8_t i=0; i<8; i=i+2){
    c300:	b6 e0       	ldi	r27, 0x06	; 6
    c302:	09 3b       	cpi	r16, 0xB9	; 185
    c304:	1b 07       	cpc	r17, r27
    c306:	99 f7       	brne	.-26     	; 0xc2ee <EMeter_Cycle+0x706>
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
    c308:	00 d0       	rcall	.+0      	; 0xc30a <EMeter_Cycle+0x722>
    c30a:	00 d0       	rcall	.+0      	; 0xc30c <EMeter_Cycle+0x724>
    c30c:	00 d0       	rcall	.+0      	; 0xc30e <EMeter_Cycle+0x726>
    c30e:	ed b7       	in	r30, 0x3d	; 61
    c310:	fe b7       	in	r31, 0x3e	; 62
    c312:	31 96       	adiw	r30, 0x01	; 1
    c314:	ce 01       	movw	r24, r28
    c316:	0e 96       	adiw	r24, 0x0e	; 14
    c318:	ad b7       	in	r26, 0x3d	; 61
    c31a:	be b7       	in	r27, 0x3e	; 62
    c31c:	12 96       	adiw	r26, 0x02	; 2
    c31e:	9c 93       	st	X, r25
    c320:	8e 93       	st	-X, r24
    c322:	11 97       	sbiw	r26, 0x01	; 1
    c324:	88 e8       	ldi	r24, 0x88	; 136
    c326:	91 e0       	ldi	r25, 0x01	; 1
    c328:	93 83       	std	Z+3, r25	; 0x03
    c32a:	82 83       	std	Z+2, r24	; 0x02
    c32c:	8b ed       	ldi	r24, 0xDB	; 219
    c32e:	91 e0       	ldi	r25, 0x01	; 1
    c330:	95 83       	std	Z+5, r25	; 0x05
    c332:	84 83       	std	Z+4, r24	; 0x04
    c334:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
						E_Meter_RAM.Ap *=10;
    c338:	60 91 db 01 	lds	r22, 0x01DB
    c33c:	70 91 dc 01 	lds	r23, 0x01DC
    c340:	80 91 dd 01 	lds	r24, 0x01DD
    c344:	90 91 de 01 	lds	r25, 0x01DE
    c348:	2a e0       	ldi	r18, 0x0A	; 10
    c34a:	30 e0       	ldi	r19, 0x00	; 0
    c34c:	40 e0       	ldi	r20, 0x00	; 0
    c34e:	50 e0       	ldi	r21, 0x00	; 0
    c350:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    c354:	60 93 db 01 	sts	0x01DB, r22
    c358:	70 93 dc 01 	sts	0x01DC, r23
    c35c:	80 93 dd 01 	sts	0x01DD, r24
    c360:	90 93 de 01 	sts	0x01DE, r25
    c364:	00 5f       	subi	r16, 0xF0	; 240
    c366:	1f 4f       	sbci	r17, 0xFF	; 255
    c368:	f7 01       	movw	r30, r14
    c36a:	8d b7       	in	r24, 0x3d	; 61
    c36c:	9e b7       	in	r25, 0x3e	; 62
    c36e:	06 96       	adiw	r24, 0x06	; 6
    c370:	0f b6       	in	r0, 0x3f	; 63
    c372:	f8 94       	cli
    c374:	9e bf       	out	0x3e, r25	; 62
    c376:	0f be       	out	0x3f, r0	; 63
    c378:	8d bf       	out	0x3d, r24	; 61
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    c37a:	d8 01       	movw	r26, r16
    c37c:	8c 91       	ld	r24, X
    c37e:	80 83       	st	Z, r24
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    c380:	11 96       	adiw	r26, 0x01	; 1
    c382:	8c 91       	ld	r24, X
    c384:	81 83       	std	Z+1, r24	; 0x01
    c386:	02 50       	subi	r16, 0x02	; 2
    c388:	10 40       	sbci	r17, 0x00	; 0
    c38a:	32 96       	adiw	r30, 0x02	; 2
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Ap);		
						E_Meter_RAM.Ap *=10;
						Start = 10;
						for(uint8_t i=0; i<8; i=i+2){
    c38c:	b6 e0       	ldi	r27, 0x06	; 6
    c38e:	01 3c       	cpi	r16, 0xC1	; 193
    c390:	1b 07       	cpc	r17, r27
    c392:	99 f7       	brne	.-26     	; 0xc37a <EMeter_Cycle+0x792>
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
    c394:	00 d0       	rcall	.+0      	; 0xc396 <EMeter_Cycle+0x7ae>
    c396:	00 d0       	rcall	.+0      	; 0xc398 <EMeter_Cycle+0x7b0>
    c398:	00 d0       	rcall	.+0      	; 0xc39a <EMeter_Cycle+0x7b2>
    c39a:	ed b7       	in	r30, 0x3d	; 61
    c39c:	fe b7       	in	r31, 0x3e	; 62
    c39e:	31 96       	adiw	r30, 0x01	; 1
    c3a0:	ce 01       	movw	r24, r28
    c3a2:	0e 96       	adiw	r24, 0x0e	; 14
    c3a4:	ad b7       	in	r26, 0x3d	; 61
    c3a6:	be b7       	in	r27, 0x3e	; 62
    c3a8:	12 96       	adiw	r26, 0x02	; 2
    c3aa:	9c 93       	st	X, r25
    c3ac:	8e 93       	st	-X, r24
    c3ae:	11 97       	sbiw	r26, 0x01	; 1
    c3b0:	88 e8       	ldi	r24, 0x88	; 136
    c3b2:	91 e0       	ldi	r25, 0x01	; 1
    c3b4:	93 83       	std	Z+3, r25	; 0x03
    c3b6:	82 83       	std	Z+2, r24	; 0x02
    c3b8:	8f ed       	ldi	r24, 0xDF	; 223
    c3ba:	91 e0       	ldi	r25, 0x01	; 1
    c3bc:	95 83       	std	Z+5, r25	; 0x05
    c3be:	84 83       	std	Z+4, r24	; 0x04
    c3c0:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
						E_Meter_RAM.Am *=10;
    c3c4:	60 91 df 01 	lds	r22, 0x01DF
    c3c8:	70 91 e0 01 	lds	r23, 0x01E0
    c3cc:	80 91 e1 01 	lds	r24, 0x01E1
    c3d0:	90 91 e2 01 	lds	r25, 0x01E2
    c3d4:	2a e0       	ldi	r18, 0x0A	; 10
    c3d6:	30 e0       	ldi	r19, 0x00	; 0
    c3d8:	40 e0       	ldi	r20, 0x00	; 0
    c3da:	50 e0       	ldi	r21, 0x00	; 0
    c3dc:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    c3e0:	60 93 df 01 	sts	0x01DF, r22
    c3e4:	70 93 e0 01 	sts	0x01E0, r23
    c3e8:	80 93 e1 01 	sts	0x01E1, r24
    c3ec:	90 93 e2 01 	sts	0x01E2, r25
    c3f0:	00 5f       	subi	r16, 0xF0	; 240
    c3f2:	1f 4f       	sbci	r17, 0xFF	; 255
    c3f4:	f7 01       	movw	r30, r14
    c3f6:	8d b7       	in	r24, 0x3d	; 61
    c3f8:	9e b7       	in	r25, 0x3e	; 62
    c3fa:	06 96       	adiw	r24, 0x06	; 6
    c3fc:	0f b6       	in	r0, 0x3f	; 63
    c3fe:	f8 94       	cli
    c400:	9e bf       	out	0x3e, r25	; 62
    c402:	0f be       	out	0x3f, r0	; 63
    c404:	8d bf       	out	0x3d, r24	; 61
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    c406:	d8 01       	movw	r26, r16
    c408:	8c 91       	ld	r24, X
    c40a:	80 83       	st	Z, r24
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    c40c:	11 96       	adiw	r26, 0x01	; 1
    c40e:	8c 91       	ld	r24, X
    c410:	81 83       	std	Z+1, r24	; 0x01
    c412:	02 50       	subi	r16, 0x02	; 2
    c414:	10 40       	sbci	r17, 0x00	; 0
    c416:	32 96       	adiw	r30, 0x02	; 2
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Am);
						E_Meter_RAM.Am *=10;
						Start = 18;
						for(uint8_t i=0; i<8; i=i+2){
    c418:	b6 e0       	ldi	r27, 0x06	; 6
    c41a:	09 3c       	cpi	r16, 0xC9	; 201
    c41c:	1b 07       	cpc	r17, r27
    c41e:	99 f7       	brne	.-26     	; 0xc406 <EMeter_Cycle+0x81e>
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
    c420:	00 d0       	rcall	.+0      	; 0xc422 <EMeter_Cycle+0x83a>
    c422:	00 d0       	rcall	.+0      	; 0xc424 <EMeter_Cycle+0x83c>
    c424:	00 d0       	rcall	.+0      	; 0xc426 <EMeter_Cycle+0x83e>
    c426:	ed b7       	in	r30, 0x3d	; 61
    c428:	fe b7       	in	r31, 0x3e	; 62
    c42a:	31 96       	adiw	r30, 0x01	; 1
    c42c:	ce 01       	movw	r24, r28
    c42e:	0e 96       	adiw	r24, 0x0e	; 14
    c430:	ad b7       	in	r26, 0x3d	; 61
    c432:	be b7       	in	r27, 0x3e	; 62
    c434:	12 96       	adiw	r26, 0x02	; 2
    c436:	9c 93       	st	X, r25
    c438:	8e 93       	st	-X, r24
    c43a:	11 97       	sbiw	r26, 0x01	; 1
    c43c:	88 e8       	ldi	r24, 0x88	; 136
    c43e:	91 e0       	ldi	r25, 0x01	; 1
    c440:	93 83       	std	Z+3, r25	; 0x03
    c442:	82 83       	std	Z+2, r24	; 0x02
    c444:	83 ee       	ldi	r24, 0xE3	; 227
    c446:	91 e0       	ldi	r25, 0x01	; 1
    c448:	95 83       	std	Z+5, r25	; 0x05
    c44a:	84 83       	std	Z+4, r24	; 0x04
    c44c:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
						E_Meter_RAM.Rp *=10;
    c450:	60 91 e3 01 	lds	r22, 0x01E3
    c454:	70 91 e4 01 	lds	r23, 0x01E4
    c458:	80 91 e5 01 	lds	r24, 0x01E5
    c45c:	90 91 e6 01 	lds	r25, 0x01E6
    c460:	2a e0       	ldi	r18, 0x0A	; 10
    c462:	30 e0       	ldi	r19, 0x00	; 0
    c464:	40 e0       	ldi	r20, 0x00	; 0
    c466:	50 e0       	ldi	r21, 0x00	; 0
    c468:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    c46c:	60 93 e3 01 	sts	0x01E3, r22
    c470:	70 93 e4 01 	sts	0x01E4, r23
    c474:	80 93 e5 01 	sts	0x01E5, r24
    c478:	90 93 e6 01 	sts	0x01E6, r25
    c47c:	f8 01       	movw	r30, r16
    c47e:	70 96       	adiw	r30, 0x10	; 16
    c480:	8d b7       	in	r24, 0x3d	; 61
    c482:	9e b7       	in	r25, 0x3e	; 62
    c484:	06 96       	adiw	r24, 0x06	; 6
    c486:	0f b6       	in	r0, 0x3f	; 63
    c488:	f8 94       	cli
    c48a:	9e bf       	out	0x3e, r25	; 62
    c48c:	0f be       	out	0x3f, r0	; 63
    c48e:	8d bf       	out	0x3d, r24	; 61
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
    c490:	80 81       	ld	r24, Z
    c492:	d7 01       	movw	r26, r14
    c494:	8c 93       	st	X, r24
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
    c496:	81 81       	ldd	r24, Z+1	; 0x01
    c498:	11 96       	adiw	r26, 0x01	; 1
    c49a:	8c 93       	st	X, r24
    c49c:	32 97       	sbiw	r30, 0x02	; 2
    c49e:	82 e0       	ldi	r24, 0x02	; 2
    c4a0:	90 e0       	ldi	r25, 0x00	; 0
    c4a2:	e8 0e       	add	r14, r24
    c4a4:	f9 1e       	adc	r15, r25
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rp);
						E_Meter_RAM.Rp *=10;
						Start = 26;
						for(uint8_t i=0; i<8; i=i+2){
    c4a6:	96 e0       	ldi	r25, 0x06	; 6
    c4a8:	e1 3d       	cpi	r30, 0xD1	; 209
    c4aa:	f9 07       	cpc	r31, r25
    c4ac:	89 f7       	brne	.-30     	; 0xc490 <EMeter_Cycle+0x8a8>
							TempStr[i+2] = EMeter_RxStr[Start+6-i];
							TempStr[i+3] = EMeter_RxStr[Start+7-i];
						}
						sscanf(TempStr,"%lXd",&E_Meter_RAM.Rm);
    c4ae:	00 d0       	rcall	.+0      	; 0xc4b0 <EMeter_Cycle+0x8c8>
    c4b0:	00 d0       	rcall	.+0      	; 0xc4b2 <EMeter_Cycle+0x8ca>
    c4b2:	00 d0       	rcall	.+0      	; 0xc4b4 <EMeter_Cycle+0x8cc>
    c4b4:	ed b7       	in	r30, 0x3d	; 61
    c4b6:	fe b7       	in	r31, 0x3e	; 62
    c4b8:	31 96       	adiw	r30, 0x01	; 1
    c4ba:	ce 01       	movw	r24, r28
    c4bc:	0e 96       	adiw	r24, 0x0e	; 14
    c4be:	ad b7       	in	r26, 0x3d	; 61
    c4c0:	be b7       	in	r27, 0x3e	; 62
    c4c2:	12 96       	adiw	r26, 0x02	; 2
    c4c4:	9c 93       	st	X, r25
    c4c6:	8e 93       	st	-X, r24
    c4c8:	11 97       	sbiw	r26, 0x01	; 1
    c4ca:	88 e8       	ldi	r24, 0x88	; 136
    c4cc:	91 e0       	ldi	r25, 0x01	; 1
    c4ce:	93 83       	std	Z+3, r25	; 0x03
    c4d0:	82 83       	std	Z+2, r24	; 0x02
    c4d2:	87 ee       	ldi	r24, 0xE7	; 231
    c4d4:	91 e0       	ldi	r25, 0x01	; 1
    c4d6:	95 83       	std	Z+5, r25	; 0x05
    c4d8:	84 83       	std	Z+4, r24	; 0x04
    c4da:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
						E_Meter_RAM.Rm *=10;
    c4de:	60 91 e7 01 	lds	r22, 0x01E7
    c4e2:	70 91 e8 01 	lds	r23, 0x01E8
    c4e6:	80 91 e9 01 	lds	r24, 0x01E9
    c4ea:	90 91 ea 01 	lds	r25, 0x01EA
    c4ee:	2a e0       	ldi	r18, 0x0A	; 10
    c4f0:	30 e0       	ldi	r19, 0x00	; 0
    c4f2:	40 e0       	ldi	r20, 0x00	; 0
    c4f4:	50 e0       	ldi	r21, 0x00	; 0
    c4f6:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    c4fa:	60 93 e7 01 	sts	0x01E7, r22
    c4fe:	70 93 e8 01 	sts	0x01E8, r23
    c502:	80 93 e9 01 	sts	0x01E9, r24
    c506:	90 93 ea 01 	sts	0x01EA, r25
				
						//StartTimer16(TD_EMeter,1000);
						EM_Retry = 0;
    c50a:	10 92 d3 01 	sts	0x01D3, r1
						EM_Mode = 255;
    c50e:	8f ef       	ldi	r24, 0xFF	; 255
    c510:	80 93 db 09 	sts	0x09DB, r24
    c514:	ed b7       	in	r30, 0x3d	; 61
    c516:	fe b7       	in	r31, 0x3e	; 62
    c518:	36 96       	adiw	r30, 0x06	; 6
    c51a:	0f b6       	in	r0, 0x3f	; 63
    c51c:	f8 94       	cli
    c51e:	fe bf       	out	0x3e, r31	; 62
    c520:	0f be       	out	0x3f, r0	; 63
    c522:	ed bf       	out	0x3d, r30	; 61
    c524:	13 c0       	rjmp	.+38     	; 0xc54c <EMeter_Cycle+0x964>
					break;
				case 255:
					//      
					break;
				default: 
					if(Timer16Stopp(TD_EMeter)){
    c526:	80 91 a0 0b 	lds	r24, 0x0BA0
    c52a:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c52e:	88 23       	and	r24, r24
    c530:	69 f0       	breq	.+26     	; 0xc54c <EMeter_Cycle+0x964>
						EMeter_SendCR(EM_REQ);
    c532:	8c e7       	ldi	r24, 0x7C	; 124
    c534:	97 e0       	ldi	r25, 0x07	; 7
    c536:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
						StartTimer16(TD_EMeter,100);
    c53a:	80 91 a0 0b 	lds	r24, 0x0BA0
    c53e:	64 e6       	ldi	r22, 0x64	; 100
    c540:	70 e0       	ldi	r23, 0x00	; 0
    c542:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 1;
    c546:	81 e0       	ldi	r24, 0x01	; 1
    c548:	80 93 db 09 	sts	0x09DB, r24
    c54c:	8c e5       	ldi	r24, 0x5C	; 92
    c54e:	91 e0       	ldi	r25, 0x01	; 1
    c550:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    c554:	18 2f       	mov	r17, r24
					break;
			}
		}

		// ---  230
		if(erb(&EMeterType) == MERCURY_230){
    c556:	83 30       	cpi	r24, 0x03	; 3
    c558:	09 f0       	breq	.+2      	; 0xc55c <EMeter_Cycle+0x974>
    c55a:	00 c2       	rjmp	.+1024   	; 0xc95c <EMeter_Cycle+0xd74>
			switch(EM_Mode){
    c55c:	80 91 db 09 	lds	r24, 0x09DB
    c560:	85 30       	cpi	r24, 0x05	; 5
    c562:	09 f4       	brne	.+2      	; 0xc566 <EMeter_Cycle+0x97e>
    c564:	19 c1       	rjmp	.+562    	; 0xc798 <EMeter_Cycle+0xbb0>
    c566:	86 30       	cpi	r24, 0x06	; 6
    c568:	78 f4       	brcc	.+30     	; 0xc588 <EMeter_Cycle+0x9a0>
    c56a:	82 30       	cpi	r24, 0x02	; 2
    c56c:	71 f1       	breq	.+92     	; 0xc5ca <EMeter_Cycle+0x9e2>
    c56e:	83 30       	cpi	r24, 0x03	; 3
    c570:	20 f4       	brcc	.+8      	; 0xc57a <EMeter_Cycle+0x992>
    c572:	81 30       	cpi	r24, 0x01	; 1
    c574:	09 f0       	breq	.+2      	; 0xc578 <EMeter_Cycle+0x990>
    c576:	de c1       	rjmp	.+956    	; 0xc934 <EMeter_Cycle+0xd4c>
    c578:	14 c0       	rjmp	.+40     	; 0xc5a2 <EMeter_Cycle+0x9ba>
    c57a:	83 30       	cpi	r24, 0x03	; 3
    c57c:	09 f4       	brne	.+2      	; 0xc580 <EMeter_Cycle+0x998>
    c57e:	86 c0       	rjmp	.+268    	; 0xc68c <EMeter_Cycle+0xaa4>
    c580:	84 30       	cpi	r24, 0x04	; 4
    c582:	09 f0       	breq	.+2      	; 0xc586 <EMeter_Cycle+0x99e>
    c584:	d7 c1       	rjmp	.+942    	; 0xc934 <EMeter_Cycle+0xd4c>
    c586:	96 c0       	rjmp	.+300    	; 0xc6b4 <EMeter_Cycle+0xacc>
    c588:	87 30       	cpi	r24, 0x07	; 7
    c58a:	09 f4       	brne	.+2      	; 0xc58e <EMeter_Cycle+0x9a6>
    c58c:	8b c1       	rjmp	.+790    	; 0xc8a4 <EMeter_Cycle+0xcbc>
    c58e:	87 30       	cpi	r24, 0x07	; 7
    c590:	08 f4       	brcc	.+2      	; 0xc594 <EMeter_Cycle+0x9ac>
    c592:	16 c1       	rjmp	.+556    	; 0xc7c0 <EMeter_Cycle+0xbd8>
    c594:	88 30       	cpi	r24, 0x08	; 8
    c596:	09 f4       	brne	.+2      	; 0xc59a <EMeter_Cycle+0x9b2>
    c598:	99 c1       	rjmp	.+818    	; 0xc8cc <EMeter_Cycle+0xce4>
    c59a:	8f 3f       	cpi	r24, 0xFF	; 255
    c59c:	09 f0       	breq	.+2      	; 0xc5a0 <EMeter_Cycle+0x9b8>
    c59e:	ca c1       	rjmp	.+916    	; 0xc934 <EMeter_Cycle+0xd4c>
    c5a0:	dd c1       	rjmp	.+954    	; 0xc95c <EMeter_Cycle+0xd74>

				case 1:	
					if(Timer16Stopp(TD_EMeter)){
    c5a2:	80 91 a0 0b 	lds	r24, 0x0BA0
    c5a6:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c5aa:	88 23       	and	r24, r24
    c5ac:	09 f4       	brne	.+2      	; 0xc5b0 <EMeter_Cycle+0x9c8>
    c5ae:	d6 c1       	rjmp	.+940    	; 0xc95c <EMeter_Cycle+0xd74>
						EMeter_SendData_P(EM_ENERGY_REQ, sizeof(EM_ENERGY_REQ));
    c5b0:	80 e9       	ldi	r24, 0x90	; 144
    c5b2:	97 e0       	ldi	r25, 0x07	; 7
    c5b4:	66 e0       	ldi	r22, 0x06	; 6
    c5b6:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    c5ba:	80 91 a0 0b 	lds	r24, 0x0BA0
    c5be:	64 e6       	ldi	r22, 0x64	; 100
    c5c0:	70 e0       	ldi	r23, 0x00	; 0
    c5c2:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 2;
    c5c6:	82 e0       	ldi	r24, 0x02	; 2
    c5c8:	c7 c1       	rjmp	.+910    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;
				case 2:
					if(Timer16Stopp(TD_EMeter)){	
    c5ca:	80 91 a0 0b 	lds	r24, 0x0BA0
    c5ce:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c5d2:	88 23       	and	r24, r24
    c5d4:	09 f4       	brne	.+2      	; 0xc5d8 <EMeter_Cycle+0x9f0>
    c5d6:	c2 c1       	rjmp	.+900    	; 0xc95c <EMeter_Cycle+0xd74>
				
						 //read data

						// check frame
						if(EMeter_RxCharN != 19){
    c5d8:	80 91 a6 0c 	lds	r24, 0x0CA6
    c5dc:	90 91 a7 0c 	lds	r25, 0x0CA7
    c5e0:	43 97       	sbiw	r24, 0x13	; 19
    c5e2:	09 f0       	breq	.+2      	; 0xc5e6 <EMeter_Cycle+0x9fe>
    c5e4:	98 c1       	rjmp	.+816    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 17);
    c5e6:	8e e1       	ldi	r24, 0x1E	; 30
    c5e8:	96 e2       	ldi	r25, 0x26	; 38
    c5ea:	69 eb       	ldi	r22, 0xB9	; 185
    c5ec:	76 e0       	ldi	r23, 0x06	; 6
    c5ee:	21 e1       	ldi	r18, 0x11	; 17
    c5f0:	30 e0       	ldi	r19, 0x00	; 0
    c5f2:	40 e0       	ldi	r20, 0x00	; 0
    c5f4:	50 e0       	ldi	r21, 0x00	; 0
    c5f6:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[18]<<8) + EMeter_RxStr[17];
						if(MyCRC != EM_CRC){
    c5fa:	30 91 cb 06 	lds	r19, 0x06CB
    c5fe:	20 e0       	ldi	r18, 0x00	; 0
    c600:	40 91 ca 06 	lds	r20, 0x06CA
    c604:	24 0f       	add	r18, r20
    c606:	31 1d       	adc	r19, r1
    c608:	82 17       	cp	r24, r18
    c60a:	93 07       	cpc	r25, r19
    c60c:	09 f0       	breq	.+2      	; 0xc610 <EMeter_Cycle+0xa28>
    c60e:	83 c1       	rjmp	.+774    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    c610:	80 91 b9 06 	lds	r24, 0x06B9
    c614:	88 23       	and	r24, r24
    c616:	09 f0       	breq	.+2      	; 0xc61a <EMeter_Cycle+0xa32>
    c618:	7e c1       	rjmp	.+764    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						//process data
						E_Meter_RAM.Ap = EMeter_M230_Data_Convert(1);
    c61a:	81 e0       	ldi	r24, 0x01	; 1
    c61c:	90 e0       	ldi	r25, 0x00	; 0
    c61e:	0e 94 55 42 	call	0x84aa	; 0x84aa <EMeter_M230_Data_Convert>
    c622:	60 93 db 01 	sts	0x01DB, r22
    c626:	70 93 dc 01 	sts	0x01DC, r23
    c62a:	80 93 dd 01 	sts	0x01DD, r24
    c62e:	90 93 de 01 	sts	0x01DE, r25
						E_Meter_RAM.Am = EMeter_M230_Data_Convert(5);
    c632:	85 e0       	ldi	r24, 0x05	; 5
    c634:	90 e0       	ldi	r25, 0x00	; 0
    c636:	0e 94 55 42 	call	0x84aa	; 0x84aa <EMeter_M230_Data_Convert>
    c63a:	60 93 df 01 	sts	0x01DF, r22
    c63e:	70 93 e0 01 	sts	0x01E0, r23
    c642:	80 93 e1 01 	sts	0x01E1, r24
    c646:	90 93 e2 01 	sts	0x01E2, r25
						E_Meter_RAM.Rp = EMeter_M230_Data_Convert(9);
    c64a:	89 e0       	ldi	r24, 0x09	; 9
    c64c:	90 e0       	ldi	r25, 0x00	; 0
    c64e:	0e 94 55 42 	call	0x84aa	; 0x84aa <EMeter_M230_Data_Convert>
    c652:	60 93 e3 01 	sts	0x01E3, r22
    c656:	70 93 e4 01 	sts	0x01E4, r23
    c65a:	80 93 e5 01 	sts	0x01E5, r24
    c65e:	90 93 e6 01 	sts	0x01E6, r25
						E_Meter_RAM.Rm = EMeter_M230_Data_Convert(13);
    c662:	8d e0       	ldi	r24, 0x0D	; 13
    c664:	90 e0       	ldi	r25, 0x00	; 0
    c666:	0e 94 55 42 	call	0x84aa	; 0x84aa <EMeter_M230_Data_Convert>
    c66a:	60 93 e7 01 	sts	0x01E7, r22
    c66e:	70 93 e8 01 	sts	0x01E8, r23
    c672:	80 93 e9 01 	sts	0x01E9, r24
    c676:	90 93 ea 01 	sts	0x01EA, r25

						//StartTimer16(TD_EMeter,1000);
						
						//EM_Mode = 255;

						StartTimer16(TD_EMeter,100);
    c67a:	80 91 a0 0b 	lds	r24, 0x0BA0
    c67e:	64 e6       	ldi	r22, 0x64	; 100
    c680:	70 e0       	ldi	r23, 0x00	; 0
    c682:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 3;
    c686:	10 93 db 09 	sts	0x09DB, r17
    c68a:	68 c1       	rjmp	.+720    	; 0xc95c <EMeter_Cycle+0xd74>
					}
					break;
				case 3:
					if(Timer16Stopp(TD_EMeter)){
    c68c:	80 91 a0 0b 	lds	r24, 0x0BA0
    c690:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c694:	88 23       	and	r24, r24
    c696:	09 f4       	brne	.+2      	; 0xc69a <EMeter_Cycle+0xab2>
    c698:	61 c1       	rjmp	.+706    	; 0xc95c <EMeter_Cycle+0xd74>
						EMeter_SendData_P(EM_VOLTAGE_REQ, sizeof(EM_VOLTAGE_REQ));
    c69a:	86 e9       	ldi	r24, 0x96	; 150
    c69c:	97 e0       	ldi	r25, 0x07	; 7
    c69e:	66 e0       	ldi	r22, 0x06	; 6
    c6a0:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    c6a4:	80 91 a0 0b 	lds	r24, 0x0BA0
    c6a8:	64 e6       	ldi	r22, 0x64	; 100
    c6aa:	70 e0       	ldi	r23, 0x00	; 0
    c6ac:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 4;							
    c6b0:	84 e0       	ldi	r24, 0x04	; 4
    c6b2:	52 c1       	rjmp	.+676    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;

				case 4:
					if(Timer16Stopp(TD_EMeter)){
    c6b4:	80 91 a0 0b 	lds	r24, 0x0BA0
    c6b8:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c6bc:	88 23       	and	r24, r24
    c6be:	09 f4       	brne	.+2      	; 0xc6c2 <EMeter_Cycle+0xada>
    c6c0:	4d c1       	rjmp	.+666    	; 0xc95c <EMeter_Cycle+0xd74>
						if(EMeter_RxCharN != 12){
    c6c2:	80 91 a6 0c 	lds	r24, 0x0CA6
    c6c6:	90 91 a7 0c 	lds	r25, 0x0CA7
    c6ca:	0c 97       	sbiw	r24, 0x0c	; 12
    c6cc:	09 f0       	breq	.+2      	; 0xc6d0 <EMeter_Cycle+0xae8>
    c6ce:	23 c1       	rjmp	.+582    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 10);
    c6d0:	8e e1       	ldi	r24, 0x1E	; 30
    c6d2:	96 e2       	ldi	r25, 0x26	; 38
    c6d4:	69 eb       	ldi	r22, 0xB9	; 185
    c6d6:	76 e0       	ldi	r23, 0x06	; 6
    c6d8:	2a e0       	ldi	r18, 0x0A	; 10
    c6da:	30 e0       	ldi	r19, 0x00	; 0
    c6dc:	40 e0       	ldi	r20, 0x00	; 0
    c6de:	50 e0       	ldi	r21, 0x00	; 0
    c6e0:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[11]<<8) + EMeter_RxStr[10];
						if(MyCRC != EM_CRC){
    c6e4:	30 91 c4 06 	lds	r19, 0x06C4
    c6e8:	20 e0       	ldi	r18, 0x00	; 0
    c6ea:	40 91 c3 06 	lds	r20, 0x06C3
    c6ee:	24 0f       	add	r18, r20
    c6f0:	31 1d       	adc	r19, r1
    c6f2:	82 17       	cp	r24, r18
    c6f4:	93 07       	cpc	r25, r19
    c6f6:	09 f0       	breq	.+2      	; 0xc6fa <EMeter_Cycle+0xb12>
    c6f8:	0e c1       	rjmp	.+540    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    c6fa:	80 91 b9 06 	lds	r24, 0x06B9
    c6fe:	88 23       	and	r24, r24
    c700:	09 f0       	breq	.+2      	; 0xc704 <EMeter_Cycle+0xb1c>
    c702:	09 c1       	rjmp	.+530    	; 0xc916 <EMeter_Cycle+0xd2e>
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c704:	80 91 bb 06 	lds	r24, 0x06BB
    c708:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c70a:	80 91 bc 06 	lds	r24, 0x06BC
    c70e:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c710:	89 81       	ldd	r24, Y+1	; 0x01
    c712:	9a 81       	ldd	r25, Y+2	; 0x02
    c714:	ff ef       	ldi	r31, 0xFF	; 255
    c716:	8f 3f       	cpi	r24, 0xFF	; 255
    c718:	9f 07       	cpc	r25, r31
    c71a:	11 f4       	brne	.+4      	; 0xc720 <EMeter_Cycle+0xb38>
    c71c:	80 e0       	ldi	r24, 0x00	; 0
    c71e:	90 e0       	ldi	r25, 0x00	; 0
						}
						if( EMeter_RxStr[0]!=0x00){
							EMeter_NoLink();
							break;
						}
						Ua=EMeter_M230_Data_ConvertWord(2)/100;
    c720:	64 e6       	ldi	r22, 0x64	; 100
    c722:	70 e0       	ldi	r23, 0x00	; 0
    c724:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c728:	70 93 a9 0c 	sts	0x0CA9, r23
    c72c:	60 93 a8 0c 	sts	0x0CA8, r22
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c730:	80 91 be 06 	lds	r24, 0x06BE
    c734:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c736:	80 91 bf 06 	lds	r24, 0x06BF
    c73a:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c73c:	89 81       	ldd	r24, Y+1	; 0x01
    c73e:	9a 81       	ldd	r25, Y+2	; 0x02
    c740:	2f ef       	ldi	r18, 0xFF	; 255
    c742:	8f 3f       	cpi	r24, 0xFF	; 255
    c744:	92 07       	cpc	r25, r18
    c746:	11 f4       	brne	.+4      	; 0xc74c <EMeter_Cycle+0xb64>
    c748:	80 e0       	ldi	r24, 0x00	; 0
    c74a:	90 e0       	ldi	r25, 0x00	; 0
						if( EMeter_RxStr[0]!=0x00){
							EMeter_NoLink();
							break;
						}
						Ua=EMeter_M230_Data_ConvertWord(2)/100;
						Ub=EMeter_M230_Data_ConvertWord(5)/100;
    c74c:	64 e6       	ldi	r22, 0x64	; 100
    c74e:	70 e0       	ldi	r23, 0x00	; 0
    c750:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c754:	70 93 68 03 	sts	0x0368, r23
    c758:	60 93 67 03 	sts	0x0367, r22
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c75c:	80 91 c1 06 	lds	r24, 0x06C1
    c760:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c762:	80 91 c2 06 	lds	r24, 0x06C2
    c766:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c768:	89 81       	ldd	r24, Y+1	; 0x01
    c76a:	9a 81       	ldd	r25, Y+2	; 0x02
    c76c:	af ef       	ldi	r26, 0xFF	; 255
    c76e:	8f 3f       	cpi	r24, 0xFF	; 255
    c770:	9a 07       	cpc	r25, r26
    c772:	11 f4       	brne	.+4      	; 0xc778 <EMeter_Cycle+0xb90>
    c774:	80 e0       	ldi	r24, 0x00	; 0
    c776:	90 e0       	ldi	r25, 0x00	; 0
							EMeter_NoLink();
							break;
						}
						Ua=EMeter_M230_Data_ConvertWord(2)/100;
						Ub=EMeter_M230_Data_ConvertWord(5)/100;
						Uc=EMeter_M230_Data_ConvertWord(8)/100;
    c778:	64 e6       	ldi	r22, 0x64	; 100
    c77a:	70 e0       	ldi	r23, 0x00	; 0
    c77c:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c780:	70 93 de 09 	sts	0x09DE, r23
    c784:	60 93 dd 09 	sts	0x09DD, r22
						StartTimer16(TD_EMeter,100);
    c788:	80 91 a0 0b 	lds	r24, 0x0BA0
    c78c:	64 e6       	ldi	r22, 0x64	; 100
    c78e:	70 e0       	ldi	r23, 0x00	; 0
    c790:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 5;						
    c794:	85 e0       	ldi	r24, 0x05	; 5
    c796:	e0 c0       	rjmp	.+448    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;

				case 5:
					if(Timer16Stopp(TD_EMeter)){
    c798:	80 91 a0 0b 	lds	r24, 0x0BA0
    c79c:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c7a0:	88 23       	and	r24, r24
    c7a2:	09 f4       	brne	.+2      	; 0xc7a6 <EMeter_Cycle+0xbbe>
    c7a4:	db c0       	rjmp	.+438    	; 0xc95c <EMeter_Cycle+0xd74>
						EMeter_SendData_P(EM_CURRENT_REQ, sizeof(EM_CURRENT_REQ));
    c7a6:	8c e9       	ldi	r24, 0x9C	; 156
    c7a8:	97 e0       	ldi	r25, 0x07	; 7
    c7aa:	66 e0       	ldi	r22, 0x06	; 6
    c7ac:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    c7b0:	80 91 a0 0b 	lds	r24, 0x0BA0
    c7b4:	64 e6       	ldi	r22, 0x64	; 100
    c7b6:	70 e0       	ldi	r23, 0x00	; 0
    c7b8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 6;							
    c7bc:	86 e0       	ldi	r24, 0x06	; 6
    c7be:	cc c0       	rjmp	.+408    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;

				case 6:
					if(Timer16Stopp(TD_EMeter)){
    c7c0:	80 91 a0 0b 	lds	r24, 0x0BA0
    c7c4:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c7c8:	88 23       	and	r24, r24
    c7ca:	09 f4       	brne	.+2      	; 0xc7ce <EMeter_Cycle+0xbe6>
    c7cc:	c7 c0       	rjmp	.+398    	; 0xc95c <EMeter_Cycle+0xd74>
						if(EMeter_RxCharN != 12){
    c7ce:	80 91 a6 0c 	lds	r24, 0x0CA6
    c7d2:	90 91 a7 0c 	lds	r25, 0x0CA7
    c7d6:	0c 97       	sbiw	r24, 0x0c	; 12
    c7d8:	09 f0       	breq	.+2      	; 0xc7dc <EMeter_Cycle+0xbf4>
    c7da:	9d c0       	rjmp	.+314    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 10);
    c7dc:	8e e1       	ldi	r24, 0x1E	; 30
    c7de:	96 e2       	ldi	r25, 0x26	; 38
    c7e0:	69 eb       	ldi	r22, 0xB9	; 185
    c7e2:	76 e0       	ldi	r23, 0x06	; 6
    c7e4:	2a e0       	ldi	r18, 0x0A	; 10
    c7e6:	30 e0       	ldi	r19, 0x00	; 0
    c7e8:	40 e0       	ldi	r20, 0x00	; 0
    c7ea:	50 e0       	ldi	r21, 0x00	; 0
    c7ec:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[11]<<8) + EMeter_RxStr[10];
						if(MyCRC != EM_CRC){
    c7f0:	30 91 c4 06 	lds	r19, 0x06C4
    c7f4:	20 e0       	ldi	r18, 0x00	; 0
    c7f6:	40 91 c3 06 	lds	r20, 0x06C3
    c7fa:	24 0f       	add	r18, r20
    c7fc:	31 1d       	adc	r19, r1
    c7fe:	82 17       	cp	r24, r18
    c800:	93 07       	cpc	r25, r19
    c802:	09 f0       	breq	.+2      	; 0xc806 <EMeter_Cycle+0xc1e>
    c804:	88 c0       	rjmp	.+272    	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    c806:	80 91 b9 06 	lds	r24, 0x06B9
    c80a:	88 23       	and	r24, r24
    c80c:	09 f0       	breq	.+2      	; 0xc810 <EMeter_Cycle+0xc28>
    c80e:	83 c0       	rjmp	.+262    	; 0xc916 <EMeter_Cycle+0xd2e>
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c810:	80 91 bb 06 	lds	r24, 0x06BB
    c814:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c816:	80 91 bc 06 	lds	r24, 0x06BC
    c81a:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c81c:	89 81       	ldd	r24, Y+1	; 0x01
    c81e:	9a 81       	ldd	r25, Y+2	; 0x02
    c820:	bf ef       	ldi	r27, 0xFF	; 255
    c822:	8f 3f       	cpi	r24, 0xFF	; 255
    c824:	9b 07       	cpc	r25, r27
    c826:	11 f4       	brne	.+4      	; 0xc82c <EMeter_Cycle+0xc44>
    c828:	80 e0       	ldi	r24, 0x00	; 0
    c82a:	90 e0       	ldi	r25, 0x00	; 0
						}
						if( EMeter_RxStr[0]!=0x00){
							EMeter_NoLink();
							break;
						}
						Ia=EMeter_M230_Data_ConvertWord(2)/10;
    c82c:	6a e0       	ldi	r22, 0x0A	; 10
    c82e:	70 e0       	ldi	r23, 0x00	; 0
    c830:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c834:	70 93 76 03 	sts	0x0376, r23
    c838:	60 93 75 03 	sts	0x0375, r22
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c83c:	80 91 be 06 	lds	r24, 0x06BE
    c840:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c842:	80 91 bf 06 	lds	r24, 0x06BF
    c846:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c848:	89 81       	ldd	r24, Y+1	; 0x01
    c84a:	9a 81       	ldd	r25, Y+2	; 0x02
    c84c:	ef ef       	ldi	r30, 0xFF	; 255
    c84e:	8f 3f       	cpi	r24, 0xFF	; 255
    c850:	9e 07       	cpc	r25, r30
    c852:	11 f4       	brne	.+4      	; 0xc858 <EMeter_Cycle+0xc70>
    c854:	80 e0       	ldi	r24, 0x00	; 0
    c856:	90 e0       	ldi	r25, 0x00	; 0
						if( EMeter_RxStr[0]!=0x00){
							EMeter_NoLink();
							break;
						}
						Ia=EMeter_M230_Data_ConvertWord(2)/10;
						Ib=EMeter_M230_Data_ConvertWord(5)/10;
    c858:	6a e0       	ldi	r22, 0x0A	; 10
    c85a:	70 e0       	ldi	r23, 0x00	; 0
    c85c:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c860:	70 93 b7 08 	sts	0x08B7, r23
    c864:	60 93 b6 08 	sts	0x08B6, r22
}
// ~~~~~~~~~
// ~~~~~~~~~
uint16_t EMeter_M230_Data_ConvertWord(uint16_t Start){
	uint8_t TempArray[4];
	TempArray[0] = EMeter_RxStr[Start];
    c868:	80 91 c1 06 	lds	r24, 0x06C1
    c86c:	89 83       	std	Y+1, r24	; 0x01
	TempArray[1] = EMeter_RxStr[Start+1];
    c86e:	80 91 c2 06 	lds	r24, 0x06C2
    c872:	8a 83       	std	Y+2, r24	; 0x02
	if(*(uint16_t*)TempArray == 0xFFFF) return 0;
    c874:	89 81       	ldd	r24, Y+1	; 0x01
    c876:	9a 81       	ldd	r25, Y+2	; 0x02
    c878:	ff ef       	ldi	r31, 0xFF	; 255
    c87a:	8f 3f       	cpi	r24, 0xFF	; 255
    c87c:	9f 07       	cpc	r25, r31
    c87e:	11 f4       	brne	.+4      	; 0xc884 <EMeter_Cycle+0xc9c>
    c880:	80 e0       	ldi	r24, 0x00	; 0
    c882:	90 e0       	ldi	r25, 0x00	; 0
							EMeter_NoLink();
							break;
						}
						Ia=EMeter_M230_Data_ConvertWord(2)/10;
						Ib=EMeter_M230_Data_ConvertWord(5)/10;
						Ic=EMeter_M230_Data_ConvertWord(8)/10;
    c884:	6a e0       	ldi	r22, 0x0A	; 10
    c886:	70 e0       	ldi	r23, 0x00	; 0
    c888:	0e 94 16 91 	call	0x1222c	; 0x1222c <__udivmodhi4>
    c88c:	70 93 ed 08 	sts	0x08ED, r23
    c890:	60 93 ec 08 	sts	0x08EC, r22
						StartTimer16(TD_EMeter,100);
    c894:	80 91 a0 0b 	lds	r24, 0x0BA0
    c898:	64 e6       	ldi	r22, 0x64	; 100
    c89a:	70 e0       	ldi	r23, 0x00	; 0
    c89c:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 7;						
    c8a0:	87 e0       	ldi	r24, 0x07	; 7
    c8a2:	5a c0       	rjmp	.+180    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;

				case 7:
					if(Timer16Stopp(TD_EMeter)){
    c8a4:	80 91 a0 0b 	lds	r24, 0x0BA0
    c8a8:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c8ac:	88 23       	and	r24, r24
    c8ae:	09 f4       	brne	.+2      	; 0xc8b2 <EMeter_Cycle+0xcca>
    c8b0:	55 c0       	rjmp	.+170    	; 0xc95c <EMeter_Cycle+0xd74>
						EMeter_SendData_P(EM_ACTIVEPOWER_REQ, sizeof(EM_ACTIVEPOWER_REQ));
    c8b2:	82 ea       	ldi	r24, 0xA2	; 162
    c8b4:	97 e0       	ldi	r25, 0x07	; 7
    c8b6:	66 e0       	ldi	r22, 0x06	; 6
    c8b8:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    c8bc:	80 91 a0 0b 	lds	r24, 0x0BA0
    c8c0:	64 e6       	ldi	r22, 0x64	; 100
    c8c2:	70 e0       	ldi	r23, 0x00	; 0
    c8c4:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 8;							
    c8c8:	88 e0       	ldi	r24, 0x08	; 8
    c8ca:	46 c0       	rjmp	.+140    	; 0xc958 <EMeter_Cycle+0xd70>
					}
					break;

				case 8:
					if(Timer16Stopp(TD_EMeter)){
    c8cc:	80 91 a0 0b 	lds	r24, 0x0BA0
    c8d0:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c8d4:	88 23       	and	r24, r24
    c8d6:	09 f4       	brne	.+2      	; 0xc8da <EMeter_Cycle+0xcf2>
    c8d8:	41 c0       	rjmp	.+130    	; 0xc95c <EMeter_Cycle+0xd74>
						if(EMeter_RxCharN != 15){
    c8da:	80 91 a6 0c 	lds	r24, 0x0CA6
    c8de:	90 91 a7 0c 	lds	r25, 0x0CA7
    c8e2:	0f 97       	sbiw	r24, 0x0f	; 15
    c8e4:	c1 f4       	brne	.+48     	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						uint16_t MyCRC = CRC(rrb, (uint8_t *)EMeter_RxStr, 13);
    c8e6:	8e e1       	ldi	r24, 0x1E	; 30
    c8e8:	96 e2       	ldi	r25, 0x26	; 38
    c8ea:	69 eb       	ldi	r22, 0xB9	; 185
    c8ec:	76 e0       	ldi	r23, 0x06	; 6
    c8ee:	2d e0       	ldi	r18, 0x0D	; 13
    c8f0:	30 e0       	ldi	r19, 0x00	; 0
    c8f2:	40 e0       	ldi	r20, 0x00	; 0
    c8f4:	50 e0       	ldi	r21, 0x00	; 0
    c8f6:	0e 94 8d 26 	call	0x4d1a	; 0x4d1a <CRC>
						uint16_t EM_CRC = ((uint16_t)EMeter_RxStr[14]<<8) + EMeter_RxStr[13];
						if(MyCRC != EM_CRC){
    c8fa:	30 91 c7 06 	lds	r19, 0x06C7
    c8fe:	20 e0       	ldi	r18, 0x00	; 0
    c900:	40 91 c6 06 	lds	r20, 0x06C6
    c904:	24 0f       	add	r18, r20
    c906:	31 1d       	adc	r19, r1
    c908:	82 17       	cp	r24, r18
    c90a:	93 07       	cpc	r25, r19
    c90c:	21 f4       	brne	.+8      	; 0xc916 <EMeter_Cycle+0xd2e>
							EMeter_NoLink();
							break;
						}
						if( EMeter_RxStr[0]!=0x00){
    c90e:	80 91 b9 06 	lds	r24, 0x06B9
    c912:	88 23       	and	r24, r24
    c914:	19 f0       	breq	.+6      	; 0xc91c <EMeter_Cycle+0xd34>
							EMeter_NoLink();
    c916:	0e 94 ec 41 	call	0x83d8	; 0x83d8 <EMeter_NoLink>
    c91a:	20 c0       	rjmp	.+64     	; 0xc95c <EMeter_Cycle+0xd74>
							break;
						}
						EM_PowerActive=EMeter_M230_Data_ConvertP(1);
    c91c:	81 e0       	ldi	r24, 0x01	; 1
    c91e:	90 e0       	ldi	r25, 0x00	; 0
    c920:	0e 94 9c 42 	call	0x8538	; 0x8538 <EMeter_M230_Data_ConvertP>
    c924:	90 93 da 09 	sts	0x09DA, r25
    c928:	80 93 d9 09 	sts	0x09D9, r24

						EM_Retry = 0;
    c92c:	10 92 d3 01 	sts	0x01D3, r1
						EM_Mode = 255;						
    c930:	8f ef       	ldi	r24, 0xFF	; 255
    c932:	12 c0       	rjmp	.+36     	; 0xc958 <EMeter_Cycle+0xd70>
					break;
				case 255:
					//      
					break;
				default: 
					if(Timer16Stopp(TD_EMeter)){
    c934:	80 91 a0 0b 	lds	r24, 0x0BA0
    c938:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    c93c:	88 23       	and	r24, r24
    c93e:	71 f0       	breq	.+28     	; 0xc95c <EMeter_Cycle+0xd74>
						EMeter_SendData_P(EM_OPEN_CH_REQ, sizeof(EM_OPEN_CH_REQ));
    c940:	85 e8       	ldi	r24, 0x85	; 133
    c942:	97 e0       	ldi	r25, 0x07	; 7
    c944:	6b e0       	ldi	r22, 0x0B	; 11
    c946:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
						StartTimer16(TD_EMeter,100);
    c94a:	80 91 a0 0b 	lds	r24, 0x0BA0
    c94e:	64 e6       	ldi	r22, 0x64	; 100
    c950:	70 e0       	ldi	r23, 0x00	; 0
    c952:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						EM_Mode = 1;
    c956:	81 e0       	ldi	r24, 0x01	; 1
    c958:	80 93 db 09 	sts	0x09DB, r24
    c95c:	8c e5       	ldi	r24, 0x5C	; 92
    c95e:	91 e0       	ldi	r25, 0x01	; 1
    c960:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
		// EM_Mode = 0 -  .   ATZ
		// EM_Mode = 1 -      ATE0  AT,     
		//   1  RING ( 5   5 )  30 
		// EM_Mode = 2 -    (/?!)   ATA
		// 
		if(erb(&EMeterType) == ELVIN_MODEM){
    c964:	84 30       	cpi	r24, 0x04	; 4
    c966:	09 f0       	breq	.+2      	; 0xc96a <EMeter_Cycle+0xd82>
    c968:	13 c2       	rjmp	.+1062   	; 0xcd90 <EMeter_Cycle+0x11a8>
		
			#ifdef CTS
				cli();
    c96a:	f8 94       	cli
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
}
void CTS_ON(void){
	PORTD|=(1<<PD5);
    c96c:	95 9a       	sbi	0x12, 5	; 18
				CTS_ON();	// Clear RTS pin
				sei();
    c96e:	78 94       	sei
			#endif

			if(EM_Retry>10){
    c970:	80 91 d3 01 	lds	r24, 0x01D3
    c974:	8b 30       	cpi	r24, 0x0B	; 11
    c976:	18 f1       	brcs	.+70     	; 0xc9be <EMeter_Cycle+0xdd6>
	//StartTimer16(TD_EMeter,1000);
	EM_Mode = 255;
}
// ~~~~~~~~~
void EMeter_ELVIN_Modem_NoLink(void){
	E_Meter_RAM.Ap = 0;
    c978:	10 92 db 01 	sts	0x01DB, r1
    c97c:	10 92 dc 01 	sts	0x01DC, r1
    c980:	10 92 dd 01 	sts	0x01DD, r1
    c984:	10 92 de 01 	sts	0x01DE, r1
	E_Meter_RAM.Am = 0;
    c988:	10 92 df 01 	sts	0x01DF, r1
    c98c:	10 92 e0 01 	sts	0x01E0, r1
    c990:	10 92 e1 01 	sts	0x01E1, r1
    c994:	10 92 e2 01 	sts	0x01E2, r1
	E_Meter_RAM.Rp = 0;
    c998:	10 92 e3 01 	sts	0x01E3, r1
    c99c:	10 92 e4 01 	sts	0x01E4, r1
    c9a0:	10 92 e5 01 	sts	0x01E5, r1
    c9a4:	10 92 e6 01 	sts	0x01E6, r1
	E_Meter_RAM.Rm = 0;
    c9a8:	10 92 e7 01 	sts	0x01E7, r1
    c9ac:	10 92 e8 01 	sts	0x01E8, r1
    c9b0:	10 92 e9 01 	sts	0x01E9, r1
    c9b4:	10 92 ea 01 	sts	0x01EA, r1
				sei();
			#endif

			if(EM_Retry>10){
				EMeter_ELVIN_Modem_NoLink();
				EM_Retry = 10;
    c9b8:	8a e0       	ldi	r24, 0x0A	; 10
    c9ba:	80 93 d3 01 	sts	0x01D3, r24
			}
			
			if(!EMeter_TxFlag){		//   
    c9be:	80 91 c7 08 	lds	r24, 0x08C7
    c9c2:	88 23       	and	r24, r24
    c9c4:	09 f0       	breq	.+2      	; 0xc9c8 <EMeter_Cycle+0xde0>
    c9c6:	e4 c1       	rjmp	.+968    	; 0xcd90 <EMeter_Cycle+0x11a8>

				//   ATZ
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATZ) != NULL) ){
    c9c8:	89 eb       	ldi	r24, 0xB9	; 185
    c9ca:	96 e0       	ldi	r25, 0x06	; 6
    c9cc:	6c ea       	ldi	r22, 0xAC	; 172
    c9ce:	77 e0       	ldi	r23, 0x07	; 7
    c9d0:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    c9d4:	89 2b       	or	r24, r25
    c9d6:	e1 f0       	breq	.+56     	; 0xca10 <EMeter_Cycle+0xe28>
    c9d8:	e9 eb       	ldi	r30, 0xB9	; 185
    c9da:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    c9dc:	11 92       	st	Z+, r1
    c9de:	27 e0       	ldi	r18, 0x07	; 7
    c9e0:	e7 3b       	cpi	r30, 0xB7	; 183
    c9e2:	f2 07       	cpc	r31, r18
    c9e4:	d9 f7       	brne	.-10     	; 0xc9dc <EMeter_Cycle+0xdf4>
	EMeter_RxCharN = 0;
    c9e6:	10 92 a7 0c 	sts	0x0CA7, r1
    c9ea:	10 92 a6 0c 	sts	0x0CA6, r1
			if(!EMeter_TxFlag){		//   

				//   ATZ
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATZ) != NULL) ){
					EMeter_ClearRXStr();
					EMeter_SendData_P(EM_RESP_OK, sizeof(EM_RESP_OK)-1);
    c9ee:	84 ec       	ldi	r24, 0xC4	; 196
    c9f0:	97 e0       	ldi	r25, 0x07	; 7
    c9f2:	66 e0       	ldi	r22, 0x06	; 6
    c9f4:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
					StartTimer16(TD_EMeter, 1500);	// 40
    c9f8:	80 91 a0 0b 	lds	r24, 0x0BA0
    c9fc:	6c ed       	ldi	r22, 0xDC	; 220
    c9fe:	75 e0       	ldi	r23, 0x05	; 5
    ca00:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					EM_Retry++;	
    ca04:	80 91 d3 01 	lds	r24, 0x01D3
    ca08:	8f 5f       	subi	r24, 0xFF	; 255
    ca0a:	80 93 d3 01 	sts	0x01D3, r24
    ca0e:	be c1       	rjmp	.+892    	; 0xcd8c <EMeter_Cycle+0x11a4>
					EM_Mode = 0;
					return;
				}

				//   ATE0
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATE0) != NULL) ){
    ca10:	89 eb       	ldi	r24, 0xB9	; 185
    ca12:	96 e0       	ldi	r25, 0x06	; 6
    ca14:	61 eb       	ldi	r22, 0xB1	; 177
    ca16:	77 e0       	ldi	r23, 0x07	; 7
    ca18:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    ca1c:	89 2b       	or	r24, r25
    ca1e:	41 f0       	breq	.+16     	; 0xca30 <EMeter_Cycle+0xe48>
    ca20:	e9 eb       	ldi	r30, 0xB9	; 185
    ca22:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    ca24:	11 92       	st	Z+, r1
    ca26:	87 e0       	ldi	r24, 0x07	; 7
    ca28:	e7 3b       	cpi	r30, 0xB7	; 183
    ca2a:	f8 07       	cpc	r31, r24
    ca2c:	d9 f7       	brne	.-10     	; 0xca24 <EMeter_Cycle+0xe3c>
    ca2e:	0f c0       	rjmp	.+30     	; 0xca4e <EMeter_Cycle+0xe66>
					EM_Mode = 1;
					return;
				}

				//   AT
				if( (strstr_P(EMeter_RxStr, EM_RESP_AT) != NULL) ){
    ca30:	89 eb       	ldi	r24, 0xB9	; 185
    ca32:	96 e0       	ldi	r25, 0x06	; 6
    ca34:	68 ea       	ldi	r22, 0xA8	; 168
    ca36:	77 e0       	ldi	r23, 0x07	; 7
    ca38:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    ca3c:	89 2b       	or	r24, r25
    ca3e:	89 f0       	breq	.+34     	; 0xca62 <EMeter_Cycle+0xe7a>
    ca40:	e9 eb       	ldi	r30, 0xB9	; 185
    ca42:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    ca44:	11 92       	st	Z+, r1
    ca46:	97 e0       	ldi	r25, 0x07	; 7
    ca48:	e7 3b       	cpi	r30, 0xB7	; 183
    ca4a:	f9 07       	cpc	r31, r25
    ca4c:	d9 f7       	brne	.-10     	; 0xca44 <EMeter_Cycle+0xe5c>
	EMeter_RxCharN = 0;
    ca4e:	10 92 a7 0c 	sts	0x0CA7, r1
    ca52:	10 92 a6 0c 	sts	0x0CA6, r1
				}

				//   AT
				if( (strstr_P(EMeter_RxStr, EM_RESP_AT) != NULL) ){
					EMeter_ClearRXStr();
					EMeter_SendData_P(EM_RESP_OK, sizeof(EM_RESP_OK)-1);
    ca56:	84 ec       	ldi	r24, 0xC4	; 196
    ca58:	97 e0       	ldi	r25, 0x07	; 7
    ca5a:	66 e0       	ldi	r22, 0x06	; 6
    ca5c:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
    ca60:	91 c1       	rjmp	.+802    	; 0xcd84 <EMeter_Cycle+0x119c>
					EM_Mode = 1;
					return;
				}

				//   +++ATH
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATH) != NULL) ){
    ca62:	89 eb       	ldi	r24, 0xB9	; 185
    ca64:	96 e0       	ldi	r25, 0x06	; 6
    ca66:	67 eb       	ldi	r22, 0xB7	; 183
    ca68:	77 e0       	ldi	r23, 0x07	; 7
    ca6a:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    ca6e:	89 2b       	or	r24, r25
    ca70:	61 f0       	breq	.+24     	; 0xca8a <EMeter_Cycle+0xea2>
    ca72:	e9 eb       	ldi	r30, 0xB9	; 185
    ca74:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    ca76:	11 92       	st	Z+, r1
    ca78:	a7 e0       	ldi	r26, 0x07	; 7
    ca7a:	e7 3b       	cpi	r30, 0xB7	; 183
    ca7c:	fa 07       	cpc	r31, r26
    ca7e:	d9 f7       	brne	.-10     	; 0xca76 <EMeter_Cycle+0xe8e>
	EMeter_RxCharN = 0;
    ca80:	10 92 a7 0c 	sts	0x0CA7, r1
    ca84:	10 92 a6 0c 	sts	0x0CA6, r1
    ca88:	7d c1       	rjmp	.+762    	; 0xcd84 <EMeter_Cycle+0x119c>
					EM_Mode = 1;
					return;
				}

				//   ATA
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATA) != NULL) ){
    ca8a:	89 eb       	ldi	r24, 0xB9	; 185
    ca8c:	96 e0       	ldi	r25, 0x06	; 6
    ca8e:	6f eb       	ldi	r22, 0xBF	; 191
    ca90:	77 e0       	ldi	r23, 0x07	; 7
    ca92:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    ca96:	89 2b       	or	r24, r25
    ca98:	a1 f0       	breq	.+40     	; 0xcac2 <EMeter_Cycle+0xeda>
    ca9a:	e9 eb       	ldi	r30, 0xB9	; 185
    ca9c:	f6 e0       	ldi	r31, 0x06	; 6
	EMeter_SendFirstChar();
}
// ~~~~~~~~~
void EMeter_ClearRXStr(void){
	uint16_t i;
	for(i=0; i<EM_RX_SIZE; i++) EMeter_RxStr[i] = 0;
    ca9e:	11 92       	st	Z+, r1
    caa0:	b7 e0       	ldi	r27, 0x07	; 7
    caa2:	e7 3b       	cpi	r30, 0xB7	; 183
    caa4:	fb 07       	cpc	r31, r27
    caa6:	d9 f7       	brne	.-10     	; 0xca9e <EMeter_Cycle+0xeb6>
	EMeter_RxCharN = 0;
    caa8:	10 92 a7 0c 	sts	0x0CA7, r1
    caac:	10 92 a6 0c 	sts	0x0CA6, r1
				}

				//   ATA
				if( (strstr_P(EMeter_RxStr, EM_RESP_ATA) != NULL) ){
					EMeter_ClearRXStr();
					EMeter_SendData_P(EM_RESP_CONNECT, sizeof(EM_RESP_CONNECT)-1);
    cab0:	84 ed       	ldi	r24, 0xD4	; 212
    cab2:	97 e0       	ldi	r25, 0x07	; 7
    cab4:	6b e0       	ldi	r22, 0x0B	; 11
    cab6:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
					RING_Retry = 0;
    caba:	10 92 ed 01 	sts	0x01ED, r1
					EM_Mode = 2;
    cabe:	82 e0       	ldi	r24, 0x02	; 2
    cac0:	62 c1       	rjmp	.+708    	; 0xcd86 <EMeter_Cycle+0x119e>
					return;
				}
			

				if(Timer16Stopp(TD_EMeter)){
    cac2:	80 91 a0 0b 	lds	r24, 0x0BA0
    cac6:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    caca:	88 23       	and	r24, r24
    cacc:	09 f4       	brne	.+2      	; 0xcad0 <EMeter_Cycle+0xee8>
    cace:	60 c1       	rjmp	.+704    	; 0xcd90 <EMeter_Cycle+0x11a8>
					switch(EM_Mode){
    cad0:	80 91 db 09 	lds	r24, 0x09DB
    cad4:	83 30       	cpi	r24, 0x03	; 3
    cad6:	09 f4       	brne	.+2      	; 0xcada <EMeter_Cycle+0xef2>
    cad8:	5c c0       	rjmp	.+184    	; 0xcb92 <EMeter_Cycle+0xfaa>
    cada:	84 30       	cpi	r24, 0x04	; 4
    cadc:	30 f4       	brcc	.+12     	; 0xcaea <EMeter_Cycle+0xf02>
    cade:	81 30       	cpi	r24, 0x01	; 1
    cae0:	79 f1       	breq	.+94     	; 0xcb40 <EMeter_Cycle+0xf58>
    cae2:	82 30       	cpi	r24, 0x02	; 2
    cae4:	08 f0       	brcs	.+2      	; 0xcae8 <EMeter_Cycle+0xf00>
    cae6:	49 c0       	rjmp	.+146    	; 0xcb7a <EMeter_Cycle+0xf92>
    cae8:	0a c0       	rjmp	.+20     	; 0xcafe <EMeter_Cycle+0xf16>
    caea:	85 30       	cpi	r24, 0x05	; 5
    caec:	09 f4       	brne	.+2      	; 0xcaf0 <EMeter_Cycle+0xf08>
    caee:	30 c1       	rjmp	.+608    	; 0xcd50 <EMeter_Cycle+0x1168>
    caf0:	85 30       	cpi	r24, 0x05	; 5
    caf2:	08 f4       	brcc	.+2      	; 0xcaf6 <EMeter_Cycle+0xf0e>
    caf4:	5a c0       	rjmp	.+180    	; 0xcbaa <EMeter_Cycle+0xfc2>
    caf6:	86 30       	cpi	r24, 0x06	; 6
    caf8:	09 f0       	breq	.+2      	; 0xcafc <EMeter_Cycle+0xf14>
    cafa:	48 c1       	rjmp	.+656    	; 0xcd8c <EMeter_Cycle+0x11a4>
    cafc:	38 c1       	rjmp	.+624    	; 0xcd6e <EMeter_Cycle+0x1186>
	//StartTimer16(TD_EMeter,1000);
	EM_Mode = 255;
}
// ~~~~~~~~~
void EMeter_ELVIN_Modem_NoLink(void){
	E_Meter_RAM.Ap = 0;
    cafe:	10 92 db 01 	sts	0x01DB, r1
    cb02:	10 92 dc 01 	sts	0x01DC, r1
    cb06:	10 92 dd 01 	sts	0x01DD, r1
    cb0a:	10 92 de 01 	sts	0x01DE, r1
	E_Meter_RAM.Am = 0;
    cb0e:	10 92 df 01 	sts	0x01DF, r1
    cb12:	10 92 e0 01 	sts	0x01E0, r1
    cb16:	10 92 e1 01 	sts	0x01E1, r1
    cb1a:	10 92 e2 01 	sts	0x01E2, r1
	E_Meter_RAM.Rp = 0;
    cb1e:	10 92 e3 01 	sts	0x01E3, r1
    cb22:	10 92 e4 01 	sts	0x01E4, r1
    cb26:	10 92 e5 01 	sts	0x01E5, r1
    cb2a:	10 92 e6 01 	sts	0x01E6, r1
	E_Meter_RAM.Rm = 0;
    cb2e:	10 92 e7 01 	sts	0x01E7, r1
    cb32:	10 92 e8 01 	sts	0x01E8, r1
    cb36:	10 92 e9 01 	sts	0x01E9, r1
    cb3a:	10 92 ea 01 	sts	0x01EA, r1
    cb3e:	28 c1       	rjmp	.+592    	; 0xcd90 <EMeter_Cycle+0x11a8>
					switch(EM_Mode){
						case 0:
							EMeter_ELVIN_Modem_NoLink();
							break;
						case 1:
							if(RING_Retry++>5){ 
    cb40:	80 91 ed 01 	lds	r24, 0x01ED
    cb44:	8f 5f       	subi	r24, 0xFF	; 255
    cb46:	80 93 ed 01 	sts	0x01ED, r24
    cb4a:	81 50       	subi	r24, 0x01	; 1
    cb4c:	86 30       	cpi	r24, 0x06	; 6
    cb4e:	48 f0       	brcs	.+18     	; 0xcb62 <EMeter_Cycle+0xf7a>
								EM_Mode = 5;
    cb50:	85 e0       	ldi	r24, 0x05	; 5
    cb52:	80 93 db 09 	sts	0x09DB, r24
								EM_Retry++;
    cb56:	80 91 d3 01 	lds	r24, 0x01D3
    cb5a:	8f 5f       	subi	r24, 0xFF	; 255
    cb5c:	80 93 d3 01 	sts	0x01D3, r24
    cb60:	17 c1       	rjmp	.+558    	; 0xcd90 <EMeter_Cycle+0x11a8>
							}
							else{
								EMeter_SendData_P(EM_RESP_RING, sizeof(EM_RESP_RING)-1);
    cb62:	8b ec       	ldi	r24, 0xCB	; 203
    cb64:	97 e0       	ldi	r25, 0x07	; 7
    cb66:	68 e0       	ldi	r22, 0x08	; 8
    cb68:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
								StartTimer16(TD_EMeter, 500);
    cb6c:	80 91 a0 0b 	lds	r24, 0x0BA0
    cb70:	64 ef       	ldi	r22, 0xF4	; 244
    cb72:	71 e0       	ldi	r23, 0x01	; 1
    cb74:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    cb78:	0b c1       	rjmp	.+534    	; 0xcd90 <EMeter_Cycle+0x11a8>
							}
							break;
						case 2:	
							EMeter_SendCR(EM_REQ);
    cb7a:	8c e7       	ldi	r24, 0x7C	; 124
    cb7c:	97 e0       	ldi	r25, 0x07	; 7
    cb7e:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
							StartTimer16(TD_EMeter, 300);
    cb82:	80 91 a0 0b 	lds	r24, 0x0BA0
    cb86:	6c e2       	ldi	r22, 0x2C	; 44
    cb88:	71 e0       	ldi	r23, 0x01	; 1
    cb8a:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
							EM_Mode = 3;
    cb8e:	83 e0       	ldi	r24, 0x03	; 3
    cb90:	fa c0       	rjmp	.+500    	; 0xcd86 <EMeter_Cycle+0x119e>
							break;
						case 3:
							EMeter_SendCR(EM_READ_DATA_REQ);
    cb92:	80 e8       	ldi	r24, 0x80	; 128
    cb94:	97 e0       	ldi	r25, 0x07	; 7
    cb96:	0e 94 7e 49 	call	0x92fc	; 0x92fc <EMeter_SendCR>
							StartTimer16(TD_EMeter,300);
    cb9a:	80 91 a0 0b 	lds	r24, 0x0BA0
    cb9e:	6c e2       	ldi	r22, 0x2C	; 44
    cba0:	71 e0       	ldi	r23, 0x01	; 1
    cba2:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
							EM_Mode = 4;
    cba6:	84 e0       	ldi	r24, 0x04	; 4
    cba8:	ee c0       	rjmp	.+476    	; 0xcd86 <EMeter_Cycle+0x119e>
							break;
						case 4:
							// Read data
						
							// check frame
							if(EMeter_RxCharN != 24){
    cbaa:	80 91 a6 0c 	lds	r24, 0x0CA6
    cbae:	90 91 a7 0c 	lds	r25, 0x0CA7
    cbb2:	48 97       	sbiw	r24, 0x18	; 24
    cbb4:	81 f5       	brne	.+96     	; 0xcc16 <EMeter_Cycle+0x102e>
								EM_Retry++;
								EM_Mode = 5;
								break;
							}
							EM_BCC = 0;
    cbb6:	10 92 c6 08 	sts	0x08C6, r1
    cbba:	ea eb       	ldi	r30, 0xBA	; 186
    cbbc:	f6 e0       	ldi	r31, 0x06	; 6
							for(uint8_t i=1; i<23; i++) EM_BCC += EMeter_RxStr[i];
    cbbe:	90 91 c6 08 	lds	r25, 0x08C6
    cbc2:	81 91       	ld	r24, Z+
    cbc4:	98 0f       	add	r25, r24
    cbc6:	90 93 c6 08 	sts	0x08C6, r25
    cbca:	26 e0       	ldi	r18, 0x06	; 6
    cbcc:	e0 3d       	cpi	r30, 0xD0	; 208
    cbce:	f2 07       	cpc	r31, r18
    cbd0:	b1 f7       	brne	.-20     	; 0xcbbe <EMeter_Cycle+0xfd6>
							EM_BCC &= 0b01111111;
    cbd2:	9f 77       	andi	r25, 0x7F	; 127
    cbd4:	90 93 c6 08 	sts	0x08C6, r25
							if(EM_BCC != EMeter_RxStr[23]){
    cbd8:	80 81       	ld	r24, Z
    cbda:	98 17       	cp	r25, r24
    cbdc:	e1 f4       	brne	.+56     	; 0xcc16 <EMeter_Cycle+0x102e>
								EM_Retry++;
								EM_Mode = 5;
								break;
							}
							if( EMeter_RxStr[0]!=0x02 || EMeter_RxStr[1]!='(' || EMeter_RxStr[18] != ')' || EMeter_RxStr[19] != '!' ||
    cbde:	80 91 b9 06 	lds	r24, 0x06B9
    cbe2:	82 30       	cpi	r24, 0x02	; 2
    cbe4:	c1 f4       	brne	.+48     	; 0xcc16 <EMeter_Cycle+0x102e>
    cbe6:	80 91 ba 06 	lds	r24, 0x06BA
    cbea:	88 32       	cpi	r24, 0x28	; 40
    cbec:	a1 f4       	brne	.+40     	; 0xcc16 <EMeter_Cycle+0x102e>
    cbee:	80 91 cb 06 	lds	r24, 0x06CB
    cbf2:	89 32       	cpi	r24, 0x29	; 41
    cbf4:	81 f4       	brne	.+32     	; 0xcc16 <EMeter_Cycle+0x102e>
    cbf6:	80 91 cc 06 	lds	r24, 0x06CC
    cbfa:	81 32       	cpi	r24, 0x21	; 33
    cbfc:	61 f4       	brne	.+24     	; 0xcc16 <EMeter_Cycle+0x102e>
    cbfe:	80 91 cd 06 	lds	r24, 0x06CD
    cc02:	8d 30       	cpi	r24, 0x0D	; 13
    cc04:	41 f4       	brne	.+16     	; 0xcc16 <EMeter_Cycle+0x102e>
    cc06:	80 91 ce 06 	lds	r24, 0x06CE
    cc0a:	8a 30       	cpi	r24, 0x0A	; 10
    cc0c:	21 f4       	brne	.+8      	; 0xcc16 <EMeter_Cycle+0x102e>
    cc0e:	80 91 cf 06 	lds	r24, 0x06CF
    cc12:	83 30       	cpi	r24, 0x03	; 3
    cc14:	39 f0       	breq	.+14     	; 0xcc24 <EMeter_Cycle+0x103c>
								EMeter_RxStr[20] != '\r' || EMeter_RxStr[21] != '\n'|| EMeter_RxStr[22] != 0x03){
								EM_Retry++;
    cc16:	80 91 d3 01 	lds	r24, 0x01D3
    cc1a:	8f 5f       	subi	r24, 0xFF	; 255
    cc1c:	80 93 d3 01 	sts	0x01D3, r24
								EM_Mode = 5;
    cc20:	85 e0       	ldi	r24, 0x05	; 5
    cc22:	b1 c0       	rjmp	.+354    	; 0xcd86 <EMeter_Cycle+0x119e>
								break;
							}
						
							{//process data
								char TempStr[9];
								TempStr[8] = 0;
    cc24:	1d 86       	std	Y+13, r1	; 0x0d
    cc26:	8f 01       	movw	r16, r30
    cc28:	0f 50       	subi	r16, 0x0F	; 15
    cc2a:	10 40       	sbci	r17, 0x00	; 0
    cc2c:	85 e0       	ldi	r24, 0x05	; 5
    cc2e:	e8 2e       	mov	r14, r24
    cc30:	f1 2c       	mov	r15, r1
    cc32:	ec 0e       	add	r14, r28
    cc34:	fd 1e       	adc	r15, r29
    cc36:	f7 01       	movw	r30, r14

								uint8_t Start = 2;
								for(uint8_t i=0; i<8; i=i+2){
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
    cc38:	d8 01       	movw	r26, r16
    cc3a:	8c 91       	ld	r24, X
    cc3c:	80 83       	st	Z, r24
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
    cc3e:	11 96       	adiw	r26, 0x01	; 1
    cc40:	8c 91       	ld	r24, X
    cc42:	81 83       	std	Z+1, r24	; 0x01
    cc44:	02 50       	subi	r16, 0x02	; 2
    cc46:	10 40       	sbci	r17, 0x00	; 0
    cc48:	32 96       	adiw	r30, 0x02	; 2
							{//process data
								char TempStr[9];
								TempStr[8] = 0;

								uint8_t Start = 2;
								for(uint8_t i=0; i<8; i=i+2){
    cc4a:	b6 e0       	ldi	r27, 0x06	; 6
    cc4c:	09 3b       	cpi	r16, 0xB9	; 185
    cc4e:	1b 07       	cpc	r17, r27
    cc50:	99 f7       	brne	.-26     	; 0xcc38 <EMeter_Cycle+0x1050>
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Ap);		
    cc52:	00 d0       	rcall	.+0      	; 0xcc54 <EMeter_Cycle+0x106c>
    cc54:	00 d0       	rcall	.+0      	; 0xcc56 <EMeter_Cycle+0x106e>
    cc56:	00 d0       	rcall	.+0      	; 0xcc58 <EMeter_Cycle+0x1070>
    cc58:	ed b7       	in	r30, 0x3d	; 61
    cc5a:	fe b7       	in	r31, 0x3e	; 62
    cc5c:	31 96       	adiw	r30, 0x01	; 1
    cc5e:	ce 01       	movw	r24, r28
    cc60:	05 96       	adiw	r24, 0x05	; 5
    cc62:	ad b7       	in	r26, 0x3d	; 61
    cc64:	be b7       	in	r27, 0x3e	; 62
    cc66:	12 96       	adiw	r26, 0x02	; 2
    cc68:	9c 93       	st	X, r25
    cc6a:	8e 93       	st	-X, r24
    cc6c:	11 97       	sbiw	r26, 0x01	; 1
    cc6e:	83 e0       	ldi	r24, 0x03	; 3
    cc70:	91 e0       	ldi	r25, 0x01	; 1
    cc72:	93 83       	std	Z+3, r25	; 0x03
    cc74:	82 83       	std	Z+2, r24	; 0x02
    cc76:	8b ed       	ldi	r24, 0xDB	; 219
    cc78:	91 e0       	ldi	r25, 0x01	; 1
    cc7a:	95 83       	std	Z+5, r25	; 0x05
    cc7c:	84 83       	std	Z+4, r24	; 0x04
    cc7e:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
								E_Meter_RAM.Ap *=10;
    cc82:	60 91 db 01 	lds	r22, 0x01DB
    cc86:	70 91 dc 01 	lds	r23, 0x01DC
    cc8a:	80 91 dd 01 	lds	r24, 0x01DD
    cc8e:	90 91 de 01 	lds	r25, 0x01DE
    cc92:	2a e0       	ldi	r18, 0x0A	; 10
    cc94:	30 e0       	ldi	r19, 0x00	; 0
    cc96:	40 e0       	ldi	r20, 0x00	; 0
    cc98:	50 e0       	ldi	r21, 0x00	; 0
    cc9a:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    cc9e:	60 93 db 01 	sts	0x01DB, r22
    cca2:	70 93 dc 01 	sts	0x01DC, r23
    cca6:	80 93 dd 01 	sts	0x01DD, r24
    ccaa:	90 93 de 01 	sts	0x01DE, r25
    ccae:	f8 01       	movw	r30, r16
    ccb0:	70 96       	adiw	r30, 0x10	; 16
    ccb2:	8d b7       	in	r24, 0x3d	; 61
    ccb4:	9e b7       	in	r25, 0x3e	; 62
    ccb6:	06 96       	adiw	r24, 0x06	; 6
    ccb8:	0f b6       	in	r0, 0x3f	; 63
    ccba:	f8 94       	cli
    ccbc:	9e bf       	out	0x3e, r25	; 62
    ccbe:	0f be       	out	0x3f, r0	; 63
    ccc0:	8d bf       	out	0x3d, r24	; 61
								Start = 10;
								for(uint8_t i=0; i<8; i=i+2){
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
    ccc2:	80 81       	ld	r24, Z
    ccc4:	d7 01       	movw	r26, r14
    ccc6:	8c 93       	st	X, r24
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
    ccc8:	81 81       	ldd	r24, Z+1	; 0x01
    ccca:	11 96       	adiw	r26, 0x01	; 1
    cccc:	8c 93       	st	X, r24
    ccce:	32 97       	sbiw	r30, 0x02	; 2
    ccd0:	82 e0       	ldi	r24, 0x02	; 2
    ccd2:	90 e0       	ldi	r25, 0x00	; 0
    ccd4:	e8 0e       	add	r14, r24
    ccd6:	f9 1e       	adc	r15, r25
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Ap);		
								E_Meter_RAM.Ap *=10;
								Start = 10;
								for(uint8_t i=0; i<8; i=i+2){
    ccd8:	96 e0       	ldi	r25, 0x06	; 6
    ccda:	e1 3c       	cpi	r30, 0xC1	; 193
    ccdc:	f9 07       	cpc	r31, r25
    ccde:	89 f7       	brne	.-30     	; 0xccc2 <EMeter_Cycle+0x10da>
									TempStr[i+0] = EMeter_RxStr[Start+6-i];
									TempStr[i+1] = EMeter_RxStr[Start+7-i];
								}
								sscanf(TempStr,"%ld",&E_Meter_RAM.Am);
    cce0:	00 d0       	rcall	.+0      	; 0xcce2 <EMeter_Cycle+0x10fa>
    cce2:	00 d0       	rcall	.+0      	; 0xcce4 <EMeter_Cycle+0x10fc>
    cce4:	00 d0       	rcall	.+0      	; 0xcce6 <EMeter_Cycle+0x10fe>
    cce6:	ed b7       	in	r30, 0x3d	; 61
    cce8:	fe b7       	in	r31, 0x3e	; 62
    ccea:	31 96       	adiw	r30, 0x01	; 1
    ccec:	ce 01       	movw	r24, r28
    ccee:	05 96       	adiw	r24, 0x05	; 5
    ccf0:	ad b7       	in	r26, 0x3d	; 61
    ccf2:	be b7       	in	r27, 0x3e	; 62
    ccf4:	12 96       	adiw	r26, 0x02	; 2
    ccf6:	9c 93       	st	X, r25
    ccf8:	8e 93       	st	-X, r24
    ccfa:	11 97       	sbiw	r26, 0x01	; 1
    ccfc:	83 e0       	ldi	r24, 0x03	; 3
    ccfe:	91 e0       	ldi	r25, 0x01	; 1
    cd00:	93 83       	std	Z+3, r25	; 0x03
    cd02:	82 83       	std	Z+2, r24	; 0x02
    cd04:	8f ed       	ldi	r24, 0xDF	; 223
    cd06:	91 e0       	ldi	r25, 0x01	; 1
    cd08:	95 83       	std	Z+5, r25	; 0x05
    cd0a:	84 83       	std	Z+4, r24	; 0x04
    cd0c:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
								E_Meter_RAM.Am *=10;
    cd10:	60 91 df 01 	lds	r22, 0x01DF
    cd14:	70 91 e0 01 	lds	r23, 0x01E0
    cd18:	80 91 e1 01 	lds	r24, 0x01E1
    cd1c:	90 91 e2 01 	lds	r25, 0x01E2
    cd20:	2a e0       	ldi	r18, 0x0A	; 10
    cd22:	30 e0       	ldi	r19, 0x00	; 0
    cd24:	40 e0       	ldi	r20, 0x00	; 0
    cd26:	50 e0       	ldi	r21, 0x00	; 0
    cd28:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
    cd2c:	60 93 df 01 	sts	0x01DF, r22
    cd30:	70 93 e0 01 	sts	0x01E0, r23
    cd34:	80 93 e1 01 	sts	0x01E1, r24
    cd38:	90 93 e2 01 	sts	0x01E2, r25
							}
							EM_Retry = 0;
    cd3c:	10 92 d3 01 	sts	0x01D3, r1
    cd40:	ed b7       	in	r30, 0x3d	; 61
    cd42:	fe b7       	in	r31, 0x3e	; 62
    cd44:	36 96       	adiw	r30, 0x06	; 6
    cd46:	0f b6       	in	r0, 0x3f	; 63
    cd48:	f8 94       	cli
    cd4a:	fe bf       	out	0x3e, r31	; 62
    cd4c:	0f be       	out	0x3f, r0	; 63
    cd4e:	ed bf       	out	0x3d, r30	; 61
						case 5:												
							EMeter_SendData_P(EM_END_REQ, sizeof(EM_END_REQ));				
    cd50:	8f ee       	ldi	r24, 0xEF	; 239
    cd52:	97 e0       	ldi	r25, 0x07	; 7
    cd54:	64 e0       	ldi	r22, 0x04	; 4
    cd56:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
							StartTimer16(TD_EMeter,200);
    cd5a:	80 91 a0 0b 	lds	r24, 0x0BA0
    cd5e:	68 ec       	ldi	r22, 0xC8	; 200
    cd60:	70 e0       	ldi	r23, 0x00	; 0
    cd62:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
							RING_Retry = 0;
    cd66:	10 92 ed 01 	sts	0x01ED, r1
							EM_Mode = 6;
    cd6a:	86 e0       	ldi	r24, 0x06	; 6
    cd6c:	0c c0       	rjmp	.+24     	; 0xcd86 <EMeter_Cycle+0x119e>
							break;
						case 6:
							EMeter_SendData_P(EM_RESP_NOCARRIER, sizeof(EM_RESP_NOCARRIER)-1);
    cd6e:	80 ee       	ldi	r24, 0xE0	; 224
    cd70:	97 e0       	ldi	r25, 0x07	; 7
    cd72:	6e e0       	ldi	r22, 0x0E	; 14
    cd74:	0e 94 b1 49 	call	0x9362	; 0x9362 <EMeter_SendData_P>
							StartTimer16(TD_EMeter,3000);
    cd78:	80 91 a0 0b 	lds	r24, 0x0BA0
    cd7c:	68 eb       	ldi	r22, 0xB8	; 184
    cd7e:	7b e0       	ldi	r23, 0x0B	; 11
    cd80:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
							EM_Mode = 1;
    cd84:	81 e0       	ldi	r24, 0x01	; 1
    cd86:	80 93 db 09 	sts	0x09DB, r24
    cd8a:	02 c0       	rjmp	.+4      	; 0xcd90 <EMeter_Cycle+0x11a8>
							break;
						default: 
							EM_Mode = 0;
    cd8c:	10 92 db 09 	sts	0x09DB, r1
			}//EMeter_TxFlag

		}
	// ---
	}//NonTransparent
}
    cd90:	68 96       	adiw	r28, 0x18	; 24
    cd92:	0f b6       	in	r0, 0x3f	; 63
    cd94:	f8 94       	cli
    cd96:	de bf       	out	0x3e, r29	; 62
    cd98:	0f be       	out	0x3f, r0	; 63
    cd9a:	cd bf       	out	0x3d, r28	; 61
    cd9c:	cf 91       	pop	r28
    cd9e:	df 91       	pop	r29
    cda0:	1f 91       	pop	r17
    cda2:	0f 91       	pop	r16
    cda4:	ff 90       	pop	r15
    cda6:	ef 90       	pop	r14
    cda8:	df 90       	pop	r13
    cdaa:	cf 90       	pop	r12
    cdac:	08 95       	ret

0000cdae <EMRead>:
    cdae:	8c e5       	ldi	r24, 0x5C	; 92
    cdb0:	91 e0       	ldi	r25, 0x01	; 1
    cdb2:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	else return 0;
}

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    cdb6:	84 30       	cpi	r24, 0x04	; 4
    cdb8:	11 f0       	breq	.+4      	; 0xcdbe <EMRead+0x10>
    cdba:	10 92 db 09 	sts	0x09DB, r1
    cdbe:	08 95       	ret

0000cdc0 <GPRS_SendData>:
	GPRS_FlgSz_Out = 74;	//    .     
}

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    cdc0:	cf 93       	push	r28
    cdc2:	df 93       	push	r29
    cdc4:	8b e7       	ldi	r24, 0x7B	; 123
    cdc6:	91 e0       	ldi	r25, 0x01	; 1
    cdc8:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    cdcc:	88 23       	and	r24, r24
    cdce:	09 f4       	brne	.+2      	; 0xcdd2 <GPRS_SendData+0x12>
    cdd0:	5b c0       	rjmp	.+182    	; 0xce88 <GPRS_SendData+0xc8>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    cdd2:	8c e7       	ldi	r24, 0x7C	; 124
    cdd4:	91 e0       	ldi	r25, 0x01	; 1
    cdd6:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    cdda:	cc 97       	sbiw	r24, 0x3c	; 60
    cddc:	08 f4       	brcc	.+2      	; 0xcde0 <GPRS_SendData+0x20>
    cdde:	54 c0       	rjmp	.+168    	; 0xce88 <GPRS_SendData+0xc8>
		if(Timer1s != Timer1sOld){
    cde0:	90 91 78 0a 	lds	r25, 0x0A78
    cde4:	80 91 eb 08 	lds	r24, 0x08EB
    cde8:	98 17       	cp	r25, r24
    cdea:	91 f0       	breq	.+36     	; 0xce10 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    cdec:	90 93 eb 08 	sts	0x08EB, r25
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    cdf0:	c0 91 80 0a 	lds	r28, 0x0A80
    cdf4:	d0 91 81 0a 	lds	r29, 0x0A81
    cdf8:	8c e7       	ldi	r24, 0x7C	; 124
    cdfa:	91 e0       	ldi	r25, 0x01	; 1
    cdfc:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    ce00:	c8 17       	cp	r28, r24
    ce02:	d9 07       	cpc	r29, r25
    ce04:	28 f4       	brcc	.+10     	; 0xce10 <GPRS_SendData+0x50>
    ce06:	21 96       	adiw	r28, 0x01	; 1
    ce08:	d0 93 81 0a 	sts	0x0A81, r29
    ce0c:	c0 93 80 0a 	sts	0x0A80, r28
    ce10:	8c e7       	ldi	r24, 0x7C	; 124
    ce12:	91 e0       	ldi	r25, 0x01	; 1
    ce14:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    ce18:	4e 97       	sbiw	r24, 0x1e	; 30
    ce1a:	20 91 80 0a 	lds	r18, 0x0A80
    ce1e:	30 91 81 0a 	lds	r19, 0x0A81
    ce22:	28 17       	cp	r18, r24
    ce24:	39 07       	cpc	r19, r25
    ce26:	31 f4       	brne	.+12     	; 0xce34 <GPRS_SendData+0x74>
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    ce28:	80 91 db 09 	lds	r24, 0x09DB
    ce2c:	8f 3f       	cpi	r24, 0xFF	; 255
    ce2e:	11 f4       	brne	.+4      	; 0xce34 <GPRS_SendData+0x74>
			if(IsEMReady()) EMRead();			
    ce30:	0e 94 d7 66 	call	0xcdae	; 0xcdae <EMRead>
    ce34:	8c e7       	ldi	r24, 0x7C	; 124
    ce36:	91 e0       	ldi	r25, 0x01	; 1
    ce38:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    ce3c:	0f 97       	sbiw	r24, 0x0f	; 15
    ce3e:	20 91 80 0a 	lds	r18, 0x0A80
    ce42:	30 91 81 0a 	lds	r19, 0x0A81
    ce46:	28 17       	cp	r18, r24
    ce48:	39 07       	cpc	r19, r25
    ce4a:	51 f4       	brne	.+20     	; 0xce60 <GPRS_SendData+0xa0>

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    ce4c:	80 91 d3 01 	lds	r24, 0x01D3
    ce50:	88 23       	and	r24, r24
    ce52:	31 f0       	breq	.+12     	; 0xce60 <GPRS_SendData+0xa0>
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    ce54:	80 91 db 09 	lds	r24, 0x09DB
    ce58:	8f 3f       	cpi	r24, 0xFF	; 255
    ce5a:	11 f4       	brne	.+4      	; 0xce60 <GPRS_SendData+0xa0>
			if(!EMeter_Link()){
				if(IsEMReady()) EMRead();
    ce5c:	0e 94 d7 66 	call	0xcdae	; 0xcdae <EMRead>
    ce60:	8c e7       	ldi	r24, 0x7C	; 124
    ce62:	91 e0       	ldi	r25, 0x01	; 1
    ce64:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    ce68:	20 91 80 0a 	lds	r18, 0x0A80
    ce6c:	30 91 81 0a 	lds	r19, 0x0A81
    ce70:	28 17       	cp	r18, r24
    ce72:	39 07       	cpc	r19, r25
    ce74:	48 f0       	brcs	.+18     	; 0xce88 <GPRS_SendData+0xc8>
			GPRS_DataTimer = 0;
    ce76:	10 92 81 0a 	sts	0x0A81, r1
    ce7a:	10 92 80 0a 	sts	0x0A80, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    ce7e:	80 91 ca 08 	lds	r24, 0x08CA
    ce82:	81 60       	ori	r24, 0x01	; 1
    ce84:	80 93 ca 08 	sts	0x08CA, r24
		}
	}
}
    ce88:	df 91       	pop	r29
    ce8a:	cf 91       	pop	r28
    ce8c:	08 95       	ret

0000ce8e <GPRS_App>:
	}
}
// -----   ApplCycle
void GPRS_App(void){

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    ce8e:	90 91 bd 08 	lds	r25, 0x08BD

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    ce92:	8f b7       	in	r24, 0x3f	; 63
    ce94:	80 78       	andi	r24, 0x80	; 128
    ce96:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    ce9a:	f8 94       	cli
    ce9c:	e9 2f       	mov	r30, r25
    ce9e:	f0 e0       	ldi	r31, 0x00	; 0
    cea0:	ee 0f       	add	r30, r30
    cea2:	ff 1f       	adc	r31, r31
    cea4:	eb 5d       	subi	r30, 0xDB	; 219
    cea6:	fd 4f       	sbci	r31, 0xFD	; 253
    cea8:	01 90       	ld	r0, Z+
    ceaa:	f0 81       	ld	r31, Z
    ceac:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    ceae:	88 23       	and	r24, r24
    ceb0:	09 f0       	breq	.+2      	; 0xceb4 <GPRS_App+0x26>
		sei();
    ceb2:	78 94       	sei
    ceb4:	e8 3c       	cpi	r30, 0xC8	; 200
    ceb6:	f1 05       	cpc	r31, r1
    ceb8:	28 f4       	brcc	.+10     	; 0xcec4 <GPRS_App+0x36>
    ceba:	89 2f       	mov	r24, r25
    cebc:	6f ef       	ldi	r22, 0xFF	; 255
    cebe:	7f ef       	ldi	r23, 0xFF	; 255
    cec0:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    cec4:	80 91 d2 01 	lds	r24, 0x01D2
    cec8:	8f 3f       	cpi	r24, 0xFF	; 255
    ceca:	31 f4       	brne	.+12     	; 0xced8 <GPRS_App+0x4a>
		GPRS_Session_ID = 0;
    cecc:	10 92 7a 0a 	sts	0x0A7A, r1
    ced0:	10 92 79 0a 	sts	0x0A79, r1
		GPRS_LoginLevel = 0;
    ced4:	10 92 46 08 	sts	0x0846, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    ced8:	e0 91 8c 05 	lds	r30, 0x058C

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    cedc:	8f b7       	in	r24, 0x3f	; 63
    cede:	80 78       	andi	r24, 0x80	; 128
    cee0:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    cee4:	f8 94       	cli
    cee6:	f0 e0       	ldi	r31, 0x00	; 0
    cee8:	ee 0f       	add	r30, r30
    ceea:	ff 1f       	adc	r31, r31
    ceec:	eb 5d       	subi	r30, 0xDB	; 219
    ceee:	fd 4f       	sbci	r31, 0xFD	; 253
    cef0:	01 90       	ld	r0, Z+
    cef2:	f0 81       	ld	r31, Z
    cef4:	e0 2d       	mov	r30, r0

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    cef6:	88 23       	and	r24, r24
    cef8:	09 f0       	breq	.+2      	; 0xcefc <GPRS_App+0x6e>
		sei();
    cefa:	78 94       	sei
    cefc:	f0 93 7e 05 	sts	0x057E, r31
    cf00:	e0 93 7d 05 	sts	0x057D, r30

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    cf04:	80 91 d6 08 	lds	r24, 0x08D6
    cf08:	80 fd       	sbrc	r24, 0
    cf0a:	1b c0       	rjmp	.+54     	; 0xcf42 <GPRS_App+0xb4>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    cf0c:	0e 94 c3 5a 	call	0xb586	; 0xb586 <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    cf10:	80 e0       	ldi	r24, 0x00	; 0
    cf12:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
    cf16:	88 23       	and	r24, r24
    cf18:	61 f0       	breq	.+24     	; 0xcf32 <GPRS_App+0xa4>
    cf1a:	90 91 d6 08 	lds	r25, 0x08D6
    cf1e:	92 ff       	sbrs	r25, 2
    cf20:	08 c0       	rjmp	.+16     	; 0xcf32 <GPRS_App+0xa4>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    cf22:	80 91 ca 08 	lds	r24, 0x08CA
    cf26:	84 60       	ori	r24, 0x04	; 4
    cf28:	80 93 ca 08 	sts	0x08CA, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    cf2c:	9b 7f       	andi	r25, 0xFB	; 251
    cf2e:	90 93 d6 08 	sts	0x08D6, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    cf32:	0e 94 e0 66 	call	0xcdc0	; 0xcdc0 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    cf36:	80 91 b4 08 	lds	r24, 0x08B4
    cf3a:	88 23       	and	r24, r24
    cf3c:	11 f4       	brne	.+4      	; 0xcf42 <GPRS_App+0xb4>
    cf3e:	0e 94 8f 5d 	call	0xbb1e	; 0xbb1e <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
    cf42:	0e 94 2d 52 	call	0xa45a	; 0xa45a <GPRS_CriticalCMD_Process>
}
    cf46:	08 95       	ret

0000cf48 <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    cf48:	80 91 cf 01 	lds	r24, 0x01CF
	VacantTimer16Sys += n;
    cf4c:	8f 5f       	subi	r24, 0xFF	; 255
    cf4e:	80 93 cf 01 	sts	0x01CF, r24
    cf52:	81 50       	subi	r24, 0x01	; 1

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    cf54:	80 93 a0 0b 	sts	0x0BA0, r24
	EMeter_ReInit();
    cf58:	0e 94 69 58 	call	0xb0d2	; 0xb0d2 <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cf5c:	8b e7       	ldi	r24, 0x7B	; 123
    cf5e:	91 e0       	ldi	r25, 0x01	; 1
    cf60:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	if(erb(&AutoSend)){
    cf64:	88 23       	and	r24, r24
    cf66:	49 f0       	breq	.+18     	; 0xcf7a <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    cf68:	80 91 a0 0b 	lds	r24, 0x0BA0
    cf6c:	68 ee       	ldi	r22, 0xE8	; 232
    cf6e:	73 e0       	ldi	r23, 0x03	; 3
    cf70:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
		EM_Mode = 0;
    cf74:	10 92 db 09 	sts	0x09DB, r1
    cf78:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    cf7a:	8f ef       	ldi	r24, 0xFF	; 255
    cf7c:	80 93 db 09 	sts	0x09DB, r24
    cf80:	08 95       	ret

0000cf82 <ChangeUARTParam>:
    cf82:	8c e5       	ldi	r24, 0x5C	; 92
    cf84:	91 e0       	ldi	r25, 0x01	; 1
    cf86:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    cf8a:	98 2f       	mov	r25, r24
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    cf8c:	81 30       	cpi	r24, 0x01	; 1
    cf8e:	51 f4       	brne	.+20     	; 0xcfa4 <ChangeUARTParam+0x22>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    cf90:	83 e0       	ldi	r24, 0x03	; 3
    cf92:	80 93 d6 09 	sts	0x09D6, r24
		EM_UART_Parity = 1;
    cf96:	90 93 89 05 	sts	0x0589, r25
		EM_UART_StopBits = 0;
    cf9a:	10 92 b3 08 	sts	0x08B3, r1
		EM_UART_BitQt = 2;
    cf9e:	82 e0       	ldi	r24, 0x02	; 2
    cfa0:	80 93 dc 09 	sts	0x09DC, r24
    cfa4:	8c e5       	ldi	r24, 0x5C	; 92
    cfa6:	91 e0       	ldi	r25, 0x01	; 1
    cfa8:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    cfac:	82 30       	cpi	r24, 0x02	; 2
    cfae:	21 f0       	breq	.+8      	; 0xcfb8 <ChangeUARTParam+0x36>
    cfb0:	83 30       	cpi	r24, 0x03	; 3
    cfb2:	11 f0       	breq	.+4      	; 0xcfb8 <ChangeUARTParam+0x36>
    cfb4:	84 30       	cpi	r24, 0x04	; 4
    cfb6:	49 f4       	brne	.+18     	; 0xcfca <ChangeUARTParam+0x48>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    cfb8:	83 e0       	ldi	r24, 0x03	; 3
    cfba:	80 93 d6 09 	sts	0x09D6, r24
		EM_UART_Parity = 0;
    cfbe:	10 92 89 05 	sts	0x0589, r1
		EM_UART_StopBits = 0;
    cfc2:	10 92 b3 08 	sts	0x08B3, r1
		EM_UART_BitQt = 3;		
    cfc6:	80 93 dc 09 	sts	0x09DC, r24
	}
	ApplyUARTParam();
    cfca:	0e 94 1c 59 	call	0xb238	; 0xb238 <ApplyUARTParam>
}
    cfce:	08 95       	ret

0000cfd0 <WebPutField>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	  PutField  menu.h
//	  
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
    cfd0:	6f 92       	push	r6
    cfd2:	7f 92       	push	r7
    cfd4:	8f 92       	push	r8
    cfd6:	9f 92       	push	r9
    cfd8:	af 92       	push	r10
    cfda:	bf 92       	push	r11
    cfdc:	cf 92       	push	r12
    cfde:	df 92       	push	r13
    cfe0:	ef 92       	push	r14
    cfe2:	ff 92       	push	r15
    cfe4:	0f 93       	push	r16
    cfe6:	1f 93       	push	r17
    cfe8:	df 93       	push	r29
    cfea:	cf 93       	push	r28
    cfec:	00 d0       	rcall	.+0      	; 0xcfee <WebPutField+0x1e>
    cfee:	00 d0       	rcall	.+0      	; 0xcff0 <WebPutField+0x20>
    cff0:	cd b7       	in	r28, 0x3d	; 61
    cff2:	de b7       	in	r29, 0x3e	; 62
    cff4:	3b 01       	movw	r6, r22
    cff6:	6a 01       	movw	r12, r20
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
		}
		break;
	}
}
    cff8:	8d b6       	in	r8, 0x3d	; 61
    cffa:	9e b6       	in	r9, 0x3e	; 62
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    cffc:	90 e0       	ldi	r25, 0x00	; 0
    cffe:	83 32       	cpi	r24, 0x23	; 35
    d000:	91 05       	cpc	r25, r1
    d002:	08 f0       	brcs	.+2      	; 0xd006 <WebPutField+0x36>
    d004:	4b c1       	rjmp	.+662    	; 0xd29c <WebPutField+0x2cc>
    d006:	84 5a       	subi	r24, 0xA4	; 164
    d008:	9f 4f       	sbci	r25, 0xFF	; 255
    d00a:	fc 01       	movw	r30, r24
    d00c:	ee 0f       	add	r30, r30
    d00e:	ff 1f       	adc	r31, r31
    d010:	05 90       	lpm	r0, Z+
    d012:	f4 91       	lpm	r31, Z+
    d014:	e0 2d       	mov	r30, r0
    d016:	09 94       	ijmp
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    d018:	fb 01       	movw	r30, r22
    d01a:	80 81       	ld	r24, Z
    d01c:	03 c0       	rjmp	.+6      	; 0xd024 <WebPutField+0x54>
    d01e:	cb 01       	movw	r24, r22
    d020:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    d024:	90 e0       	ldi	r25, 0x00	; 0
    d026:	62 e6       	ldi	r22, 0x62	; 98
    d028:	a6 01       	movw	r20, r12
    d02a:	0e 94 ef 50 	call	0xa1de	; 0xa1de <PutVal>
    d02e:	36 c1       	rjmp	.+620    	; 0xd29c <WebPutField+0x2cc>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    d030:	fb 01       	movw	r30, r22
    d032:	80 81       	ld	r24, Z
    d034:	03 c0       	rjmp	.+6      	; 0xd03c <WebPutField+0x6c>
    d036:	cb 01       	movw	r24, r22
    d038:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    d03c:	99 27       	eor	r25, r25
    d03e:	87 fd       	sbrc	r24, 7
    d040:	90 95       	com	r25
    d042:	62 e6       	ldi	r22, 0x62	; 98
    d044:	a6 01       	movw	r20, r12
    d046:	0e 94 20 50 	call	0xa040	; 0xa040 <Put_sVal>
    d04a:	28 c1       	rjmp	.+592    	; 0xd29c <WebPutField+0x2cc>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    d04c:	fb 01       	movw	r30, r22
    d04e:	80 81       	ld	r24, Z
    d050:	03 c0       	rjmp	.+6      	; 0xd058 <WebPutField+0x88>
    d052:	cb 01       	movw	r24, r22
    d054:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    d058:	90 e0       	ldi	r25, 0x00	; 0
    d05a:	62 e6       	ldi	r22, 0x62	; 98
    d05c:	a6 01       	movw	r20, r12
    d05e:	0e 94 6f 4f 	call	0x9ede	; 0x9ede <Put_zVal>
    d062:	1c c1       	rjmp	.+568    	; 0xd29c <WebPutField+0x2cc>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    d064:	fb 01       	movw	r30, r22
    d066:	60 81       	ld	r22, Z
    d068:	70 e0       	ldi	r23, 0x00	; 0
    d06a:	80 e0       	ldi	r24, 0x00	; 0
    d06c:	90 e0       	ldi	r25, 0x00	; 0
    d06e:	42 e6       	ldi	r20, 0x62	; 98
    d070:	06 c0       	rjmp	.+12     	; 0xd07e <WebPutField+0xae>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    d072:	fb 01       	movw	r30, r22
    d074:	60 81       	ld	r22, Z
    d076:	71 81       	ldd	r23, Z+1	; 0x01
    d078:	80 e0       	ldi	r24, 0x00	; 0
    d07a:	90 e0       	ldi	r25, 0x00	; 0
    d07c:	47 e7       	ldi	r20, 0x77	; 119
    d07e:	96 01       	movw	r18, r12
    d080:	0e 94 d7 4b 	call	0x97ae	; 0x97ae <Put_zVal_h>
    d084:	0b c1       	rjmp	.+534    	; 0xd29c <WebPutField+0x2cc>
		break;
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
    d086:	fb 01       	movw	r30, r22
    d088:	60 81       	ld	r22, Z
    d08a:	71 81       	ldd	r23, Z+1	; 0x01
    d08c:	82 81       	ldd	r24, Z+2	; 0x02
    d08e:	93 81       	ldd	r25, Z+3	; 0x03
    d090:	4c e6       	ldi	r20, 0x6C	; 108
    d092:	f5 cf       	rjmp	.-22     	; 0xd07e <WebPutField+0xae>
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    d094:	fb 01       	movw	r30, r22
    d096:	80 81       	ld	r24, Z
    d098:	91 81       	ldd	r25, Z+1	; 0x01
    d09a:	03 c0       	rjmp	.+6      	; 0xd0a2 <WebPutField+0xd2>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d09c:	cb 01       	movw	r24, r22
    d09e:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    d0a2:	67 e7       	ldi	r22, 0x77	; 119
    d0a4:	c1 cf       	rjmp	.-126    	; 0xd028 <WebPutField+0x58>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    d0a6:	fb 01       	movw	r30, r22
    d0a8:	80 81       	ld	r24, Z
    d0aa:	91 81       	ldd	r25, Z+1	; 0x01
    d0ac:	03 c0       	rjmp	.+6      	; 0xd0b4 <WebPutField+0xe4>
    d0ae:	cb 01       	movw	r24, r22
    d0b0:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    d0b4:	67 e7       	ldi	r22, 0x77	; 119
    d0b6:	c6 cf       	rjmp	.-116    	; 0xd044 <WebPutField+0x74>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    d0b8:	fb 01       	movw	r30, r22
    d0ba:	80 81       	ld	r24, Z
    d0bc:	91 81       	ldd	r25, Z+1	; 0x01
    d0be:	03 c0       	rjmp	.+6      	; 0xd0c6 <WebPutField+0xf6>
    d0c0:	cb 01       	movw	r24, r22
    d0c2:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    d0c6:	67 e7       	ldi	r22, 0x77	; 119
    d0c8:	c9 cf       	rjmp	.-110    	; 0xd05c <WebPutField+0x8c>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    d0ca:	fb 01       	movw	r30, r22
    d0cc:	60 81       	ld	r22, Z
    d0ce:	71 81       	ldd	r23, Z+1	; 0x01
    d0d0:	82 81       	ldd	r24, Z+2	; 0x02
    d0d2:	93 81       	ldd	r25, Z+3	; 0x03
    d0d4:	03 c0       	rjmp	.+6      	; 0xd0dc <WebPutField+0x10c>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    d0d6:	cb 01       	movw	r24, r22
    d0d8:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    d0dc:	a6 01       	movw	r20, r12
    d0de:	0e 94 75 4e 	call	0x9cea	; 0x9cea <PutDVal>
    d0e2:	dc c0       	rjmp	.+440    	; 0xd29c <WebPutField+0x2cc>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    d0e4:	fb 01       	movw	r30, r22
    d0e6:	60 81       	ld	r22, Z
    d0e8:	71 81       	ldd	r23, Z+1	; 0x01
    d0ea:	82 81       	ldd	r24, Z+2	; 0x02
    d0ec:	93 81       	ldd	r25, Z+3	; 0x03
    d0ee:	03 c0       	rjmp	.+6      	; 0xd0f6 <WebPutField+0x126>
    d0f0:	cb 01       	movw	r24, r22
    d0f2:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    d0f6:	a6 01       	movw	r20, r12
    d0f8:	0e 94 54 4d 	call	0x9aa8	; 0x9aa8 <Put_sDVal>
    d0fc:	cf c0       	rjmp	.+414    	; 0xd29c <WebPutField+0x2cc>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    d0fe:	fb 01       	movw	r30, r22
    d100:	60 81       	ld	r22, Z
    d102:	71 81       	ldd	r23, Z+1	; 0x01
    d104:	82 81       	ldd	r24, Z+2	; 0x02
    d106:	93 81       	ldd	r25, Z+3	; 0x03
    d108:	03 c0       	rjmp	.+6      	; 0xd110 <WebPutField+0x140>
    d10a:	cb 01       	movw	r24, r22
    d10c:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    d110:	a6 01       	movw	r20, r12
    d112:	0e 94 5a 4c 	call	0x98b4	; 0x98b4 <Put_zDVal>
    d116:	c2 c0       	rjmp	.+388    	; 0xd29c <WebPutField+0x2cc>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    d118:	fb 01       	movw	r30, r22
    d11a:	60 81       	ld	r22, Z
    d11c:	71 81       	ldd	r23, Z+1	; 0x01
    d11e:	82 81       	ldd	r24, Z+2	; 0x02
    d120:	93 81       	ldd	r25, Z+3	; 0x03
    d122:	0a c0       	rjmp	.+20     	; 0xd138 <WebPutField+0x168>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d124:	ce 01       	movw	r24, r28
    d126:	01 96       	adiw	r24, 0x01	; 1
    d128:	44 e0       	ldi	r20, 0x04	; 4
    d12a:	50 e0       	ldi	r21, 0x00	; 0
    d12c:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    d130:	69 81       	ldd	r22, Y+1	; 0x01
    d132:	7a 81       	ldd	r23, Y+2	; 0x02
    d134:	8b 81       	ldd	r24, Y+3	; 0x03
    d136:	9c 81       	ldd	r25, Y+4	; 0x04
    d138:	a6 01       	movw	r20, r12
    d13a:	0e 94 7c 4b 	call	0x96f8	; 0x96f8 <Put_FFVal>
    d13e:	ae c0       	rjmp	.+348    	; 0xd29c <WebPutField+0x2cc>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    d140:	fb 01       	movw	r30, r22
    d142:	60 81       	ld	r22, Z
    d144:	71 81       	ldd	r23, Z+1	; 0x01
    d146:	82 81       	ldd	r24, Z+2	; 0x02
    d148:	93 81       	ldd	r25, Z+3	; 0x03
    d14a:	0a c0       	rjmp	.+20     	; 0xd160 <WebPutField+0x190>
    d14c:	ce 01       	movw	r24, r28
    d14e:	01 96       	adiw	r24, 0x01	; 1
    d150:	44 e0       	ldi	r20, 0x04	; 4
    d152:	50 e0       	ldi	r21, 0x00	; 0
    d154:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    d158:	69 81       	ldd	r22, Y+1	; 0x01
    d15a:	7a 81       	ldd	r23, Y+2	; 0x02
    d15c:	8b 81       	ldd	r24, Y+3	; 0x03
    d15e:	9c 81       	ldd	r25, Y+4	; 0x04
    d160:	a6 01       	movw	r20, r12
    d162:	0e 94 ee 4a 	call	0x95dc	; 0x95dc <Put_GFVal>
    d166:	9a c0       	rjmp	.+308    	; 0xd29c <WebPutField+0x2cc>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    d168:	fb 01       	movw	r30, r22
    d16a:	20 81       	ld	r18, Z
    d16c:	30 e0       	ldi	r19, 0x00	; 0
    d16e:	22 0f       	add	r18, r18
    d170:	33 1f       	adc	r19, r19
    d172:	f6 01       	movw	r30, r12
    d174:	84 81       	ldd	r24, Z+4	; 0x04
    d176:	95 81       	ldd	r25, Z+5	; 0x05
    d178:	82 0f       	add	r24, r18
    d17a:	93 1f       	adc	r25, r19
    d17c:	95 83       	std	Z+5, r25	; 0x05
    d17e:	84 83       	std	Z+4, r24	; 0x04
    d180:	0d c0       	rjmp	.+26     	; 0xd19c <WebPutField+0x1cc>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d182:	cb 01       	movw	r24, r22
    d184:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    d188:	90 e0       	ldi	r25, 0x00	; 0
    d18a:	88 0f       	add	r24, r24
    d18c:	99 1f       	adc	r25, r25
    d18e:	f6 01       	movw	r30, r12
    d190:	24 81       	ldd	r18, Z+4	; 0x04
    d192:	35 81       	ldd	r19, Z+5	; 0x05
    d194:	28 0f       	add	r18, r24
    d196:	39 1f       	adc	r19, r25
    d198:	35 83       	std	Z+5, r19	; 0x05
    d19a:	24 83       	std	Z+4, r18	; 0x04
		PutEnum(Param);
    d19c:	c6 01       	movw	r24, r12
    d19e:	0e 94 38 4c 	call	0x9870	; 0x9870 <PutEnum>
    d1a2:	7c c0       	rjmp	.+248    	; 0xd29c <WebPutField+0x2cc>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1a4:	fa 01       	movw	r30, r20
    d1a6:	a0 81       	ld	r26, Z
    d1a8:	b1 81       	ldd	r27, Z+1	; 0x01
    d1aa:	64 81       	ldd	r22, Z+4	; 0x04
    d1ac:	75 81       	ldd	r23, Z+5	; 0x05
    d1ae:	42 81       	ldd	r20, Z+2	; 0x02
    d1b0:	84 2f       	mov	r24, r20
    d1b2:	86 95       	lsr	r24
    d1b4:	86 95       	lsr	r24
    d1b6:	86 95       	lsr	r24
    d1b8:	68 0e       	add	r6, r24
    d1ba:	71 1c       	adc	r7, r1
    d1bc:	f3 01       	movw	r30, r6
    d1be:	20 81       	ld	r18, Z
    d1c0:	30 e0       	ldi	r19, 0x00	; 0
    d1c2:	47 70       	andi	r20, 0x07	; 7
    d1c4:	81 e0       	ldi	r24, 0x01	; 1
    d1c6:	90 e0       	ldi	r25, 0x00	; 0
    d1c8:	02 c0       	rjmp	.+4      	; 0xd1ce <WebPutField+0x1fe>
    d1ca:	88 0f       	add	r24, r24
    d1cc:	99 1f       	adc	r25, r25
    d1ce:	4a 95       	dec	r20
    d1d0:	e2 f7       	brpl	.-8      	; 0xd1ca <WebPutField+0x1fa>
    d1d2:	28 23       	and	r18, r24
    d1d4:	39 23       	and	r19, r25
    d1d6:	12 16       	cp	r1, r18
    d1d8:	13 06       	cpc	r1, r19
    d1da:	1c f0       	brlt	.+6      	; 0xd1e2 <WebPutField+0x212>
    d1dc:	80 e0       	ldi	r24, 0x00	; 0
    d1de:	90 e0       	ldi	r25, 0x00	; 0
    d1e0:	02 c0       	rjmp	.+4      	; 0xd1e6 <WebPutField+0x216>
    d1e2:	82 e0       	ldi	r24, 0x02	; 2
    d1e4:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d1e6:	fb 01       	movw	r30, r22
    d1e8:	e8 0f       	add	r30, r24
    d1ea:	f9 1f       	adc	r31, r25
    d1ec:	65 91       	lpm	r22, Z+
    d1ee:	74 91       	lpm	r23, Z+
    d1f0:	cd 01       	movw	r24, r26
    d1f2:	29 c0       	rjmp	.+82     	; 0xd246 <WebPutField+0x276>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1f4:	fa 01       	movw	r30, r20
    d1f6:	a0 80       	ld	r10, Z
    d1f8:	b1 80       	ldd	r11, Z+1	; 0x01
    d1fa:	e4 80       	ldd	r14, Z+4	; 0x04
    d1fc:	f5 80       	ldd	r15, Z+5	; 0x05
    d1fe:	12 81       	ldd	r17, Z+2	; 0x02
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d200:	81 2f       	mov	r24, r17
    d202:	86 95       	lsr	r24
    d204:	86 95       	lsr	r24
    d206:	86 95       	lsr	r24
    d208:	9b 01       	movw	r18, r22
    d20a:	28 0f       	add	r18, r24
    d20c:	31 1d       	adc	r19, r1
    d20e:	c9 01       	movw	r24, r18
    d210:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    d214:	17 70       	andi	r17, 0x07	; 7
    d216:	21 e0       	ldi	r18, 0x01	; 1
    d218:	30 e0       	ldi	r19, 0x00	; 0
    d21a:	02 c0       	rjmp	.+4      	; 0xd220 <WebPutField+0x250>
    d21c:	22 0f       	add	r18, r18
    d21e:	33 1f       	adc	r19, r19
    d220:	1a 95       	dec	r17
    d222:	e2 f7       	brpl	.-8      	; 0xd21c <WebPutField+0x24c>
    d224:	90 e0       	ldi	r25, 0x00	; 0
    d226:	28 23       	and	r18, r24
    d228:	39 23       	and	r19, r25
    d22a:	12 16       	cp	r1, r18
    d22c:	13 06       	cpc	r1, r19
    d22e:	1c f0       	brlt	.+6      	; 0xd236 <WebPutField+0x266>
    d230:	80 e0       	ldi	r24, 0x00	; 0
    d232:	90 e0       	ldi	r25, 0x00	; 0
    d234:	02 c0       	rjmp	.+4      	; 0xd23a <WebPutField+0x26a>
    d236:	82 e0       	ldi	r24, 0x02	; 2
    d238:	90 e0       	ldi	r25, 0x00	; 0

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d23a:	f7 01       	movw	r30, r14
    d23c:	e8 0f       	add	r30, r24
    d23e:	f9 1f       	adc	r31, r25
    d240:	65 91       	lpm	r22, Z+
    d242:	74 91       	lpm	r23, Z+
    d244:	c5 01       	movw	r24, r10
    d246:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
    d24a:	28 c0       	rjmp	.+80     	; 0xd29c <WebPutField+0x2cc>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    d24c:	cb 01       	movw	r24, r22
    d24e:	ba 01       	movw	r22, r20
    d250:	0e 94 92 4a 	call	0x9524	; 0x9524 <Put_TextValAlignLeft>
    d254:	23 c0       	rjmp	.+70     	; 0xd29c <WebPutField+0x2cc>
		break;
    d256:	ee b6       	in	r14, 0x3e	; 62
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    d258:	fa 01       	movw	r30, r20
    d25a:	43 81       	ldd	r20, Z+3	; 0x03
    d25c:	84 2f       	mov	r24, r20
    d25e:	90 e0       	ldi	r25, 0x00	; 0
    d260:	01 96       	adiw	r24, 0x01	; 1
    d262:	2d b7       	in	r18, 0x3d	; 61
    d264:	3e b7       	in	r19, 0x3e	; 62
    d266:	28 1b       	sub	r18, r24
    d268:	39 0b       	sbc	r19, r25
    d26a:	0f b6       	in	r0, 0x3f	; 63
    d26c:	f8 94       	cli
    d26e:	3e bf       	out	0x3e, r19	; 62
    d270:	0f be       	out	0x3f, r0	; 63
    d272:	2d bf       	out	0x3d, r18	; 61
    d274:	0d b7       	in	r16, 0x3d	; 61
    d276:	1e b7       	in	r17, 0x3e	; 62
    d278:	0f 5f       	subi	r16, 0xFF	; 255
    d27a:	1f 4f       	sbci	r17, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d27c:	c8 01       	movw	r24, r16
    d27e:	50 e0       	ldi	r21, 0x00	; 0
    d280:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    d284:	c8 01       	movw	r24, r16
    d286:	b6 01       	movw	r22, r12
    d288:	0e 94 92 4a 	call	0x9524	; 0x9524 <Put_TextValAlignLeft>
    d28c:	28 2d       	mov	r18, r8
    d28e:	3e 2d       	mov	r19, r14
    d290:	c9 01       	movw	r24, r18
    d292:	0f b6       	in	r0, 0x3f	; 63
    d294:	f8 94       	cli
    d296:	9e bf       	out	0x3e, r25	; 62
    d298:	0f be       	out	0x3f, r0	; 63
    d29a:	8d bf       	out	0x3d, r24	; 61
		}
		break;
	}
}
    d29c:	0f b6       	in	r0, 0x3f	; 63
    d29e:	f8 94       	cli
    d2a0:	9e be       	out	0x3e, r9	; 62
    d2a2:	0f be       	out	0x3f, r0	; 63
    d2a4:	8d be       	out	0x3d, r8	; 61
    d2a6:	0f 90       	pop	r0
    d2a8:	0f 90       	pop	r0
    d2aa:	0f 90       	pop	r0
    d2ac:	0f 90       	pop	r0
    d2ae:	cf 91       	pop	r28
    d2b0:	df 91       	pop	r29
    d2b2:	1f 91       	pop	r17
    d2b4:	0f 91       	pop	r16
    d2b6:	ff 90       	pop	r15
    d2b8:	ef 90       	pop	r14
    d2ba:	df 90       	pop	r13
    d2bc:	cf 90       	pop	r12
    d2be:	bf 90       	pop	r11
    d2c0:	af 90       	pop	r10
    d2c2:	9f 90       	pop	r9
    d2c4:	8f 90       	pop	r8
    d2c6:	7f 90       	pop	r7
    d2c8:	6f 90       	pop	r6
    d2ca:	08 95       	ret

0000d2cc <strcmp_E>:
	}
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    d2cc:	ff 92       	push	r15
    d2ce:	0f 93       	push	r16
    d2d0:	1f 93       	push	r17
    d2d2:	cf 93       	push	r28
    d2d4:	df 93       	push	r29
    d2d6:	8c 01       	movw	r16, r24
    d2d8:	eb 01       	movw	r28, r22
    d2da:	0e c0       	rjmp	.+28     	; 0xd2f8 <strcmp_E+0x2c>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d2dc:	ce 01       	movw	r24, r28
    d2de:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	while(*str_RAM || erb((uint8_t*)str_EE)){
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    d2e2:	8f 15       	cp	r24, r15
    d2e4:	10 f4       	brcc	.+4      	; 0xd2ea <strcmp_E+0x1e>
    d2e6:	81 e0       	ldi	r24, 0x01	; 1
    d2e8:	10 c0       	rjmp	.+32     	; 0xd30a <strcmp_E+0x3e>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    d2ea:	f8 16       	cp	r15, r24
    d2ec:	10 f4       	brcc	.+4      	; 0xd2f2 <strcmp_E+0x26>
    d2ee:	8f ef       	ldi	r24, 0xFF	; 255
    d2f0:	0c c0       	rjmp	.+24     	; 0xd30a <strcmp_E+0x3e>
		str_RAM++;
    d2f2:	0f 5f       	subi	r16, 0xFF	; 255
    d2f4:	1f 4f       	sbci	r17, 0xFF	; 255
		str_EE++;		
    d2f6:	21 96       	adiw	r28, 0x01	; 1
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    d2f8:	f8 01       	movw	r30, r16
    d2fa:	f0 80       	ld	r15, Z
    d2fc:	ff 20       	and	r15, r15
    d2fe:	71 f7       	brne	.-36     	; 0xd2dc <strcmp_E+0x10>
    d300:	ce 01       	movw	r24, r28
    d302:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    d306:	88 23       	and	r24, r24
    d308:	49 f7       	brne	.-46     	; 0xd2dc <strcmp_E+0x10>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    d30a:	df 91       	pop	r29
    d30c:	cf 91       	pop	r28
    d30e:	1f 91       	pop	r17
    d310:	0f 91       	pop	r16
    d312:	ff 90       	pop	r15
    d314:	08 95       	ret

0000d316 <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    d316:	ef 92       	push	r14
    d318:	ff 92       	push	r15
    d31a:	0f 93       	push	r16
    d31c:	1f 93       	push	r17
    d31e:	cf 93       	push	r28
    d320:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    d322:	80 91 e9 08 	lds	r24, 0x08E9
    d326:	88 23       	and	r24, r24
    d328:	11 f0       	breq	.+4      	; 0xd32e <Web_Login_Error+0x18>
    d32a:	81 e0       	ldi	r24, 0x01	; 1
    d32c:	97 c0       	rjmp	.+302    	; 0xd45c <Web_Login_Error+0x146>
    d32e:	0a e6       	ldi	r16, 0x6A	; 106
    d330:	15 e0       	ldi	r17, 0x05	; 5
    d332:	c0 e3       	ldi	r28, 0x30	; 48
    d334:	d1 e0       	ldi	r29, 0x01	; 1
    d336:	ff 24       	eor	r15, r15
    d338:	ee 24       	eor	r14, r14
    d33a:	ea 94       	dec	r14
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	uint8_t pass = 255;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if( !strcmp_P(Web_Login_Str, Web_Logins[i]) && !strcmp_E(Web_Passw_Str, Web_Passws[i])) pass = i;
    d33c:	82 e6       	ldi	r24, 0x62	; 98
    d33e:	99 e0       	ldi	r25, 0x09	; 9
    d340:	b8 01       	movw	r22, r16
    d342:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    d346:	89 2b       	or	r24, r25
    d348:	41 f4       	brne	.+16     	; 0xd35a <Web_Login_Error+0x44>
    d34a:	82 e7       	ldi	r24, 0x72	; 114
    d34c:	95 e0       	ldi	r25, 0x05	; 5
    d34e:	be 01       	movw	r22, r28
    d350:	0e 94 66 69 	call	0xd2cc	; 0xd2cc <strcmp_E>
    d354:	88 23       	and	r24, r24
    d356:	09 f4       	brne	.+2      	; 0xd35a <Web_Login_Error+0x44>
    d358:	ef 2c       	mov	r14, r15
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	uint8_t pass = 255;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    d35a:	f3 94       	inc	r15
    d35c:	00 5f       	subi	r16, 0xF0	; 240
    d35e:	1f 4f       	sbci	r17, 0xFF	; 255
    d360:	2b 96       	adiw	r28, 0x0b	; 11
    d362:	24 e0       	ldi	r18, 0x04	; 4
    d364:	f2 16       	cp	r15, r18
    d366:	51 f7       	brne	.-44     	; 0xd33c <Web_Login_Error+0x26>
		if( !strcmp_P(Web_Login_Str, Web_Logins[i]) && !strcmp_E(Web_Passw_Str, Web_Passws[i])) pass = i;
	}
	if(pass == 255) return 2;
    d368:	3f ef       	ldi	r19, 0xFF	; 255
    d36a:	e3 16       	cp	r14, r19
    d36c:	11 f4       	brne	.+4      	; 0xd372 <Web_Login_Error+0x5c>
    d36e:	82 e0       	ldi	r24, 0x02	; 2
    d370:	75 c0       	rjmp	.+234    	; 0xd45c <Web_Login_Error+0x146>

	

	WebSession = 1;
    d372:	81 e0       	ldi	r24, 0x01	; 1
    d374:	80 93 e9 08 	sts	0x08E9, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    d378:	e0 91 99 05 	lds	r30, 0x0599

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    d37c:	8f b7       	in	r24, 0x3f	; 63
    d37e:	80 78       	andi	r24, 0x80	; 128
    d380:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    d384:	f8 94       	cli
// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
	uint32_t Time = Timer32[TimerN];
    d386:	f0 e0       	ldi	r31, 0x00	; 0
    d388:	ee 0f       	add	r30, r30
    d38a:	ff 1f       	adc	r31, r31
    d38c:	ee 0f       	add	r30, r30
    d38e:	ff 1f       	adc	r31, r31
    d390:	eb 56       	subi	r30, 0x6B	; 107
    d392:	fd 4f       	sbci	r31, 0xFD	; 253
    d394:	20 81       	ld	r18, Z
    d396:	31 81       	ldd	r19, Z+1	; 0x01
    d398:	42 81       	ldd	r20, Z+2	; 0x02
    d39a:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    d39c:	88 23       	and	r24, r24
    d39e:	09 f0       	breq	.+2      	; 0xd3a2 <Web_Login_Error+0x8c>
		sei();
    d3a0:	78 94       	sei
	srandom(Seed);
    d3a2:	ca 01       	movw	r24, r20
    d3a4:	b9 01       	movw	r22, r18
    d3a6:	0e 94 86 87 	call	0x10f0c	; 0x10f0c <srandom>
	random();// 
    d3aa:	0e 94 81 87 	call	0x10f02	; 0x10f02 <random>
	Seed = random();
    d3ae:	0e 94 81 87 	call	0x10f02	; 0x10f02 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    d3b2:	ad b7       	in	r26, 0x3d	; 61
    d3b4:	be b7       	in	r27, 0x3e	; 62
    d3b6:	18 97       	sbiw	r26, 0x08	; 8
    d3b8:	0f b6       	in	r0, 0x3f	; 63
    d3ba:	f8 94       	cli
    d3bc:	be bf       	out	0x3e, r27	; 62
    d3be:	0f be       	out	0x3f, r0	; 63
    d3c0:	ad bf       	out	0x3d, r26	; 61
    d3c2:	ed b7       	in	r30, 0x3d	; 61
    d3c4:	fe b7       	in	r31, 0x3e	; 62
    d3c6:	31 96       	adiw	r30, 0x01	; 1
    d3c8:	06 ea       	ldi	r16, 0xA6	; 166
    d3ca:	15 e0       	ldi	r17, 0x05	; 5
    d3cc:	12 96       	adiw	r26, 0x02	; 2
    d3ce:	1c 93       	st	X, r17
    d3d0:	0e 93       	st	-X, r16
    d3d2:	11 97       	sbiw	r26, 0x01	; 1
    d3d4:	27 e0       	ldi	r18, 0x07	; 7
    d3d6:	39 e4       	ldi	r19, 0x49	; 73
    d3d8:	33 83       	std	Z+3, r19	; 0x03
    d3da:	22 83       	std	Z+2, r18	; 0x02
    d3dc:	64 83       	std	Z+4, r22	; 0x04
    d3de:	75 83       	std	Z+5, r23	; 0x05
    d3e0:	86 83       	std	Z+6, r24	; 0x06
    d3e2:	97 83       	std	Z+7, r25	; 0x07
    d3e4:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
	Seed = random();
    d3e8:	2d b7       	in	r18, 0x3d	; 61
    d3ea:	3e b7       	in	r19, 0x3e	; 62
    d3ec:	28 5f       	subi	r18, 0xF8	; 248
    d3ee:	3f 4f       	sbci	r19, 0xFF	; 255
    d3f0:	0f b6       	in	r0, 0x3f	; 63
    d3f2:	f8 94       	cli
    d3f4:	3e bf       	out	0x3e, r19	; 62
    d3f6:	0f be       	out	0x3f, r0	; 63
    d3f8:	2d bf       	out	0x3d, r18	; 61
    d3fa:	0e 94 81 87 	call	0x10f02	; 0x10f02 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    d3fe:	ad b7       	in	r26, 0x3d	; 61
    d400:	be b7       	in	r27, 0x3e	; 62
    d402:	18 97       	sbiw	r26, 0x08	; 8
    d404:	0f b6       	in	r0, 0x3f	; 63
    d406:	f8 94       	cli
    d408:	be bf       	out	0x3e, r27	; 62
    d40a:	0f be       	out	0x3f, r0	; 63
    d40c:	ad bf       	out	0x3d, r26	; 61
    d40e:	ed b7       	in	r30, 0x3d	; 61
    d410:	fe b7       	in	r31, 0x3e	; 62
    d412:	31 96       	adiw	r30, 0x01	; 1
    d414:	08 5f       	subi	r16, 0xF8	; 248
    d416:	1f 4f       	sbci	r17, 0xFF	; 255
    d418:	12 96       	adiw	r26, 0x02	; 2
    d41a:	1c 93       	st	X, r17
    d41c:	0e 93       	st	-X, r16
    d41e:	11 97       	sbiw	r26, 0x01	; 1
    d420:	2d ef       	ldi	r18, 0xFD	; 253
    d422:	38 e4       	ldi	r19, 0x48	; 72
    d424:	33 83       	std	Z+3, r19	; 0x03
    d426:	22 83       	std	Z+2, r18	; 0x02
    d428:	64 83       	std	Z+4, r22	; 0x04
    d42a:	75 83       	std	Z+5, r23	; 0x05
    d42c:	86 83       	std	Z+6, r24	; 0x06
    d42e:	97 83       	std	Z+7, r25	; 0x07
    d430:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    d434:	2d b7       	in	r18, 0x3d	; 61
    d436:	3e b7       	in	r19, 0x3e	; 62
    d438:	28 5f       	subi	r18, 0xF8	; 248
    d43a:	3f 4f       	sbci	r19, 0xFF	; 255
    d43c:	0f b6       	in	r0, 0x3f	; 63
    d43e:	f8 94       	cli
    d440:	3e bf       	out	0x3e, r19	; 62
    d442:	0f be       	out	0x3f, r0	; 63
    d444:	2d bf       	out	0x3d, r18	; 61
    d446:	8c e2       	ldi	r24, 0x2C	; 44
    d448:	91 e0       	ldi	r25, 0x01	; 1
    d44a:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
    d44e:	ab 01       	movw	r20, r22
    d450:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    d452:	80 91 d5 08 	lds	r24, 0x08D5
    d456:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <StartTimer32>
    d45a:	80 e0       	ldi	r24, 0x00	; 0
	return 0;
}
    d45c:	df 91       	pop	r29
    d45e:	cf 91       	pop	r28
    d460:	1f 91       	pop	r17
    d462:	0f 91       	pop	r16
    d464:	ff 90       	pop	r15
    d466:	ef 90       	pop	r14
    d468:	08 95       	ret

0000d46a <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    d46a:	3f 92       	push	r3
    d46c:	4f 92       	push	r4
    d46e:	5f 92       	push	r5
    d470:	6f 92       	push	r6
    d472:	7f 92       	push	r7
    d474:	8f 92       	push	r8
    d476:	9f 92       	push	r9
    d478:	af 92       	push	r10
    d47a:	bf 92       	push	r11
    d47c:	cf 92       	push	r12
    d47e:	df 92       	push	r13
    d480:	ef 92       	push	r14
    d482:	ff 92       	push	r15
    d484:	0f 93       	push	r16
    d486:	1f 93       	push	r17
    d488:	df 93       	push	r29
    d48a:	cf 93       	push	r28
    d48c:	cd b7       	in	r28, 0x3d	; 61
    d48e:	de b7       	in	r29, 0x3e	; 62
    d490:	2c 97       	sbiw	r28, 0x0c	; 12
    d492:	0f b6       	in	r0, 0x3f	; 63
    d494:	f8 94       	cli
    d496:	de bf       	out	0x3e, r29	; 62
    d498:	0f be       	out	0x3f, r0	; 63
    d49a:	cd bf       	out	0x3d, r28	; 61
    d49c:	9a 87       	std	Y+10, r25	; 0x0a
    d49e:	89 87       	std	Y+9, r24	; 0x09
    d4a0:	4b 01       	movw	r8, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    d4a2:	2d b7       	in	r18, 0x3d	; 61
    d4a4:	3e b7       	in	r19, 0x3e	; 62
    d4a6:	3c 87       	std	Y+12, r19	; 0x0c
    d4a8:	2b 87       	std	Y+11, r18	; 0x0b

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d4aa:	fc 01       	movw	r30, r24
    d4ac:	31 96       	adiw	r30, 0x01	; 1
    d4ae:	65 90       	lpm	r6, Z+
    d4b0:	74 90       	lpm	r7, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d4b2:	ac 01       	movw	r20, r24
    d4b4:	41 5f       	subi	r20, 0xF1	; 241
    d4b6:	5f 4f       	sbci	r21, 0xFF	; 255
    d4b8:	fa 01       	movw	r30, r20
    d4ba:	24 91       	lpm	r18, Z+
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    d4bc:	32 2f       	mov	r19, r18
    d4be:	37 70       	andi	r19, 0x07	; 7
    d4c0:	81 e0       	ldi	r24, 0x01	; 1
    d4c2:	90 e0       	ldi	r25, 0x00	; 0
    d4c4:	38 2e       	mov	r3, r24
    d4c6:	01 c0       	rjmp	.+2      	; 0xd4ca <WebBuf2Field+0x60>
    d4c8:	33 0c       	add	r3, r3
    d4ca:	3a 95       	dec	r19
    d4cc:	ea f7       	brpl	.-6      	; 0xd4c8 <WebBuf2Field+0x5e>
    d4ce:	26 95       	lsr	r18
    d4d0:	26 95       	lsr	r18
    d4d2:	26 95       	lsr	r18
    d4d4:	23 01       	movw	r4, r6
    d4d6:	42 0e       	add	r4, r18
    d4d8:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    d4da:	e9 85       	ldd	r30, Y+9	; 0x09
    d4dc:	fa 85       	ldd	r31, Y+10	; 0x0a
    d4de:	33 96       	adiw	r30, 0x03	; 3
    d4e0:	a5 90       	lpm	r10, Z+
    d4e2:	b5 90       	lpm	r11, Z+
    d4e4:	c5 90       	lpm	r12, Z+
    d4e6:	d4 90       	lpm	r13, Z+
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);

	uint32_t Temp=0;
    d4e8:	e9 85       	ldd	r30, Y+9	; 0x09
    d4ea:	fa 85       	ldd	r31, Y+10	; 0x0a
    d4ec:	37 96       	adiw	r30, 0x07	; 7
    d4ee:	e5 90       	lpm	r14, Z+
    d4f0:	f5 90       	lpm	r15, Z+
    d4f2:	05 91       	lpm	r16, Z+
    d4f4:	14 91       	lpm	r17, Z+
    d4f6:	19 82       	std	Y+1, r1	; 0x01
    d4f8:	1a 82       	std	Y+2, r1	; 0x02
    d4fa:	1b 82       	std	Y+3, r1	; 0x03
    d4fc:	1c 82       	std	Y+4, r1	; 0x04
	float fTemp=0;
    d4fe:	80 e0       	ldi	r24, 0x00	; 0
    d500:	90 e0       	ldi	r25, 0x00	; 0
    d502:	a0 e0       	ldi	r26, 0x00	; 0
    d504:	b0 e0       	ldi	r27, 0x00	; 0
    d506:	8d 83       	std	Y+5, r24	; 0x05
    d508:	9e 83       	std	Y+6, r25	; 0x06
    d50a:	af 83       	std	Y+7, r26	; 0x07
    d50c:	b8 87       	std	Y+8, r27	; 0x08

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    d50e:	e9 85       	ldd	r30, Y+9	; 0x09
    d510:	fa 85       	ldd	r31, Y+10	; 0x0a
    d512:	84 91       	lpm	r24, Z+


	switch(prb(&Field->Type)) {
    d514:	e8 2f       	mov	r30, r24
    d516:	f0 e0       	ldi	r31, 0x00	; 0
    d518:	e3 32       	cpi	r30, 0x23	; 35
    d51a:	f1 05       	cpc	r31, r1
    d51c:	08 f0       	brcs	.+2      	; 0xd520 <WebBuf2Field+0xb6>
    d51e:	ca c3       	rjmp	.+1940   	; 0xdcb4 <WebBuf2Field+0x84a>
    d520:	e1 58       	subi	r30, 0x81	; 129
    d522:	ff 4f       	sbci	r31, 0xFF	; 255
    d524:	ee 0f       	add	r30, r30
    d526:	ff 1f       	adc	r31, r31
    d528:	05 90       	lpm	r0, Z+
    d52a:	f4 91       	lpm	r31, Z+
    d52c:	e0 2d       	mov	r30, r0
    d52e:	09 94       	ijmp



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    d530:	89 85       	ldd	r24, Y+9	; 0x09
    d532:	9a 85       	ldd	r25, Y+10	; 0x0a
    d534:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    d538:	00 d0       	rcall	.+0      	; 0xd53a <WebBuf2Field+0xd0>
    d53a:	00 d0       	rcall	.+0      	; 0xd53c <WebBuf2Field+0xd2>
    d53c:	00 d0       	rcall	.+0      	; 0xd53e <WebBuf2Field+0xd4>
    d53e:	ed b7       	in	r30, 0x3d	; 61
    d540:	fe b7       	in	r31, 0x3e	; 62
    d542:	31 96       	adiw	r30, 0x01	; 1
    d544:	ad b7       	in	r26, 0x3d	; 61
    d546:	be b7       	in	r27, 0x3e	; 62
    d548:	12 96       	adiw	r26, 0x02	; 2
    d54a:	9c 92       	st	X, r9
    d54c:	8e 92       	st	-X, r8
    d54e:	11 97       	sbiw	r26, 0x01	; 1
    d550:	8d e8       	ldi	r24, 0x8D	; 141
    d552:	91 e0       	ldi	r25, 0x01	; 1
    d554:	93 83       	std	Z+3, r25	; 0x03
    d556:	82 83       	std	Z+2, r24	; 0x02
    d558:	ce 01       	movw	r24, r28
    d55a:	01 96       	adiw	r24, 0x01	; 1
    d55c:	95 83       	std	Z+5, r25	; 0x05
    d55e:	84 83       	std	Z+4, r24	; 0x04
    d560:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		SetField(Temp, uint8_t);
    d564:	29 81       	ldd	r18, Y+1	; 0x01
    d566:	3a 81       	ldd	r19, Y+2	; 0x02
    d568:	4b 81       	ldd	r20, Y+3	; 0x03
    d56a:	5c 81       	ldd	r21, Y+4	; 0x04
    d56c:	8e 2d       	mov	r24, r14
    d56e:	90 e0       	ldi	r25, 0x00	; 0
    d570:	a0 e0       	ldi	r26, 0x00	; 0
    d572:	b0 e0       	ldi	r27, 0x00	; 0
    d574:	ed b7       	in	r30, 0x3d	; 61
    d576:	fe b7       	in	r31, 0x3e	; 62
    d578:	36 96       	adiw	r30, 0x06	; 6
    d57a:	0f b6       	in	r0, 0x3f	; 63
    d57c:	f8 94       	cli
    d57e:	fe bf       	out	0x3e, r31	; 62
    d580:	0f be       	out	0x3f, r0	; 63
    d582:	ed bf       	out	0x3d, r30	; 61
    d584:	8e c2       	rjmp	.+1308   	; 0xdaa2 <WebBuf2Field+0x638>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    d586:	89 85       	ldd	r24, Y+9	; 0x09
    d588:	9a 85       	ldd	r25, Y+10	; 0x0a
    d58a:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    d58e:	00 d0       	rcall	.+0      	; 0xd590 <WebBuf2Field+0x126>
    d590:	00 d0       	rcall	.+0      	; 0xd592 <WebBuf2Field+0x128>
    d592:	00 d0       	rcall	.+0      	; 0xd594 <WebBuf2Field+0x12a>
    d594:	ed b7       	in	r30, 0x3d	; 61
    d596:	fe b7       	in	r31, 0x3e	; 62
    d598:	31 96       	adiw	r30, 0x01	; 1
    d59a:	ad b7       	in	r26, 0x3d	; 61
    d59c:	be b7       	in	r27, 0x3e	; 62
    d59e:	12 96       	adiw	r26, 0x02	; 2
    d5a0:	9c 92       	st	X, r9
    d5a2:	8e 92       	st	-X, r8
    d5a4:	11 97       	sbiw	r26, 0x01	; 1
    d5a6:	8d e8       	ldi	r24, 0x8D	; 141
    d5a8:	91 e0       	ldi	r25, 0x01	; 1
    d5aa:	93 83       	std	Z+3, r25	; 0x03
    d5ac:	82 83       	std	Z+2, r24	; 0x02
    d5ae:	ce 01       	movw	r24, r28
    d5b0:	01 96       	adiw	r24, 0x01	; 1
    d5b2:	95 83       	std	Z+5, r25	; 0x05
    d5b4:	84 83       	std	Z+4, r24	; 0x04
    d5b6:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    d5ba:	ed b7       	in	r30, 0x3d	; 61
    d5bc:	fe b7       	in	r31, 0x3e	; 62
    d5be:	36 96       	adiw	r30, 0x06	; 6
    d5c0:	0f b6       	in	r0, 0x3f	; 63
    d5c2:	f8 94       	cli
    d5c4:	fe bf       	out	0x3e, r31	; 62
    d5c6:	0f be       	out	0x3f, r0	; 63
    d5c8:	ed bf       	out	0x3d, r30	; 61
    d5ca:	01 97       	sbiw	r24, 0x01	; 1
    d5cc:	09 f0       	breq	.+2      	; 0xd5d0 <WebBuf2Field+0x166>
    d5ce:	72 c3       	rjmp	.+1764   	; 0xdcb4 <WebBuf2Field+0x84a>
			SetEEField(Temp, uint8_t, uint8_t, b);
    d5d0:	29 81       	ldd	r18, Y+1	; 0x01
    d5d2:	3a 81       	ldd	r19, Y+2	; 0x02
    d5d4:	4b 81       	ldd	r20, Y+3	; 0x03
    d5d6:	5c 81       	ldd	r21, Y+4	; 0x04
    d5d8:	82 c2       	rjmp	.+1284   	; 0xdade <WebBuf2Field+0x674>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    d5da:	89 85       	ldd	r24, Y+9	; 0x09
    d5dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    d5de:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    d5e2:	00 d0       	rcall	.+0      	; 0xd5e4 <WebBuf2Field+0x17a>
    d5e4:	00 d0       	rcall	.+0      	; 0xd5e6 <WebBuf2Field+0x17c>
    d5e6:	00 d0       	rcall	.+0      	; 0xd5e8 <WebBuf2Field+0x17e>
    d5e8:	ed b7       	in	r30, 0x3d	; 61
    d5ea:	fe b7       	in	r31, 0x3e	; 62
    d5ec:	31 96       	adiw	r30, 0x01	; 1
    d5ee:	ad b7       	in	r26, 0x3d	; 61
    d5f0:	be b7       	in	r27, 0x3e	; 62
    d5f2:	12 96       	adiw	r26, 0x02	; 2
    d5f4:	9c 92       	st	X, r9
    d5f6:	8e 92       	st	-X, r8
    d5f8:	11 97       	sbiw	r26, 0x01	; 1
    d5fa:	82 e9       	ldi	r24, 0x92	; 146
    d5fc:	91 e0       	ldi	r25, 0x01	; 1
    d5fe:	93 83       	std	Z+3, r25	; 0x03
    d600:	82 83       	std	Z+2, r24	; 0x02
    d602:	ce 01       	movw	r24, r28
    d604:	01 96       	adiw	r24, 0x01	; 1
    d606:	95 83       	std	Z+5, r25	; 0x05
    d608:	84 83       	std	Z+4, r24	; 0x04
    d60a:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		SetField(Temp, int8_t);
    d60e:	29 81       	ldd	r18, Y+1	; 0x01
    d610:	3a 81       	ldd	r19, Y+2	; 0x02
    d612:	4b 81       	ldd	r20, Y+3	; 0x03
    d614:	5c 81       	ldd	r21, Y+4	; 0x04
    d616:	8e 2d       	mov	r24, r14
    d618:	99 27       	eor	r25, r25
    d61a:	87 fd       	sbrc	r24, 7
    d61c:	90 95       	com	r25
    d61e:	a9 2f       	mov	r26, r25
    d620:	b9 2f       	mov	r27, r25
    d622:	ed b7       	in	r30, 0x3d	; 61
    d624:	fe b7       	in	r31, 0x3e	; 62
    d626:	36 96       	adiw	r30, 0x06	; 6
    d628:	0f b6       	in	r0, 0x3f	; 63
    d62a:	f8 94       	cli
    d62c:	fe bf       	out	0x3e, r31	; 62
    d62e:	0f be       	out	0x3f, r0	; 63
    d630:	ed bf       	out	0x3d, r30	; 61
    d632:	82 17       	cp	r24, r18
    d634:	93 07       	cpc	r25, r19
    d636:	a4 07       	cpc	r26, r20
    d638:	b5 07       	cpc	r27, r21
    d63a:	08 f4       	brcc	.+2      	; 0xd63e <WebBuf2Field+0x1d4>
    d63c:	37 c2       	rjmp	.+1134   	; 0xdaac <WebBuf2Field+0x642>
    d63e:	8a 2d       	mov	r24, r10
    d640:	99 27       	eor	r25, r25
    d642:	87 fd       	sbrc	r24, 7
    d644:	90 95       	com	r25
    d646:	a9 2f       	mov	r26, r25
    d648:	b9 2f       	mov	r27, r25
    d64a:	37 c2       	rjmp	.+1134   	; 0xdaba <WebBuf2Field+0x650>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    d64c:	89 85       	ldd	r24, Y+9	; 0x09
    d64e:	9a 85       	ldd	r25, Y+10	; 0x0a
    d650:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    d654:	00 d0       	rcall	.+0      	; 0xd656 <WebBuf2Field+0x1ec>
    d656:	00 d0       	rcall	.+0      	; 0xd658 <WebBuf2Field+0x1ee>
    d658:	00 d0       	rcall	.+0      	; 0xd65a <WebBuf2Field+0x1f0>
    d65a:	ed b7       	in	r30, 0x3d	; 61
    d65c:	fe b7       	in	r31, 0x3e	; 62
    d65e:	31 96       	adiw	r30, 0x01	; 1
    d660:	ad b7       	in	r26, 0x3d	; 61
    d662:	be b7       	in	r27, 0x3e	; 62
    d664:	12 96       	adiw	r26, 0x02	; 2
    d666:	9c 92       	st	X, r9
    d668:	8e 92       	st	-X, r8
    d66a:	11 97       	sbiw	r26, 0x01	; 1
    d66c:	82 e9       	ldi	r24, 0x92	; 146
    d66e:	91 e0       	ldi	r25, 0x01	; 1
    d670:	93 83       	std	Z+3, r25	; 0x03
    d672:	82 83       	std	Z+2, r24	; 0x02
    d674:	ce 01       	movw	r24, r28
    d676:	01 96       	adiw	r24, 0x01	; 1
    d678:	95 83       	std	Z+5, r25	; 0x05
    d67a:	84 83       	std	Z+4, r24	; 0x04
    d67c:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    d680:	ed b7       	in	r30, 0x3d	; 61
    d682:	fe b7       	in	r31, 0x3e	; 62
    d684:	36 96       	adiw	r30, 0x06	; 6
    d686:	0f b6       	in	r0, 0x3f	; 63
    d688:	f8 94       	cli
    d68a:	fe bf       	out	0x3e, r31	; 62
    d68c:	0f be       	out	0x3f, r0	; 63
    d68e:	ed bf       	out	0x3d, r30	; 61
    d690:	01 97       	sbiw	r24, 0x01	; 1
    d692:	09 f0       	breq	.+2      	; 0xd696 <WebBuf2Field+0x22c>
    d694:	0f c3       	rjmp	.+1566   	; 0xdcb4 <WebBuf2Field+0x84a>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    d696:	69 81       	ldd	r22, Y+1	; 0x01
    d698:	e6 16       	cp	r14, r22
    d69a:	0c f4       	brge	.+2      	; 0xd69e <WebBuf2Field+0x234>
    d69c:	29 c2       	rjmp	.+1106   	; 0xdaf0 <WebBuf2Field+0x686>
    d69e:	6a 15       	cp	r22, r10
    d6a0:	0c f4       	brge	.+2      	; 0xd6a4 <WebBuf2Field+0x23a>
    d6a2:	32 c2       	rjmp	.+1124   	; 0xdb08 <WebBuf2Field+0x69e>
    d6a4:	c3 01       	movw	r24, r6
    d6a6:	8f c2       	rjmp	.+1310   	; 0xdbc6 <WebBuf2Field+0x75c>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    d6a8:	89 85       	ldd	r24, Y+9	; 0x09
    d6aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    d6ac:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    d6b0:	00 d0       	rcall	.+0      	; 0xd6b2 <WebBuf2Field+0x248>
    d6b2:	00 d0       	rcall	.+0      	; 0xd6b4 <WebBuf2Field+0x24a>
    d6b4:	00 d0       	rcall	.+0      	; 0xd6b6 <WebBuf2Field+0x24c>
    d6b6:	ed b7       	in	r30, 0x3d	; 61
    d6b8:	fe b7       	in	r31, 0x3e	; 62
    d6ba:	31 96       	adiw	r30, 0x01	; 1
    d6bc:	ad b7       	in	r26, 0x3d	; 61
    d6be:	be b7       	in	r27, 0x3e	; 62
    d6c0:	12 96       	adiw	r26, 0x02	; 2
    d6c2:	9c 92       	st	X, r9
    d6c4:	8e 92       	st	-X, r8
    d6c6:	11 97       	sbiw	r26, 0x01	; 1
    d6c8:	86 e9       	ldi	r24, 0x96	; 150
    d6ca:	91 e0       	ldi	r25, 0x01	; 1
    d6cc:	93 83       	std	Z+3, r25	; 0x03
    d6ce:	82 83       	std	Z+2, r24	; 0x02
    d6d0:	ce 01       	movw	r24, r28
    d6d2:	01 96       	adiw	r24, 0x01	; 1
    d6d4:	95 83       	std	Z+5, r25	; 0x05
    d6d6:	84 83       	std	Z+4, r24	; 0x04
    d6d8:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		SetField(Temp, uint16_t);
    d6dc:	29 81       	ldd	r18, Y+1	; 0x01
    d6de:	3a 81       	ldd	r19, Y+2	; 0x02
    d6e0:	4b 81       	ldd	r20, Y+3	; 0x03
    d6e2:	5c 81       	ldd	r21, Y+4	; 0x04
    d6e4:	c7 01       	movw	r24, r14
    d6e6:	a0 e0       	ldi	r26, 0x00	; 0
    d6e8:	b0 e0       	ldi	r27, 0x00	; 0
    d6ea:	ed b7       	in	r30, 0x3d	; 61
    d6ec:	fe b7       	in	r31, 0x3e	; 62
    d6ee:	36 96       	adiw	r30, 0x06	; 6
    d6f0:	0f b6       	in	r0, 0x3f	; 63
    d6f2:	f8 94       	cli
    d6f4:	fe bf       	out	0x3e, r31	; 62
    d6f6:	0f be       	out	0x3f, r0	; 63
    d6f8:	ed bf       	out	0x3d, r30	; 61
    d6fa:	82 17       	cp	r24, r18
    d6fc:	93 07       	cpc	r25, r19
    d6fe:	a4 07       	cpc	r26, r20
    d700:	b5 07       	cpc	r27, r21
    d702:	08 f4       	brcc	.+2      	; 0xd706 <WebBuf2Field+0x29c>
    d704:	70 c0       	rjmp	.+224    	; 0xd7e6 <WebBuf2Field+0x37c>
    d706:	c5 01       	movw	r24, r10
    d708:	a0 e0       	ldi	r26, 0x00	; 0
    d70a:	b0 e0       	ldi	r27, 0x00	; 0
    d70c:	75 c0       	rjmp	.+234    	; 0xd7f8 <WebBuf2Field+0x38e>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    d70e:	89 85       	ldd	r24, Y+9	; 0x09
    d710:	9a 85       	ldd	r25, Y+10	; 0x0a
    d712:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    d716:	00 d0       	rcall	.+0      	; 0xd718 <WebBuf2Field+0x2ae>
    d718:	00 d0       	rcall	.+0      	; 0xd71a <WebBuf2Field+0x2b0>
    d71a:	00 d0       	rcall	.+0      	; 0xd71c <WebBuf2Field+0x2b2>
    d71c:	ed b7       	in	r30, 0x3d	; 61
    d71e:	fe b7       	in	r31, 0x3e	; 62
    d720:	31 96       	adiw	r30, 0x01	; 1
    d722:	ad b7       	in	r26, 0x3d	; 61
    d724:	be b7       	in	r27, 0x3e	; 62
    d726:	12 96       	adiw	r26, 0x02	; 2
    d728:	9c 92       	st	X, r9
    d72a:	8e 92       	st	-X, r8
    d72c:	11 97       	sbiw	r26, 0x01	; 1
    d72e:	8a e9       	ldi	r24, 0x9A	; 154
    d730:	91 e0       	ldi	r25, 0x01	; 1
    d732:	93 83       	std	Z+3, r25	; 0x03
    d734:	82 83       	std	Z+2, r24	; 0x02
    d736:	ce 01       	movw	r24, r28
    d738:	01 96       	adiw	r24, 0x01	; 1
    d73a:	95 83       	std	Z+5, r25	; 0x05
    d73c:	84 83       	std	Z+4, r24	; 0x04
    d73e:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    d742:	ed b7       	in	r30, 0x3d	; 61
    d744:	fe b7       	in	r31, 0x3e	; 62
    d746:	36 96       	adiw	r30, 0x06	; 6
    d748:	0f b6       	in	r0, 0x3f	; 63
    d74a:	f8 94       	cli
    d74c:	fe bf       	out	0x3e, r31	; 62
    d74e:	0f be       	out	0x3f, r0	; 63
    d750:	ed bf       	out	0x3d, r30	; 61
    d752:	01 97       	sbiw	r24, 0x01	; 1
    d754:	09 f0       	breq	.+2      	; 0xd758 <WebBuf2Field+0x2ee>
    d756:	ae c2       	rjmp	.+1372   	; 0xdcb4 <WebBuf2Field+0x84a>
			SetEEField(Temp, uint16_t, uint16_t, w);
    d758:	29 81       	ldd	r18, Y+1	; 0x01
    d75a:	3a 81       	ldd	r19, Y+2	; 0x02
    d75c:	4b 81       	ldd	r20, Y+3	; 0x03
    d75e:	5c 81       	ldd	r21, Y+4	; 0x04
    d760:	c7 01       	movw	r24, r14
    d762:	a0 e0       	ldi	r26, 0x00	; 0
    d764:	b0 e0       	ldi	r27, 0x00	; 0
    d766:	82 17       	cp	r24, r18
    d768:	93 07       	cpc	r25, r19
    d76a:	a4 07       	cpc	r26, r20
    d76c:	b5 07       	cpc	r27, r21
    d76e:	08 f4       	brcc	.+2      	; 0xd772 <WebBuf2Field+0x308>
    d770:	7c c0       	rjmp	.+248    	; 0xd86a <WebBuf2Field+0x400>
    d772:	c5 01       	movw	r24, r10
    d774:	a0 e0       	ldi	r26, 0x00	; 0
    d776:	b0 e0       	ldi	r27, 0x00	; 0
    d778:	28 17       	cp	r18, r24
    d77a:	39 07       	cpc	r19, r25
    d77c:	4a 07       	cpc	r20, r26
    d77e:	5b 07       	cpc	r21, r27
    d780:	08 f0       	brcs	.+2      	; 0xd784 <WebBuf2Field+0x31a>
    d782:	7c c0       	rjmp	.+248    	; 0xd87c <WebBuf2Field+0x412>
    d784:	78 c0       	rjmp	.+240    	; 0xd876 <WebBuf2Field+0x40c>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    d786:	89 85       	ldd	r24, Y+9	; 0x09
    d788:	9a 85       	ldd	r25, Y+10	; 0x0a
    d78a:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    d78e:	00 d0       	rcall	.+0      	; 0xd790 <WebBuf2Field+0x326>
    d790:	00 d0       	rcall	.+0      	; 0xd792 <WebBuf2Field+0x328>
    d792:	00 d0       	rcall	.+0      	; 0xd794 <WebBuf2Field+0x32a>
    d794:	ed b7       	in	r30, 0x3d	; 61
    d796:	fe b7       	in	r31, 0x3e	; 62
    d798:	31 96       	adiw	r30, 0x01	; 1
    d79a:	ad b7       	in	r26, 0x3d	; 61
    d79c:	be b7       	in	r27, 0x3e	; 62
    d79e:	12 96       	adiw	r26, 0x02	; 2
    d7a0:	9c 92       	st	X, r9
    d7a2:	8e 92       	st	-X, r8
    d7a4:	11 97       	sbiw	r26, 0x01	; 1
    d7a6:	8f e9       	ldi	r24, 0x9F	; 159
    d7a8:	91 e0       	ldi	r25, 0x01	; 1
    d7aa:	93 83       	std	Z+3, r25	; 0x03
    d7ac:	82 83       	std	Z+2, r24	; 0x02
    d7ae:	ce 01       	movw	r24, r28
    d7b0:	01 96       	adiw	r24, 0x01	; 1
    d7b2:	95 83       	std	Z+5, r25	; 0x05
    d7b4:	84 83       	std	Z+4, r24	; 0x04
    d7b6:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		SetField(Temp, int16_t);
    d7ba:	29 81       	ldd	r18, Y+1	; 0x01
    d7bc:	3a 81       	ldd	r19, Y+2	; 0x02
    d7be:	4b 81       	ldd	r20, Y+3	; 0x03
    d7c0:	5c 81       	ldd	r21, Y+4	; 0x04
    d7c2:	c7 01       	movw	r24, r14
    d7c4:	aa 27       	eor	r26, r26
    d7c6:	97 fd       	sbrc	r25, 7
    d7c8:	a0 95       	com	r26
    d7ca:	ba 2f       	mov	r27, r26
    d7cc:	ed b7       	in	r30, 0x3d	; 61
    d7ce:	fe b7       	in	r31, 0x3e	; 62
    d7d0:	36 96       	adiw	r30, 0x06	; 6
    d7d2:	0f b6       	in	r0, 0x3f	; 63
    d7d4:	f8 94       	cli
    d7d6:	fe bf       	out	0x3e, r31	; 62
    d7d8:	0f be       	out	0x3f, r0	; 63
    d7da:	ed bf       	out	0x3d, r30	; 61
    d7dc:	82 17       	cp	r24, r18
    d7de:	93 07       	cpc	r25, r19
    d7e0:	a4 07       	cpc	r26, r20
    d7e2:	b5 07       	cpc	r27, r21
    d7e4:	20 f4       	brcc	.+8      	; 0xd7ee <WebBuf2Field+0x384>
    d7e6:	d3 01       	movw	r26, r6
    d7e8:	ed 92       	st	X+, r14
    d7ea:	fc 92       	st	X, r15
    d7ec:	63 c2       	rjmp	.+1222   	; 0xdcb4 <WebBuf2Field+0x84a>
    d7ee:	c5 01       	movw	r24, r10
    d7f0:	aa 27       	eor	r26, r26
    d7f2:	97 fd       	sbrc	r25, 7
    d7f4:	a0 95       	com	r26
    d7f6:	ba 2f       	mov	r27, r26
    d7f8:	28 17       	cp	r18, r24
    d7fa:	39 07       	cpc	r19, r25
    d7fc:	4a 07       	cpc	r20, r26
    d7fe:	5b 07       	cpc	r21, r27
    d800:	20 f4       	brcc	.+8      	; 0xd80a <WebBuf2Field+0x3a0>
    d802:	f3 01       	movw	r30, r6
    d804:	b1 82       	std	Z+1, r11	; 0x01
    d806:	a0 82       	st	Z, r10
    d808:	55 c2       	rjmp	.+1194   	; 0xdcb4 <WebBuf2Field+0x84a>
    d80a:	d3 01       	movw	r26, r6
    d80c:	2d 93       	st	X+, r18
    d80e:	3c 93       	st	X, r19
    d810:	51 c2       	rjmp	.+1186   	; 0xdcb4 <WebBuf2Field+0x84a>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    d812:	89 85       	ldd	r24, Y+9	; 0x09
    d814:	9a 85       	ldd	r25, Y+10	; 0x0a
    d816:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    d81a:	00 d0       	rcall	.+0      	; 0xd81c <WebBuf2Field+0x3b2>
    d81c:	00 d0       	rcall	.+0      	; 0xd81e <WebBuf2Field+0x3b4>
    d81e:	00 d0       	rcall	.+0      	; 0xd820 <WebBuf2Field+0x3b6>
    d820:	ed b7       	in	r30, 0x3d	; 61
    d822:	fe b7       	in	r31, 0x3e	; 62
    d824:	31 96       	adiw	r30, 0x01	; 1
    d826:	ad b7       	in	r26, 0x3d	; 61
    d828:	be b7       	in	r27, 0x3e	; 62
    d82a:	12 96       	adiw	r26, 0x02	; 2
    d82c:	9c 92       	st	X, r9
    d82e:	8e 92       	st	-X, r8
    d830:	11 97       	sbiw	r26, 0x01	; 1
    d832:	8f e9       	ldi	r24, 0x9F	; 159
    d834:	91 e0       	ldi	r25, 0x01	; 1
    d836:	93 83       	std	Z+3, r25	; 0x03
    d838:	82 83       	std	Z+2, r24	; 0x02
    d83a:	ce 01       	movw	r24, r28
    d83c:	01 96       	adiw	r24, 0x01	; 1
    d83e:	95 83       	std	Z+5, r25	; 0x05
    d840:	84 83       	std	Z+4, r24	; 0x04
    d842:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    d846:	ed b7       	in	r30, 0x3d	; 61
    d848:	fe b7       	in	r31, 0x3e	; 62
    d84a:	36 96       	adiw	r30, 0x06	; 6
    d84c:	0f b6       	in	r0, 0x3f	; 63
    d84e:	f8 94       	cli
    d850:	fe bf       	out	0x3e, r31	; 62
    d852:	0f be       	out	0x3f, r0	; 63
    d854:	ed bf       	out	0x3d, r30	; 61
    d856:	01 97       	sbiw	r24, 0x01	; 1
    d858:	09 f0       	breq	.+2      	; 0xd85c <WebBuf2Field+0x3f2>
    d85a:	2c c2       	rjmp	.+1112   	; 0xdcb4 <WebBuf2Field+0x84a>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    d85c:	29 81       	ldd	r18, Y+1	; 0x01
    d85e:	3a 81       	ldd	r19, Y+2	; 0x02
    d860:	4b 81       	ldd	r20, Y+3	; 0x03
    d862:	5c 81       	ldd	r21, Y+4	; 0x04
    d864:	e2 16       	cp	r14, r18
    d866:	f3 06       	cpc	r15, r19
    d868:	1c f4       	brge	.+6      	; 0xd870 <WebBuf2Field+0x406>
    d86a:	c3 01       	movw	r24, r6
    d86c:	b7 01       	movw	r22, r14
    d86e:	08 c0       	rjmp	.+16     	; 0xd880 <WebBuf2Field+0x416>
    d870:	2a 15       	cp	r18, r10
    d872:	3b 05       	cpc	r19, r11
    d874:	1c f4       	brge	.+6      	; 0xd87c <WebBuf2Field+0x412>
    d876:	c3 01       	movw	r24, r6
    d878:	b5 01       	movw	r22, r10
    d87a:	02 c0       	rjmp	.+4      	; 0xd880 <WebBuf2Field+0x416>
    d87c:	c3 01       	movw	r24, r6
    d87e:	b9 01       	movw	r22, r18
    d880:	0e 94 08 52 	call	0xa410	; 0xa410 <eww>
    d884:	17 c2       	rjmp	.+1070   	; 0xdcb4 <WebBuf2Field+0x84a>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    d886:	80 91 5e 03 	lds	r24, 0x035E
    d88a:	90 91 5f 03 	lds	r25, 0x035F
    d88e:	d3 01       	movw	r26, r6
    d890:	8d 93       	st	X+, r24
    d892:	9c 93       	st	X, r25
    d894:	0f c2       	rjmp	.+1054   	; 0xdcb4 <WebBuf2Field+0x84a>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    d896:	89 85       	ldd	r24, Y+9	; 0x09
    d898:	9a 85       	ldd	r25, Y+10	; 0x0a
    d89a:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    d89e:	00 d0       	rcall	.+0      	; 0xd8a0 <WebBuf2Field+0x436>
    d8a0:	00 d0       	rcall	.+0      	; 0xd8a2 <WebBuf2Field+0x438>
    d8a2:	00 d0       	rcall	.+0      	; 0xd8a4 <WebBuf2Field+0x43a>
    d8a4:	ed b7       	in	r30, 0x3d	; 61
    d8a6:	fe b7       	in	r31, 0x3e	; 62
    d8a8:	31 96       	adiw	r30, 0x01	; 1
    d8aa:	ad b7       	in	r26, 0x3d	; 61
    d8ac:	be b7       	in	r27, 0x3e	; 62
    d8ae:	12 96       	adiw	r26, 0x02	; 2
    d8b0:	9c 92       	st	X, r9
    d8b2:	8e 92       	st	-X, r8
    d8b4:	11 97       	sbiw	r26, 0x01	; 1
    d8b6:	8a e9       	ldi	r24, 0x9A	; 154
    d8b8:	91 e0       	ldi	r25, 0x01	; 1
    d8ba:	25 c0       	rjmp	.+74     	; 0xd906 <WebBuf2Field+0x49c>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    d8bc:	89 85       	ldd	r24, Y+9	; 0x09
    d8be:	9a 85       	ldd	r25, Y+10	; 0x0a
    d8c0:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    d8c4:	00 d0       	rcall	.+0      	; 0xd8c6 <WebBuf2Field+0x45c>
    d8c6:	00 d0       	rcall	.+0      	; 0xd8c8 <WebBuf2Field+0x45e>
    d8c8:	00 d0       	rcall	.+0      	; 0xd8ca <WebBuf2Field+0x460>
    d8ca:	ed b7       	in	r30, 0x3d	; 61
    d8cc:	fe b7       	in	r31, 0x3e	; 62
    d8ce:	31 96       	adiw	r30, 0x01	; 1
    d8d0:	ad b7       	in	r26, 0x3d	; 61
    d8d2:	be b7       	in	r27, 0x3e	; 62
    d8d4:	12 96       	adiw	r26, 0x02	; 2
    d8d6:	9c 92       	st	X, r9
    d8d8:	8e 92       	st	-X, r8
    d8da:	11 97       	sbiw	r26, 0x01	; 1
    d8dc:	8a e9       	ldi	r24, 0x9A	; 154
    d8de:	91 e0       	ldi	r25, 0x01	; 1
    d8e0:	55 c0       	rjmp	.+170    	; 0xd98c <WebBuf2Field+0x522>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    d8e2:	89 85       	ldd	r24, Y+9	; 0x09
    d8e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    d8e6:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    d8ea:	00 d0       	rcall	.+0      	; 0xd8ec <WebBuf2Field+0x482>
    d8ec:	00 d0       	rcall	.+0      	; 0xd8ee <WebBuf2Field+0x484>
    d8ee:	00 d0       	rcall	.+0      	; 0xd8f0 <WebBuf2Field+0x486>
    d8f0:	ed b7       	in	r30, 0x3d	; 61
    d8f2:	fe b7       	in	r31, 0x3e	; 62
    d8f4:	31 96       	adiw	r30, 0x01	; 1
    d8f6:	ad b7       	in	r26, 0x3d	; 61
    d8f8:	be b7       	in	r27, 0x3e	; 62
    d8fa:	12 96       	adiw	r26, 0x02	; 2
    d8fc:	9c 92       	st	X, r9
    d8fe:	8e 92       	st	-X, r8
    d900:	11 97       	sbiw	r26, 0x01	; 1
    d902:	83 e0       	ldi	r24, 0x03	; 3
    d904:	91 e0       	ldi	r25, 0x01	; 1
    d906:	93 83       	std	Z+3, r25	; 0x03
    d908:	82 83       	std	Z+2, r24	; 0x02
    d90a:	ce 01       	movw	r24, r28
    d90c:	01 96       	adiw	r24, 0x01	; 1
    d90e:	95 83       	std	Z+5, r25	; 0x05
    d910:	84 83       	std	Z+4, r24	; 0x04
    d912:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		SetField(Temp, int32_t);
    d916:	89 81       	ldd	r24, Y+1	; 0x01
    d918:	9a 81       	ldd	r25, Y+2	; 0x02
    d91a:	ab 81       	ldd	r26, Y+3	; 0x03
    d91c:	bc 81       	ldd	r27, Y+4	; 0x04
    d91e:	ed b7       	in	r30, 0x3d	; 61
    d920:	fe b7       	in	r31, 0x3e	; 62
    d922:	36 96       	adiw	r30, 0x06	; 6
    d924:	0f b6       	in	r0, 0x3f	; 63
    d926:	f8 94       	cli
    d928:	fe bf       	out	0x3e, r31	; 62
    d92a:	0f be       	out	0x3f, r0	; 63
    d92c:	ed bf       	out	0x3d, r30	; 61
    d92e:	e8 16       	cp	r14, r24
    d930:	f9 06       	cpc	r15, r25
    d932:	0a 07       	cpc	r16, r26
    d934:	1b 07       	cpc	r17, r27
    d936:	38 f4       	brcc	.+14     	; 0xd946 <WebBuf2Field+0x4dc>
    d938:	d3 01       	movw	r26, r6
    d93a:	ed 92       	st	X+, r14
    d93c:	fd 92       	st	X+, r15
    d93e:	0d 93       	st	X+, r16
    d940:	1c 93       	st	X, r17
    d942:	13 97       	sbiw	r26, 0x03	; 3
    d944:	b7 c1       	rjmp	.+878    	; 0xdcb4 <WebBuf2Field+0x84a>
    d946:	8a 15       	cp	r24, r10
    d948:	9b 05       	cpc	r25, r11
    d94a:	ac 05       	cpc	r26, r12
    d94c:	bd 05       	cpc	r27, r13
    d94e:	30 f4       	brcc	.+12     	; 0xd95c <WebBuf2Field+0x4f2>
    d950:	f3 01       	movw	r30, r6
    d952:	a0 82       	st	Z, r10
    d954:	b1 82       	std	Z+1, r11	; 0x01
    d956:	c2 82       	std	Z+2, r12	; 0x02
    d958:	d3 82       	std	Z+3, r13	; 0x03
    d95a:	ac c1       	rjmp	.+856    	; 0xdcb4 <WebBuf2Field+0x84a>
    d95c:	f3 01       	movw	r30, r6
    d95e:	80 83       	st	Z, r24
    d960:	91 83       	std	Z+1, r25	; 0x01
    d962:	a2 83       	std	Z+2, r26	; 0x02
    d964:	b3 83       	std	Z+3, r27	; 0x03
    d966:	a6 c1       	rjmp	.+844    	; 0xdcb4 <WebBuf2Field+0x84a>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    d968:	89 85       	ldd	r24, Y+9	; 0x09
    d96a:	9a 85       	ldd	r25, Y+10	; 0x0a
    d96c:	0e 94 23 46 	call	0x8c46	; 0x8c46 <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    d970:	00 d0       	rcall	.+0      	; 0xd972 <WebBuf2Field+0x508>
    d972:	00 d0       	rcall	.+0      	; 0xd974 <WebBuf2Field+0x50a>
    d974:	00 d0       	rcall	.+0      	; 0xd976 <WebBuf2Field+0x50c>
    d976:	ed b7       	in	r30, 0x3d	; 61
    d978:	fe b7       	in	r31, 0x3e	; 62
    d97a:	31 96       	adiw	r30, 0x01	; 1
    d97c:	ad b7       	in	r26, 0x3d	; 61
    d97e:	be b7       	in	r27, 0x3e	; 62
    d980:	12 96       	adiw	r26, 0x02	; 2
    d982:	9c 92       	st	X, r9
    d984:	8e 92       	st	-X, r8
    d986:	11 97       	sbiw	r26, 0x01	; 1
    d988:	83 e0       	ldi	r24, 0x03	; 3
    d98a:	91 e0       	ldi	r25, 0x01	; 1
    d98c:	93 83       	std	Z+3, r25	; 0x03
    d98e:	82 83       	std	Z+2, r24	; 0x02
    d990:	ce 01       	movw	r24, r28
    d992:	01 96       	adiw	r24, 0x01	; 1
    d994:	95 83       	std	Z+5, r25	; 0x05
    d996:	84 83       	std	Z+4, r24	; 0x04
    d998:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    d99c:	ed b7       	in	r30, 0x3d	; 61
    d99e:	fe b7       	in	r31, 0x3e	; 62
    d9a0:	36 96       	adiw	r30, 0x06	; 6
    d9a2:	0f b6       	in	r0, 0x3f	; 63
    d9a4:	f8 94       	cli
    d9a6:	fe bf       	out	0x3e, r31	; 62
    d9a8:	0f be       	out	0x3f, r0	; 63
    d9aa:	ed bf       	out	0x3d, r30	; 61
    d9ac:	01 97       	sbiw	r24, 0x01	; 1
    d9ae:	09 f0       	breq	.+2      	; 0xd9b2 <WebBuf2Field+0x548>
    d9b0:	81 c1       	rjmp	.+770    	; 0xdcb4 <WebBuf2Field+0x84a>
			SetEEField(Temp, int32_t, uint32_t, d);
    d9b2:	49 81       	ldd	r20, Y+1	; 0x01
    d9b4:	5a 81       	ldd	r21, Y+2	; 0x02
    d9b6:	6b 81       	ldd	r22, Y+3	; 0x03
    d9b8:	7c 81       	ldd	r23, Y+4	; 0x04
    d9ba:	e4 16       	cp	r14, r20
    d9bc:	f5 06       	cpc	r15, r21
    d9be:	06 07       	cpc	r16, r22
    d9c0:	17 07       	cpc	r17, r23
    d9c2:	20 f4       	brcc	.+8      	; 0xd9cc <WebBuf2Field+0x562>
    d9c4:	c3 01       	movw	r24, r6
    d9c6:	b8 01       	movw	r22, r16
    d9c8:	a7 01       	movw	r20, r14
    d9ca:	0a c0       	rjmp	.+20     	; 0xd9e0 <WebBuf2Field+0x576>
    d9cc:	4a 15       	cp	r20, r10
    d9ce:	5b 05       	cpc	r21, r11
    d9d0:	6c 05       	cpc	r22, r12
    d9d2:	7d 05       	cpc	r23, r13
    d9d4:	20 f4       	brcc	.+8      	; 0xd9de <WebBuf2Field+0x574>
    d9d6:	c3 01       	movw	r24, r6
    d9d8:	b6 01       	movw	r22, r12
    d9da:	a5 01       	movw	r20, r10
    d9dc:	01 c0       	rjmp	.+2      	; 0xd9e0 <WebBuf2Field+0x576>
    d9de:	c3 01       	movw	r24, r6
    d9e0:	0e 94 e3 53 	call	0xa7c6	; 0xa7c6 <ewd>
    d9e4:	67 c1       	rjmp	.+718    	; 0xdcb4 <WebBuf2Field+0x84a>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    d9e6:	00 d0       	rcall	.+0      	; 0xd9e8 <WebBuf2Field+0x57e>
    d9e8:	00 d0       	rcall	.+0      	; 0xd9ea <WebBuf2Field+0x580>
    d9ea:	00 d0       	rcall	.+0      	; 0xd9ec <WebBuf2Field+0x582>
    d9ec:	ed b7       	in	r30, 0x3d	; 61
    d9ee:	fe b7       	in	r31, 0x3e	; 62
    d9f0:	31 96       	adiw	r30, 0x01	; 1
    d9f2:	ad b7       	in	r26, 0x3d	; 61
    d9f4:	be b7       	in	r27, 0x3e	; 62
    d9f6:	12 96       	adiw	r26, 0x02	; 2
    d9f8:	7c 93       	st	X, r23
    d9fa:	6e 93       	st	-X, r22
    d9fc:	11 97       	sbiw	r26, 0x01	; 1
    d9fe:	82 ea       	ldi	r24, 0xA2	; 162
    da00:	91 e0       	ldi	r25, 0x01	; 1
    da02:	93 83       	std	Z+3, r25	; 0x03
    da04:	82 83       	std	Z+2, r24	; 0x02
    da06:	ce 01       	movw	r24, r28
    da08:	05 96       	adiw	r24, 0x05	; 5
    da0a:	95 83       	std	Z+5, r25	; 0x05
    da0c:	84 83       	std	Z+4, r24	; 0x04
    da0e:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		*(float*)Var = fTemp;
    da12:	8d 81       	ldd	r24, Y+5	; 0x05
    da14:	9e 81       	ldd	r25, Y+6	; 0x06
    da16:	af 81       	ldd	r26, Y+7	; 0x07
    da18:	b8 85       	ldd	r27, Y+8	; 0x08
    da1a:	f3 01       	movw	r30, r6
    da1c:	80 83       	st	Z, r24
    da1e:	91 83       	std	Z+1, r25	; 0x01
    da20:	a2 83       	std	Z+2, r26	; 0x02
    da22:	b3 83       	std	Z+3, r27	; 0x03
    da24:	2d b7       	in	r18, 0x3d	; 61
    da26:	3e b7       	in	r19, 0x3e	; 62
    da28:	2a 5f       	subi	r18, 0xFA	; 250
    da2a:	3f 4f       	sbci	r19, 0xFF	; 255
    da2c:	0f b6       	in	r0, 0x3f	; 63
    da2e:	f8 94       	cli
    da30:	3e bf       	out	0x3e, r19	; 62
    da32:	0f be       	out	0x3f, r0	; 63
    da34:	2d bf       	out	0x3d, r18	; 61
    da36:	3e c1       	rjmp	.+636    	; 0xdcb4 <WebBuf2Field+0x84a>
		break;
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    da38:	00 d0       	rcall	.+0      	; 0xda3a <WebBuf2Field+0x5d0>
    da3a:	00 d0       	rcall	.+0      	; 0xda3c <WebBuf2Field+0x5d2>
    da3c:	00 d0       	rcall	.+0      	; 0xda3e <WebBuf2Field+0x5d4>
    da3e:	ed b7       	in	r30, 0x3d	; 61
    da40:	fe b7       	in	r31, 0x3e	; 62
    da42:	31 96       	adiw	r30, 0x01	; 1
    da44:	ad b7       	in	r26, 0x3d	; 61
    da46:	be b7       	in	r27, 0x3e	; 62
    da48:	12 96       	adiw	r26, 0x02	; 2
    da4a:	7c 93       	st	X, r23
    da4c:	6e 93       	st	-X, r22
    da4e:	11 97       	sbiw	r26, 0x01	; 1
    da50:	82 ea       	ldi	r24, 0xA2	; 162
    da52:	91 e0       	ldi	r25, 0x01	; 1
    da54:	93 83       	std	Z+3, r25	; 0x03
    da56:	82 83       	std	Z+2, r24	; 0x02
    da58:	8e 01       	movw	r16, r28
    da5a:	0b 5f       	subi	r16, 0xFB	; 251
    da5c:	1f 4f       	sbci	r17, 0xFF	; 255
    da5e:	15 83       	std	Z+5, r17	; 0x05
    da60:	04 83       	std	Z+4, r16	; 0x04
    da62:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
    da66:	ed b7       	in	r30, 0x3d	; 61
    da68:	fe b7       	in	r31, 0x3e	; 62
    da6a:	36 96       	adiw	r30, 0x06	; 6
    da6c:	0f b6       	in	r0, 0x3f	; 63
    da6e:	f8 94       	cli
    da70:	fe bf       	out	0x3e, r31	; 62
    da72:	0f be       	out	0x3f, r0	; 63
    da74:	ed bf       	out	0x3d, r30	; 61
    da76:	01 97       	sbiw	r24, 0x01	; 1
    da78:	09 f0       	breq	.+2      	; 0xda7c <WebBuf2Field+0x612>
    da7a:	1c c1       	rjmp	.+568    	; 0xdcb4 <WebBuf2Field+0x84a>
			ewbl(&fTemp, (float*)Var, 4);
    da7c:	c8 01       	movw	r24, r16
    da7e:	b3 01       	movw	r22, r6
    da80:	44 e0       	ldi	r20, 0x04	; 4
    da82:	50 e0       	ldi	r21, 0x00	; 0
    da84:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
    da88:	15 c1       	rjmp	.+554    	; 0xdcb4 <WebBuf2Field+0x84a>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    da8a:	20 91 5e 03 	lds	r18, 0x035E
    da8e:	30 91 5f 03 	lds	r19, 0x035F
    da92:	40 91 60 03 	lds	r20, 0x0360
    da96:	50 91 61 03 	lds	r21, 0x0361
    da9a:	8e 2d       	mov	r24, r14
    da9c:	90 e0       	ldi	r25, 0x00	; 0
    da9e:	a0 e0       	ldi	r26, 0x00	; 0
    daa0:	b0 e0       	ldi	r27, 0x00	; 0
    daa2:	82 17       	cp	r24, r18
    daa4:	93 07       	cpc	r25, r19
    daa6:	a4 07       	cpc	r26, r20
    daa8:	b5 07       	cpc	r27, r21
    daaa:	18 f4       	brcc	.+6      	; 0xdab2 <WebBuf2Field+0x648>
    daac:	d3 01       	movw	r26, r6
    daae:	ec 92       	st	X, r14
    dab0:	01 c1       	rjmp	.+514    	; 0xdcb4 <WebBuf2Field+0x84a>
    dab2:	8a 2d       	mov	r24, r10
    dab4:	90 e0       	ldi	r25, 0x00	; 0
    dab6:	a0 e0       	ldi	r26, 0x00	; 0
    dab8:	b0 e0       	ldi	r27, 0x00	; 0
    daba:	28 17       	cp	r18, r24
    dabc:	39 07       	cpc	r19, r25
    dabe:	4a 07       	cpc	r20, r26
    dac0:	5b 07       	cpc	r21, r27
    dac2:	18 f4       	brcc	.+6      	; 0xdaca <WebBuf2Field+0x660>
    dac4:	f3 01       	movw	r30, r6
    dac6:	a0 82       	st	Z, r10
    dac8:	f5 c0       	rjmp	.+490    	; 0xdcb4 <WebBuf2Field+0x84a>
    daca:	d3 01       	movw	r26, r6
    dacc:	48 c0       	rjmp	.+144    	; 0xdb5e <WebBuf2Field+0x6f4>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    dace:	20 91 5e 03 	lds	r18, 0x035E
    dad2:	30 91 5f 03 	lds	r19, 0x035F
    dad6:	40 91 60 03 	lds	r20, 0x0360
    dada:	50 91 61 03 	lds	r21, 0x0361
    dade:	8e 2d       	mov	r24, r14
    dae0:	90 e0       	ldi	r25, 0x00	; 0
    dae2:	a0 e0       	ldi	r26, 0x00	; 0
    dae4:	b0 e0       	ldi	r27, 0x00	; 0
    dae6:	82 17       	cp	r24, r18
    dae8:	93 07       	cpc	r25, r19
    daea:	a4 07       	cpc	r26, r20
    daec:	b5 07       	cpc	r27, r21
    daee:	18 f4       	brcc	.+6      	; 0xdaf6 <WebBuf2Field+0x68c>
    daf0:	c3 01       	movw	r24, r6
    daf2:	6e 2d       	mov	r22, r14
    daf4:	68 c0       	rjmp	.+208    	; 0xdbc6 <WebBuf2Field+0x75c>
    daf6:	8a 2d       	mov	r24, r10
    daf8:	90 e0       	ldi	r25, 0x00	; 0
    dafa:	a0 e0       	ldi	r26, 0x00	; 0
    dafc:	b0 e0       	ldi	r27, 0x00	; 0
    dafe:	28 17       	cp	r18, r24
    db00:	39 07       	cpc	r19, r25
    db02:	4a 07       	cpc	r20, r26
    db04:	5b 07       	cpc	r21, r27
    db06:	18 f4       	brcc	.+6      	; 0xdb0e <WebBuf2Field+0x6a4>
    db08:	c3 01       	movw	r24, r6
    db0a:	6a 2d       	mov	r22, r10
    db0c:	5c c0       	rjmp	.+184    	; 0xdbc6 <WebBuf2Field+0x75c>
    db0e:	c3 01       	movw	r24, r6
    db10:	62 2f       	mov	r22, r18
    db12:	59 c0       	rjmp	.+178    	; 0xdbc6 <WebBuf2Field+0x75c>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    db14:	00 d0       	rcall	.+0      	; 0xdb16 <WebBuf2Field+0x6ac>
    db16:	00 d0       	rcall	.+0      	; 0xdb18 <WebBuf2Field+0x6ae>
    db18:	00 d0       	rcall	.+0      	; 0xdb1a <WebBuf2Field+0x6b0>
    db1a:	ed b7       	in	r30, 0x3d	; 61
    db1c:	fe b7       	in	r31, 0x3e	; 62
    db1e:	31 96       	adiw	r30, 0x01	; 1
    db20:	ad b7       	in	r26, 0x3d	; 61
    db22:	be b7       	in	r27, 0x3e	; 62
    db24:	12 96       	adiw	r26, 0x02	; 2
    db26:	7c 93       	st	X, r23
    db28:	6e 93       	st	-X, r22
    db2a:	11 97       	sbiw	r26, 0x01	; 1
    db2c:	8d e8       	ldi	r24, 0x8D	; 141
    db2e:	91 e0       	ldi	r25, 0x01	; 1
    db30:	93 83       	std	Z+3, r25	; 0x03
    db32:	82 83       	std	Z+2, r24	; 0x02
    db34:	ce 01       	movw	r24, r28
    db36:	01 96       	adiw	r24, 0x01	; 1
    db38:	95 83       	std	Z+5, r25	; 0x05
    db3a:	84 83       	std	Z+4, r24	; 0x04
    db3c:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
		if((unsigned short int)Temp)
    db40:	ed b7       	in	r30, 0x3d	; 61
    db42:	fe b7       	in	r31, 0x3e	; 62
    db44:	36 96       	adiw	r30, 0x06	; 6
    db46:	0f b6       	in	r0, 0x3f	; 63
    db48:	f8 94       	cli
    db4a:	fe bf       	out	0x3e, r31	; 62
    db4c:	0f be       	out	0x3f, r0	; 63
    db4e:	ed bf       	out	0x3d, r30	; 61
    db50:	89 81       	ldd	r24, Y+1	; 0x01
    db52:	9a 81       	ldd	r25, Y+2	; 0x02
    db54:	d2 01       	movw	r26, r4
    db56:	2c 91       	ld	r18, X
    db58:	89 2b       	or	r24, r25
    db5a:	19 f0       	breq	.+6      	; 0xdb62 <WebBuf2Field+0x6f8>
			*BitVar |=Mask;
    db5c:	23 29       	or	r18, r3
    db5e:	2c 93       	st	X, r18
    db60:	a9 c0       	rjmp	.+338    	; 0xdcb4 <WebBuf2Field+0x84a>
		else
			*BitVar &=~Mask;
    db62:	30 94       	com	r3
    db64:	23 21       	and	r18, r3
    db66:	f2 01       	movw	r30, r4
    db68:	20 83       	st	Z, r18
    db6a:	a4 c0       	rjmp	.+328    	; 0xdcb4 <WebBuf2Field+0x84a>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    db6c:	00 d0       	rcall	.+0      	; 0xdb6e <WebBuf2Field+0x704>
    db6e:	00 d0       	rcall	.+0      	; 0xdb70 <WebBuf2Field+0x706>
    db70:	00 d0       	rcall	.+0      	; 0xdb72 <WebBuf2Field+0x708>
    db72:	ed b7       	in	r30, 0x3d	; 61
    db74:	fe b7       	in	r31, 0x3e	; 62
    db76:	31 96       	adiw	r30, 0x01	; 1
    db78:	ad b7       	in	r26, 0x3d	; 61
    db7a:	be b7       	in	r27, 0x3e	; 62
    db7c:	12 96       	adiw	r26, 0x02	; 2
    db7e:	7c 93       	st	X, r23
    db80:	6e 93       	st	-X, r22
    db82:	11 97       	sbiw	r26, 0x01	; 1
    db84:	8d e8       	ldi	r24, 0x8D	; 141
    db86:	91 e0       	ldi	r25, 0x01	; 1
    db88:	93 83       	std	Z+3, r25	; 0x03
    db8a:	82 83       	std	Z+2, r24	; 0x02
    db8c:	ce 01       	movw	r24, r28
    db8e:	01 96       	adiw	r24, 0x01	; 1
    db90:	95 83       	std	Z+5, r25	; 0x05
    db92:	84 83       	std	Z+4, r24	; 0x04
    db94:	0e 94 8f 88 	call	0x1111e	; 0x1111e <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    db98:	ed b7       	in	r30, 0x3d	; 61
    db9a:	fe b7       	in	r31, 0x3e	; 62
    db9c:	36 96       	adiw	r30, 0x06	; 6
    db9e:	0f b6       	in	r0, 0x3f	; 63
    dba0:	f8 94       	cli
    dba2:	fe bf       	out	0x3e, r31	; 62
    dba4:	0f be       	out	0x3f, r0	; 63
    dba6:	ed bf       	out	0x3d, r30	; 61
    dba8:	c2 01       	movw	r24, r4
    dbaa:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    dbae:	28 2f       	mov	r18, r24
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    dbb0:	89 81       	ldd	r24, Y+1	; 0x01
    dbb2:	9a 81       	ldd	r25, Y+2	; 0x02
    dbb4:	89 2b       	or	r24, r25
    dbb6:	19 f0       	breq	.+6      	; 0xdbbe <WebBuf2Field+0x754>
    dbb8:	63 2d       	mov	r22, r3
    dbba:	62 2b       	or	r22, r18
    dbbc:	03 c0       	rjmp	.+6      	; 0xdbc4 <WebBuf2Field+0x75a>
    dbbe:	63 2d       	mov	r22, r3
    dbc0:	60 95       	com	r22
    dbc2:	62 23       	and	r22, r18
    dbc4:	c2 01       	movw	r24, r4
    dbc6:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
    dbca:	74 c0       	rjmp	.+232    	; 0xdcb4 <WebBuf2Field+0x84a>
		break;
    dbcc:	1d b7       	in	r17, 0x3d	; 61
    dbce:	0e b7       	in	r16, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    dbd0:	fa 01       	movw	r30, r20
    dbd2:	84 91       	lpm	r24, Z+


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    dbd4:	90 e0       	ldi	r25, 0x00	; 0
    dbd6:	2d b7       	in	r18, 0x3d	; 61
    dbd8:	3e b7       	in	r19, 0x3e	; 62
    dbda:	28 1b       	sub	r18, r24
    dbdc:	39 0b       	sbc	r19, r25
    dbde:	0f b6       	in	r0, 0x3f	; 63
    dbe0:	f8 94       	cli
    dbe2:	3e bf       	out	0x3e, r19	; 62
    dbe4:	0f be       	out	0x3f, r0	; 63
    dbe6:	2d bf       	out	0x3d, r18	; 61
    dbe8:	4d b7       	in	r20, 0x3d	; 61
    dbea:	5e b7       	in	r21, 0x3e	; 62
    dbec:	4f 5f       	subi	r20, 0xFF	; 255
    dbee:	5f 4f       	sbci	r21, 0xFF	; 255
    dbf0:	60 e0       	ldi	r22, 0x00	; 0
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    dbf2:	01 97       	sbiw	r24, 0x01	; 1
			if(BufStr[i] == '+') TempStr[i]=' ';
    dbf4:	70 e2       	ldi	r23, 0x20	; 32
    dbf6:	09 c0       	rjmp	.+18     	; 0xdc0a <WebBuf2Field+0x7a0>
    dbf8:	da 01       	movw	r26, r20
    dbfa:	a2 0f       	add	r26, r18
    dbfc:	b3 1f       	adc	r27, r19
    dbfe:	eb 32       	cpi	r30, 0x2B	; 43
    dc00:	11 f4       	brne	.+4      	; 0xdc06 <WebBuf2Field+0x79c>
    dc02:	7c 93       	st	X, r23
    dc04:	01 c0       	rjmp	.+2      	; 0xdc08 <WebBuf2Field+0x79e>
			else TempStr[i]=BufStr[i];
    dc06:	ec 93       	st	X, r30
			i++;
    dc08:	6f 5f       	subi	r22, 0xFF	; 255
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    dc0a:	26 2f       	mov	r18, r22
    dc0c:	30 e0       	ldi	r19, 0x00	; 0
    dc0e:	28 17       	cp	r18, r24
    dc10:	39 07       	cpc	r19, r25
    dc12:	44 f4       	brge	.+16     	; 0xdc24 <WebBuf2Field+0x7ba>
    dc14:	f4 01       	movw	r30, r8
    dc16:	e2 0f       	add	r30, r18
    dc18:	f3 1f       	adc	r31, r19
    dc1a:	e0 81       	ld	r30, Z
    dc1c:	e0 32       	cpi	r30, 0x20	; 32
    dc1e:	11 f0       	breq	.+4      	; 0xdc24 <WebBuf2Field+0x7ba>
    dc20:	e6 32       	cpi	r30, 0x26	; 38
    dc22:	51 f7       	brne	.-44     	; 0xdbf8 <WebBuf2Field+0x78e>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    dc24:	fa 01       	movw	r30, r20
    dc26:	e2 0f       	add	r30, r18
    dc28:	f3 1f       	adc	r31, r19
    dc2a:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    dc2c:	2f 5f       	subi	r18, 0xFF	; 255
    dc2e:	3f 4f       	sbci	r19, 0xFF	; 255
    dc30:	c3 01       	movw	r24, r6
    dc32:	ba 01       	movw	r22, r20
    dc34:	a9 01       	movw	r20, r18
    dc36:	0e 94 fb 87 	call	0x10ff6	; 0x10ff6 <memcpy>
    dc3a:	34 c0       	rjmp	.+104    	; 0xdca4 <WebBuf2Field+0x83a>
		}


		break;
    dc3c:	1d b7       	in	r17, 0x3d	; 61
    dc3e:	0e b7       	in	r16, 0x3e	; 62
    dc40:	fa 01       	movw	r30, r20
    dc42:	84 91       	lpm	r24, Z+
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    dc44:	90 e0       	ldi	r25, 0x00	; 0
    dc46:	2d b7       	in	r18, 0x3d	; 61
    dc48:	3e b7       	in	r19, 0x3e	; 62
    dc4a:	28 1b       	sub	r18, r24
    dc4c:	39 0b       	sbc	r19, r25
    dc4e:	0f b6       	in	r0, 0x3f	; 63
    dc50:	f8 94       	cli
    dc52:	3e bf       	out	0x3e, r19	; 62
    dc54:	0f be       	out	0x3f, r0	; 63
    dc56:	2d bf       	out	0x3d, r18	; 61
    dc58:	2f 5f       	subi	r18, 0xFF	; 255
    dc5a:	3f 4f       	sbci	r19, 0xFF	; 255
    dc5c:	60 e0       	ldi	r22, 0x00	; 0
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    dc5e:	01 97       	sbiw	r24, 0x01	; 1
			if(BufStr[i] == '+') TempStr[i]=' ';
    dc60:	70 e2       	ldi	r23, 0x20	; 32
    dc62:	09 c0       	rjmp	.+18     	; 0xdc76 <WebBuf2Field+0x80c>
    dc64:	d9 01       	movw	r26, r18
    dc66:	a4 0f       	add	r26, r20
    dc68:	b5 1f       	adc	r27, r21
    dc6a:	eb 32       	cpi	r30, 0x2B	; 43
    dc6c:	11 f4       	brne	.+4      	; 0xdc72 <WebBuf2Field+0x808>
    dc6e:	7c 93       	st	X, r23
    dc70:	01 c0       	rjmp	.+2      	; 0xdc74 <WebBuf2Field+0x80a>
			else TempStr[i]=BufStr[i];
    dc72:	ec 93       	st	X, r30
			i++;
    dc74:	6f 5f       	subi	r22, 0xFF	; 255
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    dc76:	46 2f       	mov	r20, r22
    dc78:	50 e0       	ldi	r21, 0x00	; 0
    dc7a:	48 17       	cp	r20, r24
    dc7c:	59 07       	cpc	r21, r25
    dc7e:	44 f4       	brge	.+16     	; 0xdc90 <WebBuf2Field+0x826>
    dc80:	f4 01       	movw	r30, r8
    dc82:	e4 0f       	add	r30, r20
    dc84:	f5 1f       	adc	r31, r21
    dc86:	e0 81       	ld	r30, Z
    dc88:	e0 32       	cpi	r30, 0x20	; 32
    dc8a:	11 f0       	breq	.+4      	; 0xdc90 <WebBuf2Field+0x826>
    dc8c:	e6 32       	cpi	r30, 0x26	; 38
    dc8e:	51 f7       	brne	.-44     	; 0xdc64 <WebBuf2Field+0x7fa>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    dc90:	f9 01       	movw	r30, r18
    dc92:	e4 0f       	add	r30, r20
    dc94:	f5 1f       	adc	r31, r21
    dc96:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    dc98:	4f 5f       	subi	r20, 0xFF	; 255
    dc9a:	5f 4f       	sbci	r21, 0xFF	; 255
    dc9c:	c9 01       	movw	r24, r18
    dc9e:	b3 01       	movw	r22, r6
    dca0:	0e 94 ad 53 	call	0xa75a	; 0xa75a <ewbl>
    dca4:	21 2f       	mov	r18, r17
    dca6:	30 2f       	mov	r19, r16
    dca8:	c9 01       	movw	r24, r18
    dcaa:	0f b6       	in	r0, 0x3f	; 63
    dcac:	f8 94       	cli
    dcae:	9e bf       	out	0x3e, r25	; 62
    dcb0:	0f be       	out	0x3f, r0	; 63
    dcb2:	8d bf       	out	0x3d, r24	; 61

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    dcb4:	e9 85       	ldd	r30, Y+9	; 0x09
    dcb6:	fa 85       	ldd	r31, Y+10	; 0x0a
    dcb8:	3b 96       	adiw	r30, 0x0b	; 11
    dcba:	85 91       	lpm	r24, Z+
    dcbc:	94 91       	lpm	r25, Z+
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    dcbe:	00 97       	sbiw	r24, 0x00	; 0
    dcc0:	11 f0       	breq	.+4      	; 0xdcc6 <WebBuf2Field+0x85c>
		Func();
    dcc2:	fc 01       	movw	r30, r24
    dcc4:	09 95       	icall
		}
		break;
	}

	EventFunc(&Field->Act);
}
    dcc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    dcc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    dcca:	0f b6       	in	r0, 0x3f	; 63
    dccc:	f8 94       	cli
    dcce:	7e bf       	out	0x3e, r23	; 62
    dcd0:	0f be       	out	0x3f, r0	; 63
    dcd2:	6d bf       	out	0x3d, r22	; 61
    dcd4:	2c 96       	adiw	r28, 0x0c	; 12
    dcd6:	0f b6       	in	r0, 0x3f	; 63
    dcd8:	f8 94       	cli
    dcda:	de bf       	out	0x3e, r29	; 62
    dcdc:	0f be       	out	0x3f, r0	; 63
    dcde:	cd bf       	out	0x3d, r28	; 61
    dce0:	cf 91       	pop	r28
    dce2:	df 91       	pop	r29
    dce4:	1f 91       	pop	r17
    dce6:	0f 91       	pop	r16
    dce8:	ff 90       	pop	r15
    dcea:	ef 90       	pop	r14
    dcec:	df 90       	pop	r13
    dcee:	cf 90       	pop	r12
    dcf0:	bf 90       	pop	r11
    dcf2:	af 90       	pop	r10
    dcf4:	9f 90       	pop	r9
    dcf6:	8f 90       	pop	r8
    dcf8:	7f 90       	pop	r7
    dcfa:	6f 90       	pop	r6
    dcfc:	5f 90       	pop	r5
    dcfe:	4f 90       	pop	r4
    dd00:	3f 90       	pop	r3
    dd02:	08 95       	ret

0000dd04 <WebRequest>:


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    dd04:	2f 92       	push	r2
    dd06:	3f 92       	push	r3
    dd08:	4f 92       	push	r4
    dd0a:	5f 92       	push	r5
    dd0c:	6f 92       	push	r6
    dd0e:	7f 92       	push	r7
    dd10:	8f 92       	push	r8
    dd12:	9f 92       	push	r9
    dd14:	af 92       	push	r10
    dd16:	bf 92       	push	r11
    dd18:	cf 92       	push	r12
    dd1a:	df 92       	push	r13
    dd1c:	ef 92       	push	r14
    dd1e:	ff 92       	push	r15
    dd20:	0f 93       	push	r16
    dd22:	1f 93       	push	r17
    dd24:	df 93       	push	r29
    dd26:	cf 93       	push	r28
    dd28:	cd b7       	in	r28, 0x3d	; 61
    dd2a:	de b7       	in	r29, 0x3e	; 62
    dd2c:	2b 97       	sbiw	r28, 0x0b	; 11
    dd2e:	0f b6       	in	r0, 0x3f	; 63
    dd30:	f8 94       	cli
    dd32:	de bf       	out	0x3e, r29	; 62
    dd34:	0f be       	out	0x3f, r0	; 63
    dd36:	cd bf       	out	0x3d, r28	; 61
    dd38:	1c 01       	movw	r2, r24
    dd3a:	6d 83       	std	Y+5, r22	; 0x05
	

	WebStrLen = GetStringFromFIFO();
    dd3c:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    dd40:	80 93 ed 07 	sts	0x07ED, r24

	if(Web_POST==2){ 
    dd44:	80 91 da 08 	lds	r24, 0x08DA
    dd48:	82 30       	cpi	r24, 0x02	; 2
    dd4a:	19 f5       	brne	.+70     	; 0xdd92 <WebRequest+0x8e>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    dd4c:	80 91 b2 08 	lds	r24, 0x08B2
    dd50:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
    dd54:	88 23       	and	r24, r24
    dd56:	b1 f0       	breq	.+44     	; 0xdd84 <WebRequest+0x80>
}
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    dd58:	80 91 ac 0c 	lds	r24, 0x0CAC
    dd5c:	84 36       	cpi	r24, 0x64	; 100
    dd5e:	18 f0       	brcs	.+6      	; 0xdd66 <WebRequest+0x62>
    dd60:	83 e6       	ldi	r24, 0x63	; 99
    dd62:	80 93 ac 0c 	sts	0x0CAC, r24
	StrLength = GSM_RxCharN;
    dd66:	80 91 ac 0c 	lds	r24, 0x0CAC
	GSM_RxStr[GSM_RxCharN]='\0';
    dd6a:	e0 91 ac 0c 	lds	r30, 0x0CAC
    dd6e:	f0 e0       	ldi	r31, 0x00	; 0
    dd70:	ec 50       	subi	r30, 0x0C	; 12
    dd72:	f7 4f       	sbci	r31, 0xF7	; 247
    dd74:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    dd76:	10 92 ac 0c 	sts	0x0CAC, r1
			WebStrLen = ForceEndStringFromFIFO();
    dd7a:	80 93 ed 07 	sts	0x07ED, r24
			Web_POST=3;	
    dd7e:	83 e0       	ldi	r24, 0x03	; 3
    dd80:	80 93 da 08 	sts	0x08DA, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    dd84:	80 91 ed 07 	lds	r24, 0x07ED
    dd88:	88 23       	and	r24, r24
    dd8a:	19 f0       	breq	.+6      	; 0xdd92 <WebRequest+0x8e>
    dd8c:	83 e0       	ldi	r24, 0x03	; 3
    dd8e:	80 93 da 08 	sts	0x08DA, r24
	}

	//  
	if(WebStrLen){
    dd92:	10 91 ed 07 	lds	r17, 0x07ED
    dd96:	11 23       	and	r17, r17
    dd98:	09 f4       	brne	.+2      	; 0xdd9c <WebRequest+0x98>
    dd9a:	ae c1       	rjmp	.+860    	; 0xe0f8 <WebRequest+0x3f4>
    dd9c:	61 01       	movw	r12, r2
    dd9e:	f1 01       	movw	r30, r2
    dda0:	e5 90       	lpm	r14, Z+
    dda2:	f4 90       	lpm	r15, Z+
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    dda4:	84 ef       	ldi	r24, 0xF4	; 244
    dda6:	98 e0       	ldi	r25, 0x08	; 8
    dda8:	6a ee       	ldi	r22, 0xEA	; 234
    ddaa:	76 e0       	ldi	r23, 0x06	; 6
    ddac:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    ddb0:	89 2b       	or	r24, r25
    ddb2:	21 f0       	breq	.+8      	; 0xddbc <WebRequest+0xb8>
			Web_POST = 1; 
    ddb4:	81 e0       	ldi	r24, 0x01	; 1
    ddb6:	80 93 da 08 	sts	0x08DA, r24
    ddba:	9e c1       	rjmp	.+828    	; 0xe0f8 <WebRequest+0x3f4>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    ddbc:	80 91 da 08 	lds	r24, 0x08DA
    ddc0:	81 30       	cpi	r24, 0x01	; 1
    ddc2:	61 f4       	brne	.+24     	; 0xdddc <WebRequest+0xd8>
    ddc4:	11 30       	cpi	r17, 0x01	; 1
    ddc6:	09 f0       	breq	.+2      	; 0xddca <WebRequest+0xc6>
    ddc8:	92 c0       	rjmp	.+292    	; 0xdeee <WebRequest+0x1ea>
			Web_POST = 2;
    ddca:	82 e0       	ldi	r24, 0x02	; 2
    ddcc:	80 93 da 08 	sts	0x08DA, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    ddd0:	80 91 b2 08 	lds	r24, 0x08B2
    ddd4:	64 e6       	ldi	r22, 0x64	; 100
    ddd6:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
    ddda:	8e c1       	rjmp	.+796    	; 0xe0f8 <WebRequest+0x3f4>
			return NULL;
		}
		if(Web_POST==3){	//  
    dddc:	83 30       	cpi	r24, 0x03	; 3
    ddde:	09 f0       	breq	.+2      	; 0xdde2 <WebRequest+0xde>
    dde0:	86 c0       	rjmp	.+268    	; 0xdeee <WebRequest+0x1ea>
			Web_POST = 0;
    dde2:	10 92 da 08 	sts	0x08DA, r1
    dde6:	14 ef       	ldi	r17, 0xF4	; 244
    dde8:	81 2e       	mov	r8, r17
    ddea:	18 e0       	ldi	r17, 0x08	; 8
    ddec:	91 2e       	mov	r9, r17
    ddee:	08 ed       	ldi	r16, 0xD8	; 216
    ddf0:	16 e0       	ldi	r17, 0x06	; 6
    ddf2:	22 e0       	ldi	r18, 0x02	; 2
    ddf4:	30 e0       	ldi	r19, 0x00	; 0
    ddf6:	22 0e       	add	r2, r18
    ddf8:	33 1e       	adc	r3, r19
    ddfa:	f1 01       	movw	r30, r2
    ddfc:	c5 90       	lpm	r12, Z+
    ddfe:	d4 90       	lpm	r13, Z+
    de00:	8e ef       	ldi	r24, 0xFE	; 254
    de02:	9f ef       	ldi	r25, 0xFF	; 255
    de04:	28 0e       	add	r2, r24
    de06:	39 1e       	adc	r3, r25

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    de08:	f6 01       	movw	r30, r12
    de0a:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    de0c:	a6 e0       	ldi	r26, 0x06	; 6
    de0e:	b0 e0       	ldi	r27, 0x00	; 0
    de10:	ca 0e       	add	r12, r26
    de12:	db 1e       	adc	r13, r27

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    de14:	65 90       	lpm	r6, Z+
    de16:	74 90       	lpm	r7, Z+
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    de18:	76 94       	lsr	r7
    de1a:	67 94       	ror	r6
    de1c:	76 94       	lsr	r7
    de1e:	67 94       	ror	r6

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    de20:	f6 01       	movw	r30, r12
    de22:	25 91       	lpm	r18, Z+
    de24:	34 91       	lpm	r19, Z+
    de26:	3f 83       	std	Y+7, r19	; 0x07
    de28:	2e 83       	std	Y+6, r18	; 0x06
    de2a:	8a ef       	ldi	r24, 0xFA	; 250
    de2c:	9f ef       	ldi	r25, 0xFF	; 255
    de2e:	c8 0e       	add	r12, r24
    de30:	d9 1e       	adc	r13, r25
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    de32:	c4 01       	movw	r24, r8
    de34:	6d e3       	ldi	r22, 0x3D	; 61
    de36:	70 e0       	ldi	r23, 0x00	; 0
    de38:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    de3c:	2c 01       	movw	r4, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) return &Web_login;
    de3e:	00 97       	sbiw	r24, 0x00	; 0
    de40:	09 f4       	brne	.+2      	; 0xde44 <WebRequest+0x140>
    de42:	55 c1       	rjmp	.+682    	; 0xe0ee <WebRequest+0x3ea>
				nextvar=strchr(url+1,'&');
    de44:	c4 01       	movw	r24, r8
    de46:	01 96       	adiw	r24, 0x01	; 1
    de48:	66 e2       	ldi	r22, 0x26	; 38
    de4a:	70 e0       	ldi	r23, 0x00	; 0
    de4c:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    de50:	7c 01       	movw	r14, r24
				varfield = p + 1;
    de52:	52 01       	movw	r10, r4
    de54:	08 94       	sec
    de56:	a1 1c       	adc	r10, r1
    de58:	b1 1c       	adc	r11, r1
				*p = '\0';
    de5a:	d2 01       	movw	r26, r4
    de5c:	1c 92       	st	X, r1
    de5e:	55 24       	eor	r5, r5
    de60:	27 c0       	rjmp	.+78     	; 0xdeb0 <WebRequest+0x1ac>
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    de62:	ee 81       	ldd	r30, Y+6	; 0x06
    de64:	ff 81       	ldd	r31, Y+7	; 0x07
    de66:	30 97       	sbiw	r30, 0x00	; 0
    de68:	11 f1       	breq	.+68     	; 0xdeae <WebRequest+0x1aa>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    de6a:	9c 01       	movw	r18, r24
    de6c:	22 0f       	add	r18, r18
    de6e:	33 1f       	adc	r19, r19
    de70:	22 0f       	add	r18, r18
    de72:	33 1f       	adc	r19, r19
    de74:	2e 0f       	add	r18, r30
    de76:	3f 1f       	adc	r19, r31
    de78:	3b 87       	std	Y+11, r19	; 0x0b
    de7a:	2a 87       	std	Y+10, r18	; 0x0a
    de7c:	f9 01       	movw	r30, r18
    de7e:	65 91       	lpm	r22, Z+
    de80:	74 91       	lpm	r23, Z+
    de82:	c4 01       	movw	r24, r8
    de84:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    de88:	89 2b       	or	r24, r25
    de8a:	21 f0       	breq	.+8      	; 0xde94 <WebRequest+0x190>
    de8c:	10 c0       	rjmp	.+32     	; 0xdeae <WebRequest+0x1aa>
								while(*varfield=='+') varfield++;	// ignore leading '+'
    de8e:	08 94       	sec
    de90:	a1 1c       	adc	r10, r1
    de92:	b1 1c       	adc	r11, r1
    de94:	d5 01       	movw	r26, r10
    de96:	8c 91       	ld	r24, X
    de98:	8b 32       	cpi	r24, 0x2B	; 43
    de9a:	c9 f3       	breq	.-14     	; 0xde8e <WebRequest+0x18a>
    de9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    de9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    dea0:	32 96       	adiw	r30, 0x02	; 2
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    dea2:	85 91       	lpm	r24, Z+
    dea4:	94 91       	lpm	r25, Z+
    dea6:	b5 01       	movw	r22, r10
    dea8:	0e 94 35 6a 	call	0xd46a	; 0xd46a <WebBuf2Field>
    deac:	86 01       	movw	r16, r12
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    deae:	53 94       	inc	r5
    deb0:	85 2d       	mov	r24, r5
    deb2:	90 e0       	ldi	r25, 0x00	; 0
    deb4:	86 15       	cp	r24, r6
    deb6:	97 05       	cpc	r25, r7
    deb8:	a0 f2       	brcs	.-88     	; 0xde62 <WebRequest+0x15e>
							}
						}
					}
				//}
				url = nextvar+1;
			}while(nextvar);	//     
    deba:	e1 14       	cp	r14, r1
    debc:	f1 04       	cpc	r15, r1
    debe:	29 f0       	breq	.+10     	; 0xdeca <WebRequest+0x1c6>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    dec0:	47 01       	movw	r8, r14
    dec2:	08 94       	sec
    dec4:	81 1c       	adc	r8, r1
    dec6:	91 1c       	adc	r9, r1
    dec8:	b4 cf       	rjmp	.-152    	; 0xde32 <WebRequest+0x12e>
			}while(nextvar);	//     

			if(Web_LoginAttempt){
    deca:	80 91 b7 07 	lds	r24, 0x07B7
    dece:	88 23       	and	r24, r24
    ded0:	09 f4       	brne	.+2      	; 0xded4 <WebRequest+0x1d0>
    ded2:	14 c1       	rjmp	.+552    	; 0xe0fc <WebRequest+0x3f8>
				Web_LoginAttempt = 0;
    ded4:	10 92 b7 07 	sts	0x07B7, r1
				Web_Login_Code = Web_Login_Error();
    ded8:	0e 94 8b 69 	call	0xd316	; 0xd316 <Web_Login_Error>
    dedc:	80 93 87 05 	sts	0x0587, r24
				if(!Web_Login_Code) return prp(ptrSite);
    dee0:	88 23       	and	r24, r24
    dee2:	09 f0       	breq	.+2      	; 0xdee6 <WebRequest+0x1e2>
    dee4:	0b c1       	rjmp	.+534    	; 0xe0fc <WebRequest+0x3f8>
    dee6:	f1 01       	movw	r30, r2
    dee8:	05 91       	lpm	r16, Z+
    deea:	14 91       	lpm	r17, Z+
    deec:	07 c1       	rjmp	.+526    	; 0xe0fc <WebRequest+0x3f8>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    deee:	84 ef       	ldi	r24, 0xF4	; 244
    def0:	98 e0       	ldi	r25, 0x08	; 8
    def2:	64 ee       	ldi	r22, 0xE4	; 228
    def4:	76 e0       	ldi	r23, 0x06	; 6
    def6:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    defa:	89 2b       	or	r24, r25
    defc:	09 f4       	brne	.+2      	; 0xdf00 <WebRequest+0x1fc>
    defe:	fc c0       	rjmp	.+504    	; 0xe0f8 <WebRequest+0x3f4>
    df00:	88 ef       	ldi	r24, 0xF8	; 248
    df02:	98 e0       	ldi	r25, 0x08	; 8
    df04:	60 e2       	ldi	r22, 0x20	; 32
    df06:	70 e0       	ldi	r23, 0x00	; 0
    df08:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    df0c:	fc 01       	movw	r30, r24
    df0e:	00 97       	sbiw	r24, 0x00	; 0
    df10:	09 f4       	brne	.+2      	; 0xdf14 <WebRequest+0x210>
    df12:	f2 c0       	rjmp	.+484    	; 0xe0f8 <WebRequest+0x3f4>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    df14:	10 82       	st	Z, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    df16:	89 ef       	ldi	r24, 0xF9	; 249
    df18:	98 e0       	ldi	r25, 0x08	; 8
    df1a:	60 eb       	ldi	r22, 0xB0	; 176
    df1c:	76 e1       	ldi	r23, 0x16	; 22
    df1e:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    df22:	89 2b       	or	r24, r25
    df24:	19 f4       	brne	.+6      	; 0xdf2c <WebRequest+0x228>
    df26:	0a e3       	ldi	r16, 0x3A	; 58
    df28:	1c e1       	ldi	r17, 0x1C	; 28
    df2a:	e8 c0       	rjmp	.+464    	; 0xe0fc <WebRequest+0x3f8>
			url = strchr(url,'?');
    df2c:	88 ef       	ldi	r24, 0xF8	; 248
    df2e:	98 e0       	ldi	r25, 0x08	; 8
    df30:	6f e3       	ldi	r22, 0x3F	; 63
    df32:	70 e0       	ldi	r23, 0x00	; 0
    df34:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    df38:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    df3a:	80 91 e9 08 	lds	r24, 0x08E9
    df3e:	88 23       	and	r24, r24
    df40:	09 f4       	brne	.+2      	; 0xdf44 <WebRequest+0x240>
    df42:	d5 c0       	rjmp	.+426    	; 0xe0ee <WebRequest+0x3ea>
    df44:	01 15       	cp	r16, r1
    df46:	11 05       	cpc	r17, r1
    df48:	09 f4       	brne	.+2      	; 0xdf4c <WebRequest+0x248>
    df4a:	d1 c0       	rjmp	.+418    	; 0xe0ee <WebRequest+0x3ea>
    df4c:	c8 01       	movw	r24, r16
    df4e:	6a e5       	ldi	r22, 0x5A	; 90
    df50:	76 e0       	ldi	r23, 0x06	; 6
    df52:	48 e0       	ldi	r20, 0x08	; 8
    df54:	50 e0       	ldi	r21, 0x00	; 0
    df56:	0e 94 d3 87 	call	0x10fa6	; 0x10fa6 <strncmp_P>
    df5a:	89 2b       	or	r24, r25
    df5c:	09 f0       	breq	.+2      	; 0xdf60 <WebRequest+0x25c>
    df5e:	c7 c0       	rjmp	.+398    	; 0xe0ee <WebRequest+0x3ea>
    df60:	c8 01       	movw	r24, r16
    df62:	08 96       	adiw	r24, 0x08	; 8
    df64:	66 ea       	ldi	r22, 0xA6	; 166
    df66:	75 e0       	ldi	r23, 0x05	; 5
    df68:	40 e1       	ldi	r20, 0x10	; 16
    df6a:	50 e0       	ldi	r21, 0x00	; 0
    df6c:	0e 94 1f 88 	call	0x1103e	; 0x1103e <strncmp>
    df70:	00 97       	sbiw	r24, 0x00	; 0
    df72:	09 f0       	breq	.+2      	; 0xdf76 <WebRequest+0x272>
    df74:	bc c0       	rjmp	.+376    	; 0xe0ee <WebRequest+0x3ea>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    df76:	8c e2       	ldi	r24, 0x2C	; 44
    df78:	91 e0       	ldi	r25, 0x01	; 1
    df7a:	0e 94 b4 8f 	call	0x11f68	; 0x11f68 <__eerd_dword_m128>
    df7e:	ab 01       	movw	r20, r22
    df80:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    df82:	80 91 d5 08 	lds	r24, 0x08D5
    df86:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <StartTimer32>
			
			*url = '\0';
    df8a:	f8 01       	movw	r30, r16
    df8c:	11 92       	st	Z+, r1
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    df8e:	cf 01       	movw	r24, r30
    df90:	66 e2       	ldi	r22, 0x26	; 38
    df92:	70 e0       	ldi	r23, 0x00	; 0
    df94:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    df98:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    df9a:	00 97       	sbiw	r24, 0x00	; 0
    df9c:	09 f4       	brne	.+2      	; 0xdfa0 <WebRequest+0x29c>
    df9e:	79 c0       	rjmp	.+242    	; 0xe092 <WebRequest+0x38e>
    dfa0:	e8 ed       	ldi	r30, 0xD8	; 216
    dfa2:	f6 e0       	ldi	r31, 0x06	; 6
    dfa4:	fc 83       	std	Y+4, r31	; 0x04
    dfa6:	eb 83       	std	Y+3, r30	; 0x03
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    dfa8:	c8 01       	movw	r24, r16
    dfaa:	6d e3       	ldi	r22, 0x3D	; 61
    dfac:	70 e0       	ldi	r23, 0x00	; 0
    dfae:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    dfb2:	6c 01       	movw	r12, r24
					if(p==NULL) return ptrPage;
    dfb4:	00 97       	sbiw	r24, 0x00	; 0
    dfb6:	09 f4       	brne	.+2      	; 0xdfba <WebRequest+0x2b6>
    dfb8:	9d c0       	rjmp	.+314    	; 0xe0f4 <WebRequest+0x3f0>
					nextvar=strchr(url+1,'&');
    dfba:	98 01       	movw	r18, r16
    dfbc:	2f 5f       	subi	r18, 0xFF	; 255
    dfbe:	3f 4f       	sbci	r19, 0xFF	; 255
    dfc0:	3a 83       	std	Y+2, r19	; 0x02
    dfc2:	29 83       	std	Y+1, r18	; 0x01
    dfc4:	c9 01       	movw	r24, r18
    dfc6:	66 e2       	ldi	r22, 0x26	; 38
    dfc8:	70 e0       	ldi	r23, 0x00	; 0
    dfca:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
    dfce:	88 87       	std	Y+8, r24	; 0x08
    dfd0:	99 87       	std	Y+9, r25	; 0x09
					varfield = p + 1;
    dfd2:	86 01       	movw	r16, r12
    dfd4:	0f 5f       	subi	r16, 0xFF	; 255
    dfd6:	1f 4f       	sbci	r17, 0xFF	; 255
					*p = '\0';
    dfd8:	d6 01       	movw	r26, r12
    dfda:	1c 92       	st	X, r1
    dfdc:	51 01       	movw	r10, r2
    dfde:	88 24       	eor	r8, r8
    dfe0:	4a c0       	rjmp	.+148    	; 0xe076 <WebRequest+0x372>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    dfe2:	f5 01       	movw	r30, r10
    dfe4:	45 90       	lpm	r4, Z+
    dfe6:	54 90       	lpm	r5, Z+
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
    dfe8:	72 01       	movw	r14, r4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    dfea:	f2 01       	movw	r30, r4
    dfec:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    dfee:	26 e0       	ldi	r18, 0x06	; 6
    dff0:	30 e0       	ldi	r19, 0x00	; 0
    dff2:	e2 0e       	add	r14, r18
    dff4:	f3 1e       	adc	r15, r19
    dff6:	99 24       	eor	r9, r9

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    dff8:	c5 90       	lpm	r12, Z+
    dffa:	d4 90       	lpm	r13, Z+
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    dffc:	d6 94       	lsr	r13
    dffe:	c7 94       	ror	r12
    e000:	d6 94       	lsr	r13
    e002:	c7 94       	ror	r12

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e004:	f7 01       	movw	r30, r14
    e006:	65 90       	lpm	r6, Z+
    e008:	74 90       	lpm	r7, Z+
    e00a:	8a ef       	ldi	r24, 0xFA	; 250
    e00c:	9f ef       	ldi	r25, 0xFF	; 255
    e00e:	e8 0e       	add	r14, r24
    e010:	f9 1e       	adc	r15, r25
    e012:	27 c0       	rjmp	.+78     	; 0xe062 <WebRequest+0x35e>
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    e014:	61 14       	cp	r6, r1
    e016:	71 04       	cpc	r7, r1
    e018:	19 f1       	breq	.+70     	; 0xe060 <WebRequest+0x35c>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    e01a:	dc 01       	movw	r26, r24
    e01c:	aa 0f       	add	r26, r26
    e01e:	bb 1f       	adc	r27, r27
    e020:	aa 0f       	add	r26, r26
    e022:	bb 1f       	adc	r27, r27
    e024:	a6 0d       	add	r26, r6
    e026:	b7 1d       	adc	r27, r7
    e028:	bb 87       	std	Y+11, r27	; 0x0b
    e02a:	aa 87       	std	Y+10, r26	; 0x0a
    e02c:	fd 01       	movw	r30, r26
    e02e:	65 91       	lpm	r22, Z+
    e030:	74 91       	lpm	r23, Z+
    e032:	89 81       	ldd	r24, Y+1	; 0x01
    e034:	9a 81       	ldd	r25, Y+2	; 0x02
    e036:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    e03a:	89 2b       	or	r24, r25
    e03c:	19 f0       	breq	.+6      	; 0xe044 <WebRequest+0x340>
    e03e:	10 c0       	rjmp	.+32     	; 0xe060 <WebRequest+0x35c>
									while(*varfield=='+') varfield++;	// ignore leading '+'
    e040:	0f 5f       	subi	r16, 0xFF	; 255
    e042:	1f 4f       	sbci	r17, 0xFF	; 255
    e044:	f8 01       	movw	r30, r16
    e046:	80 81       	ld	r24, Z
    e048:	8b 32       	cpi	r24, 0x2B	; 43
    e04a:	d1 f3       	breq	.-12     	; 0xe040 <WebRequest+0x33c>
    e04c:	ea 85       	ldd	r30, Y+10	; 0x0a
    e04e:	fb 85       	ldd	r31, Y+11	; 0x0b
    e050:	32 96       	adiw	r30, 0x02	; 2
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    e052:	85 91       	lpm	r24, Z+
    e054:	94 91       	lpm	r25, Z+
    e056:	b8 01       	movw	r22, r16
    e058:	0e 94 35 6a 	call	0xd46a	; 0xd46a <WebBuf2Field>
    e05c:	5c 82       	std	Y+4, r5	; 0x04
    e05e:	4b 82       	std	Y+3, r4	; 0x03
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    e060:	93 94       	inc	r9
    e062:	89 2d       	mov	r24, r9
    e064:	90 e0       	ldi	r25, 0x00	; 0
    e066:	8c 15       	cp	r24, r12
    e068:	9d 05       	cpc	r25, r13
    e06a:	a0 f2       	brcs	.-88     	; 0xe014 <WebRequest+0x310>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    e06c:	83 94       	inc	r8
    e06e:	22 e0       	ldi	r18, 0x02	; 2
    e070:	30 e0       	ldi	r19, 0x00	; 0
    e072:	a2 0e       	add	r10, r18
    e074:	b3 1e       	adc	r11, r19
    e076:	3d 81       	ldd	r19, Y+5	; 0x05
    e078:	83 16       	cp	r8, r19
    e07a:	08 f4       	brcc	.+2      	; 0xe07e <WebRequest+0x37a>
    e07c:	b2 cf       	rjmp	.-156    	; 0xdfe2 <WebRequest+0x2de>
    e07e:	88 85       	ldd	r24, Y+8	; 0x08
    e080:	99 85       	ldd	r25, Y+9	; 0x09
    e082:	8c 01       	movw	r16, r24
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    e084:	01 15       	cp	r16, r1
    e086:	11 05       	cpc	r17, r1
    e088:	09 f0       	breq	.+2      	; 0xe08c <WebRequest+0x388>
    e08a:	8e cf       	rjmp	.-228    	; 0xdfa8 <WebRequest+0x2a4>
    e08c:	0b 81       	ldd	r16, Y+3	; 0x03
    e08e:	1c 81       	ldd	r17, Y+4	; 0x04
    e090:	35 c0       	rjmp	.+106    	; 0xe0fc <WebRequest+0x3f8>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    e092:	88 ef       	ldi	r24, 0xF8	; 248
    e094:	98 e0       	ldi	r25, 0x08	; 8
    e096:	6e e1       	ldi	r22, 0x1E	; 30
    e098:	79 e4       	ldi	r23, 0x49	; 73
    e09a:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    e09e:	89 2b       	or	r24, r25
    e0a0:	49 f1       	breq	.+82     	; 0xe0f4 <WebRequest+0x3f0>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    e0a2:	89 ef       	ldi	r24, 0xF9	; 249
    e0a4:	98 e0       	ldi	r25, 0x08	; 8
    e0a6:	62 e1       	ldi	r22, 0x12	; 18
    e0a8:	79 e4       	ldi	r23, 0x49	; 73
    e0aa:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    e0ae:	89 2b       	or	r24, r25
    e0b0:	11 f0       	breq	.+4      	; 0xe0b6 <WebRequest+0x3b2>
    e0b2:	10 e0       	ldi	r17, 0x00	; 0
    e0b4:	16 c0       	rjmp	.+44     	; 0xe0e2 <WebRequest+0x3de>
				WebSession = 0;
    e0b6:	10 92 e9 08 	sts	0x08E9, r1
    e0ba:	19 c0       	rjmp	.+50     	; 0xe0ee <WebRequest+0x3ea>
    e0bc:	f6 01       	movw	r30, r12
    e0be:	e5 90       	lpm	r14, Z+
    e0c0:	f4 90       	lpm	r15, Z+
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    e0c2:	f7 01       	movw	r30, r14
    e0c4:	65 91       	lpm	r22, Z+
    e0c6:	74 91       	lpm	r23, Z+
    e0c8:	89 ef       	ldi	r24, 0xF9	; 249
    e0ca:	98 e0       	ldi	r25, 0x08	; 8
    e0cc:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    e0d0:	a2 e0       	ldi	r26, 0x02	; 2
    e0d2:	b0 e0       	ldi	r27, 0x00	; 0
    e0d4:	ca 0e       	add	r12, r26
    e0d6:	db 1e       	adc	r13, r27
    e0d8:	89 2b       	or	r24, r25
    e0da:	11 f4       	brne	.+4      	; 0xe0e0 <WebRequest+0x3dc>
    e0dc:	87 01       	movw	r16, r14
    e0de:	0e c0       	rjmp	.+28     	; 0xe0fc <WebRequest+0x3f8>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    e0e0:	1f 5f       	subi	r17, 0xFF	; 255
    e0e2:	bd 81       	ldd	r27, Y+5	; 0x05
    e0e4:	1b 17       	cp	r17, r27
    e0e6:	50 f3       	brcs	.-44     	; 0xe0bc <WebRequest+0x3b8>
    e0e8:	08 ed       	ldi	r16, 0xD8	; 216
    e0ea:	16 e0       	ldi	r17, 0x06	; 6
    e0ec:	07 c0       	rjmp	.+14     	; 0xe0fc <WebRequest+0x3f8>
    e0ee:	00 e0       	ldi	r16, 0x00	; 0
    e0f0:	1b e0       	ldi	r17, 0x0B	; 11
    e0f2:	04 c0       	rjmp	.+8      	; 0xe0fc <WebRequest+0x3f8>
    e0f4:	87 01       	movw	r16, r14
    e0f6:	02 c0       	rjmp	.+4      	; 0xe0fc <WebRequest+0x3f8>
    e0f8:	00 e0       	ldi	r16, 0x00	; 0
    e0fa:	10 e0       	ldi	r17, 0x00	; 0
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    e0fc:	c8 01       	movw	r24, r16
    e0fe:	2b 96       	adiw	r28, 0x0b	; 11
    e100:	0f b6       	in	r0, 0x3f	; 63
    e102:	f8 94       	cli
    e104:	de bf       	out	0x3e, r29	; 62
    e106:	0f be       	out	0x3f, r0	; 63
    e108:	cd bf       	out	0x3d, r28	; 61
    e10a:	cf 91       	pop	r28
    e10c:	df 91       	pop	r29
    e10e:	1f 91       	pop	r17
    e110:	0f 91       	pop	r16
    e112:	ff 90       	pop	r15
    e114:	ef 90       	pop	r14
    e116:	df 90       	pop	r13
    e118:	cf 90       	pop	r12
    e11a:	bf 90       	pop	r11
    e11c:	af 90       	pop	r10
    e11e:	9f 90       	pop	r9
    e120:	8f 90       	pop	r8
    e122:	7f 90       	pop	r7
    e124:	6f 90       	pop	r6
    e126:	5f 90       	pop	r5
    e128:	4f 90       	pop	r4
    e12a:	3f 90       	pop	r3
    e12c:	2f 90       	pop	r2
    e12e:	08 95       	ret

0000e130 <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    e130:	9f 92       	push	r9
    e132:	af 92       	push	r10
    e134:	bf 92       	push	r11
    e136:	cf 92       	push	r12
    e138:	df 92       	push	r13
    e13a:	ef 92       	push	r14
    e13c:	ff 92       	push	r15
    e13e:	0f 93       	push	r16
    e140:	1f 93       	push	r17
    e142:	df 93       	push	r29
    e144:	cf 93       	push	r28
    e146:	00 d0       	rcall	.+0      	; 0xe148 <WebServer+0x18>
    e148:	00 d0       	rcall	.+0      	; 0xe14a <WebServer+0x1a>
    e14a:	00 d0       	rcall	.+0      	; 0xe14c <WebServer+0x1c>
    e14c:	cd b7       	in	r28, 0x3d	; 61
    e14e:	de b7       	in	r29, 0x3e	; 62
    e150:	8c 01       	movw	r16, r24
    e152:	f6 2e       	mov	r15, r22
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    e154:	e0 91 99 05 	lds	r30, 0x0599

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    e158:	8f b7       	in	r24, 0x3f	; 63
    e15a:	80 78       	andi	r24, 0x80	; 128
    e15c:	80 93 fc 01 	sts	0x01FC, r24
	cli();
    e160:	f8 94       	cli
    e162:	f0 e0       	ldi	r31, 0x00	; 0
    e164:	ee 0f       	add	r30, r30
    e166:	ff 1f       	adc	r31, r31
    e168:	ee 0f       	add	r30, r30
    e16a:	ff 1f       	adc	r31, r31
    e16c:	eb 56       	subi	r30, 0x6B	; 107
    e16e:	fd 4f       	sbci	r31, 0xFD	; 253
    e170:	20 81       	ld	r18, Z
    e172:	31 81       	ldd	r19, Z+1	; 0x01
    e174:	42 81       	ldd	r20, Z+2	; 0x02
    e176:	53 81       	ldd	r21, Z+3	; 0x03

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    e178:	88 23       	and	r24, r24
    e17a:	09 f0       	breq	.+2      	; 0xe17e <WebServer+0x4e>
		sei();
    e17c:	78 94       	sei
    e17e:	28 3c       	cpi	r18, 0xC8	; 200
    e180:	31 05       	cpc	r19, r1
    e182:	41 05       	cpc	r20, r1
    e184:	51 05       	cpc	r21, r1
    e186:	40 f4       	brcc	.+16     	; 0xe198 <WebServer+0x68>
    e188:	80 91 99 05 	lds	r24, 0x0599
    e18c:	4f ef       	ldi	r20, 0xFF	; 255
    e18e:	5f ef       	ldi	r21, 0xFF	; 255
    e190:	6f ef       	ldi	r22, 0xFF	; 255
    e192:	7f ef       	ldi	r23, 0xFF	; 255
    e194:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    e198:	80 91 d5 08 	lds	r24, 0x08D5
    e19c:	0e 94 94 28 	call	0x5128	; 0x5128 <Timer32Stopp>
    e1a0:	88 23       	and	r24, r24
    e1a2:	11 f0       	breq	.+4      	; 0xe1a8 <WebServer+0x78>
    e1a4:	10 92 e9 08 	sts	0x08E9, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    e1a8:	80 91 a4 05 	lds	r24, 0x05A4
    e1ac:	83 35       	cpi	r24, 0x53	; 83
    e1ae:	09 f0       	breq	.+2      	; 0xe1b2 <WebServer+0x82>
    e1b0:	a2 c2       	rjmp	.+1348   	; 0xe6f6 <WebServer+0x5c6>
    e1b2:	80 91 5f 09 	lds	r24, 0x095F
    e1b6:	81 30       	cpi	r24, 0x01	; 1
    e1b8:	09 f0       	breq	.+2      	; 0xe1bc <WebServer+0x8c>
    e1ba:	9d c2       	rjmp	.+1338   	; 0xe6f6 <WebServer+0x5c6>

		// 
		if(WebMode == 254){
    e1bc:	80 91 d5 01 	lds	r24, 0x01D5
    e1c0:	8e 3f       	cpi	r24, 0xFE	; 254
    e1c2:	71 f5       	brne	.+92     	; 0xe220 <WebServer+0xf0>
			ptrPage = WebRequest(ptrSite, SiteSize);
    e1c4:	c8 01       	movw	r24, r16
    e1c6:	6f 2d       	mov	r22, r15
    e1c8:	0e 94 82 6e 	call	0xdd04	; 0xdd04 <WebRequest>
    e1cc:	90 93 f3 01 	sts	0x01F3, r25
    e1d0:	80 93 f2 01 	sts	0x01F2, r24
			if(ptrPage != NULL){
    e1d4:	89 2b       	or	r24, r25
    e1d6:	41 f0       	breq	.+16     	; 0xe1e8 <WebServer+0xb8>
				WebMode = 255;
    e1d8:	8f ef       	ldi	r24, 0xFF	; 255
    e1da:	80 93 d5 01 	sts	0x01D5, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    e1de:	80 91 b5 08 	lds	r24, 0x08B5
    e1e2:	64 e1       	ldi	r22, 0x14	; 20
    e1e4:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    e1e8:	80 91 ef 01 	lds	r24, 0x01EF
    e1ec:	88 23       	and	r24, r24
    e1ee:	79 f0       	breq	.+30     	; 0xe20e <WebServer+0xde>
				if(Timer16Stopp(TD_WaitReqTimout)){
    e1f0:	80 91 d7 08 	lds	r24, 0x08D7
    e1f4:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    e1f8:	88 23       	and	r24, r24
    e1fa:	91 f0       	breq	.+36     	; 0xe220 <WebServer+0xf0>
					GSM_State = GSM_Swtch2CommandMode;
    e1fc:	84 e5       	ldi	r24, 0x54	; 84
    e1fe:	80 93 a4 05 	sts	0x05A4, r24
					Web_POST = 0;
    e202:	10 92 ee 01 	sts	0x01EE, r1
					WebMode = 254;
    e206:	8e ef       	ldi	r24, 0xFE	; 254
    e208:	80 93 d5 01 	sts	0x01D5, r24
    e20c:	76 c2       	rjmp	.+1260   	; 0xe6fa <WebServer+0x5ca>
					return;				
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    e20e:	80 91 d7 08 	lds	r24, 0x08D7
    e212:	68 ee       	ldi	r22, 0xE8	; 232
    e214:	73 e0       	ldi	r23, 0x03	; 3
    e216:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				StartTimeoutWaitRequest = 1;
    e21a:	81 e0       	ldi	r24, 0x01	; 1
    e21c:	80 93 ef 01 	sts	0x01EF, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    e220:	80 91 d1 01 	lds	r24, 0x01D1
    e224:	80 ff       	sbrs	r24, 0
    e226:	69 c2       	rjmp	.+1234   	; 0xe6fa <WebServer+0x5ca>
    e228:	80 91 be 08 	lds	r24, 0x08BE
    e22c:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    e230:	88 23       	and	r24, r24
    e232:	09 f4       	brne	.+2      	; 0xe236 <WebServer+0x106>
    e234:	62 c2       	rjmp	.+1220   	; 0xe6fa <WebServer+0x5ca>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    e236:	80 91 d5 01 	lds	r24, 0x01D5
    e23a:	8f 3f       	cpi	r24, 0xFF	; 255
    e23c:	41 f4       	brne	.+16     	; 0xe24e <WebServer+0x11e>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    e23e:	80 91 b5 08 	lds	r24, 0x08B5
    e242:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
    e246:	88 23       	and	r24, r24
    e248:	11 f0       	breq	.+4      	; 0xe24e <WebServer+0x11e>
					WebMode = 0;
    e24a:	10 92 d5 01 	sts	0x01D5, r1
				}
			}

			// 
			if(WebMode == 2){
    e24e:	80 91 d5 01 	lds	r24, 0x01D5
    e252:	82 30       	cpi	r24, 0x02	; 2
    e254:	59 f4       	brne	.+22     	; 0xe26c <WebServer+0x13c>
				GSM_State = GSM_Swtch2CommandMode;
    e256:	84 e5       	ldi	r24, 0x54	; 84
    e258:	80 93 a4 05 	sts	0x05A4, r24
				WebMode = 254;
    e25c:	8e ef       	ldi	r24, 0xFE	; 254
    e25e:	80 93 d5 01 	sts	0x01D5, r24
				Web_Login_Code = 0;
    e262:	10 92 87 05 	sts	0x0587, r1
				Web_POST = 0;
    e266:	10 92 ee 01 	sts	0x01EE, r1
    e26a:	47 c2       	rjmp	.+1166   	; 0xe6fa <WebServer+0x5ca>
				return;
			}
			
			//   
			if(WebMode == 0){
    e26c:	88 23       	and	r24, r24
    e26e:	e9 f4       	brne	.+58     	; 0xe2aa <WebServer+0x17a>
				//Not Found
				if(ptrPage == &Web_error_page){
    e270:	80 91 f2 01 	lds	r24, 0x01F2
    e274:	90 91 f3 01 	lds	r25, 0x01F3
    e278:	88 5d       	subi	r24, 0xD8	; 216
    e27a:	96 40       	sbci	r25, 0x06	; 6
    e27c:	c9 f4       	brne	.+50     	; 0xe2b0 <WebServer+0x180>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    e27e:	81 ea       	ldi	r24, 0xA1	; 161
    e280:	9b e0       	ldi	r25, 0x0B	; 11
    e282:	63 e6       	ldi	r22, 0x63	; 99
    e284:	76 e0       	ldi	r23, 0x06	; 6
    e286:	44 e7       	ldi	r20, 0x74	; 116
    e288:	50 e0       	ldi	r21, 0x00	; 0
    e28a:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    e28e:	84 e7       	ldi	r24, 0x74	; 116
    e290:	80 93 c5 08 	sts	0x08C5, r24
					GSM_SendFirstChar();
    e294:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    e298:	80 91 be 08 	lds	r24, 0x08BE
    e29c:	68 ec       	ldi	r22, 0xC8	; 200
    e29e:	70 e0       	ldi	r23, 0x00	; 0
    e2a0:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					WebMode = 2;
    e2a4:	82 e0       	ldi	r24, 0x02	; 2
    e2a6:	80 93 d5 01 	sts	0x01D5, r24
    e2aa:	ee 24       	eor	r14, r14
    e2ac:	ff 24       	eor	r15, r15
    e2ae:	cf c0       	rjmp	.+414    	; 0xe44e <WebServer+0x31e>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    e2b0:	81 ea       	ldi	r24, 0xA1	; 161
    e2b2:	9b e0       	ldi	r25, 0x0B	; 11
    e2b4:	6a ea       	ldi	r22, 0xAA	; 170
    e2b6:	75 e0       	ldi	r23, 0x05	; 5
    e2b8:	41 e1       	ldi	r20, 0x11	; 17
    e2ba:	50 e0       	ldi	r21, 0x00	; 0
    e2bc:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    e2c0:	82 eb       	ldi	r24, 0xB2	; 178
    e2c2:	9b e0       	ldi	r25, 0x0B	; 11
    e2c4:	6c eb       	ldi	r22, 0xBC	; 188
    e2c6:	75 e0       	ldi	r23, 0x05	; 5
    e2c8:	4e e0       	ldi	r20, 0x0E	; 14
    e2ca:	50 e0       	ldi	r21, 0x00	; 0
    e2cc:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
    e2d0:	e0 91 f2 01 	lds	r30, 0x01F2
    e2d4:	f0 91 f3 01 	lds	r31, 0x01F3
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    e2d8:	85 91       	lpm	r24, Z+
    e2da:	94 91       	lpm	r25, Z+
    e2dc:	6e e2       	ldi	r22, 0x2E	; 46
    e2de:	70 e0       	ldi	r23, 0x00	; 0
    e2e0:	0e 94 9b 87 	call	0x10f36	; 0x10f36 <strchr_P>
					if(ext_point_ptr){ 
    e2e4:	00 97       	sbiw	r24, 0x00	; 0
    e2e6:	21 f4       	brne	.+8      	; 0xe2f0 <WebServer+0x1c0>
    e2e8:	9f e1       	ldi	r25, 0x1F	; 31
    e2ea:	e9 2e       	mov	r14, r25
    e2ec:	f1 2c       	mov	r15, r1
    e2ee:	97 c0       	rjmp	.+302    	; 0xe41e <WebServer+0x2ee>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    e2f0:	7c 01       	movw	r14, r24
    e2f2:	08 94       	sec
    e2f4:	e1 1c       	adc	r14, r1
    e2f6:	f1 1c       	adc	r15, r1
    e2f8:	87 e0       	ldi	r24, 0x07	; 7
    e2fa:	96 e0       	ldi	r25, 0x06	; 6
    e2fc:	b7 01       	movw	r22, r14
    e2fe:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <strcmp_PP>
    e302:	88 23       	and	r24, r24
    e304:	59 f4       	brne	.+22     	; 0xe31c <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    e306:	80 ec       	ldi	r24, 0xC0	; 192
    e308:	9b e0       	ldi	r25, 0x0B	; 11
    e30a:	6e ed       	ldi	r22, 0xDE	; 222
    e30c:	75 e0       	ldi	r23, 0x05	; 5
    e30e:	41 e2       	ldi	r20, 0x21	; 33
    e310:	50 e0       	ldi	r21, 0x00	; 0
    e312:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
    e316:	00 e4       	ldi	r16, 0x40	; 64
    e318:	10 e0       	ldi	r17, 0x00	; 0
    e31a:	73 c0       	rjmp	.+230    	; 0xe402 <WebServer+0x2d2>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    e31c:	80 ec       	ldi	r24, 0xC0	; 192
    e31e:	9b e0       	ldi	r25, 0x0B	; 11
    e320:	60 e0       	ldi	r22, 0x00	; 0
    e322:	76 e0       	ldi	r23, 0x06	; 6
    e324:	46 e0       	ldi	r20, 0x06	; 6
    e326:	50 e0       	ldi	r21, 0x00	; 0
    e328:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    e32c:	8c e0       	ldi	r24, 0x0C	; 12
    e32e:	96 e0       	ldi	r25, 0x06	; 6
    e330:	b7 01       	movw	r22, r14
    e332:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <strcmp_PP>
    e336:	88 23       	and	r24, r24
    e338:	19 f0       	breq	.+6      	; 0xe340 <WebServer+0x210>
    e33a:	05 e2       	ldi	r16, 0x25	; 37
    e33c:	10 e0       	ldi	r17, 0x00	; 0
    e33e:	0a c0       	rjmp	.+20     	; 0xe354 <WebServer+0x224>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    e340:	86 ec       	ldi	r24, 0xC6	; 198
    e342:	9b e0       	ldi	r25, 0x0B	; 11
    e344:	6c e0       	ldi	r22, 0x0C	; 12
    e346:	76 e0       	ldi	r23, 0x06	; 6
    e348:	43 e0       	ldi	r20, 0x03	; 3
    e34a:	50 e0       	ldi	r21, 0x00	; 0
    e34c:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
    e350:	08 e2       	ldi	r16, 0x28	; 40
    e352:	10 e0       	ldi	r17, 0x00	; 0
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    e354:	80 e1       	ldi	r24, 0x10	; 16
    e356:	96 e0       	ldi	r25, 0x06	; 6
    e358:	b7 01       	movw	r22, r14
    e35a:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <strcmp_PP>
    e35e:	88 23       	and	r24, r24
    e360:	59 f4       	brne	.+22     	; 0xe378 <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    e362:	c8 01       	movw	r24, r16
    e364:	8f 55       	subi	r24, 0x5F	; 95
    e366:	94 4f       	sbci	r25, 0xF4	; 244
    e368:	60 e1       	ldi	r22, 0x10	; 16
    e36a:	76 e0       	ldi	r23, 0x06	; 6
    e36c:	43 e0       	ldi	r20, 0x03	; 3
    e36e:	50 e0       	ldi	r21, 0x00	; 0
    e370:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
								i += sizeof(gif_str)-1;								
    e374:	0d 5f       	subi	r16, 0xFD	; 253
    e376:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    e378:	84 e1       	ldi	r24, 0x14	; 20
    e37a:	96 e0       	ldi	r25, 0x06	; 6
    e37c:	b7 01       	movw	r22, r14
    e37e:	0e 94 2a 3e 	call	0x7c54	; 0x7c54 <strcmp_PP>
    e382:	88 23       	and	r24, r24
    e384:	59 f4       	brne	.+22     	; 0xe39c <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    e386:	c8 01       	movw	r24, r16
    e388:	8f 55       	subi	r24, 0x5F	; 95
    e38a:	94 4f       	sbci	r25, 0xF4	; 244
    e38c:	64 e1       	ldi	r22, 0x14	; 20
    e38e:	76 e0       	ldi	r23, 0x06	; 6
    e390:	44 e0       	ldi	r20, 0x04	; 4
    e392:	50 e0       	ldi	r21, 0x00	; 0
    e394:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    e398:	0c 5f       	subi	r16, 0xFC	; 252
    e39a:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    e39c:	c8 01       	movw	r24, r16
    e39e:	8f 55       	subi	r24, 0x5F	; 95
    e3a0:	94 4f       	sbci	r25, 0xF4	; 244
    e3a2:	6b ec       	ldi	r22, 0xCB	; 203
    e3a4:	75 e0       	ldi	r23, 0x05	; 5
    e3a6:	42 e1       	ldi	r20, 0x12	; 18
    e3a8:	50 e0       	ldi	r21, 0x00	; 0
    e3aa:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
							i += sizeof(Content_Length)-1;
    e3ae:	0e 5e       	subi	r16, 0xEE	; 238
    e3b0:	1f 4f       	sbci	r17, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    e3b2:	e0 91 f2 01 	lds	r30, 0x01F2
    e3b6:	f0 91 f3 01 	lds	r31, 0x01F3
    e3ba:	38 96       	adiw	r30, 0x08	; 8
    e3bc:	25 91       	lpm	r18, Z+
    e3be:	34 91       	lpm	r19, Z+
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    e3c0:	00 d0       	rcall	.+0      	; 0xe3c2 <WebServer+0x292>
    e3c2:	00 d0       	rcall	.+0      	; 0xe3c4 <WebServer+0x294>
    e3c4:	00 d0       	rcall	.+0      	; 0xe3c6 <WebServer+0x296>
    e3c6:	ed b7       	in	r30, 0x3d	; 61
    e3c8:	fe b7       	in	r31, 0x3e	; 62
    e3ca:	31 96       	adiw	r30, 0x01	; 1
    e3cc:	c8 01       	movw	r24, r16
    e3ce:	8f 55       	subi	r24, 0x5F	; 95
    e3d0:	94 4f       	sbci	r25, 0xF4	; 244
    e3d2:	ad b7       	in	r26, 0x3d	; 61
    e3d4:	be b7       	in	r27, 0x3e	; 62
    e3d6:	12 96       	adiw	r26, 0x02	; 2
    e3d8:	9c 93       	st	X, r25
    e3da:	8e 93       	st	-X, r24
    e3dc:	11 97       	sbiw	r26, 0x01	; 1
    e3de:	8d e0       	ldi	r24, 0x0D	; 13
    e3e0:	99 e4       	ldi	r25, 0x49	; 73
    e3e2:	93 83       	std	Z+3, r25	; 0x03
    e3e4:	82 83       	std	Z+2, r24	; 0x02
    e3e6:	35 83       	std	Z+5, r19	; 0x05
    e3e8:	24 83       	std	Z+4, r18	; 0x04
    e3ea:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
    e3ee:	08 0f       	add	r16, r24
    e3f0:	19 1f       	adc	r17, r25
    e3f2:	ed b7       	in	r30, 0x3d	; 61
    e3f4:	fe b7       	in	r31, 0x3e	; 62
    e3f6:	36 96       	adiw	r30, 0x06	; 6
    e3f8:	0f b6       	in	r0, 0x3f	; 63
    e3fa:	f8 94       	cli
    e3fc:	fe bf       	out	0x3e, r31	; 62
    e3fe:	0f be       	out	0x3f, r0	; 63
    e400:	ed bf       	out	0x3d, r30	; 61
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    e402:	c8 01       	movw	r24, r16
    e404:	8f 55       	subi	r24, 0x5F	; 95
    e406:	94 4f       	sbci	r25, 0xF4	; 244
    e408:	69 e1       	ldi	r22, 0x19	; 25
    e40a:	76 e0       	ldi	r23, 0x06	; 6
    e40c:	45 e1       	ldi	r20, 0x15	; 21
    e40e:	50 e0       	ldi	r21, 0x00	; 0
    e410:	0e 94 92 87 	call	0x10f24	; 0x10f24 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    e414:	85 e1       	ldi	r24, 0x15	; 21
    e416:	e8 2e       	mov	r14, r24
    e418:	f1 2c       	mov	r15, r1
    e41a:	e0 0e       	add	r14, r16
    e41c:	f1 1e       	adc	r15, r17

					}
					WebDataCnt = 0;
    e41e:	10 92 74 03 	sts	0x0374, r1
    e422:	10 92 73 03 	sts	0x0373, r1
					WebInputHiddenCnt = 0;
    e426:	10 92 6c 03 	sts	0x036C, r1
					WebHrefHiddenCnt = 0;
    e42a:	10 92 a5 05 	sts	0x05A5, r1
					WebImgSrcHiddenCnt = 0;
    e42e:	10 92 6b 03 	sts	0x036B, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e432:	e0 91 f2 01 	lds	r30, 0x01F2
    e436:	f0 91 f3 01 	lds	r31, 0x01F3
    e43a:	32 96       	adiw	r30, 0x02	; 2
    e43c:	85 91       	lpm	r24, Z+
    e43e:	94 91       	lpm	r25, Z+
					ptrIF = prp(&ptrPage->IF_List);
    e440:	90 93 f5 01 	sts	0x01F5, r25
    e444:	80 93 f4 01 	sts	0x01F4, r24
					WebMode = 1;
    e448:	81 e0       	ldi	r24, 0x01	; 1
    e44a:	80 93 d5 01 	sts	0x01D5, r24
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    e44e:	80 91 d5 01 	lds	r24, 0x01D5
    e452:	81 30       	cpi	r24, 0x01	; 1
    e454:	09 f0       	breq	.+2      	; 0xe458 <WebServer+0x328>
    e456:	51 c1       	rjmp	.+674    	; 0xe6fa <WebServer+0x5ca>
    e458:	b1 c0       	rjmp	.+354    	; 0xe5bc <WebServer+0x48c>
				while(i<sizeof(GSM_TxStr)){
					char ch;
					if(WebImgSrcHiddenCnt){
    e45a:	80 91 6b 03 	lds	r24, 0x036B
    e45e:	88 23       	and	r24, r24
    e460:	a1 f0       	breq	.+40     	; 0xe48a <WebServer+0x35a>
    e462:	e8 2f       	mov	r30, r24
    e464:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    e466:	89 30       	cpi	r24, 0x09	; 9
    e468:	20 f0       	brcs	.+8      	; 0xe472 <WebServer+0x342>
    e46a:	e3 56       	subi	r30, 0x63	; 99
    e46c:	fa 4f       	sbci	r31, 0xFA	; 250
    e46e:	10 81       	ld	r17, Z
    e470:	03 c0       	rjmp	.+6      	; 0xe478 <WebServer+0x348>

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e472:	e7 5a       	subi	r30, 0xA7	; 167
    e474:	f9 4f       	sbci	r31, 0xF9	; 249
    e476:	14 91       	lpm	r17, Z+
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    e478:	8f 5f       	subi	r24, 0xFF	; 255
    e47a:	80 93 6b 03 	sts	0x036B, r24
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    e47e:	89 31       	cpi	r24, 0x19	; 25
    e480:	08 f4       	brcc	.+2      	; 0xe484 <WebServer+0x354>
    e482:	47 c0       	rjmp	.+142    	; 0xe512 <WebServer+0x3e2>
    e484:	10 92 6b 03 	sts	0x036B, r1
    e488:	44 c0       	rjmp	.+136    	; 0xe512 <WebServer+0x3e2>
					}
					else{
						if(WebHrefHiddenCnt){
    e48a:	80 91 a5 05 	lds	r24, 0x05A5
    e48e:	88 23       	and	r24, r24
    e490:	99 f0       	breq	.+38     	; 0xe4b8 <WebServer+0x388>
    e492:	e8 2f       	mov	r30, r24
    e494:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    e496:	89 30       	cpi	r24, 0x09	; 9
    e498:	20 f0       	brcs	.+8      	; 0xe4a2 <WebServer+0x372>
    e49a:	e3 56       	subi	r30, 0x63	; 99
    e49c:	fa 4f       	sbci	r31, 0xFA	; 250
    e49e:	10 81       	ld	r17, Z
    e4a0:	03 c0       	rjmp	.+6      	; 0xe4a8 <WebServer+0x378>
    e4a2:	e7 5a       	subi	r30, 0xA7	; 167
    e4a4:	f9 4f       	sbci	r31, 0xF9	; 249
    e4a6:	14 91       	lpm	r17, Z+
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    e4a8:	8f 5f       	subi	r24, 0xFF	; 255
    e4aa:	80 93 a5 05 	sts	0x05A5, r24
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    e4ae:	89 31       	cpi	r24, 0x19	; 25
    e4b0:	80 f1       	brcs	.+96     	; 0xe512 <WebServer+0x3e2>
    e4b2:	10 92 a5 05 	sts	0x05A5, r1
    e4b6:	2d c0       	rjmp	.+90     	; 0xe512 <WebServer+0x3e2>
						}
						else{
							if(WebInputHiddenCnt){
    e4b8:	80 91 6c 03 	lds	r24, 0x036C
    e4bc:	88 23       	and	r24, r24
    e4be:	99 f0       	breq	.+38     	; 0xe4e6 <WebServer+0x3b6>
    e4c0:	e8 2f       	mov	r30, r24
    e4c2:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    e4c4:	8b 32       	cpi	r24, 0x2B	; 43
    e4c6:	20 f0       	brcs	.+8      	; 0xe4d0 <WebServer+0x3a0>
    e4c8:	e5 58       	subi	r30, 0x85	; 133
    e4ca:	fa 4f       	sbci	r31, 0xFA	; 250
    e4cc:	10 81       	ld	r17, Z
    e4ce:	03 c0       	rjmp	.+6      	; 0xe4d6 <WebServer+0x3a6>
    e4d0:	e2 5d       	subi	r30, 0xD2	; 210
    e4d2:	f9 4f       	sbci	r31, 0xF9	; 249
    e4d4:	14 91       	lpm	r17, Z+
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    e4d6:	8f 5f       	subi	r24, 0xFF	; 255
    e4d8:	80 93 6c 03 	sts	0x036C, r24
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    e4dc:	8e 33       	cpi	r24, 0x3E	; 62
    e4de:	c8 f0       	brcs	.+50     	; 0xe512 <WebServer+0x3e2>
    e4e0:	10 92 6c 03 	sts	0x036C, r1
    e4e4:	16 c0       	rjmp	.+44     	; 0xe512 <WebServer+0x3e2>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e4e6:	80 91 f2 01 	lds	r24, 0x01F2
    e4ea:	90 91 f3 01 	lds	r25, 0x01F3
    e4ee:	0a 96       	adiw	r24, 0x0a	; 10
    e4f0:	fc 01       	movw	r30, r24
    e4f2:	25 91       	lpm	r18, Z+
    e4f4:	34 91       	lpm	r19, Z+
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    e4f6:	80 91 73 03 	lds	r24, 0x0373
    e4fa:	90 91 74 03 	lds	r25, 0x0374
    e4fe:	01 96       	adiw	r24, 0x01	; 1
    e500:	90 93 74 03 	sts	0x0374, r25
    e504:	80 93 73 03 	sts	0x0373, r24
    e508:	01 97       	sbiw	r24, 0x01	; 1

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e50a:	28 0f       	add	r18, r24
    e50c:	39 1f       	adc	r19, r25
    e50e:	f9 01       	movw	r30, r18
    e510:	14 91       	lpm	r17, Z+
							}
						}
					}

					GSM_TxStr[i++] = ch;
    e512:	f7 01       	movw	r30, r14
    e514:	ef 55       	subi	r30, 0x5F	; 95
    e516:	f4 4f       	sbci	r31, 0xF4	; 244
    e518:	10 83       	st	Z, r17
    e51a:	67 01       	movw	r12, r14
    e51c:	08 94       	sec
    e51e:	c1 1c       	adc	r12, r1
    e520:	d1 1c       	adc	r13, r1
					if(ptrPage != &Web_login){	//  login.html   !
    e522:	80 91 f2 01 	lds	r24, 0x01F2
    e526:	90 91 f3 01 	lds	r25, 0x01F3
    e52a:	80 50       	subi	r24, 0x00	; 0
    e52c:	9b 40       	sbci	r25, 0x0B	; 11
    e52e:	11 f4       	brne	.+4      	; 0xe534 <WebServer+0x404>
    e530:	76 01       	movw	r14, r12
    e532:	2c c0       	rjmp	.+88     	; 0xe58c <WebServer+0x45c>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    e534:	81 2f       	mov	r24, r17
    e536:	0e 94 43 3e 	call	0x7c86	; 0x7c86 <SeekTagFORM>
    e53a:	88 23       	and	r24, r24
    e53c:	11 f0       	breq	.+4      	; 0xe542 <WebServer+0x412>
    e53e:	00 93 6c 03 	sts	0x036C, r16
						if(SeekTagA_HREF(ch)){ 
    e542:	81 2f       	mov	r24, r17
    e544:	0e 94 93 3e 	call	0x7d26	; 0x7d26 <SeekTagA_HREF>
    e548:	88 23       	and	r24, r24
    e54a:	11 f4       	brne	.+4      	; 0xe550 <WebServer+0x420>
    e54c:	76 01       	movw	r14, r12
    e54e:	0b c0       	rjmp	.+22     	; 0xe566 <WebServer+0x436>
							WebHrefHiddenCnt = 1;
    e550:	00 93 a5 05 	sts	0x05A5, r16
							i--;
							WebDataCnt--;
    e554:	80 91 73 03 	lds	r24, 0x0373
    e558:	90 91 74 03 	lds	r25, 0x0374
    e55c:	01 97       	sbiw	r24, 0x01	; 1
    e55e:	90 93 74 03 	sts	0x0374, r25
    e562:	80 93 73 03 	sts	0x0373, r24
						}
						if(SeekTagIMG_SRC(ch)){ 
    e566:	81 2f       	mov	r24, r17
    e568:	0e 94 e3 3e 	call	0x7dc6	; 0x7dc6 <SeekTagIMG_SRC>
    e56c:	88 23       	and	r24, r24
    e56e:	71 f0       	breq	.+28     	; 0xe58c <WebServer+0x45c>
							WebImgSrcHiddenCnt = 1;
    e570:	00 93 6b 03 	sts	0x036B, r16
							i--;
    e574:	08 94       	sec
    e576:	e1 08       	sbc	r14, r1
    e578:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    e57a:	80 91 73 03 	lds	r24, 0x0373
    e57e:	90 91 74 03 	lds	r25, 0x0374
    e582:	01 97       	sbiw	r24, 0x01	; 1
    e584:	90 93 74 03 	sts	0x0374, r25
    e588:	80 93 73 03 	sts	0x0373, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    e58c:	e0 91 f2 01 	lds	r30, 0x01F2
    e590:	f0 91 f3 01 	lds	r31, 0x01F3
    e594:	38 96       	adiw	r30, 0x08	; 8
    e596:	25 91       	lpm	r18, Z+
    e598:	34 91       	lpm	r19, Z+
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    e59a:	80 91 73 03 	lds	r24, 0x0373
    e59e:	90 91 74 03 	lds	r25, 0x0374
    e5a2:	82 17       	cp	r24, r18
    e5a4:	93 07       	cpc	r25, r19
    e5a6:	58 f0       	brcs	.+22     	; 0xe5be <WebServer+0x48e>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    e5a8:	80 91 be 08 	lds	r24, 0x08BE
    e5ac:	68 ec       	ldi	r22, 0xC8	; 200
    e5ae:	70 e0       	ldi	r23, 0x00	; 0
    e5b0:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						WebMode = 2;
    e5b4:	82 e0       	ldi	r24, 0x02	; 2
    e5b6:	80 93 d5 01 	sts	0x01D5, r24
    e5ba:	06 c0       	rjmp	.+12     	; 0xe5c8 <WebServer+0x498>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    e5bc:	01 e0       	ldi	r16, 0x01	; 1
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    e5be:	2f ef       	ldi	r18, 0xFF	; 255
    e5c0:	e2 16       	cp	r14, r18
    e5c2:	f1 04       	cpc	r15, r1
    e5c4:	08 f4       	brcc	.+2      	; 0xe5c8 <WebServer+0x498>
    e5c6:	49 cf       	rjmp	.-366    	; 0xe45a <WebServer+0x32a>
						WebMode = 2;
						break;
					}
				}
				//
				if(ptrIF != NULL){
    e5c8:	80 91 f4 01 	lds	r24, 0x01F4
    e5cc:	90 91 f5 01 	lds	r25, 0x01F5
    e5d0:	89 2b       	or	r24, r25
    e5d2:	09 f4       	brne	.+2      	; 0xe5d6 <WebServer+0x4a6>
    e5d4:	6f c0       	rjmp	.+222    	; 0xe6b4 <WebServer+0x584>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e5d6:	80 91 f2 01 	lds	r24, 0x01F2
    e5da:	90 91 f3 01 	lds	r25, 0x01F3
    e5de:	0a 96       	adiw	r24, 0x0a	; 10
    e5e0:	fc 01       	movw	r30, r24
    e5e2:	25 91       	lpm	r18, Z+
    e5e4:	34 91       	lpm	r19, Z+

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    e5e6:	80 91 73 03 	lds	r24, 0x0373
    e5ea:	90 91 74 03 	lds	r25, 0x0374
    e5ee:	28 0f       	add	r18, r24
    e5f0:	39 1f       	adc	r19, r25
    e5f2:	f9 01       	movw	r30, r18
    e5f4:	84 91       	lpm	r24, Z+
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    e5f6:	8b 37       	cpi	r24, 0x7B	; 123
    e5f8:	a9 f4       	brne	.+42     	; 0xe624 <WebServer+0x4f4>
    e5fa:	f7 01       	movw	r30, r14
    e5fc:	e0 56       	subi	r30, 0x60	; 96
    e5fe:	f4 4f       	sbci	r31, 0xF4	; 244
    e600:	0a c0       	rjmp	.+20     	; 0xe616 <WebServer+0x4e6>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
    e602:	80 91 73 03 	lds	r24, 0x0373
    e606:	90 91 74 03 	lds	r25, 0x0374
    e60a:	01 97       	sbiw	r24, 0x01	; 1
    e60c:	90 93 74 03 	sts	0x0374, r25
    e610:	80 93 73 03 	sts	0x0373, r24
    e614:	79 01       	movw	r14, r18
				}
				//
				if(ptrIF != NULL){
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
						while(GSM_TxStr[i-1] == '{'){
    e616:	97 01       	movw	r18, r14
    e618:	21 50       	subi	r18, 0x01	; 1
    e61a:	30 40       	sbci	r19, 0x00	; 0
    e61c:	80 81       	ld	r24, Z
    e61e:	31 97       	sbiw	r30, 0x01	; 1
    e620:	8b 37       	cpi	r24, 0x7B	; 123
    e622:	79 f3       	breq	.-34     	; 0xe602 <WebServer+0x4d2>
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    e624:	00 91 f4 01 	lds	r16, 0x01F4
    e628:	10 91 f5 01 	lds	r17, 0x01F5
    e62c:	9e 2c       	mov	r9, r14
    e62e:	cc 24       	eor	r12, r12
		switch(Char=GSM_TxStr[X]) {
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
			Param.Prec = prb(&IF->Prec);
			Param.Txt = prp(&IF->EnumList);
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    e630:	5e 01       	movw	r10, r28
    e632:	08 94       	sec
    e634:	a1 1c       	adc	r10, r1
    e636:	b1 1c       	adc	r11, r1
    e638:	36 c0       	rjmp	.+108    	; 0xe6a6 <WebServer+0x576>
{
	uint8_t X;
	for(X=0; X<Size; X++){
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    e63a:	ec 2d       	mov	r30, r12
    e63c:	f0 e0       	ldi	r31, 0x00	; 0
    e63e:	ef 55       	subi	r30, 0x5F	; 95
    e640:	f4 4f       	sbci	r31, 0xF4	; 244
    e642:	fa 83       	std	Y+2, r31	; 0x02
    e644:	e9 83       	std	Y+1, r30	; 0x01
		Param.Size = 0;
    e646:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    e648:	d0 80       	ld	r13, Z
    e64a:	2b e7       	ldi	r18, 0x7B	; 123
    e64c:	d2 16       	cp	r13, r18
    e64e:	11 f5       	brne	.+68     	; 0xe694 <WebServer+0x564>
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    e650:	9f 01       	movw	r18, r30
    e652:	8c 81       	ldd	r24, Y+4	; 0x04
    e654:	8f 5f       	subi	r24, 0xFF	; 255
    e656:	8c 83       	std	Y+4, r24	; 0x04
    e658:	f9 01       	movw	r30, r18
    e65a:	e8 0f       	add	r30, r24
    e65c:	f1 1d       	adc	r31, r1
    e65e:	d0 80       	ld	r13, Z
    e660:	8b e7       	ldi	r24, 0x7B	; 123
    e662:	d8 16       	cp	r13, r24
    e664:	b1 f3       	breq	.-20     	; 0xe652 <WebServer+0x522>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e666:	0b 5f       	subi	r16, 0xFB	; 251
    e668:	1f 4f       	sbci	r17, 0xFF	; 255
    e66a:	f8 01       	movw	r30, r16
    e66c:	84 91       	lpm	r24, Z+
    e66e:	05 50       	subi	r16, 0x05	; 5
    e670:	10 40       	sbci	r17, 0x00	; 0
			Param.Prec = prb(&IF->Prec);
    e672:	8b 83       	std	Y+3, r24	; 0x03

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e674:	f8 01       	movw	r30, r16
    e676:	33 96       	adiw	r30, 0x03	; 3
    e678:	85 91       	lpm	r24, Z+
    e67a:	94 91       	lpm	r25, Z+
			Param.Txt = prp(&IF->EnumList);
    e67c:	9e 83       	std	Y+6, r25	; 0x06
    e67e:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    e680:	f8 01       	movw	r30, r16
    e682:	84 91       	lpm	r24, Z+

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    e684:	31 96       	adiw	r30, 0x01	; 1
    e686:	65 91       	lpm	r22, Z+
    e688:	74 91       	lpm	r23, Z+
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    e68a:	a5 01       	movw	r20, r10
    e68c:	0e 94 e8 67 	call	0xcfd0	; 0xcfd0 <WebPutField>
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    e690:	0a 5f       	subi	r16, 0xFA	; 250
    e692:	1f 4f       	sbci	r17, 0xFF	; 255
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    e694:	8c 81       	ldd	r24, Y+4	; 0x04
    e696:	8c 0d       	add	r24, r12
    e698:	e8 2f       	mov	r30, r24
    e69a:	f0 e0       	ldi	r31, 0x00	; 0
    e69c:	ef 55       	subi	r30, 0x5F	; 95
    e69e:	f4 4f       	sbci	r31, 0xF4	; 244
    e6a0:	d0 82       	st	Z, r13
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    e6a2:	c8 2e       	mov	r12, r24
    e6a4:	c3 94       	inc	r12
    e6a6:	c9 14       	cp	r12, r9
    e6a8:	08 f4       	brcc	.+2      	; 0xe6ac <WebServer+0x57c>
    e6aa:	c7 cf       	rjmp	.-114    	; 0xe63a <WebServer+0x50a>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    e6ac:	10 93 f5 01 	sts	0x01F5, r17
    e6b0:	00 93 f4 01 	sts	0x01F4, r16
				}
				GSMTxSz = i;
    e6b4:	e0 92 c5 08 	sts	0x08C5, r14
				//flowcontrol
				PacketByteCount += GSMTxSz;
    e6b8:	80 91 c5 08 	lds	r24, 0x08C5
    e6bc:	20 91 f0 01 	lds	r18, 0x01F0
    e6c0:	30 91 f1 01 	lds	r19, 0x01F1
    e6c4:	28 0f       	add	r18, r24
    e6c6:	31 1d       	adc	r19, r1
    e6c8:	30 93 f1 01 	sts	0x01F1, r19
    e6cc:	20 93 f0 01 	sts	0x01F0, r18
				if(PacketByteCount >= MaxPacketSz){
    e6d0:	f4 e0       	ldi	r31, 0x04	; 4
    e6d2:	20 30       	cpi	r18, 0x00	; 0
    e6d4:	3f 07       	cpc	r19, r31
    e6d6:	60 f0       	brcs	.+24     	; 0xe6f0 <WebServer+0x5c0>
					PacketByteCount -= MaxPacketSz;
    e6d8:	20 50       	subi	r18, 0x00	; 0
    e6da:	34 40       	sbci	r19, 0x04	; 4
    e6dc:	30 93 f1 01 	sts	0x01F1, r19
    e6e0:	20 93 f0 01 	sts	0x01F0, r18
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    e6e4:	80 91 be 08 	lds	r24, 0x08BE
    e6e8:	68 ec       	ldi	r22, 0xC8	; 200
    e6ea:	70 e0       	ldi	r23, 0x00	; 0
    e6ec:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				}
				GSM_SendFirstChar();
    e6f0:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
    e6f4:	02 c0       	rjmp	.+4      	; 0xe6fa <WebServer+0x5ca>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    e6f6:	10 92 ef 01 	sts	0x01EF, r1
	}

}
    e6fa:	26 96       	adiw	r28, 0x06	; 6
    e6fc:	0f b6       	in	r0, 0x3f	; 63
    e6fe:	f8 94       	cli
    e700:	de bf       	out	0x3e, r29	; 62
    e702:	0f be       	out	0x3f, r0	; 63
    e704:	cd bf       	out	0x3d, r28	; 61
    e706:	cf 91       	pop	r28
    e708:	df 91       	pop	r29
    e70a:	1f 91       	pop	r17
    e70c:	0f 91       	pop	r16
    e70e:	ff 90       	pop	r15
    e710:	ef 90       	pop	r14
    e712:	df 90       	pop	r13
    e714:	cf 90       	pop	r12
    e716:	bf 90       	pop	r11
    e718:	af 90       	pop	r10
    e71a:	9f 90       	pop	r9
    e71c:	08 95       	ret

0000e71e <OneWireReadTemp>:
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
	}
}
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    e71e:	7f 92       	push	r7
    e720:	8f 92       	push	r8
    e722:	9f 92       	push	r9
    e724:	af 92       	push	r10
    e726:	bf 92       	push	r11
    e728:	cf 92       	push	r12
    e72a:	df 92       	push	r13
    e72c:	ef 92       	push	r14
    e72e:	ff 92       	push	r15
    e730:	0f 93       	push	r16
    e732:	1f 93       	push	r17
    e734:	cf 93       	push	r28
    e736:	df 93       	push	r29
    e738:	78 2e       	mov	r7, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e73a:	e8 2e       	mov	r14, r24
    e73c:	ff 24       	eor	r15, r15
    e73e:	c7 01       	movw	r24, r14
    e740:	88 5d       	subi	r24, 0xD8	; 216
    e742:	9e 4f       	sbci	r25, 0xFE	; 254
    e744:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    e748:	d7 01       	movw	r26, r14
    e74a:	a2 5a       	subi	r26, 0xA2	; 162
    e74c:	b6 4f       	sbci	r27, 0xF6	; 246
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    e74e:	88 23       	and	r24, r24
    e750:	89 f4       	brne	.+34     	; 0xe774 <OneWireReadTemp+0x56>
		Temperature[CH] = Therm_Off_Mark;
    e752:	f7 01       	movw	r30, r14
    e754:	ee 0f       	add	r30, r30
    e756:	ff 1f       	adc	r31, r31
    e758:	e0 59       	subi	r30, 0x90	; 144
    e75a:	fa 4f       	sbci	r31, 0xFA	; 250
    e75c:	80 e0       	ldi	r24, 0x00	; 0
    e75e:	90 e8       	ldi	r25, 0x80	; 128
    e760:	91 83       	std	Z+1, r25	; 0x01
    e762:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    e764:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    e766:	8a e7       	ldi	r24, 0x7A	; 122
    e768:	93 e0       	ldi	r25, 0x03	; 3
    e76a:	e8 0e       	add	r14, r24
    e76c:	f9 1e       	adc	r15, r25
    e76e:	f7 01       	movw	r30, r14
    e770:	10 82       	st	Z, r1
    e772:	b0 c0       	rjmp	.+352    	; 0xe8d4 <OneWireReadTemp+0x1b6>
		return;
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    e774:	8c 91       	ld	r24, X
    e776:	f7 01       	movw	r30, r14
    e778:	e6 58       	subi	r30, 0x86	; 134
    e77a:	fc 4f       	sbci	r31, 0xFC	; 252
    e77c:	82 30       	cpi	r24, 0x02	; 2
    e77e:	91 f4       	brne	.+36     	; 0xe7a4 <OneWireReadTemp+0x86>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    e780:	80 81       	ld	r24, Z
    e782:	8a 30       	cpi	r24, 0x0A	; 10
    e784:	60 f0       	brcs	.+24     	; 0xe79e <OneWireReadTemp+0x80>
    e786:	ee 0c       	add	r14, r14
    e788:	ff 1c       	adc	r15, r15
    e78a:	80 e7       	ldi	r24, 0x70	; 112
    e78c:	95 e0       	ldi	r25, 0x05	; 5
    e78e:	e8 0e       	add	r14, r24
    e790:	f9 1e       	adc	r15, r25
    e792:	81 e0       	ldi	r24, 0x01	; 1
    e794:	90 e8       	ldi	r25, 0x80	; 128
    e796:	f7 01       	movw	r30, r14
    e798:	91 83       	std	Z+1, r25	; 0x01
    e79a:	80 83       	st	Z, r24
    e79c:	9b c0       	rjmp	.+310    	; 0xe8d4 <OneWireReadTemp+0x1b6>
		else DS18B20_Error[CH]++;
    e79e:	8f 5f       	subi	r24, 0xFF	; 255
    e7a0:	80 83       	st	Z, r24
    e7a2:	98 c0       	rjmp	.+304    	; 0xe8d4 <OneWireReadTemp+0x1b6>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    e7a4:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    e7a6:	f8 94       	cli
    e7a8:	87 2d       	mov	r24, r7
    e7aa:	0e 94 bf 29 	call	0x537e	; 0x537e <OW_MasterPullLowBus>
    e7ae:	78 94       	sei
	Delay_us(580);
    e7b0:	84 e4       	ldi	r24, 0x44	; 68
    e7b2:	92 e0       	ldi	r25, 0x02	; 2
    e7b4:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    e7b8:	f8 94       	cli
    e7ba:	87 2d       	mov	r24, r7
    e7bc:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    e7c0:	86 e4       	ldi	r24, 0x46	; 70
    e7c2:	90 e0       	ldi	r25, 0x00	; 0
    e7c4:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    e7c8:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    e7cc:	80 ff       	sbrs	r24, 0
    e7ce:	05 c0       	rjmp	.+10     	; 0xe7da <OneWireReadTemp+0xbc>
    e7d0:	f7 01       	movw	r30, r14
    e7d2:	e2 5a       	subi	r30, 0xA2	; 162
    e7d4:	f6 4f       	sbci	r31, 0xF6	; 246
    e7d6:	82 e0       	ldi	r24, 0x02	; 2
    e7d8:	80 83       	st	Z, r24
	sei();
    e7da:	78 94       	sei
	Delay_us(510);
    e7dc:	8e ef       	ldi	r24, 0xFE	; 254
    e7de:	91 e0       	ldi	r25, 0x01	; 1
    e7e0:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    e7e4:	f7 01       	movw	r30, r14
    e7e6:	e2 5a       	subi	r30, 0xA2	; 162
    e7e8:	f6 4f       	sbci	r31, 0xF6	; 246
    e7ea:	80 81       	ld	r24, Z
    e7ec:	82 30       	cpi	r24, 0x02	; 2
    e7ee:	09 f4       	brne	.+2      	; 0xe7f2 <OneWireReadTemp+0xd4>
    e7f0:	71 c0       	rjmp	.+226    	; 0xe8d4 <OneWireReadTemp+0x1b6>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    e7f2:	87 2d       	mov	r24, r7
    e7f4:	6c ec       	ldi	r22, 0xCC	; 204
    e7f6:	0e 94 49 3d 	call	0x7a92	; 0x7a92 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    e7fa:	87 2d       	mov	r24, r7
    e7fc:	6e eb       	ldi	r22, 0xBE	; 190
    e7fe:	0e 94 49 3d 	call	0x7a92	; 0x7a92 <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    e802:	87 2d       	mov	r24, r7
    e804:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <OW_MasterRx_Data>
    e808:	08 2f       	mov	r16, r24
    e80a:	10 e0       	ldi	r17, 0x00	; 0
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    e80c:	87 2d       	mov	r24, r7
    e80e:	0e 94 8a 3d 	call	0x7b14	; 0x7b14 <OW_MasterRx_Data>
		Tres = (Tres*10)/16;
    e812:	38 2f       	mov	r19, r24
    e814:	20 e0       	ldi	r18, 0x00	; 0
    e816:	20 2b       	or	r18, r16
    e818:	31 2b       	or	r19, r17
    e81a:	a9 01       	movw	r20, r18
    e81c:	73 e0       	ldi	r23, 0x03	; 3
    e81e:	44 0f       	add	r20, r20
    e820:	55 1f       	adc	r21, r21
    e822:	7a 95       	dec	r23
    e824:	e1 f7       	brne	.-8      	; 0xe81e <OneWireReadTemp+0x100>
    e826:	22 0f       	add	r18, r18
    e828:	33 1f       	adc	r19, r19
    e82a:	42 0f       	add	r20, r18
    e82c:	53 1f       	adc	r21, r19
    e82e:	ca 01       	movw	r24, r20
    e830:	60 e1       	ldi	r22, 0x10	; 16
    e832:	70 e0       	ldi	r23, 0x00	; 0
    e834:	0e 94 2a 91 	call	0x12254	; 0x12254 <__divmodhi4>
    e838:	eb 01       	movw	r28, r22
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    e83a:	f3 e0       	ldi	r31, 0x03	; 3
    e83c:	62 35       	cpi	r22, 0x52	; 82
    e83e:	7f 07       	cpc	r23, r31
    e840:	d9 f1       	breq	.+118    	; 0xe8b8 <OneWireReadTemp+0x19a>
    e842:	47 01       	movw	r8, r14
    e844:	88 0c       	add	r8, r8
    e846:	99 1c       	adc	r9, r9
    e848:	84 01       	movw	r16, r8
    e84a:	0e 0d       	add	r16, r14
    e84c:	1f 1d       	adc	r17, r15
    e84e:	c8 01       	movw	r24, r16
    e850:	87 5d       	subi	r24, 0xD7	; 215
    e852:	9e 4f       	sbci	r25, 0xFE	; 254
    e854:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    e858:	c8 2e       	mov	r12, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    e85a:	c8 01       	movw	r24, r16
    e85c:	86 5d       	subi	r24, 0xD6	; 214
    e85e:	9e 4f       	sbci	r25, 0xFE	; 254
    e860:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    e864:	7c 01       	movw	r14, r24
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    e866:	80 e7       	ldi	r24, 0x70	; 112
    e868:	95 e0       	ldi	r25, 0x05	; 5
    e86a:	88 0e       	add	r8, r24
    e86c:	99 1e       	adc	r9, r25
    e86e:	dd 24       	eor	r13, r13
    e870:	c7 fc       	sbrc	r12, 7
    e872:	d0 94       	com	r13
    e874:	cc 0d       	add	r28, r12
    e876:	dd 1d       	adc	r29, r13
    e878:	be 01       	movw	r22, r28
    e87a:	88 27       	eor	r24, r24
    e87c:	77 fd       	sbrc	r23, 7
    e87e:	80 95       	com	r24
    e880:	98 2f       	mov	r25, r24
    e882:	0e 94 d5 89 	call	0x113aa	; 0x113aa <__floatsisf>
    e886:	5b 01       	movw	r10, r22
    e888:	6c 01       	movw	r12, r24
    e88a:	00 e0       	ldi	r16, 0x00	; 0
    e88c:	10 e0       	ldi	r17, 0x00	; 0
    e88e:	c8 01       	movw	r24, r16
    e890:	b7 01       	movw	r22, r14
    e892:	0e 94 d3 89 	call	0x113a6	; 0x113a6 <__floatunsisf>
    e896:	20 e0       	ldi	r18, 0x00	; 0
    e898:	30 e0       	ldi	r19, 0x00	; 0
    e89a:	4a e7       	ldi	r20, 0x7A	; 122
    e89c:	54 e4       	ldi	r21, 0x44	; 68
    e89e:	0e 94 3a 89 	call	0x11274	; 0x11274 <__divsf3>
    e8a2:	9b 01       	movw	r18, r22
    e8a4:	ac 01       	movw	r20, r24
    e8a6:	c6 01       	movw	r24, r12
    e8a8:	b5 01       	movw	r22, r10
    e8aa:	0e 94 61 8a 	call	0x114c2	; 0x114c2 <__mulsf3>
    e8ae:	0e 94 a2 89 	call	0x11344	; 0x11344 <__fixsfsi>
    e8b2:	f4 01       	movw	r30, r8
    e8b4:	71 83       	std	Z+1, r23	; 0x01
    e8b6:	60 83       	st	Z, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    e8b8:	f8 94       	cli
    e8ba:	87 2d       	mov	r24, r7
    e8bc:	0e 94 bf 29 	call	0x537e	; 0x537e <OW_MasterPullLowBus>
    e8c0:	78 94       	sei
		Delay_us(580);	
    e8c2:	84 e4       	ldi	r24, 0x44	; 68
    e8c4:	92 e0       	ldi	r25, 0x02	; 2
    e8c6:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    e8ca:	f8 94       	cli
    e8cc:	87 2d       	mov	r24, r7
    e8ce:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>
    e8d2:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    e8d4:	df 91       	pop	r29
    e8d6:	cf 91       	pop	r28
    e8d8:	1f 91       	pop	r17
    e8da:	0f 91       	pop	r16
    e8dc:	ff 90       	pop	r15
    e8de:	ef 90       	pop	r14
    e8e0:	df 90       	pop	r13
    e8e2:	cf 90       	pop	r12
    e8e4:	bf 90       	pop	r11
    e8e6:	af 90       	pop	r10
    e8e8:	9f 90       	pop	r9
    e8ea:	8f 90       	pop	r8
    e8ec:	7f 90       	pop	r7
    e8ee:	08 95       	ret

0000e8f0 <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    e8f0:	1f 93       	push	r17
    e8f2:	cf 93       	push	r28
    e8f4:	df 93       	push	r29
    e8f6:	18 2f       	mov	r17, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    e8f8:	c8 2f       	mov	r28, r24
    e8fa:	d0 e0       	ldi	r29, 0x00	; 0
    e8fc:	ce 01       	movw	r24, r28
    e8fe:	88 5d       	subi	r24, 0xD8	; 216
    e900:	9e 4f       	sbci	r25, 0xFE	; 254
    e902:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    e906:	88 23       	and	r24, r24
    e908:	71 f4       	brne	.+28     	; 0xe926 <OneWireStartADC+0x36>
		Temperature[CH] = Therm_Off_Mark;
    e90a:	fe 01       	movw	r30, r28
    e90c:	ee 0f       	add	r30, r30
    e90e:	ff 1f       	adc	r31, r31
    e910:	e0 59       	subi	r30, 0x90	; 144
    e912:	fa 4f       	sbci	r31, 0xFA	; 250
    e914:	80 e0       	ldi	r24, 0x00	; 0
    e916:	90 e8       	ldi	r25, 0x80	; 128
    e918:	91 83       	std	Z+1, r25	; 0x01
    e91a:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    e91c:	c2 5a       	subi	r28, 0xA2	; 162
    e91e:	d6 4f       	sbci	r29, 0xF6	; 246
    e920:	82 e0       	ldi	r24, 0x02	; 2
    e922:	88 83       	st	Y, r24
    e924:	3b c0       	rjmp	.+118    	; 0xe99c <OneWireStartADC+0xac>
		return;
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    e926:	f8 94       	cli
    e928:	81 2f       	mov	r24, r17
    e92a:	0e 94 bf 29 	call	0x537e	; 0x537e <OW_MasterPullLowBus>
    e92e:	78 94       	sei
	Delay_us(580);	
    e930:	84 e4       	ldi	r24, 0x44	; 68
    e932:	92 e0       	ldi	r25, 0x02	; 2
    e934:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    e938:	f8 94       	cli
    e93a:	81 2f       	mov	r24, r17
    e93c:	0e 94 cc 29 	call	0x5398	; 0x5398 <OW_MasterReleaseBus>
    e940:	88 e1       	ldi	r24, 0x18	; 24
    e942:	91 e0       	ldi	r25, 0x01	; 1
    e944:	01 97       	sbiw	r24, 0x01	; 1
    e946:	f1 f7       	brne	.-4      	; 0xe944 <OneWireStartADC+0x54>
    e948:	80 91 63 00 	lds	r24, 0x0063
    e94c:	a1 2f       	mov	r26, r17
    e94e:	b0 e0       	ldi	r27, 0x00	; 0
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    e950:	80 fd       	sbrc	r24, 0
    e952:	05 c0       	rjmp	.+10     	; 0xe95e <OneWireStartADC+0x6e>
    e954:	a2 5a       	subi	r26, 0xA2	; 162
    e956:	b6 4f       	sbci	r27, 0xF6	; 246
    e958:	81 e0       	ldi	r24, 0x01	; 1
    e95a:	8c 93       	st	X, r24
    e95c:	0b c0       	rjmp	.+22     	; 0xe974 <OneWireStartADC+0x84>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    e95e:	fd 01       	movw	r30, r26
    e960:	e2 5a       	subi	r30, 0xA2	; 162
    e962:	f6 4f       	sbci	r31, 0xF6	; 246
    e964:	82 e0       	ldi	r24, 0x02	; 2
    e966:	80 83       	st	Z, r24
		DS18B20_Error[CH]++;
    e968:	fd 01       	movw	r30, r26
    e96a:	e6 58       	subi	r30, 0x86	; 134
    e96c:	fc 4f       	sbci	r31, 0xFC	; 252
    e96e:	80 81       	ld	r24, Z
    e970:	8f 5f       	subi	r24, 0xFF	; 255
    e972:	80 83       	st	Z, r24
	}
	sei();
    e974:	78 94       	sei
	
	Delay_us(510);
    e976:	8e ef       	ldi	r24, 0xFE	; 254
    e978:	91 e0       	ldi	r25, 0x01	; 1
    e97a:	0e 94 97 29 	call	0x532e	; 0x532e <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    e97e:	e1 2f       	mov	r30, r17
    e980:	f0 e0       	ldi	r31, 0x00	; 0
    e982:	e2 5a       	subi	r30, 0xA2	; 162
    e984:	f6 4f       	sbci	r31, 0xF6	; 246
    e986:	80 81       	ld	r24, Z
    e988:	82 30       	cpi	r24, 0x02	; 2
    e98a:	41 f0       	breq	.+16     	; 0xe99c <OneWireStartADC+0xac>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    e98c:	81 2f       	mov	r24, r17
    e98e:	6c ec       	ldi	r22, 0xCC	; 204
    e990:	0e 94 49 3d 	call	0x7a92	; 0x7a92 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    e994:	81 2f       	mov	r24, r17
    e996:	64 e4       	ldi	r22, 0x44	; 68
    e998:	0e 94 49 3d 	call	0x7a92	; 0x7a92 <OW_MasterTx_Command>
	}
}
    e99c:	df 91       	pop	r29
    e99e:	cf 91       	pop	r28
    e9a0:	1f 91       	pop	r17
    e9a2:	08 95       	ret

0000e9a4 <DS18B20>:
	}
}
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    e9a4:	80 91 d8 08 	lds	r24, 0x08D8
    e9a8:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
    e9ac:	88 23       	and	r24, r24
    e9ae:	19 f1       	breq	.+70     	; 0xe9f6 <DS18B20+0x52>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    e9b0:	80 91 da 01 	lds	r24, 0x01DA
    e9b4:	87 30       	cpi	r24, 0x07	; 7
    e9b6:	18 f0       	brcs	.+6      	; 0xe9be <DS18B20+0x1a>
    e9b8:	81 e0       	ldi	r24, 0x01	; 1
    e9ba:	80 93 da 01 	sts	0x01DA, r24
		
			switch(DS18B20_Mode){
    e9be:	80 91 da 01 	lds	r24, 0x01DA
    e9c2:	81 30       	cpi	r24, 0x01	; 1
    e9c4:	19 f0       	breq	.+6      	; 0xe9cc <DS18B20+0x28>
    e9c6:	84 30       	cpi	r24, 0x04	; 4
    e9c8:	89 f4       	brne	.+34     	; 0xe9ec <DS18B20+0x48>
    e9ca:	0a c0       	rjmp	.+20     	; 0xe9e0 <DS18B20+0x3c>
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    e9cc:	80 e0       	ldi	r24, 0x00	; 0
    e9ce:	0e 94 78 74 	call	0xe8f0	; 0xe8f0 <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    e9d2:	80 91 d8 08 	lds	r24, 0x08D8
    e9d6:	64 e6       	ldi	r22, 0x64	; 100
    e9d8:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    e9dc:	83 e0       	ldi	r24, 0x03	; 3
    e9de:	04 c0       	rjmp	.+8      	; 0xe9e8 <DS18B20+0x44>
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    e9e0:	80 e0       	ldi	r24, 0x00	; 0
    e9e2:	0e 94 8f 73 	call	0xe71e	; 0xe71e <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    e9e6:	86 e0       	ldi	r24, 0x06	; 6
    e9e8:	80 93 da 01 	sts	0x01DA, r24
				break;
			}
			DS18B20_Mode++;
    e9ec:	80 91 da 01 	lds	r24, 0x01DA
    e9f0:	8f 5f       	subi	r24, 0xFF	; 255
    e9f2:	80 93 da 01 	sts	0x01DA, r24
    e9f6:	08 95       	ret

0000e9f8 <ThermChanWrong>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
ThermChanWrong(uint8_t ChanN)
{
    e9f8:	ff 92       	push	r15
    e9fa:	0f 93       	push	r16
    e9fc:	1f 93       	push	r17
	return ThermWrong(prb(ThermFami+ChanN), erb(ThermType+ChanN), Temperature[ChanN]);
    e9fe:	08 2f       	mov	r16, r24
    ea00:	10 e0       	ldi	r17, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ea02:	f8 01       	movw	r30, r16
    ea04:	e5 5a       	subi	r30, 0xA5	; 165
    ea06:	fb 4f       	sbci	r31, 0xFB	; 251
    ea08:	f4 90       	lpm	r15, Z+
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ea0a:	c8 01       	movw	r24, r16
    ea0c:	88 5d       	subi	r24, 0xD8	; 216
    ea0e:	9e 4f       	sbci	r25, 0xFE	; 254
    ea10:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    ea14:	68 2f       	mov	r22, r24
    ea16:	00 0f       	add	r16, r16
    ea18:	11 1f       	adc	r17, r17
    ea1a:	00 59       	subi	r16, 0x90	; 144
    ea1c:	1a 4f       	sbci	r17, 0xFA	; 250
    ea1e:	f8 01       	movw	r30, r16
    ea20:	40 81       	ld	r20, Z
    ea22:	51 81       	ldd	r21, Z+1	; 0x01
    ea24:	8f 2d       	mov	r24, r15
    ea26:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <ThermWrong>
}
    ea2a:	1f 91       	pop	r17
    ea2c:	0f 91       	pop	r16
    ea2e:	ff 90       	pop	r15
    ea30:	08 95       	ret

0000ea32 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    ea32:	1f 93       	push	r17
    ea34:	cf 93       	push	r28
    ea36:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    ea38:	10 91 47 08 	lds	r17, 0x0847
    ea3c:	10 93 48 08 	sts	0x0848, r17
    ea40:	87 e2       	ldi	r24, 0x27	; 39
    ea42:	91 e0       	ldi	r25, 0x01	; 1
    ea44:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    ea48:	18 27       	eor	r17, r24
    ea4a:	10 93 49 08 	sts	0x0849, r17
    ea4e:	a0 e0       	ldi	r26, 0x00	; 0
    ea50:	b0 e0       	ldi	r27, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    ea52:	c1 e0       	ldi	r28, 0x01	; 1
    ea54:	d0 e0       	ldi	r29, 0x00	; 0
    ea56:	cd 01       	movw	r24, r26
    ea58:	87 70       	andi	r24, 0x07	; 7
    ea5a:	90 70       	andi	r25, 0x00	; 0
    ea5c:	9e 01       	movw	r18, r28
    ea5e:	02 c0       	rjmp	.+4      	; 0xea64 <DigitIn+0x32>
    ea60:	22 0f       	add	r18, r18
    ea62:	33 1f       	adc	r19, r19
    ea64:	8a 95       	dec	r24
    ea66:	e2 f7       	brpl	.-8      	; 0xea60 <DigitIn+0x2e>
    ea68:	42 2f       	mov	r20, r18

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ea6a:	cd 01       	movw	r24, r26
    ea6c:	13 e0       	ldi	r17, 0x03	; 3
    ea6e:	88 0f       	add	r24, r24
    ea70:	99 1f       	adc	r25, r25
    ea72:	1a 95       	dec	r17
    ea74:	e1 f7       	brne	.-8      	; 0xea6e <DigitIn+0x3c>
    ea76:	fc 01       	movw	r30, r24
    ea78:	e1 5c       	subi	r30, 0xC1	; 193
    ea7a:	f6 4b       	sbci	r31, 0xB6	; 182
    ea7c:	e4 91       	lpm	r30, Z+
    ea7e:	bd 01       	movw	r22, r26
    ea80:	66 0f       	add	r22, r22
    ea82:	77 1f       	adc	r23, r23
    ea84:	9c 01       	movw	r18, r24
    ea86:	2a 5f       	subi	r18, 0xFA	; 250
    ea88:	3f 4f       	sbci	r19, 0xFF	; 255
			if(prb(&DI_M[D_N].Inversion)){
    ea8a:	ee 23       	and	r30, r30
    ea8c:	99 f0       	breq	.+38     	; 0xeab4 <DigitIn+0x82>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ea8e:	cb 01       	movw	r24, r22
    ea90:	88 0f       	add	r24, r24
    ea92:	99 1f       	adc	r25, r25
    ea94:	88 0f       	add	r24, r24
    ea96:	99 1f       	adc	r25, r25
    ea98:	84 5c       	subi	r24, 0xC4	; 196
    ea9a:	96 4b       	sbci	r25, 0xB6	; 182
    ea9c:	fc 01       	movw	r30, r24
    ea9e:	65 91       	lpm	r22, Z+
    eaa0:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    eaa2:	28 5c       	subi	r18, 0xC8	; 200
    eaa4:	36 4b       	sbci	r19, 0xB6	; 182
    eaa6:	f9 01       	movw	r30, r18
    eaa8:	84 91       	lpm	r24, Z+
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    eaaa:	fb 01       	movw	r30, r22
    eaac:	90 81       	ld	r25, Z
    eaae:	89 23       	and	r24, r25
    eab0:	99 f0       	breq	.+38     	; 0xead8 <DigitIn+0xa6>
    eab2:	17 c0       	rjmp	.+46     	; 0xeae2 <DigitIn+0xb0>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    eab4:	cb 01       	movw	r24, r22
    eab6:	88 0f       	add	r24, r24
    eab8:	99 1f       	adc	r25, r25
    eaba:	88 0f       	add	r24, r24
    eabc:	99 1f       	adc	r25, r25
    eabe:	84 5c       	subi	r24, 0xC4	; 196
    eac0:	96 4b       	sbci	r25, 0xB6	; 182
    eac2:	fc 01       	movw	r30, r24
    eac4:	65 91       	lpm	r22, Z+
    eac6:	74 91       	lpm	r23, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    eac8:	28 5c       	subi	r18, 0xC8	; 200
    eaca:	36 4b       	sbci	r19, 0xB6	; 182
    eacc:	f9 01       	movw	r30, r18
    eace:	84 91       	lpm	r24, Z+
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    ead0:	fb 01       	movw	r30, r22
    ead2:	90 81       	ld	r25, Z
    ead4:	89 23       	and	r24, r25
    ead6:	29 f0       	breq	.+10     	; 0xeae2 <DigitIn+0xb0>
					DigInput.State[Byte] &=~Bit;
    ead8:	40 95       	com	r20
    eada:	80 91 47 08 	lds	r24, 0x0847
    eade:	48 23       	and	r20, r24
    eae0:	03 c0       	rjmp	.+6      	; 0xeae8 <DigitIn+0xb6>
				else
					DigInput.State[Byte]  |=Bit;
    eae2:	80 91 47 08 	lds	r24, 0x0847
    eae6:	48 2b       	or	r20, r24
    eae8:	40 93 47 08 	sts	0x0847, r20
    eaec:	11 96       	adiw	r26, 0x01	; 1
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    eaee:	a4 30       	cpi	r26, 0x04	; 4
    eaf0:	b1 05       	cpc	r27, r1
    eaf2:	09 f0       	breq	.+2      	; 0xeaf6 <DigitIn+0xc4>
    eaf4:	b0 cf       	rjmp	.-160    	; 0xea56 <DigitIn+0x24>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    eaf6:	df 91       	pop	r29
    eaf8:	cf 91       	pop	r28
    eafa:	1f 91       	pop	r17
    eafc:	08 95       	ret

0000eafe <strcpy_EE>:
	}//while
	return GSM_RxCharN;
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    eafe:	cf 92       	push	r12
    eb00:	df 92       	push	r13
    eb02:	ef 92       	push	r14
    eb04:	ff 92       	push	r15
    eb06:	1f 93       	push	r17
    eb08:	cf 93       	push	r28
    eb0a:	df 93       	push	r29
    eb0c:	6c 01       	movw	r12, r24
    eb0e:	7b 01       	movw	r14, r22
    eb10:	10 e0       	ldi	r17, 0x00	; 0
    eb12:	04 c0       	rjmp	.+8      	; 0xeb1c <strcpy_EE+0x1e>
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
		str_RAM[i] = (char)erb(&str_EE[i]);
    eb14:	cc 0d       	add	r28, r12
    eb16:	dd 1d       	adc	r29, r13
    eb18:	88 83       	st	Y, r24
		i++;
    eb1a:	1f 5f       	subi	r17, 0xFF	; 255
}
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
	uint8_t i=0;
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    eb1c:	c1 2f       	mov	r28, r17
    eb1e:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    eb20:	c7 01       	movw	r24, r14
    eb22:	8c 0f       	add	r24, r28
    eb24:	9d 1f       	adc	r25, r29
    eb26:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    eb2a:	88 23       	and	r24, r24
    eb2c:	11 f0       	breq	.+4      	; 0xeb32 <strcpy_EE+0x34>
    eb2e:	80 32       	cpi	r24, 0x20	; 32
    eb30:	89 f7       	brne	.-30     	; 0xeb14 <strcpy_EE+0x16>
		str_RAM[i] = (char)erb(&str_EE[i]);
		i++;
	}
	return i;	
}
    eb32:	81 2f       	mov	r24, r17
    eb34:	df 91       	pop	r29
    eb36:	cf 91       	pop	r28
    eb38:	1f 91       	pop	r17
    eb3a:	ff 90       	pop	r15
    eb3c:	ef 90       	pop	r14
    eb3e:	df 90       	pop	r13
    eb40:	cf 90       	pop	r12
    eb42:	08 95       	ret

0000eb44 <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    eb44:	ef 92       	push	r14
    eb46:	ff 92       	push	r15
    eb48:	0f 93       	push	r16
    eb4a:	1f 93       	push	r17
    eb4c:	cf 93       	push	r28
    eb4e:	df 93       	push	r29
    eb50:	ec 01       	movw	r28, r24
    eb52:	16 2f       	mov	r17, r22
    eb54:	f4 2e       	mov	r15, r20
    eb56:	e2 2e       	mov	r14, r18
    eb58:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    eb5c:	81 17       	cp	r24, r17
    eb5e:	b1 f4       	brne	.+44     	; 0xeb8c <IP_E_compare_Const+0x48>
    eb60:	ce 01       	movw	r24, r28
    eb62:	01 96       	adiw	r24, 0x01	; 1
    eb64:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    eb68:	8f 15       	cp	r24, r15
    eb6a:	81 f4       	brne	.+32     	; 0xeb8c <IP_E_compare_Const+0x48>
    eb6c:	ce 01       	movw	r24, r28
    eb6e:	02 96       	adiw	r24, 0x02	; 2
    eb70:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    eb74:	8e 15       	cp	r24, r14
    eb76:	51 f4       	brne	.+20     	; 0xeb8c <IP_E_compare_Const+0x48>
    eb78:	ce 01       	movw	r24, r28
    eb7a:	03 96       	adiw	r24, 0x03	; 3
    eb7c:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    eb80:	90 e0       	ldi	r25, 0x00	; 0
    eb82:	80 13       	cpse	r24, r16
    eb84:	91 e0       	ldi	r25, 0x01	; 1
    eb86:	81 e0       	ldi	r24, 0x01	; 1
    eb88:	98 27       	eor	r25, r24
    eb8a:	01 c0       	rjmp	.+2      	; 0xeb8e <IP_E_compare_Const+0x4a>
    eb8c:	90 e0       	ldi	r25, 0x00	; 0
	else return 0;
}
    eb8e:	89 2f       	mov	r24, r25
    eb90:	df 91       	pop	r29
    eb92:	cf 91       	pop	r28
    eb94:	1f 91       	pop	r17
    eb96:	0f 91       	pop	r16
    eb98:	ff 90       	pop	r15
    eb9a:	ef 90       	pop	r14
    eb9c:	08 95       	ret

0000eb9e <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    eb9e:	6f 92       	push	r6
    eba0:	7f 92       	push	r7
    eba2:	8f 92       	push	r8
    eba4:	9f 92       	push	r9
    eba6:	af 92       	push	r10
    eba8:	bf 92       	push	r11
    ebaa:	cf 92       	push	r12
    ebac:	df 92       	push	r13
    ebae:	ef 92       	push	r14
    ebb0:	ff 92       	push	r15
    ebb2:	0f 93       	push	r16
    ebb4:	1f 93       	push	r17
    ebb6:	df 93       	push	r29
    ebb8:	cf 93       	push	r28
    ebba:	cd b7       	in	r28, 0x3d	; 61
    ebbc:	de b7       	in	r29, 0x3e	; 62
    ebbe:	a6 97       	sbiw	r28, 0x26	; 38
    ebc0:	0f b6       	in	r0, 0x3f	; 63
    ebc2:	f8 94       	cli
    ebc4:	de bf       	out	0x3e, r29	; 62
    ebc6:	0f be       	out	0x3f, r0	; 63
    ebc8:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    ebca:	80 91 e8 08 	lds	r24, 0x08E8
    ebce:	88 23       	and	r24, r24
    ebd0:	31 f0       	breq	.+12     	; 0xebde <GSM_Cycle+0x40>
    ebd2:	82 30       	cpi	r24, 0x02	; 2
    ebd4:	11 f0       	breq	.+4      	; 0xebda <GSM_Cycle+0x3c>
    ebd6:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ebda:	0c 94 82 82 	jmp	0x10504	; 0x10504 <GSM_Cycle+0x1966>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    ebde:	80 91 a4 05 	lds	r24, 0x05A4
    ebe2:	e8 2f       	mov	r30, r24
    ebe4:	f0 e0       	ldi	r31, 0x00	; 0
    ebe6:	ec 35       	cpi	r30, 0x5C	; 92
    ebe8:	f1 05       	cpc	r31, r1
    ebea:	10 f0       	brcs	.+4      	; 0xebf0 <GSM_Cycle+0x52>
    ebec:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ebf0:	ee 55       	subi	r30, 0x5E	; 94
    ebf2:	ff 4f       	sbci	r31, 0xFF	; 255
    ebf4:	ee 0f       	add	r30, r30
    ebf6:	ff 1f       	adc	r31, r31
    ebf8:	05 90       	lpm	r0, Z+
    ebfa:	f4 91       	lpm	r31, Z+
    ebfc:	e0 2d       	mov	r30, r0
    ebfe:	09 94       	ijmp

		case GSM_PowerOn:
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    ec00:	80 91 5a 03 	lds	r24, 0x035A
    ec04:	60 ed       	ldi	r22, 0xD0	; 208
    ec06:	77 e0       	ldi	r23, 0x07	; 7
    ec08:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    ec0c:	80 91 5d 03 	lds	r24, 0x035D
    ec10:	40 e0       	ldi	r20, 0x00	; 0
    ec12:	56 ed       	ldi	r21, 0xD6	; 214
    ec14:	63 e8       	ldi	r22, 0x83	; 131
    ec16:	70 e0       	ldi	r23, 0x00	; 0
    ec18:	0e 94 af 27 	call	0x4f5e	; 0x4f5e <StartTimer32>
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
	sei();
}
void GSM_PWRCNTRL_ON(void){
	cli();
    ec1c:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    ec1e:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    ec20:	78 94       	sei
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    ec22:	8f ef       	ldi	r24, 0xFF	; 255
    ec24:	80 93 44 08 	sts	0x0844, r24
	GSM_RX_FIFO_End = 255;
    ec28:	80 93 83 05 	sts	0x0583, r24
	GSM_RxCharN = 0;
    ec2c:	10 92 ac 0c 	sts	0x0CAC, r1
		case GSM_PowerOn:
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
			GSM_PWRCNTRL_ON();
			InitFIFO();
			GSM_Modem = NOT_RECOGNIZED;
    ec30:	10 92 ee 07 	sts	0x07EE, r1
			GSM_State = GSM_WAIT_RDY;
    ec34:	81 e0       	ldi	r24, 0x01	; 1
    ec36:	80 93 a4 05 	sts	0x05A4, r24
    ec3a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    ec3e:	84 e4       	ldi	r24, 0x44	; 68
    ec40:	92 e0       	ldi	r25, 0x02	; 2
    ec42:	6b e4       	ldi	r22, 0x4B	; 75
    ec44:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ec48:	88 23       	and	r24, r24
    ec4a:	11 f4       	brne	.+4      	; 0xec50 <GSM_Cycle+0xb2>
    ec4c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ec50:	80 91 a4 05 	lds	r24, 0x05A4
    ec54:	8f 5f       	subi	r24, 0xFF	; 255
    ec56:	80 93 a4 05 	sts	0x05A4, r24
    ec5a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    ec5e:	80 e3       	ldi	r24, 0x30	; 48
    ec60:	93 e0       	ldi	r25, 0x03	; 3
    ec62:	68 e8       	ldi	r22, 0x88	; 136
    ec64:	73 e1       	ldi	r23, 0x13	; 19
    ec66:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ec6a:	80 91 a4 05 	lds	r24, 0x05A4
    ec6e:	8f 5f       	subi	r24, 0xFF	; 255
    ec70:	80 93 a4 05 	sts	0x05A4, r24
    ec74:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    ec78:	80 91 5a 03 	lds	r24, 0x035A
    ec7c:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    ec80:	88 23       	and	r24, r24
    ec82:	19 f0       	breq	.+6      	; 0xec8a <GSM_Cycle+0xec>
    ec84:	8b e4       	ldi	r24, 0x4B	; 75
    ec86:	80 93 a4 05 	sts	0x05A4, r24
			if(GetStringFromFIFO()){
    ec8a:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    ec8e:	88 23       	and	r24, r24
    ec90:	e9 f0       	breq	.+58     	; 0xeccc <GSM_Cycle+0x12e>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    ec92:	84 ef       	ldi	r24, 0xF4	; 244
    ec94:	98 e0       	ldi	r25, 0x08	; 8
    ec96:	67 e2       	ldi	r22, 0x27	; 39
    ec98:	72 e0       	ldi	r23, 0x02	; 2
    ec9a:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    ec9e:	89 2b       	or	r24, r25
    eca0:	19 f4       	brne	.+6      	; 0xeca8 <GSM_Cycle+0x10a>
    eca2:	81 e0       	ldi	r24, 0x01	; 1
    eca4:	80 93 ee 07 	sts	0x07EE, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    eca8:	84 ef       	ldi	r24, 0xF4	; 244
    ecaa:	98 e0       	ldi	r25, 0x08	; 8
    ecac:	66 e3       	ldi	r22, 0x36	; 54
    ecae:	72 e0       	ldi	r23, 0x02	; 2
    ecb0:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
    ecb4:	89 2b       	or	r24, r25
    ecb6:	19 f4       	brne	.+6      	; 0xecbe <GSM_Cycle+0x120>
    ecb8:	82 e0       	ldi	r24, 0x02	; 2
    ecba:	80 93 ee 07 	sts	0x07EE, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    ecbe:	80 91 ee 07 	lds	r24, 0x07EE
    ecc2:	88 23       	and	r24, r24
    ecc4:	19 f0       	breq	.+6      	; 0xeccc <GSM_Cycle+0x12e>
    ecc6:	86 e0       	ldi	r24, 0x06	; 6
    ecc8:	80 93 a4 05 	sts	0x05A4, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    eccc:	8e e5       	ldi	r24, 0x5E	; 94
    ecce:	92 e0       	ldi	r25, 0x02	; 2
    ecd0:	6b e4       	ldi	r22, 0x4B	; 75
    ecd2:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ecd6:	88 23       	and	r24, r24
    ecd8:	11 f4       	brne	.+4      	; 0xecde <GSM_Cycle+0x140>
    ecda:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    ecde:	80 91 ee 07 	lds	r24, 0x07EE
    ece2:	82 30       	cpi	r24, 0x02	; 2
    ece4:	29 f4       	brne	.+10     	; 0xecf0 <GSM_Cycle+0x152>
    ece6:	87 e0       	ldi	r24, 0x07	; 7
    ece8:	80 93 a4 05 	sts	0x05A4, r24
    ecec:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				else GSM_State = GSM_SEND_E0;
    ecf0:	88 e0       	ldi	r24, 0x08	; 8
    ecf2:	80 93 a4 05 	sts	0x05A4, r24
    ecf6:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    ecfa:	89 e6       	ldi	r24, 0x69	; 105
    ecfc:	92 e0       	ldi	r25, 0x02	; 2
    ecfe:	6b e4       	ldi	r22, 0x4B	; 75
    ed00:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ed04:	88 23       	and	r24, r24
    ed06:	11 f4       	brne	.+4      	; 0xed0c <GSM_Cycle+0x16e>
    ed08:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ed0c:	80 91 a4 05 	lds	r24, 0x05A4
    ed10:	8f 5f       	subi	r24, 0xFF	; 255
    ed12:	80 93 a4 05 	sts	0x05A4, r24
    ed16:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    ed1a:	8b e2       	ldi	r24, 0x2B	; 43
    ed1c:	93 e0       	ldi	r25, 0x03	; 3
    ed1e:	64 e6       	ldi	r22, 0x64	; 100
    ed20:	70 e0       	ldi	r23, 0x00	; 0
    ed22:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ed26:	80 91 a4 05 	lds	r24, 0x05A4
    ed2a:	8f 5f       	subi	r24, 0xFF	; 255
    ed2c:	80 93 a4 05 	sts	0x05A4, r24
    ed30:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ed34:	83 eb       	ldi	r24, 0xB3	; 179
    ed36:	92 e0       	ldi	r25, 0x02	; 2
    ed38:	6b e4       	ldi	r22, 0x4B	; 75
    ed3a:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ed3e:	88 23       	and	r24, r24
    ed40:	11 f4       	brne	.+4      	; 0xed46 <GSM_Cycle+0x1a8>
    ed42:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ed46:	80 91 a4 05 	lds	r24, 0x05A4
    ed4a:	8f 5f       	subi	r24, 0xFF	; 255
    ed4c:	80 93 a4 05 	sts	0x05A4, r24
    ed50:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    ed54:	88 e3       	ldi	r24, 0x38	; 56
    ed56:	93 e0       	ldi	r25, 0x03	; 3
    ed58:	64 e6       	ldi	r22, 0x64	; 100
    ed5a:	70 e0       	ldi	r23, 0x00	; 0
    ed5c:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ed60:	80 91 a4 05 	lds	r24, 0x05A4
    ed64:	8f 5f       	subi	r24, 0xFF	; 255
    ed66:	80 93 a4 05 	sts	0x05A4, r24
    ed6a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ed6e:	83 eb       	ldi	r24, 0xB3	; 179
    ed70:	92 e0       	ldi	r25, 0x02	; 2
    ed72:	6b e4       	ldi	r22, 0x4B	; 75
    ed74:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ed78:	88 23       	and	r24, r24
    ed7a:	11 f4       	brne	.+4      	; 0xed80 <GSM_Cycle+0x1e2>
    ed7c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ed80:	80 91 a4 05 	lds	r24, 0x05A4
    ed84:	8f 5f       	subi	r24, 0xFF	; 255
    ed86:	80 93 a4 05 	sts	0x05A4, r24
    ed8a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_CCID:
			GSM_RxStr[19] = 0;
    ed8e:	10 92 07 09 	sts	0x0907, r1
			GSM_Execute_Command(AT_CCID,300*GSM_DEBUG_DELAY); GSM_State++;
    ed92:	82 e4       	ldi	r24, 0x42	; 66
    ed94:	93 e0       	ldi	r25, 0x03	; 3
    ed96:	6c e2       	ldi	r22, 0x2C	; 44
    ed98:	71 e0       	ldi	r23, 0x01	; 1
    ed9a:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ed9e:	80 91 a4 05 	lds	r24, 0x05A4
    eda2:	8f 5f       	subi	r24, 0xFF	; 255
    eda4:	80 93 a4 05 	sts	0x05A4, r24
    eda8:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CCID_READ:
			//8938001300106446004F
			if(GetStringFromFIFO() && (GSM_RxStr[19] == 'F') ){
    edac:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    edb0:	88 23       	and	r24, r24
    edb2:	11 f4       	brne	.+4      	; 0xedb8 <GSM_Cycle+0x21a>
    edb4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    edb8:	80 91 07 09 	lds	r24, 0x0907
    edbc:	86 34       	cpi	r24, 0x46	; 70
    edbe:	11 f0       	breq	.+4      	; 0xedc4 <GSM_Cycle+0x226>
    edc0:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				GSM_RxStr[18] = ' ';
    edc4:	b0 e2       	ldi	r27, 0x20	; 32
    edc6:	fb 2e       	mov	r15, r27
    edc8:	f0 92 06 09 	sts	0x0906, r15
				sscanf_P(GSM_RxStr+9,PSTR("%lud"), (long unsigned int*)&ICCID2);
    edcc:	00 d0       	rcall	.+0      	; 0xedce <GSM_Cycle+0x230>
    edce:	00 d0       	rcall	.+0      	; 0xedd0 <GSM_Cycle+0x232>
    edd0:	00 d0       	rcall	.+0      	; 0xedd2 <GSM_Cycle+0x234>
    edd2:	ed b7       	in	r30, 0x3d	; 61
    edd4:	fe b7       	in	r31, 0x3e	; 62
    edd6:	31 96       	adiw	r30, 0x01	; 1
    edd8:	0d ef       	ldi	r16, 0xFD	; 253
    edda:	18 e0       	ldi	r17, 0x08	; 8
    eddc:	ad b7       	in	r26, 0x3d	; 61
    edde:	be b7       	in	r27, 0x3e	; 62
    ede0:	12 96       	adiw	r26, 0x02	; 2
    ede2:	1c 93       	st	X, r17
    ede4:	0e 93       	st	-X, r16
    ede6:	11 97       	sbiw	r26, 0x01	; 1
    ede8:	87 ec       	ldi	r24, 0xC7	; 199
    edea:	99 e4       	ldi	r25, 0x49	; 73
    edec:	93 83       	std	Z+3, r25	; 0x03
    edee:	82 83       	std	Z+2, r24	; 0x02
    edf0:	8f e8       	ldi	r24, 0x8F	; 143
    edf2:	95 e0       	ldi	r25, 0x05	; 5
    edf4:	95 83       	std	Z+5, r25	; 0x05
    edf6:	84 83       	std	Z+4, r24	; 0x04
    edf8:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
				GSM_RxStr[9] = ' ';
    edfc:	f0 92 fd 08 	sts	0x08FD, r15
				sscanf_P(GSM_RxStr+5,PSTR("%u"), (unsigned int*)&ICCID1);
    ee00:	ed b7       	in	r30, 0x3d	; 61
    ee02:	fe b7       	in	r31, 0x3e	; 62
    ee04:	31 96       	adiw	r30, 0x01	; 1
    ee06:	04 50       	subi	r16, 0x04	; 4
    ee08:	10 40       	sbci	r17, 0x00	; 0
    ee0a:	ad b7       	in	r26, 0x3d	; 61
    ee0c:	be b7       	in	r27, 0x3e	; 62
    ee0e:	12 96       	adiw	r26, 0x02	; 2
    ee10:	1c 93       	st	X, r17
    ee12:	0e 93       	st	-X, r16
    ee14:	11 97       	sbiw	r26, 0x01	; 1
    ee16:	84 ec       	ldi	r24, 0xC4	; 196
    ee18:	99 e4       	ldi	r25, 0x49	; 73
    ee1a:	93 83       	std	Z+3, r25	; 0x03
    ee1c:	82 83       	std	Z+2, r24	; 0x02
    ee1e:	8f e8       	ldi	r24, 0x8F	; 143
    ee20:	9a e0       	ldi	r25, 0x0A	; 10
    ee22:	95 83       	std	Z+5, r25	; 0x05
    ee24:	84 83       	std	Z+4, r24	; 0x04
    ee26:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
				if((ICCID1 == 0) || (ICCID2==0)) GSM_State = GSM_ReStart1;
    ee2a:	40 91 8f 0a 	lds	r20, 0x0A8F
    ee2e:	50 91 90 0a 	lds	r21, 0x0A90
    ee32:	ed b7       	in	r30, 0x3d	; 61
    ee34:	fe b7       	in	r31, 0x3e	; 62
    ee36:	36 96       	adiw	r30, 0x06	; 6
    ee38:	0f b6       	in	r0, 0x3f	; 63
    ee3a:	f8 94       	cli
    ee3c:	fe bf       	out	0x3e, r31	; 62
    ee3e:	0f be       	out	0x3f, r0	; 63
    ee40:	ed bf       	out	0x3d, r30	; 61
    ee42:	41 15       	cp	r20, r1
    ee44:	51 05       	cpc	r21, r1
    ee46:	69 f0       	breq	.+26     	; 0xee62 <GSM_Cycle+0x2c4>
    ee48:	60 90 8f 05 	lds	r6, 0x058F
    ee4c:	70 90 90 05 	lds	r7, 0x0590
    ee50:	80 90 91 05 	lds	r8, 0x0591
    ee54:	90 90 92 05 	lds	r9, 0x0592
    ee58:	61 14       	cp	r6, r1
    ee5a:	71 04       	cpc	r7, r1
    ee5c:	81 04       	cpc	r8, r1
    ee5e:	91 04       	cpc	r9, r1
    ee60:	29 f4       	brne	.+10     	; 0xee6c <GSM_Cycle+0x2ce>
    ee62:	8b e4       	ldi	r24, 0x4B	; 75
    ee64:	80 93 a4 05 	sts	0x05A4, r24
    ee68:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				else{
					ICCID = (uint64_t)ICCID1 * 1000000000UL + (uint64_t)ICCID2;
    ee6c:	9a 01       	movw	r18, r20
    ee6e:	40 e0       	ldi	r20, 0x00	; 0
    ee70:	50 e0       	ldi	r21, 0x00	; 0
    ee72:	60 e0       	ldi	r22, 0x00	; 0
    ee74:	70 e0       	ldi	r23, 0x00	; 0
    ee76:	80 e0       	ldi	r24, 0x00	; 0
    ee78:	90 e0       	ldi	r25, 0x00	; 0
    ee7a:	aa 24       	eor	r10, r10
    ee7c:	aa ec       	ldi	r26, 0xCA	; 202
    ee7e:	ba 2e       	mov	r11, r26
    ee80:	fa e9       	ldi	r31, 0x9A	; 154
    ee82:	cf 2e       	mov	r12, r31
    ee84:	eb e3       	ldi	r30, 0x3B	; 59
    ee86:	de 2e       	mov	r13, r30
    ee88:	ee 24       	eor	r14, r14
    ee8a:	ff 24       	eor	r15, r15
    ee8c:	00 e0       	ldi	r16, 0x00	; 0
    ee8e:	10 e0       	ldi	r17, 0x00	; 0
    ee90:	0e 94 29 86 	call	0x10c52	; 0x10c52 <__muldi3>
    ee94:	64 01       	movw	r12, r8
    ee96:	53 01       	movw	r10, r6
    ee98:	92 2e       	mov	r9, r18
    ee9a:	9a 0c       	add	r9, r10
    ee9c:	f1 e0       	ldi	r31, 0x01	; 1
    ee9e:	92 16       	cp	r9, r18
    eea0:	08 f0       	brcs	.+2      	; 0xeea4 <GSM_Cycle+0x306>
    eea2:	f0 e0       	ldi	r31, 0x00	; 0
    eea4:	23 2f       	mov	r18, r19
    eea6:	2b 0d       	add	r18, r11
    eea8:	e1 e0       	ldi	r30, 0x01	; 1
    eeaa:	23 17       	cp	r18, r19
    eeac:	08 f0       	brcs	.+2      	; 0xeeb0 <GSM_Cycle+0x312>
    eeae:	e0 e0       	ldi	r30, 0x00	; 0
    eeb0:	bf 2f       	mov	r27, r31
    eeb2:	b2 0f       	add	r27, r18
    eeb4:	31 e0       	ldi	r19, 0x01	; 1
    eeb6:	b2 17       	cp	r27, r18
    eeb8:	08 f0       	brcs	.+2      	; 0xeebc <GSM_Cycle+0x31e>
    eeba:	30 e0       	ldi	r19, 0x00	; 0
    eebc:	e3 2b       	or	r30, r19
    eebe:	24 2f       	mov	r18, r20
    eec0:	2c 0d       	add	r18, r12
    eec2:	f1 e0       	ldi	r31, 0x01	; 1
    eec4:	24 17       	cp	r18, r20
    eec6:	08 f0       	brcs	.+2      	; 0xeeca <GSM_Cycle+0x32c>
    eec8:	f0 e0       	ldi	r31, 0x00	; 0
    eeca:	ae 2f       	mov	r26, r30
    eecc:	a2 0f       	add	r26, r18
    eece:	31 e0       	ldi	r19, 0x01	; 1
    eed0:	a2 17       	cp	r26, r18
    eed2:	08 f0       	brcs	.+2      	; 0xeed6 <GSM_Cycle+0x338>
    eed4:	30 e0       	ldi	r19, 0x00	; 0
    eed6:	f3 2b       	or	r31, r19
    eed8:	25 2f       	mov	r18, r21
    eeda:	2d 0d       	add	r18, r13
    eedc:	41 e0       	ldi	r20, 0x01	; 1
    eede:	25 17       	cp	r18, r21
    eee0:	08 f0       	brcs	.+2      	; 0xeee4 <GSM_Cycle+0x346>
    eee2:	40 e0       	ldi	r20, 0x00	; 0
    eee4:	ef 2f       	mov	r30, r31
    eee6:	e2 0f       	add	r30, r18
    eee8:	31 e0       	ldi	r19, 0x01	; 1
    eeea:	e2 17       	cp	r30, r18
    eeec:	08 f0       	brcs	.+2      	; 0xeef0 <GSM_Cycle+0x352>
    eeee:	30 e0       	ldi	r19, 0x00	; 0
    eef0:	34 2b       	or	r19, r20
    eef2:	36 0f       	add	r19, r22
    eef4:	21 e0       	ldi	r18, 0x01	; 1
    eef6:	36 17       	cp	r19, r22
    eef8:	08 f0       	brcs	.+2      	; 0xeefc <GSM_Cycle+0x35e>
    eefa:	20 e0       	ldi	r18, 0x00	; 0
    eefc:	52 2f       	mov	r21, r18
    eefe:	57 0f       	add	r21, r23
    ef00:	21 e0       	ldi	r18, 0x01	; 1
    ef02:	57 17       	cp	r21, r23
    ef04:	08 f0       	brcs	.+2      	; 0xef08 <GSM_Cycle+0x36a>
    ef06:	20 e0       	ldi	r18, 0x00	; 0
    ef08:	42 2f       	mov	r20, r18
    ef0a:	48 0f       	add	r20, r24
    ef0c:	21 e0       	ldi	r18, 0x01	; 1
    ef0e:	48 17       	cp	r20, r24
    ef10:	08 f0       	brcs	.+2      	; 0xef14 <GSM_Cycle+0x376>
    ef12:	20 e0       	ldi	r18, 0x00	; 0
    ef14:	29 0f       	add	r18, r25
    ef16:	90 92 de 08 	sts	0x08DE, r9
    ef1a:	b0 93 df 08 	sts	0x08DF, r27
    ef1e:	a0 93 e0 08 	sts	0x08E0, r26
    ef22:	e0 93 e1 08 	sts	0x08E1, r30
    ef26:	30 93 e2 08 	sts	0x08E2, r19
    ef2a:	50 93 e3 08 	sts	0x08E3, r21
    ef2e:	40 93 e4 08 	sts	0x08E4, r20
    ef32:	20 93 e5 08 	sts	0x08E5, r18
					GSM_State++;
    ef36:	80 91 a4 05 	lds	r24, 0x05A4
    ef3a:	8f 5f       	subi	r24, 0xFF	; 255
    ef3c:	80 93 a4 05 	sts	0x05A4, r24
    ef40:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				}
			}
			break;
		case GSM_WAIT_CCID_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ef44:	83 eb       	ldi	r24, 0xB3	; 179
    ef46:	92 e0       	ldi	r25, 0x02	; 2
    ef48:	6b e4       	ldi	r22, 0x4B	; 75
    ef4a:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ef4e:	88 23       	and	r24, r24
    ef50:	11 f4       	brne	.+4      	; 0xef56 <GSM_Cycle+0x3b8>
    ef52:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ef56:	80 91 a4 05 	lds	r24, 0x05A4
    ef5a:	8f 5f       	subi	r24, 0xFF	; 255
    ef5c:	80 93 a4 05 	sts	0x05A4, r24
    ef60:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    ef64:	85 e5       	ldi	r24, 0x55	; 85
    ef66:	93 e0       	ldi	r25, 0x03	; 3
    ef68:	64 e6       	ldi	r22, 0x64	; 100
    ef6a:	70 e0       	ldi	r23, 0x00	; 0
    ef6c:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ef70:	80 91 a4 05 	lds	r24, 0x05A4
    ef74:	8f 5f       	subi	r24, 0xFF	; 255
    ef76:	80 93 a4 05 	sts	0x05A4, r24
    ef7a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ef7e:	83 eb       	ldi	r24, 0xB3	; 179
    ef80:	92 e0       	ldi	r25, 0x02	; 2
    ef82:	6b e4       	ldi	r22, 0x4B	; 75
    ef84:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    ef88:	88 23       	and	r24, r24
    ef8a:	11 f4       	brne	.+4      	; 0xef90 <GSM_Cycle+0x3f2>
    ef8c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    ef90:	80 91 a4 05 	lds	r24, 0x05A4
    ef94:	8f 5f       	subi	r24, 0xFF	; 255
    ef96:	80 93 a4 05 	sts	0x05A4, r24
    ef9a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    ef9e:	8f e5       	ldi	r24, 0x5F	; 95
    efa0:	93 e0       	ldi	r25, 0x03	; 3
    efa2:	64 e6       	ldi	r22, 0x64	; 100
    efa4:	70 e0       	ldi	r23, 0x00	; 0
    efa6:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    efaa:	80 91 a4 05 	lds	r24, 0x05A4
    efae:	8f 5f       	subi	r24, 0xFF	; 255
    efb0:	80 93 a4 05 	sts	0x05A4, r24
    efb4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    efb8:	83 eb       	ldi	r24, 0xB3	; 179
    efba:	92 e0       	ldi	r25, 0x02	; 2
    efbc:	6b e4       	ldi	r22, 0x4B	; 75
    efbe:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    efc2:	88 23       	and	r24, r24
    efc4:	11 f4       	brne	.+4      	; 0xefca <GSM_Cycle+0x42c>
    efc6:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    efca:	80 91 a4 05 	lds	r24, 0x05A4
    efce:	8f 5f       	subi	r24, 0xFF	; 255
    efd0:	80 93 a4 05 	sts	0x05A4, r24
    efd4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
    efd8:	80 91 b2 0d 	lds	r24, 0x0DB2
    efdc:	88 23       	and	r24, r24
    efde:	19 f0       	breq	.+6      	; 0xefe6 <GSM_Cycle+0x448>
    efe0:	83 ea       	ldi	r24, 0xA3	; 163
    efe2:	93 e0       	ldi	r25, 0x03	; 3
    efe4:	02 c0       	rjmp	.+4      	; 0xefea <GSM_Cycle+0x44c>
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    efe6:	87 e9       	ldi	r24, 0x97	; 151
    efe8:	93 e0       	ldi	r25, 0x03	; 3
    efea:	64 e6       	ldi	r22, 0x64	; 100
    efec:	70 e0       	ldi	r23, 0x00	; 0
    efee:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
			GSM_State++; 
    eff2:	80 91 a4 05 	lds	r24, 0x05A4
    eff6:	8f 5f       	subi	r24, 0xFF	; 255
    eff8:	80 93 a4 05 	sts	0x05A4, r24
    effc:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    f000:	83 eb       	ldi	r24, 0xB3	; 179
    f002:	92 e0       	ldi	r25, 0x02	; 2
    f004:	6b e4       	ldi	r22, 0x4B	; 75
    f006:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f00a:	88 23       	and	r24, r24
    f00c:	11 f4       	brne	.+4      	; 0xf012 <GSM_Cycle+0x474>
    f00e:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				if(GSM_MultiCon){
    f012:	80 91 b2 0d 	lds	r24, 0x0DB2
    f016:	88 23       	and	r24, r24
    f018:	59 f0       	breq	.+22     	; 0xf030 <GSM_Cycle+0x492>
					GSM_State = GSM_WAIT_1;
    f01a:	87 e1       	ldi	r24, 0x17	; 23
    f01c:	80 93 a4 05 	sts	0x05A4, r24
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
    f020:	80 91 5a 03 	lds	r24, 0x035A
    f024:	68 ee       	ldi	r22, 0xE8	; 232
    f026:	73 e0       	ldi	r23, 0x03	; 3
    f028:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    f02c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				}
				else GSM_State++;
    f030:	80 91 a4 05 	lds	r24, 0x05A4
    f034:	8f 5f       	subi	r24, 0xFF	; 255
    f036:	80 93 a4 05 	sts	0x05A4, r24
    f03a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_SEND_CIPMODE:
			if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
    f03e:	80 91 b2 0d 	lds	r24, 0x0DB2
    f042:	88 23       	and	r24, r24
    f044:	19 f0       	breq	.+6      	; 0xf04c <GSM_Cycle+0x4ae>
    f046:	8d e7       	ldi	r24, 0x7D	; 125
    f048:	93 e0       	ldi	r25, 0x03	; 3
    f04a:	02 c0       	rjmp	.+4      	; 0xf050 <GSM_Cycle+0x4b2>
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    f04c:	8a e8       	ldi	r24, 0x8A	; 138
    f04e:	93 e0       	ldi	r25, 0x03	; 3
    f050:	64 e6       	ldi	r22, 0x64	; 100
    f052:	70 e0       	ldi	r23, 0x00	; 0
    f054:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
			GSM_State++;
    f058:	80 91 a4 05 	lds	r24, 0x05A4
    f05c:	8f 5f       	subi	r24, 0xFF	; 255
    f05e:	80 93 a4 05 	sts	0x05A4, r24
    f062:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    f066:	83 eb       	ldi	r24, 0xB3	; 179
    f068:	92 e0       	ldi	r25, 0x02	; 2
    f06a:	6b e4       	ldi	r22, 0x4B	; 75
    f06c:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f070:	88 23       	and	r24, r24
    f072:	11 f4       	brne	.+4      	; 0xf078 <GSM_Cycle+0x4da>
    f074:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				GSM_State++;
    f078:	80 91 a4 05 	lds	r24, 0x05A4
    f07c:	8f 5f       	subi	r24, 0xFF	; 255
    f07e:	80 93 a4 05 	sts	0x05A4, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    f082:	80 91 5a 03 	lds	r24, 0x035A
    f086:	68 ee       	ldi	r22, 0xE8	; 232
    f088:	73 e0       	ldi	r23, 0x03	; 3
    f08a:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    f08e:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    f092:	10 92 69 03 	sts	0x0369, r1
			GSM_State++;
    f096:	80 91 a4 05 	lds	r24, 0x05A4
    f09a:	8f 5f       	subi	r24, 0xFF	; 255
    f09c:	80 93 a4 05 	sts	0x05A4, r24
    f0a0:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    f0a4:	8f ea       	ldi	r24, 0xAF	; 175
    f0a6:	93 e0       	ldi	r25, 0x03	; 3
    f0a8:	64 ef       	ldi	r22, 0xF4	; 244
    f0aa:	71 e0       	ldi	r23, 0x01	; 1
    f0ac:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    f0b0:	80 91 69 03 	lds	r24, 0x0369
    f0b4:	8f 5f       	subi	r24, 0xFF	; 255
    f0b6:	80 93 69 03 	sts	0x0369, r24
    f0ba:	80 91 a4 05 	lds	r24, 0x05A4
    f0be:	8f 5f       	subi	r24, 0xFF	; 255
    f0c0:	80 93 a4 05 	sts	0x05A4, r24
    f0c4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    f0c8:	80 91 69 03 	lds	r24, 0x0369
    f0cc:	85 31       	cpi	r24, 0x15	; 21
    f0ce:	18 f0       	brcs	.+6      	; 0xf0d6 <GSM_Cycle+0x538>
    f0d0:	8b e4       	ldi	r24, 0x4B	; 75
    f0d2:	80 93 a4 05 	sts	0x05A4, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    f0d6:	83 eb       	ldi	r24, 0xB3	; 179
    f0d8:	92 e0       	ldi	r25, 0x02	; 2
    f0da:	68 e1       	ldi	r22, 0x18	; 24
    f0dc:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f0e0:	88 23       	and	r24, r24
    f0e2:	11 f4       	brne	.+4      	; 0xf0e8 <GSM_Cycle+0x54a>
    f0e4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f0e8:	80 91 a4 05 	lds	r24, 0x05A4
    f0ec:	8f 5f       	subi	r24, 0xFF	; 255
    f0ee:	80 93 a4 05 	sts	0x05A4, r24
    f0f2:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    f0f6:	80 91 d1 01 	lds	r24, 0x01D1
    f0fa:	80 ff       	sbrs	r24, 0
    f0fc:	77 c0       	rjmp	.+238    	; 0xf1ec <GSM_Cycle+0x64e>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    f0fe:	00 d0       	rcall	.+0      	; 0xf100 <GSM_Cycle+0x562>
    f100:	00 d0       	rcall	.+0      	; 0xf102 <GSM_Cycle+0x564>
    f102:	81 ea       	ldi	r24, 0xA1	; 161
    f104:	9b e0       	ldi	r25, 0x0B	; 11
    f106:	ad b7       	in	r26, 0x3d	; 61
    f108:	be b7       	in	r27, 0x3e	; 62
    f10a:	12 96       	adiw	r26, 0x02	; 2
    f10c:	9c 93       	st	X, r25
    f10e:	8e 93       	st	-X, r24
    f110:	11 97       	sbiw	r26, 0x01	; 1
    f112:	0a eb       	ldi	r16, 0xBA	; 186
    f114:	13 e0       	ldi	r17, 0x03	; 3
    f116:	14 96       	adiw	r26, 0x04	; 4
    f118:	1c 93       	st	X, r17
    f11a:	0e 93       	st	-X, r16
    f11c:	13 97       	sbiw	r26, 0x03	; 3
    f11e:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
    f122:	0f 90       	pop	r0
    f124:	0f 90       	pop	r0
    f126:	0f 90       	pop	r0
    f128:	0f 90       	pop	r0
    f12a:	c8 01       	movw	r24, r16
    f12c:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    f130:	80 93 c5 08 	sts	0x08C5, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    f134:	10 91 c5 08 	lds	r17, 0x08C5
    f138:	80 91 c5 08 	lds	r24, 0x08C5
    f13c:	90 e0       	ldi	r25, 0x00	; 0
    f13e:	8f 55       	subi	r24, 0x5F	; 95
    f140:	94 4f       	sbci	r25, 0xF4	; 244
    f142:	66 e0       	ldi	r22, 0x06	; 6
    f144:	70 e0       	ldi	r23, 0x00	; 0
    f146:	0e 94 7f 75 	call	0xeafe	; 0xeafe <strcpy_EE>
    f14a:	18 0f       	add	r17, r24
    f14c:	10 93 c5 08 	sts	0x08C5, r17
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    f150:	80 91 c5 08 	lds	r24, 0x08C5
    f154:	90 e0       	ldi	r25, 0x00	; 0
    f156:	8f 55       	subi	r24, 0x5F	; 95
    f158:	94 4f       	sbci	r25, 0xF4	; 244
    f15a:	65 ea       	ldi	r22, 0xA5	; 165
    f15c:	71 e0       	ldi	r23, 0x01	; 1
    f15e:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
    f162:	80 91 c5 08 	lds	r24, 0x08C5
    f166:	8d 5f       	subi	r24, 0xFD	; 253
    f168:	80 93 c5 08 	sts	0x08C5, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    f16c:	10 91 c5 08 	lds	r17, 0x08C5
    f170:	80 91 c5 08 	lds	r24, 0x08C5
    f174:	90 e0       	ldi	r25, 0x00	; 0
    f176:	8f 55       	subi	r24, 0x5F	; 95
    f178:	94 4f       	sbci	r25, 0xF4	; 244
    f17a:	64 e2       	ldi	r22, 0x24	; 36
    f17c:	70 e0       	ldi	r23, 0x00	; 0
    f17e:	0e 94 7f 75 	call	0xeafe	; 0xeafe <strcpy_EE>
    f182:	18 0f       	add	r17, r24
    f184:	10 93 c5 08 	sts	0x08C5, r17
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    f188:	80 91 c5 08 	lds	r24, 0x08C5
    f18c:	90 e0       	ldi	r25, 0x00	; 0
    f18e:	8f 55       	subi	r24, 0x5F	; 95
    f190:	94 4f       	sbci	r25, 0xF4	; 244
    f192:	65 ea       	ldi	r22, 0xA5	; 165
    f194:	71 e0       	ldi	r23, 0x01	; 1
    f196:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
    f19a:	80 91 c5 08 	lds	r24, 0x08C5
    f19e:	8d 5f       	subi	r24, 0xFD	; 253
    f1a0:	80 93 c5 08 	sts	0x08C5, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    f1a4:	10 91 c5 08 	lds	r17, 0x08C5
    f1a8:	80 91 c5 08 	lds	r24, 0x08C5
    f1ac:	90 e0       	ldi	r25, 0x00	; 0
    f1ae:	8f 55       	subi	r24, 0x5F	; 95
    f1b0:	94 4f       	sbci	r25, 0xF4	; 244
    f1b2:	68 e3       	ldi	r22, 0x38	; 56
    f1b4:	70 e0       	ldi	r23, 0x00	; 0
    f1b6:	0e 94 7f 75 	call	0xeafe	; 0xeafe <strcpy_EE>
    f1ba:	18 0f       	add	r17, r24
    f1bc:	10 93 c5 08 	sts	0x08C5, r17
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    f1c0:	80 91 c5 08 	lds	r24, 0x08C5
    f1c4:	90 e0       	ldi	r25, 0x00	; 0
    f1c6:	8f 55       	subi	r24, 0x5F	; 95
    f1c8:	94 4f       	sbci	r25, 0xF4	; 244
    f1ca:	69 ea       	ldi	r22, 0xA9	; 169
    f1cc:	71 e0       	ldi	r23, 0x01	; 1
    f1ce:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
    f1d2:	80 91 c5 08 	lds	r24, 0x08C5
    f1d6:	8e 5f       	subi	r24, 0xFE	; 254
    f1d8:	80 93 c5 08 	sts	0x08C5, r24
				GSM_SendFirstChar();
    f1dc:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    f1e0:	80 91 5a 03 	lds	r24, 0x035A
    f1e4:	6c e2       	ldi	r22, 0x2C	; 44
    f1e6:	71 e0       	ldi	r23, 0x01	; 1
    f1e8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			}
			GSM_State++;
    f1ec:	80 91 a4 05 	lds	r24, 0x05A4
    f1f0:	8f 5f       	subi	r24, 0xFF	; 255
    f1f2:	80 93 a4 05 	sts	0x05A4, r24
    f1f6:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    f1fa:	83 eb       	ldi	r24, 0xB3	; 179
    f1fc:	92 e0       	ldi	r25, 0x02	; 2
    f1fe:	6b e4       	ldi	r22, 0x4B	; 75
    f200:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f204:	88 23       	and	r24, r24
    f206:	11 f4       	brne	.+4      	; 0xf20c <GSM_Cycle+0x66e>
    f208:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f20c:	80 91 a4 05 	lds	r24, 0x05A4
    f210:	8f 5f       	subi	r24, 0xFF	; 255
    f212:	80 93 a4 05 	sts	0x05A4, r24
    f216:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    f21a:	89 ec       	ldi	r24, 0xC9	; 201
    f21c:	93 e0       	ldi	r25, 0x03	; 3
    f21e:	6c e2       	ldi	r22, 0x2C	; 44
    f220:	71 e0       	ldi	r23, 0x01	; 1
    f222:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    f226:	80 91 a4 05 	lds	r24, 0x05A4
    f22a:	8f 5f       	subi	r24, 0xFF	; 255
    f22c:	80 93 a4 05 	sts	0x05A4, r24
    f230:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    f234:	83 eb       	ldi	r24, 0xB3	; 179
    f236:	92 e0       	ldi	r25, 0x02	; 2
    f238:	6b e4       	ldi	r22, 0x4B	; 75
    f23a:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f23e:	88 23       	and	r24, r24
    f240:	11 f4       	brne	.+4      	; 0xf246 <GSM_Cycle+0x6a8>
    f242:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f246:	80 91 a4 05 	lds	r24, 0x05A4
    f24a:	8f 5f       	subi	r24, 0xFF	; 255
    f24c:	80 93 a4 05 	sts	0x05A4, r24
    f250:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    f254:	81 ed       	ldi	r24, 0xD1	; 209
    f256:	93 e0       	ldi	r25, 0x03	; 3
    f258:	60 ee       	ldi	r22, 0xE0	; 224
    f25a:	7e e2       	ldi	r23, 0x2E	; 46
    f25c:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    f260:	80 91 a4 05 	lds	r24, 0x05A4
    f264:	8f 5f       	subi	r24, 0xFF	; 255
    f266:	80 93 a4 05 	sts	0x05A4, r24
    f26a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    f26e:	83 eb       	ldi	r24, 0xB3	; 179
    f270:	92 e0       	ldi	r25, 0x02	; 2
    f272:	6b e4       	ldi	r22, 0x4B	; 75
    f274:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f278:	88 23       	and	r24, r24
    f27a:	11 f4       	brne	.+4      	; 0xf280 <GSM_Cycle+0x6e2>
    f27c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f280:	80 91 a4 05 	lds	r24, 0x05A4
    f284:	8f 5f       	subi	r24, 0xFF	; 255
    f286:	80 93 a4 05 	sts	0x05A4, r24
    f28a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    f28e:	8a ed       	ldi	r24, 0xDA	; 218
    f290:	93 e0       	ldi	r25, 0x03	; 3
    f292:	68 ee       	ldi	r22, 0xE8	; 232
    f294:	73 e0       	ldi	r23, 0x03	; 3
    f296:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    f29a:	80 91 a4 05 	lds	r24, 0x05A4
    f29e:	8f 5f       	subi	r24, 0xFF	; 255
    f2a0:	80 93 a4 05 	sts	0x05A4, r24
    f2a4:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    f2a8:	80 91 5a 03 	lds	r24, 0x035A
    f2ac:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    f2b0:	88 23       	and	r24, r24
    f2b2:	19 f0       	breq	.+6      	; 0xf2ba <GSM_Cycle+0x71c>
    f2b4:	8b e4       	ldi	r24, 0x4B	; 75
    f2b6:	80 93 a4 05 	sts	0x05A4, r24
			if(GetStringFromFIFO()){
    f2ba:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    f2be:	88 23       	and	r24, r24
    f2c0:	11 f4       	brne	.+4      	; 0xf2c6 <GSM_Cycle+0x728>
    f2c2:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    f2c6:	10 92 84 0a 	sts	0x0A84, r1
	IP->IP2 = IP2;
    f2ca:	10 92 85 0a 	sts	0x0A85, r1
	IP->IP3 = IP3;
    f2ce:	10 92 86 0a 	sts	0x0A86, r1
	IP->IP4 = IP4;
    f2d2:	10 92 87 0a 	sts	0x0A87, r1
    f2d6:	20 e0       	ldi	r18, 0x00	; 0
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    f2d8:	a4 ef       	ldi	r26, 0xF4	; 244
    f2da:	b8 e0       	ldi	r27, 0x08	; 8
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    f2dc:	30 e2       	ldi	r19, 0x20	; 32
    f2de:	0a c0       	rjmp	.+20     	; 0xf2f4 <GSM_Cycle+0x756>
    f2e0:	fc 01       	movw	r30, r24
    f2e2:	ec 50       	subi	r30, 0x0C	; 12
    f2e4:	f7 4f       	sbci	r31, 0xF7	; 247
    f2e6:	80 81       	ld	r24, Z
    f2e8:	90 e0       	ldi	r25, 0x00	; 0
    f2ea:	c0 97       	sbiw	r24, 0x30	; 48
    f2ec:	0a 97       	sbiw	r24, 0x0a	; 10
    f2ee:	08 f0       	brcs	.+2      	; 0xf2f2 <GSM_Cycle+0x754>
    f2f0:	30 83       	st	Z, r19
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    f2f2:	2f 5f       	subi	r18, 0xFF	; 255
    f2f4:	fd 01       	movw	r30, r26
    f2f6:	01 90       	ld	r0, Z+
    f2f8:	00 20       	and	r0, r0
    f2fa:	e9 f7       	brne	.-6      	; 0xf2f6 <GSM_Cycle+0x758>
    f2fc:	31 97       	sbiw	r30, 0x01	; 1
    f2fe:	e4 5f       	subi	r30, 0xF4	; 244
    f300:	f8 40       	sbci	r31, 0x08	; 8
    f302:	82 2f       	mov	r24, r18
    f304:	90 e0       	ldi	r25, 0x00	; 0
    f306:	8e 17       	cp	r24, r30
    f308:	9f 07       	cpc	r25, r31
    f30a:	50 f3       	brcs	.-44     	; 0xf2e0 <GSM_Cycle+0x742>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    f30c:	ed b7       	in	r30, 0x3d	; 61
    f30e:	fe b7       	in	r31, 0x3e	; 62
    f310:	3c 97       	sbiw	r30, 0x0c	; 12
    f312:	0f b6       	in	r0, 0x3f	; 63
    f314:	f8 94       	cli
    f316:	fe bf       	out	0x3e, r31	; 62
    f318:	0f be       	out	0x3f, r0	; 63
    f31a:	ed bf       	out	0x3d, r30	; 61
    f31c:	31 96       	adiw	r30, 0x01	; 1
    f31e:	84 ef       	ldi	r24, 0xF4	; 244
    f320:	98 e0       	ldi	r25, 0x08	; 8
    f322:	ad b7       	in	r26, 0x3d	; 61
    f324:	be b7       	in	r27, 0x3e	; 62
    f326:	12 96       	adiw	r26, 0x02	; 2
    f328:	9c 93       	st	X, r25
    f32a:	8e 93       	st	-X, r24
    f32c:	11 97       	sbiw	r26, 0x01	; 1
    f32e:	80 eb       	ldi	r24, 0xB0	; 176
    f330:	99 e4       	ldi	r25, 0x49	; 73
    f332:	93 83       	std	Z+3, r25	; 0x03
    f334:	82 83       	std	Z+2, r24	; 0x02
    f336:	84 e8       	ldi	r24, 0x84	; 132
    f338:	9a e0       	ldi	r25, 0x0A	; 10
    f33a:	95 83       	std	Z+5, r25	; 0x05
    f33c:	84 83       	std	Z+4, r24	; 0x04
    f33e:	01 96       	adiw	r24, 0x01	; 1
    f340:	97 83       	std	Z+7, r25	; 0x07
    f342:	86 83       	std	Z+6, r24	; 0x06
    f344:	01 96       	adiw	r24, 0x01	; 1
    f346:	91 87       	std	Z+9, r25	; 0x09
    f348:	80 87       	std	Z+8, r24	; 0x08
    f34a:	01 96       	adiw	r24, 0x01	; 1
    f34c:	93 87       	std	Z+11, r25	; 0x0b
    f34e:	82 87       	std	Z+10, r24	; 0x0a
    f350:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    f354:	ed b7       	in	r30, 0x3d	; 61
    f356:	fe b7       	in	r31, 0x3e	; 62
    f358:	3c 96       	adiw	r30, 0x0c	; 12
    f35a:	0f b6       	in	r0, 0x3f	; 63
    f35c:	f8 94       	cli
    f35e:	fe bf       	out	0x3e, r31	; 62
    f360:	0f be       	out	0x3f, r0	; 63
    f362:	ed bf       	out	0x3d, r30	; 61
    f364:	80 91 84 0a 	lds	r24, 0x0A84
    f368:	88 23       	and	r24, r24
    f36a:	11 f0       	breq	.+4      	; 0xf370 <GSM_Cycle+0x7d2>
    f36c:	0c 94 00 83 	jmp	0x10600	; 0x10600 <GSM_Cycle+0x1a62>
    f370:	80 91 85 0a 	lds	r24, 0x0A85
    f374:	88 23       	and	r24, r24
    f376:	11 f0       	breq	.+4      	; 0xf37c <GSM_Cycle+0x7de>
    f378:	0c 94 00 83 	jmp	0x10600	; 0x10600 <GSM_Cycle+0x1a62>
    f37c:	80 91 86 0a 	lds	r24, 0x0A86
    f380:	88 23       	and	r24, r24
    f382:	11 f0       	breq	.+4      	; 0xf388 <GSM_Cycle+0x7ea>
    f384:	0c 94 00 83 	jmp	0x10600	; 0x10600 <GSM_Cycle+0x1a62>
    f388:	80 91 87 0a 	lds	r24, 0x0A87
    f38c:	88 23       	and	r24, r24
    f38e:	11 f0       	breq	.+4      	; 0xf394 <GSM_Cycle+0x7f6>
    f390:	0c 94 00 83 	jmp	0x10600	; 0x10600 <GSM_Cycle+0x1a62>
    f394:	07 c0       	rjmp	.+14     	; 0xf3a4 <GSM_Cycle+0x806>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
					if(GSM_MultiCon) GSM_State++;
    f396:	80 91 a4 05 	lds	r24, 0x05A4
    f39a:	8f 5f       	subi	r24, 0xFF	; 255
    f39c:	01 c0       	rjmp	.+2      	; 0xf3a0 <GSM_Cycle+0x802>
					else GSM_State = GSM_SEND_CIPSERVER;
    f39e:	85 e2       	ldi	r24, 0x25	; 37
    f3a0:	80 93 a4 05 	sts	0x05A4, r24
				}
				TempNum=0;	//
    f3a4:	10 92 6a 03 	sts	0x036A, r1
    f3a8:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    f3ac:	10 91 6a 03 	lds	r17, 0x036A
    f3b0:	81 2f       	mov	r24, r17
    f3b2:	90 e0       	ldi	r25, 0x00	; 0
    f3b4:	88 0f       	add	r24, r24
    f3b6:	99 1f       	adc	r25, r25
    f3b8:	88 0f       	add	r24, r24
    f3ba:	99 1f       	adc	r25, r25
    f3bc:	84 5b       	subi	r24, 0xB4	; 180
    f3be:	9f 4f       	sbci	r25, 0xFF	; 255
    f3c0:	60 e0       	ldi	r22, 0x00	; 0
    f3c2:	40 e0       	ldi	r20, 0x00	; 0
    f3c4:	20 e0       	ldi	r18, 0x00	; 0
    f3c6:	00 e0       	ldi	r16, 0x00	; 0
    f3c8:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <IP_E_compare_Const>
    f3cc:	88 23       	and	r24, r24
    f3ce:	69 f0       	breq	.+26     	; 0xf3ea <GSM_Cycle+0x84c>
				TempNum++;
    f3d0:	81 2f       	mov	r24, r17
    f3d2:	8f 5f       	subi	r24, 0xFF	; 255
    f3d4:	80 93 6a 03 	sts	0x036A, r24
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    f3d8:	84 30       	cpi	r24, 0x04	; 4
    f3da:	10 f4       	brcc	.+4      	; 0xf3e0 <GSM_Cycle+0x842>
    f3dc:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f3e0:	88 e2       	ldi	r24, 0x28	; 40
    f3e2:	80 93 a4 05 	sts	0x05A4, r24
    f3e6:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    f3ea:	80 91 d1 01 	lds	r24, 0x01D1
    f3ee:	80 fd       	sbrc	r24, 0
    f3f0:	02 c0       	rjmp	.+4      	; 0xf3f6 <GSM_Cycle+0x858>
    f3f2:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
					GSMTxSz = strlen_P(AT_CIPSTART);
    f3f6:	03 ee       	ldi	r16, 0xE3	; 227
    f3f8:	13 e0       	ldi	r17, 0x03	; 3
    f3fa:	c8 01       	movw	r24, r16
    f3fc:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    f400:	80 93 c5 08 	sts	0x08C5, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    f404:	00 d0       	rcall	.+0      	; 0xf406 <GSM_Cycle+0x868>
    f406:	00 d0       	rcall	.+0      	; 0xf408 <GSM_Cycle+0x86a>
    f408:	b1 ea       	ldi	r27, 0xA1	; 161
    f40a:	cb 2e       	mov	r12, r27
    f40c:	bb e0       	ldi	r27, 0x0B	; 11
    f40e:	db 2e       	mov	r13, r27
    f410:	ad b7       	in	r26, 0x3d	; 61
    f412:	be b7       	in	r27, 0x3e	; 62
    f414:	12 96       	adiw	r26, 0x02	; 2
    f416:	dc 92       	st	X, r13
    f418:	ce 92       	st	-X, r12
    f41a:	11 97       	sbiw	r26, 0x01	; 1
    f41c:	14 96       	adiw	r26, 0x04	; 4
    f41e:	1c 93       	st	X, r17
    f420:	0e 93       	st	-X, r16
    f422:	13 97       	sbiw	r26, 0x03	; 3
    f424:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    f428:	00 91 6a 03 	lds	r16, 0x036A
    f42c:	00 5d       	subi	r16, 0xD0	; 208
    f42e:	00 93 ad 0b 	sts	0x0BAD, r16
    f432:	00 53       	subi	r16, 0x30	; 48
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    f434:	80 90 c5 08 	lds	r8, 0x08C5
    f438:	10 e0       	ldi	r17, 0x00	; 0
    f43a:	0f 90       	pop	r0
    f43c:	0f 90       	pop	r0
    f43e:	0f 90       	pop	r0
    f440:	0f 90       	pop	r0
    f442:	78 01       	movw	r14, r16
    f444:	ee 0c       	add	r14, r14
    f446:	ff 1c       	adc	r15, r15
    f448:	ee 0c       	add	r14, r14
    f44a:	ff 1c       	adc	r15, r15
    f44c:	c7 01       	movw	r24, r14
    f44e:	84 5b       	subi	r24, 0xB4	; 180
    f450:	9f 4f       	sbci	r25, 0xFF	; 255
    f452:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    f456:	98 2e       	mov	r9, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    f458:	c7 01       	movw	r24, r14
    f45a:	83 5b       	subi	r24, 0xB3	; 179
    f45c:	9f 4f       	sbci	r25, 0xFF	; 255
    f45e:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    f462:	a8 2e       	mov	r10, r24
    f464:	00 0f       	add	r16, r16
    f466:	11 1f       	adc	r17, r17
    f468:	c8 01       	movw	r24, r16
    f46a:	88 0f       	add	r24, r24
    f46c:	99 1f       	adc	r25, r25
    f46e:	82 5b       	subi	r24, 0xB2	; 178
    f470:	9f 4f       	sbci	r25, 0xFF	; 255
    f472:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    f476:	b8 2e       	mov	r11, r24
    f478:	c7 01       	movw	r24, r14
    f47a:	81 5b       	subi	r24, 0xB1	; 177
    f47c:	9f 4f       	sbci	r25, 0xFF	; 255
    f47e:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    f482:	f8 2e       	mov	r15, r24
    f484:	c8 01       	movw	r24, r16
    f486:	84 5a       	subi	r24, 0xA4	; 164
    f488:	9f 4f       	sbci	r25, 0xFF	; 255
    f48a:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    f48e:	ed b7       	in	r30, 0x3d	; 61
    f490:	fe b7       	in	r31, 0x3e	; 62
    f492:	3e 97       	sbiw	r30, 0x0e	; 14
    f494:	0f b6       	in	r0, 0x3f	; 63
    f496:	f8 94       	cli
    f498:	fe bf       	out	0x3e, r31	; 62
    f49a:	0f be       	out	0x3f, r0	; 63
    f49c:	ed bf       	out	0x3d, r30	; 61
    f49e:	31 96       	adiw	r30, 0x01	; 1
    f4a0:	28 2d       	mov	r18, r8
    f4a2:	30 e0       	ldi	r19, 0x00	; 0
    f4a4:	2c 0d       	add	r18, r12
    f4a6:	3d 1d       	adc	r19, r13
    f4a8:	ad b7       	in	r26, 0x3d	; 61
    f4aa:	be b7       	in	r27, 0x3e	; 62
    f4ac:	12 96       	adiw	r26, 0x02	; 2
    f4ae:	3c 93       	st	X, r19
    f4b0:	2e 93       	st	-X, r18
    f4b2:	11 97       	sbiw	r26, 0x01	; 1
    f4b4:	2c ea       	ldi	r18, 0xAC	; 172
    f4b6:	31 e0       	ldi	r19, 0x01	; 1
    f4b8:	33 83       	std	Z+3, r19	; 0x03
    f4ba:	22 83       	std	Z+2, r18	; 0x02
    f4bc:	94 82       	std	Z+4, r9	; 0x04
    f4be:	15 82       	std	Z+5, r1	; 0x05
    f4c0:	a6 82       	std	Z+6, r10	; 0x06
    f4c2:	17 82       	std	Z+7, r1	; 0x07
    f4c4:	b0 86       	std	Z+8, r11	; 0x08
    f4c6:	11 86       	std	Z+9, r1	; 0x09
    f4c8:	f2 86       	std	Z+10, r15	; 0x0a
    f4ca:	13 86       	std	Z+11, r1	; 0x0b
    f4cc:	95 87       	std	Z+13, r25	; 0x0d
    f4ce:	84 87       	std	Z+12, r24	; 0x0c
    f4d0:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    f4d4:	f6 01       	movw	r30, r12
    f4d6:	01 90       	ld	r0, Z+
    f4d8:	00 20       	and	r0, r0
    f4da:	e9 f7       	brne	.-6      	; 0xf4d6 <GSM_Cycle+0x938>
    f4dc:	6f 01       	movw	r12, r30
    f4de:	08 94       	sec
    f4e0:	c1 08       	sbc	r12, r1
    f4e2:	d1 08       	sbc	r13, r1
    f4e4:	21 ea       	ldi	r18, 0xA1	; 161
    f4e6:	3b e0       	ldi	r19, 0x0B	; 11
    f4e8:	c2 1a       	sub	r12, r18
    f4ea:	d3 0a       	sbc	r13, r19
    f4ec:	c0 92 c5 08 	sts	0x08C5, r12
					GSM_SendFirstChar();
    f4f0:	8d b7       	in	r24, 0x3d	; 61
    f4f2:	9e b7       	in	r25, 0x3e	; 62
    f4f4:	0e 96       	adiw	r24, 0x0e	; 14
    f4f6:	0f b6       	in	r0, 0x3f	; 63
    f4f8:	f8 94       	cli
    f4fa:	9e bf       	out	0x3e, r25	; 62
    f4fc:	0f be       	out	0x3f, r0	; 63
    f4fe:	8d bf       	out	0x3d, r24	; 61
    f500:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    f504:	80 91 5a 03 	lds	r24, 0x035A
    f508:	64 ef       	ldi	r22, 0xF4	; 244
    f50a:	71 e0       	ldi	r23, 0x01	; 1
    f50c:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					GSM_State++;
    f510:	80 91 a4 05 	lds	r24, 0x05A4
    f514:	8f 5f       	subi	r24, 0xFF	; 255
    f516:	80 93 a4 05 	sts	0x05A4, r24
    f51a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    f51e:	83 eb       	ldi	r24, 0xB3	; 179
    f520:	92 e0       	ldi	r25, 0x02	; 2
    f522:	6b e4       	ldi	r22, 0x4B	; 75
    f524:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f528:	88 23       	and	r24, r24
    f52a:	11 f4       	brne	.+4      	; 0xf530 <GSM_Cycle+0x992>
    f52c:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f530:	80 91 a4 05 	lds	r24, 0x05A4
    f534:	8f 5f       	subi	r24, 0xFF	; 255
    f536:	80 93 a4 05 	sts	0x05A4, r24
    f53a:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    f53e:	80 91 5a 03 	lds	r24, 0x035A
    f542:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    f546:	88 23       	and	r24, r24
    f548:	19 f0       	breq	.+6      	; 0xf550 <GSM_Cycle+0x9b2>
    f54a:	8b e4       	ldi	r24, 0x4B	; 75
    f54c:	80 93 a4 05 	sts	0x05A4, r24
			if(GetStringFromFIFO()){
    f550:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    f554:	88 23       	and	r24, r24
    f556:	11 f4       	brne	.+4      	; 0xf55c <GSM_Cycle+0x9be>
    f558:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    f55c:	8e 01       	movw	r16, r28
    f55e:	07 5e       	subi	r16, 0xE7	; 231
    f560:	1f 4f       	sbci	r17, 0xFF	; 255
    f562:	c8 01       	movw	r24, r16
    f564:	66 eb       	ldi	r22, 0xB6	; 182
    f566:	72 e0       	ldi	r23, 0x02	; 2
    f568:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    f56c:	f0 90 6a 03 	lds	r15, 0x036A
    f570:	90 e3       	ldi	r25, 0x30	; 48
    f572:	f9 0e       	add	r15, r25
    f574:	f9 8e       	std	Y+25, r15	; 0x19
    f576:	a0 ed       	ldi	r26, 0xD0	; 208
    f578:	fa 0e       	add	r15, r26
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    f57a:	84 ef       	ldi	r24, 0xF4	; 244
    f57c:	98 e0       	ldi	r25, 0x08	; 8
    f57e:	b8 01       	movw	r22, r16
    f580:	0e 94 0f 88 	call	0x1101e	; 0x1101e <strcmp>
    f584:	00 97       	sbiw	r24, 0x00	; 0
    f586:	11 f0       	breq	.+4      	; 0xf58c <GSM_Cycle+0x9ee>
    f588:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
    f58c:	0c 94 08 83 	jmp	0x10610	; 0x10610 <GSM_Cycle+0x1a72>
			if(GetStringFromFIFO()){
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
				RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    f590:	88 e2       	ldi	r24, 0x28	; 40
    f592:	80 93 a4 05 	sts	0x05A4, r24
    f596:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
					else GSM_State = GSM_SEND_CIPSTART;
    f59a:	82 e2       	ldi	r24, 0x22	; 34
    f59c:	80 93 a4 05 	sts	0x05A4, r24
    f5a0:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    f5a4:	80 91 d1 01 	lds	r24, 0x01D1
    f5a8:	80 fd       	sbrc	r24, 0
    f5aa:	02 c0       	rjmp	.+4      	; 0xf5b0 <GSM_Cycle+0xa12>
    f5ac:	0c 94 f3 82 	jmp	0x105e6	; 0x105e6 <GSM_Cycle+0x1a48>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    f5b0:	08 ef       	ldi	r16, 0xF8	; 248
    f5b2:	13 e0       	ldi	r17, 0x03	; 3
    f5b4:	c8 01       	movw	r24, r16
    f5b6:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    f5ba:	80 93 c5 08 	sts	0x08C5, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    f5be:	00 d0       	rcall	.+0      	; 0xf5c0 <GSM_Cycle+0xa22>
    f5c0:	00 d0       	rcall	.+0      	; 0xf5c2 <GSM_Cycle+0xa24>
    f5c2:	71 ea       	ldi	r23, 0xA1	; 161
    f5c4:	e7 2e       	mov	r14, r23
    f5c6:	7b e0       	ldi	r23, 0x0B	; 11
    f5c8:	f7 2e       	mov	r15, r23
    f5ca:	ed b7       	in	r30, 0x3d	; 61
    f5cc:	fe b7       	in	r31, 0x3e	; 62
    f5ce:	f2 82       	std	Z+2, r15	; 0x02
    f5d0:	e1 82       	std	Z+1, r14	; 0x01
    f5d2:	14 83       	std	Z+4, r17	; 0x04
    f5d4:	03 83       	std	Z+3, r16	; 0x03
    f5d6:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    f5da:	00 91 c5 08 	lds	r16, 0x08C5
    f5de:	0f 90       	pop	r0
    f5e0:	0f 90       	pop	r0
    f5e2:	0f 90       	pop	r0
    f5e4:	0f 90       	pop	r0
    f5e6:	84 e6       	ldi	r24, 0x64	; 100
    f5e8:	90 e0       	ldi	r25, 0x00	; 0
    f5ea:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    f5ee:	00 d0       	rcall	.+0      	; 0xf5f0 <GSM_Cycle+0xa52>
    f5f0:	00 d0       	rcall	.+0      	; 0xf5f2 <GSM_Cycle+0xa54>
    f5f2:	00 d0       	rcall	.+0      	; 0xf5f4 <GSM_Cycle+0xa56>
    f5f4:	ed b7       	in	r30, 0x3d	; 61
    f5f6:	fe b7       	in	r31, 0x3e	; 62
    f5f8:	31 96       	adiw	r30, 0x01	; 1
    f5fa:	10 e0       	ldi	r17, 0x00	; 0
    f5fc:	0e 0d       	add	r16, r14
    f5fe:	1f 1d       	adc	r17, r15
    f600:	ad b7       	in	r26, 0x3d	; 61
    f602:	be b7       	in	r27, 0x3e	; 62
    f604:	12 96       	adiw	r26, 0x02	; 2
    f606:	1c 93       	st	X, r17
    f608:	0e 93       	st	-X, r16
    f60a:	11 97       	sbiw	r26, 0x01	; 1
    f60c:	20 ec       	ldi	r18, 0xC0	; 192
    f60e:	31 e0       	ldi	r19, 0x01	; 1
    f610:	33 83       	std	Z+3, r19	; 0x03
    f612:	22 83       	std	Z+2, r18	; 0x02
    f614:	95 83       	std	Z+5, r25	; 0x05
    f616:	84 83       	std	Z+4, r24	; 0x04
    f618:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    f61c:	f7 01       	movw	r30, r14
    f61e:	01 90       	ld	r0, Z+
    f620:	00 20       	and	r0, r0
    f622:	e9 f7       	brne	.-6      	; 0xf61e <GSM_Cycle+0xa80>
    f624:	7f 01       	movw	r14, r30
    f626:	08 94       	sec
    f628:	e1 08       	sbc	r14, r1
    f62a:	f1 08       	sbc	r15, r1
    f62c:	21 ea       	ldi	r18, 0xA1	; 161
    f62e:	3b e0       	ldi	r19, 0x0B	; 11
    f630:	e2 1a       	sub	r14, r18
    f632:	f3 0a       	sbc	r15, r19
    f634:	e0 92 c5 08 	sts	0x08C5, r14
				GSM_SendFirstChar();
    f638:	8d b7       	in	r24, 0x3d	; 61
    f63a:	9e b7       	in	r25, 0x3e	; 62
    f63c:	06 96       	adiw	r24, 0x06	; 6
    f63e:	0f b6       	in	r0, 0x3f	; 63
    f640:	f8 94       	cli
    f642:	9e bf       	out	0x3e, r25	; 62
    f644:	0f be       	out	0x3f, r0	; 63
    f646:	8d bf       	out	0x3d, r24	; 61
    f648:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    f64c:	80 91 5a 03 	lds	r24, 0x035A
    f650:	64 ef       	ldi	r22, 0xF4	; 244
    f652:	71 e0       	ldi	r23, 0x01	; 1
    f654:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_State++;
    f658:	80 91 a4 05 	lds	r24, 0x05A4
    f65c:	8f 5f       	subi	r24, 0xFF	; 255
    f65e:	80 93 a4 05 	sts	0x05A4, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    f662:	80 91 5b 03 	lds	r24, 0x035B
    f666:	6f ef       	ldi	r22, 0xFF	; 255
    f668:	7f ef       	ldi	r23, 0xFF	; 255
    f66a:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    f66e:	bb c7       	rjmp	.+3958   	; 0x105e6 <GSM_Cycle+0x1a48>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    f670:	83 eb       	ldi	r24, 0xB3	; 179
    f672:	92 e0       	ldi	r25, 0x02	; 2
    f674:	6b e4       	ldi	r22, 0x4B	; 75
    f676:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f67a:	88 23       	and	r24, r24
    f67c:	09 f4       	brne	.+2      	; 0xf680 <GSM_Cycle+0xae2>
    f67e:	b3 c7       	rjmp	.+3942   	; 0x105e6 <GSM_Cycle+0x1a48>
    f680:	80 91 a4 05 	lds	r24, 0x05A4
    f684:	8f 5f       	subi	r24, 0xFF	; 255
    f686:	80 93 a4 05 	sts	0x05A4, r24
    f68a:	ad c7       	rjmp	.+3930   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    f68c:	84 ec       	ldi	r24, 0xC4	; 196
    f68e:	92 e0       	ldi	r25, 0x02	; 2
    f690:	6b e4       	ldi	r22, 0x4B	; 75
    f692:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    f696:	88 23       	and	r24, r24
    f698:	09 f4       	brne	.+2      	; 0xf69c <GSM_Cycle+0xafe>
    f69a:	a5 c7       	rjmp	.+3914   	; 0x105e6 <GSM_Cycle+0x1a48>
    f69c:	88 e2       	ldi	r24, 0x28	; 40
    f69e:	80 93 a4 05 	sts	0x05A4, r24
    f6a2:	a1 c7       	rjmp	.+3906   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    f6a4:	80 91 e9 08 	lds	r24, 0x08E9
    f6a8:	88 23       	and	r24, r24
    f6aa:	e1 f5       	brne	.+120    	; 0xf724 <GSM_Cycle+0xb86>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    f6ac:	80 91 b4 08 	lds	r24, 0x08B4
    f6b0:	88 23       	and	r24, r24
    f6b2:	41 f1       	breq	.+80     	; 0xf704 <GSM_Cycle+0xb66>
					if(GSM_MultiCon == 1){
    f6b4:	80 91 b2 0d 	lds	r24, 0x0DB2
    f6b8:	81 30       	cpi	r24, 0x01	; 1
    f6ba:	e9 f4       	brne	.+58     	; 0xf6f6 <GSM_Cycle+0xb58>
						if(GPRS_Protocol_Out == UDP){
    f6bc:	80 91 e7 08 	lds	r24, 0x08E7
    f6c0:	88 23       	and	r24, r24
    f6c2:	49 f4       	brne	.+18     	; 0xf6d6 <GSM_Cycle+0xb38>
							TempNum = 0;
    f6c4:	10 92 6a 03 	sts	0x036A, r1
							GSM_State = GSM_SEND_CIPSEND;
    f6c8:	8a e2       	ldi	r24, 0x2A	; 42
    f6ca:	80 93 a4 05 	sts	0x05A4, r24
							ResetTimer16(TD_GSM);
    f6ce:	80 91 5a 03 	lds	r24, 0x035A
    f6d2:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    f6d6:	80 91 e7 08 	lds	r24, 0x08E7
    f6da:	81 30       	cpi	r24, 0x01	; 1
    f6dc:	09 f0       	breq	.+2      	; 0xf6e0 <GSM_Cycle+0xb42>
    f6de:	83 c7       	rjmp	.+3846   	; 0x105e6 <GSM_Cycle+0x1a48>
							if(GSM_ActiveConnection == NO_CONNECTION){
    f6e0:	80 91 d2 01 	lds	r24, 0x01D2
    f6e4:	8f 3f       	cpi	r24, 0xFF	; 255
    f6e6:	19 f4       	brne	.+6      	; 0xf6ee <GSM_Cycle+0xb50>
								GPRS_FlgSz_Out = 0;
    f6e8:	10 92 b4 08 	sts	0x08B4, r1
    f6ec:	7c c7       	rjmp	.+3832   	; 0x105e6 <GSM_Cycle+0x1a48>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    f6ee:	8a e2       	ldi	r24, 0x2A	; 42
    f6f0:	80 93 a4 05 	sts	0x05A4, r24
    f6f4:	78 c7       	rjmp	.+3824   	; 0x105e6 <GSM_Cycle+0x1a48>
						}
					}
					else{
						GSM_MultiCon = 1;
    f6f6:	81 e0       	ldi	r24, 0x01	; 1
    f6f8:	80 93 b2 0d 	sts	0x0DB2, r24
						GSM_State = GSM_CIPSHUT;
    f6fc:	87 e4       	ldi	r24, 0x47	; 71
    f6fe:	80 93 a4 05 	sts	0x05A4, r24
    f702:	71 c7       	rjmp	.+3810   	; 0x105e6 <GSM_Cycle+0x1a48>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    f704:	80 91 d4 08 	lds	r24, 0x08D4
    f708:	88 23       	and	r24, r24
    f70a:	61 f0       	breq	.+24     	; 0xf724 <GSM_Cycle+0xb86>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    f70c:	85 e2       	ldi	r24, 0x25	; 37
    f70e:	91 e0       	ldi	r25, 0x01	; 1
    f710:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
    f714:	88 23       	and	r24, r24
    f716:	31 f0       	breq	.+12     	; 0xf724 <GSM_Cycle+0xb86>
					GSM_State = GSM_SEND_CMGS;
    f718:	8f e2       	ldi	r24, 0x2F	; 47
    f71a:	80 93 a4 05 	sts	0x05A4, r24
					TempNum = 0;
    f71e:	10 92 6a 03 	sts	0x036A, r1
    f722:	61 c7       	rjmp	.+3778   	; 0x105e6 <GSM_Cycle+0x1a48>
					break;
				}
			}

			if(GetStringFromFIFO()){
    f724:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    f728:	88 23       	and	r24, r24
    f72a:	31 f0       	breq	.+12     	; 0xf738 <GSM_Cycle+0xb9a>
				GSM_State = GSM_AnalyzeURC;
    f72c:	89 e2       	ldi	r24, 0x29	; 41
    f72e:	80 93 a4 05 	sts	0x05A4, r24
				TempNum = 0;
    f732:	10 92 6a 03 	sts	0x036A, r1
    f736:	57 c7       	rjmp	.+3758   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			if(!IsWebSession()){
    f738:	80 91 e9 08 	lds	r24, 0x08E9
    f73c:	88 23       	and	r24, r24
    f73e:	09 f0       	breq	.+2      	; 0xf742 <GSM_Cycle+0xba4>
    f740:	52 c7       	rjmp	.+3748   	; 0x105e6 <GSM_Cycle+0x1a48>
				if(Timer16Stopp(TD_TCP_Connect) ){
    f742:	80 91 5b 03 	lds	r24, 0x035B
    f746:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    f74a:	88 23       	and	r24, r24
    f74c:	21 f0       	breq	.+8      	; 0xf756 <GSM_Cycle+0xbb8>
					GSM_State = GSM_CIPSHUT;
    f74e:	87 e4       	ldi	r24, 0x47	; 71
    f750:	80 93 a4 05 	sts	0x05A4, r24
    f754:	48 c7       	rjmp	.+3728   	; 0x105e6 <GSM_Cycle+0x1a48>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    f756:	80 91 5c 03 	lds	r24, 0x035C
    f75a:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    f75e:	88 23       	and	r24, r24
    f760:	21 f0       	breq	.+8      	; 0xf76a <GSM_Cycle+0xbcc>
					GSM_State = GSM_SEND_CSQ;
    f762:	80 e5       	ldi	r24, 0x50	; 80
    f764:	80 93 a4 05 	sts	0x05A4, r24
    f768:	3e c7       	rjmp	.+3708   	; 0x105e6 <GSM_Cycle+0x1a48>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    f76a:	80 91 5d 03 	lds	r24, 0x035D
    f76e:	0e 94 94 28 	call	0x5128	; 0x5128 <Timer32Stopp>
    f772:	88 23       	and	r24, r24
    f774:	09 f4       	brne	.+2      	; 0xf778 <GSM_Cycle+0xbda>
    f776:	37 c7       	rjmp	.+3694   	; 0x105e6 <GSM_Cycle+0x1a48>
					GSM_State = GSM_ReStart1;
    f778:	8b e4       	ldi	r24, 0x4B	; 75
    f77a:	80 93 a4 05 	sts	0x05A4, r24
    f77e:	33 c7       	rjmp	.+3686   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    f780:	04 ef       	ldi	r16, 0xF4	; 244
    f782:	18 e0       	ldi	r17, 0x08	; 8
    f784:	c8 01       	movw	r24, r16
    f786:	63 e7       	ldi	r22, 0x73	; 115
    f788:	72 e0       	ldi	r23, 0x02	; 2
    f78a:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f78e:	89 2b       	or	r24, r25
    f790:	21 f0       	breq	.+8      	; 0xf79a <GSM_Cycle+0xbfc>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    f792:	83 e3       	ldi	r24, 0x33	; 51
    f794:	80 93 a4 05 	sts	0x05A4, r24
    f798:	26 c7       	rjmp	.+3660   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    f79a:	c8 01       	movw	r24, r16
    f79c:	6d e7       	ldi	r22, 0x7D	; 125
    f79e:	72 e0       	ldi	r23, 0x02	; 2
    f7a0:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f7a4:	89 2b       	or	r24, r25
    f7a6:	61 f0       	breq	.+24     	; 0xf7c0 <GSM_Cycle+0xc22>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    f7a8:	80 91 5b 03 	lds	r24, 0x035B
    f7ac:	68 ee       	ldi	r22, 0xE8	; 232
    f7ae:	73 e0       	ldi	r23, 0x03	; 3
    f7b0:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_CSD = 0;
    f7b4:	10 92 ba 08 	sts	0x08BA, r1
				GSM_State = GSM_ProtocolMode;
    f7b8:	82 e5       	ldi	r24, 0x52	; 82
    f7ba:	80 93 a4 05 	sts	0x05A4, r24
    f7be:	13 c7       	rjmp	.+3622   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    f7c0:	c8 01       	movw	r24, r16
    f7c2:	63 ea       	ldi	r22, 0xA3	; 163
    f7c4:	72 e0       	ldi	r23, 0x02	; 2
    f7c6:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f7ca:	89 2b       	or	r24, r25
    f7cc:	51 f0       	breq	.+20     	; 0xf7e2 <GSM_Cycle+0xc44>
				StartTimer16(TD_GSM, 150);
    f7ce:	80 91 5a 03 	lds	r24, 0x035A
    f7d2:	66 e9       	ldi	r22, 0x96	; 150
    f7d4:	70 e0       	ldi	r23, 0x00	; 0
    f7d6:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    f7da:	87 e5       	ldi	r24, 0x57	; 87
    f7dc:	80 93 a4 05 	sts	0x05A4, r24
    f7e0:	02 c7       	rjmp	.+3588   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    f7e2:	c8 01       	movw	r24, r16
    f7e4:	6f e8       	ldi	r22, 0x8F	; 143
    f7e6:	72 e0       	ldi	r23, 0x02	; 2
    f7e8:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f7ec:	89 2b       	or	r24, r25
    f7ee:	99 f1       	breq	.+102    	; 0xf856 <GSM_Cycle+0xcb8>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    f7f0:	00 d0       	rcall	.+0      	; 0xf7f2 <GSM_Cycle+0xc54>
    f7f2:	00 d0       	rcall	.+0      	; 0xf7f4 <GSM_Cycle+0xc56>
    f7f4:	00 d0       	rcall	.+0      	; 0xf7f6 <GSM_Cycle+0xc58>
    f7f6:	ed b7       	in	r30, 0x3d	; 61
    f7f8:	fe b7       	in	r31, 0x3e	; 62
    f7fa:	31 96       	adiw	r30, 0x01	; 1
    f7fc:	ad b7       	in	r26, 0x3d	; 61
    f7fe:	be b7       	in	r27, 0x3e	; 62
    f800:	12 96       	adiw	r26, 0x02	; 2
    f802:	1c 93       	st	X, r17
    f804:	0e 93       	st	-X, r16
    f806:	11 97       	sbiw	r26, 0x01	; 1
    f808:	83 ea       	ldi	r24, 0xA3	; 163
    f80a:	99 e4       	ldi	r25, 0x49	; 73
    f80c:	93 83       	std	Z+3, r25	; 0x03
    f80e:	82 83       	std	Z+2, r24	; 0x02
    f810:	8a e6       	ldi	r24, 0x6A	; 106
    f812:	93 e0       	ldi	r25, 0x03	; 3
    f814:	95 83       	std	Z+5, r25	; 0x05
    f816:	84 83       	std	Z+4, r24	; 0x04
    f818:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    f81c:	ed b7       	in	r30, 0x3d	; 61
    f81e:	fe b7       	in	r31, 0x3e	; 62
    f820:	36 96       	adiw	r30, 0x06	; 6
    f822:	0f b6       	in	r0, 0x3f	; 63
    f824:	f8 94       	cli
    f826:	fe bf       	out	0x3e, r31	; 62
    f828:	0f be       	out	0x3f, r0	; 63
    f82a:	ed bf       	out	0x3d, r30	; 61
    f82c:	90 91 d2 01 	lds	r25, 0x01D2
    f830:	80 91 6a 03 	lds	r24, 0x036A
    f834:	98 17       	cp	r25, r24
    f836:	59 f4       	brne	.+22     	; 0xf84e <GSM_Cycle+0xcb0>
					GSM_ActiveConnection = NO_CONNECTION;
    f838:	8f ef       	ldi	r24, 0xFF	; 255
    f83a:	80 93 d2 01 	sts	0x01D2, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    f83e:	10 92 a2 0c 	sts	0x0CA2, r1
	IP->IP2 = IP2;
    f842:	10 92 a3 0c 	sts	0x0CA3, r1
	IP->IP3 = IP3;
    f846:	10 92 a4 0c 	sts	0x0CA4, r1
	IP->IP4 = IP4;
    f84a:	10 92 a5 0c 	sts	0x0CA5, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    f84e:	88 e2       	ldi	r24, 0x28	; 40
    f850:	80 93 a4 05 	sts	0x05A4, r24
    f854:	c8 c6       	rjmp	.+3472   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    f856:	c8 01       	movw	r24, r16
    f858:	68 e9       	ldi	r22, 0x98	; 152
    f85a:	72 e0       	ldi	r23, 0x02	; 2
    f85c:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f860:	89 2b       	or	r24, r25
    f862:	21 f0       	breq	.+8      	; 0xf86c <GSM_Cycle+0xcce>
				GSM_State = GSM_SEND_E0;
    f864:	88 e0       	ldi	r24, 0x08	; 8
    f866:	80 93 a4 05 	sts	0x05A4, r24
    f86a:	bd c6       	rjmp	.+3450   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    f86c:	c8 01       	movw	r24, r16
    f86e:	65 e8       	ldi	r22, 0x85	; 133
    f870:	72 e0       	ldi	r23, 0x02	; 2
    f872:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f876:	89 2b       	or	r24, r25
    f878:	41 f0       	breq	.+16     	; 0xf88a <GSM_Cycle+0xcec>
    f87a:	80 91 cb 08 	lds	r24, 0x08CB
    f87e:	88 23       	and	r24, r24
    f880:	21 f4       	brne	.+8      	; 0xf88a <GSM_Cycle+0xcec>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    f882:	86 e3       	ldi	r24, 0x36	; 54
    f884:	80 93 a4 05 	sts	0x05A4, r24
    f888:	ae c6       	rjmp	.+3420   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    f88a:	84 ef       	ldi	r24, 0xF4	; 244
    f88c:	98 e0       	ldi	r25, 0x08	; 8
    f88e:	6d ef       	ldi	r22, 0xFD	; 253
    f890:	72 e0       	ldi	r23, 0x02	; 2
    f892:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
    f896:	89 2b       	or	r24, r25
    f898:	21 f0       	breq	.+8      	; 0xf8a2 <GSM_Cycle+0xd04>
				GSM_State = GSM_WAIT_CSQ;
    f89a:	81 e5       	ldi	r24, 0x51	; 81
    f89c:	80 93 a4 05 	sts	0x05A4, r24
    f8a0:	a2 c6       	rjmp	.+3396   	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    f8a2:	88 e2       	ldi	r24, 0x28	; 40
    f8a4:	80 93 a4 05 	sts	0x05A4, r24
    f8a8:	9e c6       	rjmp	.+3388   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    f8aa:	80 91 e7 08 	lds	r24, 0x08E7
    f8ae:	88 23       	and	r24, r24
    f8b0:	09 f0       	breq	.+2      	; 0xf8b4 <GSM_Cycle+0xd16>
    f8b2:	93 c0       	rjmp	.+294    	; 0xf9da <GSM_Cycle+0xe3c>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    f8b4:	10 91 6a 03 	lds	r17, 0x036A
    f8b8:	81 2f       	mov	r24, r17
    f8ba:	90 e0       	ldi	r25, 0x00	; 0
    f8bc:	88 0f       	add	r24, r24
    f8be:	99 1f       	adc	r25, r25
    f8c0:	88 0f       	add	r24, r24
    f8c2:	99 1f       	adc	r25, r25
    f8c4:	84 5b       	subi	r24, 0xB4	; 180
    f8c6:	9f 4f       	sbci	r25, 0xFF	; 255
    f8c8:	60 e0       	ldi	r22, 0x00	; 0
    f8ca:	40 e0       	ldi	r20, 0x00	; 0
    f8cc:	20 e0       	ldi	r18, 0x00	; 0
    f8ce:	00 e0       	ldi	r16, 0x00	; 0
    f8d0:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <IP_E_compare_Const>
    f8d4:	88 23       	and	r24, r24
    f8d6:	59 f4       	brne	.+22     	; 0xf8ee <GSM_Cycle+0xd50>
    f8d8:	80 91 ec 07 	lds	r24, 0x07EC
    f8dc:	90 e0       	ldi	r25, 0x00	; 0
    f8de:	01 2e       	mov	r0, r17
    f8e0:	02 c0       	rjmp	.+4      	; 0xf8e6 <GSM_Cycle+0xd48>
    f8e2:	95 95       	asr	r25
    f8e4:	87 95       	ror	r24
    f8e6:	0a 94       	dec	r0
    f8e8:	e2 f7       	brpl	.-8      	; 0xf8e2 <GSM_Cycle+0xd44>
    f8ea:	80 ff       	sbrs	r24, 0
    f8ec:	13 c0       	rjmp	.+38     	; 0xf914 <GSM_Cycle+0xd76>
					TempNum++;
    f8ee:	81 2f       	mov	r24, r17
    f8f0:	8f 5f       	subi	r24, 0xFF	; 255
    f8f2:	80 93 6a 03 	sts	0x036A, r24
					if(TempNum>3){
    f8f6:	84 30       	cpi	r24, 0x04	; 4
    f8f8:	08 f4       	brcc	.+2      	; 0xf8fc <GSM_Cycle+0xd5e>
    f8fa:	6f c0       	rjmp	.+222    	; 0xf9da <GSM_Cycle+0xe3c>
						StartTimer16(TD_GSM,150);
    f8fc:	80 91 5a 03 	lds	r24, 0x035A
    f900:	66 e9       	ldi	r22, 0x96	; 150
    f902:	70 e0       	ldi	r23, 0x00	; 0
    f904:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    f908:	8e e2       	ldi	r24, 0x2E	; 46
    f90a:	80 93 a4 05 	sts	0x05A4, r24
						GPRS_FlgSz_Out = 0;
    f90e:	10 92 b4 08 	sts	0x08B4, r1
    f912:	63 c0       	rjmp	.+198    	; 0xf9da <GSM_Cycle+0xe3c>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    f914:	80 91 d1 01 	lds	r24, 0x01D1
    f918:	80 ff       	sbrs	r24, 0
    f91a:	5f c0       	rjmp	.+190    	; 0xf9da <GSM_Cycle+0xe3c>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    f91c:	80 91 5a 03 	lds	r24, 0x035A
    f920:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    f924:	88 23       	and	r24, r24
    f926:	09 f4       	brne	.+2      	; 0xf92a <GSM_Cycle+0xd8c>
    f928:	58 c0       	rjmp	.+176    	; 0xf9da <GSM_Cycle+0xe3c>
							GSMTxSz = strlen_P(AT_CIPSEND);
    f92a:	57 e1       	ldi	r21, 0x17	; 23
    f92c:	e5 2e       	mov	r14, r21
    f92e:	54 e0       	ldi	r21, 0x04	; 4
    f930:	f5 2e       	mov	r15, r21
    f932:	c7 01       	movw	r24, r14
    f934:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    f938:	80 93 c5 08 	sts	0x08C5, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    f93c:	00 d0       	rcall	.+0      	; 0xf93e <GSM_Cycle+0xda0>
    f93e:	00 d0       	rcall	.+0      	; 0xf940 <GSM_Cycle+0xda2>
    f940:	01 ea       	ldi	r16, 0xA1	; 161
    f942:	1b e0       	ldi	r17, 0x0B	; 11
    f944:	ad b7       	in	r26, 0x3d	; 61
    f946:	be b7       	in	r27, 0x3e	; 62
    f948:	12 96       	adiw	r26, 0x02	; 2
    f94a:	1c 93       	st	X, r17
    f94c:	0e 93       	st	-X, r16
    f94e:	11 97       	sbiw	r26, 0x01	; 1
    f950:	14 96       	adiw	r26, 0x04	; 4
    f952:	fc 92       	st	X, r15
    f954:	ee 92       	st	-X, r14
    f956:	13 97       	sbiw	r26, 0x03	; 3
    f958:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    f95c:	80 91 c5 08 	lds	r24, 0x08C5
    f960:	00 d0       	rcall	.+0      	; 0xf962 <GSM_Cycle+0xdc4>
    f962:	00 d0       	rcall	.+0      	; 0xf964 <GSM_Cycle+0xdc6>
    f964:	ed b7       	in	r30, 0x3d	; 61
    f966:	fe b7       	in	r31, 0x3e	; 62
    f968:	31 96       	adiw	r30, 0x01	; 1
    f96a:	90 e0       	ldi	r25, 0x00	; 0
    f96c:	80 0f       	add	r24, r16
    f96e:	91 1f       	adc	r25, r17
    f970:	ad b7       	in	r26, 0x3d	; 61
    f972:	be b7       	in	r27, 0x3e	; 62
    f974:	12 96       	adiw	r26, 0x02	; 2
    f976:	9c 93       	st	X, r25
    f978:	8e 93       	st	-X, r24
    f97a:	11 97       	sbiw	r26, 0x01	; 1
    f97c:	84 ec       	ldi	r24, 0xC4	; 196
    f97e:	91 e0       	ldi	r25, 0x01	; 1
    f980:	93 83       	std	Z+3, r25	; 0x03
    f982:	82 83       	std	Z+2, r24	; 0x02
    f984:	80 91 6a 03 	lds	r24, 0x036A
    f988:	84 83       	std	Z+4, r24	; 0x04
    f98a:	15 82       	std	Z+5, r1	; 0x05
    f98c:	80 91 b4 08 	lds	r24, 0x08B4
    f990:	86 83       	std	Z+6, r24	; 0x06
    f992:	17 82       	std	Z+7, r1	; 0x07
    f994:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    f998:	f8 01       	movw	r30, r16
    f99a:	01 90       	ld	r0, Z+
    f99c:	00 20       	and	r0, r0
    f99e:	e9 f7       	brne	.-6      	; 0xf99a <GSM_Cycle+0xdfc>
    f9a0:	8f 01       	movw	r16, r30
    f9a2:	01 50       	subi	r16, 0x01	; 1
    f9a4:	10 40       	sbci	r17, 0x00	; 0
    f9a6:	01 5a       	subi	r16, 0xA1	; 161
    f9a8:	1b 40       	sbci	r17, 0x0B	; 11
    f9aa:	00 93 c5 08 	sts	0x08C5, r16
							GSM_SendFirstChar();
    f9ae:	2d b7       	in	r18, 0x3d	; 61
    f9b0:	3e b7       	in	r19, 0x3e	; 62
    f9b2:	28 5f       	subi	r18, 0xF8	; 248
    f9b4:	3f 4f       	sbci	r19, 0xFF	; 255
    f9b6:	0f b6       	in	r0, 0x3f	; 63
    f9b8:	f8 94       	cli
    f9ba:	3e bf       	out	0x3e, r19	; 62
    f9bc:	0f be       	out	0x3f, r0	; 63
    f9be:	2d bf       	out	0x3d, r18	; 61
    f9c0:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    f9c4:	80 91 5a 03 	lds	r24, 0x035A
    f9c8:	64 ef       	ldi	r22, 0xF4	; 244
    f9ca:	71 e0       	ldi	r23, 0x01	; 1
    f9cc:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
							GSM_State++;
    f9d0:	80 91 a4 05 	lds	r24, 0x05A4
    f9d4:	8f 5f       	subi	r24, 0xFF	; 255
    f9d6:	80 93 a4 05 	sts	0x05A4, r24
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    f9da:	80 91 e7 08 	lds	r24, 0x08E7
    f9de:	81 30       	cpi	r24, 0x01	; 1
    f9e0:	09 f0       	breq	.+2      	; 0xf9e4 <GSM_Cycle+0xe46>
    f9e2:	01 c6       	rjmp	.+3074   	; 0x105e6 <GSM_Cycle+0x1a48>
				if(GSM_Flag & (1<<flg_TxCStr)){
    f9e4:	80 91 d1 01 	lds	r24, 0x01D1
    f9e8:	80 ff       	sbrs	r24, 0
    f9ea:	fd c5       	rjmp	.+3066   	; 0x105e6 <GSM_Cycle+0x1a48>
					GSMTxSz = strlen_P(AT_CIPSEND);
    f9ec:	47 e1       	ldi	r20, 0x17	; 23
    f9ee:	e4 2e       	mov	r14, r20
    f9f0:	44 e0       	ldi	r20, 0x04	; 4
    f9f2:	f4 2e       	mov	r15, r20
    f9f4:	c7 01       	movw	r24, r14
    f9f6:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    f9fa:	80 93 c5 08 	sts	0x08C5, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    f9fe:	00 d0       	rcall	.+0      	; 0xfa00 <GSM_Cycle+0xe62>
    fa00:	00 d0       	rcall	.+0      	; 0xfa02 <GSM_Cycle+0xe64>
    fa02:	01 ea       	ldi	r16, 0xA1	; 161
    fa04:	1b e0       	ldi	r17, 0x0B	; 11
    fa06:	ad b7       	in	r26, 0x3d	; 61
    fa08:	be b7       	in	r27, 0x3e	; 62
    fa0a:	12 96       	adiw	r26, 0x02	; 2
    fa0c:	1c 93       	st	X, r17
    fa0e:	0e 93       	st	-X, r16
    fa10:	11 97       	sbiw	r26, 0x01	; 1
    fa12:	14 96       	adiw	r26, 0x04	; 4
    fa14:	fc 92       	st	X, r15
    fa16:	ee 92       	st	-X, r14
    fa18:	13 97       	sbiw	r26, 0x03	; 3
    fa1a:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    fa1e:	80 91 c5 08 	lds	r24, 0x08C5
    fa22:	00 d0       	rcall	.+0      	; 0xfa24 <GSM_Cycle+0xe86>
    fa24:	00 d0       	rcall	.+0      	; 0xfa26 <GSM_Cycle+0xe88>
    fa26:	ed b7       	in	r30, 0x3d	; 61
    fa28:	fe b7       	in	r31, 0x3e	; 62
    fa2a:	31 96       	adiw	r30, 0x01	; 1
    fa2c:	90 e0       	ldi	r25, 0x00	; 0
    fa2e:	80 0f       	add	r24, r16
    fa30:	91 1f       	adc	r25, r17
    fa32:	ad b7       	in	r26, 0x3d	; 61
    fa34:	be b7       	in	r27, 0x3e	; 62
    fa36:	12 96       	adiw	r26, 0x02	; 2
    fa38:	9c 93       	st	X, r25
    fa3a:	8e 93       	st	-X, r24
    fa3c:	11 97       	sbiw	r26, 0x01	; 1
    fa3e:	84 ec       	ldi	r24, 0xC4	; 196
    fa40:	91 e0       	ldi	r25, 0x01	; 1
    fa42:	93 83       	std	Z+3, r25	; 0x03
    fa44:	82 83       	std	Z+2, r24	; 0x02
    fa46:	80 91 d2 01 	lds	r24, 0x01D2
    fa4a:	84 83       	std	Z+4, r24	; 0x04
    fa4c:	15 82       	std	Z+5, r1	; 0x05
    fa4e:	80 91 b4 08 	lds	r24, 0x08B4
    fa52:	86 83       	std	Z+6, r24	; 0x06
    fa54:	17 82       	std	Z+7, r1	; 0x07
    fa56:	0e 94 2d 88 	call	0x1105a	; 0x1105a <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    fa5a:	f8 01       	movw	r30, r16
    fa5c:	01 90       	ld	r0, Z+
    fa5e:	00 20       	and	r0, r0
    fa60:	e9 f7       	brne	.-6      	; 0xfa5c <GSM_Cycle+0xebe>
    fa62:	8f 01       	movw	r16, r30
    fa64:	01 50       	subi	r16, 0x01	; 1
    fa66:	10 40       	sbci	r17, 0x00	; 0
    fa68:	01 5a       	subi	r16, 0xA1	; 161
    fa6a:	1b 40       	sbci	r17, 0x0B	; 11
    fa6c:	00 93 c5 08 	sts	0x08C5, r16
					GSM_SendFirstChar();
    fa70:	2d b7       	in	r18, 0x3d	; 61
    fa72:	3e b7       	in	r19, 0x3e	; 62
    fa74:	28 5f       	subi	r18, 0xF8	; 248
    fa76:	3f 4f       	sbci	r19, 0xFF	; 255
    fa78:	0f b6       	in	r0, 0x3f	; 63
    fa7a:	f8 94       	cli
    fa7c:	3e bf       	out	0x3e, r19	; 62
    fa7e:	0f be       	out	0x3f, r0	; 63
    fa80:	2d bf       	out	0x3d, r18	; 61
    fa82:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    fa86:	80 91 5a 03 	lds	r24, 0x035A
    fa8a:	64 ef       	ldi	r22, 0xF4	; 244
    fa8c:	71 e0       	ldi	r23, 0x01	; 1
    fa8e:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					GSM_State++;
    fa92:	80 91 a4 05 	lds	r24, 0x05A4
    fa96:	8f 5f       	subi	r24, 0xFF	; 255
    fa98:	80 93 a4 05 	sts	0x05A4, r24
    fa9c:	a4 c5       	rjmp	.+2888   	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    fa9e:	8e e3       	ldi	r24, 0x3E	; 62
    faa0:	68 e2       	ldi	r22, 0x28	; 40
    faa2:	0e 94 1e 39 	call	0x723c	; 0x723c <GSM_Wait_Char>
    faa6:	88 23       	and	r24, r24
    faa8:	29 f0       	breq	.+10     	; 0xfab4 <GSM_Cycle+0xf16>
    faaa:	80 91 a4 05 	lds	r24, 0x05A4
    faae:	8f 5f       	subi	r24, 0xFF	; 255
    fab0:	80 93 a4 05 	sts	0x05A4, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    fab4:	80 91 a4 05 	lds	r24, 0x05A4
    fab8:	88 32       	cpi	r24, 0x28	; 40
    faba:	09 f0       	breq	.+2      	; 0xfabe <GSM_Cycle+0xf20>
    fabc:	94 c5       	rjmp	.+2856   	; 0x105e6 <GSM_Cycle+0x1a48>
    fabe:	10 92 b4 08 	sts	0x08B4, r1
    fac2:	91 c5       	rjmp	.+2850   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    fac4:	81 ea       	ldi	r24, 0xA1	; 161
    fac6:	9a e0       	ldi	r25, 0x0A	; 10
    fac8:	60 91 b4 08 	lds	r22, 0x08B4
    facc:	0e 94 b2 45 	call	0x8b64	; 0x8b64 <GSM_AddHeaderSendData>
			GSM_State++;
    fad0:	80 91 a4 05 	lds	r24, 0x05A4
    fad4:	8f 5f       	subi	r24, 0xFF	; 255
    fad6:	80 93 a4 05 	sts	0x05A4, r24
    fada:	85 c5       	rjmp	.+2826   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    fadc:	80 91 5a 03 	lds	r24, 0x035A
    fae0:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    fae4:	88 23       	and	r24, r24
    fae6:	29 f0       	breq	.+10     	; 0xfaf2 <GSM_Cycle+0xf54>
				GSM_State = GSM_ServerIdle;
    fae8:	88 e2       	ldi	r24, 0x28	; 40
    faea:	80 93 a4 05 	sts	0x05A4, r24
				GPRS_FlgSz_Out = 0;
    faee:	10 92 b4 08 	sts	0x08B4, r1
			}

			if(GetStringFromFIFO()){
    faf2:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    faf6:	88 23       	and	r24, r24
    faf8:	09 f4       	brne	.+2      	; 0xfafc <GSM_Cycle+0xf5e>
    fafa:	75 c5       	rjmp	.+2794   	; 0x105e6 <GSM_Cycle+0x1a48>
				if(GPRS_Protocol_Out == UDP){
    fafc:	80 91 e7 08 	lds	r24, 0x08E7
    fb00:	88 23       	and	r24, r24
    fb02:	e9 f4       	brne	.+58     	; 0xfb3e <GSM_Cycle+0xfa0>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    fb04:	8e 01       	movw	r16, r28
    fb06:	0e 5f       	subi	r16, 0xFE	; 254
    fb08:	1f 4f       	sbci	r17, 0xFF	; 255
    fb0a:	c8 01       	movw	r24, r16
    fb0c:	6d ed       	ldi	r22, 0xDD	; 221
    fb0e:	72 e0       	ldi	r23, 0x02	; 2
    fb10:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    fb14:	80 91 6a 03 	lds	r24, 0x036A
    fb18:	80 5d       	subi	r24, 0xD0	; 208
    fb1a:	8a 83       	std	Y+2, r24	; 0x02
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    fb1c:	84 ef       	ldi	r24, 0xF4	; 244
    fb1e:	98 e0       	ldi	r25, 0x08	; 8
    fb20:	b8 01       	movw	r22, r16
    fb22:	0e 94 0f 88 	call	0x1101e	; 0x1101e <strcmp>
    fb26:	00 97       	sbiw	r24, 0x00	; 0
    fb28:	51 f4       	brne	.+20     	; 0xfb3e <GSM_Cycle+0xfa0>
    fb2a:	7c c5       	rjmp	.+2808   	; 0x10624 <GSM_Cycle+0x1a86>
					strcpy_P(RightAnswer, RESP_SEND_OK);
					RightAnswer[0] = 0x30+TempNum;
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
						StartTimer16(TD_GSM,500);//min~ 2 sec
						if(++TempNum>3){
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    fb2c:	8e e2       	ldi	r24, 0x2E	; 46
    fb2e:	80 93 a4 05 	sts	0x05A4, r24
							GPRS_FlgSz_Out = 0;
    fb32:	10 92 b4 08 	sts	0x08B4, r1
    fb36:	03 c0       	rjmp	.+6      	; 0xfb3e <GSM_Cycle+0xfa0>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    fb38:	8a e2       	ldi	r24, 0x2A	; 42
    fb3a:	80 93 a4 05 	sts	0x05A4, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    fb3e:	80 91 e7 08 	lds	r24, 0x08E7
    fb42:	81 30       	cpi	r24, 0x01	; 1
    fb44:	09 f0       	breq	.+2      	; 0xfb48 <GSM_Cycle+0xfaa>
    fb46:	4f c5       	rjmp	.+2718   	; 0x105e6 <GSM_Cycle+0x1a48>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    fb48:	8e 01       	movw	r16, r28
    fb4a:	0e 5f       	subi	r16, 0xFE	; 254
    fb4c:	1f 4f       	sbci	r17, 0xFF	; 255
    fb4e:	c8 01       	movw	r24, r16
    fb50:	6d ed       	ldi	r22, 0xDD	; 221
    fb52:	72 e0       	ldi	r23, 0x02	; 2
    fb54:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    fb58:	80 91 d2 01 	lds	r24, 0x01D2
    fb5c:	80 5d       	subi	r24, 0xD0	; 208
    fb5e:	8a 83       	std	Y+2, r24	; 0x02
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    fb60:	84 ef       	ldi	r24, 0xF4	; 244
    fb62:	98 e0       	ldi	r25, 0x08	; 8
    fb64:	b8 01       	movw	r22, r16
    fb66:	0e 94 0f 88 	call	0x1101e	; 0x1101e <strcmp>
    fb6a:	00 97       	sbiw	r24, 0x00	; 0
    fb6c:	09 f0       	breq	.+2      	; 0xfb70 <GSM_Cycle+0xfd2>
    fb6e:	3b c5       	rjmp	.+2678   	; 0x105e6 <GSM_Cycle+0x1a48>
    fb70:	68 c5       	rjmp	.+2768   	; 0x10642 <GSM_Cycle+0x1aa4>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    fb72:	80 91 5a 03 	lds	r24, 0x035A
    fb76:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    fb7a:	88 23       	and	r24, r24
    fb7c:	09 f4       	brne	.+2      	; 0xfb80 <GSM_Cycle+0xfe2>
    fb7e:	33 c5       	rjmp	.+2662   	; 0x105e6 <GSM_Cycle+0x1a48>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    fb80:	10 92 b2 0d 	sts	0x0DB2, r1
				GSM_State = GSM_CIPSHUT;
    fb84:	87 e4       	ldi	r24, 0x47	; 71
    fb86:	80 93 a4 05 	sts	0x05A4, r24
    fb8a:	2d c5       	rjmp	.+2650   	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    fb8c:	81 e4       	ldi	r24, 0x41	; 65
    fb8e:	94 e0       	ldi	r25, 0x04	; 4
    fb90:	68 ee       	ldi	r22, 0xE8	; 232
    fb92:	73 e0       	ldi	r23, 0x03	; 3
    fb94:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    fb98:	80 91 a4 05 	lds	r24, 0x05A4
    fb9c:	8f 5f       	subi	r24, 0xFF	; 255
    fb9e:	80 93 a4 05 	sts	0x05A4, r24
    fba2:	21 c5       	rjmp	.+2626   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    fba4:	83 e0       	ldi	r24, 0x03	; 3
    fba6:	93 e0       	ldi	r25, 0x03	; 3
    fba8:	6b e4       	ldi	r22, 0x4B	; 75
    fbaa:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    fbae:	88 23       	and	r24, r24
    fbb0:	09 f4       	brne	.+2      	; 0xfbb4 <GSM_Cycle+0x1016>
    fbb2:	19 c5       	rjmp	.+2610   	; 0x105e6 <GSM_Cycle+0x1a48>
    fbb4:	83 e1       	ldi	r24, 0x13	; 19
    fbb6:	80 93 a4 05 	sts	0x05A4, r24
    fbba:	15 c5       	rjmp	.+2602   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    fbbc:	80 91 d1 01 	lds	r24, 0x01D1
    fbc0:	80 ff       	sbrs	r24, 0
    fbc2:	11 c5       	rjmp	.+2594   	; 0x105e6 <GSM_Cycle+0x1a48>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    fbc4:	01 ea       	ldi	r16, 0xA1	; 161
    fbc6:	1b e0       	ldi	r17, 0x0B	; 11
    fbc8:	60 91 6a 03 	lds	r22, 0x036A
    fbcc:	8d e0       	ldi	r24, 0x0D	; 13
    fbce:	68 9f       	mul	r22, r24
    fbd0:	b0 01       	movw	r22, r0
    fbd2:	11 24       	eor	r1, r1
    fbd4:	64 58       	subi	r22, 0x84	; 132
    fbd6:	7f 4f       	sbci	r23, 0xFF	; 255
    fbd8:	c8 01       	movw	r24, r16
    fbda:	4d e0       	ldi	r20, 0x0D	; 13
    fbdc:	50 e0       	ldi	r21, 0x00	; 0
    fbde:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
    fbe2:	d8 01       	movw	r26, r16
    fbe4:	0d 90       	ld	r0, X+
    fbe6:	00 20       	and	r0, r0
    fbe8:	e9 f7       	brne	.-6      	; 0xfbe4 <GSM_Cycle+0x1046>
    fbea:	8d 01       	movw	r16, r26
    fbec:	01 50       	subi	r16, 0x01	; 1
    fbee:	10 40       	sbci	r17, 0x00	; 0
    fbf0:	01 5a       	subi	r16, 0xA1	; 161
    fbf2:	1b 40       	sbci	r17, 0x0B	; 11
    fbf4:	00 93 c5 08 	sts	0x08C5, r16
    fbf8:	90 e0       	ldi	r25, 0x00	; 0
    fbfa:	20 e0       	ldi	r18, 0x00	; 0
    fbfc:	09 c0       	rjmp	.+18     	; 0xfc10 <GSM_Cycle+0x1072>
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
					if(GSM_TxStr[i] != '0') j++;
    fbfe:	e9 2f       	mov	r30, r25
    fc00:	f0 e0       	ldi	r31, 0x00	; 0
    fc02:	ef 55       	subi	r30, 0x5F	; 95
    fc04:	f4 4f       	sbci	r31, 0xF4	; 244
    fc06:	80 81       	ld	r24, Z
    fc08:	80 33       	cpi	r24, 0x30	; 48
    fc0a:	09 f0       	breq	.+2      	; 0xfc0e <GSM_Cycle+0x1070>
    fc0c:	2f 5f       	subi	r18, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    fc0e:	9f 5f       	subi	r25, 0xFF	; 255
    fc10:	80 91 c5 08 	lds	r24, 0x08C5
    fc14:	98 17       	cp	r25, r24
    fc16:	98 f3       	brcs	.-26     	; 0xfbfe <GSM_Cycle+0x1060>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    fc18:	22 23       	and	r18, r18
    fc1a:	09 f4       	brne	.+2      	; 0xfc1e <GSM_Cycle+0x1080>
    fc1c:	55 c0       	rjmp	.+170    	; 0xfcc8 <GSM_Cycle+0x112a>
					GSMTxSz = strlen_P(AT_CMGS);
    fc1e:	32 e7       	ldi	r19, 0x72	; 114
    fc20:	e3 2e       	mov	r14, r19
    fc22:	33 e0       	ldi	r19, 0x03	; 3
    fc24:	f3 2e       	mov	r15, r19
    fc26:	c7 01       	movw	r24, r14
    fc28:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    fc2c:	80 93 c5 08 	sts	0x08C5, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    fc30:	00 d0       	rcall	.+0      	; 0xfc32 <GSM_Cycle+0x1094>
    fc32:	00 d0       	rcall	.+0      	; 0xfc34 <GSM_Cycle+0x1096>
    fc34:	01 ea       	ldi	r16, 0xA1	; 161
    fc36:	1b e0       	ldi	r17, 0x0B	; 11
    fc38:	ed b7       	in	r30, 0x3d	; 61
    fc3a:	fe b7       	in	r31, 0x3e	; 62
    fc3c:	12 83       	std	Z+2, r17	; 0x02
    fc3e:	01 83       	std	Z+1, r16	; 0x01
    fc40:	f4 82       	std	Z+4, r15	; 0x04
    fc42:	e3 82       	std	Z+3, r14	; 0x03
    fc44:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    fc48:	80 91 c5 08 	lds	r24, 0x08C5
    fc4c:	0f 90       	pop	r0
    fc4e:	0f 90       	pop	r0
    fc50:	0f 90       	pop	r0
    fc52:	0f 90       	pop	r0
    fc54:	90 e0       	ldi	r25, 0x00	; 0
    fc56:	60 91 6a 03 	lds	r22, 0x036A
    fc5a:	2d e0       	ldi	r18, 0x0D	; 13
    fc5c:	62 9f       	mul	r22, r18
    fc5e:	b0 01       	movw	r22, r0
    fc60:	11 24       	eor	r1, r1
    fc62:	64 58       	subi	r22, 0x84	; 132
    fc64:	7f 4f       	sbci	r23, 0xFF	; 255
    fc66:	80 0f       	add	r24, r16
    fc68:	91 1f       	adc	r25, r17
    fc6a:	4d e0       	ldi	r20, 0x0D	; 13
    fc6c:	50 e0       	ldi	r21, 0x00	; 0
    fc6e:	0e 94 9c 8f 	call	0x11f38	; 0x11f38 <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    fc72:	f8 01       	movw	r30, r16
    fc74:	01 90       	ld	r0, Z+
    fc76:	00 20       	and	r0, r0
    fc78:	e9 f7       	brne	.-6      	; 0xfc74 <GSM_Cycle+0x10d6>
    fc7a:	31 97       	sbiw	r30, 0x01	; 1
    fc7c:	e0 1b       	sub	r30, r16
    fc7e:	f1 0b       	sbc	r31, r17
    fc80:	e0 93 c5 08 	sts	0x08C5, r30
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    fc84:	80 91 c5 08 	lds	r24, 0x08C5
    fc88:	90 e0       	ldi	r25, 0x00	; 0
    fc8a:	80 0f       	add	r24, r16
    fc8c:	91 1f       	adc	r25, r17
    fc8e:	69 ea       	ldi	r22, 0xA9	; 169
    fc90:	71 e0       	ldi	r23, 0x01	; 1
    fc92:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    fc96:	d8 01       	movw	r26, r16
    fc98:	0d 90       	ld	r0, X+
    fc9a:	00 20       	and	r0, r0
    fc9c:	e9 f7       	brne	.-6      	; 0xfc98 <GSM_Cycle+0x10fa>
    fc9e:	8d 01       	movw	r16, r26
    fca0:	01 50       	subi	r16, 0x01	; 1
    fca2:	10 40       	sbci	r17, 0x00	; 0
    fca4:	01 5a       	subi	r16, 0xA1	; 161
    fca6:	1b 40       	sbci	r17, 0x0B	; 11
    fca8:	00 93 c5 08 	sts	0x08C5, r16
					GSM_SendFirstChar();
    fcac:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    fcb0:	80 91 5a 03 	lds	r24, 0x035A
    fcb4:	64 ef       	ldi	r22, 0xF4	; 244
    fcb6:	71 e0       	ldi	r23, 0x01	; 1
    fcb8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					GSM_State++;
    fcbc:	80 91 a4 05 	lds	r24, 0x05A4
    fcc0:	8f 5f       	subi	r24, 0xFF	; 255
    fcc2:	80 93 a4 05 	sts	0x05A4, r24
    fcc6:	8f c4       	rjmp	.+2334   	; 0x105e6 <GSM_Cycle+0x1a48>
				}
				else{
					TempNum++;
    fcc8:	80 91 6a 03 	lds	r24, 0x036A
    fccc:	8f 5f       	subi	r24, 0xFF	; 255
    fcce:	80 93 6a 03 	sts	0x036A, r24
					if(TempNum>=MaxTelephDirSz){
    fcd2:	83 30       	cpi	r24, 0x03	; 3
    fcd4:	08 f4       	brcc	.+2      	; 0xfcd8 <GSM_Cycle+0x113a>
    fcd6:	87 c4       	rjmp	.+2318   	; 0x105e6 <GSM_Cycle+0x1a48>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    fcd8:	88 e2       	ldi	r24, 0x28	; 40
    fcda:	80 93 a4 05 	sts	0x05A4, r24
						SMS_FlgSz_Out = 0;
    fcde:	10 92 d4 08 	sts	0x08D4, r1
    fce2:	81 c4       	rjmp	.+2306   	; 0x105e6 <GSM_Cycle+0x1a48>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    fce4:	8e e3       	ldi	r24, 0x3E	; 62
    fce6:	6b e4       	ldi	r22, 0x4B	; 75
    fce8:	0e 94 1e 39 	call	0x723c	; 0x723c <GSM_Wait_Char>
    fcec:	88 23       	and	r24, r24
    fcee:	09 f4       	brne	.+2      	; 0xfcf2 <GSM_Cycle+0x1154>
    fcf0:	7a c4       	rjmp	.+2292   	; 0x105e6 <GSM_Cycle+0x1a48>
    fcf2:	80 91 a4 05 	lds	r24, 0x05A4
    fcf6:	8f 5f       	subi	r24, 0xFF	; 255
    fcf8:	80 93 a4 05 	sts	0x05A4, r24
    fcfc:	74 c4       	rjmp	.+2280   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    fcfe:	60 91 d4 08 	lds	r22, 0x08D4
    fd02:	e6 2f       	mov	r30, r22
    fd04:	f0 e0       	ldi	r31, 0x00	; 0
    fd06:	e5 5b       	subi	r30, 0xB5	; 181
    fd08:	f7 4f       	sbci	r31, 0xF7	; 247
    fd0a:	8a e1       	ldi	r24, 0x1A	; 26
    fd0c:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    fd0e:	6f 5f       	subi	r22, 0xFF	; 255
    fd10:	8b e4       	ldi	r24, 0x4B	; 75
    fd12:	98 e0       	ldi	r25, 0x08	; 8
    fd14:	0e 94 a2 45 	call	0x8b44	; 0x8b44 <GSM_SendData>
			GSM_State++;
    fd18:	80 91 a4 05 	lds	r24, 0x05A4
    fd1c:	8f 5f       	subi	r24, 0xFF	; 255
    fd1e:	80 93 a4 05 	sts	0x05A4, r24
    fd22:	61 c4       	rjmp	.+2242   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    fd24:	83 eb       	ldi	r24, 0xB3	; 179
    fd26:	92 e0       	ldi	r25, 0x02	; 2
    fd28:	6b e4       	ldi	r22, 0x4B	; 75
    fd2a:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
    fd2e:	88 23       	and	r24, r24
    fd30:	09 f4       	brne	.+2      	; 0xfd34 <GSM_Cycle+0x1196>
    fd32:	59 c4       	rjmp	.+2226   	; 0x105e6 <GSM_Cycle+0x1a48>
				if(++TempNum>=MaxTelephDirSz){
    fd34:	80 91 6a 03 	lds	r24, 0x036A
    fd38:	8f 5f       	subi	r24, 0xFF	; 255
    fd3a:	80 93 6a 03 	sts	0x036A, r24
    fd3e:	83 30       	cpi	r24, 0x03	; 3
    fd40:	30 f0       	brcs	.+12     	; 0xfd4e <GSM_Cycle+0x11b0>
					GSM_State = GSM_ServerIdle;
    fd42:	88 e2       	ldi	r24, 0x28	; 40
    fd44:	80 93 a4 05 	sts	0x05A4, r24
					SMS_FlgSz_Out = 0;
    fd48:	10 92 d4 08 	sts	0x08D4, r1
    fd4c:	4c c4       	rjmp	.+2200   	; 0x105e6 <GSM_Cycle+0x1a48>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    fd4e:	8f e2       	ldi	r24, 0x2F	; 47
    fd50:	80 93 a4 05 	sts	0x05A4, r24
    fd54:	48 c4       	rjmp	.+2192   	; 0x105e6 <GSM_Cycle+0x1a48>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    fd56:	ed b7       	in	r30, 0x3d	; 61
    fd58:	fe b7       	in	r31, 0x3e	; 62
    fd5a:	3c 97       	sbiw	r30, 0x0c	; 12
    fd5c:	0f b6       	in	r0, 0x3f	; 63
    fd5e:	f8 94       	cli
    fd60:	fe bf       	out	0x3e, r31	; 62
    fd62:	0f be       	out	0x3f, r0	; 63
    fd64:	ed bf       	out	0x3d, r30	; 61
    fd66:	31 96       	adiw	r30, 0x01	; 1
    fd68:	84 ef       	ldi	r24, 0xF4	; 244
    fd6a:	98 e0       	ldi	r25, 0x08	; 8
    fd6c:	ad b7       	in	r26, 0x3d	; 61
    fd6e:	be b7       	in	r27, 0x3e	; 62
    fd70:	12 96       	adiw	r26, 0x02	; 2
    fd72:	9c 93       	st	X, r25
    fd74:	8e 93       	st	-X, r24
    fd76:	11 97       	sbiw	r26, 0x01	; 1
    fd78:	85 e8       	ldi	r24, 0x85	; 133
    fd7a:	99 e4       	ldi	r25, 0x49	; 73
    fd7c:	93 83       	std	Z+3, r25	; 0x03
    fd7e:	82 83       	std	Z+2, r24	; 0x02
    fd80:	82 ea       	ldi	r24, 0xA2	; 162
    fd82:	9c e0       	ldi	r25, 0x0C	; 12
    fd84:	95 83       	std	Z+5, r25	; 0x05
    fd86:	84 83       	std	Z+4, r24	; 0x04
    fd88:	01 96       	adiw	r24, 0x01	; 1
    fd8a:	97 83       	std	Z+7, r25	; 0x07
    fd8c:	86 83       	std	Z+6, r24	; 0x06
    fd8e:	01 96       	adiw	r24, 0x01	; 1
    fd90:	91 87       	std	Z+9, r25	; 0x09
    fd92:	80 87       	std	Z+8, r24	; 0x08
    fd94:	01 96       	adiw	r24, 0x01	; 1
    fd96:	93 87       	std	Z+11, r25	; 0x0b
    fd98:	82 87       	std	Z+10, r24	; 0x0a
    fd9a:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    fd9e:	10 92 6a 03 	sts	0x036A, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    fda2:	b0 90 a2 0c 	lds	r11, 0x0CA2
    fda6:	c0 90 a3 0c 	lds	r12, 0x0CA3
    fdaa:	d0 90 a4 0c 	lds	r13, 0x0CA4
    fdae:	10 91 a5 0c 	lds	r17, 0x0CA5
    fdb2:	26 e6       	ldi	r18, 0x66	; 102
    fdb4:	e2 2e       	mov	r14, r18
    fdb6:	20 e0       	ldi	r18, 0x00	; 0
    fdb8:	f2 2e       	mov	r15, r18
    fdba:	ed b7       	in	r30, 0x3d	; 61
    fdbc:	fe b7       	in	r31, 0x3e	; 62
    fdbe:	3c 96       	adiw	r30, 0x0c	; 12
    fdc0:	0f b6       	in	r0, 0x3f	; 63
    fdc2:	f8 94       	cli
    fdc4:	fe bf       	out	0x3e, r31	; 62
    fdc6:	0f be       	out	0x3f, r0	; 63
    fdc8:	ed bf       	out	0x3d, r30	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    fdca:	c7 01       	movw	r24, r14
    fdcc:	6f ef       	ldi	r22, 0xFF	; 255
    fdce:	4f ef       	ldi	r20, 0xFF	; 255
    fdd0:	2f ef       	ldi	r18, 0xFF	; 255
    fdd2:	0f ef       	ldi	r16, 0xFF	; 255
    fdd4:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <IP_E_compare_Const>
    fdd8:	88 23       	and	r24, r24
    fdda:	91 f4       	brne	.+36     	; 0xfe00 <GSM_Cycle+0x1262>
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    fddc:	c7 01       	movw	r24, r14
    fdde:	60 e0       	ldi	r22, 0x00	; 0
    fde0:	40 e0       	ldi	r20, 0x00	; 0
    fde2:	20 e0       	ldi	r18, 0x00	; 0
    fde4:	00 e0       	ldi	r16, 0x00	; 0
    fde6:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <IP_E_compare_Const>
    fdea:	88 23       	and	r24, r24
    fdec:	69 f4       	brne	.+26     	; 0xfe08 <GSM_Cycle+0x126a>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    fdee:	c7 01       	movw	r24, r14
    fdf0:	6b 2d       	mov	r22, r11
    fdf2:	4c 2d       	mov	r20, r12
    fdf4:	2d 2d       	mov	r18, r13
    fdf6:	01 2f       	mov	r16, r17
    fdf8:	0e 94 a2 75 	call	0xeb44	; 0xeb44 <IP_E_compare_Const>
    fdfc:	88 23       	and	r24, r24
    fdfe:	21 f0       	breq	.+8      	; 0xfe08 <GSM_Cycle+0x126a>
						TempNum = 1;
    fe00:	81 e0       	ldi	r24, 0x01	; 1
    fe02:	80 93 6a 03 	sts	0x036A, r24
    fe06:	09 c0       	rjmp	.+18     	; 0xfe1a <GSM_Cycle+0x127c>
    fe08:	24 e0       	ldi	r18, 0x04	; 4
    fe0a:	30 e0       	ldi	r19, 0x00	; 0
    fe0c:	e2 0e       	add	r14, r18
    fe0e:	f3 1e       	adc	r15, r19
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    fe10:	36 e7       	ldi	r19, 0x76	; 118
    fe12:	e3 16       	cp	r14, r19
    fe14:	30 e0       	ldi	r19, 0x00	; 0
    fe16:	f3 06       	cpc	r15, r19
    fe18:	c1 f6       	brne	.-80     	; 0xfdca <GSM_Cycle+0x122c>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    fe1a:	80 91 6a 03 	lds	r24, 0x036A
    fe1e:	88 23       	and	r24, r24
    fe20:	89 f0       	breq	.+34     	; 0xfe44 <GSM_Cycle+0x12a6>
				GSM_State = GSM_ServerIdle;
    fe22:	88 e2       	ldi	r24, 0x28	; 40
    fe24:	80 93 a4 05 	sts	0x05A4, r24
				GSM_ActiveConnection = GSM_Temp;
    fe28:	80 91 69 03 	lds	r24, 0x0369
    fe2c:	80 93 d2 01 	sts	0x01D2, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    fe30:	86 e7       	ldi	r24, 0x76	; 118
    fe32:	90 e0       	ldi	r25, 0x00	; 0
    fe34:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
    fe38:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    fe3a:	80 91 5b 03 	lds	r24, 0x035B
    fe3e:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
    fe42:	d1 c3       	rjmp	.+1954   	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    fe44:	84 e3       	ldi	r24, 0x34	; 52
    fe46:	80 93 a4 05 	sts	0x05A4, r24
    fe4a:	cd c3       	rjmp	.+1946   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    fe4c:	80 91 d1 01 	lds	r24, 0x01D1
    fe50:	80 ff       	sbrs	r24, 0
    fe52:	c9 c3       	rjmp	.+1938   	; 0x105e6 <GSM_Cycle+0x1a48>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    fe54:	03 e2       	ldi	r16, 0x23	; 35
    fe56:	14 e0       	ldi	r17, 0x04	; 4
    fe58:	c8 01       	movw	r24, r16
    fe5a:	0e 94 ca 87 	call	0x10f94	; 0x10f94 <strlen_P>
    fe5e:	80 93 c5 08 	sts	0x08C5, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    fe62:	00 d0       	rcall	.+0      	; 0xfe64 <GSM_Cycle+0x12c6>
    fe64:	00 d0       	rcall	.+0      	; 0xfe66 <GSM_Cycle+0x12c8>
    fe66:	81 ea       	ldi	r24, 0xA1	; 161
    fe68:	9b e0       	ldi	r25, 0x0B	; 11
    fe6a:	ad b7       	in	r26, 0x3d	; 61
    fe6c:	be b7       	in	r27, 0x3e	; 62
    fe6e:	12 96       	adiw	r26, 0x02	; 2
    fe70:	9c 93       	st	X, r25
    fe72:	8e 93       	st	-X, r24
    fe74:	11 97       	sbiw	r26, 0x01	; 1
    fe76:	14 96       	adiw	r26, 0x04	; 4
    fe78:	1c 93       	st	X, r17
    fe7a:	0e 93       	st	-X, r16
    fe7c:	13 97       	sbiw	r26, 0x03	; 3
    fe7e:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    fe82:	80 91 c5 08 	lds	r24, 0x08C5
    fe86:	0f 90       	pop	r0
    fe88:	0f 90       	pop	r0
    fe8a:	0f 90       	pop	r0
    fe8c:	0f 90       	pop	r0
    fe8e:	90 e0       	ldi	r25, 0x00	; 0
    fe90:	8f 55       	subi	r24, 0x5F	; 95
    fe92:	94 4f       	sbci	r25, 0xF4	; 244
    fe94:	66 e8       	ldi	r22, 0x86	; 134
    fe96:	71 e0       	ldi	r23, 0x01	; 1
    fe98:	0e 94 18 88 	call	0x11030	; 0x11030 <strcpy>
				GSMTxSz++;
    fe9c:	80 91 c5 08 	lds	r24, 0x08C5
    fea0:	8f 5f       	subi	r24, 0xFF	; 255
    fea2:	80 93 c5 08 	sts	0x08C5, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    fea6:	80 91 69 03 	lds	r24, 0x0369
    feaa:	80 5d       	subi	r24, 0xD0	; 208
    feac:	80 93 ad 0b 	sts	0x0BAD, r24
				GSM_SendFirstChar();
    feb0:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    feb4:	80 91 5a 03 	lds	r24, 0x035A
    feb8:	64 ef       	ldi	r22, 0xF4	; 244
    feba:	71 e0       	ldi	r23, 0x01	; 1
    febc:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_State++;
    fec0:	80 91 a4 05 	lds	r24, 0x05A4
    fec4:	8f 5f       	subi	r24, 0xFF	; 255
    fec6:	80 93 a4 05 	sts	0x05A4, r24
    feca:	8d c3       	rjmp	.+1818   	; 0x105e6 <GSM_Cycle+0x1a48>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    fecc:	80 91 5a 03 	lds	r24, 0x035A
    fed0:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    fed4:	88 23       	and	r24, r24
    fed6:	19 f0       	breq	.+6      	; 0xfede <GSM_Cycle+0x1340>
    fed8:	8b e4       	ldi	r24, 0x4B	; 75
    feda:	80 93 a4 05 	sts	0x05A4, r24
			if(GetStringFromFIFO()){
    fede:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
    fee2:	88 23       	and	r24, r24
    fee4:	09 f4       	brne	.+2      	; 0xfee8 <GSM_Cycle+0x134a>
    fee6:	7f c3       	rjmp	.+1790   	; 0x105e6 <GSM_Cycle+0x1a48>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    fee8:	8e 01       	movw	r16, r28
    feea:	03 5f       	subi	r16, 0xF3	; 243
    feec:	1f 4f       	sbci	r17, 0xFF	; 255
    feee:	c8 01       	movw	r24, r16
    fef0:	61 ef       	ldi	r22, 0xF1	; 241
    fef2:	72 e0       	ldi	r23, 0x02	; 2
    fef4:	0e 94 af 87 	call	0x10f5e	; 0x10f5e <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    fef8:	80 91 69 03 	lds	r24, 0x0369
    fefc:	80 5d       	subi	r24, 0xD0	; 208
    fefe:	8d 87       	std	Y+13, r24	; 0x0d
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    ff00:	84 ef       	ldi	r24, 0xF4	; 244
    ff02:	98 e0       	ldi	r25, 0x08	; 8
    ff04:	b8 01       	movw	r22, r16
    ff06:	0e 94 0f 88 	call	0x1101e	; 0x1101e <strcmp>
    ff0a:	00 97       	sbiw	r24, 0x00	; 0
    ff0c:	09 f0       	breq	.+2      	; 0xff10 <GSM_Cycle+0x1372>
    ff0e:	6b c3       	rjmp	.+1750   	; 0x105e6 <GSM_Cycle+0x1a48>
    ff10:	9b c3       	rjmp	.+1846   	; 0x10648 <GSM_Cycle+0x1aaa>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
				RightAnswer[0] = 0x30+GSM_Temp;
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
					GSM_State = GSM_ServerIdle;
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    ff12:	80 91 5b 03 	lds	r24, 0x035B
    ff16:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    ff1a:	88 23       	and	r24, r24
    ff1c:	09 f4       	brne	.+2      	; 0xff20 <GSM_Cycle+0x1382>
    ff1e:	63 c3       	rjmp	.+1734   	; 0x105e6 <GSM_Cycle+0x1a48>
						GSM_ActiveConnection = NO_CONNECTION;
    ff20:	8f ef       	ldi	r24, 0xFF	; 255
    ff22:	80 93 d2 01 	sts	0x01D2, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    ff26:	10 92 a2 0c 	sts	0x0CA2, r1
	IP->IP2 = IP2;
    ff2a:	10 92 a3 0c 	sts	0x0CA3, r1
	IP->IP3 = IP3;
    ff2e:	10 92 a4 0c 	sts	0x0CA4, r1
	IP->IP4 = IP4;
    ff32:	10 92 a5 0c 	sts	0x0CA5, r1
    ff36:	57 c3       	rjmp	.+1710   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    ff38:	ed b7       	in	r30, 0x3d	; 61
    ff3a:	fe b7       	in	r31, 0x3e	; 62
    ff3c:	38 97       	sbiw	r30, 0x08	; 8
    ff3e:	0f b6       	in	r0, 0x3f	; 63
    ff40:	f8 94       	cli
    ff42:	fe bf       	out	0x3e, r31	; 62
    ff44:	0f be       	out	0x3f, r0	; 63
    ff46:	ed bf       	out	0x3d, r30	; 61
    ff48:	31 96       	adiw	r30, 0x01	; 1
    ff4a:	84 ef       	ldi	r24, 0xF4	; 244
    ff4c:	98 e0       	ldi	r25, 0x08	; 8
    ff4e:	ad b7       	in	r26, 0x3d	; 61
    ff50:	be b7       	in	r27, 0x3e	; 62
    ff52:	12 96       	adiw	r26, 0x02	; 2
    ff54:	9c 93       	st	X, r25
    ff56:	8e 93       	st	-X, r24
    ff58:	11 97       	sbiw	r26, 0x01	; 1
    ff5a:	82 e7       	ldi	r24, 0x72	; 114
    ff5c:	99 e4       	ldi	r25, 0x49	; 73
    ff5e:	93 83       	std	Z+3, r25	; 0x03
    ff60:	82 83       	std	Z+2, r24	; 0x02
    ff62:	ce 01       	movw	r24, r28
    ff64:	01 96       	adiw	r24, 0x01	; 1
    ff66:	95 83       	std	Z+5, r25	; 0x05
    ff68:	84 83       	std	Z+4, r24	; 0x04
    ff6a:	89 e6       	ldi	r24, 0x69	; 105
    ff6c:	93 e0       	ldi	r25, 0x03	; 3
    ff6e:	97 83       	std	Z+7, r25	; 0x07
    ff70:	86 83       	std	Z+6, r24	; 0x06
    ff72:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    ff76:	ed b7       	in	r30, 0x3d	; 61
    ff78:	fe b7       	in	r31, 0x3e	; 62
    ff7a:	38 96       	adiw	r30, 0x08	; 8
    ff7c:	0f b6       	in	r0, 0x3f	; 63
    ff7e:	f8 94       	cli
    ff80:	fe bf       	out	0x3e, r31	; 62
    ff82:	0f be       	out	0x3f, r0	; 63
    ff84:	ed bf       	out	0x3d, r30	; 61
    ff86:	99 81       	ldd	r25, Y+1	; 0x01
    ff88:	80 91 d2 01 	lds	r24, 0x01D2
    ff8c:	98 17       	cp	r25, r24
    ff8e:	61 f4       	brne	.+24     	; 0xffa8 <GSM_Cycle+0x140a>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    ff90:	80 91 5a 03 	lds	r24, 0x035A
    ff94:	64 ef       	ldi	r22, 0xF4	; 244
    ff96:	71 e0       	ldi	r23, 0x01	; 1
    ff98:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
					GSM_State++;
    ff9c:	80 91 a4 05 	lds	r24, 0x05A4
    ffa0:	8f 5f       	subi	r24, 0xFF	; 255
    ffa2:	80 93 a4 05 	sts	0x05A4, r24
    ffa6:	1f c3       	rjmp	.+1598   	; 0x105e6 <GSM_Cycle+0x1a48>
					break;
				}
				GSM_State = GSM_ServerIdle;
    ffa8:	88 e2       	ldi	r24, 0x28	; 40
    ffaa:	80 93 a4 05 	sts	0x05A4, r24
    ffae:	1b c3       	rjmp	.+1590   	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    ffb0:	80 91 5a 03 	lds	r24, 0x035A
    ffb4:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    ffb8:	88 23       	and	r24, r24
    ffba:	19 f0       	breq	.+6      	; 0xffc2 <GSM_Cycle+0x1424>
    ffbc:	8b e4       	ldi	r24, 0x4B	; 75
    ffbe:	80 93 a4 05 	sts	0x05A4, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    ffc2:	80 91 69 03 	lds	r24, 0x0369
    ffc6:	80 93 cb 08 	sts	0x08CB, r24

			GSM_State = GSM_ServerIdle;
    ffca:	88 e2       	ldi	r24, 0x28	; 40
    ffcc:	80 93 a4 05 	sts	0x05A4, r24
    ffd0:	0a c3       	rjmp	.+1556   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    ffd2:	83 e3       	ldi	r24, 0x33	; 51
    ffd4:	94 e0       	ldi	r25, 0x04	; 4
    ffd6:	60 e7       	ldi	r22, 0x70	; 112
    ffd8:	77 e1       	ldi	r23, 0x17	; 23
    ffda:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
    ffde:	80 91 a4 05 	lds	r24, 0x05A4
    ffe2:	8f 5f       	subi	r24, 0xFF	; 255
    ffe4:	80 93 a4 05 	sts	0x05A4, r24
    ffe8:	fe c2       	rjmp	.+1532   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    ffea:	80 91 5a 03 	lds	r24, 0x035A
    ffee:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
    fff2:	88 23       	and	r24, r24
    fff4:	19 f0       	breq	.+6      	; 0xfffc <GSM_Cycle+0x145e>
    fff6:	8b e4       	ldi	r24, 0x4B	; 75
    fff8:	80 93 a4 05 	sts	0x05A4, r24
			//  
			if(GetStringFromFIFO()){
    fffc:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
   10000:	88 23       	and	r24, r24
   10002:	09 f4       	brne	.+2      	; 0x10006 <GSM_Cycle+0x1468>
   10004:	f0 c2       	rjmp	.+1504   	; 0x105e6 <GSM_Cycle+0x1a48>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
   10006:	84 ef       	ldi	r24, 0xF4	; 244
   10008:	98 e0       	ldi	r25, 0x08	; 8
   1000a:	68 ee       	ldi	r22, 0xE8	; 232
   1000c:	72 e0       	ldi	r23, 0x02	; 2
   1000e:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
   10012:	89 2b       	or	r24, r25
   10014:	49 f0       	breq	.+18     	; 0x10028 <GSM_Cycle+0x148a>
   10016:	84 ef       	ldi	r24, 0xF4	; 244
   10018:	98 e0       	ldi	r25, 0x08	; 8
   1001a:	61 e9       	ldi	r22, 0x91	; 145
   1001c:	72 e0       	ldi	r23, 0x02	; 2
   1001e:	0e 94 a6 87 	call	0x10f4c	; 0x10f4c <strcmp_P>
   10022:	89 2b       	or	r24, r25
   10024:	09 f0       	breq	.+2      	; 0x10028 <GSM_Cycle+0x148a>
   10026:	df c2       	rjmp	.+1470   	; 0x105e6 <GSM_Cycle+0x1a48>
					GSM_State = GSM_ServerIdle;
   10028:	88 e2       	ldi	r24, 0x28	; 40
   1002a:	80 93 a4 05 	sts	0x05A4, r24
					GPRS_FlgSz_Out = 0;						
   1002e:	10 92 b4 08 	sts	0x08B4, r1
   10032:	d9 c2       	rjmp	.+1458   	; 0x105e6 <GSM_Cycle+0x1a48>
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
	sei();
}
void GSM_PWRCNTRL_OFF(void){
	cli();
   10034:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
   10036:	1f 98       	cbi	0x03, 7	; 3
	sei();
   10038:	78 94       	sei

		
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
			StartTimer16(TD_GSM,1000);
   1003a:	80 91 5a 03 	lds	r24, 0x035A
   1003e:	68 ee       	ldi	r22, 0xE8	; 232
   10040:	73 e0       	ldi	r23, 0x03	; 3
   10042:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			RxBufOverFlow = 0;
   10046:	10 92 a1 0c 	sts	0x0CA1, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
   1004a:	10 92 d4 08 	sts	0x08D4, r1
			GSM_ActiveConnection = NO_CONNECTION;
   1004e:	8f ef       	ldi	r24, 0xFF	; 255
   10050:	80 93 d2 01 	sts	0x01D2, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
   10054:	10 92 a2 0c 	sts	0x0CA2, r1
	IP->IP2 = IP2;
   10058:	10 92 a3 0c 	sts	0x0CA3, r1
	IP->IP3 = IP3;
   1005c:	10 92 a4 0c 	sts	0x0CA4, r1
	IP->IP4 = IP4;
   10060:	10 92 a5 0c 	sts	0x0CA5, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
   10064:	80 91 d1 01 	lds	r24, 0x01D1
   10068:	81 60       	ori	r24, 0x01	; 1
   1006a:	80 93 d1 01 	sts	0x01D1, r24
			GSM_State++;
   1006e:	80 91 a4 05 	lds	r24, 0x05A4
   10072:	8f 5f       	subi	r24, 0xFF	; 255
   10074:	80 93 a4 05 	sts	0x05A4, r24
   10078:	b6 c2       	rjmp	.+1388   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
   1007a:	80 91 5a 03 	lds	r24, 0x035A
   1007e:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10082:	88 23       	and	r24, r24
   10084:	09 f4       	brne	.+2      	; 0x10088 <GSM_Cycle+0x14ea>
   10086:	af c2       	rjmp	.+1374   	; 0x105e6 <GSM_Cycle+0x1a48>
				GSM_State = GSM_PowerOn;
   10088:	10 92 a4 05 	sts	0x05A4, r1
   1008c:	ac c2       	rjmp	.+1368   	; 0x105e6 <GSM_Cycle+0x1a48>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
   1008e:	88 e0       	ldi	r24, 0x08	; 8
   10090:	94 e0       	ldi	r25, 0x04	; 4
   10092:	64 ef       	ldi	r22, 0xF4	; 244
   10094:	71 e0       	ldi	r23, 0x01	; 1
   10096:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
   1009a:	80 91 a4 05 	lds	r24, 0x05A4
   1009e:	8f 5f       	subi	r24, 0xFF	; 255
   100a0:	80 93 a4 05 	sts	0x05A4, r24
   100a4:	a0 c2       	rjmp	.+1344   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
   100a6:	83 eb       	ldi	r24, 0xB3	; 179
   100a8:	92 e0       	ldi	r25, 0x02	; 2
   100aa:	6b e4       	ldi	r22, 0x4B	; 75
   100ac:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   100b0:	88 23       	and	r24, r24
   100b2:	09 f4       	brne	.+2      	; 0x100b6 <GSM_Cycle+0x1518>
   100b4:	98 c2       	rjmp	.+1328   	; 0x105e6 <GSM_Cycle+0x1a48>
   100b6:	80 91 a4 05 	lds	r24, 0x05A4
   100ba:	8f 5f       	subi	r24, 0xFF	; 255
   100bc:	80 93 a4 05 	sts	0x05A4, r24
   100c0:	92 c2       	rjmp	.+1316   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
   100c2:	8e ec       	ldi	r24, 0xCE	; 206
   100c4:	92 e0       	ldi	r25, 0x02	; 2
   100c6:	6b e4       	ldi	r22, 0x4B	; 75
   100c8:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   100cc:	88 23       	and	r24, r24
   100ce:	09 f4       	brne	.+2      	; 0x100d2 <GSM_Cycle+0x1534>
   100d0:	8a c2       	rjmp	.+1300   	; 0x105e6 <GSM_Cycle+0x1a48>
   100d2:	85 e2       	ldi	r24, 0x25	; 37
   100d4:	80 93 a4 05 	sts	0x05A4, r24
   100d8:	86 c2       	rjmp	.+1292   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
   100da:	8c e4       	ldi	r24, 0x4C	; 76
   100dc:	94 e0       	ldi	r25, 0x04	; 4
   100de:	64 ef       	ldi	r22, 0xF4	; 244
   100e0:	71 e0       	ldi	r23, 0x01	; 1
   100e2:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
   100e6:	80 91 5c 03 	lds	r24, 0x035C
   100ea:	60 e7       	ldi	r22, 0x70	; 112
   100ec:	77 e1       	ldi	r23, 0x17	; 23
   100ee:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			GSM_State = GSM_ServerIdle;
   100f2:	88 e2       	ldi	r24, 0x28	; 40
   100f4:	80 93 a4 05 	sts	0x05A4, r24
   100f8:	76 c2       	rjmp	.+1260   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
   100fa:	8f ef       	ldi	r24, 0xFF	; 255
   100fc:	80 93 a2 05 	sts	0x05A2, r24
   10100:	80 93 d9 08 	sts	0x08D9, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
   10104:	2d b7       	in	r18, 0x3d	; 61
   10106:	3e b7       	in	r19, 0x3e	; 62
   10108:	28 50       	subi	r18, 0x08	; 8
   1010a:	30 40       	sbci	r19, 0x00	; 0
   1010c:	0f b6       	in	r0, 0x3f	; 63
   1010e:	f8 94       	cli
   10110:	3e bf       	out	0x3e, r19	; 62
   10112:	0f be       	out	0x3f, r0	; 63
   10114:	2d bf       	out	0x3d, r18	; 61
   10116:	ed b7       	in	r30, 0x3d	; 61
   10118:	fe b7       	in	r31, 0x3e	; 62
   1011a:	31 96       	adiw	r30, 0x01	; 1
   1011c:	84 ef       	ldi	r24, 0xF4	; 244
   1011e:	98 e0       	ldi	r25, 0x08	; 8
   10120:	ad b7       	in	r26, 0x3d	; 61
   10122:	be b7       	in	r27, 0x3e	; 62
   10124:	12 96       	adiw	r26, 0x02	; 2
   10126:	9c 93       	st	X, r25
   10128:	8e 93       	st	-X, r24
   1012a:	11 97       	sbiw	r26, 0x01	; 1
   1012c:	82 e6       	ldi	r24, 0x62	; 98
   1012e:	99 e4       	ldi	r25, 0x49	; 73
   10130:	93 83       	std	Z+3, r25	; 0x03
   10132:	82 83       	std	Z+2, r24	; 0x02
   10134:	82 ea       	ldi	r24, 0xA2	; 162
   10136:	95 e0       	ldi	r25, 0x05	; 5
   10138:	95 83       	std	Z+5, r25	; 0x05
   1013a:	84 83       	std	Z+4, r24	; 0x04
   1013c:	89 ed       	ldi	r24, 0xD9	; 217
   1013e:	98 e0       	ldi	r25, 0x08	; 8
   10140:	97 83       	std	Z+7, r25	; 0x07
   10142:	86 83       	std	Z+6, r24	; 0x06
   10144:	0e 94 b2 88 	call	0x11164	; 0x11164 <sscanf_P>
			GSM_State = GSM_ServerIdle;
   10148:	88 e2       	ldi	r24, 0x28	; 40
   1014a:	80 93 a4 05 	sts	0x05A4, r24
   1014e:	ed b7       	in	r30, 0x3d	; 61
   10150:	fe b7       	in	r31, 0x3e	; 62
   10152:	38 96       	adiw	r30, 0x08	; 8
   10154:	0f b6       	in	r0, 0x3f	; 63
   10156:	f8 94       	cli
   10158:	fe bf       	out	0x3e, r31	; 62
   1015a:	0f be       	out	0x3f, r0	; 63
   1015c:	ed bf       	out	0x3d, r30	; 61
   1015e:	43 c2       	rjmp	.+1158   	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			
			if(GSM_CSD == 1){	//  CSD   
   10160:	90 91 ba 08 	lds	r25, 0x08BA
   10164:	91 30       	cpi	r25, 0x01	; 1
   10166:	09 f0       	breq	.+2      	; 0x1016a <GSM_Cycle+0x15cc>
   10168:	84 c0       	rjmp	.+264    	; 0x10272 <GSM_Cycle+0x16d4>
				AppProtocol=0;	
   1016a:	10 92 5f 09 	sts	0x095F, r1
				GSM_State = GSM_DataMode;
   1016e:	83 e5       	ldi	r24, 0x53	; 83
   10170:	80 93 a4 05 	sts	0x05A4, r24
				if(UART_Soft){
   10174:	80 91 df 09 	lds	r24, 0x09DF
   10178:	88 23       	and	r24, r24
   1017a:	21 f0       	breq	.+8      	; 0x10184 <GSM_Cycle+0x15e6>
					GSM_State = GSM_Swtch2CommandMode;
   1017c:	84 e5       	ldi	r24, 0x54	; 84
   1017e:	80 93 a4 05 	sts	0x05A4, r24
   10182:	31 c2       	rjmp	.+1122   	; 0x105e6 <GSM_Cycle+0x1a48>
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
   10184:	8f ef       	ldi	r24, 0xFF	; 255
   10186:	80 93 dd 08 	sts	0x08DD, r24
	EM_RX_FIFO_End = 255;
   1018a:	80 93 a0 0c 	sts	0x0CA0, r24
	EMeter_RxCharN = 0;
   1018e:	10 92 a7 0c 	sts	0x0CA7, r1
   10192:	10 92 a6 0c 	sts	0x0CA6, r1
				}
				else{
					EM_InitFIFO();
					Transparent = 1;
   10196:	90 93 e0 09 	sts	0x09E0, r25
   1019a:	86 e7       	ldi	r24, 0x76	; 118
   1019c:	90 e0       	ldi	r25, 0x00	; 0
   1019e:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
   101a2:	bc 01       	movw	r22, r24
					StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
   101a4:	80 91 5b 03 	lds	r24, 0x035B
   101a8:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
   101ac:	1c c2       	rjmp	.+1080   	; 0x105e6 <GSM_Cycle+0x1a48>
			}

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
				
				static uint8_t GSM_RX_FIFO_End_old;	//     4 
				if(!GSM_RxCharN) GSM_RX_FIFO_End_old = GSM_RX_FIFO_End;
   101ae:	80 91 ac 0c 	lds	r24, 0x0CAC
   101b2:	88 23       	and	r24, r24
   101b4:	11 f4       	brne	.+4      	; 0x101ba <GSM_Cycle+0x161c>
   101b6:	90 93 f9 01 	sts	0x01F9, r25
				
				GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
   101ba:	84 ef       	ldi	r24, 0xF4	; 244
   101bc:	98 e0       	ldi	r25, 0x08	; 8
   101be:	6c ea       	ldi	r22, 0xAC	; 172
   101c0:	7c e0       	ldi	r23, 0x0C	; 12
   101c2:	44 e6       	ldi	r20, 0x64	; 100
   101c4:	0e 94 25 38 	call	0x704a	; 0x704a <GetByteFromFIFO>
				if(GSM_RxCharN >= 4){
   101c8:	80 91 ac 0c 	lds	r24, 0x0CAC
   101cc:	84 30       	cpi	r24, 0x04	; 4
   101ce:	08 f4       	brcc	.+2      	; 0x101d2 <GSM_Cycle+0x1634>
   101d0:	50 c0       	rjmp	.+160    	; 0x10272 <GSM_Cycle+0x16d4>
					AppProtocol = 0;
   101d2:	10 92 5f 09 	sts	0x095F, r1
					if(!strncmp_P(GSM_RxStr, PSTR("GET "), 4)) AppProtocol = _HTTP;
   101d6:	84 ef       	ldi	r24, 0xF4	; 244
   101d8:	98 e0       	ldi	r25, 0x08	; 8
   101da:	6d e5       	ldi	r22, 0x5D	; 93
   101dc:	79 e4       	ldi	r23, 0x49	; 73
   101de:	44 e0       	ldi	r20, 0x04	; 4
   101e0:	50 e0       	ldi	r21, 0x00	; 0
   101e2:	0e 94 d3 87 	call	0x10fa6	; 0x10fa6 <strncmp_P>
   101e6:	89 2b       	or	r24, r25
   101e8:	19 f4       	brne	.+6      	; 0x101f0 <GSM_Cycle+0x1652>
   101ea:	81 e0       	ldi	r24, 0x01	; 1
   101ec:	80 93 5f 09 	sts	0x095F, r24
					if(!strncmp_P(GSM_RxStr, PSTR("POST"), 4)) AppProtocol = _HTTP;
   101f0:	84 ef       	ldi	r24, 0xF4	; 244
   101f2:	98 e0       	ldi	r25, 0x08	; 8
   101f4:	68 e5       	ldi	r22, 0x58	; 88
   101f6:	79 e4       	ldi	r23, 0x49	; 73
   101f8:	44 e0       	ldi	r20, 0x04	; 4
   101fa:	50 e0       	ldi	r21, 0x00	; 0
   101fc:	0e 94 d3 87 	call	0x10fa6	; 0x10fa6 <strncmp_P>
   10200:	89 2b       	or	r24, r25
   10202:	19 f4       	brne	.+6      	; 0x1020a <GSM_Cycle+0x166c>
   10204:	81 e0       	ldi	r24, 0x01	; 1
   10206:	80 93 5f 09 	sts	0x095F, r24
					if( (GSM_RxStr[0]==5) && (GSM_RxStr[1]==1) ) AppProtocol = _VFCP;
   1020a:	80 91 f4 08 	lds	r24, 0x08F4
   1020e:	85 30       	cpi	r24, 0x05	; 5
   10210:	39 f4       	brne	.+14     	; 0x10220 <GSM_Cycle+0x1682>
   10212:	80 91 f5 08 	lds	r24, 0x08F5
   10216:	81 30       	cpi	r24, 0x01	; 1
   10218:	19 f4       	brne	.+6      	; 0x10220 <GSM_Cycle+0x1682>
   1021a:	82 e0       	ldi	r24, 0x02	; 2
   1021c:	80 93 5f 09 	sts	0x095F, r24
					GSM_State = GSM_DataMode;
   10220:	83 e5       	ldi	r24, 0x53	; 83
   10222:	80 93 a4 05 	sts	0x05A4, r24
					
					if(AppProtocol == 0){
   10226:	80 91 5f 09 	lds	r24, 0x095F
   1022a:	88 23       	and	r24, r24
   1022c:	49 f5       	brne	.+82     	; 0x10280 <GSM_Cycle+0x16e2>
						if(UART_Soft){
   1022e:	80 91 df 09 	lds	r24, 0x09DF
   10232:	88 23       	and	r24, r24
   10234:	21 f0       	breq	.+8      	; 0x1023e <GSM_Cycle+0x16a0>
							GSM_State = GSM_Swtch2CommandMode;
   10236:	84 e5       	ldi	r24, 0x54	; 84
   10238:	80 93 a4 05 	sts	0x05A4, r24
   1023c:	21 c0       	rjmp	.+66     	; 0x10280 <GSM_Cycle+0x16e2>
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){
	EM_RX_FIFO_Begin = 255;
   1023e:	8f ef       	ldi	r24, 0xFF	; 255
   10240:	80 93 dd 08 	sts	0x08DD, r24
	EM_RX_FIFO_End = 255;
   10244:	80 93 a0 0c 	sts	0x0CA0, r24
	EMeter_RxCharN = 0;
   10248:	10 92 a7 0c 	sts	0x0CA7, r1
   1024c:	10 92 a6 0c 	sts	0x0CA6, r1
						}
						else{
							EM_InitFIFO();
							GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End_old;	//     4 
   10250:	80 91 f9 01 	lds	r24, 0x01F9
   10254:	80 93 62 0a 	sts	0x0A62, r24
							Transparent = 1;
   10258:	81 e0       	ldi	r24, 0x01	; 1
   1025a:	80 93 e0 09 	sts	0x09E0, r24
   1025e:	86 e7       	ldi	r24, 0x76	; 118
   10260:	90 e0       	ldi	r25, 0x00	; 0
   10262:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
   10266:	bc 01       	movw	r22, r24
							StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
   10268:	80 91 5b 03 	lds	r24, 0x035B
   1026c:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
   10270:	07 c0       	rjmp	.+14     	; 0x10280 <GSM_Cycle+0x16e2>
					StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
				}
				break;						
			}

			while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
   10272:	80 91 44 08 	lds	r24, 0x0844
   10276:	90 91 83 05 	lds	r25, 0x0583
   1027a:	89 17       	cp	r24, r25
   1027c:	09 f0       	breq	.+2      	; 0x10280 <GSM_Cycle+0x16e2>
   1027e:	97 cf       	rjmp	.-210    	; 0x101ae <GSM_Cycle+0x1610>
					}
					break;
				}
			}//while
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
   10280:	80 91 5b 03 	lds	r24, 0x035B
   10284:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10288:	88 23       	and	r24, r24
   1028a:	09 f4       	brne	.+2      	; 0x1028e <GSM_Cycle+0x16f0>
   1028c:	ac c1       	rjmp	.+856    	; 0x105e6 <GSM_Cycle+0x1a48>
				GSM_State = GSM_Swtch2CommandMode;
   1028e:	84 e5       	ldi	r24, 0x54	; 84
   10290:	80 93 a4 05 	sts	0x05A4, r24
				GSM_CloseTransparent();
   10294:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
   10298:	a6 c1       	rjmp	.+844    	; 0x105e6 <GSM_Cycle+0x1a48>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
   1029a:	90 91 44 08 	lds	r25, 0x0844
   1029e:	80 91 83 05 	lds	r24, 0x0583
   102a2:	98 17       	cp	r25, r24
   102a4:	49 f0       	breq	.+18     	; 0x102b8 <GSM_Cycle+0x171a>
   102a6:	86 e7       	ldi	r24, 0x76	; 118
   102a8:	90 e0       	ldi	r25, 0x00	; 0
   102aa:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
   102ae:	bc 01       	movw	r22, r24
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
   102b0:	80 91 5b 03 	lds	r24, 0x035B
   102b4:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
   102b8:	80 91 5f 09 	lds	r24, 0x095F
   102bc:	81 30       	cpi	r24, 0x01	; 1
   102be:	71 f1       	breq	.+92     	; 0x1031c <GSM_Cycle+0x177e>
				if(GetStringFromFIFO()){
   102c0:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
   102c4:	88 23       	and	r24, r24
   102c6:	51 f1       	breq	.+84     	; 0x1031c <GSM_Cycle+0x177e>
								
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
   102c8:	84 ef       	ldi	r24, 0xF4	; 244
   102ca:	98 e0       	ldi	r25, 0x08	; 8
   102cc:	61 e9       	ldi	r22, 0x91	; 145
   102ce:	72 e0       	ldi	r23, 0x02	; 2
   102d0:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
   102d4:	89 2b       	or	r24, r25
   102d6:	31 f0       	breq	.+12     	; 0x102e4 <GSM_Cycle+0x1746>
						GSM_State = GSM_ServerIdle;
   102d8:	88 e2       	ldi	r24, 0x28	; 40
   102da:	80 93 a4 05 	sts	0x05A4, r24
						GSM_CloseTransparent();
   102de:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
   102e2:	81 c1       	rjmp	.+770    	; 0x105e6 <GSM_Cycle+0x1a48>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
   102e4:	84 ef       	ldi	r24, 0xF4	; 244
   102e6:	98 e0       	ldi	r25, 0x08	; 8
   102e8:	68 ea       	ldi	r22, 0xA8	; 168
   102ea:	72 e0       	ldi	r23, 0x02	; 2
   102ec:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
   102f0:	89 2b       	or	r24, r25
   102f2:	31 f0       	breq	.+12     	; 0x10300 <GSM_Cycle+0x1762>
						GSM_State = GSM_ServerIdle;
   102f4:	88 e2       	ldi	r24, 0x28	; 40
   102f6:	80 93 a4 05 	sts	0x05A4, r24
						GSM_CloseTransparent();
   102fa:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
   102fe:	73 c1       	rjmp	.+742    	; 0x105e6 <GSM_Cycle+0x1a48>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
   10300:	84 ef       	ldi	r24, 0xF4	; 244
   10302:	98 e0       	ldi	r25, 0x08	; 8
   10304:	68 e9       	ldi	r22, 0x98	; 152
   10306:	72 e0       	ldi	r23, 0x02	; 2
   10308:	0e 94 e1 87 	call	0x10fc2	; 0x10fc2 <strstr_P>
   1030c:	89 2b       	or	r24, r25
   1030e:	31 f0       	breq	.+12     	; 0x1031c <GSM_Cycle+0x177e>
						GSM_State = GSM_SEND_E0;
   10310:	88 e0       	ldi	r24, 0x08	; 8
   10312:	80 93 a4 05 	sts	0x05A4, r24
						GSM_CloseTransparent();
   10316:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
   1031a:	65 c1       	rjmp	.+714    	; 0x105e6 <GSM_Cycle+0x1a48>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
   1031c:	80 91 5b 03 	lds	r24, 0x035B
   10320:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10324:	88 23       	and	r24, r24
   10326:	09 f4       	brne	.+2      	; 0x1032a <GSM_Cycle+0x178c>
   10328:	5e c1       	rjmp	.+700    	; 0x105e6 <GSM_Cycle+0x1a48>
				GSM_State = GSM_Swtch2CommandMode;
   1032a:	84 e5       	ldi	r24, 0x54	; 84
   1032c:	80 93 a4 05 	sts	0x05A4, r24
				GSM_CloseTransparent();
   10330:	0e 94 05 59 	call	0xb20a	; 0xb20a <GSM_CloseTransparent>
   10334:	58 c1       	rjmp	.+688    	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}
			break;

		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
   10336:	80 91 5a 03 	lds	r24, 0x035A
   1033a:	6e e6       	ldi	r22, 0x6E	; 110
   1033c:	70 e0       	ldi	r23, 0x00	; 0
   1033e:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	}
	return 0;
}
// ~~~~~~~~~~~~~~~~~~
void WebClose(void){
	Web_POST = 0;
   10342:	10 92 da 08 	sts	0x08DA, r1
	WebMode = 254;
   10346:	8e ef       	ldi	r24, 0xFE	; 254
   10348:	80 93 d5 01 	sts	0x01D5, r24
			WebClose();
			GSM_State++;
   1034c:	80 91 a4 05 	lds	r24, 0x05A4
   10350:	8f 5f       	subi	r24, 0xFF	; 255
   10352:	80 93 a4 05 	sts	0x05A4, r24
   10356:	47 c1       	rjmp	.+654    	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
   10358:	80 91 5a 03 	lds	r24, 0x035A
   1035c:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10360:	88 23       	and	r24, r24
   10362:	09 f4       	brne	.+2      	; 0x10366 <GSM_Cycle+0x17c8>
   10364:	40 c1       	rjmp	.+640    	; 0x105e6 <GSM_Cycle+0x1a48>
				sprintf_P(GSM_TxStr, ESC_SEQ);
   10366:	00 d0       	rcall	.+0      	; 0x10368 <GSM_Cycle+0x17ca>
   10368:	00 d0       	rcall	.+0      	; 0x1036a <GSM_Cycle+0x17cc>
   1036a:	01 ea       	ldi	r16, 0xA1	; 161
   1036c:	1b e0       	ldi	r17, 0x0B	; 11
   1036e:	ad b7       	in	r26, 0x3d	; 61
   10370:	be b7       	in	r27, 0x3e	; 62
   10372:	12 96       	adiw	r26, 0x02	; 2
   10374:	1c 93       	st	X, r17
   10376:	0e 93       	st	-X, r16
   10378:	11 97       	sbiw	r26, 0x01	; 1
   1037a:	88 e1       	ldi	r24, 0x18	; 24
   1037c:	93 e0       	ldi	r25, 0x03	; 3
   1037e:	14 96       	adiw	r26, 0x04	; 4
   10380:	9c 93       	st	X, r25
   10382:	8e 93       	st	-X, r24
   10384:	13 97       	sbiw	r26, 0x03	; 3
   10386:	0e 94 5e 88 	call	0x110bc	; 0x110bc <sprintf_P>
				GSMTxSz = strlen(GSM_TxStr);
   1038a:	f8 01       	movw	r30, r16
   1038c:	01 90       	ld	r0, Z+
   1038e:	00 20       	and	r0, r0
   10390:	e9 f7       	brne	.-6      	; 0x1038c <GSM_Cycle+0x17ee>
   10392:	8f 01       	movw	r16, r30
   10394:	01 50       	subi	r16, 0x01	; 1
   10396:	10 40       	sbci	r17, 0x00	; 0
   10398:	01 5a       	subi	r16, 0xA1	; 161
   1039a:	1b 40       	sbci	r17, 0x0B	; 11
   1039c:	00 93 c5 08 	sts	0x08C5, r16
				GSM_SendFirstChar();
   103a0:	0f 90       	pop	r0
   103a2:	0f 90       	pop	r0
   103a4:	0f 90       	pop	r0
   103a6:	0f 90       	pop	r0
   103a8:	0e 94 fd 43 	call	0x87fa	; 0x87fa <GSM_SendFirstChar>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
   103ac:	80 91 5a 03 	lds	r24, 0x035A
   103b0:	68 ee       	ldi	r22, 0xE8	; 232
   103b2:	73 e0       	ldi	r23, 0x03	; 3
   103b4:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_State++;
   103b8:	80 91 a4 05 	lds	r24, 0x05A4
   103bc:	8f 5f       	subi	r24, 0xFF	; 255
   103be:	80 93 a4 05 	sts	0x05A4, r24
   103c2:	11 c1       	rjmp	.+546    	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
   103c4:	83 eb       	ldi	r24, 0xB3	; 179
   103c6:	92 e0       	ldi	r25, 0x02	; 2
   103c8:	6b e4       	ldi	r22, 0x4B	; 75
   103ca:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   103ce:	88 23       	and	r24, r24
   103d0:	09 f4       	brne	.+2      	; 0x103d4 <GSM_Cycle+0x1836>
   103d2:	09 c1       	rjmp	.+530    	; 0x105e6 <GSM_Cycle+0x1a48>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
   103d4:	80 91 5b 03 	lds	r24, 0x035B
   103d8:	6f ef       	ldi	r22, 0xFF	; 255
   103da:	7f ef       	ldi	r23, 0xFF	; 255
   103dc:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
   103e0:	80 91 ba 08 	lds	r24, 0x08BA
   103e4:	81 30       	cpi	r24, 0x01	; 1
   103e6:	21 f4       	brne	.+8      	; 0x103f0 <GSM_Cycle+0x1852>
   103e8:	8a e5       	ldi	r24, 0x5A	; 90
   103ea:	80 93 a4 05 	sts	0x05A4, r24
   103ee:	fb c0       	rjmp	.+502    	; 0x105e6 <GSM_Cycle+0x1a48>
				else GSM_State = GSM_SEND_CIPCLOSE;
   103f0:	88 e3       	ldi	r24, 0x38	; 56
   103f2:	80 93 a4 05 	sts	0x05A4, r24
   103f6:	f7 c0       	rjmp	.+494    	; 0x105e6 <GSM_Cycle+0x1a48>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
   103f8:	80 91 5a 03 	lds	r24, 0x035A
   103fc:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10400:	88 23       	and	r24, r24
   10402:	19 f0       	breq	.+6      	; 0x1040a <GSM_Cycle+0x186c>
   10404:	8a e5       	ldi	r24, 0x5A	; 90
   10406:	80 93 a4 05 	sts	0x05A4, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   1040a:	86 e2       	ldi	r24, 0x26	; 38
   1040c:	91 e0       	ldi	r25, 0x01	; 1
   1040e:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
   10412:	88 23       	and	r24, r24
   10414:	21 f4       	brne	.+8      	; 0x1041e <GSM_Cycle+0x1880>
				GSM_State = GSM_SEND_ATA;
   10416:	88 e5       	ldi	r24, 0x58	; 88
   10418:	80 93 a4 05 	sts	0x05A4, r24
   1041c:	e4 c0       	rjmp	.+456    	; 0x105e6 <GSM_Cycle+0x1a48>
				break;
			}
			if(GetStringFromFIFO() > 25){
   1041e:	0e 94 8c 38 	call	0x7118	; 0x7118 <GetStringFromFIFO>
   10422:	8a 31       	cpi	r24, 0x1A	; 26
   10424:	08 f4       	brcc	.+2      	; 0x10428 <GSM_Cycle+0x188a>
   10426:	df c0       	rjmp	.+446    	; 0x105e6 <GSM_Cycle+0x1a48>
				char *qoute_open = strchr(GSM_RxStr,'"');
   10428:	84 ef       	ldi	r24, 0xF4	; 244
   1042a:	98 e0       	ldi	r25, 0x08	; 8
   1042c:	62 e2       	ldi	r22, 0x22	; 34
   1042e:	70 e0       	ldi	r23, 0x00	; 0
   10430:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
   10434:	8c 01       	movw	r16, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
   10436:	01 96       	adiw	r24, 0x01	; 1
   10438:	62 e2       	ldi	r22, 0x22	; 34
   1043a:	70 e0       	ldi	r23, 0x00	; 0
   1043c:	0e 94 04 88 	call	0x11008	; 0x11008 <strchr>
   10440:	fc 01       	movw	r30, r24
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
   10442:	01 15       	cp	r16, r1
   10444:	11 05       	cpc	r17, r1
   10446:	11 f0       	breq	.+4      	; 0x1044c <GSM_Cycle+0x18ae>
   10448:	00 97       	sbiw	r24, 0x00	; 0
   1044a:	21 f4       	brne	.+8      	; 0x10454 <GSM_Cycle+0x18b6>
					GSM_State = GSM_SEND_ATH;
   1044c:	8a e5       	ldi	r24, 0x5A	; 90
   1044e:	80 93 a4 05 	sts	0x05A4, r24
   10452:	c9 c0       	rjmp	.+402    	; 0x105e6 <GSM_Cycle+0x1a48>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
   10454:	10 82       	st	Z, r1
   10456:	93 ea       	ldi	r25, 0xA3	; 163
   10458:	e9 2e       	mov	r14, r25
   1045a:	90 e0       	ldi	r25, 0x00	; 0
   1045c:	f9 2e       	mov	r15, r25
				for(uint8_t i = 0; i<10; i++){
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
   1045e:	0e 5f       	subi	r16, 0xFE	; 254
   10460:	1f 4f       	sbci	r17, 0xFF	; 255
   10462:	8a e5       	ldi	r24, 0x5A	; 90
   10464:	d8 2e       	mov	r13, r24
   10466:	c8 01       	movw	r24, r16
   10468:	b7 01       	movw	r22, r14
   1046a:	0e 94 66 69 	call	0xd2cc	; 0xd2cc <strcmp_E>
   1046e:	88 23       	and	r24, r24
   10470:	61 f0       	breq	.+24     	; 0x1048a <GSM_Cycle+0x18ec>
   10472:	d0 92 a4 05 	sts	0x05A4, r13
   10476:	2d e0       	ldi	r18, 0x0D	; 13
   10478:	30 e0       	ldi	r19, 0x00	; 0
   1047a:	e2 0e       	add	r14, r18
   1047c:	f3 1e       	adc	r15, r19
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
   1047e:	35 e2       	ldi	r19, 0x25	; 37
   10480:	e3 16       	cp	r14, r19
   10482:	31 e0       	ldi	r19, 0x01	; 1
   10484:	f3 06       	cpc	r15, r19
   10486:	79 f7       	brne	.-34     	; 0x10466 <GSM_Cycle+0x18c8>
   10488:	ae c0       	rjmp	.+348    	; 0x105e6 <GSM_Cycle+0x1a48>
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
   1048a:	88 e5       	ldi	r24, 0x58	; 88
   1048c:	80 93 a4 05 	sts	0x05A4, r24
   10490:	aa c0       	rjmp	.+340    	; 0x105e6 <GSM_Cycle+0x1a48>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 1000*GSM_DEBUG_DELAY); GSM_State++;
   10492:	83 e5       	ldi	r24, 0x53	; 83
   10494:	94 e0       	ldi	r25, 0x04	; 4
   10496:	68 ee       	ldi	r22, 0xE8	; 232
   10498:	73 e0       	ldi	r23, 0x03	; 3
   1049a:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
   1049e:	80 91 a4 05 	lds	r24, 0x05A4
   104a2:	8f 5f       	subi	r24, 0xFF	; 255
   104a4:	80 93 a4 05 	sts	0x05A4, r24
   104a8:	9e c0       	rjmp	.+316    	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
   104aa:	8b e0       	ldi	r24, 0x0B	; 11
   104ac:	93 e0       	ldi	r25, 0x03	; 3
   104ae:	6a e5       	ldi	r22, 0x5A	; 90
   104b0:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   104b4:	88 23       	and	r24, r24
   104b6:	09 f4       	brne	.+2      	; 0x104ba <GSM_Cycle+0x191c>
   104b8:	96 c0       	rjmp	.+300    	; 0x105e6 <GSM_Cycle+0x1a48>
				StartTimer16(TD_TCP_Connect, 500);	//   
   104ba:	80 91 5b 03 	lds	r24, 0x035B
   104be:	64 ef       	ldi	r22, 0xF4	; 244
   104c0:	71 e0       	ldi	r23, 0x01	; 1
   104c2:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_CSD = 1;
   104c6:	81 e0       	ldi	r24, 0x01	; 1
   104c8:	80 93 ba 08 	sts	0x08BA, r24
				GSM_State = GSM_ProtocolMode;
   104cc:	82 e5       	ldi	r24, 0x52	; 82
   104ce:	80 93 a4 05 	sts	0x05A4, r24
   104d2:	89 c0       	rjmp	.+274    	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
   104d4:	87 e5       	ldi	r24, 0x57	; 87
   104d6:	94 e0       	ldi	r25, 0x04	; 4
   104d8:	6c e2       	ldi	r22, 0x2C	; 44
   104da:	71 e0       	ldi	r23, 0x01	; 1
   104dc:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
   104e0:	80 91 a4 05 	lds	r24, 0x05A4
   104e4:	8f 5f       	subi	r24, 0xFF	; 255
   104e6:	80 93 a4 05 	sts	0x05A4, r24
   104ea:	7d c0       	rjmp	.+250    	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
   104ec:	83 eb       	ldi	r24, 0xB3	; 179
   104ee:	92 e0       	ldi	r25, 0x02	; 2
   104f0:	6b e4       	ldi	r22, 0x4B	; 75
   104f2:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   104f6:	88 23       	and	r24, r24
   104f8:	09 f4       	brne	.+2      	; 0x104fc <GSM_Cycle+0x195e>
   104fa:	75 c0       	rjmp	.+234    	; 0x105e6 <GSM_Cycle+0x1a48>
   104fc:	88 e2       	ldi	r24, 0x28	; 40
   104fe:	80 93 a4 05 	sts	0x05A4, r24
   10502:	71 c0       	rjmp	.+226    	; 0x105e6 <GSM_Cycle+0x1a48>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
   10504:	80 91 a4 05 	lds	r24, 0x05A4
   10508:	83 30       	cpi	r24, 0x03	; 3
   1050a:	09 f4       	brne	.+2      	; 0x1050e <GSM_Cycle+0x1970>
   1050c:	3f c0       	rjmp	.+126    	; 0x1058c <GSM_Cycle+0x19ee>
   1050e:	84 30       	cpi	r24, 0x04	; 4
   10510:	28 f4       	brcc	.+10     	; 0x1051c <GSM_Cycle+0x197e>
   10512:	81 30       	cpi	r24, 0x01	; 1
   10514:	e1 f0       	breq	.+56     	; 0x1054e <GSM_Cycle+0x19b0>
   10516:	82 30       	cpi	r24, 0x02	; 2
   10518:	60 f5       	brcc	.+88     	; 0x10572 <GSM_Cycle+0x19d4>
   1051a:	0a c0       	rjmp	.+20     	; 0x10530 <GSM_Cycle+0x1992>
   1051c:	85 30       	cpi	r24, 0x05	; 5
   1051e:	09 f4       	brne	.+2      	; 0x10522 <GSM_Cycle+0x1984>
   10520:	54 c0       	rjmp	.+168    	; 0x105ca <GSM_Cycle+0x1a2c>
   10522:	85 30       	cpi	r24, 0x05	; 5
   10524:	08 f4       	brcc	.+2      	; 0x10528 <GSM_Cycle+0x198a>
   10526:	3e c0       	rjmp	.+124    	; 0x105a4 <GSM_Cycle+0x1a06>
   10528:	86 30       	cpi	r24, 0x06	; 6
   1052a:	09 f0       	breq	.+2      	; 0x1052e <GSM_Cycle+0x1990>
   1052c:	5a c0       	rjmp	.+180    	; 0x105e2 <GSM_Cycle+0x1a44>
   1052e:	5b c0       	rjmp	.+182    	; 0x105e6 <GSM_Cycle+0x1a48>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
   10530:	80 91 5a 03 	lds	r24, 0x035A
   10534:	68 ec       	ldi	r22, 0xC8	; 200
   10536:	70 e0       	ldi	r23, 0x00	; 0
   10538:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
}
void GSM_PWRCNTRL_ON(void){
	cli();
   1053c:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
   1053e:	1f 9a       	sbi	0x03, 7	; 3
	sei();
   10540:	78 94       	sei
			GSM_PWRCNTRL_ON();
			GSM_State++;
   10542:	80 91 a4 05 	lds	r24, 0x05A4
   10546:	8f 5f       	subi	r24, 0xFF	; 255
   10548:	80 93 a4 05 	sts	0x05A4, r24
   1054c:	4c c0       	rjmp	.+152    	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
   1054e:	80 91 5a 03 	lds	r24, 0x035A
   10552:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10556:	88 23       	and	r24, r24
   10558:	31 f0       	breq	.+12     	; 0x10566 <GSM_Cycle+0x19c8>
   1055a:	8c e1       	ldi	r24, 0x1C	; 28
   1055c:	93 e0       	ldi	r25, 0x03	; 3
   1055e:	64 e6       	ldi	r22, 0x64	; 100
   10560:	70 e0       	ldi	r23, 0x00	; 0
   10562:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
   10566:	80 91 a4 05 	lds	r24, 0x05A4
   1056a:	8f 5f       	subi	r24, 0xFF	; 255
   1056c:	80 93 a4 05 	sts	0x05A4, r24
   10570:	3a c0       	rjmp	.+116    	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
   10572:	83 eb       	ldi	r24, 0xB3	; 179
   10574:	92 e0       	ldi	r25, 0x02	; 2
   10576:	61 e0       	ldi	r22, 0x01	; 1
   10578:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   1057c:	88 23       	and	r24, r24
   1057e:	99 f1       	breq	.+102    	; 0x105e6 <GSM_Cycle+0x1a48>
   10580:	80 91 a4 05 	lds	r24, 0x05A4
   10584:	8f 5f       	subi	r24, 0xFF	; 255
   10586:	80 93 a4 05 	sts	0x05A4, r24
   1058a:	2d c0       	rjmp	.+90     	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
   1058c:	8f e1       	ldi	r24, 0x1F	; 31
   1058e:	93 e0       	ldi	r25, 0x03	; 3
   10590:	64 e6       	ldi	r22, 0x64	; 100
   10592:	70 e0       	ldi	r23, 0x00	; 0
   10594:	0e 94 cf 51 	call	0xa39e	; 0xa39e <GSM_Execute_Command>
   10598:	80 91 a4 05 	lds	r24, 0x05A4
   1059c:	8f 5f       	subi	r24, 0xFF	; 255
   1059e:	80 93 a4 05 	sts	0x05A4, r24
   105a2:	21 c0       	rjmp	.+66     	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
   105a4:	83 eb       	ldi	r24, 0xB3	; 179
   105a6:	92 e0       	ldi	r25, 0x02	; 2
   105a8:	61 e0       	ldi	r22, 0x01	; 1
   105aa:	0e 94 be 49 	call	0x937c	; 0x937c <GSM_Wait_Response_P>
   105ae:	88 23       	and	r24, r24
   105b0:	d1 f0       	breq	.+52     	; 0x105e6 <GSM_Cycle+0x1a48>
				StartTimer16(TD_GSM,200);
   105b2:	80 91 5a 03 	lds	r24, 0x035A
   105b6:	68 ec       	ldi	r22, 0xC8	; 200
   105b8:	70 e0       	ldi	r23, 0x00	; 0
   105ba:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
				GSM_State++;
   105be:	80 91 a4 05 	lds	r24, 0x05A4
   105c2:	8f 5f       	subi	r24, 0xFF	; 255
   105c4:	80 93 a4 05 	sts	0x05A4, r24
   105c8:	0e c0       	rjmp	.+28     	; 0x105e6 <GSM_Cycle+0x1a48>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
   105ca:	80 91 5a 03 	lds	r24, 0x035A
   105ce:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   105d2:	88 23       	and	r24, r24
   105d4:	41 f0       	breq	.+16     	; 0x105e6 <GSM_Cycle+0x1a48>
   105d6:	80 91 a4 05 	lds	r24, 0x05A4
   105da:	8f 5f       	subi	r24, 0xFF	; 255
   105dc:	80 93 a4 05 	sts	0x05A4, r24
   105e0:	02 c0       	rjmp	.+4      	; 0x105e6 <GSM_Cycle+0x1a48>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
   105e2:	10 92 a4 05 	sts	0x05A4, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
   105e6:	80 91 a4 05 	lds	r24, 0x05A4
   105ea:	8b 34       	cpi	r24, 0x4B	; 75
   105ec:	b1 f1       	breq	.+108    	; 0x1065a <GSM_Cycle+0x1abc>
   105ee:	80 91 a4 05 	lds	r24, 0x05A4
   105f2:	8c 34       	cpi	r24, 0x4C	; 76
   105f4:	91 f1       	breq	.+100    	; 0x1065a <GSM_Cycle+0x1abc>
   105f6:	80 91 a4 05 	lds	r24, 0x05A4
   105fa:	80 93 c9 08 	sts	0x08C9, r24
   105fe:	2d c0       	rjmp	.+90     	; 0x1065a <GSM_Cycle+0x1abc>
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
					if(GSM_MultiCon) GSM_State++;
   10600:	80 91 b2 0d 	lds	r24, 0x0DB2
   10604:	88 23       	and	r24, r24
   10606:	11 f0       	breq	.+4      	; 0x1060c <GSM_Cycle+0x1a6e>
   10608:	0c 94 cb 79 	jmp	0xf396	; 0xf396 <GSM_Cycle+0x7f8>
   1060c:	0c 94 cf 79 	jmp	0xf39e	; 0xf39e <GSM_Cycle+0x800>
			if(GetStringFromFIFO()){
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
				RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
   10610:	8f 2d       	mov	r24, r15
   10612:	8f 5f       	subi	r24, 0xFF	; 255
   10614:	80 93 6a 03 	sts	0x036A, r24
   10618:	84 30       	cpi	r24, 0x04	; 4
   1061a:	10 f0       	brcs	.+4      	; 0x10620 <GSM_Cycle+0x1a82>
   1061c:	0c 94 c8 7a 	jmp	0xf590	; 0xf590 <GSM_Cycle+0x9f2>
   10620:	0c 94 cd 7a 	jmp	0xf59a	; 0xf59a <GSM_Cycle+0x9fc>
				if(GPRS_Protocol_Out == UDP){
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
					RightAnswer[0] = 0x30+TempNum;
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
						StartTimer16(TD_GSM,500);//min~ 2 sec
   10624:	80 91 5a 03 	lds	r24, 0x035A
   10628:	64 ef       	ldi	r22, 0xF4	; 244
   1062a:	71 e0       	ldi	r23, 0x01	; 1
   1062c:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
						if(++TempNum>3){
   10630:	80 91 6a 03 	lds	r24, 0x036A
   10634:	8f 5f       	subi	r24, 0xFF	; 255
   10636:	80 93 6a 03 	sts	0x036A, r24
   1063a:	84 30       	cpi	r24, 0x04	; 4
   1063c:	08 f0       	brcs	.+2      	; 0x10640 <GSM_Cycle+0x1aa2>
   1063e:	76 ca       	rjmp	.-2836   	; 0xfb2c <GSM_Cycle+0xf8e>
   10640:	7b ca       	rjmp	.-2826   	; 0xfb38 <GSM_Cycle+0xf9a>
				if(GPRS_Protocol_Out == TCP){
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
						GPRS_FlgSz_Out = 0;
   10642:	10 92 b4 08 	sts	0x08B4, r1
   10646:	cf cf       	rjmp	.-98     	; 0x105e6 <GSM_Cycle+0x1a48>
			if(GetStringFromFIFO()){
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
				RightAnswer[0] = 0x30+GSM_Temp;
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
					GSM_State = GSM_ServerIdle;
   10648:	88 e2       	ldi	r24, 0x28	; 40
   1064a:	80 93 a4 05 	sts	0x05A4, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
   1064e:	80 91 d2 01 	lds	r24, 0x01D2
   10652:	8f 3f       	cpi	r24, 0xFF	; 255
   10654:	09 f0       	breq	.+2      	; 0x10658 <GSM_Cycle+0x1aba>
   10656:	5d cc       	rjmp	.-1862   	; 0xff12 <GSM_Cycle+0x1374>
   10658:	c6 cf       	rjmp	.-116    	; 0x105e6 <GSM_Cycle+0x1a48>
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
}
   1065a:	a6 96       	adiw	r28, 0x26	; 38
   1065c:	0f b6       	in	r0, 0x3f	; 63
   1065e:	f8 94       	cli
   10660:	de bf       	out	0x3e, r29	; 62
   10662:	0f be       	out	0x3f, r0	; 63
   10664:	cd bf       	out	0x3d, r28	; 61
   10666:	cf 91       	pop	r28
   10668:	df 91       	pop	r29
   1066a:	1f 91       	pop	r17
   1066c:	0f 91       	pop	r16
   1066e:	ff 90       	pop	r15
   10670:	ef 90       	pop	r14
   10672:	df 90       	pop	r13
   10674:	cf 90       	pop	r12
   10676:	bf 90       	pop	r11
   10678:	af 90       	pop	r10
   1067a:	9f 90       	pop	r9
   1067c:	8f 90       	pop	r8
   1067e:	7f 90       	pop	r7
   10680:	6f 90       	pop	r6
   10682:	08 95       	ret

00010684 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
   10684:	cf 92       	push	r12
   10686:	df 92       	push	r13
   10688:	ef 92       	push	r14
   1068a:	ff 92       	push	r15
   1068c:	0f 93       	push	r16
   1068e:	1f 93       	push	r17
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
   10690:	e8 2e       	mov	r14, r24
   10692:	ff 24       	eor	r15, r15
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
   10694:	87 01       	movw	r16, r14
   10696:	00 0f       	add	r16, r16
   10698:	11 1f       	adc	r17, r17
   1069a:	00 0f       	add	r16, r16
   1069c:	11 1f       	adc	r17, r17
   1069e:	0e 0d       	add	r16, r14
   106a0:	1f 1d       	adc	r17, r15
   106a2:	36 e8       	ldi	r19, 0x86	; 134
   106a4:	c3 2e       	mov	r12, r19
   106a6:	31 e0       	ldi	r19, 0x01	; 1
   106a8:	d3 2e       	mov	r13, r19
   106aa:	c6 01       	movw	r24, r12
   106ac:	80 0f       	add	r24, r16
   106ae:	91 1f       	adc	r25, r17
   106b0:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
   106b4:	f7 01       	movw	r30, r14
   106b6:	ee 0f       	add	r30, r30
   106b8:	ff 1f       	adc	r31, r31
   106ba:	e3 56       	subi	r30, 0x63	; 99
   106bc:	fa 4f       	sbci	r31, 0xFA	; 250
   106be:	91 83       	std	Z+1, r25	; 0x01
   106c0:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   106c2:	0e 5f       	subi	r16, 0xFE	; 254
   106c4:	1f 4f       	sbci	r17, 0xFF	; 255
   106c6:	c6 01       	movw	r24, r12
   106c8:	80 0f       	add	r24, r16
   106ca:	91 1f       	adc	r25, r17
   106cc:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
   106d0:	f7 01       	movw	r30, r14
   106d2:	e5 58       	subi	r30, 0x85	; 133
   106d4:	f5 4f       	sbci	r31, 0xF5	; 245
   106d6:	80 83       	st	Z, r24
   106d8:	0f 5f       	subi	r16, 0xFF	; 255
   106da:	1f 4f       	sbci	r17, 0xFF	; 255
   106dc:	c6 01       	movw	r24, r12
   106de:	80 0f       	add	r24, r16
   106e0:	91 1f       	adc	r25, r17
   106e2:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
   106e6:	f7 01       	movw	r30, r14
   106e8:	eb 5b       	subi	r30, 0xBB	; 187
   106ea:	f7 4f       	sbci	r31, 0xF7	; 247
   106ec:	80 83       	st	Z, r24
   106ee:	0f 5f       	subi	r16, 0xFF	; 255
   106f0:	1f 4f       	sbci	r17, 0xFF	; 255
   106f2:	c6 01       	movw	r24, r12
   106f4:	80 0f       	add	r24, r16
   106f6:	91 1f       	adc	r25, r17
   106f8:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
   106fc:	2d e6       	ldi	r18, 0x6D	; 109
   106fe:	33 e0       	ldi	r19, 0x03	; 3
   10700:	e2 0e       	add	r14, r18
   10702:	f3 1e       	adc	r15, r19
   10704:	f7 01       	movw	r30, r14
   10706:	80 83       	st	Z, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
   10708:	80 91 cf 01 	lds	r24, 0x01CF
	VacantTimer16Sys += n;
   1070c:	8d 5f       	subi	r24, 0xFD	; 253
   1070e:	80 93 cf 01 	sts	0x01CF, r24
   10712:	83 50       	subi	r24, 0x03	; 3

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
   10714:	80 93 59 03 	sts	0x0359, r24
}
   10718:	1f 91       	pop	r17
   1071a:	0f 91       	pop	r16
   1071c:	ff 90       	pop	r15
   1071e:	ef 90       	pop	r14
   10720:	df 90       	pop	r13
   10722:	cf 90       	pop	r12
   10724:	08 95       	ret

00010726 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
   10726:	0f 93       	push	r16
   10728:	1f 93       	push	r17
   1072a:	08 2f       	mov	r16, r24
   1072c:	10 e0       	ldi	r17, 0x00	; 0
   1072e:	c8 01       	movw	r24, r16
   10730:	85 57       	subi	r24, 0x75	; 117
   10732:	9e 4f       	sbci	r25, 0xFE	; 254
   10734:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
   10738:	05 58       	subi	r16, 0x85	; 133
   1073a:	1c 4f       	sbci	r17, 0xFC	; 252
   1073c:	f8 01       	movw	r30, r16
   1073e:	80 83       	st	Z, r24
	#endif
}
   10740:	1f 91       	pop	r17
   10742:	0f 91       	pop	r16
   10744:	08 95       	ret

00010746 <SetBAUD>:
}

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
   10746:	ef 92       	push	r14
   10748:	ff 92       	push	r15
   1074a:	0f 93       	push	r16
   1074c:	1f 93       	push	r17
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
   1074e:	08 2f       	mov	r16, r24
   10750:	10 e0       	ldi	r17, 0x00	; 0
   10752:	78 01       	movw	r14, r16
   10754:	ee 0c       	add	r14, r14
   10756:	ff 1c       	adc	r15, r15
   10758:	e0 0e       	add	r14, r16
   1075a:	f1 1e       	adc	r15, r17
   1075c:	c7 01       	movw	r24, r14
   1075e:	8b 5f       	subi	r24, 0xFB	; 251
   10760:	9f 4f       	sbci	r25, 0xFF	; 255
   10762:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
   10766:	98 2f       	mov	r25, r24
   10768:	f8 01       	movw	r30, r16
   1076a:	e5 52       	subi	r30, 0x25	; 37
   1076c:	f7 4f       	sbci	r31, 0xF7	; 247
   1076e:	80 83       	st	Z, r24
   10770:	83 e0       	ldi	r24, 0x03	; 3
   10772:	98 9f       	mul	r25, r24
   10774:	b0 01       	movw	r22, r0
   10776:	11 24       	eor	r1, r1
   10778:	64 5f       	subi	r22, 0xF4	; 244
   1077a:	7d 4f       	sbci	r23, 0xFD	; 253

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   1077c:	84 e1       	ldi	r24, 0x14	; 20
   1077e:	90 e0       	ldi	r25, 0x00	; 0
   10780:	9c 01       	movw	r18, r24
   10782:	02 9f       	mul	r16, r18
   10784:	c0 01       	movw	r24, r0
   10786:	03 9f       	mul	r16, r19
   10788:	90 0d       	add	r25, r0
   1078a:	12 9f       	mul	r17, r18
   1078c:	90 0d       	add	r25, r0
   1078e:	11 24       	eor	r1, r1
   10790:	0a 96       	adiw	r24, 0x0a	; 10
   10792:	4c ec       	ldi	r20, 0xCC	; 204
   10794:	59 e4       	ldi	r21, 0x49	; 73
   10796:	9a 01       	movw	r18, r20
   10798:	28 0f       	add	r18, r24
   1079a:	39 1f       	adc	r19, r25
   1079c:	f9 01       	movw	r30, r18
   1079e:	a5 91       	lpm	r26, Z+
   107a0:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
   107a2:	fb 01       	movw	r30, r22
   107a4:	24 91       	lpm	r18, Z+
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
   107a6:	2c 93       	st	X, r18

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   107a8:	02 97       	sbiw	r24, 0x02	; 2
   107aa:	84 0f       	add	r24, r20
   107ac:	95 1f       	adc	r25, r21
   107ae:	fc 01       	movw	r30, r24
   107b0:	a5 91       	lpm	r26, Z+
   107b2:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
   107b4:	6f 5f       	subi	r22, 0xFF	; 255
   107b6:	7f 4f       	sbci	r23, 0xFF	; 255
   107b8:	fb 01       	movw	r30, r22
   107ba:	84 91       	lpm	r24, Z+
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
   107bc:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   107be:	c7 01       	movw	r24, r14
   107c0:	88 0f       	add	r24, r24
   107c2:	99 1f       	adc	r25, r25
   107c4:	8d 51       	subi	r24, 0x1D	; 29
   107c6:	96 4b       	sbci	r25, 0xB6	; 182
   107c8:	fc 01       	movw	r30, r24
   107ca:	a5 91       	lpm	r26, Z+
   107cc:	b4 91       	lpm	r27, Z+

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
   107ce:	6f 5f       	subi	r22, 0xFF	; 255
   107d0:	7f 4f       	sbci	r23, 0xFF	; 255
   107d2:	fb 01       	movw	r30, r22
   107d4:	84 91       	lpm	r24, Z+

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
   107d6:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
   107d8:	1f 91       	pop	r17
   107da:	0f 91       	pop	r16
   107dc:	ff 90       	pop	r15
   107de:	ef 90       	pop	r14
   107e0:	08 95       	ret

000107e2 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
   107e2:	ff 92       	push	r15
   107e4:	0f 93       	push	r16
   107e6:	1f 93       	push	r17
   107e8:	cf 93       	push	r28
   107ea:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
   107ec:	c8 2f       	mov	r28, r24
   107ee:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   107f0:	8e 01       	movw	r16, r28
   107f2:	00 0f       	add	r16, r16
   107f4:	11 1f       	adc	r17, r17
   107f6:	0c 0f       	add	r16, r28
   107f8:	1d 1f       	adc	r17, r29
   107fa:	c8 01       	movw	r24, r16
   107fc:	8d 5f       	subi	r24, 0xFD	; 253
   107fe:	9f 4f       	sbci	r25, 0xFF	; 255
   10800:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
   10804:	f8 2e       	mov	r15, r24
   10806:	0c 5f       	subi	r16, 0xFC	; 252
   10808:	1f 4f       	sbci	r17, 0xFF	; 255
   1080a:	c8 01       	movw	r24, r16
   1080c:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
   10810:	58 2f       	mov	r21, r24
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
   10812:	ff 20       	and	r15, r15
   10814:	31 f4       	brne	.+12     	; 0x10822 <SetParity+0x40>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
   10816:	81 30       	cpi	r24, 0x01	; 1
   10818:	11 f0       	breq	.+4      	; 0x1081e <SetParity+0x3c>
   1081a:	4e e8       	ldi	r20, 0x8E	; 142
   1081c:	08 c0       	rjmp	.+16     	; 0x1082e <SetParity+0x4c>
   1081e:	46 e8       	ldi	r20, 0x86	; 134
   10820:	06 c0       	rjmp	.+12     	; 0x1082e <SetParity+0x4c>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
   10822:	81 e0       	ldi	r24, 0x01	; 1
   10824:	f8 16       	cp	r15, r24
   10826:	11 f4       	brne	.+4      	; 0x1082c <SetParity+0x4a>
   10828:	46 ea       	ldi	r20, 0xA6	; 166
   1082a:	01 c0       	rjmp	.+2      	; 0x1082e <SetParity+0x4c>
   1082c:	46 eb       	ldi	r20, 0xB6	; 182

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   1082e:	84 e1       	ldi	r24, 0x14	; 20
   10830:	90 e0       	ldi	r25, 0x00	; 0
   10832:	c8 9f       	mul	r28, r24
   10834:	90 01       	movw	r18, r0
   10836:	c9 9f       	mul	r28, r25
   10838:	30 0d       	add	r19, r0
   1083a:	d8 9f       	mul	r29, r24
   1083c:	30 0d       	add	r19, r0
   1083e:	11 24       	eor	r1, r1
   10840:	2e 52       	subi	r18, 0x2E	; 46
   10842:	36 4b       	sbci	r19, 0xB6	; 182
   10844:	f9 01       	movw	r30, r18
   10846:	a5 91       	lpm	r26, Z+
   10848:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
   1084a:	4c 93       	st	X, r20
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
   1084c:	ff 20       	and	r15, r15
   1084e:	31 f0       	breq	.+12     	; 0x1085c <SetParity+0x7a>
   10850:	51 30       	cpi	r21, 0x01	; 1
   10852:	21 f0       	breq	.+8      	; 0x1085c <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
   10854:	c8 01       	movw	r24, r16
   10856:	61 e0       	ldi	r22, 0x01	; 1
   10858:	0e 94 21 52 	call	0xa442	; 0xa442 <ewb>
}
   1085c:	df 91       	pop	r29
   1085e:	cf 91       	pop	r28
   10860:	1f 91       	pop	r17
   10862:	0f 91       	pop	r16
   10864:	ff 90       	pop	r15
   10866:	08 95       	ret

00010868 <MB_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
   10868:	8c 9a       	sbi	0x11, 4	; 17
   1086a:	94 98       	cbi	0x12, 4	; 18
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
   1086c:	10 92 64 03 	sts	0x0364, r1
   10870:	8e ec       	ldi	r24, 0xCE	; 206
   10872:	99 e4       	ldi	r25, 0x49	; 73
   10874:	fc 01       	movw	r30, r24
   10876:	a5 91       	lpm	r26, Z+
   10878:	b4 91       	lpm	r27, Z+
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
   1087a:	8c ef       	ldi	r24, 0xFC	; 252
   1087c:	8c 93       	st	X, r24
   1087e:	80 ed       	ldi	r24, 0xD0	; 208
   10880:	99 e4       	ldi	r25, 0x49	; 73
   10882:	fc 01       	movw	r30, r24
   10884:	a5 91       	lpm	r26, Z+
   10886:	b4 91       	lpm	r27, Z+
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
   10888:	88 e9       	ldi	r24, 0x98	; 152
   1088a:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
   1088c:	80 e0       	ldi	r24, 0x00	; 0
   1088e:	0e 94 f1 83 	call	0x107e2	; 0x107e2 <SetParity>
		SetBAUD(MB_N);
   10892:	80 e0       	ldi	r24, 0x00	; 0
   10894:	0e 94 a3 83 	call	0x10746	; 0x10746 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
   10898:	e0 ee       	ldi	r30, 0xE0	; 224
   1089a:	f9 e4       	ldi	r31, 0x49	; 73
   1089c:	84 91       	lpm	r24, Z+
		switch (prb(MB_Role+MB_N)) {
   1089e:	88 23       	and	r24, r24
   108a0:	19 f0       	breq	.+6      	; 0x108a8 <MB_Init+0x40>
   108a2:	81 30       	cpi	r24, 0x01	; 1
   108a4:	41 f4       	brne	.+16     	; 0x108b6 <MB_Init+0x4e>
   108a6:	04 c0       	rjmp	.+8      	; 0x108b0 <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
   108a8:	80 e0       	ldi	r24, 0x00	; 0
   108aa:	0e 94 93 83 	call	0x10726	; 0x10726 <MB_S_Init>
   108ae:	03 c0       	rjmp	.+6      	; 0x108b6 <MB_Init+0x4e>
			break;
		case Role_Master:
			MB_M_Init(MB_N);
   108b0:	80 e0       	ldi	r24, 0x00	; 0
   108b2:	0e 94 42 83 	call	0x10684	; 0x10684 <MB_M_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
   108b6:	85 ee       	ldi	r24, 0xE5	; 229
   108b8:	99 e4       	ldi	r25, 0x49	; 73
   108ba:	fc 01       	movw	r30, r24
   108bc:	25 91       	lpm	r18, Z+
   108be:	34 91       	lpm	r19, Z+
			break;
		}
		MB_StartTimer(MB_N);
   108c0:	f9 01       	movw	r30, r18
   108c2:	09 95       	icall
	}
}
   108c4:	08 95       	ret

000108c6 <StopDebug>:
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
	sei();	
}

void StopDebug(void){
	GSM_DebugMode = 0;
   108c6:	10 92 5d 09 	sts	0x095D, r1
	ModbusMode = 1;
   108ca:	81 e0       	ldi	r24, 0x01	; 1
   108cc:	80 93 63 03 	sts	0x0363, r24
	cli();
   108d0:	f8 94       	cli
	MB_Init();
   108d2:	0e 94 34 84 	call	0x10868	; 0x10868 <MB_Init>
	sei();
   108d6:	78 94       	sei
/*	cli();
	EMeter_ReInit();
	sei();*/
}
   108d8:	08 95       	ret

000108da <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
   108da:	8a e9       	ldi	r24, 0x9A	; 154
   108dc:	98 e4       	ldi	r25, 0x48	; 72
   108de:	67 e0       	ldi	r22, 0x07	; 7
   108e0:	0e 94 98 70 	call	0xe130	; 0xe130 <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
   108e4:	0e 94 47 67 	call	0xce8e	; 0xce8e <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
   108e8:	0e 94 36 54 	call	0xa86c	; 0xa86c <Modbus_App>
	}
*/	


	// GSM_DebugMode
	if(UART_Soft){
   108ec:	80 91 df 09 	lds	r24, 0x09DF
   108f0:	88 23       	and	r24, r24
   108f2:	11 f1       	breq	.+68     	; 0x10938 <ApplCycle+0x5e>
		if(GSM_DebugMode){
   108f4:	80 91 5d 09 	lds	r24, 0x095D
   108f8:	88 23       	and	r24, r24
   108fa:	89 f0       	breq	.+34     	; 0x1091e <ApplCycle+0x44>
			if( DI_State(DI_BL) ){
   108fc:	83 e0       	ldi	r24, 0x03	; 3
   108fe:	0e 94 75 39 	call	0x72ea	; 0x72ea <DI_State>
   10902:	88 23       	and	r24, r24
   10904:	41 f0       	breq	.+16     	; 0x10916 <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
   10906:	81 e0       	ldi	r24, 0x01	; 1
   10908:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   1090c:	88 23       	and	r24, r24
   1090e:	61 f1       	breq	.+88     	; 0x10968 <ApplCycle+0x8e>
					StopDebug();
   10910:	0e 94 63 84 	call	0x108c6	; 0x108c6 <StopDebug>
   10914:	20 c0       	rjmp	.+64     	; 0x10956 <ApplCycle+0x7c>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
   10916:	81 e0       	ldi	r24, 0x01	; 1
   10918:	62 e3       	ldi	r22, 0x32	; 50
   1091a:	70 e0       	ldi	r23, 0x00	; 0
   1091c:	23 c0       	rjmp	.+70     	; 0x10964 <ApplCycle+0x8a>
		}
		else{
			if( DI_State(DI_BL) ){
   1091e:	83 e0       	ldi	r24, 0x03	; 3
   10920:	0e 94 75 39 	call	0x72ea	; 0x72ea <DI_State>
   10924:	88 23       	and	r24, r24
   10926:	d9 f0       	breq	.+54     	; 0x1095e <ApplCycle+0x84>
				if(Timer16Stopp(TD_GotoDebug)){
   10928:	81 e0       	ldi	r24, 0x01	; 1
   1092a:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   1092e:	88 23       	and	r24, r24
   10930:	d9 f0       	breq	.+54     	; 0x10968 <ApplCycle+0x8e>
					StartDebug();
   10932:	0e 94 1a 43 	call	0x8634	; 0x8634 <StartDebug>
   10936:	0f c0       	rjmp	.+30     	; 0x10956 <ApplCycle+0x7c>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
   10938:	83 e0       	ldi	r24, 0x03	; 3
   1093a:	0e 94 75 39 	call	0x72ea	; 0x72ea <DI_State>
   1093e:	88 23       	and	r24, r24
   10940:	71 f0       	breq	.+28     	; 0x1095e <ApplCycle+0x84>
			if(Timer16Stopp(TD_GotoDebug)){
   10942:	81 e0       	ldi	r24, 0x01	; 1
   10944:	0e 94 66 28 	call	0x50cc	; 0x50cc <Timer16Stopp>
   10948:	88 23       	and	r24, r24
   1094a:	71 f0       	breq	.+28     	; 0x10968 <ApplCycle+0x8e>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
   1094c:	82 e0       	ldi	r24, 0x02	; 2
   1094e:	6b e9       	ldi	r22, 0x9B	; 155
   10950:	74 e0       	ldi	r23, 0x04	; 4
   10952:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
   10956:	81 e0       	ldi	r24, 0x01	; 1
   10958:	64 ef       	ldi	r22, 0xF4	; 244
   1095a:	71 e0       	ldi	r23, 0x01	; 1
   1095c:	03 c0       	rjmp	.+6      	; 0x10964 <ApplCycle+0x8a>
			}
		}
		else StartTimer16(TD_GotoDebug,100);
   1095e:	81 e0       	ldi	r24, 0x01	; 1
   10960:	64 e6       	ldi	r22, 0x64	; 100
   10962:	70 e0       	ldi	r23, 0x00	; 0
   10964:	0e 94 76 27 	call	0x4eec	; 0x4eec <StartTimer16>
	}

	// DO_BL
	if(GSM_DebugMode){
   10968:	80 91 5d 09 	lds	r24, 0x095D
   1096c:	88 23       	and	r24, r24
   1096e:	69 f0       	breq	.+26     	; 0x1098a <ApplCycle+0xb0>
		if(Timer8Stopp(TD_BlinkBL)){
   10970:	81 e0       	ldi	r24, 0x01	; 1
   10972:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
   10976:	88 23       	and	r24, r24
   10978:	59 f0       	breq	.+22     	; 0x10990 <ApplCycle+0xb6>
			StartTimer8(TD_BlinkBL,5);
   1097a:	81 e0       	ldi	r24, 0x01	; 1
   1097c:	65 e0       	ldi	r22, 0x05	; 5
   1097e:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
			TogDigOut(DO_BL);
   10982:	82 e0       	ldi	r24, 0x02	; 2
   10984:	0e 94 45 3a 	call	0x748a	; 0x748a <TogDigOut>
   10988:	03 c0       	rjmp	.+6      	; 0x10990 <ApplCycle+0xb6>
		}
	}
	else ResDigOut(DO_BL);
   1098a:	82 e0       	ldi	r24, 0x02	; 2
   1098c:	0e 94 30 3a 	call	0x7460	; 0x7460 <ResDigOut>

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
   10990:	80 91 88 05 	lds	r24, 0x0588
   10994:	81 30       	cpi	r24, 0x01	; 1
   10996:	39 f4       	brne	.+14     	; 0x109a6 <ApplCycle+0xcc>
		StartTimer8(TD_GSM_LED,5);
   10998:	83 e0       	ldi	r24, 0x03	; 3
   1099a:	65 e0       	ldi	r22, 0x05	; 5
   1099c:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
		GSM_LED = 2;
   109a0:	82 e0       	ldi	r24, 0x02	; 2
   109a2:	80 93 88 05 	sts	0x0588, r24
	}
	if(GSM_LED ==2){
   109a6:	80 91 88 05 	lds	r24, 0x0588
   109aa:	82 30       	cpi	r24, 0x02	; 2
   109ac:	39 f4       	brne	.+14     	; 0x109bc <ApplCycle+0xe2>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
   109ae:	83 e0       	ldi	r24, 0x03	; 3
   109b0:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
   109b4:	88 23       	and	r24, r24
   109b6:	11 f0       	breq	.+4      	; 0x109bc <ApplCycle+0xe2>
   109b8:	10 92 88 05 	sts	0x0588, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ServerIdle){
   109bc:	80 91 a4 05 	lds	r24, 0x05A4
   109c0:	88 32       	cpi	r24, 0x28	; 40
   109c2:	41 f4       	brne	.+16     	; 0x109d4 <ApplCycle+0xfa>
		if(GSM_LED) ToggleLED(DO_GSM);
   109c4:	80 91 88 05 	lds	r24, 0x0588
   109c8:	88 23       	and	r24, r24
   109ca:	41 f4       	brne	.+16     	; 0x109dc <ApplCycle+0x102>
		else SetDigOut(DO_GSM);
   109cc:	80 e0       	ldi	r24, 0x00	; 0
   109ce:	0e 94 1c 3a 	call	0x7438	; 0x7438 <SetDigOut>
   109d2:	0b c0       	rjmp	.+22     	; 0x109ea <ApplCycle+0x110>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
   109d4:	80 91 88 05 	lds	r24, 0x0588
   109d8:	88 23       	and	r24, r24
   109da:	21 f0       	breq	.+8      	; 0x109e4 <ApplCycle+0x10a>
   109dc:	80 e0       	ldi	r24, 0x00	; 0
   109de:	0e 94 58 45 	call	0x8ab0	; 0x8ab0 <ToggleLED>
   109e2:	03 c0       	rjmp	.+6      	; 0x109ea <ApplCycle+0x110>
		else ResDigOut(DO_GSM);
   109e4:	80 e0       	ldi	r24, 0x00	; 0
   109e6:	0e 94 30 3a 	call	0x7460	; 0x7460 <ResDigOut>
	}


	//----   COMM_LED  /  UART1
	if(COMM_LED == 1){
   109ea:	80 91 8d 05 	lds	r24, 0x058D
   109ee:	81 30       	cpi	r24, 0x01	; 1
   109f0:	39 f4       	brne	.+14     	; 0x10a00 <ApplCycle+0x126>
		StartTimer8(TD_COMM_LED,5);
   109f2:	82 e0       	ldi	r24, 0x02	; 2
   109f4:	65 e0       	ldi	r22, 0x05	; 5
   109f6:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
		COMM_LED = 2;
   109fa:	82 e0       	ldi	r24, 0x02	; 2
   109fc:	80 93 8d 05 	sts	0x058D, r24
	}
	if(COMM_LED ==2){
   10a00:	80 91 8d 05 	lds	r24, 0x058D
   10a04:	82 30       	cpi	r24, 0x02	; 2
   10a06:	31 f4       	brne	.+12     	; 0x10a14 <ApplCycle+0x13a>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
   10a08:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
   10a0c:	88 23       	and	r24, r24
   10a0e:	11 f0       	breq	.+4      	; 0x10a14 <ApplCycle+0x13a>
   10a10:	10 92 8d 05 	sts	0x058D, r1

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
   10a14:	80 91 d3 01 	lds	r24, 0x01D3
   10a18:	88 23       	and	r24, r24
   10a1a:	89 f0       	breq	.+34     	; 0x10a3e <ApplCycle+0x164>
	if(EMeter_Link()){
		if(COMM_LED) ToggleLED(DO_RS);
		else SetDigOut(DO_RS);
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
   10a1c:	80 91 8d 05 	lds	r24, 0x058D
   10a20:	88 23       	and	r24, r24
   10a22:	49 f0       	breq	.+18     	; 0x10a36 <ApplCycle+0x15c>
   10a24:	04 c0       	rjmp	.+8      	; 0x10a2e <ApplCycle+0x154>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
	}
	//   COMM_LED 
	if(EMeter_Link()){
		if(COMM_LED) ToggleLED(DO_RS);
		else SetDigOut(DO_RS);
   10a26:	81 e0       	ldi	r24, 0x01	; 1
   10a28:	0e 94 1c 3a 	call	0x7438	; 0x7438 <SetDigOut>
   10a2c:	08 95       	ret
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
   10a2e:	81 e0       	ldi	r24, 0x01	; 1
   10a30:	0e 94 58 45 	call	0x8ab0	; 0x8ab0 <ToggleLED>
   10a34:	08 95       	ret
		else ResDigOut(DO_RS);
   10a36:	81 e0       	ldi	r24, 0x01	; 1
   10a38:	0e 94 30 3a 	call	0x7460	; 0x7460 <ResDigOut>
   10a3c:	08 95       	ret
	if(COMM_LED ==2){
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
	}
	//   COMM_LED 
	if(EMeter_Link()){
		if(COMM_LED) ToggleLED(DO_RS);
   10a3e:	80 91 8d 05 	lds	r24, 0x058D
   10a42:	88 23       	and	r24, r24
   10a44:	a1 f7       	brne	.-24     	; 0x10a2e <ApplCycle+0x154>
   10a46:	ef cf       	rjmp	.-34     	; 0x10a26 <ApplCycle+0x14c>

00010a48 <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
   10a48:	80 91 df 09 	lds	r24, 0x09DF
   10a4c:	88 23       	and	r24, r24
   10a4e:	c9 f0       	breq	.+50     	; 0x10a82 <USART_Cycle+0x3a>

		if(ModbusMode) MB_Cycle();
   10a50:	80 91 63 03 	lds	r24, 0x0363
   10a54:	88 23       	and	r24, r24
   10a56:	11 f0       	breq	.+4      	; 0x10a5c <USART_Cycle+0x14>
   10a58:	0e 94 f6 37 	call	0x6fec	; 0x6fec <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
   10a5c:	c8 9b       	sbis	0x19, 0	; 25
   10a5e:	2b c0       	rjmp	.+86     	; 0x10ab6 <USART_Cycle+0x6e>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
   10a60:	80 91 bb 08 	lds	r24, 0x08BB
   10a64:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
   10a68:	88 23       	and	r24, r24
   10a6a:	51 f1       	breq	.+84     	; 0x10ac0 <USART_Cycle+0x78>
				cli();
   10a6c:	f8 94       	cli
				EMeter_ReInit();
   10a6e:	0e 94 69 58 	call	0xb0d2	; 0xb0d2 <EMeter_ReInit>
				UART_Soft = 0;
   10a72:	10 92 df 09 	sts	0x09DF, r1
				ModbusMode = 0;				
   10a76:	10 92 63 03 	sts	0x0363, r1
				GSM_DebugMode = 0;	
   10a7a:	10 92 5d 09 	sts	0x095D, r1
				sei();
   10a7e:	78 94       	sei
   10a80:	1f c0       	rjmp	.+62     	; 0x10ac0 <USART_Cycle+0x78>
			}
		}
	}
	else{
		EMeter_Cycle();
   10a82:	0e 94 f4 5d 	call	0xbbe8	; 0xbbe8 <EMeter_Cycle>
		if(!(PINA & (1<<PA0))){
   10a86:	c8 99       	sbic	0x19, 0	; 25
   10a88:	16 c0       	rjmp	.+44     	; 0x10ab6 <USART_Cycle+0x6e>
			if(Timer8Stopp(TD_UART_Soft)){
   10a8a:	80 91 bb 08 	lds	r24, 0x08BB
   10a8e:	0e 94 44 28 	call	0x5088	; 0x5088 <Timer8Stopp>
   10a92:	88 23       	and	r24, r24
   10a94:	a9 f0       	breq	.+42     	; 0x10ac0 <USART_Cycle+0x78>
				if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
   10a96:	80 91 e0 09 	lds	r24, 0x09E0
   10a9a:	88 23       	and	r24, r24
   10a9c:	11 f0       	breq	.+4      	; 0x10aa2 <USART_Cycle+0x5a>
   10a9e:	0e 94 16 59 	call	0xb22c	; 0xb22c <GSM_Transparent2Modbus>
				cli();
   10aa2:	f8 94       	cli
				MB_Init();
   10aa4:	0e 94 34 84 	call	0x10868	; 0x10868 <MB_Init>
				UART_Soft = 1;
   10aa8:	81 e0       	ldi	r24, 0x01	; 1
   10aaa:	80 93 df 09 	sts	0x09DF, r24
				ModbusMode = 1;
   10aae:	80 93 63 03 	sts	0x0363, r24
				sei();
   10ab2:	78 94       	sei
   10ab4:	05 c0       	rjmp	.+10     	; 0x10ac0 <USART_Cycle+0x78>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
   10ab6:	80 91 bb 08 	lds	r24, 0x08BB
   10aba:	6a e0       	ldi	r22, 0x0A	; 10
   10abc:	0e 94 40 27 	call	0x4e80	; 0x4e80 <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
   10ac0:	0e 94 cf 75 	call	0xeb9e	; 0xeb9e <GSM_Cycle>
	#endif
}
   10ac4:	08 95       	ret

00010ac6 <USART_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
   10ac6:	80 91 ce 01 	lds	r24, 0x01CE
	VacantTimer8Sys += n;
   10aca:	8f 5f       	subi	r24, 0xFF	; 255
   10acc:	80 93 ce 01 	sts	0x01CE, r24
   10ad0:	81 50       	subi	r24, 0x01	; 1

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
   10ad2:	80 93 bb 08 	sts	0x08BB, r24

	MB_Init();
   10ad6:	0e 94 34 84 	call	0x10868	; 0x10868 <MB_Init>
	EMeter_Init();
   10ada:	0e 94 a4 67 	call	0xcf48	; 0xcf48 <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
   10ade:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
   10ae0:	d8 9a       	sbi	0x1b, 0	; 27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
   10ae2:	85 e3       	ldi	r24, 0x35	; 53
   10ae4:	8a 95       	dec	r24
   10ae6:	f1 f7       	brne	.-4      	; 0x10ae4 <USART_Init+0x1e>
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
   10ae8:	c8 99       	sbic	0x19, 0	; 25
   10aea:	08 c0       	rjmp	.+16     	; 0x10afc <USART_Init+0x36>
		MB_Init();
   10aec:	0e 94 34 84 	call	0x10868	; 0x10868 <MB_Init>
		UART_Soft = 1;
   10af0:	81 e0       	ldi	r24, 0x01	; 1
   10af2:	80 93 df 09 	sts	0x09DF, r24
		ModbusMode = 1;
   10af6:	80 93 63 03 	sts	0x0363, r24
   10afa:	06 c0       	rjmp	.+12     	; 0x10b08 <USART_Init+0x42>
	}
	else{
		EMeter_ReInit();
   10afc:	0e 94 69 58 	call	0xb0d2	; 0xb0d2 <EMeter_ReInit>
		UART_Soft = 0;
   10b00:	10 92 df 09 	sts	0x09DF, r1
		ModbusMode = 0;
   10b04:	10 92 63 03 	sts	0x0363, r1
	}
	
	GSM_Init();
   10b08:	0e 94 ea 38 	call	0x71d4	; 0x71d4 <GSM_Init>
}
   10b0c:	08 95       	ret

00010b0e <TimeInit>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
   10b0e:	a8 95       	wdr
	wdt_enable(WDTO_2S);
   10b10:	2f e0       	ldi	r18, 0x0F	; 15
   10b12:	88 e1       	ldi	r24, 0x18	; 24
   10b14:	90 e0       	ldi	r25, 0x00	; 0
   10b16:	0f b6       	in	r0, 0x3f	; 63
   10b18:	f8 94       	cli
   10b1a:	a8 95       	wdr
   10b1c:	81 bd       	out	0x21, r24	; 33
   10b1e:	0f be       	out	0x3f, r0	; 63
   10b20:	21 bd       	out	0x21, r18	; 33

	// WDT
	WdtOn();

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
   10b22:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
   10b24:	8a ee       	ldi	r24, 0xEA	; 234
   10b26:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
   10b28:	80 e2       	ldi	r24, 0x20	; 32
   10b2a:	9e e4       	ldi	r25, 0x4E	; 78
   10b2c:	9b bd       	out	0x2b, r25	; 43
   10b2e:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
   10b30:	87 b7       	in	r24, 0x37	; 55
   10b32:	80 61       	ori	r24, 0x10	; 16
   10b34:	87 bf       	out	0x37, r24	; 55
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
   10b36:	8f ef       	ldi	r24, 0xFF	; 255
   10b38:	80 93 35 03 	sts	0x0335, r24
   10b3c:	80 93 36 03 	sts	0x0336, r24
   10b40:	80 93 37 03 	sts	0x0337, r24
   10b44:	80 93 38 03 	sts	0x0338, r24
   10b48:	80 93 39 03 	sts	0x0339, r24
   10b4c:	80 93 3a 03 	sts	0x033A, r24
   10b50:	80 e0       	ldi	r24, 0x00	; 0
   10b52:	90 e0       	ldi	r25, 0x00	; 0
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
   10b54:	3f ef       	ldi	r19, 0xFF	; 255
   10b56:	fc 01       	movw	r30, r24
   10b58:	e5 5c       	subi	r30, 0xC5	; 197
   10b5a:	fc 4f       	sbci	r31, 0xFC	; 252
   10b5c:	2f ef       	ldi	r18, 0xFF	; 255
   10b5e:	30 83       	st	Z, r19
   10b60:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
   10b62:	88 30       	cpi	r24, 0x08	; 8
   10b64:	91 05       	cpc	r25, r1
   10b66:	b9 f7       	brne	.-18     	; 0x10b56 <TimeInit+0x48>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
   10b68:	20 93 43 03 	sts	0x0343, r18
   10b6c:	20 93 44 03 	sts	0x0344, r18
   10b70:	20 93 45 03 	sts	0x0345, r18
   10b74:	20 93 46 03 	sts	0x0346, r18
   10b78:	20 93 47 03 	sts	0x0347, r18
   10b7c:	20 93 48 03 	sts	0x0348, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   10b80:	81 e9       	ldi	r24, 0x91	; 145
   10b82:	91 e0       	ldi	r25, 0x01	; 1
   10b84:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
   10b88:	80 93 a0 05 	sts	0x05A0, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
   10b8c:	82 e9       	ldi	r24, 0x92	; 146
   10b8e:	91 e0       	ldi	r25, 0x01	; 1
   10b90:	0e 94 ba 8f 	call	0x11f74	; 0x11f74 <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
   10b94:	90 93 b0 0d 	sts	0x0DB0, r25
   10b98:	80 93 af 0d 	sts	0x0DAF, r24

	// Application
	#ifdef InitTimer
		StartTimer16(InitTimer, InitTime);
	#endif
}
   10b9c:	08 95       	ret

00010b9e <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   10b9e:	80 e9       	ldi	r24, 0x90	; 144
   10ba0:	91 e0       	ldi	r25, 0x01	; 1
   10ba2:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
   10ba6:	88 23       	and	r24, r24
   10ba8:	99 f4       	brne	.+38     	; 0x10bd0 <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
   10baa:	0e 94 96 26 	call	0x4d2c	; 0x4d2c <CRC_Flash_calc>
   10bae:	bc 01       	movw	r22, r24
   10bb0:	8c e8       	ldi	r24, 0x8C	; 140
   10bb2:	91 e0       	ldi	r25, 0x01	; 1
   10bb4:	0e 94 df 8f 	call	0x11fbe	; 0x11fbe <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
   10bb8:	0e 94 b0 26 	call	0x4d60	; 0x4d60 <CRC_EEPROM_calc>
   10bbc:	bc 01       	movw	r22, r24
   10bbe:	8e e8       	ldi	r24, 0x8E	; 142
   10bc0:	91 e0       	ldi	r25, 0x01	; 1
   10bc2:	0e 94 df 8f 	call	0x11fbe	; 0x11fbe <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
   10bc6:	80 e9       	ldi	r24, 0x90	; 144
   10bc8:	91 e0       	ldi	r25, 0x01	; 1
   10bca:	61 e0       	ldi	r22, 0x01	; 1
   10bcc:	0e 94 ca 8f 	call	0x11f94	; 0x11f94 <__eewr_byte_m128>
   10bd0:	08 95       	ret

00010bd2 <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimeInit();
   10bd2:	0e 94 87 85 	call	0x10b0e	; 0x10b0e <TimeInit>
	MemCheckInit();
   10bd6:	0e 94 cf 85 	call	0x10b9e	; 0x10b9e <MemCheckInit>
	LED_Init();
	DigitInit();
   10bda:	0e 94 b7 39 	call	0x736e	; 0x736e <DI_Init>
   10bde:	0e 94 a5 3a 	call	0x754a	; 0x754a <DO_Init>
	OneWire_Init();
   10be2:	0e 94 cb 3d 	call	0x7b96	; 0x7b96 <OneWire_Init>
	USART_Init();
   10be6:	0e 94 63 85 	call	0x10ac6	; 0x10ac6 <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
   10bea:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {
		wdt_reset();
   10bec:	a8 95       	wdr
		DigitIn();
   10bee:	0e 94 19 75 	call	0xea32	; 0xea32 <DigitIn>
		DS18B20();
   10bf2:	0e 94 d2 74 	call	0xe9a4	; 0xe9a4 <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
   10bf6:	80 91 da 01 	lds	r24, 0x01DA
   10bfa:	87 30       	cpi	r24, 0x07	; 7
   10bfc:	b9 f7       	brne	.-18     	; 0x10bec <main+0x1a>

//	MemCheckMsg();

	ApplInit();
   10bfe:	0e 94 2f 54 	call	0xa85e	; 0xa85e <ApplInit>
	
	ScanCycleInit();
   10c02:	0e 94 68 29 	call	0x52d0	; 0x52d0 <ScanCycleInit>

	for(;;) {
		sei();
   10c06:	78 94       	sei

		TimeCycle();
   10c08:	0e 94 74 29 	call	0x52e8	; 0x52e8 <TimeCycle>
		DigitIn();
   10c0c:	0e 94 19 75 	call	0xea32	; 0xea32 <DigitIn>
		DS18B20();
   10c10:	0e 94 d2 74 	call	0xe9a4	; 0xe9a4 <DS18B20>
		USART_Cycle();
   10c14:	0e 94 24 85 	call	0x10a48	; 0x10a48 <USART_Cycle>

		ApplCycle();
   10c18:	0e 94 6d 84 	call	0x108da	; 0x108da <ApplCycle>

		DigitOut();
   10c1c:	0e 94 5f 3a 	call	0x74be	; 0x74be <DigitOut>
   10c20:	f2 cf       	rjmp	.-28     	; 0x10c06 <main+0x34>

00010c22 <EEMEMBackUpOk>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   10c22:	80 e0       	ldi	r24, 0x00	; 0
   10c24:	90 e0       	ldi	r25, 0x00	; 0
   10c26:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   10c2a:	8f 3f       	cpi	r24, 0xFF	; 255
   10c2c:	79 f0       	breq	.+30     	; 0x10c4c <EEMEMBackUpOk+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   10c2e:	81 e0       	ldi	r24, 0x01	; 1
   10c30:	90 e0       	ldi	r25, 0x00	; 0
   10c32:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   10c36:	8f 3f       	cpi	r24, 0xFF	; 255
   10c38:	49 f0       	breq	.+18     	; 0x10c4c <EEMEMBackUpOk+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
   10c3a:	82 e0       	ldi	r24, 0x02	; 2
   10c3c:	90 e0       	ldi	r25, 0x00	; 0
   10c3e:	0e 94 ac 8f 	call	0x11f58	; 0x11f58 <__eerd_byte_m128>
   10c42:	90 e0       	ldi	r25, 0x00	; 0
   10c44:	8f 3f       	cpi	r24, 0xFF	; 255
   10c46:	19 f0       	breq	.+6      	; 0x10c4e <EEMEMBackUpOk+0x2c>
   10c48:	91 e0       	ldi	r25, 0x01	; 1
   10c4a:	01 c0       	rjmp	.+2      	; 0x10c4e <EEMEMBackUpOk+0x2c>
	uint8_t Month;
	uint8_t Year;
}DateBackUp EEMEM = {0xFF,0xFF,0xFF};

uint8_t EEMEMBackUpOk(void){
	if( (erb(&DateBackUp.Day)==0xFF) || (erb(&DateBackUp.Month)==0xFF) || (erb(&DateBackUp.Year)== 0xFF) ) return 0;
   10c4c:	90 e0       	ldi	r25, 0x00	; 0
	else return 1;
}
   10c4e:	89 2f       	mov	r24, r25
   10c50:	08 95       	ret

00010c52 <__muldi3>:
   10c52:	a0 e3       	ldi	r26, 0x30	; 48
   10c54:	b0 e0       	ldi	r27, 0x00	; 0
   10c56:	ef e2       	ldi	r30, 0x2F	; 47
   10c58:	f6 e8       	ldi	r31, 0x86	; 134
   10c5a:	0c 94 7a 91 	jmp	0x122f4	; 0x122f4 <__prologue_saves__>
   10c5e:	a8 e0       	ldi	r26, 0x08	; 8
   10c60:	4e 01       	movw	r8, r28
   10c62:	08 94       	sec
   10c64:	81 1c       	adc	r8, r1
   10c66:	91 1c       	adc	r9, r1
   10c68:	f4 01       	movw	r30, r8
   10c6a:	ba 2f       	mov	r27, r26
   10c6c:	11 92       	st	Z+, r1
   10c6e:	ba 95       	dec	r27
   10c70:	e9 f7       	brne	.-6      	; 0x10c6c <__muldi3+0x1a>
   10c72:	29 83       	std	Y+1, r18	; 0x01
   10c74:	3a 83       	std	Y+2, r19	; 0x02
   10c76:	4b 83       	std	Y+3, r20	; 0x03
   10c78:	5c 83       	std	Y+4, r21	; 0x04
   10c7a:	6d 83       	std	Y+5, r22	; 0x05
   10c7c:	7e 83       	std	Y+6, r23	; 0x06
   10c7e:	8f 83       	std	Y+7, r24	; 0x07
   10c80:	98 87       	std	Y+8, r25	; 0x08
   10c82:	ce 01       	movw	r24, r28
   10c84:	09 96       	adiw	r24, 0x09	; 9
   10c86:	fc 01       	movw	r30, r24
   10c88:	11 92       	st	Z+, r1
   10c8a:	aa 95       	dec	r26
   10c8c:	e9 f7       	brne	.-6      	; 0x10c88 <__muldi3+0x36>
   10c8e:	a9 86       	std	Y+9, r10	; 0x09
   10c90:	ba 86       	std	Y+10, r11	; 0x0a
   10c92:	cb 86       	std	Y+11, r12	; 0x0b
   10c94:	dc 86       	std	Y+12, r13	; 0x0c
   10c96:	ed 86       	std	Y+13, r14	; 0x0d
   10c98:	fe 86       	std	Y+14, r15	; 0x0e
   10c9a:	0f 87       	std	Y+15, r16	; 0x0f
   10c9c:	18 8b       	std	Y+16, r17	; 0x10
   10c9e:	29 81       	ldd	r18, Y+1	; 0x01
   10ca0:	3a 81       	ldd	r19, Y+2	; 0x02
   10ca2:	4b 81       	ldd	r20, Y+3	; 0x03
   10ca4:	5c 81       	ldd	r21, Y+4	; 0x04
   10ca6:	2d a7       	std	Y+45, r18	; 0x2d
   10ca8:	3e a7       	std	Y+46, r19	; 0x2e
   10caa:	4f a7       	std	Y+47, r20	; 0x2f
   10cac:	58 ab       	std	Y+48, r21	; 0x30
   10cae:	79 01       	movw	r14, r18
   10cb0:	8a 01       	movw	r16, r20
   10cb2:	8f ef       	ldi	r24, 0xFF	; 255
   10cb4:	9f ef       	ldi	r25, 0xFF	; 255
   10cb6:	a0 e0       	ldi	r26, 0x00	; 0
   10cb8:	b0 e0       	ldi	r27, 0x00	; 0
   10cba:	e8 22       	and	r14, r24
   10cbc:	f9 22       	and	r15, r25
   10cbe:	0a 23       	and	r16, r26
   10cc0:	1b 23       	and	r17, r27
   10cc2:	1a 01       	movw	r2, r20
   10cc4:	44 24       	eor	r4, r4
   10cc6:	55 24       	eor	r5, r5
   10cc8:	29 85       	ldd	r18, Y+9	; 0x09
   10cca:	3a 85       	ldd	r19, Y+10	; 0x0a
   10ccc:	4b 85       	ldd	r20, Y+11	; 0x0b
   10cce:	5c 85       	ldd	r21, Y+12	; 0x0c
   10cd0:	29 a7       	std	Y+41, r18	; 0x29
   10cd2:	3a a7       	std	Y+42, r19	; 0x2a
   10cd4:	4b a7       	std	Y+43, r20	; 0x2b
   10cd6:	5c a7       	std	Y+44, r21	; 0x2c
   10cd8:	59 01       	movw	r10, r18
   10cda:	6a 01       	movw	r12, r20
   10cdc:	a8 22       	and	r10, r24
   10cde:	b9 22       	and	r11, r25
   10ce0:	ca 22       	and	r12, r26
   10ce2:	db 22       	and	r13, r27
   10ce4:	3a 01       	movw	r6, r20
   10ce6:	88 24       	eor	r8, r8
   10ce8:	99 24       	eor	r9, r9
   10cea:	c6 01       	movw	r24, r12
   10cec:	b5 01       	movw	r22, r10
   10cee:	a8 01       	movw	r20, r16
   10cf0:	97 01       	movw	r18, r14
   10cf2:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10cf6:	6d a3       	std	Y+37, r22	; 0x25
   10cf8:	7e a3       	std	Y+38, r23	; 0x26
   10cfa:	8f a3       	std	Y+39, r24	; 0x27
   10cfc:	98 a7       	std	Y+40, r25	; 0x28
   10cfe:	c4 01       	movw	r24, r8
   10d00:	b3 01       	movw	r22, r6
   10d02:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10d06:	69 a3       	std	Y+33, r22	; 0x21
   10d08:	7a a3       	std	Y+34, r23	; 0x22
   10d0a:	8b a3       	std	Y+35, r24	; 0x23
   10d0c:	9c a3       	std	Y+36, r25	; 0x24
   10d0e:	c6 01       	movw	r24, r12
   10d10:	b5 01       	movw	r22, r10
   10d12:	a2 01       	movw	r20, r4
   10d14:	91 01       	movw	r18, r2
   10d16:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10d1a:	7b 01       	movw	r14, r22
   10d1c:	8c 01       	movw	r16, r24
   10d1e:	c4 01       	movw	r24, r8
   10d20:	b3 01       	movw	r22, r6
   10d22:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10d26:	5b 01       	movw	r10, r22
   10d28:	6c 01       	movw	r12, r24
   10d2a:	89 a1       	ldd	r24, Y+33	; 0x21
   10d2c:	9a a1       	ldd	r25, Y+34	; 0x22
   10d2e:	ab a1       	ldd	r26, Y+35	; 0x23
   10d30:	bc a1       	ldd	r27, Y+36	; 0x24
   10d32:	8e 0d       	add	r24, r14
   10d34:	9f 1d       	adc	r25, r15
   10d36:	a0 1f       	adc	r26, r16
   10d38:	b1 1f       	adc	r27, r17
   10d3a:	89 a3       	std	Y+33, r24	; 0x21
   10d3c:	9a a3       	std	Y+34, r25	; 0x22
   10d3e:	ab a3       	std	Y+35, r26	; 0x23
   10d40:	bc a3       	std	Y+36, r27	; 0x24
   10d42:	2d a1       	ldd	r18, Y+37	; 0x25
   10d44:	3e a1       	ldd	r19, Y+38	; 0x26
   10d46:	4f a1       	ldd	r20, Y+39	; 0x27
   10d48:	58 a5       	ldd	r21, Y+40	; 0x28
   10d4a:	ca 01       	movw	r24, r20
   10d4c:	aa 27       	eor	r26, r26
   10d4e:	bb 27       	eor	r27, r27
   10d50:	29 a1       	ldd	r18, Y+33	; 0x21
   10d52:	3a a1       	ldd	r19, Y+34	; 0x22
   10d54:	4b a1       	ldd	r20, Y+35	; 0x23
   10d56:	5c a1       	ldd	r21, Y+36	; 0x24
   10d58:	28 0f       	add	r18, r24
   10d5a:	39 1f       	adc	r19, r25
   10d5c:	4a 1f       	adc	r20, r26
   10d5e:	5b 1f       	adc	r21, r27
   10d60:	29 a3       	std	Y+33, r18	; 0x21
   10d62:	3a a3       	std	Y+34, r19	; 0x22
   10d64:	4b a3       	std	Y+35, r20	; 0x23
   10d66:	5c a3       	std	Y+36, r21	; 0x24
   10d68:	2e 15       	cp	r18, r14
   10d6a:	3f 05       	cpc	r19, r15
   10d6c:	40 07       	cpc	r20, r16
   10d6e:	51 07       	cpc	r21, r17
   10d70:	40 f4       	brcc	.+16     	; 0x10d82 <__muldi3+0x130>
   10d72:	80 e0       	ldi	r24, 0x00	; 0
   10d74:	90 e0       	ldi	r25, 0x00	; 0
   10d76:	a1 e0       	ldi	r26, 0x01	; 1
   10d78:	b0 e0       	ldi	r27, 0x00	; 0
   10d7a:	a8 0e       	add	r10, r24
   10d7c:	b9 1e       	adc	r11, r25
   10d7e:	ca 1e       	adc	r12, r26
   10d80:	db 1e       	adc	r13, r27
   10d82:	89 a1       	ldd	r24, Y+33	; 0x21
   10d84:	9a a1       	ldd	r25, Y+34	; 0x22
   10d86:	ab a1       	ldd	r26, Y+35	; 0x23
   10d88:	bc a1       	ldd	r27, Y+36	; 0x24
   10d8a:	9d 01       	movw	r18, r26
   10d8c:	44 27       	eor	r20, r20
   10d8e:	55 27       	eor	r21, r21
   10d90:	2a 0d       	add	r18, r10
   10d92:	3b 1d       	adc	r19, r11
   10d94:	4c 1d       	adc	r20, r12
   10d96:	5d 1d       	adc	r21, r13
   10d98:	2d 8f       	std	Y+29, r18	; 0x1d
   10d9a:	3e 8f       	std	Y+30, r19	; 0x1e
   10d9c:	4f 8f       	std	Y+31, r20	; 0x1f
   10d9e:	58 a3       	std	Y+32, r21	; 0x20
   10da0:	6c 01       	movw	r12, r24
   10da2:	bb 24       	eor	r11, r11
   10da4:	aa 24       	eor	r10, r10
   10da6:	8d a1       	ldd	r24, Y+37	; 0x25
   10da8:	9e a1       	ldd	r25, Y+38	; 0x26
   10daa:	af a1       	ldd	r26, Y+39	; 0x27
   10dac:	b8 a5       	ldd	r27, Y+40	; 0x28
   10dae:	a0 70       	andi	r26, 0x00	; 0
   10db0:	b0 70       	andi	r27, 0x00	; 0
   10db2:	a8 0e       	add	r10, r24
   10db4:	b9 1e       	adc	r11, r25
   10db6:	ca 1e       	adc	r12, r26
   10db8:	db 1e       	adc	r13, r27
   10dba:	a9 8e       	std	Y+25, r10	; 0x19
   10dbc:	ba 8e       	std	Y+26, r11	; 0x1a
   10dbe:	cb 8e       	std	Y+27, r12	; 0x1b
   10dc0:	dc 8e       	std	Y+28, r13	; 0x1c
   10dc2:	9a 8c       	ldd	r9, Y+26	; 0x1a
   10dc4:	8b 8c       	ldd	r8, Y+27	; 0x1b
   10dc6:	7c 8c       	ldd	r7, Y+28	; 0x1c
   10dc8:	9e 8d       	ldd	r25, Y+30	; 0x1e
   10dca:	6f 8d       	ldd	r22, Y+31	; 0x1f
   10dcc:	78 a1       	ldd	r23, Y+32	; 0x20
   10dce:	fe 01       	movw	r30, r28
   10dd0:	71 96       	adiw	r30, 0x11	; 17
   10dd2:	88 e0       	ldi	r24, 0x08	; 8
   10dd4:	df 01       	movw	r26, r30
   10dd6:	1d 92       	st	X+, r1
   10dd8:	8a 95       	dec	r24
   10dda:	e9 f7       	brne	.-6      	; 0x10dd6 <__muldi3+0x184>
   10ddc:	2d 8b       	std	Y+21, r18	; 0x15
   10dde:	9e 8b       	std	Y+22, r25	; 0x16
   10de0:	6f 8b       	std	Y+23, r22	; 0x17
   10de2:	78 8f       	std	Y+24, r23	; 0x18
   10de4:	2d 85       	ldd	r18, Y+13	; 0x0d
   10de6:	3e 85       	ldd	r19, Y+14	; 0x0e
   10de8:	4f 85       	ldd	r20, Y+15	; 0x0f
   10dea:	58 89       	ldd	r21, Y+16	; 0x10
   10dec:	6d a5       	ldd	r22, Y+45	; 0x2d
   10dee:	7e a5       	ldd	r23, Y+46	; 0x2e
   10df0:	8f a5       	ldd	r24, Y+47	; 0x2f
   10df2:	98 a9       	ldd	r25, Y+48	; 0x30
   10df4:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10df8:	7b 01       	movw	r14, r22
   10dfa:	8c 01       	movw	r16, r24
   10dfc:	2d 81       	ldd	r18, Y+5	; 0x05
   10dfe:	3e 81       	ldd	r19, Y+6	; 0x06
   10e00:	4f 81       	ldd	r20, Y+7	; 0x07
   10e02:	58 85       	ldd	r21, Y+8	; 0x08
   10e04:	69 a5       	ldd	r22, Y+41	; 0x29
   10e06:	7a a5       	ldd	r23, Y+42	; 0x2a
   10e08:	8b a5       	ldd	r24, Y+43	; 0x2b
   10e0a:	9c a5       	ldd	r25, Y+44	; 0x2c
   10e0c:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10e10:	e6 0e       	add	r14, r22
   10e12:	f7 1e       	adc	r15, r23
   10e14:	08 1f       	adc	r16, r24
   10e16:	19 1f       	adc	r17, r25
   10e18:	6d 89       	ldd	r22, Y+21	; 0x15
   10e1a:	7e 89       	ldd	r23, Y+22	; 0x16
   10e1c:	8f 89       	ldd	r24, Y+23	; 0x17
   10e1e:	98 8d       	ldd	r25, Y+24	; 0x18
   10e20:	6e 0d       	add	r22, r14
   10e22:	7f 1d       	adc	r23, r15
   10e24:	80 1f       	adc	r24, r16
   10e26:	91 1f       	adc	r25, r17
   10e28:	6d 8b       	std	Y+21, r22	; 0x15
   10e2a:	7e 8b       	std	Y+22, r23	; 0x16
   10e2c:	8f 8b       	std	Y+23, r24	; 0x17
   10e2e:	98 8f       	std	Y+24, r25	; 0x18
   10e30:	ee 89       	ldd	r30, Y+22	; 0x16
   10e32:	2a 2d       	mov	r18, r10
   10e34:	39 2d       	mov	r19, r9
   10e36:	48 2d       	mov	r20, r8
   10e38:	57 2d       	mov	r21, r7
   10e3a:	7e 2f       	mov	r23, r30
   10e3c:	8f 89       	ldd	r24, Y+23	; 0x17
   10e3e:	98 8d       	ldd	r25, Y+24	; 0x18
   10e40:	e0 96       	adiw	r28, 0x30	; 48
   10e42:	e2 e1       	ldi	r30, 0x12	; 18
   10e44:	0c 94 96 91 	jmp	0x1232c	; 0x1232c <__epilogue_restores__>

00010e48 <do_random>:
   10e48:	af 92       	push	r10
   10e4a:	bf 92       	push	r11
   10e4c:	cf 92       	push	r12
   10e4e:	df 92       	push	r13
   10e50:	ef 92       	push	r14
   10e52:	ff 92       	push	r15
   10e54:	0f 93       	push	r16
   10e56:	1f 93       	push	r17
   10e58:	cf 93       	push	r28
   10e5a:	df 93       	push	r29
   10e5c:	ec 01       	movw	r28, r24
   10e5e:	a8 80       	ld	r10, Y
   10e60:	b9 80       	ldd	r11, Y+1	; 0x01
   10e62:	ca 80       	ldd	r12, Y+2	; 0x02
   10e64:	db 80       	ldd	r13, Y+3	; 0x03
   10e66:	a1 14       	cp	r10, r1
   10e68:	b1 04       	cpc	r11, r1
   10e6a:	c1 04       	cpc	r12, r1
   10e6c:	d1 04       	cpc	r13, r1
   10e6e:	41 f4       	brne	.+16     	; 0x10e80 <do_random+0x38>
   10e70:	84 e2       	ldi	r24, 0x24	; 36
   10e72:	a8 2e       	mov	r10, r24
   10e74:	89 ed       	ldi	r24, 0xD9	; 217
   10e76:	b8 2e       	mov	r11, r24
   10e78:	8b e5       	ldi	r24, 0x5B	; 91
   10e7a:	c8 2e       	mov	r12, r24
   10e7c:	87 e0       	ldi	r24, 0x07	; 7
   10e7e:	d8 2e       	mov	r13, r24
   10e80:	c6 01       	movw	r24, r12
   10e82:	b5 01       	movw	r22, r10
   10e84:	2d e1       	ldi	r18, 0x1D	; 29
   10e86:	33 ef       	ldi	r19, 0xF3	; 243
   10e88:	41 e0       	ldi	r20, 0x01	; 1
   10e8a:	50 e0       	ldi	r21, 0x00	; 0
   10e8c:	0e 94 5f 91 	call	0x122be	; 0x122be <__divmodsi4>
   10e90:	27 ea       	ldi	r18, 0xA7	; 167
   10e92:	31 e4       	ldi	r19, 0x41	; 65
   10e94:	40 e0       	ldi	r20, 0x00	; 0
   10e96:	50 e0       	ldi	r21, 0x00	; 0
   10e98:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10e9c:	7b 01       	movw	r14, r22
   10e9e:	8c 01       	movw	r16, r24
   10ea0:	c6 01       	movw	r24, r12
   10ea2:	b5 01       	movw	r22, r10
   10ea4:	2d e1       	ldi	r18, 0x1D	; 29
   10ea6:	33 ef       	ldi	r19, 0xF3	; 243
   10ea8:	41 e0       	ldi	r20, 0x01	; 1
   10eaa:	50 e0       	ldi	r21, 0x00	; 0
   10eac:	0e 94 5f 91 	call	0x122be	; 0x122be <__divmodsi4>
   10eb0:	ca 01       	movw	r24, r20
   10eb2:	b9 01       	movw	r22, r18
   10eb4:	2c ee       	ldi	r18, 0xEC	; 236
   10eb6:	34 ef       	ldi	r19, 0xF4	; 244
   10eb8:	4f ef       	ldi	r20, 0xFF	; 255
   10eba:	5f ef       	ldi	r21, 0xFF	; 255
   10ebc:	0e 94 eb 90 	call	0x121d6	; 0x121d6 <__mulsi3>
   10ec0:	6e 0d       	add	r22, r14
   10ec2:	7f 1d       	adc	r23, r15
   10ec4:	80 1f       	adc	r24, r16
   10ec6:	91 1f       	adc	r25, r17
   10ec8:	97 ff       	sbrs	r25, 7
   10eca:	04 c0       	rjmp	.+8      	; 0x10ed4 <do_random+0x8c>
   10ecc:	61 50       	subi	r22, 0x01	; 1
   10ece:	70 40       	sbci	r23, 0x00	; 0
   10ed0:	80 40       	sbci	r24, 0x00	; 0
   10ed2:	90 48       	sbci	r25, 0x80	; 128
   10ed4:	68 83       	st	Y, r22
   10ed6:	79 83       	std	Y+1, r23	; 0x01
   10ed8:	8a 83       	std	Y+2, r24	; 0x02
   10eda:	9b 83       	std	Y+3, r25	; 0x03
   10edc:	9b 01       	movw	r18, r22
   10ede:	ac 01       	movw	r20, r24
   10ee0:	5f 77       	andi	r21, 0x7F	; 127
   10ee2:	b9 01       	movw	r22, r18
   10ee4:	ca 01       	movw	r24, r20
   10ee6:	df 91       	pop	r29
   10ee8:	cf 91       	pop	r28
   10eea:	1f 91       	pop	r17
   10eec:	0f 91       	pop	r16
   10eee:	ff 90       	pop	r15
   10ef0:	ef 90       	pop	r14
   10ef2:	df 90       	pop	r13
   10ef4:	cf 90       	pop	r12
   10ef6:	bf 90       	pop	r11
   10ef8:	af 90       	pop	r10
   10efa:	08 95       	ret

00010efc <random_r>:
   10efc:	0e 94 24 87 	call	0x10e48	; 0x10e48 <do_random>
   10f00:	08 95       	ret

00010f02 <random>:
   10f02:	86 ed       	ldi	r24, 0xD6	; 214
   10f04:	91 e0       	ldi	r25, 0x01	; 1
   10f06:	0e 94 24 87 	call	0x10e48	; 0x10e48 <do_random>
   10f0a:	08 95       	ret

00010f0c <srandom>:
   10f0c:	60 93 d6 01 	sts	0x01D6, r22
   10f10:	70 93 d7 01 	sts	0x01D7, r23
   10f14:	80 93 d8 01 	sts	0x01D8, r24
   10f18:	90 93 d9 01 	sts	0x01D9, r25
   10f1c:	08 95       	ret

00010f1e <exit>:
   10f1e:	f8 94       	cli
   10f20:	0c 94 b1 91 	jmp	0x12362	; 0x12362 <_exit>

00010f24 <memcpy_P>:
   10f24:	fb 01       	movw	r30, r22
   10f26:	dc 01       	movw	r26, r24
   10f28:	02 c0       	rjmp	.+4      	; 0x10f2e <memcpy_P+0xa>
   10f2a:	05 90       	lpm	r0, Z+
   10f2c:	0d 92       	st	X+, r0
   10f2e:	41 50       	subi	r20, 0x01	; 1
   10f30:	50 40       	sbci	r21, 0x00	; 0
   10f32:	d8 f7       	brcc	.-10     	; 0x10f2a <memcpy_P+0x6>
   10f34:	08 95       	ret

00010f36 <strchr_P>:
   10f36:	fc 01       	movw	r30, r24
   10f38:	05 90       	lpm	r0, Z+
   10f3a:	06 16       	cp	r0, r22
   10f3c:	21 f0       	breq	.+8      	; 0x10f46 <strchr_P+0x10>
   10f3e:	00 20       	and	r0, r0
   10f40:	d9 f7       	brne	.-10     	; 0x10f38 <strchr_P+0x2>
   10f42:	c0 01       	movw	r24, r0
   10f44:	08 95       	ret
   10f46:	31 97       	sbiw	r30, 0x01	; 1
   10f48:	cf 01       	movw	r24, r30
   10f4a:	08 95       	ret

00010f4c <strcmp_P>:
   10f4c:	fb 01       	movw	r30, r22
   10f4e:	dc 01       	movw	r26, r24
   10f50:	8d 91       	ld	r24, X+
   10f52:	05 90       	lpm	r0, Z+
   10f54:	80 19       	sub	r24, r0
   10f56:	01 10       	cpse	r0, r1
   10f58:	d9 f3       	breq	.-10     	; 0x10f50 <strcmp_P+0x4>
   10f5a:	99 0b       	sbc	r25, r25
   10f5c:	08 95       	ret

00010f5e <strcpy_P>:
   10f5e:	fb 01       	movw	r30, r22
   10f60:	dc 01       	movw	r26, r24
   10f62:	05 90       	lpm	r0, Z+
   10f64:	0d 92       	st	X+, r0
   10f66:	00 20       	and	r0, r0
   10f68:	e1 f7       	brne	.-8      	; 0x10f62 <strcpy_P+0x4>
   10f6a:	08 95       	ret

00010f6c <strlcpy_P>:
   10f6c:	dc 01       	movw	r26, r24
   10f6e:	fb 01       	movw	r30, r22
   10f70:	41 50       	subi	r20, 0x01	; 1
   10f72:	50 40       	sbci	r21, 0x00	; 0
   10f74:	58 f0       	brcs	.+22     	; 0x10f8c <strlcpy_P+0x20>
   10f76:	49 f0       	breq	.+18     	; 0x10f8a <strlcpy_P+0x1e>
   10f78:	05 90       	lpm	r0, Z+
   10f7a:	0d 92       	st	X+, r0
   10f7c:	00 20       	and	r0, r0
   10f7e:	c1 f7       	brne	.-16     	; 0x10f70 <strlcpy_P+0x4>
   10f80:	e6 1b       	sub	r30, r22
   10f82:	f7 0b       	sbc	r31, r23
   10f84:	31 97       	sbiw	r30, 0x01	; 1
   10f86:	cf 01       	movw	r24, r30
   10f88:	08 95       	ret
   10f8a:	1c 92       	st	X, r1
   10f8c:	05 90       	lpm	r0, Z+
   10f8e:	00 20       	and	r0, r0
   10f90:	e9 f7       	brne	.-6      	; 0x10f8c <strlcpy_P+0x20>
   10f92:	f6 cf       	rjmp	.-20     	; 0x10f80 <strlcpy_P+0x14>

00010f94 <strlen_P>:
   10f94:	fc 01       	movw	r30, r24
   10f96:	05 90       	lpm	r0, Z+
   10f98:	00 20       	and	r0, r0
   10f9a:	e9 f7       	brne	.-6      	; 0x10f96 <strlen_P+0x2>
   10f9c:	80 95       	com	r24
   10f9e:	90 95       	com	r25
   10fa0:	8e 0f       	add	r24, r30
   10fa2:	9f 1f       	adc	r25, r31
   10fa4:	08 95       	ret

00010fa6 <strncmp_P>:
   10fa6:	fb 01       	movw	r30, r22
   10fa8:	dc 01       	movw	r26, r24
   10faa:	41 50       	subi	r20, 0x01	; 1
   10fac:	50 40       	sbci	r21, 0x00	; 0
   10fae:	30 f0       	brcs	.+12     	; 0x10fbc <strncmp_P+0x16>
   10fb0:	8d 91       	ld	r24, X+
   10fb2:	05 90       	lpm	r0, Z+
   10fb4:	80 19       	sub	r24, r0
   10fb6:	19 f4       	brne	.+6      	; 0x10fbe <strncmp_P+0x18>
   10fb8:	00 20       	and	r0, r0
   10fba:	b9 f7       	brne	.-18     	; 0x10faa <strncmp_P+0x4>
   10fbc:	88 1b       	sub	r24, r24
   10fbe:	99 0b       	sbc	r25, r25
   10fc0:	08 95       	ret

00010fc2 <strstr_P>:
   10fc2:	fb 01       	movw	r30, r22
   10fc4:	55 91       	lpm	r21, Z+
   10fc6:	55 23       	and	r21, r21
   10fc8:	a9 f0       	breq	.+42     	; 0x10ff4 <strstr_P+0x32>
   10fca:	bf 01       	movw	r22, r30
   10fcc:	dc 01       	movw	r26, r24
   10fce:	4d 91       	ld	r20, X+
   10fd0:	45 17       	cp	r20, r21
   10fd2:	41 11       	cpse	r20, r1
   10fd4:	e1 f7       	brne	.-8      	; 0x10fce <strstr_P+0xc>
   10fd6:	59 f4       	brne	.+22     	; 0x10fee <strstr_P+0x2c>
   10fd8:	cd 01       	movw	r24, r26
   10fda:	05 90       	lpm	r0, Z+
   10fdc:	00 20       	and	r0, r0
   10fde:	49 f0       	breq	.+18     	; 0x10ff2 <strstr_P+0x30>
   10fe0:	4d 91       	ld	r20, X+
   10fe2:	40 15       	cp	r20, r0
   10fe4:	41 11       	cpse	r20, r1
   10fe6:	c9 f3       	breq	.-14     	; 0x10fda <strstr_P+0x18>
   10fe8:	fb 01       	movw	r30, r22
   10fea:	41 11       	cpse	r20, r1
   10fec:	ef cf       	rjmp	.-34     	; 0x10fcc <strstr_P+0xa>
   10fee:	81 e0       	ldi	r24, 0x01	; 1
   10ff0:	90 e0       	ldi	r25, 0x00	; 0
   10ff2:	01 97       	sbiw	r24, 0x01	; 1
   10ff4:	08 95       	ret

00010ff6 <memcpy>:
   10ff6:	fb 01       	movw	r30, r22
   10ff8:	dc 01       	movw	r26, r24
   10ffa:	02 c0       	rjmp	.+4      	; 0x11000 <memcpy+0xa>
   10ffc:	01 90       	ld	r0, Z+
   10ffe:	0d 92       	st	X+, r0
   11000:	41 50       	subi	r20, 0x01	; 1
   11002:	50 40       	sbci	r21, 0x00	; 0
   11004:	d8 f7       	brcc	.-10     	; 0x10ffc <memcpy+0x6>
   11006:	08 95       	ret

00011008 <strchr>:
   11008:	fc 01       	movw	r30, r24
   1100a:	81 91       	ld	r24, Z+
   1100c:	86 17       	cp	r24, r22
   1100e:	21 f0       	breq	.+8      	; 0x11018 <strchr+0x10>
   11010:	88 23       	and	r24, r24
   11012:	d9 f7       	brne	.-10     	; 0x1100a <strchr+0x2>
   11014:	99 27       	eor	r25, r25
   11016:	08 95       	ret
   11018:	31 97       	sbiw	r30, 0x01	; 1
   1101a:	cf 01       	movw	r24, r30
   1101c:	08 95       	ret

0001101e <strcmp>:
   1101e:	fb 01       	movw	r30, r22
   11020:	dc 01       	movw	r26, r24
   11022:	8d 91       	ld	r24, X+
   11024:	01 90       	ld	r0, Z+
   11026:	80 19       	sub	r24, r0
   11028:	01 10       	cpse	r0, r1
   1102a:	d9 f3       	breq	.-10     	; 0x11022 <strcmp+0x4>
   1102c:	99 0b       	sbc	r25, r25
   1102e:	08 95       	ret

00011030 <strcpy>:
   11030:	fb 01       	movw	r30, r22
   11032:	dc 01       	movw	r26, r24
   11034:	01 90       	ld	r0, Z+
   11036:	0d 92       	st	X+, r0
   11038:	00 20       	and	r0, r0
   1103a:	e1 f7       	brne	.-8      	; 0x11034 <strcpy+0x4>
   1103c:	08 95       	ret

0001103e <strncmp>:
   1103e:	fb 01       	movw	r30, r22
   11040:	dc 01       	movw	r26, r24
   11042:	41 50       	subi	r20, 0x01	; 1
   11044:	50 40       	sbci	r21, 0x00	; 0
   11046:	30 f0       	brcs	.+12     	; 0x11054 <strncmp+0x16>
   11048:	8d 91       	ld	r24, X+
   1104a:	01 90       	ld	r0, Z+
   1104c:	80 19       	sub	r24, r0
   1104e:	19 f4       	brne	.+6      	; 0x11056 <strncmp+0x18>
   11050:	00 20       	and	r0, r0
   11052:	b9 f7       	brne	.-18     	; 0x11042 <strncmp+0x4>
   11054:	88 1b       	sub	r24, r24
   11056:	99 0b       	sbc	r25, r25
   11058:	08 95       	ret

0001105a <sprintf>:
   1105a:	0f 93       	push	r16
   1105c:	1f 93       	push	r17
   1105e:	df 93       	push	r29
   11060:	cf 93       	push	r28
   11062:	cd b7       	in	r28, 0x3d	; 61
   11064:	de b7       	in	r29, 0x3e	; 62
   11066:	2e 97       	sbiw	r28, 0x0e	; 14
   11068:	0f b6       	in	r0, 0x3f	; 63
   1106a:	f8 94       	cli
   1106c:	de bf       	out	0x3e, r29	; 62
   1106e:	0f be       	out	0x3f, r0	; 63
   11070:	cd bf       	out	0x3d, r28	; 61
   11072:	0d 89       	ldd	r16, Y+21	; 0x15
   11074:	1e 89       	ldd	r17, Y+22	; 0x16
   11076:	86 e0       	ldi	r24, 0x06	; 6
   11078:	8c 83       	std	Y+4, r24	; 0x04
   1107a:	1a 83       	std	Y+2, r17	; 0x02
   1107c:	09 83       	std	Y+1, r16	; 0x01
   1107e:	8f ef       	ldi	r24, 0xFF	; 255
   11080:	9f e7       	ldi	r25, 0x7F	; 127
   11082:	9e 83       	std	Y+6, r25	; 0x06
   11084:	8d 83       	std	Y+5, r24	; 0x05
   11086:	9e 01       	movw	r18, r28
   11088:	27 5e       	subi	r18, 0xE7	; 231
   1108a:	3f 4f       	sbci	r19, 0xFF	; 255
   1108c:	ce 01       	movw	r24, r28
   1108e:	01 96       	adiw	r24, 0x01	; 1
   11090:	6f 89       	ldd	r22, Y+23	; 0x17
   11092:	78 8d       	ldd	r23, Y+24	; 0x18
   11094:	a9 01       	movw	r20, r18
   11096:	0e 94 c4 8a 	call	0x11588	; 0x11588 <vfprintf>
   1109a:	2f 81       	ldd	r18, Y+7	; 0x07
   1109c:	38 85       	ldd	r19, Y+8	; 0x08
   1109e:	02 0f       	add	r16, r18
   110a0:	13 1f       	adc	r17, r19
   110a2:	f8 01       	movw	r30, r16
   110a4:	10 82       	st	Z, r1
   110a6:	2e 96       	adiw	r28, 0x0e	; 14
   110a8:	0f b6       	in	r0, 0x3f	; 63
   110aa:	f8 94       	cli
   110ac:	de bf       	out	0x3e, r29	; 62
   110ae:	0f be       	out	0x3f, r0	; 63
   110b0:	cd bf       	out	0x3d, r28	; 61
   110b2:	cf 91       	pop	r28
   110b4:	df 91       	pop	r29
   110b6:	1f 91       	pop	r17
   110b8:	0f 91       	pop	r16
   110ba:	08 95       	ret

000110bc <sprintf_P>:
   110bc:	0f 93       	push	r16
   110be:	1f 93       	push	r17
   110c0:	df 93       	push	r29
   110c2:	cf 93       	push	r28
   110c4:	cd b7       	in	r28, 0x3d	; 61
   110c6:	de b7       	in	r29, 0x3e	; 62
   110c8:	2e 97       	sbiw	r28, 0x0e	; 14
   110ca:	0f b6       	in	r0, 0x3f	; 63
   110cc:	f8 94       	cli
   110ce:	de bf       	out	0x3e, r29	; 62
   110d0:	0f be       	out	0x3f, r0	; 63
   110d2:	cd bf       	out	0x3d, r28	; 61
   110d4:	0d 89       	ldd	r16, Y+21	; 0x15
   110d6:	1e 89       	ldd	r17, Y+22	; 0x16
   110d8:	8e e0       	ldi	r24, 0x0E	; 14
   110da:	8c 83       	std	Y+4, r24	; 0x04
   110dc:	1a 83       	std	Y+2, r17	; 0x02
   110de:	09 83       	std	Y+1, r16	; 0x01
   110e0:	8f ef       	ldi	r24, 0xFF	; 255
   110e2:	9f e7       	ldi	r25, 0x7F	; 127
   110e4:	9e 83       	std	Y+6, r25	; 0x06
   110e6:	8d 83       	std	Y+5, r24	; 0x05
   110e8:	9e 01       	movw	r18, r28
   110ea:	27 5e       	subi	r18, 0xE7	; 231
   110ec:	3f 4f       	sbci	r19, 0xFF	; 255
   110ee:	ce 01       	movw	r24, r28
   110f0:	01 96       	adiw	r24, 0x01	; 1
   110f2:	6f 89       	ldd	r22, Y+23	; 0x17
   110f4:	78 8d       	ldd	r23, Y+24	; 0x18
   110f6:	a9 01       	movw	r20, r18
   110f8:	0e 94 c4 8a 	call	0x11588	; 0x11588 <vfprintf>
   110fc:	2f 81       	ldd	r18, Y+7	; 0x07
   110fe:	38 85       	ldd	r19, Y+8	; 0x08
   11100:	02 0f       	add	r16, r18
   11102:	13 1f       	adc	r17, r19
   11104:	f8 01       	movw	r30, r16
   11106:	10 82       	st	Z, r1
   11108:	2e 96       	adiw	r28, 0x0e	; 14
   1110a:	0f b6       	in	r0, 0x3f	; 63
   1110c:	f8 94       	cli
   1110e:	de bf       	out	0x3e, r29	; 62
   11110:	0f be       	out	0x3f, r0	; 63
   11112:	cd bf       	out	0x3d, r28	; 61
   11114:	cf 91       	pop	r28
   11116:	df 91       	pop	r29
   11118:	1f 91       	pop	r17
   1111a:	0f 91       	pop	r16
   1111c:	08 95       	ret

0001111e <sscanf>:
   1111e:	df 93       	push	r29
   11120:	cf 93       	push	r28
   11122:	cd b7       	in	r28, 0x3d	; 61
   11124:	de b7       	in	r29, 0x3e	; 62
   11126:	2e 97       	sbiw	r28, 0x0e	; 14
   11128:	0f b6       	in	r0, 0x3f	; 63
   1112a:	f8 94       	cli
   1112c:	de bf       	out	0x3e, r29	; 62
   1112e:	0f be       	out	0x3f, r0	; 63
   11130:	cd bf       	out	0x3d, r28	; 61
   11132:	85 e0       	ldi	r24, 0x05	; 5
   11134:	8c 83       	std	Y+4, r24	; 0x04
   11136:	8b 89       	ldd	r24, Y+19	; 0x13
   11138:	9c 89       	ldd	r25, Y+20	; 0x14
   1113a:	9a 83       	std	Y+2, r25	; 0x02
   1113c:	89 83       	std	Y+1, r24	; 0x01
   1113e:	9e 01       	movw	r18, r28
   11140:	29 5e       	subi	r18, 0xE9	; 233
   11142:	3f 4f       	sbci	r19, 0xFF	; 255
   11144:	ce 01       	movw	r24, r28
   11146:	01 96       	adiw	r24, 0x01	; 1
   11148:	6d 89       	ldd	r22, Y+21	; 0x15
   1114a:	7e 89       	ldd	r23, Y+22	; 0x16
   1114c:	a9 01       	movw	r20, r18
   1114e:	0e 94 79 8e 	call	0x11cf2	; 0x11cf2 <vfscanf>
   11152:	2e 96       	adiw	r28, 0x0e	; 14
   11154:	0f b6       	in	r0, 0x3f	; 63
   11156:	f8 94       	cli
   11158:	de bf       	out	0x3e, r29	; 62
   1115a:	0f be       	out	0x3f, r0	; 63
   1115c:	cd bf       	out	0x3d, r28	; 61
   1115e:	cf 91       	pop	r28
   11160:	df 91       	pop	r29
   11162:	08 95       	ret

00011164 <sscanf_P>:
   11164:	df 93       	push	r29
   11166:	cf 93       	push	r28
   11168:	cd b7       	in	r28, 0x3d	; 61
   1116a:	de b7       	in	r29, 0x3e	; 62
   1116c:	2e 97       	sbiw	r28, 0x0e	; 14
   1116e:	0f b6       	in	r0, 0x3f	; 63
   11170:	f8 94       	cli
   11172:	de bf       	out	0x3e, r29	; 62
   11174:	0f be       	out	0x3f, r0	; 63
   11176:	cd bf       	out	0x3d, r28	; 61
   11178:	8d e0       	ldi	r24, 0x0D	; 13
   1117a:	8c 83       	std	Y+4, r24	; 0x04
   1117c:	8b 89       	ldd	r24, Y+19	; 0x13
   1117e:	9c 89       	ldd	r25, Y+20	; 0x14
   11180:	9a 83       	std	Y+2, r25	; 0x02
   11182:	89 83       	std	Y+1, r24	; 0x01
   11184:	9e 01       	movw	r18, r28
   11186:	29 5e       	subi	r18, 0xE9	; 233
   11188:	3f 4f       	sbci	r19, 0xFF	; 255
   1118a:	ce 01       	movw	r24, r28
   1118c:	01 96       	adiw	r24, 0x01	; 1
   1118e:	6d 89       	ldd	r22, Y+21	; 0x15
   11190:	7e 89       	ldd	r23, Y+22	; 0x16
   11192:	a9 01       	movw	r20, r18
   11194:	0e 94 79 8e 	call	0x11cf2	; 0x11cf2 <vfscanf>
   11198:	2e 96       	adiw	r28, 0x0e	; 14
   1119a:	0f b6       	in	r0, 0x3f	; 63
   1119c:	f8 94       	cli
   1119e:	de bf       	out	0x3e, r29	; 62
   111a0:	0f be       	out	0x3f, r0	; 63
   111a2:	cd bf       	out	0x3d, r28	; 61
   111a4:	cf 91       	pop	r28
   111a6:	df 91       	pop	r29
   111a8:	08 95       	ret

000111aa <__subsf3>:
   111aa:	50 58       	subi	r21, 0x80	; 128

000111ac <__addsf3>:
   111ac:	bb 27       	eor	r27, r27
   111ae:	aa 27       	eor	r26, r26
   111b0:	0e d0       	rcall	.+28     	; 0x111ce <__addsf3x>
   111b2:	4d c1       	rjmp	.+666    	; 0x1144e <__fp_round>
   111b4:	3e d1       	rcall	.+636    	; 0x11432 <__fp_pscA>
   111b6:	30 f0       	brcs	.+12     	; 0x111c4 <__addsf3+0x18>
   111b8:	43 d1       	rcall	.+646    	; 0x11440 <__fp_pscB>
   111ba:	20 f0       	brcs	.+8      	; 0x111c4 <__addsf3+0x18>
   111bc:	31 f4       	brne	.+12     	; 0x111ca <__addsf3+0x1e>
   111be:	9f 3f       	cpi	r25, 0xFF	; 255
   111c0:	11 f4       	brne	.+4      	; 0x111c6 <__addsf3+0x1a>
   111c2:	1e f4       	brtc	.+6      	; 0x111ca <__addsf3+0x1e>
   111c4:	33 c1       	rjmp	.+614    	; 0x1142c <__fp_nan>
   111c6:	0e f4       	brtc	.+2      	; 0x111ca <__addsf3+0x1e>
   111c8:	e0 95       	com	r30
   111ca:	e7 fb       	bst	r30, 7
   111cc:	29 c1       	rjmp	.+594    	; 0x11420 <__fp_inf>

000111ce <__addsf3x>:
   111ce:	e9 2f       	mov	r30, r25
   111d0:	4f d1       	rcall	.+670    	; 0x11470 <__fp_split3>
   111d2:	80 f3       	brcs	.-32     	; 0x111b4 <__addsf3+0x8>
   111d4:	ba 17       	cp	r27, r26
   111d6:	62 07       	cpc	r22, r18
   111d8:	73 07       	cpc	r23, r19
   111da:	84 07       	cpc	r24, r20
   111dc:	95 07       	cpc	r25, r21
   111de:	18 f0       	brcs	.+6      	; 0x111e6 <__addsf3x+0x18>
   111e0:	71 f4       	brne	.+28     	; 0x111fe <__addsf3x+0x30>
   111e2:	9e f5       	brtc	.+102    	; 0x1124a <__addsf3x+0x7c>
   111e4:	67 c1       	rjmp	.+718    	; 0x114b4 <__fp_zero>
   111e6:	0e f4       	brtc	.+2      	; 0x111ea <__addsf3x+0x1c>
   111e8:	e0 95       	com	r30
   111ea:	0b 2e       	mov	r0, r27
   111ec:	ba 2f       	mov	r27, r26
   111ee:	a0 2d       	mov	r26, r0
   111f0:	0b 01       	movw	r0, r22
   111f2:	b9 01       	movw	r22, r18
   111f4:	90 01       	movw	r18, r0
   111f6:	0c 01       	movw	r0, r24
   111f8:	ca 01       	movw	r24, r20
   111fa:	a0 01       	movw	r20, r0
   111fc:	11 24       	eor	r1, r1
   111fe:	ff 27       	eor	r31, r31
   11200:	59 1b       	sub	r21, r25
   11202:	99 f0       	breq	.+38     	; 0x1122a <__addsf3x+0x5c>
   11204:	59 3f       	cpi	r21, 0xF9	; 249
   11206:	50 f4       	brcc	.+20     	; 0x1121c <__addsf3x+0x4e>
   11208:	50 3e       	cpi	r21, 0xE0	; 224
   1120a:	68 f1       	brcs	.+90     	; 0x11266 <__addsf3x+0x98>
   1120c:	1a 16       	cp	r1, r26
   1120e:	f0 40       	sbci	r31, 0x00	; 0
   11210:	a2 2f       	mov	r26, r18
   11212:	23 2f       	mov	r18, r19
   11214:	34 2f       	mov	r19, r20
   11216:	44 27       	eor	r20, r20
   11218:	58 5f       	subi	r21, 0xF8	; 248
   1121a:	f3 cf       	rjmp	.-26     	; 0x11202 <__addsf3x+0x34>
   1121c:	46 95       	lsr	r20
   1121e:	37 95       	ror	r19
   11220:	27 95       	ror	r18
   11222:	a7 95       	ror	r26
   11224:	f0 40       	sbci	r31, 0x00	; 0
   11226:	53 95       	inc	r21
   11228:	c9 f7       	brne	.-14     	; 0x1121c <__addsf3x+0x4e>
   1122a:	7e f4       	brtc	.+30     	; 0x1124a <__addsf3x+0x7c>
   1122c:	1f 16       	cp	r1, r31
   1122e:	ba 0b       	sbc	r27, r26
   11230:	62 0b       	sbc	r22, r18
   11232:	73 0b       	sbc	r23, r19
   11234:	84 0b       	sbc	r24, r20
   11236:	ba f0       	brmi	.+46     	; 0x11266 <__addsf3x+0x98>
   11238:	91 50       	subi	r25, 0x01	; 1
   1123a:	a1 f0       	breq	.+40     	; 0x11264 <__addsf3x+0x96>
   1123c:	ff 0f       	add	r31, r31
   1123e:	bb 1f       	adc	r27, r27
   11240:	66 1f       	adc	r22, r22
   11242:	77 1f       	adc	r23, r23
   11244:	88 1f       	adc	r24, r24
   11246:	c2 f7       	brpl	.-16     	; 0x11238 <__addsf3x+0x6a>
   11248:	0e c0       	rjmp	.+28     	; 0x11266 <__addsf3x+0x98>
   1124a:	ba 0f       	add	r27, r26
   1124c:	62 1f       	adc	r22, r18
   1124e:	73 1f       	adc	r23, r19
   11250:	84 1f       	adc	r24, r20
   11252:	48 f4       	brcc	.+18     	; 0x11266 <__addsf3x+0x98>
   11254:	87 95       	ror	r24
   11256:	77 95       	ror	r23
   11258:	67 95       	ror	r22
   1125a:	b7 95       	ror	r27
   1125c:	f7 95       	ror	r31
   1125e:	9e 3f       	cpi	r25, 0xFE	; 254
   11260:	08 f0       	brcs	.+2      	; 0x11264 <__addsf3x+0x96>
   11262:	b3 cf       	rjmp	.-154    	; 0x111ca <__addsf3+0x1e>
   11264:	93 95       	inc	r25
   11266:	88 0f       	add	r24, r24
   11268:	08 f0       	brcs	.+2      	; 0x1126c <__addsf3x+0x9e>
   1126a:	99 27       	eor	r25, r25
   1126c:	ee 0f       	add	r30, r30
   1126e:	97 95       	ror	r25
   11270:	87 95       	ror	r24
   11272:	08 95       	ret

00011274 <__divsf3>:
   11274:	0c d0       	rcall	.+24     	; 0x1128e <__divsf3x>
   11276:	eb c0       	rjmp	.+470    	; 0x1144e <__fp_round>
   11278:	e3 d0       	rcall	.+454    	; 0x11440 <__fp_pscB>
   1127a:	40 f0       	brcs	.+16     	; 0x1128c <__divsf3+0x18>
   1127c:	da d0       	rcall	.+436    	; 0x11432 <__fp_pscA>
   1127e:	30 f0       	brcs	.+12     	; 0x1128c <__divsf3+0x18>
   11280:	21 f4       	brne	.+8      	; 0x1128a <__divsf3+0x16>
   11282:	5f 3f       	cpi	r21, 0xFF	; 255
   11284:	19 f0       	breq	.+6      	; 0x1128c <__divsf3+0x18>
   11286:	cc c0       	rjmp	.+408    	; 0x11420 <__fp_inf>
   11288:	51 11       	cpse	r21, r1
   1128a:	15 c1       	rjmp	.+554    	; 0x114b6 <__fp_szero>
   1128c:	cf c0       	rjmp	.+414    	; 0x1142c <__fp_nan>

0001128e <__divsf3x>:
   1128e:	f0 d0       	rcall	.+480    	; 0x11470 <__fp_split3>
   11290:	98 f3       	brcs	.-26     	; 0x11278 <__divsf3+0x4>

00011292 <__divsf3_pse>:
   11292:	99 23       	and	r25, r25
   11294:	c9 f3       	breq	.-14     	; 0x11288 <__divsf3+0x14>
   11296:	55 23       	and	r21, r21
   11298:	b1 f3       	breq	.-20     	; 0x11286 <__divsf3+0x12>
   1129a:	95 1b       	sub	r25, r21
   1129c:	55 0b       	sbc	r21, r21
   1129e:	bb 27       	eor	r27, r27
   112a0:	aa 27       	eor	r26, r26
   112a2:	62 17       	cp	r22, r18
   112a4:	73 07       	cpc	r23, r19
   112a6:	84 07       	cpc	r24, r20
   112a8:	38 f0       	brcs	.+14     	; 0x112b8 <__divsf3_pse+0x26>
   112aa:	9f 5f       	subi	r25, 0xFF	; 255
   112ac:	5f 4f       	sbci	r21, 0xFF	; 255
   112ae:	22 0f       	add	r18, r18
   112b0:	33 1f       	adc	r19, r19
   112b2:	44 1f       	adc	r20, r20
   112b4:	aa 1f       	adc	r26, r26
   112b6:	a9 f3       	breq	.-22     	; 0x112a2 <__divsf3_pse+0x10>
   112b8:	33 d0       	rcall	.+102    	; 0x11320 <__divsf3_pse+0x8e>
   112ba:	0e 2e       	mov	r0, r30
   112bc:	3a f0       	brmi	.+14     	; 0x112cc <__divsf3_pse+0x3a>
   112be:	e0 e8       	ldi	r30, 0x80	; 128
   112c0:	30 d0       	rcall	.+96     	; 0x11322 <__divsf3_pse+0x90>
   112c2:	91 50       	subi	r25, 0x01	; 1
   112c4:	50 40       	sbci	r21, 0x00	; 0
   112c6:	e6 95       	lsr	r30
   112c8:	00 1c       	adc	r0, r0
   112ca:	ca f7       	brpl	.-14     	; 0x112be <__divsf3_pse+0x2c>
   112cc:	29 d0       	rcall	.+82     	; 0x11320 <__divsf3_pse+0x8e>
   112ce:	fe 2f       	mov	r31, r30
   112d0:	27 d0       	rcall	.+78     	; 0x11320 <__divsf3_pse+0x8e>
   112d2:	66 0f       	add	r22, r22
   112d4:	77 1f       	adc	r23, r23
   112d6:	88 1f       	adc	r24, r24
   112d8:	bb 1f       	adc	r27, r27
   112da:	26 17       	cp	r18, r22
   112dc:	37 07       	cpc	r19, r23
   112de:	48 07       	cpc	r20, r24
   112e0:	ab 07       	cpc	r26, r27
   112e2:	b0 e8       	ldi	r27, 0x80	; 128
   112e4:	09 f0       	breq	.+2      	; 0x112e8 <__divsf3_pse+0x56>
   112e6:	bb 0b       	sbc	r27, r27
   112e8:	80 2d       	mov	r24, r0
   112ea:	bf 01       	movw	r22, r30
   112ec:	ff 27       	eor	r31, r31
   112ee:	93 58       	subi	r25, 0x83	; 131
   112f0:	5f 4f       	sbci	r21, 0xFF	; 255
   112f2:	2a f0       	brmi	.+10     	; 0x112fe <__divsf3_pse+0x6c>
   112f4:	9e 3f       	cpi	r25, 0xFE	; 254
   112f6:	51 05       	cpc	r21, r1
   112f8:	68 f0       	brcs	.+26     	; 0x11314 <__divsf3_pse+0x82>
   112fa:	92 c0       	rjmp	.+292    	; 0x11420 <__fp_inf>
   112fc:	dc c0       	rjmp	.+440    	; 0x114b6 <__fp_szero>
   112fe:	5f 3f       	cpi	r21, 0xFF	; 255
   11300:	ec f3       	brlt	.-6      	; 0x112fc <__divsf3_pse+0x6a>
   11302:	98 3e       	cpi	r25, 0xE8	; 232
   11304:	dc f3       	brlt	.-10     	; 0x112fc <__divsf3_pse+0x6a>
   11306:	86 95       	lsr	r24
   11308:	77 95       	ror	r23
   1130a:	67 95       	ror	r22
   1130c:	b7 95       	ror	r27
   1130e:	f7 95       	ror	r31
   11310:	9f 5f       	subi	r25, 0xFF	; 255
   11312:	c9 f7       	brne	.-14     	; 0x11306 <__divsf3_pse+0x74>
   11314:	88 0f       	add	r24, r24
   11316:	91 1d       	adc	r25, r1
   11318:	96 95       	lsr	r25
   1131a:	87 95       	ror	r24
   1131c:	97 f9       	bld	r25, 7
   1131e:	08 95       	ret
   11320:	e1 e0       	ldi	r30, 0x01	; 1
   11322:	66 0f       	add	r22, r22
   11324:	77 1f       	adc	r23, r23
   11326:	88 1f       	adc	r24, r24
   11328:	bb 1f       	adc	r27, r27
   1132a:	62 17       	cp	r22, r18
   1132c:	73 07       	cpc	r23, r19
   1132e:	84 07       	cpc	r24, r20
   11330:	ba 07       	cpc	r27, r26
   11332:	20 f0       	brcs	.+8      	; 0x1133c <__divsf3_pse+0xaa>
   11334:	62 1b       	sub	r22, r18
   11336:	73 0b       	sbc	r23, r19
   11338:	84 0b       	sbc	r24, r20
   1133a:	ba 0b       	sbc	r27, r26
   1133c:	ee 1f       	adc	r30, r30
   1133e:	88 f7       	brcc	.-30     	; 0x11322 <__divsf3_pse+0x90>
   11340:	e0 95       	com	r30
   11342:	08 95       	ret

00011344 <__fixsfsi>:
   11344:	04 d0       	rcall	.+8      	; 0x1134e <__fixunssfsi>
   11346:	68 94       	set
   11348:	b1 11       	cpse	r27, r1
   1134a:	b5 c0       	rjmp	.+362    	; 0x114b6 <__fp_szero>
   1134c:	08 95       	ret

0001134e <__fixunssfsi>:
   1134e:	98 d0       	rcall	.+304    	; 0x11480 <__fp_splitA>
   11350:	88 f0       	brcs	.+34     	; 0x11374 <__fixunssfsi+0x26>
   11352:	9f 57       	subi	r25, 0x7F	; 127
   11354:	90 f0       	brcs	.+36     	; 0x1137a <__fixunssfsi+0x2c>
   11356:	b9 2f       	mov	r27, r25
   11358:	99 27       	eor	r25, r25
   1135a:	b7 51       	subi	r27, 0x17	; 23
   1135c:	a0 f0       	brcs	.+40     	; 0x11386 <__fixunssfsi+0x38>
   1135e:	d1 f0       	breq	.+52     	; 0x11394 <__fixunssfsi+0x46>
   11360:	66 0f       	add	r22, r22
   11362:	77 1f       	adc	r23, r23
   11364:	88 1f       	adc	r24, r24
   11366:	99 1f       	adc	r25, r25
   11368:	1a f0       	brmi	.+6      	; 0x11370 <__fixunssfsi+0x22>
   1136a:	ba 95       	dec	r27
   1136c:	c9 f7       	brne	.-14     	; 0x11360 <__fixunssfsi+0x12>
   1136e:	12 c0       	rjmp	.+36     	; 0x11394 <__fixunssfsi+0x46>
   11370:	b1 30       	cpi	r27, 0x01	; 1
   11372:	81 f0       	breq	.+32     	; 0x11394 <__fixunssfsi+0x46>
   11374:	9f d0       	rcall	.+318    	; 0x114b4 <__fp_zero>
   11376:	b1 e0       	ldi	r27, 0x01	; 1
   11378:	08 95       	ret
   1137a:	9c c0       	rjmp	.+312    	; 0x114b4 <__fp_zero>
   1137c:	67 2f       	mov	r22, r23
   1137e:	78 2f       	mov	r23, r24
   11380:	88 27       	eor	r24, r24
   11382:	b8 5f       	subi	r27, 0xF8	; 248
   11384:	39 f0       	breq	.+14     	; 0x11394 <__fixunssfsi+0x46>
   11386:	b9 3f       	cpi	r27, 0xF9	; 249
   11388:	cc f3       	brlt	.-14     	; 0x1137c <__fixunssfsi+0x2e>
   1138a:	86 95       	lsr	r24
   1138c:	77 95       	ror	r23
   1138e:	67 95       	ror	r22
   11390:	b3 95       	inc	r27
   11392:	d9 f7       	brne	.-10     	; 0x1138a <__fixunssfsi+0x3c>
   11394:	3e f4       	brtc	.+14     	; 0x113a4 <__fixunssfsi+0x56>
   11396:	90 95       	com	r25
   11398:	80 95       	com	r24
   1139a:	70 95       	com	r23
   1139c:	61 95       	neg	r22
   1139e:	7f 4f       	sbci	r23, 0xFF	; 255
   113a0:	8f 4f       	sbci	r24, 0xFF	; 255
   113a2:	9f 4f       	sbci	r25, 0xFF	; 255
   113a4:	08 95       	ret

000113a6 <__floatunsisf>:
   113a6:	e8 94       	clt
   113a8:	09 c0       	rjmp	.+18     	; 0x113bc <__floatsisf+0x12>

000113aa <__floatsisf>:
   113aa:	97 fb       	bst	r25, 7
   113ac:	3e f4       	brtc	.+14     	; 0x113bc <__floatsisf+0x12>
   113ae:	90 95       	com	r25
   113b0:	80 95       	com	r24
   113b2:	70 95       	com	r23
   113b4:	61 95       	neg	r22
   113b6:	7f 4f       	sbci	r23, 0xFF	; 255
   113b8:	8f 4f       	sbci	r24, 0xFF	; 255
   113ba:	9f 4f       	sbci	r25, 0xFF	; 255
   113bc:	99 23       	and	r25, r25
   113be:	a9 f0       	breq	.+42     	; 0x113ea <__floatsisf+0x40>
   113c0:	f9 2f       	mov	r31, r25
   113c2:	96 e9       	ldi	r25, 0x96	; 150
   113c4:	bb 27       	eor	r27, r27
   113c6:	93 95       	inc	r25
   113c8:	f6 95       	lsr	r31
   113ca:	87 95       	ror	r24
   113cc:	77 95       	ror	r23
   113ce:	67 95       	ror	r22
   113d0:	b7 95       	ror	r27
   113d2:	f1 11       	cpse	r31, r1
   113d4:	f8 cf       	rjmp	.-16     	; 0x113c6 <__floatsisf+0x1c>
   113d6:	fa f4       	brpl	.+62     	; 0x11416 <__floatsisf+0x6c>
   113d8:	bb 0f       	add	r27, r27
   113da:	11 f4       	brne	.+4      	; 0x113e0 <__floatsisf+0x36>
   113dc:	60 ff       	sbrs	r22, 0
   113de:	1b c0       	rjmp	.+54     	; 0x11416 <__floatsisf+0x6c>
   113e0:	6f 5f       	subi	r22, 0xFF	; 255
   113e2:	7f 4f       	sbci	r23, 0xFF	; 255
   113e4:	8f 4f       	sbci	r24, 0xFF	; 255
   113e6:	9f 4f       	sbci	r25, 0xFF	; 255
   113e8:	16 c0       	rjmp	.+44     	; 0x11416 <__floatsisf+0x6c>
   113ea:	88 23       	and	r24, r24
   113ec:	11 f0       	breq	.+4      	; 0x113f2 <__floatsisf+0x48>
   113ee:	96 e9       	ldi	r25, 0x96	; 150
   113f0:	11 c0       	rjmp	.+34     	; 0x11414 <__floatsisf+0x6a>
   113f2:	77 23       	and	r23, r23
   113f4:	21 f0       	breq	.+8      	; 0x113fe <__floatsisf+0x54>
   113f6:	9e e8       	ldi	r25, 0x8E	; 142
   113f8:	87 2f       	mov	r24, r23
   113fa:	76 2f       	mov	r23, r22
   113fc:	05 c0       	rjmp	.+10     	; 0x11408 <__floatsisf+0x5e>
   113fe:	66 23       	and	r22, r22
   11400:	71 f0       	breq	.+28     	; 0x1141e <__floatsisf+0x74>
   11402:	96 e8       	ldi	r25, 0x86	; 134
   11404:	86 2f       	mov	r24, r22
   11406:	70 e0       	ldi	r23, 0x00	; 0
   11408:	60 e0       	ldi	r22, 0x00	; 0
   1140a:	2a f0       	brmi	.+10     	; 0x11416 <__floatsisf+0x6c>
   1140c:	9a 95       	dec	r25
   1140e:	66 0f       	add	r22, r22
   11410:	77 1f       	adc	r23, r23
   11412:	88 1f       	adc	r24, r24
   11414:	da f7       	brpl	.-10     	; 0x1140c <__floatsisf+0x62>
   11416:	88 0f       	add	r24, r24
   11418:	96 95       	lsr	r25
   1141a:	87 95       	ror	r24
   1141c:	97 f9       	bld	r25, 7
   1141e:	08 95       	ret

00011420 <__fp_inf>:
   11420:	97 f9       	bld	r25, 7
   11422:	9f 67       	ori	r25, 0x7F	; 127
   11424:	80 e8       	ldi	r24, 0x80	; 128
   11426:	70 e0       	ldi	r23, 0x00	; 0
   11428:	60 e0       	ldi	r22, 0x00	; 0
   1142a:	08 95       	ret

0001142c <__fp_nan>:
   1142c:	9f ef       	ldi	r25, 0xFF	; 255
   1142e:	80 ec       	ldi	r24, 0xC0	; 192
   11430:	08 95       	ret

00011432 <__fp_pscA>:
   11432:	00 24       	eor	r0, r0
   11434:	0a 94       	dec	r0
   11436:	16 16       	cp	r1, r22
   11438:	17 06       	cpc	r1, r23
   1143a:	18 06       	cpc	r1, r24
   1143c:	09 06       	cpc	r0, r25
   1143e:	08 95       	ret

00011440 <__fp_pscB>:
   11440:	00 24       	eor	r0, r0
   11442:	0a 94       	dec	r0
   11444:	12 16       	cp	r1, r18
   11446:	13 06       	cpc	r1, r19
   11448:	14 06       	cpc	r1, r20
   1144a:	05 06       	cpc	r0, r21
   1144c:	08 95       	ret

0001144e <__fp_round>:
   1144e:	09 2e       	mov	r0, r25
   11450:	03 94       	inc	r0
   11452:	00 0c       	add	r0, r0
   11454:	11 f4       	brne	.+4      	; 0x1145a <__fp_round+0xc>
   11456:	88 23       	and	r24, r24
   11458:	52 f0       	brmi	.+20     	; 0x1146e <__fp_round+0x20>
   1145a:	bb 0f       	add	r27, r27
   1145c:	40 f4       	brcc	.+16     	; 0x1146e <__fp_round+0x20>
   1145e:	bf 2b       	or	r27, r31
   11460:	11 f4       	brne	.+4      	; 0x11466 <__fp_round+0x18>
   11462:	60 ff       	sbrs	r22, 0
   11464:	04 c0       	rjmp	.+8      	; 0x1146e <__fp_round+0x20>
   11466:	6f 5f       	subi	r22, 0xFF	; 255
   11468:	7f 4f       	sbci	r23, 0xFF	; 255
   1146a:	8f 4f       	sbci	r24, 0xFF	; 255
   1146c:	9f 4f       	sbci	r25, 0xFF	; 255
   1146e:	08 95       	ret

00011470 <__fp_split3>:
   11470:	57 fd       	sbrc	r21, 7
   11472:	90 58       	subi	r25, 0x80	; 128
   11474:	44 0f       	add	r20, r20
   11476:	55 1f       	adc	r21, r21
   11478:	59 f0       	breq	.+22     	; 0x11490 <__fp_splitA+0x10>
   1147a:	5f 3f       	cpi	r21, 0xFF	; 255
   1147c:	71 f0       	breq	.+28     	; 0x1149a <__fp_splitA+0x1a>
   1147e:	47 95       	ror	r20

00011480 <__fp_splitA>:
   11480:	88 0f       	add	r24, r24
   11482:	97 fb       	bst	r25, 7
   11484:	99 1f       	adc	r25, r25
   11486:	61 f0       	breq	.+24     	; 0x114a0 <__fp_splitA+0x20>
   11488:	9f 3f       	cpi	r25, 0xFF	; 255
   1148a:	79 f0       	breq	.+30     	; 0x114aa <__fp_splitA+0x2a>
   1148c:	87 95       	ror	r24
   1148e:	08 95       	ret
   11490:	12 16       	cp	r1, r18
   11492:	13 06       	cpc	r1, r19
   11494:	14 06       	cpc	r1, r20
   11496:	55 1f       	adc	r21, r21
   11498:	f2 cf       	rjmp	.-28     	; 0x1147e <__fp_split3+0xe>
   1149a:	46 95       	lsr	r20
   1149c:	f1 df       	rcall	.-30     	; 0x11480 <__fp_splitA>
   1149e:	08 c0       	rjmp	.+16     	; 0x114b0 <__fp_splitA+0x30>
   114a0:	16 16       	cp	r1, r22
   114a2:	17 06       	cpc	r1, r23
   114a4:	18 06       	cpc	r1, r24
   114a6:	99 1f       	adc	r25, r25
   114a8:	f1 cf       	rjmp	.-30     	; 0x1148c <__fp_splitA+0xc>
   114aa:	86 95       	lsr	r24
   114ac:	71 05       	cpc	r23, r1
   114ae:	61 05       	cpc	r22, r1
   114b0:	08 94       	sec
   114b2:	08 95       	ret

000114b4 <__fp_zero>:
   114b4:	e8 94       	clt

000114b6 <__fp_szero>:
   114b6:	bb 27       	eor	r27, r27
   114b8:	66 27       	eor	r22, r22
   114ba:	77 27       	eor	r23, r23
   114bc:	cb 01       	movw	r24, r22
   114be:	97 f9       	bld	r25, 7
   114c0:	08 95       	ret

000114c2 <__mulsf3>:
   114c2:	0b d0       	rcall	.+22     	; 0x114da <__mulsf3x>
   114c4:	c4 cf       	rjmp	.-120    	; 0x1144e <__fp_round>
   114c6:	b5 df       	rcall	.-150    	; 0x11432 <__fp_pscA>
   114c8:	28 f0       	brcs	.+10     	; 0x114d4 <__mulsf3+0x12>
   114ca:	ba df       	rcall	.-140    	; 0x11440 <__fp_pscB>
   114cc:	18 f0       	brcs	.+6      	; 0x114d4 <__mulsf3+0x12>
   114ce:	95 23       	and	r25, r21
   114d0:	09 f0       	breq	.+2      	; 0x114d4 <__mulsf3+0x12>
   114d2:	a6 cf       	rjmp	.-180    	; 0x11420 <__fp_inf>
   114d4:	ab cf       	rjmp	.-170    	; 0x1142c <__fp_nan>
   114d6:	11 24       	eor	r1, r1
   114d8:	ee cf       	rjmp	.-36     	; 0x114b6 <__fp_szero>

000114da <__mulsf3x>:
   114da:	ca df       	rcall	.-108    	; 0x11470 <__fp_split3>
   114dc:	a0 f3       	brcs	.-24     	; 0x114c6 <__mulsf3+0x4>

000114de <__mulsf3_pse>:
   114de:	95 9f       	mul	r25, r21
   114e0:	d1 f3       	breq	.-12     	; 0x114d6 <__mulsf3+0x14>
   114e2:	95 0f       	add	r25, r21
   114e4:	50 e0       	ldi	r21, 0x00	; 0
   114e6:	55 1f       	adc	r21, r21
   114e8:	62 9f       	mul	r22, r18
   114ea:	f0 01       	movw	r30, r0
   114ec:	72 9f       	mul	r23, r18
   114ee:	bb 27       	eor	r27, r27
   114f0:	f0 0d       	add	r31, r0
   114f2:	b1 1d       	adc	r27, r1
   114f4:	63 9f       	mul	r22, r19
   114f6:	aa 27       	eor	r26, r26
   114f8:	f0 0d       	add	r31, r0
   114fa:	b1 1d       	adc	r27, r1
   114fc:	aa 1f       	adc	r26, r26
   114fe:	64 9f       	mul	r22, r20
   11500:	66 27       	eor	r22, r22
   11502:	b0 0d       	add	r27, r0
   11504:	a1 1d       	adc	r26, r1
   11506:	66 1f       	adc	r22, r22
   11508:	82 9f       	mul	r24, r18
   1150a:	22 27       	eor	r18, r18
   1150c:	b0 0d       	add	r27, r0
   1150e:	a1 1d       	adc	r26, r1
   11510:	62 1f       	adc	r22, r18
   11512:	73 9f       	mul	r23, r19
   11514:	b0 0d       	add	r27, r0
   11516:	a1 1d       	adc	r26, r1
   11518:	62 1f       	adc	r22, r18
   1151a:	83 9f       	mul	r24, r19
   1151c:	a0 0d       	add	r26, r0
   1151e:	61 1d       	adc	r22, r1
   11520:	22 1f       	adc	r18, r18
   11522:	74 9f       	mul	r23, r20
   11524:	33 27       	eor	r19, r19
   11526:	a0 0d       	add	r26, r0
   11528:	61 1d       	adc	r22, r1
   1152a:	23 1f       	adc	r18, r19
   1152c:	84 9f       	mul	r24, r20
   1152e:	60 0d       	add	r22, r0
   11530:	21 1d       	adc	r18, r1
   11532:	82 2f       	mov	r24, r18
   11534:	76 2f       	mov	r23, r22
   11536:	6a 2f       	mov	r22, r26
   11538:	11 24       	eor	r1, r1
   1153a:	9f 57       	subi	r25, 0x7F	; 127
   1153c:	50 40       	sbci	r21, 0x00	; 0
   1153e:	8a f0       	brmi	.+34     	; 0x11562 <__mulsf3_pse+0x84>
   11540:	e1 f0       	breq	.+56     	; 0x1157a <__mulsf3_pse+0x9c>
   11542:	88 23       	and	r24, r24
   11544:	4a f0       	brmi	.+18     	; 0x11558 <__mulsf3_pse+0x7a>
   11546:	ee 0f       	add	r30, r30
   11548:	ff 1f       	adc	r31, r31
   1154a:	bb 1f       	adc	r27, r27
   1154c:	66 1f       	adc	r22, r22
   1154e:	77 1f       	adc	r23, r23
   11550:	88 1f       	adc	r24, r24
   11552:	91 50       	subi	r25, 0x01	; 1
   11554:	50 40       	sbci	r21, 0x00	; 0
   11556:	a9 f7       	brne	.-22     	; 0x11542 <__mulsf3_pse+0x64>
   11558:	9e 3f       	cpi	r25, 0xFE	; 254
   1155a:	51 05       	cpc	r21, r1
   1155c:	70 f0       	brcs	.+28     	; 0x1157a <__mulsf3_pse+0x9c>
   1155e:	60 cf       	rjmp	.-320    	; 0x11420 <__fp_inf>
   11560:	aa cf       	rjmp	.-172    	; 0x114b6 <__fp_szero>
   11562:	5f 3f       	cpi	r21, 0xFF	; 255
   11564:	ec f3       	brlt	.-6      	; 0x11560 <__mulsf3_pse+0x82>
   11566:	98 3e       	cpi	r25, 0xE8	; 232
   11568:	dc f3       	brlt	.-10     	; 0x11560 <__mulsf3_pse+0x82>
   1156a:	86 95       	lsr	r24
   1156c:	77 95       	ror	r23
   1156e:	67 95       	ror	r22
   11570:	b7 95       	ror	r27
   11572:	f7 95       	ror	r31
   11574:	e7 95       	ror	r30
   11576:	9f 5f       	subi	r25, 0xFF	; 255
   11578:	c1 f7       	brne	.-16     	; 0x1156a <__mulsf3_pse+0x8c>
   1157a:	fe 2b       	or	r31, r30
   1157c:	88 0f       	add	r24, r24
   1157e:	91 1d       	adc	r25, r1
   11580:	96 95       	lsr	r25
   11582:	87 95       	ror	r24
   11584:	97 f9       	bld	r25, 7
   11586:	08 95       	ret

00011588 <vfprintf>:
   11588:	2f 92       	push	r2
   1158a:	3f 92       	push	r3
   1158c:	4f 92       	push	r4
   1158e:	5f 92       	push	r5
   11590:	6f 92       	push	r6
   11592:	7f 92       	push	r7
   11594:	8f 92       	push	r8
   11596:	9f 92       	push	r9
   11598:	af 92       	push	r10
   1159a:	bf 92       	push	r11
   1159c:	cf 92       	push	r12
   1159e:	df 92       	push	r13
   115a0:	ef 92       	push	r14
   115a2:	ff 92       	push	r15
   115a4:	0f 93       	push	r16
   115a6:	1f 93       	push	r17
   115a8:	df 93       	push	r29
   115aa:	cf 93       	push	r28
   115ac:	cd b7       	in	r28, 0x3d	; 61
   115ae:	de b7       	in	r29, 0x3e	; 62
   115b0:	2b 97       	sbiw	r28, 0x0b	; 11
   115b2:	0f b6       	in	r0, 0x3f	; 63
   115b4:	f8 94       	cli
   115b6:	de bf       	out	0x3e, r29	; 62
   115b8:	0f be       	out	0x3f, r0	; 63
   115ba:	cd bf       	out	0x3d, r28	; 61
   115bc:	3c 01       	movw	r6, r24
   115be:	2b 01       	movw	r4, r22
   115c0:	5a 01       	movw	r10, r20
   115c2:	fc 01       	movw	r30, r24
   115c4:	17 82       	std	Z+7, r1	; 0x07
   115c6:	16 82       	std	Z+6, r1	; 0x06
   115c8:	83 81       	ldd	r24, Z+3	; 0x03
   115ca:	81 fd       	sbrc	r24, 1
   115cc:	03 c0       	rjmp	.+6      	; 0x115d4 <vfprintf+0x4c>
   115ce:	6f ef       	ldi	r22, 0xFF	; 255
   115d0:	7f ef       	ldi	r23, 0xFF	; 255
   115d2:	c6 c1       	rjmp	.+908    	; 0x11960 <vfprintf+0x3d8>
   115d4:	9a e0       	ldi	r25, 0x0A	; 10
   115d6:	89 2e       	mov	r8, r25
   115d8:	1e 01       	movw	r2, r28
   115da:	08 94       	sec
   115dc:	21 1c       	adc	r2, r1
   115de:	31 1c       	adc	r3, r1
   115e0:	f3 01       	movw	r30, r6
   115e2:	23 81       	ldd	r18, Z+3	; 0x03
   115e4:	f2 01       	movw	r30, r4
   115e6:	23 fd       	sbrc	r18, 3
   115e8:	85 91       	lpm	r24, Z+
   115ea:	23 ff       	sbrs	r18, 3
   115ec:	81 91       	ld	r24, Z+
   115ee:	2f 01       	movw	r4, r30
   115f0:	88 23       	and	r24, r24
   115f2:	09 f4       	brne	.+2      	; 0x115f6 <vfprintf+0x6e>
   115f4:	b2 c1       	rjmp	.+868    	; 0x1195a <vfprintf+0x3d2>
   115f6:	85 32       	cpi	r24, 0x25	; 37
   115f8:	39 f4       	brne	.+14     	; 0x11608 <vfprintf+0x80>
   115fa:	23 fd       	sbrc	r18, 3
   115fc:	85 91       	lpm	r24, Z+
   115fe:	23 ff       	sbrs	r18, 3
   11600:	81 91       	ld	r24, Z+
   11602:	2f 01       	movw	r4, r30
   11604:	85 32       	cpi	r24, 0x25	; 37
   11606:	29 f4       	brne	.+10     	; 0x11612 <vfprintf+0x8a>
   11608:	90 e0       	ldi	r25, 0x00	; 0
   1160a:	b3 01       	movw	r22, r6
   1160c:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   11610:	e7 cf       	rjmp	.-50     	; 0x115e0 <vfprintf+0x58>
   11612:	98 2f       	mov	r25, r24
   11614:	ff 24       	eor	r15, r15
   11616:	ee 24       	eor	r14, r14
   11618:	99 24       	eor	r9, r9
   1161a:	ff e1       	ldi	r31, 0x1F	; 31
   1161c:	ff 15       	cp	r31, r15
   1161e:	d0 f0       	brcs	.+52     	; 0x11654 <vfprintf+0xcc>
   11620:	9b 32       	cpi	r25, 0x2B	; 43
   11622:	69 f0       	breq	.+26     	; 0x1163e <vfprintf+0xb6>
   11624:	9c 32       	cpi	r25, 0x2C	; 44
   11626:	28 f4       	brcc	.+10     	; 0x11632 <vfprintf+0xaa>
   11628:	90 32       	cpi	r25, 0x20	; 32
   1162a:	59 f0       	breq	.+22     	; 0x11642 <vfprintf+0xba>
   1162c:	93 32       	cpi	r25, 0x23	; 35
   1162e:	91 f4       	brne	.+36     	; 0x11654 <vfprintf+0xcc>
   11630:	0e c0       	rjmp	.+28     	; 0x1164e <vfprintf+0xc6>
   11632:	9d 32       	cpi	r25, 0x2D	; 45
   11634:	49 f0       	breq	.+18     	; 0x11648 <vfprintf+0xc0>
   11636:	90 33       	cpi	r25, 0x30	; 48
   11638:	69 f4       	brne	.+26     	; 0x11654 <vfprintf+0xcc>
   1163a:	41 e0       	ldi	r20, 0x01	; 1
   1163c:	24 c0       	rjmp	.+72     	; 0x11686 <vfprintf+0xfe>
   1163e:	52 e0       	ldi	r21, 0x02	; 2
   11640:	f5 2a       	or	r15, r21
   11642:	84 e0       	ldi	r24, 0x04	; 4
   11644:	f8 2a       	or	r15, r24
   11646:	28 c0       	rjmp	.+80     	; 0x11698 <vfprintf+0x110>
   11648:	98 e0       	ldi	r25, 0x08	; 8
   1164a:	f9 2a       	or	r15, r25
   1164c:	25 c0       	rjmp	.+74     	; 0x11698 <vfprintf+0x110>
   1164e:	e0 e1       	ldi	r30, 0x10	; 16
   11650:	fe 2a       	or	r15, r30
   11652:	22 c0       	rjmp	.+68     	; 0x11698 <vfprintf+0x110>
   11654:	f7 fc       	sbrc	r15, 7
   11656:	29 c0       	rjmp	.+82     	; 0x116aa <vfprintf+0x122>
   11658:	89 2f       	mov	r24, r25
   1165a:	80 53       	subi	r24, 0x30	; 48
   1165c:	8a 30       	cpi	r24, 0x0A	; 10
   1165e:	70 f4       	brcc	.+28     	; 0x1167c <vfprintf+0xf4>
   11660:	f6 fe       	sbrs	r15, 6
   11662:	05 c0       	rjmp	.+10     	; 0x1166e <vfprintf+0xe6>
   11664:	98 9c       	mul	r9, r8
   11666:	90 2c       	mov	r9, r0
   11668:	11 24       	eor	r1, r1
   1166a:	98 0e       	add	r9, r24
   1166c:	15 c0       	rjmp	.+42     	; 0x11698 <vfprintf+0x110>
   1166e:	e8 9c       	mul	r14, r8
   11670:	e0 2c       	mov	r14, r0
   11672:	11 24       	eor	r1, r1
   11674:	e8 0e       	add	r14, r24
   11676:	f0 e2       	ldi	r31, 0x20	; 32
   11678:	ff 2a       	or	r15, r31
   1167a:	0e c0       	rjmp	.+28     	; 0x11698 <vfprintf+0x110>
   1167c:	9e 32       	cpi	r25, 0x2E	; 46
   1167e:	29 f4       	brne	.+10     	; 0x1168a <vfprintf+0x102>
   11680:	f6 fc       	sbrc	r15, 6
   11682:	6b c1       	rjmp	.+726    	; 0x1195a <vfprintf+0x3d2>
   11684:	40 e4       	ldi	r20, 0x40	; 64
   11686:	f4 2a       	or	r15, r20
   11688:	07 c0       	rjmp	.+14     	; 0x11698 <vfprintf+0x110>
   1168a:	9c 36       	cpi	r25, 0x6C	; 108
   1168c:	19 f4       	brne	.+6      	; 0x11694 <vfprintf+0x10c>
   1168e:	50 e8       	ldi	r21, 0x80	; 128
   11690:	f5 2a       	or	r15, r21
   11692:	02 c0       	rjmp	.+4      	; 0x11698 <vfprintf+0x110>
   11694:	98 36       	cpi	r25, 0x68	; 104
   11696:	49 f4       	brne	.+18     	; 0x116aa <vfprintf+0x122>
   11698:	f2 01       	movw	r30, r4
   1169a:	23 fd       	sbrc	r18, 3
   1169c:	95 91       	lpm	r25, Z+
   1169e:	23 ff       	sbrs	r18, 3
   116a0:	91 91       	ld	r25, Z+
   116a2:	2f 01       	movw	r4, r30
   116a4:	99 23       	and	r25, r25
   116a6:	09 f0       	breq	.+2      	; 0x116aa <vfprintf+0x122>
   116a8:	b8 cf       	rjmp	.-144    	; 0x1161a <vfprintf+0x92>
   116aa:	89 2f       	mov	r24, r25
   116ac:	85 54       	subi	r24, 0x45	; 69
   116ae:	83 30       	cpi	r24, 0x03	; 3
   116b0:	18 f0       	brcs	.+6      	; 0x116b8 <vfprintf+0x130>
   116b2:	80 52       	subi	r24, 0x20	; 32
   116b4:	83 30       	cpi	r24, 0x03	; 3
   116b6:	38 f4       	brcc	.+14     	; 0x116c6 <vfprintf+0x13e>
   116b8:	44 e0       	ldi	r20, 0x04	; 4
   116ba:	50 e0       	ldi	r21, 0x00	; 0
   116bc:	a4 0e       	add	r10, r20
   116be:	b5 1e       	adc	r11, r21
   116c0:	5f e3       	ldi	r21, 0x3F	; 63
   116c2:	59 83       	std	Y+1, r21	; 0x01
   116c4:	0f c0       	rjmp	.+30     	; 0x116e4 <vfprintf+0x15c>
   116c6:	93 36       	cpi	r25, 0x63	; 99
   116c8:	31 f0       	breq	.+12     	; 0x116d6 <vfprintf+0x14e>
   116ca:	93 37       	cpi	r25, 0x73	; 115
   116cc:	79 f0       	breq	.+30     	; 0x116ec <vfprintf+0x164>
   116ce:	93 35       	cpi	r25, 0x53	; 83
   116d0:	09 f0       	breq	.+2      	; 0x116d4 <vfprintf+0x14c>
   116d2:	56 c0       	rjmp	.+172    	; 0x11780 <vfprintf+0x1f8>
   116d4:	20 c0       	rjmp	.+64     	; 0x11716 <vfprintf+0x18e>
   116d6:	f5 01       	movw	r30, r10
   116d8:	80 81       	ld	r24, Z
   116da:	89 83       	std	Y+1, r24	; 0x01
   116dc:	42 e0       	ldi	r20, 0x02	; 2
   116de:	50 e0       	ldi	r21, 0x00	; 0
   116e0:	a4 0e       	add	r10, r20
   116e2:	b5 1e       	adc	r11, r21
   116e4:	61 01       	movw	r12, r2
   116e6:	01 e0       	ldi	r16, 0x01	; 1
   116e8:	10 e0       	ldi	r17, 0x00	; 0
   116ea:	12 c0       	rjmp	.+36     	; 0x11710 <vfprintf+0x188>
   116ec:	f5 01       	movw	r30, r10
   116ee:	c0 80       	ld	r12, Z
   116f0:	d1 80       	ldd	r13, Z+1	; 0x01
   116f2:	f6 fc       	sbrc	r15, 6
   116f4:	03 c0       	rjmp	.+6      	; 0x116fc <vfprintf+0x174>
   116f6:	6f ef       	ldi	r22, 0xFF	; 255
   116f8:	7f ef       	ldi	r23, 0xFF	; 255
   116fa:	02 c0       	rjmp	.+4      	; 0x11700 <vfprintf+0x178>
   116fc:	69 2d       	mov	r22, r9
   116fe:	70 e0       	ldi	r23, 0x00	; 0
   11700:	42 e0       	ldi	r20, 0x02	; 2
   11702:	50 e0       	ldi	r21, 0x00	; 0
   11704:	a4 0e       	add	r10, r20
   11706:	b5 1e       	adc	r11, r21
   11708:	c6 01       	movw	r24, r12
   1170a:	0e 94 f7 8f 	call	0x11fee	; 0x11fee <strnlen>
   1170e:	8c 01       	movw	r16, r24
   11710:	5f e7       	ldi	r21, 0x7F	; 127
   11712:	f5 22       	and	r15, r21
   11714:	14 c0       	rjmp	.+40     	; 0x1173e <vfprintf+0x1b6>
   11716:	f5 01       	movw	r30, r10
   11718:	c0 80       	ld	r12, Z
   1171a:	d1 80       	ldd	r13, Z+1	; 0x01
   1171c:	f6 fc       	sbrc	r15, 6
   1171e:	03 c0       	rjmp	.+6      	; 0x11726 <vfprintf+0x19e>
   11720:	6f ef       	ldi	r22, 0xFF	; 255
   11722:	7f ef       	ldi	r23, 0xFF	; 255
   11724:	02 c0       	rjmp	.+4      	; 0x1172a <vfprintf+0x1a2>
   11726:	69 2d       	mov	r22, r9
   11728:	70 e0       	ldi	r23, 0x00	; 0
   1172a:	42 e0       	ldi	r20, 0x02	; 2
   1172c:	50 e0       	ldi	r21, 0x00	; 0
   1172e:	a4 0e       	add	r10, r20
   11730:	b5 1e       	adc	r11, r21
   11732:	c6 01       	movw	r24, r12
   11734:	0e 94 ec 8f 	call	0x11fd8	; 0x11fd8 <strnlen_P>
   11738:	8c 01       	movw	r16, r24
   1173a:	50 e8       	ldi	r21, 0x80	; 128
   1173c:	f5 2a       	or	r15, r21
   1173e:	f3 fe       	sbrs	r15, 3
   11740:	07 c0       	rjmp	.+14     	; 0x11750 <vfprintf+0x1c8>
   11742:	1a c0       	rjmp	.+52     	; 0x11778 <vfprintf+0x1f0>
   11744:	80 e2       	ldi	r24, 0x20	; 32
   11746:	90 e0       	ldi	r25, 0x00	; 0
   11748:	b3 01       	movw	r22, r6
   1174a:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   1174e:	ea 94       	dec	r14
   11750:	8e 2d       	mov	r24, r14
   11752:	90 e0       	ldi	r25, 0x00	; 0
   11754:	08 17       	cp	r16, r24
   11756:	19 07       	cpc	r17, r25
   11758:	a8 f3       	brcs	.-22     	; 0x11744 <vfprintf+0x1bc>
   1175a:	0e c0       	rjmp	.+28     	; 0x11778 <vfprintf+0x1f0>
   1175c:	f6 01       	movw	r30, r12
   1175e:	f7 fc       	sbrc	r15, 7
   11760:	85 91       	lpm	r24, Z+
   11762:	f7 fe       	sbrs	r15, 7
   11764:	81 91       	ld	r24, Z+
   11766:	6f 01       	movw	r12, r30
   11768:	90 e0       	ldi	r25, 0x00	; 0
   1176a:	b3 01       	movw	r22, r6
   1176c:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   11770:	e1 10       	cpse	r14, r1
   11772:	ea 94       	dec	r14
   11774:	01 50       	subi	r16, 0x01	; 1
   11776:	10 40       	sbci	r17, 0x00	; 0
   11778:	01 15       	cp	r16, r1
   1177a:	11 05       	cpc	r17, r1
   1177c:	79 f7       	brne	.-34     	; 0x1175c <vfprintf+0x1d4>
   1177e:	ea c0       	rjmp	.+468    	; 0x11954 <vfprintf+0x3cc>
   11780:	94 36       	cpi	r25, 0x64	; 100
   11782:	11 f0       	breq	.+4      	; 0x11788 <vfprintf+0x200>
   11784:	99 36       	cpi	r25, 0x69	; 105
   11786:	69 f5       	brne	.+90     	; 0x117e2 <vfprintf+0x25a>
   11788:	f7 fe       	sbrs	r15, 7
   1178a:	08 c0       	rjmp	.+16     	; 0x1179c <vfprintf+0x214>
   1178c:	f5 01       	movw	r30, r10
   1178e:	20 81       	ld	r18, Z
   11790:	31 81       	ldd	r19, Z+1	; 0x01
   11792:	42 81       	ldd	r20, Z+2	; 0x02
   11794:	53 81       	ldd	r21, Z+3	; 0x03
   11796:	84 e0       	ldi	r24, 0x04	; 4
   11798:	90 e0       	ldi	r25, 0x00	; 0
   1179a:	0a c0       	rjmp	.+20     	; 0x117b0 <vfprintf+0x228>
   1179c:	f5 01       	movw	r30, r10
   1179e:	80 81       	ld	r24, Z
   117a0:	91 81       	ldd	r25, Z+1	; 0x01
   117a2:	9c 01       	movw	r18, r24
   117a4:	44 27       	eor	r20, r20
   117a6:	37 fd       	sbrc	r19, 7
   117a8:	40 95       	com	r20
   117aa:	54 2f       	mov	r21, r20
   117ac:	82 e0       	ldi	r24, 0x02	; 2
   117ae:	90 e0       	ldi	r25, 0x00	; 0
   117b0:	a8 0e       	add	r10, r24
   117b2:	b9 1e       	adc	r11, r25
   117b4:	9f e6       	ldi	r25, 0x6F	; 111
   117b6:	f9 22       	and	r15, r25
   117b8:	57 ff       	sbrs	r21, 7
   117ba:	09 c0       	rjmp	.+18     	; 0x117ce <vfprintf+0x246>
   117bc:	50 95       	com	r21
   117be:	40 95       	com	r20
   117c0:	30 95       	com	r19
   117c2:	21 95       	neg	r18
   117c4:	3f 4f       	sbci	r19, 0xFF	; 255
   117c6:	4f 4f       	sbci	r20, 0xFF	; 255
   117c8:	5f 4f       	sbci	r21, 0xFF	; 255
   117ca:	e0 e8       	ldi	r30, 0x80	; 128
   117cc:	fe 2a       	or	r15, r30
   117ce:	ca 01       	movw	r24, r20
   117d0:	b9 01       	movw	r22, r18
   117d2:	a1 01       	movw	r20, r2
   117d4:	2a e0       	ldi	r18, 0x0A	; 10
   117d6:	30 e0       	ldi	r19, 0x00	; 0
   117d8:	0e 94 8a 90 	call	0x12114	; 0x12114 <__ultoa_invert>
   117dc:	d8 2e       	mov	r13, r24
   117de:	d2 18       	sub	r13, r2
   117e0:	40 c0       	rjmp	.+128    	; 0x11862 <vfprintf+0x2da>
   117e2:	95 37       	cpi	r25, 0x75	; 117
   117e4:	29 f4       	brne	.+10     	; 0x117f0 <vfprintf+0x268>
   117e6:	1f 2d       	mov	r17, r15
   117e8:	1f 7e       	andi	r17, 0xEF	; 239
   117ea:	2a e0       	ldi	r18, 0x0A	; 10
   117ec:	30 e0       	ldi	r19, 0x00	; 0
   117ee:	1d c0       	rjmp	.+58     	; 0x1182a <vfprintf+0x2a2>
   117f0:	1f 2d       	mov	r17, r15
   117f2:	19 7f       	andi	r17, 0xF9	; 249
   117f4:	9f 36       	cpi	r25, 0x6F	; 111
   117f6:	61 f0       	breq	.+24     	; 0x11810 <vfprintf+0x288>
   117f8:	90 37       	cpi	r25, 0x70	; 112
   117fa:	20 f4       	brcc	.+8      	; 0x11804 <vfprintf+0x27c>
   117fc:	98 35       	cpi	r25, 0x58	; 88
   117fe:	09 f0       	breq	.+2      	; 0x11802 <vfprintf+0x27a>
   11800:	ac c0       	rjmp	.+344    	; 0x1195a <vfprintf+0x3d2>
   11802:	0f c0       	rjmp	.+30     	; 0x11822 <vfprintf+0x29a>
   11804:	90 37       	cpi	r25, 0x70	; 112
   11806:	39 f0       	breq	.+14     	; 0x11816 <vfprintf+0x28e>
   11808:	98 37       	cpi	r25, 0x78	; 120
   1180a:	09 f0       	breq	.+2      	; 0x1180e <vfprintf+0x286>
   1180c:	a6 c0       	rjmp	.+332    	; 0x1195a <vfprintf+0x3d2>
   1180e:	04 c0       	rjmp	.+8      	; 0x11818 <vfprintf+0x290>
   11810:	28 e0       	ldi	r18, 0x08	; 8
   11812:	30 e0       	ldi	r19, 0x00	; 0
   11814:	0a c0       	rjmp	.+20     	; 0x1182a <vfprintf+0x2a2>
   11816:	10 61       	ori	r17, 0x10	; 16
   11818:	14 fd       	sbrc	r17, 4
   1181a:	14 60       	ori	r17, 0x04	; 4
   1181c:	20 e1       	ldi	r18, 0x10	; 16
   1181e:	30 e0       	ldi	r19, 0x00	; 0
   11820:	04 c0       	rjmp	.+8      	; 0x1182a <vfprintf+0x2a2>
   11822:	14 fd       	sbrc	r17, 4
   11824:	16 60       	ori	r17, 0x06	; 6
   11826:	20 e1       	ldi	r18, 0x10	; 16
   11828:	32 e0       	ldi	r19, 0x02	; 2
   1182a:	17 ff       	sbrs	r17, 7
   1182c:	08 c0       	rjmp	.+16     	; 0x1183e <vfprintf+0x2b6>
   1182e:	f5 01       	movw	r30, r10
   11830:	60 81       	ld	r22, Z
   11832:	71 81       	ldd	r23, Z+1	; 0x01
   11834:	82 81       	ldd	r24, Z+2	; 0x02
   11836:	93 81       	ldd	r25, Z+3	; 0x03
   11838:	44 e0       	ldi	r20, 0x04	; 4
   1183a:	50 e0       	ldi	r21, 0x00	; 0
   1183c:	08 c0       	rjmp	.+16     	; 0x1184e <vfprintf+0x2c6>
   1183e:	f5 01       	movw	r30, r10
   11840:	80 81       	ld	r24, Z
   11842:	91 81       	ldd	r25, Z+1	; 0x01
   11844:	bc 01       	movw	r22, r24
   11846:	80 e0       	ldi	r24, 0x00	; 0
   11848:	90 e0       	ldi	r25, 0x00	; 0
   1184a:	42 e0       	ldi	r20, 0x02	; 2
   1184c:	50 e0       	ldi	r21, 0x00	; 0
   1184e:	a4 0e       	add	r10, r20
   11850:	b5 1e       	adc	r11, r21
   11852:	a1 01       	movw	r20, r2
   11854:	0e 94 8a 90 	call	0x12114	; 0x12114 <__ultoa_invert>
   11858:	d8 2e       	mov	r13, r24
   1185a:	d2 18       	sub	r13, r2
   1185c:	8f e7       	ldi	r24, 0x7F	; 127
   1185e:	f8 2e       	mov	r15, r24
   11860:	f1 22       	and	r15, r17
   11862:	f6 fe       	sbrs	r15, 6
   11864:	0b c0       	rjmp	.+22     	; 0x1187c <vfprintf+0x2f4>
   11866:	5e ef       	ldi	r21, 0xFE	; 254
   11868:	f5 22       	and	r15, r21
   1186a:	d9 14       	cp	r13, r9
   1186c:	38 f4       	brcc	.+14     	; 0x1187c <vfprintf+0x2f4>
   1186e:	f4 fe       	sbrs	r15, 4
   11870:	07 c0       	rjmp	.+14     	; 0x11880 <vfprintf+0x2f8>
   11872:	f2 fc       	sbrc	r15, 2
   11874:	05 c0       	rjmp	.+10     	; 0x11880 <vfprintf+0x2f8>
   11876:	8f ee       	ldi	r24, 0xEF	; 239
   11878:	f8 22       	and	r15, r24
   1187a:	02 c0       	rjmp	.+4      	; 0x11880 <vfprintf+0x2f8>
   1187c:	1d 2d       	mov	r17, r13
   1187e:	01 c0       	rjmp	.+2      	; 0x11882 <vfprintf+0x2fa>
   11880:	19 2d       	mov	r17, r9
   11882:	f4 fe       	sbrs	r15, 4
   11884:	0d c0       	rjmp	.+26     	; 0x118a0 <vfprintf+0x318>
   11886:	fe 01       	movw	r30, r28
   11888:	ed 0d       	add	r30, r13
   1188a:	f1 1d       	adc	r31, r1
   1188c:	80 81       	ld	r24, Z
   1188e:	80 33       	cpi	r24, 0x30	; 48
   11890:	19 f4       	brne	.+6      	; 0x11898 <vfprintf+0x310>
   11892:	99 ee       	ldi	r25, 0xE9	; 233
   11894:	f9 22       	and	r15, r25
   11896:	08 c0       	rjmp	.+16     	; 0x118a8 <vfprintf+0x320>
   11898:	1f 5f       	subi	r17, 0xFF	; 255
   1189a:	f2 fe       	sbrs	r15, 2
   1189c:	05 c0       	rjmp	.+10     	; 0x118a8 <vfprintf+0x320>
   1189e:	03 c0       	rjmp	.+6      	; 0x118a6 <vfprintf+0x31e>
   118a0:	8f 2d       	mov	r24, r15
   118a2:	86 78       	andi	r24, 0x86	; 134
   118a4:	09 f0       	breq	.+2      	; 0x118a8 <vfprintf+0x320>
   118a6:	1f 5f       	subi	r17, 0xFF	; 255
   118a8:	0f 2d       	mov	r16, r15
   118aa:	f3 fc       	sbrc	r15, 3
   118ac:	14 c0       	rjmp	.+40     	; 0x118d6 <vfprintf+0x34e>
   118ae:	f0 fe       	sbrs	r15, 0
   118b0:	0f c0       	rjmp	.+30     	; 0x118d0 <vfprintf+0x348>
   118b2:	1e 15       	cp	r17, r14
   118b4:	10 f0       	brcs	.+4      	; 0x118ba <vfprintf+0x332>
   118b6:	9d 2c       	mov	r9, r13
   118b8:	0b c0       	rjmp	.+22     	; 0x118d0 <vfprintf+0x348>
   118ba:	9d 2c       	mov	r9, r13
   118bc:	9e 0c       	add	r9, r14
   118be:	91 1a       	sub	r9, r17
   118c0:	1e 2d       	mov	r17, r14
   118c2:	06 c0       	rjmp	.+12     	; 0x118d0 <vfprintf+0x348>
   118c4:	80 e2       	ldi	r24, 0x20	; 32
   118c6:	90 e0       	ldi	r25, 0x00	; 0
   118c8:	b3 01       	movw	r22, r6
   118ca:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   118ce:	1f 5f       	subi	r17, 0xFF	; 255
   118d0:	1e 15       	cp	r17, r14
   118d2:	c0 f3       	brcs	.-16     	; 0x118c4 <vfprintf+0x33c>
   118d4:	04 c0       	rjmp	.+8      	; 0x118de <vfprintf+0x356>
   118d6:	1e 15       	cp	r17, r14
   118d8:	10 f4       	brcc	.+4      	; 0x118de <vfprintf+0x356>
   118da:	e1 1a       	sub	r14, r17
   118dc:	01 c0       	rjmp	.+2      	; 0x118e0 <vfprintf+0x358>
   118de:	ee 24       	eor	r14, r14
   118e0:	04 ff       	sbrs	r16, 4
   118e2:	0f c0       	rjmp	.+30     	; 0x11902 <vfprintf+0x37a>
   118e4:	80 e3       	ldi	r24, 0x30	; 48
   118e6:	90 e0       	ldi	r25, 0x00	; 0
   118e8:	b3 01       	movw	r22, r6
   118ea:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   118ee:	02 ff       	sbrs	r16, 2
   118f0:	1d c0       	rjmp	.+58     	; 0x1192c <vfprintf+0x3a4>
   118f2:	01 fd       	sbrc	r16, 1
   118f4:	03 c0       	rjmp	.+6      	; 0x118fc <vfprintf+0x374>
   118f6:	88 e7       	ldi	r24, 0x78	; 120
   118f8:	90 e0       	ldi	r25, 0x00	; 0
   118fa:	0e c0       	rjmp	.+28     	; 0x11918 <vfprintf+0x390>
   118fc:	88 e5       	ldi	r24, 0x58	; 88
   118fe:	90 e0       	ldi	r25, 0x00	; 0
   11900:	0b c0       	rjmp	.+22     	; 0x11918 <vfprintf+0x390>
   11902:	80 2f       	mov	r24, r16
   11904:	86 78       	andi	r24, 0x86	; 134
   11906:	91 f0       	breq	.+36     	; 0x1192c <vfprintf+0x3a4>
   11908:	01 ff       	sbrs	r16, 1
   1190a:	02 c0       	rjmp	.+4      	; 0x11910 <vfprintf+0x388>
   1190c:	8b e2       	ldi	r24, 0x2B	; 43
   1190e:	01 c0       	rjmp	.+2      	; 0x11912 <vfprintf+0x38a>
   11910:	80 e2       	ldi	r24, 0x20	; 32
   11912:	f7 fc       	sbrc	r15, 7
   11914:	8d e2       	ldi	r24, 0x2D	; 45
   11916:	90 e0       	ldi	r25, 0x00	; 0
   11918:	b3 01       	movw	r22, r6
   1191a:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   1191e:	06 c0       	rjmp	.+12     	; 0x1192c <vfprintf+0x3a4>
   11920:	80 e3       	ldi	r24, 0x30	; 48
   11922:	90 e0       	ldi	r25, 0x00	; 0
   11924:	b3 01       	movw	r22, r6
   11926:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   1192a:	9a 94       	dec	r9
   1192c:	d9 14       	cp	r13, r9
   1192e:	c0 f3       	brcs	.-16     	; 0x11920 <vfprintf+0x398>
   11930:	da 94       	dec	r13
   11932:	f1 01       	movw	r30, r2
   11934:	ed 0d       	add	r30, r13
   11936:	f1 1d       	adc	r31, r1
   11938:	80 81       	ld	r24, Z
   1193a:	90 e0       	ldi	r25, 0x00	; 0
   1193c:	b3 01       	movw	r22, r6
   1193e:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   11942:	dd 20       	and	r13, r13
   11944:	a9 f7       	brne	.-22     	; 0x11930 <vfprintf+0x3a8>
   11946:	06 c0       	rjmp	.+12     	; 0x11954 <vfprintf+0x3cc>
   11948:	80 e2       	ldi	r24, 0x20	; 32
   1194a:	90 e0       	ldi	r25, 0x00	; 0
   1194c:	b3 01       	movw	r22, r6
   1194e:	0e 94 44 90 	call	0x12088	; 0x12088 <fputc>
   11952:	ea 94       	dec	r14
   11954:	ee 20       	and	r14, r14
   11956:	c1 f7       	brne	.-16     	; 0x11948 <vfprintf+0x3c0>
   11958:	43 ce       	rjmp	.-890    	; 0x115e0 <vfprintf+0x58>
   1195a:	f3 01       	movw	r30, r6
   1195c:	66 81       	ldd	r22, Z+6	; 0x06
   1195e:	77 81       	ldd	r23, Z+7	; 0x07
   11960:	cb 01       	movw	r24, r22
   11962:	2b 96       	adiw	r28, 0x0b	; 11
   11964:	0f b6       	in	r0, 0x3f	; 63
   11966:	f8 94       	cli
   11968:	de bf       	out	0x3e, r29	; 62
   1196a:	0f be       	out	0x3f, r0	; 63
   1196c:	cd bf       	out	0x3d, r28	; 61
   1196e:	cf 91       	pop	r28
   11970:	df 91       	pop	r29
   11972:	1f 91       	pop	r17
   11974:	0f 91       	pop	r16
   11976:	ff 90       	pop	r15
   11978:	ef 90       	pop	r14
   1197a:	df 90       	pop	r13
   1197c:	cf 90       	pop	r12
   1197e:	bf 90       	pop	r11
   11980:	af 90       	pop	r10
   11982:	9f 90       	pop	r9
   11984:	8f 90       	pop	r8
   11986:	7f 90       	pop	r7
   11988:	6f 90       	pop	r6
   1198a:	5f 90       	pop	r5
   1198c:	4f 90       	pop	r4
   1198e:	3f 90       	pop	r3
   11990:	2f 90       	pop	r2
   11992:	08 95       	ret

00011994 <putval>:
   11994:	fc 01       	movw	r30, r24
   11996:	20 fd       	sbrc	r18, 0
   11998:	08 c0       	rjmp	.+16     	; 0x119aa <putval+0x16>
   1199a:	23 fd       	sbrc	r18, 3
   1199c:	05 c0       	rjmp	.+10     	; 0x119a8 <putval+0x14>
   1199e:	22 ff       	sbrs	r18, 2
   119a0:	02 c0       	rjmp	.+4      	; 0x119a6 <putval+0x12>
   119a2:	73 83       	std	Z+3, r23	; 0x03
   119a4:	62 83       	std	Z+2, r22	; 0x02
   119a6:	51 83       	std	Z+1, r21	; 0x01
   119a8:	40 83       	st	Z, r20
   119aa:	08 95       	ret

000119ac <mulacc>:
   119ac:	ef 92       	push	r14
   119ae:	ff 92       	push	r15
   119b0:	0f 93       	push	r16
   119b2:	1f 93       	push	r17
   119b4:	44 ff       	sbrs	r20, 4
   119b6:	02 c0       	rjmp	.+4      	; 0x119bc <mulacc+0x10>
   119b8:	33 e0       	ldi	r19, 0x03	; 3
   119ba:	11 c0       	rjmp	.+34     	; 0x119de <mulacc+0x32>
   119bc:	46 ff       	sbrs	r20, 6
   119be:	02 c0       	rjmp	.+4      	; 0x119c4 <mulacc+0x18>
   119c0:	34 e0       	ldi	r19, 0x04	; 4
   119c2:	0d c0       	rjmp	.+26     	; 0x119de <mulacc+0x32>
   119c4:	db 01       	movw	r26, r22
   119c6:	fc 01       	movw	r30, r24
   119c8:	aa 0f       	add	r26, r26
   119ca:	bb 1f       	adc	r27, r27
   119cc:	ee 1f       	adc	r30, r30
   119ce:	ff 1f       	adc	r31, r31
   119d0:	10 94       	com	r1
   119d2:	d1 f7       	brne	.-12     	; 0x119c8 <mulacc+0x1c>
   119d4:	6a 0f       	add	r22, r26
   119d6:	7b 1f       	adc	r23, r27
   119d8:	8e 1f       	adc	r24, r30
   119da:	9f 1f       	adc	r25, r31
   119dc:	31 e0       	ldi	r19, 0x01	; 1
   119de:	66 0f       	add	r22, r22
   119e0:	77 1f       	adc	r23, r23
   119e2:	88 1f       	adc	r24, r24
   119e4:	99 1f       	adc	r25, r25
   119e6:	31 50       	subi	r19, 0x01	; 1
   119e8:	d1 f7       	brne	.-12     	; 0x119de <mulacc+0x32>
   119ea:	7b 01       	movw	r14, r22
   119ec:	8c 01       	movw	r16, r24
   119ee:	e2 0e       	add	r14, r18
   119f0:	f1 1c       	adc	r15, r1
   119f2:	01 1d       	adc	r16, r1
   119f4:	11 1d       	adc	r17, r1
   119f6:	a8 01       	movw	r20, r16
   119f8:	97 01       	movw	r18, r14
   119fa:	b7 01       	movw	r22, r14
   119fc:	ca 01       	movw	r24, r20
   119fe:	1f 91       	pop	r17
   11a00:	0f 91       	pop	r16
   11a02:	ff 90       	pop	r15
   11a04:	ef 90       	pop	r14
   11a06:	08 95       	ret

00011a08 <skip_spaces>:
   11a08:	0f 93       	push	r16
   11a0a:	1f 93       	push	r17
   11a0c:	cf 93       	push	r28
   11a0e:	df 93       	push	r29
   11a10:	8c 01       	movw	r16, r24
   11a12:	c8 01       	movw	r24, r16
   11a14:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11a18:	ec 01       	movw	r28, r24
   11a1a:	97 fd       	sbrc	r25, 7
   11a1c:	08 c0       	rjmp	.+16     	; 0x11a2e <skip_spaces+0x26>
   11a1e:	0e 94 e4 8f 	call	0x11fc8	; 0x11fc8 <isspace>
   11a22:	89 2b       	or	r24, r25
   11a24:	b1 f7       	brne	.-20     	; 0x11a12 <skip_spaces+0xa>
   11a26:	ce 01       	movw	r24, r28
   11a28:	b8 01       	movw	r22, r16
   11a2a:	0e 94 70 90 	call	0x120e0	; 0x120e0 <ungetc>
   11a2e:	ce 01       	movw	r24, r28
   11a30:	df 91       	pop	r29
   11a32:	cf 91       	pop	r28
   11a34:	1f 91       	pop	r17
   11a36:	0f 91       	pop	r16
   11a38:	08 95       	ret

00011a3a <conv_int>:
   11a3a:	af 92       	push	r10
   11a3c:	bf 92       	push	r11
   11a3e:	cf 92       	push	r12
   11a40:	df 92       	push	r13
   11a42:	ef 92       	push	r14
   11a44:	ff 92       	push	r15
   11a46:	0f 93       	push	r16
   11a48:	1f 93       	push	r17
   11a4a:	cf 93       	push	r28
   11a4c:	df 93       	push	r29
   11a4e:	ec 01       	movw	r28, r24
   11a50:	c6 2e       	mov	r12, r22
   11a52:	5a 01       	movw	r10, r20
   11a54:	12 2f       	mov	r17, r18
   11a56:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11a5a:	ac 01       	movw	r20, r24
   11a5c:	8b 32       	cpi	r24, 0x2B	; 43
   11a5e:	19 f0       	breq	.+6      	; 0x11a66 <conv_int+0x2c>
   11a60:	8d 32       	cpi	r24, 0x2D	; 45
   11a62:	51 f4       	brne	.+20     	; 0x11a78 <conv_int+0x3e>
   11a64:	10 68       	ori	r17, 0x80	; 128
   11a66:	ca 94       	dec	r12
   11a68:	09 f4       	brne	.+2      	; 0x11a6c <conv_int+0x32>
   11a6a:	6d c0       	rjmp	.+218    	; 0x11b46 <conv_int+0x10c>
   11a6c:	ce 01       	movw	r24, r28
   11a6e:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11a72:	ac 01       	movw	r20, r24
   11a74:	97 fd       	sbrc	r25, 7
   11a76:	67 c0       	rjmp	.+206    	; 0x11b46 <conv_int+0x10c>
   11a78:	6d ef       	ldi	r22, 0xFD	; 253
   11a7a:	d6 2e       	mov	r13, r22
   11a7c:	d1 22       	and	r13, r17
   11a7e:	8d 2d       	mov	r24, r13
   11a80:	80 73       	andi	r24, 0x30	; 48
   11a82:	01 f5       	brne	.+64     	; 0x11ac4 <conv_int+0x8a>
   11a84:	40 33       	cpi	r20, 0x30	; 48
   11a86:	f1 f4       	brne	.+60     	; 0x11ac4 <conv_int+0x8a>
   11a88:	ca 94       	dec	r12
   11a8a:	09 f4       	brne	.+2      	; 0x11a8e <conv_int+0x54>
   11a8c:	47 c0       	rjmp	.+142    	; 0x11b1c <conv_int+0xe2>
   11a8e:	ce 01       	movw	r24, r28
   11a90:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11a94:	ac 01       	movw	r20, r24
   11a96:	97 fd       	sbrc	r25, 7
   11a98:	41 c0       	rjmp	.+130    	; 0x11b1c <conv_int+0xe2>
   11a9a:	82 e0       	ldi	r24, 0x02	; 2
   11a9c:	d8 2a       	or	r13, r24
   11a9e:	48 37       	cpi	r20, 0x78	; 120
   11aa0:	11 f0       	breq	.+4      	; 0x11aa6 <conv_int+0x6c>
   11aa2:	48 35       	cpi	r20, 0x58	; 88
   11aa4:	59 f4       	brne	.+22     	; 0x11abc <conv_int+0x82>
   11aa6:	80 e4       	ldi	r24, 0x40	; 64
   11aa8:	d8 2a       	or	r13, r24
   11aaa:	ca 94       	dec	r12
   11aac:	b9 f1       	breq	.+110    	; 0x11b1c <conv_int+0xe2>
   11aae:	ce 01       	movw	r24, r28
   11ab0:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11ab4:	ac 01       	movw	r20, r24
   11ab6:	99 23       	and	r25, r25
   11ab8:	2c f4       	brge	.+10     	; 0x11ac4 <conv_int+0x8a>
   11aba:	30 c0       	rjmp	.+96     	; 0x11b1c <conv_int+0xe2>
   11abc:	d6 fc       	sbrc	r13, 6
   11abe:	02 c0       	rjmp	.+4      	; 0x11ac4 <conv_int+0x8a>
   11ac0:	80 e1       	ldi	r24, 0x10	; 16
   11ac2:	d8 2a       	or	r13, r24
   11ac4:	ee 24       	eor	r14, r14
   11ac6:	ff 24       	eor	r15, r15
   11ac8:	87 01       	movw	r16, r14
   11aca:	24 2f       	mov	r18, r20
   11acc:	20 53       	subi	r18, 0x30	; 48
   11ace:	28 30       	cpi	r18, 0x08	; 8
   11ad0:	88 f0       	brcs	.+34     	; 0x11af4 <conv_int+0xba>
   11ad2:	d4 fc       	sbrc	r13, 4
   11ad4:	09 c0       	rjmp	.+18     	; 0x11ae8 <conv_int+0xae>
   11ad6:	2a 30       	cpi	r18, 0x0A	; 10
   11ad8:	68 f0       	brcs	.+26     	; 0x11af4 <conv_int+0xba>
   11ada:	d6 fe       	sbrs	r13, 6
   11adc:	05 c0       	rjmp	.+10     	; 0x11ae8 <conv_int+0xae>
   11ade:	2f 7d       	andi	r18, 0xDF	; 223
   11ae0:	82 2f       	mov	r24, r18
   11ae2:	81 51       	subi	r24, 0x11	; 17
   11ae4:	86 30       	cpi	r24, 0x06	; 6
   11ae6:	28 f0       	brcs	.+10     	; 0x11af2 <conv_int+0xb8>
   11ae8:	ca 01       	movw	r24, r20
   11aea:	be 01       	movw	r22, r28
   11aec:	0e 94 70 90 	call	0x120e0	; 0x120e0 <ungetc>
   11af0:	12 c0       	rjmp	.+36     	; 0x11b16 <conv_int+0xdc>
   11af2:	27 50       	subi	r18, 0x07	; 7
   11af4:	c8 01       	movw	r24, r16
   11af6:	b7 01       	movw	r22, r14
   11af8:	4d 2d       	mov	r20, r13
   11afa:	0e 94 d6 8c 	call	0x119ac	; 0x119ac <mulacc>
   11afe:	7b 01       	movw	r14, r22
   11b00:	8c 01       	movw	r16, r24
   11b02:	82 e0       	ldi	r24, 0x02	; 2
   11b04:	d8 2a       	or	r13, r24
   11b06:	ca 94       	dec	r12
   11b08:	61 f0       	breq	.+24     	; 0x11b22 <conv_int+0xe8>
   11b0a:	ce 01       	movw	r24, r28
   11b0c:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11b10:	ac 01       	movw	r20, r24
   11b12:	97 ff       	sbrs	r25, 7
   11b14:	da cf       	rjmp	.-76     	; 0x11aca <conv_int+0x90>
   11b16:	d1 fc       	sbrc	r13, 1
   11b18:	04 c0       	rjmp	.+8      	; 0x11b22 <conv_int+0xe8>
   11b1a:	15 c0       	rjmp	.+42     	; 0x11b46 <conv_int+0x10c>
   11b1c:	ee 24       	eor	r14, r14
   11b1e:	ff 24       	eor	r15, r15
   11b20:	87 01       	movw	r16, r14
   11b22:	d7 fe       	sbrs	r13, 7
   11b24:	08 c0       	rjmp	.+16     	; 0x11b36 <conv_int+0xfc>
   11b26:	10 95       	com	r17
   11b28:	00 95       	com	r16
   11b2a:	f0 94       	com	r15
   11b2c:	e0 94       	com	r14
   11b2e:	e1 1c       	adc	r14, r1
   11b30:	f1 1c       	adc	r15, r1
   11b32:	01 1d       	adc	r16, r1
   11b34:	11 1d       	adc	r17, r1
   11b36:	c5 01       	movw	r24, r10
   11b38:	b8 01       	movw	r22, r16
   11b3a:	a7 01       	movw	r20, r14
   11b3c:	2d 2d       	mov	r18, r13
   11b3e:	0e 94 ca 8c 	call	0x11994	; 0x11994 <putval>
   11b42:	81 e0       	ldi	r24, 0x01	; 1
   11b44:	01 c0       	rjmp	.+2      	; 0x11b48 <conv_int+0x10e>
   11b46:	80 e0       	ldi	r24, 0x00	; 0
   11b48:	df 91       	pop	r29
   11b4a:	cf 91       	pop	r28
   11b4c:	1f 91       	pop	r17
   11b4e:	0f 91       	pop	r16
   11b50:	ff 90       	pop	r15
   11b52:	ef 90       	pop	r14
   11b54:	df 90       	pop	r13
   11b56:	cf 90       	pop	r12
   11b58:	bf 90       	pop	r11
   11b5a:	af 90       	pop	r10
   11b5c:	08 95       	ret

00011b5e <conv_brk>:
   11b5e:	6f 92       	push	r6
   11b60:	7f 92       	push	r7
   11b62:	8f 92       	push	r8
   11b64:	9f 92       	push	r9
   11b66:	af 92       	push	r10
   11b68:	bf 92       	push	r11
   11b6a:	cf 92       	push	r12
   11b6c:	df 92       	push	r13
   11b6e:	ef 92       	push	r14
   11b70:	ff 92       	push	r15
   11b72:	0f 93       	push	r16
   11b74:	1f 93       	push	r17
   11b76:	df 93       	push	r29
   11b78:	cf 93       	push	r28
   11b7a:	cd b7       	in	r28, 0x3d	; 61
   11b7c:	de b7       	in	r29, 0x3e	; 62
   11b7e:	a0 97       	sbiw	r28, 0x20	; 32
   11b80:	0f b6       	in	r0, 0x3f	; 63
   11b82:	f8 94       	cli
   11b84:	de bf       	out	0x3e, r29	; 62
   11b86:	0f be       	out	0x3f, r0	; 63
   11b88:	cd bf       	out	0x3d, r28	; 61
   11b8a:	6c 01       	movw	r12, r24
   11b8c:	a6 2e       	mov	r10, r22
   11b8e:	8a 01       	movw	r16, r20
   11b90:	79 01       	movw	r14, r18
   11b92:	fe 01       	movw	r30, r28
   11b94:	31 96       	adiw	r30, 0x01	; 1
   11b96:	80 e2       	ldi	r24, 0x20	; 32
   11b98:	df 01       	movw	r26, r30
   11b9a:	1d 92       	st	X+, r1
   11b9c:	8a 95       	dec	r24
   11b9e:	e9 f7       	brne	.-6      	; 0x11b9a <conv_brk+0x3c>
   11ba0:	70 e0       	ldi	r23, 0x00	; 0
   11ba2:	30 e0       	ldi	r19, 0x00	; 0
   11ba4:	60 e0       	ldi	r22, 0x00	; 0
   11ba6:	40 e0       	ldi	r20, 0x00	; 0
   11ba8:	50 e0       	ldi	r21, 0x00	; 0
   11baa:	4f 01       	movw	r8, r30
   11bac:	a1 e0       	ldi	r26, 0x01	; 1
   11bae:	b0 e0       	ldi	r27, 0x00	; 0
   11bb0:	f6 01       	movw	r30, r12
   11bb2:	83 81       	ldd	r24, Z+3	; 0x03
   11bb4:	f7 01       	movw	r30, r14
   11bb6:	83 fd       	sbrc	r24, 3
   11bb8:	25 91       	lpm	r18, Z+
   11bba:	83 ff       	sbrs	r24, 3
   11bbc:	21 91       	ld	r18, Z+
   11bbe:	7f 01       	movw	r14, r30
   11bc0:	22 23       	and	r18, r18
   11bc2:	09 f4       	brne	.+2      	; 0x11bc6 <conv_brk+0x68>
   11bc4:	7e c0       	rjmp	.+252    	; 0x11cc2 <conv_brk+0x164>
   11bc6:	2e 35       	cpi	r18, 0x5E	; 94
   11bc8:	19 f4       	brne	.+6      	; 0x11bd0 <conv_brk+0x72>
   11bca:	41 15       	cp	r20, r1
   11bcc:	51 05       	cpc	r21, r1
   11bce:	69 f1       	breq	.+90     	; 0x11c2a <conv_brk+0xcc>
   11bd0:	87 2f       	mov	r24, r23
   11bd2:	90 e0       	ldi	r25, 0x00	; 0
   11bd4:	84 17       	cp	r24, r20
   11bd6:	95 07       	cpc	r25, r21
   11bd8:	44 f4       	brge	.+16     	; 0x11bea <conv_brk+0x8c>
   11bda:	2d 35       	cpi	r18, 0x5D	; 93
   11bdc:	51 f1       	breq	.+84     	; 0x11c32 <conv_brk+0xd4>
   11bde:	2d 32       	cpi	r18, 0x2D	; 45
   11be0:	21 f4       	brne	.+8      	; 0x11bea <conv_brk+0x8c>
   11be2:	33 23       	and	r19, r19
   11be4:	29 f4       	brne	.+10     	; 0x11bf0 <conv_brk+0x92>
   11be6:	31 e0       	ldi	r19, 0x01	; 1
   11be8:	21 c0       	rjmp	.+66     	; 0x11c2c <conv_brk+0xce>
   11bea:	33 23       	and	r19, r19
   11bec:	09 f4       	brne	.+2      	; 0x11bf0 <conv_brk+0x92>
   11bee:	62 2f       	mov	r22, r18
   11bf0:	32 2f       	mov	r19, r18
   11bf2:	83 2f       	mov	r24, r19
   11bf4:	86 95       	lsr	r24
   11bf6:	86 95       	lsr	r24
   11bf8:	86 95       	lsr	r24
   11bfa:	f4 01       	movw	r30, r8
   11bfc:	e8 0f       	add	r30, r24
   11bfe:	f1 1d       	adc	r31, r1
   11c00:	83 2f       	mov	r24, r19
   11c02:	87 70       	andi	r24, 0x07	; 7
   11c04:	3d 01       	movw	r6, r26
   11c06:	02 c0       	rjmp	.+4      	; 0x11c0c <conv_brk+0xae>
   11c08:	66 0c       	add	r6, r6
   11c0a:	77 1c       	adc	r7, r7
   11c0c:	8a 95       	dec	r24
   11c0e:	e2 f7       	brpl	.-8      	; 0x11c08 <conv_brk+0xaa>
   11c10:	20 81       	ld	r18, Z
   11c12:	26 29       	or	r18, r6
   11c14:	20 83       	st	Z, r18
   11c16:	36 17       	cp	r19, r22
   11c18:	11 f4       	brne	.+4      	; 0x11c1e <conv_brk+0xc0>
   11c1a:	30 e0       	ldi	r19, 0x00	; 0
   11c1c:	07 c0       	rjmp	.+14     	; 0x11c2c <conv_brk+0xce>
   11c1e:	36 17       	cp	r19, r22
   11c20:	10 f4       	brcc	.+4      	; 0x11c26 <conv_brk+0xc8>
   11c22:	3f 5f       	subi	r19, 0xFF	; 255
   11c24:	e6 cf       	rjmp	.-52     	; 0x11bf2 <conv_brk+0x94>
   11c26:	31 50       	subi	r19, 0x01	; 1
   11c28:	e4 cf       	rjmp	.-56     	; 0x11bf2 <conv_brk+0x94>
   11c2a:	71 e0       	ldi	r23, 0x01	; 1
   11c2c:	4f 5f       	subi	r20, 0xFF	; 255
   11c2e:	5f 4f       	sbci	r21, 0xFF	; 255
   11c30:	bf cf       	rjmp	.-130    	; 0x11bb0 <conv_brk+0x52>
   11c32:	33 23       	and	r19, r19
   11c34:	19 f0       	breq	.+6      	; 0x11c3c <conv_brk+0xde>
   11c36:	8e 81       	ldd	r24, Y+6	; 0x06
   11c38:	80 62       	ori	r24, 0x20	; 32
   11c3a:	8e 83       	std	Y+6, r24	; 0x06
   11c3c:	77 23       	and	r23, r23
   11c3e:	59 f0       	breq	.+22     	; 0x11c56 <conv_brk+0xf8>
   11c40:	fe 01       	movw	r30, r28
   11c42:	31 96       	adiw	r30, 0x01	; 1
   11c44:	9e 01       	movw	r18, r28
   11c46:	2f 5d       	subi	r18, 0xDF	; 223
   11c48:	3f 4f       	sbci	r19, 0xFF	; 255
   11c4a:	80 81       	ld	r24, Z
   11c4c:	80 95       	com	r24
   11c4e:	81 93       	st	Z+, r24
   11c50:	e2 17       	cp	r30, r18
   11c52:	f3 07       	cpc	r31, r19
   11c54:	d1 f7       	brne	.-12     	; 0x11c4a <conv_brk+0xec>
   11c56:	bb 24       	eor	r11, r11
   11c58:	b3 94       	inc	r11
   11c5a:	4e 01       	movw	r8, r28
   11c5c:	08 94       	sec
   11c5e:	81 1c       	adc	r8, r1
   11c60:	91 1c       	adc	r9, r1
   11c62:	c6 01       	movw	r24, r12
   11c64:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11c68:	ac 01       	movw	r20, r24
   11c6a:	97 fd       	sbrc	r25, 7
   11c6c:	22 c0       	rjmp	.+68     	; 0x11cb2 <conv_brk+0x154>
   11c6e:	86 95       	lsr	r24
   11c70:	86 95       	lsr	r24
   11c72:	86 95       	lsr	r24
   11c74:	f4 01       	movw	r30, r8
   11c76:	e8 0f       	add	r30, r24
   11c78:	f1 1d       	adc	r31, r1
   11c7a:	80 81       	ld	r24, Z
   11c7c:	90 e0       	ldi	r25, 0x00	; 0
   11c7e:	9a 01       	movw	r18, r20
   11c80:	27 70       	andi	r18, 0x07	; 7
   11c82:	30 70       	andi	r19, 0x00	; 0
   11c84:	02 c0       	rjmp	.+4      	; 0x11c8a <conv_brk+0x12c>
   11c86:	95 95       	asr	r25
   11c88:	87 95       	ror	r24
   11c8a:	2a 95       	dec	r18
   11c8c:	e2 f7       	brpl	.-8      	; 0x11c86 <conv_brk+0x128>
   11c8e:	80 fd       	sbrc	r24, 0
   11c90:	05 c0       	rjmp	.+10     	; 0x11c9c <conv_brk+0x13e>
   11c92:	ca 01       	movw	r24, r20
   11c94:	b6 01       	movw	r22, r12
   11c96:	0e 94 70 90 	call	0x120e0	; 0x120e0 <ungetc>
   11c9a:	0b c0       	rjmp	.+22     	; 0x11cb2 <conv_brk+0x154>
   11c9c:	01 15       	cp	r16, r1
   11c9e:	11 05       	cpc	r17, r1
   11ca0:	19 f0       	breq	.+6      	; 0x11ca8 <conv_brk+0x14a>
   11ca2:	d8 01       	movw	r26, r16
   11ca4:	4d 93       	st	X+, r20
   11ca6:	8d 01       	movw	r16, r26
   11ca8:	aa 94       	dec	r10
   11caa:	bb 24       	eor	r11, r11
   11cac:	aa 20       	and	r10, r10
   11cae:	c9 f6       	brne	.-78     	; 0x11c62 <conv_brk+0x104>
   11cb0:	02 c0       	rjmp	.+4      	; 0x11cb6 <conv_brk+0x158>
   11cb2:	bb 20       	and	r11, r11
   11cb4:	31 f4       	brne	.+12     	; 0x11cc2 <conv_brk+0x164>
   11cb6:	01 15       	cp	r16, r1
   11cb8:	11 05       	cpc	r17, r1
   11cba:	29 f0       	breq	.+10     	; 0x11cc6 <conv_brk+0x168>
   11cbc:	f8 01       	movw	r30, r16
   11cbe:	10 82       	st	Z, r1
   11cc0:	02 c0       	rjmp	.+4      	; 0x11cc6 <conv_brk+0x168>
   11cc2:	ee 24       	eor	r14, r14
   11cc4:	ff 24       	eor	r15, r15
   11cc6:	c7 01       	movw	r24, r14
   11cc8:	a0 96       	adiw	r28, 0x20	; 32
   11cca:	0f b6       	in	r0, 0x3f	; 63
   11ccc:	f8 94       	cli
   11cce:	de bf       	out	0x3e, r29	; 62
   11cd0:	0f be       	out	0x3f, r0	; 63
   11cd2:	cd bf       	out	0x3d, r28	; 61
   11cd4:	cf 91       	pop	r28
   11cd6:	df 91       	pop	r29
   11cd8:	1f 91       	pop	r17
   11cda:	0f 91       	pop	r16
   11cdc:	ff 90       	pop	r15
   11cde:	ef 90       	pop	r14
   11ce0:	df 90       	pop	r13
   11ce2:	cf 90       	pop	r12
   11ce4:	bf 90       	pop	r11
   11ce6:	af 90       	pop	r10
   11ce8:	9f 90       	pop	r9
   11cea:	8f 90       	pop	r8
   11cec:	7f 90       	pop	r7
   11cee:	6f 90       	pop	r6
   11cf0:	08 95       	ret

00011cf2 <vfscanf>:
   11cf2:	6f 92       	push	r6
   11cf4:	7f 92       	push	r7
   11cf6:	8f 92       	push	r8
   11cf8:	9f 92       	push	r9
   11cfa:	af 92       	push	r10
   11cfc:	bf 92       	push	r11
   11cfe:	cf 92       	push	r12
   11d00:	df 92       	push	r13
   11d02:	ef 92       	push	r14
   11d04:	ff 92       	push	r15
   11d06:	0f 93       	push	r16
   11d08:	1f 93       	push	r17
   11d0a:	cf 93       	push	r28
   11d0c:	df 93       	push	r29
   11d0e:	5c 01       	movw	r10, r24
   11d10:	6b 01       	movw	r12, r22
   11d12:	3a 01       	movw	r6, r20
   11d14:	fc 01       	movw	r30, r24
   11d16:	17 82       	std	Z+7, r1	; 0x07
   11d18:	16 82       	std	Z+6, r1	; 0x06
   11d1a:	88 24       	eor	r8, r8
   11d1c:	ea c0       	rjmp	.+468    	; 0x11ef2 <vfscanf+0x200>
   11d1e:	81 2f       	mov	r24, r17
   11d20:	90 e0       	ldi	r25, 0x00	; 0
   11d22:	0e 94 e4 8f 	call	0x11fc8	; 0x11fc8 <isspace>
   11d26:	89 2b       	or	r24, r25
   11d28:	21 f0       	breq	.+8      	; 0x11d32 <vfscanf+0x40>
   11d2a:	c5 01       	movw	r24, r10
   11d2c:	0e 94 04 8d 	call	0x11a08	; 0x11a08 <skip_spaces>
   11d30:	e0 c0       	rjmp	.+448    	; 0x11ef2 <vfscanf+0x200>
   11d32:	15 32       	cpi	r17, 0x25	; 37
   11d34:	49 f4       	brne	.+18     	; 0x11d48 <vfscanf+0x56>
   11d36:	f6 01       	movw	r30, r12
   11d38:	f3 fc       	sbrc	r15, 3
   11d3a:	65 91       	lpm	r22, Z+
   11d3c:	f3 fe       	sbrs	r15, 3
   11d3e:	61 91       	ld	r22, Z+
   11d40:	6f 01       	movw	r12, r30
   11d42:	65 32       	cpi	r22, 0x25	; 37
   11d44:	69 f4       	brne	.+26     	; 0x11d60 <vfscanf+0x6e>
   11d46:	15 e2       	ldi	r17, 0x25	; 37
   11d48:	c5 01       	movw	r24, r10
   11d4a:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11d4e:	97 fd       	sbrc	r25, 7
   11d50:	dc c0       	rjmp	.+440    	; 0x11f0a <vfscanf+0x218>
   11d52:	18 17       	cp	r17, r24
   11d54:	09 f4       	brne	.+2      	; 0x11d58 <vfscanf+0x66>
   11d56:	cd c0       	rjmp	.+410    	; 0x11ef2 <vfscanf+0x200>
   11d58:	b5 01       	movw	r22, r10
   11d5a:	0e 94 70 90 	call	0x120e0	; 0x120e0 <ungetc>
   11d5e:	da c0       	rjmp	.+436    	; 0x11f14 <vfscanf+0x222>
   11d60:	6a 32       	cpi	r22, 0x2A	; 42
   11d62:	19 f0       	breq	.+6      	; 0x11d6a <vfscanf+0x78>
   11d64:	16 2f       	mov	r17, r22
   11d66:	00 e0       	ldi	r16, 0x00	; 0
   11d68:	06 c0       	rjmp	.+12     	; 0x11d76 <vfscanf+0x84>
   11d6a:	f3 fc       	sbrc	r15, 3
   11d6c:	15 91       	lpm	r17, Z+
   11d6e:	f3 fe       	sbrs	r15, 3
   11d70:	11 91       	ld	r17, Z+
   11d72:	6f 01       	movw	r12, r30
   11d74:	01 e0       	ldi	r16, 0x01	; 1
   11d76:	99 24       	eor	r9, r9
   11d78:	0f c0       	rjmp	.+30     	; 0x11d98 <vfscanf+0xa6>
   11d7a:	02 60       	ori	r16, 0x02	; 2
   11d7c:	69 2d       	mov	r22, r9
   11d7e:	70 e0       	ldi	r23, 0x00	; 0
   11d80:	80 e0       	ldi	r24, 0x00	; 0
   11d82:	90 e0       	ldi	r25, 0x00	; 0
   11d84:	40 e2       	ldi	r20, 0x20	; 32
   11d86:	0e 94 d6 8c 	call	0x119ac	; 0x119ac <mulacc>
   11d8a:	96 2e       	mov	r9, r22
   11d8c:	f6 01       	movw	r30, r12
   11d8e:	f3 fc       	sbrc	r15, 3
   11d90:	15 91       	lpm	r17, Z+
   11d92:	f3 fe       	sbrs	r15, 3
   11d94:	11 91       	ld	r17, Z+
   11d96:	6f 01       	movw	r12, r30
   11d98:	21 2f       	mov	r18, r17
   11d9a:	20 53       	subi	r18, 0x30	; 48
   11d9c:	2a 30       	cpi	r18, 0x0A	; 10
   11d9e:	68 f3       	brcs	.-38     	; 0x11d7a <vfscanf+0x88>
   11da0:	01 fd       	sbrc	r16, 1
   11da2:	03 c0       	rjmp	.+6      	; 0x11daa <vfscanf+0xb8>
   11da4:	99 24       	eor	r9, r9
   11da6:	9a 94       	dec	r9
   11da8:	03 c0       	rjmp	.+6      	; 0x11db0 <vfscanf+0xbe>
   11daa:	99 20       	and	r9, r9
   11dac:	09 f4       	brne	.+2      	; 0x11db0 <vfscanf+0xbe>
   11dae:	b2 c0       	rjmp	.+356    	; 0x11f14 <vfscanf+0x222>
   11db0:	18 36       	cpi	r17, 0x68	; 104
   11db2:	21 f0       	breq	.+8      	; 0x11dbc <vfscanf+0xca>
   11db4:	1c 36       	cpi	r17, 0x6C	; 108
   11db6:	99 f4       	brne	.+38     	; 0x11dde <vfscanf+0xec>
   11db8:	f6 01       	movw	r30, r12
   11dba:	0b c0       	rjmp	.+22     	; 0x11dd2 <vfscanf+0xe0>
   11dbc:	f6 01       	movw	r30, r12
   11dbe:	f3 fc       	sbrc	r15, 3
   11dc0:	65 91       	lpm	r22, Z+
   11dc2:	f3 fe       	sbrs	r15, 3
   11dc4:	61 91       	ld	r22, Z+
   11dc6:	68 36       	cpi	r22, 0x68	; 104
   11dc8:	19 f0       	breq	.+6      	; 0x11dd0 <vfscanf+0xde>
   11dca:	6f 01       	movw	r12, r30
   11dcc:	16 2f       	mov	r17, r22
   11dce:	07 c0       	rjmp	.+14     	; 0x11dde <vfscanf+0xec>
   11dd0:	08 60       	ori	r16, 0x08	; 8
   11dd2:	04 60       	ori	r16, 0x04	; 4
   11dd4:	f3 fc       	sbrc	r15, 3
   11dd6:	15 91       	lpm	r17, Z+
   11dd8:	f3 fe       	sbrs	r15, 3
   11dda:	11 91       	ld	r17, Z+
   11ddc:	6f 01       	movw	r12, r30
   11dde:	11 23       	and	r17, r17
   11de0:	09 f4       	brne	.+2      	; 0x11de4 <vfscanf+0xf2>
   11de2:	98 c0       	rjmp	.+304    	; 0x11f14 <vfscanf+0x222>
   11de4:	8d ee       	ldi	r24, 0xED	; 237
   11de6:	9b e4       	ldi	r25, 0x4B	; 75
   11de8:	61 2f       	mov	r22, r17
   11dea:	70 e0       	ldi	r23, 0x00	; 0
   11dec:	0e 94 9b 87 	call	0x10f36	; 0x10f36 <strchr_P>
   11df0:	89 2b       	or	r24, r25
   11df2:	09 f4       	brne	.+2      	; 0x11df6 <vfscanf+0x104>
   11df4:	8f c0       	rjmp	.+286    	; 0x11f14 <vfscanf+0x222>
   11df6:	80 2f       	mov	r24, r16
   11df8:	00 ff       	sbrs	r16, 0
   11dfa:	03 c0       	rjmp	.+6      	; 0x11e02 <vfscanf+0x110>
   11dfc:	ee 24       	eor	r14, r14
   11dfe:	ff 24       	eor	r15, r15
   11e00:	07 c0       	rjmp	.+14     	; 0x11e10 <vfscanf+0x11e>
   11e02:	f3 01       	movw	r30, r6
   11e04:	e0 80       	ld	r14, Z
   11e06:	f1 80       	ldd	r15, Z+1	; 0x01
   11e08:	22 e0       	ldi	r18, 0x02	; 2
   11e0a:	30 e0       	ldi	r19, 0x00	; 0
   11e0c:	62 0e       	add	r6, r18
   11e0e:	73 1e       	adc	r7, r19
   11e10:	1e 36       	cpi	r17, 0x6E	; 110
   11e12:	51 f4       	brne	.+20     	; 0x11e28 <vfscanf+0x136>
   11e14:	f5 01       	movw	r30, r10
   11e16:	46 81       	ldd	r20, Z+6	; 0x06
   11e18:	57 81       	ldd	r21, Z+7	; 0x07
   11e1a:	60 e0       	ldi	r22, 0x00	; 0
   11e1c:	70 e0       	ldi	r23, 0x00	; 0
   11e1e:	c7 01       	movw	r24, r14
   11e20:	20 2f       	mov	r18, r16
   11e22:	0e 94 ca 8c 	call	0x11994	; 0x11994 <putval>
   11e26:	65 c0       	rjmp	.+202    	; 0x11ef2 <vfscanf+0x200>
   11e28:	13 36       	cpi	r17, 0x63	; 99
   11e2a:	91 f4       	brne	.+36     	; 0x11e50 <vfscanf+0x15e>
   11e2c:	81 fd       	sbrc	r24, 1
   11e2e:	02 c0       	rjmp	.+4      	; 0x11e34 <vfscanf+0x142>
   11e30:	99 24       	eor	r9, r9
   11e32:	93 94       	inc	r9
   11e34:	c5 01       	movw	r24, r10
   11e36:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11e3a:	97 fd       	sbrc	r25, 7
   11e3c:	66 c0       	rjmp	.+204    	; 0x11f0a <vfscanf+0x218>
   11e3e:	e1 14       	cp	r14, r1
   11e40:	f1 04       	cpc	r15, r1
   11e42:	19 f0       	breq	.+6      	; 0x11e4a <vfscanf+0x158>
   11e44:	f7 01       	movw	r30, r14
   11e46:	81 93       	st	Z+, r24
   11e48:	7f 01       	movw	r14, r30
   11e4a:	9a 94       	dec	r9
   11e4c:	99 f7       	brne	.-26     	; 0x11e34 <vfscanf+0x142>
   11e4e:	4f c0       	rjmp	.+158    	; 0x11eee <vfscanf+0x1fc>
   11e50:	1b 35       	cpi	r17, 0x5B	; 91
   11e52:	59 f4       	brne	.+22     	; 0x11e6a <vfscanf+0x178>
   11e54:	c5 01       	movw	r24, r10
   11e56:	69 2d       	mov	r22, r9
   11e58:	a7 01       	movw	r20, r14
   11e5a:	96 01       	movw	r18, r12
   11e5c:	0e 94 af 8d 	call	0x11b5e	; 0x11b5e <conv_brk>
   11e60:	6c 01       	movw	r12, r24
   11e62:	00 97       	sbiw	r24, 0x00	; 0
   11e64:	09 f0       	breq	.+2      	; 0x11e68 <vfscanf+0x176>
   11e66:	43 c0       	rjmp	.+134    	; 0x11eee <vfscanf+0x1fc>
   11e68:	3d c0       	rjmp	.+122    	; 0x11ee4 <vfscanf+0x1f2>
   11e6a:	c5 01       	movw	r24, r10
   11e6c:	0e 94 04 8d 	call	0x11a08	; 0x11a08 <skip_spaces>
   11e70:	97 fd       	sbrc	r25, 7
   11e72:	4b c0       	rjmp	.+150    	; 0x11f0a <vfscanf+0x218>
   11e74:	1f 36       	cpi	r17, 0x6F	; 111
   11e76:	59 f1       	breq	.+86     	; 0x11ece <vfscanf+0x1dc>
   11e78:	10 37       	cpi	r17, 0x70	; 112
   11e7a:	28 f4       	brcc	.+10     	; 0x11e86 <vfscanf+0x194>
   11e7c:	14 36       	cpi	r17, 0x64	; 100
   11e7e:	29 f1       	breq	.+74     	; 0x11eca <vfscanf+0x1d8>
   11e80:	19 36       	cpi	r17, 0x69	; 105
   11e82:	39 f5       	brne	.+78     	; 0x11ed2 <vfscanf+0x1e0>
   11e84:	27 c0       	rjmp	.+78     	; 0x11ed4 <vfscanf+0x1e2>
   11e86:	13 37       	cpi	r17, 0x73	; 115
   11e88:	19 f0       	breq	.+6      	; 0x11e90 <vfscanf+0x19e>
   11e8a:	15 37       	cpi	r17, 0x75	; 117
   11e8c:	11 f5       	brne	.+68     	; 0x11ed2 <vfscanf+0x1e0>
   11e8e:	1d c0       	rjmp	.+58     	; 0x11eca <vfscanf+0x1d8>
   11e90:	c5 01       	movw	r24, r10
   11e92:	0e 94 02 90 	call	0x12004	; 0x12004 <fgetc>
   11e96:	ec 01       	movw	r28, r24
   11e98:	97 fd       	sbrc	r25, 7
   11e9a:	11 c0       	rjmp	.+34     	; 0x11ebe <vfscanf+0x1cc>
   11e9c:	0e 94 e4 8f 	call	0x11fc8	; 0x11fc8 <isspace>
   11ea0:	89 2b       	or	r24, r25
   11ea2:	29 f0       	breq	.+10     	; 0x11eae <vfscanf+0x1bc>
   11ea4:	ce 01       	movw	r24, r28
   11ea6:	b5 01       	movw	r22, r10
   11ea8:	0e 94 70 90 	call	0x120e0	; 0x120e0 <ungetc>
   11eac:	08 c0       	rjmp	.+16     	; 0x11ebe <vfscanf+0x1cc>
   11eae:	e1 14       	cp	r14, r1
   11eb0:	f1 04       	cpc	r15, r1
   11eb2:	19 f0       	breq	.+6      	; 0x11eba <vfscanf+0x1c8>
   11eb4:	f7 01       	movw	r30, r14
   11eb6:	c1 93       	st	Z+, r28
   11eb8:	7f 01       	movw	r14, r30
   11eba:	9a 94       	dec	r9
   11ebc:	49 f7       	brne	.-46     	; 0x11e90 <vfscanf+0x19e>
   11ebe:	e1 14       	cp	r14, r1
   11ec0:	f1 04       	cpc	r15, r1
   11ec2:	a9 f0       	breq	.+42     	; 0x11eee <vfscanf+0x1fc>
   11ec4:	f7 01       	movw	r30, r14
   11ec6:	10 82       	st	Z, r1
   11ec8:	12 c0       	rjmp	.+36     	; 0x11eee <vfscanf+0x1fc>
   11eca:	00 62       	ori	r16, 0x20	; 32
   11ecc:	03 c0       	rjmp	.+6      	; 0x11ed4 <vfscanf+0x1e2>
   11ece:	00 61       	ori	r16, 0x10	; 16
   11ed0:	01 c0       	rjmp	.+2      	; 0x11ed4 <vfscanf+0x1e2>
   11ed2:	00 64       	ori	r16, 0x40	; 64
   11ed4:	c5 01       	movw	r24, r10
   11ed6:	69 2d       	mov	r22, r9
   11ed8:	a7 01       	movw	r20, r14
   11eda:	20 2f       	mov	r18, r16
   11edc:	0e 94 1d 8d 	call	0x11a3a	; 0x11a3a <conv_int>
   11ee0:	88 23       	and	r24, r24
   11ee2:	29 f4       	brne	.+10     	; 0x11eee <vfscanf+0x1fc>
   11ee4:	f5 01       	movw	r30, r10
   11ee6:	83 81       	ldd	r24, Z+3	; 0x03
   11ee8:	80 73       	andi	r24, 0x30	; 48
   11eea:	79 f4       	brne	.+30     	; 0x11f0a <vfscanf+0x218>
   11eec:	13 c0       	rjmp	.+38     	; 0x11f14 <vfscanf+0x222>
   11eee:	00 ff       	sbrs	r16, 0
   11ef0:	83 94       	inc	r8
   11ef2:	f5 01       	movw	r30, r10
   11ef4:	f3 80       	ldd	r15, Z+3	; 0x03
   11ef6:	f6 01       	movw	r30, r12
   11ef8:	f3 fc       	sbrc	r15, 3
   11efa:	15 91       	lpm	r17, Z+
   11efc:	f3 fe       	sbrs	r15, 3
   11efe:	11 91       	ld	r17, Z+
   11f00:	6f 01       	movw	r12, r30
   11f02:	11 23       	and	r17, r17
   11f04:	09 f0       	breq	.+2      	; 0x11f08 <vfscanf+0x216>
   11f06:	0b cf       	rjmp	.-490    	; 0x11d1e <vfscanf+0x2c>
   11f08:	05 c0       	rjmp	.+10     	; 0x11f14 <vfscanf+0x222>
   11f0a:	88 20       	and	r8, r8
   11f0c:	19 f4       	brne	.+6      	; 0x11f14 <vfscanf+0x222>
   11f0e:	2f ef       	ldi	r18, 0xFF	; 255
   11f10:	3f ef       	ldi	r19, 0xFF	; 255
   11f12:	02 c0       	rjmp	.+4      	; 0x11f18 <vfscanf+0x226>
   11f14:	28 2d       	mov	r18, r8
   11f16:	30 e0       	ldi	r19, 0x00	; 0
   11f18:	c9 01       	movw	r24, r18
   11f1a:	df 91       	pop	r29
   11f1c:	cf 91       	pop	r28
   11f1e:	1f 91       	pop	r17
   11f20:	0f 91       	pop	r16
   11f22:	ff 90       	pop	r15
   11f24:	ef 90       	pop	r14
   11f26:	df 90       	pop	r13
   11f28:	cf 90       	pop	r12
   11f2a:	bf 90       	pop	r11
   11f2c:	af 90       	pop	r10
   11f2e:	9f 90       	pop	r9
   11f30:	8f 90       	pop	r8
   11f32:	7f 90       	pop	r7
   11f34:	6f 90       	pop	r6
   11f36:	08 95       	ret

00011f38 <__eerd_block_m128>:
   11f38:	dc 01       	movw	r26, r24
   11f3a:	cb 01       	movw	r24, r22

00011f3c <__eerd_blraw_m128>:
   11f3c:	fc 01       	movw	r30, r24
   11f3e:	e1 99       	sbic	0x1c, 1	; 28
   11f40:	fe cf       	rjmp	.-4      	; 0x11f3e <__eerd_blraw_m128+0x2>
   11f42:	06 c0       	rjmp	.+12     	; 0x11f50 <__eerd_blraw_m128+0x14>
   11f44:	ff bb       	out	0x1f, r31	; 31
   11f46:	ee bb       	out	0x1e, r30	; 30
   11f48:	e0 9a       	sbi	0x1c, 0	; 28
   11f4a:	31 96       	adiw	r30, 0x01	; 1
   11f4c:	0d b2       	in	r0, 0x1d	; 29
   11f4e:	0d 92       	st	X+, r0
   11f50:	41 50       	subi	r20, 0x01	; 1
   11f52:	50 40       	sbci	r21, 0x00	; 0
   11f54:	b8 f7       	brcc	.-18     	; 0x11f44 <__eerd_blraw_m128+0x8>
   11f56:	08 95       	ret

00011f58 <__eerd_byte_m128>:
   11f58:	e1 99       	sbic	0x1c, 1	; 28
   11f5a:	fe cf       	rjmp	.-4      	; 0x11f58 <__eerd_byte_m128>
   11f5c:	9f bb       	out	0x1f, r25	; 31
   11f5e:	8e bb       	out	0x1e, r24	; 30
   11f60:	e0 9a       	sbi	0x1c, 0	; 28
   11f62:	99 27       	eor	r25, r25
   11f64:	8d b3       	in	r24, 0x1d	; 29
   11f66:	08 95       	ret

00011f68 <__eerd_dword_m128>:
   11f68:	a6 e1       	ldi	r26, 0x16	; 22
   11f6a:	b0 e0       	ldi	r27, 0x00	; 0
   11f6c:	44 e0       	ldi	r20, 0x04	; 4
   11f6e:	50 e0       	ldi	r21, 0x00	; 0
   11f70:	0c 94 9e 8f 	jmp	0x11f3c	; 0x11f3c <__eerd_blraw_m128>

00011f74 <__eerd_word_m128>:
   11f74:	a8 e1       	ldi	r26, 0x18	; 24
   11f76:	b0 e0       	ldi	r27, 0x00	; 0
   11f78:	42 e0       	ldi	r20, 0x02	; 2
   11f7a:	50 e0       	ldi	r21, 0x00	; 0
   11f7c:	0c 94 9e 8f 	jmp	0x11f3c	; 0x11f3c <__eerd_blraw_m128>

00011f80 <__eewr_block_m128>:
   11f80:	dc 01       	movw	r26, r24
   11f82:	cb 01       	movw	r24, r22
   11f84:	03 c0       	rjmp	.+6      	; 0x11f8c <__eewr_block_m128+0xc>
   11f86:	2d 91       	ld	r18, X+
   11f88:	0e 94 cb 8f 	call	0x11f96	; 0x11f96 <__eewr_r18_m128>
   11f8c:	41 50       	subi	r20, 0x01	; 1
   11f8e:	50 40       	sbci	r21, 0x00	; 0
   11f90:	d0 f7       	brcc	.-12     	; 0x11f86 <__eewr_block_m128+0x6>
   11f92:	08 95       	ret

00011f94 <__eewr_byte_m128>:
   11f94:	26 2f       	mov	r18, r22

00011f96 <__eewr_r18_m128>:
   11f96:	e1 99       	sbic	0x1c, 1	; 28
   11f98:	fe cf       	rjmp	.-4      	; 0x11f96 <__eewr_r18_m128>
   11f9a:	9f bb       	out	0x1f, r25	; 31
   11f9c:	8e bb       	out	0x1e, r24	; 30
   11f9e:	2d bb       	out	0x1d, r18	; 29
   11fa0:	0f b6       	in	r0, 0x3f	; 63
   11fa2:	f8 94       	cli
   11fa4:	e2 9a       	sbi	0x1c, 2	; 28
   11fa6:	e1 9a       	sbi	0x1c, 1	; 28
   11fa8:	0f be       	out	0x3f, r0	; 63
   11faa:	01 96       	adiw	r24, 0x01	; 1
   11fac:	08 95       	ret

00011fae <__eewr_dword_m128>:
   11fae:	24 2f       	mov	r18, r20
   11fb0:	0e 94 cb 8f 	call	0x11f96	; 0x11f96 <__eewr_r18_m128>
   11fb4:	25 2f       	mov	r18, r21
   11fb6:	0e 94 cb 8f 	call	0x11f96	; 0x11f96 <__eewr_r18_m128>
   11fba:	0c 94 df 8f 	jmp	0x11fbe	; 0x11fbe <__eewr_word_m128>

00011fbe <__eewr_word_m128>:
   11fbe:	0e 94 ca 8f 	call	0x11f94	; 0x11f94 <__eewr_byte_m128>
   11fc2:	27 2f       	mov	r18, r23
   11fc4:	0c 94 cb 8f 	jmp	0x11f96	; 0x11f96 <__eewr_r18_m128>

00011fc8 <isspace>:
   11fc8:	91 11       	cpse	r25, r1
   11fca:	02 c1       	rjmp	.+516    	; 0x121d0 <__ctype_isfalse>
   11fcc:	80 32       	cpi	r24, 0x20	; 32
   11fce:	19 f0       	breq	.+6      	; 0x11fd6 <isspace+0xe>
   11fd0:	89 50       	subi	r24, 0x09	; 9
   11fd2:	85 50       	subi	r24, 0x05	; 5
   11fd4:	d0 f7       	brcc	.-12     	; 0x11fca <isspace+0x2>
   11fd6:	08 95       	ret

00011fd8 <strnlen_P>:
   11fd8:	fc 01       	movw	r30, r24
   11fda:	05 90       	lpm	r0, Z+
   11fdc:	61 50       	subi	r22, 0x01	; 1
   11fde:	70 40       	sbci	r23, 0x00	; 0
   11fe0:	01 10       	cpse	r0, r1
   11fe2:	d8 f7       	brcc	.-10     	; 0x11fda <strnlen_P+0x2>
   11fe4:	80 95       	com	r24
   11fe6:	90 95       	com	r25
   11fe8:	8e 0f       	add	r24, r30
   11fea:	9f 1f       	adc	r25, r31
   11fec:	08 95       	ret

00011fee <strnlen>:
   11fee:	fc 01       	movw	r30, r24
   11ff0:	61 50       	subi	r22, 0x01	; 1
   11ff2:	70 40       	sbci	r23, 0x00	; 0
   11ff4:	01 90       	ld	r0, Z+
   11ff6:	01 10       	cpse	r0, r1
   11ff8:	d8 f7       	brcc	.-10     	; 0x11ff0 <strnlen+0x2>
   11ffa:	80 95       	com	r24
   11ffc:	90 95       	com	r25
   11ffe:	8e 0f       	add	r24, r30
   12000:	9f 1f       	adc	r25, r31
   12002:	08 95       	ret

00012004 <fgetc>:
   12004:	cf 93       	push	r28
   12006:	df 93       	push	r29
   12008:	ec 01       	movw	r28, r24
   1200a:	4b 81       	ldd	r20, Y+3	; 0x03
   1200c:	40 ff       	sbrs	r20, 0
   1200e:	1a c0       	rjmp	.+52     	; 0x12044 <fgetc+0x40>
   12010:	46 ff       	sbrs	r20, 6
   12012:	0a c0       	rjmp	.+20     	; 0x12028 <fgetc+0x24>
   12014:	4f 7b       	andi	r20, 0xBF	; 191
   12016:	4b 83       	std	Y+3, r20	; 0x03
   12018:	8e 81       	ldd	r24, Y+6	; 0x06
   1201a:	9f 81       	ldd	r25, Y+7	; 0x07
   1201c:	01 96       	adiw	r24, 0x01	; 1
   1201e:	9f 83       	std	Y+7, r25	; 0x07
   12020:	8e 83       	std	Y+6, r24	; 0x06
   12022:	8a 81       	ldd	r24, Y+2	; 0x02
   12024:	28 2f       	mov	r18, r24
   12026:	2b c0       	rjmp	.+86     	; 0x1207e <fgetc+0x7a>
   12028:	42 ff       	sbrs	r20, 2
   1202a:	13 c0       	rjmp	.+38     	; 0x12052 <fgetc+0x4e>
   1202c:	e8 81       	ld	r30, Y
   1202e:	f9 81       	ldd	r31, Y+1	; 0x01
   12030:	80 81       	ld	r24, Z
   12032:	28 2f       	mov	r18, r24
   12034:	33 27       	eor	r19, r19
   12036:	27 fd       	sbrc	r18, 7
   12038:	30 95       	com	r19
   1203a:	21 15       	cp	r18, r1
   1203c:	31 05       	cpc	r19, r1
   1203e:	29 f4       	brne	.+10     	; 0x1204a <fgetc+0x46>
   12040:	40 62       	ori	r20, 0x20	; 32
   12042:	4b 83       	std	Y+3, r20	; 0x03
   12044:	2f ef       	ldi	r18, 0xFF	; 255
   12046:	3f ef       	ldi	r19, 0xFF	; 255
   12048:	1b c0       	rjmp	.+54     	; 0x12080 <fgetc+0x7c>
   1204a:	31 96       	adiw	r30, 0x01	; 1
   1204c:	f9 83       	std	Y+1, r31	; 0x01
   1204e:	e8 83       	st	Y, r30
   12050:	11 c0       	rjmp	.+34     	; 0x12074 <fgetc+0x70>
   12052:	ea 85       	ldd	r30, Y+10	; 0x0a
   12054:	fb 85       	ldd	r31, Y+11	; 0x0b
   12056:	ce 01       	movw	r24, r28
   12058:	09 95       	icall
   1205a:	9c 01       	movw	r18, r24
   1205c:	97 ff       	sbrs	r25, 7
   1205e:	0a c0       	rjmp	.+20     	; 0x12074 <fgetc+0x70>
   12060:	9b 81       	ldd	r25, Y+3	; 0x03
   12062:	2f 5f       	subi	r18, 0xFF	; 255
   12064:	3f 4f       	sbci	r19, 0xFF	; 255
   12066:	11 f0       	breq	.+4      	; 0x1206c <fgetc+0x68>
   12068:	80 e2       	ldi	r24, 0x20	; 32
   1206a:	01 c0       	rjmp	.+2      	; 0x1206e <fgetc+0x6a>
   1206c:	80 e1       	ldi	r24, 0x10	; 16
   1206e:	89 2b       	or	r24, r25
   12070:	8b 83       	std	Y+3, r24	; 0x03
   12072:	e8 cf       	rjmp	.-48     	; 0x12044 <fgetc+0x40>
   12074:	8e 81       	ldd	r24, Y+6	; 0x06
   12076:	9f 81       	ldd	r25, Y+7	; 0x07
   12078:	01 96       	adiw	r24, 0x01	; 1
   1207a:	9f 83       	std	Y+7, r25	; 0x07
   1207c:	8e 83       	std	Y+6, r24	; 0x06
   1207e:	30 e0       	ldi	r19, 0x00	; 0
   12080:	c9 01       	movw	r24, r18
   12082:	df 91       	pop	r29
   12084:	cf 91       	pop	r28
   12086:	08 95       	ret

00012088 <fputc>:
   12088:	0f 93       	push	r16
   1208a:	1f 93       	push	r17
   1208c:	cf 93       	push	r28
   1208e:	df 93       	push	r29
   12090:	8c 01       	movw	r16, r24
   12092:	eb 01       	movw	r28, r22
   12094:	8b 81       	ldd	r24, Y+3	; 0x03
   12096:	81 ff       	sbrs	r24, 1
   12098:	1b c0       	rjmp	.+54     	; 0x120d0 <fputc+0x48>
   1209a:	82 ff       	sbrs	r24, 2
   1209c:	0d c0       	rjmp	.+26     	; 0x120b8 <fputc+0x30>
   1209e:	2e 81       	ldd	r18, Y+6	; 0x06
   120a0:	3f 81       	ldd	r19, Y+7	; 0x07
   120a2:	8c 81       	ldd	r24, Y+4	; 0x04
   120a4:	9d 81       	ldd	r25, Y+5	; 0x05
   120a6:	28 17       	cp	r18, r24
   120a8:	39 07       	cpc	r19, r25
   120aa:	64 f4       	brge	.+24     	; 0x120c4 <fputc+0x3c>
   120ac:	e8 81       	ld	r30, Y
   120ae:	f9 81       	ldd	r31, Y+1	; 0x01
   120b0:	01 93       	st	Z+, r16
   120b2:	f9 83       	std	Y+1, r31	; 0x01
   120b4:	e8 83       	st	Y, r30
   120b6:	06 c0       	rjmp	.+12     	; 0x120c4 <fputc+0x3c>
   120b8:	e8 85       	ldd	r30, Y+8	; 0x08
   120ba:	f9 85       	ldd	r31, Y+9	; 0x09
   120bc:	80 2f       	mov	r24, r16
   120be:	09 95       	icall
   120c0:	89 2b       	or	r24, r25
   120c2:	31 f4       	brne	.+12     	; 0x120d0 <fputc+0x48>
   120c4:	8e 81       	ldd	r24, Y+6	; 0x06
   120c6:	9f 81       	ldd	r25, Y+7	; 0x07
   120c8:	01 96       	adiw	r24, 0x01	; 1
   120ca:	9f 83       	std	Y+7, r25	; 0x07
   120cc:	8e 83       	std	Y+6, r24	; 0x06
   120ce:	02 c0       	rjmp	.+4      	; 0x120d4 <fputc+0x4c>
   120d0:	0f ef       	ldi	r16, 0xFF	; 255
   120d2:	1f ef       	ldi	r17, 0xFF	; 255
   120d4:	c8 01       	movw	r24, r16
   120d6:	df 91       	pop	r29
   120d8:	cf 91       	pop	r28
   120da:	1f 91       	pop	r17
   120dc:	0f 91       	pop	r16
   120de:	08 95       	ret

000120e0 <ungetc>:
   120e0:	9c 01       	movw	r18, r24
   120e2:	fb 01       	movw	r30, r22
   120e4:	83 81       	ldd	r24, Z+3	; 0x03
   120e6:	80 ff       	sbrs	r24, 0
   120e8:	11 c0       	rjmp	.+34     	; 0x1210c <ungetc+0x2c>
   120ea:	86 fd       	sbrc	r24, 6
   120ec:	0f c0       	rjmp	.+30     	; 0x1210c <ungetc+0x2c>
   120ee:	9f ef       	ldi	r25, 0xFF	; 255
   120f0:	2f 3f       	cpi	r18, 0xFF	; 255
   120f2:	39 07       	cpc	r19, r25
   120f4:	59 f0       	breq	.+22     	; 0x1210c <ungetc+0x2c>
   120f6:	22 83       	std	Z+2, r18	; 0x02
   120f8:	80 64       	ori	r24, 0x40	; 64
   120fa:	8f 7d       	andi	r24, 0xDF	; 223
   120fc:	83 83       	std	Z+3, r24	; 0x03
   120fe:	86 81       	ldd	r24, Z+6	; 0x06
   12100:	97 81       	ldd	r25, Z+7	; 0x07
   12102:	01 97       	sbiw	r24, 0x01	; 1
   12104:	97 83       	std	Z+7, r25	; 0x07
   12106:	86 83       	std	Z+6, r24	; 0x06
   12108:	30 e0       	ldi	r19, 0x00	; 0
   1210a:	02 c0       	rjmp	.+4      	; 0x12110 <ungetc+0x30>
   1210c:	2f ef       	ldi	r18, 0xFF	; 255
   1210e:	3f ef       	ldi	r19, 0xFF	; 255
   12110:	c9 01       	movw	r24, r18
   12112:	08 95       	ret

00012114 <__ultoa_invert>:
   12114:	fa 01       	movw	r30, r20
   12116:	aa 27       	eor	r26, r26
   12118:	28 30       	cpi	r18, 0x08	; 8
   1211a:	51 f1       	breq	.+84     	; 0x12170 <__ultoa_invert+0x5c>
   1211c:	20 31       	cpi	r18, 0x10	; 16
   1211e:	81 f1       	breq	.+96     	; 0x12180 <__ultoa_invert+0x6c>
   12120:	e8 94       	clt
   12122:	6f 93       	push	r22
   12124:	6e 7f       	andi	r22, 0xFE	; 254
   12126:	6e 5f       	subi	r22, 0xFE	; 254
   12128:	7f 4f       	sbci	r23, 0xFF	; 255
   1212a:	8f 4f       	sbci	r24, 0xFF	; 255
   1212c:	9f 4f       	sbci	r25, 0xFF	; 255
   1212e:	af 4f       	sbci	r26, 0xFF	; 255
   12130:	b1 e0       	ldi	r27, 0x01	; 1
   12132:	3e d0       	rcall	.+124    	; 0x121b0 <__ultoa_invert+0x9c>
   12134:	b4 e0       	ldi	r27, 0x04	; 4
   12136:	3c d0       	rcall	.+120    	; 0x121b0 <__ultoa_invert+0x9c>
   12138:	67 0f       	add	r22, r23
   1213a:	78 1f       	adc	r23, r24
   1213c:	89 1f       	adc	r24, r25
   1213e:	9a 1f       	adc	r25, r26
   12140:	a1 1d       	adc	r26, r1
   12142:	68 0f       	add	r22, r24
   12144:	79 1f       	adc	r23, r25
   12146:	8a 1f       	adc	r24, r26
   12148:	91 1d       	adc	r25, r1
   1214a:	a1 1d       	adc	r26, r1
   1214c:	6a 0f       	add	r22, r26
   1214e:	71 1d       	adc	r23, r1
   12150:	81 1d       	adc	r24, r1
   12152:	91 1d       	adc	r25, r1
   12154:	a1 1d       	adc	r26, r1
   12156:	20 d0       	rcall	.+64     	; 0x12198 <__ultoa_invert+0x84>
   12158:	09 f4       	brne	.+2      	; 0x1215c <__ultoa_invert+0x48>
   1215a:	68 94       	set
   1215c:	3f 91       	pop	r19
   1215e:	2a e0       	ldi	r18, 0x0A	; 10
   12160:	26 9f       	mul	r18, r22
   12162:	11 24       	eor	r1, r1
   12164:	30 19       	sub	r19, r0
   12166:	30 5d       	subi	r19, 0xD0	; 208
   12168:	31 93       	st	Z+, r19
   1216a:	de f6       	brtc	.-74     	; 0x12122 <__ultoa_invert+0xe>
   1216c:	cf 01       	movw	r24, r30
   1216e:	08 95       	ret
   12170:	46 2f       	mov	r20, r22
   12172:	47 70       	andi	r20, 0x07	; 7
   12174:	40 5d       	subi	r20, 0xD0	; 208
   12176:	41 93       	st	Z+, r20
   12178:	b3 e0       	ldi	r27, 0x03	; 3
   1217a:	0f d0       	rcall	.+30     	; 0x1219a <__ultoa_invert+0x86>
   1217c:	c9 f7       	brne	.-14     	; 0x12170 <__ultoa_invert+0x5c>
   1217e:	f6 cf       	rjmp	.-20     	; 0x1216c <__ultoa_invert+0x58>
   12180:	46 2f       	mov	r20, r22
   12182:	4f 70       	andi	r20, 0x0F	; 15
   12184:	40 5d       	subi	r20, 0xD0	; 208
   12186:	4a 33       	cpi	r20, 0x3A	; 58
   12188:	18 f0       	brcs	.+6      	; 0x12190 <__ultoa_invert+0x7c>
   1218a:	49 5d       	subi	r20, 0xD9	; 217
   1218c:	31 fd       	sbrc	r19, 1
   1218e:	40 52       	subi	r20, 0x20	; 32
   12190:	41 93       	st	Z+, r20
   12192:	02 d0       	rcall	.+4      	; 0x12198 <__ultoa_invert+0x84>
   12194:	a9 f7       	brne	.-22     	; 0x12180 <__ultoa_invert+0x6c>
   12196:	ea cf       	rjmp	.-44     	; 0x1216c <__ultoa_invert+0x58>
   12198:	b4 e0       	ldi	r27, 0x04	; 4
   1219a:	a6 95       	lsr	r26
   1219c:	97 95       	ror	r25
   1219e:	87 95       	ror	r24
   121a0:	77 95       	ror	r23
   121a2:	67 95       	ror	r22
   121a4:	ba 95       	dec	r27
   121a6:	c9 f7       	brne	.-14     	; 0x1219a <__ultoa_invert+0x86>
   121a8:	00 97       	sbiw	r24, 0x00	; 0
   121aa:	61 05       	cpc	r22, r1
   121ac:	71 05       	cpc	r23, r1
   121ae:	08 95       	ret
   121b0:	9b 01       	movw	r18, r22
   121b2:	ac 01       	movw	r20, r24
   121b4:	0a 2e       	mov	r0, r26
   121b6:	06 94       	lsr	r0
   121b8:	57 95       	ror	r21
   121ba:	47 95       	ror	r20
   121bc:	37 95       	ror	r19
   121be:	27 95       	ror	r18
   121c0:	ba 95       	dec	r27
   121c2:	c9 f7       	brne	.-14     	; 0x121b6 <__ultoa_invert+0xa2>
   121c4:	62 0f       	add	r22, r18
   121c6:	73 1f       	adc	r23, r19
   121c8:	84 1f       	adc	r24, r20
   121ca:	95 1f       	adc	r25, r21
   121cc:	a0 1d       	adc	r26, r0
   121ce:	08 95       	ret

000121d0 <__ctype_isfalse>:
   121d0:	99 27       	eor	r25, r25
   121d2:	88 27       	eor	r24, r24

000121d4 <__ctype_istrue>:
   121d4:	08 95       	ret

000121d6 <__mulsi3>:
   121d6:	62 9f       	mul	r22, r18
   121d8:	d0 01       	movw	r26, r0
   121da:	73 9f       	mul	r23, r19
   121dc:	f0 01       	movw	r30, r0
   121de:	82 9f       	mul	r24, r18
   121e0:	e0 0d       	add	r30, r0
   121e2:	f1 1d       	adc	r31, r1
   121e4:	64 9f       	mul	r22, r20
   121e6:	e0 0d       	add	r30, r0
   121e8:	f1 1d       	adc	r31, r1
   121ea:	92 9f       	mul	r25, r18
   121ec:	f0 0d       	add	r31, r0
   121ee:	83 9f       	mul	r24, r19
   121f0:	f0 0d       	add	r31, r0
   121f2:	74 9f       	mul	r23, r20
   121f4:	f0 0d       	add	r31, r0
   121f6:	65 9f       	mul	r22, r21
   121f8:	f0 0d       	add	r31, r0
   121fa:	99 27       	eor	r25, r25
   121fc:	72 9f       	mul	r23, r18
   121fe:	b0 0d       	add	r27, r0
   12200:	e1 1d       	adc	r30, r1
   12202:	f9 1f       	adc	r31, r25
   12204:	63 9f       	mul	r22, r19
   12206:	b0 0d       	add	r27, r0
   12208:	e1 1d       	adc	r30, r1
   1220a:	f9 1f       	adc	r31, r25
   1220c:	bd 01       	movw	r22, r26
   1220e:	cf 01       	movw	r24, r30
   12210:	11 24       	eor	r1, r1
   12212:	08 95       	ret

00012214 <__udivmodqi4>:
   12214:	99 1b       	sub	r25, r25
   12216:	79 e0       	ldi	r23, 0x09	; 9
   12218:	04 c0       	rjmp	.+8      	; 0x12222 <__udivmodqi4_ep>

0001221a <__udivmodqi4_loop>:
   1221a:	99 1f       	adc	r25, r25
   1221c:	96 17       	cp	r25, r22
   1221e:	08 f0       	brcs	.+2      	; 0x12222 <__udivmodqi4_ep>
   12220:	96 1b       	sub	r25, r22

00012222 <__udivmodqi4_ep>:
   12222:	88 1f       	adc	r24, r24
   12224:	7a 95       	dec	r23
   12226:	c9 f7       	brne	.-14     	; 0x1221a <__udivmodqi4_loop>
   12228:	80 95       	com	r24
   1222a:	08 95       	ret

0001222c <__udivmodhi4>:
   1222c:	aa 1b       	sub	r26, r26
   1222e:	bb 1b       	sub	r27, r27
   12230:	51 e1       	ldi	r21, 0x11	; 17
   12232:	07 c0       	rjmp	.+14     	; 0x12242 <__udivmodhi4_ep>

00012234 <__udivmodhi4_loop>:
   12234:	aa 1f       	adc	r26, r26
   12236:	bb 1f       	adc	r27, r27
   12238:	a6 17       	cp	r26, r22
   1223a:	b7 07       	cpc	r27, r23
   1223c:	10 f0       	brcs	.+4      	; 0x12242 <__udivmodhi4_ep>
   1223e:	a6 1b       	sub	r26, r22
   12240:	b7 0b       	sbc	r27, r23

00012242 <__udivmodhi4_ep>:
   12242:	88 1f       	adc	r24, r24
   12244:	99 1f       	adc	r25, r25
   12246:	5a 95       	dec	r21
   12248:	a9 f7       	brne	.-22     	; 0x12234 <__udivmodhi4_loop>
   1224a:	80 95       	com	r24
   1224c:	90 95       	com	r25
   1224e:	bc 01       	movw	r22, r24
   12250:	cd 01       	movw	r24, r26
   12252:	08 95       	ret

00012254 <__divmodhi4>:
   12254:	97 fb       	bst	r25, 7
   12256:	09 2e       	mov	r0, r25
   12258:	07 26       	eor	r0, r23
   1225a:	0a d0       	rcall	.+20     	; 0x12270 <__divmodhi4_neg1>
   1225c:	77 fd       	sbrc	r23, 7
   1225e:	04 d0       	rcall	.+8      	; 0x12268 <__divmodhi4_neg2>
   12260:	e5 df       	rcall	.-54     	; 0x1222c <__udivmodhi4>
   12262:	06 d0       	rcall	.+12     	; 0x12270 <__divmodhi4_neg1>
   12264:	00 20       	and	r0, r0
   12266:	1a f4       	brpl	.+6      	; 0x1226e <__divmodhi4_exit>

00012268 <__divmodhi4_neg2>:
   12268:	70 95       	com	r23
   1226a:	61 95       	neg	r22
   1226c:	7f 4f       	sbci	r23, 0xFF	; 255

0001226e <__divmodhi4_exit>:
   1226e:	08 95       	ret

00012270 <__divmodhi4_neg1>:
   12270:	f6 f7       	brtc	.-4      	; 0x1226e <__divmodhi4_exit>
   12272:	90 95       	com	r25
   12274:	81 95       	neg	r24
   12276:	9f 4f       	sbci	r25, 0xFF	; 255
   12278:	08 95       	ret

0001227a <__udivmodsi4>:
   1227a:	a1 e2       	ldi	r26, 0x21	; 33
   1227c:	1a 2e       	mov	r1, r26
   1227e:	aa 1b       	sub	r26, r26
   12280:	bb 1b       	sub	r27, r27
   12282:	fd 01       	movw	r30, r26
   12284:	0d c0       	rjmp	.+26     	; 0x122a0 <__udivmodsi4_ep>

00012286 <__udivmodsi4_loop>:
   12286:	aa 1f       	adc	r26, r26
   12288:	bb 1f       	adc	r27, r27
   1228a:	ee 1f       	adc	r30, r30
   1228c:	ff 1f       	adc	r31, r31
   1228e:	a2 17       	cp	r26, r18
   12290:	b3 07       	cpc	r27, r19
   12292:	e4 07       	cpc	r30, r20
   12294:	f5 07       	cpc	r31, r21
   12296:	20 f0       	brcs	.+8      	; 0x122a0 <__udivmodsi4_ep>
   12298:	a2 1b       	sub	r26, r18
   1229a:	b3 0b       	sbc	r27, r19
   1229c:	e4 0b       	sbc	r30, r20
   1229e:	f5 0b       	sbc	r31, r21

000122a0 <__udivmodsi4_ep>:
   122a0:	66 1f       	adc	r22, r22
   122a2:	77 1f       	adc	r23, r23
   122a4:	88 1f       	adc	r24, r24
   122a6:	99 1f       	adc	r25, r25
   122a8:	1a 94       	dec	r1
   122aa:	69 f7       	brne	.-38     	; 0x12286 <__udivmodsi4_loop>
   122ac:	60 95       	com	r22
   122ae:	70 95       	com	r23
   122b0:	80 95       	com	r24
   122b2:	90 95       	com	r25
   122b4:	9b 01       	movw	r18, r22
   122b6:	ac 01       	movw	r20, r24
   122b8:	bd 01       	movw	r22, r26
   122ba:	cf 01       	movw	r24, r30
   122bc:	08 95       	ret

000122be <__divmodsi4>:
   122be:	97 fb       	bst	r25, 7
   122c0:	09 2e       	mov	r0, r25
   122c2:	05 26       	eor	r0, r21
   122c4:	0e d0       	rcall	.+28     	; 0x122e2 <__divmodsi4_neg1>
   122c6:	57 fd       	sbrc	r21, 7
   122c8:	04 d0       	rcall	.+8      	; 0x122d2 <__divmodsi4_neg2>
   122ca:	d7 df       	rcall	.-82     	; 0x1227a <__udivmodsi4>
   122cc:	0a d0       	rcall	.+20     	; 0x122e2 <__divmodsi4_neg1>
   122ce:	00 1c       	adc	r0, r0
   122d0:	38 f4       	brcc	.+14     	; 0x122e0 <__divmodsi4_exit>

000122d2 <__divmodsi4_neg2>:
   122d2:	50 95       	com	r21
   122d4:	40 95       	com	r20
   122d6:	30 95       	com	r19
   122d8:	21 95       	neg	r18
   122da:	3f 4f       	sbci	r19, 0xFF	; 255
   122dc:	4f 4f       	sbci	r20, 0xFF	; 255
   122de:	5f 4f       	sbci	r21, 0xFF	; 255

000122e0 <__divmodsi4_exit>:
   122e0:	08 95       	ret

000122e2 <__divmodsi4_neg1>:
   122e2:	f6 f7       	brtc	.-4      	; 0x122e0 <__divmodsi4_exit>
   122e4:	90 95       	com	r25
   122e6:	80 95       	com	r24
   122e8:	70 95       	com	r23
   122ea:	61 95       	neg	r22
   122ec:	7f 4f       	sbci	r23, 0xFF	; 255
   122ee:	8f 4f       	sbci	r24, 0xFF	; 255
   122f0:	9f 4f       	sbci	r25, 0xFF	; 255
   122f2:	08 95       	ret

000122f4 <__prologue_saves__>:
   122f4:	2f 92       	push	r2
   122f6:	3f 92       	push	r3
   122f8:	4f 92       	push	r4
   122fa:	5f 92       	push	r5
   122fc:	6f 92       	push	r6
   122fe:	7f 92       	push	r7
   12300:	8f 92       	push	r8
   12302:	9f 92       	push	r9
   12304:	af 92       	push	r10
   12306:	bf 92       	push	r11
   12308:	cf 92       	push	r12
   1230a:	df 92       	push	r13
   1230c:	ef 92       	push	r14
   1230e:	ff 92       	push	r15
   12310:	0f 93       	push	r16
   12312:	1f 93       	push	r17
   12314:	cf 93       	push	r28
   12316:	df 93       	push	r29
   12318:	cd b7       	in	r28, 0x3d	; 61
   1231a:	de b7       	in	r29, 0x3e	; 62
   1231c:	ca 1b       	sub	r28, r26
   1231e:	db 0b       	sbc	r29, r27
   12320:	0f b6       	in	r0, 0x3f	; 63
   12322:	f8 94       	cli
   12324:	de bf       	out	0x3e, r29	; 62
   12326:	0f be       	out	0x3f, r0	; 63
   12328:	cd bf       	out	0x3d, r28	; 61
   1232a:	09 94       	ijmp

0001232c <__epilogue_restores__>:
   1232c:	2a 88       	ldd	r2, Y+18	; 0x12
   1232e:	39 88       	ldd	r3, Y+17	; 0x11
   12330:	48 88       	ldd	r4, Y+16	; 0x10
   12332:	5f 84       	ldd	r5, Y+15	; 0x0f
   12334:	6e 84       	ldd	r6, Y+14	; 0x0e
   12336:	7d 84       	ldd	r7, Y+13	; 0x0d
   12338:	8c 84       	ldd	r8, Y+12	; 0x0c
   1233a:	9b 84       	ldd	r9, Y+11	; 0x0b
   1233c:	aa 84       	ldd	r10, Y+10	; 0x0a
   1233e:	b9 84       	ldd	r11, Y+9	; 0x09
   12340:	c8 84       	ldd	r12, Y+8	; 0x08
   12342:	df 80       	ldd	r13, Y+7	; 0x07
   12344:	ee 80       	ldd	r14, Y+6	; 0x06
   12346:	fd 80       	ldd	r15, Y+5	; 0x05
   12348:	0c 81       	ldd	r16, Y+4	; 0x04
   1234a:	1b 81       	ldd	r17, Y+3	; 0x03
   1234c:	aa 81       	ldd	r26, Y+2	; 0x02
   1234e:	b9 81       	ldd	r27, Y+1	; 0x01
   12350:	ce 0f       	add	r28, r30
   12352:	d1 1d       	adc	r29, r1
   12354:	0f b6       	in	r0, 0x3f	; 63
   12356:	f8 94       	cli
   12358:	de bf       	out	0x3e, r29	; 62
   1235a:	0f be       	out	0x3f, r0	; 63
   1235c:	cd bf       	out	0x3d, r28	; 61
   1235e:	ed 01       	movw	r28, r26
   12360:	08 95       	ret

00012362 <_exit>:
   12362:	f8 94       	cli

00012364 <__stop_program>:
   12364:	ff cf       	rjmp	.-2      	; 0x12364 <__stop_program>
