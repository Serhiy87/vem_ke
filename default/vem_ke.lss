
vem_ke.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000013a  00800100  0000ec42  0000ecf6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000ec42  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c12  0080023a  0080023a  0000ee30  2**0
                  ALLOC
  3 .eeprom       000001ae  00810000  00810000  0000ee30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  0000efde  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000009d8  00000000  00000000  0000f03a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014c14  00000000  00000000  0000fa12  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d8  00000000  00000000  00024626  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e8f  00000000  00000000  00024ffe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000024e0  00000000  00000000  00028e90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004224  00000000  00000000  0002b370  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000100fe  00000000  00000000  0002f594  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d28  00000000  00000000  0003f692  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ee 27 	jmp	0x4fdc	; 0x4fdc <__ctors_end>
       4:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
       8:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
       c:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      10:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      14:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      18:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      1c:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      20:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      24:	0c 94 09 2f 	jmp	0x5e12	; 0x5e12 <__vector_9>
      28:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      2c:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      30:	0c 94 2d 2d 	jmp	0x5a5a	; 0x5a5a <__vector_12>
      34:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      38:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      3c:	0c 94 d9 2e 	jmp	0x5db2	; 0x5db2 <__vector_15>
      40:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      44:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      48:	0c 94 82 57 	jmp	0xaf04	; 0xaf04 <__vector_18>
      4c:	0c 94 01 6a 	jmp	0xd402	; 0xd402 <__vector_19>
      50:	0c 94 76 3b 	jmp	0x76ec	; 0x76ec <__vector_20>
      54:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      58:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      5c:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      60:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      64:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      68:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      6c:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      70:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      74:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      78:	0c 94 60 4c 	jmp	0x98c0	; 0x98c0 <__vector_30>
      7c:	0c 94 ca 6a 	jmp	0xd594	; 0xd594 <__vector_31>
      80:	0c 94 a3 4c 	jmp	0x9946	; 0x9946 <__vector_32>
      84:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      88:	0c 94 0d 28 	jmp	0x501a	; 0x501a <__bad_interrupt>
      8c:	cc 32       	cpi	r28, 0x2C	; 44
      8e:	cc 32       	cpi	r28, 0x2C	; 44
      90:	58 33       	cpi	r21, 0x38	; 56
      92:	58 33       	cpi	r21, 0x38	; 56
      94:	b4 34       	cpi	r27, 0x44	; 68
      96:	b3 33       	cpi	r27, 0x33	; 51
      98:	b4 34       	cpi	r27, 0x44	; 68
      9a:	b4 34       	cpi	r27, 0x44	; 68
      9c:	b4 34       	cpi	r27, 0x44	; 68
      9e:	b4 34       	cpi	r27, 0x44	; 68
      a0:	b4 34       	cpi	r27, 0x44	; 68
      a2:	b4 34       	cpi	r27, 0x44	; 68
      a4:	b4 34       	cpi	r27, 0x44	; 68
      a6:	b4 34       	cpi	r27, 0x44	; 68
      a8:	e2 33       	cpi	r30, 0x32	; 50
      aa:	5b 34       	cpi	r21, 0x4B	; 75
      ac:	51 36       	cpi	r21, 0x61	; 97
      ae:	51 36       	cpi	r21, 0x61	; 97
      b0:	e7 36       	cpi	r30, 0x67	; 103
      b2:	e7 36       	cpi	r30, 0x67	; 103
      b4:	f8 37       	cpi	r31, 0x78	; 120
      b6:	53 37       	cpi	r21, 0x73	; 115
      b8:	f8 37       	cpi	r31, 0x78	; 120
      ba:	f8 37       	cpi	r31, 0x78	; 120
      bc:	f8 37       	cpi	r31, 0x78	; 120
      be:	f8 37       	cpi	r31, 0x78	; 120
      c0:	f8 37       	cpi	r31, 0x78	; 120
      c2:	f8 37       	cpi	r31, 0x78	; 120
      c4:	f8 37       	cpi	r31, 0x78	; 120
      c6:	f8 37       	cpi	r31, 0x78	; 120
      c8:	a6 37       	cpi	r26, 0x76	; 118
      ca:	a6 37       	cpi	r26, 0x76	; 118
      cc:	3a 44       	sbci	r19, 0x4A	; 74
      ce:	65 44       	sbci	r22, 0x45	; 69
      d0:	99 44       	sbci	r25, 0x49	; 73
      d2:	cf 44       	sbci	r28, 0x4F	; 79
      d4:	3a 44       	sbci	r19, 0x4A	; 74
      d6:	65 44       	sbci	r22, 0x45	; 69
      d8:	25 47       	sbci	r18, 0x75	; 117
      da:	f1 44       	sbci	r31, 0x41	; 65
      dc:	1a 45       	sbci	r17, 0x5A	; 90
      de:	4c 45       	sbci	r20, 0x5C	; 92
      e0:	85 45       	sbci	r24, 0x55	; 85
      e2:	f1 44       	sbci	r31, 0x41	; 65
      e4:	1a 45       	sbci	r17, 0x5A	; 90
      e6:	af 45       	sbci	r26, 0x5F	; 95
      e8:	af 45       	sbci	r26, 0x5F	; 95
      ea:	25 47       	sbci	r18, 0x75	; 117
      ec:	b3 45       	sbci	r27, 0x53	; 83
      ee:	be 45       	sbci	r27, 0x5E	; 94
      f0:	c9 45       	sbci	r28, 0x59	; 89
      f2:	fd 45       	sbci	r31, 0x5D	; 93
      f4:	b3 45       	sbci	r27, 0x53	; 83
      f6:	be 45       	sbci	r27, 0x5E	; 94
      f8:	25 47       	sbci	r18, 0x75	; 117
      fa:	25 47       	sbci	r18, 0x75	; 117
      fc:	25 47       	sbci	r18, 0x75	; 117
      fe:	2d 46       	sbci	r18, 0x6D	; 109
     100:	49 46       	sbci	r20, 0x69	; 105
     102:	2d 46       	sbci	r18, 0x6D	; 109
     104:	49 46       	sbci	r20, 0x69	; 105
     106:	67 46       	sbci	r22, 0x67	; 103
     108:	6a 46       	sbci	r22, 0x6A	; 106
     10a:	71 46       	sbci	r23, 0x61	; 97
     10c:	93 46       	sbci	r25, 0x63	; 99
     10e:	b7 46       	sbci	r27, 0x67	; 103
     110:	ec 46       	sbci	r30, 0x6C	; 108
     112:	9c 47       	sbci	r25, 0x7C	; 124
     114:	a0 47       	sbci	r26, 0x70	; 112
     116:	a5 47       	sbci	r26, 0x75	; 117
     118:	aa 47       	sbci	r26, 0x7A	; 122
     11a:	af 47       	sbci	r26, 0x7F	; 127
     11c:	b4 47       	sbci	r27, 0x74	; 116
     11e:	b8 47       	sbci	r27, 0x78	; 120
     120:	bc 47       	sbci	r27, 0x7C	; 124
     122:	c2 47       	sbci	r28, 0x72	; 114
     124:	d8 47       	sbci	r29, 0x78	; 120
     126:	dc 47       	sbci	r29, 0x7C	; 124
     128:	e1 47       	sbci	r30, 0x71	; 113
     12a:	e5 47       	sbci	r30, 0x75	; 117
     12c:	ea 47       	sbci	r30, 0x7A	; 122
     12e:	ef 47       	sbci	r30, 0x7F	; 127
     130:	f4 47       	sbci	r31, 0x74	; 116
     132:	f9 47       	sbci	r31, 0x79	; 121
     134:	ff 47       	sbci	r31, 0x7F	; 127
     136:	14 48       	sbci	r17, 0x84	; 132
     138:	18 48       	sbci	r17, 0x88	; 136
     13a:	1d 48       	sbci	r17, 0x8D	; 141
     13c:	22 48       	sbci	r18, 0x82	; 130
     13e:	27 48       	sbci	r18, 0x87	; 135
     140:	2b 48       	sbci	r18, 0x8B	; 139
     142:	30 48       	sbci	r19, 0x80	; 128
     144:	35 48       	sbci	r19, 0x85	; 133
     146:	3a 48       	sbci	r19, 0x8A	; 138
     148:	40 48       	sbci	r20, 0x80	; 128
     14a:	fb 4a       	sbci	r31, 0xAB	; 171
     14c:	00 4b       	sbci	r16, 0xB0	; 176
     14e:	05 4b       	sbci	r16, 0xB5	; 181
     150:	1d 4b       	sbci	r17, 0xBD	; 189
     152:	09 4b       	sbci	r16, 0xB9	; 185
     154:	0d 4b       	sbci	r16, 0xBD	; 189
     156:	11 4b       	sbci	r17, 0xB1	; 177
     158:	15 4b       	sbci	r17, 0xB5	; 181
     15a:	19 4b       	sbci	r17, 0xB9	; 185
     15c:	b6 52       	subi	r27, 0x26	; 38
     15e:	3e 53       	subi	r19, 0x3E	; 62
     160:	b2 52       	subi	r27, 0x22	; 34
     162:	42 53       	subi	r20, 0x32	; 50
     164:	de 52       	subi	r29, 0x2E	; 46
     166:	e2 52       	subi	r30, 0x22	; 34
     168:	e6 52       	subi	r30, 0x26	; 38
     16a:	ea 52       	subi	r30, 0x2A	; 42
     16c:	ee 52       	subi	r30, 0x2E	; 46
     16e:	f2 52       	subi	r31, 0x22	; 34
     170:	f6 52       	subi	r31, 0x26	; 38
     172:	fa 52       	subi	r31, 0x2A	; 42
     174:	fe 52       	subi	r31, 0x2E	; 46
     176:	02 53       	subi	r16, 0x32	; 50
     178:	06 53       	subi	r16, 0x36	; 54
     17a:	0a 53       	subi	r16, 0x3A	; 58
     17c:	0e 53       	subi	r16, 0x3E	; 62
     17e:	12 53       	subi	r17, 0x32	; 50
     180:	16 53       	subi	r17, 0x36	; 54
     182:	1a 53       	subi	r17, 0x3A	; 58
     184:	1e 53       	subi	r17, 0x3E	; 62
     186:	22 53       	subi	r18, 0x32	; 50
     188:	96 53       	subi	r25, 0x36	; 54
     18a:	9a 53       	subi	r25, 0x3A	; 58
     18c:	9e 53       	subi	r25, 0x3E	; 62
     18e:	a2 53       	subi	r26, 0x32	; 50
     190:	a6 53       	subi	r26, 0x36	; 54
     192:	aa 53       	subi	r26, 0x3A	; 58
     194:	ae 53       	subi	r26, 0x3E	; 62
     196:	b2 53       	subi	r27, 0x32	; 50
     198:	b6 53       	subi	r27, 0x36	; 54
     19a:	ba 53       	subi	r27, 0x3A	; 58
     19c:	be 53       	subi	r27, 0x3E	; 62
     19e:	c2 53       	subi	r28, 0x32	; 50
     1a0:	56 58       	subi	r21, 0x86	; 134
     1a2:	71 58       	subi	r23, 0x81	; 129
     1a4:	81 58       	subi	r24, 0x81	; 129
     1a6:	8e 58       	subi	r24, 0x8E	; 142
     1a8:	e1 64       	ori	r30, 0x41	; 65
     1aa:	e1 64       	ori	r30, 0x41	; 65
     1ac:	b8 58       	subi	r27, 0x88	; 136
     1ae:	cf 58       	subi	r28, 0x8F	; 143
     1b0:	df 58       	subi	r29, 0x8F	; 143
     1b2:	ec 58       	subi	r30, 0x8C	; 140
     1b4:	fc 58       	subi	r31, 0x8C	; 140
     1b6:	09 59       	subi	r16, 0x99	; 153
     1b8:	19 59       	subi	r17, 0x99	; 153
     1ba:	28 59       	subi	r18, 0x98	; 152
     1bc:	a5 59       	subi	r26, 0x95	; 149
     1be:	b5 59       	subi	r27, 0x95	; 149
     1c0:	c2 59       	subi	r28, 0x92	; 146
     1c2:	d2 59       	subi	r29, 0x92	; 146
     1c4:	df 59       	subi	r29, 0x9F	; 159
     1c6:	ef 59       	subi	r30, 0x9F	; 159
     1c8:	fc 59       	subi	r31, 0x9C	; 156
     1ca:	0c 5a       	subi	r16, 0xAC	; 172
     1cc:	19 5a       	subi	r17, 0xA9	; 169
     1ce:	2f 5a       	subi	r18, 0xAF	; 175
     1d0:	38 5a       	subi	r19, 0xA8	; 168
     1d2:	4a 5a       	subi	r20, 0xAA	; 170
     1d4:	61 5a       	subi	r22, 0xA1	; 161
     1d6:	d9 5a       	subi	r29, 0xA9	; 169
     1d8:	e9 5a       	subi	r30, 0xA9	; 169
     1da:	f6 5a       	subi	r31, 0xA6	; 166
     1dc:	06 5b       	subi	r16, 0xB6	; 182
     1de:	13 5b       	subi	r17, 0xB3	; 179
     1e0:	23 5b       	subi	r18, 0xB3	; 179
     1e2:	30 5b       	subi	r19, 0xB0	; 176
     1e4:	92 5b       	subi	r25, 0xB2	; 178
     1e6:	f1 5b       	subi	r31, 0xB1	; 177
     1e8:	ff 5b       	subi	r31, 0xBF	; 191
     1ea:	0d 5c       	subi	r16, 0xCD	; 205
     1ec:	3a 5c       	subi	r19, 0xCA	; 202
     1ee:	60 5c       	subi	r22, 0xC0	; 192
     1f0:	6b 5c       	subi	r22, 0xCB	; 203
     1f2:	79 5c       	subi	r23, 0xC9	; 201
     1f4:	84 5c       	subi	r24, 0xC4	; 196
     1f6:	b3 5c       	subi	r27, 0xC3	; 195
     1f8:	43 5d       	subi	r20, 0xD3	; 211
     1fa:	51 5d       	subi	r21, 0xD1	; 209
     1fc:	7f 5d       	subi	r23, 0xDF	; 223
     1fe:	c6 5d       	subi	r28, 0xD6	; 214
     200:	d4 5d       	subi	r29, 0xD4	; 212
     202:	e0 5d       	subi	r30, 0xD0	; 208
     204:	4d 5e       	subi	r20, 0xED	; 237
     206:	dc 5e       	subi	r29, 0xEC	; 236
     208:	9b 5f       	subi	r25, 0xFB	; 251
     20a:	ae 5f       	subi	r26, 0xFE	; 254
     20c:	ba 5f       	subi	r27, 0xFA	; 250
     20e:	0f 60       	ori	r16, 0x0F	; 15
     210:	79 60       	ori	r23, 0x09	; 9
     212:	01 61       	ori	r16, 0x11	; 17
     214:	0e 61       	ori	r16, 0x1E	; 30
     216:	21 61       	ori	r18, 0x11	; 17
     218:	3a 61       	ori	r19, 0x1A	; 26
     21a:	a7 61       	ori	r26, 0x17	; 23
     21c:	dd 61       	ori	r29, 0x1D	; 29
     21e:	18 62       	ori	r17, 0x28	; 40
     220:	44 62       	ori	r20, 0x24	; 36
     222:	55 62       	ori	r21, 0x25	; 37
     224:	61 62       	ori	r22, 0x21	; 33
     226:	e1 64       	ori	r30, 0x41	; 65
     228:	e1 64       	ori	r30, 0x41	; 65
     22a:	e1 64       	ori	r30, 0x41	; 65
     22c:	e1 64       	ori	r30, 0x41	; 65
     22e:	e1 64       	ori	r30, 0x41	; 65
     230:	e1 64       	ori	r30, 0x41	; 65
     232:	e1 64       	ori	r30, 0x41	; 65
     234:	e1 64       	ori	r30, 0x41	; 65
     236:	e1 64       	ori	r30, 0x41	; 65
     238:	e1 64       	ori	r30, 0x41	; 65
     23a:	e1 64       	ori	r30, 0x41	; 65
     23c:	e1 64       	ori	r30, 0x41	; 65
     23e:	e1 64       	ori	r30, 0x41	; 65
     240:	29 60       	ori	r18, 0x09	; 9
     242:	35 60       	ori	r19, 0x05	; 5
     244:	41 60       	ori	r20, 0x01	; 1
     246:	4d 60       	ori	r20, 0x0D	; 13
     248:	5b 60       	ori	r21, 0x0B	; 11
     24a:	67 60       	ori	r22, 0x07	; 7
     24c:	e1 64       	ori	r30, 0x41	; 65
     24e:	e1 64       	ori	r30, 0x41	; 65
     250:	86 62       	ori	r24, 0x26	; 38
     252:	a8 62       	ori	r26, 0x28	; 40
     254:	b2 62       	ori	r27, 0x22	; 34
     256:	be 62       	ori	r27, 0x2E	; 46
     258:	cc 62       	ori	r28, 0x2C	; 44
     25a:	d8 62       	ori	r29, 0x28	; 40
     25c:	e8 62       	ori	r30, 0x28	; 40
     25e:	08 63       	ori	r16, 0x38	; 56
     260:	33 63       	ori	r19, 0x33	; 51
     262:	81 63       	ori	r24, 0x31	; 49
     264:	8d 63       	ori	r24, 0x3D	; 61
     266:	b7 63       	ori	r27, 0x37	; 55
     268:	d9 63       	ori	r29, 0x39	; 57
     26a:	22 64       	ori	r18, 0x42	; 66
     26c:	2e 64       	ori	r18, 0x4E	; 78
     26e:	43 64       	ori	r20, 0x43	; 67
     270:	4f 64       	ori	r20, 0x4F	; 79
     272:	67 64       	ori	r22, 0x47	; 71
     274:	75 64       	ori	r23, 0x45	; 69
     276:	87 64       	ori	r24, 0x47	; 71
     278:	95 64       	ori	r25, 0x45	; 69
     27a:	a1 64       	ori	r26, 0x41	; 65
     27c:	b4 64       	ori	r27, 0x44	; 68
     27e:	c0 64       	ori	r28, 0x40	; 64
     280:	d3 64       	ori	r29, 0x43	; 67
     282:	e1 64       	ori	r30, 0x41	; 65
     284:	e9 67       	ori	r30, 0x79	; 121
     286:	eb 67       	ori	r30, 0x7B	; 123
     288:	f6 67       	ori	r31, 0x76	; 118
     28a:	f8 67       	ori	r31, 0x78	; 120
     28c:	05 68       	ori	r16, 0x85	; 133
     28e:	07 68       	ori	r16, 0x87	; 135
     290:	12 68       	ori	r17, 0x82	; 130
     292:	44 68       	ori	r20, 0x84	; 132
     294:	4b 68       	ori	r20, 0x8B	; 139
     296:	53 68       	ori	r21, 0x83	; 131
     298:	5a 68       	ori	r21, 0x8A	; 138
     29a:	62 68       	ori	r22, 0x82	; 130
     29c:	69 68       	ori	r22, 0x89	; 137
     29e:	44 68       	ori	r20, 0x84	; 132
     2a0:	62 68       	ori	r22, 0x82	; 130
     2a2:	1b 68       	ori	r17, 0x8B	; 139
     2a4:	71 68       	ori	r23, 0x81	; 129
     2a6:	76 68       	ori	r23, 0x86	; 134
     2a8:	7f 68       	ori	r23, 0x8F	; 143
     2aa:	84 68       	ori	r24, 0x84	; 132
     2ac:	8d 68       	ori	r24, 0x8D	; 141
     2ae:	92 68       	ori	r25, 0x82	; 130
     2b0:	71 68       	ori	r23, 0x81	; 129
     2b2:	8d 68       	ori	r24, 0x8D	; 141
     2b4:	26 68       	ori	r18, 0x86	; 134
     2b6:	9b 68       	ori	r25, 0x8B	; 139
     2b8:	a0 68       	ori	r26, 0x80	; 128
     2ba:	b1 68       	ori	r27, 0x81	; 129
     2bc:	b6 68       	ori	r27, 0x86	; 134
     2be:	c7 68       	ori	r28, 0x87	; 135
     2c0:	c9 68       	ori	r28, 0x89	; 137
     2c2:	d7 68       	ori	r29, 0x87	; 135
     2c4:	e1 68       	ori	r30, 0x81	; 129
     2c6:	07 69       	ori	r16, 0x97	; 151
     2c8:	0e 69       	ori	r16, 0x9E	; 158

000002ca <__trampolines_end>:
     2ca:	ed e5       	ldi	r30, 0x5D	; 93
     2cc:	f2 20       	and	r15, r2
     2ce:	f1 e2       	ldi	r31, 0x21	; 33
     2d0:	ff e7       	ldi	r31, 0x7F	; 127
     2d2:	e8 20       	and	r14, r8
     2d4:	f1 20       	and	r15, r1
     2d6:	dd d1       	rcall	.+954    	; 0x692 <system_page+0x4c>
     2d8:	20 00       	.word	0x0020	; ????

000002da <__c.5165>:
     2da:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000002ea <__c.5163>:
     2ea:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000002f5 <__c.4709>:
     2f5:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

000002ff <__c.4707>:
     2ff:	25 30 38 6c 78 00                                   %08lx.

00000305 <__c.4690>:
     305:	25 75 0d 0a 00                                      %u...

0000030a <__c.4591>:
     30a:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

00000316 <__c.4589>:
     316:	2f 00                                               /.

00000318 <__c.3745>:
     318:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00000328 <__c.3733>:
     328:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
     338:	68 75 00                                            hu.

0000033b <__c.3722>:
     33b:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
     34b:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

00000359 <__c.3697>:
     359:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00000366 <__c.3673>:
     366:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
     376:	68 68 75 00                                         hhu.

0000037a <__c.3647>:
     37a:	25 75 00                                            %u.

0000037d <__c.3645>:
     37d:	25 6c 75 64 00                                      %lud.

00000382 <aCRCLo.1930>:
     382:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     392:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     3a2:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     3b2:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     3c2:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     3d2:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     3e2:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     3f2:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     402:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     412:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     422:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     432:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     442:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     452:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     462:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     472:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00000482 <aCRCHi.1929>:
     482:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     492:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4a2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4b2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4c2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4d2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4e2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4f2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     502:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     512:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     522:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     532:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     542:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     552:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     562:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     572:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00000582 <WebSite>:
     582:	57 45 95 48 e9 33 80 39 d4 1c e0 16 8e 0c 94 05     WE.H.3.9........
     592:	b0 32                                               .2

00000594 <Web_system>:
     594:	82 0c 40 0c 18 00 a1 05 fa 05 46 06 04              ..@.......F..

000005a1 <system_OField>:
     5a1:	40 06 30 06 29 06 19 06 0e 06 fe 05 f4 05 e4 05     @.0.)...........
     5b1:	de 05 ce 05 c9 05 b9 05                             ........

000005b9 <Web_Tlow>:
     5b9:	0a 0b 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005c9 <var_Tlow>:
     5c9:	54 6c 6f 77 00                                      Tlow.

000005ce <Web_Thigh>:
     5ce:	0a 0d 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005de <var_Thigh>:
     5de:	54 68 69 67 68 00                                   Thigh.

000005e4 <Web_BLupgrade>:
     5e4:	00 1f 06 00 00 00 00 ff 00 00 00 f5 28 00 00 00     ............(...

000005f4 <var_BLupgrade>:
     5f4:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

000005fe <Web_Bootloader>:
     5fe:	00 1f 06 00 00 00 00 ff 00 00 00 c2 29 00 00 00     ............)...

0000060e <var_Bootloader>:
     60e:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

00000619 <Web_Reboot>:
     619:	00 1f 06 00 00 00 00 ff 00 00 00 ef 28 00 00 00     ............(...

00000629 <var_Reboot>:
     629:	52 65 62 6f 6f 74 00                                Reboot.

00000630 <Web_Title>:
     630:	22 0f 00 00 00 00 00 02 00 00 00 00 00 00 00 15     "...............

00000640 <var_Title>:
     640:	54 69 74 6c 65 00                                   Title.

00000646 <system_page>:
     646:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     656:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     666:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     676:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     686:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     696:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     6a6:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     6b6:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     6c6:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     6d6:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     6e6:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     6f6:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     706:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     716:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     726:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     736:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     746:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     756:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     766:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     776:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     786:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     796:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     7a6:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     7b6:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     7c6:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     7d6:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     7e6:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     7f6:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     806:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     816:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     826:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     836:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
     846:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
     856:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
     866:	cd e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0     ........ .......
     876:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     886:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74     'text' name='Tit
     896:	6c 65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61     le' size='40' va
     8a6:	6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     lue='{{{{{{{{{{{
     8b6:	7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69     {{{{{{{{{'>...<i
     8c6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     8d6:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
     8e6:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
     8f6:	0d 0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b     ........... :{{{
     906:	7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46     {{{{{{{{ .....<F
     916:	4f 52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     ORM action='/' m
     926:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c     ethod='GET'>...<
     936:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
     946:	69 74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74     it' name='Reboot
     956:	27 20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27     ' value='Reboot'
     966:	3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1     >..</FORM>......
     976:	e8 ff 20 cf ce 3a 20 33 2e 30 37 0d 0a 3c 46 4f     .. ..: 3.07..<FO
     986:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
     996:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
     9a6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     9b6:	74 27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61     t' name='Bootloa
     9c6:	64 65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74     der' value='Boot
     9d6:	6c 6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52     loader' color='R
     9e6:	45 44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     ED'>..</FORM>..<
     9f6:	2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69     /BR>..<FORM acti
     a06:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
     a16:	45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ET'>...<input ty
     a26:	70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65     pe='submit' name
     a36:	3d 27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c     ='BLupgrade' val
     a46:	75 65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d     ue='BLupgrade'>.
     a56:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
     a66:	0a 3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0     .<H2>...........
     a76:	3c 2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3     </H2>...........
     a86:	f0 e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43     ..:{{{{{{{&#176C
     a96:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
     aa6:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
     ab6:	47 45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff     GET'>...........
     ac6:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     ad6:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69     'text' name='Thi
     ae6:	67 68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c     gh' size='5' val
     af6:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31     ue='{{{{{{{'>&#1
     b06:	37 36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     76C...<input typ
     b16:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
     b26:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
     b36:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
     b46:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
     b56:	27 47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff     'GET'>..........
     b66:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     b76:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f     'text' name='Tlo
     b86:	77 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     w' size='5' valu
     b96:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
     ba6:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
     bb6:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
     bc6:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
     bd6:	3c 2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d     </BR>....... GSM
     be6:	2d 3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32     ->EM: {{{/(max 2
     bf6:	35 30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3     50)....</BR>....
     c06:	f4 e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b     ... EM->GSM: {{{
     c16:	2f 28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f     /(max 250)....</
     c26:	42 52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     BR>....</BODY>..
     c36:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00000c40 <system_IField>:
     c40:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
     c50:	00 00 14 12 06 00 00 00 22 0f 00 00 00 15 10 63     ........"......c
     c60:	09 00 00 02 09 f2 05 00 00 01 0a 0d 00 00 00 01     ................
     c70:	0a 0b 00 00 00 01 00 7f 09 00 00 00 00 6e 0a 00     .............n..
	...

00000c82 <name_system>:
     c82:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000c8e <Web_csd>:
     c8e:	d7 16 77 16 2c 00 9b 0c c7 08 b0 0d 02              ..w.,........

00000c9b <csd_OField>:
     c9b:	a9 0d 99 0d 94 0d 84 0d 7f 0d 6f 0d 6a 0d 5a 0d     ..........o.j.Z.
     cab:	55 0d 45 0d 40 0d 30 0d 2b 0d 1b 0d 16 0d 06 0d     U.E.@.0.+.......
     cbb:	01 0d f1 0c ec 0c dc 0c d7 0c c7 0c                 ............

00000cc7 <Web_CSD_Number9>:
     cc7:	22 d6 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cd7 <var_CSD_Number9>:
     cd7:	43 53 44 39 00                                      CSD9.

00000cdc <Web_CSD_Number8>:
     cdc:	22 c9 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cec <var_CSD_Number8>:
     cec:	43 53 44 38 00                                      CSD8.

00000cf1 <Web_CSD_Number7>:
     cf1:	22 bc 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d01 <var_CSD_Number7>:
     d01:	43 53 44 37 00                                      CSD7.

00000d06 <Web_CSD_Number6>:
     d06:	22 af 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d16 <var_CSD_Number6>:
     d16:	43 53 44 36 00                                      CSD6.

00000d1b <Web_CSD_Number5>:
     d1b:	22 a2 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d2b <var_CSD_Number5>:
     d2b:	43 53 44 35 00                                      CSD5.

00000d30 <Web_CSD_Number4>:
     d30:	22 95 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d40 <var_CSD_Number4>:
     d40:	43 53 44 34 00                                      CSD4.

00000d45 <Web_CSD_Number3>:
     d45:	22 88 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d55 <var_CSD_Number3>:
     d55:	43 53 44 33 00                                      CSD3.

00000d5a <Web_CSD_Number2>:
     d5a:	22 7b 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "{..............

00000d6a <var_CSD_Number2>:
     d6a:	43 53 44 32 00                                      CSD2.

00000d6f <Web_CSD_Number1>:
     d6f:	22 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "n..............

00000d7f <var_CSD_Number1>:
     d7f:	43 53 44 31 00                                      CSD1.

00000d84 <Web_CSD_Number0>:
     d84:	22 61 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "a..............

00000d94 <var_CSD_Number0>:
     d94:	43 53 44 30 00                                      CSD0.

00000d99 <Web_CLIP>:
     d99:	01 5f 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ._..............

00000da9 <var_CLIP>:
     da9:	43 4c 49 50 4f 6e 00                                CLIPOn.

00000db0 <csd_page>:
     db0:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     dc0:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     dd0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     de0:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     df0:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     e00:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     e10:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     e20:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     e30:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     e40:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     e50:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     e60:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     e70:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     e80:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     e90:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     ea0:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     eb0:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     ec0:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     ed0:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     ee0:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     ef0:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     f00:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     f10:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     f20:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     f30:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     f40:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     f50:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     f60:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     f70:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     f80:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     f90:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     fa0:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f     .</a>..<HR>..<fo
     fb0:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
     fc0:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0     thod='GET'>.....
     fd0:	ee e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a     ...... ......:..
     fe0:	09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43     .<SELECT NAME="C
     ff0:	4c 49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49     LIPOn"> ...<OPTI
    1000:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    1010:	7b 7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49     {{{>... ...<OPTI
    1020:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    1030:	7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43     {{{>.....</SELEC
    1040:	54 3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T> ...<input typ
    1050:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    1060:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    1070:	0a 3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5     .<h3>...........
    1080:	20 ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52      ......</h3></BR
    1090:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    10a0:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10b0:	3e 0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75     >....1: ...<inpu
    10c0:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    10d0:	6d 65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27     me='CSD0' size='
    10e0:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    10f0:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1100:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1110:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1120:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1130:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1140:	47 45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c     GET'>....2: ...<
    1150:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1160:	27 20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69     ' name='CSD1' si
    1170:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    1180:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    1190:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    11a0:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    11b0:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    11c0:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    11d0:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20     od='GET'>....3: 
    11e0:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    11f0:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32     text' name='CSD2
    1200:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1210:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1220:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1230:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1240:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    1250:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    1260:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    1270:	b9 34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .4: ...<input ty
    1280:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    1290:	43 53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD3' size='12' 
    12a0:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    12b0:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    12c0:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    12d0:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    12e0:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    12f0:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1300:	3e 0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75     >....5: ...<inpu
    1310:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1320:	6d 65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27     me='CSD4' size='
    1330:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1340:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1350:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1360:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1370:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1380:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1390:	47 45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c     GET'>....6: ...<
    13a0:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    13b0:	27 20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69     ' name='CSD5' si
    13c0:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    13d0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    13e0:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    13f0:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    1400:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    1410:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1420:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20     od='GET'>....7: 
    1430:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    1440:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36     text' name='CSD6
    1450:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1460:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1470:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1480:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1490:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    14a0:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    14b0:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    14c0:	b9 38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .8: ...<input ty
    14d0:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    14e0:	43 53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD7' size='12' 
    14f0:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    1500:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    1510:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    1520:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    1530:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    1540:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1550:	3e 0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75     >....9: ...<inpu
    1560:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1570:	6d 65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27     me='CSD8' size='
    1580:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1590:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    15a0:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    15b0:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    15c0:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    15d0:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    15e0:	47 45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09     GET'>....10: ...
    15f0:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    1600:	74 27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73     t' name='CSD9' s
    1610:	69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27     ize='12' value='
    1620:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a     {{{{{{{{{{{{'>..
    1630:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    1640:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    1650:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    1660:	3e 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     >.. </BODY>..</H
    1670:	54 4d 4c 3e 0d 0a 00                                TML>...

00001677 <csd_IField>:
    1677:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    1687:	00 00 14 12 06 00 00 00 1e 5f 00 35 45 00 1e 5f     ........._.5E.._
    1697:	00 31 45 00 22 61 00 00 00 0d 22 6e 00 00 00 0d     .1E."a...."n....
    16a7:	22 7b 00 00 00 0d 22 88 00 00 00 0d 22 95 00 00     "{...."....."...
    16b7:	00 0d 22 a2 00 00 00 0d 22 af 00 00 00 0d 22 bc     ..".....".....".
    16c7:	00 00 00 0d 22 c9 00 00 00 0d 22 d6 00 00 00 0d     ....".....".....

000016d7 <name_csd>:
    16d7:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

000016e0 <Web_gsm>:
    16e0:	cb 1c 9b 1c 1c 00 ed 16 cf 04 cc 17 04              .............

000016ed <gsm_OField>:
    16ed:	c3 17 b3 17 a0 17 90 17 83 17 73 17 6d 17 5d 17     ..........s.m.].
    16fd:	51 17 41 17 35 17 25 17 19 17 09 17                 Q.A.5.%.....

00001709 <Web_SMS_Number3>:
    1709:	22 fd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001719 <var_SMS_Number3>:
    1719:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

00001725 <Web_SMS_Number2>:
    1725:	22 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001735 <var_SMS_Number2>:
    1735:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

00001741 <Web_SMS_Number1>:
    1741:	22 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001751 <var_SMS_Number1>:
    1751:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

0000175d <Web_SMS>:
    175d:	01 60 00 00 00 00 00 01 00 00 00 00 00 00 00 00     .`..............

0000176d <var_SMS>:
    176d:	53 4d 53 4f 6e 00                                   SMSOn.

00001773 <Web_GPRS_apn_psw>:
    1773:	22 54 01 00 00 00 00 02 00 00 00 19 2a 00 00 14     "T..........*...

00001783 <var_GPRS_apn_psw>:
    1783:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

00001790 <Web_GPRS_apn_user_name>:
    1790:	22 68 01 00 00 00 00 02 00 00 00 19 2a 00 00 14     "h..........*...

000017a0 <var_GPRS_apn_user_name>:
    17a0:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    17b0:	6d 65 00                                            me.

000017b3 <Web_GPRS_apn1>:
    17b3:	22 7c 01 00 00 00 00 02 00 00 00 19 2a 00 00 1e     "|..........*...

000017c3 <var_GPRS_apn1>:
    17c3:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000017cc <gsm_page>:
    17cc:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    17dc:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    17ec:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    17fc:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    180c:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    181c:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    182c:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    183c:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    184c:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    185c:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    186c:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    187c:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    188c:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    189c:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    18ac:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    18bc:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    18cc:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    18dc:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    18ec:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    18fc:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    190c:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    191c:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    192c:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    193c:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    194c:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    195c:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    196c:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    197c:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    198c:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    199c:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    19ac:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    19bc:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee     .</a>..<HR>.....
    19cc:	e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20     .... ....... {{ 
    19dc:	28 30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33     (0-31)</BR>..<h3
    19ec:	3e 47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d     >GPRS</h3></BR>.
    19fc:	0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f     .<form action='/
    1a0c:	27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d     ' method='GET'>.
    1a1c:	0a 09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c     ..APN name: ...<
    1a2c:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1a3c:	27 20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e     ' name='GPRS_apn
    1a4c:	27 20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75     ' size='29' valu
    1a5c:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    1a6c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    1a7c:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    1a8c:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    1a9c:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    1aac:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    1abc:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1acc:	47 45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d     GET'>...User nam
    1adc:	65 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     e: ...<input typ
    1aec:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47     e='text' name='G
    1afc:	50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d     PRS_apn_user_nam
    1b0c:	65 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     e' size='19' val
    1b1c:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1b2c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1b3c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1b4c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1b5c:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    1b6c:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    1b7c:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50     ethod='GET'>...P
    1b8c:	61 73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70     assword: ...<inp
    1b9c:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    1bac:	61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73     ame='GPRS_apn_ps
    1bbc:	77 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     w' size='19' val
    1bcc:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1bdc:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1bec:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1bfc:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1c0c:	66 6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f     form..</BR>..<FO
    1c1c:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    1c2c:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    1c3c:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    1c4c:	74 27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53     t' name='ResetGS
    1c5c:	4d 27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47     M' value='ResetG
    1c6c:	53 4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     SM'>..</FORM>..<
    1c7c:	2f 42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f     /BR></BR>.. </BO
    1c8c:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

00001c9b <gsm_IField>:
    1c9b:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    1cab:	00 00 14 12 06 00 00 00 00 25 06 00 00 00 22 7c     .........%...."|
    1cbb:	01 00 00 1e 22 68 01 00 00 14 22 54 01 00 00 14     ...."h...."T....

00001ccb <name_gsm>:
    1ccb:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

00001cd4 <Web_network>:
    1cd4:	a3 32 a1 31 a0 00 e1 1c 4a 10 57 21 04              .2.1....J.W!.

00001ce1 <network_OField>:
    1ce1:	48 21 38 21 24 21 14 21 02 21 f2 20 91 1d 81 1d     H!8!$!.!.!. ....
    1cf1:	e9 20 d9 20 d0 20 c0 20 b7 20 a7 20 9e 20 8e 20     . . . . . . . . 
    1d01:	85 20 75 20 6c 20 5c 20 53 20 43 20 3a 20 2a 20     . u l \ S C : * 
    1d11:	21 20 11 20 08 20 f8 1f ef 1f df 1f d6 1f c6 1f     ! . . ..........
    1d21:	bd 1f ad 1f a4 1f 94 1f 8b 1f 7b 1f 72 1f 62 1f     ..........{.r.b.
    1d31:	5c 1f 4c 1f 46 1f 36 1f 30 1f 20 1f 1a 1f 0a 1f     \.L.F.6.0. .....
    1d41:	04 1f f4 1e ee 1e de 1e d8 1e c8 1e c2 1e b2 1e     ................
    1d51:	ac 1e 9c 1e 96 1e 86 1e 80 1e 70 1e 6a 1e 5a 1e     ..........p.j.Z.
    1d61:	54 1e 44 1e 3e 1e 2e 1e 28 1e 18 1e 12 1e 02 1e     T.D.>...(.......
    1d71:	f8 1d e8 1d de 1d ce 1d c4 1d b4 1d aa 1d 9a 1d     ................

00001d81 <Web_ResetGSM>:
    1d81:	00 1f 06 00 00 00 00 ff 00 00 00 f1 28 00 00 00     ............(...

00001d91 <var_ResetGSM>:
    1d91:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00001d9a <Web_UDP3_Port>:
    1d9a:	08 30 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .0..............

00001daa <var_UDP3_Port>:
    1daa:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

00001db4 <Web_UDP2_Port>:
    1db4:	08 2e 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00001dc4 <var_UDP2_Port>:
    1dc4:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00001dce <Web_UDP1_Port>:
    1dce:	08 2c 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .,..............

00001dde <var_UDP1_Port>:
    1dde:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

00001de8 <Web_UDP0_Port>:
    1de8:	08 2a 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .*..............

00001df8 <var_UDP0_Port>:
    1df8:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

00001e02 <Web_UDP3_IP4>:
    1e02:	01 51 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Q..............

00001e12 <var_UDP3_IP4>:
    1e12:	55 44 50 33 34 00                                   UDP34.

00001e18 <Web_UDP3_IP3>:
    1e18:	01 50 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .P..............

00001e28 <var_UDP3_IP3>:
    1e28:	55 44 50 33 33 00                                   UDP33.

00001e2e <Web_UDP3_IP2>:
    1e2e:	01 4f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .O..............

00001e3e <var_UDP3_IP2>:
    1e3e:	55 44 50 33 32 00                                   UDP32.

00001e44 <Web_UDP3_IP1>:
    1e44:	01 4e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .N..............

00001e54 <var_UDP3_IP1>:
    1e54:	55 44 50 33 31 00                                   UDP31.

00001e5a <Web_UDP2_IP4>:
    1e5a:	01 4d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .M..............

00001e6a <var_UDP2_IP4>:
    1e6a:	55 44 50 32 34 00                                   UDP24.

00001e70 <Web_UDP2_IP3>:
    1e70:	01 4c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .L..............

00001e80 <var_UDP2_IP3>:
    1e80:	55 44 50 32 33 00                                   UDP23.

00001e86 <Web_UDP2_IP2>:
    1e86:	01 4b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .K..............

00001e96 <var_UDP2_IP2>:
    1e96:	55 44 50 32 32 00                                   UDP22.

00001e9c <Web_UDP2_IP1>:
    1e9c:	01 4a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .J..............

00001eac <var_UDP2_IP1>:
    1eac:	55 44 50 32 31 00                                   UDP21.

00001eb2 <Web_UDP1_IP4>:
    1eb2:	01 49 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .I..............

00001ec2 <var_UDP1_IP4>:
    1ec2:	55 44 50 31 34 00                                   UDP14.

00001ec8 <Web_UDP1_IP3>:
    1ec8:	01 48 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .H..............

00001ed8 <var_UDP1_IP3>:
    1ed8:	55 44 50 31 33 00                                   UDP13.

00001ede <Web_UDP1_IP2>:
    1ede:	01 47 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .G..............

00001eee <var_UDP1_IP2>:
    1eee:	55 44 50 31 32 00                                   UDP12.

00001ef4 <Web_UDP1_IP1>:
    1ef4:	01 46 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .F..............

00001f04 <var_UDP1_IP1>:
    1f04:	55 44 50 31 31 00                                   UDP11.

00001f0a <Web_UDP0_IP4>:
    1f0a:	01 45 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .E..............

00001f1a <var_UDP0_IP4>:
    1f1a:	55 44 50 30 34 00                                   UDP04.

00001f20 <Web_UDP0_IP3>:
    1f20:	01 44 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .D..............

00001f30 <var_UDP0_IP3>:
    1f30:	55 44 50 30 33 00                                   UDP03.

00001f36 <Web_UDP0_IP2>:
    1f36:	01 43 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .C..............

00001f46 <var_UDP0_IP2>:
    1f46:	55 44 50 30 32 00                                   UDP02.

00001f4c <Web_UDP0_IP1>:
    1f4c:	01 42 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .B..............

00001f5c <var_UDP0_IP1>:
    1f5c:	55 44 50 30 31 00                                   UDP01.

00001f62 <Web_Cli3_IP4>:
    1f62:	01 1f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f72 <var_Cli3_IP4>:
    1f72:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00001f7b <Web_Cli3_IP3>:
    1f7b:	01 1e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f8b <var_Cli3_IP3>:
    1f8b:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00001f94 <Web_Cli3_IP2>:
    1f94:	01 1d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fa4 <var_Cli3_IP2>:
    1fa4:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00001fad <Web_Cli3_IP1>:
    1fad:	01 1c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fbd <var_Cli3_IP1>:
    1fbd:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00001fc6 <Web_Cli2_IP4>:
    1fc6:	01 1b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fd6 <var_Cli2_IP4>:
    1fd6:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

00001fdf <Web_Cli2_IP3>:
    1fdf:	01 1a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fef <var_Cli2_IP3>:
    1fef:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00001ff8 <Web_Cli2_IP2>:
    1ff8:	01 19 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002008 <var_Cli2_IP2>:
    2008:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

00002011 <Web_Cli2_IP1>:
    2011:	01 18 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002021 <var_Cli2_IP1>:
    2021:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

0000202a <Web_Cli1_IP4>:
    202a:	01 17 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000203a <var_Cli1_IP4>:
    203a:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

00002043 <Web_Cli1_IP3>:
    2043:	01 16 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002053 <var_Cli1_IP3>:
    2053:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

0000205c <Web_Cli1_IP2>:
    205c:	01 15 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000206c <var_Cli1_IP2>:
    206c:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

00002075 <Web_Cli1_IP1>:
    2075:	01 14 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002085 <var_Cli1_IP1>:
    2085:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

0000208e <Web_Cli0_IP4>:
    208e:	01 13 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000209e <var_Cli0_IP4>:
    209e:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

000020a7 <Web_Cli0_IP3>:
    20a7:	01 12 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020b7 <var_Cli0_IP3>:
    20b7:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

000020c0 <Web_Cli0_IP2>:
    20c0:	01 11 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020d0 <var_Cli0_IP2>:
    20d0:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

000020d9 <Web_Cli0_IP1>:
    20d9:	01 10 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020e9 <var_Cli0_IP1>:
    20e9:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

000020f2 <Web_WebMaxSessionTime>:
    20f2:	11 56 00 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .V........;.....

00002102 <var_WebMaxSessionTime>:
    2102:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    2112:	65 00                                               e.

00002114 <Web_TCP_CONNECT_timeout>:
    2114:	08 0e 01 00 00 00 00 ff ff 00 00 19 2a 00 00 02     ............*...

00002124 <var_TCP_CONNECT_timeout>:
    2124:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2134:	6f 75 74 00                                         out.

00002138 <Web_TCP_ListenPort>:
    2138:	08 20 01 00 00 00 00 ff ff 00 00 19 2a 00 00 00     . ..........*...

00002148 <var_TCP_ListenPort>:
    2148:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

00002157 <network_page>:
    2157:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    2167:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    2177:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    2187:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    2197:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    21a7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    21b7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    21c7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    21d7:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    21e7:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    21f7:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    2207:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    2217:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    2227:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    2237:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    2247:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    2257:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    2267:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    2277:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    2287:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    2297:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    22a7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    22b7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    22c7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    22d7:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    22e7:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    22f7:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    2307:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    2317:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    2327:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    2337:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    2347:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
    2357:	68 33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72     h3>TCP/IP Server
    2367:	3c 2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </h3>..<form act
    2377:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    2387:	47 45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70     GET'>...Listen p
    2397:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    23a7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    23b7:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20     TCP_ListenPort' 
    23c7:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    23d7:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    23e7:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    23f7:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2407:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2417:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2427:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50     hod='GET'>...TCP
    2437:	2f 49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74     /IP connection t
    2447:	69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74     imeout:...<input
    2457:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    2467:	65 3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74     e='TCP_CONNECT_t
    2477:	69 6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27     imeout' size='7'
    2487:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e      value='{{{{{{'>
    2497:	73 65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     sec...<input typ
    24a7:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    24b7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    24c7:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
    24d7:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    24e7:	27 47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e     'GET'>...Session
    24f7:	20 74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70      timeout:...<inp
    2507:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2517:	61 6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69     ame='WebMaxSessi
    2527:	6f 6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27     onTime' size='7'
    2537:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b      value='{{{{{{{{
    2547:	7b 7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74     {{'>sec...<input
    2557:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2567:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2577:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68     rm>..</BR>....<h
    2587:	33 3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68     3>IP Firewall</h
    2597:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    25a7:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    25b7:	27 3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70     '>...IP1:...<inp
    25c7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    25d7:	61 6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73     ame='Cli0_IP1' s
    25e7:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    25f7:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2607:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2617:	27 43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d     'Cli0_IP2' size=
    2627:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2637:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2647:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    2657:	30 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20     0_IP3' size='3' 
    2667:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2677:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2687:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50     t' name='Cli0_IP
    2697:	34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     4' size='3' valu
    26a7:	65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     e='{{{'>...<inpu
    26b7:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    26c7:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    26d7:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    26e7:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    26f7:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50     thod='GET'>...IP
    2707:	32 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     2:...<input type
    2717:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    2727:	69 31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27     i1_IP1' size='3'
    2737:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    2747:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    2757:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49     xt' name='Cli1_I
    2767:	50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P2' size='3' val
    2777:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2787:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2797:	6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20     name='Cli1_IP3' 
    27a7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    27b7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    27c7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    27d7:	3d 27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65     ='Cli1_IP4' size
    27e7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    27f7:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2807:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2817:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2827:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    2837:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    2847:	45 54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69     ET'>...IP3:...<i
    2857:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2867:	20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27      name='Cli2_IP1'
    2877:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    2887:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    2897:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    28a7:	65 3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a     e='Cli2_IP2' siz
    28b7:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    28c7:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    28d7:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    28e7:	6c 69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33     li2_IP3' size='3
    28f7:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    2907:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2917:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f     ext' name='Cli2_
    2927:	49 50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP4' size='3' va
    2937:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     lue='{{{'>...<in
    2947:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    2957:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    2967:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c     /form>..</BR>..<
    2977:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    2987:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    2997:	49 50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     IP4:...<input ty
    29a7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29b7:	43 6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27     Cli3_IP1' size='
    29c7:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    29d7:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    29e7:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33     text' name='Cli3
    29f7:	5f 49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP2' size='3' v
    2a07:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2a17:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2a27:	27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33     ' name='Cli3_IP3
    2a37:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2a47:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2a57:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a67:	6d 65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69     me='Cli3_IP4' si
    2a77:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2a87:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2a97:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2aa7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2ab7:	0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63     .</BR>..<FORM ac
    2ac7:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2ad7:	27 47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     'GET'>...<input 
    2ae7:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61     type='submit' na
    2af7:	6d 65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61     me='ResetGSM' va
    2b07:	6c 75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d     lue='ResetGSM'>.
    2b17:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
    2b27:	0a 0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0     .....<h3>.......
    2b37:	20 f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a      ....... ......:
    2b47:	3c 2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a     </h3>..</BR>....
    2b57:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    2b67:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    2b77:	55 44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d     UDP Server1 IP:.
    2b87:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2b97:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31     ext' name='UDP01
    2ba7:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2bb7:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2bc7:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2bd7:	6d 65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d     me='UDP02' size=
    2be7:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2bf7:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2c07:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2c17:	30 33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     03' size='3' val
    2c27:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2c37:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2c47:	6e 61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a     name='UDP04' siz
    2c57:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2c67:	27 3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70     '>..Port:...<inp
    2c77:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2c87:	61 6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20     ame='UDP0_Port' 
    2c97:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2ca7:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2cb7:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2cc7:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2cd7:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2ce7:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2cf7:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20     hod='GET'>..UDP 
    2d07:	53 65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69     Server2 IP:...<i
    2d17:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2d27:	20 6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69      name='UDP11' si
    2d37:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2d47:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2d57:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2d67:	55 44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20     UDP12' size='3' 
    2d77:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2d87:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2d97:	74 27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20     t' name='UDP13' 
    2da7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2db7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2dc7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2dd7:	3d 27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33     ='UDP14' size='3
    2de7:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a     ' value='{{{'>..
    2df7:	50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74     Port:...<input t
    2e07:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2e17:	27 55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65     'UDP1_Port' size
    2e27:	3d 27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b     ='5' value='{{{{
    2e37:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2e47:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2e57:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2e67:	0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20     .</BR>....<form 
    2e77:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    2e87:	64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65     d='GET'>..UDP Se
    2e97:	72 76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70     rver3 IP:...<inp
    2ea7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2eb7:	61 6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65     ame='UDP21' size
    2ec7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2ed7:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    2ee7:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2ef7:	50 32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P22' size='3' va
    2f07:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    2f17:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2f27:	20 6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69      name='UDP23' si
    2f37:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2f47:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2f57:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2f67:	55 44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20     UDP24' size='3' 
    2f77:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f     value='{{{'>..Po
    2f87:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    2f97:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2fa7:	44 50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27     DP2_Port' size='
    2fb7:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    2fc7:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2fd7:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2fe7:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2ff7:	2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63     /BR>....<form ac
    3007:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    3017:	27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76     'GET'>..UDP Serv
    3027:	65 72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74     er4 IP:...<input
    3037:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3047:	65 3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27     e='UDP31' size='
    3057:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    3067:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    3077:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    3087:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    3097:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    30a7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    30b7:	61 6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65     ame='UDP33' size
    30c7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    30d7:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    30e7:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    30f7:	50 33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P34' size='3' va
    3107:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74     lue='{{{'>..Port
    3117:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    3127:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    3137:	33 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27     3_Port' size='5'
    3147:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d      value='{{{{{'>.
    3157:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    3167:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    3177:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    3187:	52 3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a     R>.... </BODY>..
    3197:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

000031a1 <network_IField>:
    31a1:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    31b1:	00 00 14 12 06 00 00 00 08 20 01 00 00 00 08 0e     ......... ......
    31c1:	01 00 00 02 11 56 00 00 00 02 01 10 01 00 00 00     .....V..........
    31d1:	01 11 01 00 00 00 01 12 01 00 00 00 01 13 01 00     ................
    31e1:	00 00 01 14 01 00 00 00 01 15 01 00 00 00 01 16     ................
    31f1:	01 00 00 00 01 17 01 00 00 00 01 18 01 00 00 00     ................
    3201:	01 19 01 00 00 00 01 1a 01 00 00 00 01 1b 01 00     ................
    3211:	00 00 01 1c 01 00 00 00 01 1d 01 00 00 00 01 1e     ................
    3221:	01 00 00 00 01 1f 01 00 00 00 01 42 01 00 00 00     ...........B....
    3231:	01 43 01 00 00 00 01 44 01 00 00 00 01 45 01 00     .C.....D.....E..
    3241:	00 00 08 2a 01 00 00 00 01 46 01 00 00 00 01 47     ...*.....F.....G
    3251:	01 00 00 00 01 48 01 00 00 00 01 49 01 00 00 00     .....H.....I....
    3261:	08 2c 01 00 00 00 01 4a 01 00 00 00 01 4b 01 00     .,.....J.....K..
    3271:	00 00 01 4c 01 00 00 00 01 4d 01 00 00 00 08 2e     ...L.....M......
    3281:	01 00 00 00 01 4e 01 00 00 00 01 4f 01 00 00 00     .....N.....O....
    3291:	01 50 01 00 00 00 01 51 01 00 00 00 08 30 01 00     .P.....Q.....0..
	...

000032a3 <name_network>:
    32a3:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

000032b0 <Web_name_access_error>:
    32b0:	d7 33 00 00 00 00 00 00 1a 01 bd 32 00              .3.........2.

000032bd <name_access_error_page>:
    32bd:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    32cd:	3c 54 49 54 4c 45 3e ce f8 e8 e1 ea e0 20 e4 ee     <TITLE>...... ..
    32dd:	f1 f2 f3 ef e0 3c 2f 54 49 54 4c 45 3e 0d 0a 3c     .....</TITLE>..<
    32ed:	6d 65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d     meta http-equiv=
    32fd:	22 43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63     "Content-Type" c
    330d:	6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d     ontent="text/htm
    331d:	6c 3b 20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f     l; charset=windo
    332d:	77 73 2d 31 32 35 31 22 3e 0d 0a 3c 2f 48 45 41     ws-1251">..</HEA
    333d:	44 3e 0d 0a 3c 63 65 6e 74 65 72 3e 0d 0a 3c 68     D>..<center>..<h
    334d:	65 61 64 3e 0d 0a 3c 68 33 3e c2 e0 f8 20 f3 f0     ead>..<h3>... ..
    335d:	ee e2 e5 ed fc 20 e4 ee f1 f2 f3 ef e0 20 ed e5     ..... ....... ..
    336d:	20 ef ee e7 e2 ee eb ff e5 f2 20 ef f0 ee f1 ec      ......... .....
    337d:	e0 f2 f0 e8 e2 e0 f2 fc 20 fd f2 f3 20 f1 f2 f0     ........ ... ...
    338d:	e0 ed e8 f6 f3 3c 2f 68 33 3e 0d 0a 3c 61 20 68     .....</h3>..<a h
    339d:	72 65 66 3d 22 69 6e 64 65 78 2e 68 74 6d 6c 22     ref="index.html"
    33ad:	3e cd e0 e7 e0 e4 20 ed e0 20 e3 eb e0 e2 ed f3     >..... .. ......
    33bd:	fe 20 f1 f2 f0 e0 ed e8 f6 f3 3c 2f 61 3e 0d 0a     . ........</a>..
    33cd:	3c 2f 68 74 6d 6c 3e 0d 0a 00                       </html>...

000033d7 <name_access_error>:
    33d7:	61 63 63 65 73 73 5f 65 72 72 6f 72 2e 68 74 6d     access_error.htm
    33e7:	6c 00                                               l.

000033e9 <Web_favicon>:
    33e9:	74 39 00 00 00 00 00 00 7e 05 f6 33 00              t9......~..3.

000033f6 <favicon>:
    33f6:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    3406:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    3416:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    3426:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    3436:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    3446:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    3456:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    3466:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    3476:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    3486:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    3496:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    34a6:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    34b6:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    34c6:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    3832:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3842:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3852:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    3862:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    3872:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    3882:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    3892:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    38a2:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    38b2:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    38c2:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    38d2:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    38e2:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    38f2:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    3902:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    3912:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3922:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3932:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00003974 <name_favicon>:
    3974:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

00003980 <Web_emeter>:
    3980:	4b 45 57 43 1c 00 8d 39 00 09 57 3a 02              KEWC...9..W:.

0000398d <emeter_OField>:
    398d:	4c 3a 3c 3a 37 3a 27 3a 21 3a 11 3a 0a 3a fa 39     L:<:7:':!:.:.:.9
    399d:	f1 39 e1 39 b9 39 a9 39 d8 39 c8 39                 .9.9.9.9.9.9

000039a9 <Web_CurrDataPeriod>:
    39a9:	08 08 00 3c 00 00 00 ff ff 00 00 00 00 00 00 00     ...<............

000039b9 <var_CurrDataPeriod>:
    39b9:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

000039c8 <Web_AutoSend>:
    39c8:	01 0a 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

000039d8 <var_AutoSend>:
    39d8:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

000039e1 <Web_EM_UART_StopBits>:
    39e1:	00 42 09 00 00 00 00 01 00 00 00 60 4b 00 00 00     .B.........`K...

000039f1 <var_EM_UART_StopBits>:
    39f1:	53 74 6f 70 42 69 74 73 00                          StopBits.

000039fa <Web_EM_UART_Parity>:
    39fa:	00 0c 06 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00003a0a <var_EM_UART_Parity>:
    3a0a:	50 61 72 69 74 79 00                                Parity.

00003a11 <Web_EM_UART_BitQt>:
    3a11:	00 72 0a 00 00 00 00 03 00 00 00 00 00 00 00 00     .r..............

00003a21 <var_EM_UART_BitQt>:
    3a21:	42 69 74 51 74 00                                   BitQt.

00003a27 <Web_EM_UART_Rate>:
    3a27:	00 6b 0a 00 00 00 00 08 00 00 00 00 00 00 00 00     .k..............

00003a37 <var_EM_UART_Rate>:
    3a37:	52 61 74 65 00                                      Rate.

00003a3c <Web_EMeterType>:
    3a3c:	01 29 00 00 00 00 00 04 00 00 00 8c 4b 00 00 00     .)..........K...

00003a4c <var_EMeterType>:
    3a4c:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

00003a57 <emeter_page>:
    3a57:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3a67:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3a77:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3a87:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3a97:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3aa7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3ab7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3ac7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    3ad7:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    3ae7:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    3af7:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    3b07:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    3b17:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    3b27:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    3b37:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3b47:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3b57:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3b67:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    3b77:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    3b87:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3b97:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    3ba7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    3bb7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    3bc7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    3bd7:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    3be7:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    3bf7:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    3c07:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    3c17:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    3c27:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    3c37:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    3c47:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    3c57:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    3c67:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    3c77:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    3c87:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    3c97:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    3ca7:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    3cb7:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    3cc7:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42     {{{{ ....*...</B
    3cd7:	52 3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea     R>..<h3>... ....
    3ce7:	f2 f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33     ...........:</h3
    3cf7:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    3d07:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    3d17:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    3d27:	3d 22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d     ="EMeterType"> .
    3d37:	0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    3d47:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    3d57:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    3d67:	7b 7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26     {{{{{{{{>Landis&
    3d77:	47 79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     Gyr..<OPTION VAL
    3d87:	55 45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb     UE=2 {{{{{{{{>..
    3d97:	c2 c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     .....<OPTION VAL
    3da7:	55 45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5     UE=3 {{{{{{{{>..
    3db7:	f0 ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49     ......230..<OPTI
    3dc7:	4f 4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b     ON VALUE=4 {{{{{
    3dd7:	7b 7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d     {{{>..... ......
    3de7:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c     ..</SELECT> ...<
    3df7:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e07:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e17:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d     .</form>..</BR>.
    3e27:	0a 0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb     ...<h3>.........
    3e37:	20 52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68      RS232/RS485:</h
    3e47:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    3e57:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    3e67:	27 3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a     '>.............:
    3e77:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    3e87:	22 52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49     "Rate"> ...<OPTI
    3e97:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    3ea7:	7b 7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f     {{{>1200bps...<O
    3eb7:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b     PTION VALUE=1 {{
    3ec7:	7b 7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a     {{{{{{>2400bps..
    3ed7:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32     .<OPTION VALUE=2
    3ee7:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70      {{{{{{{{>4800bp
    3ef7:	73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     s...<OPTION VALU
    3f07:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30     E=3 {{{{{{{{>960
    3f17:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3f27:	41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=4 {{{{{{{{>
    3f37:	31 34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49     14400bps...<OPTI
    3f47:	4f 4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b     ON VALUE=5 {{{{{
    3f57:	7b 7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c     {{{>19200bps...<
    3f67:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b     OPTION VALUE=6 {
    3f77:	7b 7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73     {{{{{{{>28800bps
    3f87:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    3f97:	3d 37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30     =7 {{{{{{{{>3840
    3fa7:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3fb7:	41 4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=8 {{{{{{{{>
    3fc7:	35 37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c     57600bps...</SEL
    3fd7:	45 43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1     ECT>............
    3fe7:	f2 e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45     ... ...:...<SELE
    3ff7:	43 54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e     CT NAME="BitQt">
    4007:	20 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55      ...<OPTION VALU
    4017:	45 3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a     E=0 {{{{{{{{>5..
    4027:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4037:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f      {{{{{{{{>6...<O
    4047:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4057:	7b 7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49     {{{{{{>7...<OPTI
    4067:	4f 4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b     ON VALUE=3 {{{{{
    4077:	7b 7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{{>8...</SELECT
    4087:	3e 20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a     > .............:
    4097:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    40a7:	22 50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50     "Parity"> ...<OP
    40b7:	54 49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b     TION VALUE=0 {{{
    40c7:	7b 7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54     {{{{{>......<OPT
    40d7:	49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b     ION VALUE=1 {{{{
    40e7:	7b 7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f     {{{{>.........<O
    40f7:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4107:	7b 7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d     {{{{{{>.........
    4117:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a     ..</SELECT> ....
    4127:	09 d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53     .....-....:...<S
    4137:	45 4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70     ELECT NAME="Stop
    4147:	42 69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Bits"> ...<OPTIO
    4157:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    4167:	7b 7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     {{>1...<OPTION V
    4177:	41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=1 {{{{{{{{>
    4187:	32 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a     2...</SELECT> ..
    4197:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    41a7:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    41b7:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    41c7:	42 52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1     BR>..<h3>..... .
    41d7:	f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42     .......:</h3></B
    41e7:	52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     R>..<form action
    41f7:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    4207:	27 3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d     '>...<SELECT NAM
    4217:	45 3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a     E="AutoSend"> ..
    4227:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    4237:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    4247:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4257:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c      {{{{{{{{>.....<
    4267:	2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70     /SELECT> ...<inp
    4277:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    4287:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    4297:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    42a7:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    42b7:	47 45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d     GET'>.. ......:.
    42c7:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    42d7:	65 78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44     ext' name='CurrD
    42e7:	61 74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d     ataPeriod' size=
    42f7:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    4307:	27 3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75     '>.........<inpu
    4317:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    4327:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    4337:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42     orm>..</BR>..</B
    4347:	4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00     ODY>..</HTML>...

00004357 <emeter_IField>:
    4357:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    4367:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    4377:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    4387:	1e 29 00 27 45 00 1e 29 00 1d 45 00 1e 29 00 13     .).'E..)..E..)..
    4397:	45 00 1e 29 00 09 45 00 1e 29 00 ff 44 00 1d 6b     E..)..E..)..D..k
    43a7:	0a ed 44 00 1d 6b 0a db 44 00 1d 6b 0a c9 44 00     ..D..k..D..k..D.
    43b7:	1d 6b 0a b7 44 00 1d 6b 0a a5 44 00 1d 6b 0a 93     .k..D..k..D..k..
    43c7:	44 00 1d 6b 0a 81 44 00 1d 6b 0a 6f 44 00 1d 6b     D..k..D..k.oD..k
    43d7:	0a 5d 44 00 1d 72 0a 55 44 00 1d 72 0a 4d 44 00     .]D..r.UD..r.MD.
    43e7:	1d 72 0a 45 44 00 1d 72 0a 3d 44 00 1d 0c 06 37     .r.ED..r.=D....7
    43f7:	44 00 1d 0c 06 31 44 00 1d 0c 06 2b 44 00 1d 42     D....1D....+D..B
    4407:	09 27 44 00 1d 42 09 23 44 00 1e 0a 00 35 45 00     .'D..B.#D....5E.
    4417:	1e 0a 00 31 45 00 08 08 00 00 00 00                 ...1E.......

00004423 <STB_2_List>:
    4423:	42 45 39 45                                         BE9E

00004427 <STB_1_List>:
    4427:	39 45 42 45                                         9EBE

0000442b <PAR_O_List>:
    442b:	42 45 42 45 39 45                                   BEBE9E

00004431 <PAR_E_List>:
    4431:	42 45 39 45 42 45                                   BE9EBE

00004437 <PAR_N_List>:
    4437:	39 45 42 45 42 45                                   9EBEBE

0000443d <BIT8_List>:
    443d:	42 45 42 45 42 45 39 45                             BEBEBE9E

00004445 <BIT7_List>:
    4445:	42 45 42 45 39 45 42 45                             BEBE9EBE

0000444d <BIT6_List>:
    444d:	42 45 39 45 42 45 42 45                             BE9EBEBE

00004455 <BIT5_List>:
    4455:	39 45 42 45 42 45 42 45                             9EBEBEBE

0000445d <BR57600_List>:
    445d:	42 45 42 45 42 45 42 45 42 45 42 45 42 45 42 45     BEBEBEBEBEBEBEBE
    446d:	39 45                                               9E

0000446f <BR34800_List>:
    446f:	42 45 42 45 42 45 42 45 42 45 42 45 42 45 39 45     BEBEBEBEBEBEBE9E
    447f:	42 45                                               BE

00004481 <BR28800_List>:
    4481:	42 45 42 45 42 45 42 45 42 45 42 45 39 45 42 45     BEBEBEBEBEBE9EBE
    4491:	42 45                                               BE

00004493 <BR19200_List>:
    4493:	42 45 42 45 42 45 42 45 42 45 39 45 42 45 42 45     BEBEBEBEBE9EBEBE
    44a3:	42 45                                               BE

000044a5 <BR14400_List>:
    44a5:	42 45 42 45 42 45 42 45 39 45 42 45 42 45 42 45     BEBEBEBE9EBEBEBE
    44b5:	42 45                                               BE

000044b7 <BR9600_List>:
    44b7:	42 45 42 45 42 45 39 45 42 45 42 45 42 45 42 45     BEBEBE9EBEBEBEBE
    44c7:	42 45                                               BE

000044c9 <BR4800_List>:
    44c9:	42 45 42 45 39 45 42 45 42 45 42 45 42 45 42 45     BEBE9EBEBEBEBEBE
    44d9:	42 45                                               BE

000044db <BR2400_List>:
    44db:	42 45 39 45 42 45 42 45 42 45 42 45 42 45 42 45     BE9EBEBEBEBEBEBE
    44eb:	42 45                                               BE

000044ed <BR1200_List>:
    44ed:	39 45 42 45 42 45 42 45 42 45 42 45 42 45 42 45     9EBEBEBEBEBEBEBE
    44fd:	42 45                                               BE

000044ff <ELVIN_MODEM_List>:
    44ff:	42 45 42 45 42 45 42 45 39 45                       BEBEBEBE9E

00004509 <MERCURY_230_List>:
    4509:	42 45 42 45 42 45 39 45 42 45                       BEBEBE9EBE

00004513 <ELVIN_List>:
    4513:	42 45 42 45 39 45 42 45 42 45                       BEBE9EBEBE

0000451d <LANDIS_GYR_ZMR110_List>:
    451d:	42 45 39 45 42 45 42 45 42 45                       BE9EBEBEBE

00004527 <EM_NONE_List>:
    4527:	39 45 42 45 42 45 42 45 42 45                       9EBEBEBEBE

00004531 <ON_List>:
    4531:	42 45 39 45                                         BE9E

00004535 <OFF_List>:
    4535:	39 45 42 45                                         9EBE

00004539 <Selected_Str>:
    4539:	73 65 6c 65 63 74 65 64 00                          selected.

00004542 <Space_Str>:
    4542:	20 20 20 20 20 20 20 20 00                                  .

0000454b <name_emeter>:
    454b:	65 6d 65 74 65 72 2e 68 74 6d 6c 00                 emeter.html.

00004557 <Web_index>:
    4557:	8a 48 4e 48 00 00 00 00 ea 02 64 45 00              .HNH......dE.

00004564 <index_page>:
    4564:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4574:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4584:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4594:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    45a4:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    45b4:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    45c4:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    45d4:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    45e4:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    45f4:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    4604:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    4614:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    4624:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    4634:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    4644:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4654:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4664:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    4674:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    4684:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    4694:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    46a4:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    46b4:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    46c4:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    46d4:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    46e4:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    46f4:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    4704:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    4714:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    4724:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    4734:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    4744:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    4754:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    4764:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    4774:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    4784:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    4794:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    47a4:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    47b4:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    47c4:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    47d4:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 68 33     {{{{ ....*...<h3
    47e4:	3e d3 f0 ee e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0     >....... .......
    47f4:	3a 3c 2f 68 33 3e 0d 0a 20 7b 7b 20 28 30 2d 33     :</h3>.. {{ (0-3
    4804:	31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e cd e0 f0     1)</BR>..<h3>...
    4814:	e0 e1 ee f2 ea e0 20 3a 3c 2f 68 33 3e 0d 0a 7b     ...... :</h3>..{
    4824:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a     {{{{{{{{{{ .....
    4834:	3c 2f 42 52 3e 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     </BR>..</BODY>..
    4844:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

0000484e <index_IField>:
    484e:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    485e:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    486e:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    487e:	00 25 06 00 00 00 10 63 09 00 00 02                 .%.....c....

0000488a <name_index>:
    488a:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

00004895 <Web_login>:
    4895:	a4 4b bc 4a 08 00 a2 48 e3 01 d9 48 00              .K.J...H...H.

000048a2 <vars_loginOField>:
    48a2:	d3 48 c3 48 ba 48 aa 48                             .H.H.H.H

000048aa <Web_PasswOF>:
    48aa:	21 f4 05 00 00 00 00 02 00 00 00 f9 28 00 00 0b     !...........(...

000048ba <vars_Passw>:
    48ba:	70 61 73 73 77 6f 72 64 00                          password.

000048c3 <Web_LoginOF>:
    48c3:	21 f7 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !...............

000048d3 <vars_Login>:
    48d3:	6c 6f 67 69 6e 00                                   login.

000048d9 <login_page>:
    48d9:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    48e9:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    48f9:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4909:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    4919:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    4929:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    4939:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4949:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    4959:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
    4969:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
    4979:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4989:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4999:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49a9:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
    49b9:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
    49c9:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
    49d9:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    49e9:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
    49f9:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
    4a09:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
    4a19:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
    4a29:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
    4a39:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
    4a49:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
    4a59:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
    4a69:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
    4a79:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    4a89:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    4a99:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
    4aa9:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
    4ab9:	0d 0a 00                                            ...

00004abc <login_InField>:
    4abc:	22 0f 00 00 00 15 1d 09 06 d4 4a 00 07 27 0b 00     ".........J..'..
    4acc:	00 00 14 12 06 00 00 00                             ........

00004ad4 <Web_LoginMsg_List>:
    4ad4:	72 4b 40 4b 0e 4b dc 4a                             rK@K.K.J

00004adc <Login_PSW_Str>:
    4adc:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
    4aec:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
    4afc:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b0c:	20 00                                                .

00004b0e <Login_Login_Str>:
    4b0e:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
    4b1e:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
    4b2e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b3e:	20 00                                                .

00004b40 <Login_Busy_Str>:
    4b40:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
    4b50:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
    4b60:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
    4b70:	2e 00                                               ..

00004b72 <Login_Welcome_Str>:
    4b72:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
    4b82:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
    4b92:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
    4ba2:	20 00                                                .

00004ba4 <name_login>:
    4ba4:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

00004baf <METHOD_POST>:
    4baf:	50 4f 53 54 20 2f 00                                POST /.

00004bb6 <METHOD_GET>:
    4bb6:	47 45 54 20 2f 00                                   GET /.

00004bbc <Web_error_page>:
	...
    4bc4:	75 00 c9 4b 00                                      u..K.

00004bc9 <error_page>:
    4bc9:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    4bd9:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
    4be9:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
    4bf9:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
    4c09:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
    4c19:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
    4c29:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
    4c39:	2f 68 31 3e 00                                      /h1>.

00004c3e <SESSID_pstr>:
    4c3e:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00004c47 <inputSESSID_Str>:
    4c47:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
    4c57:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
    4c67:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

00004c72 <Connection_Close>:
    4c72:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    4c82:	65 0d 0a 0d 0a 00                                   e.....

00004c88 <jpeg_str>:
    4c88:	6a 70 65 67 00                                      jpeg.

00004c8d <gif_str>:
    4c8d:	67 69 66 00                                         gif.

00004c91 <ico_str>:
    4c91:	69 63 6f 00                                         ico.

00004c95 <html_str>:
    4c95:	68 74 6d 6c 00                                      html.

00004c9a <image_str>:
    4c9a:	69 6d 61 67 65 2f 00                                image/.

00004ca1 <html_cp1251_str>:
    4ca1:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
    4cb1:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
    4cc1:	0a 00                                               ..

00004cc3 <Content_Length>:
    4cc3:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    4cd3:	3a 20 00                                            : .

00004cd6 <Content_Type>:
    4cd6:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

00004ce5 <HTTP_200_OK>:
    4ce5:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    4cf5:	0a 00                                               ..

00004cf7 <MsgErr41>:
    4cf7:	29                                                  )

00004cf8 <TestMsg_str>:
    4cf8:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
    4d08:	e8 e5 00                                            ...

00004d0b <MB_Master_List>:
    4d0b:	00 00 00                                            ...

00004d0e <DO_M>:
    4d0e:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004d1d <DI_M>:
    4d1d:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4d2d:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004d3d <AT_ATH>:
    4d3d:	41 54 48 00                                         ATH.

00004d41 <AT_ATA>:
    4d41:	41 54 41 00                                         ATA.

00004d45 <AT_CSQ>:
    4d45:	41 54 2b 43 53 51 00                                AT+CSQ.

00004d4c <AT_CGATT_0>:
    4d4c:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

00004d57 <AT_CIPSHUT>:
    4d57:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

00004d62 <AT_CIPCLOSE>:
    4d62:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00004d70 <AT_CIPCLOSE_1>:
    4d70:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00004d80 <AT_CIPSEND>:
    4d80:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00004d8c <AT_ATO>:
    4d8c:	41 54 4f 00                                         ATO.

00004d90 <AT_CIPSTATUS>:
    4d90:	41 54 2b 43 49 50 53 54 41 54 55 53 00              AT+CIPSTATUS.

00004d9d <AT_SERVERCLOSE>:
    4d9d:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00004dac <AT_CIPSERVER>:
    4dac:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00004dbc <AT_CIPSTART_TCP>:
    4dbc:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
    4dcc:	22 2c 00                                            ",.

00004dcf <AT_CIPSTART>:
    4dcf:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
    4ddf:	44 50 22 2c 00                                      DP",.

00004de4 <AT_CIFSR>:
    4de4:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00004ded <AT_CIICR>:
    4ded:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00004df6 <AT_CSTT>:
    4df6:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00004dfe <AT_CIPCSGP>:
    4dfe:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00004e0d <AT_CGATT>:
    4e0d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00004e18 <AT_CIPMUX_0>:
    4e18:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00004e24 <AT_CIPMODE_1>:
    4e24:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00004e31 <AT_CMGS>:
    4e31:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

00004e3c <AT_CSMP>:
    4e3c:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
    4e4c:	2c 30 00                                            ,0.

00004e4f <AT_CMGF>:
    4e4f:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

00004e59 <AT_CCID>:
    4e59:	41 54 2b 43 43 49 44 00                             AT+CCID.

00004e61 <AT_CLIP>:
    4e61:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00004e6b <AT_CGMM>:
    4e6b:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00004e73 <AT_E0>:
    4e73:	41 54 45 30 00                                      ATE0.

00004e78 <AT_W>:
    4e78:	41 54 26 57 00                                      AT&W.

00004e7d <AT_IPR9600>:
    4e7d:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00004e89 <AT_AT>:
    4e89:	41 54 00                                            AT.

00004e8c <ESC_SEQ>:
    4e8c:	2b 2b 2b 00                                         +++.

00004e90 <RESP_STATE_CONNECT_OK>:
    4e90:	53 54 41 54 45 3a 20 43 4f 4e 4e 45 43 54 20 4f     STATE: CONNECT O
    4ea0:	4b 00                                               K.

00004ea2 <RESP_CONNECT_9600>:
    4ea2:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00004eaf <RESP_SHUT_OK>:
    4eaf:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00004eb7 <RESP_CSQ>:
    4eb7:	2b 43 53 51 3a 00                                   +CSQ:.

00004ebd <RESP_CLOSE_OK_FAST>:
    4ebd:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00004ec9 <RESP_CLOSE_OK>:
    4ec9:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00004ed2 <RESP_SEND_OK>:
    4ed2:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00004edd <RESP_SERVER_CLOSE>:
    4edd:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00004eea <RESP_SERVER_OK>:
    4eea:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00004ef4 <RESP_CONNECT_OK>:
    4ef4:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00004f02 <RESP_CONNECT>:
    4f02:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f0a <RESP_OK>:
    4f0a:	4f 4b 00                                            OK.

00004f0d <URC_NO_CARRIER>:
    4f0d:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00004f18 <URC_RING>:
    4f18:	52 49 4e 47 00                                      RING.

00004f1d <URC_PDPDEACT>:
    4f1d:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

00004f28 <URC_CLOSED>:
    4f28:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

00004f31 <URC_RECEIVE>:
    4f31:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

00004f3b <URC_CONNECT>:
    4f3b:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f43 <URC_REMOTE_IP>:
    4f43:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

00004f4d <URC_SMS_READY>:
    4f4d:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00004f57 <URC_CALL_READY>:
    4f57:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

00004f62 <URC_RDY>:
    4f62:	52 44 59 00                                         RDY.

00004f66 <GSM_SIMCOM_SIM800>:
    4f66:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00004f74 <GSM_SIMCOM_SIM900R>:
    4f74:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00004f83 <MB_Timer>:
    4f83:	52 00 51 00 24 28 44 00 43 00 2a 28                 R.Q.$(D.C.*(

00004f8f <MB_Port>:
    4f8f:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 1c 28 21 28     .............(!(
    4f9f:	22 28 23 28                                         "(#(

00004fa3 <BR_Tbl>:
    4fa3:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
    4fb3:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00004fbe <Modbus_Map>:
    4fbe:	df 03 08 00 f6 03 08 00 7c 08 2c 00 78 0a 1e 00     ........|.,.x...

00004fce <MB_Role>:
	...

00004fcf <__c.2299>:
    4fcf:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00004fdc <__ctors_end>:
    4fdc:	11 24       	eor	r1, r1
    4fde:	1f be       	out	0x3f, r1	; 63
    4fe0:	cf ef       	ldi	r28, 0xFF	; 255
    4fe2:	d0 e1       	ldi	r29, 0x10	; 16
    4fe4:	de bf       	out	0x3e, r29	; 62
    4fe6:	cd bf       	out	0x3d, r28	; 61

00004fe8 <__do_copy_data>:
    4fe8:	12 e0       	ldi	r17, 0x02	; 2
    4fea:	a0 e0       	ldi	r26, 0x00	; 0
    4fec:	b1 e0       	ldi	r27, 0x01	; 1
    4fee:	e2 e4       	ldi	r30, 0x42	; 66
    4ff0:	fc ee       	ldi	r31, 0xEC	; 236
    4ff2:	00 e0       	ldi	r16, 0x00	; 0
    4ff4:	0b bf       	out	0x3b, r16	; 59
    4ff6:	02 c0       	rjmp	.+4      	; 0x4ffc <__do_copy_data+0x14>
    4ff8:	07 90       	elpm	r0, Z+
    4ffa:	0d 92       	st	X+, r0
    4ffc:	aa 33       	cpi	r26, 0x3A	; 58
    4ffe:	b1 07       	cpc	r27, r17
    5000:	d9 f7       	brne	.-10     	; 0x4ff8 <__do_copy_data+0x10>

00005002 <__do_clear_bss>:
    5002:	2e e0       	ldi	r18, 0x0E	; 14
    5004:	aa e3       	ldi	r26, 0x3A	; 58
    5006:	b2 e0       	ldi	r27, 0x02	; 2
    5008:	01 c0       	rjmp	.+2      	; 0x500c <.do_clear_bss_start>

0000500a <.do_clear_bss_loop>:
    500a:	1d 92       	st	X+, r1

0000500c <.do_clear_bss_start>:
    500c:	ac 34       	cpi	r26, 0x4C	; 76
    500e:	b2 07       	cpc	r27, r18
    5010:	e1 f7       	brne	.-8      	; 0x500a <.do_clear_bss_loop>
    5012:	0e 94 ae 6b 	call	0xd75c	; 0xd75c <main>
    5016:	0c 94 37 6c 	jmp	0xd86e	; 0xd86e <exit>

0000501a <__bad_interrupt>:
    501a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000501e <rrb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
	return *addr;
}
    501e:	fc 01       	movw	r30, r24
    5020:	80 81       	ld	r24, Z
    5022:	08 95       	ret

00005024 <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5024:	fc 01       	movw	r30, r24
    5026:	84 91       	lpm	r24, Z
}
    5028:	08 95       	ret

0000502a <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    502a:	a0 e0       	ldi	r26, 0x00	; 0
    502c:	b0 e0       	ldi	r27, 0x00	; 0
    502e:	11 96       	adiw	r26, 0x01	; 1
}
    5030:	ab bf       	out	0x3b, r26	; 59
    5032:	fc 01       	movw	r30, r24
    5034:	87 91       	elpm	r24, Z+
    5036:	08 95       	ret

00005038 <RS485_1>:
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
}

void RS485_0(void) {}
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5038:	82 b3       	in	r24, 0x12	; 18
    503a:	90 e1       	ldi	r25, 0x10	; 16
    503c:	89 27       	eor	r24, r25
    503e:	82 bb       	out	0x12, r24	; 18
    5040:	08 95       	ret

00005042 <MB_LED1>:

void MB_LED0(void) {}
void MB_LED1(void) {}
    5042:	08 95       	ret

00005044 <MB_LED_Err_On_1>:

void MB_LED_Err_On_0(void)	{}
void MB_LED_Err_Off_0(void)	{}
void MB_LED_Err_On_1(void)	{}
    5044:	08 95       	ret

00005046 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    5046:	08 95       	ret

00005048 <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    5048:	8f e0       	ldi	r24, 0x0F	; 15
    504a:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    504c:	87 b7       	in	r24, 0x37	; 55
    504e:	82 60       	ori	r24, 0x02	; 2
    5050:	87 bf       	out	0x37, r24	; 55
    5052:	08 95       	ret

00005054 <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    5054:	8d e0       	ldi	r24, 0x0D	; 13
    5056:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    5058:	87 b7       	in	r24, 0x37	; 55
    505a:	80 68       	ori	r24, 0x80	; 128
    505c:	87 bf       	out	0x37, r24	; 55
    505e:	08 95       	ret

00005060 <MB_Timer_ISR>:
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5060:	60 e0       	ldi	r22, 0x00	; 0
    5062:	76 e0       	ldi	r23, 0x06	; 6
    5064:	26 2f       	mov	r18, r22
    5066:	30 e0       	ldi	r19, 0x00	; 0
    5068:	72 9f       	mul	r23, r18
    506a:	f0 01       	movw	r30, r0
    506c:	73 9f       	mul	r23, r19
    506e:	f0 0d       	add	r31, r0
    5070:	11 24       	eor	r1, r1
    5072:	ed 57       	subi	r30, 0x7D	; 125
    5074:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5076:	45 91       	lpm	r20, Z+
    5078:	54 91       	lpm	r21, Z
    507a:	e6 2f       	mov	r30, r22
    507c:	f0 e0       	ldi	r31, 0x00	; 0
    507e:	84 17       	cp	r24, r20
    5080:	95 07       	cpc	r25, r21
    5082:	11 f0       	breq	.+4      	; 0x5088 <MB_Timer_ISR+0x28>
    5084:	6f 5f       	subi	r22, 0xFF	; 255
    5086:	ee cf       	rjmp	.-36     	; 0x5064 <MB_Timer_ISR+0x4>

	
	switch (prb(MB_Role+MB_N)){
    5088:	e2 53       	subi	r30, 0x32	; 50
    508a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    508c:	e4 91       	lpm	r30, Z
    508e:	ee 23       	and	r30, r30
    5090:	19 f0       	breq	.+6      	; 0x5098 <MB_Timer_ISR+0x38>
    5092:	e1 30       	cpi	r30, 0x01	; 1
    5094:	f9 f0       	breq	.+62     	; 0x50d4 <MB_Timer_ISR+0x74>
    5096:	08 95       	ret
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    5098:	f2 2f       	mov	r31, r18
    509a:	ee 27       	eor	r30, r30
    509c:	e8 5b       	subi	r30, 0xB8	; 184
    509e:	f2 4f       	sbci	r31, 0xF2	; 242
    50a0:	90 81       	ld	r25, Z
    50a2:	f9 01       	movw	r30, r18
    50a4:	e8 50       	subi	r30, 0x08	; 8
    50a6:	fc 4f       	sbci	r31, 0xFC	; 252
    50a8:	80 81       	ld	r24, Z
    50aa:	98 17       	cp	r25, r24
    50ac:	99 f0       	breq	.+38     	; 0x50d4 <MB_Timer_ISR+0x74>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    50ae:	f9 01       	movw	r30, r18
    50b0:	ef 51       	subi	r30, 0x1F	; 31
    50b2:	fc 4f       	sbci	r31, 0xFC	; 252
    50b4:	81 e0       	ldi	r24, 0x01	; 1
    50b6:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    50b8:	f9 01       	movw	r30, r18
    50ba:	84 e0       	ldi	r24, 0x04	; 4
    50bc:	ee 0f       	add	r30, r30
    50be:	ff 1f       	adc	r31, r31
    50c0:	8a 95       	dec	r24
    50c2:	e1 f7       	brne	.-8      	; 0x50bc <MB_Timer_ISR+0x5c>
    50c4:	e7 5d       	subi	r30, 0xD7	; 215
    50c6:	f4 4f       	sbci	r31, 0xF4	; 244
    50c8:	80 81       	ld	r24, Z
    50ca:	91 81       	ldd	r25, Z+1	; 0x01
    50cc:	01 96       	adiw	r24, 0x01	; 1
    50ce:	91 83       	std	Z+1, r25	; 0x01
    50d0:	80 83       	st	Z, r24
    50d2:	08 95       	ret
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    50d4:	30 91 13 0b 	lds	r19, 0x0B13
    50d8:	81 e0       	ldi	r24, 0x01	; 1
    50da:	90 e0       	ldi	r25, 0x00	; 0
    50dc:	02 2e       	mov	r0, r18
    50de:	01 c0       	rjmp	.+2      	; 0x50e2 <MB_Timer_ISR+0x82>
    50e0:	88 0f       	add	r24, r24
    50e2:	0a 94       	dec	r0
    50e4:	ea f7       	brpl	.-6      	; 0x50e0 <MB_Timer_ISR+0x80>
    50e6:	38 2b       	or	r19, r24
    50e8:	30 93 13 0b 	sts	0x0B13, r19
    50ec:	08 95       	ret

000050ee <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    50ee:	28 2f       	mov	r18, r24
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	94 e1       	ldi	r25, 0x14	; 20
    50f4:	89 9f       	mul	r24, r25
    50f6:	f0 01       	movw	r30, r0
    50f8:	11 24       	eor	r1, r1
    50fa:	ef 56       	subi	r30, 0x6F	; 111
    50fc:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    50fe:	a5 91       	lpm	r26, Z+
    5100:	b4 91       	lpm	r27, Z
    5102:	9c 91       	ld	r25, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    5104:	f9 01       	movw	r30, r18
    5106:	e7 52       	subi	r30, 0x27	; 39
    5108:	f7 4f       	sbci	r31, 0xF7	; 247
    510a:	40 81       	ld	r20, Z
    510c:	51 e0       	ldi	r21, 0x01	; 1
    510e:	54 0f       	add	r21, r20
    5110:	50 83       	st	Z, r21
    5112:	54 e1       	ldi	r21, 0x14	; 20
    5114:	52 9f       	mul	r21, r18
    5116:	f0 01       	movw	r30, r0
    5118:	53 9f       	mul	r21, r19
    511a:	f0 0d       	add	r31, r0
    511c:	11 24       	eor	r1, r1
    511e:	e1 57       	subi	r30, 0x71	; 113
    5120:	f0 4b       	sbci	r31, 0xB0	; 176
    5122:	a5 91       	lpm	r26, Z+
    5124:	b4 91       	lpm	r27, Z
    5126:	5c 91       	ld	r21, X
    5128:	f2 2f       	mov	r31, r18
    512a:	ee 27       	eor	r30, r30
    512c:	e4 0f       	add	r30, r20
    512e:	f1 1d       	adc	r31, r1
    5130:	e8 5b       	subi	r30, 0xB8	; 184
    5132:	f2 4f       	sbci	r31, 0xF2	; 242
    5134:	50 83       	st	Z, r21
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5136:	93 ff       	sbrs	r25, 3
    5138:	0e c0       	rjmp	.+28     	; 0x5156 <MBRecept+0x68>
		MB_CPT[MB_N][7]++;
    513a:	f9 01       	movw	r30, r18
    513c:	24 e0       	ldi	r18, 0x04	; 4
    513e:	ee 0f       	add	r30, r30
    5140:	ff 1f       	adc	r31, r31
    5142:	2a 95       	dec	r18
    5144:	e1 f7       	brne	.-8      	; 0x513e <MBRecept+0x50>
    5146:	e7 5d       	subi	r30, 0xD7	; 215
    5148:	f4 4f       	sbci	r31, 0xF4	; 244
    514a:	26 85       	ldd	r18, Z+14	; 0x0e
    514c:	37 85       	ldd	r19, Z+15	; 0x0f
    514e:	2f 5f       	subi	r18, 0xFF	; 255
    5150:	3f 4f       	sbci	r19, 0xFF	; 255
    5152:	37 87       	std	Z+15, r19	; 0x0f
    5154:	26 87       	std	Z+14, r18	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5156:	9c 71       	andi	r25, 0x1C	; 28
    5158:	59 f0       	breq	.+22     	; 0x5170 <MBRecept+0x82>
		MB_Err |=(1<<MB_N);
    515a:	21 e0       	ldi	r18, 0x01	; 1
    515c:	30 e0       	ldi	r19, 0x00	; 0
    515e:	01 c0       	rjmp	.+2      	; 0x5162 <MBRecept+0x74>
    5160:	22 0f       	add	r18, r18
    5162:	8a 95       	dec	r24
    5164:	ea f7       	brpl	.-6      	; 0x5160 <MBRecept+0x72>
    5166:	80 91 6b 02 	lds	r24, 0x026B
    516a:	82 2b       	or	r24, r18
    516c:	80 93 6b 02 	sts	0x026B, r24
    5170:	08 95       	ret

00005172 <GetSlave>:

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    5172:	43 e0       	ldi	r20, 0x03	; 3
    5174:	84 9f       	mul	r24, r20
    5176:	f0 01       	movw	r30, r0
    5178:	11 24       	eor	r1, r1
    517a:	e5 5f       	subi	r30, 0xF5	; 245
    517c:	f2 4b       	sbci	r31, 0xB2	; 178
    517e:	25 91       	lpm	r18, Z+
    5180:	34 91       	lpm	r19, Z
    5182:	e8 2f       	mov	r30, r24
    5184:	f0 e0       	ldi	r31, 0x00	; 0
    5186:	ea 5f       	subi	r30, 0xFA	; 250
    5188:	f9 4f       	sbci	r31, 0xF9	; 249
    518a:	80 81       	ld	r24, Z
}
    518c:	a9 01       	movw	r20, r18
    518e:	64 e0       	ldi	r22, 0x04	; 4
    5190:	86 9f       	mul	r24, r22
    5192:	40 0d       	add	r20, r0
    5194:	51 1d       	adc	r21, r1
    5196:	11 24       	eor	r1, r1
    5198:	ca 01       	movw	r24, r20
    519a:	08 95       	ret

0000519c <DI_Init_Hard>:
static T_DI_M DI_M[] PROGMEM = DI_Map_Own;

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
    519c:	8d e1       	ldi	r24, 0x1D	; 29
    519e:	9d e4       	ldi	r25, 0x4D	; 77
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    51a0:	f8 94       	cli
    51a2:	fc 01       	movw	r30, r24
    51a4:	a5 91       	lpm	r26, Z+
    51a6:	b4 91       	lpm	r27, Z
    51a8:	ac 01       	movw	r20, r24
    51aa:	4a 5f       	subi	r20, 0xFA	; 250
    51ac:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51ae:	fa 01       	movw	r30, r20
    51b0:	34 91       	lpm	r19, Z
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    51b2:	30 95       	com	r19
    51b4:	2c 91       	ld	r18, X
    51b6:	23 23       	and	r18, r19
    51b8:	2c 93       	st	X, r18
    51ba:	9c 01       	movw	r18, r24
    51bc:	2e 5f       	subi	r18, 0xFE	; 254
    51be:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    51c0:	f9 01       	movw	r30, r18
    51c2:	a5 91       	lpm	r26, Z+
    51c4:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51c6:	fa 01       	movw	r30, r20
    51c8:	44 91       	lpm	r20, Z
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    51ca:	2c 91       	ld	r18, X
    51cc:	24 2b       	or	r18, r20
    51ce:	2c 93       	st	X, r18
		sei();
    51d0:	78 94       	sei
    51d2:	08 96       	adiw	r24, 0x08	; 8

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    51d4:	fd e4       	ldi	r31, 0x4D	; 77
    51d6:	8d 33       	cpi	r24, 0x3D	; 61
    51d8:	9f 07       	cpc	r25, r31
    51da:	11 f7       	brne	.-60     	; 0x51a0 <DI_Init_Hard+0x4>
		cli();
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
		sei();
	}
}
    51dc:	08 95       	ret

000051de <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    51de:	f8 94       	cli
    51e0:	ff cf       	rjmp	.-2      	; 0x51e0 <Reboot+0x2>

000051e2 <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    51e2:	88 e5       	ldi	r24, 0x58	; 88
    51e4:	80 93 27 06 	sts	0x0627, r24
    51e8:	08 95       	ret

000051ea <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    51ea:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    51ec:	e0 e0       	ldi	r30, 0x00	; 0
    51ee:	ff ef       	ldi	r31, 0xFF	; 255
    51f0:	09 94       	ijmp

000051f2 <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	80 93 3a 08 	sts	0x083A, r24
    51f8:	08 95       	ret

000051fa <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    51fa:	0c 94 e0 73 	jmp	0xe7c0	; 0xe7c0 <__eerd_byte_m128>

000051fe <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    51fe:	0f 93       	push	r16
    5200:	1f 93       	push	r17
    5202:	cf 93       	push	r28
    5204:	df 93       	push	r29
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5206:	c8 2f       	mov	r28, r24
    5208:	d0 e0       	ldi	r29, 0x00	; 0
    520a:	fe 01       	movw	r30, r28
    520c:	ee 5d       	subi	r30, 0xDE	; 222
    520e:	f9 4f       	sbci	r31, 0xF9	; 249
    5210:	90 81       	ld	r25, Z
    5212:	92 30       	cpi	r25, 0x02	; 2
    5214:	09 f1       	breq	.+66     	; 0x5258 <GetReg+0x5a>
    5216:	fe 01       	movw	r30, r28
    5218:	a4 e0       	ldi	r26, 0x04	; 4
    521a:	ee 0f       	add	r30, r30
    521c:	ff 1f       	adc	r31, r31
    521e:	aa 95       	dec	r26
    5220:	e1 f7       	brne	.-8      	; 0x521a <GetReg+0x1c>
    5222:	ea 53       	subi	r30, 0x3A	; 58
    5224:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5226:	05 91       	lpm	r16, Z+
    5228:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    522a:	0e 94 b9 28 	call	0x5172	; 0x5172 <GetSlave>
    522e:	01 96       	adiw	r24, 0x01	; 1
    5230:	fc 01       	movw	r30, r24
    5232:	85 91       	lpm	r24, Z+
    5234:	94 91       	lpm	r25, Z
    5236:	c3 5f       	subi	r28, 0xF3	; 243
    5238:	d9 4f       	sbci	r29, 0xF9	; 249
    523a:	28 81       	ld	r18, Y
    523c:	fc 01       	movw	r30, r24
    523e:	37 e0       	ldi	r19, 0x07	; 7
    5240:	23 9f       	mul	r18, r19
    5242:	e0 0d       	add	r30, r0
    5244:	f1 1d       	adc	r31, r1
    5246:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5248:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    524a:	85 91       	lpm	r24, Z+
    524c:	94 91       	lpm	r25, Z
    524e:	88 0f       	add	r24, r24
    5250:	99 1f       	adc	r25, r25
    5252:	80 0f       	add	r24, r16
    5254:	91 1f       	adc	r25, r17
    5256:	09 c0       	rjmp	.+18     	; 0x526a <GetReg+0x6c>
    5258:	73 e0       	ldi	r23, 0x03	; 3
    525a:	cc 0f       	add	r28, r28
    525c:	dd 1f       	adc	r29, r29
    525e:	7a 95       	dec	r23
    5260:	e1 f7       	brne	.-8      	; 0x525a <GetReg+0x5c>
    5262:	cd 59       	subi	r28, 0x9D	; 157
    5264:	dd 4f       	sbci	r29, 0xFD	; 253
    5266:	8e 81       	ldd	r24, Y+6	; 0x06
    5268:	9f 81       	ldd	r25, Y+7	; 0x07
}
    526a:	df 91       	pop	r29
    526c:	cf 91       	pop	r28
    526e:	1f 91       	pop	r17
    5270:	0f 91       	pop	r16
    5272:	08 95       	ret

00005274 <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    5274:	fc 01       	movw	r30, r24
    5276:	65 91       	lpm	r22, Z+
    5278:	75 91       	lpm	r23, Z+
    527a:	85 91       	lpm	r24, Z+
    527c:	94 91       	lpm	r25, Z
}
    527e:	08 95       	ret

00005280 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    5280:	8f 92       	push	r8
    5282:	9f 92       	push	r9
    5284:	af 92       	push	r10
    5286:	bf 92       	push	r11
    5288:	cf 92       	push	r12
    528a:	df 92       	push	r13
    528c:	ef 92       	push	r14
    528e:	ff 92       	push	r15
    5290:	0f 93       	push	r16
    5292:	1f 93       	push	r17
    5294:	cf 93       	push	r28
    5296:	df 93       	push	r29
    5298:	00 d0       	rcall	.+0      	; 0x529a <CRC_Seed+0x1a>
    529a:	00 d0       	rcall	.+0      	; 0x529c <CRC_Seed+0x1c>
    529c:	cd b7       	in	r28, 0x3d	; 61
    529e:	de b7       	in	r29, 0x3e	; 62
    52a0:	4c 01       	movw	r8, r24
    52a2:	5b 01       	movw	r10, r22
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52a4:	c1 2c       	mov	r12, r1
    52a6:	d1 2c       	mov	r13, r1
    52a8:	76 01       	movw	r14, r12
    52aa:	c2 16       	cp	r12, r18
    52ac:	d3 06       	cpc	r13, r19
    52ae:	e4 06       	cpc	r14, r20
    52b0:	f5 06       	cpc	r15, r21
    52b2:	f9 f0       	breq	.+62     	; 0x52f2 <CRC_Seed+0x72>
    52b4:	c5 01       	movw	r24, r10
    52b6:	8c 0d       	add	r24, r12
    52b8:	9d 1d       	adc	r25, r13
		uint8_t j = CRCLo^GetByte(Block+i);
    52ba:	29 83       	std	Y+1, r18	; 0x01
    52bc:	3a 83       	std	Y+2, r19	; 0x02
    52be:	4b 83       	std	Y+3, r20	; 0x03
    52c0:	5c 83       	std	Y+4, r21	; 0x04
    52c2:	f4 01       	movw	r30, r8
    52c4:	09 95       	icall
    52c6:	80 27       	eor	r24, r16
		CRCLo = CRCHi^prb(aCRCHi+j);
    52c8:	68 2f       	mov	r22, r24
    52ca:	70 e0       	ldi	r23, 0x00	; 0
    52cc:	fb 01       	movw	r30, r22
    52ce:	ee 57       	subi	r30, 0x7E	; 126
    52d0:	fb 4f       	sbci	r31, 0xFB	; 251

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52d2:	04 91       	lpm	r16, Z
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    52d4:	01 27       	eor	r16, r17
		CRCHi = prb(aCRCLo+j);
    52d6:	fb 01       	movw	r30, r22
    52d8:	ee 57       	subi	r30, 0x7E	; 126
    52da:	fc 4f       	sbci	r31, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52dc:	14 91       	lpm	r17, Z
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52de:	ff ef       	ldi	r31, 0xFF	; 255
    52e0:	cf 1a       	sub	r12, r31
    52e2:	df 0a       	sbc	r13, r31
    52e4:	ef 0a       	sbc	r14, r31
    52e6:	ff 0a       	sbc	r15, r31
    52e8:	5c 81       	ldd	r21, Y+4	; 0x04
    52ea:	4b 81       	ldd	r20, Y+3	; 0x03
    52ec:	3a 81       	ldd	r19, Y+2	; 0x02
    52ee:	29 81       	ldd	r18, Y+1	; 0x01
    52f0:	dc cf       	rjmp	.-72     	; 0x52aa <CRC_Seed+0x2a>
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
    52f2:	80 2f       	mov	r24, r16
    52f4:	90 e0       	ldi	r25, 0x00	; 0
}
    52f6:	91 2b       	or	r25, r17
    52f8:	0f 90       	pop	r0
    52fa:	0f 90       	pop	r0
    52fc:	0f 90       	pop	r0
    52fe:	0f 90       	pop	r0
    5300:	df 91       	pop	r29
    5302:	cf 91       	pop	r28
    5304:	1f 91       	pop	r17
    5306:	0f 91       	pop	r16
    5308:	ff 90       	pop	r15
    530a:	ef 90       	pop	r14
    530c:	df 90       	pop	r13
    530e:	cf 90       	pop	r12
    5310:	bf 90       	pop	r11
    5312:	af 90       	pop	r10
    5314:	9f 90       	pop	r9
    5316:	8f 90       	pop	r8
    5318:	08 95       	ret

0000531a <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    531a:	0f 93       	push	r16
    531c:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    531e:	0f ef       	ldi	r16, 0xFF	; 255
    5320:	1f ef       	ldi	r17, 0xFF	; 255
    5322:	0e 94 40 29 	call	0x5280	; 0x5280 <CRC_Seed>
}
    5326:	1f 91       	pop	r17
    5328:	0f 91       	pop	r16
    532a:	08 95       	ret

0000532c <CRC_EEPROM_calc>:
}

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    532c:	0f 93       	push	r16
    532e:	1f 93       	push	r17
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
    5330:	29 ea       	ldi	r18, 0xA9	; 169
    5332:	31 e0       	ldi	r19, 0x01	; 1
// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
    5334:	40 e0       	ldi	r20, 0x00	; 0
    5336:	50 e0       	ldi	r21, 0x00	; 0
    5338:	60 e0       	ldi	r22, 0x00	; 0
    533a:	70 e0       	ldi	r23, 0x00	; 0
    533c:	8d ef       	ldi	r24, 0xFD	; 253
    533e:	98 e2       	ldi	r25, 0x28	; 40
    5340:	0e 94 8d 29 	call	0x531a	; 0x531a <CRC>
    5344:	2b ef       	ldi	r18, 0xFB	; 251
    5346:	3f e0       	ldi	r19, 0x0F	; 15
    5348:	29 5a       	subi	r18, 0xA9	; 169
    534a:	31 40       	sbci	r19, 0x01	; 1
    534c:	40 e0       	ldi	r20, 0x00	; 0
    534e:	50 e0       	ldi	r21, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
    5350:	8c 01       	movw	r16, r24
    5352:	6e ea       	ldi	r22, 0xAE	; 174
    5354:	71 e0       	ldi	r23, 0x01	; 1
    5356:	8d ef       	ldi	r24, 0xFD	; 253
    5358:	98 e2       	ldi	r25, 0x28	; 40
    535a:	0e 94 40 29 	call	0x5280	; 0x5280 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    535e:	1f 91       	pop	r17
    5360:	0f 91       	pop	r16
    5362:	08 95       	ret

00005364 <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    5364:	80 91 77 0a 	lds	r24, 0x0A77
    5368:	81 fd       	sbrc	r24, 1
    536a:	07 c0       	rjmp	.+14     	; 0x537a <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    536c:	0e 94 96 29 	call	0x532c	; 0x532c <CRC_EEPROM_calc>
    5370:	bc 01       	movw	r22, r24
    5372:	8b ea       	ldi	r24, 0xAB	; 171
    5374:	91 e0       	ldi	r25, 0x01	; 1
    5376:	0c 94 13 74 	jmp	0xe826	; 0xe826 <__eewr_word_m128>
    537a:	08 95       	ret

0000537c <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    537c:	0e 94 fe 73 	call	0xe7fc	; 0xe7fc <__eewr_byte_m128>
	CRC_EEPROM_upd();
    5380:	0c 94 b2 29 	jmp	0x5364	; 0x5364 <CRC_EEPROM_upd>

00005384 <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    5384:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    5386:	6f ef       	ldi	r22, 0xFF	; 255
    5388:	8f ef       	ldi	r24, 0xFF	; 255
    538a:	9f e0       	ldi	r25, 0x0F	; 15
    538c:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
    5390:	ff cf       	rjmp	.-2      	; 0x5390 <Start_Bootloader+0xc>

00005392 <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    5392:	0e 94 13 74 	call	0xe826	; 0xe826 <__eewr_word_m128>
	CRC_EEPROM_upd();
    5396:	0c 94 b2 29 	jmp	0x5364	; 0x5364 <CRC_EEPROM_upd>

0000539a <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    539a:	0e 94 0b 74 	call	0xe816	; 0xe816 <__eewr_dword_m128>
	CRC_EEPROM_upd();
    539e:	0c 94 b2 29 	jmp	0x5364	; 0x5364 <CRC_EEPROM_upd>

000053a2 <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    53a2:	0e 94 f4 73 	call	0xe7e8	; 0xe7e8 <__eewr_block_m128>
	CRC_EEPROM_upd();
    53a6:	0c 94 b2 29 	jmp	0x5364	; 0x5364 <CRC_EEPROM_upd>

000053aa <CRC_Flash_calc>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    53aa:	0f 93       	push	r16
    53ac:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    53ae:	20 e0       	ldi	r18, 0x00	; 0
    53b0:	30 e0       	ldi	r19, 0x00	; 0
    53b2:	41 e0       	ldi	r20, 0x01	; 1
    53b4:	50 e0       	ldi	r21, 0x00	; 0
    53b6:	60 e0       	ldi	r22, 0x00	; 0
    53b8:	70 e0       	ldi	r23, 0x00	; 0
    53ba:	82 e1       	ldi	r24, 0x12	; 18
    53bc:	98 e2       	ldi	r25, 0x28	; 40
    53be:	0e 94 8d 29 	call	0x531a	; 0x531a <CRC>
    53c2:	8c 01       	movw	r16, r24
    53c4:	20 e0       	ldi	r18, 0x00	; 0
    53c6:	30 e0       	ldi	r19, 0x00	; 0
    53c8:	41 e0       	ldi	r20, 0x01	; 1
    53ca:	50 e0       	ldi	r21, 0x00	; 0
    53cc:	60 e0       	ldi	r22, 0x00	; 0
    53ce:	70 e0       	ldi	r23, 0x00	; 0
    53d0:	85 e1       	ldi	r24, 0x15	; 21
    53d2:	98 e2       	ldi	r25, 0x28	; 40
    53d4:	0e 94 40 29 	call	0x5280	; 0x5280 <CRC_Seed>
	#endif
}
    53d8:	1f 91       	pop	r17
    53da:	0f 91       	pop	r16
    53dc:	08 95       	ret

000053de <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    53de:	8d ea       	ldi	r24, 0xAD	; 173
    53e0:	91 e0       	ldi	r25, 0x01	; 1
    53e2:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    53e6:	81 11       	cpse	r24, r1
    53e8:	13 c0       	rjmp	.+38     	; 0x5410 <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    53ea:	0e 94 d5 29 	call	0x53aa	; 0x53aa <CRC_Flash_calc>
    53ee:	bc 01       	movw	r22, r24
    53f0:	89 ea       	ldi	r24, 0xA9	; 169
    53f2:	91 e0       	ldi	r25, 0x01	; 1
    53f4:	0e 94 13 74 	call	0xe826	; 0xe826 <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    53f8:	0e 94 96 29 	call	0x532c	; 0x532c <CRC_EEPROM_calc>
    53fc:	bc 01       	movw	r22, r24
    53fe:	8b ea       	ldi	r24, 0xAB	; 171
    5400:	91 e0       	ldi	r25, 0x01	; 1
    5402:	0e 94 13 74 	call	0xe826	; 0xe826 <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    5406:	61 e0       	ldi	r22, 0x01	; 1
    5408:	8d ea       	ldi	r24, 0xAD	; 173
    540a:	91 e0       	ldi	r25, 0x01	; 1
    540c:	0c 94 fe 73 	jmp	0xe7fc	; 0xe7fc <__eewr_byte_m128>
    5410:	08 95       	ret

00005412 <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    5412:	8f b7       	in	r24, 0x3f	; 63
    5414:	80 78       	andi	r24, 0x80	; 128
    5416:	80 93 de 03 	sts	0x03DE, r24
	cli();
    541a:	f8 94       	cli
	return interru_enub_flg;
}
    541c:	80 91 de 03 	lds	r24, 0x03DE
    5420:	08 95       	ret

00005422 <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    5422:	80 91 de 03 	lds	r24, 0x03DE
    5426:	88 23       	and	r24, r24
    5428:	09 f0       	breq	.+2      	; 0x542c <IntOn+0xa>
		sei();
    542a:	78 94       	sei
	return interru_enub_flg;
}
    542c:	80 91 de 03 	lds	r24, 0x03DE
    5430:	08 95       	ret

00005432 <Modbus_ReadHoldReg>:
	eww(&SerialNum, MBHoldReg1[43]);
	
}

void Modbus_ReadHoldReg(void){
	IntOff();
    5432:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5436:	87 e2       	ldi	r24, 0x27	; 39
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	MBHoldReg1[0] = erw(&EM_UART_Param);
    543e:	90 93 7d 08 	sts	0x087D, r25
    5442:	80 93 7c 08 	sts	0x087C, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    5446:	4e e1       	ldi	r20, 0x1E	; 30
    5448:	50 e0       	ldi	r21, 0x00	; 0
    544a:	6c e7       	ldi	r22, 0x7C	; 124
    544c:	71 e0       	ldi	r23, 0x01	; 1
    544e:	8e e7       	ldi	r24, 0x7E	; 126
    5450:	98 e0       	ldi	r25, 0x08	; 8
    5452:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    5456:	44 e1       	ldi	r20, 0x14	; 20
    5458:	50 e0       	ldi	r21, 0x00	; 0
    545a:	68 e6       	ldi	r22, 0x68	; 104
    545c:	71 e0       	ldi	r23, 0x01	; 1
    545e:	8c e9       	ldi	r24, 0x9C	; 156
    5460:	98 e0       	ldi	r25, 0x08	; 8
    5462:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    5466:	44 e1       	ldi	r20, 0x14	; 20
    5468:	50 e0       	ldi	r21, 0x00	; 0
    546a:	64 e5       	ldi	r22, 0x54	; 84
    546c:	71 e0       	ldi	r23, 0x01	; 1
    546e:	80 eb       	ldi	r24, 0xB0	; 176
    5470:	98 e0       	ldi	r25, 0x08	; 8
    5472:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5476:	80 e2       	ldi	r24, 0x20	; 32
    5478:	91 e0       	ldi	r25, 0x01	; 1
    547a:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    547e:	90 93 c5 08 	sts	0x08C5, r25
    5482:	80 93 c4 08 	sts	0x08C4, r24
    5486:	8e e0       	ldi	r24, 0x0E	; 14
    5488:	91 e0       	ldi	r25, 0x01	; 1
    548a:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    548e:	90 93 c7 08 	sts	0x08C7, r25
    5492:	80 93 c6 08 	sts	0x08C6, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5496:	82 e3       	ldi	r24, 0x32	; 50
    5498:	91 e0       	ldi	r25, 0x01	; 1
    549a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MBHoldReg1[38] = erb(&TCP_ServerIP->IP1);
    549e:	90 e0       	ldi	r25, 0x00	; 0
    54a0:	90 93 c9 08 	sts	0x08C9, r25
    54a4:	80 93 c8 08 	sts	0x08C8, r24
    54a8:	83 e3       	ldi	r24, 0x33	; 51
    54aa:	91 e0       	ldi	r25, 0x01	; 1
    54ac:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MBHoldReg1[39] = erb(&TCP_ServerIP->IP2);
    54b0:	90 e0       	ldi	r25, 0x00	; 0
    54b2:	90 93 cb 08 	sts	0x08CB, r25
    54b6:	80 93 ca 08 	sts	0x08CA, r24
    54ba:	84 e3       	ldi	r24, 0x34	; 52
    54bc:	91 e0       	ldi	r25, 0x01	; 1
    54be:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MBHoldReg1[40] = erb(&TCP_ServerIP->IP3);
    54c2:	90 e0       	ldi	r25, 0x00	; 0
    54c4:	90 93 cd 08 	sts	0x08CD, r25
    54c8:	80 93 cc 08 	sts	0x08CC, r24
    54cc:	85 e3       	ldi	r24, 0x35	; 53
    54ce:	91 e0       	ldi	r25, 0x01	; 1
    54d0:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MBHoldReg1[41] = erb(&TCP_ServerIP->IP4);
    54d4:	90 e0       	ldi	r25, 0x00	; 0
    54d6:	90 93 cf 08 	sts	0x08CF, r25
    54da:	80 93 ce 08 	sts	0x08CE, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    54de:	82 e2       	ldi	r24, 0x22	; 34
    54e0:	91 e0       	ldi	r25, 0x01	; 1
    54e2:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	MBHoldReg1[42] = erw(&TCP_ServerPort[0]);
    54e6:	90 93 d1 08 	sts	0x08D1, r25
    54ea:	80 93 d0 08 	sts	0x08D0, r24
    54ee:	82 e5       	ldi	r24, 0x52	; 82
    54f0:	91 e0       	ldi	r25, 0x01	; 1
    54f2:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	MBHoldReg1[43] = erw(&SerialNum);
    54f6:	90 93 d3 08 	sts	0x08D3, r25
    54fa:	80 93 d2 08 	sts	0x08D2, r24
	IntOn();
    54fe:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

00005502 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    5502:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    5504:	2f e0       	ldi	r18, 0x0F	; 15
    5506:	88 e1       	ldi	r24, 0x18	; 24
    5508:	90 e0       	ldi	r25, 0x00	; 0
    550a:	0f b6       	in	r0, 0x3f	; 63
    550c:	f8 94       	cli
    550e:	a8 95       	wdr
    5510:	81 bd       	out	0x21, r24	; 33
    5512:	0f be       	out	0x3f, r0	; 63
    5514:	21 bd       	out	0x21, r18	; 33
    5516:	08 95       	ret

00005518 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    5518:	80 91 11 01 	lds	r24, 0x0111
	VacantTimer16++;
    551c:	91 e0       	ldi	r25, 0x01	; 1
    551e:	98 0f       	add	r25, r24
    5520:	90 93 11 01 	sts	0x0111, r25
	return N;
}
    5524:	08 95       	ret

00005526 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    5526:	80 91 10 01 	lds	r24, 0x0110
	VacantTimer32++;
    552a:	91 e0       	ldi	r25, 0x01	; 1
    552c:	98 0f       	add	r25, r24
    552e:	90 93 10 01 	sts	0x0110, r25
	return N;
}
    5532:	08 95       	ret

00005534 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    5534:	1f 93       	push	r17
    5536:	cf 93       	push	r28
    5538:	df 93       	push	r29
    553a:	1f 92       	push	r1
    553c:	cd b7       	in	r28, 0x3d	; 61
    553e:	de b7       	in	r29, 0x3e	; 62
    5540:	18 2f       	mov	r17, r24
	IntOff();
    5542:	69 83       	std	Y+1, r22	; 0x01
    5544:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	if ((Timer8[TimerN]=Timeout)>0)
    5548:	e1 2f       	mov	r30, r17
    554a:	f0 e0       	ldi	r31, 0x00	; 0
    554c:	ea 55       	subi	r30, 0x5A	; 90
    554e:	fc 4f       	sbci	r31, 0xFC	; 252
    5550:	69 81       	ldd	r22, Y+1	; 0x01
    5552:	60 83       	st	Z, r22
    5554:	e1 2f       	mov	r30, r17
    5556:	e6 95       	lsr	r30
    5558:	e6 95       	lsr	r30
    555a:	e6 95       	lsr	r30
    555c:	17 70       	andi	r17, 0x07	; 7
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    555e:	f0 e0       	ldi	r31, 0x00	; 0
    5560:	e3 58       	subi	r30, 0x83	; 131
    5562:	fd 4f       	sbci	r31, 0xFD	; 253
    5564:	80 81       	ld	r24, Z
    5566:	21 e0       	ldi	r18, 0x01	; 1
    5568:	30 e0       	ldi	r19, 0x00	; 0
    556a:	01 2e       	mov	r0, r17
    556c:	01 c0       	rjmp	.+2      	; 0x5570 <StartTimer8+0x3c>
    556e:	22 0f       	add	r18, r18
    5570:	0a 94       	dec	r0
    5572:	ea f7       	brpl	.-6      	; 0x556e <StartTimer8+0x3a>

void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    5574:	66 23       	and	r22, r22
    5576:	21 f0       	breq	.+8      	; 0x5580 <StartTimer8+0x4c>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5578:	20 95       	com	r18
    557a:	28 23       	and	r18, r24
    557c:	20 83       	st	Z, r18
    557e:	02 c0       	rjmp	.+4      	; 0x5584 <StartTimer8+0x50>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    5580:	82 2b       	or	r24, r18
    5582:	80 83       	st	Z, r24
	IntOn();
}
    5584:	0f 90       	pop	r0
    5586:	df 91       	pop	r29
    5588:	cf 91       	pop	r28
    558a:	1f 91       	pop	r17
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    558c:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

00005590 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    5590:	1f 93       	push	r17
    5592:	cf 93       	push	r28
    5594:	df 93       	push	r29
    5596:	18 2f       	mov	r17, r24
    5598:	eb 01       	movw	r28, r22
	IntOff();
    559a:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	if ((Timer16[TimerN]=Timeout)>0)
    559e:	e1 2f       	mov	r30, r17
    55a0:	f0 e0       	ldi	r31, 0x00	; 0
    55a2:	ee 0f       	add	r30, r30
    55a4:	ff 1f       	adc	r31, r31
    55a6:	ea 5d       	subi	r30, 0xDA	; 218
    55a8:	fc 4f       	sbci	r31, 0xFC	; 252
    55aa:	d1 83       	std	Z+1, r29	; 0x01
    55ac:	c0 83       	st	Z, r28
    55ae:	e1 2f       	mov	r30, r17
    55b0:	e6 95       	lsr	r30
    55b2:	e6 95       	lsr	r30
    55b4:	e6 95       	lsr	r30
    55b6:	17 70       	andi	r17, 0x07	; 7
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55b8:	f0 e0       	ldi	r31, 0x00	; 0
    55ba:	ec 58       	subi	r30, 0x8C	; 140
    55bc:	fd 4f       	sbci	r31, 0xFD	; 253
    55be:	80 81       	ld	r24, Z
    55c0:	21 e0       	ldi	r18, 0x01	; 1
    55c2:	30 e0       	ldi	r19, 0x00	; 0
    55c4:	01 2e       	mov	r0, r17
    55c6:	01 c0       	rjmp	.+2      	; 0x55ca <StartTimer16+0x3a>
    55c8:	22 0f       	add	r18, r18
    55ca:	0a 94       	dec	r0
    55cc:	ea f7       	brpl	.-6      	; 0x55c8 <StartTimer16+0x38>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    55ce:	cd 2b       	or	r28, r29
    55d0:	21 f0       	breq	.+8      	; 0x55da <StartTimer16+0x4a>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55d2:	20 95       	com	r18
    55d4:	28 23       	and	r18, r24
    55d6:	20 83       	st	Z, r18
    55d8:	02 c0       	rjmp	.+4      	; 0x55de <StartTimer16+0x4e>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    55da:	82 2b       	or	r24, r18
    55dc:	80 83       	st	Z, r24
	IntOn();
}
    55de:	df 91       	pop	r29
    55e0:	cf 91       	pop	r28
    55e2:	1f 91       	pop	r17
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    55e4:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

000055e8 <SlavesOn>:

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    55e8:	28 2f       	mov	r18, r24
    55ea:	30 e0       	ldi	r19, 0x00	; 0
    55ec:	f9 01       	movw	r30, r18
    55ee:	ee 0f       	add	r30, r30
    55f0:	ff 1f       	adc	r31, r31
    55f2:	ee 0f       	add	r30, r30
    55f4:	ff 1f       	adc	r31, r31
    55f6:	e3 5a       	subi	r30, 0xA3	; 163
    55f8:	fd 4f       	sbci	r31, 0xFD	; 253
    55fa:	10 82       	st	Z, r1
    55fc:	11 82       	std	Z+1, r1	; 0x01
    55fe:	12 82       	std	Z+2, r1	; 0x02
    5600:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    5602:	f9 01       	movw	r30, r18
    5604:	e6 51       	subi	r30, 0x16	; 22
    5606:	fc 4f       	sbci	r31, 0xFC	; 252
    5608:	60 81       	ld	r22, Z
    560a:	94 e6       	ldi	r25, 0x64	; 100
    560c:	69 9f       	mul	r22, r25
    560e:	b0 01       	movw	r22, r0
    5610:	11 24       	eor	r1, r1
    5612:	90 91 5c 02 	lds	r25, 0x025C
    5616:	9f 5f       	subi	r25, 0xFF	; 255
    5618:	89 0f       	add	r24, r25
    561a:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>

0000561e <NextSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    561e:	4f 92       	push	r4
    5620:	5f 92       	push	r5
    5622:	6f 92       	push	r6
    5624:	7f 92       	push	r7
    5626:	8f 92       	push	r8
    5628:	9f 92       	push	r9
    562a:	af 92       	push	r10
    562c:	bf 92       	push	r11
    562e:	cf 92       	push	r12
    5630:	df 92       	push	r13
    5632:	ef 92       	push	r14
    5634:	ff 92       	push	r15
    5636:	0f 93       	push	r16
    5638:	1f 93       	push	r17
    563a:	cf 93       	push	r28
    563c:	df 93       	push	r29
    563e:	98 2e       	mov	r9, r24
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
    5640:	83 e0       	ldi	r24, 0x03	; 3
    5642:	98 9e       	mul	r9, r24
    5644:	f0 01       	movw	r30, r0
    5646:	11 24       	eor	r1, r1
    5648:	e3 5f       	subi	r30, 0xF3	; 243
    564a:	f2 4b       	sbci	r31, 0xB2	; 178

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    564c:	74 90       	lpm	r7, Z
// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	uint8_t i = 0;
    564e:	81 2c       	mov	r8, r1

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
    5650:	61 2c       	mov	r6, r1
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    5652:	09 2d       	mov	r16, r9
    5654:	10 e0       	ldi	r17, 0x00	; 0
    5656:	e8 01       	movw	r28, r16
    5658:	ca 5f       	subi	r28, 0xFA	; 250
    565a:	d9 4f       	sbci	r29, 0xF9	; 249
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    565c:	98 01       	movw	r18, r16
    565e:	22 0f       	add	r18, r18
    5660:	33 1f       	adc	r19, r19
    5662:	f9 01       	movw	r30, r18
    5664:	e7 5b       	subi	r30, 0xB7	; 183
    5666:	f6 4f       	sbci	r31, 0xF6	; 246
    5668:	5f 01       	movw	r10, r30
    566a:	c9 01       	movw	r24, r18
    566c:	85 5c       	subi	r24, 0xC5	; 197
    566e:	97 4f       	sbci	r25, 0xF7	; 247
    5670:	6c 01       	movw	r12, r24
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    5672:	78 01       	movw	r14, r16
    5674:	ee 0c       	add	r14, r14
    5676:	ff 1c       	adc	r15, r15
    5678:	ee 0c       	add	r14, r14
    567a:	ff 1c       	adc	r15, r15
    567c:	f7 01       	movw	r30, r14
    567e:	e3 5a       	subi	r30, 0xA3	; 163
    5680:	fd 4f       	sbci	r31, 0xFD	; 253
    5682:	7f 01       	movw	r14, r30
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    5684:	98 81       	ld	r25, Y
    5686:	9f 5f       	subi	r25, 0xFF	; 255
    5688:	98 83       	st	Y, r25
    568a:	97 11       	cpse	r25, r7
    568c:	27 c0       	rjmp	.+78     	; 0x56dc <NextSlave+0xbe>
			CurrSlave[MB_N] = 0;
    568e:	18 82       	st	Y, r1
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5690:	60 90 5c 02 	lds	r6, 0x025C
    5694:	63 94       	inc	r6
    5696:	63 94       	inc	r6
    5698:	69 0c       	add	r6, r9

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    569a:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint16_t Time = Timer16[TimerN];
    569e:	a6 2d       	mov	r26, r6
    56a0:	b0 e0       	ldi	r27, 0x00	; 0
    56a2:	aa 0f       	add	r26, r26
    56a4:	bb 1f       	adc	r27, r27
    56a6:	aa 5d       	subi	r26, 0xDA	; 218
    56a8:	bc 4f       	sbci	r27, 0xFC	; 252
    56aa:	4d 90       	ld	r4, X+
    56ac:	5c 90       	ld	r5, X
	IntOn();
    56ae:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
    56b2:	92 01       	movw	r18, r4
    56b4:	20 95       	com	r18
    56b6:	30 95       	com	r19
    56b8:	f5 01       	movw	r30, r10
    56ba:	31 83       	std	Z+1, r19	; 0x01
    56bc:	20 83       	st	Z, r18
    56be:	f6 01       	movw	r30, r12
    56c0:	40 81       	ld	r20, Z
    56c2:	51 81       	ldd	r21, Z+1	; 0x01
    56c4:	42 17       	cp	r20, r18
    56c6:	53 07       	cpc	r21, r19
    56c8:	10 f4       	brcc	.+4      	; 0x56ce <NextSlave+0xb0>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    56ca:	31 83       	std	Z+1, r19	; 0x01
    56cc:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    56ce:	6f ef       	ldi	r22, 0xFF	; 255
    56d0:	7f ef       	ldi	r23, 0xFF	; 255
    56d2:	86 2d       	mov	r24, r6
    56d4:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;
    56d8:	66 24       	eor	r6, r6
    56da:	63 94       	inc	r6

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    56dc:	f7 01       	movw	r30, r14
    56de:	40 81       	ld	r20, Z
    56e0:	51 81       	ldd	r21, Z+1	; 0x01
    56e2:	62 81       	ldd	r22, Z+2	; 0x02
    56e4:	73 81       	ldd	r23, Z+3	; 0x03
    56e6:	08 80       	ld	r0, Y
    56e8:	04 c0       	rjmp	.+8      	; 0x56f2 <NextSlave+0xd4>
    56ea:	76 95       	lsr	r23
    56ec:	67 95       	ror	r22
    56ee:	57 95       	ror	r21
    56f0:	47 95       	ror	r20
    56f2:	0a 94       	dec	r0
    56f4:	d2 f7       	brpl	.-12     	; 0x56ea <NextSlave+0xcc>
    56f6:	40 ff       	sbrs	r20, 0
    56f8:	03 c0       	rjmp	.+6      	; 0x5700 <NextSlave+0xe2>
    56fa:	83 94       	inc	r8
    56fc:	87 14       	cp	r8, r7
    56fe:	10 f2       	brcs	.-124    	; 0x5684 <NextSlave+0x66>
	if (i==SlaveQt) {
    5700:	87 10       	cpse	r8, r7
    5702:	09 c0       	rjmp	.+18     	; 0x5716 <NextSlave+0xf8>
		SlavesOn(MB_N);
    5704:	89 2d       	mov	r24, r9
    5706:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <SlavesOn>
		if (++CurrSlave[MB_N]==SlaveQt)
    570a:	98 81       	ld	r25, Y
    570c:	9f 5f       	subi	r25, 0xFF	; 255
    570e:	98 83       	st	Y, r25
    5710:	98 11       	cpse	r25, r8
    5712:	01 c0       	rjmp	.+2      	; 0x5716 <NextSlave+0xf8>
			CurrSlave[MB_N] = 0;
    5714:	18 82       	st	Y, r1
	}
	CurrQuery[MB_N] = 0;
    5716:	f8 01       	movw	r30, r16
    5718:	e3 5f       	subi	r30, 0xF3	; 243
    571a:	f9 4f       	sbci	r31, 0xF9	; 249
    571c:	10 82       	st	Z, r1
	return Over;
}
    571e:	86 2d       	mov	r24, r6
    5720:	df 91       	pop	r29
    5722:	cf 91       	pop	r28
    5724:	1f 91       	pop	r17
    5726:	0f 91       	pop	r16
    5728:	ff 90       	pop	r15
    572a:	ef 90       	pop	r14
    572c:	df 90       	pop	r13
    572e:	cf 90       	pop	r12
    5730:	bf 90       	pop	r11
    5732:	af 90       	pop	r10
    5734:	9f 90       	pop	r9
    5736:	8f 90       	pop	r8
    5738:	7f 90       	pop	r7
    573a:	6f 90       	pop	r6
    573c:	5f 90       	pop	r5
    573e:	4f 90       	pop	r4
    5740:	08 95       	ret

00005742 <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    5742:	0f 93       	push	r16
    5744:	1f 93       	push	r17
    5746:	cf 93       	push	r28
    5748:	df 93       	push	r29
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    574a:	28 2f       	mov	r18, r24
    574c:	30 e0       	ldi	r19, 0x00	; 0
    574e:	f9 01       	movw	r30, r18
    5750:	ee 5d       	subi	r30, 0xDE	; 222
    5752:	f9 4f       	sbci	r31, 0xF9	; 249
    5754:	90 81       	ld	r25, Z
    5756:	92 30       	cpi	r25, 0x02	; 2
    5758:	11 f4       	brne	.+4      	; 0x575e <FailSlave+0x1c>
		MB_SingleState[MB_N] = MB_SingleIdle;
    575a:	10 82       	st	Z, r1
    575c:	54 c0       	rjmp	.+168    	; 0x5806 <FailSlave+0xc4>
	else{
		MB_CPT[MB_N][4]++;	// -    
    575e:	f9 01       	movw	r30, r18
    5760:	d4 e0       	ldi	r29, 0x04	; 4
    5762:	ee 0f       	add	r30, r30
    5764:	ff 1f       	adc	r31, r31
    5766:	da 95       	dec	r29
    5768:	e1 f7       	brne	.-8      	; 0x5762 <FailSlave+0x20>
    576a:	e7 5d       	subi	r30, 0xD7	; 215
    576c:	f4 4f       	sbci	r31, 0xF4	; 244
    576e:	40 85       	ldd	r20, Z+8	; 0x08
    5770:	51 85       	ldd	r21, Z+9	; 0x09
    5772:	4f 5f       	subi	r20, 0xFF	; 255
    5774:	5f 4f       	sbci	r21, 0xFF	; 255
    5776:	51 87       	std	Z+9, r21	; 0x09
    5778:	40 87       	std	Z+8, r20	; 0x08
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    577a:	f9 01       	movw	r30, r18
    577c:	ef 59       	subi	r30, 0x9F	; 159
    577e:	fd 4f       	sbci	r31, 0xFD	; 253
    5780:	90 81       	ld	r25, Z
    5782:	9f 5f       	subi	r25, 0xFF	; 255
    5784:	90 83       	st	Z, r25
    5786:	d9 01       	movw	r26, r18
    5788:	ac 52       	subi	r26, 0x2C	; 44
    578a:	b7 4f       	sbci	r27, 0xF7	; 247
    578c:	4c 91       	ld	r20, X
    578e:	94 13       	cpse	r25, r20
    5790:	3a c0       	rjmp	.+116    	; 0x5806 <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    5792:	d9 01       	movw	r26, r18
    5794:	aa 5f       	subi	r26, 0xFA	; 250
    5796:	b9 4f       	sbci	r27, 0xF9	; 249
    5798:	41 e0       	ldi	r20, 0x01	; 1
    579a:	50 e0       	ldi	r21, 0x00	; 0
    579c:	60 e0       	ldi	r22, 0x00	; 0
    579e:	70 e0       	ldi	r23, 0x00	; 0
    57a0:	0c 90       	ld	r0, X
    57a2:	04 c0       	rjmp	.+8      	; 0x57ac <FailSlave+0x6a>
    57a4:	44 0f       	add	r20, r20
    57a6:	55 1f       	adc	r21, r21
    57a8:	66 1f       	adc	r22, r22
    57aa:	77 1f       	adc	r23, r23
    57ac:	0a 94       	dec	r0
    57ae:	d2 f7       	brpl	.-12     	; 0x57a4 <FailSlave+0x62>
			SlaveOff[MB_N] |=S_N;
    57b0:	d9 01       	movw	r26, r18
    57b2:	aa 0f       	add	r26, r26
    57b4:	bb 1f       	adc	r27, r27
    57b6:	aa 0f       	add	r26, r26
    57b8:	bb 1f       	adc	r27, r27
    57ba:	ed 01       	movw	r28, r26
    57bc:	cc 5e       	subi	r28, 0xEC	; 236
    57be:	d4 4f       	sbci	r29, 0xF4	; 244
    57c0:	08 81       	ld	r16, Y
    57c2:	19 81       	ldd	r17, Y+1	; 0x01
    57c4:	2a 81       	ldd	r18, Y+2	; 0x02
    57c6:	3b 81       	ldd	r19, Y+3	; 0x03
    57c8:	04 2b       	or	r16, r20
    57ca:	15 2b       	or	r17, r21
    57cc:	26 2b       	or	r18, r22
    57ce:	37 2b       	or	r19, r23
    57d0:	08 83       	st	Y, r16
    57d2:	19 83       	std	Y+1, r17	; 0x01
    57d4:	2a 83       	std	Y+2, r18	; 0x02
    57d6:	3b 83       	std	Y+3, r19	; 0x03
			SlaveSkip[MB_N] |=S_N;
    57d8:	a3 5a       	subi	r26, 0xA3	; 163
    57da:	bd 4f       	sbci	r27, 0xFD	; 253
    57dc:	0d 91       	ld	r16, X+
    57de:	1d 91       	ld	r17, X+
    57e0:	2d 91       	ld	r18, X+
    57e2:	3c 91       	ld	r19, X
    57e4:	13 97       	sbiw	r26, 0x03	; 3
    57e6:	04 2b       	or	r16, r20
    57e8:	15 2b       	or	r17, r21
    57ea:	26 2b       	or	r18, r22
    57ec:	37 2b       	or	r19, r23
    57ee:	0d 93       	st	X+, r16
    57f0:	1d 93       	st	X+, r17
    57f2:	2d 93       	st	X+, r18
    57f4:	3c 93       	st	X, r19
    57f6:	13 97       	sbiw	r26, 0x03	; 3
			Try[MB_N] = 0;
    57f8:	10 82       	st	Z, r1
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    57fa:	df 91       	pop	r29
    57fc:	cf 91       	pop	r28
    57fe:	1f 91       	pop	r17
    5800:	0f 91       	pop	r16
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
			SlaveOff[MB_N] |=S_N;
			SlaveSkip[MB_N] |=S_N;
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
    5802:	0c 94 0f 2b 	jmp	0x561e	; 0x561e <NextSlave>
		}
	}
	return Over;
}
    5806:	80 e0       	ldi	r24, 0x00	; 0
    5808:	df 91       	pop	r29
    580a:	cf 91       	pop	r28
    580c:	1f 91       	pop	r17
    580e:	0f 91       	pop	r16
    5810:	08 95       	ret

00005812 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    5812:	1f 93       	push	r17
    5814:	cf 93       	push	r28
    5816:	df 93       	push	r29
    5818:	00 d0       	rcall	.+0      	; 0x581a <StartTimer32+0x8>
    581a:	00 d0       	rcall	.+0      	; 0x581c <StartTimer32+0xa>
    581c:	cd b7       	in	r28, 0x3d	; 61
    581e:	de b7       	in	r29, 0x3e	; 62
    5820:	18 2f       	mov	r17, r24
	IntOff();
    5822:	49 83       	std	Y+1, r20	; 0x01
    5824:	5a 83       	std	Y+2, r21	; 0x02
    5826:	6b 83       	std	Y+3, r22	; 0x03
    5828:	7c 83       	std	Y+4, r23	; 0x04
    582a:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	if ((Timer32[TimerN]=Timeout)>0)
    582e:	84 e0       	ldi	r24, 0x04	; 4
    5830:	18 9f       	mul	r17, r24
    5832:	f0 01       	movw	r30, r0
    5834:	11 24       	eor	r1, r1
    5836:	ea 57       	subi	r30, 0x7A	; 122
    5838:	fd 4f       	sbci	r31, 0xFD	; 253
    583a:	49 81       	ldd	r20, Y+1	; 0x01
    583c:	5a 81       	ldd	r21, Y+2	; 0x02
    583e:	6b 81       	ldd	r22, Y+3	; 0x03
    5840:	7c 81       	ldd	r23, Y+4	; 0x04
    5842:	40 83       	st	Z, r20
    5844:	51 83       	std	Z+1, r21	; 0x01
    5846:	62 83       	std	Z+2, r22	; 0x02
    5848:	73 83       	std	Z+3, r23	; 0x03
    584a:	e1 2f       	mov	r30, r17
    584c:	e6 95       	lsr	r30
    584e:	e6 95       	lsr	r30
    5850:	e6 95       	lsr	r30
    5852:	17 70       	andi	r17, 0x07	; 7
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    5854:	f0 e0       	ldi	r31, 0x00	; 0
    5856:	e2 59       	subi	r30, 0x92	; 146
    5858:	fd 4f       	sbci	r31, 0xFD	; 253
    585a:	80 81       	ld	r24, Z
    585c:	21 e0       	ldi	r18, 0x01	; 1
    585e:	30 e0       	ldi	r19, 0x00	; 0
    5860:	01 2e       	mov	r0, r17
    5862:	01 c0       	rjmp	.+2      	; 0x5866 <StartTimer32+0x54>
    5864:	22 0f       	add	r18, r18
    5866:	0a 94       	dec	r0
    5868:	ea f7       	brpl	.-6      	; 0x5864 <StartTimer32+0x52>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    586a:	45 2b       	or	r20, r21
    586c:	46 2b       	or	r20, r22
    586e:	47 2b       	or	r20, r23
    5870:	21 f0       	breq	.+8      	; 0x587a <StartTimer32+0x68>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    5872:	20 95       	com	r18
    5874:	28 23       	and	r18, r24
    5876:	20 83       	st	Z, r18
    5878:	02 c0       	rjmp	.+4      	; 0x587e <StartTimer32+0x6c>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    587a:	82 2b       	or	r24, r18
    587c:	80 83       	st	Z, r24
	IntOn();
}
    587e:	0f 90       	pop	r0
    5880:	0f 90       	pop	r0
    5882:	0f 90       	pop	r0
    5884:	0f 90       	pop	r0
    5886:	df 91       	pop	r29
    5888:	cf 91       	pop	r28
    588a:	1f 91       	pop	r17
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    588c:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

00005890 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    5890:	a8 2f       	mov	r26, r24
    5892:	a6 95       	lsr	r26
    5894:	a6 95       	lsr	r26
    5896:	a6 95       	lsr	r26
    5898:	b0 e0       	ldi	r27, 0x00	; 0
    589a:	a3 58       	subi	r26, 0x83	; 131
    589c:	bd 4f       	sbci	r27, 0xFD	; 253
    589e:	2c 91       	ld	r18, X
    58a0:	30 e0       	ldi	r19, 0x00	; 0
    58a2:	98 2f       	mov	r25, r24
    58a4:	97 70       	andi	r25, 0x07	; 7
    58a6:	02 c0       	rjmp	.+4      	; 0x58ac <Timer8Stopp+0x1c>
    58a8:	35 95       	asr	r19
    58aa:	27 95       	ror	r18
    58ac:	9a 95       	dec	r25
    58ae:	e2 f7       	brpl	.-8      	; 0x58a8 <Timer8Stopp+0x18>
    58b0:	20 ff       	sbrs	r18, 0
    58b2:	07 c0       	rjmp	.+14     	; 0x58c2 <Timer8Stopp+0x32>
    58b4:	e8 2f       	mov	r30, r24
    58b6:	f0 e0       	ldi	r31, 0x00	; 0
    58b8:	ea 55       	subi	r30, 0x5A	; 90
    58ba:	fc 4f       	sbci	r31, 0xFC	; 252
    58bc:	90 81       	ld	r25, Z
    58be:	81 e0       	ldi	r24, 0x01	; 1
    58c0:	91 11       	cpse	r25, r1
    58c2:	80 e0       	ldi	r24, 0x00	; 0
}
    58c4:	08 95       	ret

000058c6 <Timer16Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
    58c6:	cf 93       	push	r28
    58c8:	c8 2f       	mov	r28, r24
	IntOff();
    58ca:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    58ce:	ac 2f       	mov	r26, r28
    58d0:	a6 95       	lsr	r26
    58d2:	a6 95       	lsr	r26
    58d4:	a6 95       	lsr	r26
    58d6:	b0 e0       	ldi	r27, 0x00	; 0
    58d8:	ac 58       	subi	r26, 0x8C	; 140
    58da:	bd 4f       	sbci	r27, 0xFD	; 253
    58dc:	2c 91       	ld	r18, X
    58de:	30 e0       	ldi	r19, 0x00	; 0
    58e0:	8c 2f       	mov	r24, r28
    58e2:	87 70       	andi	r24, 0x07	; 7
    58e4:	02 c0       	rjmp	.+4      	; 0x58ea <Timer16Stopp+0x24>
    58e6:	35 95       	asr	r19
    58e8:	27 95       	ror	r18
    58ea:	8a 95       	dec	r24
    58ec:	e2 f7       	brpl	.-8      	; 0x58e6 <Timer16Stopp+0x20>
    58ee:	20 ff       	sbrs	r18, 0
    58f0:	0b c0       	rjmp	.+22     	; 0x5908 <Timer16Stopp+0x42>
    58f2:	ec 2f       	mov	r30, r28
    58f4:	f0 e0       	ldi	r31, 0x00	; 0
    58f6:	ee 0f       	add	r30, r30
    58f8:	ff 1f       	adc	r31, r31
    58fa:	ea 5d       	subi	r30, 0xDA	; 218
    58fc:	fc 4f       	sbci	r31, 0xFC	; 252
    58fe:	20 81       	ld	r18, Z
    5900:	31 81       	ldd	r19, Z+1	; 0x01
    5902:	c1 e0       	ldi	r28, 0x01	; 1
    5904:	23 2b       	or	r18, r19
    5906:	09 f0       	breq	.+2      	; 0x590a <Timer16Stopp+0x44>
    5908:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    590a:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
	return T_S;
}
    590e:	8c 2f       	mov	r24, r28
    5910:	cf 91       	pop	r28
    5912:	08 95       	ret

00005914 <Timer32Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
    5914:	cf 93       	push	r28
    5916:	c8 2f       	mov	r28, r24
	IntOff();
    5918:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    591c:	ac 2f       	mov	r26, r28
    591e:	a6 95       	lsr	r26
    5920:	a6 95       	lsr	r26
    5922:	a6 95       	lsr	r26
    5924:	b0 e0       	ldi	r27, 0x00	; 0
    5926:	a2 59       	subi	r26, 0x92	; 146
    5928:	bd 4f       	sbci	r27, 0xFD	; 253
    592a:	2c 91       	ld	r18, X
    592c:	30 e0       	ldi	r19, 0x00	; 0
    592e:	8c 2f       	mov	r24, r28
    5930:	87 70       	andi	r24, 0x07	; 7
    5932:	02 c0       	rjmp	.+4      	; 0x5938 <Timer32Stopp+0x24>
    5934:	35 95       	asr	r19
    5936:	27 95       	ror	r18
    5938:	8a 95       	dec	r24
    593a:	e2 f7       	brpl	.-8      	; 0x5934 <Timer32Stopp+0x20>
    593c:	20 ff       	sbrs	r18, 0
    593e:	0f c0       	rjmp	.+30     	; 0x595e <Timer32Stopp+0x4a>
    5940:	84 e0       	ldi	r24, 0x04	; 4
    5942:	c8 9f       	mul	r28, r24
    5944:	f0 01       	movw	r30, r0
    5946:	11 24       	eor	r1, r1
    5948:	ea 57       	subi	r30, 0x7A	; 122
    594a:	fd 4f       	sbci	r31, 0xFD	; 253
    594c:	40 81       	ld	r20, Z
    594e:	51 81       	ldd	r21, Z+1	; 0x01
    5950:	62 81       	ldd	r22, Z+2	; 0x02
    5952:	73 81       	ldd	r23, Z+3	; 0x03
    5954:	c1 e0       	ldi	r28, 0x01	; 1
    5956:	45 2b       	or	r20, r21
    5958:	46 2b       	or	r20, r22
    595a:	47 2b       	or	r20, r23
    595c:	09 f0       	breq	.+2      	; 0x5960 <Timer32Stopp+0x4c>
    595e:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5960:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
	return T_S;
}
    5964:	8c 2f       	mov	r24, r28
    5966:	cf 91       	pop	r28
    5968:	08 95       	ret

0000596a <ResetTimer16>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    596a:	cf 93       	push	r28
    596c:	c8 2f       	mov	r28, r24
	IntOff();
    596e:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    5972:	ac 2f       	mov	r26, r28
    5974:	a6 95       	lsr	r26
    5976:	a6 95       	lsr	r26
    5978:	a6 95       	lsr	r26
    597a:	b0 e0       	ldi	r27, 0x00	; 0
    597c:	ac 58       	subi	r26, 0x8C	; 140
    597e:	bd 4f       	sbci	r27, 0xFD	; 253
    5980:	8c 91       	ld	r24, X
    5982:	9c 2f       	mov	r25, r28
    5984:	97 70       	andi	r25, 0x07	; 7
    5986:	21 e0       	ldi	r18, 0x01	; 1
    5988:	30 e0       	ldi	r19, 0x00	; 0
    598a:	01 c0       	rjmp	.+2      	; 0x598e <ResetTimer16+0x24>
    598c:	22 0f       	add	r18, r18
    598e:	9a 95       	dec	r25
    5990:	ea f7       	brpl	.-6      	; 0x598c <ResetTimer16+0x22>
    5992:	82 2b       	or	r24, r18
    5994:	8c 93       	st	X, r24
	Timer16[TimerN] = 0;
    5996:	ec 2f       	mov	r30, r28
    5998:	f0 e0       	ldi	r31, 0x00	; 0
    599a:	ee 0f       	add	r30, r30
    599c:	ff 1f       	adc	r31, r31
    599e:	ea 5d       	subi	r30, 0xDA	; 218
    59a0:	fc 4f       	sbci	r31, 0xFC	; 252
    59a2:	11 82       	std	Z+1, r1	; 0x01
    59a4:	10 82       	st	Z, r1
	IntOn();
}
    59a6:	cf 91       	pop	r28
ResetTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
	Timer16[TimerN] = 0;
	IntOn();
    59a8:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

000059ac <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    59ac:	60 91 23 06 	lds	r22, 0x0623
    59b0:	85 ea       	ldi	r24, 0xA5	; 165
    59b2:	91 e0       	ldi	r25, 0x01	; 1
    59b4:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    59b8:	60 91 48 0e 	lds	r22, 0x0E48
    59bc:	70 91 49 0e 	lds	r23, 0x0E49
    59c0:	83 ea       	ldi	r24, 0xA3	; 163
    59c2:	91 e0       	ldi	r25, 0x01	; 1
    59c4:	0c 94 c9 29 	jmp	0x5392	; 0x5392 <eww>

000059c8 <TimeInit>:
		CCP = CCP_IOREG_gc; CLK.CTRL = CLK_SCLKSEL_PLL_gc;
		CCP = CCP_IOREG_gc; CLK.LOCK = CLK_LOCK_bm;
	#endif

	// WDT
	WdtOn();
    59c8:	0e 94 81 2a 	call	0x5502	; 0x5502 <WdtOn>

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    59cc:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    59ce:	8a ee       	ldi	r24, 0xEA	; 234
    59d0:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
    59d2:	80 e2       	ldi	r24, 0x20	; 32
    59d4:	9e e4       	ldi	r25, 0x4E	; 78
    59d6:	9b bd       	out	0x2b, r25	; 43
    59d8:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
    59da:	87 b7       	in	r24, 0x37	; 55
    59dc:	80 61       	ori	r24, 0x10	; 16
    59de:	87 bf       	out	0x37, r24	; 55
    59e0:	80 e0       	ldi	r24, 0x00	; 0
    59e2:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    59e4:	2f ef       	ldi	r18, 0xFF	; 255
    59e6:	fc 01       	movw	r30, r24
    59e8:	e3 58       	subi	r30, 0x83	; 131
    59ea:	fd 4f       	sbci	r31, 0xFD	; 253
    59ec:	20 83       	st	Z, r18
    59ee:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    59f0:	87 30       	cpi	r24, 0x07	; 7
    59f2:	91 05       	cpc	r25, r1
    59f4:	c1 f7       	brne	.-16     	; 0x59e6 <TimeInit+0x1e>
    59f6:	80 e0       	ldi	r24, 0x00	; 0
    59f8:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    59fa:	3f ef       	ldi	r19, 0xFF	; 255
    59fc:	fc 01       	movw	r30, r24
    59fe:	ec 58       	subi	r30, 0x8C	; 140
    5a00:	fd 4f       	sbci	r31, 0xFD	; 253
    5a02:	2f ef       	ldi	r18, 0xFF	; 255
    5a04:	30 83       	st	Z, r19
    5a06:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    5a08:	89 30       	cpi	r24, 0x09	; 9
    5a0a:	91 05       	cpc	r25, r1
    5a0c:	b9 f7       	brne	.-18     	; 0x59fc <TimeInit+0x34>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    5a0e:	20 93 6e 02 	sts	0x026E, r18
    5a12:	20 93 6f 02 	sts	0x026F, r18
    5a16:	20 93 70 02 	sts	0x0270, r18
    5a1a:	20 93 71 02 	sts	0x0271, r18
    5a1e:	20 93 72 02 	sts	0x0272, r18
    5a22:	20 93 73 02 	sts	0x0273, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5a26:	85 ea       	ldi	r24, 0xA5	; 165
    5a28:	91 e0       	ldi	r25, 0x01	; 1
    5a2a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    5a2e:	80 93 23 06 	sts	0x0623, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5a32:	83 ea       	ldi	r24, 0xA3	; 163
    5a34:	91 e0       	ldi	r25, 0x01	; 1
    5a36:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
    5a3a:	90 93 49 0e 	sts	0x0E49, r25
    5a3e:	80 93 48 0e 	sts	0x0E48, r24
    5a42:	08 95       	ret

00005a44 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    5a44:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    5a48:	91 e0       	ldi	r25, 0x01	; 1
    5a4a:	98 0f       	add	r25, r24
    5a4c:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    5a50:	80 93 6d 02 	sts	0x026D, r24
	StartTimer8(TD_Scan, 0xFF);
    5a54:	6f ef       	ldi	r22, 0xFF	; 255
    5a56:	0c 94 9a 2a 	jmp	0x5534	; 0x5534 <StartTimer8>

00005a5a <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    5a5a:	1f 92       	push	r1
    5a5c:	0f 92       	push	r0
    5a5e:	0f b6       	in	r0, 0x3f	; 63
    5a60:	0f 92       	push	r0
    5a62:	11 24       	eor	r1, r1
    5a64:	0b b6       	in	r0, 0x3b	; 59
    5a66:	0f 92       	push	r0
    5a68:	2f 93       	push	r18
    5a6a:	3f 93       	push	r19
    5a6c:	4f 93       	push	r20
    5a6e:	5f 93       	push	r21
    5a70:	6f 93       	push	r22
    5a72:	8f 93       	push	r24
    5a74:	9f 93       	push	r25
    5a76:	ef 93       	push	r30
    5a78:	ff 93       	push	r31
	TickCounter++;
    5a7a:	80 91 6c 02 	lds	r24, 0x026C
    5a7e:	8f 5f       	subi	r24, 0xFF	; 255
    5a80:	80 93 6c 02 	sts	0x026C, r24
    5a84:	80 e0       	ldi	r24, 0x00	; 0
    5a86:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5a88:	41 e0       	ldi	r20, 0x01	; 1
    5a8a:	50 e0       	ldi	r21, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    5a8c:	20 91 84 02 	lds	r18, 0x0284
    5a90:	30 e0       	ldi	r19, 0x00	; 0
    5a92:	08 2e       	mov	r0, r24
    5a94:	02 c0       	rjmp	.+4      	; 0x5a9a <__vector_12+0x40>
    5a96:	35 95       	asr	r19
    5a98:	27 95       	ror	r18
    5a9a:	0a 94       	dec	r0
    5a9c:	e2 f7       	brpl	.-8      	; 0x5a96 <__vector_12+0x3c>
    5a9e:	20 fd       	sbrc	r18, 0
    5aa0:	13 c0       	rjmp	.+38     	; 0x5ac8 <__vector_12+0x6e>
    5aa2:	fc 01       	movw	r30, r24
    5aa4:	ea 52       	subi	r30, 0x2A	; 42
    5aa6:	fc 4f       	sbci	r31, 0xFC	; 252
    5aa8:	20 81       	ld	r18, Z
    5aaa:	21 50       	subi	r18, 0x01	; 1
    5aac:	20 83       	st	Z, r18
    5aae:	21 11       	cpse	r18, r1
    5ab0:	0b c0       	rjmp	.+22     	; 0x5ac8 <__vector_12+0x6e>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5ab2:	60 91 84 02 	lds	r22, 0x0284
    5ab6:	9a 01       	movw	r18, r20
    5ab8:	08 2e       	mov	r0, r24
    5aba:	01 c0       	rjmp	.+2      	; 0x5abe <__vector_12+0x64>
    5abc:	22 0f       	add	r18, r18
    5abe:	0a 94       	dec	r0
    5ac0:	ea f7       	brpl	.-6      	; 0x5abc <__vector_12+0x62>
    5ac2:	62 2b       	or	r22, r18
    5ac4:	60 93 84 02 	sts	0x0284, r22
    5ac8:	01 96       	adiw	r24, 0x01	; 1
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    5aca:	88 30       	cpi	r24, 0x08	; 8
    5acc:	91 05       	cpc	r25, r1
    5ace:	f1 f6       	brne	.-68     	; 0x5a8c <__vector_12+0x32>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    5ad0:	ff 91       	pop	r31
    5ad2:	ef 91       	pop	r30
    5ad4:	9f 91       	pop	r25
    5ad6:	8f 91       	pop	r24
    5ad8:	6f 91       	pop	r22
    5ada:	5f 91       	pop	r21
    5adc:	4f 91       	pop	r20
    5ade:	3f 91       	pop	r19
    5ae0:	2f 91       	pop	r18
    5ae2:	0f 90       	pop	r0
    5ae4:	0b be       	out	0x3b, r0	; 59
    5ae6:	0f 90       	pop	r0
    5ae8:	0f be       	out	0x3f, r0	; 63
    5aea:	0f 90       	pop	r0
    5aec:	1f 90       	pop	r1
    5aee:	18 95       	reti

00005af0 <TimersInc>:
void 
TimersInc(void)
{
    5af0:	ef 92       	push	r14
    5af2:	ff 92       	push	r15
    5af4:	0f 93       	push	r16
    5af6:	1f 93       	push	r17
    5af8:	cf 93       	push	r28
    5afa:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    5afc:	f8 94       	cli
	TickCounterVar = TickCounter;
    5afe:	00 91 6c 02 	lds	r16, 0x026C
	TickCounter = 0;
    5b02:	10 92 6c 02 	sts	0x026C, r1
	sei();
    5b06:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b08:	10 e0       	ldi	r17, 0x00	; 0
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    5b0a:	ee 24       	eor	r14, r14
    5b0c:	e3 94       	inc	r14
    5b0e:	f1 2c       	mov	r15, r1
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b10:	10 17       	cp	r17, r16
    5b12:	09 f4       	brne	.+2      	; 0x5b16 <TimersInc+0x26>
    5b14:	e2 c0       	rjmp	.+452    	; 0x5cda <TimersInc+0x1ea>
		LiveTime++;
    5b16:	80 91 63 09 	lds	r24, 0x0963
    5b1a:	90 91 64 09 	lds	r25, 0x0964
    5b1e:	a0 91 65 09 	lds	r26, 0x0965
    5b22:	b0 91 66 09 	lds	r27, 0x0966
    5b26:	01 96       	adiw	r24, 0x01	; 1
    5b28:	a1 1d       	adc	r26, r1
    5b2a:	b1 1d       	adc	r27, r1
    5b2c:	80 93 63 09 	sts	0x0963, r24
    5b30:	90 93 64 09 	sts	0x0964, r25
    5b34:	a0 93 65 09 	sts	0x0965, r26
    5b38:	b0 93 66 09 	sts	0x0966, r27
    5b3c:	80 e0       	ldi	r24, 0x00	; 0
    5b3e:	90 e0       	ldi	r25, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    5b40:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    5b42:	e8 2f       	mov	r30, r24
    5b44:	e6 95       	lsr	r30
    5b46:	e6 95       	lsr	r30
    5b48:	e6 95       	lsr	r30
    5b4a:	f0 e0       	ldi	r31, 0x00	; 0
    5b4c:	e3 58       	subi	r30, 0x83	; 131
    5b4e:	fd 4f       	sbci	r31, 0xFD	; 253
    5b50:	20 81       	ld	r18, Z
    5b52:	58 2f       	mov	r21, r24
    5b54:	57 70       	andi	r21, 0x07	; 7
    5b56:	30 e0       	ldi	r19, 0x00	; 0
    5b58:	05 2e       	mov	r0, r21
    5b5a:	02 c0       	rjmp	.+4      	; 0x5b60 <TimersInc+0x70>
    5b5c:	35 95       	asr	r19
    5b5e:	27 95       	ror	r18
    5b60:	0a 94       	dec	r0
    5b62:	e2 f7       	brpl	.-8      	; 0x5b5c <TimersInc+0x6c>
    5b64:	20 fd       	sbrc	r18, 0
    5b66:	11 c0       	rjmp	.+34     	; 0x5b8a <TimersInc+0x9a>
    5b68:	dc 01       	movw	r26, r24
    5b6a:	aa 55       	subi	r26, 0x5A	; 90
    5b6c:	bc 4f       	sbci	r27, 0xFC	; 252
    5b6e:	3c 91       	ld	r19, X
    5b70:	31 50       	subi	r19, 0x01	; 1
    5b72:	3c 93       	st	X, r19
    5b74:	31 11       	cpse	r19, r1
    5b76:	09 c0       	rjmp	.+18     	; 0x5b8a <TimersInc+0x9a>
				Timer8Flg[i/8] |=(1<<i%8);
    5b78:	40 81       	ld	r20, Z
    5b7a:	97 01       	movw	r18, r14
    5b7c:	05 2e       	mov	r0, r21
    5b7e:	01 c0       	rjmp	.+2      	; 0x5b82 <TimersInc+0x92>
    5b80:	22 0f       	add	r18, r18
    5b82:	0a 94       	dec	r0
    5b84:	ea f7       	brpl	.-6      	; 0x5b80 <TimersInc+0x90>
    5b86:	42 2b       	or	r20, r18
    5b88:	40 83       	st	Z, r20
			sei();
    5b8a:	78 94       	sei
    5b8c:	01 96       	adiw	r24, 0x01	; 1
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    5b8e:	80 33       	cpi	r24, 0x30	; 48
    5b90:	91 05       	cpc	r25, r1
    5b92:	b1 f6       	brne	.-84     	; 0x5b40 <TimersInc+0x50>
    5b94:	80 e0       	ldi	r24, 0x00	; 0
    5b96:	90 e0       	ldi	r25, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    5b98:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    5b9a:	e8 2f       	mov	r30, r24
    5b9c:	e6 95       	lsr	r30
    5b9e:	e6 95       	lsr	r30
    5ba0:	e6 95       	lsr	r30
    5ba2:	f0 e0       	ldi	r31, 0x00	; 0
    5ba4:	ec 58       	subi	r30, 0x8C	; 140
    5ba6:	fd 4f       	sbci	r31, 0xFD	; 253
    5ba8:	20 81       	ld	r18, Z
    5baa:	58 2f       	mov	r21, r24
    5bac:	57 70       	andi	r21, 0x07	; 7
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	05 2e       	mov	r0, r21
    5bb2:	02 c0       	rjmp	.+4      	; 0x5bb8 <TimersInc+0xc8>
    5bb4:	35 95       	asr	r19
    5bb6:	27 95       	ror	r18
    5bb8:	0a 94       	dec	r0
    5bba:	e2 f7       	brpl	.-8      	; 0x5bb4 <TimersInc+0xc4>
    5bbc:	20 fd       	sbrc	r18, 0
    5bbe:	18 c0       	rjmp	.+48     	; 0x5bf0 <TimersInc+0x100>
    5bc0:	dc 01       	movw	r26, r24
    5bc2:	aa 0f       	add	r26, r26
    5bc4:	bb 1f       	adc	r27, r27
    5bc6:	aa 5d       	subi	r26, 0xDA	; 218
    5bc8:	bc 4f       	sbci	r27, 0xFC	; 252
    5bca:	2d 91       	ld	r18, X+
    5bcc:	3c 91       	ld	r19, X
    5bce:	11 97       	sbiw	r26, 0x01	; 1
    5bd0:	21 50       	subi	r18, 0x01	; 1
    5bd2:	31 09       	sbc	r19, r1
    5bd4:	11 96       	adiw	r26, 0x01	; 1
    5bd6:	3c 93       	st	X, r19
    5bd8:	2e 93       	st	-X, r18
    5bda:	23 2b       	or	r18, r19
    5bdc:	49 f4       	brne	.+18     	; 0x5bf0 <TimersInc+0x100>
				Timer16Flg[i/8] |=(1<<i%8);
    5bde:	40 81       	ld	r20, Z
    5be0:	97 01       	movw	r18, r14
    5be2:	05 2e       	mov	r0, r21
    5be4:	01 c0       	rjmp	.+2      	; 0x5be8 <TimersInc+0xf8>
    5be6:	22 0f       	add	r18, r18
    5be8:	0a 94       	dec	r0
    5bea:	ea f7       	brpl	.-6      	; 0x5be6 <TimersInc+0xf6>
    5bec:	42 2b       	or	r20, r18
    5bee:	40 83       	st	Z, r20
			sei();
    5bf0:	78 94       	sei
    5bf2:	01 96       	adiw	r24, 0x01	; 1
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    5bf4:	80 34       	cpi	r24, 0x40	; 64
    5bf6:	91 05       	cpc	r25, r1
    5bf8:	79 f6       	brne	.-98     	; 0x5b98 <TimersInc+0xa8>
    5bfa:	20 e0       	ldi	r18, 0x00	; 0
    5bfc:	30 e0       	ldi	r19, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    5bfe:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    5c00:	e2 2f       	mov	r30, r18
    5c02:	e6 95       	lsr	r30
    5c04:	e6 95       	lsr	r30
    5c06:	e6 95       	lsr	r30
    5c08:	f0 e0       	ldi	r31, 0x00	; 0
    5c0a:	e2 59       	subi	r30, 0x92	; 146
    5c0c:	fd 4f       	sbci	r31, 0xFD	; 253
    5c0e:	80 81       	ld	r24, Z
    5c10:	62 2f       	mov	r22, r18
    5c12:	67 70       	andi	r22, 0x07	; 7
    5c14:	90 e0       	ldi	r25, 0x00	; 0
    5c16:	06 2e       	mov	r0, r22
    5c18:	02 c0       	rjmp	.+4      	; 0x5c1e <TimersInc+0x12e>
    5c1a:	95 95       	asr	r25
    5c1c:	87 95       	ror	r24
    5c1e:	0a 94       	dec	r0
    5c20:	e2 f7       	brpl	.-8      	; 0x5c1a <TimersInc+0x12a>
    5c22:	80 fd       	sbrc	r24, 0
    5c24:	20 c0       	rjmp	.+64     	; 0x5c66 <TimersInc+0x176>
    5c26:	a9 01       	movw	r20, r18
    5c28:	44 0f       	add	r20, r20
    5c2a:	55 1f       	adc	r21, r21
    5c2c:	44 0f       	add	r20, r20
    5c2e:	55 1f       	adc	r21, r21
    5c30:	4a 57       	subi	r20, 0x7A	; 122
    5c32:	5d 4f       	sbci	r21, 0xFD	; 253
    5c34:	ea 01       	movw	r28, r20
    5c36:	88 81       	ld	r24, Y
    5c38:	99 81       	ldd	r25, Y+1	; 0x01
    5c3a:	aa 81       	ldd	r26, Y+2	; 0x02
    5c3c:	bb 81       	ldd	r27, Y+3	; 0x03
    5c3e:	01 97       	sbiw	r24, 0x01	; 1
    5c40:	a1 09       	sbc	r26, r1
    5c42:	b1 09       	sbc	r27, r1
    5c44:	88 83       	st	Y, r24
    5c46:	99 83       	std	Y+1, r25	; 0x01
    5c48:	aa 83       	std	Y+2, r26	; 0x02
    5c4a:	bb 83       	std	Y+3, r27	; 0x03
    5c4c:	89 2b       	or	r24, r25
    5c4e:	8a 2b       	or	r24, r26
    5c50:	8b 2b       	or	r24, r27
    5c52:	49 f4       	brne	.+18     	; 0x5c66 <TimersInc+0x176>
				Timer32Flg[i/8] |=(1<<i%8);	
    5c54:	40 81       	ld	r20, Z
    5c56:	c7 01       	movw	r24, r14
    5c58:	06 2e       	mov	r0, r22
    5c5a:	01 c0       	rjmp	.+2      	; 0x5c5e <TimersInc+0x16e>
    5c5c:	88 0f       	add	r24, r24
    5c5e:	0a 94       	dec	r0
    5c60:	ea f7       	brpl	.-6      	; 0x5c5c <TimersInc+0x16c>
    5c62:	48 2b       	or	r20, r24
    5c64:	40 83       	st	Z, r20
			sei();
    5c66:	78 94       	sei
    5c68:	2f 5f       	subi	r18, 0xFF	; 255
    5c6a:	3f 4f       	sbci	r19, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    5c6c:	28 32       	cpi	r18, 0x28	; 40
    5c6e:	31 05       	cpc	r19, r1
    5c70:	31 f6       	brne	.-116    	; 0x5bfe <TimersInc+0x10e>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    5c72:	80 91 45 02 	lds	r24, 0x0245
    5c76:	8f 5f       	subi	r24, 0xFF	; 255
    5c78:	80 93 45 02 	sts	0x0245, r24
    5c7c:	84 36       	cpi	r24, 0x64	; 100
    5c7e:	59 f5       	brne	.+86     	; 0x5cd6 <TimersInc+0x1e6>
			Timer10ms = 0;
    5c80:	10 92 45 02 	sts	0x0245, r1
			ScanPerSec = ScanCount;
    5c84:	80 91 45 09 	lds	r24, 0x0945
    5c88:	90 91 46 09 	lds	r25, 0x0946
    5c8c:	90 93 72 09 	sts	0x0972, r25
    5c90:	80 93 71 09 	sts	0x0971, r24
 			ScanCount = 0;
    5c94:	10 92 46 09 	sts	0x0946, r1
    5c98:	10 92 45 09 	sts	0x0945, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    5c9c:	80 91 0e 0b 	lds	r24, 0x0B0E
    5ca0:	8f 5f       	subi	r24, 0xFF	; 255
    5ca2:	80 93 0e 0b 	sts	0x0B0E, r24
    5ca6:	8c 33       	cpi	r24, 0x3C	; 60
    5ca8:	b1 f4       	brne	.+44     	; 0x5cd6 <TimersInc+0x1e6>
		Timer1s = 0;
    5caa:	10 92 0e 0b 	sts	0x0B0E, r1
		if (++Timer1min==60) {
    5cae:	80 91 23 06 	lds	r24, 0x0623
    5cb2:	8f 5f       	subi	r24, 0xFF	; 255
    5cb4:	80 93 23 06 	sts	0x0623, r24
    5cb8:	8c 33       	cpi	r24, 0x3C	; 60
    5cba:	69 f4       	brne	.+26     	; 0x5cd6 <TimersInc+0x1e6>
			Timer1min = 0;
    5cbc:	10 92 23 06 	sts	0x0623, r1
			++Timer1hour;
    5cc0:	80 91 48 0e 	lds	r24, 0x0E48
    5cc4:	90 91 49 0e 	lds	r25, 0x0E49
    5cc8:	01 96       	adiw	r24, 0x01	; 1
    5cca:	90 93 49 0e 	sts	0x0E49, r25
    5cce:	80 93 48 0e 	sts	0x0E48, r24
			OnTimeSave();
    5cd2:	0e 94 d6 2c 	call	0x59ac	; 0x59ac <OnTimeSave>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5cd6:	1f 5f       	subi	r17, 0xFF	; 255
    5cd8:	1b cf       	rjmp	.-458    	; 0x5b10 <TimersInc+0x20>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    5cda:	df 91       	pop	r29
    5cdc:	cf 91       	pop	r28
    5cde:	1f 91       	pop	r17
    5ce0:	0f 91       	pop	r16
    5ce2:	ff 90       	pop	r15
    5ce4:	ef 90       	pop	r14
    5ce6:	08 95       	ret

00005ce8 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    5ce8:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    5cea:	80 91 45 09 	lds	r24, 0x0945
    5cee:	90 91 46 09 	lds	r25, 0x0946
    5cf2:	01 96       	adiw	r24, 0x01	; 1
    5cf4:	90 93 46 09 	sts	0x0946, r25
    5cf8:	80 93 45 09 	sts	0x0945, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    5cfc:	80 91 6d 02 	lds	r24, 0x026D
    5d00:	e8 2f       	mov	r30, r24
    5d02:	f0 e0       	ldi	r31, 0x00	; 0
    5d04:	ea 55       	subi	r30, 0x5A	; 90
    5d06:	fc 4f       	sbci	r31, 0xFC	; 252
    5d08:	90 81       	ld	r25, Z
    5d0a:	90 95       	com	r25
    5d0c:	90 93 3e 09 	sts	0x093E, r25
    5d10:	20 91 24 06 	lds	r18, 0x0624
    5d14:	29 17       	cp	r18, r25
    5d16:	10 f4       	brcc	.+4      	; 0x5d1c <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    5d18:	90 93 24 06 	sts	0x0624, r25
	StartTimer8(TD_Scan, 0xFF);
    5d1c:	6f ef       	ldi	r22, 0xFF	; 255
    5d1e:	0c 94 9a 2a 	jmp	0x5534	; 0x5534 <StartTimer8>

00005d22 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    5d22:	bc 01       	movw	r22, r24
    5d24:	80 e0       	ldi	r24, 0x00	; 0
    5d26:	90 e0       	ldi	r25, 0x00	; 0
    5d28:	0e 94 10 6e 	call	0xdc20	; 0xdc20 <__floatunsisf>
    5d2c:	2d ec       	ldi	r18, 0xCD	; 205
    5d2e:	3c ec       	ldi	r19, 0xCC	; 204
    5d30:	4c e4       	ldi	r20, 0x4C	; 76
    5d32:	5f e3       	ldi	r21, 0x3F	; 63
    5d34:	0e 94 9e 6e 	call	0xdd3c	; 0xdd3c <__mulsf3>
    5d38:	0e 94 e4 6d 	call	0xdbc8	; 0xdbc8 <__fixunssfsi>
	while (Delay--)
    5d3c:	61 15       	cp	r22, r1
    5d3e:	71 05       	cpc	r23, r1
    5d40:	39 f0       	breq	.+14     	; 0x5d50 <Delay_us+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5d42:	85 e0       	ldi	r24, 0x05	; 5
    5d44:	8a 95       	dec	r24
    5d46:	f1 f7       	brne	.-4      	; 0x5d44 <Delay_us+0x22>
    5d48:	00 00       	nop
    5d4a:	61 50       	subi	r22, 0x01	; 1
    5d4c:	71 09       	sbc	r23, r1
    5d4e:	f6 cf       	rjmp	.-20     	; 0x5d3c <Delay_us+0x1a>
		_delay_us(1);
}
    5d50:	08 95       	ret

00005d52 <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5d52:	8c 9a       	sbi	0x11, 4	; 17
    5d54:	94 98       	cbi	0x12, 4	; 18
    5d56:	08 95       	ret

00005d58 <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    5d58:	81 11       	cpse	r24, r1
    5d5a:	0a c0       	rjmp	.+20     	; 0x5d70 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5d5c:	80 91 64 00 	lds	r24, 0x0064
    5d60:	81 60       	ori	r24, 0x01	; 1
    5d62:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d66:	80 91 65 00 	lds	r24, 0x0065
    5d6a:	8e 7f       	andi	r24, 0xFE	; 254
    5d6c:	80 93 65 00 	sts	0x0065, r24
    5d70:	08 95       	ret

00005d72 <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5d72:	81 11       	cpse	r24, r1
    5d74:	0a c0       	rjmp	.+20     	; 0x5d8a <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    5d76:	80 91 64 00 	lds	r24, 0x0064
    5d7a:	8e 7f       	andi	r24, 0xFE	; 254
    5d7c:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d80:	80 91 65 00 	lds	r24, 0x0065
    5d84:	8e 7f       	andi	r24, 0xFE	; 254
    5d86:	80 93 65 00 	sts	0x0065, r24
    5d8a:	08 95       	ret

00005d8c <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    5d8c:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    5d8e:	17 9a       	sbi	0x02, 7	; 2
	sei();
    5d90:	78 94       	sei
    5d92:	08 95       	ret

00005d94 <GSM_PWRCNTRL_OFF>:
}
void GSM_PWRCNTRL_OFF(void){
	cli();
    5d94:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    5d96:	1f 98       	cbi	0x03, 7	; 3
	sei();
    5d98:	78 94       	sei
    5d9a:	08 95       	ret

00005d9c <GSM_PWRCNTRL_ON>:
}
void GSM_PWRCNTRL_ON(void){
	cli();
    5d9c:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    5d9e:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    5da0:	78 94       	sei
    5da2:	08 95       	ret

00005da4 <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    5da4:	8d 9a       	sbi	0x11, 5	; 17
    5da6:	08 95       	ret

00005da8 <CTS_OFF>:
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    5da8:	95 98       	cbi	0x12, 5	; 18
    5daa:	08 95       	ret

00005dac <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    5dac:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    5dae:	96 9a       	sbi	0x12, 6	; 18
    5db0:	08 95       	ret

00005db2 <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    5db2:	1f 92       	push	r1
    5db4:	0f 92       	push	r0
    5db6:	0f b6       	in	r0, 0x3f	; 63
    5db8:	0f 92       	push	r0
    5dba:	11 24       	eor	r1, r1
    5dbc:	0b b6       	in	r0, 0x3b	; 59
    5dbe:	0f 92       	push	r0
    5dc0:	2f 93       	push	r18
    5dc2:	3f 93       	push	r19
    5dc4:	4f 93       	push	r20
    5dc6:	5f 93       	push	r21
    5dc8:	6f 93       	push	r22
    5dca:	7f 93       	push	r23
    5dcc:	8f 93       	push	r24
    5dce:	9f 93       	push	r25
    5dd0:	af 93       	push	r26
    5dd2:	bf 93       	push	r27
    5dd4:	ef 93       	push	r30
    5dd6:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5dd8:	83 b7       	in	r24, 0x33	; 51
    5dda:	88 7f       	andi	r24, 0xF8	; 248
    5ddc:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    5dde:	87 b7       	in	r24, 0x37	; 55
    5de0:	8d 7f       	andi	r24, 0xFD	; 253
    5de2:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    5de4:	82 e5       	ldi	r24, 0x52	; 82
    5de6:	90 e0       	ldi	r25, 0x00	; 0
    5de8:	0e 94 30 28 	call	0x5060	; 0x5060 <MB_Timer_ISR>
}
    5dec:	ff 91       	pop	r31
    5dee:	ef 91       	pop	r30
    5df0:	bf 91       	pop	r27
    5df2:	af 91       	pop	r26
    5df4:	9f 91       	pop	r25
    5df6:	8f 91       	pop	r24
    5df8:	7f 91       	pop	r23
    5dfa:	6f 91       	pop	r22
    5dfc:	5f 91       	pop	r21
    5dfe:	4f 91       	pop	r20
    5e00:	3f 91       	pop	r19
    5e02:	2f 91       	pop	r18
    5e04:	0f 90       	pop	r0
    5e06:	0b be       	out	0x3b, r0	; 59
    5e08:	0f 90       	pop	r0
    5e0a:	0f be       	out	0x3f, r0	; 63
    5e0c:	0f 90       	pop	r0
    5e0e:	1f 90       	pop	r1
    5e10:	18 95       	reti

00005e12 <__vector_9>:

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    5e12:	1f 92       	push	r1
    5e14:	0f 92       	push	r0
    5e16:	0f b6       	in	r0, 0x3f	; 63
    5e18:	0f 92       	push	r0
    5e1a:	11 24       	eor	r1, r1
    5e1c:	0b b6       	in	r0, 0x3b	; 59
    5e1e:	0f 92       	push	r0
    5e20:	2f 93       	push	r18
    5e22:	3f 93       	push	r19
    5e24:	4f 93       	push	r20
    5e26:	5f 93       	push	r21
    5e28:	6f 93       	push	r22
    5e2a:	7f 93       	push	r23
    5e2c:	8f 93       	push	r24
    5e2e:	9f 93       	push	r25
    5e30:	af 93       	push	r26
    5e32:	bf 93       	push	r27
    5e34:	ef 93       	push	r30
    5e36:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5e38:	85 b5       	in	r24, 0x25	; 37
    5e3a:	88 7f       	andi	r24, 0xF8	; 248
    5e3c:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    5e3e:	87 b7       	in	r24, 0x37	; 55
    5e40:	8f 77       	andi	r24, 0x7F	; 127
    5e42:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    5e44:	84 e4       	ldi	r24, 0x44	; 68
    5e46:	90 e0       	ldi	r25, 0x00	; 0
    5e48:	0e 94 30 28 	call	0x5060	; 0x5060 <MB_Timer_ISR>
}
    5e4c:	ff 91       	pop	r31
    5e4e:	ef 91       	pop	r30
    5e50:	bf 91       	pop	r27
    5e52:	af 91       	pop	r26
    5e54:	9f 91       	pop	r25
    5e56:	8f 91       	pop	r24
    5e58:	7f 91       	pop	r23
    5e5a:	6f 91       	pop	r22
    5e5c:	5f 91       	pop	r21
    5e5e:	4f 91       	pop	r20
    5e60:	3f 91       	pop	r19
    5e62:	2f 91       	pop	r18
    5e64:	0f 90       	pop	r0
    5e66:	0b be       	out	0x3b, r0	; 59
    5e68:	0f 90       	pop	r0
    5e6a:	0f be       	out	0x3f, r0	; 63
    5e6c:	0f 90       	pop	r0
    5e6e:	1f 90       	pop	r1
    5e70:	18 95       	reti

00005e72 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    5e72:	ff 92       	push	r15
    5e74:	0f 93       	push	r16
    5e76:	1f 93       	push	r17
    5e78:	cf 93       	push	r28
    5e7a:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    5e7c:	08 2f       	mov	r16, r24
    5e7e:	10 e0       	ldi	r17, 0x00	; 0
    5e80:	e8 01       	movw	r28, r16
    5e82:	cc 0f       	add	r28, r28
    5e84:	dd 1f       	adc	r29, r29
    5e86:	c0 0f       	add	r28, r16
    5e88:	d1 1f       	adc	r29, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5e8a:	ce 01       	movw	r24, r28
    5e8c:	81 56       	subi	r24, 0x61	; 97
    5e8e:	9e 4f       	sbci	r25, 0xFE	; 254
    5e90:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    5e94:	f8 2e       	mov	r15, r24
    5e96:	c0 56       	subi	r28, 0x60	; 96
    5e98:	de 4f       	sbci	r29, 0xFE	; 254
    5e9a:	ce 01       	movw	r24, r28
    5e9c:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    5ea0:	f1 10       	cpse	r15, r1
    5ea2:	04 c0       	rjmp	.+8      	; 0x5eac <SetParity+0x3a>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    5ea4:	81 30       	cpi	r24, 0x01	; 1
    5ea6:	39 f4       	brne	.+14     	; 0x5eb6 <SetParity+0x44>
			case 1:
				ucsrc &=~(1<<3);
    5ea8:	96 e8       	ldi	r25, 0x86	; 134
    5eaa:	08 c0       	rjmp	.+16     	; 0x5ebc <SetParity+0x4a>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    5eac:	91 e0       	ldi	r25, 0x01	; 1
    5eae:	f9 12       	cpse	r15, r25
    5eb0:	04 c0       	rjmp	.+8      	; 0x5eba <SetParity+0x48>
			case EvenParity:
				ucsrc = (ucsrc |(1<<5)) &~(1<<4);
    5eb2:	96 ea       	ldi	r25, 0xA6	; 166
    5eb4:	03 c0       	rjmp	.+6      	; 0x5ebc <SetParity+0x4a>
{
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
			ucsrc &=~(1<<5) &~(1<<4);
    5eb6:	9e e8       	ldi	r25, 0x8E	; 142
    5eb8:	01 c0       	rjmp	.+2      	; 0x5ebc <SetParity+0x4a>
				ucsrc  |=(1<<3);
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
    5eba:	96 eb       	ldi	r25, 0xB6	; 182
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    5ebc:	24 e1       	ldi	r18, 0x14	; 20
    5ebe:	20 9f       	mul	r18, r16
    5ec0:	f0 01       	movw	r30, r0
    5ec2:	21 9f       	mul	r18, r17
    5ec4:	f0 0d       	add	r31, r0
    5ec6:	11 24       	eor	r1, r1
    5ec8:	eb 56       	subi	r30, 0x6B	; 107
    5eca:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ecc:	a5 91       	lpm	r26, Z+
    5ece:	b4 91       	lpm	r27, Z
    5ed0:	9c 93       	st	X, r25
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    5ed2:	ff 20       	and	r15, r15
    5ed4:	59 f0       	breq	.+22     	; 0x5eec <SetParity+0x7a>
    5ed6:	81 30       	cpi	r24, 0x01	; 1
    5ed8:	49 f0       	breq	.+18     	; 0x5eec <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
    5eda:	61 e0       	ldi	r22, 0x01	; 1
    5edc:	ce 01       	movw	r24, r28
}
    5ede:	df 91       	pop	r29
    5ee0:	cf 91       	pop	r28
    5ee2:	1f 91       	pop	r17
    5ee4:	0f 91       	pop	r16
    5ee6:	ff 90       	pop	r15
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
    5ee8:	0c 94 be 29 	jmp	0x537c	; 0x537c <ewb>
}
    5eec:	df 91       	pop	r29
    5eee:	cf 91       	pop	r28
    5ef0:	1f 91       	pop	r17
    5ef2:	0f 91       	pop	r16
    5ef4:	ff 90       	pop	r15
    5ef6:	08 95       	ret

00005ef8 <SetBAUD>:

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    5ef8:	cf 93       	push	r28
    5efa:	df 93       	push	r29
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    5efc:	c8 2f       	mov	r28, r24
    5efe:	d0 e0       	ldi	r29, 0x00	; 0
    5f00:	ce 01       	movw	r24, r28
    5f02:	88 0f       	add	r24, r24
    5f04:	99 1f       	adc	r25, r25
    5f06:	8c 0f       	add	r24, r28
    5f08:	9d 1f       	adc	r25, r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5f0a:	8f 55       	subi	r24, 0x5F	; 95
    5f0c:	9e 4f       	sbci	r25, 0xFE	; 254
    5f0e:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    5f12:	fe 01       	movw	r30, r28
    5f14:	e1 59       	subi	r30, 0x91	; 145
    5f16:	f6 4f       	sbci	r31, 0xF6	; 246
    5f18:	80 83       	st	Z, r24
    5f1a:	23 e0       	ldi	r18, 0x03	; 3
    5f1c:	82 9f       	mul	r24, r18
    5f1e:	c0 01       	movw	r24, r0
    5f20:	11 24       	eor	r1, r1
    5f22:	8d 55       	subi	r24, 0x5D	; 93
    5f24:	90 4b       	sbci	r25, 0xB0	; 176
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    5f26:	24 e1       	ldi	r18, 0x14	; 20
    5f28:	2c 9f       	mul	r18, r28
    5f2a:	f0 01       	movw	r30, r0
    5f2c:	2d 9f       	mul	r18, r29
    5f2e:	f0 0d       	add	r31, r0
    5f30:	11 24       	eor	r1, r1
    5f32:	e7 56       	subi	r30, 0x67	; 103
    5f34:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f36:	a5 91       	lpm	r26, Z+
    5f38:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f3a:	fc 01       	movw	r30, r24
    5f3c:	24 91       	lpm	r18, Z
    5f3e:	2c 93       	st	X, r18
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    5f40:	24 e1       	ldi	r18, 0x14	; 20
    5f42:	2c 9f       	mul	r18, r28
    5f44:	f0 01       	movw	r30, r0
    5f46:	2d 9f       	mul	r18, r29
    5f48:	f0 0d       	add	r31, r0
    5f4a:	11 24       	eor	r1, r1
    5f4c:	e9 56       	subi	r30, 0x69	; 105
    5f4e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f50:	a5 91       	lpm	r26, Z+
    5f52:	b4 91       	lpm	r27, Z
    5f54:	fc 01       	movw	r30, r24
    5f56:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f58:	e4 91       	lpm	r30, Z
    5f5a:	ec 93       	st	X, r30

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    5f5c:	26 e0       	ldi	r18, 0x06	; 6
    5f5e:	2c 9f       	mul	r18, r28
    5f60:	f0 01       	movw	r30, r0
    5f62:	2d 9f       	mul	r18, r29
    5f64:	f0 0d       	add	r31, r0
    5f66:	11 24       	eor	r1, r1
    5f68:	eb 57       	subi	r30, 0x7B	; 123
    5f6a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f6c:	a5 91       	lpm	r26, Z+
    5f6e:	b4 91       	lpm	r27, Z
    5f70:	fc 01       	movw	r30, r24
    5f72:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f74:	84 91       	lpm	r24, Z
    5f76:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    5f78:	df 91       	pop	r29
    5f7a:	cf 91       	pop	r28
    5f7c:	08 95       	ret

00005f7e <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5f7e:	cf 93       	push	r28
    5f80:	df 93       	push	r29
	MB_State[MB_N] = MB_Trans;
    5f82:	c8 2f       	mov	r28, r24
    5f84:	d0 e0       	ldi	r29, 0x00	; 0
    5f86:	fe 01       	movw	r30, r28
    5f88:	ef 51       	subi	r30, 0x1F	; 31
    5f8a:	fc 4f       	sbci	r31, 0xFC	; 252
    5f8c:	83 e0       	ldi	r24, 0x03	; 3
    5f8e:	80 83       	st	Z, r24
	USART_Func(MB_N, RS485);
    5f90:	84 e1       	ldi	r24, 0x14	; 20
    5f92:	8c 9f       	mul	r24, r28
    5f94:	f0 01       	movw	r30, r0
    5f96:	8d 9f       	mul	r24, r29
    5f98:	f0 0d       	add	r31, r0
    5f9a:	11 24       	eor	r1, r1
    5f9c:	e5 56       	subi	r30, 0x65	; 101
    5f9e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fa0:	85 91       	lpm	r24, Z+
    5fa2:	94 91       	lpm	r25, Z
    5fa4:	fc 01       	movw	r30, r24
    5fa6:	09 95       	icall
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5fa8:	84 e1       	ldi	r24, 0x14	; 20
    5faa:	8c 9f       	mul	r24, r28
    5fac:	f0 01       	movw	r30, r0
    5fae:	8d 9f       	mul	r24, r29
    5fb0:	f0 0d       	add	r31, r0
    5fb2:	11 24       	eor	r1, r1
    5fb4:	e1 57       	subi	r30, 0x71	; 113
    5fb6:	f0 4b       	sbci	r31, 0xB0	; 176
    5fb8:	a5 91       	lpm	r26, Z+
    5fba:	b4 91       	lpm	r27, Z
    5fbc:	fc 2f       	mov	r31, r28
    5fbe:	ee 27       	eor	r30, r30
    5fc0:	e8 5b       	subi	r30, 0xB8	; 184
    5fc2:	f2 4f       	sbci	r31, 0xF2	; 242
    5fc4:	80 81       	ld	r24, Z
    5fc6:	8c 93       	st	X, r24

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5fc8:	84 e1       	ldi	r24, 0x14	; 20
    5fca:	8c 9f       	mul	r24, r28
    5fcc:	f0 01       	movw	r30, r0
    5fce:	8d 9f       	mul	r24, r29
    5fd0:	f0 0d       	add	r31, r0
    5fd2:	11 24       	eor	r1, r1
    5fd4:	ef 56       	subi	r30, 0x6F	; 111
    5fd6:	f0 4b       	sbci	r31, 0xB0	; 176
    5fd8:	a5 91       	lpm	r26, Z+
    5fda:	b4 91       	lpm	r27, Z
    5fdc:	8c 91       	ld	r24, X
    5fde:	80 64       	ori	r24, 0x40	; 64
    5fe0:	8c 93       	st	X, r24
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    5fe2:	84 e1       	ldi	r24, 0x14	; 20
    5fe4:	8c 9f       	mul	r24, r28
    5fe6:	f0 01       	movw	r30, r0
    5fe8:	8d 9f       	mul	r24, r29
    5fea:	f0 0d       	add	r31, r0
    5fec:	11 24       	eor	r1, r1
    5fee:	ed 56       	subi	r30, 0x6D	; 109
    5ff0:	f0 4b       	sbci	r31, 0xB0	; 176
    5ff2:	a5 91       	lpm	r26, Z+
    5ff4:	b4 91       	lpm	r27, Z
    5ff6:	8c 91       	ld	r24, X
    5ff8:	80 62       	ori	r24, 0x20	; 32
    5ffa:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5ffc:	df 91       	pop	r29
    5ffe:	cf 91       	pop	r28
    6000:	08 95       	ret

00006002 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    6002:	cf 93       	push	r28
    6004:	df 93       	push	r29
    6006:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6008:	80 e0       	ldi	r24, 0x00	; 0
    600a:	94 e1       	ldi	r25, 0x14	; 20
    600c:	c8 2f       	mov	r28, r24
    600e:	d0 e0       	ldi	r29, 0x00	; 0
    6010:	9c 9f       	mul	r25, r28
    6012:	f0 01       	movw	r30, r0
    6014:	9d 9f       	mul	r25, r29
    6016:	f0 0d       	add	r31, r0
    6018:	11 24       	eor	r1, r1
    601a:	e1 57       	subi	r30, 0x71	; 113
    601c:	f0 4b       	sbci	r31, 0xB0	; 176
    601e:	25 91       	lpm	r18, Z+
    6020:	34 91       	lpm	r19, Z
    6022:	a2 17       	cp	r26, r18
    6024:	b3 07       	cpc	r27, r19
    6026:	11 f0       	breq	.+4      	; 0x602c <Modbus_RX+0x2a>
    6028:	8f 5f       	subi	r24, 0xFF	; 255
    602a:	f0 cf       	rjmp	.-32     	; 0x600c <Modbus_RX+0xa>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    602c:	fe 01       	movw	r30, r28
    602e:	ef 51       	subi	r30, 0x1F	; 31
    6030:	fc 4f       	sbci	r31, 0xFC	; 252
    6032:	90 81       	ld	r25, Z
    6034:	92 30       	cpi	r25, 0x02	; 2
    6036:	a1 f1       	breq	.+104    	; 0x60a0 <Modbus_RX+0x9e>
    6038:	40 f5       	brcc	.+80     	; 0x608a <Modbus_RX+0x88>
    603a:	99 23       	and	r25, r25
    603c:	51 f1       	breq	.+84     	; 0x6092 <Modbus_RX+0x90>
    603e:	91 30       	cpi	r25, 0x01	; 1
    6040:	09 f0       	breq	.+2      	; 0x6044 <Modbus_RX+0x42>
    6042:	3b c0       	rjmp	.+118    	; 0x60ba <Modbus_RX+0xb8>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    6044:	92 e0       	ldi	r25, 0x02	; 2
    6046:	90 83       	st	Z, r25
		MB_Err &=~(1<<MB_N);
    6048:	21 e0       	ldi	r18, 0x01	; 1
    604a:	30 e0       	ldi	r19, 0x00	; 0
    604c:	08 2e       	mov	r0, r24
    604e:	01 c0       	rjmp	.+2      	; 0x6052 <Modbus_RX+0x50>
    6050:	22 0f       	add	r18, r18
    6052:	0a 94       	dec	r0
    6054:	ea f7       	brpl	.-6      	; 0x6050 <Modbus_RX+0x4e>
    6056:	20 95       	com	r18
    6058:	90 91 6b 02 	lds	r25, 0x026B
    605c:	92 23       	and	r25, r18
    605e:	90 93 6b 02 	sts	0x026B, r25
		MB_Frame_Sz[MB_N] = 0;
    6062:	fe 01       	movw	r30, r28
    6064:	e7 52       	subi	r30, 0x27	; 39
    6066:	f7 4f       	sbci	r31, 0xF7	; 247
    6068:	10 82       	st	Z, r1
		MBRecept(MB_N);
    606a:	0e 94 77 28 	call	0x50ee	; 0x50ee <MBRecept>
		MB_StartTimer(MB_N);
    606e:	86 e0       	ldi	r24, 0x06	; 6
    6070:	8c 9f       	mul	r24, r28
    6072:	f0 01       	movw	r30, r0
    6074:	8d 9f       	mul	r24, r29
    6076:	f0 0d       	add	r31, r0
    6078:	11 24       	eor	r1, r1
    607a:	e9 57       	subi	r30, 0x79	; 121
    607c:	f0 4b       	sbci	r31, 0xB0	; 176
    607e:	85 91       	lpm	r24, Z+
    6080:	94 91       	lpm	r25, Z
    6082:	fc 01       	movw	r30, r24
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    6084:	df 91       	pop	r29
    6086:	cf 91       	pop	r28
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
		MB_Err &=~(1<<MB_N);
		MB_Frame_Sz[MB_N] = 0;
		MBRecept(MB_N);
		MB_StartTimer(MB_N);
    6088:	09 94       	ijmp
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    608a:	96 30       	cpi	r25, 0x06	; 6
    608c:	b0 f4       	brcc	.+44     	; 0x60ba <Modbus_RX+0xb8>
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    608e:	8c 91       	ld	r24, X
		break;
    6090:	14 c0       	rjmp	.+40     	; 0x60ba <Modbus_RX+0xb8>
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    6092:	8c 91       	ld	r24, X
    6094:	fc 2f       	mov	r31, r28
    6096:	ee 27       	eor	r30, r30
    6098:	e8 5b       	subi	r30, 0xB8	; 184
    609a:	f2 4f       	sbci	r31, 0xF2	; 242
    609c:	80 83       	st	Z, r24
    609e:	02 c0       	rjmp	.+4      	; 0x60a4 <Modbus_RX+0xa2>
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    60a0:	0e 94 77 28 	call	0x50ee	; 0x50ee <MBRecept>
		MB_ClearTimer(MB_N);
    60a4:	86 e0       	ldi	r24, 0x06	; 6
    60a6:	8c 9f       	mul	r24, r28
    60a8:	f0 01       	movw	r30, r0
    60aa:	8d 9f       	mul	r24, r29
    60ac:	f0 0d       	add	r31, r0
    60ae:	11 24       	eor	r1, r1
    60b0:	ed 57       	subi	r30, 0x7D	; 125
    60b2:	f0 4b       	sbci	r31, 0xB0	; 176
    60b4:	a5 91       	lpm	r26, Z+
    60b6:	b4 91       	lpm	r27, Z
    60b8:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    60ba:	df 91       	pop	r29
    60bc:	cf 91       	pop	r28
    60be:	08 95       	ret

000060c0 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    60c0:	0f 93       	push	r16
    60c2:	1f 93       	push	r17
    60c4:	cf 93       	push	r28
    60c6:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    60c8:	c8 2f       	mov	r28, r24
    60ca:	d0 e0       	ldi	r29, 0x00	; 0
    60cc:	fe 01       	movw	r30, r28
    60ce:	e7 52       	subi	r30, 0x27	; 39
    60d0:	f7 4f       	sbci	r31, 0xF7	; 247
    60d2:	90 81       	ld	r25, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    60d4:	20 91 6b 02 	lds	r18, 0x026B
    60d8:	30 e0       	ldi	r19, 0x00	; 0
    60da:	02 c0       	rjmp	.+4      	; 0x60e0 <CommErr+0x20>
    60dc:	35 95       	asr	r19
    60de:	27 95       	ror	r18
    60e0:	8a 95       	dec	r24
    60e2:	e2 f7       	brpl	.-8      	; 0x60dc <CommErr+0x1c>
    60e4:	20 fd       	sbrc	r18, 0
    60e6:	1b c0       	rjmp	.+54     	; 0x611e <CommErr+0x5e>
    60e8:	93 30       	cpi	r25, 0x03	; 3
    60ea:	c8 f0       	brcs	.+50     	; 0x611e <CommErr+0x5e>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    60ec:	2e ef       	ldi	r18, 0xFE	; 254
    60ee:	29 0f       	add	r18, r25
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    60f0:	7c 2f       	mov	r23, r28
    60f2:	66 27       	eor	r22, r22
    60f4:	68 5b       	subi	r22, 0xB8	; 184
    60f6:	72 4f       	sbci	r23, 0xF2	; 242
    60f8:	fb 01       	movw	r30, r22
    60fa:	e2 0f       	add	r30, r18
    60fc:	f1 1d       	adc	r31, r1
    60fe:	00 81       	ld	r16, Z
    6100:	11 81       	ldd	r17, Z+1	; 0x01
    6102:	30 e0       	ldi	r19, 0x00	; 0
    6104:	40 e0       	ldi	r20, 0x00	; 0
    6106:	50 e0       	ldi	r21, 0x00	; 0
    6108:	8f e0       	ldi	r24, 0x0F	; 15
    610a:	98 e2       	ldi	r25, 0x28	; 40
    610c:	0e 94 8d 29 	call	0x531a	; 0x531a <CRC>
    6110:	21 e0       	ldi	r18, 0x01	; 1
    6112:	08 17       	cp	r16, r24
    6114:	19 07       	cpc	r17, r25
    6116:	09 f4       	brne	.+2      	; 0x611a <CommErr+0x5a>
    6118:	20 e0       	ldi	r18, 0x00	; 0
    611a:	12 2f       	mov	r17, r18
    611c:	01 c0       	rjmp	.+2      	; 0x6120 <CommErr+0x60>
    611e:	11 e0       	ldi	r17, 0x01	; 1
    6120:	fe 01       	movw	r30, r28
    6122:	54 e0       	ldi	r21, 0x04	; 4
    6124:	ee 0f       	add	r30, r30
    6126:	ff 1f       	adc	r31, r31
    6128:	5a 95       	dec	r21
    612a:	e1 f7       	brne	.-8      	; 0x6124 <CommErr+0x64>
	if (Err) {
		MB_CPT[MB_N][1]++;
    612c:	e7 5d       	subi	r30, 0xD7	; 215
    612e:	f4 4f       	sbci	r31, 0xF4	; 244
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
	if (Err) {
    6130:	11 23       	and	r17, r17
    6132:	79 f0       	breq	.+30     	; 0x6152 <CommErr+0x92>
		MB_CPT[MB_N][1]++;
    6134:	22 81       	ldd	r18, Z+2	; 0x02
    6136:	33 81       	ldd	r19, Z+3	; 0x03
    6138:	2f 5f       	subi	r18, 0xFF	; 255
    613a:	3f 4f       	sbci	r19, 0xFF	; 255
    613c:	33 83       	std	Z+3, r19	; 0x03
    613e:	22 83       	std	Z+2, r18	; 0x02
		USART_Func(MB_N, LED_Err_On);
    6140:	84 e1       	ldi	r24, 0x14	; 20
    6142:	8c 9f       	mul	r24, r28
    6144:	f0 01       	movw	r30, r0
    6146:	8d 9f       	mul	r24, r29
    6148:	f0 0d       	add	r31, r0
    614a:	11 24       	eor	r1, r1
    614c:	e1 56       	subi	r30, 0x61	; 97
    614e:	f0 4b       	sbci	r31, 0xB0	; 176
    6150:	0e c0       	rjmp	.+28     	; 0x616e <CommErr+0xae>
	}
	else {
		MB_CPT[MB_N][0]++;
    6152:	20 81       	ld	r18, Z
    6154:	31 81       	ldd	r19, Z+1	; 0x01
    6156:	2f 5f       	subi	r18, 0xFF	; 255
    6158:	3f 4f       	sbci	r19, 0xFF	; 255
    615a:	31 83       	std	Z+1, r19	; 0x01
    615c:	20 83       	st	Z, r18
		USART_Func(MB_N, LED_Err_Off);
    615e:	84 e1       	ldi	r24, 0x14	; 20
    6160:	8c 9f       	mul	r24, r28
    6162:	f0 01       	movw	r30, r0
    6164:	8d 9f       	mul	r24, r29
    6166:	f0 0d       	add	r31, r0
    6168:	11 24       	eor	r1, r1
    616a:	ef 55       	subi	r30, 0x5F	; 95
    616c:	f0 4b       	sbci	r31, 0xB0	; 176
    616e:	25 91       	lpm	r18, Z+
    6170:	34 91       	lpm	r19, Z
    6172:	f9 01       	movw	r30, r18
    6174:	09 95       	icall
	}
	return Err;
}
    6176:	81 2f       	mov	r24, r17
    6178:	df 91       	pop	r29
    617a:	cf 91       	pop	r28
    617c:	1f 91       	pop	r17
    617e:	0f 91       	pop	r16
    6180:	08 95       	ret

00006182 <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    6182:	cf 93       	push	r28
    6184:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    6186:	68 2f       	mov	r22, r24
    6188:	70 e0       	ldi	r23, 0x00	; 0
    618a:	fb 01       	movw	r30, r22
    618c:	e7 52       	subi	r30, 0x27	; 39
    618e:	f7 4f       	sbci	r31, 0xF7	; 247
    6190:	20 81       	ld	r18, Z
    6192:	22 50       	subi	r18, 0x02	; 2
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    6194:	76 2f       	mov	r23, r22
    6196:	66 27       	eor	r22, r22
    6198:	68 5b       	subi	r22, 0xB8	; 184
    619a:	72 4f       	sbci	r23, 0xF2	; 242
    619c:	eb 01       	movw	r28, r22
    619e:	c2 0f       	add	r28, r18
    61a0:	d1 1d       	adc	r29, r1
    61a2:	30 e0       	ldi	r19, 0x00	; 0
    61a4:	40 e0       	ldi	r20, 0x00	; 0
    61a6:	50 e0       	ldi	r21, 0x00	; 0
    61a8:	8f e0       	ldi	r24, 0x0F	; 15
    61aa:	98 e2       	ldi	r25, 0x28	; 40
    61ac:	0e 94 8d 29 	call	0x531a	; 0x531a <CRC>
    61b0:	99 83       	std	Y+1, r25	; 0x01
    61b2:	88 83       	st	Y, r24
}
    61b4:	df 91       	pop	r29
    61b6:	cf 91       	pop	r28
    61b8:	08 95       	ret

000061ba <FormData>:
}

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    61ba:	bf 92       	push	r11
    61bc:	cf 92       	push	r12
    61be:	df 92       	push	r13
    61c0:	ef 92       	push	r14
    61c2:	ff 92       	push	r15
    61c4:	0f 93       	push	r16
    61c6:	1f 93       	push	r17
    61c8:	cf 93       	push	r28
    61ca:	df 93       	push	r29
    61cc:	b8 2e       	mov	r11, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    61ce:	c8 2f       	mov	r28, r24
    61d0:	d0 e0       	ldi	r29, 0x00	; 0
    61d2:	dc 2e       	mov	r13, r28
    61d4:	cc 24       	eor	r12, r12
    61d6:	86 01       	movw	r16, r12
    61d8:	08 5b       	subi	r16, 0xB8	; 184
    61da:	12 4f       	sbci	r17, 0xF2	; 242
    61dc:	f8 01       	movw	r30, r16
    61de:	81 81       	ldd	r24, Z+1	; 0x01
    61e0:	86 30       	cpi	r24, 0x06	; 6
    61e2:	f1 f0       	breq	.+60     	; 0x6220 <FormData+0x66>
    61e4:	48 f4       	brcc	.+18     	; 0x61f8 <FormData+0x3e>
    61e6:	81 50       	subi	r24, 0x01	; 1
    61e8:	84 30       	cpi	r24, 0x04	; 4
    61ea:	08 f0       	brcs	.+2      	; 0x61ee <FormData+0x34>
    61ec:	c9 c0       	rjmp	.+402    	; 0x6380 <FormData+0x1c6>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    61ee:	c7 52       	subi	r28, 0x27	; 39
    61f0:	d7 4f       	sbci	r29, 0xF7	; 247
    61f2:	88 e0       	ldi	r24, 0x08	; 8
    61f4:	88 83       	st	Y, r24
		break;
    61f6:	c4 c0       	rjmp	.+392    	; 0x6380 <FormData+0x1c6>
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    61f8:	8f 30       	cpi	r24, 0x0F	; 15
    61fa:	11 f1       	breq	.+68     	; 0x6240 <FormData+0x86>
    61fc:	80 31       	cpi	r24, 0x10	; 16
    61fe:	09 f0       	breq	.+2      	; 0x6202 <FormData+0x48>
    6200:	bf c0       	rjmp	.+382    	; 0x6380 <FormData+0x1c6>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    6202:	f8 01       	movw	r30, r16
    6204:	85 81       	ldd	r24, Z+5	; 0x05
    6206:	88 0f       	add	r24, r24
    6208:	86 83       	std	Z+6, r24	; 0x06
    620a:	c7 52       	subi	r28, 0x27	; 39
    620c:	d7 4f       	sbci	r29, 0xF7	; 247
    620e:	87 5f       	subi	r24, 0xF7	; 247
    6210:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6212:	8b 2d       	mov	r24, r11
    6214:	0e 94 ff 28 	call	0x51fe	; 0x51fe <GetReg>
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6218:	20 e0       	ldi	r18, 0x00	; 0
    621a:	e8 01       	movw	r28, r16
    621c:	25 96       	adiw	r28, 0x05	; 5
    621e:	9a c0       	rjmp	.+308    	; 0x6354 <FormData+0x19a>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    6220:	c7 52       	subi	r28, 0x27	; 39
    6222:	d7 4f       	sbci	r29, 0xF7	; 247
    6224:	88 e0       	ldi	r24, 0x08	; 8
    6226:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6228:	8b 2d       	mov	r24, r11
    622a:	0e 94 ff 28 	call	0x51fe	; 0x51fe <GetReg>
		MB_Frame[MB_N][4] = *Reg>>8;
    622e:	fc 01       	movw	r30, r24
    6230:	21 81       	ldd	r18, Z+1	; 0x01
    6232:	f8 01       	movw	r30, r16
    6234:	24 83       	std	Z+4, r18	; 0x04
		MB_Frame[MB_N][5] = *Reg;
    6236:	fc 01       	movw	r30, r24
    6238:	80 81       	ld	r24, Z
    623a:	f8 01       	movw	r30, r16
    623c:	85 83       	std	Z+5, r24	; 0x05
		break;
    623e:	a0 c0       	rjmp	.+320    	; 0x6380 <FormData+0x1c6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6240:	f8 01       	movw	r30, r16
    6242:	e4 80       	ldd	r14, Z+4	; 0x04
    6244:	f1 2c       	mov	r15, r1
    6246:	fe 2c       	mov	r15, r14
    6248:	ee 24       	eor	r14, r14
    624a:	85 81       	ldd	r24, Z+5	; 0x05
    624c:	e8 2a       	or	r14, r24
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    624e:	c7 01       	movw	r24, r14
    6250:	13 e0       	ldi	r17, 0x03	; 3
    6252:	96 95       	lsr	r25
    6254:	87 95       	ror	r24
    6256:	1a 95       	dec	r17
    6258:	e1 f7       	brne	.-8      	; 0x6252 <FormData+0x98>
    625a:	97 01       	movw	r18, r14
    625c:	27 70       	andi	r18, 0x07	; 7
    625e:	33 27       	eor	r19, r19
    6260:	41 e0       	ldi	r20, 0x01	; 1
    6262:	23 2b       	or	r18, r19
    6264:	09 f4       	brne	.+2      	; 0x6268 <FormData+0xae>
    6266:	40 e0       	ldi	r20, 0x00	; 0
    6268:	24 2f       	mov	r18, r20
    626a:	28 0f       	add	r18, r24
    626c:	f6 01       	movw	r30, r12
    626e:	e8 5b       	subi	r30, 0xB8	; 184
    6270:	f2 4f       	sbci	r31, 0xF2	; 242
    6272:	26 83       	std	Z+6, r18	; 0x06
    6274:	de 01       	movw	r26, r28
    6276:	a7 52       	subi	r26, 0x27	; 39
    6278:	b7 4f       	sbci	r27, 0xF7	; 247
    627a:	27 5f       	subi	r18, 0xF7	; 247
    627c:	2c 93       	st	X, r18
		MB_Frame[MB_N][7+Qt/8] = 0;
    627e:	e8 0f       	add	r30, r24
    6280:	f9 1f       	adc	r31, r25
    6282:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    6284:	fe 01       	movw	r30, r28
    6286:	ee 5d       	subi	r30, 0xDE	; 222
    6288:	f9 4f       	sbci	r31, 0xF9	; 249
    628a:	80 81       	ld	r24, Z
    628c:	82 30       	cpi	r24, 0x02	; 2
    628e:	f9 f0       	breq	.+62     	; 0x62ce <FormData+0x114>
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6290:	fe 01       	movw	r30, r28
    6292:	a4 e0       	ldi	r26, 0x04	; 4
    6294:	ee 0f       	add	r30, r30
    6296:	ff 1f       	adc	r31, r31
    6298:	aa 95       	dec	r26
    629a:	e1 f7       	brne	.-8      	; 0x6294 <FormData+0xda>
    629c:	e2 54       	subi	r30, 0x42	; 66
    629e:	f0 4b       	sbci	r31, 0xB0	; 176
    62a0:	05 91       	lpm	r16, Z+
    62a2:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    62a4:	8b 2d       	mov	r24, r11
    62a6:	0e 94 b9 28 	call	0x5172	; 0x5172 <GetSlave>
    62aa:	01 96       	adiw	r24, 0x01	; 1
    62ac:	fc 01       	movw	r30, r24
    62ae:	85 91       	lpm	r24, Z+
    62b0:	94 91       	lpm	r25, Z
    62b2:	c3 5f       	subi	r28, 0xF3	; 243
    62b4:	d9 4f       	sbci	r29, 0xF9	; 249
    62b6:	28 81       	ld	r18, Y
    62b8:	fc 01       	movw	r30, r24
    62ba:	37 e0       	ldi	r19, 0x07	; 7
    62bc:	23 9f       	mul	r18, r19
    62be:	e0 0d       	add	r30, r0
    62c0:	f1 1d       	adc	r31, r1
    62c2:	11 24       	eor	r1, r1
		MB_Frame[MB_N][7+Qt/8] = 0;
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    62c4:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    62c6:	85 91       	lpm	r24, Z+
    62c8:	94 91       	lpm	r25, Z
    62ca:	78 2f       	mov	r23, r24
    62cc:	0a c0       	rjmp	.+20     	; 0x62e2 <FormData+0x128>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    62ce:	f3 e0       	ldi	r31, 0x03	; 3
    62d0:	cc 0f       	add	r28, r28
    62d2:	dd 1f       	adc	r29, r29
    62d4:	fa 95       	dec	r31
    62d6:	e1 f7       	brne	.-8      	; 0x62d0 <FormData+0x116>
    62d8:	cd 59       	subi	r28, 0x9D	; 157
    62da:	dd 4f       	sbci	r29, 0xFD	; 253
    62dc:	0e 81       	ldd	r16, Y+6	; 0x06
    62de:	1f 81       	ldd	r17, Y+7	; 0x07
			Pin = 0;
    62e0:	70 e0       	ldi	r23, 0x00	; 0
		}
		for (uint8_t i=0; i<Qt; i++) {
    62e2:	60 e0       	ldi	r22, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62e4:	41 e0       	ldi	r20, 0x01	; 1
    62e6:	50 e0       	ldi	r21, 0x00	; 0
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    62e8:	26 2f       	mov	r18, r22
    62ea:	30 e0       	ldi	r19, 0x00	; 0
    62ec:	2e 15       	cp	r18, r14
    62ee:	3f 05       	cpc	r19, r15
    62f0:	08 f0       	brcs	.+2      	; 0x62f4 <FormData+0x13a>
    62f2:	46 c0       	rjmp	.+140    	; 0x6380 <FormData+0x1c6>
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62f4:	e6 2f       	mov	r30, r22
    62f6:	e6 95       	lsr	r30
    62f8:	e6 95       	lsr	r30
    62fa:	e6 95       	lsr	r30
    62fc:	e9 5f       	subi	r30, 0xF9	; 249
    62fe:	86 2f       	mov	r24, r22
    6300:	87 70       	andi	r24, 0x07	; 7
    6302:	9a 01       	movw	r18, r20
    6304:	02 c0       	rjmp	.+4      	; 0x630a <FormData+0x150>
    6306:	22 0f       	add	r18, r18
    6308:	33 1f       	adc	r19, r19
    630a:	8a 95       	dec	r24
    630c:	e2 f7       	brpl	.-8      	; 0x6306 <FormData+0x14c>
    630e:	c9 01       	movw	r24, r18
			if (Discr[j/8] &(1<<j%8))
    6310:	f6 2f       	mov	r31, r22
    6312:	f7 0f       	add	r31, r23
    6314:	2f 2f       	mov	r18, r31
    6316:	26 95       	lsr	r18
    6318:	26 95       	lsr	r18
    631a:	26 95       	lsr	r18
    631c:	d8 01       	movw	r26, r16
    631e:	a2 0f       	add	r26, r18
    6320:	b1 1d       	adc	r27, r1
    6322:	2c 91       	ld	r18, X
    6324:	30 e0       	ldi	r19, 0x00	; 0
    6326:	f7 70       	andi	r31, 0x07	; 7
    6328:	02 c0       	rjmp	.+4      	; 0x632e <FormData+0x174>
    632a:	35 95       	asr	r19
    632c:	27 95       	ror	r18
    632e:	fa 95       	dec	r31
    6330:	e2 f7       	brpl	.-8      	; 0x632a <FormData+0x170>
    6332:	f0 e0       	ldi	r31, 0x00	; 0
				MB_Frame[MB_N][Byte] |=Bit;
    6334:	ec 0d       	add	r30, r12
    6336:	fd 1d       	adc	r31, r13
    6338:	e8 5b       	subi	r30, 0xB8	; 184
    633a:	f2 4f       	sbci	r31, 0xF2	; 242
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
			if (Discr[j/8] &(1<<j%8))
    633c:	20 ff       	sbrs	r18, 0
    633e:	04 c0       	rjmp	.+8      	; 0x6348 <FormData+0x18e>
				MB_Frame[MB_N][Byte] |=Bit;
    6340:	90 81       	ld	r25, Z
    6342:	98 2b       	or	r25, r24
    6344:	90 83       	st	Z, r25
    6346:	04 c0       	rjmp	.+8      	; 0x6350 <FormData+0x196>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    6348:	80 95       	com	r24
    634a:	90 81       	ld	r25, Z
    634c:	89 23       	and	r24, r25
    634e:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6350:	6f 5f       	subi	r22, 0xFF	; 255
    6352:	ca cf       	rjmp	.-108    	; 0x62e8 <FormData+0x12e>
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6354:	38 81       	ld	r19, Y
    6356:	23 17       	cp	r18, r19
    6358:	98 f4       	brcc	.+38     	; 0x6380 <FormData+0x1c6>
			uint8_t j = i*2;
    635a:	32 2f       	mov	r19, r18
    635c:	33 0f       	add	r19, r19
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    635e:	fc 01       	movw	r30, r24
    6360:	e2 0f       	add	r30, r18
    6362:	f1 1d       	adc	r31, r1
    6364:	e2 0f       	add	r30, r18
    6366:	f1 1d       	adc	r31, r1
    6368:	d8 01       	movw	r26, r16
    636a:	a3 0f       	add	r26, r19
    636c:	b1 1d       	adc	r27, r1
    636e:	31 81       	ldd	r19, Z+1	; 0x01
    6370:	17 96       	adiw	r26, 0x07	; 7
    6372:	3c 93       	st	X, r19
    6374:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    6376:	30 81       	ld	r19, Z
    6378:	18 96       	adiw	r26, 0x08	; 8
    637a:	3c 93       	st	X, r19
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    637c:	2f 5f       	subi	r18, 0xFF	; 255
    637e:	ea cf       	rjmp	.-44     	; 0x6354 <FormData+0x19a>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6380:	8b 2d       	mov	r24, r11
}
    6382:	df 91       	pop	r29
    6384:	cf 91       	pop	r28
    6386:	1f 91       	pop	r17
    6388:	0f 91       	pop	r16
    638a:	ff 90       	pop	r15
    638c:	ef 90       	pop	r14
    638e:	df 90       	pop	r13
    6390:	cf 90       	pop	r12
    6392:	bf 90       	pop	r11
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6394:	0c 94 c1 30 	jmp	0x6182	; 0x6182 <SetCRC_MB>

00006398 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    6398:	cf 93       	push	r28
    639a:	c8 2f       	mov	r28, r24
	MB_Slave *Slave = GetSlave(MB_N);
    639c:	0e 94 b9 28 	call	0x5172	; 0x5172 <GetSlave>
    63a0:	bc 01       	movw	r22, r24
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    63a2:	fc 01       	movw	r30, r24
    63a4:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    63a6:	45 91       	lpm	r20, Z+
    63a8:	54 91       	lpm	r21, Z
    63aa:	2c 2f       	mov	r18, r28
    63ac:	30 e0       	ldi	r19, 0x00	; 0
    63ae:	f9 01       	movw	r30, r18
    63b0:	e3 5f       	subi	r30, 0xF3	; 243
    63b2:	f9 4f       	sbci	r31, 0xF9	; 249
    63b4:	80 81       	ld	r24, Z
    63b6:	97 e0       	ldi	r25, 0x07	; 7
    63b8:	89 9f       	mul	r24, r25
    63ba:	40 0d       	add	r20, r0
    63bc:	51 1d       	adc	r21, r1
    63be:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    63c0:	fb 01       	movw	r30, r22
    63c2:	64 91       	lpm	r22, Z

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    63c4:	b2 2f       	mov	r27, r18
    63c6:	aa 27       	eor	r26, r26
    63c8:	a8 5b       	subi	r26, 0xB8	; 184
    63ca:	b2 4f       	sbci	r27, 0xF2	; 242
    63cc:	6c 93       	st	X, r22
    63ce:	fa 01       	movw	r30, r20
    63d0:	84 91       	lpm	r24, Z
	MB_Frame[MB_N][1] = prb(&Query->Func);
    63d2:	f2 2f       	mov	r31, r18
    63d4:	ee 27       	eor	r30, r30
    63d6:	e8 5b       	subi	r30, 0xB8	; 184
    63d8:	f2 4f       	sbci	r31, 0xF2	; 242
    63da:	81 83       	std	Z+1, r24	; 0x01
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    63dc:	fa 01       	movw	r30, r20
    63de:	32 96       	adiw	r30, 0x02	; 2
    63e0:	e4 91       	lpm	r30, Z
    63e2:	b2 2f       	mov	r27, r18
    63e4:	aa 27       	eor	r26, r26
    63e6:	a8 5b       	subi	r26, 0xB8	; 184
    63e8:	b2 4f       	sbci	r27, 0xF2	; 242
    63ea:	12 96       	adiw	r26, 0x02	; 2
    63ec:	ec 93       	st	X, r30
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    63ee:	fa 01       	movw	r30, r20
    63f0:	31 96       	adiw	r30, 0x01	; 1
    63f2:	e4 91       	lpm	r30, Z
    63f4:	b2 2f       	mov	r27, r18
    63f6:	aa 27       	eor	r26, r26
    63f8:	a8 5b       	subi	r26, 0xB8	; 184
    63fa:	b2 4f       	sbci	r27, 0xF2	; 242
    63fc:	13 96       	adiw	r26, 0x03	; 3
    63fe:	ec 93       	st	X, r30
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6400:	fa 01       	movw	r30, r20
    6402:	34 96       	adiw	r30, 0x04	; 4
    6404:	e4 91       	lpm	r30, Z
    6406:	b2 2f       	mov	r27, r18
    6408:	aa 27       	eor	r26, r26
    640a:	a8 5b       	subi	r26, 0xB8	; 184
    640c:	b2 4f       	sbci	r27, 0xF2	; 242
    640e:	14 96       	adiw	r26, 0x04	; 4
    6410:	ec 93       	st	X, r30
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    6412:	fa 01       	movw	r30, r20
    6414:	33 96       	adiw	r30, 0x03	; 3
    6416:	44 91       	lpm	r20, Z
    6418:	b2 2f       	mov	r27, r18
    641a:	aa 27       	eor	r26, r26
    641c:	a8 5b       	subi	r26, 0xB8	; 184
    641e:	b2 4f       	sbci	r27, 0xF2	; 242
    6420:	15 96       	adiw	r26, 0x05	; 5
    6422:	4c 93       	st	X, r20

	FormData(MB_N);
    6424:	8c 2f       	mov	r24, r28
}
    6426:	cf 91       	pop	r28
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);

	FormData(MB_N);
    6428:	0c 94 dd 30 	jmp	0x61ba	; 0x61ba <FormData>

0000642c <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    642c:	28 2f       	mov	r18, r24
    642e:	30 e0       	ldi	r19, 0x00	; 0
    6430:	f2 2f       	mov	r31, r18
    6432:	ee 27       	eor	r30, r30
    6434:	e8 5b       	subi	r30, 0xB8	; 184
    6436:	f2 4f       	sbci	r31, 0xF2	; 242
    6438:	d9 01       	movw	r26, r18
    643a:	93 e0       	ldi	r25, 0x03	; 3
    643c:	aa 0f       	add	r26, r26
    643e:	bb 1f       	adc	r27, r27
    6440:	9a 95       	dec	r25
    6442:	e1 f7       	brne	.-8      	; 0x643c <FormSingle+0x10>
    6444:	ad 59       	subi	r26, 0x9D	; 157
    6446:	bd 4f       	sbci	r27, 0xFD	; 253
    6448:	9c 91       	ld	r25, X
    644a:	90 83       	st	Z, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    644c:	11 96       	adiw	r26, 0x01	; 1
    644e:	9c 91       	ld	r25, X
    6450:	11 97       	sbiw	r26, 0x01	; 1
    6452:	91 83       	std	Z+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    6454:	12 96       	adiw	r26, 0x02	; 2
    6456:	9c 91       	ld	r25, X
    6458:	12 97       	sbiw	r26, 0x02	; 2
    645a:	13 96       	adiw	r26, 0x03	; 3
    645c:	4c 91       	ld	r20, X
    645e:	13 97       	sbiw	r26, 0x03	; 3
    6460:	42 83       	std	Z+2, r20	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    6462:	93 83       	std	Z+3, r25	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    6464:	14 96       	adiw	r26, 0x04	; 4
    6466:	9c 91       	ld	r25, X
    6468:	14 97       	sbiw	r26, 0x04	; 4
    646a:	15 96       	adiw	r26, 0x05	; 5
    646c:	4c 91       	ld	r20, X
    646e:	44 83       	std	Z+4, r20	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6470:	95 83       	std	Z+5, r25	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    6472:	f9 01       	movw	r30, r18
    6474:	ee 5d       	subi	r30, 0xDE	; 222
    6476:	f9 4f       	sbci	r31, 0xF9	; 249
    6478:	92 e0       	ldi	r25, 0x02	; 2
    647a:	90 83       	st	Z, r25
	FormData(MB_N);
    647c:	0c 94 dd 30 	jmp	0x61ba	; 0x61ba <FormData>

00006480 <MB_FrameReg>:
    6480:	e8 2f       	mov	r30, r24
    6482:	f0 e0       	ldi	r31, 0x00	; 0
    6484:	70 e0       	ldi	r23, 0x00	; 0
    6486:	fe 2f       	mov	r31, r30
    6488:	ee 27       	eor	r30, r30
    648a:	df 01       	movw	r26, r30
    648c:	a8 5b       	subi	r26, 0xB8	; 184
    648e:	b2 4f       	sbci	r27, 0xF2	; 242
    6490:	a6 0f       	add	r26, r22
    6492:	b7 1f       	adc	r27, r23
    6494:	11 96       	adiw	r26, 0x01	; 1
    6496:	8c 91       	ld	r24, X
    6498:	e6 0f       	add	r30, r22
    649a:	f7 1f       	adc	r31, r23
    649c:	e8 5b       	subi	r30, 0xB8	; 184
    649e:	f2 4f       	sbci	r31, 0xF2	; 242
    64a0:	20 81       	ld	r18, Z
    64a2:	90 e0       	ldi	r25, 0x00	; 0
}
    64a4:	92 2b       	or	r25, r18
    64a6:	08 95       	ret

000064a8 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    64a8:	2f 92       	push	r2
    64aa:	3f 92       	push	r3
    64ac:	4f 92       	push	r4
    64ae:	5f 92       	push	r5
    64b0:	6f 92       	push	r6
    64b2:	7f 92       	push	r7
    64b4:	8f 92       	push	r8
    64b6:	9f 92       	push	r9
    64b8:	af 92       	push	r10
    64ba:	bf 92       	push	r11
    64bc:	cf 92       	push	r12
    64be:	df 92       	push	r13
    64c0:	ef 92       	push	r14
    64c2:	ff 92       	push	r15
    64c4:	0f 93       	push	r16
    64c6:	1f 93       	push	r17
    64c8:	cf 93       	push	r28
    64ca:	df 93       	push	r29
    64cc:	00 d0       	rcall	.+0      	; 0x64ce <MB_S_Timer_ISR+0x26>
    64ce:	00 d0       	rcall	.+0      	; 0x64d0 <MB_S_Timer_ISR+0x28>
    64d0:	1f 92       	push	r1
    64d2:	cd b7       	in	r28, 0x3d	; 61
    64d4:	de b7       	in	r29, 0x3e	; 62
    64d6:	78 2e       	mov	r7, r24
	switch (MB_State[MB_N]) {
    64d8:	c8 2e       	mov	r12, r24
    64da:	d1 2c       	mov	r13, r1
    64dc:	96 01       	movw	r18, r12
    64de:	2f 51       	subi	r18, 0x1F	; 31
    64e0:	3c 4f       	sbci	r19, 0xFC	; 252
    64e2:	59 01       	movw	r10, r18
    64e4:	d9 01       	movw	r26, r18
    64e6:	8c 91       	ld	r24, X
    64e8:	88 23       	and	r24, r24
    64ea:	59 f0       	breq	.+22     	; 0x6502 <MB_S_Timer_ISR+0x5a>
    64ec:	82 30       	cpi	r24, 0x02	; 2
    64ee:	09 f0       	breq	.+2      	; 0x64f2 <MB_S_Timer_ISR+0x4a>
    64f0:	aa c2       	rjmp	.+1364   	; 0x6a46 <MB_S_Timer_ISR+0x59e>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    64f2:	84 e0       	ldi	r24, 0x04	; 4
    64f4:	d9 01       	movw	r26, r18
    64f6:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    64f8:	87 2d       	mov	r24, r7
    64fa:	0e 94 60 30 	call	0x60c0	; 0x60c0 <CommErr>
    64fe:	88 23       	and	r24, r24
    6500:	21 f0       	breq	.+8      	; 0x650a <MB_S_Timer_ISR+0x62>
		MB_State[MB_N] = MB_Idle;
    6502:	81 e0       	ldi	r24, 0x01	; 1
    6504:	f5 01       	movw	r30, r10
    6506:	80 83       	st	Z, r24
    6508:	9e c2       	rjmp	.+1340   	; 0x6a46 <MB_S_Timer_ISR+0x59e>
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    650a:	3c 2d       	mov	r19, r12
    650c:	22 27       	eor	r18, r18
    650e:	3d 83       	std	Y+5, r19	; 0x05
    6510:	2c 83       	std	Y+4, r18	; 0x04
    6512:	f9 01       	movw	r30, r18
    6514:	e8 5b       	subi	r30, 0xB8	; 184
    6516:	f2 4f       	sbci	r31, 0xF2	; 242
    6518:	80 81       	ld	r24, Z
    651a:	88 23       	and	r24, r24
    651c:	51 f0       	breq	.+20     	; 0x6532 <MB_S_Timer_ISR+0x8a>
    651e:	f6 01       	movw	r30, r12
    6520:	e8 50       	subi	r30, 0x08	; 8
    6522:	fc 4f       	sbci	r31, 0xFC	; 252
    6524:	90 81       	ld	r25, Z
    6526:	89 17       	cp	r24, r25
    6528:	21 f0       	breq	.+8      	; 0x6532 <MB_S_Timer_ISR+0x8a>
		MB_State[MB_N] = MB_Idle;
    652a:	81 e0       	ldi	r24, 0x01	; 1
    652c:	d5 01       	movw	r26, r10
    652e:	8c 93       	st	X, r24
    6530:	8a c2       	rjmp	.+1300   	; 0x6a46 <MB_S_Timer_ISR+0x59e>
		return;
	}
	USART_Func(MB_N, LED);
    6532:	84 e1       	ldi	r24, 0x14	; 20
    6534:	8c 9d       	mul	r24, r12
    6536:	40 01       	movw	r8, r0
    6538:	8d 9d       	mul	r24, r13
    653a:	90 0c       	add	r9, r0
    653c:	11 24       	eor	r1, r1
    653e:	f4 01       	movw	r30, r8
    6540:	e3 56       	subi	r30, 0x63	; 99
    6542:	f0 4b       	sbci	r31, 0xB0	; 176
    6544:	4f 01       	movw	r8, r30

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6546:	25 91       	lpm	r18, Z+
    6548:	34 91       	lpm	r19, Z
    654a:	f9 01       	movw	r30, r18
    654c:	09 95       	icall
	MB_CPT[MB_N][3]++;
    654e:	86 01       	movw	r16, r12
    6550:	e4 e0       	ldi	r30, 0x04	; 4
    6552:	00 0f       	add	r16, r16
    6554:	11 1f       	adc	r17, r17
    6556:	ea 95       	dec	r30
    6558:	e1 f7       	brne	.-8      	; 0x6552 <MB_S_Timer_ISR+0xaa>
    655a:	f8 01       	movw	r30, r16
    655c:	e7 5d       	subi	r30, 0xD7	; 215
    655e:	f4 4f       	sbci	r31, 0xF4	; 244
    6560:	86 81       	ldd	r24, Z+6	; 0x06
    6562:	97 81       	ldd	r25, Z+7	; 0x07
    6564:	01 96       	adiw	r24, 0x01	; 1
    6566:	97 83       	std	Z+7, r25	; 0x07
    6568:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    656a:	ec 81       	ldd	r30, Y+4	; 0x04
    656c:	fd 81       	ldd	r31, Y+5	; 0x05
    656e:	e8 5b       	subi	r30, 0xB8	; 184
    6570:	f2 4f       	sbci	r31, 0xF2	; 242
    6572:	e2 80       	ldd	r14, Z+2	; 0x02
    6574:	f1 2c       	mov	r15, r1
    6576:	fe 2c       	mov	r15, r14
    6578:	ee 24       	eor	r14, r14
    657a:	83 81       	ldd	r24, Z+3	; 0x03
    657c:	e8 2a       	or	r14, r24
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    657e:	61 81       	ldd	r22, Z+1	; 0x01
    6580:	86 2f       	mov	r24, r22
    6582:	90 e0       	ldi	r25, 0x00	; 0
    6584:	fc 01       	movw	r30, r24
    6586:	31 97       	sbiw	r30, 0x01	; 1
    6588:	e0 31       	cpi	r30, 0x10	; 16
    658a:	f1 05       	cpc	r31, r1
    658c:	08 f0       	brcs	.+2      	; 0x6590 <MB_S_Timer_ISR+0xe8>
    658e:	ec c1       	rjmp	.+984    	; 0x6968 <MB_S_Timer_ISR+0x4c0>
    6590:	ea 5b       	subi	r30, 0xBA	; 186
    6592:	ff 4f       	sbci	r31, 0xFF	; 255
    6594:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6598:	ec 81       	ldd	r30, Y+4	; 0x04
    659a:	fd 81       	ldd	r31, Y+5	; 0x05
    659c:	e8 5b       	subi	r30, 0xB8	; 184
    659e:	f2 4f       	sbci	r31, 0xF2	; 242
    65a0:	80 81       	ld	r24, Z
    65a2:	88 23       	and	r24, r24
    65a4:	09 f4       	brne	.+2      	; 0x65a8 <MB_S_Timer_ISR+0x100>
    65a6:	dd c0       	rjmp	.+442    	; 0x6762 <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    65a8:	d6 01       	movw	r26, r12
    65aa:	a7 52       	subi	r26, 0x27	; 39
    65ac:	b7 4f       	sbci	r27, 0xF7	; 247
    65ae:	8c 91       	ld	r24, X
    65b0:	88 30       	cpi	r24, 0x08	; 8
    65b2:	09 f0       	breq	.+2      	; 0x65b6 <MB_S_Timer_ISR+0x10e>
    65b4:	8c c0       	rjmp	.+280    	; 0x66ce <MB_S_Timer_ISR+0x226>
    65b6:	24 81       	ldd	r18, Z+4	; 0x04
    65b8:	30 e0       	ldi	r19, 0x00	; 0
    65ba:	32 2f       	mov	r19, r18
    65bc:	22 27       	eor	r18, r18
    65be:	85 81       	ldd	r24, Z+5	; 0x05
    65c0:	28 2b       	or	r18, r24
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65c2:	a9 01       	movw	r20, r18
    65c4:	4e 0d       	add	r20, r14
    65c6:	5f 1d       	adc	r21, r15
    65c8:	f8 01       	movw	r30, r16
    65ca:	61 30       	cpi	r22, 0x01	; 1
    65cc:	61 f4       	brne	.+24     	; 0x65e6 <MB_S_Timer_ISR+0x13e>
    65ce:	e0 54       	subi	r30, 0x40	; 64
    65d0:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    65d2:	85 91       	lpm	r24, Z+
    65d4:	94 91       	lpm	r25, Z
    65d6:	84 17       	cp	r24, r20
    65d8:	95 07       	cpc	r25, r21
    65da:	08 f4       	brcc	.+2      	; 0x65de <MB_S_Timer_ISR+0x136>
    65dc:	96 c1       	rjmp	.+812    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    65de:	f8 01       	movw	r30, r16
    65e0:	e2 54       	subi	r30, 0x42	; 66
    65e2:	f0 4b       	sbci	r31, 0xB0	; 176
    65e4:	0b c0       	rjmp	.+22     	; 0x65fc <MB_S_Timer_ISR+0x154>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65e6:	ec 53       	subi	r30, 0x3C	; 60
    65e8:	f0 4b       	sbci	r31, 0xB0	; 176
    65ea:	85 91       	lpm	r24, Z+
    65ec:	94 91       	lpm	r25, Z
    65ee:	84 17       	cp	r24, r20
    65f0:	95 07       	cpc	r25, r21
    65f2:	08 f4       	brcc	.+2      	; 0x65f6 <MB_S_Timer_ISR+0x14e>
    65f4:	8a c1       	rjmp	.+788    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    65f6:	f8 01       	movw	r30, r16
    65f8:	ee 53       	subi	r30, 0x3E	; 62
    65fa:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    65fc:	65 91       	lpm	r22, Z+
    65fe:	74 91       	lpm	r23, Z
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    6600:	e1 e0       	ldi	r30, 0x01	; 1
    6602:	a9 01       	movw	r20, r18
    6604:	47 70       	andi	r20, 0x07	; 7
    6606:	55 27       	eor	r21, r21
    6608:	45 2b       	or	r20, r21
    660a:	09 f4       	brne	.+2      	; 0x660e <MB_S_Timer_ISR+0x166>
    660c:	e0 e0       	ldi	r30, 0x00	; 0
    660e:	c9 01       	movw	r24, r18
    6610:	43 e0       	ldi	r20, 0x03	; 3
    6612:	96 95       	lsr	r25
    6614:	87 95       	ror	r24
    6616:	4a 95       	dec	r20
    6618:	e1 f7       	brne	.-8      	; 0x6612 <MB_S_Timer_ISR+0x16a>
    661a:	8e 0f       	add	r24, r30
    661c:	ec 81       	ldd	r30, Y+4	; 0x04
    661e:	fd 81       	ldd	r31, Y+5	; 0x05
    6620:	e8 5b       	subi	r30, 0xB8	; 184
    6622:	f2 4f       	sbci	r31, 0xF2	; 242
    6624:	82 83       	std	Z+2, r24	; 0x02
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    6626:	8b 5f       	subi	r24, 0xFB	; 251
    6628:	8c 93       	st	X, r24
	for (uint8_t i=0; i<Qt; i++) {
    662a:	a0 e0       	ldi	r26, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    662c:	22 24       	eor	r2, r2
    662e:	23 94       	inc	r2
    6630:	31 2c       	mov	r3, r1
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    6632:	4a 2f       	mov	r20, r26
    6634:	50 e0       	ldi	r21, 0x00	; 0
    6636:	42 17       	cp	r20, r18
    6638:	53 07       	cpc	r21, r19
    663a:	08 f0       	brcs	.+2      	; 0x663e <MB_S_Timer_ISR+0x196>
    663c:	93 c1       	rjmp	.+806    	; 0x6964 <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    663e:	4e 0d       	add	r20, r14
    6640:	5f 1d       	adc	r21, r15
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6642:	ba 2f       	mov	r27, r26
    6644:	b6 95       	lsr	r27
    6646:	b6 95       	lsr	r27
    6648:	b6 95       	lsr	r27
    664a:	bd 5f       	subi	r27, 0xFD	; 253
    664c:	8a 2f       	mov	r24, r26
    664e:	87 70       	andi	r24, 0x07	; 7
    6650:	21 01       	movw	r4, r2
    6652:	01 c0       	rjmp	.+2      	; 0x6656 <MB_S_Timer_ISR+0x1ae>
    6654:	44 0c       	add	r4, r4
    6656:	8a 95       	dec	r24
    6658:	ea f7       	brpl	.-6      	; 0x6654 <MB_S_Timer_ISR+0x1ac>
		if (Discr[j/8] &(1<<j%8))
    665a:	fa 01       	movw	r30, r20
    665c:	83 e0       	ldi	r24, 0x03	; 3
    665e:	f6 95       	lsr	r31
    6660:	e7 95       	ror	r30
    6662:	8a 95       	dec	r24
    6664:	e1 f7       	brne	.-8      	; 0x665e <MB_S_Timer_ISR+0x1b6>
    6666:	e6 0f       	add	r30, r22
    6668:	f7 1f       	adc	r31, r23
    666a:	80 81       	ld	r24, Z
    666c:	90 e0       	ldi	r25, 0x00	; 0
    666e:	47 70       	andi	r20, 0x07	; 7
    6670:	55 27       	eor	r21, r21
    6672:	02 c0       	rjmp	.+4      	; 0x6678 <MB_S_Timer_ISR+0x1d0>
    6674:	95 95       	asr	r25
    6676:	87 95       	ror	r24
    6678:	4a 95       	dec	r20
    667a:	e2 f7       	brpl	.-8      	; 0x6674 <MB_S_Timer_ISR+0x1cc>
    667c:	eb 2f       	mov	r30, r27
    667e:	f0 e0       	ldi	r31, 0x00	; 0
    6680:	80 ff       	sbrs	r24, 0
    6682:	0a c0       	rjmp	.+20     	; 0x6698 <MB_S_Timer_ISR+0x1f0>
			MB_Frame[MB_N][Byte] |=Bit;
    6684:	8c 81       	ldd	r24, Y+4	; 0x04
    6686:	9d 81       	ldd	r25, Y+5	; 0x05
    6688:	e8 0f       	add	r30, r24
    668a:	f9 1f       	adc	r31, r25
    668c:	e8 5b       	subi	r30, 0xB8	; 184
    668e:	f2 4f       	sbci	r31, 0xF2	; 242
    6690:	80 81       	ld	r24, Z
    6692:	84 29       	or	r24, r4
    6694:	80 83       	st	Z, r24
    6696:	0a c0       	rjmp	.+20     	; 0x66ac <MB_S_Timer_ISR+0x204>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    6698:	8c 81       	ldd	r24, Y+4	; 0x04
    669a:	9d 81       	ldd	r25, Y+5	; 0x05
    669c:	e8 0f       	add	r30, r24
    669e:	f9 1f       	adc	r31, r25
    66a0:	e8 5b       	subi	r30, 0xB8	; 184
    66a2:	f2 4f       	sbci	r31, 0xF2	; 242
    66a4:	40 94       	com	r4
    66a6:	80 81       	ld	r24, Z
    66a8:	48 22       	and	r4, r24
    66aa:	40 82       	st	Z, r4
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    66ac:	af 5f       	subi	r26, 0xFF	; 255
    66ae:	c1 cf       	rjmp	.-126    	; 0x6632 <MB_S_Timer_ISR+0x18a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    66b0:	ec 81       	ldd	r30, Y+4	; 0x04
    66b2:	fd 81       	ldd	r31, Y+5	; 0x05
    66b4:	e8 5b       	subi	r30, 0xB8	; 184
    66b6:	f2 4f       	sbci	r31, 0xF2	; 242
    66b8:	80 81       	ld	r24, Z
    66ba:	88 23       	and	r24, r24
    66bc:	09 f4       	brne	.+2      	; 0x66c0 <MB_S_Timer_ISR+0x218>
    66be:	51 c0       	rjmp	.+162    	; 0x6762 <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    66c0:	96 01       	movw	r18, r12
    66c2:	27 52       	subi	r18, 0x27	; 39
    66c4:	37 4f       	sbci	r19, 0xF7	; 247
    66c6:	d9 01       	movw	r26, r18
    66c8:	8c 91       	ld	r24, X
    66ca:	88 30       	cpi	r24, 0x08	; 8
    66cc:	11 f0       	breq	.+4      	; 0x66d2 <MB_S_Timer_ISR+0x22a>
		return MB_Frame[MB_N][2]=IllegData;
    66ce:	83 e0       	ldi	r24, 0x03	; 3
    66d0:	0f c1       	rjmp	.+542    	; 0x68f0 <MB_S_Timer_ISR+0x448>
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    66d2:	75 81       	ldd	r23, Z+5	; 0x05
    66d4:	c7 01       	movw	r24, r14
    66d6:	87 0f       	add	r24, r23
    66d8:	91 1d       	adc	r25, r1
    66da:	f8 01       	movw	r30, r16
    66dc:	63 30       	cpi	r22, 0x03	; 3
    66de:	61 f4       	brne	.+24     	; 0x66f8 <MB_S_Timer_ISR+0x250>
    66e0:	e8 53       	subi	r30, 0x38	; 56
    66e2:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    66e4:	45 91       	lpm	r20, Z+
    66e6:	54 91       	lpm	r21, Z
    66e8:	48 17       	cp	r20, r24
    66ea:	59 07       	cpc	r21, r25
    66ec:	08 f4       	brcc	.+2      	; 0x66f0 <MB_S_Timer_ISR+0x248>
    66ee:	0d c1       	rjmp	.+538    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    66f0:	f8 01       	movw	r30, r16
    66f2:	ea 53       	subi	r30, 0x3A	; 58
    66f4:	f0 4b       	sbci	r31, 0xB0	; 176
    66f6:	0b c0       	rjmp	.+22     	; 0x670e <MB_S_Timer_ISR+0x266>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    66f8:	e4 53       	subi	r30, 0x34	; 52
    66fa:	f0 4b       	sbci	r31, 0xB0	; 176
    66fc:	45 91       	lpm	r20, Z+
    66fe:	54 91       	lpm	r21, Z
    6700:	48 17       	cp	r20, r24
    6702:	59 07       	cpc	r21, r25
    6704:	08 f4       	brcc	.+2      	; 0x6708 <MB_S_Timer_ISR+0x260>
    6706:	01 c1       	rjmp	.+514    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6708:	f8 01       	movw	r30, r16
    670a:	e6 53       	subi	r30, 0x36	; 54
    670c:	f0 4b       	sbci	r31, 0xB0	; 176
    670e:	85 91       	lpm	r24, Z+
    6710:	94 91       	lpm	r25, Z
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    6712:	77 0f       	add	r23, r23
    6714:	ac 81       	ldd	r26, Y+4	; 0x04
    6716:	bd 81       	ldd	r27, Y+5	; 0x05
    6718:	a8 5b       	subi	r26, 0xB8	; 184
    671a:	b2 4f       	sbci	r27, 0xF2	; 242
    671c:	12 96       	adiw	r26, 0x02	; 2
    671e:	7c 93       	st	X, r23
    6720:	12 97       	sbiw	r26, 0x02	; 2
    6722:	7b 5f       	subi	r23, 0xFB	; 251
    6724:	f9 01       	movw	r30, r18
    6726:	70 83       	st	Z, r23
	uint8_t Qt = MB_Frame[MB_N][5];
    6728:	15 96       	adiw	r26, 0x05	; 5
    672a:	5c 91       	ld	r21, X
    672c:	15 97       	sbiw	r26, 0x05	; 5
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    672e:	f7 01       	movw	r30, r14
    6730:	ee 0f       	add	r30, r30
    6732:	ff 1f       	adc	r31, r31
    6734:	e8 0f       	add	r30, r24
    6736:	f9 1f       	adc	r31, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6738:	40 e0       	ldi	r20, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    673a:	cd 01       	movw	r24, r26
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    673c:	45 17       	cp	r20, r21
    673e:	09 f4       	brne	.+2      	; 0x6742 <MB_S_Timer_ISR+0x29a>
    6740:	11 c1       	rjmp	.+546    	; 0x6964 <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
    6742:	64 2f       	mov	r22, r20
    6744:	66 0f       	add	r22, r22
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    6746:	7c 01       	movw	r14, r24
    6748:	e6 0e       	add	r14, r22
    674a:	f1 1c       	adc	r15, r1
    674c:	61 81       	ldd	r22, Z+1	; 0x01
    674e:	d7 01       	movw	r26, r14
    6750:	13 96       	adiw	r26, 0x03	; 3
    6752:	6c 93       	st	X, r22
		MB_Frame[MB_N][4+j] = Reg[i];
    6754:	20 81       	ld	r18, Z
    6756:	32 96       	adiw	r30, 0x02	; 2
    6758:	d7 01       	movw	r26, r14
    675a:	14 96       	adiw	r26, 0x04	; 4
    675c:	2c 93       	st	X, r18
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    675e:	4f 5f       	subi	r20, 0xFF	; 255
    6760:	ed cf       	rjmp	.-38     	; 0x673c <MB_S_Timer_ISR+0x294>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
    6762:	9f ef       	ldi	r25, 0xFF	; 255
    6764:	08 c1       	rjmp	.+528    	; 0x6976 <MB_S_Timer_ISR+0x4ce>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    6766:	d6 01       	movw	r26, r12
    6768:	a7 52       	subi	r26, 0x27	; 39
    676a:	b7 4f       	sbci	r27, 0xF7	; 247
    676c:	8c 91       	ld	r24, X
    676e:	88 30       	cpi	r24, 0x08	; 8
    6770:	09 f0       	breq	.+2      	; 0x6774 <MB_S_Timer_ISR+0x2cc>
    6772:	b9 c0       	rjmp	.+370    	; 0x68e6 <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    6774:	f8 01       	movw	r30, r16
    6776:	e8 53       	subi	r30, 0x38	; 56
    6778:	f0 4b       	sbci	r31, 0xB0	; 176
    677a:	85 91       	lpm	r24, Z+
    677c:	94 91       	lpm	r25, Z
    677e:	97 01       	movw	r18, r14
    6780:	2f 5f       	subi	r18, 0xFF	; 255
    6782:	3f 4f       	sbci	r19, 0xFF	; 255
    6784:	82 17       	cp	r24, r18
    6786:	93 07       	cpc	r25, r19
    6788:	08 f4       	brcc	.+2      	; 0x678c <MB_S_Timer_ISR+0x2e4>
    678a:	bf c0       	rjmp	.+382    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    678c:	88 e0       	ldi	r24, 0x08	; 8
    678e:	8c 93       	st	X, r24
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    6790:	f8 01       	movw	r30, r16
    6792:	ea 53       	subi	r30, 0x3A	; 58
    6794:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6796:	85 91       	lpm	r24, Z+
    6798:	94 91       	lpm	r25, Z
    679a:	f7 01       	movw	r30, r14
    679c:	ee 0f       	add	r30, r30
    679e:	ff 1f       	adc	r31, r31
    67a0:	e8 0f       	add	r30, r24
    67a2:	f9 1f       	adc	r31, r25
    67a4:	ac 81       	ldd	r26, Y+4	; 0x04
    67a6:	bd 81       	ldd	r27, Y+5	; 0x05
    67a8:	a8 5b       	subi	r26, 0xB8	; 184
    67aa:	b2 4f       	sbci	r27, 0xF2	; 242
    67ac:	14 96       	adiw	r26, 0x04	; 4
    67ae:	8c 91       	ld	r24, X
    67b0:	14 97       	sbiw	r26, 0x04	; 4
    67b2:	90 e0       	ldi	r25, 0x00	; 0
    67b4:	98 2f       	mov	r25, r24
    67b6:	88 27       	eor	r24, r24
    67b8:	15 96       	adiw	r26, 0x05	; 5
    67ba:	2c 91       	ld	r18, X
    67bc:	82 2b       	or	r24, r18
    67be:	91 83       	std	Z+1, r25	; 0x01
    67c0:	80 83       	st	Z, r24
    67c2:	d0 c0       	rjmp	.+416    	; 0x6964 <MB_S_Timer_ISR+0x4bc>
    67c4:	ec 81       	ldd	r30, Y+4	; 0x04
    67c6:	fd 81       	ldd	r31, Y+5	; 0x05
    67c8:	e8 5b       	subi	r30, 0xB8	; 184
    67ca:	f2 4f       	sbci	r31, 0xF2	; 242
    67cc:	64 80       	ldd	r6, Z+4	; 0x04
    67ce:	85 81       	ldd	r24, Z+5	; 0x05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    67d0:	66 81       	ldd	r22, Z+6	; 0x06
    67d2:	d6 01       	movw	r26, r12
    67d4:	a7 52       	subi	r26, 0x27	; 39
    67d6:	b7 4f       	sbci	r27, 0xF7	; 247
    67d8:	4c 91       	ld	r20, X
    67da:	50 e0       	ldi	r21, 0x00	; 0
    67dc:	70 e0       	ldi	r23, 0x00	; 0
    67de:	9b 01       	movw	r18, r22
    67e0:	27 5f       	subi	r18, 0xF7	; 247
    67e2:	3f 4f       	sbci	r19, 0xFF	; 255
    67e4:	42 17       	cp	r20, r18
    67e6:	53 07       	cpc	r21, r19
    67e8:	09 f0       	breq	.+2      	; 0x67ec <MB_S_Timer_ISR+0x344>
    67ea:	7d c0       	rjmp	.+250    	; 0x68e6 <MB_S_Timer_ISR+0x43e>
    67ec:	90 e0       	ldi	r25, 0x00	; 0
    67ee:	96 29       	or	r25, r6
    67f0:	9c 01       	movw	r18, r24
    67f2:	27 70       	andi	r18, 0x07	; 7
    67f4:	33 27       	eor	r19, r19
    67f6:	41 e0       	ldi	r20, 0x01	; 1
    67f8:	50 e0       	ldi	r21, 0x00	; 0
    67fa:	23 2b       	or	r18, r19
    67fc:	11 f4       	brne	.+4      	; 0x6802 <MB_S_Timer_ISR+0x35a>
    67fe:	40 e0       	ldi	r20, 0x00	; 0
    6800:	50 e0       	ldi	r21, 0x00	; 0
    6802:	9c 01       	movw	r18, r24
    6804:	e3 e0       	ldi	r30, 0x03	; 3
    6806:	36 95       	lsr	r19
    6808:	27 95       	ror	r18
    680a:	ea 95       	dec	r30
    680c:	e1 f7       	brne	.-8      	; 0x6806 <MB_S_Timer_ISR+0x35e>
    680e:	24 0f       	add	r18, r20
    6810:	35 1f       	adc	r19, r21
    6812:	26 17       	cp	r18, r22
    6814:	37 07       	cpc	r19, r23
    6816:	09 f0       	breq	.+2      	; 0x681a <MB_S_Timer_ISR+0x372>
    6818:	66 c0       	rjmp	.+204    	; 0x68e6 <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    681a:	f8 01       	movw	r30, r16
    681c:	e0 54       	subi	r30, 0x40	; 64
    681e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6820:	25 91       	lpm	r18, Z+
    6822:	34 91       	lpm	r19, Z
    6824:	ac 01       	movw	r20, r24
    6826:	4e 0d       	add	r20, r14
    6828:	5f 1d       	adc	r21, r15
    682a:	24 17       	cp	r18, r20
    682c:	35 07       	cpc	r19, r21
    682e:	08 f4       	brcc	.+2      	; 0x6832 <MB_S_Timer_ISR+0x38a>
    6830:	6c c0       	rjmp	.+216    	; 0x690a <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
    6832:	f8 01       	movw	r30, r16
    6834:	e2 54       	subi	r30, 0x42	; 66
    6836:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6838:	25 90       	lpm	r2, Z+
    683a:	34 90       	lpm	r3, Z
	MB_Frame_Sz[MB_N] = 8;
    683c:	28 e0       	ldi	r18, 0x08	; 8
    683e:	2c 93       	st	X, r18
	for (uint8_t i=0; i<Qt; i++) {
    6840:	51 2c       	mov	r5, r1
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6842:	6c 81       	ldd	r22, Y+4	; 0x04
    6844:	7d 81       	ldd	r23, Y+5	; 0x05
    6846:	68 5b       	subi	r22, 0xB8	; 184
    6848:	72 4f       	sbci	r23, 0xF2	; 242
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    684a:	45 2d       	mov	r20, r5
    684c:	50 e0       	ldi	r21, 0x00	; 0
    684e:	48 17       	cp	r20, r24
    6850:	59 07       	cpc	r21, r25
    6852:	08 f0       	brcs	.+2      	; 0x6856 <MB_S_Timer_ISR+0x3ae>
    6854:	87 c0       	rjmp	.+270    	; 0x6964 <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    6856:	4e 0d       	add	r20, r14
    6858:	5f 1d       	adc	r21, r15
		uint16_t Byte=j/8, Bit=1<<j%8;
    685a:	fa 01       	movw	r30, r20
    685c:	a3 e0       	ldi	r26, 0x03	; 3
    685e:	f6 95       	lsr	r31
    6860:	e7 95       	ror	r30
    6862:	aa 95       	dec	r26
    6864:	e1 f7       	brne	.-8      	; 0x685e <MB_S_Timer_ISR+0x3b6>
    6866:	47 70       	andi	r20, 0x07	; 7
    6868:	55 27       	eor	r21, r21
    686a:	21 e0       	ldi	r18, 0x01	; 1
    686c:	30 e0       	ldi	r19, 0x00	; 0
    686e:	02 c0       	rjmp	.+4      	; 0x6874 <MB_S_Timer_ISR+0x3cc>
    6870:	22 0f       	add	r18, r18
    6872:	33 1f       	adc	r19, r19
    6874:	4a 95       	dec	r20
    6876:	e2 f7       	brpl	.-8      	; 0x6870 <MB_S_Timer_ISR+0x3c8>
    6878:	a9 01       	movw	r20, r18
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    687a:	25 2d       	mov	r18, r5
    687c:	26 95       	lsr	r18
    687e:	26 95       	lsr	r18
    6880:	26 95       	lsr	r18
    6882:	db 01       	movw	r26, r22
    6884:	a2 0f       	add	r26, r18
    6886:	b1 1d       	adc	r27, r1
    6888:	17 96       	adiw	r26, 0x07	; 7
    688a:	2c 91       	ld	r18, X
    688c:	30 e0       	ldi	r19, 0x00	; 0
    688e:	a5 2d       	mov	r26, r5
    6890:	a7 70       	andi	r26, 0x07	; 7
    6892:	02 c0       	rjmp	.+4      	; 0x6898 <MB_S_Timer_ISR+0x3f0>
    6894:	35 95       	asr	r19
    6896:	27 95       	ror	r18
    6898:	aa 95       	dec	r26
    689a:	e2 f7       	brpl	.-8      	; 0x6894 <MB_S_Timer_ISR+0x3ec>
    689c:	e2 0d       	add	r30, r2
    689e:	f3 1d       	adc	r31, r3
    68a0:	20 ff       	sbrs	r18, 0
    68a2:	03 c0       	rjmp	.+6      	; 0x68aa <MB_S_Timer_ISR+0x402>
			Coil[Byte] |=Bit;
    68a4:	20 81       	ld	r18, Z
    68a6:	24 2b       	or	r18, r20
    68a8:	03 c0       	rjmp	.+6      	; 0x68b0 <MB_S_Timer_ISR+0x408>
		else
			Coil[Byte] &=~Bit;
    68aa:	40 95       	com	r20
    68ac:	20 81       	ld	r18, Z
    68ae:	24 23       	and	r18, r20
    68b0:	20 83       	st	Z, r18
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    68b2:	53 94       	inc	r5
    68b4:	ca cf       	rjmp	.-108    	; 0x684a <MB_S_Timer_ISR+0x3a2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    68b6:	ec 81       	ldd	r30, Y+4	; 0x04
    68b8:	fd 81       	ldd	r31, Y+5	; 0x05
    68ba:	e8 5b       	subi	r30, 0xB8	; 184
    68bc:	f2 4f       	sbci	r31, 0xF2	; 242
    68be:	46 81       	ldd	r20, Z+6	; 0x06
    68c0:	50 e0       	ldi	r21, 0x00	; 0
    68c2:	d6 01       	movw	r26, r12
    68c4:	a7 52       	subi	r26, 0x27	; 39
    68c6:	b7 4f       	sbci	r27, 0xF7	; 247
    68c8:	2c 91       	ld	r18, X
    68ca:	30 e0       	ldi	r19, 0x00	; 0
    68cc:	ca 01       	movw	r24, r20
    68ce:	09 96       	adiw	r24, 0x09	; 9
    68d0:	28 17       	cp	r18, r24
    68d2:	39 07       	cpc	r19, r25
    68d4:	41 f4       	brne	.+16     	; 0x68e6 <MB_S_Timer_ISR+0x43e>
    68d6:	85 81       	ldd	r24, Z+5	; 0x05
    68d8:	90 e0       	ldi	r25, 0x00	; 0
    68da:	9c 01       	movw	r18, r24
    68dc:	22 0f       	add	r18, r18
    68de:	33 1f       	adc	r19, r19
    68e0:	24 17       	cp	r18, r20
    68e2:	35 07       	cpc	r19, r21
    68e4:	41 f0       	breq	.+16     	; 0x68f6 <MB_S_Timer_ISR+0x44e>
		return MB_Frame[MB_N][2]=IllegData;
    68e6:	83 e0       	ldi	r24, 0x03	; 3
    68e8:	ec 81       	ldd	r30, Y+4	; 0x04
    68ea:	fd 81       	ldd	r31, Y+5	; 0x05
    68ec:	e8 5b       	subi	r30, 0xB8	; 184
    68ee:	f2 4f       	sbci	r31, 0xF2	; 242
    68f0:	82 83       	std	Z+2, r24	; 0x02
    68f2:	93 e0       	ldi	r25, 0x03	; 3
    68f4:	40 c0       	rjmp	.+128    	; 0x6976 <MB_S_Timer_ISR+0x4ce>
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    68f6:	f8 01       	movw	r30, r16
    68f8:	e8 53       	subi	r30, 0x38	; 56
    68fa:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    68fc:	25 91       	lpm	r18, Z+
    68fe:	34 91       	lpm	r19, Z
    6900:	8e 0d       	add	r24, r14
    6902:	9f 1d       	adc	r25, r15
    6904:	28 17       	cp	r18, r24
    6906:	39 07       	cpc	r19, r25
    6908:	40 f4       	brcc	.+16     	; 0x691a <MB_S_Timer_ISR+0x472>
		return MB_Frame[MB_N][2]=IllegAddr;
    690a:	82 e0       	ldi	r24, 0x02	; 2
    690c:	ec 81       	ldd	r30, Y+4	; 0x04
    690e:	fd 81       	ldd	r31, Y+5	; 0x05
    6910:	e8 5b       	subi	r30, 0xB8	; 184
    6912:	f2 4f       	sbci	r31, 0xF2	; 242
    6914:	82 83       	std	Z+2, r24	; 0x02
    6916:	92 e0       	ldi	r25, 0x02	; 2
    6918:	2e c0       	rjmp	.+92     	; 0x6976 <MB_S_Timer_ISR+0x4ce>
	MB_Frame_Sz[MB_N] = 8;
    691a:	88 e0       	ldi	r24, 0x08	; 8
    691c:	8c 93       	st	X, r24
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    691e:	f8 01       	movw	r30, r16
    6920:	ea 53       	subi	r30, 0x3A	; 58
    6922:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6924:	25 90       	lpm	r2, Z+
    6926:	34 90       	lpm	r3, Z
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6928:	61 2c       	mov	r6, r1
    692a:	2c 81       	ldd	r18, Y+4	; 0x04
    692c:	3d 81       	ldd	r19, Y+5	; 0x05
    692e:	23 5b       	subi	r18, 0xB3	; 179
    6930:	32 4f       	sbci	r19, 0xF2	; 242
    6932:	3a 83       	std	Y+2, r19	; 0x02
    6934:	29 83       	std	Y+1, r18	; 0x01
    6936:	e9 81       	ldd	r30, Y+1	; 0x01
    6938:	fa 81       	ldd	r31, Y+2	; 0x02
    693a:	80 81       	ld	r24, Z
    693c:	68 16       	cp	r6, r24
    693e:	90 f4       	brcc	.+36     	; 0x6964 <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    6940:	27 01       	movw	r4, r14
    6942:	46 0c       	add	r4, r6
    6944:	51 1c       	adc	r5, r1
    6946:	44 0c       	add	r4, r4
    6948:	55 1c       	adc	r5, r5
    694a:	42 0c       	add	r4, r2
    694c:	53 1c       	adc	r5, r3
    694e:	66 2d       	mov	r22, r6
    6950:	66 0f       	add	r22, r22
    6952:	69 5f       	subi	r22, 0xF9	; 249
    6954:	87 2d       	mov	r24, r7
    6956:	0e 94 40 32 	call	0x6480	; 0x6480 <MB_FrameReg>
    695a:	d2 01       	movw	r26, r4
    695c:	8d 93       	st	X+, r24
    695e:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6960:	63 94       	inc	r6
    6962:	e9 cf       	rjmp	.-46     	; 0x6936 <MB_S_Timer_ISR+0x48e>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
	}
	return 0;
    6964:	90 e0       	ldi	r25, 0x00	; 0
    6966:	07 c0       	rjmp	.+14     	; 0x6976 <MB_S_Timer_ISR+0x4ce>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6968:	81 e0       	ldi	r24, 0x01	; 1
    696a:	ec 81       	ldd	r30, Y+4	; 0x04
    696c:	fd 81       	ldd	r31, Y+5	; 0x05
    696e:	e8 5b       	subi	r30, 0xB8	; 184
    6970:	f2 4f       	sbci	r31, 0xF2	; 242
    6972:	82 83       	std	Z+2, r24	; 0x02
    6974:	91 e0       	ldi	r25, 0x01	; 1
		break;
	}
	if (MB_Frame[MB_N][0]) {
    6976:	ec 81       	ldd	r30, Y+4	; 0x04
    6978:	fd 81       	ldd	r31, Y+5	; 0x05
    697a:	e8 5b       	subi	r30, 0xB8	; 184
    697c:	f2 4f       	sbci	r31, 0xF2	; 242
    697e:	80 81       	ld	r24, Z
    6980:	88 23       	and	r24, r24
    6982:	79 f0       	breq	.+30     	; 0x69a2 <MB_S_Timer_ISR+0x4fa>
		if (Err) {
    6984:	99 23       	and	r25, r25
    6986:	41 f0       	breq	.+16     	; 0x6998 <MB_S_Timer_ISR+0x4f0>
			MB_Frame[MB_N][1] |=(1<<7);
    6988:	81 81       	ldd	r24, Z+1	; 0x01
    698a:	80 68       	ori	r24, 0x80	; 128
    698c:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    698e:	f6 01       	movw	r30, r12
    6990:	e7 52       	subi	r30, 0x27	; 39
    6992:	f7 4f       	sbci	r31, 0xF7	; 247
    6994:	85 e0       	ldi	r24, 0x05	; 5
    6996:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    6998:	87 2d       	mov	r24, r7
    699a:	9b 83       	std	Y+3, r25	; 0x03
    699c:	0e 94 c1 30 	call	0x6182	; 0x6182 <SetCRC_MB>
    69a0:	9b 81       	ldd	r25, Y+3	; 0x03
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    69a2:	99 23       	and	r25, r25
    69a4:	41 f0       	breq	.+16     	; 0x69b6 <MB_S_Timer_ISR+0x50e>
		MB_CPT[MB_N][2]++;
    69a6:	f8 01       	movw	r30, r16
    69a8:	e7 5d       	subi	r30, 0xD7	; 215
    69aa:	f4 4f       	sbci	r31, 0xF4	; 244
    69ac:	84 81       	ldd	r24, Z+4	; 0x04
    69ae:	95 81       	ldd	r25, Z+5	; 0x05
    69b0:	01 96       	adiw	r24, 0x01	; 1
    69b2:	95 83       	std	Z+5, r25	; 0x05
    69b4:	84 83       	std	Z+4, r24	; 0x04
	if (MB_Frame[MB_N][0])
    69b6:	ec 81       	ldd	r30, Y+4	; 0x04
    69b8:	fd 81       	ldd	r31, Y+5	; 0x05
    69ba:	e8 5b       	subi	r30, 0xB8	; 184
    69bc:	f2 4f       	sbci	r31, 0xF2	; 242
    69be:	80 81       	ld	r24, Z
    69c0:	88 23       	and	r24, r24
    69c2:	d1 f0       	breq	.+52     	; 0x69f8 <MB_S_Timer_ISR+0x550>
		MB_Transm(MB_N);
    69c4:	87 2d       	mov	r24, r7
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69c6:	0f 90       	pop	r0
    69c8:	0f 90       	pop	r0
    69ca:	0f 90       	pop	r0
    69cc:	0f 90       	pop	r0
    69ce:	0f 90       	pop	r0
    69d0:	df 91       	pop	r29
    69d2:	cf 91       	pop	r28
    69d4:	1f 91       	pop	r17
    69d6:	0f 91       	pop	r16
    69d8:	ff 90       	pop	r15
    69da:	ef 90       	pop	r14
    69dc:	df 90       	pop	r13
    69de:	cf 90       	pop	r12
    69e0:	bf 90       	pop	r11
    69e2:	af 90       	pop	r10
    69e4:	9f 90       	pop	r9
    69e6:	8f 90       	pop	r8
    69e8:	7f 90       	pop	r7
    69ea:	6f 90       	pop	r6
    69ec:	5f 90       	pop	r5
    69ee:	4f 90       	pop	r4
    69f0:	3f 90       	pop	r3
    69f2:	2f 90       	pop	r2
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    69f4:	0c 94 bf 2f 	jmp	0x5f7e	; 0x5f7e <MB_Transm>
	else {
		MB_CPT[MB_N][4]++;
    69f8:	f8 01       	movw	r30, r16
    69fa:	e7 5d       	subi	r30, 0xD7	; 215
    69fc:	f4 4f       	sbci	r31, 0xF4	; 244
    69fe:	80 85       	ldd	r24, Z+8	; 0x08
    6a00:	91 85       	ldd	r25, Z+9	; 0x09
    6a02:	01 96       	adiw	r24, 0x01	; 1
    6a04:	91 87       	std	Z+9, r25	; 0x09
    6a06:	80 87       	std	Z+8, r24	; 0x08
		MB_State[MB_N] = MB_Idle;
    6a08:	81 e0       	ldi	r24, 0x01	; 1
    6a0a:	d5 01       	movw	r26, r10
    6a0c:	8c 93       	st	X, r24
    6a0e:	f4 01       	movw	r30, r8
    6a10:	85 91       	lpm	r24, Z+
    6a12:	94 91       	lpm	r25, Z
		USART_Func(MB_N, LED);
    6a14:	fc 01       	movw	r30, r24
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a16:	0f 90       	pop	r0
    6a18:	0f 90       	pop	r0
    6a1a:	0f 90       	pop	r0
    6a1c:	0f 90       	pop	r0
    6a1e:	0f 90       	pop	r0
    6a20:	df 91       	pop	r29
    6a22:	cf 91       	pop	r28
    6a24:	1f 91       	pop	r17
    6a26:	0f 91       	pop	r16
    6a28:	ff 90       	pop	r15
    6a2a:	ef 90       	pop	r14
    6a2c:	df 90       	pop	r13
    6a2e:	cf 90       	pop	r12
    6a30:	bf 90       	pop	r11
    6a32:	af 90       	pop	r10
    6a34:	9f 90       	pop	r9
    6a36:	8f 90       	pop	r8
    6a38:	7f 90       	pop	r7
    6a3a:	6f 90       	pop	r6
    6a3c:	5f 90       	pop	r5
    6a3e:	4f 90       	pop	r4
    6a40:	3f 90       	pop	r3
    6a42:	2f 90       	pop	r2
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
		MB_State[MB_N] = MB_Idle;
		USART_Func(MB_N, LED);
    6a44:	09 94       	ijmp
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a46:	0f 90       	pop	r0
    6a48:	0f 90       	pop	r0
    6a4a:	0f 90       	pop	r0
    6a4c:	0f 90       	pop	r0
    6a4e:	0f 90       	pop	r0
    6a50:	df 91       	pop	r29
    6a52:	cf 91       	pop	r28
    6a54:	1f 91       	pop	r17
    6a56:	0f 91       	pop	r16
    6a58:	ff 90       	pop	r15
    6a5a:	ef 90       	pop	r14
    6a5c:	df 90       	pop	r13
    6a5e:	cf 90       	pop	r12
    6a60:	bf 90       	pop	r11
    6a62:	af 90       	pop	r10
    6a64:	9f 90       	pop	r9
    6a66:	8f 90       	pop	r8
    6a68:	7f 90       	pop	r7
    6a6a:	6f 90       	pop	r6
    6a6c:	5f 90       	pop	r5
    6a6e:	4f 90       	pop	r4
    6a70:	3f 90       	pop	r3
    6a72:	2f 90       	pop	r2
    6a74:	08 95       	ret

00006a76 <MB_S_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6a76:	24 e1       	ldi	r18, 0x14	; 20
    6a78:	82 9f       	mul	r24, r18
    6a7a:	c0 01       	movw	r24, r0
    6a7c:	11 24       	eor	r1, r1
    6a7e:	83 56       	subi	r24, 0x63	; 99
    6a80:	90 4b       	sbci	r25, 0xB0	; 176
    6a82:	fc 01       	movw	r30, r24
    6a84:	85 91       	lpm	r24, Z+
    6a86:	94 91       	lpm	r25, Z
    6a88:	fc 01       	movw	r30, r24
    6a8a:	09 94       	ijmp

00006a8c <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    6a8c:	cf 93       	push	r28
    6a8e:	df 93       	push	r29
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    6a90:	c8 2f       	mov	r28, r24
    6a92:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6a94:	ce 01       	movw	r24, r28
    6a96:	8e 55       	subi	r24, 0x5E	; 94
    6a98:	9e 4f       	sbci	r25, 0xFE	; 254
    6a9a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    6a9e:	c8 50       	subi	r28, 0x08	; 8
    6aa0:	dc 4f       	sbci	r29, 0xFC	; 252
    6aa2:	88 83       	st	Y, r24
	#endif
}
    6aa4:	df 91       	pop	r29
    6aa6:	cf 91       	pop	r28
    6aa8:	08 95       	ret

00006aaa <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    6aaa:	0f 93       	push	r16
    6aac:	1f 93       	push	r17
    6aae:	cf 93       	push	r28
    6ab0:	df 93       	push	r29
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    6ab2:	c8 2f       	mov	r28, r24
    6ab4:	d0 e0       	ldi	r29, 0x00	; 0
    6ab6:	95 e0       	ldi	r25, 0x05	; 5
    6ab8:	89 9f       	mul	r24, r25
    6aba:	80 01       	movw	r16, r0
    6abc:	11 24       	eor	r1, r1
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    6abe:	c8 01       	movw	r24, r16
    6ac0:	86 56       	subi	r24, 0x66	; 102
    6ac2:	9e 4f       	sbci	r25, 0xFE	; 254
    6ac4:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    6ac8:	fe 01       	movw	r30, r28
    6aca:	ee 0f       	add	r30, r30
    6acc:	ff 1f       	adc	r31, r31
    6ace:	e0 5e       	subi	r30, 0xE0	; 224
    6ad0:	f9 4f       	sbci	r31, 0xF9	; 249
    6ad2:	91 83       	std	Z+1, r25	; 0x01
    6ad4:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6ad6:	c8 01       	movw	r24, r16
    6ad8:	84 56       	subi	r24, 0x64	; 100
    6ada:	9e 4f       	sbci	r25, 0xFE	; 254
    6adc:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    6ae0:	fe 01       	movw	r30, r28
    6ae2:	ee 5e       	subi	r30, 0xEE	; 238
    6ae4:	f4 4f       	sbci	r31, 0xF4	; 244
    6ae6:	80 83       	st	Z, r24
    6ae8:	c8 01       	movw	r24, r16
    6aea:	83 56       	subi	r24, 0x63	; 99
    6aec:	9e 4f       	sbci	r25, 0xFE	; 254
    6aee:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    6af2:	fe 01       	movw	r30, r28
    6af4:	ec 52       	subi	r30, 0x2C	; 44
    6af6:	f7 4f       	sbci	r31, 0xF7	; 247
    6af8:	80 83       	st	Z, r24
    6afa:	c8 01       	movw	r24, r16
    6afc:	82 56       	subi	r24, 0x62	; 98
    6afe:	9e 4f       	sbci	r25, 0xFE	; 254
    6b00:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    6b04:	c6 51       	subi	r28, 0x16	; 22
    6b06:	dc 4f       	sbci	r29, 0xFC	; 252
    6b08:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    6b0a:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    6b0e:	93 e0       	ldi	r25, 0x03	; 3
    6b10:	98 0f       	add	r25, r24
    6b12:	90 93 0e 01 	sts	0x010E, r25

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    6b16:	80 93 5c 02 	sts	0x025C, r24
}
    6b1a:	df 91       	pop	r29
    6b1c:	cf 91       	pop	r28
    6b1e:	1f 91       	pop	r17
    6b20:	0f 91       	pop	r16
    6b22:	08 95       	ret

00006b24 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    6b24:	0e 94 a9 2e 	call	0x5d52	; 0x5d52 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    6b28:	10 92 e1 03 	sts	0x03E1, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b2c:	e1 e9       	ldi	r30, 0x91	; 145
    6b2e:	ff e4       	ldi	r31, 0x4F	; 79
    6b30:	a5 91       	lpm	r26, Z+
    6b32:	b4 91       	lpm	r27, Z
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    6b34:	8c ef       	ldi	r24, 0xFC	; 252
    6b36:	8c 93       	st	X, r24
    6b38:	e3 e9       	ldi	r30, 0x93	; 147
    6b3a:	ff e4       	ldi	r31, 0x4F	; 79
    6b3c:	a5 91       	lpm	r26, Z+
    6b3e:	b4 91       	lpm	r27, Z
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    6b40:	88 e9       	ldi	r24, 0x98	; 152
    6b42:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    6b44:	80 e0       	ldi	r24, 0x00	; 0
    6b46:	0e 94 39 2f 	call	0x5e72	; 0x5e72 <SetParity>
		SetBAUD(MB_N);
    6b4a:	80 e0       	ldi	r24, 0x00	; 0
    6b4c:	0e 94 7c 2f 	call	0x5ef8	; 0x5ef8 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6b50:	ee ec       	ldi	r30, 0xCE	; 206
    6b52:	ff e4       	ldi	r31, 0x4F	; 79
    6b54:	e4 91       	lpm	r30, Z
		switch (prb(MB_Role+MB_N)) {
    6b56:	ee 23       	and	r30, r30
    6b58:	31 f0       	breq	.+12     	; 0x6b66 <MB_Init+0x42>
    6b5a:	e1 30       	cpi	r30, 0x01	; 1
    6b5c:	39 f4       	brne	.+14     	; 0x6b6c <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    6b5e:	80 e0       	ldi	r24, 0x00	; 0
    6b60:	0e 94 55 35 	call	0x6aaa	; 0x6aaa <MB_M_Init>
			break;
    6b64:	03 c0       	rjmp	.+6      	; 0x6b6c <MB_Init+0x48>
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
		case Role_Slave:
			MB_S_Init(MB_N);
    6b66:	80 e0       	ldi	r24, 0x00	; 0
    6b68:	0e 94 46 35 	call	0x6a8c	; 0x6a8c <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b6c:	e7 e8       	ldi	r30, 0x87	; 135
    6b6e:	ff e4       	ldi	r31, 0x4F	; 79
    6b70:	25 91       	lpm	r18, Z+
    6b72:	34 91       	lpm	r19, Z
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    6b74:	f9 01       	movw	r30, r18
    6b76:	09 94       	ijmp

00006b78 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6b78:	4f 92       	push	r4
    6b7a:	5f 92       	push	r5
    6b7c:	7f 92       	push	r7
    6b7e:	8f 92       	push	r8
    6b80:	9f 92       	push	r9
    6b82:	af 92       	push	r10
    6b84:	bf 92       	push	r11
    6b86:	cf 92       	push	r12
    6b88:	df 92       	push	r13
    6b8a:	ef 92       	push	r14
    6b8c:	ff 92       	push	r15
    6b8e:	0f 93       	push	r16
    6b90:	1f 93       	push	r17
    6b92:	cf 93       	push	r28
    6b94:	df 93       	push	r29
    6b96:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    6b98:	c8 2f       	mov	r28, r24
    6b9a:	d0 e0       	ldi	r29, 0x00	; 0
    6b9c:	fe 01       	movw	r30, r28
    6b9e:	ef 51       	subi	r30, 0x1F	; 31
    6ba0:	fc 4f       	sbci	r31, 0xFC	; 252
    6ba2:	80 81       	ld	r24, Z
    6ba4:	88 23       	and	r24, r24
    6ba6:	19 f0       	breq	.+6      	; 0x6bae <MB_M_Timer_ISR+0x36>
    6ba8:	82 30       	cpi	r24, 0x02	; 2
    6baa:	f1 f0       	breq	.+60     	; 0x6be8 <MB_M_Timer_ISR+0x70>
    6bac:	85 c2       	rjmp	.+1290   	; 0x70b8 <MB_M_Timer_ISR+0x540>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6bae:	80 91 5c 02 	lds	r24, 0x025C
    6bb2:	8e 5f       	subi	r24, 0xFE	; 254
    6bb4:	6f ef       	ldi	r22, 0xFF	; 255
    6bb6:	7f ef       	ldi	r23, 0xFF	; 255
    6bb8:	8d 0d       	add	r24, r13
    6bba:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
		FormQuery(MB_N);
    6bbe:	8d 2d       	mov	r24, r13
    6bc0:	0e 94 cc 31 	call	0x6398	; 0x6398 <FormQuery>
		MB_Transm(MB_N);
    6bc4:	8d 2d       	mov	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6bc6:	df 91       	pop	r29
    6bc8:	cf 91       	pop	r28
    6bca:	1f 91       	pop	r17
    6bcc:	0f 91       	pop	r16
    6bce:	ff 90       	pop	r15
    6bd0:	ef 90       	pop	r14
    6bd2:	df 90       	pop	r13
    6bd4:	cf 90       	pop	r12
    6bd6:	bf 90       	pop	r11
    6bd8:	af 90       	pop	r10
    6bda:	9f 90       	pop	r9
    6bdc:	8f 90       	pop	r8
    6bde:	7f 90       	pop	r7
    6be0:	5f 90       	pop	r5
    6be2:	4f 90       	pop	r4
{
	switch (MB_State[MB_N]) {
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
    6be4:	0c 94 bf 2f 	jmp	0x5f7e	; 0x5f7e <MB_Transm>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6be8:	84 e0       	ldi	r24, 0x04	; 4
    6bea:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6bec:	9e 01       	movw	r18, r28
    6bee:	2e 5d       	subi	r18, 0xDE	; 222
    6bf0:	39 4f       	sbci	r19, 0xF9	; 249
    6bf2:	79 01       	movw	r14, r18
    6bf4:	f9 01       	movw	r30, r18
    6bf6:	90 81       	ld	r25, Z
    6bf8:	81 e0       	ldi	r24, 0x01	; 1
    6bfa:	92 30       	cpi	r25, 0x02	; 2
    6bfc:	09 f0       	breq	.+2      	; 0x6c00 <MB_M_Timer_ISR+0x88>
    6bfe:	80 e0       	ldi	r24, 0x00	; 0
    6c00:	80 93 62 02 	sts	0x0262, r24
	if (CommErr(MB_N))
    6c04:	8d 2d       	mov	r24, r13
    6c06:	0e 94 60 30 	call	0x60c0	; 0x60c0 <CommErr>
    6c0a:	81 11       	cpse	r24, r1
    6c0c:	ed c1       	rjmp	.+986    	; 0x6fe8 <MB_M_Timer_ISR+0x470>
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6c0e:	84 e1       	ldi	r24, 0x14	; 20
    6c10:	8c 9f       	mul	r24, r28
    6c12:	f0 01       	movw	r30, r0
    6c14:	8d 9f       	mul	r24, r29
    6c16:	f0 0d       	add	r31, r0
    6c18:	11 24       	eor	r1, r1
    6c1a:	e3 56       	subi	r30, 0x63	; 99
    6c1c:	f0 4b       	sbci	r31, 0xB0	; 176
    6c1e:	85 91       	lpm	r24, Z+
    6c20:	94 91       	lpm	r25, Z
    6c22:	fc 01       	movw	r30, r24
    6c24:	09 95       	icall
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6c26:	80 91 62 02 	lds	r24, 0x0262
    6c2a:	88 23       	and	r24, r24
    6c2c:	79 f0       	breq	.+30     	; 0x6c4c <MB_M_Timer_ISR+0xd4>
			Addr = MB_SingleQuery[MB_N].Addr;
    6c2e:	fe 01       	movw	r30, r28
    6c30:	63 e0       	ldi	r22, 0x03	; 3
    6c32:	ee 0f       	add	r30, r30
    6c34:	ff 1f       	adc	r31, r31
    6c36:	6a 95       	dec	r22
    6c38:	e1 f7       	brne	.-8      	; 0x6c32 <MB_M_Timer_ISR+0xba>
    6c3a:	ed 59       	subi	r30, 0x9D	; 157
    6c3c:	fd 4f       	sbci	r31, 0xFD	; 253
    6c3e:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6c40:	41 81       	ldd	r20, Z+1	; 0x01
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
    6c42:	80 e0       	ldi	r24, 0x00	; 0
    6c44:	90 e0       	ldi	r25, 0x00	; 0
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
    6c46:	00 e0       	ldi	r16, 0x00	; 0
    6c48:	10 e0       	ldi	r17, 0x00	; 0
    6c4a:	15 c0       	rjmp	.+42     	; 0x6c76 <MB_M_Timer_ISR+0xfe>
		if (LastProcSingle) {
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
    6c4c:	8d 2d       	mov	r24, r13
    6c4e:	0e 94 b9 28 	call	0x5172	; 0x5172 <GetSlave>
    6c52:	8c 01       	movw	r16, r24
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6c54:	fc 01       	movw	r30, r24
    6c56:	31 96       	adiw	r30, 0x01	; 1
    6c58:	85 91       	lpm	r24, Z+
    6c5a:	94 91       	lpm	r25, Z
    6c5c:	fe 01       	movw	r30, r28
    6c5e:	e3 5f       	subi	r30, 0xF3	; 243
    6c60:	f9 4f       	sbci	r31, 0xF9	; 249
    6c62:	20 81       	ld	r18, Z
    6c64:	f7 e0       	ldi	r31, 0x07	; 7
    6c66:	2f 9f       	mul	r18, r31
    6c68:	80 0d       	add	r24, r0
    6c6a:	91 1d       	adc	r25, r1
    6c6c:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6c6e:	f8 01       	movw	r30, r16
    6c70:	24 91       	lpm	r18, Z
    6c72:	fc 01       	movw	r30, r24
    6c74:	44 91       	lpm	r20, Z
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6c76:	bc 2f       	mov	r27, r28
    6c78:	aa 27       	eor	r26, r26
    6c7a:	fd 01       	movw	r30, r26
    6c7c:	e8 5b       	subi	r30, 0xB8	; 184
    6c7e:	f2 4f       	sbci	r31, 0xF2	; 242
    6c80:	30 81       	ld	r19, Z
    6c82:	32 13       	cpse	r19, r18
    6c84:	b1 c1       	rjmp	.+866    	; 0x6fe8 <MB_M_Timer_ISR+0x470>
    6c86:	c1 80       	ldd	r12, Z+1	; 0x01
    6c88:	c4 12       	cpse	r12, r20
    6c8a:	ae c1       	rjmp	.+860    	; 0x6fe8 <MB_M_Timer_ISR+0x470>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err = 0;
			switch (Func) {
    6c8c:	50 e0       	ldi	r21, 0x00	; 0
    6c8e:	fa 01       	movw	r30, r20
    6c90:	31 97       	sbiw	r30, 0x01	; 1
    6c92:	e0 31       	cpi	r30, 0x10	; 16
    6c94:	f1 05       	cpc	r31, r1
    6c96:	08 f0       	brcs	.+2      	; 0x6c9a <MB_M_Timer_ISR+0x122>
    6c98:	ab c1       	rjmp	.+854    	; 0x6ff0 <MB_M_Timer_ISR+0x478>
    6c9a:	ea 5a       	subi	r30, 0xAA	; 170
    6c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    6c9e:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6ca2:	20 91 62 02 	lds	r18, 0x0262
    6ca6:	22 23       	and	r18, r18
    6ca8:	51 f0       	breq	.+20     	; 0x6cbe <MB_M_Timer_ISR+0x146>
    6caa:	fe 01       	movw	r30, r28
    6cac:	43 e0       	ldi	r20, 0x03	; 3
    6cae:	ee 0f       	add	r30, r30
    6cb0:	ff 1f       	adc	r31, r31
    6cb2:	4a 95       	dec	r20
    6cb4:	e1 f7       	brne	.-8      	; 0x6cae <MB_M_Timer_ISR+0x136>
    6cb6:	ed 59       	subi	r30, 0x9D	; 157
    6cb8:	fd 4f       	sbci	r31, 0xFD	; 253
    6cba:	64 81       	ldd	r22, Z+4	; 0x04
    6cbc:	03 c0       	rjmp	.+6      	; 0x6cc4 <MB_M_Timer_ISR+0x14c>
    6cbe:	fc 01       	movw	r30, r24
    6cc0:	33 96       	adiw	r30, 0x03	; 3
    6cc2:	64 91       	lpm	r22, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6cc4:	fd 01       	movw	r30, r26
    6cc6:	e8 5b       	subi	r30, 0xB8	; 184
    6cc8:	f2 4f       	sbci	r31, 0xF2	; 242
    6cca:	22 81       	ldd	r18, Z+2	; 0x02
    6ccc:	30 e0       	ldi	r19, 0x00	; 0
    6cce:	fe 01       	movw	r30, r28
    6cd0:	e7 52       	subi	r30, 0x27	; 39
    6cd2:	f7 4f       	sbci	r31, 0xF7	; 247
    6cd4:	e0 81       	ld	r30, Z
    6cd6:	f0 e0       	ldi	r31, 0x00	; 0
    6cd8:	a9 01       	movw	r20, r18
    6cda:	4b 5f       	subi	r20, 0xFB	; 251
    6cdc:	5f 4f       	sbci	r21, 0xFF	; 255
    6cde:	e4 17       	cp	r30, r20
    6ce0:	f5 07       	cpc	r31, r21
    6ce2:	09 f0       	breq	.+2      	; 0x6ce6 <MB_M_Timer_ISR+0x16e>
    6ce4:	74 c1       	rjmp	.+744    	; 0x6fce <MB_M_Timer_ISR+0x456>
    6ce6:	e6 2f       	mov	r30, r22
    6ce8:	e6 95       	lsr	r30
    6cea:	e6 95       	lsr	r30
    6cec:	e6 95       	lsr	r30
    6cee:	f0 e0       	ldi	r31, 0x00	; 0
    6cf0:	41 e0       	ldi	r20, 0x01	; 1
    6cf2:	50 e0       	ldi	r21, 0x00	; 0
    6cf4:	76 2f       	mov	r23, r22
    6cf6:	77 70       	andi	r23, 0x07	; 7
    6cf8:	11 f4       	brne	.+4      	; 0x6cfe <MB_M_Timer_ISR+0x186>
    6cfa:	40 e0       	ldi	r20, 0x00	; 0
    6cfc:	50 e0       	ldi	r21, 0x00	; 0
    6cfe:	4e 0f       	add	r20, r30
    6d00:	5f 1f       	adc	r21, r31
    6d02:	42 17       	cp	r20, r18
    6d04:	53 07       	cpc	r21, r19
    6d06:	09 f0       	breq	.+2      	; 0x6d0a <MB_M_Timer_ISR+0x192>
    6d08:	62 c1       	rjmp	.+708    	; 0x6fce <MB_M_Timer_ISR+0x456>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d0a:	20 91 62 02 	lds	r18, 0x0262
		Discr = MB_SingleQuery[MB_N].Buf;
    6d0e:	fe 01       	movw	r30, r28
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d10:	22 23       	and	r18, r18
    6d12:	59 f0       	breq	.+22     	; 0x6d2a <MB_M_Timer_ISR+0x1b2>
		Discr = MB_SingleQuery[MB_N].Buf;
    6d14:	33 e0       	ldi	r19, 0x03	; 3
    6d16:	ee 0f       	add	r30, r30
    6d18:	ff 1f       	adc	r31, r31
    6d1a:	3a 95       	dec	r19
    6d1c:	e1 f7       	brne	.-8      	; 0x6d16 <MB_M_Timer_ISR+0x19e>
    6d1e:	ed 59       	subi	r30, 0x9D	; 157
    6d20:	fd 4f       	sbci	r31, 0xFD	; 253
    6d22:	46 81       	ldd	r20, Z+6	; 0x06
    6d24:	57 81       	ldd	r21, Z+7	; 0x07
		Pin = 0;
    6d26:	c1 2c       	mov	r12, r1
    6d28:	14 c0       	rjmp	.+40     	; 0x6d52 <MB_M_Timer_ISR+0x1da>
    6d2a:	24 e0       	ldi	r18, 0x04	; 4
    6d2c:	ee 0f       	add	r30, r30
    6d2e:	ff 1f       	adc	r31, r31
    6d30:	2a 95       	dec	r18
    6d32:	e1 f7       	brne	.-8      	; 0x6d2c <MB_M_Timer_ISR+0x1b4>
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6d34:	21 e0       	ldi	r18, 0x01	; 1
    6d36:	c2 12       	cpse	r12, r18
    6d38:	03 c0       	rjmp	.+6      	; 0x6d40 <MB_M_Timer_ISR+0x1c8>
    6d3a:	e2 54       	subi	r30, 0x42	; 66
    6d3c:	f0 4b       	sbci	r31, 0xB0	; 176
    6d3e:	02 c0       	rjmp	.+4      	; 0x6d44 <MB_M_Timer_ISR+0x1cc>
    6d40:	ee 53       	subi	r30, 0x3E	; 62
    6d42:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6d44:	45 91       	lpm	r20, Z+
    6d46:	54 91       	lpm	r21, Z
		Pin = prw(&Query->AllocAddr);
    6d48:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6d4a:	fc 01       	movw	r30, r24
    6d4c:	85 91       	lpm	r24, Z+
    6d4e:	94 91       	lpm	r25, Z
    6d50:	c8 2e       	mov	r12, r24
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d52:	20 e0       	ldi	r18, 0x00	; 0
    6d54:	30 e0       	ldi	r19, 0x00	; 0
    6d56:	86 2e       	mov	r8, r22
    6d58:	91 2c       	mov	r9, r1
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d5a:	aa 24       	eor	r10, r10
    6d5c:	a3 94       	inc	r10
    6d5e:	b1 2c       	mov	r11, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d60:	a8 5b       	subi	r26, 0xB8	; 184
    6d62:	b2 4f       	sbci	r27, 0xF2	; 242
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d64:	28 15       	cp	r18, r8
    6d66:	39 05       	cpc	r19, r9
    6d68:	08 f0       	brcs	.+2      	; 0x6d6c <MB_M_Timer_ISR+0x1f4>
    6d6a:	42 c1       	rjmp	.+644    	; 0x6ff0 <MB_M_Timer_ISR+0x478>
    6d6c:	ec 2d       	mov	r30, r12
    6d6e:	e2 0f       	add	r30, r18
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d70:	7e 2e       	mov	r7, r30
    6d72:	76 94       	lsr	r7
    6d74:	76 94       	lsr	r7
    6d76:	76 94       	lsr	r7
    6d78:	e7 70       	andi	r30, 0x07	; 7
    6d7a:	25 01       	movw	r4, r10
    6d7c:	01 c0       	rjmp	.+2      	; 0x6d80 <MB_M_Timer_ISR+0x208>
    6d7e:	44 0c       	add	r4, r4
    6d80:	ea 95       	dec	r30
    6d82:	ea f7       	brpl	.-6      	; 0x6d7e <MB_M_Timer_ISR+0x206>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d84:	c9 01       	movw	r24, r18
    6d86:	63 e0       	ldi	r22, 0x03	; 3
    6d88:	96 95       	lsr	r25
    6d8a:	87 95       	ror	r24
    6d8c:	6a 95       	dec	r22
    6d8e:	e1 f7       	brne	.-8      	; 0x6d88 <MB_M_Timer_ISR+0x210>
    6d90:	8a 0f       	add	r24, r26
    6d92:	9b 1f       	adc	r25, r27
    6d94:	fc 01       	movw	r30, r24
    6d96:	63 81       	ldd	r22, Z+3	; 0x03
    6d98:	70 e0       	ldi	r23, 0x00	; 0
    6d9a:	c9 01       	movw	r24, r18
    6d9c:	87 70       	andi	r24, 0x07	; 7
    6d9e:	99 27       	eor	r25, r25
    6da0:	02 c0       	rjmp	.+4      	; 0x6da6 <MB_M_Timer_ISR+0x22e>
    6da2:	75 95       	asr	r23
    6da4:	67 95       	ror	r22
    6da6:	8a 95       	dec	r24
    6da8:	e2 f7       	brpl	.-8      	; 0x6da2 <MB_M_Timer_ISR+0x22a>
    6daa:	87 2d       	mov	r24, r7
    6dac:	90 e0       	ldi	r25, 0x00	; 0
			Discr[Byte] |=Bit;
    6dae:	84 0f       	add	r24, r20
    6db0:	95 1f       	adc	r25, r21
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6db2:	60 ff       	sbrs	r22, 0
    6db4:	04 c0       	rjmp	.+8      	; 0x6dbe <MB_M_Timer_ISR+0x246>
			Discr[Byte] |=Bit;
    6db6:	fc 01       	movw	r30, r24
    6db8:	60 81       	ld	r22, Z
    6dba:	64 29       	or	r22, r4
    6dbc:	04 c0       	rjmp	.+8      	; 0x6dc6 <MB_M_Timer_ISR+0x24e>
		else
			Discr[Byte] &=~Bit;
    6dbe:	40 94       	com	r4
    6dc0:	fc 01       	movw	r30, r24
    6dc2:	60 81       	ld	r22, Z
    6dc4:	64 21       	and	r22, r4
    6dc6:	60 83       	st	Z, r22
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6dc8:	2f 5f       	subi	r18, 0xFF	; 255
    6dca:	3f 4f       	sbci	r19, 0xFF	; 255
    6dcc:	cb cf       	rjmp	.-106    	; 0x6d64 <MB_M_Timer_ISR+0x1ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6dce:	a8 5b       	subi	r26, 0xB8	; 184
    6dd0:	b2 4f       	sbci	r27, 0xF2	; 242
    6dd2:	12 96       	adiw	r26, 0x02	; 2
    6dd4:	4c 91       	ld	r20, X
    6dd6:	fe 01       	movw	r30, r28
    6dd8:	e7 52       	subi	r30, 0x27	; 39
    6dda:	f7 4f       	sbci	r31, 0xF7	; 247
    6ddc:	e0 81       	ld	r30, Z
    6dde:	f0 e0       	ldi	r31, 0x00	; 0
    6de0:	64 2f       	mov	r22, r20
    6de2:	70 e0       	ldi	r23, 0x00	; 0
    6de4:	9b 01       	movw	r18, r22
    6de6:	2b 5f       	subi	r18, 0xFB	; 251
    6de8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dea:	e2 17       	cp	r30, r18
    6dec:	f3 07       	cpc	r31, r19
    6dee:	09 f0       	breq	.+2      	; 0x6df2 <MB_M_Timer_ISR+0x27a>
    6df0:	ee c0       	rjmp	.+476    	; 0x6fce <MB_M_Timer_ISR+0x456>
    6df2:	20 91 62 02 	lds	r18, 0x0262
    6df6:	22 23       	and	r18, r18
    6df8:	59 f0       	breq	.+22     	; 0x6e10 <MB_M_Timer_ISR+0x298>
    6dfa:	fe 01       	movw	r30, r28
    6dfc:	a3 e0       	ldi	r26, 0x03	; 3
    6dfe:	ee 0f       	add	r30, r30
    6e00:	ff 1f       	adc	r31, r31
    6e02:	aa 95       	dec	r26
    6e04:	e1 f7       	brne	.-8      	; 0x6dfe <MB_M_Timer_ISR+0x286>
    6e06:	ed 59       	subi	r30, 0x9D	; 157
    6e08:	fd 4f       	sbci	r31, 0xFD	; 253
    6e0a:	24 81       	ldd	r18, Z+4	; 0x04
    6e0c:	35 81       	ldd	r19, Z+5	; 0x05
    6e0e:	04 c0       	rjmp	.+8      	; 0x6e18 <MB_M_Timer_ISR+0x2a0>
    6e10:	fc 01       	movw	r30, r24
    6e12:	33 96       	adiw	r30, 0x03	; 3
    6e14:	25 91       	lpm	r18, Z+
    6e16:	34 91       	lpm	r19, Z
    6e18:	22 0f       	add	r18, r18
    6e1a:	33 1f       	adc	r19, r19
    6e1c:	26 17       	cp	r18, r22
    6e1e:	37 07       	cpc	r19, r23
    6e20:	09 f0       	breq	.+2      	; 0x6e24 <MB_M_Timer_ISR+0x2ac>
    6e22:	d5 c0       	rjmp	.+426    	; 0x6fce <MB_M_Timer_ISR+0x456>
		return 1;
	uint16_t *Reg = LastProcSingle ?
    6e24:	20 91 62 02 	lds	r18, 0x0262
		MB_SingleQuery[MB_N].Buf
	:
    6e28:	fe 01       	movw	r30, r28
    6e2a:	22 23       	and	r18, r18
    6e2c:	51 f0       	breq	.+20     	; 0x6e42 <MB_M_Timer_ISR+0x2ca>
    6e2e:	33 e0       	ldi	r19, 0x03	; 3
    6e30:	ee 0f       	add	r30, r30
    6e32:	ff 1f       	adc	r31, r31
    6e34:	3a 95       	dec	r19
    6e36:	e1 f7       	brne	.-8      	; 0x6e30 <MB_M_Timer_ISR+0x2b8>
    6e38:	ed 59       	subi	r30, 0x9D	; 157
    6e3a:	fd 4f       	sbci	r31, 0xFD	; 253
    6e3c:	a6 80       	ldd	r10, Z+6	; 0x06
    6e3e:	b7 80       	ldd	r11, Z+7	; 0x07
    6e40:	17 c0       	rjmp	.+46     	; 0x6e70 <MB_M_Timer_ISR+0x2f8>
    6e42:	24 e0       	ldi	r18, 0x04	; 4
    6e44:	ee 0f       	add	r30, r30
    6e46:	ff 1f       	adc	r31, r31
    6e48:	2a 95       	dec	r18
    6e4a:	e1 f7       	brne	.-8      	; 0x6e44 <MB_M_Timer_ISR+0x2cc>
    6e4c:	23 e0       	ldi	r18, 0x03	; 3
    6e4e:	c2 12       	cpse	r12, r18
    6e50:	03 c0       	rjmp	.+6      	; 0x6e58 <MB_M_Timer_ISR+0x2e0>
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e52:	ea 53       	subi	r30, 0x3A	; 58
    6e54:	f0 4b       	sbci	r31, 0xB0	; 176
    6e56:	02 c0       	rjmp	.+4      	; 0x6e5c <MB_M_Timer_ISR+0x2e4>
    6e58:	e6 53       	subi	r30, 0x36	; 54
    6e5a:	f0 4b       	sbci	r31, 0xB0	; 176
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e5c:	25 91       	lpm	r18, Z+
    6e5e:	34 91       	lpm	r19, Z
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e60:	05 96       	adiw	r24, 0x05	; 5
    6e62:	fc 01       	movw	r30, r24
    6e64:	a5 90       	lpm	r10, Z+
    6e66:	b4 90       	lpm	r11, Z
    6e68:	aa 0c       	add	r10, r10
    6e6a:	bb 1c       	adc	r11, r11
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e6c:	a2 0e       	add	r10, r18
    6e6e:	b3 1e       	adc	r11, r19
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6e70:	46 95       	lsr	r20
    6e72:	cc 24       	eor	r12, r12
    6e74:	ca 94       	dec	r12
    6e76:	c4 0e       	add	r12, r20
    6e78:	74 2e       	mov	r7, r20
    6e7a:	77 0c       	add	r7, r7
    6e7c:	7a 94       	dec	r7
    6e7e:	7a 94       	dec	r7
    6e80:	ff ef       	ldi	r31, 0xFF	; 255
    6e82:	cf 16       	cp	r12, r31
    6e84:	09 f4       	brne	.+2      	; 0x6e88 <MB_M_Timer_ISR+0x310>
    6e86:	b4 c0       	rjmp	.+360    	; 0x6ff0 <MB_M_Timer_ISR+0x478>
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6e88:	8c 2c       	mov	r8, r12
    6e8a:	88 0c       	add	r8, r8
    6e8c:	99 08       	sbc	r9, r9
    6e8e:	8a 0c       	add	r8, r10
    6e90:	9b 1c       	adc	r9, r11
    6e92:	63 e0       	ldi	r22, 0x03	; 3
    6e94:	67 0d       	add	r22, r7
    6e96:	8d 2d       	mov	r24, r13
    6e98:	0e 94 40 32 	call	0x6480	; 0x6480 <MB_FrameReg>
    6e9c:	f4 01       	movw	r30, r8
    6e9e:	91 83       	std	Z+1, r25	; 0x01
    6ea0:	80 83       	st	Z, r24
    6ea2:	ca 94       	dec	r12
    6ea4:	eb cf       	rjmp	.-42     	; 0x6e7c <MB_M_Timer_ISR+0x304>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6ea6:	20 91 62 02 	lds	r18, 0x0262
    6eaa:	22 23       	and	r18, r18
    6eac:	69 f0       	breq	.+26     	; 0x6ec8 <MB_M_Timer_ISR+0x350>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6eae:	fe 01       	movw	r30, r28
    6eb0:	83 e0       	ldi	r24, 0x03	; 3
    6eb2:	ee 0f       	add	r30, r30
    6eb4:	ff 1f       	adc	r31, r31
    6eb6:	8a 95       	dec	r24
    6eb8:	e1 f7       	brne	.-8      	; 0x6eb2 <MB_M_Timer_ISR+0x33a>
    6eba:	ed 59       	subi	r30, 0x9D	; 157
    6ebc:	fd 4f       	sbci	r31, 0xFD	; 253
    6ebe:	22 81       	ldd	r18, Z+2	; 0x02
    6ec0:	33 81       	ldd	r19, Z+3	; 0x03
		Reg = MB_SingleQuery[MB_N].Buf;
    6ec2:	66 81       	ldd	r22, Z+6	; 0x06
    6ec4:	77 81       	ldd	r23, Z+7	; 0x07
    6ec6:	17 c0       	rjmp	.+46     	; 0x6ef6 <MB_M_Timer_ISR+0x37e>
	}
	else {
		StartAddr = prw(&Query->StartAddr);
    6ec8:	fc 01       	movw	r30, r24
    6eca:	31 96       	adiw	r30, 0x01	; 1
    6ecc:	25 91       	lpm	r18, Z+
    6ece:	34 91       	lpm	r19, Z
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6ed0:	fe 01       	movw	r30, r28
    6ed2:	54 e0       	ldi	r21, 0x04	; 4
    6ed4:	ee 0f       	add	r30, r30
    6ed6:	ff 1f       	adc	r31, r31
    6ed8:	5a 95       	dec	r21
    6eda:	e1 f7       	brne	.-8      	; 0x6ed4 <MB_M_Timer_ISR+0x35c>
    6edc:	ea 53       	subi	r30, 0x3A	; 58
    6ede:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ee0:	45 91       	lpm	r20, Z+
    6ee2:	54 91       	lpm	r21, Z
    6ee4:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6ee6:	fc 01       	movw	r30, r24
    6ee8:	85 91       	lpm	r24, Z+
    6eea:	94 91       	lpm	r25, Z
    6eec:	bc 01       	movw	r22, r24
    6eee:	66 0f       	add	r22, r22
    6ef0:	77 1f       	adc	r23, r23
    6ef2:	64 0f       	add	r22, r20
    6ef4:	75 1f       	adc	r23, r21
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6ef6:	ce 01       	movw	r24, r28
    6ef8:	87 52       	subi	r24, 0x27	; 39
    6efa:	97 4f       	sbci	r25, 0xF7	; 247
    6efc:	fc 01       	movw	r30, r24
    6efe:	80 81       	ld	r24, Z
    6f00:	88 30       	cpi	r24, 0x08	; 8
    6f02:	09 f0       	breq	.+2      	; 0x6f06 <MB_M_Timer_ISR+0x38e>
    6f04:	61 c0       	rjmp	.+194    	; 0x6fc8 <MB_M_Timer_ISR+0x450>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6f06:	a8 5b       	subi	r26, 0xB8	; 184
    6f08:	b2 4f       	sbci	r27, 0xF2	; 242
    6f0a:	12 96       	adiw	r26, 0x02	; 2
    6f0c:	8c 91       	ld	r24, X
    6f0e:	12 97       	sbiw	r26, 0x02	; 2
    6f10:	90 e0       	ldi	r25, 0x00	; 0
    6f12:	98 2f       	mov	r25, r24
    6f14:	88 27       	eor	r24, r24
    6f16:	13 96       	adiw	r26, 0x03	; 3
    6f18:	4c 91       	ld	r20, X
    6f1a:	13 97       	sbiw	r26, 0x03	; 3
    6f1c:	84 2b       	or	r24, r20
    6f1e:	82 17       	cp	r24, r18
    6f20:	93 07       	cpc	r25, r19
    6f22:	09 f0       	breq	.+2      	; 0x6f26 <MB_M_Timer_ISR+0x3ae>
    6f24:	51 c0       	rjmp	.+162    	; 0x6fc8 <MB_M_Timer_ISR+0x450>
    6f26:	14 96       	adiw	r26, 0x04	; 4
    6f28:	8c 91       	ld	r24, X
    6f2a:	14 97       	sbiw	r26, 0x04	; 4
    6f2c:	90 e0       	ldi	r25, 0x00	; 0
    6f2e:	98 2f       	mov	r25, r24
    6f30:	88 27       	eor	r24, r24
    6f32:	15 96       	adiw	r26, 0x05	; 5
    6f34:	2c 91       	ld	r18, X
    6f36:	82 2b       	or	r24, r18
    6f38:	41 e0       	ldi	r20, 0x01	; 1
    6f3a:	fb 01       	movw	r30, r22
    6f3c:	20 81       	ld	r18, Z
    6f3e:	31 81       	ldd	r19, Z+1	; 0x01
    6f40:	82 17       	cp	r24, r18
    6f42:	93 07       	cpc	r25, r19
    6f44:	09 f4       	brne	.+2      	; 0x6f48 <MB_M_Timer_ISR+0x3d0>
    6f46:	40 e0       	ldi	r20, 0x00	; 0
    6f48:	84 2f       	mov	r24, r20
    6f4a:	3f c0       	rjmp	.+126    	; 0x6fca <MB_M_Timer_ISR+0x452>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6f4c:	20 91 62 02 	lds	r18, 0x0262
    6f50:	22 23       	and	r18, r18
    6f52:	69 f0       	breq	.+26     	; 0x6f6e <MB_M_Timer_ISR+0x3f6>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6f54:	fe 01       	movw	r30, r28
    6f56:	83 e0       	ldi	r24, 0x03	; 3
    6f58:	ee 0f       	add	r30, r30
    6f5a:	ff 1f       	adc	r31, r31
    6f5c:	8a 95       	dec	r24
    6f5e:	e1 f7       	brne	.-8      	; 0x6f58 <MB_M_Timer_ISR+0x3e0>
    6f60:	ed 59       	subi	r30, 0x9D	; 157
    6f62:	fd 4f       	sbci	r31, 0xFD	; 253
    6f64:	22 81       	ldd	r18, Z+2	; 0x02
    6f66:	33 81       	ldd	r19, Z+3	; 0x03
		Qt				= MB_SingleQuery[MB_N].Qt;
    6f68:	44 81       	ldd	r20, Z+4	; 0x04
    6f6a:	55 81       	ldd	r21, Z+5	; 0x05
    6f6c:	08 c0       	rjmp	.+16     	; 0x6f7e <MB_M_Timer_ISR+0x406>
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
    6f6e:	fc 01       	movw	r30, r24
    6f70:	31 96       	adiw	r30, 0x01	; 1
    6f72:	25 91       	lpm	r18, Z+
    6f74:	34 91       	lpm	r19, Z
		Qt				= prw(&Query->Qt);
    6f76:	03 96       	adiw	r24, 0x03	; 3
    6f78:	fc 01       	movw	r30, r24
    6f7a:	45 91       	lpm	r20, Z+
    6f7c:	54 91       	lpm	r21, Z
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6f7e:	fe 01       	movw	r30, r28
    6f80:	e7 52       	subi	r30, 0x27	; 39
    6f82:	f7 4f       	sbci	r31, 0xF7	; 247
    6f84:	80 81       	ld	r24, Z
    6f86:	88 30       	cpi	r24, 0x08	; 8
    6f88:	f9 f4       	brne	.+62     	; 0x6fc8 <MB_M_Timer_ISR+0x450>
    6f8a:	a8 5b       	subi	r26, 0xB8	; 184
    6f8c:	b2 4f       	sbci	r27, 0xF2	; 242
    6f8e:	12 96       	adiw	r26, 0x02	; 2
    6f90:	8c 91       	ld	r24, X
    6f92:	12 97       	sbiw	r26, 0x02	; 2
    6f94:	90 e0       	ldi	r25, 0x00	; 0
    6f96:	98 2f       	mov	r25, r24
    6f98:	88 27       	eor	r24, r24
    6f9a:	13 96       	adiw	r26, 0x03	; 3
    6f9c:	6c 91       	ld	r22, X
    6f9e:	13 97       	sbiw	r26, 0x03	; 3
    6fa0:	86 2b       	or	r24, r22
    6fa2:	82 17       	cp	r24, r18
    6fa4:	93 07       	cpc	r25, r19
    6fa6:	81 f4       	brne	.+32     	; 0x6fc8 <MB_M_Timer_ISR+0x450>
    6fa8:	14 96       	adiw	r26, 0x04	; 4
    6faa:	8c 91       	ld	r24, X
    6fac:	14 97       	sbiw	r26, 0x04	; 4
    6fae:	90 e0       	ldi	r25, 0x00	; 0
    6fb0:	98 2f       	mov	r25, r24
    6fb2:	88 27       	eor	r24, r24
    6fb4:	15 96       	adiw	r26, 0x05	; 5
    6fb6:	2c 91       	ld	r18, X
    6fb8:	82 2b       	or	r24, r18
    6fba:	21 e0       	ldi	r18, 0x01	; 1
    6fbc:	84 17       	cp	r24, r20
    6fbe:	95 07       	cpc	r25, r21
    6fc0:	09 f4       	brne	.+2      	; 0x6fc4 <MB_M_Timer_ISR+0x44c>
    6fc2:	20 e0       	ldi	r18, 0x00	; 0
    6fc4:	82 2f       	mov	r24, r18
    6fc6:	01 c0       	rjmp	.+2      	; 0x6fca <MB_M_Timer_ISR+0x452>
    6fc8:	81 e0       	ldi	r24, 0x01	; 1
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    6fca:	88 23       	and	r24, r24
    6fcc:	89 f0       	breq	.+34     	; 0x6ff0 <MB_M_Timer_ISR+0x478>
				MB_CPT[MB_N][2]++;
    6fce:	fe 01       	movw	r30, r28
    6fd0:	54 e0       	ldi	r21, 0x04	; 4
    6fd2:	ee 0f       	add	r30, r30
    6fd4:	ff 1f       	adc	r31, r31
    6fd6:	5a 95       	dec	r21
    6fd8:	e1 f7       	brne	.-8      	; 0x6fd2 <MB_M_Timer_ISR+0x45a>
    6fda:	e7 5d       	subi	r30, 0xD7	; 215
    6fdc:	f4 4f       	sbci	r31, 0xF4	; 244
    6fde:	84 81       	ldd	r24, Z+4	; 0x04
    6fe0:	95 81       	ldd	r25, Z+5	; 0x05
    6fe2:	01 96       	adiw	r24, 0x01	; 1
    6fe4:	95 83       	std	Z+5, r25	; 0x05
    6fe6:	84 83       	std	Z+4, r24	; 0x04
				Over = FailSlave(MB_N);
    6fe8:	8d 2d       	mov	r24, r13
    6fea:	0e 94 a1 2b 	call	0x5742	; 0x5742 <FailSlave>
    6fee:	45 c0       	rjmp	.+138    	; 0x707a <MB_M_Timer_ISR+0x502>
			}
			else if (LastProcSingle)
    6ff0:	80 91 62 02 	lds	r24, 0x0262
    6ff4:	88 23       	and	r24, r24
    6ff6:	19 f0       	breq	.+6      	; 0x6ffe <MB_M_Timer_ISR+0x486>
				MB_SingleState[MB_N] = MB_SingleIdle;
    6ff8:	f7 01       	movw	r30, r14
    6ffa:	10 82       	st	Z, r1
    6ffc:	47 c0       	rjmp	.+142    	; 0x708c <MB_M_Timer_ISR+0x514>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6ffe:	7e 01       	movw	r14, r28
    7000:	ee 0c       	add	r14, r14
    7002:	ff 1c       	adc	r15, r15
    7004:	ee 0c       	add	r14, r14
    7006:	ff 1c       	adc	r15, r15
    7008:	97 01       	movw	r18, r14
    700a:	2c 5e       	subi	r18, 0xEC	; 236
    700c:	34 4f       	sbci	r19, 0xF4	; 244
    700e:	79 01       	movw	r14, r18
    7010:	81 e0       	ldi	r24, 0x01	; 1
    7012:	90 e0       	ldi	r25, 0x00	; 0
    7014:	a0 e0       	ldi	r26, 0x00	; 0
    7016:	b0 e0       	ldi	r27, 0x00	; 0
    7018:	9e 01       	movw	r18, r28
    701a:	2a 5f       	subi	r18, 0xFA	; 250
    701c:	39 4f       	sbci	r19, 0xF9	; 249
    701e:	f9 01       	movw	r30, r18
    7020:	00 80       	ld	r0, Z
    7022:	04 c0       	rjmp	.+8      	; 0x702c <MB_M_Timer_ISR+0x4b4>
    7024:	88 0f       	add	r24, r24
    7026:	99 1f       	adc	r25, r25
    7028:	aa 1f       	adc	r26, r26
    702a:	bb 1f       	adc	r27, r27
    702c:	0a 94       	dec	r0
    702e:	d2 f7       	brpl	.-12     	; 0x7024 <MB_M_Timer_ISR+0x4ac>
    7030:	80 95       	com	r24
    7032:	90 95       	com	r25
    7034:	a0 95       	com	r26
    7036:	b0 95       	com	r27
    7038:	f7 01       	movw	r30, r14
    703a:	40 81       	ld	r20, Z
    703c:	51 81       	ldd	r21, Z+1	; 0x01
    703e:	62 81       	ldd	r22, Z+2	; 0x02
    7040:	73 81       	ldd	r23, Z+3	; 0x03
    7042:	84 23       	and	r24, r20
    7044:	95 23       	and	r25, r21
    7046:	a6 23       	and	r26, r22
    7048:	b7 23       	and	r27, r23
    704a:	80 83       	st	Z, r24
    704c:	91 83       	std	Z+1, r25	; 0x01
    704e:	a2 83       	std	Z+2, r26	; 0x02
    7050:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    7052:	fe 01       	movw	r30, r28
    7054:	e3 5f       	subi	r30, 0xF3	; 243
    7056:	f9 4f       	sbci	r31, 0xF9	; 249
    7058:	80 81       	ld	r24, Z
    705a:	8f 5f       	subi	r24, 0xFF	; 255
    705c:	80 83       	st	Z, r24
    705e:	f8 01       	movw	r30, r16
    7060:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7062:	04 91       	lpm	r16, Z
    7064:	80 13       	cpse	r24, r16
    7066:	04 c0       	rjmp	.+8      	; 0x7070 <MB_M_Timer_ISR+0x4f8>
					Over = NextSlave(MB_N);
    7068:	8d 2d       	mov	r24, r13
    706a:	0e 94 0f 2b 	call	0x561e	; 0x561e <NextSlave>
    706e:	01 c0       	rjmp	.+2      	; 0x7072 <MB_M_Timer_ISR+0x4fa>

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
    7070:	80 e0       	ldi	r24, 0x00	; 0
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    7072:	fe 01       	movw	r30, r28
    7074:	ef 59       	subi	r30, 0x9F	; 159
    7076:	fd 4f       	sbci	r31, 0xFD	; 253
    7078:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    707a:	88 23       	and	r24, r24
    707c:	39 f0       	breq	.+14     	; 0x708c <MB_M_Timer_ISR+0x514>
    707e:	cc 0f       	add	r28, r28
    7080:	dd 1f       	adc	r29, r29
    7082:	c0 5e       	subi	r28, 0xE0	; 224
    7084:	d9 4f       	sbci	r29, 0xF9	; 249
    7086:	68 81       	ld	r22, Y
    7088:	79 81       	ldd	r23, Y+1	; 0x01
    708a:	02 c0       	rjmp	.+4      	; 0x7090 <MB_M_Timer_ISR+0x518>
    708c:	65 e0       	ldi	r22, 0x05	; 5
    708e:	70 e0       	ldi	r23, 0x00	; 0
    7090:	80 91 5c 02 	lds	r24, 0x025C
    7094:	8d 0d       	add	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    7096:	df 91       	pop	r29
    7098:	cf 91       	pop	r28
    709a:	1f 91       	pop	r17
    709c:	0f 91       	pop	r16
    709e:	ff 90       	pop	r15
    70a0:	ef 90       	pop	r14
    70a2:	df 90       	pop	r13
    70a4:	cf 90       	pop	r12
    70a6:	bf 90       	pop	r11
    70a8:	af 90       	pop	r10
    70aa:	9f 90       	pop	r9
    70ac:	8f 90       	pop	r8
    70ae:	7f 90       	pop	r7
    70b0:	5f 90       	pop	r5
    70b2:	4f 90       	pop	r4
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    70b4:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    70b8:	df 91       	pop	r29
    70ba:	cf 91       	pop	r28
    70bc:	1f 91       	pop	r17
    70be:	0f 91       	pop	r16
    70c0:	ff 90       	pop	r15
    70c2:	ef 90       	pop	r14
    70c4:	df 90       	pop	r13
    70c6:	cf 90       	pop	r12
    70c8:	bf 90       	pop	r11
    70ca:	af 90       	pop	r10
    70cc:	9f 90       	pop	r9
    70ce:	8f 90       	pop	r8
    70d0:	7f 90       	pop	r7
    70d2:	5f 90       	pop	r5
    70d4:	4f 90       	pop	r4
    70d6:	08 95       	ret

000070d8 <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    70d8:	e8 2f       	mov	r30, r24
    70da:	f0 e0       	ldi	r31, 0x00	; 0
    70dc:	ee 5e       	subi	r30, 0xEE	; 238
    70de:	f4 4f       	sbci	r31, 0xF4	; 244
    70e0:	60 81       	ld	r22, Z
    70e2:	70 e0       	ldi	r23, 0x00	; 0
    70e4:	90 91 5c 02 	lds	r25, 0x025C
    70e8:	89 0f       	add	r24, r25
    70ea:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>

000070ee <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    70ee:	bf 92       	push	r11
    70f0:	cf 92       	push	r12
    70f2:	df 92       	push	r13
    70f4:	ef 92       	push	r14
    70f6:	ff 92       	push	r15
    70f8:	0f 93       	push	r16
    70fa:	1f 93       	push	r17
    70fc:	cf 93       	push	r28
    70fe:	df 93       	push	r29
    7100:	1f 92       	push	r1
    7102:	cd b7       	in	r28, 0x3d	; 61
    7104:	de b7       	in	r29, 0x3e	; 62
    7106:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7108:	80 e0       	ldi	r24, 0x00	; 0
    710a:	94 e1       	ldi	r25, 0x14	; 20
    710c:	c8 2e       	mov	r12, r24
    710e:	d1 2c       	mov	r13, r1
    7110:	9c 9d       	mul	r25, r12
    7112:	f0 01       	movw	r30, r0
    7114:	9d 9d       	mul	r25, r13
    7116:	f0 0d       	add	r31, r0
    7118:	11 24       	eor	r1, r1
    711a:	e1 57       	subi	r30, 0x71	; 113
    711c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    711e:	25 91       	lpm	r18, Z+
    7120:	34 91       	lpm	r19, Z
    7122:	e8 2e       	mov	r14, r24
    7124:	f1 2c       	mov	r15, r1
    7126:	a2 17       	cp	r26, r18
    7128:	b3 07       	cpc	r27, r19
    712a:	11 f0       	breq	.+4      	; 0x7130 <Modbus_TX+0x42>
    712c:	8f 5f       	subi	r24, 0xFF	; 255
    712e:	ee cf       	rjmp	.-36     	; 0x710c <Modbus_TX+0x1e>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    7130:	86 01       	movw	r16, r12
    7132:	0c 5b       	subi	r16, 0xBC	; 188
    7134:	1d 4f       	sbci	r17, 0xFD	; 253
    7136:	f8 01       	movw	r30, r16
    7138:	90 81       	ld	r25, Z
    713a:	69 2f       	mov	r22, r25
    713c:	70 e0       	ldi	r23, 0x00	; 0
    713e:	a6 01       	movw	r20, r12
    7140:	47 52       	subi	r20, 0x27	; 39
    7142:	57 4f       	sbci	r21, 0xF7	; 247
    7144:	fa 01       	movw	r30, r20
    7146:	20 81       	ld	r18, Z
    7148:	30 e0       	ldi	r19, 0x00	; 0
    714a:	22 50       	subi	r18, 0x02	; 2
    714c:	31 09       	sbc	r19, r1
    714e:	62 17       	cp	r22, r18
    7150:	73 07       	cpc	r23, r19
    7152:	39 f5       	brne	.+78     	; 0x71a2 <Modbus_TX+0xb4>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    7154:	64 e1       	ldi	r22, 0x14	; 20
    7156:	6c 9d       	mul	r22, r12
    7158:	90 01       	movw	r18, r0
    715a:	6d 9d       	mul	r22, r13
    715c:	30 0d       	add	r19, r0
    715e:	11 24       	eor	r1, r1
    7160:	2d 56       	subi	r18, 0x6D	; 109
    7162:	30 4b       	sbci	r19, 0xB0	; 176
    7164:	f9 01       	movw	r30, r18
    7166:	65 91       	lpm	r22, Z+
    7168:	74 91       	lpm	r23, Z
    716a:	fb 01       	movw	r30, r22
    716c:	b0 80       	ld	r11, Z
    716e:	fb 2d       	mov	r31, r11
    7170:	ff 7d       	andi	r31, 0xDF	; 223
    7172:	bf 2e       	mov	r11, r31
    7174:	fb 01       	movw	r30, r22
    7176:	b0 82       	st	Z, r11
    7178:	f9 01       	movw	r30, r18
    717a:	25 91       	lpm	r18, Z+
    717c:	34 91       	lpm	r19, Z
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    717e:	f9 01       	movw	r30, r18
    7180:	60 81       	ld	r22, Z
    7182:	60 64       	ori	r22, 0x40	; 64
    7184:	60 83       	st	Z, r22
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    7186:	24 e1       	ldi	r18, 0x14	; 20
    7188:	2c 9d       	mul	r18, r12
    718a:	f0 01       	movw	r30, r0
    718c:	2d 9d       	mul	r18, r13
    718e:	f0 0d       	add	r31, r0
    7190:	11 24       	eor	r1, r1
    7192:	ef 56       	subi	r30, 0x6F	; 111
    7194:	f0 4b       	sbci	r31, 0xB0	; 176
    7196:	25 91       	lpm	r18, Z+
    7198:	34 91       	lpm	r19, Z
    719a:	f9 01       	movw	r30, r18
    719c:	60 81       	ld	r22, Z
    719e:	60 64       	ori	r22, 0x40	; 64
    71a0:	60 83       	st	Z, r22
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    71a2:	9f 5f       	subi	r25, 0xFF	; 255
    71a4:	f8 01       	movw	r30, r16
    71a6:	90 83       	st	Z, r25
    71a8:	fa 01       	movw	r30, r20
    71aa:	20 81       	ld	r18, Z
    71ac:	92 17       	cp	r25, r18
    71ae:	48 f4       	brcc	.+18     	; 0x71c2 <Modbus_TX+0xd4>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    71b0:	fc 2d       	mov	r31, r12
    71b2:	ee 27       	eor	r30, r30
    71b4:	e9 0f       	add	r30, r25
    71b6:	f1 1d       	adc	r31, r1
    71b8:	e8 5b       	subi	r30, 0xB8	; 184
    71ba:	f2 4f       	sbci	r31, 0xF2	; 242
    71bc:	80 81       	ld	r24, Z
    71be:	8c 93       	st	X, r24
		return;
    71c0:	43 c0       	rjmp	.+134    	; 0x7248 <Modbus_TX+0x15a>
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    71c2:	94 e1       	ldi	r25, 0x14	; 20
    71c4:	9c 9d       	mul	r25, r12
    71c6:	f0 01       	movw	r30, r0
    71c8:	9d 9d       	mul	r25, r13
    71ca:	f0 0d       	add	r31, r0
    71cc:	11 24       	eor	r1, r1
    71ce:	ed 56       	subi	r30, 0x6D	; 109
    71d0:	f0 4b       	sbci	r31, 0xB0	; 176
    71d2:	a5 91       	lpm	r26, Z+
    71d4:	b4 91       	lpm	r27, Z
    71d6:	9c 91       	ld	r25, X
    71d8:	9f 79       	andi	r25, 0x9F	; 159
    71da:	9c 93       	st	X, r25
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    71dc:	94 e1       	ldi	r25, 0x14	; 20
    71de:	9c 9d       	mul	r25, r12
    71e0:	90 01       	movw	r18, r0
    71e2:	9d 9d       	mul	r25, r13
    71e4:	30 0d       	add	r19, r0
    71e6:	11 24       	eor	r1, r1
    71e8:	25 56       	subi	r18, 0x65	; 101
    71ea:	30 4b       	sbci	r19, 0xB0	; 176
    71ec:	f9 01       	movw	r30, r18
    71ee:	45 91       	lpm	r20, Z+
    71f0:	54 91       	lpm	r21, Z
    71f2:	89 83       	std	Y+1, r24	; 0x01
    71f4:	fa 01       	movw	r30, r20
    71f6:	09 95       	icall
	Count[MB_N] = 0;
    71f8:	d8 01       	movw	r26, r16
    71fa:	1c 92       	st	X, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    71fc:	f6 01       	movw	r30, r12
    71fe:	ef 51       	subi	r30, 0x1F	; 31
    7200:	fc 4f       	sbci	r31, 0xFC	; 252
    7202:	91 e0       	ldi	r25, 0x01	; 1
    7204:	90 83       	st	Z, r25
	switch (prb(MB_Role+MB_N)) {
    7206:	f7 01       	movw	r30, r14
    7208:	e2 53       	subi	r30, 0x32	; 50
    720a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    720c:	e4 91       	lpm	r30, Z
    720e:	89 81       	ldd	r24, Y+1	; 0x01
    7210:	ee 23       	and	r30, r30
    7212:	71 f0       	breq	.+28     	; 0x7230 <Modbus_TX+0x142>
    7214:	e1 30       	cpi	r30, 0x01	; 1
    7216:	c1 f4       	brne	.+48     	; 0x7248 <Modbus_TX+0x15a>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7218:	0f 90       	pop	r0
    721a:	df 91       	pop	r29
    721c:	cf 91       	pop	r28
    721e:	1f 91       	pop	r17
    7220:	0f 91       	pop	r16
    7222:	ff 90       	pop	r15
    7224:	ef 90       	pop	r14
    7226:	df 90       	pop	r13
    7228:	cf 90       	pop	r12
    722a:	bf 90       	pop	r11
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    722c:	0c 94 6c 38 	jmp	0x70d8	; 0x70d8 <MB_M_Tx>
		break;
	}
}
    7230:	0f 90       	pop	r0
    7232:	df 91       	pop	r29
    7234:	cf 91       	pop	r28
    7236:	1f 91       	pop	r17
    7238:	0f 91       	pop	r16
    723a:	ff 90       	pop	r15
    723c:	ef 90       	pop	r14
    723e:	df 90       	pop	r13
    7240:	cf 90       	pop	r12
    7242:	bf 90       	pop	r11
	Count[MB_N] = 0;
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
    7244:	0c 94 3b 35 	jmp	0x6a76	; 0x6a76 <MB_S_Tx>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7248:	0f 90       	pop	r0
    724a:	df 91       	pop	r29
    724c:	cf 91       	pop	r28
    724e:	1f 91       	pop	r17
    7250:	0f 91       	pop	r16
    7252:	ff 90       	pop	r15
    7254:	ef 90       	pop	r14
    7256:	df 90       	pop	r13
    7258:	cf 90       	pop	r12
    725a:	bf 90       	pop	r11
    725c:	08 95       	ret

0000725e <MB_M_Cycle>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    725e:	1f 93       	push	r17
    7260:	cf 93       	push	r28
    7262:	df 93       	push	r29
    7264:	18 2f       	mov	r17, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    7266:	c0 91 5c 02 	lds	r28, 0x025C
    726a:	c8 0f       	add	r28, r24
    726c:	81 e0       	ldi	r24, 0x01	; 1
    726e:	8c 0f       	add	r24, r28
    7270:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    7274:	88 23       	and	r24, r24
    7276:	19 f0       	breq	.+6      	; 0x727e <MB_M_Cycle+0x20>
		SlavesOn(MB_N);
    7278:	81 2f       	mov	r24, r17
    727a:	0e 94 f4 2a 	call	0x55e8	; 0x55e8 <SlavesOn>

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    727e:	8c 2f       	mov	r24, r28
    7280:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    7284:	88 23       	and	r24, r24
    7286:	09 f4       	brne	.+2      	; 0x728a <MB_M_Cycle+0x2c>
    7288:	4f c0       	rjmp	.+158    	; 0x7328 <MB_M_Cycle+0xca>
		cli();
    728a:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    728c:	c1 2f       	mov	r28, r17
    728e:	d0 e0       	ldi	r29, 0x00	; 0
    7290:	fe 01       	movw	r30, r28
    7292:	ef 51       	subi	r30, 0x1F	; 31
    7294:	fc 4f       	sbci	r31, 0xFC	; 252
    7296:	80 81       	ld	r24, Z
    7298:	81 30       	cpi	r24, 0x01	; 1
    729a:	11 f4       	brne	.+4      	; 0x72a0 <MB_M_Cycle+0x42>
    729c:	85 e0       	ldi	r24, 0x05	; 5
    729e:	80 83       	st	Z, r24
		sei();
    72a0:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    72a2:	80 81       	ld	r24, Z
    72a4:	84 30       	cpi	r24, 0x04	; 4
    72a6:	a1 f0       	breq	.+40     	; 0x72d0 <MB_M_Cycle+0x72>
    72a8:	85 30       	cpi	r24, 0x05	; 5
    72aa:	09 f0       	breq	.+2      	; 0x72ae <MB_M_Cycle+0x50>
    72ac:	3d c0       	rjmp	.+122    	; 0x7328 <MB_M_Cycle+0xca>
	case MB_NoReply:
		FailSlave(MB_N);
    72ae:	81 2f       	mov	r24, r17
    72b0:	0e 94 a1 2b 	call	0x5742	; 0x5742 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    72b4:	fe 01       	movw	r30, r28
    72b6:	ee 5d       	subi	r30, 0xDE	; 222
    72b8:	f9 4f       	sbci	r31, 0xF9	; 249
    72ba:	80 81       	ld	r24, Z
    72bc:	88 23       	and	r24, r24
    72be:	09 f1       	breq	.+66     	; 0x7302 <MB_M_Cycle+0xa4>
    72c0:	81 30       	cpi	r24, 0x01	; 1
    72c2:	31 f5       	brne	.+76     	; 0x7310 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    72c4:	cf 59       	subi	r28, 0x9F	; 159
    72c6:	dd 4f       	sbci	r29, 0xFD	; 253
    72c8:	88 81       	ld	r24, Y
    72ca:	81 11       	cpse	r24, r1
    72cc:	21 c0       	rjmp	.+66     	; 0x7310 <MB_M_Cycle+0xb2>
    72ce:	1d c0       	rjmp	.+58     	; 0x730a <MB_M_Cycle+0xac>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    72d0:	f8 94       	cli
		USART_Func(MB_N, LED);
    72d2:	84 e1       	ldi	r24, 0x14	; 20
    72d4:	8c 9f       	mul	r24, r28
    72d6:	f0 01       	movw	r30, r0
    72d8:	8d 9f       	mul	r24, r29
    72da:	f0 0d       	add	r31, r0
    72dc:	11 24       	eor	r1, r1
    72de:	e3 56       	subi	r30, 0x63	; 99
    72e0:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    72e2:	25 91       	lpm	r18, Z+
    72e4:	34 91       	lpm	r19, Z
    72e6:	f9 01       	movw	r30, r18
    72e8:	09 95       	icall
		sei();
    72ea:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    72ec:	ce 5d       	subi	r28, 0xDE	; 222
    72ee:	d9 4f       	sbci	r29, 0xF9	; 249
    72f0:	88 81       	ld	r24, Y
    72f2:	88 23       	and	r24, r24
    72f4:	31 f0       	breq	.+12     	; 0x7302 <MB_M_Cycle+0xa4>
    72f6:	81 30       	cpi	r24, 0x01	; 1
    72f8:	59 f4       	brne	.+22     	; 0x7310 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    72fa:	80 91 62 02 	lds	r24, 0x0262
    72fe:	88 23       	and	r24, r24
    7300:	21 f0       	breq	.+8      	; 0x730a <MB_M_Cycle+0xac>
				FormQuery(MB_N);
    7302:	81 2f       	mov	r24, r17
    7304:	0e 94 cc 31 	call	0x6398	; 0x6398 <FormQuery>
    7308:	03 c0       	rjmp	.+6      	; 0x7310 <MB_M_Cycle+0xb2>
			else
				FormSingle(MB_N);
    730a:	81 2f       	mov	r24, r17
    730c:	0e 94 16 32 	call	0x642c	; 0x642c <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    7310:	80 91 5c 02 	lds	r24, 0x025C
    7314:	6f ef       	ldi	r22, 0xFF	; 255
    7316:	7f ef       	ldi	r23, 0xFF	; 255
    7318:	81 0f       	add	r24, r17
    731a:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
		cli();
    731e:	f8 94       	cli
		MB_Transm(MB_N);
    7320:	81 2f       	mov	r24, r17
    7322:	0e 94 bf 2f 	call	0x5f7e	; 0x5f7e <MB_Transm>
		sei();
    7326:	78 94       	sei
		break;
	}
}
    7328:	df 91       	pop	r29
    732a:	cf 91       	pop	r28
    732c:	1f 91       	pop	r17
    732e:	08 95       	ret

00007330 <MB_Cycle>:
{
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    7330:	80 91 13 0b 	lds	r24, 0x0B13
    7334:	80 ff       	sbrs	r24, 0
    7336:	15 c0       	rjmp	.+42     	; 0x7362 <MB_Cycle+0x32>
			cli();
    7338:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    733a:	80 91 13 0b 	lds	r24, 0x0B13
    733e:	8e 7f       	andi	r24, 0xFE	; 254
    7340:	80 93 13 0b 	sts	0x0B13, r24
			sei();
    7344:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7346:	ee ec       	ldi	r30, 0xCE	; 206
    7348:	ff e4       	ldi	r31, 0x4F	; 79
    734a:	e4 91       	lpm	r30, Z
			switch (prb(MB_Role+MB_N)) {
    734c:	ee 23       	and	r30, r30
    734e:	31 f0       	breq	.+12     	; 0x735c <MB_Cycle+0x2c>
    7350:	e1 30       	cpi	r30, 0x01	; 1
    7352:	39 f4       	brne	.+14     	; 0x7362 <MB_Cycle+0x32>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    7354:	80 e0       	ldi	r24, 0x00	; 0
    7356:	0e 94 bc 35 	call	0x6b78	; 0x6b78 <MB_M_Timer_ISR>
				break;
    735a:	03 c0       	rjmp	.+6      	; 0x7362 <MB_Cycle+0x32>
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    735c:	80 e0       	ldi	r24, 0x00	; 0
    735e:	0e 94 54 32 	call	0x64a8	; 0x64a8 <MB_S_Timer_ISR>
    7362:	ee ec       	ldi	r30, 0xCE	; 206
    7364:	ff e4       	ldi	r31, 0x4F	; 79
    7366:	e4 91       	lpm	r30, Z
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7368:	e1 30       	cpi	r30, 0x01	; 1
    736a:	19 f4       	brne	.+6      	; 0x7372 <MB_Cycle+0x42>
			MB_M_Cycle(MB_N);
    736c:	80 e0       	ldi	r24, 0x00	; 0
    736e:	0c 94 2f 39 	jmp	0x725e	; 0x725e <MB_M_Cycle>
    7372:	08 95       	ret

00007374 <IP_compare_Const>:
	IP->IP1 = IP1;
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    7374:	0f 93       	push	r16
    7376:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7378:	80 81       	ld	r24, Z
    737a:	86 13       	cpse	r24, r22
    737c:	09 c0       	rjmp	.+18     	; 0x7390 <IP_compare_Const+0x1c>
    737e:	81 81       	ldd	r24, Z+1	; 0x01
    7380:	84 13       	cpse	r24, r20
    7382:	06 c0       	rjmp	.+12     	; 0x7390 <IP_compare_Const+0x1c>
    7384:	82 81       	ldd	r24, Z+2	; 0x02
    7386:	82 13       	cpse	r24, r18
    7388:	03 c0       	rjmp	.+6      	; 0x7390 <IP_compare_Const+0x1c>
    738a:	81 e0       	ldi	r24, 0x01	; 1
    738c:	93 81       	ldd	r25, Z+3	; 0x03
    738e:	90 13       	cpse	r25, r16
	else return 0;
    7390:	80 e0       	ldi	r24, 0x00	; 0
}
    7392:	0f 91       	pop	r16
    7394:	08 95       	ret

00007396 <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    7396:	cf 92       	push	r12
    7398:	df 92       	push	r13
    739a:	ff 92       	push	r15
    739c:	0f 93       	push	r16
    739e:	1f 93       	push	r17
    73a0:	cf 93       	push	r28
    73a2:	df 93       	push	r29
    73a4:	1f 92       	push	r1
    73a6:	cd b7       	in	r28, 0x3d	; 61
    73a8:	de b7       	in	r29, 0x3e	; 62
    73aa:	6c 01       	movw	r12, r24
    73ac:	f4 2e       	mov	r15, r20
    73ae:	12 2f       	mov	r17, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    73b0:	69 83       	std	Y+1, r22	; 0x01
    73b2:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    73b6:	69 81       	ldd	r22, Y+1	; 0x01
    73b8:	86 13       	cpse	r24, r22
    73ba:	12 c0       	rjmp	.+36     	; 0x73e0 <IP_E_compare_Const+0x4a>
    73bc:	c6 01       	movw	r24, r12
    73be:	01 96       	adiw	r24, 0x01	; 1
    73c0:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    73c4:	8f 11       	cpse	r24, r15
    73c6:	0c c0       	rjmp	.+24     	; 0x73e0 <IP_E_compare_Const+0x4a>
    73c8:	c6 01       	movw	r24, r12
    73ca:	02 96       	adiw	r24, 0x02	; 2
    73cc:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    73d0:	81 13       	cpse	r24, r17
    73d2:	06 c0       	rjmp	.+12     	; 0x73e0 <IP_E_compare_Const+0x4a>
    73d4:	c6 01       	movw	r24, r12
    73d6:	03 96       	adiw	r24, 0x03	; 3
    73d8:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    73dc:	91 e0       	ldi	r25, 0x01	; 1
    73de:	80 13       	cpse	r24, r16
	else return 0;
    73e0:	90 e0       	ldi	r25, 0x00	; 0
}
    73e2:	89 2f       	mov	r24, r25
    73e4:	0f 90       	pop	r0
    73e6:	df 91       	pop	r29
    73e8:	cf 91       	pop	r28
    73ea:	1f 91       	pop	r17
    73ec:	0f 91       	pop	r16
    73ee:	ff 90       	pop	r15
    73f0:	df 90       	pop	r13
    73f2:	cf 90       	pop	r12
    73f4:	08 95       	ret

000073f6 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    73f6:	8f ef       	ldi	r24, 0xFF	; 255
    73f8:	80 93 7b 08 	sts	0x087B, r24
	GSM_RX_FIFO_End = 255;
    73fc:	80 93 05 06 	sts	0x0605, r24
	GSM_RxCharN = 0;
    7400:	10 92 45 0d 	sts	0x0D45, r1
    7404:	08 95       	ret

00007406 <GetByteFromFIFO>:
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    7406:	fb 01       	movw	r30, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7408:	20 81       	ld	r18, Z
    740a:	24 17       	cp	r18, r20
    740c:	08 f0       	brcs	.+2      	; 0x7410 <GetByteFromFIFO+0xa>
		*Index = 0;
    740e:	10 82       	st	Z, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7410:	20 91 7b 08 	lds	r18, 0x087B
    7414:	a0 91 05 06 	lds	r26, 0x0605
    7418:	a2 17       	cp	r26, r18
    741a:	08 f5       	brcc	.+66     	; 0x745e <GetByteFromFIFO+0x58>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    741c:	af 3f       	cpi	r26, 0xFF	; 255
    741e:	81 f0       	breq	.+32     	; 0x7440 <GetByteFromFIFO+0x3a>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7420:	40 91 0d 0b 	lds	r20, 0x0B0D
    7424:	20 91 7b 08 	lds	r18, 0x087B
    7428:	50 e0       	ldi	r21, 0x00	; 0
    742a:	30 e0       	ldi	r19, 0x00	; 0
    742c:	2a 1b       	sub	r18, r26
    742e:	31 09       	sbc	r19, r1
    7430:	42 17       	cp	r20, r18
    7432:	53 07       	cpc	r21, r19
    7434:	2c f4       	brge	.+10     	; 0x7440 <GetByteFromFIFO+0x3a>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    7436:	20 91 7b 08 	lds	r18, 0x087B
    743a:	2a 1b       	sub	r18, r26
    743c:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    7440:	af 5f       	subi	r26, 0xFF	; 255
    7442:	a0 93 05 06 	sts	0x0605, r26
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7446:	b0 e0       	ldi	r27, 0x00	; 0
    7448:	a8 50       	subi	r26, 0x08	; 8
    744a:	bb 4f       	sbci	r27, 0xFB	; 251
    744c:	2c 91       	ld	r18, X
    744e:	30 81       	ld	r19, Z
    7450:	dc 01       	movw	r26, r24
    7452:	a3 0f       	add	r26, r19
    7454:	b1 1d       	adc	r27, r1
    7456:	2c 93       	st	X, r18
		*Index=*Index+1;
    7458:	20 81       	ld	r18, Z
    745a:	2f 5f       	subi	r18, 0xFF	; 255
    745c:	20 83       	st	Z, r18
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    745e:	60 91 05 06 	lds	r22, 0x0605
    7462:	20 91 7b 08 	lds	r18, 0x087B
    7466:	26 17       	cp	r18, r22
    7468:	60 f5       	brcc	.+88     	; 0x74c2 <GetByteFromFIFO+0xbc>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    746a:	6f 3f       	cpi	r22, 0xFF	; 255
    746c:	a1 f0       	breq	.+40     	; 0x7496 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    746e:	40 91 0d 0b 	lds	r20, 0x0B0D
    7472:	70 91 7b 08 	lds	r23, 0x087B
    7476:	50 e0       	ldi	r21, 0x00	; 0
    7478:	2a ef       	ldi	r18, 0xFA	; 250
    747a:	30 e0       	ldi	r19, 0x00	; 0
    747c:	26 1b       	sub	r18, r22
    747e:	31 09       	sbc	r19, r1
    7480:	27 0f       	add	r18, r23
    7482:	31 1d       	adc	r19, r1
    7484:	42 17       	cp	r20, r18
    7486:	53 07       	cpc	r21, r19
    7488:	34 f4       	brge	.+12     	; 0x7496 <GetByteFromFIFO+0x90>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    748a:	20 91 7b 08 	lds	r18, 0x087B
    748e:	26 50       	subi	r18, 0x06	; 6
    7490:	26 1b       	sub	r18, r22
    7492:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    7496:	6f 5f       	subi	r22, 0xFF	; 255
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    7498:	6a 3f       	cpi	r22, 0xFA	; 250
    749a:	18 f4       	brcc	.+6      	; 0x74a2 <GetByteFromFIFO+0x9c>
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    749c:	60 93 05 06 	sts	0x0605, r22
    74a0:	02 c0       	rjmp	.+4      	; 0x74a6 <GetByteFromFIFO+0xa0>
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    74a2:	10 92 05 06 	sts	0x0605, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    74a6:	a0 91 05 06 	lds	r26, 0x0605
    74aa:	b0 e0       	ldi	r27, 0x00	; 0
    74ac:	a8 50       	subi	r26, 0x08	; 8
    74ae:	bb 4f       	sbci	r27, 0xFB	; 251
    74b0:	2c 91       	ld	r18, X
    74b2:	30 81       	ld	r19, Z
    74b4:	dc 01       	movw	r26, r24
    74b6:	a3 0f       	add	r26, r19
    74b8:	b1 1d       	adc	r27, r1
    74ba:	2c 93       	st	X, r18
		*Index=*Index+1;
    74bc:	80 81       	ld	r24, Z
    74be:	8f 5f       	subi	r24, 0xFF	; 255
    74c0:	80 83       	st	Z, r24
    74c2:	08 95       	ret

000074c4 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    74c4:	90 91 7b 08 	lds	r25, 0x087B
    74c8:	80 91 05 06 	lds	r24, 0x0605
    74cc:	98 17       	cp	r25, r24
    74ce:	39 f1       	breq	.+78     	; 0x751e <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    74d0:	44 e6       	ldi	r20, 0x64	; 100
    74d2:	65 e4       	ldi	r22, 0x45	; 69
    74d4:	7d e0       	ldi	r23, 0x0D	; 13
    74d6:	89 e8       	ldi	r24, 0x89	; 137
    74d8:	99 e0       	ldi	r25, 0x09	; 9
    74da:	0e 94 03 3a 	call	0x7406	; 0x7406 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    74de:	80 91 45 0d 	lds	r24, 0x0D45
    74e2:	82 30       	cpi	r24, 0x02	; 2
    74e4:	78 f3       	brcs	.-34     	; 0x74c4 <GetStringFromFIFO>
    74e6:	e0 91 45 0d 	lds	r30, 0x0D45
    74ea:	f0 e0       	ldi	r31, 0x00	; 0
    74ec:	e9 57       	subi	r30, 0x79	; 121
    74ee:	f6 4f       	sbci	r31, 0xF6	; 246
    74f0:	80 81       	ld	r24, Z
    74f2:	8d 30       	cpi	r24, 0x0D	; 13
    74f4:	39 f7       	brne	.-50     	; 0x74c4 <GetStringFromFIFO>
    74f6:	e0 91 45 0d 	lds	r30, 0x0D45
    74fa:	f0 e0       	ldi	r31, 0x00	; 0
    74fc:	e8 57       	subi	r30, 0x78	; 120
    74fe:	f6 4f       	sbci	r31, 0xF6	; 246
    7500:	80 81       	ld	r24, Z
    7502:	8a 30       	cpi	r24, 0x0A	; 10
    7504:	f9 f6       	brne	.-66     	; 0x74c4 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    7506:	e0 91 45 0d 	lds	r30, 0x0D45
    750a:	f0 e0       	ldi	r31, 0x00	; 0
    750c:	e9 57       	subi	r30, 0x79	; 121
    750e:	f6 4f       	sbci	r31, 0xF6	; 246
    7510:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    7512:	80 91 45 0d 	lds	r24, 0x0D45
			GSM_RxCharN = 0;
    7516:	10 92 45 0d 	sts	0x0D45, r1
    751a:	81 50       	subi	r24, 0x01	; 1
    751c:	08 95       	ret
			return StrLength;
		}

	}//while

	return StrLength;
    751e:	80 e0       	ldi	r24, 0x00	; 0
}
    7520:	08 95       	ret

00007522 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    7522:	80 91 45 0d 	lds	r24, 0x0D45
    7526:	84 36       	cpi	r24, 0x64	; 100
    7528:	18 f0       	brcs	.+6      	; 0x7530 <ForceEndStringFromFIFO+0xe>
    752a:	83 e6       	ldi	r24, 0x63	; 99
    752c:	80 93 45 0d 	sts	0x0D45, r24
	StrLength = GSM_RxCharN;
    7530:	80 91 45 0d 	lds	r24, 0x0D45
	GSM_RxStr[GSM_RxCharN]='\0';
    7534:	e0 91 45 0d 	lds	r30, 0x0D45
    7538:	f0 e0       	ldi	r31, 0x00	; 0
    753a:	e7 57       	subi	r30, 0x77	; 119
    753c:	f6 4f       	sbci	r31, 0xF6	; 246
    753e:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    7540:	10 92 45 0d 	sts	0x0D45, r1
	return StrLength;
}
    7544:	08 95       	ret

00007546 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    7546:	cf 93       	push	r28
    7548:	c8 2f       	mov	r28, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    754a:	90 91 7b 08 	lds	r25, 0x087B
    754e:	80 91 05 06 	lds	r24, 0x0605
    7552:	98 17       	cp	r25, r24
    7554:	79 f0       	breq	.+30     	; 0x7574 <GetDataFromFIFO+0x2e>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7556:	44 e6       	ldi	r20, 0x64	; 100
    7558:	65 e4       	ldi	r22, 0x45	; 69
    755a:	7d e0       	ldi	r23, 0x0D	; 13
    755c:	89 e8       	ldi	r24, 0x89	; 137
    755e:	99 e0       	ldi	r25, 0x09	; 9
    7560:	0e 94 03 3a 	call	0x7406	; 0x7406 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    7564:	80 91 45 0d 	lds	r24, 0x0D45
    7568:	8c 17       	cp	r24, r28
    756a:	78 f3       	brcs	.-34     	; 0x754a <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    756c:	10 92 45 0d 	sts	0x0D45, r1
			return Amount;
    7570:	8c 2f       	mov	r24, r28
    7572:	02 c0       	rjmp	.+4      	; 0x7578 <GetDataFromFIFO+0x32>
		}
	}//while
	return GSM_RxCharN;
    7574:	80 91 45 0d 	lds	r24, 0x0D45
}
    7578:	cf 91       	pop	r28
    757a:	08 95       	ret

0000757c <strcpy_EE>:
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    757c:	df 92       	push	r13
    757e:	ef 92       	push	r14
    7580:	ff 92       	push	r15
    7582:	0f 93       	push	r16
    7584:	1f 93       	push	r17
    7586:	cf 93       	push	r28
    7588:	df 93       	push	r29
    758a:	8c 01       	movw	r16, r24
    758c:	7b 01       	movw	r14, r22
	uint8_t i=0;
    758e:	d1 2c       	mov	r13, r1
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    7590:	cd 2d       	mov	r28, r13
    7592:	d0 e0       	ldi	r29, 0x00	; 0
    7594:	c7 01       	movw	r24, r14
    7596:	8c 0f       	add	r24, r28
    7598:	9d 1f       	adc	r25, r29
    759a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    759e:	98 2f       	mov	r25, r24
    75a0:	9f 7d       	andi	r25, 0xDF	; 223
    75a2:	29 f0       	breq	.+10     	; 0x75ae <strcpy_EE+0x32>
		str_RAM[i] = (char)erb(&str_EE[i]);
    75a4:	c0 0f       	add	r28, r16
    75a6:	d1 1f       	adc	r29, r17
    75a8:	88 83       	st	Y, r24
		i++;
    75aa:	d3 94       	inc	r13
    75ac:	f1 cf       	rjmp	.-30     	; 0x7590 <strcpy_EE+0x14>
	}
	return i;	
}
    75ae:	8d 2d       	mov	r24, r13
    75b0:	df 91       	pop	r29
    75b2:	cf 91       	pop	r28
    75b4:	1f 91       	pop	r17
    75b6:	0f 91       	pop	r16
    75b8:	ff 90       	pop	r15
    75ba:	ef 90       	pop	r14
    75bc:	df 90       	pop	r13
    75be:	08 95       	ret

000075c0 <GSM_Init>:
}
// ~~~~~~~~~~~
void
GSM_Init(void)
{	
	InitFIFO();
    75c0:	0e 94 fb 39 	call	0x73f6	; 0x73f6 <InitFIFO>
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABl_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    75c4:	8c ef       	ldi	r24, 0xFC	; 252
    75c6:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    75c8:	88 e9       	ldi	r24, 0x98	; 152
    75ca:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    75cc:	86 e8       	ldi	r24, 0x86	; 134
    75ce:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    75d2:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    75d6:	87 e6       	ldi	r24, 0x67	; 103
    75d8:	89 b9       	out	0x09, r24	; 9
	#endif

	GSM_PWRCNTRL_Config();
    75da:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <GSM_PWRCNTRL_Config>
	GSM_PWRCNTRL_ON();
    75de:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <GSM_PWRCNTRL_ON>

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    75e2:	80 91 0e 01 	lds	r24, 0x010E
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    75e6:	80 93 5a 02 	sts	0x025A, r24
	VacantTimer16Sys += n;
    75ea:	91 e0       	ldi	r25, 0x01	; 1
    75ec:	98 0f       	add	r25, r24
	TD_TCP_Connect = Timer16SysAlloc(1);
    75ee:	90 93 59 02 	sts	0x0259, r25
    75f2:	92 e0       	ldi	r25, 0x02	; 2
    75f4:	98 0f       	add	r25, r24
	TD_RSSI = Timer16SysAlloc(1);
    75f6:	90 93 58 02 	sts	0x0258, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    75fa:	90 91 0d 01 	lds	r25, 0x010D
	VacantTimer32Sys += n;
    75fe:	21 e0       	ldi	r18, 0x01	; 1
    7600:	29 0f       	add	r18, r25
    7602:	20 93 0d 01 	sts	0x010D, r18
	TD_GSM_Reset = Timer32SysAlloc(1);
    7606:	90 93 57 02 	sts	0x0257, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    760a:	93 e0       	ldi	r25, 0x03	; 3
    760c:	98 0f       	add	r25, r24
	TCP_CONNECT_check_timer = Timer16SysAlloc(1);
    760e:	90 93 40 0d 	sts	0x0D40, r25
    7612:	95 e0       	ldi	r25, 0x05	; 5
    7614:	98 0f       	add	r25, r24
    7616:	90 93 0e 01 	sts	0x010E, r25
    761a:	8c 5f       	subi	r24, 0xFC	; 252
	GPRS_RECONNECT_timer = Timer16SysAlloc(1);
    761c:	80 93 0b 06 	sts	0x060B, r24
/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    7620:	10 92 7d 09 	sts	0x097D, r1
	GSM_State = GSM_PowerOn;
    7624:	10 92 27 06 	sts	0x0627, r1
    7628:	08 95       	ret

0000762a <GSM_Wait_Response>:
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    762a:	bc 01       	movw	r22, r24
    762c:	89 e8       	ldi	r24, 0x89	; 137
    762e:	99 e0       	ldi	r25, 0x09	; 9
    7630:	0e 94 b7 6c 	call	0xd96e	; 0xd96e <strcmp>
    7634:	21 e0       	ldi	r18, 0x01	; 1
    7636:	89 2b       	or	r24, r25
    7638:	09 f0       	breq	.+2      	; 0x763c <GSM_Wait_Response+0x12>
    763a:	20 e0       	ldi	r18, 0x00	; 0
	else return 1;
}
    763c:	82 2f       	mov	r24, r18
    763e:	08 95       	ret

00007640 <GSM_Wait_Response_P>:
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    7640:	0f 93       	push	r16
    7642:	1f 93       	push	r17
    7644:	cf 93       	push	r28
    7646:	df 93       	push	r29
    7648:	1f 92       	push	r1
    764a:	cd b7       	in	r28, 0x3d	; 61
    764c:	de b7       	in	r29, 0x3e	; 62
    764e:	8c 01       	movw	r16, r24
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    7650:	80 91 5a 02 	lds	r24, 0x025A
    7654:	69 83       	std	Y+1, r22	; 0x01
    7656:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    765a:	69 81       	ldd	r22, Y+1	; 0x01
    765c:	88 23       	and	r24, r24
    765e:	29 f0       	breq	.+10     	; 0x766a <GSM_Wait_Response_P+0x2a>
    7660:	66 23       	and	r22, r22
    7662:	19 f0       	breq	.+6      	; 0x766a <GSM_Wait_Response_P+0x2a>
		GSM_State = RestoreCMD;
    7664:	60 93 27 06 	sts	0x0627, r22
    7668:	0c c0       	rjmp	.+24     	; 0x7682 <GSM_Wait_Response_P+0x42>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    766a:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    766e:	88 23       	and	r24, r24
    7670:	41 f0       	breq	.+16     	; 0x7682 <GSM_Wait_Response_P+0x42>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    7672:	b8 01       	movw	r22, r16
    7674:	89 e8       	ldi	r24, 0x89	; 137
    7676:	99 e0       	ldi	r25, 0x09	; 9
    7678:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    767c:	21 e0       	ldi	r18, 0x01	; 1
    767e:	89 2b       	or	r24, r25
    7680:	09 f0       	breq	.+2      	; 0x7684 <GSM_Wait_Response_P+0x44>
		else return 1;
	}
	else return 0;
    7682:	20 e0       	ldi	r18, 0x00	; 0
}
    7684:	82 2f       	mov	r24, r18
    7686:	0f 90       	pop	r0
    7688:	df 91       	pop	r29
    768a:	cf 91       	pop	r28
    768c:	1f 91       	pop	r17
    768e:	0f 91       	pop	r16
    7690:	08 95       	ret

00007692 <GSM_Wait_Char>:
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7692:	1f 93       	push	r17
    7694:	cf 93       	push	r28
    7696:	df 93       	push	r29
    7698:	1f 92       	push	r1
    769a:	cd b7       	in	r28, 0x3d	; 61
    769c:	de b7       	in	r29, 0x3e	; 62
    769e:	18 2f       	mov	r17, r24
	if(Timer16Stopp(TD_GSM)){
    76a0:	80 91 5a 02 	lds	r24, 0x025A
    76a4:	69 83       	std	Y+1, r22	; 0x01
    76a6:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    76aa:	69 81       	ldd	r22, Y+1	; 0x01
    76ac:	88 23       	and	r24, r24
    76ae:	19 f0       	breq	.+6      	; 0x76b6 <GSM_Wait_Char+0x24>
		GSM_State = RestoreCMD;
    76b0:	60 93 27 06 	sts	0x0627, r22
    76b4:	09 c0       	rjmp	.+18     	; 0x76c8 <GSM_Wait_Char+0x36>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    76b6:	81 e0       	ldi	r24, 0x01	; 1
    76b8:	0e 94 a3 3a 	call	0x7546	; 0x7546 <GetDataFromFIFO>
    76bc:	88 23       	and	r24, r24
    76be:	21 f0       	breq	.+8      	; 0x76c8 <GSM_Wait_Char+0x36>
		if(GSM_RxStr[0] == Char)	return 1;
    76c0:	81 e0       	ldi	r24, 0x01	; 1
    76c2:	90 91 89 09 	lds	r25, 0x0989
    76c6:	91 13       	cpse	r25, r17
		else return 0;
	}
	else return 0;
    76c8:	80 e0       	ldi	r24, 0x00	; 0
}
    76ca:	0f 90       	pop	r0
    76cc:	df 91       	pop	r29
    76ce:	cf 91       	pop	r28
    76d0:	1f 91       	pop	r17
    76d2:	08 95       	ret

000076d4 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    76d4:	80 91 76 0a 	lds	r24, 0x0A76
    76d8:	81 11       	cpse	r24, r1
    76da:	05 c0       	rjmp	.+10     	; 0x76e6 <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    76dc:	80 91 08 01 	lds	r24, 0x0108
    76e0:	81 60       	ori	r24, 0x01	; 1
    76e2:	80 93 08 01 	sts	0x0108, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    76e6:	88 e9       	ldi	r24, 0x98	; 152
    76e8:	8a b9       	out	0x0a, r24	; 10
    76ea:	08 95       	ret

000076ec <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    76ec:	1f 92       	push	r1
    76ee:	0f 92       	push	r0
    76f0:	0f b6       	in	r0, 0x3f	; 63
    76f2:	0f 92       	push	r0
    76f4:	11 24       	eor	r1, r1
    76f6:	0b b6       	in	r0, 0x3b	; 59
    76f8:	0f 92       	push	r0
    76fa:	2f 93       	push	r18
    76fc:	3f 93       	push	r19
    76fe:	4f 93       	push	r20
    7700:	5f 93       	push	r21
    7702:	6f 93       	push	r22
    7704:	7f 93       	push	r23
    7706:	8f 93       	push	r24
    7708:	9f 93       	push	r25
    770a:	af 93       	push	r26
    770c:	bf 93       	push	r27
    770e:	ef 93       	push	r30
    7710:	ff 93       	push	r31
	GSM_TX();
    7712:	0e 94 6a 3b 	call	0x76d4	; 0x76d4 <GSM_TX>
	GSM_LED = 1;
    7716:	81 e0       	ldi	r24, 0x01	; 1
    7718:	80 93 0a 06 	sts	0x060A, r24
}
    771c:	ff 91       	pop	r31
    771e:	ef 91       	pop	r30
    7720:	bf 91       	pop	r27
    7722:	af 91       	pop	r26
    7724:	9f 91       	pop	r25
    7726:	8f 91       	pop	r24
    7728:	7f 91       	pop	r23
    772a:	6f 91       	pop	r22
    772c:	5f 91       	pop	r21
    772e:	4f 91       	pop	r20
    7730:	3f 91       	pop	r19
    7732:	2f 91       	pop	r18
    7734:	0f 90       	pop	r0
    7736:	0b be       	out	0x3b, r0	; 59
    7738:	0f 90       	pop	r0
    773a:	0f be       	out	0x3f, r0	; 63
    773c:	0f 90       	pop	r0
    773e:	1f 90       	pop	r1
    7740:	18 95       	reti

00007742 <DI_State>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
    7742:	e8 2f       	mov	r30, r24
    7744:	e6 95       	lsr	r30
    7746:	e6 95       	lsr	r30
    7748:	e6 95       	lsr	r30
    774a:	f0 e0       	ldi	r31, 0x00	; 0
    774c:	ea 52       	subi	r30, 0x2A	; 42
    774e:	f7 4f       	sbci	r31, 0xF7	; 247
    7750:	20 81       	ld	r18, Z
    7752:	30 e0       	ldi	r19, 0x00	; 0
    7754:	87 70       	andi	r24, 0x07	; 7
    7756:	02 c0       	rjmp	.+4      	; 0x775c <DI_State+0x1a>
    7758:	35 95       	asr	r19
    775a:	27 95       	ror	r18
    775c:	8a 95       	dec	r24
    775e:	e2 f7       	brpl	.-8      	; 0x7758 <DI_State+0x16>
}
    7760:	82 2f       	mov	r24, r18
    7762:	81 70       	andi	r24, 0x01	; 1
    7764:	08 95       	ret

00007766 <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
    7766:	e8 2f       	mov	r30, r24
    7768:	e6 95       	lsr	r30
    776a:	e6 95       	lsr	r30
    776c:	e6 95       	lsr	r30
    776e:	f0 e0       	ldi	r31, 0x00	; 0
    7770:	e8 52       	subi	r30, 0x28	; 40
    7772:	f7 4f       	sbci	r31, 0xF7	; 247
    7774:	20 81       	ld	r18, Z
    7776:	30 e0       	ldi	r19, 0x00	; 0
    7778:	87 70       	andi	r24, 0x07	; 7
    777a:	02 c0       	rjmp	.+4      	; 0x7780 <DI_Status+0x1a>
    777c:	35 95       	asr	r19
    777e:	27 95       	ror	r18
    7780:	8a 95       	dec	r24
    7782:	e2 f7       	brpl	.-8      	; 0x777c <DI_Status+0x16>
}
    7784:	82 2f       	mov	r24, r18
    7786:	81 70       	andi	r24, 0x01	; 1
    7788:	08 95       	ret

0000778a <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    778a:	ff 92       	push	r15
    778c:	0f 93       	push	r16
    778e:	1f 93       	push	r17
    7790:	cf 93       	push	r28
    7792:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    7794:	c0 91 d6 08 	lds	r28, 0x08D6
    7798:	c0 93 d7 08 	sts	0x08D7, r28
    779c:	8e e5       	ldi	r24, 0x5E	; 94
    779e:	90 e0       	ldi	r25, 0x00	; 0
    77a0:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    77a4:	8c 27       	eor	r24, r28
    77a6:	80 93 d8 08 	sts	0x08D8, r24
    77aa:	81 e2       	ldi	r24, 0x21	; 33
    77ac:	9d e4       	ldi	r25, 0x4D	; 77
    77ae:	20 e0       	ldi	r18, 0x00	; 0
    77b0:	30 e0       	ldi	r19, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    77b2:	c1 e0       	ldi	r28, 0x01	; 1
    77b4:	d0 e0       	ldi	r29, 0x00	; 0
    77b6:	ae 01       	movw	r20, r28
    77b8:	02 2e       	mov	r0, r18
    77ba:	01 c0       	rjmp	.+2      	; 0x77be <DigitIn+0x34>
    77bc:	44 0f       	add	r20, r20
    77be:	0a 94       	dec	r0
    77c0:	ea f7       	brpl	.-6      	; 0x77bc <DigitIn+0x32>
    77c2:	fc 01       	movw	r30, r24
    77c4:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77c6:	e4 91       	lpm	r30, Z
    77c8:	dc 01       	movw	r26, r24
    77ca:	12 96       	adiw	r26, 0x02	; 2
    77cc:	f0 90 d6 08 	lds	r15, 0x08D6
			if(prb(&DI_M[D_N].Inversion)){
    77d0:	ee 23       	and	r30, r30
    77d2:	51 f0       	breq	.+20     	; 0x77e8 <DigitIn+0x5e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    77d4:	fc 01       	movw	r30, r24
    77d6:	05 91       	lpm	r16, Z+
    77d8:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77da:	fd 01       	movw	r30, r26
    77dc:	a4 91       	lpm	r26, Z
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    77de:	f8 01       	movw	r30, r16
    77e0:	60 81       	ld	r22, Z
    77e2:	a6 23       	and	r26, r22
    77e4:	51 f0       	breq	.+20     	; 0x77fa <DigitIn+0x70>
    77e6:	0c c0       	rjmp	.+24     	; 0x7800 <DigitIn+0x76>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    77e8:	fc 01       	movw	r30, r24
    77ea:	05 91       	lpm	r16, Z+
    77ec:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77ee:	fd 01       	movw	r30, r26
    77f0:	a4 91       	lpm	r26, Z
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    77f2:	f8 01       	movw	r30, r16
    77f4:	60 81       	ld	r22, Z
    77f6:	a6 23       	and	r26, r22
    77f8:	19 f0       	breq	.+6      	; 0x7800 <DigitIn+0x76>
					DigInput.State[Byte] &=~Bit;
    77fa:	40 95       	com	r20
    77fc:	4f 21       	and	r20, r15
    77fe:	01 c0       	rjmp	.+2      	; 0x7802 <DigitIn+0x78>
				else
					DigInput.State[Byte]  |=Bit;
    7800:	4f 29       	or	r20, r15
    7802:	40 93 d6 08 	sts	0x08D6, r20
    7806:	2f 5f       	subi	r18, 0xFF	; 255
    7808:	3f 4f       	sbci	r19, 0xFF	; 255
    780a:	08 96       	adiw	r24, 0x08	; 8
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    780c:	24 30       	cpi	r18, 0x04	; 4
    780e:	31 05       	cpc	r19, r1
    7810:	09 f0       	breq	.+2      	; 0x7814 <DigitIn+0x8a>
    7812:	d1 cf       	rjmp	.-94     	; 0x77b6 <DigitIn+0x2c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    7814:	df 91       	pop	r29
    7816:	cf 91       	pop	r28
    7818:	1f 91       	pop	r17
    781a:	0f 91       	pop	r16
    781c:	ff 90       	pop	r15
    781e:	08 95       	ret

00007820 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7820:	e8 2f       	mov	r30, r24
    7822:	e6 95       	lsr	r30
    7824:	e6 95       	lsr	r30
    7826:	e6 95       	lsr	r30
    7828:	f0 e0       	ldi	r31, 0x00	; 0
    782a:	eb 57       	subi	r30, 0x7B	; 123
    782c:	f6 4f       	sbci	r31, 0xF6	; 246
    782e:	87 70       	andi	r24, 0x07	; 7
    7830:	21 e0       	ldi	r18, 0x01	; 1
    7832:	30 e0       	ldi	r19, 0x00	; 0
    7834:	01 c0       	rjmp	.+2      	; 0x7838 <SetDigOut+0x18>
    7836:	22 0f       	add	r18, r18
    7838:	8a 95       	dec	r24
    783a:	ea f7       	brpl	.-6      	; 0x7836 <SetDigOut+0x16>
    783c:	80 81       	ld	r24, Z
    783e:	82 2b       	or	r24, r18
    7840:	80 83       	st	Z, r24
    7842:	08 95       	ret

00007844 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    7844:	e8 2f       	mov	r30, r24
    7846:	e6 95       	lsr	r30
    7848:	e6 95       	lsr	r30
    784a:	e6 95       	lsr	r30
    784c:	f0 e0       	ldi	r31, 0x00	; 0
    784e:	eb 57       	subi	r30, 0x7B	; 123
    7850:	f6 4f       	sbci	r31, 0xF6	; 246
    7852:	87 70       	andi	r24, 0x07	; 7
    7854:	21 e0       	ldi	r18, 0x01	; 1
    7856:	30 e0       	ldi	r19, 0x00	; 0
    7858:	01 c0       	rjmp	.+2      	; 0x785c <ResDigOut+0x18>
    785a:	22 0f       	add	r18, r18
    785c:	8a 95       	dec	r24
    785e:	ea f7       	brpl	.-6      	; 0x785a <ResDigOut+0x16>
    7860:	20 95       	com	r18
    7862:	80 81       	ld	r24, Z
    7864:	28 23       	and	r18, r24
    7866:	20 83       	st	Z, r18
    7868:	08 95       	ret

0000786a <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    786a:	80 91 83 09 	lds	r24, 0x0983
    786e:	80 93 84 09 	sts	0x0984, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7872:	80 91 85 09 	lds	r24, 0x0985
    7876:	80 93 83 09 	sts	0x0983, r24
    787a:	80 e1       	ldi	r24, 0x10	; 16
    787c:	9d e4       	ldi	r25, 0x4D	; 77
    787e:	20 e0       	ldi	r18, 0x00	; 0
    7880:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    7882:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7884:	40 91 83 09 	lds	r20, 0x0983
    7888:	50 e0       	ldi	r21, 0x00	; 0
    788a:	02 2e       	mov	r0, r18
    788c:	02 c0       	rjmp	.+4      	; 0x7892 <DigitOut+0x28>
    788e:	55 95       	asr	r21
    7890:	47 95       	ror	r20
    7892:	0a 94       	dec	r0
    7894:	e2 f7       	brpl	.-8      	; 0x788e <DigitOut+0x24>
    7896:	bc 01       	movw	r22, r24
    7898:	6e 5f       	subi	r22, 0xFE	; 254
    789a:	7f 4f       	sbci	r23, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    789c:	fc 01       	movw	r30, r24
    789e:	40 ff       	sbrs	r20, 0
    78a0:	07 c0       	rjmp	.+14     	; 0x78b0 <DigitOut+0x46>
    78a2:	a5 91       	lpm	r26, Z+
    78a4:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78a6:	fb 01       	movw	r30, r22
    78a8:	64 91       	lpm	r22, Z
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    78aa:	4c 91       	ld	r20, X
    78ac:	46 2b       	or	r20, r22
    78ae:	07 c0       	rjmp	.+14     	; 0x78be <DigitOut+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78b0:	a5 91       	lpm	r26, Z+
    78b2:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78b4:	fb 01       	movw	r30, r22
    78b6:	64 91       	lpm	r22, Z
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    78b8:	60 95       	com	r22
    78ba:	4c 91       	ld	r20, X
    78bc:	46 23       	and	r20, r22
    78be:	4c 93       	st	X, r20
		sei();
    78c0:	78 94       	sei
    78c2:	2f 5f       	subi	r18, 0xFF	; 255
    78c4:	3f 4f       	sbci	r19, 0xFF	; 255
    78c6:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    78c8:	23 30       	cpi	r18, 0x03	; 3
    78ca:	31 05       	cpc	r19, r1
    78cc:	d1 f6       	brne	.-76     	; 0x7882 <DigitOut+0x18>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    78ce:	08 95       	ret

000078d0 <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    78d0:	8e e0       	ldi	r24, 0x0E	; 14
    78d2:	9d e4       	ldi	r25, 0x4D	; 77
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    78d4:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78d6:	fc 01       	movw	r30, r24
    78d8:	a5 91       	lpm	r26, Z+
    78da:	b4 91       	lpm	r27, Z
    78dc:	fc 01       	movw	r30, r24
    78de:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78e0:	e4 91       	lpm	r30, Z
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    78e2:	2c 91       	ld	r18, X
    78e4:	2e 2b       	or	r18, r30
    78e6:	2c 93       	st	X, r18
		sei();
    78e8:	78 94       	sei
    78ea:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    78ec:	2d e4       	ldi	r18, 0x4D	; 77
    78ee:	8d 31       	cpi	r24, 0x1D	; 29
    78f0:	92 07       	cpc	r25, r18
    78f2:	81 f7       	brne	.-32     	; 0x78d4 <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    78f4:	0c 94 35 3c 	jmp	0x786a	; 0x786a <DigitOut>

000078f8 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    78f8:	28 2f       	mov	r18, r24
	uint16_t Pow = 1;
    78fa:	81 e0       	ldi	r24, 0x01	; 1
    78fc:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
		Pow *= 10;
    78fe:	3a e0       	ldi	r19, 0x0A	; 10
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    7900:	21 50       	subi	r18, 0x01	; 1
    7902:	38 f0       	brcs	.+14     	; 0x7912 <Pow10+0x1a>
		Pow *= 10;
    7904:	ac 01       	movw	r20, r24
    7906:	34 9f       	mul	r19, r20
    7908:	c0 01       	movw	r24, r0
    790a:	35 9f       	mul	r19, r21
    790c:	90 0d       	add	r25, r0
    790e:	11 24       	eor	r1, r1
    7910:	f7 cf       	rjmp	.-18     	; 0x7900 <Pow10+0x8>
	return Pow;
}
    7912:	08 95       	ret

00007914 <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    7914:	e8 2f       	mov	r30, r24
	uint32_t Pow = 1;
    7916:	61 e0       	ldi	r22, 0x01	; 1
    7918:	70 e0       	ldi	r23, 0x00	; 0
    791a:	80 e0       	ldi	r24, 0x00	; 0
    791c:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
    791e:	e1 50       	subi	r30, 0x01	; 1
    7920:	38 f0       	brcs	.+14     	; 0x7930 <PowL10+0x1c>
		Pow *= 10;
    7922:	aa e0       	ldi	r26, 0x0A	; 10
    7924:	b0 e0       	ldi	r27, 0x00	; 0
    7926:	9b 01       	movw	r18, r22
    7928:	ac 01       	movw	r20, r24
    792a:	0e 94 9b 75 	call	0xeb36	; 0xeb36 <__muluhisi3>
    792e:	f7 cf       	rjmp	.-18     	; 0x791e <PowL10+0xa>
	return Pow;
}
    7930:	08 95       	ret

00007932 <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    7932:	ff 92       	push	r15
    7934:	0f 93       	push	r16
    7936:	1f 93       	push	r17
    7938:	cf 93       	push	r28
    793a:	df 93       	push	r29
    793c:	f8 2e       	mov	r15, r24
    793e:	c0 e0       	ldi	r28, 0x00	; 0
    7940:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    7942:	06 2f       	mov	r16, r22
    7944:	10 e0       	ldi	r17, 0x00	; 0

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    7946:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7948:	8f 2d       	mov	r24, r15
    794a:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <OW_MasterPullLowBus>
    794e:	8a e1       	ldi	r24, 0x1A	; 26
    7950:	8a 95       	dec	r24
    7952:	f1 f7       	brne	.-4      	; 0x7950 <OW_MasterTx_Command+0x1e>
    7954:	00 c0       	rjmp	.+0      	; 0x7956 <OW_MasterTx_Command+0x24>
		_delay_us(5);
		if(Command & (1<<i)){
    7956:	98 01       	movw	r18, r16
    7958:	0c 2e       	mov	r0, r28
    795a:	02 c0       	rjmp	.+4      	; 0x7960 <OW_MasterTx_Command+0x2e>
    795c:	35 95       	asr	r19
    795e:	27 95       	ror	r18
    7960:	0a 94       	dec	r0
    7962:	e2 f7       	brpl	.-8      	; 0x795c <OW_MasterTx_Command+0x2a>
    7964:	20 ff       	sbrs	r18, 0
    7966:	0a c0       	rjmp	.+20     	; 0x797c <OW_MasterTx_Command+0x4a>
			OW_MasterReleaseBus(CH);
    7968:	8f 2d       	mov	r24, r15
    796a:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>
    796e:	83 e5       	ldi	r24, 0x53	; 83
    7970:	91 e0       	ldi	r25, 0x01	; 1
    7972:	01 97       	sbiw	r24, 0x01	; 1
    7974:	f1 f7       	brne	.-4      	; 0x7972 <OW_MasterTx_Command+0x40>
    7976:	00 c0       	rjmp	.+0      	; 0x7978 <OW_MasterTx_Command+0x46>
    7978:	00 00       	nop
    797a:	07 c0       	rjmp	.+14     	; 0x798a <OW_MasterTx_Command+0x58>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    797c:	85 e5       	ldi	r24, 0x55	; 85
    797e:	90 e0       	ldi	r25, 0x00	; 0
    7980:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>
			OW_MasterReleaseBus(CH);
    7984:	8f 2d       	mov	r24, r15
    7986:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>
		}
		sei();
    798a:	78 94       	sei
    798c:	9a e1       	ldi	r25, 0x1A	; 26
    798e:	9a 95       	dec	r25
    7990:	f1 f7       	brne	.-4      	; 0x798e <OW_MasterTx_Command+0x5c>
    7992:	00 c0       	rjmp	.+0      	; 0x7994 <OW_MasterTx_Command+0x62>
    7994:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    7996:	c8 30       	cpi	r28, 0x08	; 8
    7998:	d1 05       	cpc	r29, r1
    799a:	a9 f6       	brne	.-86     	; 0x7946 <OW_MasterTx_Command+0x14>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    799c:	df 91       	pop	r29
    799e:	cf 91       	pop	r28
    79a0:	1f 91       	pop	r17
    79a2:	0f 91       	pop	r16
    79a4:	ff 90       	pop	r15
    79a6:	08 95       	ret

000079a8 <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    79a8:	ef 92       	push	r14
    79aa:	ff 92       	push	r15
    79ac:	0f 93       	push	r16
    79ae:	1f 93       	push	r17
    79b0:	cf 93       	push	r28
    79b2:	df 93       	push	r29
    79b4:	e8 2e       	mov	r14, r24
    79b6:	c0 e0       	ldi	r28, 0x00	; 0
    79b8:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	uint8_t Data = 0;
    79ba:	f1 2c       	mov	r15, r1
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79bc:	01 e0       	ldi	r16, 0x01	; 1
    79be:	10 e0       	ldi	r17, 0x00	; 0
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    79c0:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    79c2:	8e 2d       	mov	r24, r14
    79c4:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <OW_MasterPullLowBus>
    79c8:	8a e1       	ldi	r24, 0x1A	; 26
    79ca:	8a 95       	dec	r24
    79cc:	f1 f7       	brne	.-4      	; 0x79ca <OW_MasterRx_Data+0x22>
    79ce:	00 c0       	rjmp	.+0      	; 0x79d0 <OW_MasterRx_Data+0x28>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    79d0:	8e 2d       	mov	r24, r14
    79d2:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>
    79d6:	9a e1       	ldi	r25, 0x1A	; 26
    79d8:	9a 95       	dec	r25
    79da:	f1 f7       	brne	.-4      	; 0x79d8 <OW_MasterRx_Data+0x30>
    79dc:	00 c0       	rjmp	.+0      	; 0x79de <OW_MasterRx_Data+0x36>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    79de:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79e2:	80 ff       	sbrs	r24, 0
    79e4:	07 c0       	rjmp	.+14     	; 0x79f4 <OW_MasterRx_Data+0x4c>
    79e6:	98 01       	movw	r18, r16
    79e8:	0c 2e       	mov	r0, r28
    79ea:	01 c0       	rjmp	.+2      	; 0x79ee <OW_MasterRx_Data+0x46>
    79ec:	22 0f       	add	r18, r18
    79ee:	0a 94       	dec	r0
    79f0:	ea f7       	brpl	.-6      	; 0x79ec <OW_MasterRx_Data+0x44>
    79f2:	f2 2a       	or	r15, r18
		sei();
    79f4:	78 94       	sei
    79f6:	8f ee       	ldi	r24, 0xEF	; 239
    79f8:	90 e0       	ldi	r25, 0x00	; 0
    79fa:	01 97       	sbiw	r24, 0x01	; 1
    79fc:	f1 f7       	brne	.-4      	; 0x79fa <OW_MasterRx_Data+0x52>
    79fe:	00 c0       	rjmp	.+0      	; 0x7a00 <OW_MasterRx_Data+0x58>
    7a00:	00 00       	nop
    7a02:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    7a04:	c8 30       	cpi	r28, 0x08	; 8
    7a06:	d1 05       	cpc	r29, r1
    7a08:	d9 f6       	brne	.-74     	; 0x79c0 <OW_MasterRx_Data+0x18>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    7a0a:	8f 2d       	mov	r24, r15
    7a0c:	df 91       	pop	r29
    7a0e:	cf 91       	pop	r28
    7a10:	1f 91       	pop	r17
    7a12:	0f 91       	pop	r16
    7a14:	ff 90       	pop	r15
    7a16:	ef 90       	pop	r14
    7a18:	08 95       	ret

00007a1a <OneWire_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7a1a:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    7a1e:	91 e0       	ldi	r25, 0x01	; 1
    7a20:	98 0f       	add	r25, r24
    7a22:	90 93 0f 01 	sts	0x010F, r25


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    7a26:	80 93 6b 09 	sts	0x096B, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    7a2a:	8a e0       	ldi	r24, 0x0A	; 10
    7a2c:	80 93 f7 03 	sts	0x03F7, r24
    7a30:	08 95       	ret

00007a32 <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    7a32:	ff 92       	push	r15
    7a34:	0f 93       	push	r16
    7a36:	1f 93       	push	r17
    7a38:	cf 93       	push	r28
    7a3a:	df 93       	push	r29
    7a3c:	f8 2e       	mov	r15, r24
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    7a3e:	08 2f       	mov	r16, r24
    7a40:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7a42:	c8 01       	movw	r24, r16
    7a44:	83 5a       	subi	r24, 0xA3	; 163
    7a46:	9f 4f       	sbci	r25, 0xFF	; 255
    7a48:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    7a4c:	e8 01       	movw	r28, r16
    7a4e:	cd 50       	subi	r28, 0x0D	; 13
    7a50:	d6 4f       	sbci	r29, 0xF6	; 246
    7a52:	81 11       	cpse	r24, r1
    7a54:	0c c0       	rjmp	.+24     	; 0x7a6e <OneWireStartADC+0x3c>
		Temperature[CH] = Therm_Off_Mark;
    7a56:	f8 01       	movw	r30, r16
    7a58:	ee 0f       	add	r30, r30
    7a5a:	ff 1f       	adc	r31, r31
    7a5c:	ee 50       	subi	r30, 0x0E	; 14
    7a5e:	fa 4f       	sbci	r31, 0xFA	; 250
    7a60:	80 e0       	ldi	r24, 0x00	; 0
    7a62:	90 e8       	ldi	r25, 0x80	; 128
    7a64:	91 83       	std	Z+1, r25	; 0x01
    7a66:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    7a68:	82 e0       	ldi	r24, 0x02	; 2
    7a6a:	88 83       	st	Y, r24
		return;
    7a6c:	37 c0       	rjmp	.+110    	; 0x7adc <OneWireStartADC+0xaa>
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7a6e:	f8 94       	cli
    7a70:	8f 2d       	mov	r24, r15
    7a72:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <OW_MasterPullLowBus>
    7a76:	78 94       	sei
	Delay_us(580);	
    7a78:	84 e4       	ldi	r24, 0x44	; 68
    7a7a:	92 e0       	ldi	r25, 0x02	; 2
    7a7c:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7a80:	f8 94       	cli
    7a82:	8f 2d       	mov	r24, r15
    7a84:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>
    7a88:	87 e1       	ldi	r24, 0x17	; 23
    7a8a:	91 e0       	ldi	r25, 0x01	; 1
    7a8c:	01 97       	sbiw	r24, 0x01	; 1
    7a8e:	f1 f7       	brne	.-4      	; 0x7a8c <OneWireStartADC+0x5a>
    7a90:	00 c0       	rjmp	.+0      	; 0x7a92 <OneWireStartADC+0x60>
    7a92:	00 00       	nop
    7a94:	80 91 63 00 	lds	r24, 0x0063
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    7a98:	80 fd       	sbrc	r24, 0
    7a9a:	03 c0       	rjmp	.+6      	; 0x7aa2 <OneWireStartADC+0x70>
    7a9c:	81 e0       	ldi	r24, 0x01	; 1
    7a9e:	88 83       	st	Y, r24
    7aa0:	08 c0       	rjmp	.+16     	; 0x7ab2 <OneWireStartADC+0x80>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    7aa2:	82 e0       	ldi	r24, 0x02	; 2
    7aa4:	88 83       	st	Y, r24
		DS18B20_Error[CH]++;
    7aa6:	f8 01       	movw	r30, r16
    7aa8:	e9 50       	subi	r30, 0x09	; 9
    7aaa:	fc 4f       	sbci	r31, 0xFC	; 252
    7aac:	80 81       	ld	r24, Z
    7aae:	8f 5f       	subi	r24, 0xFF	; 255
    7ab0:	80 83       	st	Z, r24
	}
	sei();
    7ab2:	78 94       	sei
	
	Delay_us(510);
    7ab4:	8e ef       	ldi	r24, 0xFE	; 254
    7ab6:	91 e0       	ldi	r25, 0x01	; 1
    7ab8:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7abc:	88 81       	ld	r24, Y
    7abe:	82 30       	cpi	r24, 0x02	; 2
    7ac0:	69 f0       	breq	.+26     	; 0x7adc <OneWireStartADC+0xaa>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7ac2:	6c ec       	ldi	r22, 0xCC	; 204
    7ac4:	8f 2d       	mov	r24, r15
    7ac6:	0e 94 99 3c 	call	0x7932	; 0x7932 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7aca:	64 e4       	ldi	r22, 0x44	; 68
    7acc:	8f 2d       	mov	r24, r15
	}
}
    7ace:	df 91       	pop	r29
    7ad0:	cf 91       	pop	r28
    7ad2:	1f 91       	pop	r17
    7ad4:	0f 91       	pop	r16
    7ad6:	ff 90       	pop	r15
	
	Delay_us(510);

	if(DS18B20_Status[CH] != DS18B20_ERROR){
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7ad8:	0c 94 99 3c 	jmp	0x7932	; 0x7932 <OW_MasterTx_Command>
	}
}
    7adc:	df 91       	pop	r29
    7ade:	cf 91       	pop	r28
    7ae0:	1f 91       	pop	r17
    7ae2:	0f 91       	pop	r16
    7ae4:	ff 90       	pop	r15
    7ae6:	08 95       	ret

00007ae8 <OneWireReadTemp>:
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    7ae8:	8f 92       	push	r8
    7aea:	9f 92       	push	r9
    7aec:	af 92       	push	r10
    7aee:	bf 92       	push	r11
    7af0:	cf 92       	push	r12
    7af2:	df 92       	push	r13
    7af4:	ef 92       	push	r14
    7af6:	ff 92       	push	r15
    7af8:	1f 93       	push	r17
    7afa:	cf 93       	push	r28
    7afc:	df 93       	push	r29
    7afe:	18 2f       	mov	r17, r24
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    7b00:	c8 2f       	mov	r28, r24
    7b02:	d0 e0       	ldi	r29, 0x00	; 0
    7b04:	ce 01       	movw	r24, r28
    7b06:	83 5a       	subi	r24, 0xA3	; 163
    7b08:	9f 4f       	sbci	r25, 0xFF	; 255
    7b0a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    7b0e:	9e 01       	movw	r18, r28
    7b10:	2d 50       	subi	r18, 0x0D	; 13
    7b12:	36 4f       	sbci	r19, 0xF6	; 246
    7b14:	79 01       	movw	r14, r18
    7b16:	fe 01       	movw	r30, r28
    7b18:	e9 50       	subi	r30, 0x09	; 9
    7b1a:	fc 4f       	sbci	r31, 0xFC	; 252
    7b1c:	81 11       	cpse	r24, r1
    7b1e:	0c c0       	rjmp	.+24     	; 0x7b38 <OneWireReadTemp+0x50>
		Temperature[CH] = Therm_Off_Mark;
    7b20:	cc 0f       	add	r28, r28
    7b22:	dd 1f       	adc	r29, r29
    7b24:	ce 50       	subi	r28, 0x0E	; 14
    7b26:	da 4f       	sbci	r29, 0xFA	; 250
    7b28:	80 e0       	ldi	r24, 0x00	; 0
    7b2a:	90 e8       	ldi	r25, 0x80	; 128
    7b2c:	99 83       	std	Y+1, r25	; 0x01
    7b2e:	88 83       	st	Y, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    7b30:	d7 01       	movw	r26, r14
    7b32:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    7b34:	10 82       	st	Z, r1
		return;
    7b36:	a0 c0       	rjmp	.+320    	; 0x7c78 <OneWireReadTemp+0x190>
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    7b38:	d9 01       	movw	r26, r18
    7b3a:	8c 91       	ld	r24, X
    7b3c:	82 30       	cpi	r24, 0x02	; 2
    7b3e:	79 f4       	brne	.+30     	; 0x7b5e <OneWireReadTemp+0x76>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    7b40:	80 81       	ld	r24, Z
    7b42:	8a 30       	cpi	r24, 0x0A	; 10
    7b44:	48 f0       	brcs	.+18     	; 0x7b58 <OneWireReadTemp+0x70>
    7b46:	cc 0f       	add	r28, r28
    7b48:	dd 1f       	adc	r29, r29
    7b4a:	ce 50       	subi	r28, 0x0E	; 14
    7b4c:	da 4f       	sbci	r29, 0xFA	; 250
    7b4e:	81 e0       	ldi	r24, 0x01	; 1
    7b50:	90 e8       	ldi	r25, 0x80	; 128
    7b52:	99 83       	std	Y+1, r25	; 0x01
    7b54:	88 83       	st	Y, r24
    7b56:	90 c0       	rjmp	.+288    	; 0x7c78 <OneWireReadTemp+0x190>
		else DS18B20_Error[CH]++;
    7b58:	8f 5f       	subi	r24, 0xFF	; 255
    7b5a:	80 83       	st	Z, r24
    7b5c:	8d c0       	rjmp	.+282    	; 0x7c78 <OneWireReadTemp+0x190>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    7b5e:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7b60:	f8 94       	cli
    7b62:	81 2f       	mov	r24, r17
    7b64:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <OW_MasterPullLowBus>
    7b68:	78 94       	sei
	Delay_us(580);
    7b6a:	84 e4       	ldi	r24, 0x44	; 68
    7b6c:	92 e0       	ldi	r25, 0x02	; 2
    7b6e:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7b72:	f8 94       	cli
    7b74:	81 2f       	mov	r24, r17
    7b76:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    7b7a:	86 e4       	ldi	r24, 0x46	; 70
    7b7c:	90 e0       	ldi	r25, 0x00	; 0
    7b7e:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>
    7b82:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    7b86:	80 ff       	sbrs	r24, 0
    7b88:	03 c0       	rjmp	.+6      	; 0x7b90 <OneWireReadTemp+0xa8>
    7b8a:	82 e0       	ldi	r24, 0x02	; 2
    7b8c:	f7 01       	movw	r30, r14
    7b8e:	80 83       	st	Z, r24
	sei();
    7b90:	78 94       	sei
	Delay_us(510);
    7b92:	8e ef       	ldi	r24, 0xFE	; 254
    7b94:	91 e0       	ldi	r25, 0x01	; 1
    7b96:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7b9a:	d7 01       	movw	r26, r14
    7b9c:	8c 91       	ld	r24, X
    7b9e:	82 30       	cpi	r24, 0x02	; 2
    7ba0:	09 f4       	brne	.+2      	; 0x7ba4 <OneWireReadTemp+0xbc>
    7ba2:	6a c0       	rjmp	.+212    	; 0x7c78 <OneWireReadTemp+0x190>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7ba4:	6c ec       	ldi	r22, 0xCC	; 204
    7ba6:	81 2f       	mov	r24, r17
    7ba8:	0e 94 99 3c 	call	0x7932	; 0x7932 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    7bac:	6e eb       	ldi	r22, 0xBE	; 190
    7bae:	81 2f       	mov	r24, r17
    7bb0:	0e 94 99 3c 	call	0x7932	; 0x7932 <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    7bb4:	81 2f       	mov	r24, r17
    7bb6:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <OW_MasterRx_Data>
    7bba:	e8 2e       	mov	r14, r24
    7bbc:	f1 2c       	mov	r15, r1
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    7bbe:	81 2f       	mov	r24, r17
    7bc0:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <OW_MasterRx_Data>
    7bc4:	f8 2a       	or	r15, r24
		Tres = (Tres*10)/16;
    7bc6:	8a e0       	ldi	r24, 0x0A	; 10
    7bc8:	8e 9d       	mul	r24, r14
    7bca:	b0 01       	movw	r22, r0
    7bcc:	8f 9d       	mul	r24, r15
    7bce:	70 0d       	add	r23, r0
    7bd0:	11 24       	eor	r1, r1
    7bd2:	77 ff       	sbrs	r23, 7
    7bd4:	02 c0       	rjmp	.+4      	; 0x7bda <OneWireReadTemp+0xf2>
    7bd6:	61 5f       	subi	r22, 0xF1	; 241
    7bd8:	7f 4f       	sbci	r23, 0xFF	; 255
    7bda:	4b 01       	movw	r8, r22
    7bdc:	94 e0       	ldi	r25, 0x04	; 4
    7bde:	95 94       	asr	r9
    7be0:	87 94       	ror	r8
    7be2:	9a 95       	dec	r25
    7be4:	e1 f7       	brne	.-8      	; 0x7bde <OneWireReadTemp+0xf6>
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    7be6:	b2 e5       	ldi	r27, 0x52	; 82
    7be8:	8b 16       	cp	r8, r27
    7bea:	b3 e0       	ldi	r27, 0x03	; 3
    7bec:	9b 06       	cpc	r9, r27
    7bee:	b1 f1       	breq	.+108    	; 0x7c5c <OneWireReadTemp+0x174>
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    7bf0:	7e 01       	movw	r14, r28
    7bf2:	ee 0c       	add	r14, r14
    7bf4:	ff 1c       	adc	r15, r15
    7bf6:	ce 0d       	add	r28, r14
    7bf8:	df 1d       	adc	r29, r15
    7bfa:	ce 01       	movw	r24, r28
    7bfc:	86 5a       	subi	r24, 0xA6	; 166
    7bfe:	9f 4f       	sbci	r25, 0xFF	; 255
    7c00:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    7c04:	d8 2e       	mov	r13, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    7c06:	ce 01       	movw	r24, r28
    7c08:	85 5a       	subi	r24, 0xA5	; 165
    7c0a:	9f 4f       	sbci	r25, 0xFF	; 255
    7c0c:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    7c10:	5c 01       	movw	r10, r24
    7c12:	e7 01       	movw	r28, r14
    7c14:	ce 50       	subi	r28, 0x0E	; 14
    7c16:	da 4f       	sbci	r29, 0xFA	; 250
    7c18:	b4 01       	movw	r22, r8
    7c1a:	6d 0d       	add	r22, r13
    7c1c:	71 1d       	adc	r23, r1
    7c1e:	d7 fc       	sbrc	r13, 7
    7c20:	7a 95       	dec	r23
    7c22:	88 27       	eor	r24, r24
    7c24:	77 fd       	sbrc	r23, 7
    7c26:	80 95       	com	r24
    7c28:	98 2f       	mov	r25, r24
    7c2a:	0e 94 12 6e 	call	0xdc24	; 0xdc24 <__floatsisf>
    7c2e:	6b 01       	movw	r12, r22
    7c30:	7c 01       	movw	r14, r24
    7c32:	b5 01       	movw	r22, r10
    7c34:	80 e0       	ldi	r24, 0x00	; 0
    7c36:	90 e0       	ldi	r25, 0x00	; 0
    7c38:	0e 94 10 6e 	call	0xdc20	; 0xdc20 <__floatunsisf>
    7c3c:	20 e0       	ldi	r18, 0x00	; 0
    7c3e:	30 e0       	ldi	r19, 0x00	; 0
    7c40:	4a e7       	ldi	r20, 0x7A	; 122
    7c42:	54 e4       	ldi	r21, 0x44	; 68
    7c44:	0e 94 77 6d 	call	0xdaee	; 0xdaee <__divsf3>
    7c48:	9b 01       	movw	r18, r22
    7c4a:	ac 01       	movw	r20, r24
    7c4c:	c7 01       	movw	r24, r14
    7c4e:	b6 01       	movw	r22, r12
    7c50:	0e 94 9e 6e 	call	0xdd3c	; 0xdd3c <__mulsf3>
    7c54:	0e 94 df 6d 	call	0xdbbe	; 0xdbbe <__fixsfsi>
    7c58:	79 83       	std	Y+1, r23	; 0x01
    7c5a:	68 83       	st	Y, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    7c5c:	f8 94       	cli
    7c5e:	81 2f       	mov	r24, r17
    7c60:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <OW_MasterPullLowBus>
    7c64:	78 94       	sei
		Delay_us(580);	
    7c66:	84 e4       	ldi	r24, 0x44	; 68
    7c68:	92 e0       	ldi	r25, 0x02	; 2
    7c6a:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    7c6e:	f8 94       	cli
    7c70:	81 2f       	mov	r24, r17
    7c72:	0e 94 b9 2e 	call	0x5d72	; 0x5d72 <OW_MasterReleaseBus>
    7c76:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    7c78:	df 91       	pop	r29
    7c7a:	cf 91       	pop	r28
    7c7c:	1f 91       	pop	r17
    7c7e:	ff 90       	pop	r15
    7c80:	ef 90       	pop	r14
    7c82:	df 90       	pop	r13
    7c84:	cf 90       	pop	r12
    7c86:	bf 90       	pop	r11
    7c88:	af 90       	pop	r10
    7c8a:	9f 90       	pop	r9
    7c8c:	8f 90       	pop	r8
    7c8e:	08 95       	ret

00007c90 <DS18B20>:
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    7c90:	80 91 6b 09 	lds	r24, 0x096B
    7c94:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    7c98:	88 23       	and	r24, r24
    7c9a:	11 f1       	breq	.+68     	; 0x7ce0 <DS18B20+0x50>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    7c9c:	80 91 56 02 	lds	r24, 0x0256
    7ca0:	87 30       	cpi	r24, 0x07	; 7
    7ca2:	18 f0       	brcs	.+6      	; 0x7caa <DS18B20+0x1a>
    7ca4:	81 e0       	ldi	r24, 0x01	; 1
    7ca6:	80 93 56 02 	sts	0x0256, r24
		
			switch(DS18B20_Mode){
    7caa:	80 91 56 02 	lds	r24, 0x0256
    7cae:	81 30       	cpi	r24, 0x01	; 1
    7cb0:	39 f0       	breq	.+14     	; 0x7cc0 <DS18B20+0x30>
    7cb2:	84 30       	cpi	r24, 0x04	; 4
    7cb4:	81 f4       	brne	.+32     	; 0x7cd6 <DS18B20+0x46>
				StartTimer8(TD_DS18B20Read, 100);
				DS18B20_Mode = DS18B20_START_ADC3;
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    7cb6:	80 e0       	ldi	r24, 0x00	; 0
    7cb8:	0e 94 74 3d 	call	0x7ae8	; 0x7ae8 <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    7cbc:	86 e0       	ldi	r24, 0x06	; 6
    7cbe:	09 c0       	rjmp	.+18     	; 0x7cd2 <DS18B20+0x42>
			switch(DS18B20_Mode){
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    7cc0:	80 e0       	ldi	r24, 0x00	; 0
    7cc2:	0e 94 19 3d 	call	0x7a32	; 0x7a32 <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    7cc6:	64 e6       	ldi	r22, 0x64	; 100
    7cc8:	80 91 6b 09 	lds	r24, 0x096B
    7ccc:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    7cd0:	83 e0       	ldi	r24, 0x03	; 3
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
				DS18B20_Mode = DS18B20_READ_T3;
    7cd2:	80 93 56 02 	sts	0x0256, r24
				break;
			}
			DS18B20_Mode++;
    7cd6:	80 91 56 02 	lds	r24, 0x0256
    7cda:	8f 5f       	subi	r24, 0xFF	; 255
    7cdc:	80 93 56 02 	sts	0x0256, r24
    7ce0:	08 95       	ret

00007ce2 <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7ce2:	cf 93       	push	r28
    7ce4:	df 93       	push	r29
    7ce6:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7ce8:	ec 81       	ldd	r30, Y+4	; 0x04
    7cea:	fd 81       	ldd	r31, Y+5	; 0x05
    7cec:	65 91       	lpm	r22, Z+
    7cee:	74 91       	lpm	r23, Z
	strcpy_P(Param->Pos, prp(Param->Txt));
    7cf0:	88 81       	ld	r24, Y
    7cf2:	99 81       	ldd	r25, Y+1	; 0x01
    7cf4:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7cf8:	a8 81       	ld	r26, Y
    7cfa:	b9 81       	ldd	r27, Y+1	; 0x01
    7cfc:	fd 01       	movw	r30, r26
    7cfe:	01 90       	ld	r0, Z+
    7d00:	00 20       	and	r0, r0
    7d02:	e9 f7       	brne	.-6      	; 0x7cfe <PutEnum+0x1c>
    7d04:	31 97       	sbiw	r30, 0x01	; 1
    7d06:	4e 2f       	mov	r20, r30
    7d08:	4a 1b       	sub	r20, r26
    7d0a:	80 e0       	ldi	r24, 0x00	; 0
    7d0c:	90 e0       	ldi	r25, 0x00	; 0
    7d0e:	50 e2       	ldi	r21, 0x20	; 32
    7d10:	24 2f       	mov	r18, r20
    7d12:	28 0f       	add	r18, r24
    7d14:	01 96       	adiw	r24, 0x01	; 1
    7d16:	3b 81       	ldd	r19, Y+3	; 0x03
    7d18:	23 17       	cp	r18, r19
    7d1a:	30 f4       	brcc	.+12     	; 0x7d28 <PutEnum+0x46>
    7d1c:	e8 81       	ld	r30, Y
    7d1e:	f9 81       	ldd	r31, Y+1	; 0x01
    7d20:	e2 0f       	add	r30, r18
    7d22:	f1 1d       	adc	r31, r1
    7d24:	50 83       	st	Z, r21
    7d26:	f4 cf       	rjmp	.-24     	; 0x7d10 <PutEnum+0x2e>
}
    7d28:	df 91       	pop	r29
    7d2a:	cf 91       	pop	r28
    7d2c:	08 95       	ret

00007d2e <PutVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    7d2e:	cf 92       	push	r12
    7d30:	df 92       	push	r13
    7d32:	ef 92       	push	r14
    7d34:	ff 92       	push	r15
    7d36:	0f 93       	push	r16
    7d38:	1f 93       	push	r17
    7d3a:	cf 93       	push	r28
    7d3c:	df 93       	push	r29
    7d3e:	cd b7       	in	r28, 0x3d	; 61
    7d40:	de b7       	in	r29, 0x3e	; 62
    7d42:	29 97       	sbiw	r28, 0x09	; 9
    7d44:	0f b6       	in	r0, 0x3f	; 63
    7d46:	f8 94       	cli
    7d48:	de bf       	out	0x3e, r29	; 62
    7d4a:	0f be       	out	0x3f, r0	; 63
    7d4c:	cd bf       	out	0x3d, r28	; 61
    7d4e:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7d50:	67 37       	cpi	r22, 0x77	; 119
    7d52:	19 f4       	brne	.+6      	; 0x7d5a <PutVal+0x2c>
    7d54:	8f ef       	ldi	r24, 0xFF	; 255
    7d56:	9f ef       	ldi	r25, 0xFF	; 255
    7d58:	02 c0       	rjmp	.+4      	; 0x7d5e <PutVal+0x30>
    7d5a:	8f ef       	ldi	r24, 0xFF	; 255
    7d5c:	90 e0       	ldi	r25, 0x00	; 0
    7d5e:	8e 19       	sub	r24, r14
    7d60:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7d62:	fa 01       	movw	r30, r20
    7d64:	24 81       	ldd	r18, Z+4	; 0x04
    7d66:	35 81       	ldd	r19, Z+5	; 0x05
    7d68:	21 15       	cp	r18, r1
    7d6a:	31 05       	cpc	r19, r1
    7d6c:	69 f0       	breq	.+26     	; 0x7d88 <PutVal+0x5a>
    7d6e:	82 30       	cpi	r24, 0x02	; 2
    7d70:	91 05       	cpc	r25, r1
    7d72:	50 f4       	brcc	.+20     	; 0x7d88 <PutVal+0x5a>
		Param->Txt += Idx;
    7d74:	88 0f       	add	r24, r24
    7d76:	99 1f       	adc	r25, r25
    7d78:	82 0f       	add	r24, r18
    7d7a:	93 1f       	adc	r25, r19
    7d7c:	95 83       	std	Z+5, r25	; 0x05
    7d7e:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7d80:	ca 01       	movw	r24, r20
    7d82:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
    7d86:	3f c0       	rjmp	.+126    	; 0x7e06 <PutVal+0xd8>
		return;
	}
	char Format[] = "% u.%. u";
    7d88:	89 e0       	ldi	r24, 0x09	; 9
    7d8a:	e3 e1       	ldi	r30, 0x13	; 19
    7d8c:	f1 e0       	ldi	r31, 0x01	; 1
    7d8e:	8e 01       	movw	r16, r28
    7d90:	0f 5f       	subi	r16, 0xFF	; 255
    7d92:	1f 4f       	sbci	r17, 0xFF	; 255
    7d94:	d8 01       	movw	r26, r16
    7d96:	01 90       	ld	r0, Z+
    7d98:	0d 92       	st	X+, r0
    7d9a:	8a 95       	dec	r24
    7d9c:	e1 f7       	brne	.-8      	; 0x7d96 <PutVal+0x68>
	Format[1] = '0'+Param->Size;
    7d9e:	fa 01       	movw	r30, r20
    7da0:	93 81       	ldd	r25, Z+3	; 0x03
    7da2:	90 5d       	subi	r25, 0xD0	; 208
    7da4:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    7da6:	82 81       	ldd	r24, Z+2	; 0x02
    7da8:	c1 80       	ldd	r12, Z+1	; 0x01
    7daa:	d0 80       	ld	r13, Z
    7dac:	88 23       	and	r24, r24
    7dae:	e1 f0       	breq	.+56     	; 0x7de8 <PutVal+0xba>
		Format[1] -= Param->Prec+1;
    7db0:	98 1b       	sub	r25, r24
    7db2:	91 50       	subi	r25, 0x01	; 1
    7db4:	9a 83       	std	Y+2, r25	; 0x02
		Format[6] = '0'+Param->Prec;
    7db6:	90 e3       	ldi	r25, 0x30	; 48
    7db8:	98 0f       	add	r25, r24
    7dba:	9f 83       	std	Y+7, r25	; 0x07
		uint16_t Div=Pow10(Param->Prec);
    7dbc:	0e 94 7c 3c 	call	0x78f8	; 0x78f8 <Pow10>
    7dc0:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7dc2:	c7 01       	movw	r24, r14
    7dc4:	0e 94 2c 75 	call	0xea58	; 0xea58 <__udivmodhi4>
    7dc8:	9f 93       	push	r25
    7dca:	8f 93       	push	r24
    7dcc:	7f 93       	push	r23
    7dce:	6f 93       	push	r22
    7dd0:	1f 93       	push	r17
    7dd2:	0f 93       	push	r16
    7dd4:	cf 92       	push	r12
    7dd6:	df 92       	push	r13
    7dd8:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    7ddc:	0f b6       	in	r0, 0x3f	; 63
    7dde:	f8 94       	cli
    7de0:	de bf       	out	0x3e, r29	; 62
    7de2:	0f be       	out	0x3f, r0	; 63
    7de4:	cd bf       	out	0x3d, r28	; 61
    7de6:	0f c0       	rjmp	.+30     	; 0x7e06 <PutVal+0xd8>
	}
	else {
		Format[3] = '\0';
    7de8:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    7dea:	ff 92       	push	r15
    7dec:	ef 92       	push	r14
    7dee:	1f 93       	push	r17
    7df0:	0f 93       	push	r16
    7df2:	cf 92       	push	r12
    7df4:	df 92       	push	r13
    7df6:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    7dfa:	0f 90       	pop	r0
    7dfc:	0f 90       	pop	r0
    7dfe:	0f 90       	pop	r0
    7e00:	0f 90       	pop	r0
    7e02:	0f 90       	pop	r0
    7e04:	0f 90       	pop	r0
	}
}
    7e06:	29 96       	adiw	r28, 0x09	; 9
    7e08:	0f b6       	in	r0, 0x3f	; 63
    7e0a:	f8 94       	cli
    7e0c:	de bf       	out	0x3e, r29	; 62
    7e0e:	0f be       	out	0x3f, r0	; 63
    7e10:	cd bf       	out	0x3d, r28	; 61
    7e12:	df 91       	pop	r29
    7e14:	cf 91       	pop	r28
    7e16:	1f 91       	pop	r17
    7e18:	0f 91       	pop	r16
    7e1a:	ff 90       	pop	r15
    7e1c:	ef 90       	pop	r14
    7e1e:	df 90       	pop	r13
    7e20:	cf 90       	pop	r12
    7e22:	08 95       	ret

00007e24 <Put_sVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    7e24:	af 92       	push	r10
    7e26:	bf 92       	push	r11
    7e28:	cf 92       	push	r12
    7e2a:	df 92       	push	r13
    7e2c:	ef 92       	push	r14
    7e2e:	ff 92       	push	r15
    7e30:	0f 93       	push	r16
    7e32:	1f 93       	push	r17
    7e34:	cf 93       	push	r28
    7e36:	df 93       	push	r29
    7e38:	cd b7       	in	r28, 0x3d	; 61
    7e3a:	de b7       	in	r29, 0x3e	; 62
    7e3c:	2a 97       	sbiw	r28, 0x0a	; 10
    7e3e:	0f b6       	in	r0, 0x3f	; 63
    7e40:	f8 94       	cli
    7e42:	de bf       	out	0x3e, r29	; 62
    7e44:	0f be       	out	0x3f, r0	; 63
    7e46:	cd bf       	out	0x3d, r28	; 61
    7e48:	7c 01       	movw	r14, r24
    7e4a:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    7e4c:	67 37       	cpi	r22, 0x77	; 119
    7e4e:	19 f4       	brne	.+6      	; 0x7e56 <Put_sVal+0x32>
    7e50:	80 e0       	ldi	r24, 0x00	; 0
    7e52:	90 e8       	ldi	r25, 0x80	; 128
    7e54:	02 c0       	rjmp	.+4      	; 0x7e5a <Put_sVal+0x36>
    7e56:	80 e8       	ldi	r24, 0x80	; 128
    7e58:	90 e0       	ldi	r25, 0x00	; 0
    7e5a:	8e 0d       	add	r24, r14
    7e5c:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    7e5e:	d8 01       	movw	r26, r16
    7e60:	14 96       	adiw	r26, 0x04	; 4
    7e62:	2d 91       	ld	r18, X+
    7e64:	3c 91       	ld	r19, X
    7e66:	15 97       	sbiw	r26, 0x05	; 5
    7e68:	21 15       	cp	r18, r1
    7e6a:	31 05       	cpc	r19, r1
    7e6c:	79 f0       	breq	.+30     	; 0x7e8c <Put_sVal+0x68>
    7e6e:	82 30       	cpi	r24, 0x02	; 2
    7e70:	91 05       	cpc	r25, r1
    7e72:	60 f4       	brcc	.+24     	; 0x7e8c <Put_sVal+0x68>
		Param->Txt += Idx;
    7e74:	88 0f       	add	r24, r24
    7e76:	99 1f       	adc	r25, r25
    7e78:	82 0f       	add	r24, r18
    7e7a:	93 1f       	adc	r25, r19
    7e7c:	15 96       	adiw	r26, 0x05	; 5
    7e7e:	9c 93       	st	X, r25
    7e80:	8e 93       	st	-X, r24
    7e82:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    7e84:	c8 01       	movw	r24, r16
    7e86:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
    7e8a:	65 c0       	rjmp	.+202    	; 0x7f56 <Put_sVal+0x132>
		return;
	}
	char Format[] = "%+ d.%. u";
    7e8c:	8a e0       	ldi	r24, 0x0A	; 10
    7e8e:	ec e1       	ldi	r30, 0x1C	; 28
    7e90:	f1 e0       	ldi	r31, 0x01	; 1
    7e92:	9e 01       	movw	r18, r28
    7e94:	2f 5f       	subi	r18, 0xFF	; 255
    7e96:	3f 4f       	sbci	r19, 0xFF	; 255
    7e98:	69 01       	movw	r12, r18
    7e9a:	d9 01       	movw	r26, r18
    7e9c:	01 90       	ld	r0, Z+
    7e9e:	0d 92       	st	X+, r0
    7ea0:	8a 95       	dec	r24
    7ea2:	e1 f7       	brne	.-8      	; 0x7e9c <Put_sVal+0x78>
	if(Val==0)
    7ea4:	e1 14       	cp	r14, r1
    7ea6:	f1 04       	cpc	r15, r1
    7ea8:	11 f4       	brne	.+4      	; 0x7eae <Put_sVal+0x8a>
		Format[1] = ' ';
    7eaa:	80 e2       	ldi	r24, 0x20	; 32
    7eac:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    7eae:	d8 01       	movw	r26, r16
    7eb0:	13 96       	adiw	r26, 0x03	; 3
    7eb2:	9c 91       	ld	r25, X
    7eb4:	13 97       	sbiw	r26, 0x03	; 3
    7eb6:	90 5d       	subi	r25, 0xD0	; 208
    7eb8:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7eba:	12 96       	adiw	r26, 0x02	; 2
    7ebc:	8c 91       	ld	r24, X
    7ebe:	12 97       	sbiw	r26, 0x02	; 2
    7ec0:	11 96       	adiw	r26, 0x01	; 1
    7ec2:	ac 90       	ld	r10, X
    7ec4:	11 97       	sbiw	r26, 0x01	; 1
    7ec6:	bc 90       	ld	r11, X
    7ec8:	88 23       	and	r24, r24
    7eca:	b1 f1       	breq	.+108    	; 0x7f38 <Put_sVal+0x114>
		Format[2] -= Param->Prec+1;
    7ecc:	98 1b       	sub	r25, r24
    7ece:	91 50       	subi	r25, 0x01	; 1
    7ed0:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7ed2:	90 e3       	ldi	r25, 0x30	; 48
    7ed4:	98 0f       	add	r25, r24
    7ed6:	98 87       	std	Y+8, r25	; 0x08
		int16_t Div=Pow10(Param->Prec);
    7ed8:	0e 94 7c 3c 	call	0x78f8	; 0x78f8 <Pow10>
    7edc:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    7ede:	c7 01       	movw	r24, r14
    7ee0:	f7 fe       	sbrs	r15, 7
    7ee2:	04 c0       	rjmp	.+8      	; 0x7eec <Put_sVal+0xc8>
    7ee4:	88 27       	eor	r24, r24
    7ee6:	99 27       	eor	r25, r25
    7ee8:	8e 19       	sub	r24, r14
    7eea:	9f 09       	sbc	r25, r15
    7eec:	b9 01       	movw	r22, r18
    7eee:	0e 94 2c 75 	call	0xea58	; 0xea58 <__udivmodhi4>
    7ef2:	9f 93       	push	r25
    7ef4:	8f 93       	push	r24
    7ef6:	c7 01       	movw	r24, r14
    7ef8:	b9 01       	movw	r22, r18
    7efa:	0e 94 40 75 	call	0xea80	; 0xea80 <__divmodhi4>
    7efe:	7f 93       	push	r23
    7f00:	6f 93       	push	r22
    7f02:	df 92       	push	r13
    7f04:	cf 92       	push	r12
    7f06:	af 92       	push	r10
    7f08:	bf 92       	push	r11
    7f0a:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
		if(Val<0) {
    7f0e:	0f b6       	in	r0, 0x3f	; 63
    7f10:	f8 94       	cli
    7f12:	de bf       	out	0x3e, r29	; 62
    7f14:	0f be       	out	0x3f, r0	; 63
    7f16:	cd bf       	out	0x3d, r28	; 61
    7f18:	f7 fe       	sbrs	r15, 7
    7f1a:	1d c0       	rjmp	.+58     	; 0x7f56 <Put_sVal+0x132>
			while(*Param->Pos==' ')
    7f1c:	d8 01       	movw	r26, r16
    7f1e:	ed 91       	ld	r30, X+
    7f20:	fc 91       	ld	r31, X
    7f22:	80 81       	ld	r24, Z
    7f24:	80 32       	cpi	r24, 0x20	; 32
    7f26:	29 f4       	brne	.+10     	; 0x7f32 <Put_sVal+0x10e>
				Param->Pos++;
    7f28:	31 96       	adiw	r30, 0x01	; 1
    7f2a:	d8 01       	movw	r26, r16
    7f2c:	ed 93       	st	X+, r30
    7f2e:	fc 93       	st	X, r31
    7f30:	f5 cf       	rjmp	.-22     	; 0x7f1c <Put_sVal+0xf8>
			*Param->Pos = '-';
    7f32:	8d e2       	ldi	r24, 0x2D	; 45
    7f34:	80 83       	st	Z, r24
    7f36:	0f c0       	rjmp	.+30     	; 0x7f56 <Put_sVal+0x132>
		}
	}
	else {
		Format[4] = '\0';
    7f38:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7f3a:	ff 92       	push	r15
    7f3c:	ef 92       	push	r14
    7f3e:	df 92       	push	r13
    7f40:	cf 92       	push	r12
    7f42:	af 92       	push	r10
    7f44:	bf 92       	push	r11
    7f46:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    7f4a:	0f 90       	pop	r0
    7f4c:	0f 90       	pop	r0
    7f4e:	0f 90       	pop	r0
    7f50:	0f 90       	pop	r0
    7f52:	0f 90       	pop	r0
    7f54:	0f 90       	pop	r0
	}
}
    7f56:	2a 96       	adiw	r28, 0x0a	; 10
    7f58:	0f b6       	in	r0, 0x3f	; 63
    7f5a:	f8 94       	cli
    7f5c:	de bf       	out	0x3e, r29	; 62
    7f5e:	0f be       	out	0x3f, r0	; 63
    7f60:	cd bf       	out	0x3d, r28	; 61
    7f62:	df 91       	pop	r29
    7f64:	cf 91       	pop	r28
    7f66:	1f 91       	pop	r17
    7f68:	0f 91       	pop	r16
    7f6a:	ff 90       	pop	r15
    7f6c:	ef 90       	pop	r14
    7f6e:	df 90       	pop	r13
    7f70:	cf 90       	pop	r12
    7f72:	bf 90       	pop	r11
    7f74:	af 90       	pop	r10
    7f76:	08 95       	ret

00007f78 <Put_zVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    7f78:	cf 92       	push	r12
    7f7a:	df 92       	push	r13
    7f7c:	ef 92       	push	r14
    7f7e:	ff 92       	push	r15
    7f80:	0f 93       	push	r16
    7f82:	1f 93       	push	r17
    7f84:	cf 93       	push	r28
    7f86:	df 93       	push	r29
    7f88:	cd b7       	in	r28, 0x3d	; 61
    7f8a:	de b7       	in	r29, 0x3e	; 62
    7f8c:	2a 97       	sbiw	r28, 0x0a	; 10
    7f8e:	0f b6       	in	r0, 0x3f	; 63
    7f90:	f8 94       	cli
    7f92:	de bf       	out	0x3e, r29	; 62
    7f94:	0f be       	out	0x3f, r0	; 63
    7f96:	cd bf       	out	0x3d, r28	; 61
    7f98:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7f9a:	67 37       	cpi	r22, 0x77	; 119
    7f9c:	19 f4       	brne	.+6      	; 0x7fa4 <Put_zVal+0x2c>
    7f9e:	8f ef       	ldi	r24, 0xFF	; 255
    7fa0:	9f ef       	ldi	r25, 0xFF	; 255
    7fa2:	02 c0       	rjmp	.+4      	; 0x7fa8 <Put_zVal+0x30>
    7fa4:	8f ef       	ldi	r24, 0xFF	; 255
    7fa6:	90 e0       	ldi	r25, 0x00	; 0
    7fa8:	8e 19       	sub	r24, r14
    7faa:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7fac:	fa 01       	movw	r30, r20
    7fae:	24 81       	ldd	r18, Z+4	; 0x04
    7fb0:	35 81       	ldd	r19, Z+5	; 0x05
    7fb2:	21 15       	cp	r18, r1
    7fb4:	31 05       	cpc	r19, r1
    7fb6:	69 f0       	breq	.+26     	; 0x7fd2 <Put_zVal+0x5a>
    7fb8:	82 30       	cpi	r24, 0x02	; 2
    7fba:	91 05       	cpc	r25, r1
    7fbc:	50 f4       	brcc	.+20     	; 0x7fd2 <Put_zVal+0x5a>
		Param->Txt += Idx;
    7fbe:	88 0f       	add	r24, r24
    7fc0:	99 1f       	adc	r25, r25
    7fc2:	82 0f       	add	r24, r18
    7fc4:	93 1f       	adc	r25, r19
    7fc6:	95 83       	std	Z+5, r25	; 0x05
    7fc8:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7fca:	ca 01       	movw	r24, r20
    7fcc:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
    7fd0:	3f c0       	rjmp	.+126    	; 0x8050 <Put_zVal+0xd8>
		return;
	}
	char Format[] = "%0 u.%. u";
    7fd2:	8a e0       	ldi	r24, 0x0A	; 10
    7fd4:	e6 e2       	ldi	r30, 0x26	; 38
    7fd6:	f1 e0       	ldi	r31, 0x01	; 1
    7fd8:	8e 01       	movw	r16, r28
    7fda:	0f 5f       	subi	r16, 0xFF	; 255
    7fdc:	1f 4f       	sbci	r17, 0xFF	; 255
    7fde:	d8 01       	movw	r26, r16
    7fe0:	01 90       	ld	r0, Z+
    7fe2:	0d 92       	st	X+, r0
    7fe4:	8a 95       	dec	r24
    7fe6:	e1 f7       	brne	.-8      	; 0x7fe0 <Put_zVal+0x68>
	Format[2] = '0'+Param->Size;
    7fe8:	fa 01       	movw	r30, r20
    7fea:	93 81       	ldd	r25, Z+3	; 0x03
    7fec:	90 5d       	subi	r25, 0xD0	; 208
    7fee:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7ff0:	82 81       	ldd	r24, Z+2	; 0x02
    7ff2:	c1 80       	ldd	r12, Z+1	; 0x01
    7ff4:	d0 80       	ld	r13, Z
    7ff6:	88 23       	and	r24, r24
    7ff8:	e1 f0       	breq	.+56     	; 0x8032 <Put_zVal+0xba>
		Format[2] -= Param->Prec+1;
    7ffa:	98 1b       	sub	r25, r24
    7ffc:	91 50       	subi	r25, 0x01	; 1
    7ffe:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    8000:	90 e3       	ldi	r25, 0x30	; 48
    8002:	98 0f       	add	r25, r24
    8004:	98 87       	std	Y+8, r25	; 0x08
		uint16_t Div=Pow10(Param->Prec);
    8006:	0e 94 7c 3c 	call	0x78f8	; 0x78f8 <Pow10>
    800a:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    800c:	c7 01       	movw	r24, r14
    800e:	0e 94 2c 75 	call	0xea58	; 0xea58 <__udivmodhi4>
    8012:	9f 93       	push	r25
    8014:	8f 93       	push	r24
    8016:	7f 93       	push	r23
    8018:	6f 93       	push	r22
    801a:	1f 93       	push	r17
    801c:	0f 93       	push	r16
    801e:	cf 92       	push	r12
    8020:	df 92       	push	r13
    8022:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    8026:	0f b6       	in	r0, 0x3f	; 63
    8028:	f8 94       	cli
    802a:	de bf       	out	0x3e, r29	; 62
    802c:	0f be       	out	0x3f, r0	; 63
    802e:	cd bf       	out	0x3d, r28	; 61
    8030:	0f c0       	rjmp	.+30     	; 0x8050 <Put_zVal+0xd8>
	}
	else {
		Format[4] = '\0';
    8032:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8034:	ff 92       	push	r15
    8036:	ef 92       	push	r14
    8038:	1f 93       	push	r17
    803a:	0f 93       	push	r16
    803c:	cf 92       	push	r12
    803e:	df 92       	push	r13
    8040:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    8044:	0f 90       	pop	r0
    8046:	0f 90       	pop	r0
    8048:	0f 90       	pop	r0
    804a:	0f 90       	pop	r0
    804c:	0f 90       	pop	r0
    804e:	0f 90       	pop	r0
	}
}
    8050:	2a 96       	adiw	r28, 0x0a	; 10
    8052:	0f b6       	in	r0, 0x3f	; 63
    8054:	f8 94       	cli
    8056:	de bf       	out	0x3e, r29	; 62
    8058:	0f be       	out	0x3f, r0	; 63
    805a:	cd bf       	out	0x3d, r28	; 61
    805c:	df 91       	pop	r29
    805e:	cf 91       	pop	r28
    8060:	1f 91       	pop	r17
    8062:	0f 91       	pop	r16
    8064:	ff 90       	pop	r15
    8066:	ef 90       	pop	r14
    8068:	df 90       	pop	r13
    806a:	cf 90       	pop	r12
    806c:	08 95       	ret

0000806e <Put_zVal_h>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    806e:	f9 01       	movw	r30, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8070:	42 36       	cpi	r20, 0x62	; 98
    8072:	29 f4       	brne	.+10     	; 0x807e <Put_zVal_h+0x10>
    8074:	1f 92       	push	r1
    8076:	6f 93       	push	r22
    8078:	80 e3       	ldi	r24, 0x30	; 48
    807a:	91 e0       	ldi	r25, 0x01	; 1
    807c:	06 c0       	rjmp	.+12     	; 0x808a <Put_zVal_h+0x1c>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    807e:	47 37       	cpi	r20, 0x77	; 119
    8080:	99 f4       	brne	.+38     	; 0x80a8 <Put_zVal_h+0x3a>
    8082:	7f 93       	push	r23
    8084:	6f 93       	push	r22
    8086:	86 e3       	ldi	r24, 0x36	; 54
    8088:	91 e0       	ldi	r25, 0x01	; 1
    808a:	9f 93       	push	r25
    808c:	8f 93       	push	r24
    808e:	81 81       	ldd	r24, Z+1	; 0x01
    8090:	8f 93       	push	r24
    8092:	80 81       	ld	r24, Z
    8094:	8f 93       	push	r24
    8096:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    809a:	0f 90       	pop	r0
    809c:	0f 90       	pop	r0
    809e:	0f 90       	pop	r0
    80a0:	0f 90       	pop	r0
    80a2:	0f 90       	pop	r0
    80a4:	0f 90       	pop	r0
    80a6:	08 95       	ret
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    80a8:	4c 36       	cpi	r20, 0x6C	; 108
    80aa:	b1 f4       	brne	.+44     	; 0x80d8 <Put_zVal_h+0x6a>
    80ac:	9f 93       	push	r25
    80ae:	8f 93       	push	r24
    80b0:	7f 93       	push	r23
    80b2:	6f 93       	push	r22
    80b4:	8b e3       	ldi	r24, 0x3B	; 59
    80b6:	91 e0       	ldi	r25, 0x01	; 1
    80b8:	9f 93       	push	r25
    80ba:	8f 93       	push	r24
    80bc:	81 81       	ldd	r24, Z+1	; 0x01
    80be:	8f 93       	push	r24
    80c0:	80 81       	ld	r24, Z
    80c2:	8f 93       	push	r24
    80c4:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    80c8:	8d b7       	in	r24, 0x3d	; 61
    80ca:	9e b7       	in	r25, 0x3e	; 62
    80cc:	08 96       	adiw	r24, 0x08	; 8
    80ce:	0f b6       	in	r0, 0x3f	; 63
    80d0:	f8 94       	cli
    80d2:	9e bf       	out	0x3e, r25	; 62
    80d4:	0f be       	out	0x3f, r0	; 63
    80d6:	8d bf       	out	0x3d, r24	; 61
    80d8:	08 95       	ret

000080da <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    80da:	af 92       	push	r10
    80dc:	bf 92       	push	r11
    80de:	cf 92       	push	r12
    80e0:	df 92       	push	r13
    80e2:	ef 92       	push	r14
    80e4:	ff 92       	push	r15
    80e6:	0f 93       	push	r16
    80e8:	1f 93       	push	r17
    80ea:	cf 93       	push	r28
    80ec:	df 93       	push	r29
    80ee:	cd b7       	in	r28, 0x3d	; 61
    80f0:	de b7       	in	r29, 0x3e	; 62
    80f2:	2b 97       	sbiw	r28, 0x0b	; 11
    80f4:	0f b6       	in	r0, 0x3f	; 63
    80f6:	f8 94       	cli
    80f8:	de bf       	out	0x3e, r29	; 62
    80fa:	0f be       	out	0x3f, r0	; 63
    80fc:	cd bf       	out	0x3d, r28	; 61
    80fe:	6b 01       	movw	r12, r22
    8100:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    8102:	8b 01       	movw	r16, r22
    8104:	9c 01       	movw	r18, r24
    8106:	00 95       	com	r16
    8108:	10 95       	com	r17
    810a:	20 95       	com	r18
    810c:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    810e:	fa 01       	movw	r30, r20
    8110:	84 81       	ldd	r24, Z+4	; 0x04
    8112:	95 81       	ldd	r25, Z+5	; 0x05
    8114:	00 97       	sbiw	r24, 0x00	; 0
    8116:	79 f0       	breq	.+30     	; 0x8136 <PutDVal+0x5c>
    8118:	02 30       	cpi	r16, 0x02	; 2
    811a:	11 05       	cpc	r17, r1
    811c:	21 05       	cpc	r18, r1
    811e:	31 05       	cpc	r19, r1
    8120:	50 f4       	brcc	.+20     	; 0x8136 <PutDVal+0x5c>
		Param->Txt += Idx;
    8122:	00 0f       	add	r16, r16
    8124:	11 1f       	adc	r17, r17
    8126:	08 0f       	add	r16, r24
    8128:	19 1f       	adc	r17, r25
    812a:	15 83       	std	Z+5, r17	; 0x05
    812c:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    812e:	ca 01       	movw	r24, r20
    8130:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
		return;
    8134:	54 c0       	rjmp	.+168    	; 0x81de <PutDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    8136:	fa 01       	movw	r30, r20
    8138:	93 81       	ldd	r25, Z+3	; 0x03
    813a:	9a 30       	cpi	r25, 0x0A	; 10
    813c:	81 f4       	brne	.+32     	; 0x815e <PutDVal+0x84>
    813e:	82 81       	ldd	r24, Z+2	; 0x02
    8140:	81 11       	cpse	r24, r1
    8142:	0d c0       	rjmp	.+26     	; 0x815e <PutDVal+0x84>
		sprintf(Param->Pos, "%10lu", Val);
    8144:	ff 92       	push	r15
    8146:	ef 92       	push	r14
    8148:	df 92       	push	r13
    814a:	cf 92       	push	r12
    814c:	81 e4       	ldi	r24, 0x41	; 65
    814e:	91 e0       	ldi	r25, 0x01	; 1
    8150:	9f 93       	push	r25
    8152:	8f 93       	push	r24
    8154:	81 81       	ldd	r24, Z+1	; 0x01
    8156:	8f 93       	push	r24
    8158:	80 81       	ld	r24, Z
    815a:	8f 93       	push	r24
    815c:	39 c0       	rjmp	.+114    	; 0x81d0 <PutDVal+0xf6>
		return;
	}
	char Format[] = "% lu.%. lu";
    815e:	8b e0       	ldi	r24, 0x0B	; 11
    8160:	e7 e4       	ldi	r30, 0x47	; 71
    8162:	f1 e0       	ldi	r31, 0x01	; 1
    8164:	8e 01       	movw	r16, r28
    8166:	0f 5f       	subi	r16, 0xFF	; 255
    8168:	1f 4f       	sbci	r17, 0xFF	; 255
    816a:	d8 01       	movw	r26, r16
    816c:	01 90       	ld	r0, Z+
    816e:	0d 92       	st	X+, r0
    8170:	8a 95       	dec	r24
    8172:	e1 f7       	brne	.-8      	; 0x816c <PutDVal+0x92>
	Format[1] = '0'+Param->Size;
    8174:	90 5d       	subi	r25, 0xD0	; 208
    8176:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    8178:	fa 01       	movw	r30, r20
    817a:	82 81       	ldd	r24, Z+2	; 0x02
    817c:	a1 80       	ldd	r10, Z+1	; 0x01
    817e:	b0 80       	ld	r11, Z
    8180:	88 23       	and	r24, r24
    8182:	e9 f0       	breq	.+58     	; 0x81be <PutDVal+0xe4>
		Format[1] -= Param->Prec+1;
    8184:	98 1b       	sub	r25, r24
    8186:	91 50       	subi	r25, 0x01	; 1
    8188:	9a 83       	std	Y+2, r25	; 0x02
		Format[7] = '0'+Param->Prec;
    818a:	90 e3       	ldi	r25, 0x30	; 48
    818c:	98 0f       	add	r25, r24
    818e:	98 87       	std	Y+8, r25	; 0x08
		uint32_t Div=PowL10(Param->Prec);
    8190:	0e 94 8a 3c 	call	0x7914	; 0x7914 <PowL10>
    8194:	9b 01       	movw	r18, r22
    8196:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8198:	c7 01       	movw	r24, r14
    819a:	b6 01       	movw	r22, r12
    819c:	0e 94 54 75 	call	0xeaa8	; 0xeaa8 <__udivmodsi4>
    81a0:	9f 93       	push	r25
    81a2:	8f 93       	push	r24
    81a4:	7f 93       	push	r23
    81a6:	6f 93       	push	r22
    81a8:	5f 93       	push	r21
    81aa:	4f 93       	push	r20
    81ac:	3f 93       	push	r19
    81ae:	2f 93       	push	r18
    81b0:	1f 93       	push	r17
    81b2:	0f 93       	push	r16
    81b4:	af 92       	push	r10
    81b6:	bf 92       	push	r11
    81b8:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    81bc:	0b c0       	rjmp	.+22     	; 0x81d4 <PutDVal+0xfa>
	}
	else {
		Format[4] = '\0';
    81be:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    81c0:	ff 92       	push	r15
    81c2:	ef 92       	push	r14
    81c4:	df 92       	push	r13
    81c6:	cf 92       	push	r12
    81c8:	1f 93       	push	r17
    81ca:	0f 93       	push	r16
    81cc:	af 92       	push	r10
    81ce:	bf 92       	push	r11
    81d0:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    81d4:	0f b6       	in	r0, 0x3f	; 63
    81d6:	f8 94       	cli
    81d8:	de bf       	out	0x3e, r29	; 62
    81da:	0f be       	out	0x3f, r0	; 63
    81dc:	cd bf       	out	0x3d, r28	; 61
	}
}
    81de:	2b 96       	adiw	r28, 0x0b	; 11
    81e0:	0f b6       	in	r0, 0x3f	; 63
    81e2:	f8 94       	cli
    81e4:	de bf       	out	0x3e, r29	; 62
    81e6:	0f be       	out	0x3f, r0	; 63
    81e8:	cd bf       	out	0x3d, r28	; 61
    81ea:	df 91       	pop	r29
    81ec:	cf 91       	pop	r28
    81ee:	1f 91       	pop	r17
    81f0:	0f 91       	pop	r16
    81f2:	ff 90       	pop	r15
    81f4:	ef 90       	pop	r14
    81f6:	df 90       	pop	r13
    81f8:	cf 90       	pop	r12
    81fa:	bf 90       	pop	r11
    81fc:	af 90       	pop	r10
    81fe:	08 95       	ret

00008200 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8200:	af 92       	push	r10
    8202:	bf 92       	push	r11
    8204:	cf 92       	push	r12
    8206:	df 92       	push	r13
    8208:	ef 92       	push	r14
    820a:	ff 92       	push	r15
    820c:	0f 93       	push	r16
    820e:	1f 93       	push	r17
    8210:	cf 93       	push	r28
    8212:	df 93       	push	r29
    8214:	cd b7       	in	r28, 0x3d	; 61
    8216:	de b7       	in	r29, 0x3e	; 62
    8218:	27 97       	sbiw	r28, 0x07	; 7
    821a:	0f b6       	in	r0, 0x3f	; 63
    821c:	f8 94       	cli
    821e:	de bf       	out	0x3e, r29	; 62
    8220:	0f be       	out	0x3f, r0	; 63
    8222:	cd bf       	out	0x3d, r28	; 61
    8224:	6b 01       	movw	r12, r22
    8226:	7c 01       	movw	r14, r24
    8228:	5a 01       	movw	r10, r20
	uint32_t Idx = 0x80000000+Val;
    822a:	8b 01       	movw	r16, r22
    822c:	9c 01       	movw	r18, r24
    822e:	30 58       	subi	r19, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8230:	da 01       	movw	r26, r20
    8232:	14 96       	adiw	r26, 0x04	; 4
    8234:	8d 91       	ld	r24, X+
    8236:	9c 91       	ld	r25, X
    8238:	15 97       	sbiw	r26, 0x05	; 5
    823a:	00 97       	sbiw	r24, 0x00	; 0
    823c:	89 f0       	breq	.+34     	; 0x8260 <Put_sDVal+0x60>
    823e:	02 30       	cpi	r16, 0x02	; 2
    8240:	11 05       	cpc	r17, r1
    8242:	21 05       	cpc	r18, r1
    8244:	31 05       	cpc	r19, r1
    8246:	60 f4       	brcc	.+24     	; 0x8260 <Put_sDVal+0x60>
		Param->Txt += Idx;
    8248:	00 0f       	add	r16, r16
    824a:	11 1f       	adc	r17, r17
    824c:	08 0f       	add	r16, r24
    824e:	19 1f       	adc	r17, r25
    8250:	15 96       	adiw	r26, 0x05	; 5
    8252:	1c 93       	st	X, r17
    8254:	0e 93       	st	-X, r16
    8256:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    8258:	ca 01       	movw	r24, r20
    825a:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
		return;
    825e:	b7 c0       	rjmp	.+366    	; 0x83ce <Put_sDVal+0x1ce>
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8260:	f5 01       	movw	r30, r10
    8262:	83 81       	ldd	r24, Z+3	; 0x03
    8264:	9e 01       	movw	r18, r28
    8266:	2f 5f       	subi	r18, 0xFF	; 255
    8268:	3f 4f       	sbci	r19, 0xFF	; 255
    826a:	8a 30       	cpi	r24, 0x0A	; 10
    826c:	70 f0       	brcs	.+28     	; 0x828a <Put_sDVal+0x8a>
		char Format[] = "%+1 ld";
    826e:	97 e0       	ldi	r25, 0x07	; 7
    8270:	e2 e5       	ldi	r30, 0x52	; 82
    8272:	f1 e0       	ldi	r31, 0x01	; 1
    8274:	d9 01       	movw	r26, r18
    8276:	01 90       	ld	r0, Z+
    8278:	0d 92       	st	X+, r0
    827a:	9a 95       	dec	r25
    827c:	e1 f7       	brne	.-8      	; 0x8276 <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    827e:	6a e0       	ldi	r22, 0x0A	; 10
    8280:	0e 94 20 75 	call	0xea40	; 0xea40 <__udivmodqi4>
    8284:	90 5d       	subi	r25, 0xD0	; 208
    8286:	9c 83       	std	Y+4, r25	; 0x04
    8288:	0a c0       	rjmp	.+20     	; 0x829e <Put_sDVal+0x9e>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+ ld";
    828a:	96 e0       	ldi	r25, 0x06	; 6
    828c:	e9 e5       	ldi	r30, 0x59	; 89
    828e:	f1 e0       	ldi	r31, 0x01	; 1
    8290:	d9 01       	movw	r26, r18
    8292:	01 90       	ld	r0, Z+
    8294:	0d 92       	st	X+, r0
    8296:	9a 95       	dec	r25
    8298:	e1 f7       	brne	.-8      	; 0x8292 <Put_sDVal+0x92>
		Format[2] = '0'+Param->Size;
    829a:	80 5d       	subi	r24, 0xD0	; 208
    829c:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    829e:	ff 92       	push	r15
    82a0:	ef 92       	push	r14
    82a2:	df 92       	push	r13
    82a4:	cf 92       	push	r12
    82a6:	3f 93       	push	r19
    82a8:	2f 93       	push	r18
    82aa:	d5 01       	movw	r26, r10
    82ac:	11 96       	adiw	r26, 0x01	; 1
    82ae:	8c 91       	ld	r24, X
    82b0:	11 97       	sbiw	r26, 0x01	; 1
    82b2:	8f 93       	push	r24
    82b4:	8c 91       	ld	r24, X
    82b6:	8f 93       	push	r24
    82b8:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    82bc:	0f b6       	in	r0, 0x3f	; 63
    82be:	f8 94       	cli
    82c0:	de bf       	out	0x3e, r29	; 62
    82c2:	0f be       	out	0x3f, r0	; 63
    82c4:	cd bf       	out	0x3d, r28	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    82c6:	c1 14       	cp	r12, r1
    82c8:	d1 04       	cpc	r13, r1
    82ca:	e1 04       	cpc	r14, r1
    82cc:	f1 04       	cpc	r15, r1
    82ce:	59 f4       	brne	.+22     	; 0x82e6 <Put_sDVal+0xe6>
    82d0:	d5 01       	movw	r26, r10
    82d2:	13 96       	adiw	r26, 0x03	; 3
    82d4:	8c 91       	ld	r24, X
    82d6:	13 97       	sbiw	r26, 0x03	; 3
    82d8:	ed 91       	ld	r30, X+
    82da:	fc 91       	ld	r31, X
    82dc:	e8 0f       	add	r30, r24
    82de:	f1 1d       	adc	r31, r1
    82e0:	32 97       	sbiw	r30, 0x02	; 2
    82e2:	80 e2       	ldi	r24, 0x20	; 32
    82e4:	80 83       	st	Z, r24

	if(Param->Prec){
    82e6:	f5 01       	movw	r30, r10
    82e8:	82 81       	ldd	r24, Z+2	; 0x02
    82ea:	88 23       	and	r24, r24
    82ec:	09 f4       	brne	.+2      	; 0x82f0 <Put_sDVal+0xf0>
    82ee:	6f c0       	rjmp	.+222    	; 0x83ce <Put_sDVal+0x1ce>
    82f0:	60 e0       	ldi	r22, 0x00	; 0
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    82f2:	d5 01       	movw	r26, r10
    82f4:	13 96       	adiw	r26, 0x03	; 3
    82f6:	8c 91       	ld	r24, X
    82f8:	13 97       	sbiw	r26, 0x03	; 3
    82fa:	90 e0       	ldi	r25, 0x00	; 0
    82fc:	12 96       	adiw	r26, 0x02	; 2
    82fe:	2c 91       	ld	r18, X
    8300:	12 97       	sbiw	r26, 0x02	; 2
    8302:	82 1b       	sub	r24, r18
    8304:	91 09       	sbc	r25, r1
    8306:	46 2f       	mov	r20, r22
    8308:	50 e0       	ldi	r21, 0x00	; 0
    830a:	2d 91       	ld	r18, X+
    830c:	3c 91       	ld	r19, X
    830e:	11 97       	sbiw	r26, 0x01	; 1
			Param->Pos[i] = Param->Pos[i+1];
    8310:	f9 01       	movw	r30, r18
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8312:	48 17       	cp	r20, r24
    8314:	59 07       	cpc	r21, r25
    8316:	34 f4       	brge	.+12     	; 0x8324 <Put_sDVal+0x124>
			Param->Pos[i] = Param->Pos[i+1];
    8318:	e4 0f       	add	r30, r20
    831a:	f5 1f       	adc	r31, r21
    831c:	81 81       	ldd	r24, Z+1	; 0x01
    831e:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8320:	6f 5f       	subi	r22, 0xFF	; 255
    8322:	e7 cf       	rjmp	.-50     	; 0x82f2 <Put_sDVal+0xf2>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    8324:	e8 0f       	add	r30, r24
    8326:	f9 1f       	adc	r31, r25
    8328:	31 97       	sbiw	r30, 0x01	; 1
    832a:	2e e2       	ldi	r18, 0x2E	; 46
    832c:	20 83       	st	Z, r18
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    832e:	13 96       	adiw	r26, 0x03	; 3
    8330:	2c 91       	ld	r18, X
    8332:	13 97       	sbiw	r26, 0x03	; 3
    8334:	82 2f       	mov	r24, r18
    8336:	90 e0       	ldi	r25, 0x00	; 0
    8338:	12 96       	adiw	r26, 0x02	; 2
    833a:	3c 91       	ld	r19, X
    833c:	12 97       	sbiw	r26, 0x02	; 2
    833e:	83 1b       	sub	r24, r19
    8340:	91 09       	sbc	r25, r1
    8342:	ed 91       	ld	r30, X+
    8344:	fc 91       	ld	r31, X
    8346:	e8 0f       	add	r30, r24
    8348:	f9 1f       	adc	r31, r25
    834a:	32 97       	sbiw	r30, 0x02	; 2
    834c:	80 81       	ld	r24, Z
		if(c ==' ' || c =='+' || c =='-'){
    834e:	80 32       	cpi	r24, 0x20	; 32
    8350:	21 f0       	breq	.+8      	; 0x835a <Put_sDVal+0x15a>
    8352:	8b 32       	cpi	r24, 0x2B	; 43
    8354:	11 f0       	breq	.+4      	; 0x835a <Put_sDVal+0x15a>
    8356:	8d 32       	cpi	r24, 0x2D	; 45
    8358:	d1 f5       	brne	.+116    	; 0x83ce <Put_sDVal+0x1ce>
			for(uint8_t i=Param->Size-1; i>1; i--){
    835a:	21 50       	subi	r18, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    835c:	40 e3       	ldi	r20, 0x30	; 48
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    835e:	22 30       	cpi	r18, 0x02	; 2
    8360:	b0 f1       	brcs	.+108    	; 0x83ce <Put_sDVal+0x1ce>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8362:	82 2f       	mov	r24, r18
    8364:	90 e0       	ldi	r25, 0x00	; 0
    8366:	d5 01       	movw	r26, r10
    8368:	ed 91       	ld	r30, X+
    836a:	fc 91       	ld	r31, X
    836c:	e8 0f       	add	r30, r24
    836e:	f9 1f       	adc	r31, r25
    8370:	30 81       	ld	r19, Z
    8372:	30 32       	cpi	r19, 0x20	; 32
    8374:	21 f0       	breq	.+8      	; 0x837e <Put_sDVal+0x17e>
    8376:	3b 32       	cpi	r19, 0x2B	; 43
    8378:	11 f0       	breq	.+4      	; 0x837e <Put_sDVal+0x17e>
    837a:	3d 32       	cpi	r19, 0x2D	; 45
    837c:	09 f4       	brne	.+2      	; 0x8380 <Put_sDVal+0x180>
    837e:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    8380:	d5 01       	movw	r26, r10
    8382:	ed 91       	ld	r30, X+
    8384:	fc 91       	ld	r31, X
    8386:	11 97       	sbiw	r26, 0x01	; 1
    8388:	e8 0f       	add	r30, r24
    838a:	f9 1f       	adc	r31, r25
    838c:	30 81       	ld	r19, Z
    838e:	3e 32       	cpi	r19, 0x2E	; 46
    8390:	e1 f4       	brne	.+56     	; 0x83ca <Put_sDVal+0x1ca>
					Param->Pos[i-1]='0';
    8392:	31 97       	sbiw	r30, 0x01	; 1
    8394:	20 e3       	ldi	r18, 0x30	; 48
    8396:	20 83       	st	Z, r18
					if(Val>0)Param->Pos[i-2]='+';
    8398:	1c 14       	cp	r1, r12
    839a:	1d 04       	cpc	r1, r13
    839c:	1e 04       	cpc	r1, r14
    839e:	1f 04       	cpc	r1, r15
    83a0:	3c f4       	brge	.+14     	; 0x83b0 <Put_sDVal+0x1b0>
    83a2:	ed 91       	ld	r30, X+
    83a4:	fc 91       	ld	r31, X
    83a6:	e8 0f       	add	r30, r24
    83a8:	f9 1f       	adc	r31, r25
    83aa:	32 97       	sbiw	r30, 0x02	; 2
    83ac:	8b e2       	ldi	r24, 0x2B	; 43
    83ae:	0b c0       	rjmp	.+22     	; 0x83c6 <Put_sDVal+0x1c6>
					if(Val<0)Param->Pos[i-2]='-';
    83b0:	cd 28       	or	r12, r13
    83b2:	ce 28       	or	r12, r14
    83b4:	cf 28       	or	r12, r15
    83b6:	59 f0       	breq	.+22     	; 0x83ce <Put_sDVal+0x1ce>
    83b8:	d5 01       	movw	r26, r10
    83ba:	ed 91       	ld	r30, X+
    83bc:	fc 91       	ld	r31, X
    83be:	e8 0f       	add	r30, r24
    83c0:	f9 1f       	adc	r31, r25
    83c2:	32 97       	sbiw	r30, 0x02	; 2
    83c4:	8d e2       	ldi	r24, 0x2D	; 45
    83c6:	80 83       	st	Z, r24
    83c8:	02 c0       	rjmp	.+4      	; 0x83ce <Put_sDVal+0x1ce>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    83ca:	21 50       	subi	r18, 0x01	; 1
    83cc:	c8 cf       	rjmp	.-112    	; 0x835e <Put_sDVal+0x15e>
				}
			}
		}
	}

}
    83ce:	27 96       	adiw	r28, 0x07	; 7
    83d0:	0f b6       	in	r0, 0x3f	; 63
    83d2:	f8 94       	cli
    83d4:	de bf       	out	0x3e, r29	; 62
    83d6:	0f be       	out	0x3f, r0	; 63
    83d8:	cd bf       	out	0x3d, r28	; 61
    83da:	df 91       	pop	r29
    83dc:	cf 91       	pop	r28
    83de:	1f 91       	pop	r17
    83e0:	0f 91       	pop	r16
    83e2:	ff 90       	pop	r15
    83e4:	ef 90       	pop	r14
    83e6:	df 90       	pop	r13
    83e8:	cf 90       	pop	r12
    83ea:	bf 90       	pop	r11
    83ec:	af 90       	pop	r10
    83ee:	08 95       	ret

000083f0 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    83f0:	af 92       	push	r10
    83f2:	bf 92       	push	r11
    83f4:	cf 92       	push	r12
    83f6:	df 92       	push	r13
    83f8:	ef 92       	push	r14
    83fa:	ff 92       	push	r15
    83fc:	0f 93       	push	r16
    83fe:	1f 93       	push	r17
    8400:	cf 93       	push	r28
    8402:	df 93       	push	r29
    8404:	cd b7       	in	r28, 0x3d	; 61
    8406:	de b7       	in	r29, 0x3e	; 62
    8408:	2c 97       	sbiw	r28, 0x0c	; 12
    840a:	0f b6       	in	r0, 0x3f	; 63
    840c:	f8 94       	cli
    840e:	de bf       	out	0x3e, r29	; 62
    8410:	0f be       	out	0x3f, r0	; 63
    8412:	cd bf       	out	0x3d, r28	; 61
    8414:	6b 01       	movw	r12, r22
    8416:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    8418:	8b 01       	movw	r16, r22
    841a:	9c 01       	movw	r18, r24
    841c:	00 95       	com	r16
    841e:	10 95       	com	r17
    8420:	20 95       	com	r18
    8422:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    8424:	fa 01       	movw	r30, r20
    8426:	84 81       	ldd	r24, Z+4	; 0x04
    8428:	95 81       	ldd	r25, Z+5	; 0x05
    842a:	00 97       	sbiw	r24, 0x00	; 0
    842c:	79 f0       	breq	.+30     	; 0x844c <Put_zDVal+0x5c>
    842e:	02 30       	cpi	r16, 0x02	; 2
    8430:	11 05       	cpc	r17, r1
    8432:	21 05       	cpc	r18, r1
    8434:	31 05       	cpc	r19, r1
    8436:	50 f4       	brcc	.+20     	; 0x844c <Put_zDVal+0x5c>
		Param->Txt += Idx;
    8438:	00 0f       	add	r16, r16
    843a:	11 1f       	adc	r17, r17
    843c:	08 0f       	add	r16, r24
    843e:	19 1f       	adc	r17, r25
    8440:	15 83       	std	Z+5, r17	; 0x05
    8442:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    8444:	ca 01       	movw	r24, r20
    8446:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
		return;
    844a:	54 c0       	rjmp	.+168    	; 0x84f4 <Put_zDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    844c:	fa 01       	movw	r30, r20
    844e:	93 81       	ldd	r25, Z+3	; 0x03
    8450:	9a 30       	cpi	r25, 0x0A	; 10
    8452:	81 f4       	brne	.+32     	; 0x8474 <Put_zDVal+0x84>
    8454:	82 81       	ldd	r24, Z+2	; 0x02
    8456:	81 11       	cpse	r24, r1
    8458:	0d c0       	rjmp	.+26     	; 0x8474 <Put_zDVal+0x84>
		sprintf(Param->Pos, "%010lu", Val);
    845a:	ff 92       	push	r15
    845c:	ef 92       	push	r14
    845e:	df 92       	push	r13
    8460:	cf 92       	push	r12
    8462:	8f e5       	ldi	r24, 0x5F	; 95
    8464:	91 e0       	ldi	r25, 0x01	; 1
    8466:	9f 93       	push	r25
    8468:	8f 93       	push	r24
    846a:	81 81       	ldd	r24, Z+1	; 0x01
    846c:	8f 93       	push	r24
    846e:	80 81       	ld	r24, Z
    8470:	8f 93       	push	r24
    8472:	39 c0       	rjmp	.+114    	; 0x84e6 <Put_zDVal+0xf6>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8474:	8c e0       	ldi	r24, 0x0C	; 12
    8476:	e6 e6       	ldi	r30, 0x66	; 102
    8478:	f1 e0       	ldi	r31, 0x01	; 1
    847a:	8e 01       	movw	r16, r28
    847c:	0f 5f       	subi	r16, 0xFF	; 255
    847e:	1f 4f       	sbci	r17, 0xFF	; 255
    8480:	d8 01       	movw	r26, r16
    8482:	01 90       	ld	r0, Z+
    8484:	0d 92       	st	X+, r0
    8486:	8a 95       	dec	r24
    8488:	e1 f7       	brne	.-8      	; 0x8482 <Put_zDVal+0x92>
	Format[2] = '0'+Param->Size;
    848a:	90 5d       	subi	r25, 0xD0	; 208
    848c:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    848e:	fa 01       	movw	r30, r20
    8490:	82 81       	ldd	r24, Z+2	; 0x02
    8492:	a1 80       	ldd	r10, Z+1	; 0x01
    8494:	b0 80       	ld	r11, Z
    8496:	88 23       	and	r24, r24
    8498:	e9 f0       	breq	.+58     	; 0x84d4 <Put_zDVal+0xe4>
		Format[2] -= Param->Prec+1;
    849a:	98 1b       	sub	r25, r24
    849c:	91 50       	subi	r25, 0x01	; 1
    849e:	9b 83       	std	Y+3, r25	; 0x03
		Format[8] = '0'+Param->Prec;
    84a0:	90 e3       	ldi	r25, 0x30	; 48
    84a2:	98 0f       	add	r25, r24
    84a4:	99 87       	std	Y+9, r25	; 0x09
		uint32_t Div=PowL10(Param->Prec);
    84a6:	0e 94 8a 3c 	call	0x7914	; 0x7914 <PowL10>
    84aa:	9b 01       	movw	r18, r22
    84ac:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    84ae:	c7 01       	movw	r24, r14
    84b0:	b6 01       	movw	r22, r12
    84b2:	0e 94 54 75 	call	0xeaa8	; 0xeaa8 <__udivmodsi4>
    84b6:	9f 93       	push	r25
    84b8:	8f 93       	push	r24
    84ba:	7f 93       	push	r23
    84bc:	6f 93       	push	r22
    84be:	5f 93       	push	r21
    84c0:	4f 93       	push	r20
    84c2:	3f 93       	push	r19
    84c4:	2f 93       	push	r18
    84c6:	1f 93       	push	r17
    84c8:	0f 93       	push	r16
    84ca:	af 92       	push	r10
    84cc:	bf 92       	push	r11
    84ce:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    84d2:	0b c0       	rjmp	.+22     	; 0x84ea <Put_zDVal+0xfa>
	}
	else {
		Format[5] = '\0';
    84d4:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    84d6:	ff 92       	push	r15
    84d8:	ef 92       	push	r14
    84da:	df 92       	push	r13
    84dc:	cf 92       	push	r12
    84de:	1f 93       	push	r17
    84e0:	0f 93       	push	r16
    84e2:	af 92       	push	r10
    84e4:	bf 92       	push	r11
    84e6:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    84ea:	0f b6       	in	r0, 0x3f	; 63
    84ec:	f8 94       	cli
    84ee:	de bf       	out	0x3e, r29	; 62
    84f0:	0f be       	out	0x3f, r0	; 63
    84f2:	cd bf       	out	0x3d, r28	; 61
	}
}
    84f4:	2c 96       	adiw	r28, 0x0c	; 12
    84f6:	0f b6       	in	r0, 0x3f	; 63
    84f8:	f8 94       	cli
    84fa:	de bf       	out	0x3e, r29	; 62
    84fc:	0f be       	out	0x3f, r0	; 63
    84fe:	cd bf       	out	0x3d, r28	; 61
    8500:	df 91       	pop	r29
    8502:	cf 91       	pop	r28
    8504:	1f 91       	pop	r17
    8506:	0f 91       	pop	r16
    8508:	ff 90       	pop	r15
    850a:	ef 90       	pop	r14
    850c:	df 90       	pop	r13
    850e:	cf 90       	pop	r12
    8510:	bf 90       	pop	r11
    8512:	af 90       	pop	r10
    8514:	08 95       	ret

00008516 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    8516:	1f 93       	push	r17
    8518:	cf 93       	push	r28
    851a:	df 93       	push	r29
    851c:	cd b7       	in	r28, 0x3d	; 61
    851e:	de b7       	in	r29, 0x3e	; 62
    8520:	27 97       	sbiw	r28, 0x07	; 7
    8522:	0f b6       	in	r0, 0x3f	; 63
    8524:	f8 94       	cli
    8526:	de bf       	out	0x3e, r29	; 62
    8528:	0f be       	out	0x3f, r0	; 63
    852a:	cd bf       	out	0x3d, r28	; 61
	char Format[] = "%+ . f";
    852c:	17 e0       	ldi	r17, 0x07	; 7
    852e:	e2 e7       	ldi	r30, 0x72	; 114
    8530:	f1 e0       	ldi	r31, 0x01	; 1
    8532:	9e 01       	movw	r18, r28
    8534:	2f 5f       	subi	r18, 0xFF	; 255
    8536:	3f 4f       	sbci	r19, 0xFF	; 255
    8538:	d9 01       	movw	r26, r18
    853a:	01 90       	ld	r0, Z+
    853c:	0d 92       	st	X+, r0
    853e:	1a 95       	dec	r17
    8540:	e1 f7       	brne	.-8      	; 0x853a <Put_FFVal+0x24>
	Format[2] = '0'+Param->Size;
    8542:	da 01       	movw	r26, r20
    8544:	13 96       	adiw	r26, 0x03	; 3
    8546:	ec 91       	ld	r30, X
    8548:	13 97       	sbiw	r26, 0x03	; 3
    854a:	e0 5d       	subi	r30, 0xD0	; 208
    854c:	eb 83       	std	Y+3, r30	; 0x03
	Format[4] = '0'+Param->Prec;	
    854e:	12 96       	adiw	r26, 0x02	; 2
    8550:	ec 91       	ld	r30, X
    8552:	12 97       	sbiw	r26, 0x02	; 2
    8554:	e0 5d       	subi	r30, 0xD0	; 208
    8556:	ed 83       	std	Y+5, r30	; 0x05
	sprintf(Param->Pos, Format, Val);
    8558:	9f 93       	push	r25
    855a:	8f 93       	push	r24
    855c:	7f 93       	push	r23
    855e:	6f 93       	push	r22
    8560:	3f 93       	push	r19
    8562:	2f 93       	push	r18
    8564:	11 96       	adiw	r26, 0x01	; 1
    8566:	8c 91       	ld	r24, X
    8568:	11 97       	sbiw	r26, 0x01	; 1
    856a:	8f 93       	push	r24
    856c:	8c 91       	ld	r24, X
    856e:	8f 93       	push	r24
    8570:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    8574:	0f b6       	in	r0, 0x3f	; 63
    8576:	f8 94       	cli
    8578:	de bf       	out	0x3e, r29	; 62
    857a:	0f be       	out	0x3f, r0	; 63
    857c:	cd bf       	out	0x3d, r28	; 61
}
    857e:	27 96       	adiw	r28, 0x07	; 7
    8580:	0f b6       	in	r0, 0x3f	; 63
    8582:	f8 94       	cli
    8584:	de bf       	out	0x3e, r29	; 62
    8586:	0f be       	out	0x3f, r0	; 63
    8588:	cd bf       	out	0x3d, r28	; 61
    858a:	df 91       	pop	r29
    858c:	cf 91       	pop	r28
    858e:	1f 91       	pop	r17
    8590:	08 95       	ret

00008592 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    8592:	0f 93       	push	r16
    8594:	1f 93       	push	r17
    8596:	cf 93       	push	r28
    8598:	df 93       	push	r29
    859a:	cd b7       	in	r28, 0x3d	; 61
    859c:	de b7       	in	r29, 0x3e	; 62
    859e:	28 97       	sbiw	r28, 0x08	; 8
    85a0:	0f b6       	in	r0, 0x3f	; 63
    85a2:	f8 94       	cli
    85a4:	de bf       	out	0x3e, r29	; 62
    85a6:	0f be       	out	0x3f, r0	; 63
    85a8:	cd bf       	out	0x3d, r28	; 61
	if(Param->Size < 10){
    85aa:	da 01       	movw	r26, r20
    85ac:	13 96       	adiw	r26, 0x03	; 3
    85ae:	1c 91       	ld	r17, X
    85b0:	9e 01       	movw	r18, r28
    85b2:	2f 5f       	subi	r18, 0xFF	; 255
    85b4:	3f 4f       	sbci	r19, 0xFF	; 255
    85b6:	1a 30       	cpi	r17, 0x0A	; 10
    85b8:	88 f4       	brcc	.+34     	; 0x85dc <Put_GFVal+0x4a>
		char Format[] = "%+ . g";
    85ba:	07 e0       	ldi	r16, 0x07	; 7
    85bc:	e9 e7       	ldi	r30, 0x79	; 121
    85be:	f1 e0       	ldi	r31, 0x01	; 1
    85c0:	d9 01       	movw	r26, r18
    85c2:	01 90       	ld	r0, Z+
    85c4:	0d 92       	st	X+, r0
    85c6:	0a 95       	dec	r16
    85c8:	e1 f7       	brne	.-8      	; 0x85c2 <Put_GFVal+0x30>
		Format[2] = '0'+Param->Size;
    85ca:	10 5d       	subi	r17, 0xD0	; 208
    85cc:	1b 83       	std	Y+3, r17	; 0x03
		Format[4] = '0'+Param->Prec;
    85ce:	da 01       	movw	r26, r20
    85d0:	12 96       	adiw	r26, 0x02	; 2
    85d2:	ec 91       	ld	r30, X
    85d4:	12 97       	sbiw	r26, 0x02	; 2
    85d6:	e0 5d       	subi	r30, 0xD0	; 208
    85d8:	ed 83       	std	Y+5, r30	; 0x05
    85da:	10 c0       	rjmp	.+32     	; 0x85fc <Put_GFVal+0x6a>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    85dc:	08 e0       	ldi	r16, 0x08	; 8
    85de:	e0 e8       	ldi	r30, 0x80	; 128
    85e0:	f1 e0       	ldi	r31, 0x01	; 1
    85e2:	d9 01       	movw	r26, r18
    85e4:	01 90       	ld	r0, Z+
    85e6:	0d 92       	st	X+, r0
    85e8:	0a 95       	dec	r16
    85ea:	e1 f7       	brne	.-8      	; 0x85e4 <Put_GFVal+0x52>
		Format[3] = '0'+Param->Size-10;	
    85ec:	1a 5d       	subi	r17, 0xDA	; 218
    85ee:	1c 83       	std	Y+4, r17	; 0x04
		Format[5] = '0'+Param->Prec;
    85f0:	da 01       	movw	r26, r20
    85f2:	12 96       	adiw	r26, 0x02	; 2
    85f4:	ec 91       	ld	r30, X
    85f6:	12 97       	sbiw	r26, 0x02	; 2
    85f8:	e0 5d       	subi	r30, 0xD0	; 208
    85fa:	ee 83       	std	Y+6, r30	; 0x06
		sprintf(Param->Pos, Format, Val);
    85fc:	9f 93       	push	r25
    85fe:	8f 93       	push	r24
    8600:	7f 93       	push	r23
    8602:	6f 93       	push	r22
    8604:	3f 93       	push	r19
    8606:	2f 93       	push	r18
    8608:	11 96       	adiw	r26, 0x01	; 1
    860a:	8c 91       	ld	r24, X
    860c:	11 97       	sbiw	r26, 0x01	; 1
    860e:	8f 93       	push	r24
    8610:	8c 91       	ld	r24, X
    8612:	8f 93       	push	r24
    8614:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    8618:	0f b6       	in	r0, 0x3f	; 63
    861a:	f8 94       	cli
    861c:	de bf       	out	0x3e, r29	; 62
    861e:	0f be       	out	0x3f, r0	; 63
    8620:	cd bf       	out	0x3d, r28	; 61
	}
}
    8622:	28 96       	adiw	r28, 0x08	; 8
    8624:	0f b6       	in	r0, 0x3f	; 63
    8626:	f8 94       	cli
    8628:	de bf       	out	0x3e, r29	; 62
    862a:	0f be       	out	0x3f, r0	; 63
    862c:	cd bf       	out	0x3d, r28	; 61
    862e:	df 91       	pop	r29
    8630:	cf 91       	pop	r28
    8632:	1f 91       	pop	r17
    8634:	0f 91       	pop	r16
    8636:	08 95       	ret

00008638 <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8638:	cf 92       	push	r12
    863a:	df 92       	push	r13
    863c:	ef 92       	push	r14
    863e:	ff 92       	push	r15
    8640:	0f 93       	push	r16
    8642:	1f 93       	push	r17
    8644:	cf 93       	push	r28
    8646:	df 93       	push	r29
    8648:	cd b7       	in	r28, 0x3d	; 61
    864a:	de b7       	in	r29, 0x3e	; 62
    864c:	29 97       	sbiw	r28, 0x09	; 9
    864e:	0f b6       	in	r0, 0x3f	; 63
    8650:	f8 94       	cli
    8652:	de bf       	out	0x3e, r29	; 62
    8654:	0f be       	out	0x3f, r0	; 63
    8656:	cd bf       	out	0x3d, r28	; 61
    8658:	d8 2e       	mov	r13, r24
    865a:	c9 2e       	mov	r12, r25
    865c:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    865e:	fb 01       	movw	r30, r22
    8660:	23 81       	ldd	r18, Z+3	; 0x03
    8662:	1f 92       	push	r1
    8664:	2f 93       	push	r18
    8666:	1f 92       	push	r1
    8668:	2f 93       	push	r18
    866a:	28 e8       	ldi	r18, 0x88	; 136
    866c:	31 e0       	ldi	r19, 0x01	; 1
    866e:	3f 93       	push	r19
    8670:	2f 93       	push	r18
    8672:	8e 01       	movw	r16, r28
    8674:	0f 5f       	subi	r16, 0xFF	; 255
    8676:	1f 4f       	sbci	r17, 0xFF	; 255
    8678:	1f 93       	push	r17
    867a:	0f 93       	push	r16
    867c:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
	sprintf(Param->Pos, Format, Val);
    8680:	cf 92       	push	r12
    8682:	df 92       	push	r13
    8684:	1f 93       	push	r17
    8686:	0f 93       	push	r16
    8688:	f7 01       	movw	r30, r14
    868a:	81 81       	ldd	r24, Z+1	; 0x01
    868c:	8f 93       	push	r24
    868e:	80 81       	ld	r24, Z
    8690:	8f 93       	push	r24
    8692:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    8696:	0f b6       	in	r0, 0x3f	; 63
    8698:	f8 94       	cli
    869a:	de bf       	out	0x3e, r29	; 62
    869c:	0f be       	out	0x3f, r0	; 63
    869e:	cd bf       	out	0x3d, r28	; 61
}
    86a0:	29 96       	adiw	r28, 0x09	; 9
    86a2:	0f b6       	in	r0, 0x3f	; 63
    86a4:	f8 94       	cli
    86a6:	de bf       	out	0x3e, r29	; 62
    86a8:	0f be       	out	0x3f, r0	; 63
    86aa:	cd bf       	out	0x3d, r28	; 61
    86ac:	df 91       	pop	r29
    86ae:	cf 91       	pop	r28
    86b0:	1f 91       	pop	r17
    86b2:	0f 91       	pop	r16
    86b4:	ff 90       	pop	r15
    86b6:	ef 90       	pop	r14
    86b8:	df 90       	pop	r13
    86ba:	cf 90       	pop	r12
    86bc:	08 95       	ret

000086be <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    86be:	80 91 25 0b 	lds	r24, 0x0B25
    86c2:	90 91 26 0b 	lds	r25, 0x0B26
    86c6:	89 2b       	or	r24, r25
    86c8:	31 f0       	breq	.+12     	; 0x86d6 <HideMsg+0x18>
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    86ca:	10 92 26 0b 	sts	0x0B26, r1
    86ce:	10 92 25 0b 	sts	0x0B25, r1
		return 1;
    86d2:	81 e0       	ldi	r24, 0x01	; 1
    86d4:	08 95       	ret
	}
	else
		return 0;
    86d6:	80 e0       	ldi	r24, 0x00	; 0
}
    86d8:	08 95       	ret

000086da <WebInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    86da:	80 91 0f 01 	lds	r24, 0x010F
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    86de:	80 93 41 09 	sts	0x0941, r24
	VacantTimer8Sys += n;
    86e2:	92 e0       	ldi	r25, 0x02	; 2
    86e4:	98 0f       	add	r25, r24
    86e6:	90 93 0f 01 	sts	0x010F, r25
    86ea:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    86ec:	80 93 44 09 	sts	0x0944, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    86f0:	80 91 0e 01 	lds	r24, 0x010E
	TD_FlowDelay =  Timer16SysAlloc(1);
    86f4:	80 93 4f 09 	sts	0x094F, r24
	VacantTimer16Sys += n;
    86f8:	92 e0       	ldi	r25, 0x02	; 2
    86fa:	98 0f       	add	r25, r24
    86fc:	90 93 0e 01 	sts	0x010E, r25
    8700:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    8702:	80 93 6a 09 	sts	0x096A, r24
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    8706:	0e 94 93 2a 	call	0x5526	; 0x5526 <Timer32Alloc>
    870a:	80 93 1c 06 	sts	0x061C, r24
	TD_WebSessTimeout	= Timer32Alloc();
    870e:	0e 94 93 2a 	call	0x5526	; 0x5526 <Timer32Alloc>
    8712:	80 93 68 09 	sts	0x0968, r24
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    8716:	80 91 12 01 	lds	r24, 0x0112
    871a:	88 31       	cpi	r24, 0x18	; 24
    871c:	40 f4       	brcc	.+16     	; 0x872e <WebInit+0x54>
    871e:	80 91 11 01 	lds	r24, 0x0111
    8722:	88 32       	cpi	r24, 0x28	; 40
    8724:	20 f4       	brcc	.+8      	; 0x872e <WebInit+0x54>
    8726:	80 91 10 01 	lds	r24, 0x0110
    872a:	80 32       	cpi	r24, 0x20	; 32
    872c:	40 f0       	brcs	.+16     	; 0x873e <WebInit+0x64>

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
    872e:	0e 94 5f 43 	call	0x86be	; 0x86be <HideMsg>
	CurrMsg = Msg;
    8732:	87 ef       	ldi	r24, 0xF7	; 247
    8734:	9c e4       	ldi	r25, 0x4C	; 76
    8736:	90 93 26 0b 	sts	0x0B26, r25
    873a:	80 93 25 0b 	sts	0x0B25, r24
    873e:	08 95       	ret

00008740 <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8740:	0f 93       	push	r16
    8742:	1f 93       	push	r17
    8744:	cf 93       	push	r28
    8746:	df 93       	push	r29
    8748:	8b 01       	movw	r16, r22
	if(prb(&Field->Prec)){
    874a:	ec 01       	movw	r28, r24
    874c:	2f 96       	adiw	r28, 0x0f	; 15

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    874e:	fe 01       	movw	r30, r28
    8750:	84 91       	lpm	r24, Z
    8752:	88 23       	and	r24, r24
    8754:	69 f1       	breq	.+90     	; 0x87b0 <WebPresicionHanler+0x70>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    8756:	6e e2       	ldi	r22, 0x2E	; 46
    8758:	70 e0       	ldi	r23, 0x00	; 0
    875a:	c8 01       	movw	r24, r16
    875c:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
		if(p==NULL){
    8760:	00 97       	sbiw	r24, 0x00	; 0
    8762:	29 f4       	brne	.+10     	; 0x876e <WebPresicionHanler+0x2e>
			p = strchr(BufStr,' ');	//else seek for first space
    8764:	60 e2       	ldi	r22, 0x20	; 32
    8766:	70 e0       	ldi	r23, 0x00	; 0
    8768:	c8 01       	movw	r24, r16
    876a:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    876e:	dc 01       	movw	r26, r24
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    8770:	40 e3       	ldi	r20, 0x30	; 48
    8772:	fe 01       	movw	r30, r28
    8774:	24 91       	lpm	r18, Z
    8776:	3a 2f       	mov	r19, r26
    8778:	38 1b       	sub	r19, r24
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    877a:	32 17       	cp	r19, r18
    877c:	c8 f4       	brcc	.+50     	; 0x87b0 <WebPresicionHanler+0x70>
			if(*p == ' ') *p='0'; 
    877e:	2c 91       	ld	r18, X
    8780:	20 32       	cpi	r18, 0x20	; 32
    8782:	09 f4       	brne	.+2      	; 0x8786 <WebPresicionHanler+0x46>
    8784:	4c 93       	st	X, r20
			if(*p == '.'){
    8786:	5c 91       	ld	r21, X
    8788:	5e 32       	cpi	r21, 0x2E	; 46
    878a:	81 f4       	brne	.+32     	; 0x87ac <WebPresicionHanler+0x6c>
				if(isdigit(*(p+1))){
    878c:	11 96       	adiw	r26, 0x01	; 1
    878e:	6c 91       	ld	r22, X
    8790:	11 97       	sbiw	r26, 0x01	; 1
    8792:	26 2f       	mov	r18, r22
    8794:	30 e0       	ldi	r19, 0x00	; 0
    8796:	20 53       	subi	r18, 0x30	; 48
    8798:	31 09       	sbc	r19, r1
    879a:	2a 30       	cpi	r18, 0x0A	; 10
    879c:	31 05       	cpc	r19, r1
    879e:	28 f4       	brcc	.+10     	; 0x87aa <WebPresicionHanler+0x6a>
					*p= *(p+1);
    87a0:	6c 93       	st	X, r22
					*(p+1) = '.';
    87a2:	11 96       	adiw	r26, 0x01	; 1
    87a4:	5c 93       	st	X, r21
    87a6:	11 97       	sbiw	r26, 0x01	; 1
    87a8:	01 c0       	rjmp	.+2      	; 0x87ac <WebPresicionHanler+0x6c>
				}
				else *p='0'; 
    87aa:	4c 93       	st	X, r20
			}
			p++;
    87ac:	11 96       	adiw	r26, 0x01	; 1
    87ae:	e1 cf       	rjmp	.-62     	; 0x8772 <WebPresicionHanler+0x32>
		}
	}
	
}
    87b0:	df 91       	pop	r29
    87b2:	cf 91       	pop	r28
    87b4:	1f 91       	pop	r17
    87b6:	0f 91       	pop	r16
    87b8:	08 95       	ret

000087ba <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    87ba:	2f 92       	push	r2
    87bc:	3f 92       	push	r3
    87be:	4f 92       	push	r4
    87c0:	5f 92       	push	r5
    87c2:	6f 92       	push	r6
    87c4:	7f 92       	push	r7
    87c6:	8f 92       	push	r8
    87c8:	9f 92       	push	r9
    87ca:	af 92       	push	r10
    87cc:	bf 92       	push	r11
    87ce:	cf 92       	push	r12
    87d0:	df 92       	push	r13
    87d2:	ef 92       	push	r14
    87d4:	ff 92       	push	r15
    87d6:	0f 93       	push	r16
    87d8:	1f 93       	push	r17
    87da:	cf 93       	push	r28
    87dc:	df 93       	push	r29
    87de:	cd b7       	in	r28, 0x3d	; 61
    87e0:	de b7       	in	r29, 0x3e	; 62
    87e2:	2e 97       	sbiw	r28, 0x0e	; 14
    87e4:	0f b6       	in	r0, 0x3f	; 63
    87e6:	f8 94       	cli
    87e8:	de bf       	out	0x3e, r29	; 62
    87ea:	0f be       	out	0x3f, r0	; 63
    87ec:	cd bf       	out	0x3d, r28	; 61
    87ee:	6c 01       	movw	r12, r24
    87f0:	8b 01       	movw	r16, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    87f2:	2d b7       	in	r18, 0x3d	; 61
    87f4:	3e b7       	in	r19, 0x3e	; 62
    87f6:	3e 87       	std	Y+14, r19	; 0x0e
    87f8:	2d 87       	std	Y+13, r18	; 0x0d
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
    87fa:	fc 01       	movw	r30, r24
    87fc:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    87fe:	e5 90       	lpm	r14, Z+
    8800:	f4 90       	lpm	r15, Z
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    8802:	1c 01       	movw	r2, r24
    8804:	3f e0       	ldi	r19, 0x0F	; 15
    8806:	23 0e       	add	r2, r19
    8808:	31 1c       	adc	r3, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    880a:	f1 01       	movw	r30, r2
    880c:	84 91       	lpm	r24, Z
    880e:	98 2f       	mov	r25, r24
    8810:	97 70       	andi	r25, 0x07	; 7
    8812:	21 e0       	ldi	r18, 0x01	; 1
    8814:	30 e0       	ldi	r19, 0x00	; 0
    8816:	02 c0       	rjmp	.+4      	; 0x881c <WebBuf2Field+0x62>
    8818:	22 0f       	add	r18, r18
    881a:	33 1f       	adc	r19, r19
    881c:	9a 95       	dec	r25
    881e:	e2 f7       	brpl	.-8      	; 0x8818 <WebBuf2Field+0x5e>
    8820:	3a 87       	std	Y+10, r19	; 0x0a
    8822:	29 87       	std	Y+9, r18	; 0x09
    8824:	86 95       	lsr	r24
    8826:	86 95       	lsr	r24
    8828:	86 95       	lsr	r24
    882a:	97 01       	movw	r18, r14
    882c:	28 0f       	add	r18, r24
    882e:	31 1d       	adc	r19, r1
    8830:	3c 87       	std	Y+12, r19	; 0x0c
    8832:	2b 87       	std	Y+11, r18	; 0x0b
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);
    8834:	c6 01       	movw	r24, r12
    8836:	03 96       	adiw	r24, 0x03	; 3
    8838:	0e 94 3a 29 	call	0x5274	; 0x5274 <prd>
    883c:	2b 01       	movw	r4, r22
    883e:	3c 01       	movw	r6, r24
    8840:	c6 01       	movw	r24, r12
    8842:	07 96       	adiw	r24, 0x07	; 7
    8844:	0e 94 3a 29 	call	0x5274	; 0x5274 <prd>
    8848:	4b 01       	movw	r8, r22
    884a:	5c 01       	movw	r10, r24

	uint32_t Temp=0;
    884c:	1d 82       	std	Y+5, r1	; 0x05
    884e:	1e 82       	std	Y+6, r1	; 0x06
    8850:	1f 82       	std	Y+7, r1	; 0x07
    8852:	18 86       	std	Y+8, r1	; 0x08
	float fTemp=0;
    8854:	19 82       	std	Y+1, r1	; 0x01
    8856:	1a 82       	std	Y+2, r1	; 0x02
    8858:	1b 82       	std	Y+3, r1	; 0x03
    885a:	1c 82       	std	Y+4, r1	; 0x04
    885c:	f6 01       	movw	r30, r12
    885e:	84 91       	lpm	r24, Z


	switch(prb(&Field->Type)) {
    8860:	90 e0       	ldi	r25, 0x00	; 0
    8862:	83 32       	cpi	r24, 0x23	; 35
    8864:	91 05       	cpc	r25, r1
    8866:	08 f0       	brcs	.+2      	; 0x886a <WebBuf2Field+0xb0>
    8868:	f0 c2       	rjmp	.+1504   	; 0x8e4a <WebBuf2Field+0x690>
    886a:	fc 01       	movw	r30, r24
    886c:	ea 59       	subi	r30, 0x9A	; 154
    886e:	ff 4f       	sbci	r31, 0xFF	; 255
    8870:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8874:	b8 01       	movw	r22, r16
    8876:	c6 01       	movw	r24, r12
    8878:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    887c:	ce 01       	movw	r24, r28
    887e:	05 96       	adiw	r24, 0x05	; 5
    8880:	9f 93       	push	r25
    8882:	8f 93       	push	r24
    8884:	82 e9       	ldi	r24, 0x92	; 146
    8886:	91 e0       	ldi	r25, 0x01	; 1
    8888:	9f 93       	push	r25
    888a:	8f 93       	push	r24
    888c:	1f 93       	push	r17
    888e:	0f 93       	push	r16
    8890:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		SetField(Temp, uint8_t);
    8894:	8d 81       	ldd	r24, Y+5	; 0x05
    8896:	9e 81       	ldd	r25, Y+6	; 0x06
    8898:	af 81       	ldd	r26, Y+7	; 0x07
    889a:	b8 85       	ldd	r27, Y+8	; 0x08
    889c:	0f 90       	pop	r0
    889e:	0f 90       	pop	r0
    88a0:	0f 90       	pop	r0
    88a2:	0f 90       	pop	r0
    88a4:	0f 90       	pop	r0
    88a6:	0f 90       	pop	r0
    88a8:	b5 01       	movw	r22, r10
    88aa:	a4 01       	movw	r20, r8
    88ac:	55 27       	eor	r21, r21
    88ae:	66 27       	eor	r22, r22
    88b0:	77 27       	eor	r23, r23
    88b2:	48 17       	cp	r20, r24
    88b4:	59 07       	cpc	r21, r25
    88b6:	6a 07       	cpc	r22, r26
    88b8:	7b 07       	cpc	r23, r27
    88ba:	08 f4       	brcc	.+2      	; 0x88be <WebBuf2Field+0x104>
    88bc:	5f c0       	rjmp	.+190    	; 0x897c <WebBuf2Field+0x1c2>
    88be:	b3 01       	movw	r22, r6
    88c0:	a2 01       	movw	r20, r4
    88c2:	55 27       	eor	r21, r21
    88c4:	66 27       	eor	r22, r22
    88c6:	77 27       	eor	r23, r23
    88c8:	61 c0       	rjmp	.+194    	; 0x898c <WebBuf2Field+0x1d2>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    88ca:	b8 01       	movw	r22, r16
    88cc:	c6 01       	movw	r24, r12
    88ce:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    88d2:	ce 01       	movw	r24, r28
    88d4:	05 96       	adiw	r24, 0x05	; 5
    88d6:	9f 93       	push	r25
    88d8:	8f 93       	push	r24
    88da:	82 e9       	ldi	r24, 0x92	; 146
    88dc:	91 e0       	ldi	r25, 0x01	; 1
    88de:	9f 93       	push	r25
    88e0:	8f 93       	push	r24
    88e2:	1f 93       	push	r17
    88e4:	0f 93       	push	r16
    88e6:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    88ea:	0f 90       	pop	r0
    88ec:	0f 90       	pop	r0
    88ee:	0f 90       	pop	r0
    88f0:	0f 90       	pop	r0
    88f2:	0f 90       	pop	r0
    88f4:	0f 90       	pop	r0
    88f6:	01 97       	sbiw	r24, 0x01	; 1
    88f8:	09 f0       	breq	.+2      	; 0x88fc <WebBuf2Field+0x142>
    88fa:	a7 c2       	rjmp	.+1358   	; 0x8e4a <WebBuf2Field+0x690>
			SetEEField(Temp, uint8_t, uint8_t, b);
    88fc:	6d 81       	ldd	r22, Y+5	; 0x05
    88fe:	7e 81       	ldd	r23, Y+6	; 0x06
    8900:	8f 81       	ldd	r24, Y+7	; 0x07
    8902:	98 85       	ldd	r25, Y+8	; 0x08
    8904:	95 01       	movw	r18, r10
    8906:	84 01       	movw	r16, r8
    8908:	11 27       	eor	r17, r17
    890a:	22 27       	eor	r18, r18
    890c:	33 27       	eor	r19, r19
    890e:	06 17       	cp	r16, r22
    8910:	17 07       	cpc	r17, r23
    8912:	28 07       	cpc	r18, r24
    8914:	39 07       	cpc	r19, r25
    8916:	08 f4       	brcc	.+2      	; 0x891a <WebBuf2Field+0x160>
    8918:	5e c0       	rjmp	.+188    	; 0x89d6 <WebBuf2Field+0x21c>
    891a:	93 01       	movw	r18, r6
    891c:	82 01       	movw	r16, r4
    891e:	11 27       	eor	r17, r17
    8920:	22 27       	eor	r18, r18
    8922:	33 27       	eor	r19, r19
    8924:	60 17       	cp	r22, r16
    8926:	71 07       	cpc	r23, r17
    8928:	82 07       	cpc	r24, r18
    892a:	93 07       	cpc	r25, r19
    892c:	08 f0       	brcs	.+2      	; 0x8930 <WebBuf2Field+0x176>
    892e:	d7 c1       	rjmp	.+942    	; 0x8cde <WebBuf2Field+0x524>
    8930:	d3 c1       	rjmp	.+934    	; 0x8cd8 <WebBuf2Field+0x51e>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    8932:	b8 01       	movw	r22, r16
    8934:	c6 01       	movw	r24, r12
    8936:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    893a:	ce 01       	movw	r24, r28
    893c:	05 96       	adiw	r24, 0x05	; 5
    893e:	9f 93       	push	r25
    8940:	8f 93       	push	r24
    8942:	87 e9       	ldi	r24, 0x97	; 151
    8944:	91 e0       	ldi	r25, 0x01	; 1
    8946:	9f 93       	push	r25
    8948:	8f 93       	push	r24
    894a:	1f 93       	push	r17
    894c:	0f 93       	push	r16
    894e:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		SetField(Temp, int8_t);
    8952:	8d 81       	ldd	r24, Y+5	; 0x05
    8954:	9e 81       	ldd	r25, Y+6	; 0x06
    8956:	af 81       	ldd	r26, Y+7	; 0x07
    8958:	b8 85       	ldd	r27, Y+8	; 0x08
    895a:	0f 90       	pop	r0
    895c:	0f 90       	pop	r0
    895e:	0f 90       	pop	r0
    8960:	0f 90       	pop	r0
    8962:	0f 90       	pop	r0
    8964:	0f 90       	pop	r0
    8966:	48 2d       	mov	r20, r8
    8968:	55 27       	eor	r21, r21
    896a:	47 fd       	sbrc	r20, 7
    896c:	50 95       	com	r21
    896e:	65 2f       	mov	r22, r21
    8970:	75 2f       	mov	r23, r21
    8972:	48 17       	cp	r20, r24
    8974:	59 07       	cpc	r21, r25
    8976:	6a 07       	cpc	r22, r26
    8978:	7b 07       	cpc	r23, r27
    897a:	10 f4       	brcc	.+4      	; 0x8980 <WebBuf2Field+0x1c6>
    897c:	f7 01       	movw	r30, r14
    897e:	cc c1       	rjmp	.+920    	; 0x8d18 <WebBuf2Field+0x55e>
    8980:	44 2d       	mov	r20, r4
    8982:	55 27       	eor	r21, r21
    8984:	47 fd       	sbrc	r20, 7
    8986:	50 95       	com	r21
    8988:	65 2f       	mov	r22, r21
    898a:	75 2f       	mov	r23, r21
    898c:	f7 01       	movw	r30, r14
    898e:	84 17       	cp	r24, r20
    8990:	95 07       	cpc	r25, r21
    8992:	a6 07       	cpc	r26, r22
    8994:	b7 07       	cpc	r27, r23
    8996:	08 f4       	brcc	.+2      	; 0x899a <WebBuf2Field+0x1e0>
    8998:	9b c1       	rjmp	.+822    	; 0x8cd0 <WebBuf2Field+0x516>
    899a:	80 83       	st	Z, r24
    899c:	56 c2       	rjmp	.+1196   	; 0x8e4a <WebBuf2Field+0x690>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    899e:	b8 01       	movw	r22, r16
    89a0:	c6 01       	movw	r24, r12
    89a2:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    89a6:	ce 01       	movw	r24, r28
    89a8:	05 96       	adiw	r24, 0x05	; 5
    89aa:	9f 93       	push	r25
    89ac:	8f 93       	push	r24
    89ae:	87 e9       	ldi	r24, 0x97	; 151
    89b0:	91 e0       	ldi	r25, 0x01	; 1
    89b2:	9f 93       	push	r25
    89b4:	8f 93       	push	r24
    89b6:	1f 93       	push	r17
    89b8:	0f 93       	push	r16
    89ba:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    89be:	0f 90       	pop	r0
    89c0:	0f 90       	pop	r0
    89c2:	0f 90       	pop	r0
    89c4:	0f 90       	pop	r0
    89c6:	0f 90       	pop	r0
    89c8:	0f 90       	pop	r0
    89ca:	01 97       	sbiw	r24, 0x01	; 1
    89cc:	09 f0       	breq	.+2      	; 0x89d0 <WebBuf2Field+0x216>
    89ce:	3d c2       	rjmp	.+1146   	; 0x8e4a <WebBuf2Field+0x690>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    89d0:	6d 81       	ldd	r22, Y+5	; 0x05
    89d2:	86 16       	cp	r8, r22
    89d4:	14 f4       	brge	.+4      	; 0x89da <WebBuf2Field+0x220>
    89d6:	68 2d       	mov	r22, r8
    89d8:	82 c1       	rjmp	.+772    	; 0x8cde <WebBuf2Field+0x524>
    89da:	64 15       	cp	r22, r4
    89dc:	0c f0       	brlt	.+2      	; 0x89e0 <WebBuf2Field+0x226>
    89de:	7f c1       	rjmp	.+766    	; 0x8cde <WebBuf2Field+0x524>
    89e0:	7b c1       	rjmp	.+758    	; 0x8cd8 <WebBuf2Field+0x51e>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    89e2:	b8 01       	movw	r22, r16
    89e4:	c6 01       	movw	r24, r12
    89e6:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    89ea:	ce 01       	movw	r24, r28
    89ec:	05 96       	adiw	r24, 0x05	; 5
    89ee:	9f 93       	push	r25
    89f0:	8f 93       	push	r24
    89f2:	8b e9       	ldi	r24, 0x9B	; 155
    89f4:	91 e0       	ldi	r25, 0x01	; 1
    89f6:	9f 93       	push	r25
    89f8:	8f 93       	push	r24
    89fa:	1f 93       	push	r17
    89fc:	0f 93       	push	r16
    89fe:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		SetField(Temp, uint16_t);
    8a02:	8d 81       	ldd	r24, Y+5	; 0x05
    8a04:	9e 81       	ldd	r25, Y+6	; 0x06
    8a06:	af 81       	ldd	r26, Y+7	; 0x07
    8a08:	b8 85       	ldd	r27, Y+8	; 0x08
    8a0a:	0f 90       	pop	r0
    8a0c:	0f 90       	pop	r0
    8a0e:	0f 90       	pop	r0
    8a10:	0f 90       	pop	r0
    8a12:	0f 90       	pop	r0
    8a14:	0f 90       	pop	r0
    8a16:	b5 01       	movw	r22, r10
    8a18:	a4 01       	movw	r20, r8
    8a1a:	66 27       	eor	r22, r22
    8a1c:	77 27       	eor	r23, r23
    8a1e:	48 17       	cp	r20, r24
    8a20:	59 07       	cpc	r21, r25
    8a22:	6a 07       	cpc	r22, r26
    8a24:	7b 07       	cpc	r23, r27
    8a26:	08 f4       	brcc	.+2      	; 0x8a2a <WebBuf2Field+0x270>
    8a28:	5b c0       	rjmp	.+182    	; 0x8ae0 <WebBuf2Field+0x326>
    8a2a:	b3 01       	movw	r22, r6
    8a2c:	a2 01       	movw	r20, r4
    8a2e:	66 27       	eor	r22, r22
    8a30:	77 27       	eor	r23, r23
    8a32:	5f c0       	rjmp	.+190    	; 0x8af2 <WebBuf2Field+0x338>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8a34:	b8 01       	movw	r22, r16
    8a36:	c6 01       	movw	r24, r12
    8a38:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8a3c:	ce 01       	movw	r24, r28
    8a3e:	05 96       	adiw	r24, 0x05	; 5
    8a40:	9f 93       	push	r25
    8a42:	8f 93       	push	r24
    8a44:	8f e9       	ldi	r24, 0x9F	; 159
    8a46:	91 e0       	ldi	r25, 0x01	; 1
    8a48:	9f 93       	push	r25
    8a4a:	8f 93       	push	r24
    8a4c:	1f 93       	push	r17
    8a4e:	0f 93       	push	r16
    8a50:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    8a54:	0f 90       	pop	r0
    8a56:	0f 90       	pop	r0
    8a58:	0f 90       	pop	r0
    8a5a:	0f 90       	pop	r0
    8a5c:	0f 90       	pop	r0
    8a5e:	0f 90       	pop	r0
    8a60:	01 97       	sbiw	r24, 0x01	; 1
    8a62:	09 f0       	breq	.+2      	; 0x8a66 <WebBuf2Field+0x2ac>
    8a64:	f2 c1       	rjmp	.+996    	; 0x8e4a <WebBuf2Field+0x690>
			SetEEField(Temp, uint16_t, uint16_t, w);
    8a66:	6d 81       	ldd	r22, Y+5	; 0x05
    8a68:	7e 81       	ldd	r23, Y+6	; 0x06
    8a6a:	8f 81       	ldd	r24, Y+7	; 0x07
    8a6c:	98 85       	ldd	r25, Y+8	; 0x08
    8a6e:	95 01       	movw	r18, r10
    8a70:	84 01       	movw	r16, r8
    8a72:	22 27       	eor	r18, r18
    8a74:	33 27       	eor	r19, r19
    8a76:	06 17       	cp	r16, r22
    8a78:	17 07       	cpc	r17, r23
    8a7a:	28 07       	cpc	r18, r24
    8a7c:	39 07       	cpc	r19, r25
    8a7e:	08 f4       	brcc	.+2      	; 0x8a82 <WebBuf2Field+0x2c8>
    8a80:	64 c0       	rjmp	.+200    	; 0x8b4a <WebBuf2Field+0x390>
    8a82:	93 01       	movw	r18, r6
    8a84:	82 01       	movw	r16, r4
    8a86:	22 27       	eor	r18, r18
    8a88:	33 27       	eor	r19, r19
    8a8a:	60 17       	cp	r22, r16
    8a8c:	71 07       	cpc	r23, r17
    8a8e:	82 07       	cpc	r24, r18
    8a90:	93 07       	cpc	r25, r19
    8a92:	08 f0       	brcs	.+2      	; 0x8a96 <WebBuf2Field+0x2dc>
    8a94:	60 c0       	rjmp	.+192    	; 0x8b56 <WebBuf2Field+0x39c>
    8a96:	5e c0       	rjmp	.+188    	; 0x8b54 <WebBuf2Field+0x39a>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    8a98:	b8 01       	movw	r22, r16
    8a9a:	c6 01       	movw	r24, r12
    8a9c:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    8aa0:	ce 01       	movw	r24, r28
    8aa2:	05 96       	adiw	r24, 0x05	; 5
    8aa4:	9f 93       	push	r25
    8aa6:	8f 93       	push	r24
    8aa8:	84 ea       	ldi	r24, 0xA4	; 164
    8aaa:	91 e0       	ldi	r25, 0x01	; 1
    8aac:	9f 93       	push	r25
    8aae:	8f 93       	push	r24
    8ab0:	1f 93       	push	r17
    8ab2:	0f 93       	push	r16
    8ab4:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		SetField(Temp, int16_t);
    8ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    8aba:	9e 81       	ldd	r25, Y+6	; 0x06
    8abc:	af 81       	ldd	r26, Y+7	; 0x07
    8abe:	b8 85       	ldd	r27, Y+8	; 0x08
    8ac0:	0f 90       	pop	r0
    8ac2:	0f 90       	pop	r0
    8ac4:	0f 90       	pop	r0
    8ac6:	0f 90       	pop	r0
    8ac8:	0f 90       	pop	r0
    8aca:	0f 90       	pop	r0
    8acc:	a4 01       	movw	r20, r8
    8ace:	66 27       	eor	r22, r22
    8ad0:	57 fd       	sbrc	r21, 7
    8ad2:	60 95       	com	r22
    8ad4:	76 2f       	mov	r23, r22
    8ad6:	48 17       	cp	r20, r24
    8ad8:	59 07       	cpc	r21, r25
    8ada:	6a 07       	cpc	r22, r26
    8adc:	7b 07       	cpc	r23, r27
    8ade:	20 f4       	brcc	.+8      	; 0x8ae8 <WebBuf2Field+0x32e>
    8ae0:	f7 01       	movw	r30, r14
    8ae2:	91 82       	std	Z+1, r9	; 0x01
    8ae4:	80 82       	st	Z, r8
    8ae6:	b1 c1       	rjmp	.+866    	; 0x8e4a <WebBuf2Field+0x690>
    8ae8:	a2 01       	movw	r20, r4
    8aea:	66 27       	eor	r22, r22
    8aec:	57 fd       	sbrc	r21, 7
    8aee:	60 95       	com	r22
    8af0:	76 2f       	mov	r23, r22
    8af2:	f7 01       	movw	r30, r14
    8af4:	84 17       	cp	r24, r20
    8af6:	95 07       	cpc	r25, r21
    8af8:	a6 07       	cpc	r26, r22
    8afa:	b7 07       	cpc	r27, r23
    8afc:	18 f4       	brcc	.+6      	; 0x8b04 <WebBuf2Field+0x34a>
    8afe:	51 82       	std	Z+1, r5	; 0x01
    8b00:	40 82       	st	Z, r4
    8b02:	a3 c1       	rjmp	.+838    	; 0x8e4a <WebBuf2Field+0x690>
    8b04:	91 83       	std	Z+1, r25	; 0x01
    8b06:	80 83       	st	Z, r24
    8b08:	a0 c1       	rjmp	.+832    	; 0x8e4a <WebBuf2Field+0x690>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8b0a:	b8 01       	movw	r22, r16
    8b0c:	c6 01       	movw	r24, r12
    8b0e:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    8b12:	ce 01       	movw	r24, r28
    8b14:	05 96       	adiw	r24, 0x05	; 5
    8b16:	9f 93       	push	r25
    8b18:	8f 93       	push	r24
    8b1a:	84 ea       	ldi	r24, 0xA4	; 164
    8b1c:	91 e0       	ldi	r25, 0x01	; 1
    8b1e:	9f 93       	push	r25
    8b20:	8f 93       	push	r24
    8b22:	1f 93       	push	r17
    8b24:	0f 93       	push	r16
    8b26:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    8b2a:	0f 90       	pop	r0
    8b2c:	0f 90       	pop	r0
    8b2e:	0f 90       	pop	r0
    8b30:	0f 90       	pop	r0
    8b32:	0f 90       	pop	r0
    8b34:	0f 90       	pop	r0
    8b36:	01 97       	sbiw	r24, 0x01	; 1
    8b38:	09 f0       	breq	.+2      	; 0x8b3c <WebBuf2Field+0x382>
    8b3a:	87 c1       	rjmp	.+782    	; 0x8e4a <WebBuf2Field+0x690>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    8b3c:	6d 81       	ldd	r22, Y+5	; 0x05
    8b3e:	7e 81       	ldd	r23, Y+6	; 0x06
    8b40:	8f 81       	ldd	r24, Y+7	; 0x07
    8b42:	98 85       	ldd	r25, Y+8	; 0x08
    8b44:	86 16       	cp	r8, r22
    8b46:	97 06       	cpc	r9, r23
    8b48:	14 f4       	brge	.+4      	; 0x8b4e <WebBuf2Field+0x394>
    8b4a:	b4 01       	movw	r22, r8
    8b4c:	04 c0       	rjmp	.+8      	; 0x8b56 <WebBuf2Field+0x39c>
    8b4e:	64 15       	cp	r22, r4
    8b50:	75 05       	cpc	r23, r5
    8b52:	0c f4       	brge	.+2      	; 0x8b56 <WebBuf2Field+0x39c>
    8b54:	b2 01       	movw	r22, r4
    8b56:	c7 01       	movw	r24, r14
    8b58:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>
    8b5c:	76 c1       	rjmp	.+748    	; 0x8e4a <WebBuf2Field+0x690>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    8b5e:	f7 01       	movw	r30, r14
    8b60:	11 82       	std	Z+1, r1	; 0x01
    8b62:	10 82       	st	Z, r1
		break;
    8b64:	72 c1       	rjmp	.+740    	; 0x8e4a <WebBuf2Field+0x690>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8b66:	b8 01       	movw	r22, r16
    8b68:	c6 01       	movw	r24, r12
    8b6a:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    8b6e:	ce 01       	movw	r24, r28
    8b70:	05 96       	adiw	r24, 0x05	; 5
    8b72:	9f 93       	push	r25
    8b74:	8f 93       	push	r24
    8b76:	8f e9       	ldi	r24, 0x9F	; 159
    8b78:	91 e0       	ldi	r25, 0x01	; 1
    8b7a:	15 c0       	rjmp	.+42     	; 0x8ba6 <WebBuf2Field+0x3ec>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8b7c:	b8 01       	movw	r22, r16
    8b7e:	c6 01       	movw	r24, r12
    8b80:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8b84:	ce 01       	movw	r24, r28
    8b86:	05 96       	adiw	r24, 0x05	; 5
    8b88:	9f 93       	push	r25
    8b8a:	8f 93       	push	r24
    8b8c:	8f e9       	ldi	r24, 0x9F	; 159
    8b8e:	91 e0       	ldi	r25, 0x01	; 1
    8b90:	3e c0       	rjmp	.+124    	; 0x8c0e <WebBuf2Field+0x454>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    8b92:	b8 01       	movw	r22, r16
    8b94:	c6 01       	movw	r24, r12
    8b96:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    8b9a:	ce 01       	movw	r24, r28
    8b9c:	05 96       	adiw	r24, 0x05	; 5
    8b9e:	9f 93       	push	r25
    8ba0:	8f 93       	push	r24
    8ba2:	87 ea       	ldi	r24, 0xA7	; 167
    8ba4:	91 e0       	ldi	r25, 0x01	; 1
    8ba6:	9f 93       	push	r25
    8ba8:	8f 93       	push	r24
    8baa:	1f 93       	push	r17
    8bac:	0f 93       	push	r16
    8bae:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		SetField(Temp, int32_t);
    8bb2:	8d 81       	ldd	r24, Y+5	; 0x05
    8bb4:	9e 81       	ldd	r25, Y+6	; 0x06
    8bb6:	af 81       	ldd	r26, Y+7	; 0x07
    8bb8:	b8 85       	ldd	r27, Y+8	; 0x08
    8bba:	0f 90       	pop	r0
    8bbc:	0f 90       	pop	r0
    8bbe:	0f 90       	pop	r0
    8bc0:	0f 90       	pop	r0
    8bc2:	0f 90       	pop	r0
    8bc4:	0f 90       	pop	r0
    8bc6:	f7 01       	movw	r30, r14
    8bc8:	88 16       	cp	r8, r24
    8bca:	99 06       	cpc	r9, r25
    8bcc:	aa 06       	cpc	r10, r26
    8bce:	bb 06       	cpc	r11, r27
    8bd0:	28 f4       	brcc	.+10     	; 0x8bdc <WebBuf2Field+0x422>
    8bd2:	80 82       	st	Z, r8
    8bd4:	91 82       	std	Z+1, r9	; 0x01
    8bd6:	a2 82       	std	Z+2, r10	; 0x02
    8bd8:	b3 82       	std	Z+3, r11	; 0x03
    8bda:	37 c1       	rjmp	.+622    	; 0x8e4a <WebBuf2Field+0x690>
    8bdc:	84 15       	cp	r24, r4
    8bde:	95 05       	cpc	r25, r5
    8be0:	a6 05       	cpc	r26, r6
    8be2:	b7 05       	cpc	r27, r7
    8be4:	28 f4       	brcc	.+10     	; 0x8bf0 <WebBuf2Field+0x436>
    8be6:	40 82       	st	Z, r4
    8be8:	51 82       	std	Z+1, r5	; 0x01
    8bea:	62 82       	std	Z+2, r6	; 0x02
    8bec:	73 82       	std	Z+3, r7	; 0x03
    8bee:	2d c1       	rjmp	.+602    	; 0x8e4a <WebBuf2Field+0x690>
    8bf0:	80 83       	st	Z, r24
    8bf2:	91 83       	std	Z+1, r25	; 0x01
    8bf4:	a2 83       	std	Z+2, r26	; 0x02
    8bf6:	b3 83       	std	Z+3, r27	; 0x03
    8bf8:	28 c1       	rjmp	.+592    	; 0x8e4a <WebBuf2Field+0x690>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8bfa:	b8 01       	movw	r22, r16
    8bfc:	c6 01       	movw	r24, r12
    8bfe:	0e 94 a0 43 	call	0x8740	; 0x8740 <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    8c02:	ce 01       	movw	r24, r28
    8c04:	05 96       	adiw	r24, 0x05	; 5
    8c06:	9f 93       	push	r25
    8c08:	8f 93       	push	r24
    8c0a:	87 ea       	ldi	r24, 0xA7	; 167
    8c0c:	91 e0       	ldi	r25, 0x01	; 1
    8c0e:	9f 93       	push	r25
    8c10:	8f 93       	push	r24
    8c12:	1f 93       	push	r17
    8c14:	0f 93       	push	r16
    8c16:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    8c1a:	0f 90       	pop	r0
    8c1c:	0f 90       	pop	r0
    8c1e:	0f 90       	pop	r0
    8c20:	0f 90       	pop	r0
    8c22:	0f 90       	pop	r0
    8c24:	0f 90       	pop	r0
    8c26:	01 97       	sbiw	r24, 0x01	; 1
    8c28:	09 f0       	breq	.+2      	; 0x8c2c <WebBuf2Field+0x472>
    8c2a:	0f c1       	rjmp	.+542    	; 0x8e4a <WebBuf2Field+0x690>
			SetEEField(Temp, int32_t, uint32_t, d);
    8c2c:	4d 81       	ldd	r20, Y+5	; 0x05
    8c2e:	5e 81       	ldd	r21, Y+6	; 0x06
    8c30:	6f 81       	ldd	r22, Y+7	; 0x07
    8c32:	78 85       	ldd	r23, Y+8	; 0x08
    8c34:	84 16       	cp	r8, r20
    8c36:	95 06       	cpc	r9, r21
    8c38:	a6 06       	cpc	r10, r22
    8c3a:	b7 06       	cpc	r11, r23
    8c3c:	18 f4       	brcc	.+6      	; 0x8c44 <WebBuf2Field+0x48a>
    8c3e:	b5 01       	movw	r22, r10
    8c40:	a4 01       	movw	r20, r8
    8c42:	07 c0       	rjmp	.+14     	; 0x8c52 <WebBuf2Field+0x498>
    8c44:	44 15       	cp	r20, r4
    8c46:	55 05       	cpc	r21, r5
    8c48:	66 05       	cpc	r22, r6
    8c4a:	77 05       	cpc	r23, r7
    8c4c:	10 f4       	brcc	.+4      	; 0x8c52 <WebBuf2Field+0x498>
    8c4e:	b3 01       	movw	r22, r6
    8c50:	a2 01       	movw	r20, r4
    8c52:	c7 01       	movw	r24, r14
    8c54:	0e 94 cd 29 	call	0x539a	; 0x539a <ewd>
    8c58:	f8 c0       	rjmp	.+496    	; 0x8e4a <WebBuf2Field+0x690>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    8c5a:	ce 01       	movw	r24, r28
    8c5c:	01 96       	adiw	r24, 0x01	; 1
    8c5e:	9f 93       	push	r25
    8c60:	8f 93       	push	r24
    8c62:	8b ea       	ldi	r24, 0xAB	; 171
    8c64:	91 e0       	ldi	r25, 0x01	; 1
    8c66:	9f 93       	push	r25
    8c68:	8f 93       	push	r24
    8c6a:	1f 93       	push	r17
    8c6c:	0f 93       	push	r16
    8c6e:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		*(float*)Var = fTemp;
    8c72:	89 81       	ldd	r24, Y+1	; 0x01
    8c74:	9a 81       	ldd	r25, Y+2	; 0x02
    8c76:	ab 81       	ldd	r26, Y+3	; 0x03
    8c78:	bc 81       	ldd	r27, Y+4	; 0x04
    8c7a:	f7 01       	movw	r30, r14
    8c7c:	80 83       	st	Z, r24
    8c7e:	91 83       	std	Z+1, r25	; 0x01
    8c80:	a2 83       	std	Z+2, r26	; 0x02
    8c82:	b3 83       	std	Z+3, r27	; 0x03
		break;
    8c84:	0f 90       	pop	r0
    8c86:	0f 90       	pop	r0
    8c88:	0f 90       	pop	r0
    8c8a:	0f 90       	pop	r0
    8c8c:	0f 90       	pop	r0
    8c8e:	0f 90       	pop	r0
    8c90:	dc c0       	rjmp	.+440    	; 0x8e4a <WebBuf2Field+0x690>
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    8c92:	9e 01       	movw	r18, r28
    8c94:	2f 5f       	subi	r18, 0xFF	; 255
    8c96:	3f 4f       	sbci	r19, 0xFF	; 255
    8c98:	59 01       	movw	r10, r18
    8c9a:	bf 92       	push	r11
    8c9c:	2f 93       	push	r18
    8c9e:	8b ea       	ldi	r24, 0xAB	; 171
    8ca0:	91 e0       	ldi	r25, 0x01	; 1
    8ca2:	9f 93       	push	r25
    8ca4:	8f 93       	push	r24
    8ca6:	1f 93       	push	r17
    8ca8:	0f 93       	push	r16
    8caa:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
    8cae:	0f 90       	pop	r0
    8cb0:	0f 90       	pop	r0
    8cb2:	0f 90       	pop	r0
    8cb4:	0f 90       	pop	r0
    8cb6:	0f 90       	pop	r0
    8cb8:	0f 90       	pop	r0
    8cba:	01 97       	sbiw	r24, 0x01	; 1
    8cbc:	09 f0       	breq	.+2      	; 0x8cc0 <WebBuf2Field+0x506>
    8cbe:	c5 c0       	rjmp	.+394    	; 0x8e4a <WebBuf2Field+0x690>
			ewbl(&fTemp, (float*)Var, 4);
    8cc0:	44 e0       	ldi	r20, 0x04	; 4
    8cc2:	50 e0       	ldi	r21, 0x00	; 0
    8cc4:	b7 01       	movw	r22, r14
    8cc6:	c5 01       	movw	r24, r10
    8cc8:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
    8ccc:	be c0       	rjmp	.+380    	; 0x8e4a <WebBuf2Field+0x690>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    8cce:	f7 01       	movw	r30, r14
    8cd0:	40 82       	st	Z, r4
    8cd2:	bb c0       	rjmp	.+374    	; 0x8e4a <WebBuf2Field+0x690>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    8cd4:	44 20       	and	r4, r4
    8cd6:	11 f0       	breq	.+4      	; 0x8cdc <WebBuf2Field+0x522>
    8cd8:	64 2d       	mov	r22, r4
    8cda:	01 c0       	rjmp	.+2      	; 0x8cde <WebBuf2Field+0x524>
    8cdc:	60 e0       	ldi	r22, 0x00	; 0
    8cde:	c7 01       	movw	r24, r14
    8ce0:	43 c0       	rjmp	.+134    	; 0x8d68 <WebBuf2Field+0x5ae>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8ce2:	ce 01       	movw	r24, r28
    8ce4:	05 96       	adiw	r24, 0x05	; 5
    8ce6:	9f 93       	push	r25
    8ce8:	8f 93       	push	r24
    8cea:	82 e9       	ldi	r24, 0x92	; 146
    8cec:	91 e0       	ldi	r25, 0x01	; 1
    8cee:	9f 93       	push	r25
    8cf0:	8f 93       	push	r24
    8cf2:	1f 93       	push	r17
    8cf4:	0f 93       	push	r16
    8cf6:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
		if((unsigned short int)Temp)
    8cfa:	0f 90       	pop	r0
    8cfc:	0f 90       	pop	r0
    8cfe:	0f 90       	pop	r0
    8d00:	0f 90       	pop	r0
    8d02:	0f 90       	pop	r0
    8d04:	0f 90       	pop	r0
    8d06:	8d 81       	ldd	r24, Y+5	; 0x05
    8d08:	9e 81       	ldd	r25, Y+6	; 0x06
    8d0a:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d0c:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d0e:	20 81       	ld	r18, Z
			*BitVar |=Mask;
    8d10:	89 84       	ldd	r8, Y+9	; 0x09
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
		if((unsigned short int)Temp)
    8d12:	89 2b       	or	r24, r25
    8d14:	19 f0       	breq	.+6      	; 0x8d1c <WebBuf2Field+0x562>
			*BitVar |=Mask;
    8d16:	82 2a       	or	r8, r18
    8d18:	80 82       	st	Z, r8
    8d1a:	97 c0       	rjmp	.+302    	; 0x8e4a <WebBuf2Field+0x690>
		else
			*BitVar &=~Mask;
    8d1c:	80 94       	com	r8
    8d1e:	82 22       	and	r8, r18
    8d20:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d22:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d24:	f9 cf       	rjmp	.-14     	; 0x8d18 <WebBuf2Field+0x55e>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8d26:	ce 01       	movw	r24, r28
    8d28:	05 96       	adiw	r24, 0x05	; 5
    8d2a:	9f 93       	push	r25
    8d2c:	8f 93       	push	r24
    8d2e:	82 e9       	ldi	r24, 0x92	; 146
    8d30:	91 e0       	ldi	r25, 0x01	; 1
    8d32:	9f 93       	push	r25
    8d34:	8f 93       	push	r24
    8d36:	1f 93       	push	r17
    8d38:	0f 93       	push	r16
    8d3a:	0e 94 33 6d 	call	0xda66	; 0xda66 <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8d3e:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d40:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d42:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    8d46:	0f 90       	pop	r0
    8d48:	0f 90       	pop	r0
    8d4a:	0f 90       	pop	r0
    8d4c:	0f 90       	pop	r0
    8d4e:	0f 90       	pop	r0
    8d50:	0f 90       	pop	r0
    8d52:	2d 81       	ldd	r18, Y+5	; 0x05
    8d54:	3e 81       	ldd	r19, Y+6	; 0x06
    8d56:	69 85       	ldd	r22, Y+9	; 0x09
    8d58:	23 2b       	or	r18, r19
    8d5a:	11 f0       	breq	.+4      	; 0x8d60 <WebBuf2Field+0x5a6>
    8d5c:	68 2b       	or	r22, r24
    8d5e:	02 c0       	rjmp	.+4      	; 0x8d64 <WebBuf2Field+0x5aa>
    8d60:	60 95       	com	r22
    8d62:	68 23       	and	r22, r24
    8d64:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d66:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d68:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
		break;
    8d6c:	6e c0       	rjmp	.+220    	; 0x8e4a <WebBuf2Field+0x690>
    8d6e:	ad b6       	in	r10, 0x3d	; 61
    8d70:	be b6       	in	r11, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8d72:	f1 01       	movw	r30, r2
    8d74:	24 90       	lpm	r2, Z


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8d76:	31 2c       	mov	r3, r1
    8d78:	2d b7       	in	r18, 0x3d	; 61
    8d7a:	3e b7       	in	r19, 0x3e	; 62
    8d7c:	22 19       	sub	r18, r2
    8d7e:	33 09       	sbc	r19, r3
    8d80:	0f b6       	in	r0, 0x3f	; 63
    8d82:	f8 94       	cli
    8d84:	3e bf       	out	0x3e, r19	; 62
    8d86:	0f be       	out	0x3f, r0	; 63
    8d88:	2d bf       	out	0x3d, r18	; 61
    8d8a:	6d b7       	in	r22, 0x3d	; 61
    8d8c:	7e b7       	in	r23, 0x3e	; 62
    8d8e:	6f 5f       	subi	r22, 0xFF	; 255
    8d90:	7f 4f       	sbci	r23, 0xFF	; 255
		uint8_t i=0;
    8d92:	90 e0       	ldi	r25, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d94:	31 e0       	ldi	r19, 0x01	; 1
    8d96:	23 1a       	sub	r2, r19
    8d98:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8d9a:	20 e2       	ldi	r18, 0x20	; 32
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d9c:	49 2f       	mov	r20, r25
    8d9e:	50 e0       	ldi	r21, 0x00	; 0
    8da0:	fb 01       	movw	r30, r22
    8da2:	e4 0f       	add	r30, r20
    8da4:	f5 1f       	adc	r31, r21
    8da6:	42 15       	cp	r20, r2
    8da8:	53 05       	cpc	r21, r3
    8daa:	3c f0       	brlt	.+14     	; 0x8dba <WebBuf2Field+0x600>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8dac:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    8dae:	4f 5f       	subi	r20, 0xFF	; 255
    8db0:	5f 4f       	sbci	r21, 0xFF	; 255
    8db2:	c7 01       	movw	r24, r14
    8db4:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
    8db8:	33 c0       	rjmp	.+102    	; 0x8e20 <WebBuf2Field+0x666>
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dba:	d8 01       	movw	r26, r16
    8dbc:	a4 0f       	add	r26, r20
    8dbe:	b5 1f       	adc	r27, r21
    8dc0:	8c 91       	ld	r24, X
    8dc2:	80 32       	cpi	r24, 0x20	; 32
    8dc4:	99 f3       	breq	.-26     	; 0x8dac <WebBuf2Field+0x5f2>
    8dc6:	86 32       	cpi	r24, 0x26	; 38
    8dc8:	89 f3       	breq	.-30     	; 0x8dac <WebBuf2Field+0x5f2>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8dca:	8b 32       	cpi	r24, 0x2B	; 43
    8dcc:	11 f4       	brne	.+4      	; 0x8dd2 <WebBuf2Field+0x618>
    8dce:	20 83       	st	Z, r18
    8dd0:	01 c0       	rjmp	.+2      	; 0x8dd4 <WebBuf2Field+0x61a>
			else TempStr[i]=BufStr[i];
    8dd2:	80 83       	st	Z, r24
			i++;
    8dd4:	9f 5f       	subi	r25, 0xFF	; 255
    8dd6:	e2 cf       	rjmp	.-60     	; 0x8d9c <WebBuf2Field+0x5e2>
    8dd8:	ad b6       	in	r10, 0x3d	; 61
    8dda:	be b6       	in	r11, 0x3e	; 62
    8ddc:	f1 01       	movw	r30, r2
    8dde:	24 90       	lpm	r2, Z

		break;
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8de0:	31 2c       	mov	r3, r1
    8de2:	2d b7       	in	r18, 0x3d	; 61
    8de4:	3e b7       	in	r19, 0x3e	; 62
    8de6:	22 19       	sub	r18, r2
    8de8:	33 09       	sbc	r19, r3
    8dea:	0f b6       	in	r0, 0x3f	; 63
    8dec:	f8 94       	cli
    8dee:	3e bf       	out	0x3e, r19	; 62
    8df0:	0f be       	out	0x3f, r0	; 63
    8df2:	2d bf       	out	0x3d, r18	; 61
    8df4:	8d b7       	in	r24, 0x3d	; 61
    8df6:	9e b7       	in	r25, 0x3e	; 62
    8df8:	01 96       	adiw	r24, 0x01	; 1
		uint8_t i=0;
    8dfa:	30 e0       	ldi	r19, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dfc:	e1 e0       	ldi	r30, 0x01	; 1
    8dfe:	2e 1a       	sub	r2, r30
    8e00:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e02:	60 e2       	ldi	r22, 0x20	; 32
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e04:	43 2f       	mov	r20, r19
    8e06:	50 e0       	ldi	r21, 0x00	; 0
    8e08:	fc 01       	movw	r30, r24
    8e0a:	e4 0f       	add	r30, r20
    8e0c:	f5 1f       	adc	r31, r21
    8e0e:	42 15       	cp	r20, r2
    8e10:	53 05       	cpc	r21, r3
    8e12:	64 f0       	brlt	.+24     	; 0x8e2c <WebBuf2Field+0x672>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8e14:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    8e16:	4f 5f       	subi	r20, 0xFF	; 255
    8e18:	5f 4f       	sbci	r21, 0xFF	; 255
    8e1a:	b7 01       	movw	r22, r14
    8e1c:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
    8e20:	0f b6       	in	r0, 0x3f	; 63
    8e22:	f8 94       	cli
    8e24:	be be       	out	0x3e, r11	; 62
    8e26:	0f be       	out	0x3f, r0	; 63
    8e28:	ad be       	out	0x3d, r10	; 61
		}
		break;
    8e2a:	0f c0       	rjmp	.+30     	; 0x8e4a <WebBuf2Field+0x690>
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e2c:	d8 01       	movw	r26, r16
    8e2e:	a4 0f       	add	r26, r20
    8e30:	b5 1f       	adc	r27, r21
    8e32:	2c 91       	ld	r18, X
    8e34:	20 32       	cpi	r18, 0x20	; 32
    8e36:	71 f3       	breq	.-36     	; 0x8e14 <WebBuf2Field+0x65a>
    8e38:	26 32       	cpi	r18, 0x26	; 38
    8e3a:	61 f3       	breq	.-40     	; 0x8e14 <WebBuf2Field+0x65a>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e3c:	2b 32       	cpi	r18, 0x2B	; 43
    8e3e:	11 f4       	brne	.+4      	; 0x8e44 <WebBuf2Field+0x68a>
    8e40:	60 83       	st	Z, r22
    8e42:	01 c0       	rjmp	.+2      	; 0x8e46 <WebBuf2Field+0x68c>
			else TempStr[i]=BufStr[i];
    8e44:	20 83       	st	Z, r18
			i++;
    8e46:	3f 5f       	subi	r19, 0xFF	; 255
    8e48:	dd cf       	rjmp	.-70     	; 0x8e04 <WebBuf2Field+0x64a>
		ewbl(TempStr, Var, i+1);
		}
		break;
	}

	EventFunc(&Field->Act);
    8e4a:	fb e0       	ldi	r31, 0x0B	; 11
    8e4c:	cf 0e       	add	r12, r31
    8e4e:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8e50:	f6 01       	movw	r30, r12
    8e52:	85 91       	lpm	r24, Z+
    8e54:	94 91       	lpm	r25, Z
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8e56:	00 97       	sbiw	r24, 0x00	; 0
    8e58:	11 f0       	breq	.+4      	; 0x8e5e <WebBuf2Field+0x6a4>
		Func();
    8e5a:	fc 01       	movw	r30, r24
    8e5c:	09 95       	icall
}
    8e5e:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e60:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e62:	0f b6       	in	r0, 0x3f	; 63
    8e64:	f8 94       	cli
    8e66:	3e bf       	out	0x3e, r19	; 62
    8e68:	0f be       	out	0x3f, r0	; 63
    8e6a:	2d bf       	out	0x3d, r18	; 61
    8e6c:	2e 96       	adiw	r28, 0x0e	; 14
    8e6e:	0f b6       	in	r0, 0x3f	; 63
    8e70:	f8 94       	cli
    8e72:	de bf       	out	0x3e, r29	; 62
    8e74:	0f be       	out	0x3f, r0	; 63
    8e76:	cd bf       	out	0x3d, r28	; 61
    8e78:	df 91       	pop	r29
    8e7a:	cf 91       	pop	r28
    8e7c:	1f 91       	pop	r17
    8e7e:	0f 91       	pop	r16
    8e80:	ff 90       	pop	r15
    8e82:	ef 90       	pop	r14
    8e84:	df 90       	pop	r13
    8e86:	cf 90       	pop	r12
    8e88:	bf 90       	pop	r11
    8e8a:	af 90       	pop	r10
    8e8c:	9f 90       	pop	r9
    8e8e:	8f 90       	pop	r8
    8e90:	7f 90       	pop	r7
    8e92:	6f 90       	pop	r6
    8e94:	5f 90       	pop	r5
    8e96:	4f 90       	pop	r4
    8e98:	3f 90       	pop	r3
    8e9a:	2f 90       	pop	r2
    8e9c:	08 95       	ret

00008e9e <strcmp_PP>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8e9e:	fc 01       	movw	r30, r24
    8ea0:	24 91       	lpm	r18, Z
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    8ea2:	22 23       	and	r18, r18
    8ea4:	c1 f0       	breq	.+48     	; 0x8ed6 <strcmp_PP+0x38>
    8ea6:	fb 01       	movw	r30, r22
    8ea8:	24 91       	lpm	r18, Z
    8eaa:	22 23       	and	r18, r18
    8eac:	a1 f0       	breq	.+40     	; 0x8ed6 <strcmp_PP+0x38>
    8eae:	fc 01       	movw	r30, r24
    8eb0:	24 91       	lpm	r18, Z
    8eb2:	fb 01       	movw	r30, r22
    8eb4:	34 91       	lpm	r19, Z
		if(prb(s1) > prb(s2)) return 1;
    8eb6:	32 17       	cp	r19, r18
    8eb8:	50 f0       	brcs	.+20     	; 0x8ece <strcmp_PP+0x30>
    8eba:	fc 01       	movw	r30, r24
    8ebc:	24 91       	lpm	r18, Z
    8ebe:	fb 01       	movw	r30, r22
    8ec0:	34 91       	lpm	r19, Z
		if(prb(s1) < prb(s2)) return -1;
    8ec2:	23 17       	cp	r18, r19
    8ec4:	30 f0       	brcs	.+12     	; 0x8ed2 <strcmp_PP+0x34>
		s1++;
    8ec6:	01 96       	adiw	r24, 0x01	; 1
		s2++;
    8ec8:	6f 5f       	subi	r22, 0xFF	; 255
    8eca:	7f 4f       	sbci	r23, 0xFF	; 255
    8ecc:	e8 cf       	rjmp	.-48     	; 0x8e9e <strcmp_PP>
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    8ece:	81 e0       	ldi	r24, 0x01	; 1
    8ed0:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    8ed2:	8f ef       	ldi	r24, 0xFF	; 255
    8ed4:	08 95       	ret
		s1++;
		s2++;
	}
	return 0;	
    8ed6:	80 e0       	ldi	r24, 0x00	; 0
}
    8ed8:	08 95       	ret

00008eda <strcmp_E>:
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    8eda:	ff 92       	push	r15
    8edc:	0f 93       	push	r16
    8ede:	1f 93       	push	r17
    8ee0:	cf 93       	push	r28
    8ee2:	df 93       	push	r29
    8ee4:	eb 01       	movw	r28, r22
    8ee6:	8c 01       	movw	r16, r24
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8ee8:	f8 01       	movw	r30, r16
    8eea:	f1 90       	ld	r15, Z+
    8eec:	8f 01       	movw	r16, r30
    8eee:	ff 20       	and	r15, r15
    8ef0:	49 f0       	breq	.+18     	; 0x8f04 <strcmp_E+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8ef2:	ce 01       	movw	r24, r28
    8ef4:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8ef8:	8f 15       	cp	r24, r15
    8efa:	50 f0       	brcs	.+20     	; 0x8f10 <strcmp_E+0x36>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8efc:	f8 16       	cp	r15, r24
    8efe:	50 f0       	brcs	.+20     	; 0x8f14 <strcmp_E+0x3a>
		str_RAM++;
		str_EE++;		
    8f00:	21 96       	adiw	r28, 0x01	; 1
    8f02:	f2 cf       	rjmp	.-28     	; 0x8ee8 <strcmp_E+0xe>
    8f04:	ce 01       	movw	r24, r28
    8f06:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8f0a:	81 11       	cpse	r24, r1
    8f0c:	f2 cf       	rjmp	.-28     	; 0x8ef2 <strcmp_E+0x18>
    8f0e:	03 c0       	rjmp	.+6      	; 0x8f16 <strcmp_E+0x3c>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8f10:	81 e0       	ldi	r24, 0x01	; 1
    8f12:	01 c0       	rjmp	.+2      	; 0x8f16 <strcmp_E+0x3c>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8f14:	8f ef       	ldi	r24, 0xFF	; 255
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    8f16:	df 91       	pop	r29
    8f18:	cf 91       	pop	r28
    8f1a:	1f 91       	pop	r17
    8f1c:	0f 91       	pop	r16
    8f1e:	ff 90       	pop	r15
    8f20:	08 95       	ret

00008f22 <SeekTagFORM>:
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
	static uint8_t match;
	switch(match) {
    8f22:	40 91 43 02 	lds	r20, 0x0243
    8f26:	50 e0       	ldi	r21, 0x00	; 0
    8f28:	49 30       	cpi	r20, 0x09	; 9
    8f2a:	51 05       	cpc	r21, r1
    8f2c:	88 f5       	brcc	.+98     	; 0x8f90 <SeekTagFORM+0x6e>
    8f2e:	fa 01       	movw	r30, r20
    8f30:	e7 57       	subi	r30, 0x77	; 119
    8f32:	ff 4f       	sbci	r31, 0xFF	; 255
    8f34:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8f38:	8c 33       	cpi	r24, 0x3C	; 60
    8f3a:	61 f5       	brne	.+88     	; 0x8f94 <SeekTagFORM+0x72>
    8f3c:	81 e0       	ldi	r24, 0x01	; 1
    8f3e:	1f c0       	rjmp	.+62     	; 0x8f7e <SeekTagFORM+0x5c>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    8f40:	8f 7d       	andi	r24, 0xDF	; 223
    8f42:	86 34       	cpi	r24, 0x46	; 70
    8f44:	29 f5       	brne	.+74     	; 0x8f90 <SeekTagFORM+0x6e>
    8f46:	82 e0       	ldi	r24, 0x02	; 2
    8f48:	1a c0       	rjmp	.+52     	; 0x8f7e <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    8f4a:	8f 7d       	andi	r24, 0xDF	; 223
    8f4c:	8f 34       	cpi	r24, 0x4F	; 79
    8f4e:	01 f5       	brne	.+64     	; 0x8f90 <SeekTagFORM+0x6e>
    8f50:	83 e0       	ldi	r24, 0x03	; 3
    8f52:	15 c0       	rjmp	.+42     	; 0x8f7e <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    8f54:	8f 7d       	andi	r24, 0xDF	; 223
    8f56:	82 35       	cpi	r24, 0x52	; 82
    8f58:	d9 f4       	brne	.+54     	; 0x8f90 <SeekTagFORM+0x6e>
    8f5a:	84 e0       	ldi	r24, 0x04	; 4
    8f5c:	10 c0       	rjmp	.+32     	; 0x8f7e <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    8f5e:	8f 7d       	andi	r24, 0xDF	; 223
    8f60:	8d 34       	cpi	r24, 0x4D	; 77
    8f62:	b1 f4       	brne	.+44     	; 0x8f90 <SeekTagFORM+0x6e>
    8f64:	85 e0       	ldi	r24, 0x05	; 5
    8f66:	0b c0       	rjmp	.+22     	; 0x8f7e <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    8f68:	80 32       	cpi	r24, 0x20	; 32
    8f6a:	91 f4       	brne	.+36     	; 0x8f90 <SeekTagFORM+0x6e>
    8f6c:	86 e0       	ldi	r24, 0x06	; 6
    8f6e:	07 c0       	rjmp	.+14     	; 0x8f7e <SeekTagFORM+0x5c>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    8f70:	8e 33       	cpi	r24, 0x3E	; 62
    8f72:	81 f4       	brne	.+32     	; 0x8f94 <SeekTagFORM+0x72>
    8f74:	87 e0       	ldi	r24, 0x07	; 7
    8f76:	03 c0       	rjmp	.+6      	; 0x8f7e <SeekTagFORM+0x5c>
			break;
		case 7:
			if(ch=='\r') match = 8;
    8f78:	8d 30       	cpi	r24, 0x0D	; 13
    8f7a:	51 f4       	brne	.+20     	; 0x8f90 <SeekTagFORM+0x6e>
    8f7c:	88 e0       	ldi	r24, 0x08	; 8
    8f7e:	80 93 43 02 	sts	0x0243, r24
    8f82:	08 c0       	rjmp	.+16     	; 0x8f94 <SeekTagFORM+0x72>
			else match = 0;
			break;
		case 8:
			match = 0;
    8f84:	10 92 43 02 	sts	0x0243, r1
			if(ch=='\n') return 1;
    8f88:	91 e0       	ldi	r25, 0x01	; 1
    8f8a:	8a 30       	cpi	r24, 0x0A	; 10
    8f8c:	19 f4       	brne	.+6      	; 0x8f94 <SeekTagFORM+0x72>
    8f8e:	03 c0       	rjmp	.+6      	; 0x8f96 <SeekTagFORM+0x74>
			break;
		default:
			match = 0;
    8f90:	10 92 43 02 	sts	0x0243, r1
	}
	return 0;
    8f94:	90 e0       	ldi	r25, 0x00	; 0

}
    8f96:	89 2f       	mov	r24, r25
    8f98:	08 95       	ret

00008f9a <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    8f9a:	40 91 42 02 	lds	r20, 0x0242
    8f9e:	50 e0       	ldi	r21, 0x00	; 0
    8fa0:	49 30       	cpi	r20, 0x09	; 9
    8fa2:	51 05       	cpc	r21, r1
    8fa4:	90 f5       	brcc	.+100    	; 0x900a <SeekTagA_HREF+0x70>
    8fa6:	fa 01       	movw	r30, r20
    8fa8:	ee 56       	subi	r30, 0x6E	; 110
    8faa:	ff 4f       	sbci	r31, 0xFF	; 255
    8fac:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8fb0:	8c 33       	cpi	r24, 0x3C	; 60
    8fb2:	69 f5       	brne	.+90     	; 0x900e <SeekTagA_HREF+0x74>
    8fb4:	81 e0       	ldi	r24, 0x01	; 1
    8fb6:	20 c0       	rjmp	.+64     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    8fb8:	8f 7d       	andi	r24, 0xDF	; 223
    8fba:	81 34       	cpi	r24, 0x41	; 65
    8fbc:	31 f5       	brne	.+76     	; 0x900a <SeekTagA_HREF+0x70>
    8fbe:	82 e0       	ldi	r24, 0x02	; 2
    8fc0:	1b c0       	rjmp	.+54     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    8fc2:	80 32       	cpi	r24, 0x20	; 32
    8fc4:	11 f5       	brne	.+68     	; 0x900a <SeekTagA_HREF+0x70>
    8fc6:	83 e0       	ldi	r24, 0x03	; 3
    8fc8:	17 c0       	rjmp	.+46     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    8fca:	8f 7d       	andi	r24, 0xDF	; 223
    8fcc:	88 34       	cpi	r24, 0x48	; 72
    8fce:	e9 f4       	brne	.+58     	; 0x900a <SeekTagA_HREF+0x70>
    8fd0:	84 e0       	ldi	r24, 0x04	; 4
    8fd2:	12 c0       	rjmp	.+36     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    8fd4:	8f 7d       	andi	r24, 0xDF	; 223
    8fd6:	82 35       	cpi	r24, 0x52	; 82
    8fd8:	c1 f4       	brne	.+48     	; 0x900a <SeekTagA_HREF+0x70>
    8fda:	85 e0       	ldi	r24, 0x05	; 5
    8fdc:	0d c0       	rjmp	.+26     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    8fde:	8f 7d       	andi	r24, 0xDF	; 223
    8fe0:	85 34       	cpi	r24, 0x45	; 69
    8fe2:	99 f4       	brne	.+38     	; 0x900a <SeekTagA_HREF+0x70>
    8fe4:	86 e0       	ldi	r24, 0x06	; 6
    8fe6:	08 c0       	rjmp	.+16     	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    8fe8:	8f 7d       	andi	r24, 0xDF	; 223
    8fea:	86 34       	cpi	r24, 0x46	; 70
    8fec:	71 f4       	brne	.+28     	; 0x900a <SeekTagA_HREF+0x70>
    8fee:	87 e0       	ldi	r24, 0x07	; 7
    8ff0:	03 c0       	rjmp	.+6      	; 0x8ff8 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    8ff2:	82 32       	cpi	r24, 0x22	; 34
    8ff4:	61 f4       	brne	.+24     	; 0x900e <SeekTagA_HREF+0x74>
    8ff6:	88 e0       	ldi	r24, 0x08	; 8
    8ff8:	80 93 42 02 	sts	0x0242, r24
    8ffc:	08 c0       	rjmp	.+16     	; 0x900e <SeekTagA_HREF+0x74>
			break;
		case 8:
			if(ch=='\"'){
    8ffe:	82 32       	cpi	r24, 0x22	; 34
    9000:	31 f4       	brne	.+12     	; 0x900e <SeekTagA_HREF+0x74>
				match = 0;
    9002:	10 92 42 02 	sts	0x0242, r1
				return 1;
    9006:	81 e0       	ldi	r24, 0x01	; 1
    9008:	08 95       	ret
			}
			break;
		default:
			match = 0;
    900a:	10 92 42 02 	sts	0x0242, r1
	}
	return 0;
    900e:	80 e0       	ldi	r24, 0x00	; 0
}
    9010:	08 95       	ret

00009012 <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    9012:	40 91 41 02 	lds	r20, 0x0241
    9016:	50 e0       	ldi	r21, 0x00	; 0
    9018:	4a 30       	cpi	r20, 0x0A	; 10
    901a:	51 05       	cpc	r21, r1
    901c:	b8 f5       	brcc	.+110    	; 0x908c <SeekTagIMG_SRC+0x7a>
    901e:	fa 01       	movw	r30, r20
    9020:	e5 56       	subi	r30, 0x65	; 101
    9022:	ff 4f       	sbci	r31, 0xFF	; 255
    9024:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    9028:	8c 33       	cpi	r24, 0x3C	; 60
    902a:	91 f5       	brne	.+100    	; 0x9090 <SeekTagIMG_SRC+0x7e>
    902c:	81 e0       	ldi	r24, 0x01	; 1
    902e:	25 c0       	rjmp	.+74     	; 0x907a <SeekTagIMG_SRC+0x68>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    9030:	8f 7d       	andi	r24, 0xDF	; 223
    9032:	89 34       	cpi	r24, 0x49	; 73
    9034:	59 f5       	brne	.+86     	; 0x908c <SeekTagIMG_SRC+0x7a>
    9036:	82 e0       	ldi	r24, 0x02	; 2
    9038:	20 c0       	rjmp	.+64     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    903a:	8f 7d       	andi	r24, 0xDF	; 223
    903c:	8d 34       	cpi	r24, 0x4D	; 77
    903e:	31 f5       	brne	.+76     	; 0x908c <SeekTagIMG_SRC+0x7a>
    9040:	83 e0       	ldi	r24, 0x03	; 3
    9042:	1b c0       	rjmp	.+54     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    9044:	8f 7d       	andi	r24, 0xDF	; 223
    9046:	87 34       	cpi	r24, 0x47	; 71
    9048:	09 f5       	brne	.+66     	; 0x908c <SeekTagIMG_SRC+0x7a>
    904a:	84 e0       	ldi	r24, 0x04	; 4
    904c:	16 c0       	rjmp	.+44     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    904e:	80 32       	cpi	r24, 0x20	; 32
    9050:	e9 f4       	brne	.+58     	; 0x908c <SeekTagIMG_SRC+0x7a>
    9052:	85 e0       	ldi	r24, 0x05	; 5
    9054:	12 c0       	rjmp	.+36     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    9056:	8f 7d       	andi	r24, 0xDF	; 223
    9058:	83 35       	cpi	r24, 0x53	; 83
    905a:	c1 f4       	brne	.+48     	; 0x908c <SeekTagIMG_SRC+0x7a>
    905c:	86 e0       	ldi	r24, 0x06	; 6
    905e:	0d c0       	rjmp	.+26     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    9060:	8f 7d       	andi	r24, 0xDF	; 223
    9062:	82 35       	cpi	r24, 0x52	; 82
    9064:	99 f4       	brne	.+38     	; 0x908c <SeekTagIMG_SRC+0x7a>
    9066:	87 e0       	ldi	r24, 0x07	; 7
    9068:	08 c0       	rjmp	.+16     	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    906a:	8f 7d       	andi	r24, 0xDF	; 223
    906c:	83 34       	cpi	r24, 0x43	; 67
    906e:	71 f4       	brne	.+28     	; 0x908c <SeekTagIMG_SRC+0x7a>
    9070:	88 e0       	ldi	r24, 0x08	; 8
    9072:	03 c0       	rjmp	.+6      	; 0x907a <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    9074:	82 32       	cpi	r24, 0x22	; 34
    9076:	61 f4       	brne	.+24     	; 0x9090 <SeekTagIMG_SRC+0x7e>
    9078:	89 e0       	ldi	r24, 0x09	; 9
    907a:	80 93 41 02 	sts	0x0241, r24
    907e:	08 c0       	rjmp	.+16     	; 0x9090 <SeekTagIMG_SRC+0x7e>
			break;
		case 9:
			if(ch=='\"'){
    9080:	82 32       	cpi	r24, 0x22	; 34
    9082:	31 f4       	brne	.+12     	; 0x9090 <SeekTagIMG_SRC+0x7e>
				match = 0;
    9084:	10 92 41 02 	sts	0x0241, r1
				return 1;
    9088:	81 e0       	ldi	r24, 0x01	; 1
    908a:	08 95       	ret
			}
			break;
		default:
			match = 0;
    908c:	10 92 41 02 	sts	0x0241, r1
	}
	return 0;
    9090:	80 e0       	ldi	r24, 0x00	; 0
}
    9092:	08 95       	ret

00009094 <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    9094:	cf 92       	push	r12
    9096:	df 92       	push	r13
    9098:	ef 92       	push	r14
    909a:	ff 92       	push	r15
    909c:	0f 93       	push	r16
    909e:	1f 93       	push	r17
    90a0:	cf 93       	push	r28
    90a2:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    90a4:	80 91 7e 09 	lds	r24, 0x097E
    90a8:	81 11       	cpse	r24, r1
    90aa:	73 c0       	rjmp	.+230    	; 0x9192 <Web_Login_Error+0xfe>
//	if(strcmp_E(Web_Passw_Str, Web_Passws) ) return 3;
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
    90ac:	10 92 6c 0a 	sts	0x0A6C, r1
    90b0:	0a ef       	ldi	r16, 0xFA	; 250
    90b2:	11 e0       	ldi	r17, 0x01	; 1
    90b4:	ca e2       	ldi	r28, 0x2A	; 42
    90b6:	d0 e0       	ldi	r29, 0x00	; 0
    90b8:	ff 24       	eor	r15, r15
    90ba:	f3 94       	inc	r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    90bc:	f8 01       	movw	r30, r16
    90be:	65 91       	lpm	r22, Z+
    90c0:	74 91       	lpm	r23, Z
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
    90c2:	87 ef       	ldi	r24, 0xF7	; 247
    90c4:	99 e0       	ldi	r25, 0x09	; 9
    90c6:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <strcmp_PP>
    90ca:	81 11       	cpse	r24, r1
    90cc:	09 c0       	rjmp	.+18     	; 0x90e0 <Web_Login_Error+0x4c>
    90ce:	be 01       	movw	r22, r28
    90d0:	84 ef       	ldi	r24, 0xF4	; 244
    90d2:	95 e0       	ldi	r25, 0x05	; 5
    90d4:	0e 94 6d 47 	call	0x8eda	; 0x8eda <strcmp_E>
    90d8:	81 11       	cpse	r24, r1
    90da:	02 c0       	rjmp	.+4      	; 0x90e0 <Web_Login_Error+0x4c>
    90dc:	f0 92 6c 0a 	sts	0x0A6C, r15
    90e0:	f3 94       	inc	r15
    90e2:	00 5f       	subi	r16, 0xF0	; 240
    90e4:	1f 4f       	sbci	r17, 0xFF	; 255
    90e6:	2b 96       	adiw	r28, 0x0b	; 11
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    90e8:	85 e0       	ldi	r24, 0x05	; 5
    90ea:	f8 12       	cpse	r15, r24
    90ec:	e7 cf       	rjmp	.-50     	; 0x90bc <Web_Login_Error+0x28>
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
    90ee:	80 91 6c 0a 	lds	r24, 0x0A6C
    90f2:	88 23       	and	r24, r24
    90f4:	09 f4       	brne	.+2      	; 0x90f8 <Web_Login_Error+0x64>
    90f6:	4f c0       	rjmp	.+158    	; 0x9196 <Web_Login_Error+0x102>
	return 2;}


	WebSession = 1;
    90f8:	81 e0       	ldi	r24, 0x01	; 1
    90fa:	80 93 7e 09 	sts	0x097E, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    90fe:	c0 91 1c 06 	lds	r28, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    9102:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint32_t Time = Timer32[TimerN];
    9106:	94 e0       	ldi	r25, 0x04	; 4
    9108:	c9 9f       	mul	r28, r25
    910a:	f0 01       	movw	r30, r0
    910c:	11 24       	eor	r1, r1
    910e:	ea 57       	subi	r30, 0x7A	; 122
    9110:	fd 4f       	sbci	r31, 0xFD	; 253
    9112:	c0 80       	ld	r12, Z
    9114:	d1 80       	ldd	r13, Z+1	; 0x01
    9116:	e2 80       	ldd	r14, Z+2	; 0x02
    9118:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    911a:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
	srandom(Seed);
    911e:	c7 01       	movw	r24, r14
    9120:	b6 01       	movw	r22, r12
    9122:	0e 94 2e 6c 	call	0xd85c	; 0xd85c <srandom>
	random();// 
    9126:	0e 94 2a 6c 	call	0xd854	; 0xd854 <random>
	Seed = random();
    912a:	0e 94 2a 6c 	call	0xd854	; 0xd854 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    912e:	9f 93       	push	r25
    9130:	8f 93       	push	r24
    9132:	7f 93       	push	r23
    9134:	6f 93       	push	r22
    9136:	8f ef       	ldi	r24, 0xFF	; 255
    9138:	92 e0       	ldi	r25, 0x02	; 2
    913a:	9f 93       	push	r25
    913c:	8f 93       	push	r24
    913e:	89 e2       	ldi	r24, 0x29	; 41
    9140:	96 e0       	ldi	r25, 0x06	; 6
    9142:	9f 93       	push	r25
    9144:	8f 93       	push	r24
    9146:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
	Seed = random();
    914a:	0e 94 2a 6c 	call	0xd854	; 0xd854 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    914e:	9f 93       	push	r25
    9150:	8f 93       	push	r24
    9152:	7f 93       	push	r23
    9154:	6f 93       	push	r22
    9156:	85 ef       	ldi	r24, 0xF5	; 245
    9158:	92 e0       	ldi	r25, 0x02	; 2
    915a:	9f 93       	push	r25
    915c:	8f 93       	push	r24
    915e:	81 e3       	ldi	r24, 0x31	; 49
    9160:	96 e0       	ldi	r25, 0x06	; 6
    9162:	9f 93       	push	r25
    9164:	8f 93       	push	r24
    9166:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    916a:	86 e5       	ldi	r24, 0x56	; 86
    916c:	90 e0       	ldi	r25, 0x00	; 0
    916e:	0e 94 e8 73 	call	0xe7d0	; 0xe7d0 <__eerd_dword_m128>
    9172:	ab 01       	movw	r20, r22
    9174:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    9176:	80 91 68 09 	lds	r24, 0x0968
    917a:	0e 94 09 2c 	call	0x5812	; 0x5812 <StartTimer32>
	return 0;
    917e:	8d b7       	in	r24, 0x3d	; 61
    9180:	9e b7       	in	r25, 0x3e	; 62
    9182:	40 96       	adiw	r24, 0x10	; 16
    9184:	0f b6       	in	r0, 0x3f	; 63
    9186:	f8 94       	cli
    9188:	9e bf       	out	0x3e, r25	; 62
    918a:	0f be       	out	0x3f, r0	; 63
    918c:	8d bf       	out	0x3d, r24	; 61
    918e:	80 e0       	ldi	r24, 0x00	; 0
    9190:	03 c0       	rjmp	.+6      	; 0x9198 <Web_Login_Error+0x104>
}
//--Session
uint8_t Web_Login_Error(void){

	//   ?
	if(WebSession) return 1;
    9192:	81 e0       	ldi	r24, 0x01	; 1
    9194:	01 c0       	rjmp	.+2      	; 0x9198 <Web_Login_Error+0x104>
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
	return 2;}
    9196:	82 e0       	ldi	r24, 0x02	; 2
	Seed = random();
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}
    9198:	df 91       	pop	r29
    919a:	cf 91       	pop	r28
    919c:	1f 91       	pop	r17
    919e:	0f 91       	pop	r16
    91a0:	ff 90       	pop	r15
    91a2:	ef 90       	pop	r14
    91a4:	df 90       	pop	r13
    91a6:	cf 90       	pop	r12
    91a8:	08 95       	ret

000091aa <WebRequest>:
}


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    91aa:	2f 92       	push	r2
    91ac:	3f 92       	push	r3
    91ae:	4f 92       	push	r4
    91b0:	5f 92       	push	r5
    91b2:	6f 92       	push	r6
    91b4:	7f 92       	push	r7
    91b6:	8f 92       	push	r8
    91b8:	9f 92       	push	r9
    91ba:	af 92       	push	r10
    91bc:	bf 92       	push	r11
    91be:	cf 92       	push	r12
    91c0:	df 92       	push	r13
    91c2:	ef 92       	push	r14
    91c4:	ff 92       	push	r15
    91c6:	0f 93       	push	r16
    91c8:	1f 93       	push	r17
    91ca:	cf 93       	push	r28
    91cc:	df 93       	push	r29
    91ce:	cd b7       	in	r28, 0x3d	; 61
    91d0:	de b7       	in	r29, 0x3e	; 62
    91d2:	2a 97       	sbiw	r28, 0x0a	; 10
    91d4:	0f b6       	in	r0, 0x3f	; 63
    91d6:	f8 94       	cli
    91d8:	de bf       	out	0x3e, r29	; 62
    91da:	0f be       	out	0x3f, r0	; 63
    91dc:	cd bf       	out	0x3d, r28	; 61
    91de:	9a 87       	std	Y+10, r25	; 0x0a
    91e0:	89 87       	std	Y+9, r24	; 0x09
    91e2:	69 83       	std	Y+1, r22	; 0x01
	
	
	WebStrLen = GetStringFromFIFO();
    91e4:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    91e8:	80 93 70 08 	sts	0x0870, r24

	if(Web_POST==2){ 
    91ec:	80 91 6d 09 	lds	r24, 0x096D
    91f0:	82 30       	cpi	r24, 0x02	; 2
    91f2:	a1 f4       	brne	.+40     	; 0x921c <WebRequest+0x72>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    91f4:	80 91 41 09 	lds	r24, 0x0941
    91f8:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    91fc:	88 23       	and	r24, r24
    91fe:	39 f0       	breq	.+14     	; 0x920e <WebRequest+0x64>
			WebStrLen = ForceEndStringFromFIFO();
    9200:	0e 94 91 3a 	call	0x7522	; 0x7522 <ForceEndStringFromFIFO>
    9204:	80 93 70 08 	sts	0x0870, r24
			Web_POST=3;	
    9208:	83 e0       	ldi	r24, 0x03	; 3
    920a:	80 93 6d 09 	sts	0x096D, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    920e:	80 91 70 08 	lds	r24, 0x0870
    9212:	88 23       	and	r24, r24
    9214:	19 f0       	breq	.+6      	; 0x921c <WebRequest+0x72>
    9216:	83 e0       	ldi	r24, 0x03	; 3
    9218:	80 93 6d 09 	sts	0x096D, r24
	}

	//  
	if(WebStrLen){
    921c:	10 91 70 08 	lds	r17, 0x0870
    9220:	11 23       	and	r17, r17
    9222:	f9 f0       	breq	.+62     	; 0x9262 <WebRequest+0xb8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9224:	e9 85       	ldd	r30, Y+9	; 0x09
    9226:	fa 85       	ldd	r31, Y+10	; 0x0a
    9228:	25 90       	lpm	r2, Z+
    922a:	34 90       	lpm	r3, Z
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    922c:	6f ea       	ldi	r22, 0xAF	; 175
    922e:	7b e4       	ldi	r23, 0x4B	; 75
    9230:	89 e8       	ldi	r24, 0x89	; 137
    9232:	99 e0       	ldi	r25, 0x09	; 9
    9234:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    9238:	89 2b       	or	r24, r25
    923a:	21 f0       	breq	.+8      	; 0x9244 <WebRequest+0x9a>

			Web_POST = 1; 
    923c:	81 e0       	ldi	r24, 0x01	; 1
    923e:	80 93 6d 09 	sts	0x096D, r24
    9242:	0f c0       	rjmp	.+30     	; 0x9262 <WebRequest+0xb8>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    9244:	80 91 6d 09 	lds	r24, 0x096D
    9248:	81 30       	cpi	r24, 0x01	; 1
    924a:	71 f4       	brne	.+28     	; 0x9268 <WebRequest+0xbe>
    924c:	11 30       	cpi	r17, 0x01	; 1
    924e:	09 f0       	breq	.+2      	; 0x9252 <WebRequest+0xa8>
    9250:	8e c0       	rjmp	.+284    	; 0x936e <WebRequest+0x1c4>
			Web_POST = 2;
    9252:	82 e0       	ldi	r24, 0x02	; 2
    9254:	80 93 6d 09 	sts	0x096D, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    9258:	64 e6       	ldi	r22, 0x64	; 100
    925a:	80 91 41 09 	lds	r24, 0x0941
    925e:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
			return NULL;
    9262:	80 e0       	ldi	r24, 0x00	; 0
    9264:	90 e0       	ldi	r25, 0x00	; 0
    9266:	94 c1       	rjmp	.+808    	; 0x9590 <WebRequest+0x3e6>
		}
		if(Web_POST==3){	//  
    9268:	83 30       	cpi	r24, 0x03	; 3
    926a:	09 f0       	breq	.+2      	; 0x926e <WebRequest+0xc4>
    926c:	80 c0       	rjmp	.+256    	; 0x936e <WebRequest+0x1c4>
			Web_POST = 0;
    926e:	10 92 6d 09 	sts	0x096D, r1
			url = GSM_RxStr;

			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
    9272:	fc eb       	ldi	r31, 0xBC	; 188
    9274:	cf 2e       	mov	r12, r31
    9276:	fb e4       	ldi	r31, 0x4B	; 75
    9278:	df 2e       	mov	r13, r31
			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//For Debug
			#endif

			//URL 
			url = GSM_RxStr;
    927a:	a9 e8       	ldi	r26, 0x89	; 137
    927c:	ea 2e       	mov	r14, r26
    927e:	a9 e0       	ldi	r26, 0x09	; 9
    9280:	fa 2e       	mov	r15, r26
				varfield = p + 1;
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
    9282:	89 85       	ldd	r24, Y+9	; 0x09
    9284:	9a 85       	ldd	r25, Y+10	; 0x0a
    9286:	02 96       	adiw	r24, 0x02	; 2
    9288:	9a 83       	std	Y+2, r25	; 0x02
    928a:	89 83       	std	Y+1, r24	; 0x01
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    928c:	6d e3       	ldi	r22, 0x3D	; 61
    928e:	70 e0       	ldi	r23, 0x00	; 0
    9290:	c7 01       	movw	r24, r14
    9292:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    9296:	5c 01       	movw	r10, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) {
    9298:	00 97       	sbiw	r24, 0x00	; 0
    929a:	09 f4       	brne	.+2      	; 0x929e <WebRequest+0xf4>
    929c:	4e c1       	rjmp	.+668    	; 0x953a <WebRequest+0x390>
				return &Web_login;
				}
				nextvar=strchr(url+1,'&');
    929e:	66 e2       	ldi	r22, 0x26	; 38
    92a0:	70 e0       	ldi	r23, 0x00	; 0
    92a2:	c7 01       	movw	r24, r14
    92a4:	01 96       	adiw	r24, 0x01	; 1
    92a6:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    92aa:	4c 01       	movw	r8, r24
				varfield = p + 1;
    92ac:	85 01       	movw	r16, r10
    92ae:	0f 5f       	subi	r16, 0xFF	; 255
    92b0:	1f 4f       	sbci	r17, 0xFF	; 255
				*p = '\0';
    92b2:	d5 01       	movw	r26, r10
    92b4:	1c 92       	st	X, r1
    92b6:	e9 81       	ldd	r30, Y+1	; 0x01
    92b8:	fa 81       	ldd	r31, Y+2	; 0x02
    92ba:	65 90       	lpm	r6, Z+
    92bc:	74 90       	lpm	r7, Z
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92be:	20 e0       	ldi	r18, 0x00	; 0
    92c0:	13 01       	movw	r2, r6
    92c2:	b4 e0       	ldi	r27, 0x04	; 4
    92c4:	2b 0e       	add	r2, r27
    92c6:	31 1c       	adc	r3, r1
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    92c8:	23 01       	movw	r4, r6
    92ca:	e6 e0       	ldi	r30, 0x06	; 6
    92cc:	4e 0e       	add	r4, r30
    92ce:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    92d0:	f1 01       	movw	r30, r2
    92d2:	85 91       	lpm	r24, Z+
    92d4:	94 91       	lpm	r25, Z
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92d6:	a2 2e       	mov	r10, r18
    92d8:	b1 2c       	mov	r11, r1
    92da:	96 95       	lsr	r25
    92dc:	87 95       	ror	r24
    92de:	96 95       	lsr	r25
    92e0:	87 95       	ror	r24
    92e2:	a8 16       	cp	r10, r24
    92e4:	b9 06       	cpc	r11, r25
    92e6:	50 f5       	brcc	.+84     	; 0x933c <WebRequest+0x192>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    92e8:	f2 01       	movw	r30, r4
    92ea:	85 91       	lpm	r24, Z+
    92ec:	94 91       	lpm	r25, Z
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    92ee:	00 97       	sbiw	r24, 0x00	; 0
    92f0:	19 f1       	breq	.+70     	; 0x9338 <WebRequest+0x18e>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    92f2:	aa 0c       	add	r10, r10
    92f4:	bb 1c       	adc	r11, r11
    92f6:	aa 0c       	add	r10, r10
    92f8:	bb 1c       	adc	r11, r11
    92fa:	a8 0e       	add	r10, r24
    92fc:	b9 1e       	adc	r11, r25
    92fe:	f5 01       	movw	r30, r10
    9300:	65 91       	lpm	r22, Z+
    9302:	74 91       	lpm	r23, Z
    9304:	c7 01       	movw	r24, r14
    9306:	28 87       	std	Y+8, r18	; 0x08
    9308:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    930c:	28 85       	ldd	r18, Y+8	; 0x08
    930e:	89 2b       	or	r24, r25
    9310:	99 f4       	brne	.+38     	; 0x9338 <WebRequest+0x18e>
    9312:	c8 01       	movw	r24, r16
    9314:	8c 01       	movw	r16, r24
    9316:	01 96       	adiw	r24, 0x01	; 1
								while(*varfield=='+') varfield++;	// ignore leading '+'
    9318:	d8 01       	movw	r26, r16
    931a:	3c 91       	ld	r19, X
    931c:	3b 32       	cpi	r19, 0x2B	; 43
    931e:	d1 f3       	breq	.-12     	; 0x9314 <WebRequest+0x16a>
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield); 
    9320:	b2 e0       	ldi	r27, 0x02	; 2
    9322:	ab 0e       	add	r10, r27
    9324:	b1 1c       	adc	r11, r1
    9326:	f5 01       	movw	r30, r10
    9328:	85 91       	lpm	r24, Z+
    932a:	94 91       	lpm	r25, Z
    932c:	b8 01       	movw	r22, r16
    932e:	28 87       	std	Y+8, r18	; 0x08
    9330:	0e 94 dd 43 	call	0x87ba	; 0x87ba <WebBuf2Field>
								ptrPageVar = ptrPage;	//  -    ptrPage
    9334:	63 01       	movw	r12, r6
    9336:	28 85       	ldd	r18, Y+8	; 0x08
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9338:	2f 5f       	subi	r18, 0xFF	; 255
    933a:	ca cf       	rjmp	.-108    	; 0x92d0 <WebRequest+0x126>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    933c:	74 01       	movw	r14, r8
    933e:	ef ef       	ldi	r30, 0xFF	; 255
    9340:	ee 1a       	sub	r14, r30
    9342:	fe 0a       	sbc	r15, r30
			}while(nextvar);	//     
    9344:	89 28       	or	r8, r9
    9346:	09 f0       	breq	.+2      	; 0x934a <WebRequest+0x1a0>
    9348:	a1 cf       	rjmp	.-190    	; 0x928c <WebRequest+0xe2>

			if(Web_LoginAttempt){				
    934a:	80 91 3a 08 	lds	r24, 0x083A
    934e:	88 23       	and	r24, r24
    9350:	09 f4       	brne	.+2      	; 0x9354 <WebRequest+0x1aa>
    9352:	18 c1       	rjmp	.+560    	; 0x9584 <WebRequest+0x3da>
				Web_LoginAttempt = 0;
    9354:	10 92 3a 08 	sts	0x083A, r1
				Web_Login_Code = Web_Login_Error();
    9358:	0e 94 4a 48 	call	0x9094	; 0x9094 <Web_Login_Error>
    935c:	80 93 09 06 	sts	0x0609, r24
				if(!Web_Login_Code){ return prp(ptrSite);}
    9360:	81 11       	cpse	r24, r1
    9362:	10 c1       	rjmp	.+544    	; 0x9584 <WebRequest+0x3da>
    9364:	e9 85       	ldd	r30, Y+9	; 0x09
    9366:	fa 85       	ldd	r31, Y+10	; 0x0a
    9368:	85 91       	lpm	r24, Z+
    936a:	94 91       	lpm	r25, Z
    936c:	11 c1       	rjmp	.+546    	; 0x9590 <WebRequest+0x3e6>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    936e:	66 eb       	ldi	r22, 0xB6	; 182
    9370:	7b e4       	ldi	r23, 0x4B	; 75
    9372:	89 e8       	ldi	r24, 0x89	; 137
    9374:	99 e0       	ldi	r25, 0x09	; 9
    9376:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    937a:	89 2b       	or	r24, r25
    937c:	09 f4       	brne	.+2      	; 0x9380 <WebRequest+0x1d6>
    937e:	71 cf       	rjmp	.-286    	; 0x9262 <WebRequest+0xb8>
    9380:	60 e2       	ldi	r22, 0x20	; 32
    9382:	70 e0       	ldi	r23, 0x00	; 0
    9384:	8d e8       	ldi	r24, 0x8D	; 141
    9386:	99 e0       	ldi	r25, 0x09	; 9
    9388:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    938c:	00 97       	sbiw	r24, 0x00	; 0
    938e:	09 f4       	brne	.+2      	; 0x9392 <WebRequest+0x1e8>
    9390:	68 cf       	rjmp	.-304    	; 0x9262 <WebRequest+0xb8>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    9392:	dc 01       	movw	r26, r24
    9394:	1c 92       	st	X, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9396:	64 e7       	ldi	r22, 0x74	; 116
    9398:	79 e3       	ldi	r23, 0x39	; 57
    939a:	8e e8       	ldi	r24, 0x8E	; 142
    939c:	99 e0       	ldi	r25, 0x09	; 9
    939e:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    93a2:	89 2b       	or	r24, r25
    93a4:	09 f4       	brne	.+2      	; 0x93a8 <WebRequest+0x1fe>
    93a6:	eb c0       	rjmp	.+470    	; 0x957e <WebRequest+0x3d4>
			url = strchr(url,'?');
    93a8:	6f e3       	ldi	r22, 0x3F	; 63
    93aa:	70 e0       	ldi	r23, 0x00	; 0
    93ac:	8d e8       	ldi	r24, 0x8D	; 141
    93ae:	99 e0       	ldi	r25, 0x09	; 9
    93b0:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    93b4:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    93b6:	80 91 7e 09 	lds	r24, 0x097E
    93ba:	88 23       	and	r24, r24
    93bc:	09 f4       	brne	.+2      	; 0x93c0 <WebRequest+0x216>
    93be:	bd c0       	rjmp	.+378    	; 0x953a <WebRequest+0x390>
    93c0:	01 15       	cp	r16, r1
    93c2:	11 05       	cpc	r17, r1
    93c4:	09 f4       	brne	.+2      	; 0x93c8 <WebRequest+0x21e>
    93c6:	b9 c0       	rjmp	.+370    	; 0x953a <WebRequest+0x390>
    93c8:	48 e0       	ldi	r20, 0x08	; 8
    93ca:	50 e0       	ldi	r21, 0x00	; 0
    93cc:	6e e3       	ldi	r22, 0x3E	; 62
    93ce:	7c e4       	ldi	r23, 0x4C	; 76
    93d0:	c8 01       	movw	r24, r16
    93d2:	0e 94 7b 6c 	call	0xd8f6	; 0xd8f6 <strncmp_P>
    93d6:	89 2b       	or	r24, r25
    93d8:	09 f0       	breq	.+2      	; 0x93dc <WebRequest+0x232>
    93da:	af c0       	rjmp	.+350    	; 0x953a <WebRequest+0x390>
    93dc:	40 e1       	ldi	r20, 0x10	; 16
    93de:	50 e0       	ldi	r21, 0x00	; 0
    93e0:	69 e2       	ldi	r22, 0x29	; 41
    93e2:	76 e0       	ldi	r23, 0x06	; 6
    93e4:	c8 01       	movw	r24, r16
    93e6:	08 96       	adiw	r24, 0x08	; 8
    93e8:	0e 94 c7 6c 	call	0xd98e	; 0xd98e <strncmp>
    93ec:	89 2b       	or	r24, r25
    93ee:	09 f0       	breq	.+2      	; 0x93f2 <WebRequest+0x248>
    93f0:	a4 c0       	rjmp	.+328    	; 0x953a <WebRequest+0x390>
    93f2:	61 01       	movw	r12, r2
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    93f4:	86 e5       	ldi	r24, 0x56	; 86
    93f6:	90 e0       	ldi	r25, 0x00	; 0
    93f8:	0e 94 e8 73 	call	0xe7d0	; 0xe7d0 <__eerd_dword_m128>
    93fc:	ab 01       	movw	r20, r22
    93fe:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    9400:	80 91 68 09 	lds	r24, 0x0968
    9404:	0e 94 09 2c 	call	0x5812	; 0x5812 <StartTimer32>
			
			*url = '\0';
    9408:	f8 01       	movw	r30, r16
    940a:	11 92       	st	Z+, r1
    940c:	cf 01       	movw	r24, r30
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    940e:	66 e2       	ldi	r22, 0x26	; 38
    9410:	70 e0       	ldi	r23, 0x00	; 0
    9412:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    9416:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    9418:	00 97       	sbiw	r24, 0x00	; 0
    941a:	09 f4       	brne	.+2      	; 0x941e <WebRequest+0x274>
    941c:	77 c0       	rjmp	.+238    	; 0x950c <WebRequest+0x362>
    941e:	6c eb       	ldi	r22, 0xBC	; 188
    9420:	26 2e       	mov	r2, r22
    9422:	6b e4       	ldi	r22, 0x4B	; 75
    9424:	36 2e       	mov	r3, r22
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    9426:	6d e3       	ldi	r22, 0x3D	; 61
    9428:	70 e0       	ldi	r23, 0x00	; 0
    942a:	c8 01       	movw	r24, r16
    942c:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    9430:	5c 01       	movw	r10, r24
					if(p==NULL) return ptrPage;
    9432:	00 97       	sbiw	r24, 0x00	; 0
    9434:	09 f4       	brne	.+2      	; 0x9438 <WebRequest+0x28e>
    9436:	a6 c0       	rjmp	.+332    	; 0x9584 <WebRequest+0x3da>
					nextvar=strchr(url+1,'&');
    9438:	28 01       	movw	r4, r16
    943a:	ff ef       	ldi	r31, 0xFF	; 255
    943c:	4f 1a       	sub	r4, r31
    943e:	5f 0a       	sbc	r5, r31
    9440:	66 e2       	ldi	r22, 0x26	; 38
    9442:	70 e0       	ldi	r23, 0x00	; 0
    9444:	c2 01       	movw	r24, r4
    9446:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    944a:	8c 01       	movw	r16, r24
					varfield = p + 1;
    944c:	75 01       	movw	r14, r10
    944e:	2f ef       	ldi	r18, 0xFF	; 255
    9450:	e2 1a       	sub	r14, r18
    9452:	f2 0a       	sbc	r15, r18
					*p = '\0';
    9454:	d5 01       	movw	r26, r10
    9456:	1c 92       	st	X, r1
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9458:	69 84       	ldd	r6, Y+9	; 0x09
    945a:	7a 84       	ldd	r7, Y+10	; 0x0a
    945c:	30 e0       	ldi	r19, 0x00	; 0
    945e:	29 81       	ldd	r18, Y+1	; 0x01
    9460:	32 17       	cp	r19, r18
    9462:	09 f4       	brne	.+2      	; 0x9466 <WebRequest+0x2bc>
    9464:	4e c0       	rjmp	.+156    	; 0x9502 <WebRequest+0x358>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9466:	f3 01       	movw	r30, r6
    9468:	85 90       	lpm	r8, Z+
    946a:	94 90       	lpm	r9, Z
    946c:	64 01       	movw	r12, r8
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    946e:	20 e0       	ldi	r18, 0x00	; 0
    9470:	f4 01       	movw	r30, r8
    9472:	34 96       	adiw	r30, 0x04	; 4
    9474:	fc 83       	std	Y+4, r31	; 0x04
    9476:	eb 83       	std	Y+3, r30	; 0x03
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    9478:	c4 01       	movw	r24, r8
    947a:	06 96       	adiw	r24, 0x06	; 6
    947c:	9e 83       	std	Y+6, r25	; 0x06
    947e:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9480:	eb 81       	ldd	r30, Y+3	; 0x03
    9482:	fc 81       	ldd	r31, Y+4	; 0x04
    9484:	85 91       	lpm	r24, Z+
    9486:	94 91       	lpm	r25, Z
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9488:	a2 2e       	mov	r10, r18
    948a:	b1 2c       	mov	r11, r1
    948c:	96 95       	lsr	r25
    948e:	87 95       	ror	r24
    9490:	96 95       	lsr	r25
    9492:	87 95       	ror	r24
    9494:	a8 16       	cp	r10, r24
    9496:	b9 06       	cpc	r11, r25
    9498:	78 f5       	brcc	.+94     	; 0x94f8 <WebRequest+0x34e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    949a:	ed 81       	ldd	r30, Y+5	; 0x05
    949c:	fe 81       	ldd	r31, Y+6	; 0x06
    949e:	85 91       	lpm	r24, Z+
    94a0:	94 91       	lpm	r25, Z
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    94a2:	00 97       	sbiw	r24, 0x00	; 0
    94a4:	39 f1       	breq	.+78     	; 0x94f4 <WebRequest+0x34a>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    94a6:	aa 0c       	add	r10, r10
    94a8:	bb 1c       	adc	r11, r11
    94aa:	aa 0c       	add	r10, r10
    94ac:	bb 1c       	adc	r11, r11
    94ae:	a8 0e       	add	r10, r24
    94b0:	b9 1e       	adc	r11, r25
    94b2:	f5 01       	movw	r30, r10
    94b4:	65 91       	lpm	r22, Z+
    94b6:	74 91       	lpm	r23, Z
    94b8:	c2 01       	movw	r24, r4
    94ba:	28 87       	std	Y+8, r18	; 0x08
    94bc:	3f 83       	std	Y+7, r19	; 0x07
    94be:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    94c2:	28 85       	ldd	r18, Y+8	; 0x08
    94c4:	3f 81       	ldd	r19, Y+7	; 0x07
    94c6:	89 2b       	or	r24, r25
    94c8:	a9 f4       	brne	.+42     	; 0x94f4 <WebRequest+0x34a>
    94ca:	c7 01       	movw	r24, r14
    94cc:	7c 01       	movw	r14, r24
    94ce:	01 96       	adiw	r24, 0x01	; 1
									while(*varfield=='+') varfield++;	// ignore leading '+'
    94d0:	d7 01       	movw	r26, r14
    94d2:	4c 91       	ld	r20, X
    94d4:	4b 32       	cpi	r20, 0x2B	; 43
    94d6:	d1 f3       	breq	.-12     	; 0x94cc <WebRequest+0x322>
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    94d8:	b2 e0       	ldi	r27, 0x02	; 2
    94da:	ab 0e       	add	r10, r27
    94dc:	b1 1c       	adc	r11, r1
    94de:	f5 01       	movw	r30, r10
    94e0:	85 91       	lpm	r24, Z+
    94e2:	94 91       	lpm	r25, Z
    94e4:	b7 01       	movw	r22, r14
    94e6:	28 87       	std	Y+8, r18	; 0x08
    94e8:	3f 83       	std	Y+7, r19	; 0x07
    94ea:	0e 94 dd 43 	call	0x87ba	; 0x87ba <WebBuf2Field>
									ptrPageVar = ptrPage;	//  -    ptrPage
    94ee:	14 01       	movw	r2, r8
    94f0:	3f 81       	ldd	r19, Y+7	; 0x07
    94f2:	28 85       	ldd	r18, Y+8	; 0x08
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    94f4:	2f 5f       	subi	r18, 0xFF	; 255
    94f6:	c4 cf       	rjmp	.-120    	; 0x9480 <WebRequest+0x2d6>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    94f8:	3f 5f       	subi	r19, 0xFF	; 255
    94fa:	e2 e0       	ldi	r30, 0x02	; 2
    94fc:	6e 0e       	add	r6, r30
    94fe:	71 1c       	adc	r7, r1
    9500:	ae cf       	rjmp	.-164    	; 0x945e <WebRequest+0x2b4>
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    9502:	01 15       	cp	r16, r1
    9504:	11 05       	cpc	r17, r1
    9506:	09 f0       	breq	.+2      	; 0x950a <WebRequest+0x360>
    9508:	8e cf       	rjmp	.-228    	; 0x9426 <WebRequest+0x27c>
    950a:	3e c0       	rjmp	.+124    	; 0x9588 <WebRequest+0x3de>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    950c:	66 e1       	ldi	r22, 0x16	; 22
    950e:	73 e0       	ldi	r23, 0x03	; 3
    9510:	8d e8       	ldi	r24, 0x8D	; 141
    9512:	99 e0       	ldi	r25, 0x09	; 9
    9514:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    9518:	89 2b       	or	r24, r25
    951a:	09 f4       	brne	.+2      	; 0x951e <WebRequest+0x374>
    951c:	35 c0       	rjmp	.+106    	; 0x9588 <WebRequest+0x3de>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    951e:	6a e0       	ldi	r22, 0x0A	; 10
    9520:	73 e0       	ldi	r23, 0x03	; 3
    9522:	8e e8       	ldi	r24, 0x8E	; 142
    9524:	99 e0       	ldi	r25, 0x09	; 9
    9526:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    952a:	89 2b       	or	r24, r25
    952c:	21 f0       	breq	.+8      	; 0x9536 <WebRequest+0x38c>
    952e:	e9 84       	ldd	r14, Y+9	; 0x09
    9530:	fa 84       	ldd	r15, Y+10	; 0x0a
    9532:	10 e0       	ldi	r17, 0x00	; 0
    9534:	15 c0       	rjmp	.+42     	; 0x9560 <WebRequest+0x3b6>
				WebSession = 0;
    9536:	10 92 7e 09 	sts	0x097E, r1
				return &Web_login;
    953a:	85 e9       	ldi	r24, 0x95	; 149
    953c:	98 e4       	ldi	r25, 0x48	; 72
    953e:	28 c0       	rjmp	.+80     	; 0x9590 <WebRequest+0x3e6>
    9540:	f7 01       	movw	r30, r14
    9542:	c5 90       	lpm	r12, Z+
    9544:	d4 90       	lpm	r13, Z
    9546:	f6 01       	movw	r30, r12
    9548:	65 91       	lpm	r22, Z+
    954a:	74 91       	lpm	r23, Z
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    954c:	8e e8       	ldi	r24, 0x8E	; 142
    954e:	99 e0       	ldi	r25, 0x09	; 9
    9550:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    9554:	a2 e0       	ldi	r26, 0x02	; 2
    9556:	ea 0e       	add	r14, r26
    9558:	f1 1c       	adc	r15, r1
    955a:	89 2b       	or	r24, r25
    955c:	29 f0       	breq	.+10     	; 0x9568 <WebRequest+0x3be>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    955e:	1f 5f       	subi	r17, 0xFF	; 255
    9560:	29 81       	ldd	r18, Y+1	; 0x01
    9562:	12 13       	cpse	r17, r18
    9564:	ed cf       	rjmp	.-38     	; 0x9540 <WebRequest+0x396>
    9566:	08 c0       	rjmp	.+16     	; 0x9578 <WebRequest+0x3ce>
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9568:	f6 01       	movw	r30, r12
    956a:	3c 96       	adiw	r30, 0x0c	; 12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    956c:	e4 91       	lpm	r30, Z
    956e:	80 91 6c 0a 	lds	r24, 0x0A6C
    9572:	8e 17       	cp	r24, r30
    9574:	58 f0       	brcs	.+22     	; 0x958c <WebRequest+0x3e2>
    9576:	06 c0       	rjmp	.+12     	; 0x9584 <WebRequest+0x3da>
					return ptrPage;				
				}
			}
			
			//  URL
			return &Web_error_page;
    9578:	8c eb       	ldi	r24, 0xBC	; 188
    957a:	9b e4       	ldi	r25, 0x4B	; 75
    957c:	09 c0       	rjmp	.+18     	; 0x9590 <WebRequest+0x3e6>
			#endif

			*p = '\0';

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    957e:	89 ee       	ldi	r24, 0xE9	; 233
    9580:	93 e3       	ldi	r25, 0x33	; 51
    9582:	06 c0       	rjmp	.+12     	; 0x9590 <WebRequest+0x3e6>
    9584:	c6 01       	movw	r24, r12
    9586:	04 c0       	rjmp	.+8      	; 0x9590 <WebRequest+0x3e6>
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
				return ptrPage;			
    9588:	c1 01       	movw	r24, r2
    958a:	02 c0       	rjmp	.+4      	; 0x9590 <WebRequest+0x3e6>
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    958c:	80 eb       	ldi	r24, 0xB0	; 176
    958e:	92 e3       	ldi	r25, 0x32	; 50
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    9590:	2a 96       	adiw	r28, 0x0a	; 10
    9592:	0f b6       	in	r0, 0x3f	; 63
    9594:	f8 94       	cli
    9596:	de bf       	out	0x3e, r29	; 62
    9598:	0f be       	out	0x3f, r0	; 63
    959a:	cd bf       	out	0x3d, r28	; 61
    959c:	df 91       	pop	r29
    959e:	cf 91       	pop	r28
    95a0:	1f 91       	pop	r17
    95a2:	0f 91       	pop	r16
    95a4:	ff 90       	pop	r15
    95a6:	ef 90       	pop	r14
    95a8:	df 90       	pop	r13
    95aa:	cf 90       	pop	r12
    95ac:	bf 90       	pop	r11
    95ae:	af 90       	pop	r10
    95b0:	9f 90       	pop	r9
    95b2:	8f 90       	pop	r8
    95b4:	7f 90       	pop	r7
    95b6:	6f 90       	pop	r6
    95b8:	5f 90       	pop	r5
    95ba:	4f 90       	pop	r4
    95bc:	3f 90       	pop	r3
    95be:	2f 90       	pop	r2
    95c0:	08 95       	ret

000095c2 <EM_InitFIFO>:
void EMeter_NoLink(void);
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){cli();
    95c2:	f8 94       	cli
	EM_RX_FIFO_Begin = 255;
    95c4:	8f ef       	ldi	r24, 0xFF	; 255
    95c6:	80 93 70 09 	sts	0x0970, r24
	EM_RX_FIFO_End = 255;
    95ca:	80 93 38 0d 	sts	0x0D38, r24
	EMeter_RxCharN = 0;
    95ce:	10 92 3f 0d 	sts	0x0D3F, r1
    95d2:	10 92 3e 0d 	sts	0x0D3E, r1
	sei();
    95d6:	78 94       	sei
    95d8:	08 95       	ret

000095da <EM_SetUARTParam>:
		EM_UART_BitQt = 3;		
	}
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
    95da:	29 2f       	mov	r18, r25
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    95dc:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    95e0:	80 93 6b 0a 	sts	0x0A6B, r24

	switch(EM_UART_Rate){
    95e4:	90 e0       	ldi	r25, 0x00	; 0
    95e6:	89 30       	cpi	r24, 0x09	; 9
    95e8:	91 05       	cpc	r25, r1
    95ea:	38 f5       	brcc	.+78     	; 0x963a <EM_SetUARTParam+0x60>
    95ec:	fc 01       	movw	r30, r24
    95ee:	eb 55       	subi	r30, 0x5B	; 91
    95f0:	ff 4f       	sbci	r31, 0xFF	; 255
    95f2:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    95f6:	83 e0       	ldi	r24, 0x03	; 3
    95f8:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    95fc:	82 e4       	ldi	r24, 0x42	; 66
    95fe:	20 c0       	rjmp	.+64     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    9600:	81 e0       	ldi	r24, 0x01	; 1
    9602:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    9606:	80 ea       	ldi	r24, 0xA0	; 160
    9608:	1b c0       	rjmp	.+54     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    960a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    960e:	8f ec       	ldi	r24, 0xCF	; 207
    9610:	17 c0       	rjmp	.+46     	; 0x9640 <EM_SetUARTParam+0x66>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    9612:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    9616:	84 e4       	ldi	r24, 0x44	; 68
    9618:	13 c0       	rjmp	.+38     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    961a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    961e:	83 e3       	ldi	r24, 0x33	; 51
    9620:	0f c0       	rjmp	.+30     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    9622:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    9626:	82 e2       	ldi	r24, 0x22	; 34
    9628:	0b c0       	rjmp	.+22     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    962a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    962e:	89 e1       	ldi	r24, 0x19	; 25
    9630:	07 c0       	rjmp	.+14     	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    9632:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    9636:	80 e1       	ldi	r24, 0x10	; 16
    9638:	03 c0       	rjmp	.+6      	; 0x9640 <EM_SetUARTParam+0x66>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    963a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    963e:	87 e6       	ldi	r24, 0x67	; 103
    9640:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    9644:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    9648:	82 2f       	mov	r24, r18
    964a:	83 70       	andi	r24, 0x03	; 3
    964c:	80 93 0c 06 	sts	0x060C, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    9650:	82 30       	cpi	r24, 0x02	; 2
    9652:	41 f0       	breq	.+16     	; 0x9664 <EM_SetUARTParam+0x8a>
    9654:	83 30       	cpi	r24, 0x03	; 3
    9656:	51 f0       	breq	.+20     	; 0x966c <EM_SetUARTParam+0x92>
    9658:	81 30       	cpi	r24, 0x01	; 1
    965a:	41 f4       	brne	.+16     	; 0x966c <EM_SetUARTParam+0x92>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    965c:	80 91 9d 00 	lds	r24, 0x009D
    9660:	80 62       	ori	r24, 0x20	; 32
    9662:	06 c0       	rjmp	.+12     	; 0x9670 <EM_SetUARTParam+0x96>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    9664:	80 91 9d 00 	lds	r24, 0x009D
    9668:	80 63       	ori	r24, 0x30	; 48
    966a:	02 c0       	rjmp	.+4      	; 0x9670 <EM_SetUARTParam+0x96>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    966c:	80 91 9d 00 	lds	r24, 0x009D
    9670:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    9674:	22 fb       	bst	r18, 2
    9676:	88 27       	eor	r24, r24
    9678:	80 f9       	bld	r24, 0
    967a:	80 93 42 09 	sts	0x0942, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    967e:	81 30       	cpi	r24, 0x01	; 1
    9680:	19 f0       	breq	.+6      	; 0x9688 <EM_SetUARTParam+0xae>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    9682:	80 91 9d 00 	lds	r24, 0x009D
    9686:	03 c0       	rjmp	.+6      	; 0x968e <EM_SetUARTParam+0xb4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    9688:	80 91 9d 00 	lds	r24, 0x009D
    968c:	88 60       	ori	r24, 0x08	; 8
    968e:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    9692:	92 2f       	mov	r25, r18
    9694:	96 95       	lsr	r25
    9696:	96 95       	lsr	r25
    9698:	96 95       	lsr	r25
    969a:	93 70       	andi	r25, 0x03	; 3
    969c:	90 93 72 0a 	sts	0x0A72, r25
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96a0:	80 91 9d 00 	lds	r24, 0x009D
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    96a4:	92 30       	cpi	r25, 0x02	; 2
    96a6:	31 f0       	breq	.+12     	; 0x96b4 <EM_SetUARTParam+0xda>
    96a8:	93 30       	cpi	r25, 0x03	; 3
    96aa:	31 f0       	breq	.+12     	; 0x96b8 <EM_SetUARTParam+0xde>
    96ac:	91 30       	cpi	r25, 0x01	; 1
    96ae:	29 f4       	brne	.+10     	; 0x96ba <EM_SetUARTParam+0xe0>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96b0:	82 60       	ori	r24, 0x02	; 2
    96b2:	03 c0       	rjmp	.+6      	; 0x96ba <EM_SetUARTParam+0xe0>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96b4:	84 60       	ori	r24, 0x04	; 4
    96b6:	01 c0       	rjmp	.+2      	; 0x96ba <EM_SetUARTParam+0xe0>
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96b8:	86 60       	ori	r24, 0x06	; 6
    96ba:	80 93 9d 00 	sts	0x009D, r24
    96be:	08 95       	ret

000096c0 <ApplyUARTParam>:
	}
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
    96c0:	80 91 6b 0a 	lds	r24, 0x0A6B
    96c4:	60 91 0c 06 	lds	r22, 0x060C
    96c8:	70 e0       	ldi	r23, 0x00	; 0
    96ca:	76 2f       	mov	r23, r22
    96cc:	66 27       	eor	r22, r22
    96ce:	68 0f       	add	r22, r24
    96d0:	71 1d       	adc	r23, r1
    96d2:	80 91 42 09 	lds	r24, 0x0942
    96d6:	90 e0       	ldi	r25, 0x00	; 0
    96d8:	98 2f       	mov	r25, r24
    96da:	88 27       	eor	r24, r24
    96dc:	99 0f       	add	r25, r25
    96de:	99 0f       	add	r25, r25
    96e0:	68 0f       	add	r22, r24
    96e2:	79 1f       	adc	r23, r25
    96e4:	80 91 72 0a 	lds	r24, 0x0A72
    96e8:	90 e0       	ldi	r25, 0x00	; 0
    96ea:	98 2f       	mov	r25, r24
    96ec:	88 27       	eor	r24, r24
    96ee:	99 0f       	add	r25, r25
    96f0:	99 0f       	add	r25, r25
    96f2:	99 0f       	add	r25, r25
    96f4:	68 0f       	add	r22, r24
    96f6:	79 1f       	adc	r23, r25
	eww(&EM_UART_Param, Temp16);
    96f8:	87 e2       	ldi	r24, 0x27	; 39
    96fa:	90 e0       	ldi	r25, 0x00	; 0
    96fc:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    9700:	80 91 75 0a 	lds	r24, 0x0A75
    9704:	81 11       	cpse	r24, r1
    9706:	06 c0       	rjmp	.+12     	; 0x9714 <ApplyUARTParam+0x54>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9708:	87 e2       	ldi	r24, 0x27	; 39
    970a:	90 e0       	ldi	r25, 0x00	; 0
    970c:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    9710:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    9714:	0c 94 19 2a 	jmp	0x5432	; 0x5432 <Modbus_ReadHoldReg>

00009718 <ChangeUARTParam>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9718:	89 e2       	ldi	r24, 0x29	; 41
    971a:	90 e0       	ldi	r25, 0x00	; 0
    971c:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9720:	81 30       	cpi	r24, 0x01	; 1
    9722:	51 f4       	brne	.+20     	; 0x9738 <ChangeUARTParam+0x20>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    9724:	93 e0       	ldi	r25, 0x03	; 3
    9726:	90 93 6b 0a 	sts	0x0A6B, r25
		EM_UART_Parity = 1;
    972a:	80 93 0c 06 	sts	0x060C, r24
		EM_UART_StopBits = 0;
    972e:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 2;
    9732:	82 e0       	ldi	r24, 0x02	; 2
    9734:	80 93 72 0a 	sts	0x0A72, r24
    9738:	89 e2       	ldi	r24, 0x29	; 41
    973a:	90 e0       	ldi	r25, 0x00	; 0
    973c:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    9740:	82 50       	subi	r24, 0x02	; 2
    9742:	83 30       	cpi	r24, 0x03	; 3
    9744:	48 f4       	brcc	.+18     	; 0x9758 <ChangeUARTParam+0x40>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    9746:	83 e0       	ldi	r24, 0x03	; 3
    9748:	80 93 6b 0a 	sts	0x0A6B, r24
		EM_UART_Parity = 0;
    974c:	10 92 0c 06 	sts	0x060C, r1
		EM_UART_StopBits = 0;
    9750:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 3;		
    9754:	80 93 72 0a 	sts	0x0A72, r24
	}
	ApplyUARTParam();
    9758:	0c 94 60 4b 	jmp	0x96c0	; 0x96c0 <ApplyUARTParam>

0000975c <EMeter_ReInit>:
	}
}
void EMeter_ReInit(void){

	//RS485
	MB_PLC_Init();
    975c:	0e 94 a9 2e 	call	0x5d52	; 0x5d52 <MB_PLC_Init>
	
	#ifdef CTS
		CTS_Config();
    9760:	0e 94 d2 2e 	call	0x5da4	; 0x5da4 <CTS_Config>
		CTS_OFF();
    9764:	0e 94 d4 2e 	call	0x5da8	; 0x5da8 <CTS_OFF>
	#endif
	#ifdef RTS
		RTS_Config();
    9768:	0e 94 d6 2e 	call	0x5dac	; 0x5dac <RTS_Config>
	#endif

	EM_InitFIFO();
    976c:	0e 94 e1 4a 	call	0x95c2	; 0x95c2 <EM_InitFIFO>

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9770:	88 e9       	ldi	r24, 0x98	; 152
    9772:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    9776:	80 e4       	ldi	r24, 0x40	; 64
    9778:	80 93 9b 00 	sts	0x009B, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    977c:	87 e2       	ldi	r24, 0x27	; 39
    977e:	90 e0       	ldi	r25, 0x00	; 0
    9780:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    9784:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_SetUARTParam>

	EM_HalfBufferStart= EMeter_RxStr;//----    
    9788:	8c e3       	ldi	r24, 0x3C	; 60
    978a:	97 e0       	ldi	r25, 0x07	; 7
    978c:	90 93 88 09 	sts	0x0988, r25
    9790:	80 93 87 09 	sts	0x0987, r24
	EMeter_RxStr_Offset = EMeter_RxStr;
    9794:	90 93 08 06 	sts	0x0608, r25
    9798:	80 93 07 06 	sts	0x0607, r24
	EM_BufferReadEnable=0;//----- 
    979c:	10 92 50 09 	sts	0x0950, r1
	EMeter_RxCharN=0;
    97a0:	10 92 3f 0d 	sts	0x0D3F, r1
    97a4:	10 92 3e 0d 	sts	0x0D3E, r1
    97a8:	08 95       	ret

000097aa <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    97aa:	80 91 76 0a 	lds	r24, 0x0A76
    97ae:	88 23       	and	r24, r24
    97b0:	31 f0       	breq	.+12     	; 0x97be <GSM_CloseTransparent+0x14>
		cli();		
    97b2:	f8 94       	cli
		Transparent = 0;
    97b4:	10 92 76 0a 	sts	0x0A76, r1
		EMeter_ReInit();
    97b8:	0e 94 ae 4b 	call	0x975c	; 0x975c <EMeter_ReInit>
		sei();		
    97bc:	78 94       	sei
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    97be:	6f ef       	ldi	r22, 0xFF	; 255
    97c0:	7f ef       	ldi	r23, 0xFF	; 255
    97c2:	80 91 59 02 	lds	r24, 0x0259
    97c6:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>

000097ca <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    97ca:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    97ce:	91 e0       	ldi	r25, 0x01	; 1
    97d0:	98 0f       	add	r25, r24
    97d2:	90 93 0e 01 	sts	0x010E, r25

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    97d6:	80 93 38 0c 	sts	0x0C38, r24
	EMeter_ReInit();
    97da:	0e 94 ae 4b 	call	0x975c	; 0x975c <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    97de:	8a e0       	ldi	r24, 0x0A	; 10
    97e0:	90 e0       	ldi	r25, 0x00	; 0
    97e2:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	if(erb(&AutoSend)){
    97e6:	88 23       	and	r24, r24
    97e8:	49 f0       	breq	.+18     	; 0x97fc <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    97ea:	68 ee       	ldi	r22, 0xE8	; 232
    97ec:	73 e0       	ldi	r23, 0x03	; 3
    97ee:	80 91 38 0c 	lds	r24, 0x0C38
    97f2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
		EM_Mode = 0;
    97f6:	10 92 71 0a 	sts	0x0A71, r1
    97fa:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    97fc:	8f ef       	ldi	r24, 0xFF	; 255
    97fe:	80 93 71 0a 	sts	0x0A71, r24
    9802:	08 95       	ret

00009804 <USART_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    9804:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    9808:	91 e0       	ldi	r25, 0x01	; 1
    980a:	98 0f       	add	r25, r24
    980c:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
    9810:	80 93 4c 09 	sts	0x094C, r24

	MB_Init();
    9814:	0e 94 92 35 	call	0x6b24	; 0x6b24 <MB_Init>
	EMeter_Init();
    9818:	0e 94 e5 4b 	call	0x97ca	; 0x97ca <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
    981c:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
    981e:	d8 9a       	sbi	0x1b, 0	; 27
    9820:	85 e3       	ldi	r24, 0x35	; 53
    9822:	8a 95       	dec	r24
    9824:	f1 f7       	brne	.-4      	; 0x9822 <USART_Init+0x1e>
    9826:	00 00       	nop
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
    9828:	c8 99       	sbic	0x19, 0	; 25
    982a:	08 c0       	rjmp	.+16     	; 0x983c <USART_Init+0x38>
		MB_Init();
    982c:	0e 94 92 35 	call	0x6b24	; 0x6b24 <MB_Init>
		UART_Soft = 1;
    9830:	81 e0       	ldi	r24, 0x01	; 1
    9832:	80 93 75 0a 	sts	0x0A75, r24
		ModbusMode = 1;
    9836:	80 93 e0 03 	sts	0x03E0, r24
    983a:	06 c0       	rjmp	.+12     	; 0x9848 <USART_Init+0x44>
	}
	else{
		EMeter_ReInit();
    983c:	0e 94 ae 4b 	call	0x975c	; 0x975c <EMeter_ReInit>
		UART_Soft = 0;
    9840:	10 92 75 0a 	sts	0x0A75, r1
		ModbusMode = 0;
    9844:	10 92 e0 03 	sts	0x03E0, r1
	}
	
	GSM_Init();
    9848:	0c 94 e0 3a 	jmp	0x75c0	; 0x75c0 <GSM_Init>

0000984c <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    984c:	80 91 76 0a 	lds	r24, 0x0A76
    9850:	88 23       	and	r24, r24
    9852:	a9 f1       	breq	.+106    	; 0x98be <EMeter_RX+0x72>
					StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    9854:	60 91 0b 01 	lds	r22, 0x010B
    9858:	70 91 0c 01 	lds	r23, 0x010C
    985c:	80 91 40 0d 	lds	r24, 0x0D40
    9860:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    9864:	60 91 09 01 	lds	r22, 0x0109
    9868:	70 91 0a 01 	lds	r23, 0x010A
    986c:	80 91 0b 06 	lds	r24, 0x060B
    9870:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					EMeterIsLink=1;
    9874:	81 e0       	ldi	r24, 0x01	; 1
    9876:	80 93 5d 09 	sts	0x095D, r24
		char Char = UDR_EMETER;
    987a:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    987e:	80 91 70 09 	lds	r24, 0x0970
    9882:	8f 5f       	subi	r24, 0xFF	; 255
    9884:	80 93 70 09 	sts	0x0970, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    9888:	80 91 70 09 	lds	r24, 0x0970
    988c:	8f 3f       	cpi	r24, 0xFF	; 255
    988e:	11 f4       	brne	.+4      	; 0x9894 <EMeter_RX+0x48>
    9890:	10 92 70 09 	sts	0x0970, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    9894:	e0 91 70 09 	lds	r30, 0x0970
    9898:	f0 e0       	ldi	r31, 0x00	; 0
    989a:	e7 50       	subi	r30, 0x07	; 7
    989c:	fc 4f       	sbci	r31, 0xFC	; 252
    989e:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    98a0:	90 91 70 09 	lds	r25, 0x0970
    98a4:	80 91 38 0d 	lds	r24, 0x0D38
    98a8:	98 13       	cpse	r25, r24
    98aa:	06 c0       	rjmp	.+12     	; 0x98b8 <EMeter_RX+0x6c>
			EM_RX_FIFOOverFlow = 1;
    98ac:	81 e0       	ldi	r24, 0x01	; 1
    98ae:	80 93 24 0b 	sts	0x0B24, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    98b2:	8f ef       	ldi	r24, 0xFF	; 255
    98b4:	80 93 6e 0a 	sts	0x0A6E, r24
			
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    98b8:	88 eb       	ldi	r24, 0xB8	; 184
    98ba:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    98bc:	5e 9a       	sbi	0x0b, 6	; 11
    98be:	08 95       	ret

000098c0 <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    98c0:	1f 92       	push	r1
    98c2:	0f 92       	push	r0
    98c4:	0f b6       	in	r0, 0x3f	; 63
    98c6:	0f 92       	push	r0
    98c8:	11 24       	eor	r1, r1
    98ca:	0b b6       	in	r0, 0x3b	; 59
    98cc:	0f 92       	push	r0
    98ce:	2f 93       	push	r18
    98d0:	3f 93       	push	r19
    98d2:	4f 93       	push	r20
    98d4:	5f 93       	push	r21
    98d6:	6f 93       	push	r22
    98d8:	7f 93       	push	r23
    98da:	8f 93       	push	r24
    98dc:	9f 93       	push	r25
    98de:	af 93       	push	r26
    98e0:	bf 93       	push	r27
    98e2:	ef 93       	push	r30
    98e4:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    98e6:	80 91 e0 03 	lds	r24, 0x03E0
    98ea:	88 23       	and	r24, r24
    98ec:	29 f0       	breq	.+10     	; 0x98f8 <__vector_30+0x38>
    98ee:	8c e9       	ldi	r24, 0x9C	; 156
    98f0:	90 e0       	ldi	r25, 0x00	; 0
    98f2:	0e 94 01 30 	call	0x6002	; 0x6002 <Modbus_RX>
    98f6:	02 c0       	rjmp	.+4      	; 0x98fc <__vector_30+0x3c>
	else EMeter_RX();
    98f8:	0e 94 26 4c 	call	0x984c	; 0x984c <EMeter_RX>
	COMM_LED = 1;
    98fc:	81 e0       	ldi	r24, 0x01	; 1
    98fe:	80 93 10 06 	sts	0x0610, r24
}	
    9902:	ff 91       	pop	r31
    9904:	ef 91       	pop	r30
    9906:	bf 91       	pop	r27
    9908:	af 91       	pop	r26
    990a:	9f 91       	pop	r25
    990c:	8f 91       	pop	r24
    990e:	7f 91       	pop	r23
    9910:	6f 91       	pop	r22
    9912:	5f 91       	pop	r21
    9914:	4f 91       	pop	r20
    9916:	3f 91       	pop	r19
    9918:	2f 91       	pop	r18
    991a:	0f 90       	pop	r0
    991c:	0b be       	out	0x3b, r0	; 59
    991e:	0f 90       	pop	r0
    9920:	0f be       	out	0x3f, r0	; 63
    9922:	0f 90       	pop	r0
    9924:	1f 90       	pop	r1
    9926:	18 95       	reti

00009928 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    9928:	80 91 76 0a 	lds	r24, 0x0A76
    992c:	88 23       	and	r24, r24
    992e:	21 f0       	breq	.+8      	; 0x9938 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9930:	88 e9       	ldi	r24, 0x98	; 152
    9932:	80 93 9a 00 	sts	0x009A, r24
    9936:	05 c0       	rjmp	.+10     	; 0x9942 <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9938:	88 e9       	ldi	r24, 0x98	; 152
    993a:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    993e:	10 92 59 09 	sts	0x0959, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    9942:	94 98       	cbi	0x12, 4	; 18
    9944:	08 95       	ret

00009946 <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    9946:	1f 92       	push	r1
    9948:	0f 92       	push	r0
    994a:	0f b6       	in	r0, 0x3f	; 63
    994c:	0f 92       	push	r0
    994e:	11 24       	eor	r1, r1
    9950:	0b b6       	in	r0, 0x3b	; 59
    9952:	0f 92       	push	r0
    9954:	2f 93       	push	r18
    9956:	3f 93       	push	r19
    9958:	4f 93       	push	r20
    995a:	5f 93       	push	r21
    995c:	6f 93       	push	r22
    995e:	7f 93       	push	r23
    9960:	8f 93       	push	r24
    9962:	9f 93       	push	r25
    9964:	af 93       	push	r26
    9966:	bf 93       	push	r27
    9968:	ef 93       	push	r30
    996a:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    996c:	80 91 e0 03 	lds	r24, 0x03E0
    9970:	88 23       	and	r24, r24
    9972:	29 f0       	breq	.+10     	; 0x997e <__vector_32+0x38>
    9974:	8c e9       	ldi	r24, 0x9C	; 156
    9976:	90 e0       	ldi	r25, 0x00	; 0
    9978:	0e 94 77 38 	call	0x70ee	; 0x70ee <Modbus_TX>
    997c:	02 c0       	rjmp	.+4      	; 0x9982 <__vector_32+0x3c>
	else EMeter_TX();
    997e:	0e 94 94 4c 	call	0x9928	; 0x9928 <EMeter_TX>
	COMM_LED = 1;
    9982:	81 e0       	ldi	r24, 0x01	; 1
    9984:	80 93 10 06 	sts	0x0610, r24
}
    9988:	ff 91       	pop	r31
    998a:	ef 91       	pop	r30
    998c:	bf 91       	pop	r27
    998e:	af 91       	pop	r26
    9990:	9f 91       	pop	r25
    9992:	8f 91       	pop	r24
    9994:	7f 91       	pop	r23
    9996:	6f 91       	pop	r22
    9998:	5f 91       	pop	r21
    999a:	4f 91       	pop	r20
    999c:	3f 91       	pop	r19
    999e:	2f 91       	pop	r18
    99a0:	0f 90       	pop	r0
    99a2:	0b be       	out	0x3b, r0	; 59
    99a4:	0f 90       	pop	r0
    99a6:	0f be       	out	0x3f, r0	; 63
    99a8:	0f 90       	pop	r0
    99aa:	1f 90       	pop	r1
    99ac:	18 95       	reti

000099ae <EMeter_Link>:

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    99ae:	81 e0       	ldi	r24, 0x01	; 1
    99b0:	90 91 05 01 	lds	r25, 0x0105
    99b4:	91 11       	cpse	r25, r1
    99b6:	80 e0       	ldi	r24, 0x00	; 0
	else return 1;
}
    99b8:	08 95       	ret

000099ba <IsEMReady>:
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    99ba:	81 e0       	ldi	r24, 0x01	; 1
    99bc:	90 91 71 0a 	lds	r25, 0x0A71
    99c0:	9f 3f       	cpi	r25, 0xFF	; 255
    99c2:	09 f0       	breq	.+2      	; 0x99c6 <IsEMReady+0xc>
    99c4:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    99c6:	08 95       	ret

000099c8 <EMRead>:
    99c8:	89 e2       	ldi	r24, 0x29	; 41
    99ca:	90 e0       	ldi	r25, 0x00	; 0
    99cc:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    99d0:	84 30       	cpi	r24, 0x04	; 4
    99d2:	11 f0       	breq	.+4      	; 0x99d8 <EMRead+0x10>
    99d4:	10 92 71 0a 	sts	0x0A71, r1
    99d8:	08 95       	ret

000099da <GPRS_AppInit>:

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    99da:	0e 94 8c 2a 	call	0x5518	; 0x5518 <Timer16Alloc>
    99de:	80 93 0f 06 	sts	0x060F, r24
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    99e2:	0e 94 8c 2a 	call	0x5518	; 0x5518 <Timer16Alloc>
    99e6:	80 93 4e 09 	sts	0x094E, r24
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    99ea:	0e 94 8c 2a 	call	0x5518	; 0x5518 <Timer16Alloc>
    99ee:	80 93 0c 0b 	sts	0x0B0C, r24
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    99f2:	6f ef       	ldi	r22, 0xFF	; 255
    99f4:	7f ef       	ldi	r23, 0xFF	; 255
    99f6:	80 91 4e 09 	lds	r24, 0x094E
    99fa:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    99fe:	80 91 11 01 	lds	r24, 0x0111
    9a02:	88 32       	cpi	r24, 0x28	; 40
    9a04:	28 f0       	brcs	.+10     	; 0x9a10 <GPRS_AppInit+0x36>
    9a06:	80 91 69 09 	lds	r24, 0x0969
    9a0a:	81 60       	ori	r24, 0x01	; 1
    9a0c:	80 93 69 09 	sts	0x0969, r24
    9a10:	08 95       	ret

00009a12 <GPRS_AddHeader>:
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    9a12:	0f 93       	push	r16
    9a14:	1f 93       	push	r17
    9a16:	cf 93       	push	r28
    9a18:	df 93       	push	r29
    9a1a:	00 d0       	rcall	.+0      	; 0x9a1c <GPRS_AddHeader+0xa>
    9a1c:	1f 92       	push	r1
    9a1e:	cd b7       	in	r28, 0x3d	; 61
    9a20:	de b7       	in	r29, 0x3e	; 62
    9a22:	8c 01       	movw	r16, r24

	Buf[0] = 5;	
    9a24:	85 e0       	ldi	r24, 0x05	; 5
    9a26:	f8 01       	movw	r30, r16
    9a28:	80 83       	st	Z, r24
	Buf[1] = 1;	
    9a2a:	81 e0       	ldi	r24, 0x01	; 1
    9a2c:	81 83       	std	Z+1, r24	; 0x01
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a2e:	8c e0       	ldi	r24, 0x0C	; 12
    9a30:	91 e0       	ldi	r25, 0x01	; 1
    9a32:	2b 83       	std	Y+3, r18	; 0x03
    9a34:	4a 83       	std	Y+2, r20	; 0x02
    9a36:	69 83       	std	Y+1, r22	; 0x01
    9a38:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    9a3c:	f8 01       	movw	r30, r16
    9a3e:	92 83       	std	Z+2, r25	; 0x02
    9a40:	8c e0       	ldi	r24, 0x0C	; 12
    9a42:	91 e0       	ldi	r25, 0x01	; 1
    9a44:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    9a48:	f8 01       	movw	r30, r16
    9a4a:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    9a4c:	69 81       	ldd	r22, Y+1	; 0x01
    9a4e:	64 83       	std	Z+4, r22	; 0x04
	Buf[5] = Size;	// -       
    9a50:	2b 81       	ldd	r18, Y+3	; 0x03
    9a52:	25 83       	std	Z+5, r18	; 0x05
	Buf[6] = Func;		
    9a54:	4a 81       	ldd	r20, Y+2	; 0x02
    9a56:	46 83       	std	Z+6, r20	; 0x06
}
    9a58:	0f 90       	pop	r0
    9a5a:	0f 90       	pop	r0
    9a5c:	0f 90       	pop	r0
    9a5e:	df 91       	pop	r29
    9a60:	cf 91       	pop	r28
    9a62:	1f 91       	pop	r17
    9a64:	0f 91       	pop	r16
    9a66:	08 95       	ret

00009a68 <GPRS_CurDataSend>:

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    9a68:	cf 92       	push	r12
    9a6a:	df 92       	push	r13
    9a6c:	ef 92       	push	r14
    9a6e:	ff 92       	push	r15
    9a70:	0f 93       	push	r16
    9a72:	1f 93       	push	r17
    9a74:	cf 93       	push	r28
    9a76:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    9a78:	86 e0       	ldi	r24, 0x06	; 6
    9a7a:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    9a7e:	81 e0       	ldi	r24, 0x01	; 1
    9a80:	80 93 3a 0b 	sts	0x0B3A, r24
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9a84:	90 91 7a 09 	lds	r25, 0x097A
    9a88:	90 93 3b 0b 	sts	0x0B3B, r25
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    9a8c:	90 91 79 09 	lds	r25, 0x0979
    9a90:	90 93 3c 0b 	sts	0x0B3C, r25
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    9a94:	90 91 78 09 	lds	r25, 0x0978
    9a98:	90 93 3d 0b 	sts	0x0B3D, r25
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    9a9c:	90 91 77 09 	lds	r25, 0x0977
    9aa0:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    9aa4:	90 91 76 09 	lds	r25, 0x0976
    9aa8:	90 93 3f 0b 	sts	0x0B3F, r25
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    9aac:	90 91 75 09 	lds	r25, 0x0975
    9ab0:	90 93 40 0b 	sts	0x0B40, r25
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    9ab4:	90 91 74 09 	lds	r25, 0x0974
    9ab8:	90 93 41 0b 	sts	0x0B41, r25
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9abc:	90 91 73 09 	lds	r25, 0x0973
    9ac0:	90 93 42 0b 	sts	0x0B42, r25

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    9ac4:	80 93 43 0b 	sts	0x0B43, r24
	GPRS_Data_Out[11] = SW_VERSION;		//   
    9ac8:	83 e0       	ldi	r24, 0x03	; 3
    9aca:	80 93 44 0b 	sts	0x0B44, r24
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    9ace:	87 e0       	ldi	r24, 0x07	; 7
    9ad0:	80 93 45 0b 	sts	0x0B45, r24

	GPRS_Data_Out[13] = 60;			// -       
    9ad4:	8c e3       	ldi	r24, 0x3C	; 60
    9ad6:	80 93 46 0b 	sts	0x0B46, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    9ada:	80 91 1c 0b 	lds	r24, 0x0B1C
    9ade:	80 93 47 0b 	sts	0x0B47, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    9ae2:	80 91 1d 0b 	lds	r24, 0x0B1D
    9ae6:	80 93 48 0b 	sts	0x0B48, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    9aea:	80 91 1e 0b 	lds	r24, 0x0B1E
    9aee:	80 93 49 0b 	sts	0x0B49, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    9af2:	80 91 1f 0b 	lds	r24, 0x0B1F
    9af6:	80 93 4a 0b 	sts	0x0B4A, r24

	if(EMeter_Link()){
    9afa:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <EMeter_Link>
    9afe:	88 23       	and	r24, r24
    9b00:	f1 f0       	breq	.+60     	; 0x9b3e <GPRS_CurDataSend+0xd6>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b02:	89 e2       	ldi	r24, 0x29	; 41
    9b04:	90 e0       	ldi	r25, 0x00	; 0
    9b06:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9b0a:	81 30       	cpi	r24, 0x01	; 1
    9b0c:	a9 f4       	brne	.+42     	; 0x9b38 <GPRS_CurDataSend+0xd0>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    9b0e:	82 e7       	ldi	r24, 0x72	; 114
    9b10:	98 e0       	ldi	r25, 0x08	; 8
    9b12:	9f 93       	push	r25
    9b14:	8f 93       	push	r24
    9b16:	8a ee       	ldi	r24, 0xEA	; 234
    9b18:	92 e0       	ldi	r25, 0x02	; 2
    9b1a:	9f 93       	push	r25
    9b1c:	8f 93       	push	r24
    9b1e:	8b e4       	ldi	r24, 0x4B	; 75
    9b20:	9b e0       	ldi	r25, 0x0B	; 11
    9b22:	9f 93       	push	r25
    9b24:	8f 93       	push	r24
    9b26:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
    9b2a:	0f 90       	pop	r0
    9b2c:	0f 90       	pop	r0
    9b2e:	0f 90       	pop	r0
    9b30:	0f 90       	pop	r0
    9b32:	0f 90       	pop	r0
    9b34:	0f 90       	pop	r0
    9b36:	11 c0       	rjmp	.+34     	; 0x9b5a <GPRS_CurDataSend+0xf2>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    9b38:	8a ed       	ldi	r24, 0xDA	; 218
    9b3a:	92 e0       	ldi	r25, 0x02	; 2
    9b3c:	02 c0       	rjmp	.+4      	; 0x9b42 <GPRS_CurDataSend+0xda>
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    9b3e:	8a ec       	ldi	r24, 0xCA	; 202
    9b40:	92 e0       	ldi	r25, 0x02	; 2
    9b42:	9f 93       	push	r25
    9b44:	8f 93       	push	r24
    9b46:	8b e4       	ldi	r24, 0x4B	; 75
    9b48:	9b e0       	ldi	r25, 0x0B	; 11
    9b4a:	9f 93       	push	r25
    9b4c:	8f 93       	push	r24
    9b4e:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
    9b52:	0f 90       	pop	r0
    9b54:	0f 90       	pop	r0
    9b56:	0f 90       	pop	r0
    9b58:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    9b5a:	10 92 5b 0b 	sts	0x0B5B, r1
    9b5e:	10 92 5a 0b 	sts	0x0B5A, r1
	if(!EMeter_Link()){
    9b62:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <EMeter_Link>
    9b66:	e0 90 41 0d 	lds	r14, 0x0D41
    9b6a:	f0 90 42 0d 	lds	r15, 0x0D42
    9b6e:	00 91 e4 03 	lds	r16, 0x03E4
    9b72:	10 91 e5 03 	lds	r17, 0x03E5
    9b76:	c0 91 73 0a 	lds	r28, 0x0A73
    9b7a:	d0 91 74 0a 	lds	r29, 0x0A74
    9b7e:	81 11       	cpse	r24, r1
    9b80:	03 c0       	rjmp	.+6      	; 0x9b88 <GPRS_CurDataSend+0x120>
		ptr[0] |= (1<<0);
    9b82:	81 e0       	ldi	r24, 0x01	; 1
    9b84:	90 e0       	ldi	r25, 0x00	; 0
    9b86:	ac c0       	rjmp	.+344    	; 0x9ce0 <GPRS_CurDataSend+0x278>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    9b88:	e1 14       	cp	r14, r1
    9b8a:	f1 04       	cpc	r15, r1
    9b8c:	31 f4       	brne	.+12     	; 0x9b9a <GPRS_CurDataSend+0x132>
    9b8e:	80 e2       	ldi	r24, 0x20	; 32
    9b90:	90 e0       	ldi	r25, 0x00	; 0
    9b92:	90 93 5b 0b 	sts	0x0B5B, r25
    9b96:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Ub==0) ptr[0] |= (1<<6);
    9b9a:	01 15       	cp	r16, r1
    9b9c:	11 05       	cpc	r17, r1
    9b9e:	49 f4       	brne	.+18     	; 0x9bb2 <GPRS_CurDataSend+0x14a>
    9ba0:	80 91 5a 0b 	lds	r24, 0x0B5A
    9ba4:	90 91 5b 0b 	lds	r25, 0x0B5B
    9ba8:	80 64       	ori	r24, 0x40	; 64
    9baa:	90 93 5b 0b 	sts	0x0B5B, r25
    9bae:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Uc==0) ptr[0] |= (1<<7);
    9bb2:	20 97       	sbiw	r28, 0x00	; 0
    9bb4:	49 f4       	brne	.+18     	; 0x9bc8 <GPRS_CurDataSend+0x160>
    9bb6:	80 91 5a 0b 	lds	r24, 0x0B5A
    9bba:	90 91 5b 0b 	lds	r25, 0x0B5B
    9bbe:	80 68       	ori	r24, 0x80	; 128
    9bc0:	90 93 5b 0b 	sts	0x0B5B, r25
    9bc4:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    9bc8:	40 91 5f 09 	lds	r20, 0x095F
    9bcc:	50 91 60 09 	lds	r21, 0x0960
    9bd0:	60 91 61 09 	lds	r22, 0x0961
    9bd4:	70 91 62 09 	lds	r23, 0x0962
    9bd8:	80 91 08 0b 	lds	r24, 0x0B08
    9bdc:	90 91 09 0b 	lds	r25, 0x0B09
    9be0:	a0 91 0a 0b 	lds	r26, 0x0B0A
    9be4:	b0 91 0b 0b 	lds	r27, 0x0B0B
    9be8:	48 17       	cp	r20, r24
    9bea:	59 07       	cpc	r21, r25
    9bec:	6a 07       	cpc	r22, r26
    9bee:	7b 07       	cpc	r23, r27
    9bf0:	59 f4       	brne	.+22     	; 0x9c08 <GPRS_CurDataSend+0x1a0>
    9bf2:	20 91 3f 09 	lds	r18, 0x093F
    9bf6:	30 91 40 09 	lds	r19, 0x0940
    9bfa:	80 91 f5 09 	lds	r24, 0x09F5
    9bfe:	90 91 f6 09 	lds	r25, 0x09F6
    9c02:	28 17       	cp	r18, r24
    9c04:	39 07       	cpc	r19, r25
    9c06:	49 f0       	breq	.+18     	; 0x9c1a <GPRS_CurDataSend+0x1b2>
    9c08:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c0c:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c10:	91 60       	ori	r25, 0x01	; 1
    9c12:	90 93 5b 0b 	sts	0x0B5B, r25
    9c16:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    9c1a:	40 91 20 0b 	lds	r20, 0x0B20
    9c1e:	50 91 21 0b 	lds	r21, 0x0B21
    9c22:	60 91 22 0b 	lds	r22, 0x0B22
    9c26:	70 91 23 0b 	lds	r23, 0x0B23
    9c2a:	80 91 ee 09 	lds	r24, 0x09EE
    9c2e:	90 91 ef 09 	lds	r25, 0x09EF
    9c32:	a0 91 f0 09 	lds	r26, 0x09F0
    9c36:	b0 91 f1 09 	lds	r27, 0x09F1
    9c3a:	48 17       	cp	r20, r24
    9c3c:	59 07       	cpc	r21, r25
    9c3e:	6a 07       	cpc	r22, r26
    9c40:	7b 07       	cpc	r23, r27
    9c42:	59 f4       	brne	.+22     	; 0x9c5a <GPRS_CurDataSend+0x1f2>
    9c44:	20 91 1a 06 	lds	r18, 0x061A
    9c48:	30 91 1b 06 	lds	r19, 0x061B
    9c4c:	80 91 f4 03 	lds	r24, 0x03F4
    9c50:	90 91 f5 03 	lds	r25, 0x03F5
    9c54:	28 17       	cp	r18, r24
    9c56:	39 07       	cpc	r19, r25
    9c58:	49 f0       	breq	.+18     	; 0x9c6c <GPRS_CurDataSend+0x204>
    9c5a:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c5e:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c62:	92 60       	ori	r25, 0x02	; 2
    9c64:	90 93 5b 0b 	sts	0x0B5B, r25
    9c68:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    9c6c:	40 91 eb 03 	lds	r20, 0x03EB
    9c70:	50 91 ec 03 	lds	r21, 0x03EC
    9c74:	60 91 ed 03 	lds	r22, 0x03ED
    9c78:	70 91 ee 03 	lds	r23, 0x03EE
    9c7c:	80 91 16 06 	lds	r24, 0x0616
    9c80:	90 91 17 06 	lds	r25, 0x0617
    9c84:	a0 91 18 06 	lds	r26, 0x0618
    9c88:	b0 91 19 06 	lds	r27, 0x0619
    9c8c:	48 17       	cp	r20, r24
    9c8e:	59 07       	cpc	r21, r25
    9c90:	6a 07       	cpc	r22, r26
    9c92:	7b 07       	cpc	r23, r27
    9c94:	59 f4       	brne	.+22     	; 0x9cac <GPRS_CurDataSend+0x244>
    9c96:	20 91 1a 0b 	lds	r18, 0x0B1A
    9c9a:	30 91 1b 0b 	lds	r19, 0x0B1B
    9c9e:	80 91 43 0d 	lds	r24, 0x0D43
    9ca2:	90 91 44 0d 	lds	r25, 0x0D44
    9ca6:	28 17       	cp	r18, r24
    9ca8:	39 07       	cpc	r19, r25
    9caa:	49 f0       	breq	.+18     	; 0x9cbe <GPRS_CurDataSend+0x256>
    9cac:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cb0:	90 91 5b 0b 	lds	r25, 0x0B5B
    9cb4:	94 60       	ori	r25, 0x04	; 4
    9cb6:	90 93 5b 0b 	sts	0x0B5B, r25
    9cba:	80 93 5a 0b 	sts	0x0B5A, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    9cbe:	80 91 53 09 	lds	r24, 0x0953
    9cc2:	90 91 54 09 	lds	r25, 0x0954
    9cc6:	a0 91 55 09 	lds	r26, 0x0955
    9cca:	b0 91 56 09 	lds	r27, 0x0956
    9cce:	89 2b       	or	r24, r25
    9cd0:	8a 2b       	or	r24, r26
    9cd2:	8b 2b       	or	r24, r27
    9cd4:	49 f0       	breq	.+18     	; 0x9ce8 <GPRS_CurDataSend+0x280>
    9cd6:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cda:	90 91 5b 0b 	lds	r25, 0x0B5B
    9cde:	98 60       	ori	r25, 0x08	; 8
    9ce0:	90 93 5b 0b 	sts	0x0B5B, r25
    9ce4:	80 93 5a 0b 	sts	0x0B5A, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    9ce8:	80 e0       	ldi	r24, 0x00	; 0
    9cea:	0e 94 b3 3b 	call	0x7766	; 0x7766 <DI_Status>
    9cee:	81 11       	cpse	r24, r1
    9cf0:	09 c0       	rjmp	.+18     	; 0x9d04 <GPRS_CurDataSend+0x29c>
    9cf2:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cf6:	90 91 5b 0b 	lds	r25, 0x0B5B
    9cfa:	82 60       	ori	r24, 0x02	; 2
    9cfc:	90 93 5b 0b 	sts	0x0B5B, r25
    9d00:	80 93 5a 0b 	sts	0x0B5A, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    9d04:	81 e0       	ldi	r24, 0x01	; 1
    9d06:	0e 94 b3 3b 	call	0x7766	; 0x7766 <DI_Status>
    9d0a:	81 11       	cpse	r24, r1
    9d0c:	09 c0       	rjmp	.+18     	; 0x9d20 <GPRS_CurDataSend+0x2b8>
    9d0e:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d12:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d16:	84 60       	ori	r24, 0x04	; 4
    9d18:	90 93 5b 0b 	sts	0x0B5B, r25
    9d1c:	80 93 5a 0b 	sts	0x0B5A, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    9d20:	c0 90 f2 05 	lds	r12, 0x05F2
    9d24:	d0 90 f3 05 	lds	r13, 0x05F3
    9d28:	c6 01       	movw	r24, r12
    9d2a:	90 58       	subi	r25, 0x80	; 128
    9d2c:	02 97       	sbiw	r24, 0x02	; 2
    9d2e:	00 f1       	brcs	.+64     	; 0x9d70 <GPRS_CurDataSend+0x308>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9d30:	8d e0       	ldi	r24, 0x0D	; 13
    9d32:	90 e0       	ldi	r25, 0x00	; 0
    9d34:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    9d38:	c8 16       	cp	r12, r24
    9d3a:	d9 06       	cpc	r13, r25
    9d3c:	4c f0       	brlt	.+18     	; 0x9d50 <GPRS_CurDataSend+0x2e8>
    9d3e:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d42:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d46:	88 60       	ori	r24, 0x08	; 8
    9d48:	90 93 5b 0b 	sts	0x0B5B, r25
    9d4c:	80 93 5a 0b 	sts	0x0B5A, r24
    9d50:	8b e0       	ldi	r24, 0x0B	; 11
    9d52:	90 e0       	ldi	r25, 0x00	; 0
    9d54:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    9d58:	8c 15       	cp	r24, r12
    9d5a:	9d 05       	cpc	r25, r13
    9d5c:	4c f0       	brlt	.+18     	; 0x9d70 <GPRS_CurDataSend+0x308>
    9d5e:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d62:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d66:	80 61       	ori	r24, 0x10	; 16
    9d68:	90 93 5b 0b 	sts	0x0B5B, r25
    9d6c:	80 93 5a 0b 	sts	0x0B5A, r24
	}

	ptr[1] = Temperature[0];
    9d70:	d0 92 5d 0b 	sts	0x0B5D, r13
    9d74:	c0 92 5c 0b 	sts	0x0B5C, r12

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    9d78:	80 91 46 02 	lds	r24, 0x0246
    9d7c:	90 91 47 02 	lds	r25, 0x0247
    9d80:	a0 91 48 02 	lds	r26, 0x0248
    9d84:	b0 91 49 02 	lds	r27, 0x0249
    9d88:	80 93 5e 0b 	sts	0x0B5E, r24
    9d8c:	90 93 5f 0b 	sts	0x0B5F, r25
    9d90:	a0 93 60 0b 	sts	0x0B60, r26
    9d94:	b0 93 61 0b 	sts	0x0B61, r27
	pi4[1] = E_Meter_RAM.Am;
    9d98:	80 91 4a 02 	lds	r24, 0x024A
    9d9c:	90 91 4b 02 	lds	r25, 0x024B
    9da0:	a0 91 4c 02 	lds	r26, 0x024C
    9da4:	b0 91 4d 02 	lds	r27, 0x024D
    9da8:	80 93 62 0b 	sts	0x0B62, r24
    9dac:	90 93 63 0b 	sts	0x0B63, r25
    9db0:	a0 93 64 0b 	sts	0x0B64, r26
    9db4:	b0 93 65 0b 	sts	0x0B65, r27
	pi4[2] = E_Meter_RAM.Rp;
    9db8:	80 91 4e 02 	lds	r24, 0x024E
    9dbc:	90 91 4f 02 	lds	r25, 0x024F
    9dc0:	a0 91 50 02 	lds	r26, 0x0250
    9dc4:	b0 91 51 02 	lds	r27, 0x0251
    9dc8:	80 93 66 0b 	sts	0x0B66, r24
    9dcc:	90 93 67 0b 	sts	0x0B67, r25
    9dd0:	a0 93 68 0b 	sts	0x0B68, r26
    9dd4:	b0 93 69 0b 	sts	0x0B69, r27
	pi4[3] = E_Meter_RAM.Rm;
    9dd8:	80 91 52 02 	lds	r24, 0x0252
    9ddc:	90 91 53 02 	lds	r25, 0x0253
    9de0:	a0 91 54 02 	lds	r26, 0x0254
    9de4:	b0 91 55 02 	lds	r27, 0x0255
    9de8:	80 93 6a 0b 	sts	0x0B6A, r24
    9dec:	90 93 6b 0b 	sts	0x0B6B, r25
    9df0:	a0 93 6c 0b 	sts	0x0B6C, r26
    9df4:	b0 93 6d 0b 	sts	0x0B6D, r27

	GPRS_Data_Out[53] = EM_Year;
    9df8:	80 91 86 09 	lds	r24, 0x0986
    9dfc:	80 93 6e 0b 	sts	0x0B6E, r24
	GPRS_Data_Out[54] = EM_Month;
    9e00:	80 91 ed 09 	lds	r24, 0x09ED
    9e04:	80 93 6f 0b 	sts	0x0B6F, r24
	GPRS_Data_Out[55] = EM_Day;
    9e08:	80 91 e2 03 	lds	r24, 0x03E2
    9e0c:	80 93 70 0b 	sts	0x0B70, r24
	GPRS_Data_Out[56] = EM_Hour;
    9e10:	80 91 6e 09 	lds	r24, 0x096E
    9e14:	80 93 71 0b 	sts	0x0B71, r24
	GPRS_Data_Out[57] = EM_Min;
    9e18:	80 91 4d 09 	lds	r24, 0x094D
    9e1c:	80 93 72 0b 	sts	0x0B72, r24
	GPRS_Data_Out[58] = EM_Sec;
    9e20:	80 91 0e 06 	lds	r24, 0x060E
    9e24:	80 93 73 0b 	sts	0x0B73, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
	ptr[0] = EM_PowerActive;
    9e28:	80 91 6f 0a 	lds	r24, 0x0A6F
    9e2c:	90 91 70 0a 	lds	r25, 0x0A70
    9e30:	90 93 75 0b 	sts	0x0B75, r25
    9e34:	80 93 74 0b 	sts	0x0B74, r24
	ptr[1] = Ua;
    9e38:	f0 92 77 0b 	sts	0x0B77, r15
    9e3c:	e0 92 76 0b 	sts	0x0B76, r14
	ptr[2] = Ub;
    9e40:	10 93 79 0b 	sts	0x0B79, r17
    9e44:	00 93 78 0b 	sts	0x0B78, r16
	ptr[3] = Uc;
    9e48:	d0 93 7b 0b 	sts	0x0B7B, r29
    9e4c:	c0 93 7a 0b 	sts	0x0B7A, r28
	ptr[4] = Ia;
    9e50:	80 91 f2 03 	lds	r24, 0x03F2
    9e54:	90 91 f3 03 	lds	r25, 0x03F3
    9e58:	90 93 7d 0b 	sts	0x0B7D, r25
    9e5c:	80 93 7c 0b 	sts	0x0B7C, r24
	ptr[5] = Ib;
    9e60:	80 91 47 09 	lds	r24, 0x0947
    9e64:	90 91 48 09 	lds	r25, 0x0948
    9e68:	90 93 7f 0b 	sts	0x0B7F, r25
    9e6c:	80 93 7e 0b 	sts	0x0B7E, r24
	ptr[6] = Ic;
    9e70:	80 91 81 09 	lds	r24, 0x0981
    9e74:	90 91 82 09 	lds	r25, 0x0982
    9e78:	90 93 81 0b 	sts	0x0B81, r25
    9e7c:	80 93 80 0b 	sts	0x0B80, r24

	GPRS_Data_Out[73] = GSM_RSSI;
    9e80:	80 91 25 06 	lds	r24, 0x0625
    9e84:	80 93 82 0b 	sts	0x0B82, r24

	GPRS_FlgSz_Out = 74;	//    .     
    9e88:	8a e4       	ldi	r24, 0x4A	; 74
    9e8a:	80 93 43 09 	sts	0x0943, r24
}
    9e8e:	df 91       	pop	r29
    9e90:	cf 91       	pop	r28
    9e92:	1f 91       	pop	r17
    9e94:	0f 91       	pop	r16
    9e96:	ff 90       	pop	r15
    9e98:	ef 90       	pop	r14
    9e9a:	df 90       	pop	r13
    9e9c:	cf 90       	pop	r12
    9e9e:	08 95       	ret

00009ea0 <GPRS_SendData>:

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    9ea0:	cf 93       	push	r28
    9ea2:	df 93       	push	r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9ea4:	8a e0       	ldi	r24, 0x0A	; 10
    9ea6:	90 e0       	ldi	r25, 0x00	; 0
    9ea8:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    9eac:	88 23       	and	r24, r24
    9eae:	09 f4       	brne	.+2      	; 0x9eb2 <GPRS_SendData+0x12>
    9eb0:	59 c0       	rjmp	.+178    	; 0x9f64 <GPRS_SendData+0xc4>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9eb2:	88 e0       	ldi	r24, 0x08	; 8
    9eb4:	90 e0       	ldi	r25, 0x00	; 0
    9eb6:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    9eba:	cc 97       	sbiw	r24, 0x3c	; 60
    9ebc:	08 f4       	brcc	.+2      	; 0x9ec0 <GPRS_SendData+0x20>
    9ebe:	52 c0       	rjmp	.+164    	; 0x9f64 <GPRS_SendData+0xc4>
		if(Timer1s != Timer1sOld){
    9ec0:	80 91 0e 0b 	lds	r24, 0x0B0E
    9ec4:	90 91 80 09 	lds	r25, 0x0980
    9ec8:	89 17       	cp	r24, r25
    9eca:	91 f0       	breq	.+36     	; 0x9ef0 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    9ecc:	80 93 80 09 	sts	0x0980, r24
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    9ed0:	c0 91 18 0b 	lds	r28, 0x0B18
    9ed4:	d0 91 19 0b 	lds	r29, 0x0B19
    9ed8:	88 e0       	ldi	r24, 0x08	; 8
    9eda:	90 e0       	ldi	r25, 0x00	; 0
    9edc:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    9ee0:	c8 17       	cp	r28, r24
    9ee2:	d9 07       	cpc	r29, r25
    9ee4:	28 f4       	brcc	.+10     	; 0x9ef0 <GPRS_SendData+0x50>
    9ee6:	21 96       	adiw	r28, 0x01	; 1
    9ee8:	d0 93 19 0b 	sts	0x0B19, r29
    9eec:	c0 93 18 0b 	sts	0x0B18, r28
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    9ef0:	c0 91 18 0b 	lds	r28, 0x0B18
    9ef4:	d0 91 19 0b 	lds	r29, 0x0B19
    9ef8:	88 e0       	ldi	r24, 0x08	; 8
    9efa:	90 e0       	ldi	r25, 0x00	; 0
    9efc:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    9f00:	4e 97       	sbiw	r24, 0x1e	; 30
    9f02:	c8 17       	cp	r28, r24
    9f04:	d9 07       	cpc	r29, r25
    9f06:	29 f4       	brne	.+10     	; 0x9f12 <GPRS_SendData+0x72>
			if(IsEMReady()) EMRead();			
    9f08:	0e 94 dd 4c 	call	0x99ba	; 0x99ba <IsEMReady>
    9f0c:	81 11       	cpse	r24, r1
    9f0e:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <EMRead>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    9f12:	c0 91 18 0b 	lds	r28, 0x0B18
    9f16:	d0 91 19 0b 	lds	r29, 0x0B19
    9f1a:	88 e0       	ldi	r24, 0x08	; 8
    9f1c:	90 e0       	ldi	r25, 0x00	; 0
    9f1e:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    9f22:	0f 97       	sbiw	r24, 0x0f	; 15
    9f24:	c8 17       	cp	r28, r24
    9f26:	d9 07       	cpc	r29, r25
    9f28:	49 f4       	brne	.+18     	; 0x9f3c <GPRS_SendData+0x9c>
			if(!EMeter_Link()){
    9f2a:	0e 94 d7 4c 	call	0x99ae	; 0x99ae <EMeter_Link>
    9f2e:	81 11       	cpse	r24, r1
    9f30:	05 c0       	rjmp	.+10     	; 0x9f3c <GPRS_SendData+0x9c>
				if(IsEMReady()) EMRead();
    9f32:	0e 94 dd 4c 	call	0x99ba	; 0x99ba <IsEMReady>
    9f36:	81 11       	cpse	r24, r1
    9f38:	0e 94 e4 4c 	call	0x99c8	; 0x99c8 <EMRead>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    9f3c:	c0 91 18 0b 	lds	r28, 0x0B18
    9f40:	d0 91 19 0b 	lds	r29, 0x0B19
    9f44:	88 e0       	ldi	r24, 0x08	; 8
    9f46:	90 e0       	ldi	r25, 0x00	; 0
    9f48:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    9f4c:	c8 17       	cp	r28, r24
    9f4e:	d9 07       	cpc	r29, r25
    9f50:	48 f0       	brcs	.+18     	; 0x9f64 <GPRS_SendData+0xc4>
			GPRS_DataTimer = 0;
    9f52:	10 92 19 0b 	sts	0x0B19, r1
    9f56:	10 92 18 0b 	sts	0x0B18, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    9f5a:	80 91 5c 09 	lds	r24, 0x095C
    9f5e:	81 60       	ori	r24, 0x01	; 1
    9f60:	80 93 5c 09 	sts	0x095C, r24
		}
	}
}
    9f64:	df 91       	pop	r29
    9f66:	cf 91       	pop	r28
    9f68:	08 95       	ret

00009f6a <GPRS_NewMsg>:

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    9f6a:	90 91 69 09 	lds	r25, 0x0969
    9f6e:	90 fd       	sbrc	r25, 0
    9f70:	5b c0       	rjmp	.+182    	; 0xa028 <GPRS_NewMsg+0xbe>
		GPRS_CrashID++;
    9f72:	90 91 04 01 	lds	r25, 0x0104
    9f76:	9f 5f       	subi	r25, 0xFF	; 255
    9f78:	90 93 04 01 	sts	0x0104, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    9f7c:	26 e0       	ldi	r18, 0x06	; 6
    9f7e:	20 93 07 0a 	sts	0x0A07, r18
		GPRS_CrashData[1] = 1;	
    9f82:	21 e0       	ldi	r18, 0x01	; 1
    9f84:	20 93 08 0a 	sts	0x0A08, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9f88:	30 91 7a 09 	lds	r19, 0x097A
    9f8c:	30 93 09 0a 	sts	0x0A09, r19
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    9f90:	30 91 79 09 	lds	r19, 0x0979
    9f94:	30 93 0a 0a 	sts	0x0A0A, r19
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    9f98:	30 91 78 09 	lds	r19, 0x0978
    9f9c:	30 93 0b 0a 	sts	0x0A0B, r19
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    9fa0:	30 91 77 09 	lds	r19, 0x0977
    9fa4:	30 93 0c 0a 	sts	0x0A0C, r19
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    9fa8:	30 91 76 09 	lds	r19, 0x0976
    9fac:	30 93 0d 0a 	sts	0x0A0D, r19
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    9fb0:	30 91 75 09 	lds	r19, 0x0975
    9fb4:	30 93 0e 0a 	sts	0x0A0E, r19
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    9fb8:	30 91 74 09 	lds	r19, 0x0974
    9fbc:	30 93 0f 0a 	sts	0x0A0F, r19
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9fc0:	30 91 73 09 	lds	r19, 0x0973
    9fc4:	30 93 10 0a 	sts	0x0A10, r19

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    9fc8:	32 e0       	ldi	r19, 0x02	; 2
    9fca:	30 93 11 0a 	sts	0x0A11, r19
		GPRS_CrashData[11] = SW_VERSION;		//   
    9fce:	33 e0       	ldi	r19, 0x03	; 3
    9fd0:	30 93 12 0a 	sts	0x0A12, r19
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    9fd4:	37 e0       	ldi	r19, 0x07	; 7
    9fd6:	30 93 13 0a 	sts	0x0A13, r19
		
		GPRS_CrashData[14] = Type;
    9fda:	80 93 15 0a 	sts	0x0A15, r24
		GPRS_CrashData[15] = 1;			//    
    9fde:	20 93 16 0a 	sts	0x0A16, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    9fe2:	90 93 17 0a 	sts	0x0A17, r25

		GPRS_CrashData[17] = 0;
    9fe6:	10 92 18 0a 	sts	0x0A18, r1
		GPRS_CrashData[18] = 0;
    9fea:	10 92 19 0a 	sts	0x0A19, r1
		GPRS_CrashData[19] = 0;
    9fee:	10 92 1a 0a 	sts	0x0A1A, r1
		GPRS_CrashData[20] = 0;
    9ff2:	10 92 1b 0a 	sts	0x0A1B, r1
		GPRS_CrashData[21] = 0;
    9ff6:	10 92 1c 0a 	sts	0x0A1C, r1
		GPRS_CrashData[22] = 0;
    9ffa:	10 92 1d 0a 	sts	0x0A1D, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    9ffe:	42 e3       	ldi	r20, 0x32	; 50
    a000:	50 e0       	ldi	r21, 0x00	; 0
    a002:	8e e1       	ldi	r24, 0x1E	; 30
    a004:	9a e0       	ldi	r25, 0x0A	; 10
    a006:	0e 94 5e 6c 	call	0xd8bc	; 0xd8bc <strlcpy_P>
    a00a:	87 5f       	subi	r24, 0xF7	; 247
    a00c:	80 93 14 0a 	sts	0x0A14, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
    a010:	80 91 5c 09 	lds	r24, 0x095C
    a014:	8f 7d       	andi	r24, 0xDF	; 223
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    a016:	80 64       	ori	r24, 0x40	; 64
    a018:	80 93 5c 09 	sts	0x095C, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    a01c:	60 ee       	ldi	r22, 0xE0	; 224
    a01e:	7e e2       	ldi	r23, 0x2E	; 46
    a020:	80 91 0f 06 	lds	r24, 0x060F
    a024:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>
    a028:	08 95       	ret

0000a02a <GPRS_SendNewCrash>:
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    a02a:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a02c:	c0 91 14 0a 	lds	r28, 0x0A14
    a030:	c2 5f       	subi	r28, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a032:	4c 2f       	mov	r20, r28
    a034:	50 e0       	ldi	r21, 0x00	; 0
    a036:	67 e0       	ldi	r22, 0x07	; 7
    a038:	7a e0       	ldi	r23, 0x0A	; 10
    a03a:	89 e3       	ldi	r24, 0x39	; 57
    a03c:	9b e0       	ldi	r25, 0x0B	; 11
    a03e:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a042:	c0 93 43 09 	sts	0x0943, r28
}
    a046:	cf 91       	pop	r28
    a048:	08 95       	ret

0000a04a <GPRS_SendRepCrash>:
// --      
void GPRS_SendRepCrash(void){
    a04a:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a04c:	c0 91 14 0a 	lds	r28, 0x0A14
    a050:	c2 5f       	subi	r28, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    a052:	82 e0       	ldi	r24, 0x02	; 2
    a054:	80 93 16 0a 	sts	0x0A16, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a058:	4c 2f       	mov	r20, r28
    a05a:	50 e0       	ldi	r21, 0x00	; 0
    a05c:	67 e0       	ldi	r22, 0x07	; 7
    a05e:	7a e0       	ldi	r23, 0x0A	; 10
    a060:	89 e3       	ldi	r24, 0x39	; 57
    a062:	9b e0       	ldi	r25, 0x0B	; 11
    a064:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a068:	c0 93 43 09 	sts	0x0943, r28
}
    a06c:	cf 91       	pop	r28
    a06e:	08 95       	ret

0000a070 <GPRS_Check_PSW>:

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    a070:	0f 93       	push	r16
    a072:	1f 93       	push	r17
    a074:	cf 93       	push	r28
    a076:	df 93       	push	r29
    a078:	8c 01       	movw	r16, r24
    a07a:	c0 e0       	ldi	r28, 0x00	; 0
    a07c:	d0 e0       	ldi	r29, 0x00	; 0
    a07e:	ce 01       	movw	r24, r28
    a080:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a084:	08 17       	cp	r16, r24
    a086:	19 07       	cpc	r17, r25
    a088:	59 f0       	breq	.+22     	; 0xa0a0 <GPRS_Check_PSW+0x30>
    a08a:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    a08c:	80 e0       	ldi	r24, 0x00	; 0
    a08e:	c8 30       	cpi	r28, 0x08	; 8
    a090:	d8 07       	cpc	r29, r24
    a092:	a9 f7       	brne	.-22     	; 0xa07e <GPRS_Check_PSW+0xe>
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
    a094:	81 e0       	ldi	r24, 0x01	; 1
    a096:	0c 3f       	cpi	r16, 0xFC	; 252
    a098:	18 45       	sbci	r17, 0x58	; 88
    a09a:	19 f0       	breq	.+6      	; 0xa0a2 <GPRS_Check_PSW+0x32>
    a09c:	80 e0       	ldi	r24, 0x00	; 0
    a09e:	01 c0       	rjmp	.+2      	; 0xa0a2 <GPRS_Check_PSW+0x32>
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a0a0:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(Pass == 22780) return 1;
	return 0;
}
    a0a2:	df 91       	pop	r29
    a0a4:	cf 91       	pop	r28
    a0a6:	1f 91       	pop	r17
    a0a8:	0f 91       	pop	r16
    a0aa:	08 95       	ret

0000a0ac <GPRS_Get_Session_ID>:
	}
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
    a0ac:	cf 93       	push	r28
    a0ae:	df 93       	push	r29
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    a0b0:	80 91 69 09 	lds	r24, 0x0969
    a0b4:	83 ff       	sbrs	r24, 3
    a0b6:	05 c0       	rjmp	.+10     	; 0xa0c2 <GPRS_Get_Session_ID+0x16>
    a0b8:	10 92 11 0b 	sts	0x0B11, r1
    a0bc:	10 92 10 0b 	sts	0x0B10, r1
    a0c0:	12 c0       	rjmp	.+36     	; 0xa0e6 <GPRS_Get_Session_ID+0x3a>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    a0c2:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    a0c6:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint16_t Time = Timer16[TimerN];
    a0ca:	ec 2f       	mov	r30, r28
    a0cc:	f0 e0       	ldi	r31, 0x00	; 0
    a0ce:	ee 0f       	add	r30, r30
    a0d0:	ff 1f       	adc	r31, r31
    a0d2:	ea 5d       	subi	r30, 0xDA	; 218
    a0d4:	fc 4f       	sbci	r31, 0xFC	; 252
    a0d6:	c0 81       	ld	r28, Z
    a0d8:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    a0da:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
    a0de:	d0 93 11 0b 	sts	0x0B11, r29
    a0e2:	c0 93 10 0b 	sts	0x0B10, r28
	GPRS_Data_Out[0] = 5;	//    
    a0e6:	85 e0       	ldi	r24, 0x05	; 5
    a0e8:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a0ec:	81 e0       	ldi	r24, 0x01	; 1
    a0ee:	80 93 3a 0b 	sts	0x0B3A, r24
    a0f2:	8c e0       	ldi	r24, 0x0C	; 12
    a0f4:	91 e0       	ldi	r25, 0x01	; 1
    a0f6:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a0fa:	90 93 3b 0b 	sts	0x0B3B, r25
    a0fe:	8c e0       	ldi	r24, 0x0C	; 12
    a100:	91 e0       	ldi	r25, 0x01	; 1
    a102:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a106:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 4;
    a10a:	84 e0       	ldi	r24, 0x04	; 4
    a10c:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    a110:	80 91 10 0b 	lds	r24, 0x0B10
    a114:	90 91 11 0b 	lds	r25, 0x0B11
    a118:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    a11c:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_FlgSz_Out = 7;					//    .     	
    a120:	87 e0       	ldi	r24, 0x07	; 7
    a122:	80 93 43 09 	sts	0x0943, r24
}
    a126:	df 91       	pop	r29
    a128:	cf 91       	pop	r28
    a12a:	08 95       	ret

0000a12c <GPRS_RemoteDisplayControl>:

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    a12c:	6f e0       	ldi	r22, 0x0F	; 15
    a12e:	80 e0       	ldi	r24, 0x00	; 0
    a130:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    a134:	80 91 69 09 	lds	r24, 0x0969
    a138:	84 60       	ori	r24, 0x04	; 4
    a13a:	80 93 69 09 	sts	0x0969, r24
    a13e:	08 95       	ret

0000a140 <GPRS_SendDisplay>:
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
	GPRS_Data_Out[0] = 5;	//    
    a140:	85 e0       	ldi	r24, 0x05	; 5
    a142:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a146:	81 e0       	ldi	r24, 0x01	; 1
    a148:	80 93 3a 0b 	sts	0x0B3A, r24
    a14c:	8c e0       	ldi	r24, 0x0C	; 12
    a14e:	91 e0       	ldi	r25, 0x01	; 1
    a150:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a154:	90 93 3b 0b 	sts	0x0B3B, r25
    a158:	8c e0       	ldi	r24, 0x0C	; 12
    a15a:	91 e0       	ldi	r25, 0x01	; 1
    a15c:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a160:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 3;
    a164:	83 e0       	ldi	r24, 0x03	; 3
    a166:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = 34;
    a16a:	82 e2       	ldi	r24, 0x22	; 34
    a16c:	80 93 3e 0b 	sts	0x0B3E, r24
	GPRS_Data_Out[6] = 10;
    a170:	8a e0       	ldi	r24, 0x0A	; 10
    a172:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    a176:	80 93 40 0b 	sts	0x0B40, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    a17a:	88 e2       	ldi	r24, 0x28	; 40
    a17c:	80 93 43 09 	sts	0x0943, r24
    a180:	08 95       	ret

0000a182 <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    a182:	cf 93       	push	r28
    a184:	c8 2f       	mov	r28, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    a186:	48 2f       	mov	r20, r24
    a188:	50 e0       	ldi	r21, 0x00	; 0
    a18a:	6d e3       	ldi	r22, 0x3D	; 61
    a18c:	76 e0       	ldi	r23, 0x06	; 6
    a18e:	89 e3       	ldi	r24, 0x39	; 57
    a190:	9b e0       	ldi	r25, 0x0B	; 11
    a192:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    a196:	c0 93 43 09 	sts	0x0943, r28
}
    a19a:	cf 91       	pop	r28
    a19c:	08 95       	ret

0000a19e <GPRS_ReadParamReply>:
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    a19e:	1f 93       	push	r17
    a1a0:	cf 93       	push	r28
    a1a2:	df 93       	push	r29
    a1a4:	00 d0       	rcall	.+0      	; 0xa1a6 <GPRS_ReadParamReply+0x8>
    a1a6:	cd b7       	in	r28, 0x3d	; 61
    a1a8:	de b7       	in	r29, 0x3e	; 62
    a1aa:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a1ac:	85 e0       	ldi	r24, 0x05	; 5
    a1ae:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a1b2:	81 e0       	ldi	r24, 0x01	; 1
    a1b4:	80 93 3e 06 	sts	0x063E, r24
    a1b8:	8c e0       	ldi	r24, 0x0C	; 12
    a1ba:	91 e0       	ldi	r25, 0x01	; 1
    a1bc:	4a 83       	std	Y+2, r20	; 0x02
    a1be:	69 83       	std	Y+1, r22	; 0x01
    a1c0:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a1c4:	90 93 3f 06 	sts	0x063F, r25
    a1c8:	8c e0       	ldi	r24, 0x0C	; 12
    a1ca:	91 e0       	ldi	r25, 0x01	; 1
    a1cc:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a1d0:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a1d4:	83 e0       	ldi	r24, 0x03	; 3
    a1d6:	80 93 41 06 	sts	0x0641, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    a1da:	4a 81       	ldd	r20, Y+2	; 0x02
    a1dc:	4d 5f       	subi	r20, 0xFD	; 253
    a1de:	40 93 42 06 	sts	0x0642, r20
	GPRS_ChangeData[6] = 7;
    a1e2:	87 e0       	ldi	r24, 0x07	; 7
    a1e4:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a1e8:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;
    a1ec:	69 81       	ldd	r22, Y+1	; 0x01
    a1ee:	60 93 45 06 	sts	0x0645, r22
}
    a1f2:	0f 90       	pop	r0
    a1f4:	0f 90       	pop	r0
    a1f6:	df 91       	pop	r29
    a1f8:	cf 91       	pop	r28
    a1fa:	1f 91       	pop	r17
    a1fc:	08 95       	ret

0000a1fe <GPRS_WriteParamReply>:
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    a1fe:	1f 93       	push	r17
    a200:	cf 93       	push	r28
    a202:	df 93       	push	r29
    a204:	1f 92       	push	r1
    a206:	cd b7       	in	r28, 0x3d	; 61
    a208:	de b7       	in	r29, 0x3e	; 62
    a20a:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a20c:	85 e0       	ldi	r24, 0x05	; 5
    a20e:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a212:	81 e0       	ldi	r24, 0x01	; 1
    a214:	80 93 3e 06 	sts	0x063E, r24
    a218:	8c e0       	ldi	r24, 0x0C	; 12
    a21a:	91 e0       	ldi	r25, 0x01	; 1
    a21c:	69 83       	std	Y+1, r22	; 0x01
    a21e:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a222:	90 93 3f 06 	sts	0x063F, r25
    a226:	8c e0       	ldi	r24, 0x0C	; 12
    a228:	91 e0       	ldi	r25, 0x01	; 1
    a22a:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a22e:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a232:	93 e0       	ldi	r25, 0x03	; 3
    a234:	90 93 41 06 	sts	0x0641, r25
	GPRS_ChangeData[5] = 3;	// -       
    a238:	90 93 42 06 	sts	0x0642, r25
	GPRS_ChangeData[6] = 8;
    a23c:	88 e0       	ldi	r24, 0x08	; 8
    a23e:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a242:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;	
    a246:	69 81       	ldd	r22, Y+1	; 0x01
    a248:	60 93 45 06 	sts	0x0645, r22
}
    a24c:	0f 90       	pop	r0
    a24e:	df 91       	pop	r29
    a250:	cf 91       	pop	r28
    a252:	1f 91       	pop	r17
    a254:	08 95       	ret

0000a256 <GPRS_Param>:

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    a256:	cf 92       	push	r12
    a258:	ef 92       	push	r14
    a25a:	0f 93       	push	r16
    a25c:	1f 93       	push	r17
    a25e:	cf 93       	push	r28
    a260:	df 93       	push	r29
    a262:	d8 2f       	mov	r29, r24
    a264:	16 2f       	mov	r17, r22
    a266:	ca 01       	movw	r24, r20
    a268:	c2 2f       	mov	r28, r18
	if(Cmd==READ_PARAM ){
    a26a:	01 3c       	cpi	r16, 0xC1	; 193
    a26c:	b9 f4       	brne	.+46     	; 0xa29c <GPRS_Param+0x46>
		if(MemCopy){
    a26e:	ee 20       	and	r14, r14
    a270:	61 f0       	breq	.+24     	; 0xa28a <GPRS_Param+0x34>
    a272:	42 2f       	mov	r20, r18
    a274:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    a276:	bc 01       	movw	r22, r24
    a278:	86 e4       	ldi	r24, 0x46	; 70
    a27a:	96 e0       	ldi	r25, 0x06	; 6
    a27c:	cc 20       	and	r12, r12
    a27e:	19 f0       	breq	.+6      	; 0xa286 <GPRS_Param+0x30>
    a280:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
    a284:	02 c0       	rjmp	.+4      	; 0xa28a <GPRS_Param+0x34>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a286:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    a28a:	4c 2f       	mov	r20, r28
    a28c:	61 2f       	mov	r22, r17
    a28e:	8d 2f       	mov	r24, r29
    a290:	0e 94 cf 50 	call	0xa19e	; 0xa19e <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    a294:	c7 5f       	subi	r28, 0xF7	; 247
    a296:	c0 93 11 06 	sts	0x0611, r28
    a29a:	19 c0       	rjmp	.+50     	; 0xa2ce <GPRS_Param+0x78>
	}
	if(Cmd==WRITE_PARAM){
    a29c:	0c 34       	cpi	r16, 0x4C	; 76
    a29e:	b9 f4       	brne	.+46     	; 0xa2ce <GPRS_Param+0x78>
		if(MemCopy){
    a2a0:	ee 20       	and	r14, r14
    a2a2:	71 f0       	breq	.+28     	; 0xa2c0 <GPRS_Param+0x6a>
    a2a4:	42 2f       	mov	r20, r18
    a2a6:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    a2a8:	cc 20       	and	r12, r12
    a2aa:	29 f0       	breq	.+10     	; 0xa2b6 <GPRS_Param+0x60>
    a2ac:	68 e4       	ldi	r22, 0x48	; 72
    a2ae:	78 e0       	ldi	r23, 0x08	; 8
    a2b0:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
    a2b4:	05 c0       	rjmp	.+10     	; 0xa2c0 <GPRS_Param+0x6a>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    a2b6:	bc 01       	movw	r22, r24
    a2b8:	88 e4       	ldi	r24, 0x48	; 72
    a2ba:	98 e0       	ldi	r25, 0x08	; 8
    a2bc:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    a2c0:	61 2f       	mov	r22, r17
    a2c2:	8d 2f       	mov	r24, r29
    a2c4:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    a2c8:	89 e0       	ldi	r24, 0x09	; 9
    a2ca:	80 93 11 06 	sts	0x0611, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a2ce:	80 91 5c 09 	lds	r24, 0x095C
    a2d2:	88 60       	ori	r24, 0x08	; 8
    a2d4:	80 93 5c 09 	sts	0x095C, r24
}
    a2d8:	df 91       	pop	r29
    a2da:	cf 91       	pop	r28
    a2dc:	1f 91       	pop	r17
    a2de:	0f 91       	pop	r16
    a2e0:	ef 90       	pop	r14
    a2e2:	cf 90       	pop	r12
    a2e4:	08 95       	ret

0000a2e6 <GPRS_CriticalCMD_Process>:

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    a2e6:	80 91 e3 03 	lds	r24, 0x03E3
    a2ea:	88 23       	and	r24, r24
    a2ec:	f9 f0       	breq	.+62     	; 0xa32c <GPRS_CriticalCMD_Process+0x46>
    a2ee:	80 91 0c 0b 	lds	r24, 0x0B0C
    a2f2:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    a2f6:	88 23       	and	r24, r24
    a2f8:	c9 f0       	breq	.+50     	; 0xa32c <GPRS_CriticalCMD_Process+0x46>
		switch(GPRS_CriticalCMD){
    a2fa:	80 91 e3 03 	lds	r24, 0x03E3
    a2fe:	82 30       	cpi	r24, 0x02	; 2
    a300:	69 f0       	breq	.+26     	; 0xa31c <GPRS_CriticalCMD_Process+0x36>
    a302:	20 f4       	brcc	.+8      	; 0xa30c <GPRS_CriticalCMD_Process+0x26>
    a304:	81 30       	cpi	r24, 0x01	; 1
    a306:	81 f4       	brne	.+32     	; 0xa328 <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    a308:	f8 94       	cli
    a30a:	07 c0       	rjmp	.+14     	; 0xa31a <GPRS_CriticalCMD_Process+0x34>
    a30c:	83 30       	cpi	r24, 0x03	; 3
    a30e:	51 f0       	breq	.+20     	; 0xa324 <GPRS_CriticalCMD_Process+0x3e>
    a310:	84 30       	cpi	r24, 0x04	; 4
    a312:	51 f4       	brne	.+20     	; 0xa328 <GPRS_CriticalCMD_Process+0x42>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
			case GPRS_UPDATER:		Start_Updater(); break;
    a314:	0e 94 f5 28 	call	0x51ea	; 0x51ea <Start_Updater>
    a318:	07 c0       	rjmp	.+14     	; 0xa328 <GPRS_CriticalCMD_Process+0x42>
    a31a:	ff cf       	rjmp	.-2      	; 0xa31a <GPRS_CriticalCMD_Process+0x34>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    a31c:	88 e5       	ldi	r24, 0x58	; 88
    a31e:	80 93 27 06 	sts	0x0627, r24
    a322:	02 c0       	rjmp	.+4      	; 0xa328 <GPRS_CriticalCMD_Process+0x42>
void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
		switch(GPRS_CriticalCMD){
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    a324:	0e 94 c2 29 	call	0x5384	; 0x5384 <Start_Bootloader>
			case GPRS_UPDATER:		Start_Updater(); break;
		}
		GPRS_CriticalCMD = 0;
    a328:	10 92 e3 03 	sts	0x03E3, r1
    a32c:	08 95       	ret

0000a32e <GPRS_Param00>:
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    a32e:	cf 92       	push	r12
    a330:	ef 92       	push	r14
    a332:	0f 93       	push	r16
    a334:	cf 93       	push	r28
    a336:	c8 2f       	mov	r28, r24
    a338:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    a33a:	84 30       	cpi	r24, 0x04	; 4
    a33c:	61 f1       	breq	.+88     	; 0xa396 <GPRS_Param00+0x68>
    a33e:	28 f4       	brcc	.+10     	; 0xa34a <GPRS_Param00+0x1c>
    a340:	81 30       	cpi	r24, 0x01	; 1
    a342:	49 f0       	breq	.+18     	; 0xa356 <GPRS_Param00+0x28>
    a344:	82 30       	cpi	r24, 0x02	; 2
    a346:	89 f0       	breq	.+34     	; 0xa36a <GPRS_Param00+0x3c>
    a348:	50 c0       	rjmp	.+160    	; 0xa3ea <GPRS_Param00+0xbc>
    a34a:	86 30       	cpi	r24, 0x06	; 6
    a34c:	a1 f1       	breq	.+104    	; 0xa3b6 <GPRS_Param00+0x88>
    a34e:	58 f1       	brcs	.+86     	; 0xa3a6 <GPRS_Param00+0x78>
    a350:	87 30       	cpi	r24, 0x07	; 7
    a352:	c9 f1       	breq	.+114    	; 0xa3c6 <GPRS_Param00+0x98>
    a354:	4a c0       	rjmp	.+148    	; 0xa3ea <GPRS_Param00+0xbc>
		case 1:	if(Cmd==READ_PARAM){
    a356:	61 3c       	cpi	r22, 0xC1	; 193
    a358:	09 f0       	breq	.+2      	; 0xa35c <GPRS_Param00+0x2e>
    a35a:	47 c0       	rjmp	.+142    	; 0xa3ea <GPRS_Param00+0xbc>
					GPRS_ChangeData[9] = SW_VERSION;
    a35c:	83 e0       	ldi	r24, 0x03	; 3
    a35e:	80 93 46 06 	sts	0x0646, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    a362:	87 e0       	ldi	r24, 0x07	; 7
    a364:	80 93 47 06 	sts	0x0647, r24
    a368:	3e c0       	rjmp	.+124    	; 0xa3e6 <GPRS_Param00+0xb8>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    a36a:	61 3c       	cpi	r22, 0xC1	; 193
    a36c:	49 f4       	brne	.+18     	; 0xa380 <GPRS_Param00+0x52>
    a36e:	42 e0       	ldi	r20, 0x02	; 2
    a370:	50 e0       	ldi	r21, 0x00	; 0
    a372:	6c e0       	ldi	r22, 0x0C	; 12
    a374:	71 e0       	ldi	r23, 0x01	; 1
    a376:	86 e4       	ldi	r24, 0x46	; 70
    a378:	96 e0       	ldi	r25, 0x06	; 6
    a37a:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a37e:	33 c0       	rjmp	.+102    	; 0xa3e6 <GPRS_Param00+0xb8>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    a380:	6c 34       	cpi	r22, 0x4C	; 76
    a382:	89 f5       	brne	.+98     	; 0xa3e6 <GPRS_Param00+0xb8>
    a384:	42 e0       	ldi	r20, 0x02	; 2
    a386:	50 e0       	ldi	r21, 0x00	; 0
    a388:	6c e0       	ldi	r22, 0x0C	; 12
    a38a:	71 e0       	ldi	r23, 0x01	; 1
    a38c:	88 e4       	ldi	r24, 0x48	; 72
    a38e:	98 e0       	ldi	r25, 0x08	; 8
    a390:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
    a394:	28 c0       	rjmp	.+80     	; 0xa3e6 <GPRS_Param00+0xb8>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    a396:	6c 34       	cpi	r22, 0x4C	; 76
    a398:	41 f5       	brne	.+80     	; 0xa3ea <GPRS_Param00+0xbc>
    a39a:	80 91 48 08 	lds	r24, 0x0848
    a39e:	88 23       	and	r24, r24
    a3a0:	21 f1       	breq	.+72     	; 0xa3ea <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    a3a2:	81 e0       	ldi	r24, 0x01	; 1
    a3a4:	17 c0       	rjmp	.+46     	; 0xa3d4 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3a6:	6c 34       	cpi	r22, 0x4C	; 76
    a3a8:	01 f5       	brne	.+64     	; 0xa3ea <GPRS_Param00+0xbc>
    a3aa:	80 91 48 08 	lds	r24, 0x0848
    a3ae:	88 23       	and	r24, r24
    a3b0:	e1 f0       	breq	.+56     	; 0xa3ea <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    a3b2:	82 e0       	ldi	r24, 0x02	; 2
    a3b4:	0f c0       	rjmp	.+30     	; 0xa3d4 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3b6:	6c 34       	cpi	r22, 0x4C	; 76
    a3b8:	c1 f4       	brne	.+48     	; 0xa3ea <GPRS_Param00+0xbc>
    a3ba:	80 91 48 08 	lds	r24, 0x0848
    a3be:	88 23       	and	r24, r24
    a3c0:	a1 f0       	breq	.+40     	; 0xa3ea <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    a3c2:	83 e0       	ldi	r24, 0x03	; 3
    a3c4:	07 c0       	rjmp	.+14     	; 0xa3d4 <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3c6:	6c 34       	cpi	r22, 0x4C	; 76
    a3c8:	81 f4       	brne	.+32     	; 0xa3ea <GPRS_Param00+0xbc>
    a3ca:	80 91 48 08 	lds	r24, 0x0848
    a3ce:	88 23       	and	r24, r24
    a3d0:	61 f0       	breq	.+24     	; 0xa3ea <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    a3d2:	84 e0       	ldi	r24, 0x04	; 4
    a3d4:	80 93 e3 03 	sts	0x03E3, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    a3d8:	60 e9       	ldi	r22, 0x90	; 144
    a3da:	71 e0       	ldi	r23, 0x01	; 1
    a3dc:	80 91 0c 0b 	lds	r24, 0x0B0C
    a3e0:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    a3e4:	02 c0       	rjmp	.+4      	; 0xa3ea <GPRS_Param00+0xbc>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
				param_size = sizeof(Vega_SN);
    a3e6:	22 e0       	ldi	r18, 0x02	; 2
    a3e8:	01 c0       	rjmp	.+2      	; 0xa3ec <GPRS_Param00+0xbe>
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
	uint8_t param_size = 0;
    a3ea:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a3ec:	c1 2c       	mov	r12, r1
    a3ee:	e1 2c       	mov	r14, r1
    a3f0:	40 e0       	ldi	r20, 0x00	; 0
    a3f2:	50 e0       	ldi	r21, 0x00	; 0
    a3f4:	6c 2f       	mov	r22, r28
    a3f6:	80 e0       	ldi	r24, 0x00	; 0
    a3f8:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a3fc:	cf 91       	pop	r28
    a3fe:	0f 91       	pop	r16
    a400:	ef 90       	pop	r14
    a402:	cf 90       	pop	r12
    a404:	08 95       	ret

0000a406 <GPRS_Param01>:
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a406:	cf 92       	push	r12
    a408:	ef 92       	push	r14
    a40a:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a40c:	c1 2c       	mov	r12, r1
    a40e:	e1 2c       	mov	r14, r1
    a410:	06 2f       	mov	r16, r22
    a412:	20 e0       	ldi	r18, 0x00	; 0
    a414:	40 e0       	ldi	r20, 0x00	; 0
    a416:	50 e0       	ldi	r21, 0x00	; 0
    a418:	68 2f       	mov	r22, r24
    a41a:	81 e0       	ldi	r24, 0x01	; 1
    a41c:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a420:	0f 91       	pop	r16
    a422:	ef 90       	pop	r14
    a424:	cf 90       	pop	r12
    a426:	08 95       	ret

0000a428 <GPRS_Param02>:
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a428:	cf 92       	push	r12
    a42a:	ef 92       	push	r14
    a42c:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    a42e:	c1 2c       	mov	r12, r1
    a430:	e1 2c       	mov	r14, r1
    a432:	06 2f       	mov	r16, r22
    a434:	21 e0       	ldi	r18, 0x01	; 1
    a436:	40 e0       	ldi	r20, 0x00	; 0
    a438:	50 e0       	ldi	r21, 0x00	; 0
    a43a:	68 2f       	mov	r22, r24
    a43c:	82 e0       	ldi	r24, 0x02	; 2
    a43e:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a442:	0f 91       	pop	r16
    a444:	ef 90       	pop	r14
    a446:	cf 90       	pop	r12
    a448:	08 95       	ret

0000a44a <GPRS_Param03>:
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a44a:	cf 92       	push	r12
    a44c:	ef 92       	push	r14
    a44e:	0f 93       	push	r16
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a450:	c1 2c       	mov	r12, r1
    a452:	ee 24       	eor	r14, r14
    a454:	e3 94       	inc	r14
    a456:	06 2f       	mov	r16, r22
    a458:	20 e0       	ldi	r18, 0x00	; 0
    a45a:	40 e0       	ldi	r20, 0x00	; 0
    a45c:	50 e0       	ldi	r21, 0x00	; 0
    a45e:	68 2f       	mov	r22, r24
    a460:	83 e0       	ldi	r24, 0x03	; 3
    a462:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a466:	0f 91       	pop	r16
    a468:	ef 90       	pop	r14
    a46a:	cf 90       	pop	r12
    a46c:	08 95       	ret

0000a46e <GPRS_Param04>:

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a46e:	cf 92       	push	r12
    a470:	ef 92       	push	r14
    a472:	0f 93       	push	r16
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a474:	c1 2c       	mov	r12, r1
    a476:	ee 24       	eor	r14, r14
    a478:	e3 94       	inc	r14
    a47a:	06 2f       	mov	r16, r22
    a47c:	20 e0       	ldi	r18, 0x00	; 0
    a47e:	40 e0       	ldi	r20, 0x00	; 0
    a480:	50 e0       	ldi	r21, 0x00	; 0
    a482:	68 2f       	mov	r22, r24
    a484:	84 e0       	ldi	r24, 0x04	; 4
    a486:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a48a:	0f 91       	pop	r16
    a48c:	ef 90       	pop	r14
    a48e:	cf 90       	pop	r12
    a490:	08 95       	ret

0000a492 <GPRS_Param05>:

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a492:	cf 92       	push	r12
    a494:	ef 92       	push	r14
    a496:	0f 93       	push	r16
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a498:	c1 2c       	mov	r12, r1
    a49a:	ee 24       	eor	r14, r14
    a49c:	e3 94       	inc	r14
    a49e:	06 2f       	mov	r16, r22
    a4a0:	20 e0       	ldi	r18, 0x00	; 0
    a4a2:	40 e0       	ldi	r20, 0x00	; 0
    a4a4:	50 e0       	ldi	r21, 0x00	; 0
    a4a6:	68 2f       	mov	r22, r24
    a4a8:	85 e0       	ldi	r24, 0x05	; 5
    a4aa:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a4ae:	0f 91       	pop	r16
    a4b0:	ef 90       	pop	r14
    a4b2:	cf 90       	pop	r12
    a4b4:	08 95       	ret

0000a4b6 <GPRS_Param06>:

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4b6:	cf 92       	push	r12
    a4b8:	ef 92       	push	r14
    a4ba:	0f 93       	push	r16
    a4bc:	2f ef       	ldi	r18, 0xFF	; 255
    a4be:	28 0f       	add	r18, r24
    a4c0:	27 30       	cpi	r18, 0x07	; 7
    a4c2:	68 f4       	brcc	.+26     	; 0xa4de <GPRS_Param06+0x28>
    a4c4:	30 e0       	ldi	r19, 0x00	; 0
    a4c6:	f9 01       	movw	r30, r18
    a4c8:	ee 0f       	add	r30, r30
    a4ca:	ff 1f       	adc	r31, r31
    a4cc:	e4 51       	subi	r30, 0x14	; 20
    a4ce:	fe 4f       	sbci	r31, 0xFE	; 254
    a4d0:	40 81       	ld	r20, Z
    a4d2:	51 81       	ldd	r21, Z+1	; 0x01
    a4d4:	f9 01       	movw	r30, r18
    a4d6:	eb 51       	subi	r30, 0x1B	; 27
    a4d8:	fe 4f       	sbci	r31, 0xFE	; 254
    a4da:	20 81       	ld	r18, Z
    a4dc:	03 c0       	rjmp	.+6      	; 0xa4e4 <GPRS_Param06+0x2e>
    a4de:	20 e0       	ldi	r18, 0x00	; 0
    a4e0:	40 e0       	ldi	r20, 0x00	; 0
    a4e2:	50 e0       	ldi	r21, 0x00	; 0
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a4e4:	c1 2c       	mov	r12, r1
    a4e6:	ee 24       	eor	r14, r14
    a4e8:	e3 94       	inc	r14
    a4ea:	06 2f       	mov	r16, r22
    a4ec:	68 2f       	mov	r22, r24
    a4ee:	86 e0       	ldi	r24, 0x06	; 6
    a4f0:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a4f4:	0f 91       	pop	r16
    a4f6:	ef 90       	pop	r14
    a4f8:	cf 90       	pop	r12
    a4fa:	08 95       	ret

0000a4fc <GPRS_Param07>:
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4fc:	cf 92       	push	r12
    a4fe:	ef 92       	push	r14
    a500:	0f 93       	push	r16
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a502:	c1 2c       	mov	r12, r1
    a504:	ee 24       	eor	r14, r14
    a506:	e3 94       	inc	r14
    a508:	06 2f       	mov	r16, r22
    a50a:	20 e0       	ldi	r18, 0x00	; 0
    a50c:	40 e0       	ldi	r20, 0x00	; 0
    a50e:	50 e0       	ldi	r21, 0x00	; 0
    a510:	68 2f       	mov	r22, r24
    a512:	87 e0       	ldi	r24, 0x07	; 7
    a514:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a518:	0f 91       	pop	r16
    a51a:	ef 90       	pop	r14
    a51c:	cf 90       	pop	r12
    a51e:	08 95       	ret

0000a520 <GPRS_Param08>:

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a520:	cf 92       	push	r12
    a522:	ef 92       	push	r14
    a524:	0f 93       	push	r16
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    a526:	c1 2c       	mov	r12, r1
    a528:	ee 24       	eor	r14, r14
    a52a:	e3 94       	inc	r14
    a52c:	06 2f       	mov	r16, r22
    a52e:	20 e0       	ldi	r18, 0x00	; 0
    a530:	40 e0       	ldi	r20, 0x00	; 0
    a532:	50 e0       	ldi	r21, 0x00	; 0
    a534:	68 2f       	mov	r22, r24
    a536:	88 e0       	ldi	r24, 0x08	; 8
    a538:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a53c:	0f 91       	pop	r16
    a53e:	ef 90       	pop	r14
    a540:	cf 90       	pop	r12
    a542:	08 95       	ret

0000a544 <GPRS_Param09>:

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a544:	cf 92       	push	r12
    a546:	ef 92       	push	r14
    a548:	0f 93       	push	r16
    a54a:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a54c:	48 2f       	mov	r20, r24
    a54e:	50 e0       	ldi	r21, 0x00	; 0
    a550:	fa 01       	movw	r30, r20
    a552:	31 97       	sbiw	r30, 0x01	; 1
    a554:	e6 31       	cpi	r30, 0x16	; 22
    a556:	f1 05       	cpc	r31, r1
    a558:	08 f0       	brcs	.+2      	; 0xa55c <GPRS_Param09+0x18>
    a55a:	78 c0       	rjmp	.+240    	; 0xa64c <GPRS_Param09+0x108>
    a55c:	e2 55       	subi	r30, 0x52	; 82
    a55e:	ff 4f       	sbci	r31, 0xFF	; 255
    a560:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
    a564:	23 e1       	ldi	r18, 0x13	; 19
    a566:	44 e5       	ldi	r20, 0x54	; 84
    a568:	51 e0       	ldi	r21, 0x01	; 1
    a56a:	7b c0       	rjmp	.+246    	; 0xa662 <GPRS_Param09+0x11e>
void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:
			if(Cmd==READ_PARAM){
    a56c:	61 3c       	cpi	r22, 0xC1	; 193
    a56e:	91 f4       	brne	.+36     	; 0xa594 <GPRS_Param09+0x50>
    a570:	4f e0       	ldi	r20, 0x0F	; 15
    a572:	50 e0       	ldi	r21, 0x00	; 0
    a574:	6c e7       	ldi	r22, 0x7C	; 124
    a576:	71 e0       	ldi	r23, 0x01	; 1
    a578:	86 e4       	ldi	r24, 0x46	; 70
    a57a:	96 e0       	ldi	r25, 0x06	; 6
    a57c:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a580:	4f e0       	ldi	r20, 0x0F	; 15
    a582:	50 e0       	ldi	r21, 0x00	; 0
    a584:	6a e9       	ldi	r22, 0x9A	; 154
    a586:	71 e0       	ldi	r23, 0x01	; 1
    a588:	85 e5       	ldi	r24, 0x55	; 85
    a58a:	96 e0       	ldi	r25, 0x06	; 6
    a58c:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
    a590:	2e e1       	ldi	r18, 0x1E	; 30
    a592:	5f c0       	rjmp	.+190    	; 0xa652 <GPRS_Param09+0x10e>
			}
			if(Cmd==WRITE_PARAM){
    a594:	6c 34       	cpi	r22, 0x4C	; 76
    a596:	09 f0       	breq	.+2      	; 0xa59a <GPRS_Param09+0x56>
    a598:	6f c0       	rjmp	.+222    	; 0xa678 <GPRS_Param09+0x134>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    a59a:	4f e0       	ldi	r20, 0x0F	; 15
    a59c:	50 e0       	ldi	r21, 0x00	; 0
    a59e:	6c e7       	ldi	r22, 0x7C	; 124
    a5a0:	71 e0       	ldi	r23, 0x01	; 1
    a5a2:	88 e4       	ldi	r24, 0x48	; 72
    a5a4:	98 e0       	ldi	r25, 0x08	; 8
    a5a6:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    a5aa:	4f e0       	ldi	r20, 0x0F	; 15
    a5ac:	50 e0       	ldi	r21, 0x00	; 0
    a5ae:	6e e3       	ldi	r22, 0x3E	; 62
    a5b0:	73 e0       	ldi	r23, 0x03	; 3
    a5b2:	87 e5       	ldi	r24, 0x57	; 87
    a5b4:	98 e0       	ldi	r25, 0x08	; 8
    a5b6:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
    a5ba:	5e c0       	rjmp	.+188    	; 0xa678 <GPRS_Param09+0x134>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    a5bc:	24 e0       	ldi	r18, 0x04	; 4
    a5be:	46 e4       	ldi	r20, 0x46	; 70
    a5c0:	51 e0       	ldi	r21, 0x01	; 1
    a5c2:	4f c0       	rjmp	.+158    	; 0xa662 <GPRS_Param09+0x11e>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    a5c4:	24 e0       	ldi	r18, 0x04	; 4
    a5c6:	4a e4       	ldi	r20, 0x4A	; 74
    a5c8:	51 e0       	ldi	r21, 0x01	; 1
    a5ca:	4b c0       	rjmp	.+150    	; 0xa662 <GPRS_Param09+0x11e>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    a5cc:	24 e0       	ldi	r18, 0x04	; 4
    a5ce:	4e e4       	ldi	r20, 0x4E	; 78
    a5d0:	51 e0       	ldi	r21, 0x01	; 1
    a5d2:	47 c0       	rjmp	.+142    	; 0xa662 <GPRS_Param09+0x11e>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    a5d4:	22 e0       	ldi	r18, 0x02	; 2
    a5d6:	4a e2       	ldi	r20, 0x2A	; 42
    a5d8:	51 e0       	ldi	r21, 0x01	; 1
    a5da:	43 c0       	rjmp	.+134    	; 0xa662 <GPRS_Param09+0x11e>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    a5dc:	22 e0       	ldi	r18, 0x02	; 2
    a5de:	4c e2       	ldi	r20, 0x2C	; 44
    a5e0:	51 e0       	ldi	r21, 0x01	; 1
    a5e2:	3f c0       	rjmp	.+126    	; 0xa662 <GPRS_Param09+0x11e>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    a5e4:	22 e0       	ldi	r18, 0x02	; 2
    a5e6:	4e e2       	ldi	r20, 0x2E	; 46
    a5e8:	51 e0       	ldi	r21, 0x01	; 1
    a5ea:	3b c0       	rjmp	.+118    	; 0xa662 <GPRS_Param09+0x11e>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    a5ec:	22 e0       	ldi	r18, 0x02	; 2
    a5ee:	40 e3       	ldi	r20, 0x30	; 48
    a5f0:	51 e0       	ldi	r21, 0x01	; 1
    a5f2:	37 c0       	rjmp	.+110    	; 0xa662 <GPRS_Param09+0x11e>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    a5f4:	24 e0       	ldi	r18, 0x04	; 4
    a5f6:	40 e1       	ldi	r20, 0x10	; 16
    a5f8:	51 e0       	ldi	r21, 0x01	; 1
    a5fa:	33 c0       	rjmp	.+102    	; 0xa662 <GPRS_Param09+0x11e>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    a5fc:	24 e0       	ldi	r18, 0x04	; 4
    a5fe:	44 e1       	ldi	r20, 0x14	; 20
    a600:	51 e0       	ldi	r21, 0x01	; 1
    a602:	2f c0       	rjmp	.+94     	; 0xa662 <GPRS_Param09+0x11e>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    a604:	24 e0       	ldi	r18, 0x04	; 4
    a606:	48 e1       	ldi	r20, 0x18	; 24
    a608:	51 e0       	ldi	r21, 0x01	; 1
    a60a:	2b c0       	rjmp	.+86     	; 0xa662 <GPRS_Param09+0x11e>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    a60c:	24 e0       	ldi	r18, 0x04	; 4
    a60e:	4c e1       	ldi	r20, 0x1C	; 28
    a610:	51 e0       	ldi	r21, 0x01	; 1
    a612:	27 c0       	rjmp	.+78     	; 0xa662 <GPRS_Param09+0x11e>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    a614:	22 e0       	ldi	r18, 0x02	; 2
    a616:	40 e2       	ldi	r20, 0x20	; 32
    a618:	51 e0       	ldi	r21, 0x01	; 1
    a61a:	23 c0       	rjmp	.+70     	; 0xa662 <GPRS_Param09+0x11e>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    a61c:	22 e0       	ldi	r18, 0x02	; 2
    a61e:	4e e0       	ldi	r20, 0x0E	; 14
    a620:	51 e0       	ldi	r21, 0x01	; 1
    a622:	1f c0       	rjmp	.+62     	; 0xa662 <GPRS_Param09+0x11e>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    a624:	21 e0       	ldi	r18, 0x01	; 1
    a626:	40 e6       	ldi	r20, 0x60	; 96
    a628:	50 e0       	ldi	r21, 0x00	; 0
    a62a:	1b c0       	rjmp	.+54     	; 0xa662 <GPRS_Param09+0x11e>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    a62c:	2c e0       	ldi	r18, 0x0C	; 12
    a62e:	43 ee       	ldi	r20, 0xE3	; 227
    a630:	50 e0       	ldi	r21, 0x00	; 0
    a632:	17 c0       	rjmp	.+46     	; 0xa662 <GPRS_Param09+0x11e>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    a634:	2c e0       	ldi	r18, 0x0C	; 12
    a636:	40 ef       	ldi	r20, 0xF0	; 240
    a638:	50 e0       	ldi	r21, 0x00	; 0
    a63a:	13 c0       	rjmp	.+38     	; 0xa662 <GPRS_Param09+0x11e>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    a63c:	2c e0       	ldi	r18, 0x0C	; 12
    a63e:	4d ef       	ldi	r20, 0xFD	; 253
    a640:	50 e0       	ldi	r21, 0x00	; 0
    a642:	0f c0       	rjmp	.+30     	; 0xa662 <GPRS_Param09+0x11e>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;
    a644:	22 e0       	ldi	r18, 0x02	; 2
    a646:	48 e0       	ldi	r20, 0x08	; 8
    a648:	50 e0       	ldi	r21, 0x00	; 0
    a64a:	0b c0       	rjmp	.+22     	; 0xa662 <GPRS_Param09+0x11e>
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a64c:	20 e0       	ldi	r18, 0x00	; 0
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a64e:	81 30       	cpi	r24, 0x01	; 1
    a650:	31 f4       	brne	.+12     	; 0xa65e <GPRS_Param09+0x11a>
    a652:	c1 2c       	mov	r12, r1
    a654:	e1 2c       	mov	r14, r1
    a656:	40 e0       	ldi	r20, 0x00	; 0
    a658:	50 e0       	ldi	r21, 0x00	; 0
    a65a:	61 e0       	ldi	r22, 0x01	; 1
    a65c:	06 c0       	rjmp	.+12     	; 0xa66a <GPRS_Param09+0x126>
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a65e:	40 e0       	ldi	r20, 0x00	; 0
    a660:	50 e0       	ldi	r21, 0x00	; 0

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a662:	c1 2c       	mov	r12, r1
    a664:	ee 24       	eor	r14, r14
    a666:	e3 94       	inc	r14
    a668:	68 2f       	mov	r22, r24
    a66a:	89 e0       	ldi	r24, 0x09	; 9
    a66c:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a670:	0f 91       	pop	r16
    a672:	ef 90       	pop	r14
    a674:	cf 90       	pop	r12
    a676:	08 95       	ret
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a678:	20 e0       	ldi	r18, 0x00	; 0
    a67a:	eb cf       	rjmp	.-42     	; 0xa652 <GPRS_Param09+0x10e>
			if(Cmd==WRITE_PARAM){
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
    a67c:	23 e1       	ldi	r18, 0x13	; 19
    a67e:	48 e6       	ldi	r20, 0x68	; 104
    a680:	51 e0       	ldi	r21, 0x01	; 1
    a682:	ef cf       	rjmp	.-34     	; 0xa662 <GPRS_Param09+0x11e>
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    a684:	24 e0       	ldi	r18, 0x04	; 4
    a686:	42 e4       	ldi	r20, 0x42	; 66
    a688:	51 e0       	ldi	r21, 0x01	; 1
    a68a:	eb cf       	rjmp	.-42     	; 0xa662 <GPRS_Param09+0x11e>

0000a68c <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a68c:	cf 92       	push	r12
    a68e:	ef 92       	push	r14
    a690:	0f 93       	push	r16
    a692:	ef ef       	ldi	r30, 0xFF	; 255
    a694:	e8 0f       	add	r30, r24
    a696:	e5 30       	cpi	r30, 0x05	; 5
    a698:	48 f4       	brcc	.+18     	; 0xa6ac <GPRS_Param10+0x20>
    a69a:	f0 e0       	ldi	r31, 0x00	; 0
    a69c:	ee 0f       	add	r30, r30
    a69e:	ff 1f       	adc	r31, r31
    a6a0:	e5 52       	subi	r30, 0x25	; 37
    a6a2:	fe 4f       	sbci	r31, 0xFE	; 254
    a6a4:	40 81       	ld	r20, Z
    a6a6:	51 81       	ldd	r21, Z+1	; 0x01
    a6a8:	22 e0       	ldi	r18, 0x02	; 2
    a6aa:	03 c0       	rjmp	.+6      	; 0xa6b2 <GPRS_Param10+0x26>
    a6ac:	20 e0       	ldi	r18, 0x00	; 0
    a6ae:	40 e0       	ldi	r20, 0x00	; 0
    a6b0:	50 e0       	ldi	r21, 0x00	; 0
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6b2:	c1 2c       	mov	r12, r1
    a6b4:	ee 24       	eor	r14, r14
    a6b6:	e3 94       	inc	r14
    a6b8:	06 2f       	mov	r16, r22
    a6ba:	68 2f       	mov	r22, r24
    a6bc:	8a e0       	ldi	r24, 0x0A	; 10
    a6be:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
}
    a6c2:	0f 91       	pop	r16
    a6c4:	ef 90       	pop	r14
    a6c6:	cf 90       	pop	r12
    a6c8:	08 95       	ret

0000a6ca <GPRS_Param11>:
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a6ca:	cf 92       	push	r12
    a6cc:	ef 92       	push	r14
    a6ce:	0f 93       	push	r16
    a6d0:	cf 93       	push	r28
    a6d2:	c8 2f       	mov	r28, r24
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a6d4:	81 30       	cpi	r24, 0x01	; 1
    a6d6:	21 f4       	brne	.+8      	; 0xa6e0 <GPRS_Param11+0x16>
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
    a6d8:	21 e0       	ldi	r18, 0x01	; 1
    a6da:	49 e2       	ldi	r20, 0x29	; 41
    a6dc:	50 e0       	ldi	r21, 0x00	; 0
    a6de:	03 c0       	rjmp	.+6      	; 0xa6e6 <GPRS_Param11+0x1c>
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a6e0:	20 e0       	ldi	r18, 0x00	; 0
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a6e2:	40 e0       	ldi	r20, 0x00	; 0
    a6e4:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6e6:	c1 2c       	mov	r12, r1
    a6e8:	ee 24       	eor	r14, r14
    a6ea:	e3 94       	inc	r14
    a6ec:	06 2f       	mov	r16, r22
    a6ee:	6c 2f       	mov	r22, r28
    a6f0:	8b e0       	ldi	r24, 0x0B	; 11
    a6f2:	0e 94 2b 51 	call	0xa256	; 0xa256 <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a6f6:	c1 30       	cpi	r28, 0x01	; 1
    a6f8:	31 f4       	brne	.+12     	; 0xa706 <GPRS_Param11+0x3c>
#endif
}
    a6fa:	cf 91       	pop	r28
    a6fc:	0f 91       	pop	r16
    a6fe:	ef 90       	pop	r14
    a700:	cf 90       	pop	r12
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a702:	0c 94 ae 4b 	jmp	0x975c	; 0x975c <EMeter_ReInit>
#endif
}
    a706:	cf 91       	pop	r28
    a708:	0f 91       	pop	r16
    a70a:	ef 90       	pop	r14
    a70c:	cf 90       	pop	r12
    a70e:	08 95       	ret

0000a710 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
    a710:	0f 93       	push	r16
    a712:	1f 93       	push	r17
    a714:	08 2f       	mov	r16, r24
    a716:	86 2f       	mov	r24, r22
    a718:	64 2f       	mov	r22, r20
	switch(ParamID_Hi){
    a71a:	10 e0       	ldi	r17, 0x00	; 0
    a71c:	0c 30       	cpi	r16, 0x0C	; 12
    a71e:	11 05       	cpc	r17, r1
    a720:	a8 f5       	brcc	.+106    	; 0xa78c <GPRS_Parameter+0x7c>
    a722:	f8 01       	movw	r30, r16
    a724:	ec 53       	subi	r30, 0x3C	; 60
    a726:	ff 4f       	sbci	r31, 0xFF	; 255
    a728:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a72c:	1f 91       	pop	r17
    a72e:	0f 91       	pop	r16
#endif
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    a730:	0c 94 97 51 	jmp	0xa32e	; 0xa32e <GPRS_Param00>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a734:	1f 91       	pop	r17
    a736:	0f 91       	pop	r16
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    a738:	0c 94 03 52 	jmp	0xa406	; 0xa406 <GPRS_Param01>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a73c:	1f 91       	pop	r17
    a73e:	0f 91       	pop	r16

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    a740:	0c 94 14 52 	jmp	0xa428	; 0xa428 <GPRS_Param02>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a744:	1f 91       	pop	r17
    a746:	0f 91       	pop	r16
void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    a748:	0c 94 25 52 	jmp	0xa44a	; 0xa44a <GPRS_Param03>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a74c:	1f 91       	pop	r17
    a74e:	0f 91       	pop	r16
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    a750:	0c 94 37 52 	jmp	0xa46e	; 0xa46e <GPRS_Param04>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a754:	1f 91       	pop	r17
    a756:	0f 91       	pop	r16
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    a758:	0c 94 49 52 	jmp	0xa492	; 0xa492 <GPRS_Param05>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a75c:	1f 91       	pop	r17
    a75e:	0f 91       	pop	r16
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    a760:	0c 94 5b 52 	jmp	0xa4b6	; 0xa4b6 <GPRS_Param06>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a764:	1f 91       	pop	r17
    a766:	0f 91       	pop	r16
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    a768:	0c 94 7e 52 	jmp	0xa4fc	; 0xa4fc <GPRS_Param07>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a76c:	1f 91       	pop	r17
    a76e:	0f 91       	pop	r16
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    a770:	0c 94 90 52 	jmp	0xa520	; 0xa520 <GPRS_Param08>
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a774:	1f 91       	pop	r17
    a776:	0f 91       	pop	r16
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    a778:	0c 94 a2 52 	jmp	0xa544	; 0xa544 <GPRS_Param09>
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a77c:	1f 91       	pop	r17
    a77e:	0f 91       	pop	r16
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    a780:	0c 94 46 53 	jmp	0xa68c	; 0xa68c <GPRS_Param10>
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a784:	1f 91       	pop	r17
    a786:	0f 91       	pop	r16
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    a788:	0c 94 65 53 	jmp	0xa6ca	; 0xa6ca <GPRS_Param11>
	}
}
    a78c:	1f 91       	pop	r17
    a78e:	0f 91       	pop	r16
    a790:	08 95       	ret

0000a792 <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    a792:	cf 93       	push	r28
    a794:	c8 2f       	mov	r28, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    a796:	82 30       	cpi	r24, 0x02	; 2
    a798:	09 f0       	breq	.+2      	; 0xa79c <ReadParamBlock+0xa>
    a79a:	80 c0       	rjmp	.+256    	; 0xa89c <ReadParamBlock+0x10a>
    a79c:	4f e0       	ldi	r20, 0x0F	; 15
    a79e:	50 e0       	ldi	r21, 0x00	; 0
    a7a0:	6c e7       	ldi	r22, 0x7C	; 124
    a7a2:	71 e0       	ldi	r23, 0x01	; 1
    a7a4:	85 e4       	ldi	r24, 0x45	; 69
    a7a6:	96 e0       	ldi	r25, 0x06	; 6
    a7a8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7ac:	4f e0       	ldi	r20, 0x0F	; 15
    a7ae:	50 e0       	ldi	r21, 0x00	; 0
    a7b0:	6e e3       	ldi	r22, 0x3E	; 62
    a7b2:	73 e0       	ldi	r23, 0x03	; 3
    a7b4:	84 e5       	ldi	r24, 0x54	; 84
    a7b6:	96 e0       	ldi	r25, 0x06	; 6
    a7b8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7bc:	43 e1       	ldi	r20, 0x13	; 19
    a7be:	50 e0       	ldi	r21, 0x00	; 0
    a7c0:	68 e6       	ldi	r22, 0x68	; 104
    a7c2:	71 e0       	ldi	r23, 0x01	; 1
    a7c4:	83 e6       	ldi	r24, 0x63	; 99
    a7c6:	96 e0       	ldi	r25, 0x06	; 6
    a7c8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7cc:	44 e1       	ldi	r20, 0x14	; 20
    a7ce:	50 e0       	ldi	r21, 0x00	; 0
    a7d0:	64 e5       	ldi	r22, 0x54	; 84
    a7d2:	71 e0       	ldi	r23, 0x01	; 1
    a7d4:	86 e7       	ldi	r24, 0x76	; 118
    a7d6:	96 e0       	ldi	r25, 0x06	; 6
    a7d8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7dc:	40 e1       	ldi	r20, 0x10	; 16
    a7de:	50 e0       	ldi	r21, 0x00	; 0
    a7e0:	62 e4       	ldi	r22, 0x42	; 66
    a7e2:	71 e0       	ldi	r23, 0x01	; 1
    a7e4:	89 e8       	ldi	r24, 0x89	; 137
    a7e6:	96 e0       	ldi	r25, 0x06	; 6
    a7e8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7ec:	48 e0       	ldi	r20, 0x08	; 8
    a7ee:	50 e0       	ldi	r21, 0x00	; 0
    a7f0:	6a e2       	ldi	r22, 0x2A	; 42
    a7f2:	71 e0       	ldi	r23, 0x01	; 1
    a7f4:	89 e9       	ldi	r24, 0x99	; 153
    a7f6:	96 e0       	ldi	r25, 0x06	; 6
    a7f8:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a7fc:	40 e1       	ldi	r20, 0x10	; 16
    a7fe:	50 e0       	ldi	r21, 0x00	; 0
    a800:	60 e1       	ldi	r22, 0x10	; 16
    a802:	71 e0       	ldi	r23, 0x01	; 1
    a804:	81 ea       	ldi	r24, 0xA1	; 161
    a806:	96 e0       	ldi	r25, 0x06	; 6
    a808:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a80c:	42 e0       	ldi	r20, 0x02	; 2
    a80e:	50 e0       	ldi	r21, 0x00	; 0
    a810:	60 e2       	ldi	r22, 0x20	; 32
    a812:	71 e0       	ldi	r23, 0x01	; 1
    a814:	81 eb       	ldi	r24, 0xB1	; 177
    a816:	96 e0       	ldi	r25, 0x06	; 6
    a818:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a81c:	42 e0       	ldi	r20, 0x02	; 2
    a81e:	50 e0       	ldi	r21, 0x00	; 0
    a820:	6e e0       	ldi	r22, 0x0E	; 14
    a822:	71 e0       	ldi	r23, 0x01	; 1
    a824:	83 eb       	ldi	r24, 0xB3	; 179
    a826:	96 e0       	ldi	r25, 0x06	; 6
    a828:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a82c:	41 e0       	ldi	r20, 0x01	; 1
    a82e:	50 e0       	ldi	r21, 0x00	; 0
    a830:	60 e6       	ldi	r22, 0x60	; 96
    a832:	70 e0       	ldi	r23, 0x00	; 0
    a834:	85 eb       	ldi	r24, 0xB5	; 181
    a836:	96 e0       	ldi	r25, 0x06	; 6
    a838:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a83c:	4c e0       	ldi	r20, 0x0C	; 12
    a83e:	50 e0       	ldi	r21, 0x00	; 0
    a840:	63 ee       	ldi	r22, 0xE3	; 227
    a842:	70 e0       	ldi	r23, 0x00	; 0
    a844:	86 eb       	ldi	r24, 0xB6	; 182
    a846:	96 e0       	ldi	r25, 0x06	; 6
    a848:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a84c:	4c e0       	ldi	r20, 0x0C	; 12
    a84e:	50 e0       	ldi	r21, 0x00	; 0
    a850:	60 ef       	ldi	r22, 0xF0	; 240
    a852:	70 e0       	ldi	r23, 0x00	; 0
    a854:	82 ec       	ldi	r24, 0xC2	; 194
    a856:	96 e0       	ldi	r25, 0x06	; 6
    a858:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a85c:	4c e0       	ldi	r20, 0x0C	; 12
    a85e:	50 e0       	ldi	r21, 0x00	; 0
    a860:	6d ef       	ldi	r22, 0xFD	; 253
    a862:	70 e0       	ldi	r23, 0x00	; 0
    a864:	8e ec       	ldi	r24, 0xCE	; 206
    a866:	96 e0       	ldi	r25, 0x06	; 6
    a868:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
    a86c:	42 e0       	ldi	r20, 0x02	; 2
    a86e:	50 e0       	ldi	r21, 0x00	; 0
    a870:	68 e0       	ldi	r22, 0x08	; 8
    a872:	70 e0       	ldi	r23, 0x00	; 0
    a874:	8a ed       	ldi	r24, 0xDA	; 218
    a876:	96 e0       	ldi	r25, 0x06	; 6
    a878:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    a87c:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a880:	29 e9       	ldi	r18, 0x99	; 153
    a882:	41 e1       	ldi	r20, 0x11	; 17
    a884:	63 e0       	ldi	r22, 0x03	; 3
    a886:	8d e3       	ldi	r24, 0x3D	; 61
    a888:	96 e0       	ldi	r25, 0x06	; 6
    a88a:	0e 94 09 4d 	call	0x9a12	; 0x9a12 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a88e:	80 91 5c 09 	lds	r24, 0x095C
    a892:	88 60       	ori	r24, 0x08	; 8
    a894:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a898:	8f e9       	ldi	r24, 0x9F	; 159
    a89a:	17 c0       	rjmp	.+46     	; 0xa8ca <ReadParamBlock+0x138>
	}

	if(Block == 3){
    a89c:	83 30       	cpi	r24, 0x03	; 3
    a89e:	c1 f4       	brne	.+48     	; 0xa8d0 <ReadParamBlock+0x13e>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a8a0:	89 e2       	ldi	r24, 0x29	; 41
    a8a2:	90 e0       	ldi	r25, 0x00	; 0
    a8a4:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    a8a8:	80 93 45 06 	sts	0x0645, r24

		GPRS_ChangeData[7] = Block;
    a8ac:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a8b0:	23 e0       	ldi	r18, 0x03	; 3
    a8b2:	41 e1       	ldi	r20, 0x11	; 17
    a8b4:	63 e0       	ldi	r22, 0x03	; 3
    a8b6:	8d e3       	ldi	r24, 0x3D	; 61
    a8b8:	96 e0       	ldi	r25, 0x06	; 6
    a8ba:	0e 94 09 4d 	call	0x9a12	; 0x9a12 <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a8be:	80 91 5c 09 	lds	r24, 0x095C
    a8c2:	88 60       	ori	r24, 0x08	; 8
    a8c4:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a8c8:	89 e0       	ldi	r24, 0x09	; 9
    a8ca:	80 93 11 06 	sts	0x0611, r24
    a8ce:	01 c0       	rjmp	.+2      	; 0xa8d2 <ReadParamBlock+0x140>

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){

	uint8_t blocksize=8;
    a8d0:	88 e0       	ldi	r24, 0x08	; 8
		GPRS_ChangeReplySize = blocksize;
	}

	return blocksize;
	
}
    a8d2:	cf 91       	pop	r28
    a8d4:	08 95       	ret

0000a8d6 <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){
    a8d6:	cf 93       	push	r28

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    a8d8:	c0 91 5e 09 	lds	r28, 0x095E
    a8dc:	cc 23       	and	r28, r28
    a8de:	09 f4       	brne	.+2      	; 0xa8e2 <GPRS_ReciveData+0xc>
    a8e0:	8a c0       	rjmp	.+276    	; 0xa9f6 <GPRS_ReciveData+0x120>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    a8e2:	80 91 3d 08 	lds	r24, 0x083D
    a8e6:	85 30       	cpi	r24, 0x05	; 5
    a8e8:	09 f0       	breq	.+2      	; 0xa8ec <GPRS_ReciveData+0x16>
    a8ea:	85 c0       	rjmp	.+266    	; 0xa9f6 <GPRS_ReciveData+0x120>
    a8ec:	80 91 3e 08 	lds	r24, 0x083E
    a8f0:	81 30       	cpi	r24, 0x01	; 1
    a8f2:	09 f0       	breq	.+2      	; 0xa8f6 <GPRS_ReciveData+0x20>
    a8f4:	80 c0       	rjmp	.+256    	; 0xa9f6 <GPRS_ReciveData+0x120>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
    a8f6:	80 91 3f 08 	lds	r24, 0x083F
    a8fa:	90 e0       	ldi	r25, 0x00	; 0
    a8fc:	98 2f       	mov	r25, r24
    a8fe:	88 27       	eor	r24, r24
    a900:	20 91 40 08 	lds	r18, 0x0840
		if(GPRS_Check_PSW(Psw) == 0){
    a904:	82 0f       	add	r24, r18
    a906:	91 1d       	adc	r25, r1
    a908:	0e 94 38 50 	call	0xa070	; 0xa070 <GPRS_Check_PSW>
    a90c:	81 11       	cpse	r24, r1
    a90e:	06 c0       	rjmp	.+12     	; 0xa91c <GPRS_ReciveData+0x46>
			GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a910:	80 91 69 09 	lds	r24, 0x0969
    a914:	88 60       	ori	r24, 0x08	; 8
    a916:	80 93 69 09 	sts	0x0969, r24
    a91a:	1b c0       	rjmp	.+54     	; 0xa952 <GPRS_ReciveData+0x7c>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    a91c:	80 91 41 08 	lds	r24, 0x0841
    a920:	84 30       	cpi	r24, 0x04	; 4
    a922:	d9 f4       	brne	.+54     	; 0xa95a <GPRS_ReciveData+0x84>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a924:	8c e0       	ldi	r24, 0x0C	; 12
    a926:	91 e0       	ldi	r25, 0x01	; 1
    a928:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    a92c:	20 91 42 08 	lds	r18, 0x0842
    a930:	30 e0       	ldi	r19, 0x00	; 0
    a932:	32 2f       	mov	r19, r18
    a934:	22 27       	eor	r18, r18
    a936:	40 91 43 08 	lds	r20, 0x0843
    a93a:	24 0f       	add	r18, r20
    a93c:	31 1d       	adc	r19, r1
    a93e:	40 91 69 09 	lds	r20, 0x0969
    a942:	82 17       	cp	r24, r18
    a944:	93 07       	cpc	r25, r19
    a946:	11 f4       	brne	.+4      	; 0xa94c <GPRS_ReciveData+0x76>
    a948:	47 7f       	andi	r20, 0xF7	; 247
    a94a:	01 c0       	rjmp	.+2      	; 0xa94e <GPRS_ReciveData+0x78>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a94c:	48 60       	ori	r20, 0x08	; 8
    a94e:	40 93 69 09 	sts	0x0969, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    a952:	80 91 5c 09 	lds	r24, 0x095C
    a956:	80 61       	ori	r24, 0x10	; 16
    a958:	2e c0       	rjmp	.+92     	; 0xa9b6 <GPRS_ReciveData+0xe0>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    a95a:	83 30       	cpi	r24, 0x03	; 3
    a95c:	09 f0       	breq	.+2      	; 0xa960 <GPRS_ReciveData+0x8a>
    a95e:	4b c0       	rjmp	.+150    	; 0xa9f6 <GPRS_ReciveData+0x120>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    a960:	20 91 10 0b 	lds	r18, 0x0B10
    a964:	30 91 11 0b 	lds	r19, 0x0B11
    a968:	21 15       	cp	r18, r1
    a96a:	31 05       	cpc	r19, r1
    a96c:	89 f2       	breq	.-94     	; 0xa910 <GPRS_ReciveData+0x3a>
    a96e:	80 91 42 08 	lds	r24, 0x0842
    a972:	90 e0       	ldi	r25, 0x00	; 0
    a974:	98 2f       	mov	r25, r24
    a976:	88 27       	eor	r24, r24
    a978:	40 91 43 08 	lds	r20, 0x0843
    a97c:	84 0f       	add	r24, r20
    a97e:	91 1d       	adc	r25, r1
    a980:	28 17       	cp	r18, r24
    a982:	39 07       	cpc	r19, r25
    a984:	29 f6       	brne	.-118    	; 0xa910 <GPRS_ReciveData+0x3a>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    a986:	90 91 44 08 	lds	r25, 0x0844
			
			switch(GPRS_Data_In[8]){
    a98a:	80 91 45 08 	lds	r24, 0x0845
    a98e:	88 30       	cpi	r24, 0x08	; 8
    a990:	d9 f0       	breq	.+54     	; 0xa9c8 <GPRS_ReciveData+0xf2>
    a992:	28 f4       	brcc	.+10     	; 0xa99e <GPRS_ReciveData+0xc8>
    a994:	81 30       	cpi	r24, 0x01	; 1
    a996:	41 f0       	breq	.+16     	; 0xa9a8 <GPRS_ReciveData+0xd2>
    a998:	87 30       	cpi	r24, 0x07	; 7
    a99a:	81 f0       	breq	.+32     	; 0xa9bc <GPRS_ReciveData+0xe6>
    a99c:	2c c0       	rjmp	.+88     	; 0xa9f6 <GPRS_ReciveData+0x120>
    a99e:	8a 30       	cpi	r24, 0x0A	; 10
    a9a0:	d9 f0       	breq	.+54     	; 0xa9d8 <GPRS_ReciveData+0x102>
    a9a2:	81 31       	cpi	r24, 0x11	; 17
    a9a4:	01 f1       	breq	.+64     	; 0xa9e6 <GPRS_ReciveData+0x110>
    a9a6:	27 c0       	rjmp	.+78     	; 0xa9f6 <GPRS_ReciveData+0x120>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    a9a8:	91 30       	cpi	r25, 0x01	; 1
    a9aa:	29 f5       	brne	.+74     	; 0xa9f6 <GPRS_ReciveData+0x120>
    a9ac:	c9 30       	cpi	r28, 0x09	; 9
    a9ae:	19 f5       	brne	.+70     	; 0xa9f6 <GPRS_ReciveData+0x120>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    a9b0:	80 91 5c 09 	lds	r24, 0x095C
    a9b4:	82 60       	ori	r24, 0x02	; 2
    a9b6:	80 93 5c 09 	sts	0x095C, r24
    a9ba:	1d c0       	rjmp	.+58     	; 0xa9f6 <GPRS_ReciveData+0x120>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    a9bc:	93 30       	cpi	r25, 0x03	; 3
    a9be:	d9 f4       	brne	.+54     	; 0xa9f6 <GPRS_ReciveData+0x120>
    a9c0:	cb 30       	cpi	r28, 0x0B	; 11
    a9c2:	c9 f4       	brne	.+50     	; 0xa9f6 <GPRS_ReciveData+0x120>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    a9c4:	41 ec       	ldi	r20, 0xC1	; 193
    a9c6:	01 c0       	rjmp	.+2      	; 0xa9ca <GPRS_ReciveData+0xf4>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    a9c8:	4c e4       	ldi	r20, 0x4C	; 76
    a9ca:	60 91 47 08 	lds	r22, 0x0847
    a9ce:	80 91 46 08 	lds	r24, 0x0846
    a9d2:	0e 94 88 53 	call	0xa710	; 0xa710 <GPRS_Parameter>
				break;
    a9d6:	0f c0       	rjmp	.+30     	; 0xa9f6 <GPRS_ReciveData+0x120>
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    a9d8:	92 30       	cpi	r25, 0x02	; 2
    a9da:	69 f4       	brne	.+26     	; 0xa9f6 <GPRS_ReciveData+0x120>
    a9dc:	ca 30       	cpi	r28, 0x0A	; 10
    a9de:	59 f4       	brne	.+22     	; 0xa9f6 <GPRS_ReciveData+0x120>
					GPRS_RemoteDisplayControl();
    a9e0:	0e 94 96 50 	call	0xa12c	; 0xa12c <GPRS_RemoteDisplayControl>
    a9e4:	08 c0       	rjmp	.+16     	; 0xa9f6 <GPRS_ReciveData+0x120>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    a9e6:	92 30       	cpi	r25, 0x02	; 2
    a9e8:	31 f4       	brne	.+12     	; 0xa9f6 <GPRS_ReciveData+0x120>
    a9ea:	ca 30       	cpi	r28, 0x0A	; 10
    a9ec:	21 f4       	brne	.+8      	; 0xa9f6 <GPRS_ReciveData+0x120>
					ReadParamBlock	(GPRS_Data_In[9]);
    a9ee:	80 91 46 08 	lds	r24, 0x0846
    a9f2:	0e 94 c9 53 	call	0xa792	; 0xa792 <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
    a9f6:	10 92 5e 09 	sts	0x095E, r1
	}//   
	else GPRS_FlgSz_In = 0;
}
    a9fa:	cf 91       	pop	r28
    a9fc:	08 95       	ret

0000a9fe <GPRS_Arbitr>:
// -----                  
void GPRS_Arbitr(void){
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    a9fe:	80 91 5c 09 	lds	r24, 0x095C
    aa02:	86 ff       	sbrs	r24, 6
    aa04:	06 c0       	rjmp	.+12     	; 0xaa12 <GPRS_Arbitr+0x14>
		GPRS_SendNewCrash();
    aa06:	0e 94 15 50 	call	0xa02a	; 0xa02a <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    aa0a:	80 91 5c 09 	lds	r24, 0x095C
    aa0e:	8f 7b       	andi	r24, 0xBF	; 191
    aa10:	3d c0       	rjmp	.+122    	; 0xaa8c <GPRS_Arbitr+0x8e>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    aa12:	85 ff       	sbrs	r24, 5
    aa14:	0d c0       	rjmp	.+26     	; 0xaa30 <GPRS_Arbitr+0x32>
		GPRS_SendRepCrash();
    aa16:	0e 94 25 50 	call	0xa04a	; 0xa04a <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    aa1a:	80 91 5c 09 	lds	r24, 0x095C
    aa1e:	8f 7d       	andi	r24, 0xDF	; 223
    aa20:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aa24:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0b11111110;	//   IP1
    aa28:	8e ef       	ldi	r24, 0xFE	; 254
    aa2a:	80 93 6f 08 	sts	0x086F, r24
    aa2e:	34 c0       	rjmp	.+104    	; 0xaa98 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    aa30:	84 ff       	sbrs	r24, 4
    aa32:	06 c0       	rjmp	.+12     	; 0xaa40 <GPRS_Arbitr+0x42>
		GPRS_Get_Session_ID();
    aa34:	0e 94 56 50 	call	0xa0ac	; 0xa0ac <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    aa38:	80 91 5c 09 	lds	r24, 0x095C
    aa3c:	8f 7e       	andi	r24, 0xEF	; 239
    aa3e:	19 c0       	rjmp	.+50     	; 0xaa72 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    aa40:	83 ff       	sbrs	r24, 3
    aa42:	08 c0       	rjmp	.+16     	; 0xaa54 <GPRS_Arbitr+0x56>
		GPRS_SendChange(GPRS_ChangeReplySize);
    aa44:	80 91 11 06 	lds	r24, 0x0611
    aa48:	0e 94 c1 50 	call	0xa182	; 0xa182 <GPRS_SendChange>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    aa4c:	80 91 5c 09 	lds	r24, 0x095C
    aa50:	87 7f       	andi	r24, 0xF7	; 247
    aa52:	0f c0       	rjmp	.+30     	; 0xaa72 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    aa54:	82 ff       	sbrs	r24, 2
    aa56:	06 c0       	rjmp	.+12     	; 0xaa64 <GPRS_Arbitr+0x66>
		GPRS_SendDisplay();
    aa58:	0e 94 a0 50 	call	0xa140	; 0xa140 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    aa5c:	80 91 5c 09 	lds	r24, 0x095C
    aa60:	8b 7f       	andi	r24, 0xFB	; 251
    aa62:	07 c0       	rjmp	.+14     	; 0xaa72 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    aa64:	81 ff       	sbrs	r24, 1
    aa66:	0b c0       	rjmp	.+22     	; 0xaa7e <GPRS_Arbitr+0x80>
		GPRS_CurDataSend();
    aa68:	0e 94 34 4d 	call	0x9a68	; 0x9a68 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    aa6c:	80 91 5c 09 	lds	r24, 0x095C
    aa70:	8d 7f       	andi	r24, 0xFD	; 253
    aa72:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = TCP;
    aa76:	81 e0       	ldi	r24, 0x01	; 1
    aa78:	80 93 7c 09 	sts	0x097C, r24
    aa7c:	0d c0       	rjmp	.+26     	; 0xaa98 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    aa7e:	80 ff       	sbrs	r24, 0
    aa80:	0f c0       	rjmp	.+30     	; 0xaaa0 <GPRS_Arbitr+0xa2>
		GPRS_CurDataSend();
    aa82:	0e 94 34 4d 	call	0x9a68	; 0x9a68 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    aa86:	80 91 5c 09 	lds	r24, 0x095C
    aa8a:	8e 7f       	andi	r24, 0xFE	; 254
    aa8c:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aa90:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0;	//   IP
    aa94:	10 92 6f 08 	sts	0x086F, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    aa98:	80 91 43 09 	lds	r24, 0x0943
    aa9c:	80 93 7b 09 	sts	0x097B, r24
    aaa0:	08 95       	ret

0000aaa2 <GPRS_App>:
		return;
	}
}
// -----   ApplCycle
void GPRS_App(void){
    aaa2:	cf 93       	push	r28
    aaa4:	df 93       	push	r29

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    aaa6:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aaaa:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint16_t Time = Timer16[TimerN];
    aaae:	ec 2f       	mov	r30, r28
    aab0:	f0 e0       	ldi	r31, 0x00	; 0
    aab2:	ee 0f       	add	r30, r30
    aab4:	ff 1f       	adc	r31, r31
    aab6:	ea 5d       	subi	r30, 0xDA	; 218
    aab8:	fc 4f       	sbci	r31, 0xFC	; 252
    aaba:	c0 81       	ld	r28, Z
    aabc:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    aabe:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
    aac2:	c8 3c       	cpi	r28, 0xC8	; 200
    aac4:	d1 05       	cpc	r29, r1
    aac6:	30 f4       	brcc	.+12     	; 0xaad4 <GPRS_App+0x32>
    aac8:	6f ef       	ldi	r22, 0xFF	; 255
    aaca:	7f ef       	ldi	r23, 0xFF	; 255
    aacc:	80 91 4e 09 	lds	r24, 0x094E
    aad0:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    aad4:	80 91 07 01 	lds	r24, 0x0107
    aad8:	8f 3f       	cpi	r24, 0xFF	; 255
    aada:	31 f4       	brne	.+12     	; 0xaae8 <GPRS_App+0x46>
		GPRS_Session_ID = 0;
    aadc:	10 92 11 0b 	sts	0x0B11, r1
    aae0:	10 92 10 0b 	sts	0x0B10, r1
		GPRS_LoginLevel = 0;
    aae4:	10 92 d5 08 	sts	0x08D5, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    aae8:	c0 91 0f 06 	lds	r28, 0x060F

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aaec:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint16_t Time = Timer16[TimerN];
    aaf0:	ec 2f       	mov	r30, r28
    aaf2:	f0 e0       	ldi	r31, 0x00	; 0
    aaf4:	ee 0f       	add	r30, r30
    aaf6:	ff 1f       	adc	r31, r31
    aaf8:	ea 5d       	subi	r30, 0xDA	; 218
    aafa:	fc 4f       	sbci	r31, 0xFC	; 252
    aafc:	c0 81       	ld	r28, Z
    aafe:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    ab00:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
    ab04:	d0 93 00 06 	sts	0x0600, r29
    ab08:	c0 93 ff 05 	sts	0x05FF, r28

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    ab0c:	80 91 69 09 	lds	r24, 0x0969
    ab10:	80 fd       	sbrc	r24, 0
    ab12:	1b c0       	rjmp	.+54     	; 0xab4a <GPRS_App+0xa8>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    ab14:	0e 94 6b 54 	call	0xa8d6	; 0xa8d6 <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    ab18:	80 e0       	ldi	r24, 0x00	; 0
    ab1a:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    ab1e:	88 23       	and	r24, r24
    ab20:	61 f0       	breq	.+24     	; 0xab3a <GPRS_App+0x98>
    ab22:	90 91 69 09 	lds	r25, 0x0969
    ab26:	92 ff       	sbrs	r25, 2
    ab28:	08 c0       	rjmp	.+16     	; 0xab3a <GPRS_App+0x98>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    ab2a:	80 91 5c 09 	lds	r24, 0x095C
    ab2e:	84 60       	ori	r24, 0x04	; 4
    ab30:	80 93 5c 09 	sts	0x095C, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    ab34:	9b 7f       	andi	r25, 0xFB	; 251
    ab36:	90 93 69 09 	sts	0x0969, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    ab3a:	0e 94 50 4f 	call	0x9ea0	; 0x9ea0 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    ab3e:	80 91 43 09 	lds	r24, 0x0943
    ab42:	81 11       	cpse	r24, r1
    ab44:	02 c0       	rjmp	.+4      	; 0xab4a <GPRS_App+0xa8>
    ab46:	0e 94 ff 54 	call	0xa9fe	; 0xa9fe <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
}
    ab4a:	df 91       	pop	r29
    ab4c:	cf 91       	pop	r28
		GPRS_SendData();
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
	}

	GPRS_CriticalCMD_Process();
    ab4e:	0c 94 73 51 	jmp	0xa2e6	; 0xa2e6 <GPRS_CriticalCMD_Process>

0000ab52 <GSMApply>:
}

void 
GSMApply(void){//=====================================================   GSM

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    ab52:	4e e1       	ldi	r20, 0x1E	; 30
    ab54:	50 e0       	ldi	r21, 0x00	; 0
    ab56:	6c e7       	ldi	r22, 0x7C	; 124
    ab58:	71 e0       	ldi	r23, 0x01	; 1
    ab5a:	8e e7       	ldi	r24, 0x7E	; 126
    ab5c:	98 e0       	ldi	r25, 0x08	; 8
    ab5e:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
	wdt_reset();
    ab62:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    ab64:	44 e1       	ldi	r20, 0x14	; 20
    ab66:	50 e0       	ldi	r21, 0x00	; 0
    ab68:	68 e6       	ldi	r22, 0x68	; 104
    ab6a:	71 e0       	ldi	r23, 0x01	; 1
    ab6c:	8c e9       	ldi	r24, 0x9C	; 156
    ab6e:	98 e0       	ldi	r25, 0x08	; 8
    ab70:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
	wdt_reset();
    ab74:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    ab76:	44 e1       	ldi	r20, 0x14	; 20
    ab78:	50 e0       	ldi	r21, 0x00	; 0
    ab7a:	64 e5       	ldi	r22, 0x54	; 84
    ab7c:	71 e0       	ldi	r23, 0x01	; 1
    ab7e:	80 eb       	ldi	r24, 0xB0	; 176
    ab80:	98 e0       	ldi	r25, 0x08	; 8
    ab82:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewbl>
	wdt_reset();
    ab86:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    ab88:	60 91 c4 08 	lds	r22, 0x08C4
    ab8c:	70 91 c5 08 	lds	r23, 0x08C5
    ab90:	80 e2       	ldi	r24, 0x20	; 32
    ab92:	91 e0       	ldi	r25, 0x01	; 1
    ab94:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    ab98:	60 91 c6 08 	lds	r22, 0x08C6
    ab9c:	70 91 c7 08 	lds	r23, 0x08C7
    aba0:	8e e0       	ldi	r24, 0x0E	; 14
    aba2:	91 e0       	ldi	r25, 0x01	; 1
    aba4:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>

	ewb(&TCP_ServerIP->IP1, MBHoldReg1[38]);
    aba8:	60 91 c8 08 	lds	r22, 0x08C8
    abac:	82 e3       	ldi	r24, 0x32	; 50
    abae:	91 e0       	ldi	r25, 0x01	; 1
    abb0:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
	ewb(&TCP_ServerIP->IP2, MBHoldReg1[39]);
    abb4:	60 91 ca 08 	lds	r22, 0x08CA
    abb8:	83 e3       	ldi	r24, 0x33	; 51
    abba:	91 e0       	ldi	r25, 0x01	; 1
    abbc:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
	ewb(&TCP_ServerIP->IP3, MBHoldReg1[40]);
    abc0:	60 91 cc 08 	lds	r22, 0x08CC
    abc4:	84 e3       	ldi	r24, 0x34	; 52
    abc6:	91 e0       	ldi	r25, 0x01	; 1
    abc8:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
	ewb(&TCP_ServerIP->IP4, MBHoldReg1[41]);
    abcc:	60 91 ce 08 	lds	r22, 0x08CE
    abd0:	85 e3       	ldi	r24, 0x35	; 53
    abd2:	91 e0       	ldi	r25, 0x01	; 1
    abd4:	0e 94 be 29 	call	0x537c	; 0x537c <ewb>
	eww(&TCP_ServerPort[0], MBHoldReg1[42]);
    abd8:	60 91 d0 08 	lds	r22, 0x08D0
    abdc:	70 91 d1 08 	lds	r23, 0x08D1
    abe0:	82 e2       	ldi	r24, 0x22	; 34
    abe2:	91 e0       	ldi	r25, 0x01	; 1
    abe4:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>
	eww(&SerialNum, MBHoldReg1[43]);
    abe8:	60 91 d2 08 	lds	r22, 0x08D2
    abec:	70 91 d3 08 	lds	r23, 0x08D3
    abf0:	82 e5       	ldi	r24, 0x52	; 82
    abf2:	91 e0       	ldi	r25, 0x01	; 1
    abf4:	0c 94 c9 29 	jmp	0x5392	; 0x5392 <eww>

0000abf8 <Modbus_App>:
	MBHoldReg1[43] = erw(&SerialNum);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    abf8:	cf 93       	push	r28
    abfa:	df 93       	push	r29

	IntOff();
    abfc:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	MBInput1[0] = DigInput.State[0];
    ac00:	80 91 d6 08 	lds	r24, 0x08D6
    ac04:	80 93 f6 03 	sts	0x03F6, r24

	MBInReg1[0]  = (SW_VERSION << 8) + 	SW_SUBVERSION;
    ac08:	87 e0       	ldi	r24, 0x07	; 7
    ac0a:	93 e0       	ldi	r25, 0x03	; 3
    ac0c:	90 93 79 0a 	sts	0x0A79, r25
    ac10:	80 93 78 0a 	sts	0x0A78, r24
	MBInReg1[1]  = MemFail;
    ac14:	80 91 77 0a 	lds	r24, 0x0A77
    ac18:	90 e0       	ldi	r25, 0x00	; 0
    ac1a:	90 93 7b 0a 	sts	0x0A7B, r25
    ac1e:	80 93 7a 0a 	sts	0x0A7A, r24
	MBInReg1[2]  = (uint16_t)(LiveTime & 0x0000FFFF);
    ac22:	80 91 63 09 	lds	r24, 0x0963
    ac26:	90 91 64 09 	lds	r25, 0x0964
    ac2a:	a0 91 65 09 	lds	r26, 0x0965
    ac2e:	b0 91 66 09 	lds	r27, 0x0966
    ac32:	90 93 7d 0a 	sts	0x0A7D, r25
    ac36:	80 93 7c 0a 	sts	0x0A7C, r24
	MBInReg1[3]  = (uint16_t)(LiveTime>>16);
    ac3a:	80 91 63 09 	lds	r24, 0x0963
    ac3e:	90 91 64 09 	lds	r25, 0x0964
    ac42:	a0 91 65 09 	lds	r26, 0x0965
    ac46:	b0 91 66 09 	lds	r27, 0x0966
    ac4a:	b0 93 7f 0a 	sts	0x0A7F, r27
    ac4e:	a0 93 7e 0a 	sts	0x0A7E, r26
	MBInReg1[4]  = (uint16_t)Temperature[0];	
    ac52:	80 91 f2 05 	lds	r24, 0x05F2
    ac56:	90 91 f3 05 	lds	r25, 0x05F3
    ac5a:	90 93 81 0a 	sts	0x0A81, r25
    ac5e:	80 93 80 0a 	sts	0x0A80, r24
	MBInReg1[5]  = (uint16_t)GSM_State;
    ac62:	80 91 27 06 	lds	r24, 0x0627
    ac66:	90 e0       	ldi	r25, 0x00	; 0
    ac68:	90 93 83 0a 	sts	0x0A83, r25
    ac6c:	80 93 82 0a 	sts	0x0A82, r24
	MBInReg1[6]  = GSM_MyIP.IP1;
    ac70:	80 91 1c 0b 	lds	r24, 0x0B1C
    ac74:	90 e0       	ldi	r25, 0x00	; 0
    ac76:	90 93 85 0a 	sts	0x0A85, r25
    ac7a:	80 93 84 0a 	sts	0x0A84, r24
	MBInReg1[7]  = GSM_MyIP.IP2;
    ac7e:	80 91 1d 0b 	lds	r24, 0x0B1D
    ac82:	90 e0       	ldi	r25, 0x00	; 0
    ac84:	90 93 87 0a 	sts	0x0A87, r25
    ac88:	80 93 86 0a 	sts	0x0A86, r24
	MBInReg1[8]  = GSM_MyIP.IP3;
    ac8c:	80 91 1e 0b 	lds	r24, 0x0B1E
    ac90:	90 e0       	ldi	r25, 0x00	; 0
    ac92:	90 93 89 0a 	sts	0x0A89, r25
    ac96:	80 93 88 0a 	sts	0x0A88, r24
	MBInReg1[9]  = GSM_MyIP.IP4;
    ac9a:	80 91 1f 0b 	lds	r24, 0x0B1F
    ac9e:	90 e0       	ldi	r25, 0x00	; 0
    aca0:	90 93 8b 0a 	sts	0x0A8B, r25
    aca4:	80 93 8a 0a 	sts	0x0A8A, r24
	MBInReg1[10] = GSM_ClientIP.IP1;
    aca8:	80 91 3a 0d 	lds	r24, 0x0D3A
    acac:	90 e0       	ldi	r25, 0x00	; 0
    acae:	90 93 8d 0a 	sts	0x0A8D, r25
    acb2:	80 93 8c 0a 	sts	0x0A8C, r24
	MBInReg1[11] = GSM_ClientIP.IP2;
    acb6:	80 91 3b 0d 	lds	r24, 0x0D3B
    acba:	90 e0       	ldi	r25, 0x00	; 0
    acbc:	90 93 8f 0a 	sts	0x0A8F, r25
    acc0:	80 93 8e 0a 	sts	0x0A8E, r24
	MBInReg1[12] = GSM_ClientIP.IP3;
    acc4:	80 91 3c 0d 	lds	r24, 0x0D3C
    acc8:	90 e0       	ldi	r25, 0x00	; 0
    acca:	90 93 91 0a 	sts	0x0A91, r25
    acce:	80 93 90 0a 	sts	0x0A90, r24
	MBInReg1[13] = GSM_ClientIP.IP4;
    acd2:	80 91 3d 0d 	lds	r24, 0x0D3D
    acd6:	90 e0       	ldi	r25, 0x00	; 0
    acd8:	90 93 93 0a 	sts	0x0A93, r25
    acdc:	80 93 92 0a 	sts	0x0A92, r24
	MBInReg1[14] = GSM_RX_FIFOMax;
    ace0:	80 91 0d 0b 	lds	r24, 0x0B0D
    ace4:	90 e0       	ldi	r25, 0x00	; 0
    ace6:	90 93 95 0a 	sts	0x0A95, r25
    acea:	80 93 94 0a 	sts	0x0A94, r24
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    acee:	80 91 7f 09 	lds	r24, 0x097F
    acf2:	90 e0       	ldi	r25, 0x00	; 0
    acf4:	90 93 97 0a 	sts	0x0A97, r25
    acf8:	80 93 96 0a 	sts	0x0A96, r24
	MBInReg1[16] = EM_RX_FIFOMax;
    acfc:	80 91 6e 0a 	lds	r24, 0x0A6E
    ad00:	90 e0       	ldi	r25, 0x00	; 0
    ad02:	90 93 99 0a 	sts	0x0A99, r25
    ad06:	80 93 98 0a 	sts	0x0A98, r24
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    ad0a:	80 91 73 09 	lds	r24, 0x0973
    ad0e:	80 93 9a 0a 	sts	0x0A9A, r24
    ad12:	80 91 74 09 	lds	r24, 0x0974
    ad16:	80 93 9b 0a 	sts	0x0A9B, r24
    ad1a:	80 91 75 09 	lds	r24, 0x0975
    ad1e:	80 93 9c 0a 	sts	0x0A9C, r24
    ad22:	80 91 76 09 	lds	r24, 0x0976
    ad26:	80 93 9d 0a 	sts	0x0A9D, r24
    ad2a:	80 91 77 09 	lds	r24, 0x0977
    ad2e:	80 93 9e 0a 	sts	0x0A9E, r24
    ad32:	80 91 78 09 	lds	r24, 0x0978
    ad36:	80 93 9f 0a 	sts	0x0A9F, r24
    ad3a:	80 91 79 09 	lds	r24, 0x0979
    ad3e:	80 93 a0 0a 	sts	0x0AA0, r24
    ad42:	80 91 7a 09 	lds	r24, 0x097A
    ad46:	80 93 a1 0a 	sts	0x0AA1, r24
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    ad4a:	80 91 5b 09 	lds	r24, 0x095B
    ad4e:	90 e0       	ldi	r25, 0x00	; 0
    ad50:	90 93 a3 0a 	sts	0x0AA3, r25
    ad54:	80 93 a2 0a 	sts	0x0AA2, r24
	MBInReg1[22] = (uint16_t)Web_POST;
    ad58:	80 91 6d 09 	lds	r24, 0x096D
    ad5c:	90 e0       	ldi	r25, 0x00	; 0
    ad5e:	90 93 a5 0a 	sts	0x0AA5, r25
    ad62:	80 93 a4 0a 	sts	0x0AA4, r24
	MBInReg1[23] = (uint16_t)AppProtocol;
    ad66:	80 91 f4 09 	lds	r24, 0x09F4
    ad6a:	90 e0       	ldi	r25, 0x00	; 0
    ad6c:	90 93 a7 0a 	sts	0x0AA7, r25
    ad70:	80 93 a6 0a 	sts	0x0AA6, r24
	MBInReg1[24] = (uint16_t)WebSession;
    ad74:	80 91 7e 09 	lds	r24, 0x097E
    ad78:	90 e0       	ldi	r25, 0x00	; 0
    ad7a:	90 93 a9 0a 	sts	0x0AA9, r25
    ad7e:	80 93 a8 0a 	sts	0x0AA8, r24
	MBInReg1[25] = (uint16_t)WebMode;
    ad82:	80 91 06 01 	lds	r24, 0x0106
    ad86:	90 e0       	ldi	r25, 0x00	; 0
    ad88:	90 93 ab 0a 	sts	0x0AAB, r25
    ad8c:	80 93 aa 0a 	sts	0x0AAA, r24
	MBInReg1[26] = (uint16_t)WebStrLen;
    ad90:	80 91 70 08 	lds	r24, 0x0870
    ad94:	90 e0       	ldi	r25, 0x00	; 0
    ad96:	90 93 ad 0a 	sts	0x0AAD, r25
    ad9a:	80 93 ac 0a 	sts	0x0AAC, r24

	IntOn();
    ad9e:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    ada2:	80 91 df 03 	lds	r24, 0x03DF
    ada6:	80 ff       	sbrs	r24, 0
    ada8:	10 c0       	rjmp	.+32     	; 0xadca <Modbus_App+0x1d2>
		GSMApply();						//  MB RAM  EEPROM
    adaa:	0e 94 a9 55 	call	0xab52	; 0xab52 <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    adae:	0e 94 19 2a 	call	0x5432	; 0x5432 <Modbus_ReadHoldReg>
    adb2:	88 e5       	ldi	r24, 0x58	; 88
    adb4:	80 93 27 06 	sts	0x0627, r24
		ResetGSMState();				// 
		IntOff();
    adb8:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    adbc:	80 91 df 03 	lds	r24, 0x03DF
    adc0:	8e 7f       	andi	r24, 0xFE	; 254
    adc2:	80 93 df 03 	sts	0x03DF, r24
		IntOn();
    adc6:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
	}
	
	IntOff();
    adca:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    adce:	c0 91 7c 08 	lds	r28, 0x087C
    add2:	d0 91 7d 08 	lds	r29, 0x087D
    add6:	87 e2       	ldi	r24, 0x27	; 39
    add8:	90 e0       	ldi	r25, 0x00	; 0
    adda:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    adde:	c8 17       	cp	r28, r24
    ade0:	d9 07       	cpc	r29, r25
    ade2:	29 f0       	breq	.+10     	; 0xadee <Modbus_App+0x1f6>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    ade4:	be 01       	movw	r22, r28
    ade6:	87 e2       	ldi	r24, 0x27	; 39
    ade8:	90 e0       	ldi	r25, 0x00	; 0
    adea:	0e 94 c9 29 	call	0x5392	; 0x5392 <eww>
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    adee:	df 91       	pop	r29
    adf0:	cf 91       	pop	r28
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
		eww(&EM_UART_Param, MBHoldReg1[0]);
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
    adf2:	0c 94 11 2a 	jmp	0x5422	; 0x5422 <IntOn>

0000adf6 <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    adf6:	81 e0       	ldi	r24, 0x01	; 1
    adf8:	80 93 f2 09 	sts	0x09F2, r24
	ModbusMode = 0;
    adfc:	10 92 e0 03 	sts	0x03E0, r1
	EM_InitFIFO();
    ae00:	0e 94 e1 4a 	call	0x95c2	; 0x95c2 <EM_InitFIFO>
	cli();
    ae04:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    ae06:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    ae08:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ae0c:	88 e0       	ldi	r24, 0x08	; 8
    ae0e:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    ae12:	85 e0       	ldi	r24, 0x05	; 5
    ae14:	99 e1       	ldi	r25, 0x19	; 25
    ae16:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_SetUARTParam>
	sei();	
    ae1a:	78 94       	sei
    ae1c:	08 95       	ret

0000ae1e <StopDebug>:
}

void StopDebug(void){
	GSM_DebugMode = 0;
    ae1e:	10 92 f2 09 	sts	0x09F2, r1
	ModbusMode = 1;
    ae22:	81 e0       	ldi	r24, 0x01	; 1
    ae24:	80 93 e0 03 	sts	0x03E0, r24
	cli();
    ae28:	f8 94       	cli
	MB_Init();
    ae2a:	0e 94 92 35 	call	0x6b24	; 0x6b24 <MB_Init>
	sei();
    ae2e:	78 94       	sei
    ae30:	08 95       	ret

0000ae32 <SendDebug>:
}

//  ISR
void SendDebug(uint8_t Char){
	//---FIFO
	EM_RX_FIFO_Begin++;
    ae32:	90 91 70 09 	lds	r25, 0x0970
    ae36:	9f 5f       	subi	r25, 0xFF	; 255
    ae38:	90 93 70 09 	sts	0x0970, r25
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    ae3c:	90 91 70 09 	lds	r25, 0x0970
    ae40:	9f 3f       	cpi	r25, 0xFF	; 255
    ae42:	11 f4       	brne	.+4      	; 0xae48 <SendDebug+0x16>
    ae44:	10 92 70 09 	sts	0x0970, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    ae48:	e0 91 70 09 	lds	r30, 0x0970
    ae4c:	f0 e0       	ldi	r31, 0x00	; 0
    ae4e:	e7 50       	subi	r30, 0x07	; 7
    ae50:	fc 4f       	sbci	r31, 0xFC	; 252
    ae52:	80 83       	st	Z, r24
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    ae54:	90 91 70 09 	lds	r25, 0x0970
    ae58:	80 91 38 0d 	lds	r24, 0x0D38
    ae5c:	98 13       	cpse	r25, r24
    ae5e:	06 c0       	rjmp	.+12     	; 0xae6c <SendDebug+0x3a>
		EM_RX_FIFOOverFlow = 1;
    ae60:	81 e0       	ldi	r24, 0x01	; 1
    ae62:	80 93 24 0b 	sts	0x0B24, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    ae66:	8f ef       	ldi	r24, 0xFF	; 255
    ae68:	80 93 6e 0a 	sts	0x0A6E, r24
    ae6c:	08 95       	ret

0000ae6e <GSM_RX>:

}
// ~~~~~~~~~
void
GSM_RX(void)
{
    ae6e:	cf 93       	push	r28
	char Char = UDR_GSM;
    ae70:	cc b1       	in	r28, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    ae72:	90 91 7b 08 	lds	r25, 0x087B
    ae76:	9f 5f       	subi	r25, 0xFF	; 255
    ae78:	90 93 7b 08 	sts	0x087B, r25
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    ae7c:	80 91 7b 08 	lds	r24, 0x087B
    ae80:	8a 3f       	cpi	r24, 0xFA	; 250
    ae82:	10 f0       	brcs	.+4      	; 0xae88 <GSM_RX+0x1a>
    ae84:	10 92 7b 08 	sts	0x087B, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    ae88:	e0 91 7b 08 	lds	r30, 0x087B
    ae8c:	f0 e0       	ldi	r31, 0x00	; 0
    ae8e:	e8 50       	subi	r30, 0x08	; 8
    ae90:	fb 4f       	sbci	r31, 0xFB	; 251
    ae92:	c0 83       	st	Z, r28
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    ae94:	90 91 7b 08 	lds	r25, 0x087B
    ae98:	80 91 05 06 	lds	r24, 0x0605
    ae9c:	98 13       	cpse	r25, r24
    ae9e:	06 c0       	rjmp	.+12     	; 0xaeac <GSM_RX+0x3e>
		GSM_RX_FIFOOverFlow = 1;
    aea0:	81 e0       	ldi	r24, 0x01	; 1
    aea2:	80 93 6d 0a 	sts	0x0A6D, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    aea6:	8a ef       	ldi	r24, 0xFA	; 250
    aea8:	80 93 0d 0b 	sts	0x0B0D, r24
	}

	//---In Transparent Mode
	if(Transparent){
    aeac:	80 91 76 0a 	lds	r24, 0x0A76
    aeb0:	88 23       	and	r24, r24
    aeb2:	e1 f0       	breq	.+56     	; 0xaeec <GSM_RX+0x7e>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    aeb4:	88 eb       	ldi	r24, 0xB8	; 184
    aeb6:	80 93 9a 00 	sts	0x009A, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    aeba:	90 91 9b 00 	lds	r25, 0x009B
    aebe:	90 64       	ori	r25, 0x40	; 64
    aec0:	90 93 9b 00 	sts	0x009B, r25

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    aec4:	90 91 7b 08 	lds	r25, 0x087B
    aec8:	80 91 f8 0a 	lds	r24, 0x0AF8
    aecc:	98 13       	cpse	r25, r24
    aece:	06 c0       	rjmp	.+12     	; 0xaedc <GSM_RX+0x6e>
			GSM_RX_FIFOOverFlow_Transp = 1;
    aed0:	81 e0       	ldi	r24, 0x01	; 1
    aed2:	80 93 4a 0e 	sts	0x0E4A, r24
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    aed6:	8a ef       	ldi	r24, 0xFA	; 250
    aed8:	80 93 7f 09 	sts	0x097F, r24
		}
		StartTimer16(TCP_CONNECT_check_timer, Connection_check_period );
    aedc:	60 91 0b 01 	lds	r22, 0x010B
    aee0:	70 91 0c 01 	lds	r23, 0x010C
    aee4:	80 91 40 0d 	lds	r24, 0x0D40
    aee8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    aeec:	80 91 f2 09 	lds	r24, 0x09F2
    aef0:	88 23       	and	r24, r24
    aef2:	31 f0       	breq	.+12     	; 0xaf00 <GSM_RX+0x92>
		SendDebug(Char);
    aef4:	8c 2f       	mov	r24, r28
    aef6:	0e 94 19 57 	call	0xae32	; 0xae32 <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    aefa:	88 e2       	ldi	r24, 0x28	; 40
    aefc:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
	}

}
    af00:	cf 91       	pop	r28
    af02:	08 95       	ret

0000af04 <__vector_18>:
}
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    af04:	1f 92       	push	r1
    af06:	0f 92       	push	r0
    af08:	0f b6       	in	r0, 0x3f	; 63
    af0a:	0f 92       	push	r0
    af0c:	11 24       	eor	r1, r1
    af0e:	0b b6       	in	r0, 0x3b	; 59
    af10:	0f 92       	push	r0
    af12:	2f 93       	push	r18
    af14:	3f 93       	push	r19
    af16:	4f 93       	push	r20
    af18:	5f 93       	push	r21
    af1a:	6f 93       	push	r22
    af1c:	7f 93       	push	r23
    af1e:	8f 93       	push	r24
    af20:	9f 93       	push	r25
    af22:	af 93       	push	r26
    af24:	bf 93       	push	r27
    af26:	ef 93       	push	r30
    af28:	ff 93       	push	r31
	GSM_RX();
    af2a:	0e 94 37 57 	call	0xae6e	; 0xae6e <GSM_RX>
	GSM_LED = 1;
    af2e:	81 e0       	ldi	r24, 0x01	; 1
    af30:	80 93 0a 06 	sts	0x060A, r24
}
    af34:	ff 91       	pop	r31
    af36:	ef 91       	pop	r30
    af38:	bf 91       	pop	r27
    af3a:	af 91       	pop	r26
    af3c:	9f 91       	pop	r25
    af3e:	8f 91       	pop	r24
    af40:	7f 91       	pop	r23
    af42:	6f 91       	pop	r22
    af44:	5f 91       	pop	r21
    af46:	4f 91       	pop	r20
    af48:	3f 91       	pop	r19
    af4a:	2f 91       	pop	r18
    af4c:	0f 90       	pop	r0
    af4e:	0b be       	out	0x3b, r0	; 59
    af50:	0f 90       	pop	r0
    af52:	0f be       	out	0x3f, r0	; 63
    af54:	0f 90       	pop	r0
    af56:	1f 90       	pop	r1
    af58:	18 95       	reti

0000af5a <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    af5a:	80 91 39 0c 	lds	r24, 0x0C39
    af5e:	8c b9       	out	0x0c, r24	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    af60:	80 91 f2 09 	lds	r24, 0x09F2
    af64:	88 23       	and	r24, r24
    af66:	49 f0       	breq	.+18     	; 0xaf7a <GSM_SendFirstChar+0x20>
		SendDebug(GSM_TxStr[0]);
    af68:	80 91 39 0c 	lds	r24, 0x0C39
    af6c:	0e 94 19 57 	call	0xae32	; 0xae32 <SendDebug>
		cli();
    af70:	f8 94       	cli
    af72:	88 e2       	ldi	r24, 0x28	; 40
    af74:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    af78:	78 94       	sei
	}

	GSM_TxCharN = 1;
    af7a:	81 e0       	ldi	r24, 0x01	; 1
    af7c:	80 93 46 0d 	sts	0x0D46, r24
	cli();
    af80:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    af82:	80 91 08 01 	lds	r24, 0x0108
    af86:	8e 7f       	andi	r24, 0xFE	; 254
    af88:	80 93 08 01 	sts	0x0108, r24
	sei();
    af8c:	78 94       	sei
	cli();
    af8e:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    af90:	88 eb       	ldi	r24, 0xB8	; 184
    af92:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    af94:	78 94       	sei
    af96:	08 95       	ret

0000af98 <GSM_SendCR>:
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    af98:	cf 93       	push	r28
    af9a:	df 93       	push	r29
    af9c:	ec 01       	movw	r28, r24


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    af9e:	0e 94 72 6c 	call	0xd8e4	; 0xd8e4 <__strlen_P>
	GSMTxSz = strlen_P(Str_P);
    afa2:	80 93 57 09 	sts	0x0957, r24
	sprintf_P(GSM_TxStr, Str_P);
    afa6:	df 93       	push	r29
    afa8:	cf 93       	push	r28
    afaa:	89 e3       	ldi	r24, 0x39	; 57
    afac:	9c e0       	ldi	r25, 0x0C	; 12
    afae:	9f 93       	push	r25
    afb0:	8f 93       	push	r24
    afb2:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    afb6:	80 91 57 09 	lds	r24, 0x0957
    afba:	90 e0       	ldi	r25, 0x00	; 0
    afbc:	69 ec       	ldi	r22, 0xC9	; 201
    afbe:	71 e0       	ldi	r23, 0x01	; 1
    afc0:	87 5c       	subi	r24, 0xC7	; 199
    afc2:	93 4f       	sbci	r25, 0xF3	; 243
    afc4:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
	GSMTxSz++;
    afc8:	80 91 57 09 	lds	r24, 0x0957
    afcc:	8f 5f       	subi	r24, 0xFF	; 255
    afce:	80 93 57 09 	sts	0x0957, r24
	GSM_SendFirstChar();
    afd2:	0f 90       	pop	r0
    afd4:	0f 90       	pop	r0
    afd6:	0f 90       	pop	r0
    afd8:	0f 90       	pop	r0
}
    afda:	df 91       	pop	r29
    afdc:	cf 91       	pop	r28
void GSM_SendCR(prog_char *Str_P){
	GSMTxSz = strlen_P(Str_P);
	sprintf_P(GSM_TxStr, Str_P);
	sprintf(GSM_TxStr + GSMTxSz, "\r");
	GSMTxSz++;
	GSM_SendFirstChar();
    afde:	0c 94 ad 57 	jmp	0xaf5a	; 0xaf5a <GSM_SendFirstChar>

0000afe2 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    afe2:	cf 93       	push	r28
    afe4:	df 93       	push	r29
    afe6:	00 d0       	rcall	.+0      	; 0xafe8 <GSM_Execute_Command+0x6>
    afe8:	cd b7       	in	r28, 0x3d	; 61
    afea:	de b7       	in	r29, 0x3e	; 62
	if(GSM_Flag & (1<<flg_TxCStr)){
    afec:	20 91 08 01 	lds	r18, 0x0108
    aff0:	20 ff       	sbrs	r18, 0
    aff2:	0e c0       	rjmp	.+28     	; 0xb010 <GSM_Execute_Command+0x2e>
		GSM_SendCR(Str_P);
    aff4:	69 83       	std	Y+1, r22	; 0x01
    aff6:	7a 83       	std	Y+2, r23	; 0x02
    aff8:	0e 94 cc 57 	call	0xaf98	; 0xaf98 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    affc:	69 81       	ldd	r22, Y+1	; 0x01
    affe:	7a 81       	ldd	r23, Y+2	; 0x02
    b000:	80 91 5a 02 	lds	r24, 0x025A
	}
}
    b004:	0f 90       	pop	r0
    b006:	0f 90       	pop	r0
    b008:	df 91       	pop	r29
    b00a:	cf 91       	pop	r28
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
	if(GSM_Flag & (1<<flg_TxCStr)){
		GSM_SendCR(Str_P);
		StartTimer16(TD_GSM, Timeout);
    b00c:	0c 94 c8 2a 	jmp	0x5590	; 0x5590 <StartTimer16>
	}
}
    b010:	0f 90       	pop	r0
    b012:	0f 90       	pop	r0
    b014:	df 91       	pop	r29
    b016:	cf 91       	pop	r28
    b018:	08 95       	ret

0000b01a <GSM_AddHeaderSendData>:
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b01a:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b01e:	40 91 57 09 	lds	r20, 0x0957
    b022:	50 e0       	ldi	r21, 0x00	; 0
    b024:	bc 01       	movw	r22, r24
    b026:	89 e3       	ldi	r24, 0x39	; 57
    b028:	9c e0       	ldi	r25, 0x0C	; 12
    b02a:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
	GSM_SendFirstChar();
    b02e:	0c 94 ad 57 	jmp	0xaf5a	; 0xaf5a <GSM_SendFirstChar>

0000b032 <GSM_SendData>:
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b032:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b036:	40 91 57 09 	lds	r20, 0x0957
    b03a:	50 e0       	ldi	r21, 0x00	; 0
    b03c:	bc 01       	movw	r22, r24
    b03e:	89 e3       	ldi	r24, 0x39	; 57
    b040:	9c e0       	ldi	r25, 0x0C	; 12
    b042:	0e 94 a3 6c 	call	0xd946	; 0xd946 <memcpy>
	GSM_SendFirstChar();
    b046:	0c 94 ad 57 	jmp	0xaf5a	; 0xaf5a <GSM_SendFirstChar>

0000b04a <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    b04a:	2f 92       	push	r2
    b04c:	3f 92       	push	r3
    b04e:	4f 92       	push	r4
    b050:	5f 92       	push	r5
    b052:	6f 92       	push	r6
    b054:	7f 92       	push	r7
    b056:	8f 92       	push	r8
    b058:	9f 92       	push	r9
    b05a:	af 92       	push	r10
    b05c:	bf 92       	push	r11
    b05e:	cf 92       	push	r12
    b060:	df 92       	push	r13
    b062:	ef 92       	push	r14
    b064:	ff 92       	push	r15
    b066:	0f 93       	push	r16
    b068:	1f 93       	push	r17
    b06a:	cf 93       	push	r28
    b06c:	df 93       	push	r29
    b06e:	cd b7       	in	r28, 0x3d	; 61
    b070:	de b7       	in	r29, 0x3e	; 62
    b072:	2e 97       	sbiw	r28, 0x0e	; 14
    b074:	0f b6       	in	r0, 0x3f	; 63
    b076:	f8 94       	cli
    b078:	de bf       	out	0x3e, r29	; 62
    b07a:	0f be       	out	0x3f, r0	; 63
    b07c:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    b07e:	80 91 7d 09 	lds	r24, 0x097D
    b082:	88 23       	and	r24, r24
    b084:	31 f0       	breq	.+12     	; 0xb092 <GSM_Cycle+0x48>
    b086:	82 30       	cpi	r24, 0x02	; 2
    b088:	11 f4       	brne	.+4      	; 0xb08e <GSM_Cycle+0x44>
    b08a:	0c 94 5b 64 	jmp	0xc8b6	; 0xc8b6 <GSM_Cycle+0x186c>
    b08e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    b092:	80 91 27 06 	lds	r24, 0x0627
    b096:	90 e0       	ldi	r25, 0x00	; 0
    b098:	89 36       	cpi	r24, 0x69	; 105
    b09a:	91 05       	cpc	r25, r1
    b09c:	10 f0       	brcs	.+4      	; 0xb0a2 <GSM_Cycle+0x58>
    b09e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b0a2:	fc 01       	movw	r30, r24
    b0a4:	e0 53       	subi	r30, 0x30	; 48
    b0a6:	ff 4f       	sbci	r31, 0xFF	; 255
    b0a8:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>

		case GSM_PowerOn:
		    Transparent_Application_state = INIT;
    b0ac:	10 92 52 09 	sts	0x0952, r1
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    b0b0:	60 ed       	ldi	r22, 0xD0	; 208
    b0b2:	77 e0       	ldi	r23, 0x07	; 7
    b0b4:	80 91 5a 02 	lds	r24, 0x025A
    b0b8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    b0bc:	40 e0       	ldi	r20, 0x00	; 0
    b0be:	56 ed       	ldi	r21, 0xD6	; 214
    b0c0:	63 e8       	ldi	r22, 0x83	; 131
    b0c2:	70 e0       	ldi	r23, 0x00	; 0
    b0c4:	80 91 57 02 	lds	r24, 0x0257
    b0c8:	0e 94 09 2c 	call	0x5812	; 0x5812 <StartTimer32>
			GSM_PWRCNTRL_ON();
    b0cc:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <GSM_PWRCNTRL_ON>
			InitFIFO();
    b0d0:	0e 94 fb 39 	call	0x73f6	; 0x73f6 <InitFIFO>
			GSM_Modem = NOT_RECOGNIZED;
    b0d4:	10 92 71 08 	sts	0x0871, r1
			GSM_State = GSM_WAIT_RDY;
    b0d8:	81 e0       	ldi	r24, 0x01	; 1
    b0da:	80 93 27 06 	sts	0x0627, r24
    b0de:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    b0e2:	68 e5       	ldi	r22, 0x58	; 88
    b0e4:	82 e6       	ldi	r24, 0x62	; 98
    b0e6:	9f e4       	ldi	r25, 0x4F	; 79
    b0e8:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b0ec:	88 23       	and	r24, r24
    b0ee:	11 f4       	brne	.+4      	; 0xb0f4 <GSM_Cycle+0xaa>
    b0f0:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b0f4:	80 91 27 06 	lds	r24, 0x0627
    b0f8:	8f 5f       	subi	r24, 0xFF	; 255
    b0fa:	80 93 27 06 	sts	0x0627, r24
    b0fe:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    b102:	68 e8       	ldi	r22, 0x88	; 136
    b104:	73 e1       	ldi	r23, 0x13	; 19
    b106:	8b e6       	ldi	r24, 0x6B	; 107
    b108:	9e e4       	ldi	r25, 0x4E	; 78
    b10a:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b10e:	80 91 27 06 	lds	r24, 0x0627
    b112:	8f 5f       	subi	r24, 0xFF	; 255
    b114:	80 93 27 06 	sts	0x0627, r24
    b118:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b11c:	80 91 5a 02 	lds	r24, 0x025A
    b120:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    b124:	88 23       	and	r24, r24
    b126:	19 f0       	breq	.+6      	; 0xb12e <GSM_Cycle+0xe4>
    b128:	88 e5       	ldi	r24, 0x58	; 88
    b12a:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b12e:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    b132:	88 23       	and	r24, r24
    b134:	e9 f0       	breq	.+58     	; 0xb170 <GSM_Cycle+0x126>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    b136:	64 e7       	ldi	r22, 0x74	; 116
    b138:	7f e4       	ldi	r23, 0x4F	; 79
    b13a:	89 e8       	ldi	r24, 0x89	; 137
    b13c:	99 e0       	ldi	r25, 0x09	; 9
    b13e:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    b142:	89 2b       	or	r24, r25
    b144:	19 f4       	brne	.+6      	; 0xb14c <GSM_Cycle+0x102>
    b146:	81 e0       	ldi	r24, 0x01	; 1
    b148:	80 93 71 08 	sts	0x0871, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    b14c:	66 e6       	ldi	r22, 0x66	; 102
    b14e:	7f e4       	ldi	r23, 0x4F	; 79
    b150:	89 e8       	ldi	r24, 0x89	; 137
    b152:	99 e0       	ldi	r25, 0x09	; 9
    b154:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    b158:	89 2b       	or	r24, r25
    b15a:	19 f4       	brne	.+6      	; 0xb162 <GSM_Cycle+0x118>
    b15c:	82 e0       	ldi	r24, 0x02	; 2
    b15e:	80 93 71 08 	sts	0x0871, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    b162:	80 91 71 08 	lds	r24, 0x0871
    b166:	88 23       	and	r24, r24
    b168:	19 f0       	breq	.+6      	; 0xb170 <GSM_Cycle+0x126>
    b16a:	86 e0       	ldi	r24, 0x06	; 6
    b16c:	80 93 27 06 	sts	0x0627, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    b170:	68 e5       	ldi	r22, 0x58	; 88
    b172:	87 e5       	ldi	r24, 0x57	; 87
    b174:	9f e4       	ldi	r25, 0x4F	; 79
    b176:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b17a:	88 23       	and	r24, r24
    b17c:	11 f4       	brne	.+4      	; 0xb182 <GSM_Cycle+0x138>
    b17e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    b182:	80 91 71 08 	lds	r24, 0x0871
    b186:	82 30       	cpi	r24, 0x02	; 2
    b188:	29 f4       	brne	.+10     	; 0xb194 <GSM_Cycle+0x14a>
    b18a:	87 e0       	ldi	r24, 0x07	; 7
    b18c:	80 93 27 06 	sts	0x0627, r24
    b190:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				else GSM_State = GSM_SEND_E0;
    b194:	88 e0       	ldi	r24, 0x08	; 8
    b196:	80 93 27 06 	sts	0x0627, r24
    b19a:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    b19e:	68 e5       	ldi	r22, 0x58	; 88
    b1a0:	8d e4       	ldi	r24, 0x4D	; 77
    b1a2:	9f e4       	ldi	r25, 0x4F	; 79
    b1a4:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b1a8:	88 23       	and	r24, r24
    b1aa:	11 f4       	brne	.+4      	; 0xb1b0 <GSM_Cycle+0x166>
    b1ac:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b1b0:	80 91 27 06 	lds	r24, 0x0627
    b1b4:	8f 5f       	subi	r24, 0xFF	; 255
    b1b6:	80 93 27 06 	sts	0x0627, r24
    b1ba:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    b1be:	64 e6       	ldi	r22, 0x64	; 100
    b1c0:	70 e0       	ldi	r23, 0x00	; 0
    b1c2:	83 e7       	ldi	r24, 0x73	; 115
    b1c4:	9e e4       	ldi	r25, 0x4E	; 78
    b1c6:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b1ca:	80 91 27 06 	lds	r24, 0x0627
    b1ce:	8f 5f       	subi	r24, 0xFF	; 255
    b1d0:	80 93 27 06 	sts	0x0627, r24
    b1d4:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b1d8:	68 e5       	ldi	r22, 0x58	; 88
    b1da:	8a e0       	ldi	r24, 0x0A	; 10
    b1dc:	9f e4       	ldi	r25, 0x4F	; 79
    b1de:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b1e2:	88 23       	and	r24, r24
    b1e4:	11 f4       	brne	.+4      	; 0xb1ea <GSM_Cycle+0x1a0>
    b1e6:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b1ea:	80 91 27 06 	lds	r24, 0x0627
    b1ee:	8f 5f       	subi	r24, 0xFF	; 255
    b1f0:	80 93 27 06 	sts	0x0627, r24
    b1f4:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    b1f8:	64 e6       	ldi	r22, 0x64	; 100
    b1fa:	70 e0       	ldi	r23, 0x00	; 0
    b1fc:	81 e6       	ldi	r24, 0x61	; 97
    b1fe:	9e e4       	ldi	r25, 0x4E	; 78
    b200:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b204:	80 91 27 06 	lds	r24, 0x0627
    b208:	8f 5f       	subi	r24, 0xFF	; 255
    b20a:	80 93 27 06 	sts	0x0627, r24
    b20e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b212:	68 e5       	ldi	r22, 0x58	; 88
    b214:	8a e0       	ldi	r24, 0x0A	; 10
    b216:	9f e4       	ldi	r25, 0x4F	; 79
    b218:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b21c:	88 23       	and	r24, r24
    b21e:	11 f4       	brne	.+4      	; 0xb224 <GSM_Cycle+0x1da>
    b220:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b224:	80 91 27 06 	lds	r24, 0x0627
    b228:	8f 5f       	subi	r24, 0xFF	; 255
    b22a:	80 93 27 06 	sts	0x0627, r24
    b22e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_CCID:
			GSM_RxStr[19] = 0;
    b232:	10 92 9c 09 	sts	0x099C, r1
			GSM_Execute_Command(AT_CCID,300*GSM_DEBUG_DELAY); GSM_State++;
    b236:	6c e2       	ldi	r22, 0x2C	; 44
    b238:	71 e0       	ldi	r23, 0x01	; 1
    b23a:	89 e5       	ldi	r24, 0x59	; 89
    b23c:	9e e4       	ldi	r25, 0x4E	; 78
    b23e:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b242:	80 91 27 06 	lds	r24, 0x0627
    b246:	8f 5f       	subi	r24, 0xFF	; 255
    b248:	80 93 27 06 	sts	0x0627, r24
    b24c:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CCID_READ:
			//8938001300106446004F
			if(GetStringFromFIFO() && ((GSM_RxStr[19] == 'F')||(GSM_RxStr[19] == 'f')) ){
    b250:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    b254:	88 23       	and	r24, r24
    b256:	11 f4       	brne	.+4      	; 0xb25c <GSM_Cycle+0x212>
    b258:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b25c:	80 91 9c 09 	lds	r24, 0x099C
    b260:	8f 7d       	andi	r24, 0xDF	; 223
    b262:	86 34       	cpi	r24, 0x46	; 70
    b264:	11 f0       	breq	.+4      	; 0xb26a <GSM_Cycle+0x220>
    b266:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>



				GSM_RxStr[18] = ' ';
    b26a:	10 e2       	ldi	r17, 0x20	; 32
    b26c:	10 93 9b 09 	sts	0x099B, r17
				sscanf_P(GSM_RxStr+9,PSTR("%lud"), (long unsigned int*)&ICCID2);
    b270:	82 e1       	ldi	r24, 0x12	; 18
    b272:	96 e0       	ldi	r25, 0x06	; 6
    b274:	9f 93       	push	r25
    b276:	8f 93       	push	r24
    b278:	8d e7       	ldi	r24, 0x7D	; 125
    b27a:	93 e0       	ldi	r25, 0x03	; 3
    b27c:	9f 93       	push	r25
    b27e:	8f 93       	push	r24
    b280:	82 e9       	ldi	r24, 0x92	; 146
    b282:	99 e0       	ldi	r25, 0x09	; 9
    b284:	9f 93       	push	r25
    b286:	8f 93       	push	r24
    b288:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				GSM_RxStr[9] = ' ';
    b28c:	10 93 92 09 	sts	0x0992, r17
				sscanf_P(GSM_RxStr+5,PSTR("%u"), (unsigned int*)&ICCID1);
    b290:	87 e2       	ldi	r24, 0x27	; 39
    b292:	9b e0       	ldi	r25, 0x0B	; 11
    b294:	9f 93       	push	r25
    b296:	8f 93       	push	r24
    b298:	8a e7       	ldi	r24, 0x7A	; 122
    b29a:	93 e0       	ldi	r25, 0x03	; 3
    b29c:	9f 93       	push	r25
    b29e:	8f 93       	push	r24
    b2a0:	8e e8       	ldi	r24, 0x8E	; 142
    b2a2:	99 e0       	ldi	r25, 0x09	; 9
    b2a4:	9f 93       	push	r25
    b2a6:	8f 93       	push	r24
    b2a8:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				if((ICCID1 == 0) || (ICCID2==0)) GSM_State = GSM_ReStart1;
    b2ac:	40 91 27 0b 	lds	r20, 0x0B27
    b2b0:	50 91 28 0b 	lds	r21, 0x0B28
    b2b4:	0f b6       	in	r0, 0x3f	; 63
    b2b6:	f8 94       	cli
    b2b8:	de bf       	out	0x3e, r29	; 62
    b2ba:	0f be       	out	0x3f, r0	; 63
    b2bc:	cd bf       	out	0x3d, r28	; 61
    b2be:	41 15       	cp	r20, r1
    b2c0:	51 05       	cpc	r21, r1
    b2c2:	69 f0       	breq	.+26     	; 0xb2de <GSM_Cycle+0x294>
    b2c4:	40 90 12 06 	lds	r4, 0x0612
    b2c8:	50 90 13 06 	lds	r5, 0x0613
    b2cc:	60 90 14 06 	lds	r6, 0x0614
    b2d0:	70 90 15 06 	lds	r7, 0x0615
    b2d4:	41 14       	cp	r4, r1
    b2d6:	51 04       	cpc	r5, r1
    b2d8:	61 04       	cpc	r6, r1
    b2da:	71 04       	cpc	r7, r1
    b2dc:	29 f4       	brne	.+10     	; 0xb2e8 <GSM_Cycle+0x29e>
    b2de:	88 e5       	ldi	r24, 0x58	; 88
    b2e0:	80 93 27 06 	sts	0x0627, r24
    b2e4:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				else{
					ICCID = (uint64_t)ICCID1 * 1000000000UL + (uint64_t)ICCID2;
    b2e8:	a1 2c       	mov	r10, r1
    b2ea:	6a ec       	ldi	r22, 0xCA	; 202
    b2ec:	b6 2e       	mov	r11, r22
    b2ee:	7a e9       	ldi	r23, 0x9A	; 154
    b2f0:	c7 2e       	mov	r12, r23
    b2f2:	eb e3       	ldi	r30, 0x3B	; 59
    b2f4:	de 2e       	mov	r13, r30
    b2f6:	e1 2c       	mov	r14, r1
    b2f8:	f1 2c       	mov	r15, r1
    b2fa:	00 e0       	ldi	r16, 0x00	; 0
    b2fc:	10 e0       	ldi	r17, 0x00	; 0
    b2fe:	9a 01       	movw	r18, r20
    b300:	40 e0       	ldi	r20, 0x00	; 0
    b302:	50 e0       	ldi	r21, 0x00	; 0
    b304:	60 e0       	ldi	r22, 0x00	; 0
    b306:	70 e0       	ldi	r23, 0x00	; 0
    b308:	80 e0       	ldi	r24, 0x00	; 0
    b30a:	90 e0       	ldi	r25, 0x00	; 0
    b30c:	0e 94 ae 75 	call	0xeb5c	; 0xeb5c <__muldi3>
    b310:	12 01       	movw	r2, r4
    b312:	23 01       	movw	r4, r6
    b314:	51 01       	movw	r10, r2
    b316:	62 01       	movw	r12, r4
    b318:	0e 94 07 76 	call	0xec0e	; 0xec0e <__adddi3>
    b31c:	20 93 73 09 	sts	0x0973, r18
    b320:	30 93 74 09 	sts	0x0974, r19
    b324:	40 93 75 09 	sts	0x0975, r20
    b328:	50 93 76 09 	sts	0x0976, r21
    b32c:	60 93 77 09 	sts	0x0977, r22
    b330:	70 93 78 09 	sts	0x0978, r23
    b334:	80 93 79 09 	sts	0x0979, r24
    b338:	90 93 7a 09 	sts	0x097A, r25
					GSM_State++;
    b33c:	80 91 27 06 	lds	r24, 0x0627
    b340:	8f 5f       	subi	r24, 0xFF	; 255
    b342:	80 93 27 06 	sts	0x0627, r24
    b346:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				}
			}
			break;
		case GSM_WAIT_CCID_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b34a:	68 e5       	ldi	r22, 0x58	; 88
    b34c:	8a e0       	ldi	r24, 0x0A	; 10
    b34e:	9f e4       	ldi	r25, 0x4F	; 79
    b350:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b354:	88 23       	and	r24, r24
    b356:	11 f4       	brne	.+4      	; 0xb35c <GSM_Cycle+0x312>
    b358:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b35c:	80 91 27 06 	lds	r24, 0x0627
    b360:	8f 5f       	subi	r24, 0xFF	; 255
    b362:	80 93 27 06 	sts	0x0627, r24
    b366:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    b36a:	64 e6       	ldi	r22, 0x64	; 100
    b36c:	70 e0       	ldi	r23, 0x00	; 0
    b36e:	8f e4       	ldi	r24, 0x4F	; 79
    b370:	9e e4       	ldi	r25, 0x4E	; 78
    b372:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b376:	80 91 27 06 	lds	r24, 0x0627
    b37a:	8f 5f       	subi	r24, 0xFF	; 255
    b37c:	80 93 27 06 	sts	0x0627, r24
    b380:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b384:	68 e5       	ldi	r22, 0x58	; 88
    b386:	8a e0       	ldi	r24, 0x0A	; 10
    b388:	9f e4       	ldi	r25, 0x4F	; 79
    b38a:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b38e:	88 23       	and	r24, r24
    b390:	11 f4       	brne	.+4      	; 0xb396 <GSM_Cycle+0x34c>
    b392:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b396:	80 91 27 06 	lds	r24, 0x0627
    b39a:	8f 5f       	subi	r24, 0xFF	; 255
    b39c:	80 93 27 06 	sts	0x0627, r24
    b3a0:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    b3a4:	64 e6       	ldi	r22, 0x64	; 100
    b3a6:	70 e0       	ldi	r23, 0x00	; 0
    b3a8:	8c e3       	ldi	r24, 0x3C	; 60
    b3aa:	9e e4       	ldi	r25, 0x4E	; 78
    b3ac:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b3b0:	80 91 27 06 	lds	r24, 0x0627
    b3b4:	8f 5f       	subi	r24, 0xFF	; 255
    b3b6:	80 93 27 06 	sts	0x0627, r24
    b3ba:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b3be:	68 e5       	ldi	r22, 0x58	; 88
    b3c0:	8a e0       	ldi	r24, 0x0A	; 10
    b3c2:	9f e4       	ldi	r25, 0x4F	; 79
    b3c4:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b3c8:	88 23       	and	r24, r24
    b3ca:	11 f4       	brne	.+4      	; 0xb3d0 <GSM_Cycle+0x386>
    b3cc:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b3d0:	80 91 27 06 	lds	r24, 0x0627
    b3d4:	8f 5f       	subi	r24, 0xFF	; 255
    b3d6:	80 93 27 06 	sts	0x0627, r24
    b3da:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    b3de:	64 e6       	ldi	r22, 0x64	; 100
    b3e0:	70 e0       	ldi	r23, 0x00	; 0
    b3e2:	88 e1       	ldi	r24, 0x18	; 24
    b3e4:	9e e4       	ldi	r25, 0x4E	; 78
    b3e6:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
			GSM_State++; 
    b3ea:	80 91 27 06 	lds	r24, 0x0627
    b3ee:	8f 5f       	subi	r24, 0xFF	; 255
    b3f0:	80 93 27 06 	sts	0x0627, r24
    b3f4:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b3f8:	68 e5       	ldi	r22, 0x58	; 88
    b3fa:	8a e0       	ldi	r24, 0x0A	; 10
    b3fc:	9f e4       	ldi	r25, 0x4F	; 79
    b3fe:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b402:	88 23       	and	r24, r24
    b404:	11 f4       	brne	.+4      	; 0xb40a <GSM_Cycle+0x3c0>
    b406:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;*/
				GSM_State++;
    b40a:	80 91 27 06 	lds	r24, 0x0627
    b40e:	8f 5f       	subi	r24, 0xFF	; 255
    b410:	80 93 27 06 	sts	0x0627, r24
    b414:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_SEND_CIPMODE:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    b418:	64 e6       	ldi	r22, 0x64	; 100
    b41a:	70 e0       	ldi	r23, 0x00	; 0
    b41c:	84 e2       	ldi	r24, 0x24	; 36
    b41e:	9e e4       	ldi	r25, 0x4E	; 78
    b420:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
			GSM_State++;
    b424:	80 91 27 06 	lds	r24, 0x0627
    b428:	8f 5f       	subi	r24, 0xFF	; 255
    b42a:	80 93 27 06 	sts	0x0627, r24
    b42e:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b432:	68 e5       	ldi	r22, 0x58	; 88
    b434:	8a e0       	ldi	r24, 0x0A	; 10
    b436:	9f e4       	ldi	r25, 0x4F	; 79
    b438:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b43c:	88 23       	and	r24, r24
    b43e:	11 f4       	brne	.+4      	; 0xb444 <GSM_Cycle+0x3fa>
    b440:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				GSM_State++;
    b444:	80 91 27 06 	lds	r24, 0x0627
    b448:	8f 5f       	subi	r24, 0xFF	; 255
    b44a:	80 93 27 06 	sts	0x0627, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    b44e:	68 ee       	ldi	r22, 0xE8	; 232
    b450:	73 e0       	ldi	r23, 0x03	; 3
    b452:	80 91 5a 02 	lds	r24, 0x025A
    b456:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    b45a:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    b45e:	10 92 e6 03 	sts	0x03E6, r1
			GSM_State++;
    b462:	80 91 27 06 	lds	r24, 0x0627
    b466:	8f 5f       	subi	r24, 0xFF	; 255
    b468:	80 93 27 06 	sts	0x0627, r24
    b46c:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    b470:	64 ef       	ldi	r22, 0xF4	; 244
    b472:	71 e0       	ldi	r23, 0x01	; 1
    b474:	8d e0       	ldi	r24, 0x0D	; 13
    b476:	9e e4       	ldi	r25, 0x4E	; 78
    b478:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b47c:	80 91 e6 03 	lds	r24, 0x03E6
    b480:	8f 5f       	subi	r24, 0xFF	; 255
    b482:	80 93 e6 03 	sts	0x03E6, r24
    b486:	80 91 27 06 	lds	r24, 0x0627
    b48a:	8f 5f       	subi	r24, 0xFF	; 255
    b48c:	80 93 27 06 	sts	0x0627, r24
    b490:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    b494:	80 91 e6 03 	lds	r24, 0x03E6
    b498:	85 31       	cpi	r24, 0x15	; 21
    b49a:	18 f0       	brcs	.+6      	; 0xb4a2 <GSM_Cycle+0x458>
    b49c:	88 e5       	ldi	r24, 0x58	; 88
    b49e:	80 93 27 06 	sts	0x0627, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    b4a2:	68 e1       	ldi	r22, 0x18	; 24
    b4a4:	8a e0       	ldi	r24, 0x0A	; 10
    b4a6:	9f e4       	ldi	r25, 0x4F	; 79
    b4a8:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b4ac:	88 23       	and	r24, r24
    b4ae:	11 f4       	brne	.+4      	; 0xb4b4 <GSM_Cycle+0x46a>
    b4b0:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b4b4:	80 91 27 06 	lds	r24, 0x0627
    b4b8:	8f 5f       	subi	r24, 0xFF	; 255
    b4ba:	80 93 27 06 	sts	0x0627, r24
    b4be:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    b4c2:	80 91 08 01 	lds	r24, 0x0108
    b4c6:	80 ff       	sbrs	r24, 0
    b4c8:	6d c0       	rjmp	.+218    	; 0xb5a4 <GSM_Cycle+0x55a>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    b4ca:	8e ef       	ldi	r24, 0xFE	; 254
    b4cc:	9d e4       	ldi	r25, 0x4D	; 77
    b4ce:	9f 93       	push	r25
    b4d0:	8f 93       	push	r24
    b4d2:	89 e3       	ldi	r24, 0x39	; 57
    b4d4:	9c e0       	ldi	r25, 0x0C	; 12
    b4d6:	9f 93       	push	r25
    b4d8:	8f 93       	push	r24
    b4da:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
    b4de:	8e e0       	ldi	r24, 0x0E	; 14
    b4e0:	80 93 57 09 	sts	0x0957, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    b4e4:	10 91 57 09 	lds	r17, 0x0957
    b4e8:	80 91 57 09 	lds	r24, 0x0957
    b4ec:	90 e0       	ldi	r25, 0x00	; 0
    b4ee:	6c e7       	ldi	r22, 0x7C	; 124
    b4f0:	71 e0       	ldi	r23, 0x01	; 1
    b4f2:	87 5c       	subi	r24, 0xC7	; 199
    b4f4:	93 4f       	sbci	r25, 0xF3	; 243
    b4f6:	0e 94 be 3a 	call	0x757c	; 0x757c <strcpy_EE>
    b4fa:	81 0f       	add	r24, r17
    b4fc:	80 93 57 09 	sts	0x0957, r24
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    b500:	80 91 57 09 	lds	r24, 0x0957
    b504:	90 e0       	ldi	r25, 0x00	; 0
    b506:	63 eb       	ldi	r22, 0xB3	; 179
    b508:	71 e0       	ldi	r23, 0x01	; 1
    b50a:	87 5c       	subi	r24, 0xC7	; 199
    b50c:	93 4f       	sbci	r25, 0xF3	; 243
    b50e:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
    b512:	80 91 57 09 	lds	r24, 0x0957
    b516:	8d 5f       	subi	r24, 0xFD	; 253
    b518:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    b51c:	10 91 57 09 	lds	r17, 0x0957
    b520:	80 91 57 09 	lds	r24, 0x0957
    b524:	90 e0       	ldi	r25, 0x00	; 0
    b526:	68 e6       	ldi	r22, 0x68	; 104
    b528:	71 e0       	ldi	r23, 0x01	; 1
    b52a:	87 5c       	subi	r24, 0xC7	; 199
    b52c:	93 4f       	sbci	r25, 0xF3	; 243
    b52e:	0e 94 be 3a 	call	0x757c	; 0x757c <strcpy_EE>
    b532:	81 0f       	add	r24, r17
    b534:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    b538:	80 91 57 09 	lds	r24, 0x0957
    b53c:	90 e0       	ldi	r25, 0x00	; 0
    b53e:	63 eb       	ldi	r22, 0xB3	; 179
    b540:	71 e0       	ldi	r23, 0x01	; 1
    b542:	87 5c       	subi	r24, 0xC7	; 199
    b544:	93 4f       	sbci	r25, 0xF3	; 243
    b546:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
    b54a:	80 91 57 09 	lds	r24, 0x0957
    b54e:	8d 5f       	subi	r24, 0xFD	; 253
    b550:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    b554:	10 91 57 09 	lds	r17, 0x0957
    b558:	80 91 57 09 	lds	r24, 0x0957
    b55c:	90 e0       	ldi	r25, 0x00	; 0
    b55e:	64 e5       	ldi	r22, 0x54	; 84
    b560:	71 e0       	ldi	r23, 0x01	; 1
    b562:	87 5c       	subi	r24, 0xC7	; 199
    b564:	93 4f       	sbci	r25, 0xF3	; 243
    b566:	0e 94 be 3a 	call	0x757c	; 0x757c <strcpy_EE>
    b56a:	81 0f       	add	r24, r17
    b56c:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    b570:	80 91 57 09 	lds	r24, 0x0957
    b574:	90 e0       	ldi	r25, 0x00	; 0
    b576:	68 ec       	ldi	r22, 0xC8	; 200
    b578:	71 e0       	ldi	r23, 0x01	; 1
    b57a:	87 5c       	subi	r24, 0xC7	; 199
    b57c:	93 4f       	sbci	r25, 0xF3	; 243
    b57e:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
    b582:	80 91 57 09 	lds	r24, 0x0957
    b586:	8e 5f       	subi	r24, 0xFE	; 254
    b588:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b58c:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    b590:	6c e2       	ldi	r22, 0x2C	; 44
    b592:	71 e0       	ldi	r23, 0x01	; 1
    b594:	80 91 5a 02 	lds	r24, 0x025A
    b598:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    b59c:	0f 90       	pop	r0
    b59e:	0f 90       	pop	r0
    b5a0:	0f 90       	pop	r0
    b5a2:	0f 90       	pop	r0
			}
			GSM_State++;
    b5a4:	80 91 27 06 	lds	r24, 0x0627
    b5a8:	8f 5f       	subi	r24, 0xFF	; 255
    b5aa:	80 93 27 06 	sts	0x0627, r24
    b5ae:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b5b2:	68 e5       	ldi	r22, 0x58	; 88
    b5b4:	8a e0       	ldi	r24, 0x0A	; 10
    b5b6:	9f e4       	ldi	r25, 0x4F	; 79
    b5b8:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b5bc:	88 23       	and	r24, r24
    b5be:	11 f4       	brne	.+4      	; 0xb5c4 <GSM_Cycle+0x57a>
    b5c0:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b5c4:	80 91 27 06 	lds	r24, 0x0627
    b5c8:	8f 5f       	subi	r24, 0xFF	; 255
    b5ca:	80 93 27 06 	sts	0x0627, r24
    b5ce:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    b5d2:	6c e2       	ldi	r22, 0x2C	; 44
    b5d4:	71 e0       	ldi	r23, 0x01	; 1
    b5d6:	86 ef       	ldi	r24, 0xF6	; 246
    b5d8:	9d e4       	ldi	r25, 0x4D	; 77
    b5da:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b5de:	80 91 27 06 	lds	r24, 0x0627
    b5e2:	8f 5f       	subi	r24, 0xFF	; 255
    b5e4:	80 93 27 06 	sts	0x0627, r24
    b5e8:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b5ec:	68 e5       	ldi	r22, 0x58	; 88
    b5ee:	8a e0       	ldi	r24, 0x0A	; 10
    b5f0:	9f e4       	ldi	r25, 0x4F	; 79
    b5f2:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b5f6:	88 23       	and	r24, r24
    b5f8:	11 f4       	brne	.+4      	; 0xb5fe <GSM_Cycle+0x5b4>
    b5fa:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b5fe:	80 91 27 06 	lds	r24, 0x0627
    b602:	8f 5f       	subi	r24, 0xFF	; 255
    b604:	80 93 27 06 	sts	0x0627, r24
    b608:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    b60c:	60 ee       	ldi	r22, 0xE0	; 224
    b60e:	7e e2       	ldi	r23, 0x2E	; 46
    b610:	8d ee       	ldi	r24, 0xED	; 237
    b612:	9d e4       	ldi	r25, 0x4D	; 77
    b614:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b618:	80 91 27 06 	lds	r24, 0x0627
    b61c:	8f 5f       	subi	r24, 0xFF	; 255
    b61e:	80 93 27 06 	sts	0x0627, r24
    b622:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b626:	68 e5       	ldi	r22, 0x58	; 88
    b628:	8a e0       	ldi	r24, 0x0A	; 10
    b62a:	9f e4       	ldi	r25, 0x4F	; 79
    b62c:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b630:	88 23       	and	r24, r24
    b632:	11 f4       	brne	.+4      	; 0xb638 <GSM_Cycle+0x5ee>
    b634:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b638:	80 91 27 06 	lds	r24, 0x0627
    b63c:	8f 5f       	subi	r24, 0xFF	; 255
    b63e:	80 93 27 06 	sts	0x0627, r24
    b642:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    b646:	68 ee       	ldi	r22, 0xE8	; 232
    b648:	73 e0       	ldi	r23, 0x03	; 3
    b64a:	84 ee       	ldi	r24, 0xE4	; 228
    b64c:	9d e4       	ldi	r25, 0x4D	; 77
    b64e:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b652:	80 91 27 06 	lds	r24, 0x0627
    b656:	8f 5f       	subi	r24, 0xFF	; 255
    b658:	80 93 27 06 	sts	0x0627, r24
    b65c:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b660:	80 91 5a 02 	lds	r24, 0x025A
    b664:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    b668:	88 23       	and	r24, r24
    b66a:	19 f0       	breq	.+6      	; 0xb672 <GSM_Cycle+0x628>
    b66c:	88 e5       	ldi	r24, 0x58	; 88
    b66e:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b672:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    b676:	88 23       	and	r24, r24
    b678:	11 f4       	brne	.+4      	; 0xb67e <GSM_Cycle+0x634>
    b67a:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    b67e:	10 92 1c 0b 	sts	0x0B1C, r1
	IP->IP2 = IP2;
    b682:	10 92 1d 0b 	sts	0x0B1D, r1
	IP->IP3 = IP3;
    b686:	10 92 1e 0b 	sts	0x0B1E, r1
	IP->IP4 = IP4;
    b68a:	10 92 1f 0b 	sts	0x0B1F, r1
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b68e:	40 e0       	ldi	r20, 0x00	; 0
    b690:	a9 e8       	ldi	r26, 0x89	; 137
    b692:	b9 e0       	ldi	r27, 0x09	; 9
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b694:	50 e2       	ldi	r21, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b696:	89 e8       	ldi	r24, 0x89	; 137
    b698:	99 e0       	ldi	r25, 0x09	; 9
    b69a:	fd 01       	movw	r30, r26
    b69c:	01 90       	ld	r0, Z+
    b69e:	00 20       	and	r0, r0
    b6a0:	e9 f7       	brne	.-6      	; 0xb69c <GSM_Cycle+0x652>
    b6a2:	31 97       	sbiw	r30, 0x01	; 1
    b6a4:	e9 58       	subi	r30, 0x89	; 137
    b6a6:	f9 40       	sbci	r31, 0x09	; 9
    b6a8:	24 2f       	mov	r18, r20
    b6aa:	30 e0       	ldi	r19, 0x00	; 0
    b6ac:	2e 17       	cp	r18, r30
    b6ae:	3f 07       	cpc	r19, r31
    b6b0:	58 f4       	brcc	.+22     	; 0xb6c8 <GSM_Cycle+0x67e>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b6b2:	f9 01       	movw	r30, r18
    b6b4:	e7 57       	subi	r30, 0x77	; 119
    b6b6:	f6 4f       	sbci	r31, 0xF6	; 246
    b6b8:	80 81       	ld	r24, Z
    b6ba:	90 e0       	ldi	r25, 0x00	; 0
    b6bc:	c0 97       	sbiw	r24, 0x30	; 48
    b6be:	0a 97       	sbiw	r24, 0x0a	; 10
    b6c0:	08 f0       	brcs	.+2      	; 0xb6c4 <GSM_Cycle+0x67a>
    b6c2:	50 83       	st	Z, r21
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b6c4:	4f 5f       	subi	r20, 0xFF	; 255
    b6c6:	e7 cf       	rjmp	.-50     	; 0xb696 <GSM_Cycle+0x64c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    b6c8:	2f e1       	ldi	r18, 0x1F	; 31
    b6ca:	3b e0       	ldi	r19, 0x0B	; 11
    b6cc:	3f 93       	push	r19
    b6ce:	2f 93       	push	r18
    b6d0:	2e e1       	ldi	r18, 0x1E	; 30
    b6d2:	3b e0       	ldi	r19, 0x0B	; 11
    b6d4:	3f 93       	push	r19
    b6d6:	2f 93       	push	r18
    b6d8:	2d e1       	ldi	r18, 0x1D	; 29
    b6da:	3b e0       	ldi	r19, 0x0B	; 11
    b6dc:	3f 93       	push	r19
    b6de:	2f 93       	push	r18
    b6e0:	2c e1       	ldi	r18, 0x1C	; 28
    b6e2:	3b e0       	ldi	r19, 0x0B	; 11
    b6e4:	3f 93       	push	r19
    b6e6:	2f 93       	push	r18
    b6e8:	26 e6       	ldi	r18, 0x66	; 102
    b6ea:	33 e0       	ldi	r19, 0x03	; 3
    b6ec:	3f 93       	push	r19
    b6ee:	2f 93       	push	r18
    b6f0:	9f 93       	push	r25
    b6f2:	8f 93       	push	r24
    b6f4:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
    b6f8:	00 e0       	ldi	r16, 0x00	; 0
    b6fa:	20 e0       	ldi	r18, 0x00	; 0
    b6fc:	40 e0       	ldi	r20, 0x00	; 0
    b6fe:	60 e0       	ldi	r22, 0x00	; 0
    b700:	8c e1       	ldi	r24, 0x1C	; 28
    b702:	9b e0       	ldi	r25, 0x0B	; 11
    b704:	0e 94 ba 39 	call	0x7374	; 0x7374 <IP_compare_Const>
    b708:	0f b6       	in	r0, 0x3f	; 63
    b70a:	f8 94       	cli
    b70c:	de bf       	out	0x3e, r29	; 62
    b70e:	0f be       	out	0x3f, r0	; 63
    b710:	cd bf       	out	0x3d, r28	; 61
    b712:	81 11       	cpse	r24, r1
    b714:	03 c0       	rjmp	.+6      	; 0xb71c <GSM_Cycle+0x6d2>
				/*	if(GSM_MultiCon) GSM_State++;
					else GSM_State = GSM_SEND_CIPSERVER;*/
					GSM_State=GSM_SEND_CIPSTART_TCP;
    b716:	82 e2       	ldi	r24, 0x22	; 34
    b718:	80 93 27 06 	sts	0x0627, r24
				}
				TempNum=0;	//
    b71c:	10 92 e7 03 	sts	0x03E7, r1
    b720:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    b724:	80 91 08 01 	lds	r24, 0x0108
    b728:	80 fd       	sbrc	r24, 0
    b72a:	02 c0       	rjmp	.+4      	; 0xb730 <GSM_Cycle+0x6e6>
    b72c:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				GSMTxSz = strlen_P(AT_CIPSTART_TCP);
    b730:	82 e1       	ldi	r24, 0x12	; 18
    b732:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSTART_TCP);
    b736:	8c eb       	ldi	r24, 0xBC	; 188
    b738:	9d e4       	ldi	r25, 0x4D	; 77
    b73a:	9f 93       	push	r25
    b73c:	8f 93       	push	r24
    b73e:	09 e3       	ldi	r16, 0x39	; 57
    b740:	1c e0       	ldi	r17, 0x0C	; 12
    b742:	1f 93       	push	r17
    b744:	0f 93       	push	r16
    b746:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
    b74a:	82 e2       	ldi	r24, 0x22	; 34
    b74c:	91 e0       	ldi	r25, 0x01	; 1
    b74e:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    b752:	68 2e       	mov	r6, r24
    b754:	59 2e       	mov	r5, r25
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b756:	85 e3       	ldi	r24, 0x35	; 53
    b758:	91 e0       	ldi	r25, 0x01	; 1
    b75a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    b75e:	78 2e       	mov	r7, r24
    b760:	84 e3       	ldi	r24, 0x34	; 52
    b762:	91 e0       	ldi	r25, 0x01	; 1
    b764:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    b768:	88 2e       	mov	r8, r24
    b76a:	83 e3       	ldi	r24, 0x33	; 51
    b76c:	91 e0       	ldi	r25, 0x01	; 1
    b76e:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    b772:	98 2e       	mov	r9, r24
    b774:	82 e3       	ldi	r24, 0x32	; 50
    b776:	91 e0       	ldi	r25, 0x01	; 1
    b778:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
				
				sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2),
    b77c:	90 91 57 09 	lds	r25, 0x0957
    b780:	5f 92       	push	r5
    b782:	6f 92       	push	r6
    b784:	1f 92       	push	r1
    b786:	7f 92       	push	r7
    b788:	1f 92       	push	r1
    b78a:	8f 92       	push	r8
    b78c:	1f 92       	push	r1
    b78e:	9f 92       	push	r9
    b790:	1f 92       	push	r1
    b792:	8f 93       	push	r24
    b794:	27 eb       	ldi	r18, 0xB7	; 183
    b796:	31 e0       	ldi	r19, 0x01	; 1
    b798:	3f 93       	push	r19
    b79a:	2f 93       	push	r18
    b79c:	89 2f       	mov	r24, r25
    b79e:	90 e0       	ldi	r25, 0x00	; 0
    b7a0:	87 5c       	subi	r24, 0xC7	; 199
    b7a2:	93 4f       	sbci	r25, 0xF3	; 243
    b7a4:	9f 93       	push	r25
    b7a6:	8f 93       	push	r24
    b7a8:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
				(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
				GSMTxSz = strlen(GSM_TxStr);
    b7ac:	f8 01       	movw	r30, r16
    b7ae:	01 90       	ld	r0, Z+
    b7b0:	00 20       	and	r0, r0
    b7b2:	e9 f7       	brne	.-6      	; 0xb7ae <GSM_Cycle+0x764>
    b7b4:	31 97       	sbiw	r30, 0x01	; 1
    b7b6:	e9 53       	subi	r30, 0x39	; 57
    b7b8:	fc 40       	sbci	r31, 0x0C	; 12
    b7ba:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    b7be:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    b7c2:	68 ee       	ldi	r22, 0xE8	; 232
    b7c4:	73 e0       	ldi	r23, 0x03	; 3
    b7c6:	80 91 5a 02 	lds	r24, 0x025A
    b7ca:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State=GSM_WAIT_CIPSTART_TCP_OK;
    b7ce:	83 e2       	ldi	r24, 0x23	; 35
    b7d0:	80 93 27 06 	sts	0x0627, r24
    b7d4:	0f b6       	in	r0, 0x3f	; 63
    b7d6:	f8 94       	cli
    b7d8:	de bf       	out	0x3e, r29	; 62
    b7da:	0f be       	out	0x3f, r0	; 63
    b7dc:	cd bf       	out	0x3d, r28	; 61
    b7de:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}		
			break;
		case GSM_WAIT_CIPSTART_TCP_OK:
	
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_WAIT_CIPSTART_TCP_CONNECT;
    b7e2:	68 e5       	ldi	r22, 0x58	; 88
    b7e4:	8a e0       	ldi	r24, 0x0A	; 10
    b7e6:	9f e4       	ldi	r25, 0x4F	; 79
    b7e8:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b7ec:	88 23       	and	r24, r24
    b7ee:	11 f4       	brne	.+4      	; 0xb7f4 <GSM_Cycle+0x7aa>
    b7f0:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b7f4:	84 e2       	ldi	r24, 0x24	; 36
    b7f6:	80 93 27 06 	sts	0x0627, r24
    b7fa:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			if(GetStringFromFIFO()){
			SetDigOut(2);*/
			/*	char RightAnswer[sizeof(RESP_CONNECT)];
				strcpy_P(RightAnswer, RESP_CONNECT);*/
				//RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b7fe:	68 e5       	ldi	r22, 0x58	; 88
    b800:	82 e0       	ldi	r24, 0x02	; 2
    b802:	9f e4       	ldi	r25, 0x4F	; 79
    b804:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b808:	88 23       	and	r24, r24
    b80a:	11 f4       	brne	.+4      	; 0xb810 <GSM_Cycle+0x7c6>
    b80c:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				/*	if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
					else GSM_State = GSM_SEND_CIPSTART;*/
					GSM_State = GSM_SEND_IDENTIFICATION;
    b810:	85 e2       	ldi	r24, 0x25	; 37
    b812:	80 93 27 06 	sts	0x0627, r24
    b816:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				}
		//	}
			break;
		case GSM_SEND_IDENTIFICATION:
			if(GSM_Flag & (1<<flg_TxCStr)){
    b81a:	80 91 08 01 	lds	r24, 0x0108
    b81e:	80 fd       	sbrc	r24, 0
    b820:	02 c0       	rjmp	.+4      	; 0xb826 <GSM_Cycle+0x7dc>
    b822:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b826:	82 e5       	ldi	r24, 0x52	; 82
    b828:	91 e0       	ldi	r25, 0x01	; 1
    b82a:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
				GSMTxSz = sprintf(GSM_TxStr, "Modem=%u",(unsigned int)erw(&SerialNum));
    b82e:	9f 93       	push	r25
    b830:	8f 93       	push	r24
    b832:	8b ec       	ldi	r24, 0xCB	; 203
    b834:	91 e0       	ldi	r25, 0x01	; 1
    b836:	9f 93       	push	r25
    b838:	8f 93       	push	r24
    b83a:	89 e3       	ldi	r24, 0x39	; 57
    b83c:	9c e0       	ldi	r25, 0x0C	; 12
    b83e:	9f 93       	push	r25
    b840:	8f 93       	push	r24
    b842:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    b846:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b84a:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b84e:	64 ef       	ldi	r22, 0xF4	; 244
    b850:	71 e0       	ldi	r23, 0x01	; 1
    b852:	80 91 5a 02 	lds	r24, 0x025A
    b856:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State++;
    b85a:	80 91 27 06 	lds	r24, 0x0627
    b85e:	8f 5f       	subi	r24, 0xFF	; 255
    b860:	80 93 27 06 	sts	0x0627, r24
    b864:	0f 90       	pop	r0
    b866:	0f 90       	pop	r0
    b868:	0f 90       	pop	r0
    b86a:	0f 90       	pop	r0
    b86c:	0f 90       	pop	r0
    b86e:	0f 90       	pop	r0
    b870:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_WAIT_IDENTIFICATION_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1))
    b874:	68 e5       	ldi	r22, 0x58	; 88
    b876:	8a e0       	ldi	r24, 0x0A	; 10
    b878:	9f e4       	ldi	r25, 0x4F	; 79
    b87a:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b87e:	88 23       	and	r24, r24
    b880:	11 f4       	brne	.+4      	; 0xb886 <GSM_Cycle+0x83c>
    b882:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			{
				EM_InitFIFO(); 
    b886:	0e 94 e1 4a 	call	0x95c2	; 0x95c2 <EM_InitFIFO>
				InitFIFO();
    b88a:	0e 94 fb 39 	call	0x73f6	; 0x73f6 <InitFIFO>
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b88e:	80 91 05 06 	lds	r24, 0x0605
    b892:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State=GSM_ProtocolMode;
    b896:	8f e5       	ldi	r24, 0x5F	; 95
    b898:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b89c:	60 91 0b 01 	lds	r22, 0x010B
    b8a0:	70 91 0c 01 	lds	r23, 0x010C
    b8a4:	80 91 40 0d 	lds	r24, 0x0D40
    b8a8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b8ac:	60 91 09 01 	lds	r22, 0x0109
    b8b0:	70 91 0a 01 	lds	r23, 0x010A
    b8b4:	80 91 0b 06 	lds	r24, 0x060B
    b8b8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    b8bc:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_SEND_CIPSTATUS:
			GSM_Execute_Command(AT_CIPSTATUS, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_STATE_CONNECT_OK;			
    b8c0:	64 ef       	ldi	r22, 0xF4	; 244
    b8c2:	71 e0       	ldi	r23, 0x01	; 1
    b8c4:	80 e9       	ldi	r24, 0x90	; 144
    b8c6:	9d e4       	ldi	r25, 0x4D	; 77
    b8c8:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b8cc:	88 e2       	ldi	r24, 0x28	; 40
    b8ce:	80 93 27 06 	sts	0x0627, r24
    b8d2:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_STATE_CONNECT_OK:
			if(GSM_Wait_Response_P(RESP_STATE_CONNECT_OK, GSM_ReStart1)){
    b8d6:	68 e5       	ldi	r22, 0x58	; 88
    b8d8:	80 e9       	ldi	r24, 0x90	; 144
    b8da:	9e e4       	ldi	r25, 0x4E	; 78
    b8dc:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b8e0:	88 23       	and	r24, r24
    b8e2:	11 f4       	brne	.+4      	; 0xb8e8 <GSM_Cycle+0x89e>
    b8e4:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				GSM_State = GSM_SEND_ATO;
    b8e8:	89 e2       	ldi	r24, 0x29	; 41
    b8ea:	80 93 27 06 	sts	0x0627, r24
    b8ee:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_SEND_ATO:
			GSM_Execute_Command(AT_ATO, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_ATO_CONNECT;
    b8f2:	64 ef       	ldi	r22, 0xF4	; 244
    b8f4:	71 e0       	ldi	r23, 0x01	; 1
    b8f6:	8c e8       	ldi	r24, 0x8C	; 140
    b8f8:	9d e4       	ldi	r25, 0x4D	; 77
    b8fa:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    b8fe:	8a e2       	ldi	r24, 0x2A	; 42
    b900:	80 93 27 06 	sts	0x0627, r24
    b904:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_ATO_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b908:	68 e5       	ldi	r22, 0x58	; 88
    b90a:	82 e0       	ldi	r24, 0x02	; 2
    b90c:	9f e4       	ldi	r25, 0x4F	; 79
    b90e:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    b912:	88 23       	and	r24, r24
    b914:	11 f4       	brne	.+4      	; 0xb91a <GSM_Cycle+0x8d0>
    b916:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
				switch(Transparent_Application_state){
    b91a:	80 91 52 09 	lds	r24, 0x0952
    b91e:	82 30       	cpi	r24, 0x02	; 2
    b920:	49 f0       	breq	.+18     	; 0xb934 <GSM_Cycle+0x8ea>
    b922:	83 30       	cpi	r24, 0x03	; 3
    b924:	b9 f4       	brne	.+46     	; 0xb954 <GSM_Cycle+0x90a>
					case CHECK_CONNECTION_STATE:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b926:	60 91 0b 01 	lds	r22, 0x010B
    b92a:	70 91 0c 01 	lds	r23, 0x010C
    b92e:	80 91 40 0d 	lds	r24, 0x0D40
    b932:	0e c0       	rjmp	.+28     	; 0xb950 <GSM_Cycle+0x906>
						break;
					case RECONNECT:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b934:	60 91 0b 01 	lds	r22, 0x010B
    b938:	70 91 0c 01 	lds	r23, 0x010C
    b93c:	80 91 40 0d 	lds	r24, 0x0D40
    b940:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
						StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b944:	60 91 09 01 	lds	r22, 0x0109
    b948:	70 91 0a 01 	lds	r23, 0x010A
    b94c:	80 91 0b 06 	lds	r24, 0x060B
    b950:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
						break;
					default:break;
				}
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b954:	80 91 05 06 	lds	r24, 0x0605
    b958:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State = GSM_ProtocolMode;
    b95c:	8f e5       	ldi	r24, 0x5F	; 95
    b95e:	80 93 27 06 	sts	0x0627, r24
    b962:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    b966:	10 91 e7 03 	lds	r17, 0x03E7
    b96a:	34 e0       	ldi	r19, 0x04	; 4
    b96c:	13 9f       	mul	r17, r19
    b96e:	c0 01       	movw	r24, r0
    b970:	11 24       	eor	r1, r1
    b972:	00 e0       	ldi	r16, 0x00	; 0
    b974:	20 e0       	ldi	r18, 0x00	; 0
    b976:	40 e0       	ldi	r20, 0x00	; 0
    b978:	60 e0       	ldi	r22, 0x00	; 0
    b97a:	8e 5b       	subi	r24, 0xBE	; 190
    b97c:	9e 4f       	sbci	r25, 0xFE	; 254
    b97e:	0e 94 cb 39 	call	0x7396	; 0x7396 <IP_E_compare_Const>
    b982:	88 23       	and	r24, r24
    b984:	61 f0       	breq	.+24     	; 0xb99e <GSM_Cycle+0x954>
				TempNum++;
    b986:	1f 5f       	subi	r17, 0xFF	; 255
    b988:	10 93 e7 03 	sts	0x03E7, r17
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    b98c:	14 30       	cpi	r17, 0x04	; 4
    b98e:	10 f4       	brcc	.+4      	; 0xb994 <GSM_Cycle+0x94a>
    b990:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
    b994:	81 e3       	ldi	r24, 0x31	; 49
    b996:	80 93 27 06 	sts	0x0627, r24
    b99a:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    b99e:	80 91 08 01 	lds	r24, 0x0108
    b9a2:	80 fd       	sbrc	r24, 0
    b9a4:	02 c0       	rjmp	.+4      	; 0xb9aa <GSM_Cycle+0x960>
    b9a6:	0c 94 e1 64 	jmp	0xc9c2	; 0xc9c2 <GSM_Cycle+0x1978>
					GSMTxSz = strlen_P(AT_CIPSTART);
    b9aa:	84 e1       	ldi	r24, 0x14	; 20
    b9ac:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    b9b0:	8f ec       	ldi	r24, 0xCF	; 207
    b9b2:	9d e4       	ldi	r25, 0x4D	; 77
    b9b4:	9f 93       	push	r25
    b9b6:	8f 93       	push	r24
    b9b8:	89 e3       	ldi	r24, 0x39	; 57
    b9ba:	88 2e       	mov	r8, r24
    b9bc:	8c e0       	ldi	r24, 0x0C	; 12
    b9be:	98 2e       	mov	r9, r24
    b9c0:	9f 92       	push	r9
    b9c2:	8f 92       	push	r8
    b9c4:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    b9c8:	00 91 e7 03 	lds	r16, 0x03E7
    b9cc:	80 e3       	ldi	r24, 0x30	; 48
    b9ce:	80 0f       	add	r24, r16
    b9d0:	80 93 45 0c 	sts	0x0C45, r24
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
    b9d4:	10 e0       	ldi	r17, 0x00	; 0
    b9d6:	c8 01       	movw	r24, r16
    b9d8:	88 0f       	add	r24, r24
    b9da:	99 1f       	adc	r25, r25
    b9dc:	86 5d       	subi	r24, 0xD6	; 214
    b9de:	9e 4f       	sbci	r25, 0xFE	; 254
    b9e0:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
    b9e4:	48 2e       	mov	r4, r24
    b9e6:	39 2e       	mov	r3, r25
    b9e8:	00 0f       	add	r16, r16
    b9ea:	11 1f       	adc	r17, r17
    b9ec:	00 0f       	add	r16, r16
    b9ee:	11 1f       	adc	r17, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b9f0:	c8 01       	movw	r24, r16
    b9f2:	8b 5b       	subi	r24, 0xBB	; 187
    b9f4:	9e 4f       	sbci	r25, 0xFE	; 254
    b9f6:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    b9fa:	58 2e       	mov	r5, r24
    b9fc:	c8 01       	movw	r24, r16
    b9fe:	8c 5b       	subi	r24, 0xBC	; 188
    ba00:	9e 4f       	sbci	r25, 0xFE	; 254
    ba02:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    ba06:	68 2e       	mov	r6, r24
    ba08:	c8 01       	movw	r24, r16
    ba0a:	8d 5b       	subi	r24, 0xBD	; 189
    ba0c:	9e 4f       	sbci	r25, 0xFE	; 254
    ba0e:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    ba12:	78 2e       	mov	r7, r24
    ba14:	c8 01       	movw	r24, r16
    ba16:	8e 5b       	subi	r24, 0xBE	; 190
    ba18:	9e 4f       	sbci	r25, 0xFE	; 254
    ba1a:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
					GSMTxSz = strlen_P(AT_CIPSTART);
					sprintf_P(GSM_TxStr, AT_CIPSTART);
					GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    ba1e:	90 91 57 09 	lds	r25, 0x0957
    ba22:	3f 92       	push	r3
    ba24:	4f 92       	push	r4
    ba26:	1f 92       	push	r1
    ba28:	5f 92       	push	r5
    ba2a:	1f 92       	push	r1
    ba2c:	6f 92       	push	r6
    ba2e:	1f 92       	push	r1
    ba30:	7f 92       	push	r7
    ba32:	1f 92       	push	r1
    ba34:	8f 93       	push	r24
    ba36:	27 eb       	ldi	r18, 0xB7	; 183
    ba38:	31 e0       	ldi	r19, 0x01	; 1
    ba3a:	3f 93       	push	r19
    ba3c:	2f 93       	push	r18
    ba3e:	89 2f       	mov	r24, r25
    ba40:	90 e0       	ldi	r25, 0x00	; 0
    ba42:	87 5c       	subi	r24, 0xC7	; 199
    ba44:	93 4f       	sbci	r25, 0xF3	; 243
    ba46:	9f 93       	push	r25
    ba48:	8f 93       	push	r24
    ba4a:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    ba4e:	f4 01       	movw	r30, r8
    ba50:	01 90       	ld	r0, Z+
    ba52:	00 20       	and	r0, r0
    ba54:	e9 f7       	brne	.-6      	; 0xba50 <GSM_Cycle+0xa06>
    ba56:	31 97       	sbiw	r30, 0x01	; 1
    ba58:	e9 53       	subi	r30, 0x39	; 57
    ba5a:	fc 40       	sbci	r31, 0x0C	; 12
    ba5c:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    ba60:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    ba64:	64 ef       	ldi	r22, 0xF4	; 244
    ba66:	71 e0       	ldi	r23, 0x01	; 1
    ba68:	80 91 5a 02 	lds	r24, 0x025A
    ba6c:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					GSM_State++;
    ba70:	80 91 27 06 	lds	r24, 0x0627
    ba74:	8f 5f       	subi	r24, 0xFF	; 255
    ba76:	80 93 27 06 	sts	0x0627, r24
    ba7a:	0f b6       	in	r0, 0x3f	; 63
    ba7c:	f8 94       	cli
    ba7e:	de bf       	out	0x3e, r29	; 62
    ba80:	0f be       	out	0x3f, r0	; 63
    ba82:	cd bf       	out	0x3d, r28	; 61
    ba84:	9e c7       	rjmp	.+3900   	; 0xc9c2 <GSM_Cycle+0x1978>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ba86:	68 e5       	ldi	r22, 0x58	; 88
    ba88:	8a e0       	ldi	r24, 0x0A	; 10
    ba8a:	9f e4       	ldi	r25, 0x4F	; 79
    ba8c:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    ba90:	88 23       	and	r24, r24
    ba92:	09 f4       	brne	.+2      	; 0xba96 <GSM_Cycle+0xa4c>
    ba94:	96 c7       	rjmp	.+3884   	; 0xc9c2 <GSM_Cycle+0x1978>
    ba96:	80 91 27 06 	lds	r24, 0x0627
    ba9a:	8f 5f       	subi	r24, 0xFF	; 255
    ba9c:	80 93 27 06 	sts	0x0627, r24
    baa0:	90 c7       	rjmp	.+3872   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    baa2:	80 91 5a 02 	lds	r24, 0x025A
    baa6:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    baaa:	88 23       	and	r24, r24
    baac:	19 f0       	breq	.+6      	; 0xbab4 <GSM_Cycle+0xa6a>
    baae:	88 e5       	ldi	r24, 0x58	; 88
    bab0:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    bab4:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    bab8:	88 23       	and	r24, r24
    baba:	09 f4       	brne	.+2      	; 0xbabe <GSM_Cycle+0xa74>
    babc:	82 c7       	rjmp	.+3844   	; 0xc9c2 <GSM_Cycle+0x1978>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    babe:	64 ef       	ldi	r22, 0xF4	; 244
    bac0:	7e e4       	ldi	r23, 0x4E	; 78
    bac2:	ce 01       	movw	r24, r28
    bac4:	01 96       	adiw	r24, 0x01	; 1
    bac6:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    baca:	10 91 e7 03 	lds	r17, 0x03E7
    bace:	80 e3       	ldi	r24, 0x30	; 48
    bad0:	81 0f       	add	r24, r17
    bad2:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bad4:	68 e5       	ldi	r22, 0x58	; 88
    bad6:	ce 01       	movw	r24, r28
    bad8:	01 96       	adiw	r24, 0x01	; 1
    bada:	0e 94 15 3b 	call	0x762a	; 0x762a <GSM_Wait_Response>
    bade:	88 23       	and	r24, r24
    bae0:	09 f4       	brne	.+2      	; 0xbae4 <GSM_Cycle+0xa9a>
    bae2:	6f c7       	rjmp	.+3806   	; 0xc9c2 <GSM_Cycle+0x1978>
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    bae4:	1f 5f       	subi	r17, 0xFF	; 255
    bae6:	10 93 e7 03 	sts	0x03E7, r17
    baea:	14 30       	cpi	r17, 0x04	; 4
    baec:	20 f0       	brcs	.+8      	; 0xbaf6 <GSM_Cycle+0xaac>
    baee:	81 e3       	ldi	r24, 0x31	; 49
    baf0:	80 93 27 06 	sts	0x0627, r24
    baf4:	66 c7       	rjmp	.+3788   	; 0xc9c2 <GSM_Cycle+0x1978>
					else GSM_State = GSM_SEND_CIPSTART;
    baf6:	8b e2       	ldi	r24, 0x2B	; 43
    baf8:	80 93 27 06 	sts	0x0627, r24
    bafc:	62 c7       	rjmp	.+3780   	; 0xc9c2 <GSM_Cycle+0x1978>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    bafe:	80 91 08 01 	lds	r24, 0x0108
    bb02:	80 ff       	sbrs	r24, 0
    bb04:	5e c7       	rjmp	.+3772   	; 0xc9c2 <GSM_Cycle+0x1978>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    bb06:	8f e0       	ldi	r24, 0x0F	; 15
    bb08:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    bb0c:	8c ea       	ldi	r24, 0xAC	; 172
    bb0e:	9d e4       	ldi	r25, 0x4D	; 77
    bb10:	9f 93       	push	r25
    bb12:	8f 93       	push	r24
    bb14:	09 e3       	ldi	r16, 0x39	; 57
    bb16:	1c e0       	ldi	r17, 0x0C	; 12
    bb18:	1f 93       	push	r17
    bb1a:	0f 93       	push	r16
    bb1c:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    bb20:	80 e2       	ldi	r24, 0x20	; 32
    bb22:	91 e0       	ldi	r25, 0x01	; 1
    bb24:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    bb28:	40 91 57 09 	lds	r20, 0x0957
    bb2c:	9f 93       	push	r25
    bb2e:	8f 93       	push	r24
    bb30:	27 ed       	ldi	r18, 0xD7	; 215
    bb32:	31 e0       	ldi	r19, 0x01	; 1
    bb34:	3f 93       	push	r19
    bb36:	2f 93       	push	r18
    bb38:	84 2f       	mov	r24, r20
    bb3a:	90 e0       	ldi	r25, 0x00	; 0
    bb3c:	87 5c       	subi	r24, 0xC7	; 199
    bb3e:	93 4f       	sbci	r25, 0xF3	; 243
    bb40:	9f 93       	push	r25
    bb42:	8f 93       	push	r24
    bb44:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    bb48:	f8 01       	movw	r30, r16
    bb4a:	01 90       	ld	r0, Z+
    bb4c:	00 20       	and	r0, r0
    bb4e:	e9 f7       	brne	.-6      	; 0xbb4a <GSM_Cycle+0xb00>
    bb50:	31 97       	sbiw	r30, 0x01	; 1
    bb52:	e9 53       	subi	r30, 0x39	; 57
    bb54:	fc 40       	sbci	r31, 0x0C	; 12
    bb56:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    bb5a:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bb5e:	64 ef       	ldi	r22, 0xF4	; 244
    bb60:	71 e0       	ldi	r23, 0x01	; 1
    bb62:	80 91 5a 02 	lds	r24, 0x025A
    bb66:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State++;
    bb6a:	80 91 27 06 	lds	r24, 0x0627
    bb6e:	8f 5f       	subi	r24, 0xFF	; 255
    bb70:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    bb74:	6f ef       	ldi	r22, 0xFF	; 255
    bb76:	7f ef       	ldi	r23, 0xFF	; 255
    bb78:	80 91 59 02 	lds	r24, 0x0259
    bb7c:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    bb80:	0f b6       	in	r0, 0x3f	; 63
    bb82:	f8 94       	cli
    bb84:	de bf       	out	0x3e, r29	; 62
    bb86:	0f be       	out	0x3f, r0	; 63
    bb88:	cd bf       	out	0x3d, r28	; 61
    bb8a:	1b c7       	rjmp	.+3638   	; 0xc9c2 <GSM_Cycle+0x1978>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    bb8c:	68 e5       	ldi	r22, 0x58	; 88
    bb8e:	8a e0       	ldi	r24, 0x0A	; 10
    bb90:	9f e4       	ldi	r25, 0x4F	; 79
    bb92:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    bb96:	88 23       	and	r24, r24
    bb98:	09 f4       	brne	.+2      	; 0xbb9c <GSM_Cycle+0xb52>
    bb9a:	13 c7       	rjmp	.+3622   	; 0xc9c2 <GSM_Cycle+0x1978>
    bb9c:	80 91 27 06 	lds	r24, 0x0627
    bba0:	8f 5f       	subi	r24, 0xFF	; 255
    bba2:	80 93 27 06 	sts	0x0627, r24
    bba6:	0d c7       	rjmp	.+3610   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    bba8:	68 e5       	ldi	r22, 0x58	; 88
    bbaa:	8a ee       	ldi	r24, 0xEA	; 234
    bbac:	9e e4       	ldi	r25, 0x4E	; 78
    bbae:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    bbb2:	88 23       	and	r24, r24
    bbb4:	09 f4       	brne	.+2      	; 0xbbb8 <GSM_Cycle+0xb6e>
    bbb6:	05 c7       	rjmp	.+3594   	; 0xc9c2 <GSM_Cycle+0x1978>
    bbb8:	81 e3       	ldi	r24, 0x31	; 49
    bbba:	80 93 27 06 	sts	0x0627, r24
    bbbe:	01 c7       	rjmp	.+3586   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    bbc0:	80 91 7e 09 	lds	r24, 0x097E
    bbc4:	81 11       	cpse	r24, r1
    bbc6:	3c c0       	rjmp	.+120    	; 0xbc40 <GSM_Cycle+0xbf6>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    bbc8:	80 91 43 09 	lds	r24, 0x0943
    bbcc:	88 23       	and	r24, r24
    bbce:	41 f1       	breq	.+80     	; 0xbc20 <GSM_Cycle+0xbd6>
					if(GSM_MultiCon == 1){
    bbd0:	80 91 4b 0e 	lds	r24, 0x0E4B
    bbd4:	81 30       	cpi	r24, 0x01	; 1
    bbd6:	e9 f4       	brne	.+58     	; 0xbc12 <GSM_Cycle+0xbc8>
						if(GPRS_Protocol_Out == UDP){
    bbd8:	80 91 7c 09 	lds	r24, 0x097C
    bbdc:	81 11       	cpse	r24, r1
    bbde:	09 c0       	rjmp	.+18     	; 0xbbf2 <GSM_Cycle+0xba8>
							TempNum = 0;
    bbe0:	10 92 e7 03 	sts	0x03E7, r1
							GSM_State = GSM_SEND_CIPSEND;
    bbe4:	83 e3       	ldi	r24, 0x33	; 51
    bbe6:	80 93 27 06 	sts	0x0627, r24
							ResetTimer16(TD_GSM);
    bbea:	80 91 5a 02 	lds	r24, 0x025A
    bbee:	0e 94 b5 2c 	call	0x596a	; 0x596a <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    bbf2:	80 91 7c 09 	lds	r24, 0x097C
    bbf6:	81 30       	cpi	r24, 0x01	; 1
    bbf8:	09 f0       	breq	.+2      	; 0xbbfc <GSM_Cycle+0xbb2>
    bbfa:	e3 c6       	rjmp	.+3526   	; 0xc9c2 <GSM_Cycle+0x1978>
							if(GSM_ActiveConnection == NO_CONNECTION){
    bbfc:	80 91 07 01 	lds	r24, 0x0107
    bc00:	8f 3f       	cpi	r24, 0xFF	; 255
    bc02:	19 f4       	brne	.+6      	; 0xbc0a <GSM_Cycle+0xbc0>
								GPRS_FlgSz_Out = 0;
    bc04:	10 92 43 09 	sts	0x0943, r1
    bc08:	dc c6       	rjmp	.+3512   	; 0xc9c2 <GSM_Cycle+0x1978>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    bc0a:	83 e3       	ldi	r24, 0x33	; 51
    bc0c:	80 93 27 06 	sts	0x0627, r24
    bc10:	d8 c6       	rjmp	.+3504   	; 0xc9c2 <GSM_Cycle+0x1978>
						}
					}
					else{
						GSM_MultiCon = 1;
    bc12:	81 e0       	ldi	r24, 0x01	; 1
    bc14:	80 93 4b 0e 	sts	0x0E4B, r24
						GSM_State = GSM_CIPSHUT;
    bc18:	80 e5       	ldi	r24, 0x50	; 80
    bc1a:	80 93 27 06 	sts	0x0627, r24
    bc1e:	d1 c6       	rjmp	.+3490   	; 0xc9c2 <GSM_Cycle+0x1978>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    bc20:	80 91 67 09 	lds	r24, 0x0967
    bc24:	88 23       	and	r24, r24
    bc26:	61 f0       	breq	.+24     	; 0xbc40 <GSM_Cycle+0xbf6>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bc28:	80 e6       	ldi	r24, 0x60	; 96
    bc2a:	90 e0       	ldi	r25, 0x00	; 0
    bc2c:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    bc30:	88 23       	and	r24, r24
    bc32:	31 f0       	breq	.+12     	; 0xbc40 <GSM_Cycle+0xbf6>
					GSM_State = GSM_SEND_CMGS;
    bc34:	88 e3       	ldi	r24, 0x38	; 56
    bc36:	80 93 27 06 	sts	0x0627, r24
					TempNum = 0;
    bc3a:	10 92 e7 03 	sts	0x03E7, r1
    bc3e:	c1 c6       	rjmp	.+3458   	; 0xc9c2 <GSM_Cycle+0x1978>
					break;
				}
			}

			if(GetStringFromFIFO()){
    bc40:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    bc44:	88 23       	and	r24, r24
    bc46:	31 f0       	breq	.+12     	; 0xbc54 <GSM_Cycle+0xc0a>
				GSM_State = GSM_AnalyzeURC;
    bc48:	82 e3       	ldi	r24, 0x32	; 50
    bc4a:	80 93 27 06 	sts	0x0627, r24
				TempNum = 0;
    bc4e:	10 92 e7 03 	sts	0x03E7, r1
    bc52:	b7 c6       	rjmp	.+3438   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			if(!IsWebSession()){
    bc54:	80 91 7e 09 	lds	r24, 0x097E
    bc58:	81 11       	cpse	r24, r1
    bc5a:	b3 c6       	rjmp	.+3430   	; 0xc9c2 <GSM_Cycle+0x1978>
				if(Timer16Stopp(TD_TCP_Connect) ){
    bc5c:	80 91 59 02 	lds	r24, 0x0259
    bc60:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    bc64:	88 23       	and	r24, r24
    bc66:	21 f0       	breq	.+8      	; 0xbc70 <GSM_Cycle+0xc26>
					GSM_State = GSM_CIPSHUT;
    bc68:	80 e5       	ldi	r24, 0x50	; 80
    bc6a:	80 93 27 06 	sts	0x0627, r24
    bc6e:	a9 c6       	rjmp	.+3410   	; 0xc9c2 <GSM_Cycle+0x1978>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    bc70:	80 91 58 02 	lds	r24, 0x0258
    bc74:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    bc78:	88 23       	and	r24, r24
    bc7a:	21 f0       	breq	.+8      	; 0xbc84 <GSM_Cycle+0xc3a>
					GSM_State = GSM_SEND_CSQ;
    bc7c:	8d e5       	ldi	r24, 0x5D	; 93
    bc7e:	80 93 27 06 	sts	0x0627, r24
    bc82:	9f c6       	rjmp	.+3390   	; 0xc9c2 <GSM_Cycle+0x1978>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    bc84:	80 91 57 02 	lds	r24, 0x0257
    bc88:	0e 94 8a 2c 	call	0x5914	; 0x5914 <Timer32Stopp>
    bc8c:	88 23       	and	r24, r24
    bc8e:	09 f4       	brne	.+2      	; 0xbc92 <GSM_Cycle+0xc48>
    bc90:	98 c6       	rjmp	.+3376   	; 0xc9c2 <GSM_Cycle+0x1978>
					GSM_State = GSM_ReStart1;
    bc92:	88 e5       	ldi	r24, 0x58	; 88
    bc94:	80 93 27 06 	sts	0x0627, r24
    bc98:	94 c6       	rjmp	.+3368   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    bc9a:	63 e4       	ldi	r22, 0x43	; 67
    bc9c:	7f e4       	ldi	r23, 0x4F	; 79
    bc9e:	89 e8       	ldi	r24, 0x89	; 137
    bca0:	99 e0       	ldi	r25, 0x09	; 9
    bca2:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bca6:	89 2b       	or	r24, r25
    bca8:	21 f0       	breq	.+8      	; 0xbcb2 <GSM_Cycle+0xc68>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    bcaa:	8c e3       	ldi	r24, 0x3C	; 60
    bcac:	80 93 27 06 	sts	0x0627, r24
    bcb0:	88 c6       	rjmp	.+3344   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    bcb2:	6b e3       	ldi	r22, 0x3B	; 59
    bcb4:	7f e4       	ldi	r23, 0x4F	; 79
    bcb6:	89 e8       	ldi	r24, 0x89	; 137
    bcb8:	99 e0       	ldi	r25, 0x09	; 9
    bcba:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bcbe:	89 2b       	or	r24, r25
    bcc0:	61 f0       	breq	.+24     	; 0xbcda <GSM_Cycle+0xc90>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    bcc2:	68 ee       	ldi	r22, 0xE8	; 232
    bcc4:	73 e0       	ldi	r23, 0x03	; 3
    bcc6:	80 91 59 02 	lds	r24, 0x0259
    bcca:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_CSD = 0;
    bcce:	10 92 4b 09 	sts	0x094B, r1
				GSM_State = GSM_ProtocolMode;
    bcd2:	8f e5       	ldi	r24, 0x5F	; 95
    bcd4:	80 93 27 06 	sts	0x0627, r24
    bcd8:	74 c6       	rjmp	.+3304   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    bcda:	68 e1       	ldi	r22, 0x18	; 24
    bcdc:	7f e4       	ldi	r23, 0x4F	; 79
    bcde:	89 e8       	ldi	r24, 0x89	; 137
    bce0:	99 e0       	ldi	r25, 0x09	; 9
    bce2:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bce6:	89 2b       	or	r24, r25
    bce8:	51 f0       	breq	.+20     	; 0xbcfe <GSM_Cycle+0xcb4>
				StartTimer16(TD_GSM, 150);
    bcea:	66 e9       	ldi	r22, 0x96	; 150
    bcec:	70 e0       	ldi	r23, 0x00	; 0
    bcee:	80 91 5a 02 	lds	r24, 0x025A
    bcf2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    bcf6:	84 e6       	ldi	r24, 0x64	; 100
    bcf8:	80 93 27 06 	sts	0x0627, r24
    bcfc:	62 c6       	rjmp	.+3268   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    bcfe:	68 e2       	ldi	r22, 0x28	; 40
    bd00:	7f e4       	ldi	r23, 0x4F	; 79
    bd02:	89 e8       	ldi	r24, 0x89	; 137
    bd04:	99 e0       	ldi	r25, 0x09	; 9
    bd06:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bd0a:	89 2b       	or	r24, r25
    bd0c:	49 f1       	breq	.+82     	; 0xbd60 <GSM_Cycle+0xd16>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    bd0e:	87 ee       	ldi	r24, 0xE7	; 231
    bd10:	93 e0       	ldi	r25, 0x03	; 3
    bd12:	9f 93       	push	r25
    bd14:	8f 93       	push	r24
    bd16:	89 e5       	ldi	r24, 0x59	; 89
    bd18:	93 e0       	ldi	r25, 0x03	; 3
    bd1a:	9f 93       	push	r25
    bd1c:	8f 93       	push	r24
    bd1e:	89 e8       	ldi	r24, 0x89	; 137
    bd20:	99 e0       	ldi	r25, 0x09	; 9
    bd22:	9f 93       	push	r25
    bd24:	8f 93       	push	r24
    bd26:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    bd2a:	0f 90       	pop	r0
    bd2c:	0f 90       	pop	r0
    bd2e:	0f 90       	pop	r0
    bd30:	0f 90       	pop	r0
    bd32:	0f 90       	pop	r0
    bd34:	0f 90       	pop	r0
    bd36:	90 91 07 01 	lds	r25, 0x0107
    bd3a:	80 91 e7 03 	lds	r24, 0x03E7
    bd3e:	98 13       	cpse	r25, r24
    bd40:	0b c0       	rjmp	.+22     	; 0xbd58 <GSM_Cycle+0xd0e>
					GSM_ActiveConnection = NO_CONNECTION;
    bd42:	8f ef       	ldi	r24, 0xFF	; 255
    bd44:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    bd48:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    bd4c:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    bd50:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    bd54:	10 92 3d 0d 	sts	0x0D3D, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    bd58:	81 e3       	ldi	r24, 0x31	; 49
    bd5a:	80 93 27 06 	sts	0x0627, r24
    bd5e:	31 c6       	rjmp	.+3170   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    bd60:	6d e1       	ldi	r22, 0x1D	; 29
    bd62:	7f e4       	ldi	r23, 0x4F	; 79
    bd64:	89 e8       	ldi	r24, 0x89	; 137
    bd66:	99 e0       	ldi	r25, 0x09	; 9
    bd68:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bd6c:	89 2b       	or	r24, r25
    bd6e:	21 f0       	breq	.+8      	; 0xbd78 <GSM_Cycle+0xd2e>
				GSM_State = GSM_SEND_E0;
    bd70:	88 e0       	ldi	r24, 0x08	; 8
    bd72:	80 93 27 06 	sts	0x0627, r24
    bd76:	25 c6       	rjmp	.+3146   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    bd78:	61 e3       	ldi	r22, 0x31	; 49
    bd7a:	7f e4       	ldi	r23, 0x4F	; 79
    bd7c:	89 e8       	ldi	r24, 0x89	; 137
    bd7e:	99 e0       	ldi	r25, 0x09	; 9
    bd80:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bd84:	89 2b       	or	r24, r25
    bd86:	41 f0       	breq	.+16     	; 0xbd98 <GSM_Cycle+0xd4e>
    bd88:	80 91 5e 09 	lds	r24, 0x095E
    bd8c:	81 11       	cpse	r24, r1
    bd8e:	04 c0       	rjmp	.+8      	; 0xbd98 <GSM_Cycle+0xd4e>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    bd90:	8f e3       	ldi	r24, 0x3F	; 63
    bd92:	80 93 27 06 	sts	0x0627, r24
    bd96:	15 c6       	rjmp	.+3114   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    bd98:	67 eb       	ldi	r22, 0xB7	; 183
    bd9a:	7e e4       	ldi	r23, 0x4E	; 78
    bd9c:	89 e8       	ldi	r24, 0x89	; 137
    bd9e:	99 e0       	ldi	r25, 0x09	; 9
    bda0:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    bda4:	89 2b       	or	r24, r25
    bda6:	21 f0       	breq	.+8      	; 0xbdb0 <GSM_Cycle+0xd66>
				GSM_State = GSM_WAIT_CSQ;
    bda8:	8e e5       	ldi	r24, 0x5E	; 94
    bdaa:	80 93 27 06 	sts	0x0627, r24
    bdae:	09 c6       	rjmp	.+3090   	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    bdb0:	81 e3       	ldi	r24, 0x31	; 49
    bdb2:	80 93 27 06 	sts	0x0627, r24
    bdb6:	05 c6       	rjmp	.+3082   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    bdb8:	80 91 7c 09 	lds	r24, 0x097C
    bdbc:	81 11       	cpse	r24, r1
    bdbe:	74 c0       	rjmp	.+232    	; 0xbea8 <GSM_Cycle+0xe5e>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    bdc0:	10 91 e7 03 	lds	r17, 0x03E7
    bdc4:	f4 e0       	ldi	r31, 0x04	; 4
    bdc6:	1f 9f       	mul	r17, r31
    bdc8:	c0 01       	movw	r24, r0
    bdca:	11 24       	eor	r1, r1
    bdcc:	00 e0       	ldi	r16, 0x00	; 0
    bdce:	20 e0       	ldi	r18, 0x00	; 0
    bdd0:	40 e0       	ldi	r20, 0x00	; 0
    bdd2:	60 e0       	ldi	r22, 0x00	; 0
    bdd4:	8e 5b       	subi	r24, 0xBE	; 190
    bdd6:	9e 4f       	sbci	r25, 0xFE	; 254
    bdd8:	0e 94 cb 39 	call	0x7396	; 0x7396 <IP_E_compare_Const>
    bddc:	81 11       	cpse	r24, r1
    bdde:	0b c0       	rjmp	.+22     	; 0xbdf6 <GSM_Cycle+0xdac>
    bde0:	80 91 6f 08 	lds	r24, 0x086F
    bde4:	90 e0       	ldi	r25, 0x00	; 0
    bde6:	01 2e       	mov	r0, r17
    bde8:	02 c0       	rjmp	.+4      	; 0xbdee <GSM_Cycle+0xda4>
    bdea:	95 95       	asr	r25
    bdec:	87 95       	ror	r24
    bdee:	0a 94       	dec	r0
    bdf0:	e2 f7       	brpl	.-8      	; 0xbdea <GSM_Cycle+0xda0>
    bdf2:	80 ff       	sbrs	r24, 0
    bdf4:	12 c0       	rjmp	.+36     	; 0xbe1a <GSM_Cycle+0xdd0>
					TempNum++;
    bdf6:	1f 5f       	subi	r17, 0xFF	; 255
    bdf8:	10 93 e7 03 	sts	0x03E7, r17
					if(TempNum>3){
    bdfc:	14 30       	cpi	r17, 0x04	; 4
    bdfe:	08 f4       	brcc	.+2      	; 0xbe02 <GSM_Cycle+0xdb8>
    be00:	53 c0       	rjmp	.+166    	; 0xbea8 <GSM_Cycle+0xe5e>
						StartTimer16(TD_GSM,150);
    be02:	66 e9       	ldi	r22, 0x96	; 150
    be04:	70 e0       	ldi	r23, 0x00	; 0
    be06:	80 91 5a 02 	lds	r24, 0x025A
    be0a:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    be0e:	87 e3       	ldi	r24, 0x37	; 55
    be10:	80 93 27 06 	sts	0x0627, r24
						GPRS_FlgSz_Out = 0;
    be14:	10 92 43 09 	sts	0x0943, r1
    be18:	47 c0       	rjmp	.+142    	; 0xbea8 <GSM_Cycle+0xe5e>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    be1a:	80 91 08 01 	lds	r24, 0x0108
    be1e:	80 ff       	sbrs	r24, 0
    be20:	43 c0       	rjmp	.+134    	; 0xbea8 <GSM_Cycle+0xe5e>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    be22:	80 91 5a 02 	lds	r24, 0x025A
    be26:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    be2a:	88 23       	and	r24, r24
    be2c:	e9 f1       	breq	.+122    	; 0xbea8 <GSM_Cycle+0xe5e>
							GSMTxSz = strlen_P(AT_CIPSEND);
    be2e:	8b e0       	ldi	r24, 0x0B	; 11
    be30:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    be34:	80 e8       	ldi	r24, 0x80	; 128
    be36:	9d e4       	ldi	r25, 0x4D	; 77
    be38:	9f 93       	push	r25
    be3a:	8f 93       	push	r24
    be3c:	09 e3       	ldi	r16, 0x39	; 57
    be3e:	1c e0       	ldi	r17, 0x0C	; 12
    be40:	1f 93       	push	r17
    be42:	0f 93       	push	r16
    be44:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    be48:	80 91 57 09 	lds	r24, 0x0957
    be4c:	90 91 43 09 	lds	r25, 0x0943
    be50:	1f 92       	push	r1
    be52:	9f 93       	push	r25
    be54:	90 91 e7 03 	lds	r25, 0x03E7
    be58:	1f 92       	push	r1
    be5a:	9f 93       	push	r25
    be5c:	24 ed       	ldi	r18, 0xD4	; 212
    be5e:	31 e0       	ldi	r19, 0x01	; 1
    be60:	3f 93       	push	r19
    be62:	2f 93       	push	r18
    be64:	90 e0       	ldi	r25, 0x00	; 0
    be66:	87 5c       	subi	r24, 0xC7	; 199
    be68:	93 4f       	sbci	r25, 0xF3	; 243
    be6a:	9f 93       	push	r25
    be6c:	8f 93       	push	r24
    be6e:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    be72:	f8 01       	movw	r30, r16
    be74:	01 90       	ld	r0, Z+
    be76:	00 20       	and	r0, r0
    be78:	e9 f7       	brne	.-6      	; 0xbe74 <GSM_Cycle+0xe2a>
    be7a:	31 97       	sbiw	r30, 0x01	; 1
    be7c:	e9 53       	subi	r30, 0x39	; 57
    be7e:	fc 40       	sbci	r31, 0x0C	; 12
    be80:	e0 93 57 09 	sts	0x0957, r30
							GSM_SendFirstChar();
    be84:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    be88:	64 ef       	ldi	r22, 0xF4	; 244
    be8a:	71 e0       	ldi	r23, 0x01	; 1
    be8c:	80 91 5a 02 	lds	r24, 0x025A
    be90:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
							GSM_State++;
    be94:	80 91 27 06 	lds	r24, 0x0627
    be98:	8f 5f       	subi	r24, 0xFF	; 255
    be9a:	80 93 27 06 	sts	0x0627, r24
    be9e:	0f b6       	in	r0, 0x3f	; 63
    bea0:	f8 94       	cli
    bea2:	de bf       	out	0x3e, r29	; 62
    bea4:	0f be       	out	0x3f, r0	; 63
    bea6:	cd bf       	out	0x3d, r28	; 61
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    bea8:	80 91 7c 09 	lds	r24, 0x097C
    beac:	81 30       	cpi	r24, 0x01	; 1
    beae:	09 f0       	breq	.+2      	; 0xbeb2 <GSM_Cycle+0xe68>
    beb0:	88 c5       	rjmp	.+2832   	; 0xc9c2 <GSM_Cycle+0x1978>
				if(GSM_Flag & (1<<flg_TxCStr)){
    beb2:	80 91 08 01 	lds	r24, 0x0108
    beb6:	80 ff       	sbrs	r24, 0
    beb8:	84 c5       	rjmp	.+2824   	; 0xc9c2 <GSM_Cycle+0x1978>
					GSMTxSz = strlen_P(AT_CIPSEND);
    beba:	8b e0       	ldi	r24, 0x0B	; 11
    bebc:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    bec0:	80 e8       	ldi	r24, 0x80	; 128
    bec2:	9d e4       	ldi	r25, 0x4D	; 77
    bec4:	9f 93       	push	r25
    bec6:	8f 93       	push	r24
    bec8:	09 e3       	ldi	r16, 0x39	; 57
    beca:	1c e0       	ldi	r17, 0x0C	; 12
    becc:	1f 93       	push	r17
    bece:	0f 93       	push	r16
    bed0:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    bed4:	80 91 57 09 	lds	r24, 0x0957
    bed8:	90 91 43 09 	lds	r25, 0x0943
    bedc:	1f 92       	push	r1
    bede:	9f 93       	push	r25
    bee0:	90 91 07 01 	lds	r25, 0x0107
    bee4:	1f 92       	push	r1
    bee6:	9f 93       	push	r25
    bee8:	24 ed       	ldi	r18, 0xD4	; 212
    beea:	31 e0       	ldi	r19, 0x01	; 1
    beec:	3f 93       	push	r19
    beee:	2f 93       	push	r18
    bef0:	90 e0       	ldi	r25, 0x00	; 0
    bef2:	87 5c       	subi	r24, 0xC7	; 199
    bef4:	93 4f       	sbci	r25, 0xF3	; 243
    bef6:	9f 93       	push	r25
    bef8:	8f 93       	push	r24
    befa:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    befe:	f8 01       	movw	r30, r16
    bf00:	01 90       	ld	r0, Z+
    bf02:	00 20       	and	r0, r0
    bf04:	e9 f7       	brne	.-6      	; 0xbf00 <GSM_Cycle+0xeb6>
    bf06:	31 97       	sbiw	r30, 0x01	; 1
    bf08:	e9 53       	subi	r30, 0x39	; 57
    bf0a:	fc 40       	sbci	r31, 0x0C	; 12
    bf0c:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    bf10:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bf14:	64 ef       	ldi	r22, 0xF4	; 244
    bf16:	71 e0       	ldi	r23, 0x01	; 1
    bf18:	80 91 5a 02 	lds	r24, 0x025A
    bf1c:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					GSM_State++;
    bf20:	80 91 27 06 	lds	r24, 0x0627
    bf24:	8f 5f       	subi	r24, 0xFF	; 255
    bf26:	80 93 27 06 	sts	0x0627, r24
    bf2a:	0f b6       	in	r0, 0x3f	; 63
    bf2c:	f8 94       	cli
    bf2e:	de bf       	out	0x3e, r29	; 62
    bf30:	0f be       	out	0x3f, r0	; 63
    bf32:	cd bf       	out	0x3d, r28	; 61
    bf34:	46 c5       	rjmp	.+2700   	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    bf36:	61 e3       	ldi	r22, 0x31	; 49
    bf38:	8e e3       	ldi	r24, 0x3E	; 62
    bf3a:	0e 94 49 3b 	call	0x7692	; 0x7692 <GSM_Wait_Char>
    bf3e:	88 23       	and	r24, r24
    bf40:	29 f0       	breq	.+10     	; 0xbf4c <GSM_Cycle+0xf02>
    bf42:	80 91 27 06 	lds	r24, 0x0627
    bf46:	8f 5f       	subi	r24, 0xFF	; 255
    bf48:	80 93 27 06 	sts	0x0627, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    bf4c:	80 91 27 06 	lds	r24, 0x0627
    bf50:	81 33       	cpi	r24, 0x31	; 49
    bf52:	09 f0       	breq	.+2      	; 0xbf56 <GSM_Cycle+0xf0c>
    bf54:	36 c5       	rjmp	.+2668   	; 0xc9c2 <GSM_Cycle+0x1978>
    bf56:	10 92 43 09 	sts	0x0943, r1
    bf5a:	33 c5       	rjmp	.+2662   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    bf5c:	60 91 43 09 	lds	r22, 0x0943
    bf60:	89 e3       	ldi	r24, 0x39	; 57
    bf62:	9b e0       	ldi	r25, 0x0B	; 11
    bf64:	0e 94 0d 58 	call	0xb01a	; 0xb01a <GSM_AddHeaderSendData>
			GSM_State++;
    bf68:	80 91 27 06 	lds	r24, 0x0627
    bf6c:	8f 5f       	subi	r24, 0xFF	; 255
    bf6e:	80 93 27 06 	sts	0x0627, r24
    bf72:	27 c5       	rjmp	.+2638   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    bf74:	80 91 5a 02 	lds	r24, 0x025A
    bf78:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    bf7c:	88 23       	and	r24, r24
    bf7e:	29 f0       	breq	.+10     	; 0xbf8a <GSM_Cycle+0xf40>
				GSM_State = GSM_ServerIdle;
    bf80:	81 e3       	ldi	r24, 0x31	; 49
    bf82:	80 93 27 06 	sts	0x0627, r24
				GPRS_FlgSz_Out = 0;
    bf86:	10 92 43 09 	sts	0x0943, r1
			}

			if(GetStringFromFIFO()){
    bf8a:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    bf8e:	88 23       	and	r24, r24
    bf90:	09 f4       	brne	.+2      	; 0xbf94 <GSM_Cycle+0xf4a>
    bf92:	17 c5       	rjmp	.+2606   	; 0xc9c2 <GSM_Cycle+0x1978>
				if(GPRS_Protocol_Out == UDP){
    bf94:	80 91 7c 09 	lds	r24, 0x097C
    bf98:	81 11       	cpse	r24, r1
    bf9a:	27 c0       	rjmp	.+78     	; 0xbfea <GSM_Cycle+0xfa0>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    bf9c:	62 ed       	ldi	r22, 0xD2	; 210
    bf9e:	7e e4       	ldi	r23, 0x4E	; 78
    bfa0:	ce 01       	movw	r24, r28
    bfa2:	01 96       	adiw	r24, 0x01	; 1
    bfa4:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    bfa8:	80 91 e7 03 	lds	r24, 0x03E7
    bfac:	80 5d       	subi	r24, 0xD0	; 208
    bfae:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bfb0:	68 e5       	ldi	r22, 0x58	; 88
    bfb2:	ce 01       	movw	r24, r28
    bfb4:	01 96       	adiw	r24, 0x01	; 1
    bfb6:	0e 94 15 3b 	call	0x762a	; 0x762a <GSM_Wait_Response>
    bfba:	88 23       	and	r24, r24
    bfbc:	b1 f0       	breq	.+44     	; 0xbfea <GSM_Cycle+0xfa0>
						StartTimer16(TD_GSM,500);//min~ 2 sec
    bfbe:	64 ef       	ldi	r22, 0xF4	; 244
    bfc0:	71 e0       	ldi	r23, 0x01	; 1
    bfc2:	80 91 5a 02 	lds	r24, 0x025A
    bfc6:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
						if(++TempNum>3){
    bfca:	80 91 e7 03 	lds	r24, 0x03E7
    bfce:	8f 5f       	subi	r24, 0xFF	; 255
    bfd0:	80 93 e7 03 	sts	0x03E7, r24
    bfd4:	84 30       	cpi	r24, 0x04	; 4
    bfd6:	30 f0       	brcs	.+12     	; 0xbfe4 <GSM_Cycle+0xf9a>
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    bfd8:	87 e3       	ldi	r24, 0x37	; 55
    bfda:	80 93 27 06 	sts	0x0627, r24
							GPRS_FlgSz_Out = 0;
    bfde:	10 92 43 09 	sts	0x0943, r1
    bfe2:	03 c0       	rjmp	.+6      	; 0xbfea <GSM_Cycle+0xfa0>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    bfe4:	83 e3       	ldi	r24, 0x33	; 51
    bfe6:	80 93 27 06 	sts	0x0627, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    bfea:	80 91 7c 09 	lds	r24, 0x097C
    bfee:	81 30       	cpi	r24, 0x01	; 1
    bff0:	09 f0       	breq	.+2      	; 0xbff4 <GSM_Cycle+0xfaa>
    bff2:	e7 c4       	rjmp	.+2510   	; 0xc9c2 <GSM_Cycle+0x1978>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    bff4:	62 ed       	ldi	r22, 0xD2	; 210
    bff6:	7e e4       	ldi	r23, 0x4E	; 78
    bff8:	ce 01       	movw	r24, r28
    bffa:	01 96       	adiw	r24, 0x01	; 1
    bffc:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    c000:	80 91 07 01 	lds	r24, 0x0107
    c004:	80 5d       	subi	r24, 0xD0	; 208
    c006:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c008:	68 e5       	ldi	r22, 0x58	; 88
    c00a:	ce 01       	movw	r24, r28
    c00c:	01 96       	adiw	r24, 0x01	; 1
    c00e:	0e 94 15 3b 	call	0x762a	; 0x762a <GSM_Wait_Response>
    c012:	88 23       	and	r24, r24
    c014:	09 f4       	brne	.+2      	; 0xc018 <GSM_Cycle+0xfce>
    c016:	d5 c4       	rjmp	.+2474   	; 0xc9c2 <GSM_Cycle+0x1978>
						GPRS_FlgSz_Out = 0;
    c018:	10 92 43 09 	sts	0x0943, r1
    c01c:	d2 c4       	rjmp	.+2468   	; 0xc9c2 <GSM_Cycle+0x1978>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    c01e:	80 91 5a 02 	lds	r24, 0x025A
    c022:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c026:	88 23       	and	r24, r24
    c028:	09 f4       	brne	.+2      	; 0xc02c <GSM_Cycle+0xfe2>
    c02a:	cb c4       	rjmp	.+2454   	; 0xc9c2 <GSM_Cycle+0x1978>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    c02c:	10 92 4b 0e 	sts	0x0E4B, r1
				if(sendsWithoutReconnect<3)
    c030:	80 91 5b 02 	lds	r24, 0x025B
    c034:	83 30       	cpi	r24, 0x03	; 3
    c036:	10 f4       	brcc	.+4      	; 0xc03c <GSM_Cycle+0xff2>
				{
					GSM_State = GSM_CIPSHUT;
    c038:	80 e5       	ldi	r24, 0x50	; 80
    c03a:	03 c0       	rjmp	.+6      	; 0xc042 <GSM_Cycle+0xff8>
				}
				else{
					sendsWithoutReconnect=0;
    c03c:	10 92 5b 02 	sts	0x025B, r1
					GSM_State = GSM_CIPSHUT_;
    c040:	82 e5       	ldi	r24, 0x52	; 82
    c042:	80 93 27 06 	sts	0x0627, r24
				}
				sendsWithoutReconnect++;
    c046:	80 91 5b 02 	lds	r24, 0x025B
    c04a:	8f 5f       	subi	r24, 0xFF	; 255
    c04c:	80 93 5b 02 	sts	0x025B, r24
    c050:	b8 c4       	rjmp	.+2416   	; 0xc9c2 <GSM_Cycle+0x1978>

			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c052:	68 ee       	ldi	r22, 0xE8	; 232
    c054:	73 e0       	ldi	r23, 0x03	; 3
    c056:	87 e5       	ldi	r24, 0x57	; 87
    c058:	9d e4       	ldi	r25, 0x4D	; 77
    c05a:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c05e:	80 91 27 06 	lds	r24, 0x0627
    c062:	8f 5f       	subi	r24, 0xFF	; 255
    c064:	80 93 27 06 	sts	0x0627, r24
    c068:	ac c4       	rjmp	.+2392   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    c06a:	68 e5       	ldi	r22, 0x58	; 88
    c06c:	8f ea       	ldi	r24, 0xAF	; 175
    c06e:	9e e4       	ldi	r25, 0x4E	; 78
    c070:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c074:	88 23       	and	r24, r24
    c076:	09 f4       	brne	.+2      	; 0xc07a <GSM_Cycle+0x1030>
    c078:	a4 c4       	rjmp	.+2376   	; 0xc9c2 <GSM_Cycle+0x1978>
    c07a:	83 e1       	ldi	r24, 0x13	; 19
    c07c:	80 93 27 06 	sts	0x0627, r24
    c080:	a0 c4       	rjmp	.+2368   	; 0xc9c2 <GSM_Cycle+0x1978>
		//------------------------


				//------------------------  GPRS
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c082:	68 ee       	ldi	r22, 0xE8	; 232
    c084:	73 e0       	ldi	r23, 0x03	; 3
    c086:	87 e5       	ldi	r24, 0x57	; 87
    c088:	9d e4       	ldi	r25, 0x4D	; 77
    c08a:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c08e:	80 91 27 06 	lds	r24, 0x0627
    c092:	8f 5f       	subi	r24, 0xFF	; 255
    c094:	80 93 27 06 	sts	0x0627, r24
    c098:	94 c4       	rjmp	.+2344   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    c09a:	68 e5       	ldi	r22, 0x58	; 88
    c09c:	8f ea       	ldi	r24, 0xAF	; 175
    c09e:	9e e4       	ldi	r25, 0x4E	; 78
    c0a0:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c0a4:	88 23       	and	r24, r24
    c0a6:	09 f4       	brne	.+2      	; 0xc0aa <GSM_Cycle+0x1060>
    c0a8:	8c c4       	rjmp	.+2328   	; 0xc9c2 <GSM_Cycle+0x1978>
    c0aa:	80 91 27 06 	lds	r24, 0x0627
    c0ae:	8f 5f       	subi	r24, 0xFF	; 255
    c0b0:	80 93 27 06 	sts	0x0627, r24
    c0b4:	86 c4       	rjmp	.+2316   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c0b6:	68 ee       	ldi	r22, 0xE8	; 232
    c0b8:	73 e0       	ldi	r23, 0x03	; 3
    c0ba:	8c e4       	ldi	r24, 0x4C	; 76
    c0bc:	9d e4       	ldi	r25, 0x4D	; 77
    c0be:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c0c2:	80 91 27 06 	lds	r24, 0x0627
    c0c6:	8f 5f       	subi	r24, 0xFF	; 255
    c0c8:	80 93 27 06 	sts	0x0627, r24
    c0cc:	7a c4       	rjmp	.+2292   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c0ce:	68 e5       	ldi	r22, 0x58	; 88
    c0d0:	8a e0       	ldi	r24, 0x0A	; 10
    c0d2:	9f e4       	ldi	r25, 0x4F	; 79
    c0d4:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c0d8:	88 23       	and	r24, r24
    c0da:	09 f4       	brne	.+2      	; 0xc0de <GSM_Cycle+0x1094>
    c0dc:	72 c4       	rjmp	.+2276   	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_GSM, 1000);
    c0de:	68 ee       	ldi	r22, 0xE8	; 232
    c0e0:	73 e0       	ldi	r23, 0x03	; 3
    c0e2:	80 91 5a 02 	lds	r24, 0x025A
    c0e6:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			 	GSM_State = GSM_SEND_CIPMUX;
    c0ea:	83 e1       	ldi	r24, 0x13	; 19
    c0ec:	80 93 27 06 	sts	0x0627, r24
    c0f0:	68 c4       	rjmp	.+2256   	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c0f2:	80 91 08 01 	lds	r24, 0x0108
    c0f6:	80 ff       	sbrs	r24, 0
    c0f8:	64 c4       	rjmp	.+2248   	; 0xc9c2 <GSM_Cycle+0x1978>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
    c0fa:	60 91 e7 03 	lds	r22, 0x03E7
    c0fe:	9d e0       	ldi	r25, 0x0D	; 13
    c100:	69 9f       	mul	r22, r25
    c102:	b0 01       	movw	r22, r0
    c104:	11 24       	eor	r1, r1
    c106:	6d 51       	subi	r22, 0x1D	; 29
    c108:	7f 4f       	sbci	r23, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c10a:	4d e0       	ldi	r20, 0x0D	; 13
    c10c:	50 e0       	ldi	r21, 0x00	; 0
    c10e:	89 e3       	ldi	r24, 0x39	; 57
    c110:	9c e0       	ldi	r25, 0x0C	; 12
    c112:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
				GSMTxSz = strlen(GSM_TxStr);
    c116:	e9 e3       	ldi	r30, 0x39	; 57
    c118:	fc e0       	ldi	r31, 0x0C	; 12
    c11a:	01 90       	ld	r0, Z+
    c11c:	00 20       	and	r0, r0
    c11e:	e9 f7       	brne	.-6      	; 0xc11a <GSM_Cycle+0x10d0>
    c120:	31 97       	sbiw	r30, 0x01	; 1
    c122:	e9 53       	subi	r30, 0x39	; 57
    c124:	fc 40       	sbci	r31, 0x0C	; 12
    c126:	e0 93 57 09 	sts	0x0957, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c12a:	80 e0       	ldi	r24, 0x00	; 0
		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
    c12c:	90 e0       	ldi	r25, 0x00	; 0
				for(uint8_t i=0; i<GSMTxSz; i++)
    c12e:	20 91 57 09 	lds	r18, 0x0957
    c132:	82 17       	cp	r24, r18
    c134:	50 f4       	brcc	.+20     	; 0xc14a <GSM_Cycle+0x1100>
					if(GSM_TxStr[i] != '0') j++;
    c136:	e8 2f       	mov	r30, r24
    c138:	f0 e0       	ldi	r31, 0x00	; 0
    c13a:	e7 5c       	subi	r30, 0xC7	; 199
    c13c:	f3 4f       	sbci	r31, 0xF3	; 243
    c13e:	20 81       	ld	r18, Z
    c140:	20 33       	cpi	r18, 0x30	; 48
    c142:	09 f0       	breq	.+2      	; 0xc146 <GSM_Cycle+0x10fc>
    c144:	9f 5f       	subi	r25, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c146:	8f 5f       	subi	r24, 0xFF	; 255
    c148:	f2 cf       	rjmp	.-28     	; 0xc12e <GSM_Cycle+0x10e4>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c14a:	99 23       	and	r25, r25
    c14c:	09 f4       	brne	.+2      	; 0xc150 <GSM_Cycle+0x1106>
    c14e:	4b c0       	rjmp	.+150    	; 0xc1e6 <GSM_Cycle+0x119c>
					GSMTxSz = strlen_P(AT_CMGS);
    c150:	8a e0       	ldi	r24, 0x0A	; 10
    c152:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    c156:	81 e3       	ldi	r24, 0x31	; 49
    c158:	9e e4       	ldi	r25, 0x4E	; 78
    c15a:	9f 93       	push	r25
    c15c:	8f 93       	push	r24
    c15e:	09 e3       	ldi	r16, 0x39	; 57
    c160:	1c e0       	ldi	r17, 0x0C	; 12
    c162:	1f 93       	push	r17
    c164:	0f 93       	push	r16
    c166:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    c16a:	60 91 e7 03 	lds	r22, 0x03E7
    c16e:	80 91 57 09 	lds	r24, 0x0957
    c172:	ed e0       	ldi	r30, 0x0D	; 13
    c174:	6e 9f       	mul	r22, r30
    c176:	b0 01       	movw	r22, r0
    c178:	11 24       	eor	r1, r1
    c17a:	6d 51       	subi	r22, 0x1D	; 29
    c17c:	7f 4f       	sbci	r23, 0xFF	; 255
    c17e:	90 e0       	ldi	r25, 0x00	; 0
    c180:	4d e0       	ldi	r20, 0x0D	; 13
    c182:	50 e0       	ldi	r21, 0x00	; 0
    c184:	87 5c       	subi	r24, 0xC7	; 199
    c186:	93 4f       	sbci	r25, 0xF3	; 243
    c188:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    c18c:	d8 01       	movw	r26, r16
    c18e:	0d 90       	ld	r0, X+
    c190:	00 20       	and	r0, r0
    c192:	e9 f7       	brne	.-6      	; 0xc18e <GSM_Cycle+0x1144>
    c194:	11 97       	sbiw	r26, 0x01	; 1
    c196:	a9 53       	subi	r26, 0x39	; 57
    c198:	bc 40       	sbci	r27, 0x0C	; 12
    c19a:	a0 93 57 09 	sts	0x0957, r26
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    c19e:	80 91 57 09 	lds	r24, 0x0957
    c1a2:	90 e0       	ldi	r25, 0x00	; 0
    c1a4:	68 ec       	ldi	r22, 0xC8	; 200
    c1a6:	71 e0       	ldi	r23, 0x01	; 1
    c1a8:	87 5c       	subi	r24, 0xC7	; 199
    c1aa:	93 4f       	sbci	r25, 0xF3	; 243
    c1ac:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    c1b0:	f8 01       	movw	r30, r16
    c1b2:	01 90       	ld	r0, Z+
    c1b4:	00 20       	and	r0, r0
    c1b6:	e9 f7       	brne	.-6      	; 0xc1b2 <GSM_Cycle+0x1168>
    c1b8:	31 97       	sbiw	r30, 0x01	; 1
    c1ba:	e9 53       	subi	r30, 0x39	; 57
    c1bc:	fc 40       	sbci	r31, 0x0C	; 12
    c1be:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    c1c2:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c1c6:	64 ef       	ldi	r22, 0xF4	; 244
    c1c8:	71 e0       	ldi	r23, 0x01	; 1
    c1ca:	80 91 5a 02 	lds	r24, 0x025A
    c1ce:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					GSM_State++;
    c1d2:	80 91 27 06 	lds	r24, 0x0627
    c1d6:	8f 5f       	subi	r24, 0xFF	; 255
    c1d8:	80 93 27 06 	sts	0x0627, r24
    c1dc:	0f 90       	pop	r0
    c1de:	0f 90       	pop	r0
    c1e0:	0f 90       	pop	r0
    c1e2:	0f 90       	pop	r0
    c1e4:	ee c3       	rjmp	.+2012   	; 0xc9c2 <GSM_Cycle+0x1978>
				}
				else{
					TempNum++;
    c1e6:	80 91 e7 03 	lds	r24, 0x03E7
    c1ea:	8f 5f       	subi	r24, 0xFF	; 255
    c1ec:	80 93 e7 03 	sts	0x03E7, r24
					if(TempNum>=MaxTelephDirSz){
    c1f0:	83 30       	cpi	r24, 0x03	; 3
    c1f2:	08 f4       	brcc	.+2      	; 0xc1f6 <GSM_Cycle+0x11ac>
    c1f4:	e6 c3       	rjmp	.+1996   	; 0xc9c2 <GSM_Cycle+0x1978>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    c1f6:	81 e3       	ldi	r24, 0x31	; 49
    c1f8:	80 93 27 06 	sts	0x0627, r24
						SMS_FlgSz_Out = 0;
    c1fc:	10 92 67 09 	sts	0x0967, r1
    c200:	e0 c3       	rjmp	.+1984   	; 0xc9c2 <GSM_Cycle+0x1978>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c202:	68 e5       	ldi	r22, 0x58	; 88
    c204:	8e e3       	ldi	r24, 0x3E	; 62
    c206:	0e 94 49 3b 	call	0x7692	; 0x7692 <GSM_Wait_Char>
    c20a:	88 23       	and	r24, r24
    c20c:	09 f4       	brne	.+2      	; 0xc210 <GSM_Cycle+0x11c6>
    c20e:	d9 c3       	rjmp	.+1970   	; 0xc9c2 <GSM_Cycle+0x1978>
    c210:	80 91 27 06 	lds	r24, 0x0627
    c214:	8f 5f       	subi	r24, 0xFF	; 255
    c216:	80 93 27 06 	sts	0x0627, r24
    c21a:	d3 c3       	rjmp	.+1958   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c21c:	60 91 67 09 	lds	r22, 0x0967
    c220:	e6 2f       	mov	r30, r22
    c222:	f0 e0       	ldi	r31, 0x00	; 0
    c224:	e6 52       	subi	r30, 0x26	; 38
    c226:	f7 4f       	sbci	r31, 0xF7	; 247
    c228:	8a e1       	ldi	r24, 0x1A	; 26
    c22a:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c22c:	6f 5f       	subi	r22, 0xFF	; 255
    c22e:	8a ed       	ldi	r24, 0xDA	; 218
    c230:	98 e0       	ldi	r25, 0x08	; 8
    c232:	0e 94 19 58 	call	0xb032	; 0xb032 <GSM_SendData>
			GSM_State++;
    c236:	80 91 27 06 	lds	r24, 0x0627
    c23a:	8f 5f       	subi	r24, 0xFF	; 255
    c23c:	80 93 27 06 	sts	0x0627, r24
    c240:	c0 c3       	rjmp	.+1920   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c242:	68 e5       	ldi	r22, 0x58	; 88
    c244:	8a e0       	ldi	r24, 0x0A	; 10
    c246:	9f e4       	ldi	r25, 0x4F	; 79
    c248:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c24c:	88 23       	and	r24, r24
    c24e:	09 f4       	brne	.+2      	; 0xc252 <GSM_Cycle+0x1208>
    c250:	b8 c3       	rjmp	.+1904   	; 0xc9c2 <GSM_Cycle+0x1978>
				if(++TempNum>=MaxTelephDirSz){
    c252:	80 91 e7 03 	lds	r24, 0x03E7
    c256:	8f 5f       	subi	r24, 0xFF	; 255
    c258:	80 93 e7 03 	sts	0x03E7, r24
    c25c:	83 30       	cpi	r24, 0x03	; 3
    c25e:	30 f0       	brcs	.+12     	; 0xc26c <GSM_Cycle+0x1222>
					GSM_State = GSM_ServerIdle;
    c260:	81 e3       	ldi	r24, 0x31	; 49
    c262:	80 93 27 06 	sts	0x0627, r24
					SMS_FlgSz_Out = 0;
    c266:	10 92 67 09 	sts	0x0967, r1
    c26a:	ab c3       	rjmp	.+1878   	; 0xc9c2 <GSM_Cycle+0x1978>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    c26c:	88 e3       	ldi	r24, 0x38	; 56
    c26e:	80 93 27 06 	sts	0x0627, r24
    c272:	a7 c3       	rjmp	.+1870   	; 0xc9c2 <GSM_Cycle+0x1978>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    c274:	8d e3       	ldi	r24, 0x3D	; 61
    c276:	9d e0       	ldi	r25, 0x0D	; 13
    c278:	9f 93       	push	r25
    c27a:	8f 93       	push	r24
    c27c:	8c e3       	ldi	r24, 0x3C	; 60
    c27e:	9d e0       	ldi	r25, 0x0D	; 13
    c280:	9f 93       	push	r25
    c282:	8f 93       	push	r24
    c284:	8b e3       	ldi	r24, 0x3B	; 59
    c286:	9d e0       	ldi	r25, 0x0D	; 13
    c288:	9f 93       	push	r25
    c28a:	8f 93       	push	r24
    c28c:	8a e3       	ldi	r24, 0x3A	; 58
    c28e:	9d e0       	ldi	r25, 0x0D	; 13
    c290:	9f 93       	push	r25
    c292:	8f 93       	push	r24
    c294:	8b e3       	ldi	r24, 0x3B	; 59
    c296:	93 e0       	ldi	r25, 0x03	; 3
    c298:	9f 93       	push	r25
    c29a:	8f 93       	push	r24
    c29c:	89 e8       	ldi	r24, 0x89	; 137
    c29e:	99 e0       	ldi	r25, 0x09	; 9
    c2a0:	9f 93       	push	r25
    c2a2:	8f 93       	push	r24
    c2a4:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    c2a8:	10 92 e7 03 	sts	0x03E7, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c2ac:	10 91 3d 0d 	lds	r17, 0x0D3D
    c2b0:	70 90 3c 0d 	lds	r7, 0x0D3C
    c2b4:	60 90 3b 0d 	lds	r6, 0x0D3B
    c2b8:	50 90 3a 0d 	lds	r5, 0x0D3A
    c2bc:	00 e1       	ldi	r16, 0x10	; 16
    c2be:	80 2e       	mov	r8, r16
    c2c0:	01 e0       	ldi	r16, 0x01	; 1
    c2c2:	90 2e       	mov	r9, r16
    c2c4:	0f b6       	in	r0, 0x3f	; 63
    c2c6:	f8 94       	cli
    c2c8:	de bf       	out	0x3e, r29	; 62
    c2ca:	0f be       	out	0x3f, r0	; 63
    c2cc:	cd bf       	out	0x3d, r28	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    c2ce:	0f ef       	ldi	r16, 0xFF	; 255
    c2d0:	2f ef       	ldi	r18, 0xFF	; 255
    c2d2:	4f ef       	ldi	r20, 0xFF	; 255
    c2d4:	6f ef       	ldi	r22, 0xFF	; 255
    c2d6:	c4 01       	movw	r24, r8
    c2d8:	0e 94 cb 39 	call	0x7396	; 0x7396 <IP_E_compare_Const>
    c2dc:	88 23       	and	r24, r24
    c2de:	21 f0       	breq	.+8      	; 0xc2e8 <GSM_Cycle+0x129e>
					TempNum = 1;
    c2e0:	81 e0       	ldi	r24, 0x01	; 1
    c2e2:	80 93 e7 03 	sts	0x03E7, r24
    c2e6:	1a c0       	rjmp	.+52     	; 0xc31c <GSM_Cycle+0x12d2>
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    c2e8:	00 e0       	ldi	r16, 0x00	; 0
    c2ea:	20 e0       	ldi	r18, 0x00	; 0
    c2ec:	40 e0       	ldi	r20, 0x00	; 0
    c2ee:	60 e0       	ldi	r22, 0x00	; 0
    c2f0:	c4 01       	movw	r24, r8
    c2f2:	0e 94 cb 39 	call	0x7396	; 0x7396 <IP_E_compare_Const>
    c2f6:	81 11       	cpse	r24, r1
    c2f8:	09 c0       	rjmp	.+18     	; 0xc30c <GSM_Cycle+0x12c2>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c2fa:	01 2f       	mov	r16, r17
    c2fc:	27 2d       	mov	r18, r7
    c2fe:	46 2d       	mov	r20, r6
    c300:	65 2d       	mov	r22, r5
    c302:	c4 01       	movw	r24, r8
    c304:	0e 94 cb 39 	call	0x7396	; 0x7396 <IP_E_compare_Const>
    c308:	81 11       	cpse	r24, r1
    c30a:	ea cf       	rjmp	.-44     	; 0xc2e0 <GSM_Cycle+0x1296>
    c30c:	34 e0       	ldi	r19, 0x04	; 4
    c30e:	83 0e       	add	r8, r19
    c310:	91 1c       	adc	r9, r1
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    c312:	80 e2       	ldi	r24, 0x20	; 32
    c314:	88 16       	cp	r8, r24
    c316:	81 e0       	ldi	r24, 0x01	; 1
    c318:	98 06       	cpc	r9, r24
    c31a:	c9 f6       	brne	.-78     	; 0xc2ce <GSM_Cycle+0x1284>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    c31c:	80 91 e7 03 	lds	r24, 0x03E7
    c320:	88 23       	and	r24, r24
    c322:	89 f0       	breq	.+34     	; 0xc346 <GSM_Cycle+0x12fc>
				GSM_State = GSM_ServerIdle;
    c324:	81 e3       	ldi	r24, 0x31	; 49
    c326:	80 93 27 06 	sts	0x0627, r24
				GSM_ActiveConnection = GSM_Temp;
    c32a:	80 91 e6 03 	lds	r24, 0x03E6
    c32e:	80 93 07 01 	sts	0x0107, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c332:	8e e0       	ldi	r24, 0x0E	; 14
    c334:	91 e0       	ldi	r25, 0x01	; 1
    c336:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c33a:	bc 01       	movw	r22, r24
    c33c:	80 91 59 02 	lds	r24, 0x0259
    c340:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
    c344:	3e c3       	rjmp	.+1660   	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    c346:	8d e3       	ldi	r24, 0x3D	; 61
    c348:	80 93 27 06 	sts	0x0627, r24
    c34c:	3a c3       	rjmp	.+1652   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    c34e:	80 91 08 01 	lds	r24, 0x0108
    c352:	80 ff       	sbrs	r24, 0
    c354:	36 c3       	rjmp	.+1644   	; 0xc9c2 <GSM_Cycle+0x1978>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    c356:	8f e0       	ldi	r24, 0x0F	; 15
    c358:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    c35c:	80 e7       	ldi	r24, 0x70	; 112
    c35e:	9d e4       	ldi	r25, 0x4D	; 77
    c360:	9f 93       	push	r25
    c362:	8f 93       	push	r24
    c364:	89 e3       	ldi	r24, 0x39	; 57
    c366:	9c e0       	ldi	r25, 0x0C	; 12
    c368:	9f 93       	push	r25
    c36a:	8f 93       	push	r24
    c36c:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    c370:	80 91 57 09 	lds	r24, 0x0957
    c374:	90 e0       	ldi	r25, 0x00	; 0
    c376:	69 ec       	ldi	r22, 0xC9	; 201
    c378:	71 e0       	ldi	r23, 0x01	; 1
    c37a:	87 5c       	subi	r24, 0xC7	; 199
    c37c:	93 4f       	sbci	r25, 0xF3	; 243
    c37e:	0e 94 c0 6c 	call	0xd980	; 0xd980 <strcpy>
				GSMTxSz++;
    c382:	80 91 57 09 	lds	r24, 0x0957
    c386:	8f 5f       	subi	r24, 0xFF	; 255
    c388:	80 93 57 09 	sts	0x0957, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    c38c:	80 91 e6 03 	lds	r24, 0x03E6
    c390:	80 5d       	subi	r24, 0xD0	; 208
    c392:	80 93 45 0c 	sts	0x0C45, r24
				GSM_SendFirstChar();
    c396:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c39a:	64 ef       	ldi	r22, 0xF4	; 244
    c39c:	71 e0       	ldi	r23, 0x01	; 1
    c39e:	80 91 5a 02 	lds	r24, 0x025A
    c3a2:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State++;
    c3a6:	80 91 27 06 	lds	r24, 0x0627
    c3aa:	8f 5f       	subi	r24, 0xFF	; 255
    c3ac:	80 93 27 06 	sts	0x0627, r24
    c3b0:	0f 90       	pop	r0
    c3b2:	0f 90       	pop	r0
    c3b4:	0f 90       	pop	r0
    c3b6:	0f 90       	pop	r0
    c3b8:	04 c3       	rjmp	.+1544   	; 0xc9c2 <GSM_Cycle+0x1978>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c3ba:	80 91 5a 02 	lds	r24, 0x025A
    c3be:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c3c2:	88 23       	and	r24, r24
    c3c4:	19 f0       	breq	.+6      	; 0xc3cc <GSM_Cycle+0x1382>
    c3c6:	88 e5       	ldi	r24, 0x58	; 88
    c3c8:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    c3cc:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    c3d0:	88 23       	and	r24, r24
    c3d2:	09 f4       	brne	.+2      	; 0xc3d6 <GSM_Cycle+0x138c>
    c3d4:	f6 c2       	rjmp	.+1516   	; 0xc9c2 <GSM_Cycle+0x1978>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    c3d6:	6d eb       	ldi	r22, 0xBD	; 189
    c3d8:	7e e4       	ldi	r23, 0x4E	; 78
    c3da:	ce 01       	movw	r24, r28
    c3dc:	01 96       	adiw	r24, 0x01	; 1
    c3de:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    c3e2:	80 91 e6 03 	lds	r24, 0x03E6
    c3e6:	80 5d       	subi	r24, 0xD0	; 208
    c3e8:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c3ea:	68 e5       	ldi	r22, 0x58	; 88
    c3ec:	ce 01       	movw	r24, r28
    c3ee:	01 96       	adiw	r24, 0x01	; 1
    c3f0:	0e 94 15 3b 	call	0x762a	; 0x762a <GSM_Wait_Response>
    c3f4:	88 23       	and	r24, r24
    c3f6:	09 f4       	brne	.+2      	; 0xc3fa <GSM_Cycle+0x13b0>
    c3f8:	e4 c2       	rjmp	.+1480   	; 0xc9c2 <GSM_Cycle+0x1978>
					GSM_State = GSM_ServerIdle;
    c3fa:	81 e3       	ldi	r24, 0x31	; 49
    c3fc:	80 93 27 06 	sts	0x0627, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    c400:	80 91 07 01 	lds	r24, 0x0107
    c404:	8f 3f       	cpi	r24, 0xFF	; 255
    c406:	09 f4       	brne	.+2      	; 0xc40a <GSM_Cycle+0x13c0>
    c408:	dc c2       	rjmp	.+1464   	; 0xc9c2 <GSM_Cycle+0x1978>
    c40a:	80 91 59 02 	lds	r24, 0x0259
    c40e:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c412:	88 23       	and	r24, r24
    c414:	09 f4       	brne	.+2      	; 0xc418 <GSM_Cycle+0x13ce>
    c416:	d5 c2       	rjmp	.+1450   	; 0xc9c2 <GSM_Cycle+0x1978>
						GSM_ActiveConnection = NO_CONNECTION;
    c418:	8f ef       	ldi	r24, 0xFF	; 255
    c41a:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c41e:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c422:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c426:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c42a:	10 92 3d 0d 	sts	0x0D3D, r1
    c42e:	c9 c2       	rjmp	.+1426   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    c430:	86 ee       	ldi	r24, 0xE6	; 230
    c432:	93 e0       	ldi	r25, 0x03	; 3
    c434:	9f 93       	push	r25
    c436:	8f 93       	push	r24
    c438:	ce 01       	movw	r24, r28
    c43a:	01 96       	adiw	r24, 0x01	; 1
    c43c:	9f 93       	push	r25
    c43e:	8f 93       	push	r24
    c440:	88 e2       	ldi	r24, 0x28	; 40
    c442:	93 e0       	ldi	r25, 0x03	; 3
    c444:	9f 93       	push	r25
    c446:	8f 93       	push	r24
    c448:	89 e8       	ldi	r24, 0x89	; 137
    c44a:	99 e0       	ldi	r25, 0x09	; 9
    c44c:	9f 93       	push	r25
    c44e:	8f 93       	push	r24
    c450:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    c454:	0f b6       	in	r0, 0x3f	; 63
    c456:	f8 94       	cli
    c458:	de bf       	out	0x3e, r29	; 62
    c45a:	0f be       	out	0x3f, r0	; 63
    c45c:	cd bf       	out	0x3d, r28	; 61
    c45e:	99 81       	ldd	r25, Y+1	; 0x01
    c460:	80 91 07 01 	lds	r24, 0x0107
    c464:	98 13       	cpse	r25, r24
    c466:	0c c0       	rjmp	.+24     	; 0xc480 <GSM_Cycle+0x1436>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c468:	64 ef       	ldi	r22, 0xF4	; 244
    c46a:	71 e0       	ldi	r23, 0x01	; 1
    c46c:	80 91 5a 02 	lds	r24, 0x025A
    c470:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					GSM_State++;
    c474:	80 91 27 06 	lds	r24, 0x0627
    c478:	8f 5f       	subi	r24, 0xFF	; 255
    c47a:	80 93 27 06 	sts	0x0627, r24
    c47e:	a1 c2       	rjmp	.+1346   	; 0xc9c2 <GSM_Cycle+0x1978>
					break;
				}
				GSM_State = GSM_ServerIdle;
    c480:	81 e3       	ldi	r24, 0x31	; 49
    c482:	80 93 27 06 	sts	0x0627, r24
    c486:	9d c2       	rjmp	.+1338   	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    c488:	80 91 5a 02 	lds	r24, 0x025A
    c48c:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c490:	88 23       	and	r24, r24
    c492:	19 f0       	breq	.+6      	; 0xc49a <GSM_Cycle+0x1450>
    c494:	88 e5       	ldi	r24, 0x58	; 88
    c496:	80 93 27 06 	sts	0x0627, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    c49a:	80 91 e6 03 	lds	r24, 0x03E6
    c49e:	80 93 5e 09 	sts	0x095E, r24

			GSM_State = GSM_ServerIdle;
    c4a2:	81 e3       	ldi	r24, 0x31	; 49
    c4a4:	80 93 27 06 	sts	0x0627, r24
    c4a8:	8c c2       	rjmp	.+1304   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c4aa:	60 e7       	ldi	r22, 0x70	; 112
    c4ac:	77 e1       	ldi	r23, 0x17	; 23
    c4ae:	82 e6       	ldi	r24, 0x62	; 98
    c4b0:	9d e4       	ldi	r25, 0x4D	; 77
    c4b2:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c4b6:	80 91 27 06 	lds	r24, 0x0627
    c4ba:	8f 5f       	subi	r24, 0xFF	; 255
    c4bc:	80 93 27 06 	sts	0x0627, r24
    c4c0:	80 c2       	rjmp	.+1280   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c4c2:	80 91 5a 02 	lds	r24, 0x025A
    c4c6:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c4ca:	88 23       	and	r24, r24
    c4cc:	19 f0       	breq	.+6      	; 0xc4d4 <GSM_Cycle+0x148a>
    c4ce:	88 e5       	ldi	r24, 0x58	; 88
    c4d0:	80 93 27 06 	sts	0x0627, r24
			//  
			if(GetStringFromFIFO()){
    c4d4:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    c4d8:	88 23       	and	r24, r24
    c4da:	09 f4       	brne	.+2      	; 0xc4de <GSM_Cycle+0x1494>
    c4dc:	72 c2       	rjmp	.+1252   	; 0xc9c2 <GSM_Cycle+0x1978>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
    c4de:	69 ec       	ldi	r22, 0xC9	; 201
    c4e0:	7e e4       	ldi	r23, 0x4E	; 78
    c4e2:	89 e8       	ldi	r24, 0x89	; 137
    c4e4:	99 e0       	ldi	r25, 0x09	; 9
    c4e6:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    c4ea:	89 2b       	or	r24, r25
    c4ec:	49 f0       	breq	.+18     	; 0xc500 <GSM_Cycle+0x14b6>
    c4ee:	6a e2       	ldi	r22, 0x2A	; 42
    c4f0:	7f e4       	ldi	r23, 0x4F	; 79
    c4f2:	89 e8       	ldi	r24, 0x89	; 137
    c4f4:	99 e0       	ldi	r25, 0x09	; 9
    c4f6:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcmp_P>
    c4fa:	89 2b       	or	r24, r25
    c4fc:	09 f0       	breq	.+2      	; 0xc500 <GSM_Cycle+0x14b6>
    c4fe:	61 c2       	rjmp	.+1218   	; 0xc9c2 <GSM_Cycle+0x1978>
					GSM_State = GSM_ServerIdle;
    c500:	81 e3       	ldi	r24, 0x31	; 49
    c502:	80 93 27 06 	sts	0x0627, r24
					GPRS_FlgSz_Out = 0;						
    c506:	10 92 43 09 	sts	0x0943, r1
    c50a:	5b c2       	rjmp	.+1206   	; 0xc9c2 <GSM_Cycle+0x1978>
		//------------------------

		/*NEW COMMIT*/
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
    c50c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <GSM_PWRCNTRL_OFF>
			StartTimer16(TD_GSM,1000);
    c510:	68 ee       	ldi	r22, 0xE8	; 232
    c512:	73 e0       	ldi	r23, 0x03	; 3
    c514:	80 91 5a 02 	lds	r24, 0x025A
    c518:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			RxBufOverFlow = 0;
    c51c:	10 92 39 0d 	sts	0x0D39, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
    c520:	10 92 67 09 	sts	0x0967, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c524:	8f ef       	ldi	r24, 0xFF	; 255
    c526:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c52a:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c52e:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c532:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c536:	10 92 3d 0d 	sts	0x0D3D, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c53a:	80 91 08 01 	lds	r24, 0x0108
    c53e:	81 60       	ori	r24, 0x01	; 1
    c540:	80 93 08 01 	sts	0x0108, r24
			GSM_State++;
    c544:	80 91 27 06 	lds	r24, 0x0627
    c548:	8f 5f       	subi	r24, 0xFF	; 255
    c54a:	80 93 27 06 	sts	0x0627, r24
    c54e:	39 c2       	rjmp	.+1138   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c550:	80 91 5a 02 	lds	r24, 0x025A
    c554:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c558:	88 23       	and	r24, r24
    c55a:	09 f4       	brne	.+2      	; 0xc55e <GSM_Cycle+0x1514>
    c55c:	32 c2       	rjmp	.+1124   	; 0xc9c2 <GSM_Cycle+0x1978>
				GSM_State = GSM_PowerOn;
    c55e:	10 92 27 06 	sts	0x0627, r1
    c562:	2f c2       	rjmp	.+1118   	; 0xc9c2 <GSM_Cycle+0x1978>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
    c564:	64 ef       	ldi	r22, 0xF4	; 244
    c566:	71 e0       	ldi	r23, 0x01	; 1
    c568:	8d e9       	ldi	r24, 0x9D	; 157
    c56a:	9d e4       	ldi	r25, 0x4D	; 77
    c56c:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c570:	80 91 27 06 	lds	r24, 0x0627
    c574:	8f 5f       	subi	r24, 0xFF	; 255
    c576:	80 93 27 06 	sts	0x0627, r24
    c57a:	23 c2       	rjmp	.+1094   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c57c:	68 e5       	ldi	r22, 0x58	; 88
    c57e:	8a e0       	ldi	r24, 0x0A	; 10
    c580:	9f e4       	ldi	r25, 0x4F	; 79
    c582:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c586:	88 23       	and	r24, r24
    c588:	09 f4       	brne	.+2      	; 0xc58c <GSM_Cycle+0x1542>
    c58a:	1b c2       	rjmp	.+1078   	; 0xc9c2 <GSM_Cycle+0x1978>
    c58c:	80 91 27 06 	lds	r24, 0x0627
    c590:	8f 5f       	subi	r24, 0xFF	; 255
    c592:	80 93 27 06 	sts	0x0627, r24
    c596:	15 c2       	rjmp	.+1066   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
    c598:	68 e5       	ldi	r22, 0x58	; 88
    c59a:	8d ed       	ldi	r24, 0xDD	; 221
    c59c:	9e e4       	ldi	r25, 0x4E	; 78
    c59e:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c5a2:	88 23       	and	r24, r24
    c5a4:	09 f4       	brne	.+2      	; 0xc5a8 <GSM_Cycle+0x155e>
    c5a6:	0d c2       	rjmp	.+1050   	; 0xc9c2 <GSM_Cycle+0x1978>
    c5a8:	8e e2       	ldi	r24, 0x2E	; 46
    c5aa:	80 93 27 06 	sts	0x0627, r24
    c5ae:	09 c2       	rjmp	.+1042   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c5b0:	64 ef       	ldi	r22, 0xF4	; 244
    c5b2:	71 e0       	ldi	r23, 0x01	; 1
    c5b4:	85 e4       	ldi	r24, 0x45	; 69
    c5b6:	9d e4       	ldi	r25, 0x4D	; 77
    c5b8:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
    c5bc:	60 e7       	ldi	r22, 0x70	; 112
    c5be:	77 e1       	ldi	r23, 0x17	; 23
    c5c0:	80 91 58 02 	lds	r24, 0x0258
    c5c4:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			GSM_State = GSM_ServerIdle;
    c5c8:	81 e3       	ldi	r24, 0x31	; 49
    c5ca:	80 93 27 06 	sts	0x0627, r24
    c5ce:	f9 c1       	rjmp	.+1010   	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
    c5d0:	8f ef       	ldi	r24, 0xFF	; 255
    c5d2:	80 93 25 06 	sts	0x0625, r24
    c5d6:	80 93 6c 09 	sts	0x096C, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    c5da:	8c e6       	ldi	r24, 0x6C	; 108
    c5dc:	99 e0       	ldi	r25, 0x09	; 9
    c5de:	9f 93       	push	r25
    c5e0:	8f 93       	push	r24
    c5e2:	85 e2       	ldi	r24, 0x25	; 37
    c5e4:	96 e0       	ldi	r25, 0x06	; 6
    c5e6:	9f 93       	push	r25
    c5e8:	8f 93       	push	r24
    c5ea:	88 e1       	ldi	r24, 0x18	; 24
    c5ec:	93 e0       	ldi	r25, 0x03	; 3
    c5ee:	9f 93       	push	r25
    c5f0:	8f 93       	push	r24
    c5f2:	89 e8       	ldi	r24, 0x89	; 137
    c5f4:	99 e0       	ldi	r25, 0x09	; 9
    c5f6:	9f 93       	push	r25
    c5f8:	8f 93       	push	r24
    c5fa:	0e 94 55 6d 	call	0xdaaa	; 0xdaaa <sscanf_P>
			GSM_State = GSM_ServerIdle;
    c5fe:	81 e3       	ldi	r24, 0x31	; 49
    c600:	80 93 27 06 	sts	0x0627, r24
    c604:	0f b6       	in	r0, 0x3f	; 63
    c606:	f8 94       	cli
    c608:	de bf       	out	0x3e, r29	; 62
    c60a:	0f be       	out	0x3f, r0	; 63
    c60c:	cd bf       	out	0x3d, r28	; 61
    c60e:	d9 c1       	rjmp	.+946    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			Transparent_Application_state = WAIT_REQUEST;
    c610:	81 e0       	ldi	r24, 0x01	; 1
    c612:	80 93 52 09 	sts	0x0952, r24
			if(!UART_Soft){Transparent = 1;}else{Transparent = 0;}
    c616:	90 91 75 0a 	lds	r25, 0x0A75
    c61a:	91 11       	cpse	r25, r1
    c61c:	03 c0       	rjmp	.+6      	; 0xc624 <GSM_Cycle+0x15da>
    c61e:	80 93 76 0a 	sts	0x0A76, r24
    c622:	02 c0       	rjmp	.+4      	; 0xc628 <GSM_Cycle+0x15de>
    c624:	10 92 76 0a 	sts	0x0A76, r1
			if(Timer16Stopp(GPRS_RECONNECT_timer)){
    c628:	80 91 0b 06 	lds	r24, 0x060B
    c62c:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c630:	88 23       	and	r24, r24
    c632:	49 f0       	breq	.+18     	; 0xc646 <GSM_Cycle+0x15fc>
				GSM_State = GSM_Swtch2CommandMode;
    c634:	81 e6       	ldi	r24, 0x61	; 97
    c636:	80 93 27 06 	sts	0x0627, r24
				Transparent_Application_state = RECONNECT;
    c63a:	82 e0       	ldi	r24, 0x02	; 2
    c63c:	80 93 52 09 	sts	0x0952, r24
				Transparent = 0;
    c640:	10 92 76 0a 	sts	0x0A76, r1
    c644:	be c1       	rjmp	.+892    	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}
			if(Timer16Stopp(TCP_CONNECT_check_timer)){
    c646:	80 91 40 0d 	lds	r24, 0x0D40
    c64a:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c64e:	88 23       	and	r24, r24
    c650:	09 f4       	brne	.+2      	; 0xc654 <GSM_Cycle+0x160a>
    c652:	b7 c1       	rjmp	.+878    	; 0xc9c2 <GSM_Cycle+0x1978>
				GSM_State = GSM_Swtch2CommandMode;
    c654:	81 e6       	ldi	r24, 0x61	; 97
    c656:	80 93 27 06 	sts	0x0627, r24
				Transparent_Application_state = CHECK_CONNECTION_STATE;
    c65a:	83 e0       	ldi	r24, 0x03	; 3
    c65c:	80 93 52 09 	sts	0x0952, r24
				Transparent = 0;
    c660:	10 92 76 0a 	sts	0x0A76, r1
    c664:	ae c1       	rjmp	.+860    	; 0xc9c2 <GSM_Cycle+0x1978>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c666:	90 91 7b 08 	lds	r25, 0x087B
    c66a:	80 91 05 06 	lds	r24, 0x0605
    c66e:	98 17       	cp	r25, r24
    c670:	49 f0       	breq	.+18     	; 0xc684 <GSM_Cycle+0x163a>
    c672:	8e e0       	ldi	r24, 0x0E	; 14
    c674:	91 e0       	ldi	r25, 0x01	; 1
    c676:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c67a:	bc 01       	movw	r22, r24
    c67c:	80 91 59 02 	lds	r24, 0x0259
    c680:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
    c684:	80 91 f4 09 	lds	r24, 0x09F4
    c688:	81 30       	cpi	r24, 0x01	; 1
    c68a:	71 f1       	breq	.+92     	; 0xc6e8 <GSM_Cycle+0x169e>
				if(GetStringFromFIFO()){
    c68c:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    c690:	88 23       	and	r24, r24
    c692:	51 f1       	breq	.+84     	; 0xc6e8 <GSM_Cycle+0x169e>
								
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c694:	6a e2       	ldi	r22, 0x2A	; 42
    c696:	7f e4       	ldi	r23, 0x4F	; 79
    c698:	89 e8       	ldi	r24, 0x89	; 137
    c69a:	99 e0       	ldi	r25, 0x09	; 9
    c69c:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    c6a0:	89 2b       	or	r24, r25
    c6a2:	31 f0       	breq	.+12     	; 0xc6b0 <GSM_Cycle+0x1666>
						GSM_State = GSM_ServerIdle;
    c6a4:	81 e3       	ldi	r24, 0x31	; 49
    c6a6:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c6aa:	0e 94 d5 4b 	call	0x97aa	; 0x97aa <GSM_CloseTransparent>
    c6ae:	89 c1       	rjmp	.+786    	; 0xc9c2 <GSM_Cycle+0x1978>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
    c6b0:	6d e0       	ldi	r22, 0x0D	; 13
    c6b2:	7f e4       	ldi	r23, 0x4F	; 79
    c6b4:	89 e8       	ldi	r24, 0x89	; 137
    c6b6:	99 e0       	ldi	r25, 0x09	; 9
    c6b8:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    c6bc:	89 2b       	or	r24, r25
    c6be:	31 f0       	breq	.+12     	; 0xc6cc <GSM_Cycle+0x1682>
						GSM_State = GSM_ServerIdle;
    c6c0:	81 e3       	ldi	r24, 0x31	; 49
    c6c2:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c6c6:	0e 94 d5 4b 	call	0x97aa	; 0x97aa <GSM_CloseTransparent>
    c6ca:	7b c1       	rjmp	.+758    	; 0xc9c2 <GSM_Cycle+0x1978>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    c6cc:	6d e1       	ldi	r22, 0x1D	; 29
    c6ce:	7f e4       	ldi	r23, 0x4F	; 79
    c6d0:	89 e8       	ldi	r24, 0x89	; 137
    c6d2:	99 e0       	ldi	r25, 0x09	; 9
    c6d4:	0e 94 89 6c 	call	0xd912	; 0xd912 <strstr_P>
    c6d8:	89 2b       	or	r24, r25
    c6da:	31 f0       	breq	.+12     	; 0xc6e8 <GSM_Cycle+0x169e>
						GSM_State = GSM_SEND_E0;
    c6dc:	88 e0       	ldi	r24, 0x08	; 8
    c6de:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c6e2:	0e 94 d5 4b 	call	0x97aa	; 0x97aa <GSM_CloseTransparent>
    c6e6:	6d c1       	rjmp	.+730    	; 0xc9c2 <GSM_Cycle+0x1978>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    c6e8:	80 91 59 02 	lds	r24, 0x0259
    c6ec:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c6f0:	88 23       	and	r24, r24
    c6f2:	09 f4       	brne	.+2      	; 0xc6f6 <GSM_Cycle+0x16ac>
    c6f4:	66 c1       	rjmp	.+716    	; 0xc9c2 <GSM_Cycle+0x1978>
				GSM_State = GSM_Swtch2CommandMode;
    c6f6:	81 e6       	ldi	r24, 0x61	; 97
    c6f8:	80 93 27 06 	sts	0x0627, r24
				GSM_CloseTransparent();
    c6fc:	0e 94 d5 4b 	call	0x97aa	; 0x97aa <GSM_CloseTransparent>
    c700:	60 c1       	rjmp	.+704    	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}
			break;

		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
    c702:	6e e6       	ldi	r22, 0x6E	; 110
    c704:	70 e0       	ldi	r23, 0x00	; 0
    c706:	80 91 5a 02 	lds	r24, 0x025A
    c70a:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			//WebClose();
			GSM_State++;
    c70e:	80 91 27 06 	lds	r24, 0x0627
    c712:	8f 5f       	subi	r24, 0xFF	; 255
    c714:	80 93 27 06 	sts	0x0627, r24
    c718:	54 c1       	rjmp	.+680    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c71a:	80 91 5a 02 	lds	r24, 0x025A
    c71e:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c722:	88 23       	and	r24, r24
    c724:	09 f4       	brne	.+2      	; 0xc728 <GSM_Cycle+0x16de>
    c726:	4d c1       	rjmp	.+666    	; 0xc9c2 <GSM_Cycle+0x1978>
						if(GSM_Flag & (1<<flg_TxCStr)){
    c728:	80 91 08 01 	lds	r24, 0x0108
    c72c:	80 ff       	sbrs	r24, 0
    c72e:	49 c1       	rjmp	.+658    	; 0xc9c2 <GSM_Cycle+0x1978>
							GSMTxSz = strlen_P(ESC_SEQ);
    c730:	83 e0       	ldi	r24, 0x03	; 3
    c732:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, ESC_SEQ);
    c736:	8c e8       	ldi	r24, 0x8C	; 140
    c738:	9e e4       	ldi	r25, 0x4E	; 78
    c73a:	9f 93       	push	r25
    c73c:	8f 93       	push	r24
    c73e:	89 e3       	ldi	r24, 0x39	; 57
    c740:	9c e0       	ldi	r25, 0x0C	; 12
    c742:	9f 93       	push	r25
    c744:	8f 93       	push	r24
    c746:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
							GSM_SendFirstChar();
    c74a:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c74e:	64 ef       	ldi	r22, 0xF4	; 244
    c750:	71 e0       	ldi	r23, 0x01	; 1
    c752:	80 91 5a 02 	lds	r24, 0x025A
    c756:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
							GSM_State++;
    c75a:	80 91 27 06 	lds	r24, 0x0627
    c75e:	8f 5f       	subi	r24, 0xFF	; 255
    c760:	80 93 27 06 	sts	0x0627, r24
    c764:	0f 90       	pop	r0
    c766:	0f 90       	pop	r0
    c768:	0f 90       	pop	r0
    c76a:	0f 90       	pop	r0
    c76c:	2a c1       	rjmp	.+596    	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;*/
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c76e:	68 e5       	ldi	r22, 0x58	; 88
    c770:	8a e0       	ldi	r24, 0x0A	; 10
    c772:	9f e4       	ldi	r25, 0x4F	; 79
    c774:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c778:	88 23       	and	r24, r24
    c77a:	09 f4       	brne	.+2      	; 0xc77e <GSM_Cycle+0x1734>
    c77c:	22 c1       	rjmp	.+580    	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    c77e:	6f ef       	ldi	r22, 0xFF	; 255
    c780:	7f ef       	ldi	r23, 0xFF	; 255
    c782:	80 91 59 02 	lds	r24, 0x0259
    c786:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				/*if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
				else GSM_State = GSM_SEND_CIPCLOSE;*/
				switch(Transparent_Application_state){
    c78a:	80 91 52 09 	lds	r24, 0x0952
    c78e:	82 30       	cpi	r24, 0x02	; 2
    c790:	41 f0       	breq	.+16     	; 0xc7a2 <GSM_Cycle+0x1758>
    c792:	83 30       	cpi	r24, 0x03	; 3
    c794:	51 f4       	brne	.+20     	; 0xc7aa <GSM_Cycle+0x1760>
					case CHECK_CONNECTION_STATE:
						GSM_State = GSM_SEND_CIPSTATUS;
    c796:	87 e2       	ldi	r24, 0x27	; 39
    c798:	80 93 27 06 	sts	0x0627, r24
						InitFIFO();
    c79c:	0e 94 fb 39 	call	0x73f6	; 0x73f6 <InitFIFO>
    c7a0:	10 c1       	rjmp	.+544    	; 0xc9c2 <GSM_Cycle+0x1978>
						break;
					case RECONNECT:
						GSM_State = GSM_CIPSHUT_;
    c7a2:	82 e5       	ldi	r24, 0x52	; 82
    c7a4:	80 93 27 06 	sts	0x0627, r24
    c7a8:	0c c1       	rjmp	.+536    	; 0xc9c2 <GSM_Cycle+0x1978>
						break;
					default:GSM_State = GSM_ReStart1;
    c7aa:	88 e5       	ldi	r24, 0x58	; 88
    c7ac:	80 93 27 06 	sts	0x0627, r24
    c7b0:	08 c1       	rjmp	.+528    	; 0xc9c2 <GSM_Cycle+0x1978>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
    c7b2:	80 91 5a 02 	lds	r24, 0x025A
    c7b6:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c7ba:	88 23       	and	r24, r24
    c7bc:	19 f0       	breq	.+6      	; 0xc7c4 <GSM_Cycle+0x177a>
    c7be:	87 e6       	ldi	r24, 0x67	; 103
    c7c0:	80 93 27 06 	sts	0x0627, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c7c4:	8f e5       	ldi	r24, 0x5F	; 95
    c7c6:	90 e0       	ldi	r25, 0x00	; 0
    c7c8:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
    c7cc:	81 11       	cpse	r24, r1
    c7ce:	04 c0       	rjmp	.+8      	; 0xc7d8 <GSM_Cycle+0x178e>
				GSM_State = GSM_SEND_ATA;
    c7d0:	85 e6       	ldi	r24, 0x65	; 101
    c7d2:	80 93 27 06 	sts	0x0627, r24
    c7d6:	f5 c0       	rjmp	.+490    	; 0xc9c2 <GSM_Cycle+0x1978>
				break;
			}
			if(GetStringFromFIFO() > 25){
    c7d8:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <GetStringFromFIFO>
    c7dc:	8a 31       	cpi	r24, 0x1A	; 26
    c7de:	08 f4       	brcc	.+2      	; 0xc7e2 <GSM_Cycle+0x1798>
    c7e0:	f0 c0       	rjmp	.+480    	; 0xc9c2 <GSM_Cycle+0x1978>
				char *qoute_open = strchr(GSM_RxStr,'"');
    c7e2:	62 e2       	ldi	r22, 0x22	; 34
    c7e4:	70 e0       	ldi	r23, 0x00	; 0
    c7e6:	89 e8       	ldi	r24, 0x89	; 137
    c7e8:	99 e0       	ldi	r25, 0x09	; 9
    c7ea:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
    c7ee:	4c 01       	movw	r8, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
    c7f0:	62 e2       	ldi	r22, 0x22	; 34
    c7f2:	70 e0       	ldi	r23, 0x00	; 0
    c7f4:	01 96       	adiw	r24, 0x01	; 1
    c7f6:	0e 94 ac 6c 	call	0xd958	; 0xd958 <strchr>
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
    c7fa:	81 14       	cp	r8, r1
    c7fc:	91 04       	cpc	r9, r1
    c7fe:	11 f0       	breq	.+4      	; 0xc804 <GSM_Cycle+0x17ba>
    c800:	00 97       	sbiw	r24, 0x00	; 0
    c802:	21 f4       	brne	.+8      	; 0xc80c <GSM_Cycle+0x17c2>
					GSM_State = GSM_SEND_ATH;
    c804:	87 e6       	ldi	r24, 0x67	; 103
    c806:	80 93 27 06 	sts	0x0627, r24
    c80a:	db c0       	rjmp	.+438    	; 0xc9c2 <GSM_Cycle+0x1978>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
    c80c:	fc 01       	movw	r30, r24
    c80e:	10 82       	st	Z, r1
    c810:	01 e6       	ldi	r16, 0x61	; 97
    c812:	10 e0       	ldi	r17, 0x00	; 0
				for(uint8_t i = 0; i<10; i++){
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
    c814:	f2 e0       	ldi	r31, 0x02	; 2
    c816:	8f 0e       	add	r8, r31
    c818:	91 1c       	adc	r9, r1
    c81a:	b7 e6       	ldi	r27, 0x67	; 103
    c81c:	7b 2e       	mov	r7, r27
    c81e:	b8 01       	movw	r22, r16
    c820:	c4 01       	movw	r24, r8
    c822:	0e 94 6d 47 	call	0x8eda	; 0x8eda <strcmp_E>
    c826:	88 23       	and	r24, r24
    c828:	49 f0       	breq	.+18     	; 0xc83c <GSM_Cycle+0x17f2>
    c82a:	70 92 27 06 	sts	0x0627, r7
    c82e:	03 5f       	subi	r16, 0xF3	; 243
    c830:	1f 4f       	sbci	r17, 0xFF	; 255
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
    c832:	20 e0       	ldi	r18, 0x00	; 0
    c834:	03 3e       	cpi	r16, 0xE3	; 227
    c836:	12 07       	cpc	r17, r18
    c838:	91 f7       	brne	.-28     	; 0xc81e <GSM_Cycle+0x17d4>
    c83a:	c3 c0       	rjmp	.+390    	; 0xc9c2 <GSM_Cycle+0x1978>
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
    c83c:	85 e6       	ldi	r24, 0x65	; 101
    c83e:	80 93 27 06 	sts	0x0627, r24
    c842:	bf c0       	rjmp	.+382    	; 0xc9c2 <GSM_Cycle+0x1978>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c844:	60 e7       	ldi	r22, 0x70	; 112
    c846:	77 e1       	ldi	r23, 0x17	; 23
    c848:	81 e4       	ldi	r24, 0x41	; 65
    c84a:	9d e4       	ldi	r25, 0x4D	; 77
    c84c:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c850:	80 91 27 06 	lds	r24, 0x0627
    c854:	8f 5f       	subi	r24, 0xFF	; 255
    c856:	80 93 27 06 	sts	0x0627, r24
    c85a:	b3 c0       	rjmp	.+358    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
    c85c:	67 e6       	ldi	r22, 0x67	; 103
    c85e:	82 ea       	ldi	r24, 0xA2	; 162
    c860:	9e e4       	ldi	r25, 0x4E	; 78
    c862:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c866:	88 23       	and	r24, r24
    c868:	09 f4       	brne	.+2      	; 0xc86c <GSM_Cycle+0x1822>
    c86a:	ab c0       	rjmp	.+342    	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_TCP_Connect, 500);	//   
    c86c:	64 ef       	ldi	r22, 0xF4	; 244
    c86e:	71 e0       	ldi	r23, 0x01	; 1
    c870:	80 91 59 02 	lds	r24, 0x0259
    c874:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_CSD = 1;
    c878:	81 e0       	ldi	r24, 0x01	; 1
    c87a:	80 93 4b 09 	sts	0x094B, r24
				GSM_State = GSM_ProtocolMode;
    c87e:	8f e5       	ldi	r24, 0x5F	; 95
    c880:	80 93 27 06 	sts	0x0627, r24
    c884:	9e c0       	rjmp	.+316    	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
    c886:	6c e2       	ldi	r22, 0x2C	; 44
    c888:	71 e0       	ldi	r23, 0x01	; 1
    c88a:	8d e3       	ldi	r24, 0x3D	; 61
    c88c:	9d e4       	ldi	r25, 0x4D	; 77
    c88e:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c892:	80 91 27 06 	lds	r24, 0x0627
    c896:	8f 5f       	subi	r24, 0xFF	; 255
    c898:	80 93 27 06 	sts	0x0627, r24
    c89c:	92 c0       	rjmp	.+292    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    c89e:	68 e5       	ldi	r22, 0x58	; 88
    c8a0:	8a e0       	ldi	r24, 0x0A	; 10
    c8a2:	9f e4       	ldi	r25, 0x4F	; 79
    c8a4:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c8a8:	88 23       	and	r24, r24
    c8aa:	09 f4       	brne	.+2      	; 0xc8ae <GSM_Cycle+0x1864>
    c8ac:	8a c0       	rjmp	.+276    	; 0xc9c2 <GSM_Cycle+0x1978>
    c8ae:	81 e3       	ldi	r24, 0x31	; 49
    c8b0:	80 93 27 06 	sts	0x0627, r24
    c8b4:	86 c0       	rjmp	.+268    	; 0xc9c2 <GSM_Cycle+0x1978>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c8b6:	80 91 27 06 	lds	r24, 0x0627
    c8ba:	90 e0       	ldi	r25, 0x00	; 0
    c8bc:	89 30       	cpi	r24, 0x09	; 9
    c8be:	91 05       	cpc	r25, r1
    c8c0:	08 f0       	brcs	.+2      	; 0xc8c4 <GSM_Cycle+0x187a>
    c8c2:	7d c0       	rjmp	.+250    	; 0xc9be <GSM_Cycle+0x1974>
    c8c4:	fc 01       	movw	r30, r24
    c8c6:	e7 5c       	subi	r30, 0xC7	; 199
    c8c8:	fe 4f       	sbci	r31, 0xFE	; 254
    c8ca:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c8ce:	68 ec       	ldi	r22, 0xC8	; 200
    c8d0:	70 e0       	ldi	r23, 0x00	; 0
    c8d2:	80 91 5a 02 	lds	r24, 0x025A
    c8d6:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
			GSM_PWRCNTRL_ON();
    c8da:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <GSM_PWRCNTRL_ON>
			GSM_State++;
    c8de:	80 91 27 06 	lds	r24, 0x0627
    c8e2:	8f 5f       	subi	r24, 0xFF	; 255
    c8e4:	80 93 27 06 	sts	0x0627, r24
    c8e8:	6c c0       	rjmp	.+216    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    c8ea:	80 91 5a 02 	lds	r24, 0x025A
    c8ee:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c8f2:	88 23       	and	r24, r24
    c8f4:	31 f0       	breq	.+12     	; 0xc902 <GSM_Cycle+0x18b8>
    c8f6:	64 e6       	ldi	r22, 0x64	; 100
    c8f8:	70 e0       	ldi	r23, 0x00	; 0
    c8fa:	89 e8       	ldi	r24, 0x89	; 137
    c8fc:	9e e4       	ldi	r25, 0x4E	; 78
    c8fe:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c902:	80 91 27 06 	lds	r24, 0x0627
    c906:	8f 5f       	subi	r24, 0xFF	; 255
    c908:	80 93 27 06 	sts	0x0627, r24
    c90c:	5a c0       	rjmp	.+180    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    c90e:	61 e0       	ldi	r22, 0x01	; 1
    c910:	8a e0       	ldi	r24, 0x0A	; 10
    c912:	9f e4       	ldi	r25, 0x4F	; 79
    c914:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c918:	88 23       	and	r24, r24
    c91a:	09 f4       	brne	.+2      	; 0xc91e <GSM_Cycle+0x18d4>
    c91c:	52 c0       	rjmp	.+164    	; 0xc9c2 <GSM_Cycle+0x1978>
    c91e:	80 91 27 06 	lds	r24, 0x0627
    c922:	8f 5f       	subi	r24, 0xFF	; 255
    c924:	80 93 27 06 	sts	0x0627, r24
    c928:	4c c0       	rjmp	.+152    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c92a:	64 e6       	ldi	r22, 0x64	; 100
    c92c:	70 e0       	ldi	r23, 0x00	; 0
    c92e:	8d e7       	ldi	r24, 0x7D	; 125
    c930:	9e e4       	ldi	r25, 0x4E	; 78
    c932:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c936:	80 91 27 06 	lds	r24, 0x0627
    c93a:	8f 5f       	subi	r24, 0xFF	; 255
    c93c:	80 93 27 06 	sts	0x0627, r24
    c940:	40 c0       	rjmp	.+128    	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c942:	61 e0       	ldi	r22, 0x01	; 1
    c944:	8a e0       	ldi	r24, 0x0A	; 10
    c946:	9f e4       	ldi	r25, 0x4F	; 79
    c948:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c94c:	88 23       	and	r24, r24
    c94e:	c9 f1       	breq	.+114    	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_GSM,200);
    c950:	68 ec       	ldi	r22, 0xC8	; 200
    c952:	70 e0       	ldi	r23, 0x00	; 0
    c954:	80 91 5a 02 	lds	r24, 0x025A
    c958:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State++;
    c95c:	80 91 27 06 	lds	r24, 0x0627
    c960:	8f 5f       	subi	r24, 0xFF	; 255
    c962:	80 93 27 06 	sts	0x0627, r24
    c966:	2d c0       	rjmp	.+90     	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c968:	64 e6       	ldi	r22, 0x64	; 100
    c96a:	70 e0       	ldi	r23, 0x00	; 0
    c96c:	88 e7       	ldi	r24, 0x78	; 120
    c96e:	9e e4       	ldi	r25, 0x4E	; 78
    c970:	0e 94 f1 57 	call	0xafe2	; 0xafe2 <GSM_Execute_Command>
    c974:	80 91 27 06 	lds	r24, 0x0627
    c978:	8f 5f       	subi	r24, 0xFF	; 255
    c97a:	80 93 27 06 	sts	0x0627, r24
    c97e:	21 c0       	rjmp	.+66     	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c980:	61 e0       	ldi	r22, 0x01	; 1
    c982:	8a e0       	ldi	r24, 0x0A	; 10
    c984:	9f e4       	ldi	r25, 0x4F	; 79
    c986:	0e 94 20 3b 	call	0x7640	; 0x7640 <GSM_Wait_Response_P>
    c98a:	88 23       	and	r24, r24
    c98c:	d1 f0       	breq	.+52     	; 0xc9c2 <GSM_Cycle+0x1978>
				StartTimer16(TD_GSM,200);
    c98e:	68 ec       	ldi	r22, 0xC8	; 200
    c990:	70 e0       	ldi	r23, 0x00	; 0
    c992:	80 91 5a 02 	lds	r24, 0x025A
    c996:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				GSM_State++;
    c99a:	80 91 27 06 	lds	r24, 0x0627
    c99e:	8f 5f       	subi	r24, 0xFF	; 255
    c9a0:	80 93 27 06 	sts	0x0627, r24
    c9a4:	0e c0       	rjmp	.+28     	; 0xc9c2 <GSM_Cycle+0x1978>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    c9a6:	80 91 5a 02 	lds	r24, 0x025A
    c9aa:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    c9ae:	88 23       	and	r24, r24
    c9b0:	41 f0       	breq	.+16     	; 0xc9c2 <GSM_Cycle+0x1978>
    c9b2:	80 91 27 06 	lds	r24, 0x0627
    c9b6:	8f 5f       	subi	r24, 0xFF	; 255
    c9b8:	80 93 27 06 	sts	0x0627, r24
    c9bc:	02 c0       	rjmp	.+4      	; 0xc9c2 <GSM_Cycle+0x1978>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c9be:	10 92 27 06 	sts	0x0627, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
    c9c2:	80 91 27 06 	lds	r24, 0x0627
    c9c6:	88 35       	cpi	r24, 0x58	; 88
    c9c8:	41 f0       	breq	.+16     	; 0xc9da <GSM_Cycle+0x1990>
    c9ca:	80 91 27 06 	lds	r24, 0x0627
    c9ce:	89 35       	cpi	r24, 0x59	; 89
    c9d0:	21 f0       	breq	.+8      	; 0xc9da <GSM_Cycle+0x1990>
    c9d2:	80 91 27 06 	lds	r24, 0x0627
    c9d6:	80 93 5b 09 	sts	0x095B, r24
}
    c9da:	2e 96       	adiw	r28, 0x0e	; 14
    c9dc:	0f b6       	in	r0, 0x3f	; 63
    c9de:	f8 94       	cli
    c9e0:	de bf       	out	0x3e, r29	; 62
    c9e2:	0f be       	out	0x3f, r0	; 63
    c9e4:	cd bf       	out	0x3d, r28	; 61
    c9e6:	df 91       	pop	r29
    c9e8:	cf 91       	pop	r28
    c9ea:	1f 91       	pop	r17
    c9ec:	0f 91       	pop	r16
    c9ee:	ff 90       	pop	r15
    c9f0:	ef 90       	pop	r14
    c9f2:	df 90       	pop	r13
    c9f4:	cf 90       	pop	r12
    c9f6:	bf 90       	pop	r11
    c9f8:	af 90       	pop	r10
    c9fa:	9f 90       	pop	r9
    c9fc:	8f 90       	pop	r8
    c9fe:	7f 90       	pop	r7
    ca00:	6f 90       	pop	r6
    ca02:	5f 90       	pop	r5
    ca04:	4f 90       	pop	r4
    ca06:	3f 90       	pop	r3
    ca08:	2f 90       	pop	r2
    ca0a:	08 95       	ret

0000ca0c <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
    ca0c:	80 91 75 0a 	lds	r24, 0x0A75
    ca10:	88 23       	and	r24, r24
    ca12:	b9 f0       	breq	.+46     	; 0xca42 <USART_Cycle+0x36>

		if(ModbusMode) MB_Cycle();
    ca14:	80 91 e0 03 	lds	r24, 0x03E0
    ca18:	81 11       	cpse	r24, r1
    ca1a:	0e 94 98 39 	call	0x7330	; 0x7330 <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
    ca1e:	c8 9b       	sbis	0x19, 0	; 25
    ca20:	22 c0       	rjmp	.+68     	; 0xca66 <USART_Cycle+0x5a>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
    ca22:	80 91 4c 09 	lds	r24, 0x094C
    ca26:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    ca2a:	88 23       	and	r24, r24
    ca2c:	09 f1       	breq	.+66     	; 0xca70 <USART_Cycle+0x64>
				cli();
    ca2e:	f8 94       	cli
				EMeter_ReInit();
    ca30:	0e 94 ae 4b 	call	0x975c	; 0x975c <EMeter_ReInit>
				UART_Soft = 0;
    ca34:	10 92 75 0a 	sts	0x0A75, r1
				ModbusMode = 0;				
    ca38:	10 92 e0 03 	sts	0x03E0, r1
				GSM_DebugMode = 0;	
    ca3c:	10 92 f2 09 	sts	0x09F2, r1
    ca40:	10 c0       	rjmp	.+32     	; 0xca62 <USART_Cycle+0x56>
			}
		}
	}
	else{
	//	EMeter_Cycle();
		if(!(PINA & (1<<PA0))){
    ca42:	c8 99       	sbic	0x19, 0	; 25
    ca44:	10 c0       	rjmp	.+32     	; 0xca66 <USART_Cycle+0x5a>
			if(Timer8Stopp(TD_UART_Soft)){
    ca46:	80 91 4c 09 	lds	r24, 0x094C
    ca4a:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    ca4e:	88 23       	and	r24, r24
    ca50:	79 f0       	breq	.+30     	; 0xca70 <USART_Cycle+0x64>
				//if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
				cli();
    ca52:	f8 94       	cli
				MB_Init();
    ca54:	0e 94 92 35 	call	0x6b24	; 0x6b24 <MB_Init>
				UART_Soft = 1;
    ca58:	81 e0       	ldi	r24, 0x01	; 1
    ca5a:	80 93 75 0a 	sts	0x0A75, r24
				ModbusMode = 1;
    ca5e:	80 93 e0 03 	sts	0x03E0, r24
				sei();
    ca62:	78 94       	sei
    ca64:	05 c0       	rjmp	.+10     	; 0xca70 <USART_Cycle+0x64>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
    ca66:	6a e0       	ldi	r22, 0x0A	; 10
    ca68:	80 91 4c 09 	lds	r24, 0x094C
    ca6c:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
    ca70:	0c 94 25 58 	jmp	0xb04a	; 0xb04a <GSM_Cycle>

0000ca74 <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    ca74:	2f 92       	push	r2
    ca76:	3f 92       	push	r3
    ca78:	4f 92       	push	r4
    ca7a:	5f 92       	push	r5
    ca7c:	6f 92       	push	r6
    ca7e:	7f 92       	push	r7
    ca80:	8f 92       	push	r8
    ca82:	9f 92       	push	r9
    ca84:	af 92       	push	r10
    ca86:	bf 92       	push	r11
    ca88:	cf 92       	push	r12
    ca8a:	df 92       	push	r13
    ca8c:	ef 92       	push	r14
    ca8e:	ff 92       	push	r15
    ca90:	0f 93       	push	r16
    ca92:	1f 93       	push	r17
    ca94:	cf 93       	push	r28
    ca96:	df 93       	push	r29
    ca98:	cd b7       	in	r28, 0x3d	; 61
    ca9a:	de b7       	in	r29, 0x3e	; 62
    ca9c:	2c 97       	sbiw	r28, 0x0c	; 12
    ca9e:	0f b6       	in	r0, 0x3f	; 63
    caa0:	f8 94       	cli
    caa2:	de bf       	out	0x3e, r29	; 62
    caa4:	0f be       	out	0x3f, r0	; 63
    caa6:	cd bf       	out	0x3d, r28	; 61
    caa8:	8c 01       	movw	r16, r24
    caaa:	b6 2e       	mov	r11, r22
	}
	else{
		StartTimeoutWaitRequest = 0;
	}

}
    caac:	2d b6       	in	r2, 0x3d	; 61
    caae:	3e b6       	in	r3, 0x3e	; 62
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	//static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    cab0:	f0 90 1c 06 	lds	r15, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    cab4:	0e 94 09 2a 	call	0x5412	; 0x5412 <IntOff>
	uint32_t Time = Timer32[TimerN];
    cab8:	24 e0       	ldi	r18, 0x04	; 4
    caba:	f2 9e       	mul	r15, r18
    cabc:	f0 01       	movw	r30, r0
    cabe:	11 24       	eor	r1, r1
    cac0:	ea 57       	subi	r30, 0x7A	; 122
    cac2:	fd 4f       	sbci	r31, 0xFD	; 253
    cac4:	c0 80       	ld	r12, Z
    cac6:	d1 80       	ldd	r13, Z+1	; 0x01
    cac8:	e2 80       	ldd	r14, Z+2	; 0x02
    caca:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    cacc:	0e 94 11 2a 	call	0x5422	; 0x5422 <IntOn>
    cad0:	38 ec       	ldi	r19, 0xC8	; 200
    cad2:	c3 16       	cp	r12, r19
    cad4:	d1 04       	cpc	r13, r1
    cad6:	e1 04       	cpc	r14, r1
    cad8:	f1 04       	cpc	r15, r1
    cada:	38 f4       	brcc	.+14     	; 0xcaea <WebServer+0x76>
    cadc:	4f ef       	ldi	r20, 0xFF	; 255
    cade:	5f ef       	ldi	r21, 0xFF	; 255
    cae0:	ba 01       	movw	r22, r20
    cae2:	80 91 1c 06 	lds	r24, 0x061C
    cae6:	0e 94 09 2c 	call	0x5812	; 0x5812 <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    caea:	80 91 68 09 	lds	r24, 0x0968
    caee:	0e 94 8a 2c 	call	0x5914	; 0x5914 <Timer32Stopp>
    caf2:	81 11       	cpse	r24, r1
    caf4:	10 92 7e 09 	sts	0x097E, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    caf8:	80 91 27 06 	lds	r24, 0x0627
    cafc:	80 36       	cpi	r24, 0x60	; 96
    cafe:	09 f0       	breq	.+2      	; 0xcb02 <WebServer+0x8e>
    cb00:	e1 c3       	rjmp	.+1986   	; 0xd2c4 <WebServer+0x850>
    cb02:	80 91 f4 09 	lds	r24, 0x09F4
    cb06:	81 30       	cpi	r24, 0x01	; 1
    cb08:	09 f0       	breq	.+2      	; 0xcb0c <WebServer+0x98>
    cb0a:	dc c3       	rjmp	.+1976   	; 0xd2c4 <WebServer+0x850>
		
		// 
		if(WebMode == 254){
    cb0c:	80 91 06 01 	lds	r24, 0x0106
    cb10:	8e 3f       	cpi	r24, 0xFE	; 254
    cb12:	71 f5       	brne	.+92     	; 0xcb70 <WebServer+0xfc>
			ptrPage = WebRequest(ptrSite, SiteSize);
    cb14:	6b 2d       	mov	r22, r11
    cb16:	c8 01       	movw	r24, r16
    cb18:	0e 94 d5 48 	call	0x91aa	; 0x91aa <WebRequest>
    cb1c:	90 93 40 02 	sts	0x0240, r25
    cb20:	80 93 3f 02 	sts	0x023F, r24
			if(ptrPage != NULL){
    cb24:	89 2b       	or	r24, r25
    cb26:	41 f0       	breq	.+16     	; 0xcb38 <WebServer+0xc4>
				WebMode = 255;
    cb28:	8f ef       	ldi	r24, 0xFF	; 255
    cb2a:	80 93 06 01 	sts	0x0106, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    cb2e:	64 e1       	ldi	r22, 0x14	; 20
    cb30:	80 91 44 09 	lds	r24, 0x0944
    cb34:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    cb38:	80 91 3e 02 	lds	r24, 0x023E
    cb3c:	88 23       	and	r24, r24
    cb3e:	79 f0       	breq	.+30     	; 0xcb5e <WebServer+0xea>
				if(Timer16Stopp(TD_WaitReqTimout)){
    cb40:	80 91 6a 09 	lds	r24, 0x096A
    cb44:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    cb48:	88 23       	and	r24, r24
    cb4a:	91 f0       	breq	.+36     	; 0xcb70 <WebServer+0xfc>
					GSM_State = GSM_Swtch2CommandMode;
    cb4c:	81 e6       	ldi	r24, 0x61	; 97
    cb4e:	80 93 27 06 	sts	0x0627, r24
					Web_POST = 0;
    cb52:	10 92 6d 09 	sts	0x096D, r1
					WebMode = 254;
    cb56:	8e ef       	ldi	r24, 0xFE	; 254
    cb58:	80 93 06 01 	sts	0x0106, r24
					return;				
    cb5c:	b5 c3       	rjmp	.+1898   	; 0xd2c8 <WebServer+0x854>
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    cb5e:	68 ee       	ldi	r22, 0xE8	; 232
    cb60:	73 e0       	ldi	r23, 0x03	; 3
    cb62:	80 91 6a 09 	lds	r24, 0x096A
    cb66:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				StartTimeoutWaitRequest = 1;
    cb6a:	81 e0       	ldi	r24, 0x01	; 1
    cb6c:	80 93 3e 02 	sts	0x023E, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    cb70:	80 91 08 01 	lds	r24, 0x0108
    cb74:	80 ff       	sbrs	r24, 0
    cb76:	a8 c3       	rjmp	.+1872   	; 0xd2c8 <WebServer+0x854>
    cb78:	80 91 4f 09 	lds	r24, 0x094F
    cb7c:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    cb80:	88 23       	and	r24, r24
    cb82:	09 f4       	brne	.+2      	; 0xcb86 <WebServer+0x112>
    cb84:	a1 c3       	rjmp	.+1858   	; 0xd2c8 <WebServer+0x854>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    cb86:	80 91 06 01 	lds	r24, 0x0106
    cb8a:	8f 3f       	cpi	r24, 0xFF	; 255
    cb8c:	39 f4       	brne	.+14     	; 0xcb9c <WebServer+0x128>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    cb8e:	80 91 44 09 	lds	r24, 0x0944
    cb92:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    cb96:	81 11       	cpse	r24, r1
					WebMode = 0;
    cb98:	10 92 06 01 	sts	0x0106, r1
				}
			}

			// 
			if(WebMode == 2){
    cb9c:	80 91 06 01 	lds	r24, 0x0106
    cba0:	82 30       	cpi	r24, 0x02	; 2
    cba2:	59 f4       	brne	.+22     	; 0xcbba <WebServer+0x146>
				GSM_State = GSM_Swtch2CommandMode;
    cba4:	81 e6       	ldi	r24, 0x61	; 97
    cba6:	80 93 27 06 	sts	0x0627, r24
				WebMode = 254;
    cbaa:	8e ef       	ldi	r24, 0xFE	; 254
    cbac:	80 93 06 01 	sts	0x0106, r24
				Web_Login_Code = 0;
    cbb0:	10 92 09 06 	sts	0x0609, r1
				Web_POST = 0;
    cbb4:	10 92 6d 09 	sts	0x096D, r1
				return;
    cbb8:	87 c3       	rjmp	.+1806   	; 0xd2c8 <WebServer+0x854>
			}
			
			//   
			if(WebMode == 0){
    cbba:	81 11       	cpse	r24, r1
    cbbc:	df c0       	rjmp	.+446    	; 0xcd7c <WebServer+0x308>
				//Not Found
				if(ptrPage == &Web_error_page){
    cbbe:	80 91 3f 02 	lds	r24, 0x023F
    cbc2:	90 91 40 02 	lds	r25, 0x0240
    cbc6:	8c 5b       	subi	r24, 0xBC	; 188
    cbc8:	9b 44       	sbci	r25, 0x4B	; 75
    cbca:	b9 f4       	brne	.+46     	; 0xcbfa <WebServer+0x186>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    cbcc:	44 e7       	ldi	r20, 0x74	; 116
    cbce:	50 e0       	ldi	r21, 0x00	; 0
    cbd0:	69 ec       	ldi	r22, 0xC9	; 201
    cbd2:	7b e4       	ldi	r23, 0x4B	; 75
    cbd4:	89 e3       	ldi	r24, 0x39	; 57
    cbd6:	9c e0       	ldi	r25, 0x0C	; 12
    cbd8:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    cbdc:	84 e7       	ldi	r24, 0x74	; 116
    cbde:	80 93 57 09 	sts	0x0957, r24
					GSM_SendFirstChar();
    cbe2:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    cbe6:	68 ec       	ldi	r22, 0xC8	; 200
    cbe8:	70 e0       	ldi	r23, 0x00	; 0
    cbea:	80 91 4f 09 	lds	r24, 0x094F
    cbee:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
					WebMode = 2;
    cbf2:	82 e0       	ldi	r24, 0x02	; 2
    cbf4:	80 93 06 01 	sts	0x0106, r24
    cbf8:	c1 c0       	rjmp	.+386    	; 0xcd7c <WebServer+0x308>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    cbfa:	41 e1       	ldi	r20, 0x11	; 17
    cbfc:	50 e0       	ldi	r21, 0x00	; 0
    cbfe:	65 ee       	ldi	r22, 0xE5	; 229
    cc00:	7c e4       	ldi	r23, 0x4C	; 76
    cc02:	89 e3       	ldi	r24, 0x39	; 57
    cc04:	9c e0       	ldi	r25, 0x0C	; 12
    cc06:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    cc0a:	4e e0       	ldi	r20, 0x0E	; 14
    cc0c:	50 e0       	ldi	r21, 0x00	; 0
    cc0e:	66 ed       	ldi	r22, 0xD6	; 214
    cc10:	7c e4       	ldi	r23, 0x4C	; 76
    cc12:	8a e4       	ldi	r24, 0x4A	; 74
    cc14:	9c e0       	ldi	r25, 0x0C	; 12
    cc16:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cc1a:	e0 91 3f 02 	lds	r30, 0x023F
    cc1e:	f0 91 40 02 	lds	r31, 0x0240
    cc22:	85 91       	lpm	r24, Z+
    cc24:	94 91       	lpm	r25, Z
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    cc26:	6e e2       	ldi	r22, 0x2E	; 46
    cc28:	70 e0       	ldi	r23, 0x00	; 0
    cc2a:	0e 94 43 6c 	call	0xd886	; 0xd886 <strchr_P>
					if(ext_point_ptr){ 
    cc2e:	00 97       	sbiw	r24, 0x00	; 0
    cc30:	09 f4       	brne	.+2      	; 0xcc34 <WebServer+0x1c0>
    cc32:	89 c0       	rjmp	.+274    	; 0xcd46 <WebServer+0x2d2>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    cc34:	7c 01       	movw	r14, r24
    cc36:	5f ef       	ldi	r21, 0xFF	; 255
    cc38:	e5 1a       	sub	r14, r21
    cc3a:	f5 0a       	sbc	r15, r21
    cc3c:	b7 01       	movw	r22, r14
    cc3e:	85 e9       	ldi	r24, 0x95	; 149
    cc40:	9c e4       	ldi	r25, 0x4C	; 76
    cc42:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <strcmp_PP>
    cc46:	81 11       	cpse	r24, r1
    cc48:	0b c0       	rjmp	.+22     	; 0xcc60 <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    cc4a:	41 e2       	ldi	r20, 0x21	; 33
    cc4c:	50 e0       	ldi	r21, 0x00	; 0
    cc4e:	61 ea       	ldi	r22, 0xA1	; 161
    cc50:	7c e4       	ldi	r23, 0x4C	; 76
    cc52:	88 e5       	ldi	r24, 0x58	; 88
    cc54:	9c e0       	ldi	r25, 0x0C	; 12
    cc56:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
							i += sizeof(html_cp1251_str)-1;
    cc5a:	00 e4       	ldi	r16, 0x40	; 64
    cc5c:	10 e0       	ldi	r17, 0x00	; 0
    cc5e:	67 c0       	rjmp	.+206    	; 0xcd2e <WebServer+0x2ba>
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    cc60:	46 e0       	ldi	r20, 0x06	; 6
    cc62:	50 e0       	ldi	r21, 0x00	; 0
    cc64:	6a e9       	ldi	r22, 0x9A	; 154
    cc66:	7c e4       	ldi	r23, 0x4C	; 76
    cc68:	88 e5       	ldi	r24, 0x58	; 88
    cc6a:	9c e0       	ldi	r25, 0x0C	; 12
    cc6c:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    cc70:	b7 01       	movw	r22, r14
    cc72:	81 e9       	ldi	r24, 0x91	; 145
    cc74:	9c e4       	ldi	r25, 0x4C	; 76
    cc76:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <strcmp_PP>
    cc7a:	81 11       	cpse	r24, r1
    cc7c:	0b c0       	rjmp	.+22     	; 0xcc94 <WebServer+0x220>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    cc7e:	43 e0       	ldi	r20, 0x03	; 3
    cc80:	50 e0       	ldi	r21, 0x00	; 0
    cc82:	61 e9       	ldi	r22, 0x91	; 145
    cc84:	7c e4       	ldi	r23, 0x4C	; 76
    cc86:	8e e5       	ldi	r24, 0x5E	; 94
    cc88:	9c e0       	ldi	r25, 0x0C	; 12
    cc8a:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
								i += sizeof(ico_str)-1;
    cc8e:	08 e2       	ldi	r16, 0x28	; 40
    cc90:	10 e0       	ldi	r17, 0x00	; 0
    cc92:	02 c0       	rjmp	.+4      	; 0xcc98 <WebServer+0x224>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
							i += sizeof(image_str)-1;
    cc94:	05 e2       	ldi	r16, 0x25	; 37
    cc96:	10 e0       	ldi	r17, 0x00	; 0
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    cc98:	b7 01       	movw	r22, r14
    cc9a:	8d e8       	ldi	r24, 0x8D	; 141
    cc9c:	9c e4       	ldi	r25, 0x4C	; 76
    cc9e:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <strcmp_PP>
    cca2:	81 11       	cpse	r24, r1
    cca4:	0b c0       	rjmp	.+22     	; 0xccbc <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    cca6:	43 e0       	ldi	r20, 0x03	; 3
    cca8:	50 e0       	ldi	r21, 0x00	; 0
    ccaa:	6d e8       	ldi	r22, 0x8D	; 141
    ccac:	7c e4       	ldi	r23, 0x4C	; 76
    ccae:	c8 01       	movw	r24, r16
    ccb0:	87 5c       	subi	r24, 0xC7	; 199
    ccb2:	93 4f       	sbci	r25, 0xF3	; 243
    ccb4:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
								i += sizeof(gif_str)-1;								
    ccb8:	0d 5f       	subi	r16, 0xFD	; 253
    ccba:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    ccbc:	b7 01       	movw	r22, r14
    ccbe:	88 e8       	ldi	r24, 0x88	; 136
    ccc0:	9c e4       	ldi	r25, 0x4C	; 76
    ccc2:	0e 94 4f 47 	call	0x8e9e	; 0x8e9e <strcmp_PP>
    ccc6:	81 11       	cpse	r24, r1
    ccc8:	0b c0       	rjmp	.+22     	; 0xcce0 <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    ccca:	44 e0       	ldi	r20, 0x04	; 4
    cccc:	50 e0       	ldi	r21, 0x00	; 0
    ccce:	68 e8       	ldi	r22, 0x88	; 136
    ccd0:	7c e4       	ldi	r23, 0x4C	; 76
    ccd2:	c8 01       	movw	r24, r16
    ccd4:	87 5c       	subi	r24, 0xC7	; 199
    ccd6:	93 4f       	sbci	r25, 0xF3	; 243
    ccd8:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    ccdc:	0c 5f       	subi	r16, 0xFC	; 252
    ccde:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    cce0:	42 e1       	ldi	r20, 0x12	; 18
    cce2:	50 e0       	ldi	r21, 0x00	; 0
    cce4:	63 ec       	ldi	r22, 0xC3	; 195
    cce6:	7c e4       	ldi	r23, 0x4C	; 76
    cce8:	c8 01       	movw	r24, r16
    ccea:	87 5c       	subi	r24, 0xC7	; 199
    ccec:	93 4f       	sbci	r25, 0xF3	; 243
    ccee:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
							i += sizeof(Content_Length)-1;
    ccf2:	0e 5e       	subi	r16, 0xEE	; 238
    ccf4:	1f 4f       	sbci	r17, 0xFF	; 255
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    ccf6:	e0 91 3f 02 	lds	r30, 0x023F
    ccfa:	f0 91 40 02 	lds	r31, 0x0240
    ccfe:	38 96       	adiw	r30, 0x08	; 8

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cd00:	85 91       	lpm	r24, Z+
    cd02:	94 91       	lpm	r25, Z
    cd04:	9f 93       	push	r25
    cd06:	8f 93       	push	r24
    cd08:	85 e0       	ldi	r24, 0x05	; 5
    cd0a:	93 e0       	ldi	r25, 0x03	; 3
    cd0c:	9f 93       	push	r25
    cd0e:	8f 93       	push	r24
    cd10:	c8 01       	movw	r24, r16
    cd12:	87 5c       	subi	r24, 0xC7	; 199
    cd14:	93 4f       	sbci	r25, 0xF3	; 243
    cd16:	9f 93       	push	r25
    cd18:	8f 93       	push	r24
    cd1a:	0e 94 04 6d 	call	0xda08	; 0xda08 <sprintf_P>
    cd1e:	08 0f       	add	r16, r24
    cd20:	19 1f       	adc	r17, r25
    cd22:	0f 90       	pop	r0
    cd24:	0f 90       	pop	r0
    cd26:	0f 90       	pop	r0
    cd28:	0f 90       	pop	r0
    cd2a:	0f 90       	pop	r0
    cd2c:	0f 90       	pop	r0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    cd2e:	45 e1       	ldi	r20, 0x15	; 21
    cd30:	50 e0       	ldi	r21, 0x00	; 0
    cd32:	62 e7       	ldi	r22, 0x72	; 114
    cd34:	7c e4       	ldi	r23, 0x4C	; 76
    cd36:	c8 01       	movw	r24, r16
    cd38:	87 5c       	subi	r24, 0xC7	; 199
    cd3a:	93 4f       	sbci	r25, 0xF3	; 243
    cd3c:	0e 94 3a 6c 	call	0xd874	; 0xd874 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    cd40:	0b 5e       	subi	r16, 0xEB	; 235
    cd42:	1f 4f       	sbci	r17, 0xFF	; 255
    cd44:	02 c0       	rjmp	.+4      	; 0xcd4a <WebServer+0x2d6>
					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
					i += sizeof(Content_Type)-1;
    cd46:	0f e1       	ldi	r16, 0x1F	; 31
    cd48:	10 e0       	ldi	r17, 0x00	; 0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
						i += sizeof(Connection_Close)-1;

					}
					WebDataCnt = 0;
    cd4a:	10 92 f1 03 	sts	0x03F1, r1
    cd4e:	10 92 f0 03 	sts	0x03F0, r1
					WebInputHiddenCnt = 0;
    cd52:	10 92 e9 03 	sts	0x03E9, r1
					WebHrefHiddenCnt = 0;
    cd56:	10 92 28 06 	sts	0x0628, r1
					WebImgSrcHiddenCnt = 0;
    cd5a:	10 92 e8 03 	sts	0x03E8, r1
					ptrIF = prp(&ptrPage->IF_List);
    cd5e:	e0 91 3f 02 	lds	r30, 0x023F
    cd62:	f0 91 40 02 	lds	r31, 0x0240
    cd66:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cd68:	85 91       	lpm	r24, Z+
    cd6a:	94 91       	lpm	r25, Z
    cd6c:	90 93 3d 02 	sts	0x023D, r25
    cd70:	80 93 3c 02 	sts	0x023C, r24
					WebMode = 1;
    cd74:	81 e0       	ldi	r24, 0x01	; 1
    cd76:	80 93 06 01 	sts	0x0106, r24
    cd7a:	02 c0       	rjmp	.+4      	; 0xcd80 <WebServer+0x30c>


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){

			uint16_t i=0;
    cd7c:	00 e0       	ldi	r16, 0x00	; 0
    cd7e:	10 e0       	ldi	r17, 0x00	; 0
					WebMode = 1;
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    cd80:	80 91 06 01 	lds	r24, 0x0106
    cd84:	81 30       	cpi	r24, 0x01	; 1
    cd86:	09 f0       	breq	.+2      	; 0xcd8a <WebServer+0x316>
    cd88:	9f c2       	rjmp	.+1342   	; 0xd2c8 <WebServer+0x854>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    cd8a:	bb 24       	eor	r11, r11
    cd8c:	b3 94       	inc	r11
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    cd8e:	0f 3f       	cpi	r16, 0xFF	; 255
    cd90:	11 05       	cpc	r17, r1
    cd92:	08 f0       	brcs	.+2      	; 0xcd96 <WebServer+0x322>
    cd94:	b0 c0       	rjmp	.+352    	; 0xcef6 <WebServer+0x482>
					char ch;
					if(WebImgSrcHiddenCnt){
    cd96:	80 91 e8 03 	lds	r24, 0x03E8
    cd9a:	c0 90 3f 02 	lds	r12, 0x023F
    cd9e:	d0 90 40 02 	lds	r13, 0x0240
    cda2:	88 23       	and	r24, r24
    cda4:	a1 f0       	breq	.+40     	; 0xcdce <WebServer+0x35a>
    cda6:	e8 2f       	mov	r30, r24
    cda8:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    cdaa:	89 30       	cpi	r24, 0x09	; 9
    cdac:	20 f0       	brcs	.+8      	; 0xcdb6 <WebServer+0x342>
    cdae:	e0 5e       	subi	r30, 0xE0	; 224
    cdb0:	f9 4f       	sbci	r31, 0xF9	; 249
    cdb2:	a0 80       	ld	r10, Z
    cdb4:	03 c0       	rjmp	.+6      	; 0xcdbc <WebServer+0x348>
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
    cdb6:	e3 5c       	subi	r30, 0xC3	; 195
    cdb8:	f3 4b       	sbci	r31, 0xB3	; 179

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cdba:	a4 90       	lpm	r10, Z
						WebImgSrcHiddenCnt++ ;
    cdbc:	8f 5f       	subi	r24, 0xFF	; 255
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    cdbe:	89 31       	cpi	r24, 0x19	; 25
    cdc0:	18 f4       	brcc	.+6      	; 0xcdc8 <WebServer+0x354>
					char ch;
					if(WebImgSrcHiddenCnt){
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    cdc2:	80 93 e8 03 	sts	0x03E8, r24
    cdc6:	46 c0       	rjmp	.+140    	; 0xce54 <WebServer+0x3e0>
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    cdc8:	10 92 e8 03 	sts	0x03E8, r1
    cdcc:	43 c0       	rjmp	.+134    	; 0xce54 <WebServer+0x3e0>
					}
					else{
						if(WebHrefHiddenCnt){
    cdce:	80 91 28 06 	lds	r24, 0x0628
    cdd2:	88 23       	and	r24, r24
    cdd4:	a1 f0       	breq	.+40     	; 0xcdfe <WebServer+0x38a>
    cdd6:	e8 2f       	mov	r30, r24
    cdd8:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    cdda:	89 30       	cpi	r24, 0x09	; 9
    cddc:	20 f0       	brcs	.+8      	; 0xcde6 <WebServer+0x372>
    cdde:	e0 5e       	subi	r30, 0xE0	; 224
    cde0:	f9 4f       	sbci	r31, 0xF9	; 249
    cde2:	a0 80       	ld	r10, Z
    cde4:	03 c0       	rjmp	.+6      	; 0xcdec <WebServer+0x378>
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
    cde6:	e3 5c       	subi	r30, 0xC3	; 195
    cde8:	f3 4b       	sbci	r31, 0xB3	; 179
    cdea:	a4 90       	lpm	r10, Z
							WebHrefHiddenCnt++ ;
    cdec:	8f 5f       	subi	r24, 0xFF	; 255
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    cdee:	89 31       	cpi	r24, 0x19	; 25
    cdf0:	18 f4       	brcc	.+6      	; 0xcdf8 <WebServer+0x384>
					else{
						if(WebHrefHiddenCnt){
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    cdf2:	80 93 28 06 	sts	0x0628, r24
    cdf6:	2e c0       	rjmp	.+92     	; 0xce54 <WebServer+0x3e0>
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    cdf8:	10 92 28 06 	sts	0x0628, r1
    cdfc:	2b c0       	rjmp	.+86     	; 0xce54 <WebServer+0x3e0>
						}
						else{
							if(WebInputHiddenCnt){
    cdfe:	80 91 e9 03 	lds	r24, 0x03E9
    ce02:	88 23       	and	r24, r24
    ce04:	a1 f0       	breq	.+40     	; 0xce2e <WebServer+0x3ba>
    ce06:	e8 2f       	mov	r30, r24
    ce08:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    ce0a:	8b 32       	cpi	r24, 0x2B	; 43
    ce0c:	20 f0       	brcs	.+8      	; 0xce16 <WebServer+0x3a2>
    ce0e:	e2 50       	subi	r30, 0x02	; 2
    ce10:	fa 4f       	sbci	r31, 0xFA	; 250
    ce12:	a0 80       	ld	r10, Z
    ce14:	03 c0       	rjmp	.+6      	; 0xce1c <WebServer+0x3a8>
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
    ce16:	ea 5b       	subi	r30, 0xBA	; 186
    ce18:	f3 4b       	sbci	r31, 0xB3	; 179
    ce1a:	a4 90       	lpm	r10, Z
								WebInputHiddenCnt++ ;
    ce1c:	8f 5f       	subi	r24, 0xFF	; 255
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    ce1e:	8e 33       	cpi	r24, 0x3E	; 62
    ce20:	18 f4       	brcc	.+6      	; 0xce28 <WebServer+0x3b4>
						else{
							if(WebInputHiddenCnt){
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    ce22:	80 93 e9 03 	sts	0x03E9, r24
    ce26:	16 c0       	rjmp	.+44     	; 0xce54 <WebServer+0x3e0>
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    ce28:	10 92 e9 03 	sts	0x03E9, r1
    ce2c:	13 c0       	rjmp	.+38     	; 0xce54 <WebServer+0x3e0>
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    ce2e:	f6 01       	movw	r30, r12
    ce30:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce32:	25 91       	lpm	r18, Z+
    ce34:	34 91       	lpm	r19, Z
    ce36:	80 91 f0 03 	lds	r24, 0x03F0
    ce3a:	90 91 f1 03 	lds	r25, 0x03F1
    ce3e:	ac 01       	movw	r20, r24
    ce40:	4f 5f       	subi	r20, 0xFF	; 255
    ce42:	5f 4f       	sbci	r21, 0xFF	; 255
    ce44:	50 93 f1 03 	sts	0x03F1, r21
    ce48:	40 93 f0 03 	sts	0x03F0, r20
    ce4c:	f9 01       	movw	r30, r18
    ce4e:	e8 0f       	add	r30, r24
    ce50:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ce52:	a4 90       	lpm	r10, Z
							}
						}
					}

					GSM_TxStr[i++] = ch;
    ce54:	78 01       	movw	r14, r16
    ce56:	8f ef       	ldi	r24, 0xFF	; 255
    ce58:	e8 1a       	sub	r14, r24
    ce5a:	f8 0a       	sbc	r15, r24
    ce5c:	d8 01       	movw	r26, r16
    ce5e:	a7 5c       	subi	r26, 0xC7	; 199
    ce60:	b3 4f       	sbci	r27, 0xF3	; 243
    ce62:	ac 92       	st	X, r10
					if(ptrPage != &Web_login){	//  login.html   !
    ce64:	95 e9       	ldi	r25, 0x95	; 149
    ce66:	c9 16       	cp	r12, r25
    ce68:	98 e4       	ldi	r25, 0x48	; 72
    ce6a:	d9 06       	cpc	r13, r25
    ce6c:	59 f1       	breq	.+86     	; 0xcec4 <WebServer+0x450>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    ce6e:	8a 2d       	mov	r24, r10
    ce70:	0e 94 91 47 	call	0x8f22	; 0x8f22 <SeekTagFORM>
    ce74:	81 11       	cpse	r24, r1
    ce76:	b0 92 e9 03 	sts	0x03E9, r11
						if(SeekTagA_HREF(ch)){ 
    ce7a:	8a 2d       	mov	r24, r10
    ce7c:	0e 94 cd 47 	call	0x8f9a	; 0x8f9a <SeekTagA_HREF>
    ce80:	88 23       	and	r24, r24
    ce82:	69 f0       	breq	.+26     	; 0xce9e <WebServer+0x42a>
							WebHrefHiddenCnt = 1;
    ce84:	b0 92 28 06 	sts	0x0628, r11
							i--;
							WebDataCnt--;
    ce88:	20 91 f0 03 	lds	r18, 0x03F0
    ce8c:	30 91 f1 03 	lds	r19, 0x03F1
    ce90:	21 50       	subi	r18, 0x01	; 1
    ce92:	31 09       	sbc	r19, r1
    ce94:	30 93 f1 03 	sts	0x03F1, r19
    ce98:	20 93 f0 03 	sts	0x03F0, r18
    ce9c:	78 01       	movw	r14, r16
						}
						if(SeekTagIMG_SRC(ch)){ 
    ce9e:	8a 2d       	mov	r24, r10
    cea0:	0e 94 09 48 	call	0x9012	; 0x9012 <SeekTagIMG_SRC>
    cea4:	88 23       	and	r24, r24
    cea6:	71 f0       	breq	.+28     	; 0xcec4 <WebServer+0x450>
							WebImgSrcHiddenCnt = 1;
    cea8:	b0 92 e8 03 	sts	0x03E8, r11
							i--;
    ceac:	e1 e0       	ldi	r30, 0x01	; 1
    ceae:	ee 1a       	sub	r14, r30
    ceb0:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    ceb2:	80 91 f0 03 	lds	r24, 0x03F0
    ceb6:	90 91 f1 03 	lds	r25, 0x03F1
    ceba:	01 97       	sbiw	r24, 0x01	; 1
    cebc:	90 93 f1 03 	sts	0x03F1, r25
    cec0:	80 93 f0 03 	sts	0x03F0, r24
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    cec4:	f8 e0       	ldi	r31, 0x08	; 8
    cec6:	cf 0e       	add	r12, r31
    cec8:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    ceca:	f6 01       	movw	r30, r12
    cecc:	85 91       	lpm	r24, Z+
    cece:	94 91       	lpm	r25, Z
    ced0:	20 91 f0 03 	lds	r18, 0x03F0
    ced4:	30 91 f1 03 	lds	r19, 0x03F1
    ced8:	28 17       	cp	r18, r24
    ceda:	39 07       	cpc	r19, r25
    cedc:	10 f4       	brcc	.+4      	; 0xcee2 <WebServer+0x46e>
    cede:	87 01       	movw	r16, r14
    cee0:	56 cf       	rjmp	.-340    	; 0xcd8e <WebServer+0x31a>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    cee2:	68 ec       	ldi	r22, 0xC8	; 200
    cee4:	70 e0       	ldi	r23, 0x00	; 0
    cee6:	80 91 4f 09 	lds	r24, 0x094F
    ceea:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
						WebMode = 2;
    ceee:	82 e0       	ldi	r24, 0x02	; 2
    cef0:	80 93 06 01 	sts	0x0106, r24
						break;
    cef4:	87 01       	movw	r16, r14
					}
				}
				//
				if(ptrIF != NULL){
    cef6:	c0 90 3c 02 	lds	r12, 0x023C
    cefa:	d0 90 3d 02 	lds	r13, 0x023D
    cefe:	c1 14       	cp	r12, r1
    cf00:	d1 04       	cpc	r13, r1
    cf02:	09 f4       	brne	.+2      	; 0xcf06 <WebServer+0x492>
    cf04:	be c1       	rjmp	.+892    	; 0xd282 <WebServer+0x80e>
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    cf06:	e0 91 3f 02 	lds	r30, 0x023F
    cf0a:	f0 91 40 02 	lds	r31, 0x0240
    cf0e:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cf10:	25 91       	lpm	r18, Z+
    cf12:	34 91       	lpm	r19, Z
    cf14:	80 91 f0 03 	lds	r24, 0x03F0
    cf18:	90 91 f1 03 	lds	r25, 0x03F1
    cf1c:	f9 01       	movw	r30, r18
    cf1e:	e8 0f       	add	r30, r24
    cf20:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cf22:	24 91       	lpm	r18, Z
    cf24:	2b 37       	cpi	r18, 0x7B	; 123
    cf26:	a1 f4       	brne	.+40     	; 0xcf50 <WebServer+0x4dc>
    cf28:	80 1b       	sub	r24, r16
    cf2a:	91 0b       	sbc	r25, r17
    cf2c:	ac 01       	movw	r20, r24
    cf2e:	40 0f       	add	r20, r16
    cf30:	51 1f       	adc	r21, r17
						while(GSM_TxStr[i-1] == '{'){
    cf32:	98 01       	movw	r18, r16
    cf34:	21 50       	subi	r18, 0x01	; 1
    cf36:	31 09       	sbc	r19, r1
    cf38:	f9 01       	movw	r30, r18
    cf3a:	e7 5c       	subi	r30, 0xC7	; 199
    cf3c:	f3 4f       	sbci	r31, 0xF3	; 243
    cf3e:	60 81       	ld	r22, Z
    cf40:	6b 37       	cpi	r22, 0x7B	; 123
    cf42:	11 f4       	brne	.+4      	; 0xcf48 <WebServer+0x4d4>
							WebDataCnt--;
							i--;
    cf44:	89 01       	movw	r16, r18
    cf46:	f2 cf       	rjmp	.-28     	; 0xcf2c <WebServer+0x4b8>
    cf48:	50 93 f1 03 	sts	0x03F1, r21
    cf4c:	40 93 f0 03 	sts	0x03F0, r20
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    cf50:	0b 87       	std	Y+11, r16	; 0x0b
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    cf52:	61 2c       	mov	r6, r1
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    cf54:	aa 24       	eor	r10, r10
    cf56:	a3 94       	inc	r10
    cf58:	b1 2c       	mov	r11, r1
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    cf5a:	ab e3       	ldi	r26, 0x3B	; 59
    cf5c:	4a 2e       	mov	r4, r26
    cf5e:	a1 e0       	ldi	r26, 0x01	; 1
    cf60:	5a 2e       	mov	r5, r26
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    cf62:	4b 85       	ldd	r20, Y+11	; 0x0b
    cf64:	64 16       	cp	r6, r20
    cf66:	08 f0       	brcs	.+2      	; 0xcf6a <WebServer+0x4f6>
    cf68:	88 c1       	rjmp	.+784    	; 0xd27a <WebServer+0x806>
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    cf6a:	e6 2c       	mov	r14, r6
    cf6c:	f1 2c       	mov	r15, r1
    cf6e:	97 01       	movw	r18, r14
    cf70:	27 5c       	subi	r18, 0xC7	; 199
    cf72:	33 4f       	sbci	r19, 0xF3	; 243
    cf74:	79 01       	movw	r14, r18
    cf76:	3a 83       	std	Y+2, r19	; 0x02
    cf78:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
    cf7a:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    cf7c:	f9 01       	movw	r30, r18
    cf7e:	70 80       	ld	r7, Z
    cf80:	fb e7       	ldi	r31, 0x7B	; 123
    cf82:	7f 12       	cpse	r7, r31
    cf84:	6f c1       	rjmp	.+734    	; 0xd264 <WebServer+0x7f0>
    cf86:	80 e0       	ldi	r24, 0x00	; 0
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    cf88:	8f 5f       	subi	r24, 0xFF	; 255
    cf8a:	48 2f       	mov	r20, r24
    cf8c:	50 e0       	ldi	r21, 0x00	; 0
    cf8e:	f7 01       	movw	r30, r14
    cf90:	e4 0f       	add	r30, r20
    cf92:	f5 1f       	adc	r31, r21
    cf94:	70 80       	ld	r7, Z
    cf96:	2b e7       	ldi	r18, 0x7B	; 123
    cf98:	72 16       	cp	r7, r18
    cf9a:	b1 f3       	breq	.-20     	; 0xcf88 <WebServer+0x514>
    cf9c:	8c 83       	std	Y+4, r24	; 0x04
			Param.Prec = prb(&IF->Prec);
    cf9e:	f6 01       	movw	r30, r12
    cfa0:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cfa2:	e4 91       	lpm	r30, Z
    cfa4:	eb 83       	std	Y+3, r30	; 0x03
			Param.Txt = prp(&IF->EnumList);
    cfa6:	f6 01       	movw	r30, r12
    cfa8:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cfaa:	85 90       	lpm	r8, Z+
    cfac:	94 90       	lpm	r9, Z
    cfae:	9e 82       	std	Y+6, r9	; 0x06
    cfb0:	8d 82       	std	Y+5, r8	; 0x05
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    cfb2:	f6 01       	movw	r30, r12
    cfb4:	31 96       	adiw	r30, 0x01	; 1
    cfb6:	a5 91       	lpm	r26, Z+
    cfb8:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cfba:	f6 01       	movw	r30, r12
    cfbc:	64 91       	lpm	r22, Z
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    cfbe:	70 e0       	ldi	r23, 0x00	; 0
    cfc0:	63 32       	cpi	r22, 0x23	; 35
    cfc2:	71 05       	cpc	r23, r1
    cfc4:	08 f0       	brcs	.+2      	; 0xcfc8 <WebServer+0x554>
    cfc6:	4b c1       	rjmp	.+662    	; 0xd25e <WebServer+0x7ea>
    cfc8:	fb 01       	movw	r30, r22
    cfca:	ee 5b       	subi	r30, 0xBE	; 190
    cfcc:	fe 4f       	sbci	r31, 0xFE	; 254
    cfce:	0c 94 95 75 	jmp	0xeb2a	; 0xeb2a <__tablejump2__>
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    cfd2:	8c 91       	ld	r24, X
    cfd4:	03 c0       	rjmp	.+6      	; 0xcfdc <WebServer+0x568>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cfd6:	cd 01       	movw	r24, r26
    cfd8:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    cfdc:	ae 01       	movw	r20, r28
    cfde:	4f 5f       	subi	r20, 0xFF	; 255
    cfe0:	5f 4f       	sbci	r21, 0xFF	; 255
    cfe2:	62 e6       	ldi	r22, 0x62	; 98
    cfe4:	90 e0       	ldi	r25, 0x00	; 0
    cfe6:	0e 94 97 3e 	call	0x7d2e	; 0x7d2e <PutVal>
    cfea:	39 c1       	rjmp	.+626    	; 0xd25e <WebServer+0x7ea>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    cfec:	8c 91       	ld	r24, X
    cfee:	03 c0       	rjmp	.+6      	; 0xcff6 <WebServer+0x582>
    cff0:	cd 01       	movw	r24, r26
    cff2:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    cff6:	ae 01       	movw	r20, r28
    cff8:	4f 5f       	subi	r20, 0xFF	; 255
    cffa:	5f 4f       	sbci	r21, 0xFF	; 255
    cffc:	62 e6       	ldi	r22, 0x62	; 98
    cffe:	99 27       	eor	r25, r25
    d000:	87 fd       	sbrc	r24, 7
    d002:	90 95       	com	r25
    d004:	0e 94 12 3f 	call	0x7e24	; 0x7e24 <Put_sVal>
    d008:	2a c1       	rjmp	.+596    	; 0xd25e <WebServer+0x7ea>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    d00a:	8c 91       	ld	r24, X
    d00c:	03 c0       	rjmp	.+6      	; 0xd014 <WebServer+0x5a0>
    d00e:	cd 01       	movw	r24, r26
    d010:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    d014:	ae 01       	movw	r20, r28
    d016:	4f 5f       	subi	r20, 0xFF	; 255
    d018:	5f 4f       	sbci	r21, 0xFF	; 255
    d01a:	62 e6       	ldi	r22, 0x62	; 98
    d01c:	90 e0       	ldi	r25, 0x00	; 0
    d01e:	0e 94 bc 3f 	call	0x7f78	; 0x7f78 <Put_zVal>
    d022:	1d c1       	rjmp	.+570    	; 0xd25e <WebServer+0x7ea>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    d024:	6c 91       	ld	r22, X
    d026:	70 e0       	ldi	r23, 0x00	; 0
    d028:	80 e0       	ldi	r24, 0x00	; 0
    d02a:	90 e0       	ldi	r25, 0x00	; 0
    d02c:	9e 01       	movw	r18, r28
    d02e:	2f 5f       	subi	r18, 0xFF	; 255
    d030:	3f 4f       	sbci	r19, 0xFF	; 255
    d032:	42 e6       	ldi	r20, 0x62	; 98
    d034:	08 c0       	rjmp	.+16     	; 0xd046 <WebServer+0x5d2>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    d036:	6d 91       	ld	r22, X+
    d038:	7c 91       	ld	r23, X
    d03a:	80 e0       	ldi	r24, 0x00	; 0
    d03c:	90 e0       	ldi	r25, 0x00	; 0
    d03e:	9e 01       	movw	r18, r28
    d040:	2f 5f       	subi	r18, 0xFF	; 255
    d042:	3f 4f       	sbci	r19, 0xFF	; 255
    d044:	47 e7       	ldi	r20, 0x77	; 119
    d046:	0e 94 37 40 	call	0x806e	; 0x806e <Put_zVal_h>
    d04a:	09 c1       	rjmp	.+530    	; 0xd25e <WebServer+0x7ea>
    d04c:	13 96       	adiw	r26, 0x03	; 3
    d04e:	8c 91       	ld	r24, X
    d050:	13 97       	sbiw	r26, 0x03	; 3
    d052:	8f 93       	push	r24
    d054:	12 96       	adiw	r26, 0x02	; 2
    d056:	8c 91       	ld	r24, X
    d058:	12 97       	sbiw	r26, 0x02	; 2
    d05a:	8f 93       	push	r24
    d05c:	11 96       	adiw	r26, 0x01	; 1
    d05e:	8c 91       	ld	r24, X
    d060:	11 97       	sbiw	r26, 0x01	; 1
    d062:	8f 93       	push	r24
    d064:	8c 91       	ld	r24, X
    d066:	8f 93       	push	r24
    d068:	5f 92       	push	r5
    d06a:	4f 92       	push	r4
    d06c:	ff 92       	push	r15
    d06e:	ef 92       	push	r14
    d070:	0e 94 d5 6c 	call	0xd9aa	; 0xd9aa <sprintf>
    d074:	2d b7       	in	r18, 0x3d	; 61
    d076:	3e b7       	in	r19, 0x3e	; 62
    d078:	28 5f       	subi	r18, 0xF8	; 248
    d07a:	3f 4f       	sbci	r19, 0xFF	; 255
    d07c:	0f b6       	in	r0, 0x3f	; 63
    d07e:	f8 94       	cli
    d080:	3e bf       	out	0x3e, r19	; 62
    d082:	0f be       	out	0x3f, r0	; 63
    d084:	2d bf       	out	0x3d, r18	; 61
    d086:	eb c0       	rjmp	.+470    	; 0xd25e <WebServer+0x7ea>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    d088:	ae 01       	movw	r20, r28
    d08a:	4f 5f       	subi	r20, 0xFF	; 255
    d08c:	5f 4f       	sbci	r21, 0xFF	; 255
    d08e:	67 e7       	ldi	r22, 0x77	; 119
    d090:	8d 91       	ld	r24, X+
    d092:	9c 91       	ld	r25, X
    d094:	a8 cf       	rjmp	.-176    	; 0xcfe6 <WebServer+0x572>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d096:	cd 01       	movw	r24, r26
    d098:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    d09c:	ae 01       	movw	r20, r28
    d09e:	4f 5f       	subi	r20, 0xFF	; 255
    d0a0:	5f 4f       	sbci	r21, 0xFF	; 255
    d0a2:	67 e7       	ldi	r22, 0x77	; 119
    d0a4:	a0 cf       	rjmp	.-192    	; 0xcfe6 <WebServer+0x572>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    d0a6:	ae 01       	movw	r20, r28
    d0a8:	4f 5f       	subi	r20, 0xFF	; 255
    d0aa:	5f 4f       	sbci	r21, 0xFF	; 255
    d0ac:	67 e7       	ldi	r22, 0x77	; 119
    d0ae:	8d 91       	ld	r24, X+
    d0b0:	9c 91       	ld	r25, X
    d0b2:	a8 cf       	rjmp	.-176    	; 0xd004 <WebServer+0x590>
    d0b4:	cd 01       	movw	r24, r26
    d0b6:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    d0ba:	ae 01       	movw	r20, r28
    d0bc:	4f 5f       	subi	r20, 0xFF	; 255
    d0be:	5f 4f       	sbci	r21, 0xFF	; 255
    d0c0:	67 e7       	ldi	r22, 0x77	; 119
    d0c2:	a0 cf       	rjmp	.-192    	; 0xd004 <WebServer+0x590>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    d0c4:	ae 01       	movw	r20, r28
    d0c6:	4f 5f       	subi	r20, 0xFF	; 255
    d0c8:	5f 4f       	sbci	r21, 0xFF	; 255
    d0ca:	67 e7       	ldi	r22, 0x77	; 119
    d0cc:	8d 91       	ld	r24, X+
    d0ce:	9c 91       	ld	r25, X
    d0d0:	a6 cf       	rjmp	.-180    	; 0xd01e <WebServer+0x5aa>
    d0d2:	cd 01       	movw	r24, r26
    d0d4:	0e 94 ee 73 	call	0xe7dc	; 0xe7dc <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    d0d8:	ae 01       	movw	r20, r28
    d0da:	4f 5f       	subi	r20, 0xFF	; 255
    d0dc:	5f 4f       	sbci	r21, 0xFF	; 255
    d0de:	67 e7       	ldi	r22, 0x77	; 119
    d0e0:	9e cf       	rjmp	.-196    	; 0xd01e <WebServer+0x5aa>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    d0e2:	6d 91       	ld	r22, X+
    d0e4:	7d 91       	ld	r23, X+
    d0e6:	8d 91       	ld	r24, X+
    d0e8:	9c 91       	ld	r25, X
    d0ea:	03 c0       	rjmp	.+6      	; 0xd0f2 <WebServer+0x67e>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    d0ec:	cd 01       	movw	r24, r26
    d0ee:	0e 94 e8 73 	call	0xe7d0	; 0xe7d0 <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    d0f2:	ae 01       	movw	r20, r28
    d0f4:	4f 5f       	subi	r20, 0xFF	; 255
    d0f6:	5f 4f       	sbci	r21, 0xFF	; 255
    d0f8:	0e 94 6d 40 	call	0x80da	; 0x80da <PutDVal>
    d0fc:	b0 c0       	rjmp	.+352    	; 0xd25e <WebServer+0x7ea>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    d0fe:	6d 91       	ld	r22, X+
    d100:	7d 91       	ld	r23, X+
    d102:	8d 91       	ld	r24, X+
    d104:	9c 91       	ld	r25, X
    d106:	03 c0       	rjmp	.+6      	; 0xd10e <WebServer+0x69a>
    d108:	cd 01       	movw	r24, r26
    d10a:	0e 94 e8 73 	call	0xe7d0	; 0xe7d0 <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    d10e:	ae 01       	movw	r20, r28
    d110:	4f 5f       	subi	r20, 0xFF	; 255
    d112:	5f 4f       	sbci	r21, 0xFF	; 255
    d114:	0e 94 00 41 	call	0x8200	; 0x8200 <Put_sDVal>
    d118:	a2 c0       	rjmp	.+324    	; 0xd25e <WebServer+0x7ea>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    d11a:	6d 91       	ld	r22, X+
    d11c:	7d 91       	ld	r23, X+
    d11e:	8d 91       	ld	r24, X+
    d120:	9c 91       	ld	r25, X
    d122:	03 c0       	rjmp	.+6      	; 0xd12a <WebServer+0x6b6>
    d124:	cd 01       	movw	r24, r26
    d126:	0e 94 e8 73 	call	0xe7d0	; 0xe7d0 <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    d12a:	ae 01       	movw	r20, r28
    d12c:	4f 5f       	subi	r20, 0xFF	; 255
    d12e:	5f 4f       	sbci	r21, 0xFF	; 255
    d130:	0e 94 f8 41 	call	0x83f0	; 0x83f0 <Put_zDVal>
    d134:	94 c0       	rjmp	.+296    	; 0xd25e <WebServer+0x7ea>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    d136:	6d 91       	ld	r22, X+
    d138:	7d 91       	ld	r23, X+
    d13a:	8d 91       	ld	r24, X+
    d13c:	9c 91       	ld	r25, X
    d13e:	0b c0       	rjmp	.+22     	; 0xd156 <WebServer+0x6e2>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d140:	44 e0       	ldi	r20, 0x04	; 4
    d142:	50 e0       	ldi	r21, 0x00	; 0
    d144:	bd 01       	movw	r22, r26
    d146:	ce 01       	movw	r24, r28
    d148:	07 96       	adiw	r24, 0x07	; 7
    d14a:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    d14e:	6f 81       	ldd	r22, Y+7	; 0x07
    d150:	78 85       	ldd	r23, Y+8	; 0x08
    d152:	89 85       	ldd	r24, Y+9	; 0x09
    d154:	9a 85       	ldd	r25, Y+10	; 0x0a
    d156:	ae 01       	movw	r20, r28
    d158:	4f 5f       	subi	r20, 0xFF	; 255
    d15a:	5f 4f       	sbci	r21, 0xFF	; 255
    d15c:	0e 94 8b 42 	call	0x8516	; 0x8516 <Put_FFVal>
    d160:	7e c0       	rjmp	.+252    	; 0xd25e <WebServer+0x7ea>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    d162:	6d 91       	ld	r22, X+
    d164:	7d 91       	ld	r23, X+
    d166:	8d 91       	ld	r24, X+
    d168:	9c 91       	ld	r25, X
    d16a:	0b c0       	rjmp	.+22     	; 0xd182 <WebServer+0x70e>
    d16c:	44 e0       	ldi	r20, 0x04	; 4
    d16e:	50 e0       	ldi	r21, 0x00	; 0
    d170:	bd 01       	movw	r22, r26
    d172:	ce 01       	movw	r24, r28
    d174:	07 96       	adiw	r24, 0x07	; 7
    d176:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    d17a:	6f 81       	ldd	r22, Y+7	; 0x07
    d17c:	78 85       	ldd	r23, Y+8	; 0x08
    d17e:	89 85       	ldd	r24, Y+9	; 0x09
    d180:	9a 85       	ldd	r25, Y+10	; 0x0a
    d182:	ae 01       	movw	r20, r28
    d184:	4f 5f       	subi	r20, 0xFF	; 255
    d186:	5f 4f       	sbci	r21, 0xFF	; 255
    d188:	0e 94 c9 42 	call	0x8592	; 0x8592 <Put_GFVal>
    d18c:	68 c0       	rjmp	.+208    	; 0xd25e <WebServer+0x7ea>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    d18e:	8c 91       	ld	r24, X
    d190:	03 c0       	rjmp	.+6      	; 0xd198 <WebServer+0x724>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d192:	cd 01       	movw	r24, r26
    d194:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    d198:	88 0e       	add	r8, r24
    d19a:	91 1c       	adc	r9, r1
    d19c:	88 0e       	add	r8, r24
    d19e:	91 1c       	adc	r9, r1
    d1a0:	9e 82       	std	Y+6, r9	; 0x06
    d1a2:	8d 82       	std	Y+5, r8	; 0x05
		PutEnum(Param);
    d1a4:	ce 01       	movw	r24, r28
    d1a6:	01 96       	adiw	r24, 0x01	; 1
    d1a8:	0e 94 71 3e 	call	0x7ce2	; 0x7ce2 <PutEnum>
    d1ac:	58 c0       	rjmp	.+176    	; 0xd25e <WebServer+0x7ea>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1ae:	2b 81       	ldd	r18, Y+3	; 0x03
    d1b0:	82 2f       	mov	r24, r18
    d1b2:	86 95       	lsr	r24
    d1b4:	86 95       	lsr	r24
    d1b6:	86 95       	lsr	r24
    d1b8:	a8 0f       	add	r26, r24
    d1ba:	b1 1d       	adc	r27, r1
    d1bc:	8c 91       	ld	r24, X
    d1be:	90 e0       	ldi	r25, 0x00	; 0
    d1c0:	0e c0       	rjmp	.+28     	; 0xd1de <WebServer+0x76a>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1c2:	2b 81       	ldd	r18, Y+3	; 0x03
    d1c4:	82 2f       	mov	r24, r18
    d1c6:	86 95       	lsr	r24
    d1c8:	86 95       	lsr	r24
    d1ca:	86 95       	lsr	r24
    d1cc:	fd 01       	movw	r30, r26
    d1ce:	e8 0f       	add	r30, r24
    d1d0:	f1 1d       	adc	r31, r1
    d1d2:	cf 01       	movw	r24, r30
    d1d4:	2c 87       	std	Y+12, r18	; 0x0c
    d1d6:	0e 94 e0 73 	call	0xe7c0	; 0xe7c0 <__eerd_byte_m128>
    d1da:	90 e0       	ldi	r25, 0x00	; 0
    d1dc:	2c 85       	ldd	r18, Y+12	; 0x0c
    d1de:	27 70       	andi	r18, 0x07	; 7
    d1e0:	a5 01       	movw	r20, r10
    d1e2:	02 c0       	rjmp	.+4      	; 0xd1e8 <WebServer+0x774>
    d1e4:	44 0f       	add	r20, r20
    d1e6:	55 1f       	adc	r21, r21
    d1e8:	2a 95       	dec	r18
    d1ea:	e2 f7       	brpl	.-8      	; 0xd1e4 <WebServer+0x770>
    d1ec:	84 23       	and	r24, r20
    d1ee:	95 23       	and	r25, r21
    d1f0:	89 2b       	or	r24, r25
    d1f2:	19 f0       	breq	.+6      	; 0xd1fa <WebServer+0x786>
    d1f4:	e2 e0       	ldi	r30, 0x02	; 2
    d1f6:	f0 e0       	ldi	r31, 0x00	; 0
    d1f8:	02 c0       	rjmp	.+4      	; 0xd1fe <WebServer+0x78a>
    d1fa:	e0 e0       	ldi	r30, 0x00	; 0
    d1fc:	f0 e0       	ldi	r31, 0x00	; 0
    d1fe:	e8 0d       	add	r30, r8
    d200:	f9 1d       	adc	r31, r9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d202:	65 91       	lpm	r22, Z+
    d204:	74 91       	lpm	r23, Z
    d206:	c7 01       	movw	r24, r14
    d208:	0e 94 57 6c 	call	0xd8ae	; 0xd8ae <strcpy_P>
    d20c:	28 c0       	rjmp	.+80     	; 0xd25e <WebServer+0x7ea>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    d20e:	be 01       	movw	r22, r28
    d210:	6f 5f       	subi	r22, 0xFF	; 255
    d212:	7f 4f       	sbci	r23, 0xFF	; 255
    d214:	cd 01       	movw	r24, r26
    d216:	0e 94 1c 43 	call	0x8638	; 0x8638 <Put_TextValAlignLeft>
    d21a:	21 c0       	rjmp	.+66     	; 0xd25e <WebServer+0x7ea>
    d21c:	8d b6       	in	r8, 0x3d	; 61
    d21e:	9e b6       	in	r9, 0x3e	; 62
		break;
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    d220:	ca 01       	movw	r24, r20
    d222:	01 96       	adiw	r24, 0x01	; 1
    d224:	ed b7       	in	r30, 0x3d	; 61
    d226:	fe b7       	in	r31, 0x3e	; 62
    d228:	e8 1b       	sub	r30, r24
    d22a:	f9 0b       	sbc	r31, r25
    d22c:	0f b6       	in	r0, 0x3f	; 63
    d22e:	f8 94       	cli
    d230:	fe bf       	out	0x3e, r31	; 62
    d232:	0f be       	out	0x3f, r0	; 63
    d234:	ed bf       	out	0x3d, r30	; 61
    d236:	2d b7       	in	r18, 0x3d	; 61
    d238:	3e b7       	in	r19, 0x3e	; 62
    d23a:	2f 5f       	subi	r18, 0xFF	; 255
    d23c:	3f 4f       	sbci	r19, 0xFF	; 255
    d23e:	79 01       	movw	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d240:	bd 01       	movw	r22, r26
    d242:	c9 01       	movw	r24, r18
    d244:	0e 94 d0 73 	call	0xe7a0	; 0xe7a0 <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    d248:	be 01       	movw	r22, r28
    d24a:	6f 5f       	subi	r22, 0xFF	; 255
    d24c:	7f 4f       	sbci	r23, 0xFF	; 255
    d24e:	c7 01       	movw	r24, r14
    d250:	0e 94 1c 43 	call	0x8638	; 0x8638 <Put_TextValAlignLeft>
    d254:	0f b6       	in	r0, 0x3f	; 63
    d256:	f8 94       	cli
    d258:	9e be       	out	0x3e, r9	; 62
    d25a:	0f be       	out	0x3f, r0	; 63
    d25c:	8d be       	out	0x3d, r8	; 61
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    d25e:	36 e0       	ldi	r19, 0x06	; 6
    d260:	c3 0e       	add	r12, r19
    d262:	d1 1c       	adc	r13, r1
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    d264:	8c 81       	ldd	r24, Y+4	; 0x04
    d266:	86 0d       	add	r24, r6
    d268:	e8 2f       	mov	r30, r24
    d26a:	f0 e0       	ldi	r31, 0x00	; 0
    d26c:	e7 5c       	subi	r30, 0xC7	; 199
    d26e:	f3 4f       	sbci	r31, 0xF3	; 243
    d270:	70 82       	st	Z, r7
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    d272:	66 24       	eor	r6, r6
    d274:	63 94       	inc	r6
    d276:	68 0e       	add	r6, r24
    d278:	74 ce       	rjmp	.-792    	; 0xcf62 <WebServer+0x4ee>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    d27a:	d0 92 3d 02 	sts	0x023D, r13
    d27e:	c0 92 3c 02 	sts	0x023C, r12
				}
				GSMTxSz = i;
    d282:	00 93 57 09 	sts	0x0957, r16
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d286:	20 91 57 09 	lds	r18, 0x0957
    d28a:	80 91 3a 02 	lds	r24, 0x023A
    d28e:	90 91 3b 02 	lds	r25, 0x023B
    d292:	82 0f       	add	r24, r18
    d294:	91 1d       	adc	r25, r1
				if(PacketByteCount >= MaxPacketSz){
    d296:	81 15       	cp	r24, r1
    d298:	54 e0       	ldi	r21, 0x04	; 4
    d29a:	95 07       	cpc	r25, r21
    d29c:	28 f4       	brcc	.+10     	; 0xd2a8 <WebServer+0x834>
					}
					ptrIF = PutWebLine(ptrIF, i);
				}
				GSMTxSz = i;
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d29e:	90 93 3b 02 	sts	0x023B, r25
    d2a2:	80 93 3a 02 	sts	0x023A, r24
    d2a6:	0b c0       	rjmp	.+22     	; 0xd2be <WebServer+0x84a>
				if(PacketByteCount >= MaxPacketSz){
					PacketByteCount -= MaxPacketSz;
    d2a8:	94 50       	subi	r25, 0x04	; 4
    d2aa:	90 93 3b 02 	sts	0x023B, r25
    d2ae:	80 93 3a 02 	sts	0x023A, r24
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    d2b2:	68 ec       	ldi	r22, 0xC8	; 200
    d2b4:	70 e0       	ldi	r23, 0x00	; 0
    d2b6:	80 91 4f 09 	lds	r24, 0x094F
    d2ba:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
				}
				GSM_SendFirstChar();
    d2be:	0e 94 ad 57 	call	0xaf5a	; 0xaf5a <GSM_SendFirstChar>
    d2c2:	02 c0       	rjmp	.+4      	; 0xd2c8 <WebServer+0x854>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    d2c4:	10 92 3e 02 	sts	0x023E, r1
	}

}
    d2c8:	0f b6       	in	r0, 0x3f	; 63
    d2ca:	f8 94       	cli
    d2cc:	3e be       	out	0x3e, r3	; 62
    d2ce:	0f be       	out	0x3f, r0	; 63
    d2d0:	2d be       	out	0x3d, r2	; 61
    d2d2:	2c 96       	adiw	r28, 0x0c	; 12
    d2d4:	0f b6       	in	r0, 0x3f	; 63
    d2d6:	f8 94       	cli
    d2d8:	de bf       	out	0x3e, r29	; 62
    d2da:	0f be       	out	0x3f, r0	; 63
    d2dc:	cd bf       	out	0x3d, r28	; 61
    d2de:	df 91       	pop	r29
    d2e0:	cf 91       	pop	r28
    d2e2:	1f 91       	pop	r17
    d2e4:	0f 91       	pop	r16
    d2e6:	ff 90       	pop	r15
    d2e8:	ef 90       	pop	r14
    d2ea:	df 90       	pop	r13
    d2ec:	cf 90       	pop	r12
    d2ee:	bf 90       	pop	r11
    d2f0:	af 90       	pop	r10
    d2f2:	9f 90       	pop	r9
    d2f4:	8f 90       	pop	r8
    d2f6:	7f 90       	pop	r7
    d2f8:	6f 90       	pop	r6
    d2fa:	5f 90       	pop	r5
    d2fc:	4f 90       	pop	r4
    d2fe:	3f 90       	pop	r3
    d300:	2f 90       	pop	r2
    d302:	08 95       	ret

0000d304 <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    d304:	80 91 76 0a 	lds	r24, 0x0A76
    d308:	88 23       	and	r24, r24
    d30a:	09 f4       	brne	.+2      	; 0xd30e <GSM_DRE+0xa>
    d30c:	55 c0       	rjmp	.+170    	; 0xd3b8 <GSM_DRE+0xb4>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d30e:	90 91 70 09 	lds	r25, 0x0970
    d312:	80 91 38 0d 	lds	r24, 0x0D38
    d316:	98 17       	cp	r25, r24
    d318:	a1 f0       	breq	.+40     	; 0xd342 <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    d31a:	80 91 38 0d 	lds	r24, 0x0D38
    d31e:	8f 5f       	subi	r24, 0xFF	; 255
    d320:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d324:	80 91 38 0d 	lds	r24, 0x0D38
    d328:	8f 3f       	cpi	r24, 0xFF	; 255
    d32a:	11 f4       	brne	.+4      	; 0xd330 <GSM_DRE+0x2c>
    d32c:	10 92 38 0d 	sts	0x0D38, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    d330:	e0 91 38 0d 	lds	r30, 0x0D38
    d334:	f0 e0       	ldi	r31, 0x00	; 0
    d336:	e7 50       	subi	r30, 0x07	; 7
    d338:	fc 4f       	sbci	r31, 0xFC	; 252
    d33a:	80 81       	ld	r24, Z
    d33c:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    d33e:	5e 9a       	sbi	0x0b, 6	; 11
    d340:	02 c0       	rjmp	.+4      	; 0xd346 <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d342:	88 ed       	ldi	r24, 0xD8	; 216
    d344:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    d346:	90 91 70 09 	lds	r25, 0x0970
    d34a:	80 91 38 0d 	lds	r24, 0x0D38
    d34e:	89 17       	cp	r24, r25
    d350:	a0 f4       	brcc	.+40     	; 0xd37a <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    d352:	20 91 6e 0a 	lds	r18, 0x0A6E
    d356:	80 91 70 09 	lds	r24, 0x0970
    d35a:	40 91 38 0d 	lds	r20, 0x0D38
    d35e:	30 e0       	ldi	r19, 0x00	; 0
    d360:	90 e0       	ldi	r25, 0x00	; 0
    d362:	84 1b       	sub	r24, r20
    d364:	91 09       	sbc	r25, r1
    d366:	28 17       	cp	r18, r24
    d368:	39 07       	cpc	r19, r25
    d36a:	3c f4       	brge	.+14     	; 0xd37a <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    d36c:	80 91 70 09 	lds	r24, 0x0970
    d370:	90 91 38 0d 	lds	r25, 0x0D38
    d374:	89 1b       	sub	r24, r25
    d376:	80 93 6e 0a 	sts	0x0A6E, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    d37a:	90 91 38 0d 	lds	r25, 0x0D38
    d37e:	80 91 70 09 	lds	r24, 0x0970
    d382:	89 17       	cp	r24, r25
    d384:	e8 f5       	brcc	.+122    	; 0xd400 <GSM_DRE+0xfc>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    d386:	20 91 6e 0a 	lds	r18, 0x0A6E
    d38a:	50 91 38 0d 	lds	r21, 0x0D38
    d38e:	40 91 70 09 	lds	r20, 0x0970
    d392:	30 e0       	ldi	r19, 0x00	; 0
    d394:	8f ef       	ldi	r24, 0xFF	; 255
    d396:	90 e0       	ldi	r25, 0x00	; 0
    d398:	85 1b       	sub	r24, r21
    d39a:	91 09       	sbc	r25, r1
    d39c:	84 0f       	add	r24, r20
    d39e:	91 1d       	adc	r25, r1
    d3a0:	28 17       	cp	r18, r24
    d3a2:	39 07       	cpc	r19, r25
    d3a4:	6c f5       	brge	.+90     	; 0xd400 <GSM_DRE+0xfc>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    d3a6:	80 91 70 09 	lds	r24, 0x0970
    d3aa:	90 91 38 0d 	lds	r25, 0x0D38
    d3ae:	81 50       	subi	r24, 0x01	; 1
    d3b0:	89 1b       	sub	r24, r25
    d3b2:	80 93 6e 0a 	sts	0x0A6E, r24
    d3b6:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    d3b8:	90 91 46 0d 	lds	r25, 0x0D46
    d3bc:	80 91 57 09 	lds	r24, 0x0957
    d3c0:	98 17       	cp	r25, r24
    d3c2:	e0 f4       	brcc	.+56     	; 0xd3fc <GSM_DRE+0xf8>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    d3c4:	e0 91 46 0d 	lds	r30, 0x0D46
    d3c8:	f0 e0       	ldi	r31, 0x00	; 0
    d3ca:	e7 5c       	subi	r30, 0xC7	; 199
    d3cc:	f3 4f       	sbci	r31, 0xF3	; 243
    d3ce:	80 81       	ld	r24, Z
    d3d0:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    d3d2:	80 91 f2 09 	lds	r24, 0x09F2
    d3d6:	88 23       	and	r24, r24
    d3d8:	59 f0       	breq	.+22     	; 0xd3f0 <GSM_DRE+0xec>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    d3da:	e0 91 46 0d 	lds	r30, 0x0D46
    d3de:	f0 e0       	ldi	r31, 0x00	; 0
    d3e0:	e7 5c       	subi	r30, 0xC7	; 199
    d3e2:	f3 4f       	sbci	r31, 0xF3	; 243
    d3e4:	80 81       	ld	r24, Z
    d3e6:	0e 94 19 57 	call	0xae32	; 0xae32 <SendDebug>
    d3ea:	88 e2       	ldi	r24, 0x28	; 40
    d3ec:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    d3f0:	80 91 46 0d 	lds	r24, 0x0D46
    d3f4:	8f 5f       	subi	r24, 0xFF	; 255
    d3f6:	80 93 46 0d 	sts	0x0D46, r24
    d3fa:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d3fc:	88 ed       	ldi	r24, 0xD8	; 216
    d3fe:	8a b9       	out	0x0a, r24	; 10
    d400:	08 95       	ret

0000d402 <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    d402:	1f 92       	push	r1
    d404:	0f 92       	push	r0
    d406:	0f b6       	in	r0, 0x3f	; 63
    d408:	0f 92       	push	r0
    d40a:	11 24       	eor	r1, r1
    d40c:	0b b6       	in	r0, 0x3b	; 59
    d40e:	0f 92       	push	r0
    d410:	2f 93       	push	r18
    d412:	3f 93       	push	r19
    d414:	4f 93       	push	r20
    d416:	5f 93       	push	r21
    d418:	6f 93       	push	r22
    d41a:	7f 93       	push	r23
    d41c:	8f 93       	push	r24
    d41e:	9f 93       	push	r25
    d420:	af 93       	push	r26
    d422:	bf 93       	push	r27
    d424:	ef 93       	push	r30
    d426:	ff 93       	push	r31
	GSM_DRE();
    d428:	0e 94 82 69 	call	0xd304	; 0xd304 <GSM_DRE>
	GSM_LED = 1;
    d42c:	81 e0       	ldi	r24, 0x01	; 1
    d42e:	80 93 0a 06 	sts	0x060A, r24
}
    d432:	ff 91       	pop	r31
    d434:	ef 91       	pop	r30
    d436:	bf 91       	pop	r27
    d438:	af 91       	pop	r26
    d43a:	9f 91       	pop	r25
    d43c:	8f 91       	pop	r24
    d43e:	7f 91       	pop	r23
    d440:	6f 91       	pop	r22
    d442:	5f 91       	pop	r21
    d444:	4f 91       	pop	r20
    d446:	3f 91       	pop	r19
    d448:	2f 91       	pop	r18
    d44a:	0f 90       	pop	r0
    d44c:	0b be       	out	0x3b, r0	; 59
    d44e:	0f 90       	pop	r0
    d450:	0f be       	out	0x3f, r0	; 63
    d452:	0f 90       	pop	r0
    d454:	1f 90       	pop	r1
    d456:	18 95       	reti

0000d458 <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d458:	90 91 70 09 	lds	r25, 0x0970
    d45c:	80 91 38 0d 	lds	r24, 0x0D38
    d460:	98 17       	cp	r25, r24
    d462:	a1 f0       	breq	.+40     	; 0xd48c <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    d464:	80 91 38 0d 	lds	r24, 0x0D38
    d468:	8f 5f       	subi	r24, 0xFF	; 255
    d46a:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d46e:	80 91 38 0d 	lds	r24, 0x0D38
    d472:	8f 3f       	cpi	r24, 0xFF	; 255
    d474:	11 f4       	brne	.+4      	; 0xd47a <Debug_DRE+0x22>
    d476:	10 92 38 0d 	sts	0x0D38, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    d47a:	e0 91 38 0d 	lds	r30, 0x0D38
    d47e:	f0 e0       	ldi	r31, 0x00	; 0
    d480:	e7 50       	subi	r30, 0x07	; 7
    d482:	fc 4f       	sbci	r31, 0xFC	; 252
    d484:	80 81       	ld	r24, Z
    d486:	80 93 9c 00 	sts	0x009C, r24
    d48a:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    d48c:	88 e0       	ldi	r24, 0x08	; 8
    d48e:	80 93 9a 00 	sts	0x009A, r24
    d492:	08 95       	ret

0000d494 <EMeter_DRE>:
	}*/
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    d494:	80 91 f2 09 	lds	r24, 0x09F2
    d498:	81 11       	cpse	r24, r1
    d49a:	0c 94 2c 6a 	jmp	0xd458	; 0xd458 <Debug_DRE>
	else{
		if(Transparent){
    d49e:	80 91 76 0a 	lds	r24, 0x0A76
    d4a2:	88 23       	and	r24, r24
    d4a4:	09 f4       	brne	.+2      	; 0xd4a8 <EMeter_DRE+0x14>
    d4a6:	5e c0       	rjmp	.+188    	; 0xd564 <EMeter_DRE+0xd0>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    d4a8:	90 91 7b 08 	lds	r25, 0x087B
    d4ac:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4b0:	98 17       	cp	r25, r24
    d4b2:	d1 f0       	breq	.+52     	; 0xd4e8 <EMeter_DRE+0x54>
		GSM_RX_FIFO_End_Transp++;
    d4b4:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4b8:	8f 5f       	subi	r24, 0xFF	; 255
    d4ba:	80 93 f8 0a 	sts	0x0AF8, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    d4be:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4c2:	8a 3f       	cpi	r24, 0xFA	; 250
    d4c4:	10 f0       	brcs	.+4      	; 0xd4ca <EMeter_DRE+0x36>
    d4c6:	10 92 f8 0a 	sts	0x0AF8, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    d4ca:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    d4cc:	e0 91 f8 0a 	lds	r30, 0x0AF8
    d4d0:	f0 e0       	ldi	r31, 0x00	; 0
    d4d2:	e8 50       	subi	r30, 0x08	; 8
    d4d4:	fb 4f       	sbci	r31, 0xFB	; 251
    d4d6:	80 81       	ld	r24, Z
    d4d8:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    d4dc:	80 91 9b 00 	lds	r24, 0x009B
    d4e0:	80 64       	ori	r24, 0x40	; 64
    d4e2:	80 93 9b 00 	sts	0x009B, r24
    d4e6:	03 c0       	rjmp	.+6      	; 0xd4ee <EMeter_DRE+0x5a>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d4e8:	88 ed       	ldi	r24, 0xD8	; 216
    d4ea:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    d4ee:	90 91 7b 08 	lds	r25, 0x087B
    d4f2:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4f6:	89 17       	cp	r24, r25
    d4f8:	a0 f4       	brcc	.+40     	; 0xd522 <EMeter_DRE+0x8e>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    d4fa:	20 91 7f 09 	lds	r18, 0x097F
    d4fe:	80 91 7b 08 	lds	r24, 0x087B
    d502:	40 91 f8 0a 	lds	r20, 0x0AF8
    d506:	30 e0       	ldi	r19, 0x00	; 0
    d508:	90 e0       	ldi	r25, 0x00	; 0
    d50a:	84 1b       	sub	r24, r20
    d50c:	91 09       	sbc	r25, r1
    d50e:	28 17       	cp	r18, r24
    d510:	39 07       	cpc	r19, r25
    d512:	3c f4       	brge	.+14     	; 0xd522 <EMeter_DRE+0x8e>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    d514:	80 91 7b 08 	lds	r24, 0x087B
    d518:	90 91 f8 0a 	lds	r25, 0x0AF8
    d51c:	89 1b       	sub	r24, r25
    d51e:	80 93 7f 09 	sts	0x097F, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    d522:	90 91 f8 0a 	lds	r25, 0x0AF8
    d526:	80 91 7b 08 	lds	r24, 0x087B
    d52a:	89 17       	cp	r24, r25
    d52c:	c0 f4       	brcc	.+48     	; 0xd55e <EMeter_DRE+0xca>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    d52e:	20 91 7f 09 	lds	r18, 0x097F
    d532:	50 91 f8 0a 	lds	r21, 0x0AF8
    d536:	40 91 7b 08 	lds	r20, 0x087B
    d53a:	30 e0       	ldi	r19, 0x00	; 0
    d53c:	8a ef       	ldi	r24, 0xFA	; 250
    d53e:	90 e0       	ldi	r25, 0x00	; 0
    d540:	85 1b       	sub	r24, r21
    d542:	91 09       	sbc	r25, r1
    d544:	84 0f       	add	r24, r20
    d546:	91 1d       	adc	r25, r1
    d548:	28 17       	cp	r18, r24
    d54a:	39 07       	cpc	r19, r25
    d54c:	44 f4       	brge	.+16     	; 0xd55e <EMeter_DRE+0xca>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    d54e:	80 91 7b 08 	lds	r24, 0x087B
    d552:	90 91 f8 0a 	lds	r25, 0x0AF8
    d556:	86 50       	subi	r24, 0x06	; 6
    d558:	89 1b       	sub	r24, r25
    d55a:	80 93 7f 09 	sts	0x097F, r24
			GetByteFromGSM_FIFO_Transp();
			EMeterIsLink=0;
    d55e:	10 92 5d 09 	sts	0x095D, r1
    d562:	08 95       	ret
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    d564:	90 91 51 09 	lds	r25, 0x0951
    d568:	80 91 47 0d 	lds	r24, 0x0D47
    d56c:	98 17       	cp	r25, r24
    d56e:	70 f4       	brcc	.+28     	; 0xd58c <EMeter_DRE+0xf8>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    d570:	e0 91 51 09 	lds	r30, 0x0951
    d574:	f0 e0       	ldi	r31, 0x00	; 0
    d576:	e7 50       	subi	r30, 0x07	; 7
    d578:	f5 4f       	sbci	r31, 0xF5	; 245
    d57a:	80 81       	ld	r24, Z
    d57c:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    d580:	80 91 51 09 	lds	r24, 0x0951
    d584:	8f 5f       	subi	r24, 0xFF	; 255
    d586:	80 93 51 09 	sts	0x0951, r24
    d58a:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d58c:	88 ed       	ldi	r24, 0xD8	; 216
    d58e:	80 93 9a 00 	sts	0x009A, r24
    d592:	08 95       	ret

0000d594 <__vector_31>:
}

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    d594:	1f 92       	push	r1
    d596:	0f 92       	push	r0
    d598:	0f b6       	in	r0, 0x3f	; 63
    d59a:	0f 92       	push	r0
    d59c:	11 24       	eor	r1, r1
    d59e:	0b b6       	in	r0, 0x3b	; 59
    d5a0:	0f 92       	push	r0
    d5a2:	2f 93       	push	r18
    d5a4:	3f 93       	push	r19
    d5a6:	4f 93       	push	r20
    d5a8:	5f 93       	push	r21
    d5aa:	6f 93       	push	r22
    d5ac:	7f 93       	push	r23
    d5ae:	8f 93       	push	r24
    d5b0:	9f 93       	push	r25
    d5b2:	af 93       	push	r26
    d5b4:	bf 93       	push	r27
    d5b6:	ef 93       	push	r30
    d5b8:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    d5ba:	80 91 e0 03 	lds	r24, 0x03E0
    d5be:	88 23       	and	r24, r24
    d5c0:	29 f0       	breq	.+10     	; 0xd5cc <__vector_31+0x38>
    d5c2:	8c e9       	ldi	r24, 0x9C	; 156
    d5c4:	90 e0       	ldi	r25, 0x00	; 0
    d5c6:	0e 94 77 38 	call	0x70ee	; 0x70ee <Modbus_TX>
    d5ca:	02 c0       	rjmp	.+4      	; 0xd5d0 <__vector_31+0x3c>
	else EMeter_DRE();
    d5cc:	0e 94 4a 6a 	call	0xd494	; 0xd494 <EMeter_DRE>
	COMM_LED = 1;
    d5d0:	81 e0       	ldi	r24, 0x01	; 1
    d5d2:	80 93 10 06 	sts	0x0610, r24
}
    d5d6:	ff 91       	pop	r31
    d5d8:	ef 91       	pop	r30
    d5da:	bf 91       	pop	r27
    d5dc:	af 91       	pop	r26
    d5de:	9f 91       	pop	r25
    d5e0:	8f 91       	pop	r24
    d5e2:	7f 91       	pop	r23
    d5e4:	6f 91       	pop	r22
    d5e6:	5f 91       	pop	r21
    d5e8:	4f 91       	pop	r20
    d5ea:	3f 91       	pop	r19
    d5ec:	2f 91       	pop	r18
    d5ee:	0f 90       	pop	r0
    d5f0:	0b be       	out	0x3b, r0	; 59
    d5f2:	0f 90       	pop	r0
    d5f4:	0f be       	out	0x3f, r0	; 63
    d5f6:	0f 90       	pop	r0
    d5f8:	1f 90       	pop	r1
    d5fa:	18 95       	reti

0000d5fc <ToggleLED>:

//#include "web.h"
#include "web_vem_levels.h"

void ToggleLED(uint8_t DO){
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    d5fc:	40 91 63 09 	lds	r20, 0x0963
    d600:	50 91 64 09 	lds	r21, 0x0964
    d604:	60 91 65 09 	lds	r22, 0x0965
    d608:	70 91 66 09 	lds	r23, 0x0966
    d60c:	42 fd       	sbrc	r20, 2
    d60e:	0c 94 22 3c 	jmp	0x7844	; 0x7844 <ResDigOut>
	else SetDigOut(DO);
    d612:	0c 94 10 3c 	jmp	0x7820	; 0x7820 <SetDigOut>

0000d616 <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    d616:	0e 94 19 2a 	call	0x5432	; 0x5432 <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    d61a:	0e 94 ed 4c 	call	0x99da	; 0x99da <GPRS_AppInit>
	#endif

	WebInit();
    d61e:	0c 94 6d 43 	jmp	0x86da	; 0x86da <WebInit>

0000d622 <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
    d622:	69 e0       	ldi	r22, 0x09	; 9
    d624:	82 e8       	ldi	r24, 0x82	; 130
    d626:	95 e0       	ldi	r25, 0x05	; 5
    d628:	0e 94 3a 65 	call	0xca74	; 0xca74 <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
    d62c:	0e 94 51 55 	call	0xaaa2	; 0xaaa2 <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
    d630:	0e 94 fc 55 	call	0xabf8	; 0xabf8 <Modbus_App>
		}
	*/	


	// GSM_DebugMode
	if(UART_Soft){
    d634:	80 91 75 0a 	lds	r24, 0x0A75
    d638:	88 23       	and	r24, r24
    d63a:	09 f1       	breq	.+66     	; 0xd67e <ApplCycle+0x5c>
		if(GSM_DebugMode){
    d63c:	80 91 f2 09 	lds	r24, 0x09F2
    d640:	88 23       	and	r24, r24
    d642:	81 f0       	breq	.+32     	; 0xd664 <ApplCycle+0x42>
			if( DI_State(DI_BL) ){
    d644:	83 e0       	ldi	r24, 0x03	; 3
    d646:	0e 94 a1 3b 	call	0x7742	; 0x7742 <DI_State>
    d64a:	88 23       	and	r24, r24
    d64c:	41 f0       	breq	.+16     	; 0xd65e <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
    d64e:	81 e0       	ldi	r24, 0x01	; 1
    d650:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    d654:	88 23       	and	r24, r24
    d656:	51 f1       	breq	.+84     	; 0xd6ac <ApplCycle+0x8a>
					StopDebug();
    d658:	0e 94 0f 57 	call	0xae1e	; 0xae1e <StopDebug>
    d65c:	22 c0       	rjmp	.+68     	; 0xd6a2 <ApplCycle+0x80>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
    d65e:	62 e3       	ldi	r22, 0x32	; 50
    d660:	70 e0       	ldi	r23, 0x00	; 0
    d662:	21 c0       	rjmp	.+66     	; 0xd6a6 <ApplCycle+0x84>
		}
		else{
			if( DI_State(DI_BL) ){
    d664:	83 e0       	ldi	r24, 0x03	; 3
    d666:	0e 94 a1 3b 	call	0x7742	; 0x7742 <DI_State>
    d66a:	88 23       	and	r24, r24
    d66c:	69 f0       	breq	.+26     	; 0xd688 <ApplCycle+0x66>
				if(Timer16Stopp(TD_GotoDebug)){
    d66e:	81 e0       	ldi	r24, 0x01	; 1
    d670:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    d674:	88 23       	and	r24, r24
    d676:	d1 f0       	breq	.+52     	; 0xd6ac <ApplCycle+0x8a>
					StartDebug();
    d678:	0e 94 fb 56 	call	0xadf6	; 0xadf6 <StartDebug>
    d67c:	12 c0       	rjmp	.+36     	; 0xd6a2 <ApplCycle+0x80>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
    d67e:	83 e0       	ldi	r24, 0x03	; 3
    d680:	0e 94 a1 3b 	call	0x7742	; 0x7742 <DI_State>
    d684:	81 11       	cpse	r24, r1
    d686:	03 c0       	rjmp	.+6      	; 0xd68e <ApplCycle+0x6c>
				if(Timer16Stopp(TD_GotoDebug)){
					StartDebug();
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,100);
    d688:	64 e6       	ldi	r22, 0x64	; 100
    d68a:	70 e0       	ldi	r23, 0x00	; 0
    d68c:	0c c0       	rjmp	.+24     	; 0xd6a6 <ApplCycle+0x84>
		}
	}
	else{
		if( DI_State(DI_BL) ){
			if(Timer16Stopp(TD_GotoDebug)){
    d68e:	81 e0       	ldi	r24, 0x01	; 1
    d690:	0e 94 63 2c 	call	0x58c6	; 0x58c6 <Timer16Stopp>
    d694:	88 23       	and	r24, r24
    d696:	51 f0       	breq	.+20     	; 0xd6ac <ApplCycle+0x8a>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
    d698:	68 ef       	ldi	r22, 0xF8	; 248
    d69a:	7c e4       	ldi	r23, 0x4C	; 76
    d69c:	82 e0       	ldi	r24, 0x02	; 2
    d69e:	0e 94 b5 4f 	call	0x9f6a	; 0x9f6a <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
    d6a2:	64 ef       	ldi	r22, 0xF4	; 244
    d6a4:	71 e0       	ldi	r23, 0x01	; 1
    d6a6:	81 e0       	ldi	r24, 0x01	; 1
    d6a8:	0e 94 c8 2a 	call	0x5590	; 0x5590 <StartTimer16>
		}
	}
	else ResDigOut(DO_BL);*/

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
    d6ac:	80 91 0a 06 	lds	r24, 0x060A
    d6b0:	81 30       	cpi	r24, 0x01	; 1
    d6b2:	39 f4       	brne	.+14     	; 0xd6c2 <ApplCycle+0xa0>
		StartTimer8(TD_GSM_LED,5);
    d6b4:	65 e0       	ldi	r22, 0x05	; 5
    d6b6:	83 e0       	ldi	r24, 0x03	; 3
    d6b8:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
		GSM_LED = 2;
    d6bc:	82 e0       	ldi	r24, 0x02	; 2
    d6be:	80 93 0a 06 	sts	0x060A, r24
	}
	if(GSM_LED ==2){
    d6c2:	80 91 0a 06 	lds	r24, 0x060A
    d6c6:	82 30       	cpi	r24, 0x02	; 2
    d6c8:	31 f4       	brne	.+12     	; 0xd6d6 <ApplCycle+0xb4>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
    d6ca:	83 e0       	ldi	r24, 0x03	; 3
    d6cc:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    d6d0:	81 11       	cpse	r24, r1
    d6d2:	10 92 0a 06 	sts	0x060A, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ProtocolMode){
    d6d6:	80 91 27 06 	lds	r24, 0x0627
    d6da:	8f 35       	cpi	r24, 0x5F	; 95
    d6dc:	81 f4       	brne	.+32     	; 0xd6fe <ApplCycle+0xdc>
		if(GSM_LED||UART_Soft) ToggleLED(DO_GSM);
    d6de:	80 91 0a 06 	lds	r24, 0x060A
    d6e2:	81 11       	cpse	r24, r1
    d6e4:	04 c0       	rjmp	.+8      	; 0xd6ee <ApplCycle+0xcc>
    d6e6:	80 91 75 0a 	lds	r24, 0x0A75
    d6ea:	88 23       	and	r24, r24
    d6ec:	21 f0       	breq	.+8      	; 0xd6f6 <ApplCycle+0xd4>
    d6ee:	80 e0       	ldi	r24, 0x00	; 0
    d6f0:	0e 94 fe 6a 	call	0xd5fc	; 0xd5fc <ToggleLED>
    d6f4:	0a c0       	rjmp	.+20     	; 0xd70a <ApplCycle+0xe8>
		else SetDigOut(DO_GSM);
    d6f6:	80 e0       	ldi	r24, 0x00	; 0
    d6f8:	0e 94 10 3c 	call	0x7820	; 0x7820 <SetDigOut>
    d6fc:	06 c0       	rjmp	.+12     	; 0xd70a <ApplCycle+0xe8>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
    d6fe:	80 91 0a 06 	lds	r24, 0x060A
    d702:	81 11       	cpse	r24, r1
    d704:	f4 cf       	rjmp	.-24     	; 0xd6ee <ApplCycle+0xcc>
		else ResDigOut(DO_GSM);
    d706:	0e 94 22 3c 	call	0x7844	; 0x7844 <ResDigOut>
	}


	//----   COMM_LED  /  UART1
	if(COMM_LED == 1){
    d70a:	80 91 10 06 	lds	r24, 0x0610
    d70e:	81 30       	cpi	r24, 0x01	; 1
    d710:	39 f4       	brne	.+14     	; 0xd720 <ApplCycle+0xfe>
		StartTimer8(TD_COMM_LED,5);
    d712:	65 e0       	ldi	r22, 0x05	; 5
    d714:	82 e0       	ldi	r24, 0x02	; 2
    d716:	0e 94 9a 2a 	call	0x5534	; 0x5534 <StartTimer8>
		COMM_LED = 2;
    d71a:	82 e0       	ldi	r24, 0x02	; 2
    d71c:	80 93 10 06 	sts	0x0610, r24
	}
	if(COMM_LED ==2){
    d720:	80 91 10 06 	lds	r24, 0x0610
    d724:	82 30       	cpi	r24, 0x02	; 2
    d726:	29 f4       	brne	.+10     	; 0xd732 <ApplCycle+0x110>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
    d728:	0e 94 48 2c 	call	0x5890	; 0x5890 <Timer8Stopp>
    d72c:	81 11       	cpse	r24, r1
    d72e:	10 92 10 06 	sts	0x0610, r1
	}
	//   COMM_LED 
	//if(EMeter_Link()){
	if(EMeterIsLink){
    d732:	80 91 5d 09 	lds	r24, 0x095D
    d736:	88 23       	and	r24, r24
    d738:	51 f0       	breq	.+20     	; 0xd74e <ApplCycle+0x12c>
		if(COMM_LED) ToggleLED(DO_RS);
    d73a:	80 91 10 06 	lds	r24, 0x0610
    d73e:	88 23       	and	r24, r24
    d740:	19 f0       	breq	.+6      	; 0xd748 <ApplCycle+0x126>
    d742:	81 e0       	ldi	r24, 0x01	; 1
    d744:	0c 94 fe 6a 	jmp	0xd5fc	; 0xd5fc <ToggleLED>
		else SetDigOut(DO_RS);
    d748:	81 e0       	ldi	r24, 0x01	; 1
    d74a:	0c 94 10 3c 	jmp	0x7820	; 0x7820 <SetDigOut>
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
    d74e:	80 91 10 06 	lds	r24, 0x0610
    d752:	81 11       	cpse	r24, r1
    d754:	f6 cf       	rjmp	.-20     	; 0xd742 <ApplCycle+0x120>
		else ResDigOut(DO_RS);
    d756:	81 e0       	ldi	r24, 0x01	; 1
    d758:	0c 94 22 3c 	jmp	0x7844	; 0x7844 <ResDigOut>

0000d75c <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimersInc();
    d75c:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <TimersInc>
	TimeInit();
    d760:	0e 94 e4 2c 	call	0x59c8	; 0x59c8 <TimeInit>
	MemCheckInit();
    d764:	0e 94 ef 29 	call	0x53de	; 0x53de <MemCheckInit>

// ~~~~~~~~~~
void
DI_Init(void)
{
	DI_Init_Hard();
    d768:	0e 94 ce 28 	call	0x519c	; 0x519c <DI_Init_Hard>
	LED_Init();
	DigitInit();
    d76c:	0e 94 68 3c 	call	0x78d0	; 0x78d0 <DO_Init>
	OneWire_Init();
    d770:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <OneWire_Init>
	USART_Init();
    d774:	0e 94 02 4c 	call	0x9804	; 0x9804 <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    d778:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {TimersInc();
    d77a:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <TimersInc>
		wdt_reset();
    d77e:	a8 95       	wdr
		DigitIn();
    d780:	0e 94 c5 3b 	call	0x778a	; 0x778a <DigitIn>
		DS18B20();
    d784:	0e 94 48 3e 	call	0x7c90	; 0x7c90 <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
    d788:	80 91 56 02 	lds	r24, 0x0256
    d78c:	87 30       	cpi	r24, 0x07	; 7
    d78e:	a9 f7       	brne	.-22     	; 0xd77a <main+0x1e>

//	MemCheckMsg();

	ApplInit();
    d790:	0e 94 0b 6b 	call	0xd616	; 0xd616 <ApplInit>
	
	ScanCycleInit();
    d794:	0e 94 22 2d 	call	0x5a44	; 0x5a44 <ScanCycleInit>

	for(;;) {TimersInc();
    d798:	0e 94 78 2d 	call	0x5af0	; 0x5af0 <TimersInc>
		sei();
    d79c:	78 94       	sei

		TimeCycle();
    d79e:	0e 94 74 2e 	call	0x5ce8	; 0x5ce8 <TimeCycle>
		DigitIn();
    d7a2:	0e 94 c5 3b 	call	0x778a	; 0x778a <DigitIn>
		DS18B20();
    d7a6:	0e 94 48 3e 	call	0x7c90	; 0x7c90 <DS18B20>
		USART_Cycle();
    d7aa:	0e 94 06 65 	call	0xca0c	; 0xca0c <USART_Cycle>

		ApplCycle();
    d7ae:	0e 94 11 6b 	call	0xd622	; 0xd622 <ApplCycle>

		DigitOut();
    d7b2:	0e 94 35 3c 	call	0x786a	; 0x786a <DigitOut>
    d7b6:	f0 cf       	rjmp	.-32     	; 0xd798 <main+0x3c>

0000d7b8 <do_random>:
    d7b8:	8f 92       	push	r8
    d7ba:	9f 92       	push	r9
    d7bc:	af 92       	push	r10
    d7be:	bf 92       	push	r11
    d7c0:	cf 92       	push	r12
    d7c2:	df 92       	push	r13
    d7c4:	ef 92       	push	r14
    d7c6:	ff 92       	push	r15
    d7c8:	cf 93       	push	r28
    d7ca:	df 93       	push	r29
    d7cc:	ec 01       	movw	r28, r24
    d7ce:	68 81       	ld	r22, Y
    d7d0:	79 81       	ldd	r23, Y+1	; 0x01
    d7d2:	8a 81       	ldd	r24, Y+2	; 0x02
    d7d4:	9b 81       	ldd	r25, Y+3	; 0x03
    d7d6:	61 15       	cp	r22, r1
    d7d8:	71 05       	cpc	r23, r1
    d7da:	81 05       	cpc	r24, r1
    d7dc:	91 05       	cpc	r25, r1
    d7de:	21 f4       	brne	.+8      	; 0xd7e8 <do_random+0x30>
    d7e0:	64 e2       	ldi	r22, 0x24	; 36
    d7e2:	79 ed       	ldi	r23, 0xD9	; 217
    d7e4:	8b e5       	ldi	r24, 0x5B	; 91
    d7e6:	97 e0       	ldi	r25, 0x07	; 7
    d7e8:	2d e1       	ldi	r18, 0x1D	; 29
    d7ea:	33 ef       	ldi	r19, 0xF3	; 243
    d7ec:	41 e0       	ldi	r20, 0x01	; 1
    d7ee:	50 e0       	ldi	r21, 0x00	; 0
    d7f0:	0e 94 76 75 	call	0xeaec	; 0xeaec <__divmodsi4>
    d7f4:	49 01       	movw	r8, r18
    d7f6:	5a 01       	movw	r10, r20
    d7f8:	9b 01       	movw	r18, r22
    d7fa:	ac 01       	movw	r20, r24
    d7fc:	a7 ea       	ldi	r26, 0xA7	; 167
    d7fe:	b1 e4       	ldi	r27, 0x41	; 65
    d800:	0e 94 9b 75 	call	0xeb36	; 0xeb36 <__muluhisi3>
    d804:	6b 01       	movw	r12, r22
    d806:	7c 01       	movw	r14, r24
    d808:	ac ee       	ldi	r26, 0xEC	; 236
    d80a:	b4 ef       	ldi	r27, 0xF4	; 244
    d80c:	a5 01       	movw	r20, r10
    d80e:	94 01       	movw	r18, r8
    d810:	0e 94 a9 75 	call	0xeb52	; 0xeb52 <__mulohisi3>
    d814:	c6 0e       	add	r12, r22
    d816:	d7 1e       	adc	r13, r23
    d818:	e8 1e       	adc	r14, r24
    d81a:	f9 1e       	adc	r15, r25
    d81c:	f7 fe       	sbrs	r15, 7
    d81e:	06 c0       	rjmp	.+12     	; 0xd82c <do_random+0x74>
    d820:	81 e0       	ldi	r24, 0x01	; 1
    d822:	c8 1a       	sub	r12, r24
    d824:	d1 08       	sbc	r13, r1
    d826:	e1 08       	sbc	r14, r1
    d828:	80 e8       	ldi	r24, 0x80	; 128
    d82a:	f8 0a       	sbc	r15, r24
    d82c:	c8 82       	st	Y, r12
    d82e:	d9 82       	std	Y+1, r13	; 0x01
    d830:	ea 82       	std	Y+2, r14	; 0x02
    d832:	fb 82       	std	Y+3, r15	; 0x03
    d834:	c7 01       	movw	r24, r14
    d836:	b6 01       	movw	r22, r12
    d838:	9f 77       	andi	r25, 0x7F	; 127
    d83a:	df 91       	pop	r29
    d83c:	cf 91       	pop	r28
    d83e:	ff 90       	pop	r15
    d840:	ef 90       	pop	r14
    d842:	df 90       	pop	r13
    d844:	cf 90       	pop	r12
    d846:	bf 90       	pop	r11
    d848:	af 90       	pop	r10
    d84a:	9f 90       	pop	r9
    d84c:	8f 90       	pop	r8
    d84e:	08 95       	ret

0000d850 <random_r>:
    d850:	0c 94 dc 6b 	jmp	0xd7b8	; 0xd7b8 <do_random>

0000d854 <random>:
    d854:	80 e0       	ldi	r24, 0x00	; 0
    d856:	91 e0       	ldi	r25, 0x01	; 1
    d858:	0c 94 dc 6b 	jmp	0xd7b8	; 0xd7b8 <do_random>

0000d85c <srandom>:
    d85c:	60 93 00 01 	sts	0x0100, r22
    d860:	70 93 01 01 	sts	0x0101, r23
    d864:	80 93 02 01 	sts	0x0102, r24
    d868:	90 93 03 01 	sts	0x0103, r25
    d86c:	08 95       	ret

0000d86e <exit>:
    d86e:	f8 94       	cli
    d870:	0c 94 1f 76 	jmp	0xec3e	; 0xec3e <_exit>

0000d874 <memcpy_P>:
    d874:	fb 01       	movw	r30, r22
    d876:	dc 01       	movw	r26, r24
    d878:	02 c0       	rjmp	.+4      	; 0xd87e <memcpy_P+0xa>
    d87a:	05 90       	lpm	r0, Z+
    d87c:	0d 92       	st	X+, r0
    d87e:	41 50       	subi	r20, 0x01	; 1
    d880:	50 40       	sbci	r21, 0x00	; 0
    d882:	d8 f7       	brcc	.-10     	; 0xd87a <memcpy_P+0x6>
    d884:	08 95       	ret

0000d886 <strchr_P>:
    d886:	fc 01       	movw	r30, r24
    d888:	05 90       	lpm	r0, Z+
    d88a:	06 16       	cp	r0, r22
    d88c:	21 f0       	breq	.+8      	; 0xd896 <strchr_P+0x10>
    d88e:	00 20       	and	r0, r0
    d890:	d9 f7       	brne	.-10     	; 0xd888 <strchr_P+0x2>
    d892:	c0 01       	movw	r24, r0
    d894:	08 95       	ret
    d896:	31 97       	sbiw	r30, 0x01	; 1
    d898:	cf 01       	movw	r24, r30
    d89a:	08 95       	ret

0000d89c <strcmp_P>:
    d89c:	fb 01       	movw	r30, r22
    d89e:	dc 01       	movw	r26, r24
    d8a0:	8d 91       	ld	r24, X+
    d8a2:	05 90       	lpm	r0, Z+
    d8a4:	80 19       	sub	r24, r0
    d8a6:	01 10       	cpse	r0, r1
    d8a8:	d9 f3       	breq	.-10     	; 0xd8a0 <strcmp_P+0x4>
    d8aa:	99 0b       	sbc	r25, r25
    d8ac:	08 95       	ret

0000d8ae <strcpy_P>:
    d8ae:	fb 01       	movw	r30, r22
    d8b0:	dc 01       	movw	r26, r24
    d8b2:	05 90       	lpm	r0, Z+
    d8b4:	0d 92       	st	X+, r0
    d8b6:	00 20       	and	r0, r0
    d8b8:	e1 f7       	brne	.-8      	; 0xd8b2 <strcpy_P+0x4>
    d8ba:	08 95       	ret

0000d8bc <strlcpy_P>:
    d8bc:	dc 01       	movw	r26, r24
    d8be:	fb 01       	movw	r30, r22
    d8c0:	41 50       	subi	r20, 0x01	; 1
    d8c2:	50 40       	sbci	r21, 0x00	; 0
    d8c4:	58 f0       	brcs	.+22     	; 0xd8dc <strlcpy_P+0x20>
    d8c6:	49 f0       	breq	.+18     	; 0xd8da <strlcpy_P+0x1e>
    d8c8:	05 90       	lpm	r0, Z+
    d8ca:	0d 92       	st	X+, r0
    d8cc:	00 20       	and	r0, r0
    d8ce:	c1 f7       	brne	.-16     	; 0xd8c0 <strlcpy_P+0x4>
    d8d0:	e6 1b       	sub	r30, r22
    d8d2:	f7 0b       	sbc	r31, r23
    d8d4:	31 97       	sbiw	r30, 0x01	; 1
    d8d6:	cf 01       	movw	r24, r30
    d8d8:	08 95       	ret
    d8da:	1c 92       	st	X, r1
    d8dc:	05 90       	lpm	r0, Z+
    d8de:	00 20       	and	r0, r0
    d8e0:	e9 f7       	brne	.-6      	; 0xd8dc <strlcpy_P+0x20>
    d8e2:	f6 cf       	rjmp	.-20     	; 0xd8d0 <strlcpy_P+0x14>

0000d8e4 <__strlen_P>:
    d8e4:	fc 01       	movw	r30, r24
    d8e6:	05 90       	lpm	r0, Z+
    d8e8:	00 20       	and	r0, r0
    d8ea:	e9 f7       	brne	.-6      	; 0xd8e6 <__strlen_P+0x2>
    d8ec:	80 95       	com	r24
    d8ee:	90 95       	com	r25
    d8f0:	8e 0f       	add	r24, r30
    d8f2:	9f 1f       	adc	r25, r31
    d8f4:	08 95       	ret

0000d8f6 <strncmp_P>:
    d8f6:	fb 01       	movw	r30, r22
    d8f8:	dc 01       	movw	r26, r24
    d8fa:	41 50       	subi	r20, 0x01	; 1
    d8fc:	50 40       	sbci	r21, 0x00	; 0
    d8fe:	30 f0       	brcs	.+12     	; 0xd90c <strncmp_P+0x16>
    d900:	8d 91       	ld	r24, X+
    d902:	05 90       	lpm	r0, Z+
    d904:	80 19       	sub	r24, r0
    d906:	19 f4       	brne	.+6      	; 0xd90e <strncmp_P+0x18>
    d908:	00 20       	and	r0, r0
    d90a:	b9 f7       	brne	.-18     	; 0xd8fa <strncmp_P+0x4>
    d90c:	88 1b       	sub	r24, r24
    d90e:	99 0b       	sbc	r25, r25
    d910:	08 95       	ret

0000d912 <strstr_P>:
    d912:	fb 01       	movw	r30, r22
    d914:	55 91       	lpm	r21, Z+
    d916:	55 23       	and	r21, r21
    d918:	a9 f0       	breq	.+42     	; 0xd944 <strstr_P+0x32>
    d91a:	bf 01       	movw	r22, r30
    d91c:	dc 01       	movw	r26, r24
    d91e:	4d 91       	ld	r20, X+
    d920:	45 17       	cp	r20, r21
    d922:	41 11       	cpse	r20, r1
    d924:	e1 f7       	brne	.-8      	; 0xd91e <strstr_P+0xc>
    d926:	59 f4       	brne	.+22     	; 0xd93e <strstr_P+0x2c>
    d928:	cd 01       	movw	r24, r26
    d92a:	05 90       	lpm	r0, Z+
    d92c:	00 20       	and	r0, r0
    d92e:	49 f0       	breq	.+18     	; 0xd942 <strstr_P+0x30>
    d930:	4d 91       	ld	r20, X+
    d932:	40 15       	cp	r20, r0
    d934:	41 11       	cpse	r20, r1
    d936:	c9 f3       	breq	.-14     	; 0xd92a <strstr_P+0x18>
    d938:	fb 01       	movw	r30, r22
    d93a:	41 11       	cpse	r20, r1
    d93c:	ef cf       	rjmp	.-34     	; 0xd91c <strstr_P+0xa>
    d93e:	81 e0       	ldi	r24, 0x01	; 1
    d940:	90 e0       	ldi	r25, 0x00	; 0
    d942:	01 97       	sbiw	r24, 0x01	; 1
    d944:	08 95       	ret

0000d946 <memcpy>:
    d946:	fb 01       	movw	r30, r22
    d948:	dc 01       	movw	r26, r24
    d94a:	02 c0       	rjmp	.+4      	; 0xd950 <memcpy+0xa>
    d94c:	01 90       	ld	r0, Z+
    d94e:	0d 92       	st	X+, r0
    d950:	41 50       	subi	r20, 0x01	; 1
    d952:	50 40       	sbci	r21, 0x00	; 0
    d954:	d8 f7       	brcc	.-10     	; 0xd94c <memcpy+0x6>
    d956:	08 95       	ret

0000d958 <strchr>:
    d958:	fc 01       	movw	r30, r24
    d95a:	81 91       	ld	r24, Z+
    d95c:	86 17       	cp	r24, r22
    d95e:	21 f0       	breq	.+8      	; 0xd968 <strchr+0x10>
    d960:	88 23       	and	r24, r24
    d962:	d9 f7       	brne	.-10     	; 0xd95a <strchr+0x2>
    d964:	99 27       	eor	r25, r25
    d966:	08 95       	ret
    d968:	31 97       	sbiw	r30, 0x01	; 1
    d96a:	cf 01       	movw	r24, r30
    d96c:	08 95       	ret

0000d96e <strcmp>:
    d96e:	fb 01       	movw	r30, r22
    d970:	dc 01       	movw	r26, r24
    d972:	8d 91       	ld	r24, X+
    d974:	01 90       	ld	r0, Z+
    d976:	80 19       	sub	r24, r0
    d978:	01 10       	cpse	r0, r1
    d97a:	d9 f3       	breq	.-10     	; 0xd972 <strcmp+0x4>
    d97c:	99 0b       	sbc	r25, r25
    d97e:	08 95       	ret

0000d980 <strcpy>:
    d980:	fb 01       	movw	r30, r22
    d982:	dc 01       	movw	r26, r24
    d984:	01 90       	ld	r0, Z+
    d986:	0d 92       	st	X+, r0
    d988:	00 20       	and	r0, r0
    d98a:	e1 f7       	brne	.-8      	; 0xd984 <strcpy+0x4>
    d98c:	08 95       	ret

0000d98e <strncmp>:
    d98e:	fb 01       	movw	r30, r22
    d990:	dc 01       	movw	r26, r24
    d992:	41 50       	subi	r20, 0x01	; 1
    d994:	50 40       	sbci	r21, 0x00	; 0
    d996:	30 f0       	brcs	.+12     	; 0xd9a4 <strncmp+0x16>
    d998:	8d 91       	ld	r24, X+
    d99a:	01 90       	ld	r0, Z+
    d99c:	80 19       	sub	r24, r0
    d99e:	19 f4       	brne	.+6      	; 0xd9a6 <strncmp+0x18>
    d9a0:	00 20       	and	r0, r0
    d9a2:	b9 f7       	brne	.-18     	; 0xd992 <strncmp+0x4>
    d9a4:	88 1b       	sub	r24, r24
    d9a6:	99 0b       	sbc	r25, r25
    d9a8:	08 95       	ret

0000d9aa <sprintf>:
    d9aa:	0f 93       	push	r16
    d9ac:	1f 93       	push	r17
    d9ae:	cf 93       	push	r28
    d9b0:	df 93       	push	r29
    d9b2:	cd b7       	in	r28, 0x3d	; 61
    d9b4:	de b7       	in	r29, 0x3e	; 62
    d9b6:	2e 97       	sbiw	r28, 0x0e	; 14
    d9b8:	0f b6       	in	r0, 0x3f	; 63
    d9ba:	f8 94       	cli
    d9bc:	de bf       	out	0x3e, r29	; 62
    d9be:	0f be       	out	0x3f, r0	; 63
    d9c0:	cd bf       	out	0x3d, r28	; 61
    d9c2:	0d 89       	ldd	r16, Y+21	; 0x15
    d9c4:	1e 89       	ldd	r17, Y+22	; 0x16
    d9c6:	86 e0       	ldi	r24, 0x06	; 6
    d9c8:	8c 83       	std	Y+4, r24	; 0x04
    d9ca:	1a 83       	std	Y+2, r17	; 0x02
    d9cc:	09 83       	std	Y+1, r16	; 0x01
    d9ce:	8f ef       	ldi	r24, 0xFF	; 255
    d9d0:	9f e7       	ldi	r25, 0x7F	; 127
    d9d2:	9e 83       	std	Y+6, r25	; 0x06
    d9d4:	8d 83       	std	Y+5, r24	; 0x05
    d9d6:	ae 01       	movw	r20, r28
    d9d8:	47 5e       	subi	r20, 0xE7	; 231
    d9da:	5f 4f       	sbci	r21, 0xFF	; 255
    d9dc:	6f 89       	ldd	r22, Y+23	; 0x17
    d9de:	78 8d       	ldd	r23, Y+24	; 0x18
    d9e0:	ce 01       	movw	r24, r28
    d9e2:	01 96       	adiw	r24, 0x01	; 1
    d9e4:	0e 94 01 6f 	call	0xde02	; 0xde02 <vfprintf>
    d9e8:	ef 81       	ldd	r30, Y+7	; 0x07
    d9ea:	f8 85       	ldd	r31, Y+8	; 0x08
    d9ec:	e0 0f       	add	r30, r16
    d9ee:	f1 1f       	adc	r31, r17
    d9f0:	10 82       	st	Z, r1
    d9f2:	2e 96       	adiw	r28, 0x0e	; 14
    d9f4:	0f b6       	in	r0, 0x3f	; 63
    d9f6:	f8 94       	cli
    d9f8:	de bf       	out	0x3e, r29	; 62
    d9fa:	0f be       	out	0x3f, r0	; 63
    d9fc:	cd bf       	out	0x3d, r28	; 61
    d9fe:	df 91       	pop	r29
    da00:	cf 91       	pop	r28
    da02:	1f 91       	pop	r17
    da04:	0f 91       	pop	r16
    da06:	08 95       	ret

0000da08 <sprintf_P>:
    da08:	0f 93       	push	r16
    da0a:	1f 93       	push	r17
    da0c:	cf 93       	push	r28
    da0e:	df 93       	push	r29
    da10:	cd b7       	in	r28, 0x3d	; 61
    da12:	de b7       	in	r29, 0x3e	; 62
    da14:	2e 97       	sbiw	r28, 0x0e	; 14
    da16:	0f b6       	in	r0, 0x3f	; 63
    da18:	f8 94       	cli
    da1a:	de bf       	out	0x3e, r29	; 62
    da1c:	0f be       	out	0x3f, r0	; 63
    da1e:	cd bf       	out	0x3d, r28	; 61
    da20:	0d 89       	ldd	r16, Y+21	; 0x15
    da22:	1e 89       	ldd	r17, Y+22	; 0x16
    da24:	8e e0       	ldi	r24, 0x0E	; 14
    da26:	8c 83       	std	Y+4, r24	; 0x04
    da28:	1a 83       	std	Y+2, r17	; 0x02
    da2a:	09 83       	std	Y+1, r16	; 0x01
    da2c:	8f ef       	ldi	r24, 0xFF	; 255
    da2e:	9f e7       	ldi	r25, 0x7F	; 127
    da30:	9e 83       	std	Y+6, r25	; 0x06
    da32:	8d 83       	std	Y+5, r24	; 0x05
    da34:	ae 01       	movw	r20, r28
    da36:	47 5e       	subi	r20, 0xE7	; 231
    da38:	5f 4f       	sbci	r21, 0xFF	; 255
    da3a:	6f 89       	ldd	r22, Y+23	; 0x17
    da3c:	78 8d       	ldd	r23, Y+24	; 0x18
    da3e:	ce 01       	movw	r24, r28
    da40:	01 96       	adiw	r24, 0x01	; 1
    da42:	0e 94 01 6f 	call	0xde02	; 0xde02 <vfprintf>
    da46:	ef 81       	ldd	r30, Y+7	; 0x07
    da48:	f8 85       	ldd	r31, Y+8	; 0x08
    da4a:	e0 0f       	add	r30, r16
    da4c:	f1 1f       	adc	r31, r17
    da4e:	10 82       	st	Z, r1
    da50:	2e 96       	adiw	r28, 0x0e	; 14
    da52:	0f b6       	in	r0, 0x3f	; 63
    da54:	f8 94       	cli
    da56:	de bf       	out	0x3e, r29	; 62
    da58:	0f be       	out	0x3f, r0	; 63
    da5a:	cd bf       	out	0x3d, r28	; 61
    da5c:	df 91       	pop	r29
    da5e:	cf 91       	pop	r28
    da60:	1f 91       	pop	r17
    da62:	0f 91       	pop	r16
    da64:	08 95       	ret

0000da66 <sscanf>:
    da66:	cf 93       	push	r28
    da68:	df 93       	push	r29
    da6a:	cd b7       	in	r28, 0x3d	; 61
    da6c:	de b7       	in	r29, 0x3e	; 62
    da6e:	2e 97       	sbiw	r28, 0x0e	; 14
    da70:	0f b6       	in	r0, 0x3f	; 63
    da72:	f8 94       	cli
    da74:	de bf       	out	0x3e, r29	; 62
    da76:	0f be       	out	0x3f, r0	; 63
    da78:	cd bf       	out	0x3d, r28	; 61
    da7a:	85 e0       	ldi	r24, 0x05	; 5
    da7c:	8c 83       	std	Y+4, r24	; 0x04
    da7e:	8b 89       	ldd	r24, Y+19	; 0x13
    da80:	9c 89       	ldd	r25, Y+20	; 0x14
    da82:	9a 83       	std	Y+2, r25	; 0x02
    da84:	89 83       	std	Y+1, r24	; 0x01
    da86:	ae 01       	movw	r20, r28
    da88:	49 5e       	subi	r20, 0xE9	; 233
    da8a:	5f 4f       	sbci	r21, 0xFF	; 255
    da8c:	6d 89       	ldd	r22, Y+21	; 0x15
    da8e:	7e 89       	ldd	r23, Y+22	; 0x16
    da90:	ce 01       	movw	r24, r28
    da92:	01 96       	adiw	r24, 0x01	; 1
    da94:	0e 94 99 72 	call	0xe532	; 0xe532 <vfscanf>
    da98:	2e 96       	adiw	r28, 0x0e	; 14
    da9a:	0f b6       	in	r0, 0x3f	; 63
    da9c:	f8 94       	cli
    da9e:	de bf       	out	0x3e, r29	; 62
    daa0:	0f be       	out	0x3f, r0	; 63
    daa2:	cd bf       	out	0x3d, r28	; 61
    daa4:	df 91       	pop	r29
    daa6:	cf 91       	pop	r28
    daa8:	08 95       	ret

0000daaa <sscanf_P>:
    daaa:	cf 93       	push	r28
    daac:	df 93       	push	r29
    daae:	cd b7       	in	r28, 0x3d	; 61
    dab0:	de b7       	in	r29, 0x3e	; 62
    dab2:	2e 97       	sbiw	r28, 0x0e	; 14
    dab4:	0f b6       	in	r0, 0x3f	; 63
    dab6:	f8 94       	cli
    dab8:	de bf       	out	0x3e, r29	; 62
    daba:	0f be       	out	0x3f, r0	; 63
    dabc:	cd bf       	out	0x3d, r28	; 61
    dabe:	8d e0       	ldi	r24, 0x0D	; 13
    dac0:	8c 83       	std	Y+4, r24	; 0x04
    dac2:	8b 89       	ldd	r24, Y+19	; 0x13
    dac4:	9c 89       	ldd	r25, Y+20	; 0x14
    dac6:	9a 83       	std	Y+2, r25	; 0x02
    dac8:	89 83       	std	Y+1, r24	; 0x01
    daca:	ae 01       	movw	r20, r28
    dacc:	49 5e       	subi	r20, 0xE9	; 233
    dace:	5f 4f       	sbci	r21, 0xFF	; 255
    dad0:	6d 89       	ldd	r22, Y+21	; 0x15
    dad2:	7e 89       	ldd	r23, Y+22	; 0x16
    dad4:	ce 01       	movw	r24, r28
    dad6:	01 96       	adiw	r24, 0x01	; 1
    dad8:	0e 94 99 72 	call	0xe532	; 0xe532 <vfscanf>
    dadc:	2e 96       	adiw	r28, 0x0e	; 14
    dade:	0f b6       	in	r0, 0x3f	; 63
    dae0:	f8 94       	cli
    dae2:	de bf       	out	0x3e, r29	; 62
    dae4:	0f be       	out	0x3f, r0	; 63
    dae6:	cd bf       	out	0x3d, r28	; 61
    dae8:	df 91       	pop	r29
    daea:	cf 91       	pop	r28
    daec:	08 95       	ret

0000daee <__divsf3>:
    daee:	0c d0       	rcall	.+24     	; 0xdb08 <__divsf3x>
    daf0:	eb c0       	rjmp	.+470    	; 0xdcc8 <__fp_round>
    daf2:	e3 d0       	rcall	.+454    	; 0xdcba <__fp_pscB>
    daf4:	40 f0       	brcs	.+16     	; 0xdb06 <__divsf3+0x18>
    daf6:	da d0       	rcall	.+436    	; 0xdcac <__fp_pscA>
    daf8:	30 f0       	brcs	.+12     	; 0xdb06 <__divsf3+0x18>
    dafa:	21 f4       	brne	.+8      	; 0xdb04 <__divsf3+0x16>
    dafc:	5f 3f       	cpi	r21, 0xFF	; 255
    dafe:	19 f0       	breq	.+6      	; 0xdb06 <__divsf3+0x18>
    db00:	cc c0       	rjmp	.+408    	; 0xdc9a <__fp_inf>
    db02:	51 11       	cpse	r21, r1
    db04:	15 c1       	rjmp	.+554    	; 0xdd30 <__fp_szero>
    db06:	cf c0       	rjmp	.+414    	; 0xdca6 <__fp_nan>

0000db08 <__divsf3x>:
    db08:	f0 d0       	rcall	.+480    	; 0xdcea <__fp_split3>
    db0a:	98 f3       	brcs	.-26     	; 0xdaf2 <__divsf3+0x4>

0000db0c <__divsf3_pse>:
    db0c:	99 23       	and	r25, r25
    db0e:	c9 f3       	breq	.-14     	; 0xdb02 <__divsf3+0x14>
    db10:	55 23       	and	r21, r21
    db12:	b1 f3       	breq	.-20     	; 0xdb00 <__divsf3+0x12>
    db14:	95 1b       	sub	r25, r21
    db16:	55 0b       	sbc	r21, r21
    db18:	bb 27       	eor	r27, r27
    db1a:	aa 27       	eor	r26, r26
    db1c:	62 17       	cp	r22, r18
    db1e:	73 07       	cpc	r23, r19
    db20:	84 07       	cpc	r24, r20
    db22:	38 f0       	brcs	.+14     	; 0xdb32 <__divsf3_pse+0x26>
    db24:	9f 5f       	subi	r25, 0xFF	; 255
    db26:	5f 4f       	sbci	r21, 0xFF	; 255
    db28:	22 0f       	add	r18, r18
    db2a:	33 1f       	adc	r19, r19
    db2c:	44 1f       	adc	r20, r20
    db2e:	aa 1f       	adc	r26, r26
    db30:	a9 f3       	breq	.-22     	; 0xdb1c <__divsf3_pse+0x10>
    db32:	33 d0       	rcall	.+102    	; 0xdb9a <__divsf3_pse+0x8e>
    db34:	0e 2e       	mov	r0, r30
    db36:	3a f0       	brmi	.+14     	; 0xdb46 <__divsf3_pse+0x3a>
    db38:	e0 e8       	ldi	r30, 0x80	; 128
    db3a:	30 d0       	rcall	.+96     	; 0xdb9c <__divsf3_pse+0x90>
    db3c:	91 50       	subi	r25, 0x01	; 1
    db3e:	50 40       	sbci	r21, 0x00	; 0
    db40:	e6 95       	lsr	r30
    db42:	00 1c       	adc	r0, r0
    db44:	ca f7       	brpl	.-14     	; 0xdb38 <__divsf3_pse+0x2c>
    db46:	29 d0       	rcall	.+82     	; 0xdb9a <__divsf3_pse+0x8e>
    db48:	fe 2f       	mov	r31, r30
    db4a:	27 d0       	rcall	.+78     	; 0xdb9a <__divsf3_pse+0x8e>
    db4c:	66 0f       	add	r22, r22
    db4e:	77 1f       	adc	r23, r23
    db50:	88 1f       	adc	r24, r24
    db52:	bb 1f       	adc	r27, r27
    db54:	26 17       	cp	r18, r22
    db56:	37 07       	cpc	r19, r23
    db58:	48 07       	cpc	r20, r24
    db5a:	ab 07       	cpc	r26, r27
    db5c:	b0 e8       	ldi	r27, 0x80	; 128
    db5e:	09 f0       	breq	.+2      	; 0xdb62 <__divsf3_pse+0x56>
    db60:	bb 0b       	sbc	r27, r27
    db62:	80 2d       	mov	r24, r0
    db64:	bf 01       	movw	r22, r30
    db66:	ff 27       	eor	r31, r31
    db68:	93 58       	subi	r25, 0x83	; 131
    db6a:	5f 4f       	sbci	r21, 0xFF	; 255
    db6c:	2a f0       	brmi	.+10     	; 0xdb78 <__divsf3_pse+0x6c>
    db6e:	9e 3f       	cpi	r25, 0xFE	; 254
    db70:	51 05       	cpc	r21, r1
    db72:	68 f0       	brcs	.+26     	; 0xdb8e <__divsf3_pse+0x82>
    db74:	92 c0       	rjmp	.+292    	; 0xdc9a <__fp_inf>
    db76:	dc c0       	rjmp	.+440    	; 0xdd30 <__fp_szero>
    db78:	5f 3f       	cpi	r21, 0xFF	; 255
    db7a:	ec f3       	brlt	.-6      	; 0xdb76 <__divsf3_pse+0x6a>
    db7c:	98 3e       	cpi	r25, 0xE8	; 232
    db7e:	dc f3       	brlt	.-10     	; 0xdb76 <__divsf3_pse+0x6a>
    db80:	86 95       	lsr	r24
    db82:	77 95       	ror	r23
    db84:	67 95       	ror	r22
    db86:	b7 95       	ror	r27
    db88:	f7 95       	ror	r31
    db8a:	9f 5f       	subi	r25, 0xFF	; 255
    db8c:	c9 f7       	brne	.-14     	; 0xdb80 <__divsf3_pse+0x74>
    db8e:	88 0f       	add	r24, r24
    db90:	91 1d       	adc	r25, r1
    db92:	96 95       	lsr	r25
    db94:	87 95       	ror	r24
    db96:	97 f9       	bld	r25, 7
    db98:	08 95       	ret
    db9a:	e1 e0       	ldi	r30, 0x01	; 1
    db9c:	66 0f       	add	r22, r22
    db9e:	77 1f       	adc	r23, r23
    dba0:	88 1f       	adc	r24, r24
    dba2:	bb 1f       	adc	r27, r27
    dba4:	62 17       	cp	r22, r18
    dba6:	73 07       	cpc	r23, r19
    dba8:	84 07       	cpc	r24, r20
    dbaa:	ba 07       	cpc	r27, r26
    dbac:	20 f0       	brcs	.+8      	; 0xdbb6 <__divsf3_pse+0xaa>
    dbae:	62 1b       	sub	r22, r18
    dbb0:	73 0b       	sbc	r23, r19
    dbb2:	84 0b       	sbc	r24, r20
    dbb4:	ba 0b       	sbc	r27, r26
    dbb6:	ee 1f       	adc	r30, r30
    dbb8:	88 f7       	brcc	.-30     	; 0xdb9c <__divsf3_pse+0x90>
    dbba:	e0 95       	com	r30
    dbbc:	08 95       	ret

0000dbbe <__fixsfsi>:
    dbbe:	04 d0       	rcall	.+8      	; 0xdbc8 <__fixunssfsi>
    dbc0:	68 94       	set
    dbc2:	b1 11       	cpse	r27, r1
    dbc4:	b5 c0       	rjmp	.+362    	; 0xdd30 <__fp_szero>
    dbc6:	08 95       	ret

0000dbc8 <__fixunssfsi>:
    dbc8:	98 d0       	rcall	.+304    	; 0xdcfa <__fp_splitA>
    dbca:	88 f0       	brcs	.+34     	; 0xdbee <__fixunssfsi+0x26>
    dbcc:	9f 57       	subi	r25, 0x7F	; 127
    dbce:	90 f0       	brcs	.+36     	; 0xdbf4 <__fixunssfsi+0x2c>
    dbd0:	b9 2f       	mov	r27, r25
    dbd2:	99 27       	eor	r25, r25
    dbd4:	b7 51       	subi	r27, 0x17	; 23
    dbd6:	a0 f0       	brcs	.+40     	; 0xdc00 <__fixunssfsi+0x38>
    dbd8:	d1 f0       	breq	.+52     	; 0xdc0e <__fixunssfsi+0x46>
    dbda:	66 0f       	add	r22, r22
    dbdc:	77 1f       	adc	r23, r23
    dbde:	88 1f       	adc	r24, r24
    dbe0:	99 1f       	adc	r25, r25
    dbe2:	1a f0       	brmi	.+6      	; 0xdbea <__fixunssfsi+0x22>
    dbe4:	ba 95       	dec	r27
    dbe6:	c9 f7       	brne	.-14     	; 0xdbda <__fixunssfsi+0x12>
    dbe8:	12 c0       	rjmp	.+36     	; 0xdc0e <__fixunssfsi+0x46>
    dbea:	b1 30       	cpi	r27, 0x01	; 1
    dbec:	81 f0       	breq	.+32     	; 0xdc0e <__fixunssfsi+0x46>
    dbee:	9f d0       	rcall	.+318    	; 0xdd2e <__fp_zero>
    dbf0:	b1 e0       	ldi	r27, 0x01	; 1
    dbf2:	08 95       	ret
    dbf4:	9c c0       	rjmp	.+312    	; 0xdd2e <__fp_zero>
    dbf6:	67 2f       	mov	r22, r23
    dbf8:	78 2f       	mov	r23, r24
    dbfa:	88 27       	eor	r24, r24
    dbfc:	b8 5f       	subi	r27, 0xF8	; 248
    dbfe:	39 f0       	breq	.+14     	; 0xdc0e <__fixunssfsi+0x46>
    dc00:	b9 3f       	cpi	r27, 0xF9	; 249
    dc02:	cc f3       	brlt	.-14     	; 0xdbf6 <__fixunssfsi+0x2e>
    dc04:	86 95       	lsr	r24
    dc06:	77 95       	ror	r23
    dc08:	67 95       	ror	r22
    dc0a:	b3 95       	inc	r27
    dc0c:	d9 f7       	brne	.-10     	; 0xdc04 <__fixunssfsi+0x3c>
    dc0e:	3e f4       	brtc	.+14     	; 0xdc1e <__fixunssfsi+0x56>
    dc10:	90 95       	com	r25
    dc12:	80 95       	com	r24
    dc14:	70 95       	com	r23
    dc16:	61 95       	neg	r22
    dc18:	7f 4f       	sbci	r23, 0xFF	; 255
    dc1a:	8f 4f       	sbci	r24, 0xFF	; 255
    dc1c:	9f 4f       	sbci	r25, 0xFF	; 255
    dc1e:	08 95       	ret

0000dc20 <__floatunsisf>:
    dc20:	e8 94       	clt
    dc22:	09 c0       	rjmp	.+18     	; 0xdc36 <__floatsisf+0x12>

0000dc24 <__floatsisf>:
    dc24:	97 fb       	bst	r25, 7
    dc26:	3e f4       	brtc	.+14     	; 0xdc36 <__floatsisf+0x12>
    dc28:	90 95       	com	r25
    dc2a:	80 95       	com	r24
    dc2c:	70 95       	com	r23
    dc2e:	61 95       	neg	r22
    dc30:	7f 4f       	sbci	r23, 0xFF	; 255
    dc32:	8f 4f       	sbci	r24, 0xFF	; 255
    dc34:	9f 4f       	sbci	r25, 0xFF	; 255
    dc36:	99 23       	and	r25, r25
    dc38:	a9 f0       	breq	.+42     	; 0xdc64 <__floatsisf+0x40>
    dc3a:	f9 2f       	mov	r31, r25
    dc3c:	96 e9       	ldi	r25, 0x96	; 150
    dc3e:	bb 27       	eor	r27, r27
    dc40:	93 95       	inc	r25
    dc42:	f6 95       	lsr	r31
    dc44:	87 95       	ror	r24
    dc46:	77 95       	ror	r23
    dc48:	67 95       	ror	r22
    dc4a:	b7 95       	ror	r27
    dc4c:	f1 11       	cpse	r31, r1
    dc4e:	f8 cf       	rjmp	.-16     	; 0xdc40 <__floatsisf+0x1c>
    dc50:	fa f4       	brpl	.+62     	; 0xdc90 <__floatsisf+0x6c>
    dc52:	bb 0f       	add	r27, r27
    dc54:	11 f4       	brne	.+4      	; 0xdc5a <__floatsisf+0x36>
    dc56:	60 ff       	sbrs	r22, 0
    dc58:	1b c0       	rjmp	.+54     	; 0xdc90 <__floatsisf+0x6c>
    dc5a:	6f 5f       	subi	r22, 0xFF	; 255
    dc5c:	7f 4f       	sbci	r23, 0xFF	; 255
    dc5e:	8f 4f       	sbci	r24, 0xFF	; 255
    dc60:	9f 4f       	sbci	r25, 0xFF	; 255
    dc62:	16 c0       	rjmp	.+44     	; 0xdc90 <__floatsisf+0x6c>
    dc64:	88 23       	and	r24, r24
    dc66:	11 f0       	breq	.+4      	; 0xdc6c <__floatsisf+0x48>
    dc68:	96 e9       	ldi	r25, 0x96	; 150
    dc6a:	11 c0       	rjmp	.+34     	; 0xdc8e <__floatsisf+0x6a>
    dc6c:	77 23       	and	r23, r23
    dc6e:	21 f0       	breq	.+8      	; 0xdc78 <__floatsisf+0x54>
    dc70:	9e e8       	ldi	r25, 0x8E	; 142
    dc72:	87 2f       	mov	r24, r23
    dc74:	76 2f       	mov	r23, r22
    dc76:	05 c0       	rjmp	.+10     	; 0xdc82 <__floatsisf+0x5e>
    dc78:	66 23       	and	r22, r22
    dc7a:	71 f0       	breq	.+28     	; 0xdc98 <__floatsisf+0x74>
    dc7c:	96 e8       	ldi	r25, 0x86	; 134
    dc7e:	86 2f       	mov	r24, r22
    dc80:	70 e0       	ldi	r23, 0x00	; 0
    dc82:	60 e0       	ldi	r22, 0x00	; 0
    dc84:	2a f0       	brmi	.+10     	; 0xdc90 <__floatsisf+0x6c>
    dc86:	9a 95       	dec	r25
    dc88:	66 0f       	add	r22, r22
    dc8a:	77 1f       	adc	r23, r23
    dc8c:	88 1f       	adc	r24, r24
    dc8e:	da f7       	brpl	.-10     	; 0xdc86 <__floatsisf+0x62>
    dc90:	88 0f       	add	r24, r24
    dc92:	96 95       	lsr	r25
    dc94:	87 95       	ror	r24
    dc96:	97 f9       	bld	r25, 7
    dc98:	08 95       	ret

0000dc9a <__fp_inf>:
    dc9a:	97 f9       	bld	r25, 7
    dc9c:	9f 67       	ori	r25, 0x7F	; 127
    dc9e:	80 e8       	ldi	r24, 0x80	; 128
    dca0:	70 e0       	ldi	r23, 0x00	; 0
    dca2:	60 e0       	ldi	r22, 0x00	; 0
    dca4:	08 95       	ret

0000dca6 <__fp_nan>:
    dca6:	9f ef       	ldi	r25, 0xFF	; 255
    dca8:	80 ec       	ldi	r24, 0xC0	; 192
    dcaa:	08 95       	ret

0000dcac <__fp_pscA>:
    dcac:	00 24       	eor	r0, r0
    dcae:	0a 94       	dec	r0
    dcb0:	16 16       	cp	r1, r22
    dcb2:	17 06       	cpc	r1, r23
    dcb4:	18 06       	cpc	r1, r24
    dcb6:	09 06       	cpc	r0, r25
    dcb8:	08 95       	ret

0000dcba <__fp_pscB>:
    dcba:	00 24       	eor	r0, r0
    dcbc:	0a 94       	dec	r0
    dcbe:	12 16       	cp	r1, r18
    dcc0:	13 06       	cpc	r1, r19
    dcc2:	14 06       	cpc	r1, r20
    dcc4:	05 06       	cpc	r0, r21
    dcc6:	08 95       	ret

0000dcc8 <__fp_round>:
    dcc8:	09 2e       	mov	r0, r25
    dcca:	03 94       	inc	r0
    dccc:	00 0c       	add	r0, r0
    dcce:	11 f4       	brne	.+4      	; 0xdcd4 <__fp_round+0xc>
    dcd0:	88 23       	and	r24, r24
    dcd2:	52 f0       	brmi	.+20     	; 0xdce8 <__fp_round+0x20>
    dcd4:	bb 0f       	add	r27, r27
    dcd6:	40 f4       	brcc	.+16     	; 0xdce8 <__fp_round+0x20>
    dcd8:	bf 2b       	or	r27, r31
    dcda:	11 f4       	brne	.+4      	; 0xdce0 <__fp_round+0x18>
    dcdc:	60 ff       	sbrs	r22, 0
    dcde:	04 c0       	rjmp	.+8      	; 0xdce8 <__fp_round+0x20>
    dce0:	6f 5f       	subi	r22, 0xFF	; 255
    dce2:	7f 4f       	sbci	r23, 0xFF	; 255
    dce4:	8f 4f       	sbci	r24, 0xFF	; 255
    dce6:	9f 4f       	sbci	r25, 0xFF	; 255
    dce8:	08 95       	ret

0000dcea <__fp_split3>:
    dcea:	57 fd       	sbrc	r21, 7
    dcec:	90 58       	subi	r25, 0x80	; 128
    dcee:	44 0f       	add	r20, r20
    dcf0:	55 1f       	adc	r21, r21
    dcf2:	59 f0       	breq	.+22     	; 0xdd0a <__fp_splitA+0x10>
    dcf4:	5f 3f       	cpi	r21, 0xFF	; 255
    dcf6:	71 f0       	breq	.+28     	; 0xdd14 <__fp_splitA+0x1a>
    dcf8:	47 95       	ror	r20

0000dcfa <__fp_splitA>:
    dcfa:	88 0f       	add	r24, r24
    dcfc:	97 fb       	bst	r25, 7
    dcfe:	99 1f       	adc	r25, r25
    dd00:	61 f0       	breq	.+24     	; 0xdd1a <__fp_splitA+0x20>
    dd02:	9f 3f       	cpi	r25, 0xFF	; 255
    dd04:	79 f0       	breq	.+30     	; 0xdd24 <__fp_splitA+0x2a>
    dd06:	87 95       	ror	r24
    dd08:	08 95       	ret
    dd0a:	12 16       	cp	r1, r18
    dd0c:	13 06       	cpc	r1, r19
    dd0e:	14 06       	cpc	r1, r20
    dd10:	55 1f       	adc	r21, r21
    dd12:	f2 cf       	rjmp	.-28     	; 0xdcf8 <__fp_split3+0xe>
    dd14:	46 95       	lsr	r20
    dd16:	f1 df       	rcall	.-30     	; 0xdcfa <__fp_splitA>
    dd18:	08 c0       	rjmp	.+16     	; 0xdd2a <__fp_splitA+0x30>
    dd1a:	16 16       	cp	r1, r22
    dd1c:	17 06       	cpc	r1, r23
    dd1e:	18 06       	cpc	r1, r24
    dd20:	99 1f       	adc	r25, r25
    dd22:	f1 cf       	rjmp	.-30     	; 0xdd06 <__fp_splitA+0xc>
    dd24:	86 95       	lsr	r24
    dd26:	71 05       	cpc	r23, r1
    dd28:	61 05       	cpc	r22, r1
    dd2a:	08 94       	sec
    dd2c:	08 95       	ret

0000dd2e <__fp_zero>:
    dd2e:	e8 94       	clt

0000dd30 <__fp_szero>:
    dd30:	bb 27       	eor	r27, r27
    dd32:	66 27       	eor	r22, r22
    dd34:	77 27       	eor	r23, r23
    dd36:	cb 01       	movw	r24, r22
    dd38:	97 f9       	bld	r25, 7
    dd3a:	08 95       	ret

0000dd3c <__mulsf3>:
    dd3c:	0b d0       	rcall	.+22     	; 0xdd54 <__mulsf3x>
    dd3e:	c4 cf       	rjmp	.-120    	; 0xdcc8 <__fp_round>
    dd40:	b5 df       	rcall	.-150    	; 0xdcac <__fp_pscA>
    dd42:	28 f0       	brcs	.+10     	; 0xdd4e <__mulsf3+0x12>
    dd44:	ba df       	rcall	.-140    	; 0xdcba <__fp_pscB>
    dd46:	18 f0       	brcs	.+6      	; 0xdd4e <__mulsf3+0x12>
    dd48:	95 23       	and	r25, r21
    dd4a:	09 f0       	breq	.+2      	; 0xdd4e <__mulsf3+0x12>
    dd4c:	a6 cf       	rjmp	.-180    	; 0xdc9a <__fp_inf>
    dd4e:	ab cf       	rjmp	.-170    	; 0xdca6 <__fp_nan>
    dd50:	11 24       	eor	r1, r1
    dd52:	ee cf       	rjmp	.-36     	; 0xdd30 <__fp_szero>

0000dd54 <__mulsf3x>:
    dd54:	ca df       	rcall	.-108    	; 0xdcea <__fp_split3>
    dd56:	a0 f3       	brcs	.-24     	; 0xdd40 <__mulsf3+0x4>

0000dd58 <__mulsf3_pse>:
    dd58:	95 9f       	mul	r25, r21
    dd5a:	d1 f3       	breq	.-12     	; 0xdd50 <__mulsf3+0x14>
    dd5c:	95 0f       	add	r25, r21
    dd5e:	50 e0       	ldi	r21, 0x00	; 0
    dd60:	55 1f       	adc	r21, r21
    dd62:	62 9f       	mul	r22, r18
    dd64:	f0 01       	movw	r30, r0
    dd66:	72 9f       	mul	r23, r18
    dd68:	bb 27       	eor	r27, r27
    dd6a:	f0 0d       	add	r31, r0
    dd6c:	b1 1d       	adc	r27, r1
    dd6e:	63 9f       	mul	r22, r19
    dd70:	aa 27       	eor	r26, r26
    dd72:	f0 0d       	add	r31, r0
    dd74:	b1 1d       	adc	r27, r1
    dd76:	aa 1f       	adc	r26, r26
    dd78:	64 9f       	mul	r22, r20
    dd7a:	66 27       	eor	r22, r22
    dd7c:	b0 0d       	add	r27, r0
    dd7e:	a1 1d       	adc	r26, r1
    dd80:	66 1f       	adc	r22, r22
    dd82:	82 9f       	mul	r24, r18
    dd84:	22 27       	eor	r18, r18
    dd86:	b0 0d       	add	r27, r0
    dd88:	a1 1d       	adc	r26, r1
    dd8a:	62 1f       	adc	r22, r18
    dd8c:	73 9f       	mul	r23, r19
    dd8e:	b0 0d       	add	r27, r0
    dd90:	a1 1d       	adc	r26, r1
    dd92:	62 1f       	adc	r22, r18
    dd94:	83 9f       	mul	r24, r19
    dd96:	a0 0d       	add	r26, r0
    dd98:	61 1d       	adc	r22, r1
    dd9a:	22 1f       	adc	r18, r18
    dd9c:	74 9f       	mul	r23, r20
    dd9e:	33 27       	eor	r19, r19
    dda0:	a0 0d       	add	r26, r0
    dda2:	61 1d       	adc	r22, r1
    dda4:	23 1f       	adc	r18, r19
    dda6:	84 9f       	mul	r24, r20
    dda8:	60 0d       	add	r22, r0
    ddaa:	21 1d       	adc	r18, r1
    ddac:	82 2f       	mov	r24, r18
    ddae:	76 2f       	mov	r23, r22
    ddb0:	6a 2f       	mov	r22, r26
    ddb2:	11 24       	eor	r1, r1
    ddb4:	9f 57       	subi	r25, 0x7F	; 127
    ddb6:	50 40       	sbci	r21, 0x00	; 0
    ddb8:	8a f0       	brmi	.+34     	; 0xdddc <__mulsf3_pse+0x84>
    ddba:	e1 f0       	breq	.+56     	; 0xddf4 <__mulsf3_pse+0x9c>
    ddbc:	88 23       	and	r24, r24
    ddbe:	4a f0       	brmi	.+18     	; 0xddd2 <__mulsf3_pse+0x7a>
    ddc0:	ee 0f       	add	r30, r30
    ddc2:	ff 1f       	adc	r31, r31
    ddc4:	bb 1f       	adc	r27, r27
    ddc6:	66 1f       	adc	r22, r22
    ddc8:	77 1f       	adc	r23, r23
    ddca:	88 1f       	adc	r24, r24
    ddcc:	91 50       	subi	r25, 0x01	; 1
    ddce:	50 40       	sbci	r21, 0x00	; 0
    ddd0:	a9 f7       	brne	.-22     	; 0xddbc <__mulsf3_pse+0x64>
    ddd2:	9e 3f       	cpi	r25, 0xFE	; 254
    ddd4:	51 05       	cpc	r21, r1
    ddd6:	70 f0       	brcs	.+28     	; 0xddf4 <__mulsf3_pse+0x9c>
    ddd8:	60 cf       	rjmp	.-320    	; 0xdc9a <__fp_inf>
    ddda:	aa cf       	rjmp	.-172    	; 0xdd30 <__fp_szero>
    dddc:	5f 3f       	cpi	r21, 0xFF	; 255
    ddde:	ec f3       	brlt	.-6      	; 0xddda <__mulsf3_pse+0x82>
    dde0:	98 3e       	cpi	r25, 0xE8	; 232
    dde2:	dc f3       	brlt	.-10     	; 0xddda <__mulsf3_pse+0x82>
    dde4:	86 95       	lsr	r24
    dde6:	77 95       	ror	r23
    dde8:	67 95       	ror	r22
    ddea:	b7 95       	ror	r27
    ddec:	f7 95       	ror	r31
    ddee:	e7 95       	ror	r30
    ddf0:	9f 5f       	subi	r25, 0xFF	; 255
    ddf2:	c1 f7       	brne	.-16     	; 0xdde4 <__mulsf3_pse+0x8c>
    ddf4:	fe 2b       	or	r31, r30
    ddf6:	88 0f       	add	r24, r24
    ddf8:	91 1d       	adc	r25, r1
    ddfa:	96 95       	lsr	r25
    ddfc:	87 95       	ror	r24
    ddfe:	97 f9       	bld	r25, 7
    de00:	08 95       	ret

0000de02 <vfprintf>:
    de02:	2f 92       	push	r2
    de04:	3f 92       	push	r3
    de06:	4f 92       	push	r4
    de08:	5f 92       	push	r5
    de0a:	6f 92       	push	r6
    de0c:	7f 92       	push	r7
    de0e:	8f 92       	push	r8
    de10:	9f 92       	push	r9
    de12:	af 92       	push	r10
    de14:	bf 92       	push	r11
    de16:	cf 92       	push	r12
    de18:	df 92       	push	r13
    de1a:	ef 92       	push	r14
    de1c:	ff 92       	push	r15
    de1e:	0f 93       	push	r16
    de20:	1f 93       	push	r17
    de22:	cf 93       	push	r28
    de24:	df 93       	push	r29
    de26:	cd b7       	in	r28, 0x3d	; 61
    de28:	de b7       	in	r29, 0x3e	; 62
    de2a:	2c 97       	sbiw	r28, 0x0c	; 12
    de2c:	0f b6       	in	r0, 0x3f	; 63
    de2e:	f8 94       	cli
    de30:	de bf       	out	0x3e, r29	; 62
    de32:	0f be       	out	0x3f, r0	; 63
    de34:	cd bf       	out	0x3d, r28	; 61
    de36:	7c 01       	movw	r14, r24
    de38:	6b 01       	movw	r12, r22
    de3a:	8a 01       	movw	r16, r20
    de3c:	fc 01       	movw	r30, r24
    de3e:	17 82       	std	Z+7, r1	; 0x07
    de40:	16 82       	std	Z+6, r1	; 0x06
    de42:	83 81       	ldd	r24, Z+3	; 0x03
    de44:	81 ff       	sbrs	r24, 1
    de46:	bd c1       	rjmp	.+890    	; 0xe1c2 <vfprintf+0x3c0>
    de48:	ce 01       	movw	r24, r28
    de4a:	01 96       	adiw	r24, 0x01	; 1
    de4c:	4c 01       	movw	r8, r24
    de4e:	f7 01       	movw	r30, r14
    de50:	93 81       	ldd	r25, Z+3	; 0x03
    de52:	f6 01       	movw	r30, r12
    de54:	93 fd       	sbrc	r25, 3
    de56:	85 91       	lpm	r24, Z+
    de58:	93 ff       	sbrs	r25, 3
    de5a:	81 91       	ld	r24, Z+
    de5c:	6f 01       	movw	r12, r30
    de5e:	88 23       	and	r24, r24
    de60:	09 f4       	brne	.+2      	; 0xde64 <vfprintf+0x62>
    de62:	ab c1       	rjmp	.+854    	; 0xe1ba <vfprintf+0x3b8>
    de64:	85 32       	cpi	r24, 0x25	; 37
    de66:	39 f4       	brne	.+14     	; 0xde76 <vfprintf+0x74>
    de68:	93 fd       	sbrc	r25, 3
    de6a:	85 91       	lpm	r24, Z+
    de6c:	93 ff       	sbrs	r25, 3
    de6e:	81 91       	ld	r24, Z+
    de70:	6f 01       	movw	r12, r30
    de72:	85 32       	cpi	r24, 0x25	; 37
    de74:	29 f4       	brne	.+10     	; 0xde80 <vfprintf+0x7e>
    de76:	b7 01       	movw	r22, r14
    de78:	90 e0       	ldi	r25, 0x00	; 0
    de7a:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    de7e:	e7 cf       	rjmp	.-50     	; 0xde4e <vfprintf+0x4c>
    de80:	51 2c       	mov	r5, r1
    de82:	31 2c       	mov	r3, r1
    de84:	20 e0       	ldi	r18, 0x00	; 0
    de86:	20 32       	cpi	r18, 0x20	; 32
    de88:	a0 f4       	brcc	.+40     	; 0xdeb2 <vfprintf+0xb0>
    de8a:	8b 32       	cpi	r24, 0x2B	; 43
    de8c:	69 f0       	breq	.+26     	; 0xdea8 <vfprintf+0xa6>
    de8e:	30 f4       	brcc	.+12     	; 0xde9c <vfprintf+0x9a>
    de90:	80 32       	cpi	r24, 0x20	; 32
    de92:	59 f0       	breq	.+22     	; 0xdeaa <vfprintf+0xa8>
    de94:	83 32       	cpi	r24, 0x23	; 35
    de96:	69 f4       	brne	.+26     	; 0xdeb2 <vfprintf+0xb0>
    de98:	20 61       	ori	r18, 0x10	; 16
    de9a:	2c c0       	rjmp	.+88     	; 0xdef4 <vfprintf+0xf2>
    de9c:	8d 32       	cpi	r24, 0x2D	; 45
    de9e:	39 f0       	breq	.+14     	; 0xdeae <vfprintf+0xac>
    dea0:	80 33       	cpi	r24, 0x30	; 48
    dea2:	39 f4       	brne	.+14     	; 0xdeb2 <vfprintf+0xb0>
    dea4:	21 60       	ori	r18, 0x01	; 1
    dea6:	26 c0       	rjmp	.+76     	; 0xdef4 <vfprintf+0xf2>
    dea8:	22 60       	ori	r18, 0x02	; 2
    deaa:	24 60       	ori	r18, 0x04	; 4
    deac:	23 c0       	rjmp	.+70     	; 0xdef4 <vfprintf+0xf2>
    deae:	28 60       	ori	r18, 0x08	; 8
    deb0:	21 c0       	rjmp	.+66     	; 0xdef4 <vfprintf+0xf2>
    deb2:	27 fd       	sbrc	r18, 7
    deb4:	27 c0       	rjmp	.+78     	; 0xdf04 <vfprintf+0x102>
    deb6:	30 ed       	ldi	r19, 0xD0	; 208
    deb8:	38 0f       	add	r19, r24
    deba:	3a 30       	cpi	r19, 0x0A	; 10
    debc:	78 f4       	brcc	.+30     	; 0xdedc <vfprintf+0xda>
    debe:	26 ff       	sbrs	r18, 6
    dec0:	06 c0       	rjmp	.+12     	; 0xdece <vfprintf+0xcc>
    dec2:	fa e0       	ldi	r31, 0x0A	; 10
    dec4:	5f 9e       	mul	r5, r31
    dec6:	30 0d       	add	r19, r0
    dec8:	11 24       	eor	r1, r1
    deca:	53 2e       	mov	r5, r19
    decc:	13 c0       	rjmp	.+38     	; 0xdef4 <vfprintf+0xf2>
    dece:	8a e0       	ldi	r24, 0x0A	; 10
    ded0:	38 9e       	mul	r3, r24
    ded2:	30 0d       	add	r19, r0
    ded4:	11 24       	eor	r1, r1
    ded6:	33 2e       	mov	r3, r19
    ded8:	20 62       	ori	r18, 0x20	; 32
    deda:	0c c0       	rjmp	.+24     	; 0xdef4 <vfprintf+0xf2>
    dedc:	8e 32       	cpi	r24, 0x2E	; 46
    dede:	21 f4       	brne	.+8      	; 0xdee8 <vfprintf+0xe6>
    dee0:	26 fd       	sbrc	r18, 6
    dee2:	6b c1       	rjmp	.+726    	; 0xe1ba <vfprintf+0x3b8>
    dee4:	20 64       	ori	r18, 0x40	; 64
    dee6:	06 c0       	rjmp	.+12     	; 0xdef4 <vfprintf+0xf2>
    dee8:	8c 36       	cpi	r24, 0x6C	; 108
    deea:	11 f4       	brne	.+4      	; 0xdef0 <vfprintf+0xee>
    deec:	20 68       	ori	r18, 0x80	; 128
    deee:	02 c0       	rjmp	.+4      	; 0xdef4 <vfprintf+0xf2>
    def0:	88 36       	cpi	r24, 0x68	; 104
    def2:	41 f4       	brne	.+16     	; 0xdf04 <vfprintf+0x102>
    def4:	f6 01       	movw	r30, r12
    def6:	93 fd       	sbrc	r25, 3
    def8:	85 91       	lpm	r24, Z+
    defa:	93 ff       	sbrs	r25, 3
    defc:	81 91       	ld	r24, Z+
    defe:	6f 01       	movw	r12, r30
    df00:	81 11       	cpse	r24, r1
    df02:	c1 cf       	rjmp	.-126    	; 0xde86 <vfprintf+0x84>
    df04:	98 2f       	mov	r25, r24
    df06:	9f 7d       	andi	r25, 0xDF	; 223
    df08:	95 54       	subi	r25, 0x45	; 69
    df0a:	93 30       	cpi	r25, 0x03	; 3
    df0c:	28 f4       	brcc	.+10     	; 0xdf18 <vfprintf+0x116>
    df0e:	0c 5f       	subi	r16, 0xFC	; 252
    df10:	1f 4f       	sbci	r17, 0xFF	; 255
    df12:	ff e3       	ldi	r31, 0x3F	; 63
    df14:	f9 83       	std	Y+1, r31	; 0x01
    df16:	0d c0       	rjmp	.+26     	; 0xdf32 <vfprintf+0x130>
    df18:	83 36       	cpi	r24, 0x63	; 99
    df1a:	31 f0       	breq	.+12     	; 0xdf28 <vfprintf+0x126>
    df1c:	83 37       	cpi	r24, 0x73	; 115
    df1e:	71 f0       	breq	.+28     	; 0xdf3c <vfprintf+0x13a>
    df20:	83 35       	cpi	r24, 0x53	; 83
    df22:	09 f0       	breq	.+2      	; 0xdf26 <vfprintf+0x124>
    df24:	5b c0       	rjmp	.+182    	; 0xdfdc <vfprintf+0x1da>
    df26:	22 c0       	rjmp	.+68     	; 0xdf6c <vfprintf+0x16a>
    df28:	f8 01       	movw	r30, r16
    df2a:	80 81       	ld	r24, Z
    df2c:	89 83       	std	Y+1, r24	; 0x01
    df2e:	0e 5f       	subi	r16, 0xFE	; 254
    df30:	1f 4f       	sbci	r17, 0xFF	; 255
    df32:	44 24       	eor	r4, r4
    df34:	43 94       	inc	r4
    df36:	51 2c       	mov	r5, r1
    df38:	54 01       	movw	r10, r8
    df3a:	15 c0       	rjmp	.+42     	; 0xdf66 <vfprintf+0x164>
    df3c:	38 01       	movw	r6, r16
    df3e:	f2 e0       	ldi	r31, 0x02	; 2
    df40:	6f 0e       	add	r6, r31
    df42:	71 1c       	adc	r7, r1
    df44:	f8 01       	movw	r30, r16
    df46:	a0 80       	ld	r10, Z
    df48:	b1 80       	ldd	r11, Z+1	; 0x01
    df4a:	26 ff       	sbrs	r18, 6
    df4c:	03 c0       	rjmp	.+6      	; 0xdf54 <vfprintf+0x152>
    df4e:	65 2d       	mov	r22, r5
    df50:	70 e0       	ldi	r23, 0x00	; 0
    df52:	02 c0       	rjmp	.+4      	; 0xdf58 <vfprintf+0x156>
    df54:	6f ef       	ldi	r22, 0xFF	; 255
    df56:	7f ef       	ldi	r23, 0xFF	; 255
    df58:	c5 01       	movw	r24, r10
    df5a:	2c 87       	std	Y+12, r18	; 0x0c
    df5c:	0e 94 2b 74 	call	0xe856	; 0xe856 <strnlen>
    df60:	2c 01       	movw	r4, r24
    df62:	83 01       	movw	r16, r6
    df64:	2c 85       	ldd	r18, Y+12	; 0x0c
    df66:	2f 77       	andi	r18, 0x7F	; 127
    df68:	22 2e       	mov	r2, r18
    df6a:	17 c0       	rjmp	.+46     	; 0xdf9a <vfprintf+0x198>
    df6c:	38 01       	movw	r6, r16
    df6e:	f2 e0       	ldi	r31, 0x02	; 2
    df70:	6f 0e       	add	r6, r31
    df72:	71 1c       	adc	r7, r1
    df74:	f8 01       	movw	r30, r16
    df76:	a0 80       	ld	r10, Z
    df78:	b1 80       	ldd	r11, Z+1	; 0x01
    df7a:	26 ff       	sbrs	r18, 6
    df7c:	03 c0       	rjmp	.+6      	; 0xdf84 <vfprintf+0x182>
    df7e:	65 2d       	mov	r22, r5
    df80:	70 e0       	ldi	r23, 0x00	; 0
    df82:	02 c0       	rjmp	.+4      	; 0xdf88 <vfprintf+0x186>
    df84:	6f ef       	ldi	r22, 0xFF	; 255
    df86:	7f ef       	ldi	r23, 0xFF	; 255
    df88:	c5 01       	movw	r24, r10
    df8a:	2c 87       	std	Y+12, r18	; 0x0c
    df8c:	0e 94 20 74 	call	0xe840	; 0xe840 <strnlen_P>
    df90:	2c 01       	movw	r4, r24
    df92:	2c 85       	ldd	r18, Y+12	; 0x0c
    df94:	20 68       	ori	r18, 0x80	; 128
    df96:	22 2e       	mov	r2, r18
    df98:	83 01       	movw	r16, r6
    df9a:	23 fc       	sbrc	r2, 3
    df9c:	1b c0       	rjmp	.+54     	; 0xdfd4 <vfprintf+0x1d2>
    df9e:	83 2d       	mov	r24, r3
    dfa0:	90 e0       	ldi	r25, 0x00	; 0
    dfa2:	48 16       	cp	r4, r24
    dfa4:	59 06       	cpc	r5, r25
    dfa6:	b0 f4       	brcc	.+44     	; 0xdfd4 <vfprintf+0x1d2>
    dfa8:	b7 01       	movw	r22, r14
    dfaa:	80 e2       	ldi	r24, 0x20	; 32
    dfac:	90 e0       	ldi	r25, 0x00	; 0
    dfae:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    dfb2:	3a 94       	dec	r3
    dfb4:	f4 cf       	rjmp	.-24     	; 0xdf9e <vfprintf+0x19c>
    dfb6:	f5 01       	movw	r30, r10
    dfb8:	27 fc       	sbrc	r2, 7
    dfba:	85 91       	lpm	r24, Z+
    dfbc:	27 fe       	sbrs	r2, 7
    dfbe:	81 91       	ld	r24, Z+
    dfc0:	5f 01       	movw	r10, r30
    dfc2:	b7 01       	movw	r22, r14
    dfc4:	90 e0       	ldi	r25, 0x00	; 0
    dfc6:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    dfca:	31 10       	cpse	r3, r1
    dfcc:	3a 94       	dec	r3
    dfce:	f1 e0       	ldi	r31, 0x01	; 1
    dfd0:	4f 1a       	sub	r4, r31
    dfd2:	51 08       	sbc	r5, r1
    dfd4:	41 14       	cp	r4, r1
    dfd6:	51 04       	cpc	r5, r1
    dfd8:	71 f7       	brne	.-36     	; 0xdfb6 <vfprintf+0x1b4>
    dfda:	e5 c0       	rjmp	.+458    	; 0xe1a6 <vfprintf+0x3a4>
    dfdc:	84 36       	cpi	r24, 0x64	; 100
    dfde:	11 f0       	breq	.+4      	; 0xdfe4 <vfprintf+0x1e2>
    dfe0:	89 36       	cpi	r24, 0x69	; 105
    dfe2:	39 f5       	brne	.+78     	; 0xe032 <vfprintf+0x230>
    dfe4:	f8 01       	movw	r30, r16
    dfe6:	27 ff       	sbrs	r18, 7
    dfe8:	07 c0       	rjmp	.+14     	; 0xdff8 <vfprintf+0x1f6>
    dfea:	60 81       	ld	r22, Z
    dfec:	71 81       	ldd	r23, Z+1	; 0x01
    dfee:	82 81       	ldd	r24, Z+2	; 0x02
    dff0:	93 81       	ldd	r25, Z+3	; 0x03
    dff2:	0c 5f       	subi	r16, 0xFC	; 252
    dff4:	1f 4f       	sbci	r17, 0xFF	; 255
    dff6:	08 c0       	rjmp	.+16     	; 0xe008 <vfprintf+0x206>
    dff8:	60 81       	ld	r22, Z
    dffa:	71 81       	ldd	r23, Z+1	; 0x01
    dffc:	88 27       	eor	r24, r24
    dffe:	77 fd       	sbrc	r23, 7
    e000:	80 95       	com	r24
    e002:	98 2f       	mov	r25, r24
    e004:	0e 5f       	subi	r16, 0xFE	; 254
    e006:	1f 4f       	sbci	r17, 0xFF	; 255
    e008:	2f 76       	andi	r18, 0x6F	; 111
    e00a:	b2 2e       	mov	r11, r18
    e00c:	97 ff       	sbrs	r25, 7
    e00e:	09 c0       	rjmp	.+18     	; 0xe022 <vfprintf+0x220>
    e010:	90 95       	com	r25
    e012:	80 95       	com	r24
    e014:	70 95       	com	r23
    e016:	61 95       	neg	r22
    e018:	7f 4f       	sbci	r23, 0xFF	; 255
    e01a:	8f 4f       	sbci	r24, 0xFF	; 255
    e01c:	9f 4f       	sbci	r25, 0xFF	; 255
    e01e:	20 68       	ori	r18, 0x80	; 128
    e020:	b2 2e       	mov	r11, r18
    e022:	2a e0       	ldi	r18, 0x0A	; 10
    e024:	30 e0       	ldi	r19, 0x00	; 0
    e026:	a4 01       	movw	r20, r8
    e028:	0e 94 bf 74 	call	0xe97e	; 0xe97e <__ultoa_invert>
    e02c:	a8 2e       	mov	r10, r24
    e02e:	a8 18       	sub	r10, r8
    e030:	44 c0       	rjmp	.+136    	; 0xe0ba <vfprintf+0x2b8>
    e032:	85 37       	cpi	r24, 0x75	; 117
    e034:	29 f4       	brne	.+10     	; 0xe040 <vfprintf+0x23e>
    e036:	2f 7e       	andi	r18, 0xEF	; 239
    e038:	b2 2e       	mov	r11, r18
    e03a:	2a e0       	ldi	r18, 0x0A	; 10
    e03c:	30 e0       	ldi	r19, 0x00	; 0
    e03e:	25 c0       	rjmp	.+74     	; 0xe08a <vfprintf+0x288>
    e040:	f2 2f       	mov	r31, r18
    e042:	f9 7f       	andi	r31, 0xF9	; 249
    e044:	bf 2e       	mov	r11, r31
    e046:	8f 36       	cpi	r24, 0x6F	; 111
    e048:	c1 f0       	breq	.+48     	; 0xe07a <vfprintf+0x278>
    e04a:	18 f4       	brcc	.+6      	; 0xe052 <vfprintf+0x250>
    e04c:	88 35       	cpi	r24, 0x58	; 88
    e04e:	79 f0       	breq	.+30     	; 0xe06e <vfprintf+0x26c>
    e050:	b4 c0       	rjmp	.+360    	; 0xe1ba <vfprintf+0x3b8>
    e052:	80 37       	cpi	r24, 0x70	; 112
    e054:	19 f0       	breq	.+6      	; 0xe05c <vfprintf+0x25a>
    e056:	88 37       	cpi	r24, 0x78	; 120
    e058:	21 f0       	breq	.+8      	; 0xe062 <vfprintf+0x260>
    e05a:	af c0       	rjmp	.+350    	; 0xe1ba <vfprintf+0x3b8>
    e05c:	2f 2f       	mov	r18, r31
    e05e:	20 61       	ori	r18, 0x10	; 16
    e060:	b2 2e       	mov	r11, r18
    e062:	b4 fe       	sbrs	r11, 4
    e064:	0d c0       	rjmp	.+26     	; 0xe080 <vfprintf+0x27e>
    e066:	8b 2d       	mov	r24, r11
    e068:	84 60       	ori	r24, 0x04	; 4
    e06a:	b8 2e       	mov	r11, r24
    e06c:	09 c0       	rjmp	.+18     	; 0xe080 <vfprintf+0x27e>
    e06e:	24 ff       	sbrs	r18, 4
    e070:	0a c0       	rjmp	.+20     	; 0xe086 <vfprintf+0x284>
    e072:	9f 2f       	mov	r25, r31
    e074:	96 60       	ori	r25, 0x06	; 6
    e076:	b9 2e       	mov	r11, r25
    e078:	06 c0       	rjmp	.+12     	; 0xe086 <vfprintf+0x284>
    e07a:	28 e0       	ldi	r18, 0x08	; 8
    e07c:	30 e0       	ldi	r19, 0x00	; 0
    e07e:	05 c0       	rjmp	.+10     	; 0xe08a <vfprintf+0x288>
    e080:	20 e1       	ldi	r18, 0x10	; 16
    e082:	30 e0       	ldi	r19, 0x00	; 0
    e084:	02 c0       	rjmp	.+4      	; 0xe08a <vfprintf+0x288>
    e086:	20 e1       	ldi	r18, 0x10	; 16
    e088:	32 e0       	ldi	r19, 0x02	; 2
    e08a:	f8 01       	movw	r30, r16
    e08c:	b7 fe       	sbrs	r11, 7
    e08e:	07 c0       	rjmp	.+14     	; 0xe09e <vfprintf+0x29c>
    e090:	60 81       	ld	r22, Z
    e092:	71 81       	ldd	r23, Z+1	; 0x01
    e094:	82 81       	ldd	r24, Z+2	; 0x02
    e096:	93 81       	ldd	r25, Z+3	; 0x03
    e098:	0c 5f       	subi	r16, 0xFC	; 252
    e09a:	1f 4f       	sbci	r17, 0xFF	; 255
    e09c:	06 c0       	rjmp	.+12     	; 0xe0aa <vfprintf+0x2a8>
    e09e:	60 81       	ld	r22, Z
    e0a0:	71 81       	ldd	r23, Z+1	; 0x01
    e0a2:	80 e0       	ldi	r24, 0x00	; 0
    e0a4:	90 e0       	ldi	r25, 0x00	; 0
    e0a6:	0e 5f       	subi	r16, 0xFE	; 254
    e0a8:	1f 4f       	sbci	r17, 0xFF	; 255
    e0aa:	a4 01       	movw	r20, r8
    e0ac:	0e 94 bf 74 	call	0xe97e	; 0xe97e <__ultoa_invert>
    e0b0:	a8 2e       	mov	r10, r24
    e0b2:	a8 18       	sub	r10, r8
    e0b4:	fb 2d       	mov	r31, r11
    e0b6:	ff 77       	andi	r31, 0x7F	; 127
    e0b8:	bf 2e       	mov	r11, r31
    e0ba:	b6 fe       	sbrs	r11, 6
    e0bc:	0b c0       	rjmp	.+22     	; 0xe0d4 <vfprintf+0x2d2>
    e0be:	2b 2d       	mov	r18, r11
    e0c0:	2e 7f       	andi	r18, 0xFE	; 254
    e0c2:	a5 14       	cp	r10, r5
    e0c4:	50 f4       	brcc	.+20     	; 0xe0da <vfprintf+0x2d8>
    e0c6:	b4 fe       	sbrs	r11, 4
    e0c8:	0a c0       	rjmp	.+20     	; 0xe0de <vfprintf+0x2dc>
    e0ca:	b2 fc       	sbrc	r11, 2
    e0cc:	08 c0       	rjmp	.+16     	; 0xe0de <vfprintf+0x2dc>
    e0ce:	2b 2d       	mov	r18, r11
    e0d0:	2e 7e       	andi	r18, 0xEE	; 238
    e0d2:	05 c0       	rjmp	.+10     	; 0xe0de <vfprintf+0x2dc>
    e0d4:	7a 2c       	mov	r7, r10
    e0d6:	2b 2d       	mov	r18, r11
    e0d8:	03 c0       	rjmp	.+6      	; 0xe0e0 <vfprintf+0x2de>
    e0da:	7a 2c       	mov	r7, r10
    e0dc:	01 c0       	rjmp	.+2      	; 0xe0e0 <vfprintf+0x2de>
    e0de:	75 2c       	mov	r7, r5
    e0e0:	24 ff       	sbrs	r18, 4
    e0e2:	0d c0       	rjmp	.+26     	; 0xe0fe <vfprintf+0x2fc>
    e0e4:	fe 01       	movw	r30, r28
    e0e6:	ea 0d       	add	r30, r10
    e0e8:	f1 1d       	adc	r31, r1
    e0ea:	80 81       	ld	r24, Z
    e0ec:	80 33       	cpi	r24, 0x30	; 48
    e0ee:	11 f4       	brne	.+4      	; 0xe0f4 <vfprintf+0x2f2>
    e0f0:	29 7e       	andi	r18, 0xE9	; 233
    e0f2:	09 c0       	rjmp	.+18     	; 0xe106 <vfprintf+0x304>
    e0f4:	22 ff       	sbrs	r18, 2
    e0f6:	06 c0       	rjmp	.+12     	; 0xe104 <vfprintf+0x302>
    e0f8:	73 94       	inc	r7
    e0fa:	73 94       	inc	r7
    e0fc:	04 c0       	rjmp	.+8      	; 0xe106 <vfprintf+0x304>
    e0fe:	82 2f       	mov	r24, r18
    e100:	86 78       	andi	r24, 0x86	; 134
    e102:	09 f0       	breq	.+2      	; 0xe106 <vfprintf+0x304>
    e104:	73 94       	inc	r7
    e106:	23 fd       	sbrc	r18, 3
    e108:	13 c0       	rjmp	.+38     	; 0xe130 <vfprintf+0x32e>
    e10a:	20 ff       	sbrs	r18, 0
    e10c:	06 c0       	rjmp	.+12     	; 0xe11a <vfprintf+0x318>
    e10e:	5a 2c       	mov	r5, r10
    e110:	73 14       	cp	r7, r3
    e112:	18 f4       	brcc	.+6      	; 0xe11a <vfprintf+0x318>
    e114:	53 0c       	add	r5, r3
    e116:	57 18       	sub	r5, r7
    e118:	73 2c       	mov	r7, r3
    e11a:	73 14       	cp	r7, r3
    e11c:	68 f4       	brcc	.+26     	; 0xe138 <vfprintf+0x336>
    e11e:	b7 01       	movw	r22, r14
    e120:	80 e2       	ldi	r24, 0x20	; 32
    e122:	90 e0       	ldi	r25, 0x00	; 0
    e124:	2c 87       	std	Y+12, r18	; 0x0c
    e126:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e12a:	73 94       	inc	r7
    e12c:	2c 85       	ldd	r18, Y+12	; 0x0c
    e12e:	f5 cf       	rjmp	.-22     	; 0xe11a <vfprintf+0x318>
    e130:	73 14       	cp	r7, r3
    e132:	10 f4       	brcc	.+4      	; 0xe138 <vfprintf+0x336>
    e134:	37 18       	sub	r3, r7
    e136:	01 c0       	rjmp	.+2      	; 0xe13a <vfprintf+0x338>
    e138:	31 2c       	mov	r3, r1
    e13a:	24 ff       	sbrs	r18, 4
    e13c:	12 c0       	rjmp	.+36     	; 0xe162 <vfprintf+0x360>
    e13e:	b7 01       	movw	r22, r14
    e140:	80 e3       	ldi	r24, 0x30	; 48
    e142:	90 e0       	ldi	r25, 0x00	; 0
    e144:	2c 87       	std	Y+12, r18	; 0x0c
    e146:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e14a:	2c 85       	ldd	r18, Y+12	; 0x0c
    e14c:	22 ff       	sbrs	r18, 2
    e14e:	17 c0       	rjmp	.+46     	; 0xe17e <vfprintf+0x37c>
    e150:	21 ff       	sbrs	r18, 1
    e152:	03 c0       	rjmp	.+6      	; 0xe15a <vfprintf+0x358>
    e154:	88 e5       	ldi	r24, 0x58	; 88
    e156:	90 e0       	ldi	r25, 0x00	; 0
    e158:	02 c0       	rjmp	.+4      	; 0xe15e <vfprintf+0x35c>
    e15a:	88 e7       	ldi	r24, 0x78	; 120
    e15c:	90 e0       	ldi	r25, 0x00	; 0
    e15e:	b7 01       	movw	r22, r14
    e160:	0c c0       	rjmp	.+24     	; 0xe17a <vfprintf+0x378>
    e162:	82 2f       	mov	r24, r18
    e164:	86 78       	andi	r24, 0x86	; 134
    e166:	59 f0       	breq	.+22     	; 0xe17e <vfprintf+0x37c>
    e168:	21 fd       	sbrc	r18, 1
    e16a:	02 c0       	rjmp	.+4      	; 0xe170 <vfprintf+0x36e>
    e16c:	80 e2       	ldi	r24, 0x20	; 32
    e16e:	01 c0       	rjmp	.+2      	; 0xe172 <vfprintf+0x370>
    e170:	8b e2       	ldi	r24, 0x2B	; 43
    e172:	27 fd       	sbrc	r18, 7
    e174:	8d e2       	ldi	r24, 0x2D	; 45
    e176:	b7 01       	movw	r22, r14
    e178:	90 e0       	ldi	r25, 0x00	; 0
    e17a:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e17e:	a5 14       	cp	r10, r5
    e180:	38 f4       	brcc	.+14     	; 0xe190 <vfprintf+0x38e>
    e182:	b7 01       	movw	r22, r14
    e184:	80 e3       	ldi	r24, 0x30	; 48
    e186:	90 e0       	ldi	r25, 0x00	; 0
    e188:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e18c:	5a 94       	dec	r5
    e18e:	f7 cf       	rjmp	.-18     	; 0xe17e <vfprintf+0x37c>
    e190:	aa 94       	dec	r10
    e192:	f4 01       	movw	r30, r8
    e194:	ea 0d       	add	r30, r10
    e196:	f1 1d       	adc	r31, r1
    e198:	80 81       	ld	r24, Z
    e19a:	b7 01       	movw	r22, r14
    e19c:	90 e0       	ldi	r25, 0x00	; 0
    e19e:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e1a2:	a1 10       	cpse	r10, r1
    e1a4:	f5 cf       	rjmp	.-22     	; 0xe190 <vfprintf+0x38e>
    e1a6:	33 20       	and	r3, r3
    e1a8:	09 f4       	brne	.+2      	; 0xe1ac <vfprintf+0x3aa>
    e1aa:	51 ce       	rjmp	.-862    	; 0xde4e <vfprintf+0x4c>
    e1ac:	b7 01       	movw	r22, r14
    e1ae:	80 e2       	ldi	r24, 0x20	; 32
    e1b0:	90 e0       	ldi	r25, 0x00	; 0
    e1b2:	0e 94 74 74 	call	0xe8e8	; 0xe8e8 <fputc>
    e1b6:	3a 94       	dec	r3
    e1b8:	f6 cf       	rjmp	.-20     	; 0xe1a6 <vfprintf+0x3a4>
    e1ba:	f7 01       	movw	r30, r14
    e1bc:	86 81       	ldd	r24, Z+6	; 0x06
    e1be:	97 81       	ldd	r25, Z+7	; 0x07
    e1c0:	02 c0       	rjmp	.+4      	; 0xe1c6 <vfprintf+0x3c4>
    e1c2:	8f ef       	ldi	r24, 0xFF	; 255
    e1c4:	9f ef       	ldi	r25, 0xFF	; 255
    e1c6:	2c 96       	adiw	r28, 0x0c	; 12
    e1c8:	0f b6       	in	r0, 0x3f	; 63
    e1ca:	f8 94       	cli
    e1cc:	de bf       	out	0x3e, r29	; 62
    e1ce:	0f be       	out	0x3f, r0	; 63
    e1d0:	cd bf       	out	0x3d, r28	; 61
    e1d2:	df 91       	pop	r29
    e1d4:	cf 91       	pop	r28
    e1d6:	1f 91       	pop	r17
    e1d8:	0f 91       	pop	r16
    e1da:	ff 90       	pop	r15
    e1dc:	ef 90       	pop	r14
    e1de:	df 90       	pop	r13
    e1e0:	cf 90       	pop	r12
    e1e2:	bf 90       	pop	r11
    e1e4:	af 90       	pop	r10
    e1e6:	9f 90       	pop	r9
    e1e8:	8f 90       	pop	r8
    e1ea:	7f 90       	pop	r7
    e1ec:	6f 90       	pop	r6
    e1ee:	5f 90       	pop	r5
    e1f0:	4f 90       	pop	r4
    e1f2:	3f 90       	pop	r3
    e1f4:	2f 90       	pop	r2
    e1f6:	08 95       	ret

0000e1f8 <putval>:
    e1f8:	20 fd       	sbrc	r18, 0
    e1fa:	09 c0       	rjmp	.+18     	; 0xe20e <putval+0x16>
    e1fc:	fc 01       	movw	r30, r24
    e1fe:	23 fd       	sbrc	r18, 3
    e200:	05 c0       	rjmp	.+10     	; 0xe20c <putval+0x14>
    e202:	22 ff       	sbrs	r18, 2
    e204:	02 c0       	rjmp	.+4      	; 0xe20a <putval+0x12>
    e206:	73 83       	std	Z+3, r23	; 0x03
    e208:	62 83       	std	Z+2, r22	; 0x02
    e20a:	51 83       	std	Z+1, r21	; 0x01
    e20c:	40 83       	st	Z, r20
    e20e:	08 95       	ret

0000e210 <mulacc>:
    e210:	44 fd       	sbrc	r20, 4
    e212:	10 c0       	rjmp	.+32     	; 0xe234 <mulacc+0x24>
    e214:	46 fd       	sbrc	r20, 6
    e216:	10 c0       	rjmp	.+32     	; 0xe238 <mulacc+0x28>
    e218:	db 01       	movw	r26, r22
    e21a:	fc 01       	movw	r30, r24
    e21c:	aa 0f       	add	r26, r26
    e21e:	bb 1f       	adc	r27, r27
    e220:	ee 1f       	adc	r30, r30
    e222:	ff 1f       	adc	r31, r31
    e224:	10 94       	com	r1
    e226:	d1 f7       	brne	.-12     	; 0xe21c <mulacc+0xc>
    e228:	6a 0f       	add	r22, r26
    e22a:	7b 1f       	adc	r23, r27
    e22c:	8e 1f       	adc	r24, r30
    e22e:	9f 1f       	adc	r25, r31
    e230:	31 e0       	ldi	r19, 0x01	; 1
    e232:	03 c0       	rjmp	.+6      	; 0xe23a <mulacc+0x2a>
    e234:	33 e0       	ldi	r19, 0x03	; 3
    e236:	01 c0       	rjmp	.+2      	; 0xe23a <mulacc+0x2a>
    e238:	34 e0       	ldi	r19, 0x04	; 4
    e23a:	66 0f       	add	r22, r22
    e23c:	77 1f       	adc	r23, r23
    e23e:	88 1f       	adc	r24, r24
    e240:	99 1f       	adc	r25, r25
    e242:	31 50       	subi	r19, 0x01	; 1
    e244:	d1 f7       	brne	.-12     	; 0xe23a <mulacc+0x2a>
    e246:	62 0f       	add	r22, r18
    e248:	71 1d       	adc	r23, r1
    e24a:	81 1d       	adc	r24, r1
    e24c:	91 1d       	adc	r25, r1
    e24e:	08 95       	ret

0000e250 <skip_spaces>:
    e250:	0f 93       	push	r16
    e252:	1f 93       	push	r17
    e254:	cf 93       	push	r28
    e256:	df 93       	push	r29
    e258:	8c 01       	movw	r16, r24
    e25a:	c8 01       	movw	r24, r16
    e25c:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e260:	ec 01       	movw	r28, r24
    e262:	97 fd       	sbrc	r25, 7
    e264:	08 c0       	rjmp	.+16     	; 0xe276 <skip_spaces+0x26>
    e266:	0e 94 18 74 	call	0xe830	; 0xe830 <isspace>
    e26a:	89 2b       	or	r24, r25
    e26c:	b1 f7       	brne	.-20     	; 0xe25a <skip_spaces+0xa>
    e26e:	b8 01       	movw	r22, r16
    e270:	ce 01       	movw	r24, r28
    e272:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ungetc>
    e276:	ce 01       	movw	r24, r28
    e278:	df 91       	pop	r29
    e27a:	cf 91       	pop	r28
    e27c:	1f 91       	pop	r17
    e27e:	0f 91       	pop	r16
    e280:	08 95       	ret

0000e282 <conv_int>:
    e282:	8f 92       	push	r8
    e284:	9f 92       	push	r9
    e286:	af 92       	push	r10
    e288:	cf 92       	push	r12
    e28a:	df 92       	push	r13
    e28c:	ef 92       	push	r14
    e28e:	ff 92       	push	r15
    e290:	0f 93       	push	r16
    e292:	1f 93       	push	r17
    e294:	cf 93       	push	r28
    e296:	df 93       	push	r29
    e298:	ec 01       	movw	r28, r24
    e29a:	a6 2e       	mov	r10, r22
    e29c:	4a 01       	movw	r8, r20
    e29e:	02 2f       	mov	r16, r18
    e2a0:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e2a4:	ac 01       	movw	r20, r24
    e2a6:	55 27       	eor	r21, r21
    e2a8:	4b 32       	cpi	r20, 0x2B	; 43
    e2aa:	51 05       	cpc	r21, r1
    e2ac:	21 f0       	breq	.+8      	; 0xe2b6 <conv_int+0x34>
    e2ae:	4d 32       	cpi	r20, 0x2D	; 45
    e2b0:	51 05       	cpc	r21, r1
    e2b2:	51 f4       	brne	.+20     	; 0xe2c8 <conv_int+0x46>
    e2b4:	00 68       	ori	r16, 0x80	; 128
    e2b6:	aa 94       	dec	r10
    e2b8:	11 f4       	brne	.+4      	; 0xe2be <conv_int+0x3c>
    e2ba:	80 e0       	ldi	r24, 0x00	; 0
    e2bc:	67 c0       	rjmp	.+206    	; 0xe38c <conv_int+0x10a>
    e2be:	ce 01       	movw	r24, r28
    e2c0:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e2c4:	97 fd       	sbrc	r25, 7
    e2c6:	f9 cf       	rjmp	.-14     	; 0xe2ba <conv_int+0x38>
    e2c8:	10 2f       	mov	r17, r16
    e2ca:	1d 7f       	andi	r17, 0xFD	; 253
    e2cc:	30 2f       	mov	r19, r16
    e2ce:	30 73       	andi	r19, 0x30	; 48
    e2d0:	01 f5       	brne	.+64     	; 0xe312 <conv_int+0x90>
    e2d2:	80 33       	cpi	r24, 0x30	; 48
    e2d4:	f1 f4       	brne	.+60     	; 0xe312 <conv_int+0x90>
    e2d6:	ff 24       	eor	r15, r15
    e2d8:	fa 94       	dec	r15
    e2da:	fa 0c       	add	r15, r10
    e2dc:	09 f4       	brne	.+2      	; 0xe2e0 <conv_int+0x5e>
    e2de:	42 c0       	rjmp	.+132    	; 0xe364 <conv_int+0xe2>
    e2e0:	ce 01       	movw	r24, r28
    e2e2:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e2e6:	97 fd       	sbrc	r25, 7
    e2e8:	3d c0       	rjmp	.+122    	; 0xe364 <conv_int+0xe2>
    e2ea:	38 2f       	mov	r19, r24
    e2ec:	3f 7d       	andi	r19, 0xDF	; 223
    e2ee:	38 35       	cpi	r19, 0x58	; 88
    e2f0:	51 f4       	brne	.+20     	; 0xe306 <conv_int+0x84>
    e2f2:	12 64       	ori	r17, 0x42	; 66
    e2f4:	aa 94       	dec	r10
    e2f6:	aa 94       	dec	r10
    e2f8:	a9 f1       	breq	.+106    	; 0xe364 <conv_int+0xe2>
    e2fa:	ce 01       	movw	r24, r28
    e2fc:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e300:	97 ff       	sbrs	r25, 7
    e302:	07 c0       	rjmp	.+14     	; 0xe312 <conv_int+0x90>
    e304:	2f c0       	rjmp	.+94     	; 0xe364 <conv_int+0xe2>
    e306:	06 ff       	sbrs	r16, 6
    e308:	02 c0       	rjmp	.+4      	; 0xe30e <conv_int+0x8c>
    e30a:	12 60       	ori	r17, 0x02	; 2
    e30c:	01 c0       	rjmp	.+2      	; 0xe310 <conv_int+0x8e>
    e30e:	12 61       	ori	r17, 0x12	; 18
    e310:	af 2c       	mov	r10, r15
    e312:	c1 2c       	mov	r12, r1
    e314:	d1 2c       	mov	r13, r1
    e316:	76 01       	movw	r14, r12
    e318:	20 ed       	ldi	r18, 0xD0	; 208
    e31a:	28 0f       	add	r18, r24
    e31c:	28 30       	cpi	r18, 0x08	; 8
    e31e:	80 f0       	brcs	.+32     	; 0xe340 <conv_int+0xbe>
    e320:	14 ff       	sbrs	r17, 4
    e322:	04 c0       	rjmp	.+8      	; 0xe32c <conv_int+0xaa>
    e324:	be 01       	movw	r22, r28
    e326:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ungetc>
    e32a:	19 c0       	rjmp	.+50     	; 0xe35e <conv_int+0xdc>
    e32c:	2a 30       	cpi	r18, 0x0A	; 10
    e32e:	40 f0       	brcs	.+16     	; 0xe340 <conv_int+0xbe>
    e330:	16 ff       	sbrs	r17, 6
    e332:	f8 cf       	rjmp	.-16     	; 0xe324 <conv_int+0xa2>
    e334:	2f 7d       	andi	r18, 0xDF	; 223
    e336:	3f ee       	ldi	r19, 0xEF	; 239
    e338:	32 0f       	add	r19, r18
    e33a:	36 30       	cpi	r19, 0x06	; 6
    e33c:	98 f7       	brcc	.-26     	; 0xe324 <conv_int+0xa2>
    e33e:	27 50       	subi	r18, 0x07	; 7
    e340:	41 2f       	mov	r20, r17
    e342:	c7 01       	movw	r24, r14
    e344:	b6 01       	movw	r22, r12
    e346:	0e 94 08 71 	call	0xe210	; 0xe210 <mulacc>
    e34a:	6b 01       	movw	r12, r22
    e34c:	7c 01       	movw	r14, r24
    e34e:	12 60       	ori	r17, 0x02	; 2
    e350:	aa 94       	dec	r10
    e352:	59 f0       	breq	.+22     	; 0xe36a <conv_int+0xe8>
    e354:	ce 01       	movw	r24, r28
    e356:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e35a:	97 ff       	sbrs	r25, 7
    e35c:	dd cf       	rjmp	.-70     	; 0xe318 <conv_int+0x96>
    e35e:	11 fd       	sbrc	r17, 1
    e360:	04 c0       	rjmp	.+8      	; 0xe36a <conv_int+0xe8>
    e362:	ab cf       	rjmp	.-170    	; 0xe2ba <conv_int+0x38>
    e364:	c1 2c       	mov	r12, r1
    e366:	d1 2c       	mov	r13, r1
    e368:	76 01       	movw	r14, r12
    e36a:	17 ff       	sbrs	r17, 7
    e36c:	08 c0       	rjmp	.+16     	; 0xe37e <conv_int+0xfc>
    e36e:	f0 94       	com	r15
    e370:	e0 94       	com	r14
    e372:	d0 94       	com	r13
    e374:	c0 94       	com	r12
    e376:	c1 1c       	adc	r12, r1
    e378:	d1 1c       	adc	r13, r1
    e37a:	e1 1c       	adc	r14, r1
    e37c:	f1 1c       	adc	r15, r1
    e37e:	21 2f       	mov	r18, r17
    e380:	b7 01       	movw	r22, r14
    e382:	a6 01       	movw	r20, r12
    e384:	c4 01       	movw	r24, r8
    e386:	0e 94 fc 70 	call	0xe1f8	; 0xe1f8 <putval>
    e38a:	81 e0       	ldi	r24, 0x01	; 1
    e38c:	df 91       	pop	r29
    e38e:	cf 91       	pop	r28
    e390:	1f 91       	pop	r17
    e392:	0f 91       	pop	r16
    e394:	ff 90       	pop	r15
    e396:	ef 90       	pop	r14
    e398:	df 90       	pop	r13
    e39a:	cf 90       	pop	r12
    e39c:	af 90       	pop	r10
    e39e:	9f 90       	pop	r9
    e3a0:	8f 90       	pop	r8
    e3a2:	08 95       	ret

0000e3a4 <conv_brk>:
    e3a4:	7f 92       	push	r7
    e3a6:	8f 92       	push	r8
    e3a8:	9f 92       	push	r9
    e3aa:	af 92       	push	r10
    e3ac:	bf 92       	push	r11
    e3ae:	cf 92       	push	r12
    e3b0:	df 92       	push	r13
    e3b2:	ef 92       	push	r14
    e3b4:	ff 92       	push	r15
    e3b6:	0f 93       	push	r16
    e3b8:	1f 93       	push	r17
    e3ba:	cf 93       	push	r28
    e3bc:	df 93       	push	r29
    e3be:	cd b7       	in	r28, 0x3d	; 61
    e3c0:	de b7       	in	r29, 0x3e	; 62
    e3c2:	a1 97       	sbiw	r28, 0x21	; 33
    e3c4:	0f b6       	in	r0, 0x3f	; 63
    e3c6:	f8 94       	cli
    e3c8:	de bf       	out	0x3e, r29	; 62
    e3ca:	0f be       	out	0x3f, r0	; 63
    e3cc:	cd bf       	out	0x3d, r28	; 61
    e3ce:	5c 01       	movw	r10, r24
    e3d0:	7a 01       	movw	r14, r20
    e3d2:	8e 01       	movw	r16, r28
    e3d4:	0f 5f       	subi	r16, 0xFF	; 255
    e3d6:	1f 4f       	sbci	r17, 0xFF	; 255
    e3d8:	68 01       	movw	r12, r16
    e3da:	80 e2       	ldi	r24, 0x20	; 32
    e3dc:	d8 01       	movw	r26, r16
    e3de:	1d 92       	st	X+, r1
    e3e0:	8a 95       	dec	r24
    e3e2:	e9 f7       	brne	.-6      	; 0xe3de <conv_brk+0x3a>
    e3e4:	f5 01       	movw	r30, r10
    e3e6:	73 80       	ldd	r7, Z+3	; 0x03
    e3e8:	40 e0       	ldi	r20, 0x00	; 0
    e3ea:	50 e0       	ldi	r21, 0x00	; 0
    e3ec:	81 2c       	mov	r8, r1
    e3ee:	b0 e0       	ldi	r27, 0x00	; 0
    e3f0:	91 2c       	mov	r9, r1
    e3f2:	81 e0       	ldi	r24, 0x01	; 1
    e3f4:	90 e0       	ldi	r25, 0x00	; 0
    e3f6:	f9 01       	movw	r30, r18
    e3f8:	73 fc       	sbrc	r7, 3
    e3fa:	a5 91       	lpm	r26, Z+
    e3fc:	73 fe       	sbrs	r7, 3
    e3fe:	a1 91       	ld	r26, Z+
    e400:	8f 01       	movw	r16, r30
    e402:	7a 2f       	mov	r23, r26
    e404:	9f 01       	movw	r18, r30
    e406:	a1 11       	cpse	r26, r1
    e408:	03 c0       	rjmp	.+6      	; 0xe410 <conv_brk+0x6c>
    e40a:	80 e0       	ldi	r24, 0x00	; 0
    e40c:	90 e0       	ldi	r25, 0x00	; 0
    e40e:	7d c0       	rjmp	.+250    	; 0xe50a <conv_brk+0x166>
    e410:	ae 35       	cpi	r26, 0x5E	; 94
    e412:	19 f4       	brne	.+6      	; 0xe41a <conv_brk+0x76>
    e414:	41 15       	cp	r20, r1
    e416:	51 05       	cpc	r21, r1
    e418:	59 f1       	breq	.+86     	; 0xe470 <conv_brk+0xcc>
    e41a:	e9 2d       	mov	r30, r9
    e41c:	f0 e0       	ldi	r31, 0x00	; 0
    e41e:	e4 17       	cp	r30, r20
    e420:	f5 07       	cpc	r31, r21
    e422:	3c f4       	brge	.+14     	; 0xe432 <conv_brk+0x8e>
    e424:	ad 35       	cpi	r26, 0x5D	; 93
    e426:	69 f1       	breq	.+90     	; 0xe482 <conv_brk+0xde>
    e428:	ad 32       	cpi	r26, 0x2D	; 45
    e42a:	19 f4       	brne	.+6      	; 0xe432 <conv_brk+0x8e>
    e42c:	bb 23       	and	r27, r27
    e42e:	19 f1       	breq	.+70     	; 0xe476 <conv_brk+0xd2>
    e430:	03 c0       	rjmp	.+6      	; 0xe438 <conv_brk+0x94>
    e432:	b1 11       	cpse	r27, r1
    e434:	01 c0       	rjmp	.+2      	; 0xe438 <conv_brk+0x94>
    e436:	8a 2e       	mov	r8, r26
    e438:	e7 2f       	mov	r30, r23
    e43a:	e6 95       	lsr	r30
    e43c:	e6 95       	lsr	r30
    e43e:	e6 95       	lsr	r30
    e440:	86 01       	movw	r16, r12
    e442:	0e 0f       	add	r16, r30
    e444:	11 1d       	adc	r17, r1
    e446:	f8 01       	movw	r30, r16
    e448:	a7 2f       	mov	r26, r23
    e44a:	a7 70       	andi	r26, 0x07	; 7
    e44c:	8c 01       	movw	r16, r24
    e44e:	02 c0       	rjmp	.+4      	; 0xe454 <conv_brk+0xb0>
    e450:	00 0f       	add	r16, r16
    e452:	11 1f       	adc	r17, r17
    e454:	aa 95       	dec	r26
    e456:	e2 f7       	brpl	.-8      	; 0xe450 <conv_brk+0xac>
    e458:	d8 01       	movw	r26, r16
    e45a:	b0 81       	ld	r27, Z
    e45c:	ba 2b       	or	r27, r26
    e45e:	b0 83       	st	Z, r27
    e460:	78 15       	cp	r23, r8
    e462:	59 f0       	breq	.+22     	; 0xe47a <conv_brk+0xd6>
    e464:	78 15       	cp	r23, r8
    e466:	10 f4       	brcc	.+4      	; 0xe46c <conv_brk+0xc8>
    e468:	7f 5f       	subi	r23, 0xFF	; 255
    e46a:	e6 cf       	rjmp	.-52     	; 0xe438 <conv_brk+0x94>
    e46c:	71 50       	subi	r23, 0x01	; 1
    e46e:	e4 cf       	rjmp	.-56     	; 0xe438 <conv_brk+0x94>
    e470:	99 24       	eor	r9, r9
    e472:	93 94       	inc	r9
    e474:	03 c0       	rjmp	.+6      	; 0xe47c <conv_brk+0xd8>
    e476:	b1 e0       	ldi	r27, 0x01	; 1
    e478:	01 c0       	rjmp	.+2      	; 0xe47c <conv_brk+0xd8>
    e47a:	b0 e0       	ldi	r27, 0x00	; 0
    e47c:	4f 5f       	subi	r20, 0xFF	; 255
    e47e:	5f 4f       	sbci	r21, 0xFF	; 255
    e480:	ba cf       	rjmp	.-140    	; 0xe3f6 <conv_brk+0x52>
    e482:	bb 23       	and	r27, r27
    e484:	19 f0       	breq	.+6      	; 0xe48c <conv_brk+0xe8>
    e486:	8e 81       	ldd	r24, Y+6	; 0x06
    e488:	80 62       	ori	r24, 0x20	; 32
    e48a:	8e 83       	std	Y+6, r24	; 0x06
    e48c:	91 10       	cpse	r9, r1
    e48e:	03 c0       	rjmp	.+6      	; 0xe496 <conv_brk+0xf2>
    e490:	99 24       	eor	r9, r9
    e492:	93 94       	inc	r9
    e494:	15 c0       	rjmp	.+42     	; 0xe4c0 <conv_brk+0x11c>
    e496:	f6 01       	movw	r30, r12
    e498:	ce 01       	movw	r24, r28
    e49a:	81 96       	adiw	r24, 0x21	; 33
    e49c:	20 81       	ld	r18, Z
    e49e:	20 95       	com	r18
    e4a0:	21 93       	st	Z+, r18
    e4a2:	e8 17       	cp	r30, r24
    e4a4:	f9 07       	cpc	r31, r25
    e4a6:	d1 f7       	brne	.-12     	; 0xe49c <conv_brk+0xf8>
    e4a8:	f3 cf       	rjmp	.-26     	; 0xe490 <conv_brk+0xec>
    e4aa:	e1 14       	cp	r14, r1
    e4ac:	f1 04       	cpc	r15, r1
    e4ae:	29 f0       	breq	.+10     	; 0xe4ba <conv_brk+0x116>
    e4b0:	d7 01       	movw	r26, r14
    e4b2:	8c 93       	st	X, r24
    e4b4:	f7 01       	movw	r30, r14
    e4b6:	31 96       	adiw	r30, 0x01	; 1
    e4b8:	7f 01       	movw	r14, r30
    e4ba:	61 50       	subi	r22, 0x01	; 1
    e4bc:	01 f1       	breq	.+64     	; 0xe4fe <conv_brk+0x15a>
    e4be:	91 2c       	mov	r9, r1
    e4c0:	c5 01       	movw	r24, r10
    e4c2:	69 a3       	std	Y+33, r22	; 0x21
    e4c4:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e4c8:	69 a1       	ldd	r22, Y+33	; 0x21
    e4ca:	97 fd       	sbrc	r25, 7
    e4cc:	16 c0       	rjmp	.+44     	; 0xe4fa <conv_brk+0x156>
    e4ce:	28 2f       	mov	r18, r24
    e4d0:	26 95       	lsr	r18
    e4d2:	26 95       	lsr	r18
    e4d4:	26 95       	lsr	r18
    e4d6:	f6 01       	movw	r30, r12
    e4d8:	e2 0f       	add	r30, r18
    e4da:	f1 1d       	adc	r31, r1
    e4dc:	20 81       	ld	r18, Z
    e4de:	30 e0       	ldi	r19, 0x00	; 0
    e4e0:	ac 01       	movw	r20, r24
    e4e2:	47 70       	andi	r20, 0x07	; 7
    e4e4:	55 27       	eor	r21, r21
    e4e6:	02 c0       	rjmp	.+4      	; 0xe4ec <conv_brk+0x148>
    e4e8:	35 95       	asr	r19
    e4ea:	27 95       	ror	r18
    e4ec:	4a 95       	dec	r20
    e4ee:	e2 f7       	brpl	.-8      	; 0xe4e8 <conv_brk+0x144>
    e4f0:	20 fd       	sbrc	r18, 0
    e4f2:	db cf       	rjmp	.-74     	; 0xe4aa <conv_brk+0x106>
    e4f4:	b5 01       	movw	r22, r10
    e4f6:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ungetc>
    e4fa:	91 10       	cpse	r9, r1
    e4fc:	86 cf       	rjmp	.-244    	; 0xe40a <conv_brk+0x66>
    e4fe:	e1 14       	cp	r14, r1
    e500:	f1 04       	cpc	r15, r1
    e502:	11 f0       	breq	.+4      	; 0xe508 <conv_brk+0x164>
    e504:	d7 01       	movw	r26, r14
    e506:	1c 92       	st	X, r1
    e508:	c8 01       	movw	r24, r16
    e50a:	a1 96       	adiw	r28, 0x21	; 33
    e50c:	0f b6       	in	r0, 0x3f	; 63
    e50e:	f8 94       	cli
    e510:	de bf       	out	0x3e, r29	; 62
    e512:	0f be       	out	0x3f, r0	; 63
    e514:	cd bf       	out	0x3d, r28	; 61
    e516:	df 91       	pop	r29
    e518:	cf 91       	pop	r28
    e51a:	1f 91       	pop	r17
    e51c:	0f 91       	pop	r16
    e51e:	ff 90       	pop	r15
    e520:	ef 90       	pop	r14
    e522:	df 90       	pop	r13
    e524:	cf 90       	pop	r12
    e526:	bf 90       	pop	r11
    e528:	af 90       	pop	r10
    e52a:	9f 90       	pop	r9
    e52c:	8f 90       	pop	r8
    e52e:	7f 90       	pop	r7
    e530:	08 95       	ret

0000e532 <vfscanf>:
    e532:	4f 92       	push	r4
    e534:	5f 92       	push	r5
    e536:	7f 92       	push	r7
    e538:	8f 92       	push	r8
    e53a:	9f 92       	push	r9
    e53c:	af 92       	push	r10
    e53e:	bf 92       	push	r11
    e540:	cf 92       	push	r12
    e542:	df 92       	push	r13
    e544:	ef 92       	push	r14
    e546:	ff 92       	push	r15
    e548:	0f 93       	push	r16
    e54a:	1f 93       	push	r17
    e54c:	cf 93       	push	r28
    e54e:	df 93       	push	r29
    e550:	1f 92       	push	r1
    e552:	cd b7       	in	r28, 0x3d	; 61
    e554:	de b7       	in	r29, 0x3e	; 62
    e556:	8c 01       	movw	r16, r24
    e558:	2b 01       	movw	r4, r22
    e55a:	7a 01       	movw	r14, r20
    e55c:	fc 01       	movw	r30, r24
    e55e:	17 82       	std	Z+7, r1	; 0x07
    e560:	16 82       	std	Z+6, r1	; 0x06
    e562:	a1 2c       	mov	r10, r1
    e564:	f8 01       	movw	r30, r16
    e566:	d3 80       	ldd	r13, Z+3	; 0x03
    e568:	f2 01       	movw	r30, r4
    e56a:	d3 fc       	sbrc	r13, 3
    e56c:	85 91       	lpm	r24, Z+
    e56e:	d3 fe       	sbrs	r13, 3
    e570:	81 91       	ld	r24, Z+
    e572:	38 2f       	mov	r19, r24
    e574:	2f 01       	movw	r4, r30
    e576:	88 23       	and	r24, r24
    e578:	09 f4       	brne	.+2      	; 0xe57c <vfscanf+0x4a>
    e57a:	fc c0       	rjmp	.+504    	; 0xe774 <vfscanf+0x242>
    e57c:	90 e0       	ldi	r25, 0x00	; 0
    e57e:	39 83       	std	Y+1, r19	; 0x01
    e580:	0e 94 18 74 	call	0xe830	; 0xe830 <isspace>
    e584:	39 81       	ldd	r19, Y+1	; 0x01
    e586:	89 2b       	or	r24, r25
    e588:	21 f0       	breq	.+8      	; 0xe592 <vfscanf+0x60>
    e58a:	c8 01       	movw	r24, r16
    e58c:	0e 94 28 71 	call	0xe250	; 0xe250 <skip_spaces>
    e590:	e9 cf       	rjmp	.-46     	; 0xe564 <vfscanf+0x32>
    e592:	35 32       	cpi	r19, 0x25	; 37
    e594:	41 f4       	brne	.+16     	; 0xe5a6 <vfscanf+0x74>
    e596:	f2 01       	movw	r30, r4
    e598:	d3 fc       	sbrc	r13, 3
    e59a:	35 91       	lpm	r19, Z+
    e59c:	d3 fe       	sbrs	r13, 3
    e59e:	31 91       	ld	r19, Z+
    e5a0:	2f 01       	movw	r4, r30
    e5a2:	35 32       	cpi	r19, 0x25	; 37
    e5a4:	69 f4       	brne	.+26     	; 0xe5c0 <vfscanf+0x8e>
    e5a6:	c8 01       	movw	r24, r16
    e5a8:	39 83       	std	Y+1, r19	; 0x01
    e5aa:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e5ae:	39 81       	ldd	r19, Y+1	; 0x01
    e5b0:	97 fd       	sbrc	r25, 7
    e5b2:	de c0       	rjmp	.+444    	; 0xe770 <vfscanf+0x23e>
    e5b4:	38 17       	cp	r19, r24
    e5b6:	b1 f2       	breq	.-84     	; 0xe564 <vfscanf+0x32>
    e5b8:	b8 01       	movw	r22, r16
    e5ba:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ungetc>
    e5be:	da c0       	rjmp	.+436    	; 0xe774 <vfscanf+0x242>
    e5c0:	3a 32       	cpi	r19, 0x2A	; 42
    e5c2:	41 f4       	brne	.+16     	; 0xe5d4 <vfscanf+0xa2>
    e5c4:	d3 fc       	sbrc	r13, 3
    e5c6:	35 91       	lpm	r19, Z+
    e5c8:	d3 fe       	sbrs	r13, 3
    e5ca:	31 91       	ld	r19, Z+
    e5cc:	2f 01       	movw	r4, r30
    e5ce:	bb 24       	eor	r11, r11
    e5d0:	b3 94       	inc	r11
    e5d2:	01 c0       	rjmp	.+2      	; 0xe5d6 <vfscanf+0xa4>
    e5d4:	b1 2c       	mov	r11, r1
    e5d6:	71 2c       	mov	r7, r1
    e5d8:	20 ed       	ldi	r18, 0xD0	; 208
    e5da:	23 0f       	add	r18, r19
    e5dc:	2a 30       	cpi	r18, 0x0A	; 10
    e5de:	90 f4       	brcc	.+36     	; 0xe604 <vfscanf+0xd2>
    e5e0:	fb 2d       	mov	r31, r11
    e5e2:	f2 60       	ori	r31, 0x02	; 2
    e5e4:	bf 2e       	mov	r11, r31
    e5e6:	67 2d       	mov	r22, r7
    e5e8:	70 e0       	ldi	r23, 0x00	; 0
    e5ea:	80 e0       	ldi	r24, 0x00	; 0
    e5ec:	90 e0       	ldi	r25, 0x00	; 0
    e5ee:	40 e2       	ldi	r20, 0x20	; 32
    e5f0:	0e 94 08 71 	call	0xe210	; 0xe210 <mulacc>
    e5f4:	76 2e       	mov	r7, r22
    e5f6:	f2 01       	movw	r30, r4
    e5f8:	d3 fc       	sbrc	r13, 3
    e5fa:	35 91       	lpm	r19, Z+
    e5fc:	d3 fe       	sbrs	r13, 3
    e5fe:	31 91       	ld	r19, Z+
    e600:	2f 01       	movw	r4, r30
    e602:	ea cf       	rjmp	.-44     	; 0xe5d8 <vfscanf+0xa6>
    e604:	b1 fe       	sbrs	r11, 1
    e606:	03 c0       	rjmp	.+6      	; 0xe60e <vfscanf+0xdc>
    e608:	71 10       	cpse	r7, r1
    e60a:	03 c0       	rjmp	.+6      	; 0xe612 <vfscanf+0xe0>
    e60c:	b3 c0       	rjmp	.+358    	; 0xe774 <vfscanf+0x242>
    e60e:	77 24       	eor	r7, r7
    e610:	7a 94       	dec	r7
    e612:	38 36       	cpi	r19, 0x68	; 104
    e614:	19 f0       	breq	.+6      	; 0xe61c <vfscanf+0xea>
    e616:	3c 36       	cpi	r19, 0x6C	; 108
    e618:	61 f0       	breq	.+24     	; 0xe632 <vfscanf+0x100>
    e61a:	14 c0       	rjmp	.+40     	; 0xe644 <vfscanf+0x112>
    e61c:	f2 01       	movw	r30, r4
    e61e:	d3 fc       	sbrc	r13, 3
    e620:	35 91       	lpm	r19, Z+
    e622:	d3 fe       	sbrs	r13, 3
    e624:	31 91       	ld	r19, Z+
    e626:	2f 01       	movw	r4, r30
    e628:	38 36       	cpi	r19, 0x68	; 104
    e62a:	61 f4       	brne	.+24     	; 0xe644 <vfscanf+0x112>
    e62c:	fb 2d       	mov	r31, r11
    e62e:	f8 60       	ori	r31, 0x08	; 8
    e630:	bf 2e       	mov	r11, r31
    e632:	8b 2d       	mov	r24, r11
    e634:	84 60       	ori	r24, 0x04	; 4
    e636:	b8 2e       	mov	r11, r24
    e638:	f2 01       	movw	r30, r4
    e63a:	d3 fc       	sbrc	r13, 3
    e63c:	35 91       	lpm	r19, Z+
    e63e:	d3 fe       	sbrs	r13, 3
    e640:	31 91       	ld	r19, Z+
    e642:	2f 01       	movw	r4, r30
    e644:	33 23       	and	r19, r19
    e646:	09 f4       	brne	.+2      	; 0xe64a <vfscanf+0x118>
    e648:	95 c0       	rjmp	.+298    	; 0xe774 <vfscanf+0x242>
    e64a:	63 2f       	mov	r22, r19
    e64c:	70 e0       	ldi	r23, 0x00	; 0
    e64e:	8f ec       	ldi	r24, 0xCF	; 207
    e650:	9f e4       	ldi	r25, 0x4F	; 79
    e652:	39 83       	std	Y+1, r19	; 0x01
    e654:	0e 94 43 6c 	call	0xd886	; 0xd886 <strchr_P>
    e658:	39 81       	ldd	r19, Y+1	; 0x01
    e65a:	89 2b       	or	r24, r25
    e65c:	09 f4       	brne	.+2      	; 0xe660 <vfscanf+0x12e>
    e65e:	8a c0       	rjmp	.+276    	; 0xe774 <vfscanf+0x242>
    e660:	b0 fc       	sbrc	r11, 0
    e662:	07 c0       	rjmp	.+14     	; 0xe672 <vfscanf+0x140>
    e664:	f7 01       	movw	r30, r14
    e666:	c0 80       	ld	r12, Z
    e668:	d1 80       	ldd	r13, Z+1	; 0x01
    e66a:	c7 01       	movw	r24, r14
    e66c:	02 96       	adiw	r24, 0x02	; 2
    e66e:	7c 01       	movw	r14, r24
    e670:	02 c0       	rjmp	.+4      	; 0xe676 <vfscanf+0x144>
    e672:	c1 2c       	mov	r12, r1
    e674:	d1 2c       	mov	r13, r1
    e676:	3e 36       	cpi	r19, 0x6E	; 110
    e678:	51 f4       	brne	.+20     	; 0xe68e <vfscanf+0x15c>
    e67a:	f8 01       	movw	r30, r16
    e67c:	46 81       	ldd	r20, Z+6	; 0x06
    e67e:	57 81       	ldd	r21, Z+7	; 0x07
    e680:	60 e0       	ldi	r22, 0x00	; 0
    e682:	70 e0       	ldi	r23, 0x00	; 0
    e684:	2b 2d       	mov	r18, r11
    e686:	c6 01       	movw	r24, r12
    e688:	0e 94 fc 70 	call	0xe1f8	; 0xe1f8 <putval>
    e68c:	6b cf       	rjmp	.-298    	; 0xe564 <vfscanf+0x32>
    e68e:	33 36       	cpi	r19, 0x63	; 99
    e690:	a1 f4       	brne	.+40     	; 0xe6ba <vfscanf+0x188>
    e692:	b1 fc       	sbrc	r11, 1
    e694:	02 c0       	rjmp	.+4      	; 0xe69a <vfscanf+0x168>
    e696:	77 24       	eor	r7, r7
    e698:	73 94       	inc	r7
    e69a:	c8 01       	movw	r24, r16
    e69c:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e6a0:	97 fd       	sbrc	r25, 7
    e6a2:	66 c0       	rjmp	.+204    	; 0xe770 <vfscanf+0x23e>
    e6a4:	c1 14       	cp	r12, r1
    e6a6:	d1 04       	cpc	r13, r1
    e6a8:	29 f0       	breq	.+10     	; 0xe6b4 <vfscanf+0x182>
    e6aa:	f6 01       	movw	r30, r12
    e6ac:	80 83       	st	Z, r24
    e6ae:	c6 01       	movw	r24, r12
    e6b0:	01 96       	adiw	r24, 0x01	; 1
    e6b2:	6c 01       	movw	r12, r24
    e6b4:	7a 94       	dec	r7
    e6b6:	89 f7       	brne	.-30     	; 0xe69a <vfscanf+0x168>
    e6b8:	57 c0       	rjmp	.+174    	; 0xe768 <vfscanf+0x236>
    e6ba:	3b 35       	cpi	r19, 0x5B	; 91
    e6bc:	59 f4       	brne	.+22     	; 0xe6d4 <vfscanf+0x1a2>
    e6be:	92 01       	movw	r18, r4
    e6c0:	a6 01       	movw	r20, r12
    e6c2:	67 2d       	mov	r22, r7
    e6c4:	c8 01       	movw	r24, r16
    e6c6:	0e 94 d2 71 	call	0xe3a4	; 0xe3a4 <conv_brk>
    e6ca:	2c 01       	movw	r4, r24
    e6cc:	00 97       	sbiw	r24, 0x00	; 0
    e6ce:	09 f0       	breq	.+2      	; 0xe6d2 <vfscanf+0x1a0>
    e6d0:	4b c0       	rjmp	.+150    	; 0xe768 <vfscanf+0x236>
    e6d2:	45 c0       	rjmp	.+138    	; 0xe75e <vfscanf+0x22c>
    e6d4:	c8 01       	movw	r24, r16
    e6d6:	39 83       	std	Y+1, r19	; 0x01
    e6d8:	0e 94 28 71 	call	0xe250	; 0xe250 <skip_spaces>
    e6dc:	39 81       	ldd	r19, Y+1	; 0x01
    e6de:	97 fd       	sbrc	r25, 7
    e6e0:	47 c0       	rjmp	.+142    	; 0xe770 <vfscanf+0x23e>
    e6e2:	3f 36       	cpi	r19, 0x6F	; 111
    e6e4:	69 f1       	breq	.+90     	; 0xe740 <vfscanf+0x20e>
    e6e6:	28 f4       	brcc	.+10     	; 0xe6f2 <vfscanf+0x1c0>
    e6e8:	34 36       	cpi	r19, 0x64	; 100
    e6ea:	31 f1       	breq	.+76     	; 0xe738 <vfscanf+0x206>
    e6ec:	39 36       	cpi	r19, 0x69	; 105
    e6ee:	79 f1       	breq	.+94     	; 0xe74e <vfscanf+0x21c>
    e6f0:	2b c0       	rjmp	.+86     	; 0xe748 <vfscanf+0x216>
    e6f2:	33 37       	cpi	r19, 0x73	; 115
    e6f4:	69 f0       	breq	.+26     	; 0xe710 <vfscanf+0x1de>
    e6f6:	35 37       	cpi	r19, 0x75	; 117
    e6f8:	f9 f0       	breq	.+62     	; 0xe738 <vfscanf+0x206>
    e6fa:	26 c0       	rjmp	.+76     	; 0xe748 <vfscanf+0x216>
    e6fc:	c1 14       	cp	r12, r1
    e6fe:	d1 04       	cpc	r13, r1
    e700:	29 f0       	breq	.+10     	; 0xe70c <vfscanf+0x1da>
    e702:	f6 01       	movw	r30, r12
    e704:	80 82       	st	Z, r8
    e706:	c6 01       	movw	r24, r12
    e708:	01 96       	adiw	r24, 0x01	; 1
    e70a:	6c 01       	movw	r12, r24
    e70c:	7a 94       	dec	r7
    e70e:	71 f0       	breq	.+28     	; 0xe72c <vfscanf+0x1fa>
    e710:	c8 01       	movw	r24, r16
    e712:	0e 94 36 74 	call	0xe86c	; 0xe86c <fgetc>
    e716:	4c 01       	movw	r8, r24
    e718:	97 fd       	sbrc	r25, 7
    e71a:	08 c0       	rjmp	.+16     	; 0xe72c <vfscanf+0x1fa>
    e71c:	0e 94 18 74 	call	0xe830	; 0xe830 <isspace>
    e720:	89 2b       	or	r24, r25
    e722:	61 f3       	breq	.-40     	; 0xe6fc <vfscanf+0x1ca>
    e724:	b8 01       	movw	r22, r16
    e726:	c4 01       	movw	r24, r8
    e728:	0e 94 a6 74 	call	0xe94c	; 0xe94c <ungetc>
    e72c:	c1 14       	cp	r12, r1
    e72e:	d1 04       	cpc	r13, r1
    e730:	d9 f0       	breq	.+54     	; 0xe768 <vfscanf+0x236>
    e732:	f6 01       	movw	r30, r12
    e734:	10 82       	st	Z, r1
    e736:	18 c0       	rjmp	.+48     	; 0xe768 <vfscanf+0x236>
    e738:	fb 2d       	mov	r31, r11
    e73a:	f0 62       	ori	r31, 0x20	; 32
    e73c:	bf 2e       	mov	r11, r31
    e73e:	07 c0       	rjmp	.+14     	; 0xe74e <vfscanf+0x21c>
    e740:	8b 2d       	mov	r24, r11
    e742:	80 61       	ori	r24, 0x10	; 16
    e744:	b8 2e       	mov	r11, r24
    e746:	03 c0       	rjmp	.+6      	; 0xe74e <vfscanf+0x21c>
    e748:	9b 2d       	mov	r25, r11
    e74a:	90 64       	ori	r25, 0x40	; 64
    e74c:	b9 2e       	mov	r11, r25
    e74e:	2b 2d       	mov	r18, r11
    e750:	a6 01       	movw	r20, r12
    e752:	67 2d       	mov	r22, r7
    e754:	c8 01       	movw	r24, r16
    e756:	0e 94 41 71 	call	0xe282	; 0xe282 <conv_int>
    e75a:	81 11       	cpse	r24, r1
    e75c:	05 c0       	rjmp	.+10     	; 0xe768 <vfscanf+0x236>
    e75e:	f8 01       	movw	r30, r16
    e760:	83 81       	ldd	r24, Z+3	; 0x03
    e762:	80 73       	andi	r24, 0x30	; 48
    e764:	29 f4       	brne	.+10     	; 0xe770 <vfscanf+0x23e>
    e766:	06 c0       	rjmp	.+12     	; 0xe774 <vfscanf+0x242>
    e768:	b0 fc       	sbrc	r11, 0
    e76a:	fc ce       	rjmp	.-520    	; 0xe564 <vfscanf+0x32>
    e76c:	a3 94       	inc	r10
    e76e:	fa ce       	rjmp	.-524    	; 0xe564 <vfscanf+0x32>
    e770:	aa 20       	and	r10, r10
    e772:	19 f0       	breq	.+6      	; 0xe77a <vfscanf+0x248>
    e774:	8a 2d       	mov	r24, r10
    e776:	90 e0       	ldi	r25, 0x00	; 0
    e778:	02 c0       	rjmp	.+4      	; 0xe77e <vfscanf+0x24c>
    e77a:	8f ef       	ldi	r24, 0xFF	; 255
    e77c:	9f ef       	ldi	r25, 0xFF	; 255
    e77e:	0f 90       	pop	r0
    e780:	df 91       	pop	r29
    e782:	cf 91       	pop	r28
    e784:	1f 91       	pop	r17
    e786:	0f 91       	pop	r16
    e788:	ff 90       	pop	r15
    e78a:	ef 90       	pop	r14
    e78c:	df 90       	pop	r13
    e78e:	cf 90       	pop	r12
    e790:	bf 90       	pop	r11
    e792:	af 90       	pop	r10
    e794:	9f 90       	pop	r9
    e796:	8f 90       	pop	r8
    e798:	7f 90       	pop	r7
    e79a:	5f 90       	pop	r5
    e79c:	4f 90       	pop	r4
    e79e:	08 95       	ret

0000e7a0 <__eerd_block_m128>:
    e7a0:	dc 01       	movw	r26, r24
    e7a2:	cb 01       	movw	r24, r22

0000e7a4 <__eerd_blraw_m128>:
    e7a4:	fc 01       	movw	r30, r24
    e7a6:	e1 99       	sbic	0x1c, 1	; 28
    e7a8:	fe cf       	rjmp	.-4      	; 0xe7a6 <__eerd_blraw_m128+0x2>
    e7aa:	06 c0       	rjmp	.+12     	; 0xe7b8 <__eerd_blraw_m128+0x14>
    e7ac:	ff bb       	out	0x1f, r31	; 31
    e7ae:	ee bb       	out	0x1e, r30	; 30
    e7b0:	e0 9a       	sbi	0x1c, 0	; 28
    e7b2:	31 96       	adiw	r30, 0x01	; 1
    e7b4:	0d b2       	in	r0, 0x1d	; 29
    e7b6:	0d 92       	st	X+, r0
    e7b8:	41 50       	subi	r20, 0x01	; 1
    e7ba:	50 40       	sbci	r21, 0x00	; 0
    e7bc:	b8 f7       	brcc	.-18     	; 0xe7ac <__eerd_blraw_m128+0x8>
    e7be:	08 95       	ret

0000e7c0 <__eerd_byte_m128>:
    e7c0:	e1 99       	sbic	0x1c, 1	; 28
    e7c2:	fe cf       	rjmp	.-4      	; 0xe7c0 <__eerd_byte_m128>
    e7c4:	9f bb       	out	0x1f, r25	; 31
    e7c6:	8e bb       	out	0x1e, r24	; 30
    e7c8:	e0 9a       	sbi	0x1c, 0	; 28
    e7ca:	99 27       	eor	r25, r25
    e7cc:	8d b3       	in	r24, 0x1d	; 29
    e7ce:	08 95       	ret

0000e7d0 <__eerd_dword_m128>:
    e7d0:	a6 e1       	ldi	r26, 0x16	; 22
    e7d2:	b0 e0       	ldi	r27, 0x00	; 0
    e7d4:	44 e0       	ldi	r20, 0x04	; 4
    e7d6:	50 e0       	ldi	r21, 0x00	; 0
    e7d8:	0c 94 d2 73 	jmp	0xe7a4	; 0xe7a4 <__eerd_blraw_m128>

0000e7dc <__eerd_word_m128>:
    e7dc:	a8 e1       	ldi	r26, 0x18	; 24
    e7de:	b0 e0       	ldi	r27, 0x00	; 0
    e7e0:	42 e0       	ldi	r20, 0x02	; 2
    e7e2:	50 e0       	ldi	r21, 0x00	; 0
    e7e4:	0c 94 d2 73 	jmp	0xe7a4	; 0xe7a4 <__eerd_blraw_m128>

0000e7e8 <__eewr_block_m128>:
    e7e8:	dc 01       	movw	r26, r24
    e7ea:	cb 01       	movw	r24, r22
    e7ec:	03 c0       	rjmp	.+6      	; 0xe7f4 <__eewr_block_m128+0xc>
    e7ee:	2d 91       	ld	r18, X+
    e7f0:	0e 94 ff 73 	call	0xe7fe	; 0xe7fe <__eewr_r18_m128>
    e7f4:	41 50       	subi	r20, 0x01	; 1
    e7f6:	50 40       	sbci	r21, 0x00	; 0
    e7f8:	d0 f7       	brcc	.-12     	; 0xe7ee <__eewr_block_m128+0x6>
    e7fa:	08 95       	ret

0000e7fc <__eewr_byte_m128>:
    e7fc:	26 2f       	mov	r18, r22

0000e7fe <__eewr_r18_m128>:
    e7fe:	e1 99       	sbic	0x1c, 1	; 28
    e800:	fe cf       	rjmp	.-4      	; 0xe7fe <__eewr_r18_m128>
    e802:	9f bb       	out	0x1f, r25	; 31
    e804:	8e bb       	out	0x1e, r24	; 30
    e806:	2d bb       	out	0x1d, r18	; 29
    e808:	0f b6       	in	r0, 0x3f	; 63
    e80a:	f8 94       	cli
    e80c:	e2 9a       	sbi	0x1c, 2	; 28
    e80e:	e1 9a       	sbi	0x1c, 1	; 28
    e810:	0f be       	out	0x3f, r0	; 63
    e812:	01 96       	adiw	r24, 0x01	; 1
    e814:	08 95       	ret

0000e816 <__eewr_dword_m128>:
    e816:	24 2f       	mov	r18, r20
    e818:	0e 94 ff 73 	call	0xe7fe	; 0xe7fe <__eewr_r18_m128>
    e81c:	25 2f       	mov	r18, r21
    e81e:	0e 94 ff 73 	call	0xe7fe	; 0xe7fe <__eewr_r18_m128>
    e822:	0c 94 13 74 	jmp	0xe826	; 0xe826 <__eewr_word_m128>

0000e826 <__eewr_word_m128>:
    e826:	0e 94 fe 73 	call	0xe7fc	; 0xe7fc <__eewr_byte_m128>
    e82a:	27 2f       	mov	r18, r23
    e82c:	0c 94 ff 73 	jmp	0xe7fe	; 0xe7fe <__eewr_r18_m128>

0000e830 <isspace>:
    e830:	91 11       	cpse	r25, r1
    e832:	03 c1       	rjmp	.+518    	; 0xea3a <__ctype_isfalse>
    e834:	80 32       	cpi	r24, 0x20	; 32
    e836:	19 f0       	breq	.+6      	; 0xe83e <isspace+0xe>
    e838:	89 50       	subi	r24, 0x09	; 9
    e83a:	85 50       	subi	r24, 0x05	; 5
    e83c:	d0 f7       	brcc	.-12     	; 0xe832 <isspace+0x2>
    e83e:	08 95       	ret

0000e840 <strnlen_P>:
    e840:	fc 01       	movw	r30, r24
    e842:	05 90       	lpm	r0, Z+
    e844:	61 50       	subi	r22, 0x01	; 1
    e846:	70 40       	sbci	r23, 0x00	; 0
    e848:	01 10       	cpse	r0, r1
    e84a:	d8 f7       	brcc	.-10     	; 0xe842 <strnlen_P+0x2>
    e84c:	80 95       	com	r24
    e84e:	90 95       	com	r25
    e850:	8e 0f       	add	r24, r30
    e852:	9f 1f       	adc	r25, r31
    e854:	08 95       	ret

0000e856 <strnlen>:
    e856:	fc 01       	movw	r30, r24
    e858:	61 50       	subi	r22, 0x01	; 1
    e85a:	70 40       	sbci	r23, 0x00	; 0
    e85c:	01 90       	ld	r0, Z+
    e85e:	01 10       	cpse	r0, r1
    e860:	d8 f7       	brcc	.-10     	; 0xe858 <strnlen+0x2>
    e862:	80 95       	com	r24
    e864:	90 95       	com	r25
    e866:	8e 0f       	add	r24, r30
    e868:	9f 1f       	adc	r25, r31
    e86a:	08 95       	ret

0000e86c <fgetc>:
    e86c:	cf 93       	push	r28
    e86e:	df 93       	push	r29
    e870:	ec 01       	movw	r28, r24
    e872:	2b 81       	ldd	r18, Y+3	; 0x03
    e874:	20 ff       	sbrs	r18, 0
    e876:	33 c0       	rjmp	.+102    	; 0xe8de <fgetc+0x72>
    e878:	26 ff       	sbrs	r18, 6
    e87a:	0a c0       	rjmp	.+20     	; 0xe890 <fgetc+0x24>
    e87c:	2f 7b       	andi	r18, 0xBF	; 191
    e87e:	2b 83       	std	Y+3, r18	; 0x03
    e880:	8e 81       	ldd	r24, Y+6	; 0x06
    e882:	9f 81       	ldd	r25, Y+7	; 0x07
    e884:	01 96       	adiw	r24, 0x01	; 1
    e886:	9f 83       	std	Y+7, r25	; 0x07
    e888:	8e 83       	std	Y+6, r24	; 0x06
    e88a:	8a 81       	ldd	r24, Y+2	; 0x02
    e88c:	90 e0       	ldi	r25, 0x00	; 0
    e88e:	29 c0       	rjmp	.+82     	; 0xe8e2 <fgetc+0x76>
    e890:	22 ff       	sbrs	r18, 2
    e892:	0f c0       	rjmp	.+30     	; 0xe8b2 <fgetc+0x46>
    e894:	e8 81       	ld	r30, Y
    e896:	f9 81       	ldd	r31, Y+1	; 0x01
    e898:	80 81       	ld	r24, Z
    e89a:	99 27       	eor	r25, r25
    e89c:	87 fd       	sbrc	r24, 7
    e89e:	90 95       	com	r25
    e8a0:	00 97       	sbiw	r24, 0x00	; 0
    e8a2:	19 f4       	brne	.+6      	; 0xe8aa <fgetc+0x3e>
    e8a4:	20 62       	ori	r18, 0x20	; 32
    e8a6:	2b 83       	std	Y+3, r18	; 0x03
    e8a8:	1a c0       	rjmp	.+52     	; 0xe8de <fgetc+0x72>
    e8aa:	31 96       	adiw	r30, 0x01	; 1
    e8ac:	f9 83       	std	Y+1, r31	; 0x01
    e8ae:	e8 83       	st	Y, r30
    e8b0:	0e c0       	rjmp	.+28     	; 0xe8ce <fgetc+0x62>
    e8b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    e8b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    e8b6:	09 95       	icall
    e8b8:	97 ff       	sbrs	r25, 7
    e8ba:	09 c0       	rjmp	.+18     	; 0xe8ce <fgetc+0x62>
    e8bc:	2b 81       	ldd	r18, Y+3	; 0x03
    e8be:	01 96       	adiw	r24, 0x01	; 1
    e8c0:	11 f4       	brne	.+4      	; 0xe8c6 <fgetc+0x5a>
    e8c2:	80 e1       	ldi	r24, 0x10	; 16
    e8c4:	01 c0       	rjmp	.+2      	; 0xe8c8 <fgetc+0x5c>
    e8c6:	80 e2       	ldi	r24, 0x20	; 32
    e8c8:	82 2b       	or	r24, r18
    e8ca:	8b 83       	std	Y+3, r24	; 0x03
    e8cc:	08 c0       	rjmp	.+16     	; 0xe8de <fgetc+0x72>
    e8ce:	2e 81       	ldd	r18, Y+6	; 0x06
    e8d0:	3f 81       	ldd	r19, Y+7	; 0x07
    e8d2:	2f 5f       	subi	r18, 0xFF	; 255
    e8d4:	3f 4f       	sbci	r19, 0xFF	; 255
    e8d6:	3f 83       	std	Y+7, r19	; 0x07
    e8d8:	2e 83       	std	Y+6, r18	; 0x06
    e8da:	99 27       	eor	r25, r25
    e8dc:	02 c0       	rjmp	.+4      	; 0xe8e2 <fgetc+0x76>
    e8de:	8f ef       	ldi	r24, 0xFF	; 255
    e8e0:	9f ef       	ldi	r25, 0xFF	; 255
    e8e2:	df 91       	pop	r29
    e8e4:	cf 91       	pop	r28
    e8e6:	08 95       	ret

0000e8e8 <fputc>:
    e8e8:	0f 93       	push	r16
    e8ea:	1f 93       	push	r17
    e8ec:	cf 93       	push	r28
    e8ee:	df 93       	push	r29
    e8f0:	18 2f       	mov	r17, r24
    e8f2:	09 2f       	mov	r16, r25
    e8f4:	eb 01       	movw	r28, r22
    e8f6:	8b 81       	ldd	r24, Y+3	; 0x03
    e8f8:	81 fd       	sbrc	r24, 1
    e8fa:	03 c0       	rjmp	.+6      	; 0xe902 <fputc+0x1a>
    e8fc:	8f ef       	ldi	r24, 0xFF	; 255
    e8fe:	9f ef       	ldi	r25, 0xFF	; 255
    e900:	20 c0       	rjmp	.+64     	; 0xe942 <fputc+0x5a>
    e902:	82 ff       	sbrs	r24, 2
    e904:	10 c0       	rjmp	.+32     	; 0xe926 <fputc+0x3e>
    e906:	4e 81       	ldd	r20, Y+6	; 0x06
    e908:	5f 81       	ldd	r21, Y+7	; 0x07
    e90a:	2c 81       	ldd	r18, Y+4	; 0x04
    e90c:	3d 81       	ldd	r19, Y+5	; 0x05
    e90e:	42 17       	cp	r20, r18
    e910:	53 07       	cpc	r21, r19
    e912:	7c f4       	brge	.+30     	; 0xe932 <fputc+0x4a>
    e914:	e8 81       	ld	r30, Y
    e916:	f9 81       	ldd	r31, Y+1	; 0x01
    e918:	9f 01       	movw	r18, r30
    e91a:	2f 5f       	subi	r18, 0xFF	; 255
    e91c:	3f 4f       	sbci	r19, 0xFF	; 255
    e91e:	39 83       	std	Y+1, r19	; 0x01
    e920:	28 83       	st	Y, r18
    e922:	10 83       	st	Z, r17
    e924:	06 c0       	rjmp	.+12     	; 0xe932 <fputc+0x4a>
    e926:	e8 85       	ldd	r30, Y+8	; 0x08
    e928:	f9 85       	ldd	r31, Y+9	; 0x09
    e92a:	81 2f       	mov	r24, r17
    e92c:	09 95       	icall
    e92e:	89 2b       	or	r24, r25
    e930:	29 f7       	brne	.-54     	; 0xe8fc <fputc+0x14>
    e932:	2e 81       	ldd	r18, Y+6	; 0x06
    e934:	3f 81       	ldd	r19, Y+7	; 0x07
    e936:	2f 5f       	subi	r18, 0xFF	; 255
    e938:	3f 4f       	sbci	r19, 0xFF	; 255
    e93a:	3f 83       	std	Y+7, r19	; 0x07
    e93c:	2e 83       	std	Y+6, r18	; 0x06
    e93e:	81 2f       	mov	r24, r17
    e940:	90 2f       	mov	r25, r16
    e942:	df 91       	pop	r29
    e944:	cf 91       	pop	r28
    e946:	1f 91       	pop	r17
    e948:	0f 91       	pop	r16
    e94a:	08 95       	ret

0000e94c <ungetc>:
    e94c:	fb 01       	movw	r30, r22
    e94e:	23 81       	ldd	r18, Z+3	; 0x03
    e950:	20 ff       	sbrs	r18, 0
    e952:	12 c0       	rjmp	.+36     	; 0xe978 <ungetc+0x2c>
    e954:	26 fd       	sbrc	r18, 6
    e956:	10 c0       	rjmp	.+32     	; 0xe978 <ungetc+0x2c>
    e958:	8f 3f       	cpi	r24, 0xFF	; 255
    e95a:	3f ef       	ldi	r19, 0xFF	; 255
    e95c:	93 07       	cpc	r25, r19
    e95e:	61 f0       	breq	.+24     	; 0xe978 <ungetc+0x2c>
    e960:	82 83       	std	Z+2, r24	; 0x02
    e962:	2f 7d       	andi	r18, 0xDF	; 223
    e964:	20 64       	ori	r18, 0x40	; 64
    e966:	23 83       	std	Z+3, r18	; 0x03
    e968:	26 81       	ldd	r18, Z+6	; 0x06
    e96a:	37 81       	ldd	r19, Z+7	; 0x07
    e96c:	21 50       	subi	r18, 0x01	; 1
    e96e:	31 09       	sbc	r19, r1
    e970:	37 83       	std	Z+7, r19	; 0x07
    e972:	26 83       	std	Z+6, r18	; 0x06
    e974:	99 27       	eor	r25, r25
    e976:	08 95       	ret
    e978:	8f ef       	ldi	r24, 0xFF	; 255
    e97a:	9f ef       	ldi	r25, 0xFF	; 255
    e97c:	08 95       	ret

0000e97e <__ultoa_invert>:
    e97e:	fa 01       	movw	r30, r20
    e980:	aa 27       	eor	r26, r26
    e982:	28 30       	cpi	r18, 0x08	; 8
    e984:	51 f1       	breq	.+84     	; 0xe9da <__ultoa_invert+0x5c>
    e986:	20 31       	cpi	r18, 0x10	; 16
    e988:	81 f1       	breq	.+96     	; 0xe9ea <__ultoa_invert+0x6c>
    e98a:	e8 94       	clt
    e98c:	6f 93       	push	r22
    e98e:	6e 7f       	andi	r22, 0xFE	; 254
    e990:	6e 5f       	subi	r22, 0xFE	; 254
    e992:	7f 4f       	sbci	r23, 0xFF	; 255
    e994:	8f 4f       	sbci	r24, 0xFF	; 255
    e996:	9f 4f       	sbci	r25, 0xFF	; 255
    e998:	af 4f       	sbci	r26, 0xFF	; 255
    e99a:	b1 e0       	ldi	r27, 0x01	; 1
    e99c:	3e d0       	rcall	.+124    	; 0xea1a <__ultoa_invert+0x9c>
    e99e:	b4 e0       	ldi	r27, 0x04	; 4
    e9a0:	3c d0       	rcall	.+120    	; 0xea1a <__ultoa_invert+0x9c>
    e9a2:	67 0f       	add	r22, r23
    e9a4:	78 1f       	adc	r23, r24
    e9a6:	89 1f       	adc	r24, r25
    e9a8:	9a 1f       	adc	r25, r26
    e9aa:	a1 1d       	adc	r26, r1
    e9ac:	68 0f       	add	r22, r24
    e9ae:	79 1f       	adc	r23, r25
    e9b0:	8a 1f       	adc	r24, r26
    e9b2:	91 1d       	adc	r25, r1
    e9b4:	a1 1d       	adc	r26, r1
    e9b6:	6a 0f       	add	r22, r26
    e9b8:	71 1d       	adc	r23, r1
    e9ba:	81 1d       	adc	r24, r1
    e9bc:	91 1d       	adc	r25, r1
    e9be:	a1 1d       	adc	r26, r1
    e9c0:	20 d0       	rcall	.+64     	; 0xea02 <__ultoa_invert+0x84>
    e9c2:	09 f4       	brne	.+2      	; 0xe9c6 <__ultoa_invert+0x48>
    e9c4:	68 94       	set
    e9c6:	3f 91       	pop	r19
    e9c8:	2a e0       	ldi	r18, 0x0A	; 10
    e9ca:	26 9f       	mul	r18, r22
    e9cc:	11 24       	eor	r1, r1
    e9ce:	30 19       	sub	r19, r0
    e9d0:	30 5d       	subi	r19, 0xD0	; 208
    e9d2:	31 93       	st	Z+, r19
    e9d4:	de f6       	brtc	.-74     	; 0xe98c <__ultoa_invert+0xe>
    e9d6:	cf 01       	movw	r24, r30
    e9d8:	08 95       	ret
    e9da:	46 2f       	mov	r20, r22
    e9dc:	47 70       	andi	r20, 0x07	; 7
    e9de:	40 5d       	subi	r20, 0xD0	; 208
    e9e0:	41 93       	st	Z+, r20
    e9e2:	b3 e0       	ldi	r27, 0x03	; 3
    e9e4:	0f d0       	rcall	.+30     	; 0xea04 <__ultoa_invert+0x86>
    e9e6:	c9 f7       	brne	.-14     	; 0xe9da <__ultoa_invert+0x5c>
    e9e8:	f6 cf       	rjmp	.-20     	; 0xe9d6 <__ultoa_invert+0x58>
    e9ea:	46 2f       	mov	r20, r22
    e9ec:	4f 70       	andi	r20, 0x0F	; 15
    e9ee:	40 5d       	subi	r20, 0xD0	; 208
    e9f0:	4a 33       	cpi	r20, 0x3A	; 58
    e9f2:	18 f0       	brcs	.+6      	; 0xe9fa <__ultoa_invert+0x7c>
    e9f4:	49 5d       	subi	r20, 0xD9	; 217
    e9f6:	31 fd       	sbrc	r19, 1
    e9f8:	40 52       	subi	r20, 0x20	; 32
    e9fa:	41 93       	st	Z+, r20
    e9fc:	02 d0       	rcall	.+4      	; 0xea02 <__ultoa_invert+0x84>
    e9fe:	a9 f7       	brne	.-22     	; 0xe9ea <__ultoa_invert+0x6c>
    ea00:	ea cf       	rjmp	.-44     	; 0xe9d6 <__ultoa_invert+0x58>
    ea02:	b4 e0       	ldi	r27, 0x04	; 4
    ea04:	a6 95       	lsr	r26
    ea06:	97 95       	ror	r25
    ea08:	87 95       	ror	r24
    ea0a:	77 95       	ror	r23
    ea0c:	67 95       	ror	r22
    ea0e:	ba 95       	dec	r27
    ea10:	c9 f7       	brne	.-14     	; 0xea04 <__ultoa_invert+0x86>
    ea12:	00 97       	sbiw	r24, 0x00	; 0
    ea14:	61 05       	cpc	r22, r1
    ea16:	71 05       	cpc	r23, r1
    ea18:	08 95       	ret
    ea1a:	9b 01       	movw	r18, r22
    ea1c:	ac 01       	movw	r20, r24
    ea1e:	0a 2e       	mov	r0, r26
    ea20:	06 94       	lsr	r0
    ea22:	57 95       	ror	r21
    ea24:	47 95       	ror	r20
    ea26:	37 95       	ror	r19
    ea28:	27 95       	ror	r18
    ea2a:	ba 95       	dec	r27
    ea2c:	c9 f7       	brne	.-14     	; 0xea20 <__ultoa_invert+0xa2>
    ea2e:	62 0f       	add	r22, r18
    ea30:	73 1f       	adc	r23, r19
    ea32:	84 1f       	adc	r24, r20
    ea34:	95 1f       	adc	r25, r21
    ea36:	a0 1d       	adc	r26, r0
    ea38:	08 95       	ret

0000ea3a <__ctype_isfalse>:
    ea3a:	99 27       	eor	r25, r25
    ea3c:	88 27       	eor	r24, r24

0000ea3e <__ctype_istrue>:
    ea3e:	08 95       	ret

0000ea40 <__udivmodqi4>:
    ea40:	99 1b       	sub	r25, r25
    ea42:	79 e0       	ldi	r23, 0x09	; 9
    ea44:	04 c0       	rjmp	.+8      	; 0xea4e <__udivmodqi4_ep>

0000ea46 <__udivmodqi4_loop>:
    ea46:	99 1f       	adc	r25, r25
    ea48:	96 17       	cp	r25, r22
    ea4a:	08 f0       	brcs	.+2      	; 0xea4e <__udivmodqi4_ep>
    ea4c:	96 1b       	sub	r25, r22

0000ea4e <__udivmodqi4_ep>:
    ea4e:	88 1f       	adc	r24, r24
    ea50:	7a 95       	dec	r23
    ea52:	c9 f7       	brne	.-14     	; 0xea46 <__udivmodqi4_loop>
    ea54:	80 95       	com	r24
    ea56:	08 95       	ret

0000ea58 <__udivmodhi4>:
    ea58:	aa 1b       	sub	r26, r26
    ea5a:	bb 1b       	sub	r27, r27
    ea5c:	51 e1       	ldi	r21, 0x11	; 17
    ea5e:	07 c0       	rjmp	.+14     	; 0xea6e <__udivmodhi4_ep>

0000ea60 <__udivmodhi4_loop>:
    ea60:	aa 1f       	adc	r26, r26
    ea62:	bb 1f       	adc	r27, r27
    ea64:	a6 17       	cp	r26, r22
    ea66:	b7 07       	cpc	r27, r23
    ea68:	10 f0       	brcs	.+4      	; 0xea6e <__udivmodhi4_ep>
    ea6a:	a6 1b       	sub	r26, r22
    ea6c:	b7 0b       	sbc	r27, r23

0000ea6e <__udivmodhi4_ep>:
    ea6e:	88 1f       	adc	r24, r24
    ea70:	99 1f       	adc	r25, r25
    ea72:	5a 95       	dec	r21
    ea74:	a9 f7       	brne	.-22     	; 0xea60 <__udivmodhi4_loop>
    ea76:	80 95       	com	r24
    ea78:	90 95       	com	r25
    ea7a:	bc 01       	movw	r22, r24
    ea7c:	cd 01       	movw	r24, r26
    ea7e:	08 95       	ret

0000ea80 <__divmodhi4>:
    ea80:	97 fb       	bst	r25, 7
    ea82:	07 2e       	mov	r0, r23
    ea84:	16 f4       	brtc	.+4      	; 0xea8a <__divmodhi4+0xa>
    ea86:	00 94       	com	r0
    ea88:	07 d0       	rcall	.+14     	; 0xea98 <__divmodhi4_neg1>
    ea8a:	77 fd       	sbrc	r23, 7
    ea8c:	09 d0       	rcall	.+18     	; 0xeaa0 <__divmodhi4_neg2>
    ea8e:	0e 94 2c 75 	call	0xea58	; 0xea58 <__udivmodhi4>
    ea92:	07 fc       	sbrc	r0, 7
    ea94:	05 d0       	rcall	.+10     	; 0xeaa0 <__divmodhi4_neg2>
    ea96:	3e f4       	brtc	.+14     	; 0xeaa6 <__divmodhi4_exit>

0000ea98 <__divmodhi4_neg1>:
    ea98:	90 95       	com	r25
    ea9a:	81 95       	neg	r24
    ea9c:	9f 4f       	sbci	r25, 0xFF	; 255
    ea9e:	08 95       	ret

0000eaa0 <__divmodhi4_neg2>:
    eaa0:	70 95       	com	r23
    eaa2:	61 95       	neg	r22
    eaa4:	7f 4f       	sbci	r23, 0xFF	; 255

0000eaa6 <__divmodhi4_exit>:
    eaa6:	08 95       	ret

0000eaa8 <__udivmodsi4>:
    eaa8:	a1 e2       	ldi	r26, 0x21	; 33
    eaaa:	1a 2e       	mov	r1, r26
    eaac:	aa 1b       	sub	r26, r26
    eaae:	bb 1b       	sub	r27, r27
    eab0:	fd 01       	movw	r30, r26
    eab2:	0d c0       	rjmp	.+26     	; 0xeace <__udivmodsi4_ep>

0000eab4 <__udivmodsi4_loop>:
    eab4:	aa 1f       	adc	r26, r26
    eab6:	bb 1f       	adc	r27, r27
    eab8:	ee 1f       	adc	r30, r30
    eaba:	ff 1f       	adc	r31, r31
    eabc:	a2 17       	cp	r26, r18
    eabe:	b3 07       	cpc	r27, r19
    eac0:	e4 07       	cpc	r30, r20
    eac2:	f5 07       	cpc	r31, r21
    eac4:	20 f0       	brcs	.+8      	; 0xeace <__udivmodsi4_ep>
    eac6:	a2 1b       	sub	r26, r18
    eac8:	b3 0b       	sbc	r27, r19
    eaca:	e4 0b       	sbc	r30, r20
    eacc:	f5 0b       	sbc	r31, r21

0000eace <__udivmodsi4_ep>:
    eace:	66 1f       	adc	r22, r22
    ead0:	77 1f       	adc	r23, r23
    ead2:	88 1f       	adc	r24, r24
    ead4:	99 1f       	adc	r25, r25
    ead6:	1a 94       	dec	r1
    ead8:	69 f7       	brne	.-38     	; 0xeab4 <__udivmodsi4_loop>
    eada:	60 95       	com	r22
    eadc:	70 95       	com	r23
    eade:	80 95       	com	r24
    eae0:	90 95       	com	r25
    eae2:	9b 01       	movw	r18, r22
    eae4:	ac 01       	movw	r20, r24
    eae6:	bd 01       	movw	r22, r26
    eae8:	cf 01       	movw	r24, r30
    eaea:	08 95       	ret

0000eaec <__divmodsi4>:
    eaec:	05 2e       	mov	r0, r21
    eaee:	97 fb       	bst	r25, 7
    eaf0:	1e f4       	brtc	.+6      	; 0xeaf8 <__divmodsi4+0xc>
    eaf2:	00 94       	com	r0
    eaf4:	0e 94 8d 75 	call	0xeb1a	; 0xeb1a <__negsi2>
    eaf8:	57 fd       	sbrc	r21, 7
    eafa:	07 d0       	rcall	.+14     	; 0xeb0a <__divmodsi4_neg2>
    eafc:	0e 94 54 75 	call	0xeaa8	; 0xeaa8 <__udivmodsi4>
    eb00:	07 fc       	sbrc	r0, 7
    eb02:	03 d0       	rcall	.+6      	; 0xeb0a <__divmodsi4_neg2>
    eb04:	4e f4       	brtc	.+18     	; 0xeb18 <__divmodsi4_exit>
    eb06:	0c 94 8d 75 	jmp	0xeb1a	; 0xeb1a <__negsi2>

0000eb0a <__divmodsi4_neg2>:
    eb0a:	50 95       	com	r21
    eb0c:	40 95       	com	r20
    eb0e:	30 95       	com	r19
    eb10:	21 95       	neg	r18
    eb12:	3f 4f       	sbci	r19, 0xFF	; 255
    eb14:	4f 4f       	sbci	r20, 0xFF	; 255
    eb16:	5f 4f       	sbci	r21, 0xFF	; 255

0000eb18 <__divmodsi4_exit>:
    eb18:	08 95       	ret

0000eb1a <__negsi2>:
    eb1a:	90 95       	com	r25
    eb1c:	80 95       	com	r24
    eb1e:	70 95       	com	r23
    eb20:	61 95       	neg	r22
    eb22:	7f 4f       	sbci	r23, 0xFF	; 255
    eb24:	8f 4f       	sbci	r24, 0xFF	; 255
    eb26:	9f 4f       	sbci	r25, 0xFF	; 255
    eb28:	08 95       	ret

0000eb2a <__tablejump2__>:
    eb2a:	ee 0f       	add	r30, r30
    eb2c:	ff 1f       	adc	r31, r31

0000eb2e <__tablejump__>:
    eb2e:	05 90       	lpm	r0, Z+
    eb30:	f4 91       	lpm	r31, Z
    eb32:	e0 2d       	mov	r30, r0
    eb34:	09 94       	ijmp

0000eb36 <__muluhisi3>:
    eb36:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    eb3a:	a5 9f       	mul	r26, r21
    eb3c:	90 0d       	add	r25, r0
    eb3e:	b4 9f       	mul	r27, r20
    eb40:	90 0d       	add	r25, r0
    eb42:	a4 9f       	mul	r26, r20
    eb44:	80 0d       	add	r24, r0
    eb46:	91 1d       	adc	r25, r1
    eb48:	11 24       	eor	r1, r1
    eb4a:	08 95       	ret

0000eb4c <__mulshisi3>:
    eb4c:	b7 ff       	sbrs	r27, 7
    eb4e:	0c 94 9b 75 	jmp	0xeb36	; 0xeb36 <__muluhisi3>

0000eb52 <__mulohisi3>:
    eb52:	0e 94 9b 75 	call	0xeb36	; 0xeb36 <__muluhisi3>
    eb56:	82 1b       	sub	r24, r18
    eb58:	93 0b       	sbc	r25, r19
    eb5a:	08 95       	ret

0000eb5c <__muldi3>:
    eb5c:	df 93       	push	r29
    eb5e:	cf 93       	push	r28
    eb60:	1f 93       	push	r17
    eb62:	0f 93       	push	r16
    eb64:	9a 9d       	mul	r25, r10
    eb66:	f0 2d       	mov	r31, r0
    eb68:	21 9f       	mul	r18, r17
    eb6a:	f0 0d       	add	r31, r0
    eb6c:	8b 9d       	mul	r24, r11
    eb6e:	f0 0d       	add	r31, r0
    eb70:	8a 9d       	mul	r24, r10
    eb72:	e0 2d       	mov	r30, r0
    eb74:	f1 0d       	add	r31, r1
    eb76:	03 9f       	mul	r16, r19
    eb78:	f0 0d       	add	r31, r0
    eb7a:	02 9f       	mul	r16, r18
    eb7c:	e0 0d       	add	r30, r0
    eb7e:	f1 1d       	adc	r31, r1
    eb80:	4e 9d       	mul	r20, r14
    eb82:	e0 0d       	add	r30, r0
    eb84:	f1 1d       	adc	r31, r1
    eb86:	5e 9d       	mul	r21, r14
    eb88:	f0 0d       	add	r31, r0
    eb8a:	4f 9d       	mul	r20, r15
    eb8c:	f0 0d       	add	r31, r0
    eb8e:	7f 93       	push	r23
    eb90:	6f 93       	push	r22
    eb92:	bf 92       	push	r11
    eb94:	af 92       	push	r10
    eb96:	5f 93       	push	r21
    eb98:	4f 93       	push	r20
    eb9a:	d5 01       	movw	r26, r10
    eb9c:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    eba0:	8b 01       	movw	r16, r22
    eba2:	ac 01       	movw	r20, r24
    eba4:	d7 01       	movw	r26, r14
    eba6:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    ebaa:	eb 01       	movw	r28, r22
    ebac:	e8 0f       	add	r30, r24
    ebae:	f9 1f       	adc	r31, r25
    ebb0:	d6 01       	movw	r26, r12
    ebb2:	0e 94 fe 75 	call	0xebfc	; 0xebfc <__muldi3_6>
    ebb6:	2f 91       	pop	r18
    ebb8:	3f 91       	pop	r19
    ebba:	d6 01       	movw	r26, r12
    ebbc:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    ebc0:	c6 0f       	add	r28, r22
    ebc2:	d7 1f       	adc	r29, r23
    ebc4:	e8 1f       	adc	r30, r24
    ebc6:	f9 1f       	adc	r31, r25
    ebc8:	af 91       	pop	r26
    ebca:	bf 91       	pop	r27
    ebcc:	0e 94 fe 75 	call	0xebfc	; 0xebfc <__muldi3_6>
    ebd0:	2f 91       	pop	r18
    ebd2:	3f 91       	pop	r19
    ebd4:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    ebd8:	c6 0f       	add	r28, r22
    ebda:	d7 1f       	adc	r29, r23
    ebdc:	e8 1f       	adc	r30, r24
    ebde:	f9 1f       	adc	r31, r25
    ebe0:	d6 01       	movw	r26, r12
    ebe2:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    ebe6:	e6 0f       	add	r30, r22
    ebe8:	f7 1f       	adc	r31, r23
    ebea:	98 01       	movw	r18, r16
    ebec:	be 01       	movw	r22, r28
    ebee:	cf 01       	movw	r24, r30
    ebf0:	11 24       	eor	r1, r1
    ebf2:	0f 91       	pop	r16
    ebf4:	1f 91       	pop	r17
    ebf6:	cf 91       	pop	r28
    ebf8:	df 91       	pop	r29
    ebfa:	08 95       	ret

0000ebfc <__muldi3_6>:
    ebfc:	0e 94 10 76 	call	0xec20	; 0xec20 <__umulhisi3>
    ec00:	46 0f       	add	r20, r22
    ec02:	57 1f       	adc	r21, r23
    ec04:	c8 1f       	adc	r28, r24
    ec06:	d9 1f       	adc	r29, r25
    ec08:	08 f4       	brcc	.+2      	; 0xec0c <__muldi3_6+0x10>
    ec0a:	31 96       	adiw	r30, 0x01	; 1
    ec0c:	08 95       	ret

0000ec0e <__adddi3>:
    ec0e:	2a 0d       	add	r18, r10
    ec10:	3b 1d       	adc	r19, r11
    ec12:	4c 1d       	adc	r20, r12
    ec14:	5d 1d       	adc	r21, r13
    ec16:	6e 1d       	adc	r22, r14
    ec18:	7f 1d       	adc	r23, r15
    ec1a:	80 1f       	adc	r24, r16
    ec1c:	91 1f       	adc	r25, r17
    ec1e:	08 95       	ret

0000ec20 <__umulhisi3>:
    ec20:	a2 9f       	mul	r26, r18
    ec22:	b0 01       	movw	r22, r0
    ec24:	b3 9f       	mul	r27, r19
    ec26:	c0 01       	movw	r24, r0
    ec28:	a3 9f       	mul	r26, r19
    ec2a:	70 0d       	add	r23, r0
    ec2c:	81 1d       	adc	r24, r1
    ec2e:	11 24       	eor	r1, r1
    ec30:	91 1d       	adc	r25, r1
    ec32:	b2 9f       	mul	r27, r18
    ec34:	70 0d       	add	r23, r0
    ec36:	81 1d       	adc	r24, r1
    ec38:	11 24       	eor	r1, r1
    ec3a:	91 1d       	adc	r25, r1
    ec3c:	08 95       	ret

0000ec3e <_exit>:
    ec3e:	f8 94       	cli

0000ec40 <__stop_program>:
    ec40:	ff cf       	rjmp	.-2      	; 0xec40 <__stop_program>
