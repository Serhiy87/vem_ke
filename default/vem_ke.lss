
vem_ke.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000134  00800100  0000eb5e  0000ec12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000eb5e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c05  00800234  00800234  0000ed46  2**0
                  ALLOC
  3 .eeprom       000001ac  00810000  00810000  0000ed46  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  0000eef2  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000009d8  00000000  00000000  0000ef4e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001494a  00000000  00000000  0000f926  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d8  00000000  00000000  00024270  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e32  00000000  00000000  00024c48  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000024d8  00000000  00000000  00028a7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000420d  00000000  00000000  0002af54  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000ff88  00000000  00000000  0002f161  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d28  00000000  00000000  0003f0e9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f3 27 	jmp	0x4fe6	; 0x4fe6 <__ctors_end>
       4:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
       8:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
       c:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      10:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      14:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      18:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      1c:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      20:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      24:	0c 94 da 2e 	jmp	0x5db4	; 0x5db4 <__vector_9>
      28:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      2c:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      30:	0c 94 fe 2c 	jmp	0x59fc	; 0x59fc <__vector_12>
      34:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      38:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      3c:	0c 94 aa 2e 	jmp	0x5d54	; 0x5d54 <__vector_15>
      40:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      44:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      48:	0c 94 23 57 	jmp	0xae46	; 0xae46 <__vector_18>
      4c:	0c 94 95 69 	jmp	0xd32a	; 0xd32a <__vector_19>
      50:	0c 94 47 3b 	jmp	0x768e	; 0x768e <__vector_20>
      54:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      58:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      5c:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      60:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      64:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      68:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      6c:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      70:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      74:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      78:	0c 94 34 4c 	jmp	0x9868	; 0x9868 <__vector_30>
      7c:	0c 94 5c 6a 	jmp	0xd4b8	; 0xd4b8 <__vector_31>
      80:	0c 94 77 4c 	jmp	0x98ee	; 0x98ee <__vector_32>
      84:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      88:	0c 94 12 28 	jmp	0x5024	; 0x5024 <__bad_interrupt>
      8c:	9d 32       	cpi	r25, 0x2D	; 45
      8e:	9d 32       	cpi	r25, 0x2D	; 45
      90:	29 33       	cpi	r18, 0x39	; 57
      92:	29 33       	cpi	r18, 0x39	; 57
      94:	85 34       	cpi	r24, 0x45	; 69
      96:	84 33       	cpi	r24, 0x34	; 52
      98:	85 34       	cpi	r24, 0x45	; 69
      9a:	85 34       	cpi	r24, 0x45	; 69
      9c:	85 34       	cpi	r24, 0x45	; 69
      9e:	85 34       	cpi	r24, 0x45	; 69
      a0:	85 34       	cpi	r24, 0x45	; 69
      a2:	85 34       	cpi	r24, 0x45	; 69
      a4:	85 34       	cpi	r24, 0x45	; 69
      a6:	85 34       	cpi	r24, 0x45	; 69
      a8:	b3 33       	cpi	r27, 0x33	; 51
      aa:	2c 34       	cpi	r18, 0x4C	; 76
      ac:	22 36       	cpi	r18, 0x62	; 98
      ae:	22 36       	cpi	r18, 0x62	; 98
      b0:	b8 36       	cpi	r27, 0x68	; 104
      b2:	b8 36       	cpi	r27, 0x68	; 104
      b4:	c9 37       	cpi	r28, 0x79	; 121
      b6:	24 37       	cpi	r18, 0x74	; 116
      b8:	c9 37       	cpi	r28, 0x79	; 121
      ba:	c9 37       	cpi	r28, 0x79	; 121
      bc:	c9 37       	cpi	r28, 0x79	; 121
      be:	c9 37       	cpi	r28, 0x79	; 121
      c0:	c9 37       	cpi	r28, 0x79	; 121
      c2:	c9 37       	cpi	r28, 0x79	; 121
      c4:	c9 37       	cpi	r28, 0x79	; 121
      c6:	c9 37       	cpi	r28, 0x79	; 121
      c8:	77 37       	cpi	r23, 0x77	; 119
      ca:	77 37       	cpi	r23, 0x77	; 119
      cc:	0b 44       	sbci	r16, 0x4B	; 75
      ce:	36 44       	sbci	r19, 0x46	; 70
      d0:	6a 44       	sbci	r22, 0x4A	; 74
      d2:	a0 44       	sbci	r26, 0x40	; 64
      d4:	0b 44       	sbci	r16, 0x4B	; 75
      d6:	36 44       	sbci	r19, 0x46	; 70
      d8:	f6 46       	sbci	r31, 0x66	; 102
      da:	c2 44       	sbci	r28, 0x42	; 66
      dc:	eb 44       	sbci	r30, 0x4B	; 75
      de:	1d 45       	sbci	r17, 0x5D	; 93
      e0:	56 45       	sbci	r21, 0x56	; 86
      e2:	c2 44       	sbci	r28, 0x42	; 66
      e4:	eb 44       	sbci	r30, 0x4B	; 75
      e6:	80 45       	sbci	r24, 0x50	; 80
      e8:	80 45       	sbci	r24, 0x50	; 80
      ea:	f6 46       	sbci	r31, 0x66	; 102
      ec:	84 45       	sbci	r24, 0x54	; 84
      ee:	8f 45       	sbci	r24, 0x5F	; 95
      f0:	9a 45       	sbci	r25, 0x5A	; 90
      f2:	ce 45       	sbci	r28, 0x5E	; 94
      f4:	84 45       	sbci	r24, 0x54	; 84
      f6:	8f 45       	sbci	r24, 0x5F	; 95
      f8:	f6 46       	sbci	r31, 0x66	; 102
      fa:	f6 46       	sbci	r31, 0x66	; 102
      fc:	f6 46       	sbci	r31, 0x66	; 102
      fe:	fe 45       	sbci	r31, 0x5E	; 94
     100:	1a 46       	sbci	r17, 0x6A	; 106
     102:	fe 45       	sbci	r31, 0x5E	; 94
     104:	1a 46       	sbci	r17, 0x6A	; 106
     106:	38 46       	sbci	r19, 0x68	; 104
     108:	3b 46       	sbci	r19, 0x6B	; 107
     10a:	42 46       	sbci	r20, 0x62	; 98
     10c:	64 46       	sbci	r22, 0x64	; 100
     10e:	88 46       	sbci	r24, 0x68	; 104
     110:	bd 46       	sbci	r27, 0x6D	; 109
     112:	6d 47       	sbci	r22, 0x7D	; 125
     114:	71 47       	sbci	r23, 0x71	; 113
     116:	76 47       	sbci	r23, 0x76	; 118
     118:	7b 47       	sbci	r23, 0x7B	; 123
     11a:	80 47       	sbci	r24, 0x70	; 112
     11c:	85 47       	sbci	r24, 0x75	; 117
     11e:	89 47       	sbci	r24, 0x79	; 121
     120:	8d 47       	sbci	r24, 0x7D	; 125
     122:	93 47       	sbci	r25, 0x73	; 115
     124:	a9 47       	sbci	r26, 0x79	; 121
     126:	ad 47       	sbci	r26, 0x7D	; 125
     128:	b2 47       	sbci	r27, 0x72	; 114
     12a:	b6 47       	sbci	r27, 0x76	; 118
     12c:	bb 47       	sbci	r27, 0x7B	; 123
     12e:	c0 47       	sbci	r28, 0x70	; 112
     130:	c5 47       	sbci	r28, 0x75	; 117
     132:	ca 47       	sbci	r28, 0x7A	; 122
     134:	d0 47       	sbci	r29, 0x70	; 112
     136:	e5 47       	sbci	r30, 0x75	; 117
     138:	e9 47       	sbci	r30, 0x79	; 121
     13a:	ee 47       	sbci	r30, 0x7E	; 126
     13c:	f3 47       	sbci	r31, 0x73	; 115
     13e:	f8 47       	sbci	r31, 0x78	; 120
     140:	fc 47       	sbci	r31, 0x7C	; 124
     142:	01 48       	sbci	r16, 0x81	; 129
     144:	06 48       	sbci	r16, 0x86	; 134
     146:	0b 48       	sbci	r16, 0x8B	; 139
     148:	11 48       	sbci	r17, 0x81	; 129
     14a:	cc 4a       	sbci	r28, 0xAC	; 172
     14c:	d1 4a       	sbci	r29, 0xA1	; 161
     14e:	d6 4a       	sbci	r29, 0xA6	; 166
     150:	ee 4a       	sbci	r30, 0xAE	; 174
     152:	da 4a       	sbci	r29, 0xAA	; 170
     154:	de 4a       	sbci	r29, 0xAE	; 174
     156:	e2 4a       	sbci	r30, 0xA2	; 162
     158:	e6 4a       	sbci	r30, 0xA6	; 166
     15a:	ea 4a       	sbci	r30, 0xAA	; 170
     15c:	8a 52       	subi	r24, 0x2A	; 42
     15e:	12 53       	subi	r17, 0x32	; 50
     160:	86 52       	subi	r24, 0x26	; 38
     162:	16 53       	subi	r17, 0x36	; 54
     164:	b2 52       	subi	r27, 0x22	; 34
     166:	b6 52       	subi	r27, 0x26	; 38
     168:	ba 52       	subi	r27, 0x2A	; 42
     16a:	be 52       	subi	r27, 0x2E	; 46
     16c:	c2 52       	subi	r28, 0x22	; 34
     16e:	c6 52       	subi	r28, 0x26	; 38
     170:	ca 52       	subi	r28, 0x2A	; 42
     172:	ce 52       	subi	r28, 0x2E	; 46
     174:	d2 52       	subi	r29, 0x22	; 34
     176:	d6 52       	subi	r29, 0x26	; 38
     178:	da 52       	subi	r29, 0x2A	; 42
     17a:	de 52       	subi	r29, 0x2E	; 46
     17c:	e2 52       	subi	r30, 0x22	; 34
     17e:	e6 52       	subi	r30, 0x26	; 38
     180:	ea 52       	subi	r30, 0x2A	; 42
     182:	ee 52       	subi	r30, 0x2E	; 46
     184:	f2 52       	subi	r31, 0x22	; 34
     186:	f6 52       	subi	r31, 0x26	; 38
     188:	6a 53       	subi	r22, 0x3A	; 58
     18a:	6e 53       	subi	r22, 0x3E	; 62
     18c:	72 53       	subi	r23, 0x32	; 50
     18e:	76 53       	subi	r23, 0x36	; 54
     190:	7a 53       	subi	r23, 0x3A	; 58
     192:	7e 53       	subi	r23, 0x3E	; 62
     194:	82 53       	subi	r24, 0x32	; 50
     196:	86 53       	subi	r24, 0x36	; 54
     198:	8a 53       	subi	r24, 0x3A	; 58
     19a:	8e 53       	subi	r24, 0x3E	; 62
     19c:	92 53       	subi	r25, 0x32	; 50
     19e:	96 53       	subi	r25, 0x36	; 54
     1a0:	f7 57       	subi	r31, 0x77	; 119
     1a2:	12 58       	subi	r17, 0x82	; 130
     1a4:	22 58       	subi	r18, 0x82	; 130
     1a6:	2f 58       	subi	r18, 0x8F	; 143
     1a8:	70 64       	ori	r23, 0x40	; 64
     1aa:	70 64       	ori	r23, 0x40	; 64
     1ac:	59 58       	subi	r21, 0x89	; 137
     1ae:	70 58       	subi	r23, 0x80	; 128
     1b0:	80 58       	subi	r24, 0x80	; 128
     1b2:	8d 58       	subi	r24, 0x8D	; 141
     1b4:	9d 58       	subi	r25, 0x8D	; 141
     1b6:	aa 58       	subi	r26, 0x8A	; 138
     1b8:	ba 58       	subi	r27, 0x8A	; 138
     1ba:	c9 58       	subi	r28, 0x89	; 137
     1bc:	46 59       	subi	r20, 0x96	; 150
     1be:	56 59       	subi	r21, 0x96	; 150
     1c0:	63 59       	subi	r22, 0x93	; 147
     1c2:	73 59       	subi	r23, 0x93	; 147
     1c4:	80 59       	subi	r24, 0x90	; 144
     1c6:	90 59       	subi	r25, 0x90	; 144
     1c8:	9d 59       	subi	r25, 0x9D	; 157
     1ca:	ad 59       	subi	r26, 0x9D	; 157
     1cc:	ba 59       	subi	r27, 0x9A	; 154
     1ce:	d0 59       	subi	r29, 0x90	; 144
     1d0:	d9 59       	subi	r29, 0x99	; 153
     1d2:	eb 59       	subi	r30, 0x9B	; 155
     1d4:	02 5a       	subi	r16, 0xA2	; 162
     1d6:	7a 5a       	subi	r23, 0xAA	; 170
     1d8:	8a 5a       	subi	r24, 0xAA	; 170
     1da:	97 5a       	subi	r25, 0xA7	; 167
     1dc:	a7 5a       	subi	r26, 0xA7	; 167
     1de:	b4 5a       	subi	r27, 0xA4	; 164
     1e0:	c4 5a       	subi	r28, 0xA4	; 164
     1e2:	d1 5a       	subi	r29, 0xA1	; 161
     1e4:	33 5b       	subi	r19, 0xB3	; 179
     1e6:	92 5b       	subi	r25, 0xB2	; 178
     1e8:	a0 5b       	subi	r26, 0xB0	; 176
     1ea:	ae 5b       	subi	r26, 0xBE	; 190
     1ec:	d4 5b       	subi	r29, 0xB4	; 180
     1ee:	fa 5b       	subi	r31, 0xBA	; 186
     1f0:	05 5c       	subi	r16, 0xC5	; 197
     1f2:	13 5c       	subi	r17, 0xC3	; 195
     1f4:	1e 5c       	subi	r17, 0xCE	; 206
     1f6:	49 5c       	subi	r20, 0xC9	; 201
     1f8:	d9 5c       	subi	r29, 0xC9	; 201
     1fa:	e7 5c       	subi	r30, 0xC7	; 199
     1fc:	15 5d       	subi	r17, 0xD5	; 213
     1fe:	5c 5d       	subi	r21, 0xDC	; 220
     200:	6a 5d       	subi	r22, 0xDA	; 218
     202:	76 5d       	subi	r23, 0xD6	; 214
     204:	e3 5d       	subi	r30, 0xD3	; 211
     206:	72 5e       	subi	r23, 0xE2	; 226
     208:	31 5f       	subi	r19, 0xF1	; 241
     20a:	44 5f       	subi	r20, 0xF4	; 244
     20c:	50 5f       	subi	r21, 0xF0	; 240
     20e:	a5 5f       	subi	r26, 0xF5	; 245
     210:	0f 60       	ori	r16, 0x0F	; 15
     212:	97 60       	ori	r25, 0x07	; 7
     214:	a4 60       	ori	r26, 0x04	; 4
     216:	b7 60       	ori	r27, 0x07	; 7
     218:	d0 60       	ori	r29, 0x00	; 0
     21a:	3d 61       	ori	r19, 0x1D	; 29
     21c:	73 61       	ori	r23, 0x13	; 19
     21e:	ae 61       	ori	r26, 0x1E	; 30
     220:	da 61       	ori	r29, 0x1A	; 26
     222:	eb 61       	ori	r30, 0x1B	; 27
     224:	f7 61       	ori	r31, 0x17	; 23
     226:	70 64       	ori	r23, 0x40	; 64
     228:	70 64       	ori	r23, 0x40	; 64
     22a:	70 64       	ori	r23, 0x40	; 64
     22c:	70 64       	ori	r23, 0x40	; 64
     22e:	70 64       	ori	r23, 0x40	; 64
     230:	70 64       	ori	r23, 0x40	; 64
     232:	70 64       	ori	r23, 0x40	; 64
     234:	70 64       	ori	r23, 0x40	; 64
     236:	70 64       	ori	r23, 0x40	; 64
     238:	70 64       	ori	r23, 0x40	; 64
     23a:	70 64       	ori	r23, 0x40	; 64
     23c:	70 64       	ori	r23, 0x40	; 64
     23e:	70 64       	ori	r23, 0x40	; 64
     240:	bf 5f       	subi	r27, 0xFF	; 255
     242:	cb 5f       	subi	r28, 0xFB	; 251
     244:	d7 5f       	subi	r29, 0xF7	; 247
     246:	e3 5f       	subi	r30, 0xF3	; 243
     248:	f1 5f       	subi	r31, 0xF1	; 241
     24a:	fd 5f       	subi	r31, 0xFD	; 253
     24c:	70 64       	ori	r23, 0x40	; 64
     24e:	70 64       	ori	r23, 0x40	; 64
     250:	1c 62       	ori	r17, 0x2C	; 44
     252:	3e 62       	ori	r19, 0x2E	; 46
     254:	48 62       	ori	r20, 0x28	; 40
     256:	54 62       	ori	r21, 0x24	; 36
     258:	62 62       	ori	r22, 0x22	; 34
     25a:	6e 62       	ori	r22, 0x2E	; 46
     25c:	7e 62       	ori	r23, 0x2E	; 46
     25e:	9e 62       	ori	r25, 0x2E	; 46
     260:	c2 62       	ori	r28, 0x22	; 34
     262:	10 63       	ori	r17, 0x30	; 48
     264:	1c 63       	ori	r17, 0x3C	; 60
     266:	46 63       	ori	r20, 0x36	; 54
     268:	68 63       	ori	r22, 0x38	; 56
     26a:	b1 63       	ori	r27, 0x31	; 49
     26c:	bd 63       	ori	r27, 0x3D	; 61
     26e:	d2 63       	ori	r29, 0x32	; 50
     270:	de 63       	ori	r29, 0x3E	; 62
     272:	f6 63       	ori	r31, 0x36	; 54
     274:	04 64       	ori	r16, 0x44	; 68
     276:	16 64       	ori	r17, 0x46	; 70
     278:	24 64       	ori	r18, 0x44	; 68
     27a:	30 64       	ori	r19, 0x40	; 64
     27c:	43 64       	ori	r20, 0x43	; 67
     27e:	4f 64       	ori	r20, 0x4F	; 79
     280:	62 64       	ori	r22, 0x42	; 66
     282:	70 64       	ori	r23, 0x40	; 64
     284:	7d 67       	ori	r23, 0x7D	; 125
     286:	7f 67       	ori	r23, 0x7F	; 127
     288:	8a 67       	ori	r24, 0x7A	; 122
     28a:	8c 67       	ori	r24, 0x7C	; 124
     28c:	99 67       	ori	r25, 0x79	; 121
     28e:	9b 67       	ori	r25, 0x7B	; 123
     290:	a6 67       	ori	r26, 0x76	; 118
     292:	d8 67       	ori	r29, 0x78	; 120
     294:	df 67       	ori	r29, 0x7F	; 127
     296:	e7 67       	ori	r30, 0x77	; 119
     298:	ee 67       	ori	r30, 0x7E	; 126
     29a:	f6 67       	ori	r31, 0x76	; 118
     29c:	fd 67       	ori	r31, 0x7D	; 125
     29e:	d8 67       	ori	r29, 0x78	; 120
     2a0:	f6 67       	ori	r31, 0x76	; 118
     2a2:	af 67       	ori	r26, 0x7F	; 127
     2a4:	05 68       	ori	r16, 0x85	; 133
     2a6:	0a 68       	ori	r16, 0x8A	; 138
     2a8:	13 68       	ori	r17, 0x83	; 131
     2aa:	18 68       	ori	r17, 0x88	; 136
     2ac:	21 68       	ori	r18, 0x81	; 129
     2ae:	26 68       	ori	r18, 0x86	; 134
     2b0:	05 68       	ori	r16, 0x85	; 133
     2b2:	21 68       	ori	r18, 0x81	; 129
     2b4:	ba 67       	ori	r27, 0x7A	; 122
     2b6:	2f 68       	ori	r18, 0x8F	; 143
     2b8:	34 68       	ori	r19, 0x84	; 132
     2ba:	45 68       	ori	r20, 0x85	; 133
     2bc:	4a 68       	ori	r20, 0x8A	; 138
     2be:	5b 68       	ori	r21, 0x8B	; 139
     2c0:	5d 68       	ori	r21, 0x8D	; 141
     2c2:	6b 68       	ori	r22, 0x8B	; 139
     2c4:	75 68       	ori	r23, 0x85	; 133
     2c6:	9b 68       	ori	r25, 0x8B	; 139
     2c8:	a2 68       	ori	r26, 0x82	; 130

000002ca <__trampolines_end>:
     2ca:	ed e5       	ldi	r30, 0x5D	; 93
     2cc:	f2 20       	and	r15, r2
     2ce:	f1 e2       	ldi	r31, 0x21	; 33
     2d0:	ff e7       	ldi	r31, 0x7F	; 127
     2d2:	e8 20       	and	r14, r8
     2d4:	f1 20       	and	r15, r1
     2d6:	dd d1       	rcall	.+954    	; 0x692 <system_page+0x4c>
     2d8:	20 00       	.word	0x0020	; ????

000002da <__c.5163>:
     2da:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000002ea <__c.5161>:
     2ea:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000002f5 <__c.4708>:
     2f5:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

000002ff <__c.4706>:
     2ff:	25 30 38 6c 78 00                                   %08lx.

00000305 <__c.4689>:
     305:	25 75 0d 0a 00                                      %u...

0000030a <__c.4590>:
     30a:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

00000316 <__c.4588>:
     316:	2f 00                                               /.

00000318 <__c.3744>:
     318:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

00000328 <__c.3732>:
     328:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
     338:	68 75 00                                            hu.

0000033b <__c.3721>:
     33b:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
     34b:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

00000359 <__c.3696>:
     359:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

00000366 <__c.3672>:
     366:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
     376:	68 68 75 00                                         hhu.

0000037a <__c.3646>:
     37a:	25 75 00                                            %u.

0000037d <__c.3644>:
     37d:	25 6c 75 64 00                                      %lud.

00000382 <aCRCLo.1930>:
     382:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     392:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     3a2:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     3b2:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     3c2:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     3d2:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     3e2:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     3f2:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     402:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     412:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     422:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     432:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     442:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     452:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     462:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     472:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00000482 <aCRCHi.1929>:
     482:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     492:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4a2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4b2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4c2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4d2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4e2:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4f2:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     502:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     512:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     522:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     532:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     542:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     552:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     562:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     572:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00000582 <WebSite>:
     582:	57 45 95 48 e9 33 80 39 d4 1c e0 16 8e 0c 94 05     WE.H.3.9........
     592:	b0 32                                               .2

00000594 <Web_system>:
     594:	82 0c 40 0c 18 00 a1 05 fa 05 46 06 04              ..@.......F..

000005a1 <system_OField>:
     5a1:	40 06 30 06 29 06 19 06 0e 06 fe 05 f4 05 e4 05     @.0.)...........
     5b1:	de 05 ce 05 c9 05 b9 05                             ........

000005b9 <Web_Tlow>:
     5b9:	0a 0b 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005c9 <var_Tlow>:
     5c9:	54 6c 6f 77 00                                      Tlow.

000005ce <Web_Thigh>:
     5ce:	0a 0d 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005de <var_Thigh>:
     5de:	54 68 69 67 68 00                                   Thigh.

000005e4 <Web_BLupgrade>:
     5e4:	00 19 06 00 00 00 00 ff 00 00 00 fa 28 00 00 00     ............(...

000005f4 <var_BLupgrade>:
     5f4:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

000005fe <Web_Bootloader>:
     5fe:	00 19 06 00 00 00 00 ff 00 00 00 c7 29 00 00 00     ............)...

0000060e <var_Bootloader>:
     60e:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

00000619 <Web_Reboot>:
     619:	00 19 06 00 00 00 00 ff 00 00 00 f4 28 00 00 00     ............(...

00000629 <var_Reboot>:
     629:	52 65 62 6f 6f 74 00                                Reboot.

00000630 <Web_Title>:
     630:	22 0f 00 00 00 00 00 02 00 00 00 00 00 00 00 15     "...............

00000640 <var_Title>:
     640:	54 69 74 6c 65 00                                   Title.

00000646 <system_page>:
     646:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     656:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     666:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     676:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     686:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     696:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     6a6:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     6b6:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     6c6:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     6d6:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     6e6:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     6f6:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     706:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     716:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     726:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     736:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     746:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     756:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     766:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     776:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     786:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     796:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     7a6:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     7b6:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     7c6:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     7d6:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     7e6:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     7f6:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     806:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     816:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     826:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     836:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
     846:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
     856:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
     866:	cd e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0     ........ .......
     876:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     886:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74     'text' name='Tit
     896:	6c 65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61     le' size='40' va
     8a6:	6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     lue='{{{{{{{{{{{
     8b6:	7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69     {{{{{{{{{'>...<i
     8c6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     8d6:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
     8e6:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
     8f6:	0d 0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b     ........... :{{{
     906:	7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46     {{{{{{{{ .....<F
     916:	4f 52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     ORM action='/' m
     926:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c     ethod='GET'>...<
     936:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
     946:	69 74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74     it' name='Reboot
     956:	27 20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27     ' value='Reboot'
     966:	3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1     >..</FORM>......
     976:	e8 ff 20 cf ce 3a 20 33 2e 30 37 0d 0a 3c 46 4f     .. ..: 3.07..<FO
     986:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
     996:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
     9a6:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     9b6:	74 27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61     t' name='Bootloa
     9c6:	64 65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74     der' value='Boot
     9d6:	6c 6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52     loader' color='R
     9e6:	45 44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     ED'>..</FORM>..<
     9f6:	2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69     /BR>..<FORM acti
     a06:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
     a16:	45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ET'>...<input ty
     a26:	70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65     pe='submit' name
     a36:	3d 27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c     ='BLupgrade' val
     a46:	75 65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d     ue='BLupgrade'>.
     a56:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
     a66:	0a 3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0     .<H2>...........
     a76:	3c 2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3     </H2>...........
     a86:	f0 e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43     ..:{{{{{{{&#176C
     a96:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
     aa6:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
     ab6:	47 45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff     GET'>...........
     ac6:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     ad6:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69     'text' name='Thi
     ae6:	67 68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c     gh' size='5' val
     af6:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31     ue='{{{{{{{'>&#1
     b06:	37 36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     76C...<input typ
     b16:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
     b26:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
     b36:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
     b46:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
     b56:	27 47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff     'GET'>..........
     b66:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     b76:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f     'text' name='Tlo
     b86:	77 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     w' size='5' valu
     b96:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
     ba6:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
     bb6:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
     bc6:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
     bd6:	3c 2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d     </BR>....... GSM
     be6:	2d 3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32     ->EM: {{{/(max 2
     bf6:	35 30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3     50)....</BR>....
     c06:	f4 e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b     ... EM->GSM: {{{
     c16:	2f 28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f     /(max 250)....</
     c26:	42 52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     BR>....</BODY>..
     c36:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00000c40 <system_IField>:
     c40:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
     c50:	00 00 14 0c 06 00 00 00 22 0f 00 00 00 15 10 50     ........"......P
     c60:	09 00 00 02 09 ec 05 00 00 01 0a 0d 00 00 00 01     ................
     c70:	0a 0b 00 00 00 01 00 6c 09 00 00 00 00 5b 0a 00     .......l.....[..
	...

00000c82 <name_system>:
     c82:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000c8e <Web_csd>:
     c8e:	d7 16 77 16 2c 00 9b 0c c7 08 b0 0d 02              ..w.,........

00000c9b <csd_OField>:
     c9b:	a9 0d 99 0d 94 0d 84 0d 7f 0d 6f 0d 6a 0d 5a 0d     ..........o.j.Z.
     cab:	55 0d 45 0d 40 0d 30 0d 2b 0d 1b 0d 16 0d 06 0d     U.E.@.0.+.......
     cbb:	01 0d f1 0c ec 0c dc 0c d7 0c c7 0c                 ............

00000cc7 <Web_CSD_Number9>:
     cc7:	22 d6 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cd7 <var_CSD_Number9>:
     cd7:	43 53 44 39 00                                      CSD9.

00000cdc <Web_CSD_Number8>:
     cdc:	22 c9 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cec <var_CSD_Number8>:
     cec:	43 53 44 38 00                                      CSD8.

00000cf1 <Web_CSD_Number7>:
     cf1:	22 bc 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d01 <var_CSD_Number7>:
     d01:	43 53 44 37 00                                      CSD7.

00000d06 <Web_CSD_Number6>:
     d06:	22 af 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d16 <var_CSD_Number6>:
     d16:	43 53 44 36 00                                      CSD6.

00000d1b <Web_CSD_Number5>:
     d1b:	22 a2 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d2b <var_CSD_Number5>:
     d2b:	43 53 44 35 00                                      CSD5.

00000d30 <Web_CSD_Number4>:
     d30:	22 95 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d40 <var_CSD_Number4>:
     d40:	43 53 44 34 00                                      CSD4.

00000d45 <Web_CSD_Number3>:
     d45:	22 88 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d55 <var_CSD_Number3>:
     d55:	43 53 44 33 00                                      CSD3.

00000d5a <Web_CSD_Number2>:
     d5a:	22 7b 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "{..............

00000d6a <var_CSD_Number2>:
     d6a:	43 53 44 32 00                                      CSD2.

00000d6f <Web_CSD_Number1>:
     d6f:	22 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "n..............

00000d7f <var_CSD_Number1>:
     d7f:	43 53 44 31 00                                      CSD1.

00000d84 <Web_CSD_Number0>:
     d84:	22 61 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "a..............

00000d94 <var_CSD_Number0>:
     d94:	43 53 44 30 00                                      CSD0.

00000d99 <Web_CLIP>:
     d99:	01 5f 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ._..............

00000da9 <var_CLIP>:
     da9:	43 4c 49 50 4f 6e 00                                CLIPOn.

00000db0 <csd_page>:
     db0:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     dc0:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     dd0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     de0:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     df0:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     e00:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     e10:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     e20:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     e30:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     e40:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     e50:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     e60:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     e70:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     e80:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     e90:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     ea0:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     eb0:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     ec0:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     ed0:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     ee0:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     ef0:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     f00:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     f10:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     f20:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     f30:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     f40:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     f50:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     f60:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     f70:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     f80:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     f90:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     fa0:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f     .</a>..<HR>..<fo
     fb0:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
     fc0:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0     thod='GET'>.....
     fd0:	ee e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a     ...... ......:..
     fe0:	09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43     .<SELECT NAME="C
     ff0:	4c 49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49     LIPOn"> ...<OPTI
    1000:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    1010:	7b 7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49     {{{>... ...<OPTI
    1020:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    1030:	7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43     {{{>.....</SELEC
    1040:	54 3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T> ...<input typ
    1050:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    1060:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    1070:	0a 3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5     .<h3>...........
    1080:	20 ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52      ......</h3></BR
    1090:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    10a0:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10b0:	3e 0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75     >....1: ...<inpu
    10c0:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    10d0:	6d 65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27     me='CSD0' size='
    10e0:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    10f0:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1100:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1110:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1120:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1130:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1140:	47 45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c     GET'>....2: ...<
    1150:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1160:	27 20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69     ' name='CSD1' si
    1170:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    1180:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    1190:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    11a0:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    11b0:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    11c0:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    11d0:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20     od='GET'>....3: 
    11e0:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    11f0:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32     text' name='CSD2
    1200:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1210:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1220:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1230:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1240:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    1250:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    1260:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    1270:	b9 34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .4: ...<input ty
    1280:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    1290:	43 53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD3' size='12' 
    12a0:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    12b0:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    12c0:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    12d0:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    12e0:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    12f0:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1300:	3e 0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75     >....5: ...<inpu
    1310:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1320:	6d 65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27     me='CSD4' size='
    1330:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1340:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1350:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1360:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1370:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1380:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1390:	47 45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c     GET'>....6: ...<
    13a0:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    13b0:	27 20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69     ' name='CSD5' si
    13c0:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    13d0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    13e0:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    13f0:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    1400:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    1410:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1420:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20     od='GET'>....7: 
    1430:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    1440:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36     text' name='CSD6
    1450:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1460:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1470:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1480:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1490:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    14a0:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    14b0:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    14c0:	b9 38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .8: ...<input ty
    14d0:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    14e0:	43 53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD7' size='12' 
    14f0:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    1500:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    1510:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    1520:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    1530:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    1540:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1550:	3e 0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75     >....9: ...<inpu
    1560:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1570:	6d 65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27     me='CSD8' size='
    1580:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1590:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    15a0:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    15b0:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    15c0:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    15d0:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    15e0:	47 45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09     GET'>....10: ...
    15f0:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    1600:	74 27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73     t' name='CSD9' s
    1610:	69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27     ize='12' value='
    1620:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a     {{{{{{{{{{{{'>..
    1630:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    1640:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    1650:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    1660:	3e 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     >.. </BODY>..</H
    1670:	54 4d 4c 3e 0d 0a 00                                TML>...

00001677 <csd_IField>:
    1677:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
    1687:	00 00 14 0c 06 00 00 00 1e 5f 00 35 45 00 1e 5f     ........._.5E.._
    1697:	00 31 45 00 22 61 00 00 00 0d 22 6e 00 00 00 0d     .1E."a...."n....
    16a7:	22 7b 00 00 00 0d 22 88 00 00 00 0d 22 95 00 00     "{...."....."...
    16b7:	00 0d 22 a2 00 00 00 0d 22 af 00 00 00 0d 22 bc     ..".....".....".
    16c7:	00 00 00 0d 22 c9 00 00 00 0d 22 d6 00 00 00 0d     ....".....".....

000016d7 <name_csd>:
    16d7:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

000016e0 <Web_gsm>:
    16e0:	cb 1c 9b 1c 1c 00 ed 16 cf 04 cc 17 04              .............

000016ed <gsm_OField>:
    16ed:	c3 17 b3 17 a0 17 90 17 83 17 73 17 6d 17 5d 17     ..........s.m.].
    16fd:	51 17 41 17 35 17 25 17 19 17 09 17                 Q.A.5.%.....

00001709 <Web_SMS_Number3>:
    1709:	22 fd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001719 <var_SMS_Number3>:
    1719:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

00001725 <Web_SMS_Number2>:
    1725:	22 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001735 <var_SMS_Number2>:
    1735:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

00001741 <Web_SMS_Number1>:
    1741:	22 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001751 <var_SMS_Number1>:
    1751:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

0000175d <Web_SMS>:
    175d:	01 60 00 00 00 00 00 01 00 00 00 00 00 00 00 00     .`..............

0000176d <var_SMS>:
    176d:	53 4d 53 4f 6e 00                                   SMSOn.

00001773 <Web_GPRS_apn_psw>:
    1773:	22 52 01 00 00 00 00 02 00 00 00 1e 2a 00 00 14     "R..........*...

00001783 <var_GPRS_apn_psw>:
    1783:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

00001790 <Web_GPRS_apn_user_name>:
    1790:	22 66 01 00 00 00 00 02 00 00 00 1e 2a 00 00 14     "f..........*...

000017a0 <var_GPRS_apn_user_name>:
    17a0:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    17b0:	6d 65 00                                            me.

000017b3 <Web_GPRS_apn1>:
    17b3:	22 7a 01 00 00 00 00 02 00 00 00 1e 2a 00 00 1e     "z..........*...

000017c3 <var_GPRS_apn1>:
    17c3:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000017cc <gsm_page>:
    17cc:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    17dc:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    17ec:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    17fc:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    180c:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    181c:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    182c:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    183c:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    184c:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    185c:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    186c:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    187c:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    188c:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    189c:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    18ac:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    18bc:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    18cc:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    18dc:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    18ec:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    18fc:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    190c:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    191c:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    192c:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    193c:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    194c:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    195c:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    196c:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    197c:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    198c:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    199c:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    19ac:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    19bc:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee     .</a>..<HR>.....
    19cc:	e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20     .... ....... {{ 
    19dc:	28 30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33     (0-31)</BR>..<h3
    19ec:	3e 47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d     >GPRS</h3></BR>.
    19fc:	0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f     .<form action='/
    1a0c:	27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d     ' method='GET'>.
    1a1c:	0a 09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c     ..APN name: ...<
    1a2c:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1a3c:	27 20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e     ' name='GPRS_apn
    1a4c:	27 20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75     ' size='29' valu
    1a5c:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    1a6c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    1a7c:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    1a8c:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    1a9c:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    1aac:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    1abc:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1acc:	47 45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d     GET'>...User nam
    1adc:	65 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     e: ...<input typ
    1aec:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47     e='text' name='G
    1afc:	50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d     PRS_apn_user_nam
    1b0c:	65 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     e' size='19' val
    1b1c:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1b2c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1b3c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1b4c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1b5c:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    1b6c:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    1b7c:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50     ethod='GET'>...P
    1b8c:	61 73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70     assword: ...<inp
    1b9c:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    1bac:	61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73     ame='GPRS_apn_ps
    1bbc:	77 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     w' size='19' val
    1bcc:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1bdc:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1bec:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1bfc:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1c0c:	66 6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f     form..</BR>..<FO
    1c1c:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    1c2c:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    1c3c:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    1c4c:	74 27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53     t' name='ResetGS
    1c5c:	4d 27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47     M' value='ResetG
    1c6c:	53 4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     SM'>..</FORM>..<
    1c7c:	2f 42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f     /BR></BR>.. </BO
    1c8c:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

00001c9b <gsm_IField>:
    1c9b:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
    1cab:	00 00 14 0c 06 00 00 00 00 1f 06 00 00 00 22 7a     .............."z
    1cbb:	01 00 00 1e 22 66 01 00 00 14 22 52 01 00 00 14     ...."f...."R....

00001ccb <name_gsm>:
    1ccb:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

00001cd4 <Web_network>:
    1cd4:	a3 32 a1 31 a0 00 e1 1c 4a 10 57 21 04              .2.1....J.W!.

00001ce1 <network_OField>:
    1ce1:	48 21 38 21 24 21 14 21 02 21 f2 20 91 1d 81 1d     H!8!$!.!.!. ....
    1cf1:	e9 20 d9 20 d0 20 c0 20 b7 20 a7 20 9e 20 8e 20     . . . . . . . . 
    1d01:	85 20 75 20 6c 20 5c 20 53 20 43 20 3a 20 2a 20     . u l \ S C : * 
    1d11:	21 20 11 20 08 20 f8 1f ef 1f df 1f d6 1f c6 1f     ! . . ..........
    1d21:	bd 1f ad 1f a4 1f 94 1f 8b 1f 7b 1f 72 1f 62 1f     ..........{.r.b.
    1d31:	5c 1f 4c 1f 46 1f 36 1f 30 1f 20 1f 1a 1f 0a 1f     \.L.F.6.0. .....
    1d41:	04 1f f4 1e ee 1e de 1e d8 1e c8 1e c2 1e b2 1e     ................
    1d51:	ac 1e 9c 1e 96 1e 86 1e 80 1e 70 1e 6a 1e 5a 1e     ..........p.j.Z.
    1d61:	54 1e 44 1e 3e 1e 2e 1e 28 1e 18 1e 12 1e 02 1e     T.D.>...(.......
    1d71:	f8 1d e8 1d de 1d ce 1d c4 1d b4 1d aa 1d 9a 1d     ................

00001d81 <Web_ResetGSM>:
    1d81:	00 19 06 00 00 00 00 ff 00 00 00 f6 28 00 00 00     ............(...

00001d91 <var_ResetGSM>:
    1d91:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00001d9a <Web_UDP3_Port>:
    1d9a:	08 30 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .0..............

00001daa <var_UDP3_Port>:
    1daa:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

00001db4 <Web_UDP2_Port>:
    1db4:	08 2e 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00001dc4 <var_UDP2_Port>:
    1dc4:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00001dce <Web_UDP1_Port>:
    1dce:	08 2c 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .,..............

00001dde <var_UDP1_Port>:
    1dde:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

00001de8 <Web_UDP0_Port>:
    1de8:	08 2a 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .*..............

00001df8 <var_UDP0_Port>:
    1df8:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

00001e02 <Web_UDP3_IP4>:
    1e02:	01 51 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Q..............

00001e12 <var_UDP3_IP4>:
    1e12:	55 44 50 33 34 00                                   UDP34.

00001e18 <Web_UDP3_IP3>:
    1e18:	01 50 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .P..............

00001e28 <var_UDP3_IP3>:
    1e28:	55 44 50 33 33 00                                   UDP33.

00001e2e <Web_UDP3_IP2>:
    1e2e:	01 4f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .O..............

00001e3e <var_UDP3_IP2>:
    1e3e:	55 44 50 33 32 00                                   UDP32.

00001e44 <Web_UDP3_IP1>:
    1e44:	01 4e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .N..............

00001e54 <var_UDP3_IP1>:
    1e54:	55 44 50 33 31 00                                   UDP31.

00001e5a <Web_UDP2_IP4>:
    1e5a:	01 4d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .M..............

00001e6a <var_UDP2_IP4>:
    1e6a:	55 44 50 32 34 00                                   UDP24.

00001e70 <Web_UDP2_IP3>:
    1e70:	01 4c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .L..............

00001e80 <var_UDP2_IP3>:
    1e80:	55 44 50 32 33 00                                   UDP23.

00001e86 <Web_UDP2_IP2>:
    1e86:	01 4b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .K..............

00001e96 <var_UDP2_IP2>:
    1e96:	55 44 50 32 32 00                                   UDP22.

00001e9c <Web_UDP2_IP1>:
    1e9c:	01 4a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .J..............

00001eac <var_UDP2_IP1>:
    1eac:	55 44 50 32 31 00                                   UDP21.

00001eb2 <Web_UDP1_IP4>:
    1eb2:	01 49 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .I..............

00001ec2 <var_UDP1_IP4>:
    1ec2:	55 44 50 31 34 00                                   UDP14.

00001ec8 <Web_UDP1_IP3>:
    1ec8:	01 48 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .H..............

00001ed8 <var_UDP1_IP3>:
    1ed8:	55 44 50 31 33 00                                   UDP13.

00001ede <Web_UDP1_IP2>:
    1ede:	01 47 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .G..............

00001eee <var_UDP1_IP2>:
    1eee:	55 44 50 31 32 00                                   UDP12.

00001ef4 <Web_UDP1_IP1>:
    1ef4:	01 46 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .F..............

00001f04 <var_UDP1_IP1>:
    1f04:	55 44 50 31 31 00                                   UDP11.

00001f0a <Web_UDP0_IP4>:
    1f0a:	01 45 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .E..............

00001f1a <var_UDP0_IP4>:
    1f1a:	55 44 50 30 34 00                                   UDP04.

00001f20 <Web_UDP0_IP3>:
    1f20:	01 44 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .D..............

00001f30 <var_UDP0_IP3>:
    1f30:	55 44 50 30 33 00                                   UDP03.

00001f36 <Web_UDP0_IP2>:
    1f36:	01 43 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .C..............

00001f46 <var_UDP0_IP2>:
    1f46:	55 44 50 30 32 00                                   UDP02.

00001f4c <Web_UDP0_IP1>:
    1f4c:	01 42 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .B..............

00001f5c <var_UDP0_IP1>:
    1f5c:	55 44 50 30 31 00                                   UDP01.

00001f62 <Web_Cli3_IP4>:
    1f62:	01 1f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f72 <var_Cli3_IP4>:
    1f72:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00001f7b <Web_Cli3_IP3>:
    1f7b:	01 1e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f8b <var_Cli3_IP3>:
    1f8b:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00001f94 <Web_Cli3_IP2>:
    1f94:	01 1d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fa4 <var_Cli3_IP2>:
    1fa4:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00001fad <Web_Cli3_IP1>:
    1fad:	01 1c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fbd <var_Cli3_IP1>:
    1fbd:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00001fc6 <Web_Cli2_IP4>:
    1fc6:	01 1b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fd6 <var_Cli2_IP4>:
    1fd6:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

00001fdf <Web_Cli2_IP3>:
    1fdf:	01 1a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fef <var_Cli2_IP3>:
    1fef:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00001ff8 <Web_Cli2_IP2>:
    1ff8:	01 19 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002008 <var_Cli2_IP2>:
    2008:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

00002011 <Web_Cli2_IP1>:
    2011:	01 18 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002021 <var_Cli2_IP1>:
    2021:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

0000202a <Web_Cli1_IP4>:
    202a:	01 17 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000203a <var_Cli1_IP4>:
    203a:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

00002043 <Web_Cli1_IP3>:
    2043:	01 16 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002053 <var_Cli1_IP3>:
    2053:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

0000205c <Web_Cli1_IP2>:
    205c:	01 15 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000206c <var_Cli1_IP2>:
    206c:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

00002075 <Web_Cli1_IP1>:
    2075:	01 14 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002085 <var_Cli1_IP1>:
    2085:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

0000208e <Web_Cli0_IP4>:
    208e:	01 13 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000209e <var_Cli0_IP4>:
    209e:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

000020a7 <Web_Cli0_IP3>:
    20a7:	01 12 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020b7 <var_Cli0_IP3>:
    20b7:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

000020c0 <Web_Cli0_IP2>:
    20c0:	01 11 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020d0 <var_Cli0_IP2>:
    20d0:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

000020d9 <Web_Cli0_IP1>:
    20d9:	01 10 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020e9 <var_Cli0_IP1>:
    20e9:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

000020f2 <Web_WebMaxSessionTime>:
    20f2:	11 56 00 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .V........;.....

00002102 <var_WebMaxSessionTime>:
    2102:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    2112:	65 00                                               e.

00002114 <Web_TCP_CONNECT_timeout>:
    2114:	08 0e 01 00 00 00 00 ff ff 00 00 1e 2a 00 00 02     ............*...

00002124 <var_TCP_CONNECT_timeout>:
    2124:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2134:	6f 75 74 00                                         out.

00002138 <Web_TCP_ListenPort>:
    2138:	08 20 01 00 00 00 00 ff ff 00 00 1e 2a 00 00 00     . ..........*...

00002148 <var_TCP_ListenPort>:
    2148:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

00002157 <network_page>:
    2157:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    2167:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    2177:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    2187:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    2197:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    21a7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    21b7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    21c7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    21d7:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    21e7:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    21f7:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    2207:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    2217:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    2227:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    2237:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    2247:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    2257:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    2267:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    2277:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    2287:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    2297:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    22a7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    22b7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    22c7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    22d7:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    22e7:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    22f7:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    2307:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    2317:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    2327:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    2337:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    2347:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
    2357:	68 33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72     h3>TCP/IP Server
    2367:	3c 2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </h3>..<form act
    2377:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    2387:	47 45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70     GET'>...Listen p
    2397:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    23a7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    23b7:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20     TCP_ListenPort' 
    23c7:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    23d7:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    23e7:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    23f7:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2407:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2417:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2427:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50     hod='GET'>...TCP
    2437:	2f 49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74     /IP connection t
    2447:	69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74     imeout:...<input
    2457:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    2467:	65 3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74     e='TCP_CONNECT_t
    2477:	69 6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27     imeout' size='7'
    2487:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e      value='{{{{{{'>
    2497:	73 65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     sec...<input typ
    24a7:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    24b7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    24c7:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
    24d7:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    24e7:	27 47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e     'GET'>...Session
    24f7:	20 74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70      timeout:...<inp
    2507:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2517:	61 6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69     ame='WebMaxSessi
    2527:	6f 6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27     onTime' size='7'
    2537:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b      value='{{{{{{{{
    2547:	7b 7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74     {{'>sec...<input
    2557:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2567:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2577:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68     rm>..</BR>....<h
    2587:	33 3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68     3>IP Firewall</h
    2597:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    25a7:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    25b7:	27 3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70     '>...IP1:...<inp
    25c7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    25d7:	61 6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73     ame='Cli0_IP1' s
    25e7:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    25f7:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2607:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2617:	27 43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d     'Cli0_IP2' size=
    2627:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2637:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2647:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    2657:	30 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20     0_IP3' size='3' 
    2667:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2677:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2687:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50     t' name='Cli0_IP
    2697:	34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     4' size='3' valu
    26a7:	65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     e='{{{'>...<inpu
    26b7:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    26c7:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    26d7:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    26e7:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    26f7:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50     thod='GET'>...IP
    2707:	32 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     2:...<input type
    2717:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    2727:	69 31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27     i1_IP1' size='3'
    2737:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    2747:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    2757:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49     xt' name='Cli1_I
    2767:	50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P2' size='3' val
    2777:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2787:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2797:	6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20     name='Cli1_IP3' 
    27a7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    27b7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    27c7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    27d7:	3d 27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65     ='Cli1_IP4' size
    27e7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    27f7:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2807:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2817:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2827:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    2837:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    2847:	45 54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69     ET'>...IP3:...<i
    2857:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2867:	20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27      name='Cli2_IP1'
    2877:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    2887:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    2897:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    28a7:	65 3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a     e='Cli2_IP2' siz
    28b7:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    28c7:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    28d7:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    28e7:	6c 69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33     li2_IP3' size='3
    28f7:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    2907:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2917:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f     ext' name='Cli2_
    2927:	49 50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP4' size='3' va
    2937:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     lue='{{{'>...<in
    2947:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    2957:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    2967:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c     /form>..</BR>..<
    2977:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    2987:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    2997:	49 50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     IP4:...<input ty
    29a7:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29b7:	43 6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27     Cli3_IP1' size='
    29c7:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    29d7:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    29e7:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33     text' name='Cli3
    29f7:	5f 49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP2' size='3' v
    2a07:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2a17:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2a27:	27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33     ' name='Cli3_IP3
    2a37:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2a47:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2a57:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a67:	6d 65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69     me='Cli3_IP4' si
    2a77:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2a87:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2a97:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2aa7:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2ab7:	0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63     .</BR>..<FORM ac
    2ac7:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2ad7:	27 47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     'GET'>...<input 
    2ae7:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61     type='submit' na
    2af7:	6d 65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61     me='ResetGSM' va
    2b07:	6c 75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d     lue='ResetGSM'>.
    2b17:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
    2b27:	0a 0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0     .....<h3>.......
    2b37:	20 f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a      ....... ......:
    2b47:	3c 2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a     </h3>..</BR>....
    2b57:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    2b67:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    2b77:	55 44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d     UDP Server1 IP:.
    2b87:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2b97:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31     ext' name='UDP01
    2ba7:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2bb7:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2bc7:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2bd7:	6d 65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d     me='UDP02' size=
    2be7:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2bf7:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2c07:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2c17:	30 33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     03' size='3' val
    2c27:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2c37:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2c47:	6e 61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a     name='UDP04' siz
    2c57:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2c67:	27 3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70     '>..Port:...<inp
    2c77:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2c87:	61 6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20     ame='UDP0_Port' 
    2c97:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2ca7:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2cb7:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2cc7:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2cd7:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2ce7:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2cf7:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20     hod='GET'>..UDP 
    2d07:	53 65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69     Server2 IP:...<i
    2d17:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2d27:	20 6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69      name='UDP11' si
    2d37:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2d47:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2d57:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2d67:	55 44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20     UDP12' size='3' 
    2d77:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2d87:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2d97:	74 27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20     t' name='UDP13' 
    2da7:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2db7:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2dc7:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2dd7:	3d 27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33     ='UDP14' size='3
    2de7:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a     ' value='{{{'>..
    2df7:	50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74     Port:...<input t
    2e07:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2e17:	27 55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65     'UDP1_Port' size
    2e27:	3d 27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b     ='5' value='{{{{
    2e37:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2e47:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2e57:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2e67:	0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20     .</BR>....<form 
    2e77:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    2e87:	64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65     d='GET'>..UDP Se
    2e97:	72 76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70     rver3 IP:...<inp
    2ea7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2eb7:	61 6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65     ame='UDP21' size
    2ec7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2ed7:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    2ee7:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2ef7:	50 32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P22' size='3' va
    2f07:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    2f17:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2f27:	20 6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69      name='UDP23' si
    2f37:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2f47:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2f57:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2f67:	55 44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20     UDP24' size='3' 
    2f77:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f     value='{{{'>..Po
    2f87:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    2f97:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2fa7:	44 50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27     DP2_Port' size='
    2fb7:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    2fc7:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2fd7:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2fe7:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2ff7:	2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63     /BR>....<form ac
    3007:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    3017:	27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76     'GET'>..UDP Serv
    3027:	65 72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74     er4 IP:...<input
    3037:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3047:	65 3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27     e='UDP31' size='
    3057:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    3067:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    3077:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    3087:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    3097:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    30a7:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    30b7:	61 6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65     ame='UDP33' size
    30c7:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    30d7:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    30e7:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    30f7:	50 33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P34' size='3' va
    3107:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74     lue='{{{'>..Port
    3117:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    3127:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    3137:	33 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27     3_Port' size='5'
    3147:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d      value='{{{{{'>.
    3157:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    3167:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    3177:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    3187:	52 3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a     R>.... </BODY>..
    3197:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

000031a1 <network_IField>:
    31a1:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
    31b1:	00 00 14 0c 06 00 00 00 08 20 01 00 00 00 08 0e     ......... ......
    31c1:	01 00 00 02 11 56 00 00 00 02 01 10 01 00 00 00     .....V..........
    31d1:	01 11 01 00 00 00 01 12 01 00 00 00 01 13 01 00     ................
    31e1:	00 00 01 14 01 00 00 00 01 15 01 00 00 00 01 16     ................
    31f1:	01 00 00 00 01 17 01 00 00 00 01 18 01 00 00 00     ................
    3201:	01 19 01 00 00 00 01 1a 01 00 00 00 01 1b 01 00     ................
    3211:	00 00 01 1c 01 00 00 00 01 1d 01 00 00 00 01 1e     ................
    3221:	01 00 00 00 01 1f 01 00 00 00 01 42 01 00 00 00     ...........B....
    3231:	01 43 01 00 00 00 01 44 01 00 00 00 01 45 01 00     .C.....D.....E..
    3241:	00 00 08 2a 01 00 00 00 01 46 01 00 00 00 01 47     ...*.....F.....G
    3251:	01 00 00 00 01 48 01 00 00 00 01 49 01 00 00 00     .....H.....I....
    3261:	08 2c 01 00 00 00 01 4a 01 00 00 00 01 4b 01 00     .,.....J.....K..
    3271:	00 00 01 4c 01 00 00 00 01 4d 01 00 00 00 08 2e     ...L.....M......
    3281:	01 00 00 00 01 4e 01 00 00 00 01 4f 01 00 00 00     .....N.....O....
    3291:	01 50 01 00 00 00 01 51 01 00 00 00 08 30 01 00     .P.....Q.....0..
	...

000032a3 <name_network>:
    32a3:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

000032b0 <Web_name_access_error>:
    32b0:	d7 33 00 00 00 00 00 00 1a 01 bd 32 00              .3.........2.

000032bd <name_access_error_page>:
    32bd:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    32cd:	3c 54 49 54 4c 45 3e ce f8 e8 e1 ea e0 20 e4 ee     <TITLE>...... ..
    32dd:	f1 f2 f3 ef e0 3c 2f 54 49 54 4c 45 3e 0d 0a 3c     .....</TITLE>..<
    32ed:	6d 65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d     meta http-equiv=
    32fd:	22 43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63     "Content-Type" c
    330d:	6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d     ontent="text/htm
    331d:	6c 3b 20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f     l; charset=windo
    332d:	77 73 2d 31 32 35 31 22 3e 0d 0a 3c 2f 48 45 41     ws-1251">..</HEA
    333d:	44 3e 0d 0a 3c 63 65 6e 74 65 72 3e 0d 0a 3c 68     D>..<center>..<h
    334d:	65 61 64 3e 0d 0a 3c 68 33 3e c2 e0 f8 20 f3 f0     ead>..<h3>... ..
    335d:	ee e2 e5 ed fc 20 e4 ee f1 f2 f3 ef e0 20 ed e5     ..... ....... ..
    336d:	20 ef ee e7 e2 ee eb ff e5 f2 20 ef f0 ee f1 ec      ......... .....
    337d:	e0 f2 f0 e8 e2 e0 f2 fc 20 fd f2 f3 20 f1 f2 f0     ........ ... ...
    338d:	e0 ed e8 f6 f3 3c 2f 68 33 3e 0d 0a 3c 61 20 68     .....</h3>..<a h
    339d:	72 65 66 3d 22 69 6e 64 65 78 2e 68 74 6d 6c 22     ref="index.html"
    33ad:	3e cd e0 e7 e0 e4 20 ed e0 20 e3 eb e0 e2 ed f3     >..... .. ......
    33bd:	fe 20 f1 f2 f0 e0 ed e8 f6 f3 3c 2f 61 3e 0d 0a     . ........</a>..
    33cd:	3c 2f 68 74 6d 6c 3e 0d 0a 00                       </html>...

000033d7 <name_access_error>:
    33d7:	61 63 63 65 73 73 5f 65 72 72 6f 72 2e 68 74 6d     access_error.htm
    33e7:	6c 00                                               l.

000033e9 <Web_favicon>:
    33e9:	74 39 00 00 00 00 00 00 7e 05 f6 33 00              t9......~..3.

000033f6 <favicon>:
    33f6:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    3406:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    3416:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    3426:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    3436:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    3446:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    3456:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    3466:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    3476:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    3486:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    3496:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    34a6:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    34b6:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    34c6:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    3832:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3842:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3852:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    3862:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    3872:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    3882:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    3892:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    38a2:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    38b2:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    38c2:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    38d2:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    38e2:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    38f2:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    3902:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    3912:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3922:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3932:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00003974 <name_favicon>:
    3974:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

00003980 <Web_emeter>:
    3980:	4b 45 57 43 1c 00 8d 39 00 09 57 3a 02              KEWC...9..W:.

0000398d <emeter_OField>:
    398d:	4c 3a 3c 3a 37 3a 27 3a 21 3a 11 3a 0a 3a fa 39     L:<:7:':!:.:.:.9
    399d:	f1 39 e1 39 b9 39 a9 39 d8 39 c8 39                 .9.9.9.9.9.9

000039a9 <Web_CurrDataPeriod>:
    39a9:	08 08 00 3c 00 00 00 ff ff 00 00 00 00 00 00 00     ...<............

000039b9 <var_CurrDataPeriod>:
    39b9:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

000039c8 <Web_AutoSend>:
    39c8:	01 0a 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

000039d8 <var_AutoSend>:
    39d8:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

000039e1 <Web_EM_UART_StopBits>:
    39e1:	00 30 09 00 00 00 00 01 00 00 00 31 4b 00 00 00     .0.........1K...

000039f1 <var_EM_UART_StopBits>:
    39f1:	53 74 6f 70 42 69 74 73 00                          StopBits.

000039fa <Web_EM_UART_Parity>:
    39fa:	00 06 06 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00003a0a <var_EM_UART_Parity>:
    3a0a:	50 61 72 69 74 79 00                                Parity.

00003a11 <Web_EM_UART_BitQt>:
    3a11:	00 5f 0a 00 00 00 00 03 00 00 00 00 00 00 00 00     ._..............

00003a21 <var_EM_UART_BitQt>:
    3a21:	42 69 74 51 74 00                                   BitQt.

00003a27 <Web_EM_UART_Rate>:
    3a27:	00 58 0a 00 00 00 00 08 00 00 00 00 00 00 00 00     .X..............

00003a37 <var_EM_UART_Rate>:
    3a37:	52 61 74 65 00                                      Rate.

00003a3c <Web_EMeterType>:
    3a3c:	01 29 00 00 00 00 00 04 00 00 00 5d 4b 00 00 00     .).........]K...

00003a4c <var_EMeterType>:
    3a4c:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

00003a57 <emeter_page>:
    3a57:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3a67:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3a77:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3a87:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3a97:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3aa7:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3ab7:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3ac7:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    3ad7:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    3ae7:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    3af7:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    3b07:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    3b17:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    3b27:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    3b37:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3b47:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3b57:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3b67:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    3b77:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    3b87:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3b97:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    3ba7:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    3bb7:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    3bc7:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    3bd7:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    3be7:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    3bf7:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    3c07:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    3c17:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    3c27:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    3c37:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    3c47:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    3c57:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    3c67:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    3c77:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    3c87:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    3c97:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    3ca7:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    3cb7:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    3cc7:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42     {{{{ ....*...</B
    3cd7:	52 3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea     R>..<h3>... ....
    3ce7:	f2 f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33     ...........:</h3
    3cf7:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    3d07:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    3d17:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    3d27:	3d 22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d     ="EMeterType"> .
    3d37:	0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    3d47:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    3d57:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    3d67:	7b 7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26     {{{{{{{{>Landis&
    3d77:	47 79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     Gyr..<OPTION VAL
    3d87:	55 45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb     UE=2 {{{{{{{{>..
    3d97:	c2 c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     .....<OPTION VAL
    3da7:	55 45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5     UE=3 {{{{{{{{>..
    3db7:	f0 ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49     ......230..<OPTI
    3dc7:	4f 4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b     ON VALUE=4 {{{{{
    3dd7:	7b 7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d     {{{>..... ......
    3de7:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c     ..</SELECT> ...<
    3df7:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e07:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e17:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d     .</form>..</BR>.
    3e27:	0a 0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb     ...<h3>.........
    3e37:	20 52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68      RS232/RS485:</h
    3e47:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    3e57:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    3e67:	27 3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a     '>.............:
    3e77:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    3e87:	22 52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49     "Rate"> ...<OPTI
    3e97:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    3ea7:	7b 7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f     {{{>1200bps...<O
    3eb7:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b     PTION VALUE=1 {{
    3ec7:	7b 7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a     {{{{{{>2400bps..
    3ed7:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32     .<OPTION VALUE=2
    3ee7:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70      {{{{{{{{>4800bp
    3ef7:	73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     s...<OPTION VALU
    3f07:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30     E=3 {{{{{{{{>960
    3f17:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3f27:	41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=4 {{{{{{{{>
    3f37:	31 34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49     14400bps...<OPTI
    3f47:	4f 4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b     ON VALUE=5 {{{{{
    3f57:	7b 7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c     {{{>19200bps...<
    3f67:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b     OPTION VALUE=6 {
    3f77:	7b 7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73     {{{{{{{>28800bps
    3f87:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    3f97:	3d 37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30     =7 {{{{{{{{>3840
    3fa7:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3fb7:	41 4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=8 {{{{{{{{>
    3fc7:	35 37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c     57600bps...</SEL
    3fd7:	45 43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1     ECT>............
    3fe7:	f2 e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45     ... ...:...<SELE
    3ff7:	43 54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e     CT NAME="BitQt">
    4007:	20 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55      ...<OPTION VALU
    4017:	45 3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a     E=0 {{{{{{{{>5..
    4027:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4037:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f      {{{{{{{{>6...<O
    4047:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4057:	7b 7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49     {{{{{{>7...<OPTI
    4067:	4f 4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b     ON VALUE=3 {{{{{
    4077:	7b 7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{{>8...</SELECT
    4087:	3e 20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a     > .............:
    4097:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    40a7:	22 50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50     "Parity"> ...<OP
    40b7:	54 49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b     TION VALUE=0 {{{
    40c7:	7b 7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54     {{{{{>......<OPT
    40d7:	49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b     ION VALUE=1 {{{{
    40e7:	7b 7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f     {{{{>.........<O
    40f7:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4107:	7b 7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d     {{{{{{>.........
    4117:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a     ..</SELECT> ....
    4127:	09 d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53     .....-....:...<S
    4137:	45 4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70     ELECT NAME="Stop
    4147:	42 69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Bits"> ...<OPTIO
    4157:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    4167:	7b 7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     {{>1...<OPTION V
    4177:	41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=1 {{{{{{{{>
    4187:	32 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a     2...</SELECT> ..
    4197:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    41a7:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    41b7:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    41c7:	42 52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1     BR>..<h3>..... .
    41d7:	f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42     .......:</h3></B
    41e7:	52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     R>..<form action
    41f7:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    4207:	27 3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d     '>...<SELECT NAM
    4217:	45 3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a     E="AutoSend"> ..
    4227:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    4237:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    4247:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4257:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c      {{{{{{{{>.....<
    4267:	2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70     /SELECT> ...<inp
    4277:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    4287:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    4297:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    42a7:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    42b7:	47 45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d     GET'>.. ......:.
    42c7:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    42d7:	65 78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44     ext' name='CurrD
    42e7:	61 74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d     ataPeriod' size=
    42f7:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    4307:	27 3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75     '>.........<inpu
    4317:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    4327:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    4337:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42     orm>..</BR>..</B
    4347:	4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00     ODY>..</HTML>...

00004357 <emeter_IField>:
    4357:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
    4367:	00 00 14 0c 06 00 00 00 10 40 02 00 00 03 10 44     .........@.....D
    4377:	02 00 00 03 10 48 02 00 00 03 10 4c 02 00 00 03     .....H.....L....
    4387:	1e 29 00 27 45 00 1e 29 00 1d 45 00 1e 29 00 13     .).'E..)..E..)..
    4397:	45 00 1e 29 00 09 45 00 1e 29 00 ff 44 00 1d 58     E..)..E..)..D..X
    43a7:	0a ed 44 00 1d 58 0a db 44 00 1d 58 0a c9 44 00     ..D..X..D..X..D.
    43b7:	1d 58 0a b7 44 00 1d 58 0a a5 44 00 1d 58 0a 93     .X..D..X..D..X..
    43c7:	44 00 1d 58 0a 81 44 00 1d 58 0a 6f 44 00 1d 58     D..X..D..X.oD..X
    43d7:	0a 5d 44 00 1d 5f 0a 55 44 00 1d 5f 0a 4d 44 00     .]D.._.UD.._.MD.
    43e7:	1d 5f 0a 45 44 00 1d 5f 0a 3d 44 00 1d 06 06 37     ._.ED.._.=D....7
    43f7:	44 00 1d 06 06 31 44 00 1d 06 06 2b 44 00 1d 30     D....1D....+D..0
    4407:	09 27 44 00 1d 30 09 23 44 00 1e 0a 00 35 45 00     .'D..0.#D....5E.
    4417:	1e 0a 00 31 45 00 08 08 00 00 00 00                 ...1E.......

00004423 <STB_2_List>:
    4423:	42 45 39 45                                         BE9E

00004427 <STB_1_List>:
    4427:	39 45 42 45                                         9EBE

0000442b <PAR_O_List>:
    442b:	42 45 42 45 39 45                                   BEBE9E

00004431 <PAR_E_List>:
    4431:	42 45 39 45 42 45                                   BE9EBE

00004437 <PAR_N_List>:
    4437:	39 45 42 45 42 45                                   9EBEBE

0000443d <BIT8_List>:
    443d:	42 45 42 45 42 45 39 45                             BEBEBE9E

00004445 <BIT7_List>:
    4445:	42 45 42 45 39 45 42 45                             BEBE9EBE

0000444d <BIT6_List>:
    444d:	42 45 39 45 42 45 42 45                             BE9EBEBE

00004455 <BIT5_List>:
    4455:	39 45 42 45 42 45 42 45                             9EBEBEBE

0000445d <BR57600_List>:
    445d:	42 45 42 45 42 45 42 45 42 45 42 45 42 45 42 45     BEBEBEBEBEBEBEBE
    446d:	39 45                                               9E

0000446f <BR34800_List>:
    446f:	42 45 42 45 42 45 42 45 42 45 42 45 42 45 39 45     BEBEBEBEBEBEBE9E
    447f:	42 45                                               BE

00004481 <BR28800_List>:
    4481:	42 45 42 45 42 45 42 45 42 45 42 45 39 45 42 45     BEBEBEBEBEBE9EBE
    4491:	42 45                                               BE

00004493 <BR19200_List>:
    4493:	42 45 42 45 42 45 42 45 42 45 39 45 42 45 42 45     BEBEBEBEBE9EBEBE
    44a3:	42 45                                               BE

000044a5 <BR14400_List>:
    44a5:	42 45 42 45 42 45 42 45 39 45 42 45 42 45 42 45     BEBEBEBE9EBEBEBE
    44b5:	42 45                                               BE

000044b7 <BR9600_List>:
    44b7:	42 45 42 45 42 45 39 45 42 45 42 45 42 45 42 45     BEBEBE9EBEBEBEBE
    44c7:	42 45                                               BE

000044c9 <BR4800_List>:
    44c9:	42 45 42 45 39 45 42 45 42 45 42 45 42 45 42 45     BEBE9EBEBEBEBEBE
    44d9:	42 45                                               BE

000044db <BR2400_List>:
    44db:	42 45 39 45 42 45 42 45 42 45 42 45 42 45 42 45     BE9EBEBEBEBEBEBE
    44eb:	42 45                                               BE

000044ed <BR1200_List>:
    44ed:	39 45 42 45 42 45 42 45 42 45 42 45 42 45 42 45     9EBEBEBEBEBEBEBE
    44fd:	42 45                                               BE

000044ff <ELVIN_MODEM_List>:
    44ff:	42 45 42 45 42 45 42 45 39 45                       BEBEBEBE9E

00004509 <MERCURY_230_List>:
    4509:	42 45 42 45 42 45 39 45 42 45                       BEBEBE9EBE

00004513 <ELVIN_List>:
    4513:	42 45 42 45 39 45 42 45 42 45                       BEBE9EBEBE

0000451d <LANDIS_GYR_ZMR110_List>:
    451d:	42 45 39 45 42 45 42 45 42 45                       BE9EBEBEBE

00004527 <EM_NONE_List>:
    4527:	39 45 42 45 42 45 42 45 42 45                       9EBEBEBEBE

00004531 <ON_List>:
    4531:	42 45 39 45                                         BE9E

00004535 <OFF_List>:
    4535:	39 45 42 45                                         9EBE

00004539 <Selected_Str>:
    4539:	73 65 6c 65 63 74 65 64 00                          selected.

00004542 <Space_Str>:
    4542:	20 20 20 20 20 20 20 20 00                                  .

0000454b <name_emeter>:
    454b:	65 6d 65 74 65 72 2e 68 74 6d 6c 00                 emeter.html.

00004557 <Web_index>:
    4557:	8a 48 4e 48 00 00 00 00 ea 02 64 45 00              .HNH......dE.

00004564 <index_page>:
    4564:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4574:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4584:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4594:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    45a4:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    45b4:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    45c4:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    45d4:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    45e4:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    45f4:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    4604:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    4614:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    4624:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    4634:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    4644:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4654:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4664:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    4674:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    4684:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    4694:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    46a4:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    46b4:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    46c4:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    46d4:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    46e4:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    46f4:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    4704:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    4714:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    4724:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    4734:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    4744:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    4754:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    4764:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    4774:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    4784:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    4794:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    47a4:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    47b4:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    47c4:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    47d4:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 68 33     {{{{ ....*...<h3
    47e4:	3e d3 f0 ee e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0     >....... .......
    47f4:	3a 3c 2f 68 33 3e 0d 0a 20 7b 7b 20 28 30 2d 33     :</h3>.. {{ (0-3
    4804:	31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e cd e0 f0     1)</BR>..<h3>...
    4814:	e0 e1 ee f2 ea e0 20 3a 3c 2f 68 33 3e 0d 0a 7b     ...... :</h3>..{
    4824:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a     {{{{{{{{{{ .....
    4834:	3c 2f 42 52 3e 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     </BR>..</BODY>..
    4844:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

0000484e <index_IField>:
    484e:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 14 0b 00     ".....".........
    485e:	00 00 14 0c 06 00 00 00 10 40 02 00 00 03 10 44     .........@.....D
    486e:	02 00 00 03 10 48 02 00 00 03 10 4c 02 00 00 03     .....H.....L....
    487e:	00 1f 06 00 00 00 10 50 09 00 00 02                 .......P....

0000488a <name_index>:
    488a:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

00004895 <Web_login>:
    4895:	a4 4b bc 4a 08 00 a2 48 e3 01 d9 48 00              .K.J...H...H.

000048a2 <vars_loginOField>:
    48a2:	d3 48 c3 48 ba 48 aa 48                             .H.H.H.H

000048aa <Web_PasswOF>:
    48aa:	21 ee 05 00 00 00 00 02 00 00 00 fe 28 00 00 0b     !...........(...

000048ba <vars_Passw>:
    48ba:	70 61 73 73 77 6f 72 64 00                          password.

000048c3 <Web_LoginOF>:
    48c3:	21 e4 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !...............

000048d3 <vars_Login>:
    48d3:	6c 6f 67 69 6e 00                                   login.

000048d9 <login_page>:
    48d9:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    48e9:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    48f9:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4909:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    4919:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    4929:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    4939:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4949:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    4959:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
    4969:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
    4979:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4989:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4999:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49a9:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
    49b9:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
    49c9:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
    49d9:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    49e9:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
    49f9:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
    4a09:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
    4a19:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
    4a29:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
    4a39:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
    4a49:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
    4a59:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
    4a69:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
    4a79:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    4a89:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    4a99:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
    4aa9:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
    4ab9:	0d 0a 00                                            ...

00004abc <login_InField>:
    4abc:	22 0f 00 00 00 15 1d 03 06 d4 4a 00 07 14 0b 00     ".........J.....
    4acc:	00 00 14 0c 06 00 00 00                             ........

00004ad4 <Web_LoginMsg_List>:
    4ad4:	72 4b 40 4b 0e 4b dc 4a                             rK@K.K.J

00004adc <Login_PSW_Str>:
    4adc:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
    4aec:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
    4afc:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b0c:	20 00                                                .

00004b0e <Login_Login_Str>:
    4b0e:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
    4b1e:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
    4b2e:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b3e:	20 00                                                .

00004b40 <Login_Busy_Str>:
    4b40:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
    4b50:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
    4b60:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
    4b70:	2e 00                                               ..

00004b72 <Login_Welcome_Str>:
    4b72:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
    4b82:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
    4b92:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
    4ba2:	20 00                                                .

00004ba4 <name_login>:
    4ba4:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

00004baf <METHOD_POST>:
    4baf:	50 4f 53 54 20 2f 00                                POST /.

00004bb6 <METHOD_GET>:
    4bb6:	47 45 54 20 2f 00                                   GET /.

00004bbc <Web_error_page>:
	...
    4bc4:	75 00 c9 4b 00                                      u..K.

00004bc9 <error_page>:
    4bc9:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    4bd9:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
    4be9:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
    4bf9:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
    4c09:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
    4c19:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
    4c29:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
    4c39:	2f 68 31 3e 00                                      /h1>.

00004c3e <SESSID_pstr>:
    4c3e:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00004c47 <inputSESSID_Str>:
    4c47:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
    4c57:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
    4c67:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

00004c72 <Connection_Close>:
    4c72:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    4c82:	65 0d 0a 0d 0a 00                                   e.....

00004c88 <jpeg_str>:
    4c88:	6a 70 65 67 00                                      jpeg.

00004c8d <gif_str>:
    4c8d:	67 69 66 00                                         gif.

00004c91 <ico_str>:
    4c91:	69 63 6f 00                                         ico.

00004c95 <html_str>:
    4c95:	68 74 6d 6c 00                                      html.

00004c9a <image_str>:
    4c9a:	69 6d 61 67 65 2f 00                                image/.

00004ca1 <html_cp1251_str>:
    4ca1:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
    4cb1:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
    4cc1:	0a 00                                               ..

00004cc3 <Content_Length>:
    4cc3:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    4cd3:	3a 20 00                                            : .

00004cd6 <Content_Type>:
    4cd6:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

00004ce5 <HTTP_200_OK>:
    4ce5:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    4cf5:	0a 00                                               ..

00004cf7 <MsgErr41>:
    4cf7:	29                                                  )

00004cf8 <TestMsg_str>:
    4cf8:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
    4d08:	e8 e5 00                                            ...

00004d0b <MB_Master_List>:
    4d0b:	00 00 00                                            ...

00004d0e <DO_M>:
    4d0e:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004d1d <DI_M>:
    4d1d:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4d2d:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004d3d <AT_ATH>:
    4d3d:	41 54 48 00                                         ATH.

00004d41 <AT_ATA>:
    4d41:	41 54 41 00                                         ATA.

00004d45 <AT_CSQ>:
    4d45:	41 54 2b 43 53 51 00                                AT+CSQ.

00004d4c <AT_CGATT_0>:
    4d4c:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

00004d57 <AT_CIPSHUT>:
    4d57:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

00004d62 <AT_CIPCLOSE>:
    4d62:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00004d70 <AT_CIPCLOSE_1>:
    4d70:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00004d80 <AT_CIPSEND>:
    4d80:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00004d8c <AT_ATO>:
    4d8c:	41 54 4f 00                                         ATO.

00004d90 <AT_CIPSTATUS>:
    4d90:	41 54 2b 43 49 50 53 54 41 54 55 53 00              AT+CIPSTATUS.

00004d9d <AT_SERVERCLOSE>:
    4d9d:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00004dac <AT_CIPSERVER>:
    4dac:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00004dbc <AT_CIPSTART_TCP>:
    4dbc:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
    4dcc:	22 2c 00                                            ",.

00004dcf <AT_CIPSTART>:
    4dcf:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
    4ddf:	44 50 22 2c 00                                      DP",.

00004de4 <AT_CIFSR>:
    4de4:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00004ded <AT_CIICR>:
    4ded:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00004df6 <AT_CSTT>:
    4df6:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00004dfe <AT_CIPCSGP>:
    4dfe:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00004e0d <AT_CGATT>:
    4e0d:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00004e18 <AT_CIPMUX_0>:
    4e18:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00004e24 <AT_CIPMODE_1>:
    4e24:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00004e31 <AT_CMGS>:
    4e31:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

00004e3c <AT_CSMP>:
    4e3c:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
    4e4c:	2c 30 00                                            ,0.

00004e4f <AT_CMGF>:
    4e4f:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

00004e59 <AT_CCID>:
    4e59:	41 54 2b 43 43 49 44 00                             AT+CCID.

00004e61 <AT_CLIP>:
    4e61:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00004e6b <AT_CGMM>:
    4e6b:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00004e73 <AT_E0>:
    4e73:	41 54 45 30 00                                      ATE0.

00004e78 <AT_W>:
    4e78:	41 54 26 57 00                                      AT&W.

00004e7d <AT_IPR9600>:
    4e7d:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00004e89 <AT_AT>:
    4e89:	41 54 00                                            AT.

00004e8c <MODEM_EQUAL>:
    4e8c:	4d 6f 64 65 6d 3d 39 39 30 00                       Modem=990.

00004e96 <ESC_SEQ>:
    4e96:	2b 2b 2b 00                                         +++.

00004e9a <RESP_STATE_CONNECT_OK>:
    4e9a:	53 54 41 54 45 3a 20 43 4f 4e 4e 45 43 54 20 4f     STATE: CONNECT O
    4eaa:	4b 00                                               K.

00004eac <RESP_CONNECT_9600>:
    4eac:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00004eb9 <RESP_SHUT_OK>:
    4eb9:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00004ec1 <RESP_CSQ>:
    4ec1:	2b 43 53 51 3a 00                                   +CSQ:.

00004ec7 <RESP_CLOSE_OK_FAST>:
    4ec7:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00004ed3 <RESP_CLOSE_OK>:
    4ed3:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00004edc <RESP_SEND_OK>:
    4edc:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00004ee7 <RESP_SERVER_CLOSE>:
    4ee7:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00004ef4 <RESP_SERVER_OK>:
    4ef4:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00004efe <RESP_CONNECT_OK>:
    4efe:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00004f0c <RESP_CONNECT>:
    4f0c:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f14 <RESP_OK>:
    4f14:	4f 4b 00                                            OK.

00004f17 <URC_NO_CARRIER>:
    4f17:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00004f22 <URC_RING>:
    4f22:	52 49 4e 47 00                                      RING.

00004f27 <URC_PDPDEACT>:
    4f27:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

00004f32 <URC_CLOSED>:
    4f32:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

00004f3b <URC_RECEIVE>:
    4f3b:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

00004f45 <URC_CONNECT>:
    4f45:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f4d <URC_REMOTE_IP>:
    4f4d:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

00004f57 <URC_SMS_READY>:
    4f57:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00004f61 <URC_CALL_READY>:
    4f61:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

00004f6c <URC_RDY>:
    4f6c:	52 44 59 00                                         RDY.

00004f70 <GSM_SIMCOM_SIM800>:
    4f70:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00004f7e <GSM_SIMCOM_SIM900R>:
    4f7e:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00004f8d <MB_Timer>:
    4f8d:	52 00 51 00 29 28 44 00 43 00 2f 28                 R.Q.)(D.C./(

00004f99 <MB_Port>:
    4f99:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 21 28 26 28     ............!(&(
    4fa9:	27 28 28 28                                         '(((

00004fad <BR_Tbl>:
    4fad:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
    4fbd:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00004fc8 <Modbus_Map>:
    4fc8:	d9 03 08 00 f0 03 08 00 76 08 26 00 65 0a 1e 00     ........v.&.e...

00004fd8 <MB_Role>:
	...

00004fd9 <__c.2299>:
    4fd9:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00004fe6 <__ctors_end>:
    4fe6:	11 24       	eor	r1, r1
    4fe8:	1f be       	out	0x3f, r1	; 63
    4fea:	cf ef       	ldi	r28, 0xFF	; 255
    4fec:	d0 e1       	ldi	r29, 0x10	; 16
    4fee:	de bf       	out	0x3e, r29	; 62
    4ff0:	cd bf       	out	0x3d, r28	; 61

00004ff2 <__do_copy_data>:
    4ff2:	12 e0       	ldi	r17, 0x02	; 2
    4ff4:	a0 e0       	ldi	r26, 0x00	; 0
    4ff6:	b1 e0       	ldi	r27, 0x01	; 1
    4ff8:	ee e5       	ldi	r30, 0x5E	; 94
    4ffa:	fb ee       	ldi	r31, 0xEB	; 235
    4ffc:	00 e0       	ldi	r16, 0x00	; 0
    4ffe:	0b bf       	out	0x3b, r16	; 59
    5000:	02 c0       	rjmp	.+4      	; 0x5006 <__do_copy_data+0x14>
    5002:	07 90       	elpm	r0, Z+
    5004:	0d 92       	st	X+, r0
    5006:	a4 33       	cpi	r26, 0x34	; 52
    5008:	b1 07       	cpc	r27, r17
    500a:	d9 f7       	brne	.-10     	; 0x5002 <__do_copy_data+0x10>

0000500c <__do_clear_bss>:
    500c:	2e e0       	ldi	r18, 0x0E	; 14
    500e:	a4 e3       	ldi	r26, 0x34	; 52
    5010:	b2 e0       	ldi	r27, 0x02	; 2
    5012:	01 c0       	rjmp	.+2      	; 0x5016 <.do_clear_bss_start>

00005014 <.do_clear_bss_loop>:
    5014:	1d 92       	st	X+, r1

00005016 <.do_clear_bss_start>:
    5016:	a9 33       	cpi	r26, 0x39	; 57
    5018:	b2 07       	cpc	r27, r18
    501a:	e1 f7       	brne	.-8      	; 0x5014 <.do_clear_bss_loop>
    501c:	0e 94 3c 6b 	call	0xd678	; 0xd678 <main>
    5020:	0c 94 c5 6b 	jmp	0xd78a	; 0xd78a <exit>

00005024 <__bad_interrupt>:
    5024:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00005028 <rrb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
	return *addr;
}
    5028:	fc 01       	movw	r30, r24
    502a:	80 81       	ld	r24, Z
    502c:	08 95       	ret

0000502e <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    502e:	fc 01       	movw	r30, r24
    5030:	84 91       	lpm	r24, Z
}
    5032:	08 95       	ret

00005034 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    5034:	a0 e0       	ldi	r26, 0x00	; 0
    5036:	b0 e0       	ldi	r27, 0x00	; 0
    5038:	11 96       	adiw	r26, 0x01	; 1
}
    503a:	ab bf       	out	0x3b, r26	; 59
    503c:	fc 01       	movw	r30, r24
    503e:	87 91       	elpm	r24, Z+
    5040:	08 95       	ret

00005042 <RS485_1>:
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
}

void RS485_0(void) {}
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5042:	82 b3       	in	r24, 0x12	; 18
    5044:	90 e1       	ldi	r25, 0x10	; 16
    5046:	89 27       	eor	r24, r25
    5048:	82 bb       	out	0x12, r24	; 18
    504a:	08 95       	ret

0000504c <MB_LED1>:

void MB_LED0(void) {}
void MB_LED1(void) {}
    504c:	08 95       	ret

0000504e <MB_LED_Err_On_1>:

void MB_LED_Err_On_0(void)	{}
void MB_LED_Err_Off_0(void)	{}
void MB_LED_Err_On_1(void)	{}
    504e:	08 95       	ret

00005050 <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    5050:	08 95       	ret

00005052 <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    5052:	8f e0       	ldi	r24, 0x0F	; 15
    5054:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    5056:	87 b7       	in	r24, 0x37	; 55
    5058:	82 60       	ori	r24, 0x02	; 2
    505a:	87 bf       	out	0x37, r24	; 55
    505c:	08 95       	ret

0000505e <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    505e:	8d e0       	ldi	r24, 0x0D	; 13
    5060:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    5062:	87 b7       	in	r24, 0x37	; 55
    5064:	80 68       	ori	r24, 0x80	; 128
    5066:	87 bf       	out	0x37, r24	; 55
    5068:	08 95       	ret

0000506a <MB_Timer_ISR>:
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    506a:	60 e0       	ldi	r22, 0x00	; 0
    506c:	76 e0       	ldi	r23, 0x06	; 6
    506e:	26 2f       	mov	r18, r22
    5070:	30 e0       	ldi	r19, 0x00	; 0
    5072:	72 9f       	mul	r23, r18
    5074:	f0 01       	movw	r30, r0
    5076:	73 9f       	mul	r23, r19
    5078:	f0 0d       	add	r31, r0
    507a:	11 24       	eor	r1, r1
    507c:	e3 57       	subi	r30, 0x73	; 115
    507e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5080:	45 91       	lpm	r20, Z+
    5082:	54 91       	lpm	r21, Z
    5084:	e6 2f       	mov	r30, r22
    5086:	f0 e0       	ldi	r31, 0x00	; 0
    5088:	84 17       	cp	r24, r20
    508a:	95 07       	cpc	r25, r21
    508c:	11 f0       	breq	.+4      	; 0x5092 <MB_Timer_ISR+0x28>
    508e:	6f 5f       	subi	r22, 0xFF	; 255
    5090:	ee cf       	rjmp	.-36     	; 0x506e <MB_Timer_ISR+0x4>

	
	switch (prb(MB_Role+MB_N)){
    5092:	e8 52       	subi	r30, 0x28	; 40
    5094:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5096:	e4 91       	lpm	r30, Z
    5098:	ee 23       	and	r30, r30
    509a:	19 f0       	breq	.+6      	; 0x50a2 <MB_Timer_ISR+0x38>
    509c:	e1 30       	cpi	r30, 0x01	; 1
    509e:	f9 f0       	breq	.+62     	; 0x50de <MB_Timer_ISR+0x74>
    50a0:	08 95       	ret
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    50a2:	f2 2f       	mov	r31, r18
    50a4:	ee 27       	eor	r30, r30
    50a6:	eb 5c       	subi	r30, 0xCB	; 203
    50a8:	f2 4f       	sbci	r31, 0xF2	; 242
    50aa:	90 81       	ld	r25, Z
    50ac:	f9 01       	movw	r30, r18
    50ae:	ee 50       	subi	r30, 0x0E	; 14
    50b0:	fc 4f       	sbci	r31, 0xFC	; 252
    50b2:	80 81       	ld	r24, Z
    50b4:	98 17       	cp	r25, r24
    50b6:	99 f0       	breq	.+38     	; 0x50de <MB_Timer_ISR+0x74>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    50b8:	f9 01       	movw	r30, r18
    50ba:	e5 52       	subi	r30, 0x25	; 37
    50bc:	fc 4f       	sbci	r31, 0xFC	; 252
    50be:	81 e0       	ldi	r24, 0x01	; 1
    50c0:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    50c2:	f9 01       	movw	r30, r18
    50c4:	84 e0       	ldi	r24, 0x04	; 4
    50c6:	ee 0f       	add	r30, r30
    50c8:	ff 1f       	adc	r31, r31
    50ca:	8a 95       	dec	r24
    50cc:	e1 f7       	brne	.-8      	; 0x50c6 <MB_Timer_ISR+0x5c>
    50ce:	ea 5e       	subi	r30, 0xEA	; 234
    50d0:	f4 4f       	sbci	r31, 0xF4	; 244
    50d2:	80 81       	ld	r24, Z
    50d4:	91 81       	ldd	r25, Z+1	; 0x01
    50d6:	01 96       	adiw	r24, 0x01	; 1
    50d8:	91 83       	std	Z+1, r25	; 0x01
    50da:	80 83       	st	Z, r24
    50dc:	08 95       	ret
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    50de:	30 91 00 0b 	lds	r19, 0x0B00
    50e2:	81 e0       	ldi	r24, 0x01	; 1
    50e4:	90 e0       	ldi	r25, 0x00	; 0
    50e6:	02 2e       	mov	r0, r18
    50e8:	01 c0       	rjmp	.+2      	; 0x50ec <MB_Timer_ISR+0x82>
    50ea:	88 0f       	add	r24, r24
    50ec:	0a 94       	dec	r0
    50ee:	ea f7       	brpl	.-6      	; 0x50ea <MB_Timer_ISR+0x80>
    50f0:	38 2b       	or	r19, r24
    50f2:	30 93 00 0b 	sts	0x0B00, r19
    50f6:	08 95       	ret

000050f8 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    50f8:	28 2f       	mov	r18, r24
    50fa:	30 e0       	ldi	r19, 0x00	; 0
    50fc:	94 e1       	ldi	r25, 0x14	; 20
    50fe:	89 9f       	mul	r24, r25
    5100:	f0 01       	movw	r30, r0
    5102:	11 24       	eor	r1, r1
    5104:	e5 56       	subi	r30, 0x65	; 101
    5106:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5108:	a5 91       	lpm	r26, Z+
    510a:	b4 91       	lpm	r27, Z
    510c:	9c 91       	ld	r25, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    510e:	f9 01       	movw	r30, r18
    5110:	e9 53       	subi	r30, 0x39	; 57
    5112:	f7 4f       	sbci	r31, 0xF7	; 247
    5114:	40 81       	ld	r20, Z
    5116:	51 e0       	ldi	r21, 0x01	; 1
    5118:	54 0f       	add	r21, r20
    511a:	50 83       	st	Z, r21
    511c:	54 e1       	ldi	r21, 0x14	; 20
    511e:	52 9f       	mul	r21, r18
    5120:	f0 01       	movw	r30, r0
    5122:	53 9f       	mul	r21, r19
    5124:	f0 0d       	add	r31, r0
    5126:	11 24       	eor	r1, r1
    5128:	e7 56       	subi	r30, 0x67	; 103
    512a:	f0 4b       	sbci	r31, 0xB0	; 176
    512c:	a5 91       	lpm	r26, Z+
    512e:	b4 91       	lpm	r27, Z
    5130:	5c 91       	ld	r21, X
    5132:	f2 2f       	mov	r31, r18
    5134:	ee 27       	eor	r30, r30
    5136:	e4 0f       	add	r30, r20
    5138:	f1 1d       	adc	r31, r1
    513a:	eb 5c       	subi	r30, 0xCB	; 203
    513c:	f2 4f       	sbci	r31, 0xF2	; 242
    513e:	50 83       	st	Z, r21
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    5140:	93 ff       	sbrs	r25, 3
    5142:	0e c0       	rjmp	.+28     	; 0x5160 <MBRecept+0x68>
		MB_CPT[MB_N][7]++;
    5144:	f9 01       	movw	r30, r18
    5146:	24 e0       	ldi	r18, 0x04	; 4
    5148:	ee 0f       	add	r30, r30
    514a:	ff 1f       	adc	r31, r31
    514c:	2a 95       	dec	r18
    514e:	e1 f7       	brne	.-8      	; 0x5148 <MBRecept+0x50>
    5150:	ea 5e       	subi	r30, 0xEA	; 234
    5152:	f4 4f       	sbci	r31, 0xF4	; 244
    5154:	26 85       	ldd	r18, Z+14	; 0x0e
    5156:	37 85       	ldd	r19, Z+15	; 0x0f
    5158:	2f 5f       	subi	r18, 0xFF	; 255
    515a:	3f 4f       	sbci	r19, 0xFF	; 255
    515c:	37 87       	std	Z+15, r19	; 0x0f
    515e:	26 87       	std	Z+14, r18	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    5160:	9c 71       	andi	r25, 0x1C	; 28
    5162:	59 f0       	breq	.+22     	; 0x517a <MBRecept+0x82>
		MB_Err |=(1<<MB_N);
    5164:	21 e0       	ldi	r18, 0x01	; 1
    5166:	30 e0       	ldi	r19, 0x00	; 0
    5168:	01 c0       	rjmp	.+2      	; 0x516c <MBRecept+0x74>
    516a:	22 0f       	add	r18, r18
    516c:	8a 95       	dec	r24
    516e:	ea f7       	brpl	.-6      	; 0x516a <MBRecept+0x72>
    5170:	80 91 65 02 	lds	r24, 0x0265
    5174:	82 2b       	or	r24, r18
    5176:	80 93 65 02 	sts	0x0265, r24
    517a:	08 95       	ret

0000517c <GetSlave>:

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    517c:	43 e0       	ldi	r20, 0x03	; 3
    517e:	84 9f       	mul	r24, r20
    5180:	f0 01       	movw	r30, r0
    5182:	11 24       	eor	r1, r1
    5184:	e5 5f       	subi	r30, 0xF5	; 245
    5186:	f2 4b       	sbci	r31, 0xB2	; 178
    5188:	25 91       	lpm	r18, Z+
    518a:	34 91       	lpm	r19, Z
    518c:	e8 2f       	mov	r30, r24
    518e:	f0 e0       	ldi	r31, 0x00	; 0
    5190:	e0 50       	subi	r30, 0x00	; 0
    5192:	fa 4f       	sbci	r31, 0xFA	; 250
    5194:	80 81       	ld	r24, Z
}
    5196:	a9 01       	movw	r20, r18
    5198:	64 e0       	ldi	r22, 0x04	; 4
    519a:	86 9f       	mul	r24, r22
    519c:	40 0d       	add	r20, r0
    519e:	51 1d       	adc	r21, r1
    51a0:	11 24       	eor	r1, r1
    51a2:	ca 01       	movw	r24, r20
    51a4:	08 95       	ret

000051a6 <DI_Init_Hard>:
static T_DI_M DI_M[] PROGMEM = DI_Map_Own;

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
    51a6:	8d e1       	ldi	r24, 0x1D	; 29
    51a8:	9d e4       	ldi	r25, 0x4D	; 77
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    51aa:	f8 94       	cli
    51ac:	fc 01       	movw	r30, r24
    51ae:	a5 91       	lpm	r26, Z+
    51b0:	b4 91       	lpm	r27, Z
    51b2:	ac 01       	movw	r20, r24
    51b4:	4a 5f       	subi	r20, 0xFA	; 250
    51b6:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51b8:	fa 01       	movw	r30, r20
    51ba:	34 91       	lpm	r19, Z
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    51bc:	30 95       	com	r19
    51be:	2c 91       	ld	r18, X
    51c0:	23 23       	and	r18, r19
    51c2:	2c 93       	st	X, r18
    51c4:	9c 01       	movw	r18, r24
    51c6:	2e 5f       	subi	r18, 0xFE	; 254
    51c8:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    51ca:	f9 01       	movw	r30, r18
    51cc:	a5 91       	lpm	r26, Z+
    51ce:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51d0:	fa 01       	movw	r30, r20
    51d2:	44 91       	lpm	r20, Z
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    51d4:	2c 91       	ld	r18, X
    51d6:	24 2b       	or	r18, r20
    51d8:	2c 93       	st	X, r18
		sei();
    51da:	78 94       	sei
    51dc:	08 96       	adiw	r24, 0x08	; 8

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    51de:	fd e4       	ldi	r31, 0x4D	; 77
    51e0:	8d 33       	cpi	r24, 0x3D	; 61
    51e2:	9f 07       	cpc	r25, r31
    51e4:	11 f7       	brne	.-60     	; 0x51aa <DI_Init_Hard+0x4>
		cli();
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
		sei();
	}
}
    51e6:	08 95       	ret

000051e8 <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    51e8:	f8 94       	cli
    51ea:	ff cf       	rjmp	.-2      	; 0x51ea <Reboot+0x2>

000051ec <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    51ec:	88 e5       	ldi	r24, 0x58	; 88
    51ee:	80 93 21 06 	sts	0x0621, r24
    51f2:	08 95       	ret

000051f4 <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    51f4:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    51f6:	e0 e0       	ldi	r30, 0x00	; 0
    51f8:	ff ef       	ldi	r31, 0xFF	; 255
    51fa:	09 94       	ijmp

000051fc <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    51fc:	81 e0       	ldi	r24, 0x01	; 1
    51fe:	80 93 34 08 	sts	0x0834, r24
    5202:	08 95       	ret

00005204 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5204:	0c 94 6e 73 	jmp	0xe6dc	; 0xe6dc <__eerd_byte_m128>

00005208 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5208:	0f 93       	push	r16
    520a:	1f 93       	push	r17
    520c:	cf 93       	push	r28
    520e:	df 93       	push	r29
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5210:	c8 2f       	mov	r28, r24
    5212:	d0 e0       	ldi	r29, 0x00	; 0
    5214:	fe 01       	movw	r30, r28
    5216:	e4 5e       	subi	r30, 0xE4	; 228
    5218:	f9 4f       	sbci	r31, 0xF9	; 249
    521a:	90 81       	ld	r25, Z
    521c:	92 30       	cpi	r25, 0x02	; 2
    521e:	09 f1       	breq	.+66     	; 0x5262 <GetReg+0x5a>
    5220:	fe 01       	movw	r30, r28
    5222:	a4 e0       	ldi	r26, 0x04	; 4
    5224:	ee 0f       	add	r30, r30
    5226:	ff 1f       	adc	r31, r31
    5228:	aa 95       	dec	r26
    522a:	e1 f7       	brne	.-8      	; 0x5224 <GetReg+0x1c>
    522c:	e0 53       	subi	r30, 0x30	; 48
    522e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5230:	05 91       	lpm	r16, Z+
    5232:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    5234:	0e 94 be 28 	call	0x517c	; 0x517c <GetSlave>
    5238:	01 96       	adiw	r24, 0x01	; 1
    523a:	fc 01       	movw	r30, r24
    523c:	85 91       	lpm	r24, Z+
    523e:	94 91       	lpm	r25, Z
    5240:	c9 5f       	subi	r28, 0xF9	; 249
    5242:	d9 4f       	sbci	r29, 0xF9	; 249
    5244:	28 81       	ld	r18, Y
    5246:	fc 01       	movw	r30, r24
    5248:	37 e0       	ldi	r19, 0x07	; 7
    524a:	23 9f       	mul	r18, r19
    524c:	e0 0d       	add	r30, r0
    524e:	f1 1d       	adc	r31, r1
    5250:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5252:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5254:	85 91       	lpm	r24, Z+
    5256:	94 91       	lpm	r25, Z
    5258:	88 0f       	add	r24, r24
    525a:	99 1f       	adc	r25, r25
    525c:	80 0f       	add	r24, r16
    525e:	91 1f       	adc	r25, r17
    5260:	09 c0       	rjmp	.+18     	; 0x5274 <GetReg+0x6c>
    5262:	73 e0       	ldi	r23, 0x03	; 3
    5264:	cc 0f       	add	r28, r28
    5266:	dd 1f       	adc	r29, r29
    5268:	7a 95       	dec	r23
    526a:	e1 f7       	brne	.-8      	; 0x5264 <GetReg+0x5c>
    526c:	c3 5a       	subi	r28, 0xA3	; 163
    526e:	dd 4f       	sbci	r29, 0xFD	; 253
    5270:	8e 81       	ldd	r24, Y+6	; 0x06
    5272:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5274:	df 91       	pop	r29
    5276:	cf 91       	pop	r28
    5278:	1f 91       	pop	r17
    527a:	0f 91       	pop	r16
    527c:	08 95       	ret

0000527e <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    527e:	fc 01       	movw	r30, r24
    5280:	65 91       	lpm	r22, Z+
    5282:	75 91       	lpm	r23, Z+
    5284:	85 91       	lpm	r24, Z+
    5286:	94 91       	lpm	r25, Z
}
    5288:	08 95       	ret

0000528a <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    528a:	8f 92       	push	r8
    528c:	9f 92       	push	r9
    528e:	af 92       	push	r10
    5290:	bf 92       	push	r11
    5292:	cf 92       	push	r12
    5294:	df 92       	push	r13
    5296:	ef 92       	push	r14
    5298:	ff 92       	push	r15
    529a:	0f 93       	push	r16
    529c:	1f 93       	push	r17
    529e:	cf 93       	push	r28
    52a0:	df 93       	push	r29
    52a2:	00 d0       	rcall	.+0      	; 0x52a4 <CRC_Seed+0x1a>
    52a4:	00 d0       	rcall	.+0      	; 0x52a6 <CRC_Seed+0x1c>
    52a6:	cd b7       	in	r28, 0x3d	; 61
    52a8:	de b7       	in	r29, 0x3e	; 62
    52aa:	4c 01       	movw	r8, r24
    52ac:	5b 01       	movw	r10, r22
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52ae:	c1 2c       	mov	r12, r1
    52b0:	d1 2c       	mov	r13, r1
    52b2:	76 01       	movw	r14, r12
    52b4:	c2 16       	cp	r12, r18
    52b6:	d3 06       	cpc	r13, r19
    52b8:	e4 06       	cpc	r14, r20
    52ba:	f5 06       	cpc	r15, r21
    52bc:	f9 f0       	breq	.+62     	; 0x52fc <CRC_Seed+0x72>
    52be:	c5 01       	movw	r24, r10
    52c0:	8c 0d       	add	r24, r12
    52c2:	9d 1d       	adc	r25, r13
		uint8_t j = CRCLo^GetByte(Block+i);
    52c4:	29 83       	std	Y+1, r18	; 0x01
    52c6:	3a 83       	std	Y+2, r19	; 0x02
    52c8:	4b 83       	std	Y+3, r20	; 0x03
    52ca:	5c 83       	std	Y+4, r21	; 0x04
    52cc:	f4 01       	movw	r30, r8
    52ce:	09 95       	icall
    52d0:	80 27       	eor	r24, r16
		CRCLo = CRCHi^prb(aCRCHi+j);
    52d2:	68 2f       	mov	r22, r24
    52d4:	70 e0       	ldi	r23, 0x00	; 0
    52d6:	fb 01       	movw	r30, r22
    52d8:	ee 57       	subi	r30, 0x7E	; 126
    52da:	fb 4f       	sbci	r31, 0xFB	; 251

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52dc:	04 91       	lpm	r16, Z
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    52de:	01 27       	eor	r16, r17
		CRCHi = prb(aCRCLo+j);
    52e0:	fb 01       	movw	r30, r22
    52e2:	ee 57       	subi	r30, 0x7E	; 126
    52e4:	fc 4f       	sbci	r31, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52e6:	14 91       	lpm	r17, Z
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52e8:	ff ef       	ldi	r31, 0xFF	; 255
    52ea:	cf 1a       	sub	r12, r31
    52ec:	df 0a       	sbc	r13, r31
    52ee:	ef 0a       	sbc	r14, r31
    52f0:	ff 0a       	sbc	r15, r31
    52f2:	5c 81       	ldd	r21, Y+4	; 0x04
    52f4:	4b 81       	ldd	r20, Y+3	; 0x03
    52f6:	3a 81       	ldd	r19, Y+2	; 0x02
    52f8:	29 81       	ldd	r18, Y+1	; 0x01
    52fa:	dc cf       	rjmp	.-72     	; 0x52b4 <CRC_Seed+0x2a>
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
    52fc:	80 2f       	mov	r24, r16
    52fe:	90 e0       	ldi	r25, 0x00	; 0
}
    5300:	91 2b       	or	r25, r17
    5302:	0f 90       	pop	r0
    5304:	0f 90       	pop	r0
    5306:	0f 90       	pop	r0
    5308:	0f 90       	pop	r0
    530a:	df 91       	pop	r29
    530c:	cf 91       	pop	r28
    530e:	1f 91       	pop	r17
    5310:	0f 91       	pop	r16
    5312:	ff 90       	pop	r15
    5314:	ef 90       	pop	r14
    5316:	df 90       	pop	r13
    5318:	cf 90       	pop	r12
    531a:	bf 90       	pop	r11
    531c:	af 90       	pop	r10
    531e:	9f 90       	pop	r9
    5320:	8f 90       	pop	r8
    5322:	08 95       	ret

00005324 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    5324:	0f 93       	push	r16
    5326:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    5328:	0f ef       	ldi	r16, 0xFF	; 255
    532a:	1f ef       	ldi	r17, 0xFF	; 255
    532c:	0e 94 45 29 	call	0x528a	; 0x528a <CRC_Seed>
}
    5330:	1f 91       	pop	r17
    5332:	0f 91       	pop	r16
    5334:	08 95       	ret

00005336 <CRC_EEPROM_calc>:
}

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    5336:	0f 93       	push	r16
    5338:	1f 93       	push	r17
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
    533a:	27 ea       	ldi	r18, 0xA7	; 167
    533c:	31 e0       	ldi	r19, 0x01	; 1
// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
    533e:	40 e0       	ldi	r20, 0x00	; 0
    5340:	50 e0       	ldi	r21, 0x00	; 0
    5342:	60 e0       	ldi	r22, 0x00	; 0
    5344:	70 e0       	ldi	r23, 0x00	; 0
    5346:	82 e0       	ldi	r24, 0x02	; 2
    5348:	99 e2       	ldi	r25, 0x29	; 41
    534a:	0e 94 92 29 	call	0x5324	; 0x5324 <CRC>
    534e:	2b ef       	ldi	r18, 0xFB	; 251
    5350:	3f e0       	ldi	r19, 0x0F	; 15
    5352:	27 5a       	subi	r18, 0xA7	; 167
    5354:	31 40       	sbci	r19, 0x01	; 1
    5356:	40 e0       	ldi	r20, 0x00	; 0
    5358:	50 e0       	ldi	r21, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
    535a:	8c 01       	movw	r16, r24
    535c:	6c ea       	ldi	r22, 0xAC	; 172
    535e:	71 e0       	ldi	r23, 0x01	; 1
    5360:	82 e0       	ldi	r24, 0x02	; 2
    5362:	99 e2       	ldi	r25, 0x29	; 41
    5364:	0e 94 45 29 	call	0x528a	; 0x528a <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    5368:	1f 91       	pop	r17
    536a:	0f 91       	pop	r16
    536c:	08 95       	ret

0000536e <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    536e:	80 91 64 0a 	lds	r24, 0x0A64
    5372:	81 fd       	sbrc	r24, 1
    5374:	07 c0       	rjmp	.+14     	; 0x5384 <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5376:	0e 94 9b 29 	call	0x5336	; 0x5336 <CRC_EEPROM_calc>
    537a:	bc 01       	movw	r22, r24
    537c:	89 ea       	ldi	r24, 0xA9	; 169
    537e:	91 e0       	ldi	r25, 0x01	; 1
    5380:	0c 94 a1 73 	jmp	0xe742	; 0xe742 <__eewr_word_m128>
    5384:	08 95       	ret

00005386 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    5386:	0e 94 8c 73 	call	0xe718	; 0xe718 <__eewr_byte_m128>
	CRC_EEPROM_upd();
    538a:	0c 94 b7 29 	jmp	0x536e	; 0x536e <CRC_EEPROM_upd>

0000538e <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    538e:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    5390:	6f ef       	ldi	r22, 0xFF	; 255
    5392:	8f ef       	ldi	r24, 0xFF	; 255
    5394:	9f e0       	ldi	r25, 0x0F	; 15
    5396:	0e 94 c3 29 	call	0x5386	; 0x5386 <ewb>
    539a:	ff cf       	rjmp	.-2      	; 0x539a <Start_Bootloader+0xc>

0000539c <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    539c:	0e 94 a1 73 	call	0xe742	; 0xe742 <__eewr_word_m128>
	CRC_EEPROM_upd();
    53a0:	0c 94 b7 29 	jmp	0x536e	; 0x536e <CRC_EEPROM_upd>

000053a4 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    53a4:	0e 94 99 73 	call	0xe732	; 0xe732 <__eewr_dword_m128>
	CRC_EEPROM_upd();
    53a8:	0c 94 b7 29 	jmp	0x536e	; 0x536e <CRC_EEPROM_upd>

000053ac <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    53ac:	0e 94 82 73 	call	0xe704	; 0xe704 <__eewr_block_m128>
	CRC_EEPROM_upd();
    53b0:	0c 94 b7 29 	jmp	0x536e	; 0x536e <CRC_EEPROM_upd>

000053b4 <CRC_Flash_calc>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    53b4:	0f 93       	push	r16
    53b6:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    53b8:	20 e0       	ldi	r18, 0x00	; 0
    53ba:	30 e0       	ldi	r19, 0x00	; 0
    53bc:	41 e0       	ldi	r20, 0x01	; 1
    53be:	50 e0       	ldi	r21, 0x00	; 0
    53c0:	60 e0       	ldi	r22, 0x00	; 0
    53c2:	70 e0       	ldi	r23, 0x00	; 0
    53c4:	87 e1       	ldi	r24, 0x17	; 23
    53c6:	98 e2       	ldi	r25, 0x28	; 40
    53c8:	0e 94 92 29 	call	0x5324	; 0x5324 <CRC>
    53cc:	8c 01       	movw	r16, r24
    53ce:	20 e0       	ldi	r18, 0x00	; 0
    53d0:	30 e0       	ldi	r19, 0x00	; 0
    53d2:	41 e0       	ldi	r20, 0x01	; 1
    53d4:	50 e0       	ldi	r21, 0x00	; 0
    53d6:	60 e0       	ldi	r22, 0x00	; 0
    53d8:	70 e0       	ldi	r23, 0x00	; 0
    53da:	8a e1       	ldi	r24, 0x1A	; 26
    53dc:	98 e2       	ldi	r25, 0x28	; 40
    53de:	0e 94 45 29 	call	0x528a	; 0x528a <CRC_Seed>
	#endif
}
    53e2:	1f 91       	pop	r17
    53e4:	0f 91       	pop	r16
    53e6:	08 95       	ret

000053e8 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    53e8:	8b ea       	ldi	r24, 0xAB	; 171
    53ea:	91 e0       	ldi	r25, 0x01	; 1
    53ec:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    53f0:	81 11       	cpse	r24, r1
    53f2:	13 c0       	rjmp	.+38     	; 0x541a <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    53f4:	0e 94 da 29 	call	0x53b4	; 0x53b4 <CRC_Flash_calc>
    53f8:	bc 01       	movw	r22, r24
    53fa:	87 ea       	ldi	r24, 0xA7	; 167
    53fc:	91 e0       	ldi	r25, 0x01	; 1
    53fe:	0e 94 a1 73 	call	0xe742	; 0xe742 <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5402:	0e 94 9b 29 	call	0x5336	; 0x5336 <CRC_EEPROM_calc>
    5406:	bc 01       	movw	r22, r24
    5408:	89 ea       	ldi	r24, 0xA9	; 169
    540a:	91 e0       	ldi	r25, 0x01	; 1
    540c:	0e 94 a1 73 	call	0xe742	; 0xe742 <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    5410:	61 e0       	ldi	r22, 0x01	; 1
    5412:	8b ea       	ldi	r24, 0xAB	; 171
    5414:	91 e0       	ldi	r25, 0x01	; 1
    5416:	0c 94 8c 73 	jmp	0xe718	; 0xe718 <__eewr_byte_m128>
    541a:	08 95       	ret

0000541c <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    541c:	8f b7       	in	r24, 0x3f	; 63
    541e:	80 78       	andi	r24, 0x80	; 128
    5420:	80 93 d8 03 	sts	0x03D8, r24
	cli();
    5424:	f8 94       	cli
	return interru_enub_flg;
}
    5426:	80 91 d8 03 	lds	r24, 0x03D8
    542a:	08 95       	ret

0000542c <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    542c:	80 91 d8 03 	lds	r24, 0x03D8
    5430:	88 23       	and	r24, r24
    5432:	09 f0       	breq	.+2      	; 0x5436 <IntOn+0xa>
		sei();
    5434:	78 94       	sei
	return interru_enub_flg;
}
    5436:	80 91 d8 03 	lds	r24, 0x03D8
    543a:	08 95       	ret

0000543c <Modbus_ReadHoldReg>:
	eww(&TCP_ListenPort, MBHoldReg1[36]);
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
}

void Modbus_ReadHoldReg(void){
	IntOff();
    543c:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5440:	87 e2       	ldi	r24, 0x27	; 39
    5442:	90 e0       	ldi	r25, 0x00	; 0
    5444:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	MBHoldReg1[0] = erw(&EM_UART_Param);
    5448:	90 93 77 08 	sts	0x0877, r25
    544c:	80 93 76 08 	sts	0x0876, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    5450:	4e e1       	ldi	r20, 0x1E	; 30
    5452:	50 e0       	ldi	r21, 0x00	; 0
    5454:	6a e7       	ldi	r22, 0x7A	; 122
    5456:	71 e0       	ldi	r23, 0x01	; 1
    5458:	88 e7       	ldi	r24, 0x78	; 120
    545a:	98 e0       	ldi	r25, 0x08	; 8
    545c:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    5460:	44 e1       	ldi	r20, 0x14	; 20
    5462:	50 e0       	ldi	r21, 0x00	; 0
    5464:	66 e6       	ldi	r22, 0x66	; 102
    5466:	71 e0       	ldi	r23, 0x01	; 1
    5468:	86 e9       	ldi	r24, 0x96	; 150
    546a:	98 e0       	ldi	r25, 0x08	; 8
    546c:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    5470:	44 e1       	ldi	r20, 0x14	; 20
    5472:	50 e0       	ldi	r21, 0x00	; 0
    5474:	62 e5       	ldi	r22, 0x52	; 82
    5476:	71 e0       	ldi	r23, 0x01	; 1
    5478:	8a ea       	ldi	r24, 0xAA	; 170
    547a:	98 e0       	ldi	r25, 0x08	; 8
    547c:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5480:	80 e2       	ldi	r24, 0x20	; 32
    5482:	91 e0       	ldi	r25, 0x01	; 1
    5484:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    5488:	90 93 bf 08 	sts	0x08BF, r25
    548c:	80 93 be 08 	sts	0x08BE, r24
    5490:	8e e0       	ldi	r24, 0x0E	; 14
    5492:	91 e0       	ldi	r25, 0x01	; 1
    5494:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    5498:	90 93 c1 08 	sts	0x08C1, r25
    549c:	80 93 c0 08 	sts	0x08C0, r24
	IntOn();
    54a0:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

000054a4 <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    54a4:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    54a6:	2f e0       	ldi	r18, 0x0F	; 15
    54a8:	88 e1       	ldi	r24, 0x18	; 24
    54aa:	90 e0       	ldi	r25, 0x00	; 0
    54ac:	0f b6       	in	r0, 0x3f	; 63
    54ae:	f8 94       	cli
    54b0:	a8 95       	wdr
    54b2:	81 bd       	out	0x21, r24	; 33
    54b4:	0f be       	out	0x3f, r0	; 63
    54b6:	21 bd       	out	0x21, r18	; 33
    54b8:	08 95       	ret

000054ba <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    54ba:	80 91 11 01 	lds	r24, 0x0111
	VacantTimer16++;
    54be:	91 e0       	ldi	r25, 0x01	; 1
    54c0:	98 0f       	add	r25, r24
    54c2:	90 93 11 01 	sts	0x0111, r25
	return N;
}
    54c6:	08 95       	ret

000054c8 <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    54c8:	80 91 10 01 	lds	r24, 0x0110
	VacantTimer32++;
    54cc:	91 e0       	ldi	r25, 0x01	; 1
    54ce:	98 0f       	add	r25, r24
    54d0:	90 93 10 01 	sts	0x0110, r25
	return N;
}
    54d4:	08 95       	ret

000054d6 <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    54d6:	1f 93       	push	r17
    54d8:	cf 93       	push	r28
    54da:	df 93       	push	r29
    54dc:	1f 92       	push	r1
    54de:	cd b7       	in	r28, 0x3d	; 61
    54e0:	de b7       	in	r29, 0x3e	; 62
    54e2:	18 2f       	mov	r17, r24
	IntOff();
    54e4:	69 83       	std	Y+1, r22	; 0x01
    54e6:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	if ((Timer8[TimerN]=Timeout)>0)
    54ea:	e1 2f       	mov	r30, r17
    54ec:	f0 e0       	ldi	r31, 0x00	; 0
    54ee:	e0 56       	subi	r30, 0x60	; 96
    54f0:	fc 4f       	sbci	r31, 0xFC	; 252
    54f2:	69 81       	ldd	r22, Y+1	; 0x01
    54f4:	60 83       	st	Z, r22
    54f6:	e1 2f       	mov	r30, r17
    54f8:	e6 95       	lsr	r30
    54fa:	e6 95       	lsr	r30
    54fc:	e6 95       	lsr	r30
    54fe:	17 70       	andi	r17, 0x07	; 7
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5500:	f0 e0       	ldi	r31, 0x00	; 0
    5502:	e9 58       	subi	r30, 0x89	; 137
    5504:	fd 4f       	sbci	r31, 0xFD	; 253
    5506:	80 81       	ld	r24, Z
    5508:	21 e0       	ldi	r18, 0x01	; 1
    550a:	30 e0       	ldi	r19, 0x00	; 0
    550c:	01 2e       	mov	r0, r17
    550e:	01 c0       	rjmp	.+2      	; 0x5512 <StartTimer8+0x3c>
    5510:	22 0f       	add	r18, r18
    5512:	0a 94       	dec	r0
    5514:	ea f7       	brpl	.-6      	; 0x5510 <StartTimer8+0x3a>

void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    5516:	66 23       	and	r22, r22
    5518:	21 f0       	breq	.+8      	; 0x5522 <StartTimer8+0x4c>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    551a:	20 95       	com	r18
    551c:	28 23       	and	r18, r24
    551e:	20 83       	st	Z, r18
    5520:	02 c0       	rjmp	.+4      	; 0x5526 <StartTimer8+0x50>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    5522:	82 2b       	or	r24, r18
    5524:	80 83       	st	Z, r24
	IntOn();
}
    5526:	0f 90       	pop	r0
    5528:	df 91       	pop	r29
    552a:	cf 91       	pop	r28
    552c:	1f 91       	pop	r17
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    552e:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

00005532 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    5532:	1f 93       	push	r17
    5534:	cf 93       	push	r28
    5536:	df 93       	push	r29
    5538:	18 2f       	mov	r17, r24
    553a:	eb 01       	movw	r28, r22
	IntOff();
    553c:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	if ((Timer16[TimerN]=Timeout)>0)
    5540:	e1 2f       	mov	r30, r17
    5542:	f0 e0       	ldi	r31, 0x00	; 0
    5544:	ee 0f       	add	r30, r30
    5546:	ff 1f       	adc	r31, r31
    5548:	e0 5e       	subi	r30, 0xE0	; 224
    554a:	fc 4f       	sbci	r31, 0xFC	; 252
    554c:	d1 83       	std	Z+1, r29	; 0x01
    554e:	c0 83       	st	Z, r28
    5550:	e1 2f       	mov	r30, r17
    5552:	e6 95       	lsr	r30
    5554:	e6 95       	lsr	r30
    5556:	e6 95       	lsr	r30
    5558:	17 70       	andi	r17, 0x07	; 7
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    555a:	f0 e0       	ldi	r31, 0x00	; 0
    555c:	e2 59       	subi	r30, 0x92	; 146
    555e:	fd 4f       	sbci	r31, 0xFD	; 253
    5560:	80 81       	ld	r24, Z
    5562:	21 e0       	ldi	r18, 0x01	; 1
    5564:	30 e0       	ldi	r19, 0x00	; 0
    5566:	01 2e       	mov	r0, r17
    5568:	01 c0       	rjmp	.+2      	; 0x556c <StartTimer16+0x3a>
    556a:	22 0f       	add	r18, r18
    556c:	0a 94       	dec	r0
    556e:	ea f7       	brpl	.-6      	; 0x556a <StartTimer16+0x38>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    5570:	cd 2b       	or	r28, r29
    5572:	21 f0       	breq	.+8      	; 0x557c <StartTimer16+0x4a>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    5574:	20 95       	com	r18
    5576:	28 23       	and	r18, r24
    5578:	20 83       	st	Z, r18
    557a:	02 c0       	rjmp	.+4      	; 0x5580 <StartTimer16+0x4e>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    557c:	82 2b       	or	r24, r18
    557e:	80 83       	st	Z, r24
	IntOn();
}
    5580:	df 91       	pop	r29
    5582:	cf 91       	pop	r28
    5584:	1f 91       	pop	r17
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5586:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

0000558a <SlavesOn>:

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    558a:	28 2f       	mov	r18, r24
    558c:	30 e0       	ldi	r19, 0x00	; 0
    558e:	f9 01       	movw	r30, r18
    5590:	ee 0f       	add	r30, r30
    5592:	ff 1f       	adc	r31, r31
    5594:	ee 0f       	add	r30, r30
    5596:	ff 1f       	adc	r31, r31
    5598:	e9 5a       	subi	r30, 0xA9	; 169
    559a:	fd 4f       	sbci	r31, 0xFD	; 253
    559c:	10 82       	st	Z, r1
    559e:	11 82       	std	Z+1, r1	; 0x01
    55a0:	12 82       	std	Z+2, r1	; 0x02
    55a2:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    55a4:	f9 01       	movw	r30, r18
    55a6:	ec 51       	subi	r30, 0x1C	; 28
    55a8:	fc 4f       	sbci	r31, 0xFC	; 252
    55aa:	60 81       	ld	r22, Z
    55ac:	94 e6       	ldi	r25, 0x64	; 100
    55ae:	69 9f       	mul	r22, r25
    55b0:	b0 01       	movw	r22, r0
    55b2:	11 24       	eor	r1, r1
    55b4:	90 91 56 02 	lds	r25, 0x0256
    55b8:	9f 5f       	subi	r25, 0xFF	; 255
    55ba:	89 0f       	add	r24, r25
    55bc:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>

000055c0 <NextSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    55c0:	4f 92       	push	r4
    55c2:	5f 92       	push	r5
    55c4:	6f 92       	push	r6
    55c6:	7f 92       	push	r7
    55c8:	8f 92       	push	r8
    55ca:	9f 92       	push	r9
    55cc:	af 92       	push	r10
    55ce:	bf 92       	push	r11
    55d0:	cf 92       	push	r12
    55d2:	df 92       	push	r13
    55d4:	ef 92       	push	r14
    55d6:	ff 92       	push	r15
    55d8:	0f 93       	push	r16
    55da:	1f 93       	push	r17
    55dc:	cf 93       	push	r28
    55de:	df 93       	push	r29
    55e0:	98 2e       	mov	r9, r24
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
    55e2:	83 e0       	ldi	r24, 0x03	; 3
    55e4:	98 9e       	mul	r9, r24
    55e6:	f0 01       	movw	r30, r0
    55e8:	11 24       	eor	r1, r1
    55ea:	e3 5f       	subi	r30, 0xF3	; 243
    55ec:	f2 4b       	sbci	r31, 0xB2	; 178

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    55ee:	74 90       	lpm	r7, Z
// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	uint8_t i = 0;
    55f0:	81 2c       	mov	r8, r1

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
    55f2:	61 2c       	mov	r6, r1
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    55f4:	09 2d       	mov	r16, r9
    55f6:	10 e0       	ldi	r17, 0x00	; 0
    55f8:	e8 01       	movw	r28, r16
    55fa:	c0 50       	subi	r28, 0x00	; 0
    55fc:	da 4f       	sbci	r29, 0xFA	; 250
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    55fe:	98 01       	movw	r18, r16
    5600:	22 0f       	add	r18, r18
    5602:	33 1f       	adc	r19, r19
    5604:	f9 01       	movw	r30, r18
    5606:	e9 5c       	subi	r30, 0xC9	; 201
    5608:	f6 4f       	sbci	r31, 0xF6	; 246
    560a:	5f 01       	movw	r10, r30
    560c:	c9 01       	movw	r24, r18
    560e:	8b 5c       	subi	r24, 0xCB	; 203
    5610:	97 4f       	sbci	r25, 0xF7	; 247
    5612:	6c 01       	movw	r12, r24
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    5614:	78 01       	movw	r14, r16
    5616:	ee 0c       	add	r14, r14
    5618:	ff 1c       	adc	r15, r15
    561a:	ee 0c       	add	r14, r14
    561c:	ff 1c       	adc	r15, r15
    561e:	f7 01       	movw	r30, r14
    5620:	e9 5a       	subi	r30, 0xA9	; 169
    5622:	fd 4f       	sbci	r31, 0xFD	; 253
    5624:	7f 01       	movw	r14, r30
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    5626:	98 81       	ld	r25, Y
    5628:	9f 5f       	subi	r25, 0xFF	; 255
    562a:	98 83       	st	Y, r25
    562c:	97 11       	cpse	r25, r7
    562e:	27 c0       	rjmp	.+78     	; 0x567e <NextSlave+0xbe>
			CurrSlave[MB_N] = 0;
    5630:	18 82       	st	Y, r1
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5632:	60 90 56 02 	lds	r6, 0x0256
    5636:	63 94       	inc	r6
    5638:	63 94       	inc	r6
    563a:	69 0c       	add	r6, r9

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    563c:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint16_t Time = Timer16[TimerN];
    5640:	a6 2d       	mov	r26, r6
    5642:	b0 e0       	ldi	r27, 0x00	; 0
    5644:	aa 0f       	add	r26, r26
    5646:	bb 1f       	adc	r27, r27
    5648:	a0 5e       	subi	r26, 0xE0	; 224
    564a:	bc 4f       	sbci	r27, 0xFC	; 252
    564c:	4d 90       	ld	r4, X+
    564e:	5c 90       	ld	r5, X
	IntOn();
    5650:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
    5654:	92 01       	movw	r18, r4
    5656:	20 95       	com	r18
    5658:	30 95       	com	r19
    565a:	f5 01       	movw	r30, r10
    565c:	31 83       	std	Z+1, r19	; 0x01
    565e:	20 83       	st	Z, r18
    5660:	f6 01       	movw	r30, r12
    5662:	40 81       	ld	r20, Z
    5664:	51 81       	ldd	r21, Z+1	; 0x01
    5666:	42 17       	cp	r20, r18
    5668:	53 07       	cpc	r21, r19
    566a:	10 f4       	brcc	.+4      	; 0x5670 <NextSlave+0xb0>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    566c:	31 83       	std	Z+1, r19	; 0x01
    566e:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    5670:	6f ef       	ldi	r22, 0xFF	; 255
    5672:	7f ef       	ldi	r23, 0xFF	; 255
    5674:	86 2d       	mov	r24, r6
    5676:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;
    567a:	66 24       	eor	r6, r6
    567c:	63 94       	inc	r6

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    567e:	f7 01       	movw	r30, r14
    5680:	40 81       	ld	r20, Z
    5682:	51 81       	ldd	r21, Z+1	; 0x01
    5684:	62 81       	ldd	r22, Z+2	; 0x02
    5686:	73 81       	ldd	r23, Z+3	; 0x03
    5688:	08 80       	ld	r0, Y
    568a:	04 c0       	rjmp	.+8      	; 0x5694 <NextSlave+0xd4>
    568c:	76 95       	lsr	r23
    568e:	67 95       	ror	r22
    5690:	57 95       	ror	r21
    5692:	47 95       	ror	r20
    5694:	0a 94       	dec	r0
    5696:	d2 f7       	brpl	.-12     	; 0x568c <NextSlave+0xcc>
    5698:	40 ff       	sbrs	r20, 0
    569a:	03 c0       	rjmp	.+6      	; 0x56a2 <NextSlave+0xe2>
    569c:	83 94       	inc	r8
    569e:	87 14       	cp	r8, r7
    56a0:	10 f2       	brcs	.-124    	; 0x5626 <NextSlave+0x66>
	if (i==SlaveQt) {
    56a2:	87 10       	cpse	r8, r7
    56a4:	09 c0       	rjmp	.+18     	; 0x56b8 <NextSlave+0xf8>
		SlavesOn(MB_N);
    56a6:	89 2d       	mov	r24, r9
    56a8:	0e 94 c5 2a 	call	0x558a	; 0x558a <SlavesOn>
		if (++CurrSlave[MB_N]==SlaveQt)
    56ac:	98 81       	ld	r25, Y
    56ae:	9f 5f       	subi	r25, 0xFF	; 255
    56b0:	98 83       	st	Y, r25
    56b2:	98 11       	cpse	r25, r8
    56b4:	01 c0       	rjmp	.+2      	; 0x56b8 <NextSlave+0xf8>
			CurrSlave[MB_N] = 0;
    56b6:	18 82       	st	Y, r1
	}
	CurrQuery[MB_N] = 0;
    56b8:	f8 01       	movw	r30, r16
    56ba:	e9 5f       	subi	r30, 0xF9	; 249
    56bc:	f9 4f       	sbci	r31, 0xF9	; 249
    56be:	10 82       	st	Z, r1
	return Over;
}
    56c0:	86 2d       	mov	r24, r6
    56c2:	df 91       	pop	r29
    56c4:	cf 91       	pop	r28
    56c6:	1f 91       	pop	r17
    56c8:	0f 91       	pop	r16
    56ca:	ff 90       	pop	r15
    56cc:	ef 90       	pop	r14
    56ce:	df 90       	pop	r13
    56d0:	cf 90       	pop	r12
    56d2:	bf 90       	pop	r11
    56d4:	af 90       	pop	r10
    56d6:	9f 90       	pop	r9
    56d8:	8f 90       	pop	r8
    56da:	7f 90       	pop	r7
    56dc:	6f 90       	pop	r6
    56de:	5f 90       	pop	r5
    56e0:	4f 90       	pop	r4
    56e2:	08 95       	ret

000056e4 <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    56e4:	0f 93       	push	r16
    56e6:	1f 93       	push	r17
    56e8:	cf 93       	push	r28
    56ea:	df 93       	push	r29
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    56ec:	28 2f       	mov	r18, r24
    56ee:	30 e0       	ldi	r19, 0x00	; 0
    56f0:	f9 01       	movw	r30, r18
    56f2:	e4 5e       	subi	r30, 0xE4	; 228
    56f4:	f9 4f       	sbci	r31, 0xF9	; 249
    56f6:	90 81       	ld	r25, Z
    56f8:	92 30       	cpi	r25, 0x02	; 2
    56fa:	11 f4       	brne	.+4      	; 0x5700 <FailSlave+0x1c>
		MB_SingleState[MB_N] = MB_SingleIdle;
    56fc:	10 82       	st	Z, r1
    56fe:	54 c0       	rjmp	.+168    	; 0x57a8 <FailSlave+0xc4>
	else{
		MB_CPT[MB_N][4]++;	// -    
    5700:	f9 01       	movw	r30, r18
    5702:	d4 e0       	ldi	r29, 0x04	; 4
    5704:	ee 0f       	add	r30, r30
    5706:	ff 1f       	adc	r31, r31
    5708:	da 95       	dec	r29
    570a:	e1 f7       	brne	.-8      	; 0x5704 <FailSlave+0x20>
    570c:	ea 5e       	subi	r30, 0xEA	; 234
    570e:	f4 4f       	sbci	r31, 0xF4	; 244
    5710:	40 85       	ldd	r20, Z+8	; 0x08
    5712:	51 85       	ldd	r21, Z+9	; 0x09
    5714:	4f 5f       	subi	r20, 0xFF	; 255
    5716:	5f 4f       	sbci	r21, 0xFF	; 255
    5718:	51 87       	std	Z+9, r21	; 0x09
    571a:	40 87       	std	Z+8, r20	; 0x08
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    571c:	f9 01       	movw	r30, r18
    571e:	e5 5a       	subi	r30, 0xA5	; 165
    5720:	fd 4f       	sbci	r31, 0xFD	; 253
    5722:	90 81       	ld	r25, Z
    5724:	9f 5f       	subi	r25, 0xFF	; 255
    5726:	90 83       	st	Z, r25
    5728:	d9 01       	movw	r26, r18
    572a:	ae 53       	subi	r26, 0x3E	; 62
    572c:	b7 4f       	sbci	r27, 0xF7	; 247
    572e:	4c 91       	ld	r20, X
    5730:	94 13       	cpse	r25, r20
    5732:	3a c0       	rjmp	.+116    	; 0x57a8 <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    5734:	d9 01       	movw	r26, r18
    5736:	a0 50       	subi	r26, 0x00	; 0
    5738:	ba 4f       	sbci	r27, 0xFA	; 250
    573a:	41 e0       	ldi	r20, 0x01	; 1
    573c:	50 e0       	ldi	r21, 0x00	; 0
    573e:	60 e0       	ldi	r22, 0x00	; 0
    5740:	70 e0       	ldi	r23, 0x00	; 0
    5742:	0c 90       	ld	r0, X
    5744:	04 c0       	rjmp	.+8      	; 0x574e <FailSlave+0x6a>
    5746:	44 0f       	add	r20, r20
    5748:	55 1f       	adc	r21, r21
    574a:	66 1f       	adc	r22, r22
    574c:	77 1f       	adc	r23, r23
    574e:	0a 94       	dec	r0
    5750:	d2 f7       	brpl	.-12     	; 0x5746 <FailSlave+0x62>
			SlaveOff[MB_N] |=S_N;
    5752:	d9 01       	movw	r26, r18
    5754:	aa 0f       	add	r26, r26
    5756:	bb 1f       	adc	r27, r27
    5758:	aa 0f       	add	r26, r26
    575a:	bb 1f       	adc	r27, r27
    575c:	ed 01       	movw	r28, r26
    575e:	cf 5f       	subi	r28, 0xFF	; 255
    5760:	d4 4f       	sbci	r29, 0xF4	; 244
    5762:	08 81       	ld	r16, Y
    5764:	19 81       	ldd	r17, Y+1	; 0x01
    5766:	2a 81       	ldd	r18, Y+2	; 0x02
    5768:	3b 81       	ldd	r19, Y+3	; 0x03
    576a:	04 2b       	or	r16, r20
    576c:	15 2b       	or	r17, r21
    576e:	26 2b       	or	r18, r22
    5770:	37 2b       	or	r19, r23
    5772:	08 83       	st	Y, r16
    5774:	19 83       	std	Y+1, r17	; 0x01
    5776:	2a 83       	std	Y+2, r18	; 0x02
    5778:	3b 83       	std	Y+3, r19	; 0x03
			SlaveSkip[MB_N] |=S_N;
    577a:	a9 5a       	subi	r26, 0xA9	; 169
    577c:	bd 4f       	sbci	r27, 0xFD	; 253
    577e:	0d 91       	ld	r16, X+
    5780:	1d 91       	ld	r17, X+
    5782:	2d 91       	ld	r18, X+
    5784:	3c 91       	ld	r19, X
    5786:	13 97       	sbiw	r26, 0x03	; 3
    5788:	04 2b       	or	r16, r20
    578a:	15 2b       	or	r17, r21
    578c:	26 2b       	or	r18, r22
    578e:	37 2b       	or	r19, r23
    5790:	0d 93       	st	X+, r16
    5792:	1d 93       	st	X+, r17
    5794:	2d 93       	st	X+, r18
    5796:	3c 93       	st	X, r19
    5798:	13 97       	sbiw	r26, 0x03	; 3
			Try[MB_N] = 0;
    579a:	10 82       	st	Z, r1
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    579c:	df 91       	pop	r29
    579e:	cf 91       	pop	r28
    57a0:	1f 91       	pop	r17
    57a2:	0f 91       	pop	r16
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
			SlaveOff[MB_N] |=S_N;
			SlaveSkip[MB_N] |=S_N;
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
    57a4:	0c 94 e0 2a 	jmp	0x55c0	; 0x55c0 <NextSlave>
		}
	}
	return Over;
}
    57a8:	80 e0       	ldi	r24, 0x00	; 0
    57aa:	df 91       	pop	r29
    57ac:	cf 91       	pop	r28
    57ae:	1f 91       	pop	r17
    57b0:	0f 91       	pop	r16
    57b2:	08 95       	ret

000057b4 <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    57b4:	1f 93       	push	r17
    57b6:	cf 93       	push	r28
    57b8:	df 93       	push	r29
    57ba:	00 d0       	rcall	.+0      	; 0x57bc <StartTimer32+0x8>
    57bc:	00 d0       	rcall	.+0      	; 0x57be <StartTimer32+0xa>
    57be:	cd b7       	in	r28, 0x3d	; 61
    57c0:	de b7       	in	r29, 0x3e	; 62
    57c2:	18 2f       	mov	r17, r24
	IntOff();
    57c4:	49 83       	std	Y+1, r20	; 0x01
    57c6:	5a 83       	std	Y+2, r21	; 0x02
    57c8:	6b 83       	std	Y+3, r22	; 0x03
    57ca:	7c 83       	std	Y+4, r23	; 0x04
    57cc:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	if ((Timer32[TimerN]=Timeout)>0)
    57d0:	84 e0       	ldi	r24, 0x04	; 4
    57d2:	18 9f       	mul	r17, r24
    57d4:	f0 01       	movw	r30, r0
    57d6:	11 24       	eor	r1, r1
    57d8:	e0 58       	subi	r30, 0x80	; 128
    57da:	fd 4f       	sbci	r31, 0xFD	; 253
    57dc:	49 81       	ldd	r20, Y+1	; 0x01
    57de:	5a 81       	ldd	r21, Y+2	; 0x02
    57e0:	6b 81       	ldd	r22, Y+3	; 0x03
    57e2:	7c 81       	ldd	r23, Y+4	; 0x04
    57e4:	40 83       	st	Z, r20
    57e6:	51 83       	std	Z+1, r21	; 0x01
    57e8:	62 83       	std	Z+2, r22	; 0x02
    57ea:	73 83       	std	Z+3, r23	; 0x03
    57ec:	e1 2f       	mov	r30, r17
    57ee:	e6 95       	lsr	r30
    57f0:	e6 95       	lsr	r30
    57f2:	e6 95       	lsr	r30
    57f4:	17 70       	andi	r17, 0x07	; 7
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    57f6:	f0 e0       	ldi	r31, 0x00	; 0
    57f8:	e8 59       	subi	r30, 0x98	; 152
    57fa:	fd 4f       	sbci	r31, 0xFD	; 253
    57fc:	80 81       	ld	r24, Z
    57fe:	21 e0       	ldi	r18, 0x01	; 1
    5800:	30 e0       	ldi	r19, 0x00	; 0
    5802:	01 2e       	mov	r0, r17
    5804:	01 c0       	rjmp	.+2      	; 0x5808 <StartTimer32+0x54>
    5806:	22 0f       	add	r18, r18
    5808:	0a 94       	dec	r0
    580a:	ea f7       	brpl	.-6      	; 0x5806 <StartTimer32+0x52>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    580c:	45 2b       	or	r20, r21
    580e:	46 2b       	or	r20, r22
    5810:	47 2b       	or	r20, r23
    5812:	21 f0       	breq	.+8      	; 0x581c <StartTimer32+0x68>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    5814:	20 95       	com	r18
    5816:	28 23       	and	r18, r24
    5818:	20 83       	st	Z, r18
    581a:	02 c0       	rjmp	.+4      	; 0x5820 <StartTimer32+0x6c>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    581c:	82 2b       	or	r24, r18
    581e:	80 83       	st	Z, r24
	IntOn();
}
    5820:	0f 90       	pop	r0
    5822:	0f 90       	pop	r0
    5824:	0f 90       	pop	r0
    5826:	0f 90       	pop	r0
    5828:	df 91       	pop	r29
    582a:	cf 91       	pop	r28
    582c:	1f 91       	pop	r17
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    582e:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

00005832 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    5832:	a8 2f       	mov	r26, r24
    5834:	a6 95       	lsr	r26
    5836:	a6 95       	lsr	r26
    5838:	a6 95       	lsr	r26
    583a:	b0 e0       	ldi	r27, 0x00	; 0
    583c:	a9 58       	subi	r26, 0x89	; 137
    583e:	bd 4f       	sbci	r27, 0xFD	; 253
    5840:	2c 91       	ld	r18, X
    5842:	30 e0       	ldi	r19, 0x00	; 0
    5844:	98 2f       	mov	r25, r24
    5846:	97 70       	andi	r25, 0x07	; 7
    5848:	02 c0       	rjmp	.+4      	; 0x584e <Timer8Stopp+0x1c>
    584a:	35 95       	asr	r19
    584c:	27 95       	ror	r18
    584e:	9a 95       	dec	r25
    5850:	e2 f7       	brpl	.-8      	; 0x584a <Timer8Stopp+0x18>
    5852:	20 ff       	sbrs	r18, 0
    5854:	07 c0       	rjmp	.+14     	; 0x5864 <Timer8Stopp+0x32>
    5856:	e8 2f       	mov	r30, r24
    5858:	f0 e0       	ldi	r31, 0x00	; 0
    585a:	e0 56       	subi	r30, 0x60	; 96
    585c:	fc 4f       	sbci	r31, 0xFC	; 252
    585e:	90 81       	ld	r25, Z
    5860:	81 e0       	ldi	r24, 0x01	; 1
    5862:	91 11       	cpse	r25, r1
    5864:	80 e0       	ldi	r24, 0x00	; 0
}
    5866:	08 95       	ret

00005868 <Timer16Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
    5868:	cf 93       	push	r28
    586a:	c8 2f       	mov	r28, r24
	IntOff();
    586c:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    5870:	ac 2f       	mov	r26, r28
    5872:	a6 95       	lsr	r26
    5874:	a6 95       	lsr	r26
    5876:	a6 95       	lsr	r26
    5878:	b0 e0       	ldi	r27, 0x00	; 0
    587a:	a2 59       	subi	r26, 0x92	; 146
    587c:	bd 4f       	sbci	r27, 0xFD	; 253
    587e:	2c 91       	ld	r18, X
    5880:	30 e0       	ldi	r19, 0x00	; 0
    5882:	8c 2f       	mov	r24, r28
    5884:	87 70       	andi	r24, 0x07	; 7
    5886:	02 c0       	rjmp	.+4      	; 0x588c <Timer16Stopp+0x24>
    5888:	35 95       	asr	r19
    588a:	27 95       	ror	r18
    588c:	8a 95       	dec	r24
    588e:	e2 f7       	brpl	.-8      	; 0x5888 <Timer16Stopp+0x20>
    5890:	20 ff       	sbrs	r18, 0
    5892:	0b c0       	rjmp	.+22     	; 0x58aa <Timer16Stopp+0x42>
    5894:	ec 2f       	mov	r30, r28
    5896:	f0 e0       	ldi	r31, 0x00	; 0
    5898:	ee 0f       	add	r30, r30
    589a:	ff 1f       	adc	r31, r31
    589c:	e0 5e       	subi	r30, 0xE0	; 224
    589e:	fc 4f       	sbci	r31, 0xFC	; 252
    58a0:	20 81       	ld	r18, Z
    58a2:	31 81       	ldd	r19, Z+1	; 0x01
    58a4:	c1 e0       	ldi	r28, 0x01	; 1
    58a6:	23 2b       	or	r18, r19
    58a8:	09 f0       	breq	.+2      	; 0x58ac <Timer16Stopp+0x44>
    58aa:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    58ac:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
	return T_S;
}
    58b0:	8c 2f       	mov	r24, r28
    58b2:	cf 91       	pop	r28
    58b4:	08 95       	ret

000058b6 <Timer32Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
    58b6:	cf 93       	push	r28
    58b8:	c8 2f       	mov	r28, r24
	IntOff();
    58ba:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    58be:	ac 2f       	mov	r26, r28
    58c0:	a6 95       	lsr	r26
    58c2:	a6 95       	lsr	r26
    58c4:	a6 95       	lsr	r26
    58c6:	b0 e0       	ldi	r27, 0x00	; 0
    58c8:	a8 59       	subi	r26, 0x98	; 152
    58ca:	bd 4f       	sbci	r27, 0xFD	; 253
    58cc:	2c 91       	ld	r18, X
    58ce:	30 e0       	ldi	r19, 0x00	; 0
    58d0:	8c 2f       	mov	r24, r28
    58d2:	87 70       	andi	r24, 0x07	; 7
    58d4:	02 c0       	rjmp	.+4      	; 0x58da <Timer32Stopp+0x24>
    58d6:	35 95       	asr	r19
    58d8:	27 95       	ror	r18
    58da:	8a 95       	dec	r24
    58dc:	e2 f7       	brpl	.-8      	; 0x58d6 <Timer32Stopp+0x20>
    58de:	20 ff       	sbrs	r18, 0
    58e0:	0f c0       	rjmp	.+30     	; 0x5900 <Timer32Stopp+0x4a>
    58e2:	84 e0       	ldi	r24, 0x04	; 4
    58e4:	c8 9f       	mul	r28, r24
    58e6:	f0 01       	movw	r30, r0
    58e8:	11 24       	eor	r1, r1
    58ea:	e0 58       	subi	r30, 0x80	; 128
    58ec:	fd 4f       	sbci	r31, 0xFD	; 253
    58ee:	40 81       	ld	r20, Z
    58f0:	51 81       	ldd	r21, Z+1	; 0x01
    58f2:	62 81       	ldd	r22, Z+2	; 0x02
    58f4:	73 81       	ldd	r23, Z+3	; 0x03
    58f6:	c1 e0       	ldi	r28, 0x01	; 1
    58f8:	45 2b       	or	r20, r21
    58fa:	46 2b       	or	r20, r22
    58fc:	47 2b       	or	r20, r23
    58fe:	09 f0       	breq	.+2      	; 0x5902 <Timer32Stopp+0x4c>
    5900:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5902:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
	return T_S;
}
    5906:	8c 2f       	mov	r24, r28
    5908:	cf 91       	pop	r28
    590a:	08 95       	ret

0000590c <ResetTimer16>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    590c:	cf 93       	push	r28
    590e:	c8 2f       	mov	r28, r24
	IntOff();
    5910:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    5914:	ac 2f       	mov	r26, r28
    5916:	a6 95       	lsr	r26
    5918:	a6 95       	lsr	r26
    591a:	a6 95       	lsr	r26
    591c:	b0 e0       	ldi	r27, 0x00	; 0
    591e:	a2 59       	subi	r26, 0x92	; 146
    5920:	bd 4f       	sbci	r27, 0xFD	; 253
    5922:	8c 91       	ld	r24, X
    5924:	9c 2f       	mov	r25, r28
    5926:	97 70       	andi	r25, 0x07	; 7
    5928:	21 e0       	ldi	r18, 0x01	; 1
    592a:	30 e0       	ldi	r19, 0x00	; 0
    592c:	01 c0       	rjmp	.+2      	; 0x5930 <ResetTimer16+0x24>
    592e:	22 0f       	add	r18, r18
    5930:	9a 95       	dec	r25
    5932:	ea f7       	brpl	.-6      	; 0x592e <ResetTimer16+0x22>
    5934:	82 2b       	or	r24, r18
    5936:	8c 93       	st	X, r24
	Timer16[TimerN] = 0;
    5938:	ec 2f       	mov	r30, r28
    593a:	f0 e0       	ldi	r31, 0x00	; 0
    593c:	ee 0f       	add	r30, r30
    593e:	ff 1f       	adc	r31, r31
    5940:	e0 5e       	subi	r30, 0xE0	; 224
    5942:	fc 4f       	sbci	r31, 0xFC	; 252
    5944:	11 82       	std	Z+1, r1	; 0x01
    5946:	10 82       	st	Z, r1
	IntOn();
}
    5948:	cf 91       	pop	r28
ResetTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
	Timer16[TimerN] = 0;
	IntOn();
    594a:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

0000594e <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    594e:	60 91 1d 06 	lds	r22, 0x061D
    5952:	83 ea       	ldi	r24, 0xA3	; 163
    5954:	91 e0       	ldi	r25, 0x01	; 1
    5956:	0e 94 c3 29 	call	0x5386	; 0x5386 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    595a:	60 91 35 0e 	lds	r22, 0x0E35
    595e:	70 91 36 0e 	lds	r23, 0x0E36
    5962:	81 ea       	ldi	r24, 0xA1	; 161
    5964:	91 e0       	ldi	r25, 0x01	; 1
    5966:	0c 94 ce 29 	jmp	0x539c	; 0x539c <eww>

0000596a <TimeInit>:
		CCP = CCP_IOREG_gc; CLK.CTRL = CLK_SCLKSEL_PLL_gc;
		CCP = CCP_IOREG_gc; CLK.LOCK = CLK_LOCK_bm;
	#endif

	// WDT
	WdtOn();
    596a:	0e 94 52 2a 	call	0x54a4	; 0x54a4 <WdtOn>

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    596e:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    5970:	8a ee       	ldi	r24, 0xEA	; 234
    5972:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
    5974:	80 e2       	ldi	r24, 0x20	; 32
    5976:	9e e4       	ldi	r25, 0x4E	; 78
    5978:	9b bd       	out	0x2b, r25	; 43
    597a:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
    597c:	87 b7       	in	r24, 0x37	; 55
    597e:	80 61       	ori	r24, 0x10	; 16
    5980:	87 bf       	out	0x37, r24	; 55
    5982:	80 e0       	ldi	r24, 0x00	; 0
    5984:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    5986:	2f ef       	ldi	r18, 0xFF	; 255
    5988:	fc 01       	movw	r30, r24
    598a:	e9 58       	subi	r30, 0x89	; 137
    598c:	fd 4f       	sbci	r31, 0xFD	; 253
    598e:	20 83       	st	Z, r18
    5990:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    5992:	87 30       	cpi	r24, 0x07	; 7
    5994:	91 05       	cpc	r25, r1
    5996:	c1 f7       	brne	.-16     	; 0x5988 <TimeInit+0x1e>
    5998:	80 e0       	ldi	r24, 0x00	; 0
    599a:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    599c:	3f ef       	ldi	r19, 0xFF	; 255
    599e:	fc 01       	movw	r30, r24
    59a0:	e2 59       	subi	r30, 0x92	; 146
    59a2:	fd 4f       	sbci	r31, 0xFD	; 253
    59a4:	2f ef       	ldi	r18, 0xFF	; 255
    59a6:	30 83       	st	Z, r19
    59a8:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    59aa:	89 30       	cpi	r24, 0x09	; 9
    59ac:	91 05       	cpc	r25, r1
    59ae:	b9 f7       	brne	.-18     	; 0x599e <TimeInit+0x34>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    59b0:	20 93 68 02 	sts	0x0268, r18
    59b4:	20 93 69 02 	sts	0x0269, r18
    59b8:	20 93 6a 02 	sts	0x026A, r18
    59bc:	20 93 6b 02 	sts	0x026B, r18
    59c0:	20 93 6c 02 	sts	0x026C, r18
    59c4:	20 93 6d 02 	sts	0x026D, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    59c8:	83 ea       	ldi	r24, 0xA3	; 163
    59ca:	91 e0       	ldi	r25, 0x01	; 1
    59cc:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    59d0:	80 93 1d 06 	sts	0x061D, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    59d4:	81 ea       	ldi	r24, 0xA1	; 161
    59d6:	91 e0       	ldi	r25, 0x01	; 1
    59d8:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
    59dc:	90 93 36 0e 	sts	0x0E36, r25
    59e0:	80 93 35 0e 	sts	0x0E35, r24
    59e4:	08 95       	ret

000059e6 <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    59e6:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    59ea:	91 e0       	ldi	r25, 0x01	; 1
    59ec:	98 0f       	add	r25, r24
    59ee:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    59f2:	80 93 67 02 	sts	0x0267, r24
	StartTimer8(TD_Scan, 0xFF);
    59f6:	6f ef       	ldi	r22, 0xFF	; 255
    59f8:	0c 94 6b 2a 	jmp	0x54d6	; 0x54d6 <StartTimer8>

000059fc <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    59fc:	1f 92       	push	r1
    59fe:	0f 92       	push	r0
    5a00:	0f b6       	in	r0, 0x3f	; 63
    5a02:	0f 92       	push	r0
    5a04:	11 24       	eor	r1, r1
    5a06:	0b b6       	in	r0, 0x3b	; 59
    5a08:	0f 92       	push	r0
    5a0a:	2f 93       	push	r18
    5a0c:	3f 93       	push	r19
    5a0e:	4f 93       	push	r20
    5a10:	5f 93       	push	r21
    5a12:	6f 93       	push	r22
    5a14:	8f 93       	push	r24
    5a16:	9f 93       	push	r25
    5a18:	ef 93       	push	r30
    5a1a:	ff 93       	push	r31
	TickCounter++;
    5a1c:	80 91 66 02 	lds	r24, 0x0266
    5a20:	8f 5f       	subi	r24, 0xFF	; 255
    5a22:	80 93 66 02 	sts	0x0266, r24
    5a26:	80 e0       	ldi	r24, 0x00	; 0
    5a28:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5a2a:	41 e0       	ldi	r20, 0x01	; 1
    5a2c:	50 e0       	ldi	r21, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    5a2e:	20 91 7e 02 	lds	r18, 0x027E
    5a32:	30 e0       	ldi	r19, 0x00	; 0
    5a34:	08 2e       	mov	r0, r24
    5a36:	02 c0       	rjmp	.+4      	; 0x5a3c <__vector_12+0x40>
    5a38:	35 95       	asr	r19
    5a3a:	27 95       	ror	r18
    5a3c:	0a 94       	dec	r0
    5a3e:	e2 f7       	brpl	.-8      	; 0x5a38 <__vector_12+0x3c>
    5a40:	20 fd       	sbrc	r18, 0
    5a42:	13 c0       	rjmp	.+38     	; 0x5a6a <__vector_12+0x6e>
    5a44:	fc 01       	movw	r30, r24
    5a46:	e0 53       	subi	r30, 0x30	; 48
    5a48:	fc 4f       	sbci	r31, 0xFC	; 252
    5a4a:	20 81       	ld	r18, Z
    5a4c:	21 50       	subi	r18, 0x01	; 1
    5a4e:	20 83       	st	Z, r18
    5a50:	21 11       	cpse	r18, r1
    5a52:	0b c0       	rjmp	.+22     	; 0x5a6a <__vector_12+0x6e>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5a54:	60 91 7e 02 	lds	r22, 0x027E
    5a58:	9a 01       	movw	r18, r20
    5a5a:	08 2e       	mov	r0, r24
    5a5c:	01 c0       	rjmp	.+2      	; 0x5a60 <__vector_12+0x64>
    5a5e:	22 0f       	add	r18, r18
    5a60:	0a 94       	dec	r0
    5a62:	ea f7       	brpl	.-6      	; 0x5a5e <__vector_12+0x62>
    5a64:	62 2b       	or	r22, r18
    5a66:	60 93 7e 02 	sts	0x027E, r22
    5a6a:	01 96       	adiw	r24, 0x01	; 1
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    5a6c:	88 30       	cpi	r24, 0x08	; 8
    5a6e:	91 05       	cpc	r25, r1
    5a70:	f1 f6       	brne	.-68     	; 0x5a2e <__vector_12+0x32>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    5a72:	ff 91       	pop	r31
    5a74:	ef 91       	pop	r30
    5a76:	9f 91       	pop	r25
    5a78:	8f 91       	pop	r24
    5a7a:	6f 91       	pop	r22
    5a7c:	5f 91       	pop	r21
    5a7e:	4f 91       	pop	r20
    5a80:	3f 91       	pop	r19
    5a82:	2f 91       	pop	r18
    5a84:	0f 90       	pop	r0
    5a86:	0b be       	out	0x3b, r0	; 59
    5a88:	0f 90       	pop	r0
    5a8a:	0f be       	out	0x3f, r0	; 63
    5a8c:	0f 90       	pop	r0
    5a8e:	1f 90       	pop	r1
    5a90:	18 95       	reti

00005a92 <TimersInc>:
void 
TimersInc(void)
{
    5a92:	ef 92       	push	r14
    5a94:	ff 92       	push	r15
    5a96:	0f 93       	push	r16
    5a98:	1f 93       	push	r17
    5a9a:	cf 93       	push	r28
    5a9c:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    5a9e:	f8 94       	cli
	TickCounterVar = TickCounter;
    5aa0:	00 91 66 02 	lds	r16, 0x0266
	TickCounter = 0;
    5aa4:	10 92 66 02 	sts	0x0266, r1
	sei();
    5aa8:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    5aaa:	10 e0       	ldi	r17, 0x00	; 0
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    5aac:	ee 24       	eor	r14, r14
    5aae:	e3 94       	inc	r14
    5ab0:	f1 2c       	mov	r15, r1
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5ab2:	10 17       	cp	r17, r16
    5ab4:	09 f4       	brne	.+2      	; 0x5ab8 <TimersInc+0x26>
    5ab6:	e2 c0       	rjmp	.+452    	; 0x5c7c <TimersInc+0x1ea>
		LiveTime++;
    5ab8:	80 91 50 09 	lds	r24, 0x0950
    5abc:	90 91 51 09 	lds	r25, 0x0951
    5ac0:	a0 91 52 09 	lds	r26, 0x0952
    5ac4:	b0 91 53 09 	lds	r27, 0x0953
    5ac8:	01 96       	adiw	r24, 0x01	; 1
    5aca:	a1 1d       	adc	r26, r1
    5acc:	b1 1d       	adc	r27, r1
    5ace:	80 93 50 09 	sts	0x0950, r24
    5ad2:	90 93 51 09 	sts	0x0951, r25
    5ad6:	a0 93 52 09 	sts	0x0952, r26
    5ada:	b0 93 53 09 	sts	0x0953, r27
    5ade:	80 e0       	ldi	r24, 0x00	; 0
    5ae0:	90 e0       	ldi	r25, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    5ae2:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    5ae4:	e8 2f       	mov	r30, r24
    5ae6:	e6 95       	lsr	r30
    5ae8:	e6 95       	lsr	r30
    5aea:	e6 95       	lsr	r30
    5aec:	f0 e0       	ldi	r31, 0x00	; 0
    5aee:	e9 58       	subi	r30, 0x89	; 137
    5af0:	fd 4f       	sbci	r31, 0xFD	; 253
    5af2:	20 81       	ld	r18, Z
    5af4:	58 2f       	mov	r21, r24
    5af6:	57 70       	andi	r21, 0x07	; 7
    5af8:	30 e0       	ldi	r19, 0x00	; 0
    5afa:	05 2e       	mov	r0, r21
    5afc:	02 c0       	rjmp	.+4      	; 0x5b02 <TimersInc+0x70>
    5afe:	35 95       	asr	r19
    5b00:	27 95       	ror	r18
    5b02:	0a 94       	dec	r0
    5b04:	e2 f7       	brpl	.-8      	; 0x5afe <TimersInc+0x6c>
    5b06:	20 fd       	sbrc	r18, 0
    5b08:	11 c0       	rjmp	.+34     	; 0x5b2c <TimersInc+0x9a>
    5b0a:	dc 01       	movw	r26, r24
    5b0c:	a0 56       	subi	r26, 0x60	; 96
    5b0e:	bc 4f       	sbci	r27, 0xFC	; 252
    5b10:	3c 91       	ld	r19, X
    5b12:	31 50       	subi	r19, 0x01	; 1
    5b14:	3c 93       	st	X, r19
    5b16:	31 11       	cpse	r19, r1
    5b18:	09 c0       	rjmp	.+18     	; 0x5b2c <TimersInc+0x9a>
				Timer8Flg[i/8] |=(1<<i%8);
    5b1a:	40 81       	ld	r20, Z
    5b1c:	97 01       	movw	r18, r14
    5b1e:	05 2e       	mov	r0, r21
    5b20:	01 c0       	rjmp	.+2      	; 0x5b24 <TimersInc+0x92>
    5b22:	22 0f       	add	r18, r18
    5b24:	0a 94       	dec	r0
    5b26:	ea f7       	brpl	.-6      	; 0x5b22 <TimersInc+0x90>
    5b28:	42 2b       	or	r20, r18
    5b2a:	40 83       	st	Z, r20
			sei();
    5b2c:	78 94       	sei
    5b2e:	01 96       	adiw	r24, 0x01	; 1
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    5b30:	80 33       	cpi	r24, 0x30	; 48
    5b32:	91 05       	cpc	r25, r1
    5b34:	b1 f6       	brne	.-84     	; 0x5ae2 <TimersInc+0x50>
    5b36:	80 e0       	ldi	r24, 0x00	; 0
    5b38:	90 e0       	ldi	r25, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    5b3a:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    5b3c:	e8 2f       	mov	r30, r24
    5b3e:	e6 95       	lsr	r30
    5b40:	e6 95       	lsr	r30
    5b42:	e6 95       	lsr	r30
    5b44:	f0 e0       	ldi	r31, 0x00	; 0
    5b46:	e2 59       	subi	r30, 0x92	; 146
    5b48:	fd 4f       	sbci	r31, 0xFD	; 253
    5b4a:	20 81       	ld	r18, Z
    5b4c:	58 2f       	mov	r21, r24
    5b4e:	57 70       	andi	r21, 0x07	; 7
    5b50:	30 e0       	ldi	r19, 0x00	; 0
    5b52:	05 2e       	mov	r0, r21
    5b54:	02 c0       	rjmp	.+4      	; 0x5b5a <TimersInc+0xc8>
    5b56:	35 95       	asr	r19
    5b58:	27 95       	ror	r18
    5b5a:	0a 94       	dec	r0
    5b5c:	e2 f7       	brpl	.-8      	; 0x5b56 <TimersInc+0xc4>
    5b5e:	20 fd       	sbrc	r18, 0
    5b60:	18 c0       	rjmp	.+48     	; 0x5b92 <TimersInc+0x100>
    5b62:	dc 01       	movw	r26, r24
    5b64:	aa 0f       	add	r26, r26
    5b66:	bb 1f       	adc	r27, r27
    5b68:	a0 5e       	subi	r26, 0xE0	; 224
    5b6a:	bc 4f       	sbci	r27, 0xFC	; 252
    5b6c:	2d 91       	ld	r18, X+
    5b6e:	3c 91       	ld	r19, X
    5b70:	11 97       	sbiw	r26, 0x01	; 1
    5b72:	21 50       	subi	r18, 0x01	; 1
    5b74:	31 09       	sbc	r19, r1
    5b76:	11 96       	adiw	r26, 0x01	; 1
    5b78:	3c 93       	st	X, r19
    5b7a:	2e 93       	st	-X, r18
    5b7c:	23 2b       	or	r18, r19
    5b7e:	49 f4       	brne	.+18     	; 0x5b92 <TimersInc+0x100>
				Timer16Flg[i/8] |=(1<<i%8);
    5b80:	40 81       	ld	r20, Z
    5b82:	97 01       	movw	r18, r14
    5b84:	05 2e       	mov	r0, r21
    5b86:	01 c0       	rjmp	.+2      	; 0x5b8a <TimersInc+0xf8>
    5b88:	22 0f       	add	r18, r18
    5b8a:	0a 94       	dec	r0
    5b8c:	ea f7       	brpl	.-6      	; 0x5b88 <TimersInc+0xf6>
    5b8e:	42 2b       	or	r20, r18
    5b90:	40 83       	st	Z, r20
			sei();
    5b92:	78 94       	sei
    5b94:	01 96       	adiw	r24, 0x01	; 1
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    5b96:	80 34       	cpi	r24, 0x40	; 64
    5b98:	91 05       	cpc	r25, r1
    5b9a:	79 f6       	brne	.-98     	; 0x5b3a <TimersInc+0xa8>
    5b9c:	20 e0       	ldi	r18, 0x00	; 0
    5b9e:	30 e0       	ldi	r19, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    5ba0:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    5ba2:	e2 2f       	mov	r30, r18
    5ba4:	e6 95       	lsr	r30
    5ba6:	e6 95       	lsr	r30
    5ba8:	e6 95       	lsr	r30
    5baa:	f0 e0       	ldi	r31, 0x00	; 0
    5bac:	e8 59       	subi	r30, 0x98	; 152
    5bae:	fd 4f       	sbci	r31, 0xFD	; 253
    5bb0:	80 81       	ld	r24, Z
    5bb2:	62 2f       	mov	r22, r18
    5bb4:	67 70       	andi	r22, 0x07	; 7
    5bb6:	90 e0       	ldi	r25, 0x00	; 0
    5bb8:	06 2e       	mov	r0, r22
    5bba:	02 c0       	rjmp	.+4      	; 0x5bc0 <TimersInc+0x12e>
    5bbc:	95 95       	asr	r25
    5bbe:	87 95       	ror	r24
    5bc0:	0a 94       	dec	r0
    5bc2:	e2 f7       	brpl	.-8      	; 0x5bbc <TimersInc+0x12a>
    5bc4:	80 fd       	sbrc	r24, 0
    5bc6:	20 c0       	rjmp	.+64     	; 0x5c08 <TimersInc+0x176>
    5bc8:	a9 01       	movw	r20, r18
    5bca:	44 0f       	add	r20, r20
    5bcc:	55 1f       	adc	r21, r21
    5bce:	44 0f       	add	r20, r20
    5bd0:	55 1f       	adc	r21, r21
    5bd2:	40 58       	subi	r20, 0x80	; 128
    5bd4:	5d 4f       	sbci	r21, 0xFD	; 253
    5bd6:	ea 01       	movw	r28, r20
    5bd8:	88 81       	ld	r24, Y
    5bda:	99 81       	ldd	r25, Y+1	; 0x01
    5bdc:	aa 81       	ldd	r26, Y+2	; 0x02
    5bde:	bb 81       	ldd	r27, Y+3	; 0x03
    5be0:	01 97       	sbiw	r24, 0x01	; 1
    5be2:	a1 09       	sbc	r26, r1
    5be4:	b1 09       	sbc	r27, r1
    5be6:	88 83       	st	Y, r24
    5be8:	99 83       	std	Y+1, r25	; 0x01
    5bea:	aa 83       	std	Y+2, r26	; 0x02
    5bec:	bb 83       	std	Y+3, r27	; 0x03
    5bee:	89 2b       	or	r24, r25
    5bf0:	8a 2b       	or	r24, r26
    5bf2:	8b 2b       	or	r24, r27
    5bf4:	49 f4       	brne	.+18     	; 0x5c08 <TimersInc+0x176>
				Timer32Flg[i/8] |=(1<<i%8);	
    5bf6:	40 81       	ld	r20, Z
    5bf8:	c7 01       	movw	r24, r14
    5bfa:	06 2e       	mov	r0, r22
    5bfc:	01 c0       	rjmp	.+2      	; 0x5c00 <TimersInc+0x16e>
    5bfe:	88 0f       	add	r24, r24
    5c00:	0a 94       	dec	r0
    5c02:	ea f7       	brpl	.-6      	; 0x5bfe <TimersInc+0x16c>
    5c04:	48 2b       	or	r20, r24
    5c06:	40 83       	st	Z, r20
			sei();
    5c08:	78 94       	sei
    5c0a:	2f 5f       	subi	r18, 0xFF	; 255
    5c0c:	3f 4f       	sbci	r19, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    5c0e:	28 32       	cpi	r18, 0x28	; 40
    5c10:	31 05       	cpc	r19, r1
    5c12:	31 f6       	brne	.-116    	; 0x5ba0 <TimersInc+0x10e>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    5c14:	80 91 3f 02 	lds	r24, 0x023F
    5c18:	8f 5f       	subi	r24, 0xFF	; 255
    5c1a:	80 93 3f 02 	sts	0x023F, r24
    5c1e:	84 36       	cpi	r24, 0x64	; 100
    5c20:	59 f5       	brne	.+86     	; 0x5c78 <TimersInc+0x1e6>
			Timer10ms = 0;
    5c22:	10 92 3f 02 	sts	0x023F, r1
			ScanPerSec = ScanCount;
    5c26:	80 91 33 09 	lds	r24, 0x0933
    5c2a:	90 91 34 09 	lds	r25, 0x0934
    5c2e:	90 93 5f 09 	sts	0x095F, r25
    5c32:	80 93 5e 09 	sts	0x095E, r24
 			ScanCount = 0;
    5c36:	10 92 34 09 	sts	0x0934, r1
    5c3a:	10 92 33 09 	sts	0x0933, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    5c3e:	80 91 fb 0a 	lds	r24, 0x0AFB
    5c42:	8f 5f       	subi	r24, 0xFF	; 255
    5c44:	80 93 fb 0a 	sts	0x0AFB, r24
    5c48:	8c 33       	cpi	r24, 0x3C	; 60
    5c4a:	b1 f4       	brne	.+44     	; 0x5c78 <TimersInc+0x1e6>
		Timer1s = 0;
    5c4c:	10 92 fb 0a 	sts	0x0AFB, r1
		if (++Timer1min==60) {
    5c50:	80 91 1d 06 	lds	r24, 0x061D
    5c54:	8f 5f       	subi	r24, 0xFF	; 255
    5c56:	80 93 1d 06 	sts	0x061D, r24
    5c5a:	8c 33       	cpi	r24, 0x3C	; 60
    5c5c:	69 f4       	brne	.+26     	; 0x5c78 <TimersInc+0x1e6>
			Timer1min = 0;
    5c5e:	10 92 1d 06 	sts	0x061D, r1
			++Timer1hour;
    5c62:	80 91 35 0e 	lds	r24, 0x0E35
    5c66:	90 91 36 0e 	lds	r25, 0x0E36
    5c6a:	01 96       	adiw	r24, 0x01	; 1
    5c6c:	90 93 36 0e 	sts	0x0E36, r25
    5c70:	80 93 35 0e 	sts	0x0E35, r24
			OnTimeSave();
    5c74:	0e 94 a7 2c 	call	0x594e	; 0x594e <OnTimeSave>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5c78:	1f 5f       	subi	r17, 0xFF	; 255
    5c7a:	1b cf       	rjmp	.-458    	; 0x5ab2 <TimersInc+0x20>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    5c7c:	df 91       	pop	r29
    5c7e:	cf 91       	pop	r28
    5c80:	1f 91       	pop	r17
    5c82:	0f 91       	pop	r16
    5c84:	ff 90       	pop	r15
    5c86:	ef 90       	pop	r14
    5c88:	08 95       	ret

00005c8a <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    5c8a:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    5c8c:	80 91 33 09 	lds	r24, 0x0933
    5c90:	90 91 34 09 	lds	r25, 0x0934
    5c94:	01 96       	adiw	r24, 0x01	; 1
    5c96:	90 93 34 09 	sts	0x0934, r25
    5c9a:	80 93 33 09 	sts	0x0933, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    5c9e:	80 91 67 02 	lds	r24, 0x0267
    5ca2:	e8 2f       	mov	r30, r24
    5ca4:	f0 e0       	ldi	r31, 0x00	; 0
    5ca6:	e0 56       	subi	r30, 0x60	; 96
    5ca8:	fc 4f       	sbci	r31, 0xFC	; 252
    5caa:	90 81       	ld	r25, Z
    5cac:	90 95       	com	r25
    5cae:	90 93 2c 09 	sts	0x092C, r25
    5cb2:	20 91 1e 06 	lds	r18, 0x061E
    5cb6:	29 17       	cp	r18, r25
    5cb8:	10 f4       	brcc	.+4      	; 0x5cbe <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    5cba:	90 93 1e 06 	sts	0x061E, r25
	StartTimer8(TD_Scan, 0xFF);
    5cbe:	6f ef       	ldi	r22, 0xFF	; 255
    5cc0:	0c 94 6b 2a 	jmp	0x54d6	; 0x54d6 <StartTimer8>

00005cc4 <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    5cc4:	bc 01       	movw	r22, r24
    5cc6:	80 e0       	ldi	r24, 0x00	; 0
    5cc8:	90 e0       	ldi	r25, 0x00	; 0
    5cca:	0e 94 9e 6d 	call	0xdb3c	; 0xdb3c <__floatunsisf>
    5cce:	2d ec       	ldi	r18, 0xCD	; 205
    5cd0:	3c ec       	ldi	r19, 0xCC	; 204
    5cd2:	4c e4       	ldi	r20, 0x4C	; 76
    5cd4:	5f e3       	ldi	r21, 0x3F	; 63
    5cd6:	0e 94 2c 6e 	call	0xdc58	; 0xdc58 <__mulsf3>
    5cda:	0e 94 72 6d 	call	0xdae4	; 0xdae4 <__fixunssfsi>
	while (Delay--)
    5cde:	61 15       	cp	r22, r1
    5ce0:	71 05       	cpc	r23, r1
    5ce2:	39 f0       	breq	.+14     	; 0x5cf2 <Delay_us+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5ce4:	85 e0       	ldi	r24, 0x05	; 5
    5ce6:	8a 95       	dec	r24
    5ce8:	f1 f7       	brne	.-4      	; 0x5ce6 <Delay_us+0x22>
    5cea:	00 00       	nop
    5cec:	61 50       	subi	r22, 0x01	; 1
    5cee:	71 09       	sbc	r23, r1
    5cf0:	f6 cf       	rjmp	.-20     	; 0x5cde <Delay_us+0x1a>
		_delay_us(1);
}
    5cf2:	08 95       	ret

00005cf4 <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5cf4:	8c 9a       	sbi	0x11, 4	; 17
    5cf6:	94 98       	cbi	0x12, 4	; 18
    5cf8:	08 95       	ret

00005cfa <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    5cfa:	81 11       	cpse	r24, r1
    5cfc:	0a c0       	rjmp	.+20     	; 0x5d12 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5cfe:	80 91 64 00 	lds	r24, 0x0064
    5d02:	81 60       	ori	r24, 0x01	; 1
    5d04:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d08:	80 91 65 00 	lds	r24, 0x0065
    5d0c:	8e 7f       	andi	r24, 0xFE	; 254
    5d0e:	80 93 65 00 	sts	0x0065, r24
    5d12:	08 95       	ret

00005d14 <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5d14:	81 11       	cpse	r24, r1
    5d16:	0a c0       	rjmp	.+20     	; 0x5d2c <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    5d18:	80 91 64 00 	lds	r24, 0x0064
    5d1c:	8e 7f       	andi	r24, 0xFE	; 254
    5d1e:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d22:	80 91 65 00 	lds	r24, 0x0065
    5d26:	8e 7f       	andi	r24, 0xFE	; 254
    5d28:	80 93 65 00 	sts	0x0065, r24
    5d2c:	08 95       	ret

00005d2e <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    5d2e:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    5d30:	17 9a       	sbi	0x02, 7	; 2
	sei();
    5d32:	78 94       	sei
    5d34:	08 95       	ret

00005d36 <GSM_PWRCNTRL_OFF>:
}
void GSM_PWRCNTRL_OFF(void){
	cli();
    5d36:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    5d38:	1f 98       	cbi	0x03, 7	; 3
	sei();
    5d3a:	78 94       	sei
    5d3c:	08 95       	ret

00005d3e <GSM_PWRCNTRL_ON>:
}
void GSM_PWRCNTRL_ON(void){
	cli();
    5d3e:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    5d40:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    5d42:	78 94       	sei
    5d44:	08 95       	ret

00005d46 <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    5d46:	8d 9a       	sbi	0x11, 5	; 17
    5d48:	08 95       	ret

00005d4a <CTS_OFF>:
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    5d4a:	95 98       	cbi	0x12, 5	; 18
    5d4c:	08 95       	ret

00005d4e <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    5d4e:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    5d50:	96 9a       	sbi	0x12, 6	; 18
    5d52:	08 95       	ret

00005d54 <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    5d54:	1f 92       	push	r1
    5d56:	0f 92       	push	r0
    5d58:	0f b6       	in	r0, 0x3f	; 63
    5d5a:	0f 92       	push	r0
    5d5c:	11 24       	eor	r1, r1
    5d5e:	0b b6       	in	r0, 0x3b	; 59
    5d60:	0f 92       	push	r0
    5d62:	2f 93       	push	r18
    5d64:	3f 93       	push	r19
    5d66:	4f 93       	push	r20
    5d68:	5f 93       	push	r21
    5d6a:	6f 93       	push	r22
    5d6c:	7f 93       	push	r23
    5d6e:	8f 93       	push	r24
    5d70:	9f 93       	push	r25
    5d72:	af 93       	push	r26
    5d74:	bf 93       	push	r27
    5d76:	ef 93       	push	r30
    5d78:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5d7a:	83 b7       	in	r24, 0x33	; 51
    5d7c:	88 7f       	andi	r24, 0xF8	; 248
    5d7e:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    5d80:	87 b7       	in	r24, 0x37	; 55
    5d82:	8d 7f       	andi	r24, 0xFD	; 253
    5d84:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    5d86:	82 e5       	ldi	r24, 0x52	; 82
    5d88:	90 e0       	ldi	r25, 0x00	; 0
    5d8a:	0e 94 35 28 	call	0x506a	; 0x506a <MB_Timer_ISR>
}
    5d8e:	ff 91       	pop	r31
    5d90:	ef 91       	pop	r30
    5d92:	bf 91       	pop	r27
    5d94:	af 91       	pop	r26
    5d96:	9f 91       	pop	r25
    5d98:	8f 91       	pop	r24
    5d9a:	7f 91       	pop	r23
    5d9c:	6f 91       	pop	r22
    5d9e:	5f 91       	pop	r21
    5da0:	4f 91       	pop	r20
    5da2:	3f 91       	pop	r19
    5da4:	2f 91       	pop	r18
    5da6:	0f 90       	pop	r0
    5da8:	0b be       	out	0x3b, r0	; 59
    5daa:	0f 90       	pop	r0
    5dac:	0f be       	out	0x3f, r0	; 63
    5dae:	0f 90       	pop	r0
    5db0:	1f 90       	pop	r1
    5db2:	18 95       	reti

00005db4 <__vector_9>:

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    5db4:	1f 92       	push	r1
    5db6:	0f 92       	push	r0
    5db8:	0f b6       	in	r0, 0x3f	; 63
    5dba:	0f 92       	push	r0
    5dbc:	11 24       	eor	r1, r1
    5dbe:	0b b6       	in	r0, 0x3b	; 59
    5dc0:	0f 92       	push	r0
    5dc2:	2f 93       	push	r18
    5dc4:	3f 93       	push	r19
    5dc6:	4f 93       	push	r20
    5dc8:	5f 93       	push	r21
    5dca:	6f 93       	push	r22
    5dcc:	7f 93       	push	r23
    5dce:	8f 93       	push	r24
    5dd0:	9f 93       	push	r25
    5dd2:	af 93       	push	r26
    5dd4:	bf 93       	push	r27
    5dd6:	ef 93       	push	r30
    5dd8:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5dda:	85 b5       	in	r24, 0x25	; 37
    5ddc:	88 7f       	andi	r24, 0xF8	; 248
    5dde:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    5de0:	87 b7       	in	r24, 0x37	; 55
    5de2:	8f 77       	andi	r24, 0x7F	; 127
    5de4:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    5de6:	84 e4       	ldi	r24, 0x44	; 68
    5de8:	90 e0       	ldi	r25, 0x00	; 0
    5dea:	0e 94 35 28 	call	0x506a	; 0x506a <MB_Timer_ISR>
}
    5dee:	ff 91       	pop	r31
    5df0:	ef 91       	pop	r30
    5df2:	bf 91       	pop	r27
    5df4:	af 91       	pop	r26
    5df6:	9f 91       	pop	r25
    5df8:	8f 91       	pop	r24
    5dfa:	7f 91       	pop	r23
    5dfc:	6f 91       	pop	r22
    5dfe:	5f 91       	pop	r21
    5e00:	4f 91       	pop	r20
    5e02:	3f 91       	pop	r19
    5e04:	2f 91       	pop	r18
    5e06:	0f 90       	pop	r0
    5e08:	0b be       	out	0x3b, r0	; 59
    5e0a:	0f 90       	pop	r0
    5e0c:	0f be       	out	0x3f, r0	; 63
    5e0e:	0f 90       	pop	r0
    5e10:	1f 90       	pop	r1
    5e12:	18 95       	reti

00005e14 <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    5e14:	ff 92       	push	r15
    5e16:	0f 93       	push	r16
    5e18:	1f 93       	push	r17
    5e1a:	cf 93       	push	r28
    5e1c:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    5e1e:	08 2f       	mov	r16, r24
    5e20:	10 e0       	ldi	r17, 0x00	; 0
    5e22:	e8 01       	movw	r28, r16
    5e24:	cc 0f       	add	r28, r28
    5e26:	dd 1f       	adc	r29, r29
    5e28:	c0 0f       	add	r28, r16
    5e2a:	d1 1f       	adc	r29, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5e2c:	ce 01       	movw	r24, r28
    5e2e:	83 56       	subi	r24, 0x63	; 99
    5e30:	9e 4f       	sbci	r25, 0xFE	; 254
    5e32:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    5e36:	f8 2e       	mov	r15, r24
    5e38:	c2 56       	subi	r28, 0x62	; 98
    5e3a:	de 4f       	sbci	r29, 0xFE	; 254
    5e3c:	ce 01       	movw	r24, r28
    5e3e:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    5e42:	f1 10       	cpse	r15, r1
    5e44:	04 c0       	rjmp	.+8      	; 0x5e4e <SetParity+0x3a>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    5e46:	81 30       	cpi	r24, 0x01	; 1
    5e48:	39 f4       	brne	.+14     	; 0x5e58 <SetParity+0x44>
			case 1:
				ucsrc &=~(1<<3);
    5e4a:	96 e8       	ldi	r25, 0x86	; 134
    5e4c:	08 c0       	rjmp	.+16     	; 0x5e5e <SetParity+0x4a>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    5e4e:	91 e0       	ldi	r25, 0x01	; 1
    5e50:	f9 12       	cpse	r15, r25
    5e52:	04 c0       	rjmp	.+8      	; 0x5e5c <SetParity+0x48>
			case EvenParity:
				ucsrc = (ucsrc |(1<<5)) &~(1<<4);
    5e54:	96 ea       	ldi	r25, 0xA6	; 166
    5e56:	03 c0       	rjmp	.+6      	; 0x5e5e <SetParity+0x4a>
{
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
			ucsrc &=~(1<<5) &~(1<<4);
    5e58:	9e e8       	ldi	r25, 0x8E	; 142
    5e5a:	01 c0       	rjmp	.+2      	; 0x5e5e <SetParity+0x4a>
				ucsrc  |=(1<<3);
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
    5e5c:	96 eb       	ldi	r25, 0xB6	; 182
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    5e5e:	24 e1       	ldi	r18, 0x14	; 20
    5e60:	20 9f       	mul	r18, r16
    5e62:	f0 01       	movw	r30, r0
    5e64:	21 9f       	mul	r18, r17
    5e66:	f0 0d       	add	r31, r0
    5e68:	11 24       	eor	r1, r1
    5e6a:	e1 56       	subi	r30, 0x61	; 97
    5e6c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5e6e:	a5 91       	lpm	r26, Z+
    5e70:	b4 91       	lpm	r27, Z
    5e72:	9c 93       	st	X, r25
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    5e74:	ff 20       	and	r15, r15
    5e76:	59 f0       	breq	.+22     	; 0x5e8e <SetParity+0x7a>
    5e78:	81 30       	cpi	r24, 0x01	; 1
    5e7a:	49 f0       	breq	.+18     	; 0x5e8e <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
    5e7c:	61 e0       	ldi	r22, 0x01	; 1
    5e7e:	ce 01       	movw	r24, r28
}
    5e80:	df 91       	pop	r29
    5e82:	cf 91       	pop	r28
    5e84:	1f 91       	pop	r17
    5e86:	0f 91       	pop	r16
    5e88:	ff 90       	pop	r15
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
    5e8a:	0c 94 c3 29 	jmp	0x5386	; 0x5386 <ewb>
}
    5e8e:	df 91       	pop	r29
    5e90:	cf 91       	pop	r28
    5e92:	1f 91       	pop	r17
    5e94:	0f 91       	pop	r16
    5e96:	ff 90       	pop	r15
    5e98:	08 95       	ret

00005e9a <SetBAUD>:

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    5e9a:	cf 93       	push	r28
    5e9c:	df 93       	push	r29
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    5e9e:	c8 2f       	mov	r28, r24
    5ea0:	d0 e0       	ldi	r29, 0x00	; 0
    5ea2:	ce 01       	movw	r24, r28
    5ea4:	88 0f       	add	r24, r24
    5ea6:	99 1f       	adc	r25, r25
    5ea8:	8c 0f       	add	r24, r28
    5eaa:	9d 1f       	adc	r25, r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5eac:	81 56       	subi	r24, 0x61	; 97
    5eae:	9e 4f       	sbci	r25, 0xFE	; 254
    5eb0:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    5eb4:	fe 01       	movw	r30, r28
    5eb6:	e4 5a       	subi	r30, 0xA4	; 164
    5eb8:	f6 4f       	sbci	r31, 0xF6	; 246
    5eba:	80 83       	st	Z, r24
    5ebc:	23 e0       	ldi	r18, 0x03	; 3
    5ebe:	82 9f       	mul	r24, r18
    5ec0:	c0 01       	movw	r24, r0
    5ec2:	11 24       	eor	r1, r1
    5ec4:	83 55       	subi	r24, 0x53	; 83
    5ec6:	90 4b       	sbci	r25, 0xB0	; 176
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    5ec8:	24 e1       	ldi	r18, 0x14	; 20
    5eca:	2c 9f       	mul	r18, r28
    5ecc:	f0 01       	movw	r30, r0
    5ece:	2d 9f       	mul	r18, r29
    5ed0:	f0 0d       	add	r31, r0
    5ed2:	11 24       	eor	r1, r1
    5ed4:	ed 55       	subi	r30, 0x5D	; 93
    5ed6:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ed8:	a5 91       	lpm	r26, Z+
    5eda:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5edc:	fc 01       	movw	r30, r24
    5ede:	24 91       	lpm	r18, Z
    5ee0:	2c 93       	st	X, r18
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    5ee2:	24 e1       	ldi	r18, 0x14	; 20
    5ee4:	2c 9f       	mul	r18, r28
    5ee6:	f0 01       	movw	r30, r0
    5ee8:	2d 9f       	mul	r18, r29
    5eea:	f0 0d       	add	r31, r0
    5eec:	11 24       	eor	r1, r1
    5eee:	ef 55       	subi	r30, 0x5F	; 95
    5ef0:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ef2:	a5 91       	lpm	r26, Z+
    5ef4:	b4 91       	lpm	r27, Z
    5ef6:	fc 01       	movw	r30, r24
    5ef8:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5efa:	e4 91       	lpm	r30, Z
    5efc:	ec 93       	st	X, r30

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    5efe:	26 e0       	ldi	r18, 0x06	; 6
    5f00:	2c 9f       	mul	r18, r28
    5f02:	f0 01       	movw	r30, r0
    5f04:	2d 9f       	mul	r18, r29
    5f06:	f0 0d       	add	r31, r0
    5f08:	11 24       	eor	r1, r1
    5f0a:	e1 57       	subi	r30, 0x71	; 113
    5f0c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f0e:	a5 91       	lpm	r26, Z+
    5f10:	b4 91       	lpm	r27, Z
    5f12:	fc 01       	movw	r30, r24
    5f14:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f16:	84 91       	lpm	r24, Z
    5f18:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    5f1a:	df 91       	pop	r29
    5f1c:	cf 91       	pop	r28
    5f1e:	08 95       	ret

00005f20 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5f20:	cf 93       	push	r28
    5f22:	df 93       	push	r29
	MB_State[MB_N] = MB_Trans;
    5f24:	c8 2f       	mov	r28, r24
    5f26:	d0 e0       	ldi	r29, 0x00	; 0
    5f28:	fe 01       	movw	r30, r28
    5f2a:	e5 52       	subi	r30, 0x25	; 37
    5f2c:	fc 4f       	sbci	r31, 0xFC	; 252
    5f2e:	83 e0       	ldi	r24, 0x03	; 3
    5f30:	80 83       	st	Z, r24
	USART_Func(MB_N, RS485);
    5f32:	84 e1       	ldi	r24, 0x14	; 20
    5f34:	8c 9f       	mul	r24, r28
    5f36:	f0 01       	movw	r30, r0
    5f38:	8d 9f       	mul	r24, r29
    5f3a:	f0 0d       	add	r31, r0
    5f3c:	11 24       	eor	r1, r1
    5f3e:	eb 55       	subi	r30, 0x5B	; 91
    5f40:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f42:	85 91       	lpm	r24, Z+
    5f44:	94 91       	lpm	r25, Z
    5f46:	fc 01       	movw	r30, r24
    5f48:	09 95       	icall
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5f4a:	84 e1       	ldi	r24, 0x14	; 20
    5f4c:	8c 9f       	mul	r24, r28
    5f4e:	f0 01       	movw	r30, r0
    5f50:	8d 9f       	mul	r24, r29
    5f52:	f0 0d       	add	r31, r0
    5f54:	11 24       	eor	r1, r1
    5f56:	e7 56       	subi	r30, 0x67	; 103
    5f58:	f0 4b       	sbci	r31, 0xB0	; 176
    5f5a:	a5 91       	lpm	r26, Z+
    5f5c:	b4 91       	lpm	r27, Z
    5f5e:	fc 2f       	mov	r31, r28
    5f60:	ee 27       	eor	r30, r30
    5f62:	eb 5c       	subi	r30, 0xCB	; 203
    5f64:	f2 4f       	sbci	r31, 0xF2	; 242
    5f66:	80 81       	ld	r24, Z
    5f68:	8c 93       	st	X, r24

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5f6a:	84 e1       	ldi	r24, 0x14	; 20
    5f6c:	8c 9f       	mul	r24, r28
    5f6e:	f0 01       	movw	r30, r0
    5f70:	8d 9f       	mul	r24, r29
    5f72:	f0 0d       	add	r31, r0
    5f74:	11 24       	eor	r1, r1
    5f76:	e5 56       	subi	r30, 0x65	; 101
    5f78:	f0 4b       	sbci	r31, 0xB0	; 176
    5f7a:	a5 91       	lpm	r26, Z+
    5f7c:	b4 91       	lpm	r27, Z
    5f7e:	8c 91       	ld	r24, X
    5f80:	80 64       	ori	r24, 0x40	; 64
    5f82:	8c 93       	st	X, r24
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    5f84:	84 e1       	ldi	r24, 0x14	; 20
    5f86:	8c 9f       	mul	r24, r28
    5f88:	f0 01       	movw	r30, r0
    5f8a:	8d 9f       	mul	r24, r29
    5f8c:	f0 0d       	add	r31, r0
    5f8e:	11 24       	eor	r1, r1
    5f90:	e3 56       	subi	r30, 0x63	; 99
    5f92:	f0 4b       	sbci	r31, 0xB0	; 176
    5f94:	a5 91       	lpm	r26, Z+
    5f96:	b4 91       	lpm	r27, Z
    5f98:	8c 91       	ld	r24, X
    5f9a:	80 62       	ori	r24, 0x20	; 32
    5f9c:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    5f9e:	df 91       	pop	r29
    5fa0:	cf 91       	pop	r28
    5fa2:	08 95       	ret

00005fa4 <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    5fa4:	cf 93       	push	r28
    5fa6:	df 93       	push	r29
    5fa8:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    5faa:	80 e0       	ldi	r24, 0x00	; 0
    5fac:	94 e1       	ldi	r25, 0x14	; 20
    5fae:	c8 2f       	mov	r28, r24
    5fb0:	d0 e0       	ldi	r29, 0x00	; 0
    5fb2:	9c 9f       	mul	r25, r28
    5fb4:	f0 01       	movw	r30, r0
    5fb6:	9d 9f       	mul	r25, r29
    5fb8:	f0 0d       	add	r31, r0
    5fba:	11 24       	eor	r1, r1
    5fbc:	e7 56       	subi	r30, 0x67	; 103
    5fbe:	f0 4b       	sbci	r31, 0xB0	; 176
    5fc0:	25 91       	lpm	r18, Z+
    5fc2:	34 91       	lpm	r19, Z
    5fc4:	a2 17       	cp	r26, r18
    5fc6:	b3 07       	cpc	r27, r19
    5fc8:	11 f0       	breq	.+4      	; 0x5fce <Modbus_RX+0x2a>
    5fca:	8f 5f       	subi	r24, 0xFF	; 255
    5fcc:	f0 cf       	rjmp	.-32     	; 0x5fae <Modbus_RX+0xa>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    5fce:	fe 01       	movw	r30, r28
    5fd0:	e5 52       	subi	r30, 0x25	; 37
    5fd2:	fc 4f       	sbci	r31, 0xFC	; 252
    5fd4:	90 81       	ld	r25, Z
    5fd6:	92 30       	cpi	r25, 0x02	; 2
    5fd8:	a1 f1       	breq	.+104    	; 0x6042 <Modbus_RX+0x9e>
    5fda:	40 f5       	brcc	.+80     	; 0x602c <Modbus_RX+0x88>
    5fdc:	99 23       	and	r25, r25
    5fde:	51 f1       	breq	.+84     	; 0x6034 <Modbus_RX+0x90>
    5fe0:	91 30       	cpi	r25, 0x01	; 1
    5fe2:	09 f0       	breq	.+2      	; 0x5fe6 <Modbus_RX+0x42>
    5fe4:	3b c0       	rjmp	.+118    	; 0x605c <Modbus_RX+0xb8>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    5fe6:	92 e0       	ldi	r25, 0x02	; 2
    5fe8:	90 83       	st	Z, r25
		MB_Err &=~(1<<MB_N);
    5fea:	21 e0       	ldi	r18, 0x01	; 1
    5fec:	30 e0       	ldi	r19, 0x00	; 0
    5fee:	08 2e       	mov	r0, r24
    5ff0:	01 c0       	rjmp	.+2      	; 0x5ff4 <Modbus_RX+0x50>
    5ff2:	22 0f       	add	r18, r18
    5ff4:	0a 94       	dec	r0
    5ff6:	ea f7       	brpl	.-6      	; 0x5ff2 <Modbus_RX+0x4e>
    5ff8:	20 95       	com	r18
    5ffa:	90 91 65 02 	lds	r25, 0x0265
    5ffe:	92 23       	and	r25, r18
    6000:	90 93 65 02 	sts	0x0265, r25
		MB_Frame_Sz[MB_N] = 0;
    6004:	fe 01       	movw	r30, r28
    6006:	e9 53       	subi	r30, 0x39	; 57
    6008:	f7 4f       	sbci	r31, 0xF7	; 247
    600a:	10 82       	st	Z, r1
		MBRecept(MB_N);
    600c:	0e 94 7c 28 	call	0x50f8	; 0x50f8 <MBRecept>
		MB_StartTimer(MB_N);
    6010:	86 e0       	ldi	r24, 0x06	; 6
    6012:	8c 9f       	mul	r24, r28
    6014:	f0 01       	movw	r30, r0
    6016:	8d 9f       	mul	r24, r29
    6018:	f0 0d       	add	r31, r0
    601a:	11 24       	eor	r1, r1
    601c:	ef 56       	subi	r30, 0x6F	; 111
    601e:	f0 4b       	sbci	r31, 0xB0	; 176
    6020:	85 91       	lpm	r24, Z+
    6022:	94 91       	lpm	r25, Z
    6024:	fc 01       	movw	r30, r24
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    6026:	df 91       	pop	r29
    6028:	cf 91       	pop	r28
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
		MB_Err &=~(1<<MB_N);
		MB_Frame_Sz[MB_N] = 0;
		MBRecept(MB_N);
		MB_StartTimer(MB_N);
    602a:	09 94       	ijmp
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    602c:	96 30       	cpi	r25, 0x06	; 6
    602e:	b0 f4       	brcc	.+44     	; 0x605c <Modbus_RX+0xb8>
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    6030:	8c 91       	ld	r24, X
		break;
    6032:	14 c0       	rjmp	.+40     	; 0x605c <Modbus_RX+0xb8>
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    6034:	8c 91       	ld	r24, X
    6036:	fc 2f       	mov	r31, r28
    6038:	ee 27       	eor	r30, r30
    603a:	eb 5c       	subi	r30, 0xCB	; 203
    603c:	f2 4f       	sbci	r31, 0xF2	; 242
    603e:	80 83       	st	Z, r24
    6040:	02 c0       	rjmp	.+4      	; 0x6046 <Modbus_RX+0xa2>
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    6042:	0e 94 7c 28 	call	0x50f8	; 0x50f8 <MBRecept>
		MB_ClearTimer(MB_N);
    6046:	86 e0       	ldi	r24, 0x06	; 6
    6048:	8c 9f       	mul	r24, r28
    604a:	f0 01       	movw	r30, r0
    604c:	8d 9f       	mul	r24, r29
    604e:	f0 0d       	add	r31, r0
    6050:	11 24       	eor	r1, r1
    6052:	e3 57       	subi	r30, 0x73	; 115
    6054:	f0 4b       	sbci	r31, 0xB0	; 176
    6056:	a5 91       	lpm	r26, Z+
    6058:	b4 91       	lpm	r27, Z
    605a:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    605c:	df 91       	pop	r29
    605e:	cf 91       	pop	r28
    6060:	08 95       	ret

00006062 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    6062:	0f 93       	push	r16
    6064:	1f 93       	push	r17
    6066:	cf 93       	push	r28
    6068:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    606a:	c8 2f       	mov	r28, r24
    606c:	d0 e0       	ldi	r29, 0x00	; 0
    606e:	fe 01       	movw	r30, r28
    6070:	e9 53       	subi	r30, 0x39	; 57
    6072:	f7 4f       	sbci	r31, 0xF7	; 247
    6074:	90 81       	ld	r25, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    6076:	20 91 65 02 	lds	r18, 0x0265
    607a:	30 e0       	ldi	r19, 0x00	; 0
    607c:	02 c0       	rjmp	.+4      	; 0x6082 <CommErr+0x20>
    607e:	35 95       	asr	r19
    6080:	27 95       	ror	r18
    6082:	8a 95       	dec	r24
    6084:	e2 f7       	brpl	.-8      	; 0x607e <CommErr+0x1c>
    6086:	20 fd       	sbrc	r18, 0
    6088:	1b c0       	rjmp	.+54     	; 0x60c0 <CommErr+0x5e>
    608a:	93 30       	cpi	r25, 0x03	; 3
    608c:	c8 f0       	brcs	.+50     	; 0x60c0 <CommErr+0x5e>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    608e:	2e ef       	ldi	r18, 0xFE	; 254
    6090:	29 0f       	add	r18, r25
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    6092:	7c 2f       	mov	r23, r28
    6094:	66 27       	eor	r22, r22
    6096:	6b 5c       	subi	r22, 0xCB	; 203
    6098:	72 4f       	sbci	r23, 0xF2	; 242
    609a:	fb 01       	movw	r30, r22
    609c:	e2 0f       	add	r30, r18
    609e:	f1 1d       	adc	r31, r1
    60a0:	00 81       	ld	r16, Z
    60a2:	11 81       	ldd	r17, Z+1	; 0x01
    60a4:	30 e0       	ldi	r19, 0x00	; 0
    60a6:	40 e0       	ldi	r20, 0x00	; 0
    60a8:	50 e0       	ldi	r21, 0x00	; 0
    60aa:	84 e1       	ldi	r24, 0x14	; 20
    60ac:	98 e2       	ldi	r25, 0x28	; 40
    60ae:	0e 94 92 29 	call	0x5324	; 0x5324 <CRC>
    60b2:	21 e0       	ldi	r18, 0x01	; 1
    60b4:	08 17       	cp	r16, r24
    60b6:	19 07       	cpc	r17, r25
    60b8:	09 f4       	brne	.+2      	; 0x60bc <CommErr+0x5a>
    60ba:	20 e0       	ldi	r18, 0x00	; 0
    60bc:	12 2f       	mov	r17, r18
    60be:	01 c0       	rjmp	.+2      	; 0x60c2 <CommErr+0x60>
    60c0:	11 e0       	ldi	r17, 0x01	; 1
    60c2:	fe 01       	movw	r30, r28
    60c4:	54 e0       	ldi	r21, 0x04	; 4
    60c6:	ee 0f       	add	r30, r30
    60c8:	ff 1f       	adc	r31, r31
    60ca:	5a 95       	dec	r21
    60cc:	e1 f7       	brne	.-8      	; 0x60c6 <CommErr+0x64>
	if (Err) {
		MB_CPT[MB_N][1]++;
    60ce:	ea 5e       	subi	r30, 0xEA	; 234
    60d0:	f4 4f       	sbci	r31, 0xF4	; 244
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
	if (Err) {
    60d2:	11 23       	and	r17, r17
    60d4:	79 f0       	breq	.+30     	; 0x60f4 <CommErr+0x92>
		MB_CPT[MB_N][1]++;
    60d6:	22 81       	ldd	r18, Z+2	; 0x02
    60d8:	33 81       	ldd	r19, Z+3	; 0x03
    60da:	2f 5f       	subi	r18, 0xFF	; 255
    60dc:	3f 4f       	sbci	r19, 0xFF	; 255
    60de:	33 83       	std	Z+3, r19	; 0x03
    60e0:	22 83       	std	Z+2, r18	; 0x02
		USART_Func(MB_N, LED_Err_On);
    60e2:	84 e1       	ldi	r24, 0x14	; 20
    60e4:	8c 9f       	mul	r24, r28
    60e6:	f0 01       	movw	r30, r0
    60e8:	8d 9f       	mul	r24, r29
    60ea:	f0 0d       	add	r31, r0
    60ec:	11 24       	eor	r1, r1
    60ee:	e7 55       	subi	r30, 0x57	; 87
    60f0:	f0 4b       	sbci	r31, 0xB0	; 176
    60f2:	0e c0       	rjmp	.+28     	; 0x6110 <CommErr+0xae>
	}
	else {
		MB_CPT[MB_N][0]++;
    60f4:	20 81       	ld	r18, Z
    60f6:	31 81       	ldd	r19, Z+1	; 0x01
    60f8:	2f 5f       	subi	r18, 0xFF	; 255
    60fa:	3f 4f       	sbci	r19, 0xFF	; 255
    60fc:	31 83       	std	Z+1, r19	; 0x01
    60fe:	20 83       	st	Z, r18
		USART_Func(MB_N, LED_Err_Off);
    6100:	84 e1       	ldi	r24, 0x14	; 20
    6102:	8c 9f       	mul	r24, r28
    6104:	f0 01       	movw	r30, r0
    6106:	8d 9f       	mul	r24, r29
    6108:	f0 0d       	add	r31, r0
    610a:	11 24       	eor	r1, r1
    610c:	e5 55       	subi	r30, 0x55	; 85
    610e:	f0 4b       	sbci	r31, 0xB0	; 176
    6110:	25 91       	lpm	r18, Z+
    6112:	34 91       	lpm	r19, Z
    6114:	f9 01       	movw	r30, r18
    6116:	09 95       	icall
	}
	return Err;
}
    6118:	81 2f       	mov	r24, r17
    611a:	df 91       	pop	r29
    611c:	cf 91       	pop	r28
    611e:	1f 91       	pop	r17
    6120:	0f 91       	pop	r16
    6122:	08 95       	ret

00006124 <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    6124:	cf 93       	push	r28
    6126:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    6128:	68 2f       	mov	r22, r24
    612a:	70 e0       	ldi	r23, 0x00	; 0
    612c:	fb 01       	movw	r30, r22
    612e:	e9 53       	subi	r30, 0x39	; 57
    6130:	f7 4f       	sbci	r31, 0xF7	; 247
    6132:	20 81       	ld	r18, Z
    6134:	22 50       	subi	r18, 0x02	; 2
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    6136:	76 2f       	mov	r23, r22
    6138:	66 27       	eor	r22, r22
    613a:	6b 5c       	subi	r22, 0xCB	; 203
    613c:	72 4f       	sbci	r23, 0xF2	; 242
    613e:	eb 01       	movw	r28, r22
    6140:	c2 0f       	add	r28, r18
    6142:	d1 1d       	adc	r29, r1
    6144:	30 e0       	ldi	r19, 0x00	; 0
    6146:	40 e0       	ldi	r20, 0x00	; 0
    6148:	50 e0       	ldi	r21, 0x00	; 0
    614a:	84 e1       	ldi	r24, 0x14	; 20
    614c:	98 e2       	ldi	r25, 0x28	; 40
    614e:	0e 94 92 29 	call	0x5324	; 0x5324 <CRC>
    6152:	99 83       	std	Y+1, r25	; 0x01
    6154:	88 83       	st	Y, r24
}
    6156:	df 91       	pop	r29
    6158:	cf 91       	pop	r28
    615a:	08 95       	ret

0000615c <FormData>:
}

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    615c:	bf 92       	push	r11
    615e:	cf 92       	push	r12
    6160:	df 92       	push	r13
    6162:	ef 92       	push	r14
    6164:	ff 92       	push	r15
    6166:	0f 93       	push	r16
    6168:	1f 93       	push	r17
    616a:	cf 93       	push	r28
    616c:	df 93       	push	r29
    616e:	b8 2e       	mov	r11, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    6170:	c8 2f       	mov	r28, r24
    6172:	d0 e0       	ldi	r29, 0x00	; 0
    6174:	dc 2e       	mov	r13, r28
    6176:	cc 24       	eor	r12, r12
    6178:	86 01       	movw	r16, r12
    617a:	0b 5c       	subi	r16, 0xCB	; 203
    617c:	12 4f       	sbci	r17, 0xF2	; 242
    617e:	f8 01       	movw	r30, r16
    6180:	81 81       	ldd	r24, Z+1	; 0x01
    6182:	86 30       	cpi	r24, 0x06	; 6
    6184:	f1 f0       	breq	.+60     	; 0x61c2 <FormData+0x66>
    6186:	48 f4       	brcc	.+18     	; 0x619a <FormData+0x3e>
    6188:	81 50       	subi	r24, 0x01	; 1
    618a:	84 30       	cpi	r24, 0x04	; 4
    618c:	08 f0       	brcs	.+2      	; 0x6190 <FormData+0x34>
    618e:	c9 c0       	rjmp	.+402    	; 0x6322 <FormData+0x1c6>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    6190:	c9 53       	subi	r28, 0x39	; 57
    6192:	d7 4f       	sbci	r29, 0xF7	; 247
    6194:	88 e0       	ldi	r24, 0x08	; 8
    6196:	88 83       	st	Y, r24
		break;
    6198:	c4 c0       	rjmp	.+392    	; 0x6322 <FormData+0x1c6>
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    619a:	8f 30       	cpi	r24, 0x0F	; 15
    619c:	11 f1       	breq	.+68     	; 0x61e2 <FormData+0x86>
    619e:	80 31       	cpi	r24, 0x10	; 16
    61a0:	09 f0       	breq	.+2      	; 0x61a4 <FormData+0x48>
    61a2:	bf c0       	rjmp	.+382    	; 0x6322 <FormData+0x1c6>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    61a4:	f8 01       	movw	r30, r16
    61a6:	85 81       	ldd	r24, Z+5	; 0x05
    61a8:	88 0f       	add	r24, r24
    61aa:	86 83       	std	Z+6, r24	; 0x06
    61ac:	c9 53       	subi	r28, 0x39	; 57
    61ae:	d7 4f       	sbci	r29, 0xF7	; 247
    61b0:	87 5f       	subi	r24, 0xF7	; 247
    61b2:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    61b4:	8b 2d       	mov	r24, r11
    61b6:	0e 94 04 29 	call	0x5208	; 0x5208 <GetReg>
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    61ba:	20 e0       	ldi	r18, 0x00	; 0
    61bc:	e8 01       	movw	r28, r16
    61be:	25 96       	adiw	r28, 0x05	; 5
    61c0:	9a c0       	rjmp	.+308    	; 0x62f6 <FormData+0x19a>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    61c2:	c9 53       	subi	r28, 0x39	; 57
    61c4:	d7 4f       	sbci	r29, 0xF7	; 247
    61c6:	88 e0       	ldi	r24, 0x08	; 8
    61c8:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    61ca:	8b 2d       	mov	r24, r11
    61cc:	0e 94 04 29 	call	0x5208	; 0x5208 <GetReg>
		MB_Frame[MB_N][4] = *Reg>>8;
    61d0:	fc 01       	movw	r30, r24
    61d2:	21 81       	ldd	r18, Z+1	; 0x01
    61d4:	f8 01       	movw	r30, r16
    61d6:	24 83       	std	Z+4, r18	; 0x04
		MB_Frame[MB_N][5] = *Reg;
    61d8:	fc 01       	movw	r30, r24
    61da:	80 81       	ld	r24, Z
    61dc:	f8 01       	movw	r30, r16
    61de:	85 83       	std	Z+5, r24	; 0x05
		break;
    61e0:	a0 c0       	rjmp	.+320    	; 0x6322 <FormData+0x1c6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    61e2:	f8 01       	movw	r30, r16
    61e4:	e4 80       	ldd	r14, Z+4	; 0x04
    61e6:	f1 2c       	mov	r15, r1
    61e8:	fe 2c       	mov	r15, r14
    61ea:	ee 24       	eor	r14, r14
    61ec:	85 81       	ldd	r24, Z+5	; 0x05
    61ee:	e8 2a       	or	r14, r24
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    61f0:	c7 01       	movw	r24, r14
    61f2:	13 e0       	ldi	r17, 0x03	; 3
    61f4:	96 95       	lsr	r25
    61f6:	87 95       	ror	r24
    61f8:	1a 95       	dec	r17
    61fa:	e1 f7       	brne	.-8      	; 0x61f4 <FormData+0x98>
    61fc:	97 01       	movw	r18, r14
    61fe:	27 70       	andi	r18, 0x07	; 7
    6200:	33 27       	eor	r19, r19
    6202:	41 e0       	ldi	r20, 0x01	; 1
    6204:	23 2b       	or	r18, r19
    6206:	09 f4       	brne	.+2      	; 0x620a <FormData+0xae>
    6208:	40 e0       	ldi	r20, 0x00	; 0
    620a:	24 2f       	mov	r18, r20
    620c:	28 0f       	add	r18, r24
    620e:	f6 01       	movw	r30, r12
    6210:	eb 5c       	subi	r30, 0xCB	; 203
    6212:	f2 4f       	sbci	r31, 0xF2	; 242
    6214:	26 83       	std	Z+6, r18	; 0x06
    6216:	de 01       	movw	r26, r28
    6218:	a9 53       	subi	r26, 0x39	; 57
    621a:	b7 4f       	sbci	r27, 0xF7	; 247
    621c:	27 5f       	subi	r18, 0xF7	; 247
    621e:	2c 93       	st	X, r18
		MB_Frame[MB_N][7+Qt/8] = 0;
    6220:	e8 0f       	add	r30, r24
    6222:	f9 1f       	adc	r31, r25
    6224:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    6226:	fe 01       	movw	r30, r28
    6228:	e4 5e       	subi	r30, 0xE4	; 228
    622a:	f9 4f       	sbci	r31, 0xF9	; 249
    622c:	80 81       	ld	r24, Z
    622e:	82 30       	cpi	r24, 0x02	; 2
    6230:	f9 f0       	breq	.+62     	; 0x6270 <FormData+0x114>
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6232:	fe 01       	movw	r30, r28
    6234:	a4 e0       	ldi	r26, 0x04	; 4
    6236:	ee 0f       	add	r30, r30
    6238:	ff 1f       	adc	r31, r31
    623a:	aa 95       	dec	r26
    623c:	e1 f7       	brne	.-8      	; 0x6236 <FormData+0xda>
    623e:	e8 53       	subi	r30, 0x38	; 56
    6240:	f0 4b       	sbci	r31, 0xB0	; 176
    6242:	05 91       	lpm	r16, Z+
    6244:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    6246:	8b 2d       	mov	r24, r11
    6248:	0e 94 be 28 	call	0x517c	; 0x517c <GetSlave>
    624c:	01 96       	adiw	r24, 0x01	; 1
    624e:	fc 01       	movw	r30, r24
    6250:	85 91       	lpm	r24, Z+
    6252:	94 91       	lpm	r25, Z
    6254:	c9 5f       	subi	r28, 0xF9	; 249
    6256:	d9 4f       	sbci	r29, 0xF9	; 249
    6258:	28 81       	ld	r18, Y
    625a:	fc 01       	movw	r30, r24
    625c:	37 e0       	ldi	r19, 0x07	; 7
    625e:	23 9f       	mul	r18, r19
    6260:	e0 0d       	add	r30, r0
    6262:	f1 1d       	adc	r31, r1
    6264:	11 24       	eor	r1, r1
		MB_Frame[MB_N][7+Qt/8] = 0;
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    6266:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6268:	85 91       	lpm	r24, Z+
    626a:	94 91       	lpm	r25, Z
    626c:	78 2f       	mov	r23, r24
    626e:	0a c0       	rjmp	.+20     	; 0x6284 <FormData+0x128>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    6270:	f3 e0       	ldi	r31, 0x03	; 3
    6272:	cc 0f       	add	r28, r28
    6274:	dd 1f       	adc	r29, r29
    6276:	fa 95       	dec	r31
    6278:	e1 f7       	brne	.-8      	; 0x6272 <FormData+0x116>
    627a:	c3 5a       	subi	r28, 0xA3	; 163
    627c:	dd 4f       	sbci	r29, 0xFD	; 253
    627e:	0e 81       	ldd	r16, Y+6	; 0x06
    6280:	1f 81       	ldd	r17, Y+7	; 0x07
			Pin = 0;
    6282:	70 e0       	ldi	r23, 0x00	; 0
		}
		for (uint8_t i=0; i<Qt; i++) {
    6284:	60 e0       	ldi	r22, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6286:	41 e0       	ldi	r20, 0x01	; 1
    6288:	50 e0       	ldi	r21, 0x00	; 0
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    628a:	26 2f       	mov	r18, r22
    628c:	30 e0       	ldi	r19, 0x00	; 0
    628e:	2e 15       	cp	r18, r14
    6290:	3f 05       	cpc	r19, r15
    6292:	08 f0       	brcs	.+2      	; 0x6296 <FormData+0x13a>
    6294:	46 c0       	rjmp	.+140    	; 0x6322 <FormData+0x1c6>
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    6296:	e6 2f       	mov	r30, r22
    6298:	e6 95       	lsr	r30
    629a:	e6 95       	lsr	r30
    629c:	e6 95       	lsr	r30
    629e:	e9 5f       	subi	r30, 0xF9	; 249
    62a0:	86 2f       	mov	r24, r22
    62a2:	87 70       	andi	r24, 0x07	; 7
    62a4:	9a 01       	movw	r18, r20
    62a6:	02 c0       	rjmp	.+4      	; 0x62ac <FormData+0x150>
    62a8:	22 0f       	add	r18, r18
    62aa:	33 1f       	adc	r19, r19
    62ac:	8a 95       	dec	r24
    62ae:	e2 f7       	brpl	.-8      	; 0x62a8 <FormData+0x14c>
    62b0:	c9 01       	movw	r24, r18
			if (Discr[j/8] &(1<<j%8))
    62b2:	f6 2f       	mov	r31, r22
    62b4:	f7 0f       	add	r31, r23
    62b6:	2f 2f       	mov	r18, r31
    62b8:	26 95       	lsr	r18
    62ba:	26 95       	lsr	r18
    62bc:	26 95       	lsr	r18
    62be:	d8 01       	movw	r26, r16
    62c0:	a2 0f       	add	r26, r18
    62c2:	b1 1d       	adc	r27, r1
    62c4:	2c 91       	ld	r18, X
    62c6:	30 e0       	ldi	r19, 0x00	; 0
    62c8:	f7 70       	andi	r31, 0x07	; 7
    62ca:	02 c0       	rjmp	.+4      	; 0x62d0 <FormData+0x174>
    62cc:	35 95       	asr	r19
    62ce:	27 95       	ror	r18
    62d0:	fa 95       	dec	r31
    62d2:	e2 f7       	brpl	.-8      	; 0x62cc <FormData+0x170>
    62d4:	f0 e0       	ldi	r31, 0x00	; 0
				MB_Frame[MB_N][Byte] |=Bit;
    62d6:	ec 0d       	add	r30, r12
    62d8:	fd 1d       	adc	r31, r13
    62da:	eb 5c       	subi	r30, 0xCB	; 203
    62dc:	f2 4f       	sbci	r31, 0xF2	; 242
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
			if (Discr[j/8] &(1<<j%8))
    62de:	20 ff       	sbrs	r18, 0
    62e0:	04 c0       	rjmp	.+8      	; 0x62ea <FormData+0x18e>
				MB_Frame[MB_N][Byte] |=Bit;
    62e2:	90 81       	ld	r25, Z
    62e4:	98 2b       	or	r25, r24
    62e6:	90 83       	st	Z, r25
    62e8:	04 c0       	rjmp	.+8      	; 0x62f2 <FormData+0x196>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    62ea:	80 95       	com	r24
    62ec:	90 81       	ld	r25, Z
    62ee:	89 23       	and	r24, r25
    62f0:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    62f2:	6f 5f       	subi	r22, 0xFF	; 255
    62f4:	ca cf       	rjmp	.-108    	; 0x628a <FormData+0x12e>
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    62f6:	38 81       	ld	r19, Y
    62f8:	23 17       	cp	r18, r19
    62fa:	98 f4       	brcc	.+38     	; 0x6322 <FormData+0x1c6>
			uint8_t j = i*2;
    62fc:	32 2f       	mov	r19, r18
    62fe:	33 0f       	add	r19, r19
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6300:	fc 01       	movw	r30, r24
    6302:	e2 0f       	add	r30, r18
    6304:	f1 1d       	adc	r31, r1
    6306:	e2 0f       	add	r30, r18
    6308:	f1 1d       	adc	r31, r1
    630a:	d8 01       	movw	r26, r16
    630c:	a3 0f       	add	r26, r19
    630e:	b1 1d       	adc	r27, r1
    6310:	31 81       	ldd	r19, Z+1	; 0x01
    6312:	17 96       	adiw	r26, 0x07	; 7
    6314:	3c 93       	st	X, r19
    6316:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    6318:	30 81       	ld	r19, Z
    631a:	18 96       	adiw	r26, 0x08	; 8
    631c:	3c 93       	st	X, r19
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    631e:	2f 5f       	subi	r18, 0xFF	; 255
    6320:	ea cf       	rjmp	.-44     	; 0x62f6 <FormData+0x19a>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6322:	8b 2d       	mov	r24, r11
}
    6324:	df 91       	pop	r29
    6326:	cf 91       	pop	r28
    6328:	1f 91       	pop	r17
    632a:	0f 91       	pop	r16
    632c:	ff 90       	pop	r15
    632e:	ef 90       	pop	r14
    6330:	df 90       	pop	r13
    6332:	cf 90       	pop	r12
    6334:	bf 90       	pop	r11
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6336:	0c 94 92 30 	jmp	0x6124	; 0x6124 <SetCRC_MB>

0000633a <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    633a:	cf 93       	push	r28
    633c:	c8 2f       	mov	r28, r24
	MB_Slave *Slave = GetSlave(MB_N);
    633e:	0e 94 be 28 	call	0x517c	; 0x517c <GetSlave>
    6342:	bc 01       	movw	r22, r24
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6344:	fc 01       	movw	r30, r24
    6346:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6348:	45 91       	lpm	r20, Z+
    634a:	54 91       	lpm	r21, Z
    634c:	2c 2f       	mov	r18, r28
    634e:	30 e0       	ldi	r19, 0x00	; 0
    6350:	f9 01       	movw	r30, r18
    6352:	e9 5f       	subi	r30, 0xF9	; 249
    6354:	f9 4f       	sbci	r31, 0xF9	; 249
    6356:	80 81       	ld	r24, Z
    6358:	97 e0       	ldi	r25, 0x07	; 7
    635a:	89 9f       	mul	r24, r25
    635c:	40 0d       	add	r20, r0
    635e:	51 1d       	adc	r21, r1
    6360:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6362:	fb 01       	movw	r30, r22
    6364:	64 91       	lpm	r22, Z

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    6366:	b2 2f       	mov	r27, r18
    6368:	aa 27       	eor	r26, r26
    636a:	ab 5c       	subi	r26, 0xCB	; 203
    636c:	b2 4f       	sbci	r27, 0xF2	; 242
    636e:	6c 93       	st	X, r22
    6370:	fa 01       	movw	r30, r20
    6372:	84 91       	lpm	r24, Z
	MB_Frame[MB_N][1] = prb(&Query->Func);
    6374:	f2 2f       	mov	r31, r18
    6376:	ee 27       	eor	r30, r30
    6378:	eb 5c       	subi	r30, 0xCB	; 203
    637a:	f2 4f       	sbci	r31, 0xF2	; 242
    637c:	81 83       	std	Z+1, r24	; 0x01
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    637e:	fa 01       	movw	r30, r20
    6380:	32 96       	adiw	r30, 0x02	; 2
    6382:	e4 91       	lpm	r30, Z
    6384:	b2 2f       	mov	r27, r18
    6386:	aa 27       	eor	r26, r26
    6388:	ab 5c       	subi	r26, 0xCB	; 203
    638a:	b2 4f       	sbci	r27, 0xF2	; 242
    638c:	12 96       	adiw	r26, 0x02	; 2
    638e:	ec 93       	st	X, r30
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6390:	fa 01       	movw	r30, r20
    6392:	31 96       	adiw	r30, 0x01	; 1
    6394:	e4 91       	lpm	r30, Z
    6396:	b2 2f       	mov	r27, r18
    6398:	aa 27       	eor	r26, r26
    639a:	ab 5c       	subi	r26, 0xCB	; 203
    639c:	b2 4f       	sbci	r27, 0xF2	; 242
    639e:	13 96       	adiw	r26, 0x03	; 3
    63a0:	ec 93       	st	X, r30
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    63a2:	fa 01       	movw	r30, r20
    63a4:	34 96       	adiw	r30, 0x04	; 4
    63a6:	e4 91       	lpm	r30, Z
    63a8:	b2 2f       	mov	r27, r18
    63aa:	aa 27       	eor	r26, r26
    63ac:	ab 5c       	subi	r26, 0xCB	; 203
    63ae:	b2 4f       	sbci	r27, 0xF2	; 242
    63b0:	14 96       	adiw	r26, 0x04	; 4
    63b2:	ec 93       	st	X, r30
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    63b4:	fa 01       	movw	r30, r20
    63b6:	33 96       	adiw	r30, 0x03	; 3
    63b8:	44 91       	lpm	r20, Z
    63ba:	b2 2f       	mov	r27, r18
    63bc:	aa 27       	eor	r26, r26
    63be:	ab 5c       	subi	r26, 0xCB	; 203
    63c0:	b2 4f       	sbci	r27, 0xF2	; 242
    63c2:	15 96       	adiw	r26, 0x05	; 5
    63c4:	4c 93       	st	X, r20

	FormData(MB_N);
    63c6:	8c 2f       	mov	r24, r28
}
    63c8:	cf 91       	pop	r28
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);

	FormData(MB_N);
    63ca:	0c 94 ae 30 	jmp	0x615c	; 0x615c <FormData>

000063ce <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    63ce:	28 2f       	mov	r18, r24
    63d0:	30 e0       	ldi	r19, 0x00	; 0
    63d2:	f2 2f       	mov	r31, r18
    63d4:	ee 27       	eor	r30, r30
    63d6:	eb 5c       	subi	r30, 0xCB	; 203
    63d8:	f2 4f       	sbci	r31, 0xF2	; 242
    63da:	d9 01       	movw	r26, r18
    63dc:	93 e0       	ldi	r25, 0x03	; 3
    63de:	aa 0f       	add	r26, r26
    63e0:	bb 1f       	adc	r27, r27
    63e2:	9a 95       	dec	r25
    63e4:	e1 f7       	brne	.-8      	; 0x63de <FormSingle+0x10>
    63e6:	a3 5a       	subi	r26, 0xA3	; 163
    63e8:	bd 4f       	sbci	r27, 0xFD	; 253
    63ea:	9c 91       	ld	r25, X
    63ec:	90 83       	st	Z, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    63ee:	11 96       	adiw	r26, 0x01	; 1
    63f0:	9c 91       	ld	r25, X
    63f2:	11 97       	sbiw	r26, 0x01	; 1
    63f4:	91 83       	std	Z+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    63f6:	12 96       	adiw	r26, 0x02	; 2
    63f8:	9c 91       	ld	r25, X
    63fa:	12 97       	sbiw	r26, 0x02	; 2
    63fc:	13 96       	adiw	r26, 0x03	; 3
    63fe:	4c 91       	ld	r20, X
    6400:	13 97       	sbiw	r26, 0x03	; 3
    6402:	42 83       	std	Z+2, r20	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    6404:	93 83       	std	Z+3, r25	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    6406:	14 96       	adiw	r26, 0x04	; 4
    6408:	9c 91       	ld	r25, X
    640a:	14 97       	sbiw	r26, 0x04	; 4
    640c:	15 96       	adiw	r26, 0x05	; 5
    640e:	4c 91       	ld	r20, X
    6410:	44 83       	std	Z+4, r20	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6412:	95 83       	std	Z+5, r25	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    6414:	f9 01       	movw	r30, r18
    6416:	e4 5e       	subi	r30, 0xE4	; 228
    6418:	f9 4f       	sbci	r31, 0xF9	; 249
    641a:	92 e0       	ldi	r25, 0x02	; 2
    641c:	90 83       	st	Z, r25
	FormData(MB_N);
    641e:	0c 94 ae 30 	jmp	0x615c	; 0x615c <FormData>

00006422 <MB_FrameReg>:
    6422:	e8 2f       	mov	r30, r24
    6424:	f0 e0       	ldi	r31, 0x00	; 0
    6426:	70 e0       	ldi	r23, 0x00	; 0
    6428:	fe 2f       	mov	r31, r30
    642a:	ee 27       	eor	r30, r30
    642c:	df 01       	movw	r26, r30
    642e:	ab 5c       	subi	r26, 0xCB	; 203
    6430:	b2 4f       	sbci	r27, 0xF2	; 242
    6432:	a6 0f       	add	r26, r22
    6434:	b7 1f       	adc	r27, r23
    6436:	11 96       	adiw	r26, 0x01	; 1
    6438:	8c 91       	ld	r24, X
    643a:	e6 0f       	add	r30, r22
    643c:	f7 1f       	adc	r31, r23
    643e:	eb 5c       	subi	r30, 0xCB	; 203
    6440:	f2 4f       	sbci	r31, 0xF2	; 242
    6442:	20 81       	ld	r18, Z
    6444:	90 e0       	ldi	r25, 0x00	; 0
}
    6446:	92 2b       	or	r25, r18
    6448:	08 95       	ret

0000644a <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    644a:	2f 92       	push	r2
    644c:	3f 92       	push	r3
    644e:	4f 92       	push	r4
    6450:	5f 92       	push	r5
    6452:	6f 92       	push	r6
    6454:	7f 92       	push	r7
    6456:	8f 92       	push	r8
    6458:	9f 92       	push	r9
    645a:	af 92       	push	r10
    645c:	bf 92       	push	r11
    645e:	cf 92       	push	r12
    6460:	df 92       	push	r13
    6462:	ef 92       	push	r14
    6464:	ff 92       	push	r15
    6466:	0f 93       	push	r16
    6468:	1f 93       	push	r17
    646a:	cf 93       	push	r28
    646c:	df 93       	push	r29
    646e:	00 d0       	rcall	.+0      	; 0x6470 <MB_S_Timer_ISR+0x26>
    6470:	00 d0       	rcall	.+0      	; 0x6472 <MB_S_Timer_ISR+0x28>
    6472:	1f 92       	push	r1
    6474:	cd b7       	in	r28, 0x3d	; 61
    6476:	de b7       	in	r29, 0x3e	; 62
    6478:	78 2e       	mov	r7, r24
	switch (MB_State[MB_N]) {
    647a:	c8 2e       	mov	r12, r24
    647c:	d1 2c       	mov	r13, r1
    647e:	96 01       	movw	r18, r12
    6480:	25 52       	subi	r18, 0x25	; 37
    6482:	3c 4f       	sbci	r19, 0xFC	; 252
    6484:	59 01       	movw	r10, r18
    6486:	d9 01       	movw	r26, r18
    6488:	8c 91       	ld	r24, X
    648a:	88 23       	and	r24, r24
    648c:	59 f0       	breq	.+22     	; 0x64a4 <MB_S_Timer_ISR+0x5a>
    648e:	82 30       	cpi	r24, 0x02	; 2
    6490:	09 f0       	breq	.+2      	; 0x6494 <MB_S_Timer_ISR+0x4a>
    6492:	aa c2       	rjmp	.+1364   	; 0x69e8 <MB_S_Timer_ISR+0x59e>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6494:	84 e0       	ldi	r24, 0x04	; 4
    6496:	d9 01       	movw	r26, r18
    6498:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    649a:	87 2d       	mov	r24, r7
    649c:	0e 94 31 30 	call	0x6062	; 0x6062 <CommErr>
    64a0:	88 23       	and	r24, r24
    64a2:	21 f0       	breq	.+8      	; 0x64ac <MB_S_Timer_ISR+0x62>
		MB_State[MB_N] = MB_Idle;
    64a4:	81 e0       	ldi	r24, 0x01	; 1
    64a6:	f5 01       	movw	r30, r10
    64a8:	80 83       	st	Z, r24
    64aa:	9e c2       	rjmp	.+1340   	; 0x69e8 <MB_S_Timer_ISR+0x59e>
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    64ac:	3c 2d       	mov	r19, r12
    64ae:	22 27       	eor	r18, r18
    64b0:	3d 83       	std	Y+5, r19	; 0x05
    64b2:	2c 83       	std	Y+4, r18	; 0x04
    64b4:	f9 01       	movw	r30, r18
    64b6:	eb 5c       	subi	r30, 0xCB	; 203
    64b8:	f2 4f       	sbci	r31, 0xF2	; 242
    64ba:	80 81       	ld	r24, Z
    64bc:	88 23       	and	r24, r24
    64be:	51 f0       	breq	.+20     	; 0x64d4 <MB_S_Timer_ISR+0x8a>
    64c0:	f6 01       	movw	r30, r12
    64c2:	ee 50       	subi	r30, 0x0E	; 14
    64c4:	fc 4f       	sbci	r31, 0xFC	; 252
    64c6:	90 81       	ld	r25, Z
    64c8:	89 17       	cp	r24, r25
    64ca:	21 f0       	breq	.+8      	; 0x64d4 <MB_S_Timer_ISR+0x8a>
		MB_State[MB_N] = MB_Idle;
    64cc:	81 e0       	ldi	r24, 0x01	; 1
    64ce:	d5 01       	movw	r26, r10
    64d0:	8c 93       	st	X, r24
    64d2:	8a c2       	rjmp	.+1300   	; 0x69e8 <MB_S_Timer_ISR+0x59e>
		return;
	}
	USART_Func(MB_N, LED);
    64d4:	84 e1       	ldi	r24, 0x14	; 20
    64d6:	8c 9d       	mul	r24, r12
    64d8:	40 01       	movw	r8, r0
    64da:	8d 9d       	mul	r24, r13
    64dc:	90 0c       	add	r9, r0
    64de:	11 24       	eor	r1, r1
    64e0:	f4 01       	movw	r30, r8
    64e2:	e9 55       	subi	r30, 0x59	; 89
    64e4:	f0 4b       	sbci	r31, 0xB0	; 176
    64e6:	4f 01       	movw	r8, r30

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    64e8:	25 91       	lpm	r18, Z+
    64ea:	34 91       	lpm	r19, Z
    64ec:	f9 01       	movw	r30, r18
    64ee:	09 95       	icall
	MB_CPT[MB_N][3]++;
    64f0:	86 01       	movw	r16, r12
    64f2:	e4 e0       	ldi	r30, 0x04	; 4
    64f4:	00 0f       	add	r16, r16
    64f6:	11 1f       	adc	r17, r17
    64f8:	ea 95       	dec	r30
    64fa:	e1 f7       	brne	.-8      	; 0x64f4 <MB_S_Timer_ISR+0xaa>
    64fc:	f8 01       	movw	r30, r16
    64fe:	ea 5e       	subi	r30, 0xEA	; 234
    6500:	f4 4f       	sbci	r31, 0xF4	; 244
    6502:	86 81       	ldd	r24, Z+6	; 0x06
    6504:	97 81       	ldd	r25, Z+7	; 0x07
    6506:	01 96       	adiw	r24, 0x01	; 1
    6508:	97 83       	std	Z+7, r25	; 0x07
    650a:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    650c:	ec 81       	ldd	r30, Y+4	; 0x04
    650e:	fd 81       	ldd	r31, Y+5	; 0x05
    6510:	eb 5c       	subi	r30, 0xCB	; 203
    6512:	f2 4f       	sbci	r31, 0xF2	; 242
    6514:	e2 80       	ldd	r14, Z+2	; 0x02
    6516:	f1 2c       	mov	r15, r1
    6518:	fe 2c       	mov	r15, r14
    651a:	ee 24       	eor	r14, r14
    651c:	83 81       	ldd	r24, Z+3	; 0x03
    651e:	e8 2a       	or	r14, r24
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6520:	61 81       	ldd	r22, Z+1	; 0x01
    6522:	86 2f       	mov	r24, r22
    6524:	90 e0       	ldi	r25, 0x00	; 0
    6526:	fc 01       	movw	r30, r24
    6528:	31 97       	sbiw	r30, 0x01	; 1
    652a:	e0 31       	cpi	r30, 0x10	; 16
    652c:	f1 05       	cpc	r31, r1
    652e:	08 f0       	brcs	.+2      	; 0x6532 <MB_S_Timer_ISR+0xe8>
    6530:	ec c1       	rjmp	.+984    	; 0x690a <MB_S_Timer_ISR+0x4c0>
    6532:	ea 5b       	subi	r30, 0xBA	; 186
    6534:	ff 4f       	sbci	r31, 0xFF	; 255
    6536:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    653a:	ec 81       	ldd	r30, Y+4	; 0x04
    653c:	fd 81       	ldd	r31, Y+5	; 0x05
    653e:	eb 5c       	subi	r30, 0xCB	; 203
    6540:	f2 4f       	sbci	r31, 0xF2	; 242
    6542:	80 81       	ld	r24, Z
    6544:	88 23       	and	r24, r24
    6546:	09 f4       	brne	.+2      	; 0x654a <MB_S_Timer_ISR+0x100>
    6548:	dd c0       	rjmp	.+442    	; 0x6704 <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    654a:	d6 01       	movw	r26, r12
    654c:	a9 53       	subi	r26, 0x39	; 57
    654e:	b7 4f       	sbci	r27, 0xF7	; 247
    6550:	8c 91       	ld	r24, X
    6552:	88 30       	cpi	r24, 0x08	; 8
    6554:	09 f0       	breq	.+2      	; 0x6558 <MB_S_Timer_ISR+0x10e>
    6556:	8c c0       	rjmp	.+280    	; 0x6670 <MB_S_Timer_ISR+0x226>
    6558:	24 81       	ldd	r18, Z+4	; 0x04
    655a:	30 e0       	ldi	r19, 0x00	; 0
    655c:	32 2f       	mov	r19, r18
    655e:	22 27       	eor	r18, r18
    6560:	85 81       	ldd	r24, Z+5	; 0x05
    6562:	28 2b       	or	r18, r24
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    6564:	a9 01       	movw	r20, r18
    6566:	4e 0d       	add	r20, r14
    6568:	5f 1d       	adc	r21, r15
    656a:	f8 01       	movw	r30, r16
    656c:	61 30       	cpi	r22, 0x01	; 1
    656e:	61 f4       	brne	.+24     	; 0x6588 <MB_S_Timer_ISR+0x13e>
    6570:	e6 53       	subi	r30, 0x36	; 54
    6572:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6574:	85 91       	lpm	r24, Z+
    6576:	94 91       	lpm	r25, Z
    6578:	84 17       	cp	r24, r20
    657a:	95 07       	cpc	r25, r21
    657c:	08 f4       	brcc	.+2      	; 0x6580 <MB_S_Timer_ISR+0x136>
    657e:	96 c1       	rjmp	.+812    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6580:	f8 01       	movw	r30, r16
    6582:	e8 53       	subi	r30, 0x38	; 56
    6584:	f0 4b       	sbci	r31, 0xB0	; 176
    6586:	0b c0       	rjmp	.+22     	; 0x659e <MB_S_Timer_ISR+0x154>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    6588:	e2 53       	subi	r30, 0x32	; 50
    658a:	f0 4b       	sbci	r31, 0xB0	; 176
    658c:	85 91       	lpm	r24, Z+
    658e:	94 91       	lpm	r25, Z
    6590:	84 17       	cp	r24, r20
    6592:	95 07       	cpc	r25, r21
    6594:	08 f4       	brcc	.+2      	; 0x6598 <MB_S_Timer_ISR+0x14e>
    6596:	8a c1       	rjmp	.+788    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6598:	f8 01       	movw	r30, r16
    659a:	e4 53       	subi	r30, 0x34	; 52
    659c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    659e:	65 91       	lpm	r22, Z+
    65a0:	74 91       	lpm	r23, Z
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    65a2:	e1 e0       	ldi	r30, 0x01	; 1
    65a4:	a9 01       	movw	r20, r18
    65a6:	47 70       	andi	r20, 0x07	; 7
    65a8:	55 27       	eor	r21, r21
    65aa:	45 2b       	or	r20, r21
    65ac:	09 f4       	brne	.+2      	; 0x65b0 <MB_S_Timer_ISR+0x166>
    65ae:	e0 e0       	ldi	r30, 0x00	; 0
    65b0:	c9 01       	movw	r24, r18
    65b2:	43 e0       	ldi	r20, 0x03	; 3
    65b4:	96 95       	lsr	r25
    65b6:	87 95       	ror	r24
    65b8:	4a 95       	dec	r20
    65ba:	e1 f7       	brne	.-8      	; 0x65b4 <MB_S_Timer_ISR+0x16a>
    65bc:	8e 0f       	add	r24, r30
    65be:	ec 81       	ldd	r30, Y+4	; 0x04
    65c0:	fd 81       	ldd	r31, Y+5	; 0x05
    65c2:	eb 5c       	subi	r30, 0xCB	; 203
    65c4:	f2 4f       	sbci	r31, 0xF2	; 242
    65c6:	82 83       	std	Z+2, r24	; 0x02
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    65c8:	8b 5f       	subi	r24, 0xFB	; 251
    65ca:	8c 93       	st	X, r24
	for (uint8_t i=0; i<Qt; i++) {
    65cc:	a0 e0       	ldi	r26, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    65ce:	22 24       	eor	r2, r2
    65d0:	23 94       	inc	r2
    65d2:	31 2c       	mov	r3, r1
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    65d4:	4a 2f       	mov	r20, r26
    65d6:	50 e0       	ldi	r21, 0x00	; 0
    65d8:	42 17       	cp	r20, r18
    65da:	53 07       	cpc	r21, r19
    65dc:	08 f0       	brcs	.+2      	; 0x65e0 <MB_S_Timer_ISR+0x196>
    65de:	93 c1       	rjmp	.+806    	; 0x6906 <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    65e0:	4e 0d       	add	r20, r14
    65e2:	5f 1d       	adc	r21, r15
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    65e4:	ba 2f       	mov	r27, r26
    65e6:	b6 95       	lsr	r27
    65e8:	b6 95       	lsr	r27
    65ea:	b6 95       	lsr	r27
    65ec:	bd 5f       	subi	r27, 0xFD	; 253
    65ee:	8a 2f       	mov	r24, r26
    65f0:	87 70       	andi	r24, 0x07	; 7
    65f2:	21 01       	movw	r4, r2
    65f4:	01 c0       	rjmp	.+2      	; 0x65f8 <MB_S_Timer_ISR+0x1ae>
    65f6:	44 0c       	add	r4, r4
    65f8:	8a 95       	dec	r24
    65fa:	ea f7       	brpl	.-6      	; 0x65f6 <MB_S_Timer_ISR+0x1ac>
		if (Discr[j/8] &(1<<j%8))
    65fc:	fa 01       	movw	r30, r20
    65fe:	83 e0       	ldi	r24, 0x03	; 3
    6600:	f6 95       	lsr	r31
    6602:	e7 95       	ror	r30
    6604:	8a 95       	dec	r24
    6606:	e1 f7       	brne	.-8      	; 0x6600 <MB_S_Timer_ISR+0x1b6>
    6608:	e6 0f       	add	r30, r22
    660a:	f7 1f       	adc	r31, r23
    660c:	80 81       	ld	r24, Z
    660e:	90 e0       	ldi	r25, 0x00	; 0
    6610:	47 70       	andi	r20, 0x07	; 7
    6612:	55 27       	eor	r21, r21
    6614:	02 c0       	rjmp	.+4      	; 0x661a <MB_S_Timer_ISR+0x1d0>
    6616:	95 95       	asr	r25
    6618:	87 95       	ror	r24
    661a:	4a 95       	dec	r20
    661c:	e2 f7       	brpl	.-8      	; 0x6616 <MB_S_Timer_ISR+0x1cc>
    661e:	eb 2f       	mov	r30, r27
    6620:	f0 e0       	ldi	r31, 0x00	; 0
    6622:	80 ff       	sbrs	r24, 0
    6624:	0a c0       	rjmp	.+20     	; 0x663a <MB_S_Timer_ISR+0x1f0>
			MB_Frame[MB_N][Byte] |=Bit;
    6626:	8c 81       	ldd	r24, Y+4	; 0x04
    6628:	9d 81       	ldd	r25, Y+5	; 0x05
    662a:	e8 0f       	add	r30, r24
    662c:	f9 1f       	adc	r31, r25
    662e:	eb 5c       	subi	r30, 0xCB	; 203
    6630:	f2 4f       	sbci	r31, 0xF2	; 242
    6632:	80 81       	ld	r24, Z
    6634:	84 29       	or	r24, r4
    6636:	80 83       	st	Z, r24
    6638:	0a c0       	rjmp	.+20     	; 0x664e <MB_S_Timer_ISR+0x204>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    663a:	8c 81       	ldd	r24, Y+4	; 0x04
    663c:	9d 81       	ldd	r25, Y+5	; 0x05
    663e:	e8 0f       	add	r30, r24
    6640:	f9 1f       	adc	r31, r25
    6642:	eb 5c       	subi	r30, 0xCB	; 203
    6644:	f2 4f       	sbci	r31, 0xF2	; 242
    6646:	40 94       	com	r4
    6648:	80 81       	ld	r24, Z
    664a:	48 22       	and	r4, r24
    664c:	40 82       	st	Z, r4
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    664e:	af 5f       	subi	r26, 0xFF	; 255
    6650:	c1 cf       	rjmp	.-126    	; 0x65d4 <MB_S_Timer_ISR+0x18a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    6652:	ec 81       	ldd	r30, Y+4	; 0x04
    6654:	fd 81       	ldd	r31, Y+5	; 0x05
    6656:	eb 5c       	subi	r30, 0xCB	; 203
    6658:	f2 4f       	sbci	r31, 0xF2	; 242
    665a:	80 81       	ld	r24, Z
    665c:	88 23       	and	r24, r24
    665e:	09 f4       	brne	.+2      	; 0x6662 <MB_S_Timer_ISR+0x218>
    6660:	51 c0       	rjmp	.+162    	; 0x6704 <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    6662:	96 01       	movw	r18, r12
    6664:	29 53       	subi	r18, 0x39	; 57
    6666:	37 4f       	sbci	r19, 0xF7	; 247
    6668:	d9 01       	movw	r26, r18
    666a:	8c 91       	ld	r24, X
    666c:	88 30       	cpi	r24, 0x08	; 8
    666e:	11 f0       	breq	.+4      	; 0x6674 <MB_S_Timer_ISR+0x22a>
		return MB_Frame[MB_N][2]=IllegData;
    6670:	83 e0       	ldi	r24, 0x03	; 3
    6672:	0f c1       	rjmp	.+542    	; 0x6892 <MB_S_Timer_ISR+0x448>
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    6674:	75 81       	ldd	r23, Z+5	; 0x05
    6676:	c7 01       	movw	r24, r14
    6678:	87 0f       	add	r24, r23
    667a:	91 1d       	adc	r25, r1
    667c:	f8 01       	movw	r30, r16
    667e:	63 30       	cpi	r22, 0x03	; 3
    6680:	61 f4       	brne	.+24     	; 0x669a <MB_S_Timer_ISR+0x250>
    6682:	ee 52       	subi	r30, 0x2E	; 46
    6684:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6686:	45 91       	lpm	r20, Z+
    6688:	54 91       	lpm	r21, Z
    668a:	48 17       	cp	r20, r24
    668c:	59 07       	cpc	r21, r25
    668e:	08 f4       	brcc	.+2      	; 0x6692 <MB_S_Timer_ISR+0x248>
    6690:	0d c1       	rjmp	.+538    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6692:	f8 01       	movw	r30, r16
    6694:	e0 53       	subi	r30, 0x30	; 48
    6696:	f0 4b       	sbci	r31, 0xB0	; 176
    6698:	0b c0       	rjmp	.+22     	; 0x66b0 <MB_S_Timer_ISR+0x266>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    669a:	ea 52       	subi	r30, 0x2A	; 42
    669c:	f0 4b       	sbci	r31, 0xB0	; 176
    669e:	45 91       	lpm	r20, Z+
    66a0:	54 91       	lpm	r21, Z
    66a2:	48 17       	cp	r20, r24
    66a4:	59 07       	cpc	r21, r25
    66a6:	08 f4       	brcc	.+2      	; 0x66aa <MB_S_Timer_ISR+0x260>
    66a8:	01 c1       	rjmp	.+514    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    66aa:	f8 01       	movw	r30, r16
    66ac:	ec 52       	subi	r30, 0x2C	; 44
    66ae:	f0 4b       	sbci	r31, 0xB0	; 176
    66b0:	85 91       	lpm	r24, Z+
    66b2:	94 91       	lpm	r25, Z
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    66b4:	77 0f       	add	r23, r23
    66b6:	ac 81       	ldd	r26, Y+4	; 0x04
    66b8:	bd 81       	ldd	r27, Y+5	; 0x05
    66ba:	ab 5c       	subi	r26, 0xCB	; 203
    66bc:	b2 4f       	sbci	r27, 0xF2	; 242
    66be:	12 96       	adiw	r26, 0x02	; 2
    66c0:	7c 93       	st	X, r23
    66c2:	12 97       	sbiw	r26, 0x02	; 2
    66c4:	7b 5f       	subi	r23, 0xFB	; 251
    66c6:	f9 01       	movw	r30, r18
    66c8:	70 83       	st	Z, r23
	uint8_t Qt = MB_Frame[MB_N][5];
    66ca:	15 96       	adiw	r26, 0x05	; 5
    66cc:	5c 91       	ld	r21, X
    66ce:	15 97       	sbiw	r26, 0x05	; 5
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    66d0:	f7 01       	movw	r30, r14
    66d2:	ee 0f       	add	r30, r30
    66d4:	ff 1f       	adc	r31, r31
    66d6:	e8 0f       	add	r30, r24
    66d8:	f9 1f       	adc	r31, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    66da:	40 e0       	ldi	r20, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    66dc:	cd 01       	movw	r24, r26
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    66de:	45 17       	cp	r20, r21
    66e0:	09 f4       	brne	.+2      	; 0x66e4 <MB_S_Timer_ISR+0x29a>
    66e2:	11 c1       	rjmp	.+546    	; 0x6906 <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
    66e4:	64 2f       	mov	r22, r20
    66e6:	66 0f       	add	r22, r22
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    66e8:	7c 01       	movw	r14, r24
    66ea:	e6 0e       	add	r14, r22
    66ec:	f1 1c       	adc	r15, r1
    66ee:	61 81       	ldd	r22, Z+1	; 0x01
    66f0:	d7 01       	movw	r26, r14
    66f2:	13 96       	adiw	r26, 0x03	; 3
    66f4:	6c 93       	st	X, r22
		MB_Frame[MB_N][4+j] = Reg[i];
    66f6:	20 81       	ld	r18, Z
    66f8:	32 96       	adiw	r30, 0x02	; 2
    66fa:	d7 01       	movw	r26, r14
    66fc:	14 96       	adiw	r26, 0x04	; 4
    66fe:	2c 93       	st	X, r18
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6700:	4f 5f       	subi	r20, 0xFF	; 255
    6702:	ed cf       	rjmp	.-38     	; 0x66de <MB_S_Timer_ISR+0x294>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
    6704:	9f ef       	ldi	r25, 0xFF	; 255
    6706:	08 c1       	rjmp	.+528    	; 0x6918 <MB_S_Timer_ISR+0x4ce>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    6708:	d6 01       	movw	r26, r12
    670a:	a9 53       	subi	r26, 0x39	; 57
    670c:	b7 4f       	sbci	r27, 0xF7	; 247
    670e:	8c 91       	ld	r24, X
    6710:	88 30       	cpi	r24, 0x08	; 8
    6712:	09 f0       	breq	.+2      	; 0x6716 <MB_S_Timer_ISR+0x2cc>
    6714:	b9 c0       	rjmp	.+370    	; 0x6888 <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    6716:	f8 01       	movw	r30, r16
    6718:	ee 52       	subi	r30, 0x2E	; 46
    671a:	f0 4b       	sbci	r31, 0xB0	; 176
    671c:	85 91       	lpm	r24, Z+
    671e:	94 91       	lpm	r25, Z
    6720:	97 01       	movw	r18, r14
    6722:	2f 5f       	subi	r18, 0xFF	; 255
    6724:	3f 4f       	sbci	r19, 0xFF	; 255
    6726:	82 17       	cp	r24, r18
    6728:	93 07       	cpc	r25, r19
    672a:	08 f4       	brcc	.+2      	; 0x672e <MB_S_Timer_ISR+0x2e4>
    672c:	bf c0       	rjmp	.+382    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    672e:	88 e0       	ldi	r24, 0x08	; 8
    6730:	8c 93       	st	X, r24
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    6732:	f8 01       	movw	r30, r16
    6734:	e0 53       	subi	r30, 0x30	; 48
    6736:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6738:	85 91       	lpm	r24, Z+
    673a:	94 91       	lpm	r25, Z
    673c:	f7 01       	movw	r30, r14
    673e:	ee 0f       	add	r30, r30
    6740:	ff 1f       	adc	r31, r31
    6742:	e8 0f       	add	r30, r24
    6744:	f9 1f       	adc	r31, r25
    6746:	ac 81       	ldd	r26, Y+4	; 0x04
    6748:	bd 81       	ldd	r27, Y+5	; 0x05
    674a:	ab 5c       	subi	r26, 0xCB	; 203
    674c:	b2 4f       	sbci	r27, 0xF2	; 242
    674e:	14 96       	adiw	r26, 0x04	; 4
    6750:	8c 91       	ld	r24, X
    6752:	14 97       	sbiw	r26, 0x04	; 4
    6754:	90 e0       	ldi	r25, 0x00	; 0
    6756:	98 2f       	mov	r25, r24
    6758:	88 27       	eor	r24, r24
    675a:	15 96       	adiw	r26, 0x05	; 5
    675c:	2c 91       	ld	r18, X
    675e:	82 2b       	or	r24, r18
    6760:	91 83       	std	Z+1, r25	; 0x01
    6762:	80 83       	st	Z, r24
    6764:	d0 c0       	rjmp	.+416    	; 0x6906 <MB_S_Timer_ISR+0x4bc>
    6766:	ec 81       	ldd	r30, Y+4	; 0x04
    6768:	fd 81       	ldd	r31, Y+5	; 0x05
    676a:	eb 5c       	subi	r30, 0xCB	; 203
    676c:	f2 4f       	sbci	r31, 0xF2	; 242
    676e:	64 80       	ldd	r6, Z+4	; 0x04
    6770:	85 81       	ldd	r24, Z+5	; 0x05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    6772:	66 81       	ldd	r22, Z+6	; 0x06
    6774:	d6 01       	movw	r26, r12
    6776:	a9 53       	subi	r26, 0x39	; 57
    6778:	b7 4f       	sbci	r27, 0xF7	; 247
    677a:	4c 91       	ld	r20, X
    677c:	50 e0       	ldi	r21, 0x00	; 0
    677e:	70 e0       	ldi	r23, 0x00	; 0
    6780:	9b 01       	movw	r18, r22
    6782:	27 5f       	subi	r18, 0xF7	; 247
    6784:	3f 4f       	sbci	r19, 0xFF	; 255
    6786:	42 17       	cp	r20, r18
    6788:	53 07       	cpc	r21, r19
    678a:	09 f0       	breq	.+2      	; 0x678e <MB_S_Timer_ISR+0x344>
    678c:	7d c0       	rjmp	.+250    	; 0x6888 <MB_S_Timer_ISR+0x43e>
    678e:	90 e0       	ldi	r25, 0x00	; 0
    6790:	96 29       	or	r25, r6
    6792:	9c 01       	movw	r18, r24
    6794:	27 70       	andi	r18, 0x07	; 7
    6796:	33 27       	eor	r19, r19
    6798:	41 e0       	ldi	r20, 0x01	; 1
    679a:	50 e0       	ldi	r21, 0x00	; 0
    679c:	23 2b       	or	r18, r19
    679e:	11 f4       	brne	.+4      	; 0x67a4 <MB_S_Timer_ISR+0x35a>
    67a0:	40 e0       	ldi	r20, 0x00	; 0
    67a2:	50 e0       	ldi	r21, 0x00	; 0
    67a4:	9c 01       	movw	r18, r24
    67a6:	e3 e0       	ldi	r30, 0x03	; 3
    67a8:	36 95       	lsr	r19
    67aa:	27 95       	ror	r18
    67ac:	ea 95       	dec	r30
    67ae:	e1 f7       	brne	.-8      	; 0x67a8 <MB_S_Timer_ISR+0x35e>
    67b0:	24 0f       	add	r18, r20
    67b2:	35 1f       	adc	r19, r21
    67b4:	26 17       	cp	r18, r22
    67b6:	37 07       	cpc	r19, r23
    67b8:	09 f0       	breq	.+2      	; 0x67bc <MB_S_Timer_ISR+0x372>
    67ba:	66 c0       	rjmp	.+204    	; 0x6888 <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    67bc:	f8 01       	movw	r30, r16
    67be:	e6 53       	subi	r30, 0x36	; 54
    67c0:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    67c2:	25 91       	lpm	r18, Z+
    67c4:	34 91       	lpm	r19, Z
    67c6:	ac 01       	movw	r20, r24
    67c8:	4e 0d       	add	r20, r14
    67ca:	5f 1d       	adc	r21, r15
    67cc:	24 17       	cp	r18, r20
    67ce:	35 07       	cpc	r19, r21
    67d0:	08 f4       	brcc	.+2      	; 0x67d4 <MB_S_Timer_ISR+0x38a>
    67d2:	6c c0       	rjmp	.+216    	; 0x68ac <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
    67d4:	f8 01       	movw	r30, r16
    67d6:	e8 53       	subi	r30, 0x38	; 56
    67d8:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    67da:	25 90       	lpm	r2, Z+
    67dc:	34 90       	lpm	r3, Z
	MB_Frame_Sz[MB_N] = 8;
    67de:	28 e0       	ldi	r18, 0x08	; 8
    67e0:	2c 93       	st	X, r18
	for (uint8_t i=0; i<Qt; i++) {
    67e2:	51 2c       	mov	r5, r1
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    67e4:	6c 81       	ldd	r22, Y+4	; 0x04
    67e6:	7d 81       	ldd	r23, Y+5	; 0x05
    67e8:	6b 5c       	subi	r22, 0xCB	; 203
    67ea:	72 4f       	sbci	r23, 0xF2	; 242
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    67ec:	45 2d       	mov	r20, r5
    67ee:	50 e0       	ldi	r21, 0x00	; 0
    67f0:	48 17       	cp	r20, r24
    67f2:	59 07       	cpc	r21, r25
    67f4:	08 f0       	brcs	.+2      	; 0x67f8 <MB_S_Timer_ISR+0x3ae>
    67f6:	87 c0       	rjmp	.+270    	; 0x6906 <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    67f8:	4e 0d       	add	r20, r14
    67fa:	5f 1d       	adc	r21, r15
		uint16_t Byte=j/8, Bit=1<<j%8;
    67fc:	fa 01       	movw	r30, r20
    67fe:	a3 e0       	ldi	r26, 0x03	; 3
    6800:	f6 95       	lsr	r31
    6802:	e7 95       	ror	r30
    6804:	aa 95       	dec	r26
    6806:	e1 f7       	brne	.-8      	; 0x6800 <MB_S_Timer_ISR+0x3b6>
    6808:	47 70       	andi	r20, 0x07	; 7
    680a:	55 27       	eor	r21, r21
    680c:	21 e0       	ldi	r18, 0x01	; 1
    680e:	30 e0       	ldi	r19, 0x00	; 0
    6810:	02 c0       	rjmp	.+4      	; 0x6816 <MB_S_Timer_ISR+0x3cc>
    6812:	22 0f       	add	r18, r18
    6814:	33 1f       	adc	r19, r19
    6816:	4a 95       	dec	r20
    6818:	e2 f7       	brpl	.-8      	; 0x6812 <MB_S_Timer_ISR+0x3c8>
    681a:	a9 01       	movw	r20, r18
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    681c:	25 2d       	mov	r18, r5
    681e:	26 95       	lsr	r18
    6820:	26 95       	lsr	r18
    6822:	26 95       	lsr	r18
    6824:	db 01       	movw	r26, r22
    6826:	a2 0f       	add	r26, r18
    6828:	b1 1d       	adc	r27, r1
    682a:	17 96       	adiw	r26, 0x07	; 7
    682c:	2c 91       	ld	r18, X
    682e:	30 e0       	ldi	r19, 0x00	; 0
    6830:	a5 2d       	mov	r26, r5
    6832:	a7 70       	andi	r26, 0x07	; 7
    6834:	02 c0       	rjmp	.+4      	; 0x683a <MB_S_Timer_ISR+0x3f0>
    6836:	35 95       	asr	r19
    6838:	27 95       	ror	r18
    683a:	aa 95       	dec	r26
    683c:	e2 f7       	brpl	.-8      	; 0x6836 <MB_S_Timer_ISR+0x3ec>
    683e:	e2 0d       	add	r30, r2
    6840:	f3 1d       	adc	r31, r3
    6842:	20 ff       	sbrs	r18, 0
    6844:	03 c0       	rjmp	.+6      	; 0x684c <MB_S_Timer_ISR+0x402>
			Coil[Byte] |=Bit;
    6846:	20 81       	ld	r18, Z
    6848:	24 2b       	or	r18, r20
    684a:	03 c0       	rjmp	.+6      	; 0x6852 <MB_S_Timer_ISR+0x408>
		else
			Coil[Byte] &=~Bit;
    684c:	40 95       	com	r20
    684e:	20 81       	ld	r18, Z
    6850:	24 23       	and	r18, r20
    6852:	20 83       	st	Z, r18
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    6854:	53 94       	inc	r5
    6856:	ca cf       	rjmp	.-108    	; 0x67ec <MB_S_Timer_ISR+0x3a2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    6858:	ec 81       	ldd	r30, Y+4	; 0x04
    685a:	fd 81       	ldd	r31, Y+5	; 0x05
    685c:	eb 5c       	subi	r30, 0xCB	; 203
    685e:	f2 4f       	sbci	r31, 0xF2	; 242
    6860:	46 81       	ldd	r20, Z+6	; 0x06
    6862:	50 e0       	ldi	r21, 0x00	; 0
    6864:	d6 01       	movw	r26, r12
    6866:	a9 53       	subi	r26, 0x39	; 57
    6868:	b7 4f       	sbci	r27, 0xF7	; 247
    686a:	2c 91       	ld	r18, X
    686c:	30 e0       	ldi	r19, 0x00	; 0
    686e:	ca 01       	movw	r24, r20
    6870:	09 96       	adiw	r24, 0x09	; 9
    6872:	28 17       	cp	r18, r24
    6874:	39 07       	cpc	r19, r25
    6876:	41 f4       	brne	.+16     	; 0x6888 <MB_S_Timer_ISR+0x43e>
    6878:	85 81       	ldd	r24, Z+5	; 0x05
    687a:	90 e0       	ldi	r25, 0x00	; 0
    687c:	9c 01       	movw	r18, r24
    687e:	22 0f       	add	r18, r18
    6880:	33 1f       	adc	r19, r19
    6882:	24 17       	cp	r18, r20
    6884:	35 07       	cpc	r19, r21
    6886:	41 f0       	breq	.+16     	; 0x6898 <MB_S_Timer_ISR+0x44e>
		return MB_Frame[MB_N][2]=IllegData;
    6888:	83 e0       	ldi	r24, 0x03	; 3
    688a:	ec 81       	ldd	r30, Y+4	; 0x04
    688c:	fd 81       	ldd	r31, Y+5	; 0x05
    688e:	eb 5c       	subi	r30, 0xCB	; 203
    6890:	f2 4f       	sbci	r31, 0xF2	; 242
    6892:	82 83       	std	Z+2, r24	; 0x02
    6894:	93 e0       	ldi	r25, 0x03	; 3
    6896:	40 c0       	rjmp	.+128    	; 0x6918 <MB_S_Timer_ISR+0x4ce>
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    6898:	f8 01       	movw	r30, r16
    689a:	ee 52       	subi	r30, 0x2E	; 46
    689c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    689e:	25 91       	lpm	r18, Z+
    68a0:	34 91       	lpm	r19, Z
    68a2:	8e 0d       	add	r24, r14
    68a4:	9f 1d       	adc	r25, r15
    68a6:	28 17       	cp	r18, r24
    68a8:	39 07       	cpc	r19, r25
    68aa:	40 f4       	brcc	.+16     	; 0x68bc <MB_S_Timer_ISR+0x472>
		return MB_Frame[MB_N][2]=IllegAddr;
    68ac:	82 e0       	ldi	r24, 0x02	; 2
    68ae:	ec 81       	ldd	r30, Y+4	; 0x04
    68b0:	fd 81       	ldd	r31, Y+5	; 0x05
    68b2:	eb 5c       	subi	r30, 0xCB	; 203
    68b4:	f2 4f       	sbci	r31, 0xF2	; 242
    68b6:	82 83       	std	Z+2, r24	; 0x02
    68b8:	92 e0       	ldi	r25, 0x02	; 2
    68ba:	2e c0       	rjmp	.+92     	; 0x6918 <MB_S_Timer_ISR+0x4ce>
	MB_Frame_Sz[MB_N] = 8;
    68bc:	88 e0       	ldi	r24, 0x08	; 8
    68be:	8c 93       	st	X, r24
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    68c0:	f8 01       	movw	r30, r16
    68c2:	e0 53       	subi	r30, 0x30	; 48
    68c4:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    68c6:	25 90       	lpm	r2, Z+
    68c8:	34 90       	lpm	r3, Z
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    68ca:	61 2c       	mov	r6, r1
    68cc:	2c 81       	ldd	r18, Y+4	; 0x04
    68ce:	3d 81       	ldd	r19, Y+5	; 0x05
    68d0:	26 5c       	subi	r18, 0xC6	; 198
    68d2:	32 4f       	sbci	r19, 0xF2	; 242
    68d4:	3a 83       	std	Y+2, r19	; 0x02
    68d6:	29 83       	std	Y+1, r18	; 0x01
    68d8:	e9 81       	ldd	r30, Y+1	; 0x01
    68da:	fa 81       	ldd	r31, Y+2	; 0x02
    68dc:	80 81       	ld	r24, Z
    68de:	68 16       	cp	r6, r24
    68e0:	90 f4       	brcc	.+36     	; 0x6906 <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    68e2:	27 01       	movw	r4, r14
    68e4:	46 0c       	add	r4, r6
    68e6:	51 1c       	adc	r5, r1
    68e8:	44 0c       	add	r4, r4
    68ea:	55 1c       	adc	r5, r5
    68ec:	42 0c       	add	r4, r2
    68ee:	53 1c       	adc	r5, r3
    68f0:	66 2d       	mov	r22, r6
    68f2:	66 0f       	add	r22, r22
    68f4:	69 5f       	subi	r22, 0xF9	; 249
    68f6:	87 2d       	mov	r24, r7
    68f8:	0e 94 11 32 	call	0x6422	; 0x6422 <MB_FrameReg>
    68fc:	d2 01       	movw	r26, r4
    68fe:	8d 93       	st	X+, r24
    6900:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6902:	63 94       	inc	r6
    6904:	e9 cf       	rjmp	.-46     	; 0x68d8 <MB_S_Timer_ISR+0x48e>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
	}
	return 0;
    6906:	90 e0       	ldi	r25, 0x00	; 0
    6908:	07 c0       	rjmp	.+14     	; 0x6918 <MB_S_Timer_ISR+0x4ce>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    690a:	81 e0       	ldi	r24, 0x01	; 1
    690c:	ec 81       	ldd	r30, Y+4	; 0x04
    690e:	fd 81       	ldd	r31, Y+5	; 0x05
    6910:	eb 5c       	subi	r30, 0xCB	; 203
    6912:	f2 4f       	sbci	r31, 0xF2	; 242
    6914:	82 83       	std	Z+2, r24	; 0x02
    6916:	91 e0       	ldi	r25, 0x01	; 1
		break;
	}
	if (MB_Frame[MB_N][0]) {
    6918:	ec 81       	ldd	r30, Y+4	; 0x04
    691a:	fd 81       	ldd	r31, Y+5	; 0x05
    691c:	eb 5c       	subi	r30, 0xCB	; 203
    691e:	f2 4f       	sbci	r31, 0xF2	; 242
    6920:	80 81       	ld	r24, Z
    6922:	88 23       	and	r24, r24
    6924:	79 f0       	breq	.+30     	; 0x6944 <MB_S_Timer_ISR+0x4fa>
		if (Err) {
    6926:	99 23       	and	r25, r25
    6928:	41 f0       	breq	.+16     	; 0x693a <MB_S_Timer_ISR+0x4f0>
			MB_Frame[MB_N][1] |=(1<<7);
    692a:	81 81       	ldd	r24, Z+1	; 0x01
    692c:	80 68       	ori	r24, 0x80	; 128
    692e:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    6930:	f6 01       	movw	r30, r12
    6932:	e9 53       	subi	r30, 0x39	; 57
    6934:	f7 4f       	sbci	r31, 0xF7	; 247
    6936:	85 e0       	ldi	r24, 0x05	; 5
    6938:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    693a:	87 2d       	mov	r24, r7
    693c:	9b 83       	std	Y+3, r25	; 0x03
    693e:	0e 94 92 30 	call	0x6124	; 0x6124 <SetCRC_MB>
    6942:	9b 81       	ldd	r25, Y+3	; 0x03
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    6944:	99 23       	and	r25, r25
    6946:	41 f0       	breq	.+16     	; 0x6958 <MB_S_Timer_ISR+0x50e>
		MB_CPT[MB_N][2]++;
    6948:	f8 01       	movw	r30, r16
    694a:	ea 5e       	subi	r30, 0xEA	; 234
    694c:	f4 4f       	sbci	r31, 0xF4	; 244
    694e:	84 81       	ldd	r24, Z+4	; 0x04
    6950:	95 81       	ldd	r25, Z+5	; 0x05
    6952:	01 96       	adiw	r24, 0x01	; 1
    6954:	95 83       	std	Z+5, r25	; 0x05
    6956:	84 83       	std	Z+4, r24	; 0x04
	if (MB_Frame[MB_N][0])
    6958:	ec 81       	ldd	r30, Y+4	; 0x04
    695a:	fd 81       	ldd	r31, Y+5	; 0x05
    695c:	eb 5c       	subi	r30, 0xCB	; 203
    695e:	f2 4f       	sbci	r31, 0xF2	; 242
    6960:	80 81       	ld	r24, Z
    6962:	88 23       	and	r24, r24
    6964:	d1 f0       	breq	.+52     	; 0x699a <MB_S_Timer_ISR+0x550>
		MB_Transm(MB_N);
    6966:	87 2d       	mov	r24, r7
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6968:	0f 90       	pop	r0
    696a:	0f 90       	pop	r0
    696c:	0f 90       	pop	r0
    696e:	0f 90       	pop	r0
    6970:	0f 90       	pop	r0
    6972:	df 91       	pop	r29
    6974:	cf 91       	pop	r28
    6976:	1f 91       	pop	r17
    6978:	0f 91       	pop	r16
    697a:	ff 90       	pop	r15
    697c:	ef 90       	pop	r14
    697e:	df 90       	pop	r13
    6980:	cf 90       	pop	r12
    6982:	bf 90       	pop	r11
    6984:	af 90       	pop	r10
    6986:	9f 90       	pop	r9
    6988:	8f 90       	pop	r8
    698a:	7f 90       	pop	r7
    698c:	6f 90       	pop	r6
    698e:	5f 90       	pop	r5
    6990:	4f 90       	pop	r4
    6992:	3f 90       	pop	r3
    6994:	2f 90       	pop	r2
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    6996:	0c 94 90 2f 	jmp	0x5f20	; 0x5f20 <MB_Transm>
	else {
		MB_CPT[MB_N][4]++;
    699a:	f8 01       	movw	r30, r16
    699c:	ea 5e       	subi	r30, 0xEA	; 234
    699e:	f4 4f       	sbci	r31, 0xF4	; 244
    69a0:	80 85       	ldd	r24, Z+8	; 0x08
    69a2:	91 85       	ldd	r25, Z+9	; 0x09
    69a4:	01 96       	adiw	r24, 0x01	; 1
    69a6:	91 87       	std	Z+9, r25	; 0x09
    69a8:	80 87       	std	Z+8, r24	; 0x08
		MB_State[MB_N] = MB_Idle;
    69aa:	81 e0       	ldi	r24, 0x01	; 1
    69ac:	d5 01       	movw	r26, r10
    69ae:	8c 93       	st	X, r24
    69b0:	f4 01       	movw	r30, r8
    69b2:	85 91       	lpm	r24, Z+
    69b4:	94 91       	lpm	r25, Z
		USART_Func(MB_N, LED);
    69b6:	fc 01       	movw	r30, r24
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69b8:	0f 90       	pop	r0
    69ba:	0f 90       	pop	r0
    69bc:	0f 90       	pop	r0
    69be:	0f 90       	pop	r0
    69c0:	0f 90       	pop	r0
    69c2:	df 91       	pop	r29
    69c4:	cf 91       	pop	r28
    69c6:	1f 91       	pop	r17
    69c8:	0f 91       	pop	r16
    69ca:	ff 90       	pop	r15
    69cc:	ef 90       	pop	r14
    69ce:	df 90       	pop	r13
    69d0:	cf 90       	pop	r12
    69d2:	bf 90       	pop	r11
    69d4:	af 90       	pop	r10
    69d6:	9f 90       	pop	r9
    69d8:	8f 90       	pop	r8
    69da:	7f 90       	pop	r7
    69dc:	6f 90       	pop	r6
    69de:	5f 90       	pop	r5
    69e0:	4f 90       	pop	r4
    69e2:	3f 90       	pop	r3
    69e4:	2f 90       	pop	r2
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
		MB_State[MB_N] = MB_Idle;
		USART_Func(MB_N, LED);
    69e6:	09 94       	ijmp
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69e8:	0f 90       	pop	r0
    69ea:	0f 90       	pop	r0
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	0f 90       	pop	r0
    69f2:	df 91       	pop	r29
    69f4:	cf 91       	pop	r28
    69f6:	1f 91       	pop	r17
    69f8:	0f 91       	pop	r16
    69fa:	ff 90       	pop	r15
    69fc:	ef 90       	pop	r14
    69fe:	df 90       	pop	r13
    6a00:	cf 90       	pop	r12
    6a02:	bf 90       	pop	r11
    6a04:	af 90       	pop	r10
    6a06:	9f 90       	pop	r9
    6a08:	8f 90       	pop	r8
    6a0a:	7f 90       	pop	r7
    6a0c:	6f 90       	pop	r6
    6a0e:	5f 90       	pop	r5
    6a10:	4f 90       	pop	r4
    6a12:	3f 90       	pop	r3
    6a14:	2f 90       	pop	r2
    6a16:	08 95       	ret

00006a18 <MB_S_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6a18:	24 e1       	ldi	r18, 0x14	; 20
    6a1a:	82 9f       	mul	r24, r18
    6a1c:	c0 01       	movw	r24, r0
    6a1e:	11 24       	eor	r1, r1
    6a20:	89 55       	subi	r24, 0x59	; 89
    6a22:	90 4b       	sbci	r25, 0xB0	; 176
    6a24:	fc 01       	movw	r30, r24
    6a26:	85 91       	lpm	r24, Z+
    6a28:	94 91       	lpm	r25, Z
    6a2a:	fc 01       	movw	r30, r24
    6a2c:	09 94       	ijmp

00006a2e <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    6a2e:	cf 93       	push	r28
    6a30:	df 93       	push	r29
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    6a32:	c8 2f       	mov	r28, r24
    6a34:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6a36:	ce 01       	movw	r24, r28
    6a38:	80 56       	subi	r24, 0x60	; 96
    6a3a:	9e 4f       	sbci	r25, 0xFE	; 254
    6a3c:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    6a40:	ce 50       	subi	r28, 0x0E	; 14
    6a42:	dc 4f       	sbci	r29, 0xFC	; 252
    6a44:	88 83       	st	Y, r24
	#endif
}
    6a46:	df 91       	pop	r29
    6a48:	cf 91       	pop	r28
    6a4a:	08 95       	ret

00006a4c <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    6a4c:	0f 93       	push	r16
    6a4e:	1f 93       	push	r17
    6a50:	cf 93       	push	r28
    6a52:	df 93       	push	r29
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    6a54:	c8 2f       	mov	r28, r24
    6a56:	d0 e0       	ldi	r29, 0x00	; 0
    6a58:	95 e0       	ldi	r25, 0x05	; 5
    6a5a:	89 9f       	mul	r24, r25
    6a5c:	80 01       	movw	r16, r0
    6a5e:	11 24       	eor	r1, r1
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    6a60:	c8 01       	movw	r24, r16
    6a62:	88 56       	subi	r24, 0x68	; 104
    6a64:	9e 4f       	sbci	r25, 0xFE	; 254
    6a66:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    6a6a:	fe 01       	movw	r30, r28
    6a6c:	ee 0f       	add	r30, r30
    6a6e:	ff 1f       	adc	r31, r31
    6a70:	e6 5e       	subi	r30, 0xE6	; 230
    6a72:	f9 4f       	sbci	r31, 0xF9	; 249
    6a74:	91 83       	std	Z+1, r25	; 0x01
    6a76:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6a78:	c8 01       	movw	r24, r16
    6a7a:	86 56       	subi	r24, 0x66	; 102
    6a7c:	9e 4f       	sbci	r25, 0xFE	; 254
    6a7e:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    6a82:	fe 01       	movw	r30, r28
    6a84:	e1 50       	subi	r30, 0x01	; 1
    6a86:	f5 4f       	sbci	r31, 0xF5	; 245
    6a88:	80 83       	st	Z, r24
    6a8a:	c8 01       	movw	r24, r16
    6a8c:	85 56       	subi	r24, 0x65	; 101
    6a8e:	9e 4f       	sbci	r25, 0xFE	; 254
    6a90:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    6a94:	fe 01       	movw	r30, r28
    6a96:	ee 53       	subi	r30, 0x3E	; 62
    6a98:	f7 4f       	sbci	r31, 0xF7	; 247
    6a9a:	80 83       	st	Z, r24
    6a9c:	c8 01       	movw	r24, r16
    6a9e:	84 56       	subi	r24, 0x64	; 100
    6aa0:	9e 4f       	sbci	r25, 0xFE	; 254
    6aa2:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    6aa6:	cc 51       	subi	r28, 0x1C	; 28
    6aa8:	dc 4f       	sbci	r29, 0xFC	; 252
    6aaa:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    6aac:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    6ab0:	93 e0       	ldi	r25, 0x03	; 3
    6ab2:	98 0f       	add	r25, r24
    6ab4:	90 93 0e 01 	sts	0x010E, r25

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    6ab8:	80 93 56 02 	sts	0x0256, r24
}
    6abc:	df 91       	pop	r29
    6abe:	cf 91       	pop	r28
    6ac0:	1f 91       	pop	r17
    6ac2:	0f 91       	pop	r16
    6ac4:	08 95       	ret

00006ac6 <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    6ac6:	0e 94 7a 2e 	call	0x5cf4	; 0x5cf4 <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    6aca:	10 92 db 03 	sts	0x03DB, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ace:	eb e9       	ldi	r30, 0x9B	; 155
    6ad0:	ff e4       	ldi	r31, 0x4F	; 79
    6ad2:	a5 91       	lpm	r26, Z+
    6ad4:	b4 91       	lpm	r27, Z
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    6ad6:	8c ef       	ldi	r24, 0xFC	; 252
    6ad8:	8c 93       	st	X, r24
    6ada:	ed e9       	ldi	r30, 0x9D	; 157
    6adc:	ff e4       	ldi	r31, 0x4F	; 79
    6ade:	a5 91       	lpm	r26, Z+
    6ae0:	b4 91       	lpm	r27, Z
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    6ae2:	88 e9       	ldi	r24, 0x98	; 152
    6ae4:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    6ae6:	80 e0       	ldi	r24, 0x00	; 0
    6ae8:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <SetParity>
		SetBAUD(MB_N);
    6aec:	80 e0       	ldi	r24, 0x00	; 0
    6aee:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6af2:	e8 ed       	ldi	r30, 0xD8	; 216
    6af4:	ff e4       	ldi	r31, 0x4F	; 79
    6af6:	e4 91       	lpm	r30, Z
		switch (prb(MB_Role+MB_N)) {
    6af8:	ee 23       	and	r30, r30
    6afa:	31 f0       	breq	.+12     	; 0x6b08 <MB_Init+0x42>
    6afc:	e1 30       	cpi	r30, 0x01	; 1
    6afe:	39 f4       	brne	.+14     	; 0x6b0e <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    6b00:	80 e0       	ldi	r24, 0x00	; 0
    6b02:	0e 94 26 35 	call	0x6a4c	; 0x6a4c <MB_M_Init>
			break;
    6b06:	03 c0       	rjmp	.+6      	; 0x6b0e <MB_Init+0x48>
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
		case Role_Slave:
			MB_S_Init(MB_N);
    6b08:	80 e0       	ldi	r24, 0x00	; 0
    6b0a:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b0e:	e1 e9       	ldi	r30, 0x91	; 145
    6b10:	ff e4       	ldi	r31, 0x4F	; 79
    6b12:	25 91       	lpm	r18, Z+
    6b14:	34 91       	lpm	r19, Z
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    6b16:	f9 01       	movw	r30, r18
    6b18:	09 94       	ijmp

00006b1a <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6b1a:	4f 92       	push	r4
    6b1c:	5f 92       	push	r5
    6b1e:	7f 92       	push	r7
    6b20:	8f 92       	push	r8
    6b22:	9f 92       	push	r9
    6b24:	af 92       	push	r10
    6b26:	bf 92       	push	r11
    6b28:	cf 92       	push	r12
    6b2a:	df 92       	push	r13
    6b2c:	ef 92       	push	r14
    6b2e:	ff 92       	push	r15
    6b30:	0f 93       	push	r16
    6b32:	1f 93       	push	r17
    6b34:	cf 93       	push	r28
    6b36:	df 93       	push	r29
    6b38:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    6b3a:	c8 2f       	mov	r28, r24
    6b3c:	d0 e0       	ldi	r29, 0x00	; 0
    6b3e:	fe 01       	movw	r30, r28
    6b40:	e5 52       	subi	r30, 0x25	; 37
    6b42:	fc 4f       	sbci	r31, 0xFC	; 252
    6b44:	80 81       	ld	r24, Z
    6b46:	88 23       	and	r24, r24
    6b48:	19 f0       	breq	.+6      	; 0x6b50 <MB_M_Timer_ISR+0x36>
    6b4a:	82 30       	cpi	r24, 0x02	; 2
    6b4c:	f1 f0       	breq	.+60     	; 0x6b8a <MB_M_Timer_ISR+0x70>
    6b4e:	85 c2       	rjmp	.+1290   	; 0x705a <MB_M_Timer_ISR+0x540>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6b50:	80 91 56 02 	lds	r24, 0x0256
    6b54:	8e 5f       	subi	r24, 0xFE	; 254
    6b56:	6f ef       	ldi	r22, 0xFF	; 255
    6b58:	7f ef       	ldi	r23, 0xFF	; 255
    6b5a:	8d 0d       	add	r24, r13
    6b5c:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
		FormQuery(MB_N);
    6b60:	8d 2d       	mov	r24, r13
    6b62:	0e 94 9d 31 	call	0x633a	; 0x633a <FormQuery>
		MB_Transm(MB_N);
    6b66:	8d 2d       	mov	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6b68:	df 91       	pop	r29
    6b6a:	cf 91       	pop	r28
    6b6c:	1f 91       	pop	r17
    6b6e:	0f 91       	pop	r16
    6b70:	ff 90       	pop	r15
    6b72:	ef 90       	pop	r14
    6b74:	df 90       	pop	r13
    6b76:	cf 90       	pop	r12
    6b78:	bf 90       	pop	r11
    6b7a:	af 90       	pop	r10
    6b7c:	9f 90       	pop	r9
    6b7e:	8f 90       	pop	r8
    6b80:	7f 90       	pop	r7
    6b82:	5f 90       	pop	r5
    6b84:	4f 90       	pop	r4
{
	switch (MB_State[MB_N]) {
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
    6b86:	0c 94 90 2f 	jmp	0x5f20	; 0x5f20 <MB_Transm>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6b8a:	84 e0       	ldi	r24, 0x04	; 4
    6b8c:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6b8e:	9e 01       	movw	r18, r28
    6b90:	24 5e       	subi	r18, 0xE4	; 228
    6b92:	39 4f       	sbci	r19, 0xF9	; 249
    6b94:	79 01       	movw	r14, r18
    6b96:	f9 01       	movw	r30, r18
    6b98:	90 81       	ld	r25, Z
    6b9a:	81 e0       	ldi	r24, 0x01	; 1
    6b9c:	92 30       	cpi	r25, 0x02	; 2
    6b9e:	09 f0       	breq	.+2      	; 0x6ba2 <MB_M_Timer_ISR+0x88>
    6ba0:	80 e0       	ldi	r24, 0x00	; 0
    6ba2:	80 93 5c 02 	sts	0x025C, r24
	if (CommErr(MB_N))
    6ba6:	8d 2d       	mov	r24, r13
    6ba8:	0e 94 31 30 	call	0x6062	; 0x6062 <CommErr>
    6bac:	81 11       	cpse	r24, r1
    6bae:	ed c1       	rjmp	.+986    	; 0x6f8a <MB_M_Timer_ISR+0x470>
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6bb0:	84 e1       	ldi	r24, 0x14	; 20
    6bb2:	8c 9f       	mul	r24, r28
    6bb4:	f0 01       	movw	r30, r0
    6bb6:	8d 9f       	mul	r24, r29
    6bb8:	f0 0d       	add	r31, r0
    6bba:	11 24       	eor	r1, r1
    6bbc:	e9 55       	subi	r30, 0x59	; 89
    6bbe:	f0 4b       	sbci	r31, 0xB0	; 176
    6bc0:	85 91       	lpm	r24, Z+
    6bc2:	94 91       	lpm	r25, Z
    6bc4:	fc 01       	movw	r30, r24
    6bc6:	09 95       	icall
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6bc8:	80 91 5c 02 	lds	r24, 0x025C
    6bcc:	88 23       	and	r24, r24
    6bce:	79 f0       	breq	.+30     	; 0x6bee <MB_M_Timer_ISR+0xd4>
			Addr = MB_SingleQuery[MB_N].Addr;
    6bd0:	fe 01       	movw	r30, r28
    6bd2:	63 e0       	ldi	r22, 0x03	; 3
    6bd4:	ee 0f       	add	r30, r30
    6bd6:	ff 1f       	adc	r31, r31
    6bd8:	6a 95       	dec	r22
    6bda:	e1 f7       	brne	.-8      	; 0x6bd4 <MB_M_Timer_ISR+0xba>
    6bdc:	e3 5a       	subi	r30, 0xA3	; 163
    6bde:	fd 4f       	sbci	r31, 0xFD	; 253
    6be0:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6be2:	41 81       	ldd	r20, Z+1	; 0x01
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
    6be4:	80 e0       	ldi	r24, 0x00	; 0
    6be6:	90 e0       	ldi	r25, 0x00	; 0
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
    6be8:	00 e0       	ldi	r16, 0x00	; 0
    6bea:	10 e0       	ldi	r17, 0x00	; 0
    6bec:	15 c0       	rjmp	.+42     	; 0x6c18 <MB_M_Timer_ISR+0xfe>
		if (LastProcSingle) {
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
    6bee:	8d 2d       	mov	r24, r13
    6bf0:	0e 94 be 28 	call	0x517c	; 0x517c <GetSlave>
    6bf4:	8c 01       	movw	r16, r24
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6bf6:	fc 01       	movw	r30, r24
    6bf8:	31 96       	adiw	r30, 0x01	; 1
    6bfa:	85 91       	lpm	r24, Z+
    6bfc:	94 91       	lpm	r25, Z
    6bfe:	fe 01       	movw	r30, r28
    6c00:	e9 5f       	subi	r30, 0xF9	; 249
    6c02:	f9 4f       	sbci	r31, 0xF9	; 249
    6c04:	20 81       	ld	r18, Z
    6c06:	f7 e0       	ldi	r31, 0x07	; 7
    6c08:	2f 9f       	mul	r18, r31
    6c0a:	80 0d       	add	r24, r0
    6c0c:	91 1d       	adc	r25, r1
    6c0e:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6c10:	f8 01       	movw	r30, r16
    6c12:	24 91       	lpm	r18, Z
    6c14:	fc 01       	movw	r30, r24
    6c16:	44 91       	lpm	r20, Z
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6c18:	bc 2f       	mov	r27, r28
    6c1a:	aa 27       	eor	r26, r26
    6c1c:	fd 01       	movw	r30, r26
    6c1e:	eb 5c       	subi	r30, 0xCB	; 203
    6c20:	f2 4f       	sbci	r31, 0xF2	; 242
    6c22:	30 81       	ld	r19, Z
    6c24:	32 13       	cpse	r19, r18
    6c26:	b1 c1       	rjmp	.+866    	; 0x6f8a <MB_M_Timer_ISR+0x470>
    6c28:	c1 80       	ldd	r12, Z+1	; 0x01
    6c2a:	c4 12       	cpse	r12, r20
    6c2c:	ae c1       	rjmp	.+860    	; 0x6f8a <MB_M_Timer_ISR+0x470>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err = 0;
			switch (Func) {
    6c2e:	50 e0       	ldi	r21, 0x00	; 0
    6c30:	fa 01       	movw	r30, r20
    6c32:	31 97       	sbiw	r30, 0x01	; 1
    6c34:	e0 31       	cpi	r30, 0x10	; 16
    6c36:	f1 05       	cpc	r31, r1
    6c38:	08 f0       	brcs	.+2      	; 0x6c3c <MB_M_Timer_ISR+0x122>
    6c3a:	ab c1       	rjmp	.+854    	; 0x6f92 <MB_M_Timer_ISR+0x478>
    6c3c:	ea 5a       	subi	r30, 0xAA	; 170
    6c3e:	ff 4f       	sbci	r31, 0xFF	; 255
    6c40:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6c44:	20 91 5c 02 	lds	r18, 0x025C
    6c48:	22 23       	and	r18, r18
    6c4a:	51 f0       	breq	.+20     	; 0x6c60 <MB_M_Timer_ISR+0x146>
    6c4c:	fe 01       	movw	r30, r28
    6c4e:	43 e0       	ldi	r20, 0x03	; 3
    6c50:	ee 0f       	add	r30, r30
    6c52:	ff 1f       	adc	r31, r31
    6c54:	4a 95       	dec	r20
    6c56:	e1 f7       	brne	.-8      	; 0x6c50 <MB_M_Timer_ISR+0x136>
    6c58:	e3 5a       	subi	r30, 0xA3	; 163
    6c5a:	fd 4f       	sbci	r31, 0xFD	; 253
    6c5c:	64 81       	ldd	r22, Z+4	; 0x04
    6c5e:	03 c0       	rjmp	.+6      	; 0x6c66 <MB_M_Timer_ISR+0x14c>
    6c60:	fc 01       	movw	r30, r24
    6c62:	33 96       	adiw	r30, 0x03	; 3
    6c64:	64 91       	lpm	r22, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6c66:	fd 01       	movw	r30, r26
    6c68:	eb 5c       	subi	r30, 0xCB	; 203
    6c6a:	f2 4f       	sbci	r31, 0xF2	; 242
    6c6c:	22 81       	ldd	r18, Z+2	; 0x02
    6c6e:	30 e0       	ldi	r19, 0x00	; 0
    6c70:	fe 01       	movw	r30, r28
    6c72:	e9 53       	subi	r30, 0x39	; 57
    6c74:	f7 4f       	sbci	r31, 0xF7	; 247
    6c76:	e0 81       	ld	r30, Z
    6c78:	f0 e0       	ldi	r31, 0x00	; 0
    6c7a:	a9 01       	movw	r20, r18
    6c7c:	4b 5f       	subi	r20, 0xFB	; 251
    6c7e:	5f 4f       	sbci	r21, 0xFF	; 255
    6c80:	e4 17       	cp	r30, r20
    6c82:	f5 07       	cpc	r31, r21
    6c84:	09 f0       	breq	.+2      	; 0x6c88 <MB_M_Timer_ISR+0x16e>
    6c86:	74 c1       	rjmp	.+744    	; 0x6f70 <MB_M_Timer_ISR+0x456>
    6c88:	e6 2f       	mov	r30, r22
    6c8a:	e6 95       	lsr	r30
    6c8c:	e6 95       	lsr	r30
    6c8e:	e6 95       	lsr	r30
    6c90:	f0 e0       	ldi	r31, 0x00	; 0
    6c92:	41 e0       	ldi	r20, 0x01	; 1
    6c94:	50 e0       	ldi	r21, 0x00	; 0
    6c96:	76 2f       	mov	r23, r22
    6c98:	77 70       	andi	r23, 0x07	; 7
    6c9a:	11 f4       	brne	.+4      	; 0x6ca0 <MB_M_Timer_ISR+0x186>
    6c9c:	40 e0       	ldi	r20, 0x00	; 0
    6c9e:	50 e0       	ldi	r21, 0x00	; 0
    6ca0:	4e 0f       	add	r20, r30
    6ca2:	5f 1f       	adc	r21, r31
    6ca4:	42 17       	cp	r20, r18
    6ca6:	53 07       	cpc	r21, r19
    6ca8:	09 f0       	breq	.+2      	; 0x6cac <MB_M_Timer_ISR+0x192>
    6caa:	62 c1       	rjmp	.+708    	; 0x6f70 <MB_M_Timer_ISR+0x456>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6cac:	20 91 5c 02 	lds	r18, 0x025C
		Discr = MB_SingleQuery[MB_N].Buf;
    6cb0:	fe 01       	movw	r30, r28
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6cb2:	22 23       	and	r18, r18
    6cb4:	59 f0       	breq	.+22     	; 0x6ccc <MB_M_Timer_ISR+0x1b2>
		Discr = MB_SingleQuery[MB_N].Buf;
    6cb6:	33 e0       	ldi	r19, 0x03	; 3
    6cb8:	ee 0f       	add	r30, r30
    6cba:	ff 1f       	adc	r31, r31
    6cbc:	3a 95       	dec	r19
    6cbe:	e1 f7       	brne	.-8      	; 0x6cb8 <MB_M_Timer_ISR+0x19e>
    6cc0:	e3 5a       	subi	r30, 0xA3	; 163
    6cc2:	fd 4f       	sbci	r31, 0xFD	; 253
    6cc4:	46 81       	ldd	r20, Z+6	; 0x06
    6cc6:	57 81       	ldd	r21, Z+7	; 0x07
		Pin = 0;
    6cc8:	c1 2c       	mov	r12, r1
    6cca:	14 c0       	rjmp	.+40     	; 0x6cf4 <MB_M_Timer_ISR+0x1da>
    6ccc:	24 e0       	ldi	r18, 0x04	; 4
    6cce:	ee 0f       	add	r30, r30
    6cd0:	ff 1f       	adc	r31, r31
    6cd2:	2a 95       	dec	r18
    6cd4:	e1 f7       	brne	.-8      	; 0x6cce <MB_M_Timer_ISR+0x1b4>
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6cd6:	21 e0       	ldi	r18, 0x01	; 1
    6cd8:	c2 12       	cpse	r12, r18
    6cda:	03 c0       	rjmp	.+6      	; 0x6ce2 <MB_M_Timer_ISR+0x1c8>
    6cdc:	e8 53       	subi	r30, 0x38	; 56
    6cde:	f0 4b       	sbci	r31, 0xB0	; 176
    6ce0:	02 c0       	rjmp	.+4      	; 0x6ce6 <MB_M_Timer_ISR+0x1cc>
    6ce2:	e4 53       	subi	r30, 0x34	; 52
    6ce4:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ce6:	45 91       	lpm	r20, Z+
    6ce8:	54 91       	lpm	r21, Z
		Pin = prw(&Query->AllocAddr);
    6cea:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6cec:	fc 01       	movw	r30, r24
    6cee:	85 91       	lpm	r24, Z+
    6cf0:	94 91       	lpm	r25, Z
    6cf2:	c8 2e       	mov	r12, r24
	}
	for (uint16_t i=0; i<Qt; i++) {
    6cf4:	20 e0       	ldi	r18, 0x00	; 0
    6cf6:	30 e0       	ldi	r19, 0x00	; 0
    6cf8:	86 2e       	mov	r8, r22
    6cfa:	91 2c       	mov	r9, r1
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6cfc:	aa 24       	eor	r10, r10
    6cfe:	a3 94       	inc	r10
    6d00:	b1 2c       	mov	r11, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d02:	ab 5c       	subi	r26, 0xCB	; 203
    6d04:	b2 4f       	sbci	r27, 0xF2	; 242
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d06:	28 15       	cp	r18, r8
    6d08:	39 05       	cpc	r19, r9
    6d0a:	08 f0       	brcs	.+2      	; 0x6d0e <MB_M_Timer_ISR+0x1f4>
    6d0c:	42 c1       	rjmp	.+644    	; 0x6f92 <MB_M_Timer_ISR+0x478>
    6d0e:	ec 2d       	mov	r30, r12
    6d10:	e2 0f       	add	r30, r18
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d12:	7e 2e       	mov	r7, r30
    6d14:	76 94       	lsr	r7
    6d16:	76 94       	lsr	r7
    6d18:	76 94       	lsr	r7
    6d1a:	e7 70       	andi	r30, 0x07	; 7
    6d1c:	25 01       	movw	r4, r10
    6d1e:	01 c0       	rjmp	.+2      	; 0x6d22 <MB_M_Timer_ISR+0x208>
    6d20:	44 0c       	add	r4, r4
    6d22:	ea 95       	dec	r30
    6d24:	ea f7       	brpl	.-6      	; 0x6d20 <MB_M_Timer_ISR+0x206>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d26:	c9 01       	movw	r24, r18
    6d28:	63 e0       	ldi	r22, 0x03	; 3
    6d2a:	96 95       	lsr	r25
    6d2c:	87 95       	ror	r24
    6d2e:	6a 95       	dec	r22
    6d30:	e1 f7       	brne	.-8      	; 0x6d2a <MB_M_Timer_ISR+0x210>
    6d32:	8a 0f       	add	r24, r26
    6d34:	9b 1f       	adc	r25, r27
    6d36:	fc 01       	movw	r30, r24
    6d38:	63 81       	ldd	r22, Z+3	; 0x03
    6d3a:	70 e0       	ldi	r23, 0x00	; 0
    6d3c:	c9 01       	movw	r24, r18
    6d3e:	87 70       	andi	r24, 0x07	; 7
    6d40:	99 27       	eor	r25, r25
    6d42:	02 c0       	rjmp	.+4      	; 0x6d48 <MB_M_Timer_ISR+0x22e>
    6d44:	75 95       	asr	r23
    6d46:	67 95       	ror	r22
    6d48:	8a 95       	dec	r24
    6d4a:	e2 f7       	brpl	.-8      	; 0x6d44 <MB_M_Timer_ISR+0x22a>
    6d4c:	87 2d       	mov	r24, r7
    6d4e:	90 e0       	ldi	r25, 0x00	; 0
			Discr[Byte] |=Bit;
    6d50:	84 0f       	add	r24, r20
    6d52:	95 1f       	adc	r25, r21
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d54:	60 ff       	sbrs	r22, 0
    6d56:	04 c0       	rjmp	.+8      	; 0x6d60 <MB_M_Timer_ISR+0x246>
			Discr[Byte] |=Bit;
    6d58:	fc 01       	movw	r30, r24
    6d5a:	60 81       	ld	r22, Z
    6d5c:	64 29       	or	r22, r4
    6d5e:	04 c0       	rjmp	.+8      	; 0x6d68 <MB_M_Timer_ISR+0x24e>
		else
			Discr[Byte] &=~Bit;
    6d60:	40 94       	com	r4
    6d62:	fc 01       	movw	r30, r24
    6d64:	60 81       	ld	r22, Z
    6d66:	64 21       	and	r22, r4
    6d68:	60 83       	st	Z, r22
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d6a:	2f 5f       	subi	r18, 0xFF	; 255
    6d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    6d6e:	cb cf       	rjmp	.-106    	; 0x6d06 <MB_M_Timer_ISR+0x1ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6d70:	ab 5c       	subi	r26, 0xCB	; 203
    6d72:	b2 4f       	sbci	r27, 0xF2	; 242
    6d74:	12 96       	adiw	r26, 0x02	; 2
    6d76:	4c 91       	ld	r20, X
    6d78:	fe 01       	movw	r30, r28
    6d7a:	e9 53       	subi	r30, 0x39	; 57
    6d7c:	f7 4f       	sbci	r31, 0xF7	; 247
    6d7e:	e0 81       	ld	r30, Z
    6d80:	f0 e0       	ldi	r31, 0x00	; 0
    6d82:	64 2f       	mov	r22, r20
    6d84:	70 e0       	ldi	r23, 0x00	; 0
    6d86:	9b 01       	movw	r18, r22
    6d88:	2b 5f       	subi	r18, 0xFB	; 251
    6d8a:	3f 4f       	sbci	r19, 0xFF	; 255
    6d8c:	e2 17       	cp	r30, r18
    6d8e:	f3 07       	cpc	r31, r19
    6d90:	09 f0       	breq	.+2      	; 0x6d94 <MB_M_Timer_ISR+0x27a>
    6d92:	ee c0       	rjmp	.+476    	; 0x6f70 <MB_M_Timer_ISR+0x456>
    6d94:	20 91 5c 02 	lds	r18, 0x025C
    6d98:	22 23       	and	r18, r18
    6d9a:	59 f0       	breq	.+22     	; 0x6db2 <MB_M_Timer_ISR+0x298>
    6d9c:	fe 01       	movw	r30, r28
    6d9e:	a3 e0       	ldi	r26, 0x03	; 3
    6da0:	ee 0f       	add	r30, r30
    6da2:	ff 1f       	adc	r31, r31
    6da4:	aa 95       	dec	r26
    6da6:	e1 f7       	brne	.-8      	; 0x6da0 <MB_M_Timer_ISR+0x286>
    6da8:	e3 5a       	subi	r30, 0xA3	; 163
    6daa:	fd 4f       	sbci	r31, 0xFD	; 253
    6dac:	24 81       	ldd	r18, Z+4	; 0x04
    6dae:	35 81       	ldd	r19, Z+5	; 0x05
    6db0:	04 c0       	rjmp	.+8      	; 0x6dba <MB_M_Timer_ISR+0x2a0>
    6db2:	fc 01       	movw	r30, r24
    6db4:	33 96       	adiw	r30, 0x03	; 3
    6db6:	25 91       	lpm	r18, Z+
    6db8:	34 91       	lpm	r19, Z
    6dba:	22 0f       	add	r18, r18
    6dbc:	33 1f       	adc	r19, r19
    6dbe:	26 17       	cp	r18, r22
    6dc0:	37 07       	cpc	r19, r23
    6dc2:	09 f0       	breq	.+2      	; 0x6dc6 <MB_M_Timer_ISR+0x2ac>
    6dc4:	d5 c0       	rjmp	.+426    	; 0x6f70 <MB_M_Timer_ISR+0x456>
		return 1;
	uint16_t *Reg = LastProcSingle ?
    6dc6:	20 91 5c 02 	lds	r18, 0x025C
		MB_SingleQuery[MB_N].Buf
	:
    6dca:	fe 01       	movw	r30, r28
    6dcc:	22 23       	and	r18, r18
    6dce:	51 f0       	breq	.+20     	; 0x6de4 <MB_M_Timer_ISR+0x2ca>
    6dd0:	33 e0       	ldi	r19, 0x03	; 3
    6dd2:	ee 0f       	add	r30, r30
    6dd4:	ff 1f       	adc	r31, r31
    6dd6:	3a 95       	dec	r19
    6dd8:	e1 f7       	brne	.-8      	; 0x6dd2 <MB_M_Timer_ISR+0x2b8>
    6dda:	e3 5a       	subi	r30, 0xA3	; 163
    6ddc:	fd 4f       	sbci	r31, 0xFD	; 253
    6dde:	a6 80       	ldd	r10, Z+6	; 0x06
    6de0:	b7 80       	ldd	r11, Z+7	; 0x07
    6de2:	17 c0       	rjmp	.+46     	; 0x6e12 <MB_M_Timer_ISR+0x2f8>
    6de4:	24 e0       	ldi	r18, 0x04	; 4
    6de6:	ee 0f       	add	r30, r30
    6de8:	ff 1f       	adc	r31, r31
    6dea:	2a 95       	dec	r18
    6dec:	e1 f7       	brne	.-8      	; 0x6de6 <MB_M_Timer_ISR+0x2cc>
    6dee:	23 e0       	ldi	r18, 0x03	; 3
    6df0:	c2 12       	cpse	r12, r18
    6df2:	03 c0       	rjmp	.+6      	; 0x6dfa <MB_M_Timer_ISR+0x2e0>
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6df4:	e0 53       	subi	r30, 0x30	; 48
    6df6:	f0 4b       	sbci	r31, 0xB0	; 176
    6df8:	02 c0       	rjmp	.+4      	; 0x6dfe <MB_M_Timer_ISR+0x2e4>
    6dfa:	ec 52       	subi	r30, 0x2C	; 44
    6dfc:	f0 4b       	sbci	r31, 0xB0	; 176
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6dfe:	25 91       	lpm	r18, Z+
    6e00:	34 91       	lpm	r19, Z
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e02:	05 96       	adiw	r24, 0x05	; 5
    6e04:	fc 01       	movw	r30, r24
    6e06:	a5 90       	lpm	r10, Z+
    6e08:	b4 90       	lpm	r11, Z
    6e0a:	aa 0c       	add	r10, r10
    6e0c:	bb 1c       	adc	r11, r11
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e0e:	a2 0e       	add	r10, r18
    6e10:	b3 1e       	adc	r11, r19
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6e12:	46 95       	lsr	r20
    6e14:	cc 24       	eor	r12, r12
    6e16:	ca 94       	dec	r12
    6e18:	c4 0e       	add	r12, r20
    6e1a:	74 2e       	mov	r7, r20
    6e1c:	77 0c       	add	r7, r7
    6e1e:	7a 94       	dec	r7
    6e20:	7a 94       	dec	r7
    6e22:	ff ef       	ldi	r31, 0xFF	; 255
    6e24:	cf 16       	cp	r12, r31
    6e26:	09 f4       	brne	.+2      	; 0x6e2a <MB_M_Timer_ISR+0x310>
    6e28:	b4 c0       	rjmp	.+360    	; 0x6f92 <MB_M_Timer_ISR+0x478>
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6e2a:	8c 2c       	mov	r8, r12
    6e2c:	88 0c       	add	r8, r8
    6e2e:	99 08       	sbc	r9, r9
    6e30:	8a 0c       	add	r8, r10
    6e32:	9b 1c       	adc	r9, r11
    6e34:	63 e0       	ldi	r22, 0x03	; 3
    6e36:	67 0d       	add	r22, r7
    6e38:	8d 2d       	mov	r24, r13
    6e3a:	0e 94 11 32 	call	0x6422	; 0x6422 <MB_FrameReg>
    6e3e:	f4 01       	movw	r30, r8
    6e40:	91 83       	std	Z+1, r25	; 0x01
    6e42:	80 83       	st	Z, r24
    6e44:	ca 94       	dec	r12
    6e46:	eb cf       	rjmp	.-42     	; 0x6e1e <MB_M_Timer_ISR+0x304>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6e48:	20 91 5c 02 	lds	r18, 0x025C
    6e4c:	22 23       	and	r18, r18
    6e4e:	69 f0       	breq	.+26     	; 0x6e6a <MB_M_Timer_ISR+0x350>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6e50:	fe 01       	movw	r30, r28
    6e52:	83 e0       	ldi	r24, 0x03	; 3
    6e54:	ee 0f       	add	r30, r30
    6e56:	ff 1f       	adc	r31, r31
    6e58:	8a 95       	dec	r24
    6e5a:	e1 f7       	brne	.-8      	; 0x6e54 <MB_M_Timer_ISR+0x33a>
    6e5c:	e3 5a       	subi	r30, 0xA3	; 163
    6e5e:	fd 4f       	sbci	r31, 0xFD	; 253
    6e60:	22 81       	ldd	r18, Z+2	; 0x02
    6e62:	33 81       	ldd	r19, Z+3	; 0x03
		Reg = MB_SingleQuery[MB_N].Buf;
    6e64:	66 81       	ldd	r22, Z+6	; 0x06
    6e66:	77 81       	ldd	r23, Z+7	; 0x07
    6e68:	17 c0       	rjmp	.+46     	; 0x6e98 <MB_M_Timer_ISR+0x37e>
	}
	else {
		StartAddr = prw(&Query->StartAddr);
    6e6a:	fc 01       	movw	r30, r24
    6e6c:	31 96       	adiw	r30, 0x01	; 1
    6e6e:	25 91       	lpm	r18, Z+
    6e70:	34 91       	lpm	r19, Z
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6e72:	fe 01       	movw	r30, r28
    6e74:	54 e0       	ldi	r21, 0x04	; 4
    6e76:	ee 0f       	add	r30, r30
    6e78:	ff 1f       	adc	r31, r31
    6e7a:	5a 95       	dec	r21
    6e7c:	e1 f7       	brne	.-8      	; 0x6e76 <MB_M_Timer_ISR+0x35c>
    6e7e:	e0 53       	subi	r30, 0x30	; 48
    6e80:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6e82:	45 91       	lpm	r20, Z+
    6e84:	54 91       	lpm	r21, Z
    6e86:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6e88:	fc 01       	movw	r30, r24
    6e8a:	85 91       	lpm	r24, Z+
    6e8c:	94 91       	lpm	r25, Z
    6e8e:	bc 01       	movw	r22, r24
    6e90:	66 0f       	add	r22, r22
    6e92:	77 1f       	adc	r23, r23
    6e94:	64 0f       	add	r22, r20
    6e96:	75 1f       	adc	r23, r21
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6e98:	ce 01       	movw	r24, r28
    6e9a:	89 53       	subi	r24, 0x39	; 57
    6e9c:	97 4f       	sbci	r25, 0xF7	; 247
    6e9e:	fc 01       	movw	r30, r24
    6ea0:	80 81       	ld	r24, Z
    6ea2:	88 30       	cpi	r24, 0x08	; 8
    6ea4:	09 f0       	breq	.+2      	; 0x6ea8 <MB_M_Timer_ISR+0x38e>
    6ea6:	61 c0       	rjmp	.+194    	; 0x6f6a <MB_M_Timer_ISR+0x450>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6ea8:	ab 5c       	subi	r26, 0xCB	; 203
    6eaa:	b2 4f       	sbci	r27, 0xF2	; 242
    6eac:	12 96       	adiw	r26, 0x02	; 2
    6eae:	8c 91       	ld	r24, X
    6eb0:	12 97       	sbiw	r26, 0x02	; 2
    6eb2:	90 e0       	ldi	r25, 0x00	; 0
    6eb4:	98 2f       	mov	r25, r24
    6eb6:	88 27       	eor	r24, r24
    6eb8:	13 96       	adiw	r26, 0x03	; 3
    6eba:	4c 91       	ld	r20, X
    6ebc:	13 97       	sbiw	r26, 0x03	; 3
    6ebe:	84 2b       	or	r24, r20
    6ec0:	82 17       	cp	r24, r18
    6ec2:	93 07       	cpc	r25, r19
    6ec4:	09 f0       	breq	.+2      	; 0x6ec8 <MB_M_Timer_ISR+0x3ae>
    6ec6:	51 c0       	rjmp	.+162    	; 0x6f6a <MB_M_Timer_ISR+0x450>
    6ec8:	14 96       	adiw	r26, 0x04	; 4
    6eca:	8c 91       	ld	r24, X
    6ecc:	14 97       	sbiw	r26, 0x04	; 4
    6ece:	90 e0       	ldi	r25, 0x00	; 0
    6ed0:	98 2f       	mov	r25, r24
    6ed2:	88 27       	eor	r24, r24
    6ed4:	15 96       	adiw	r26, 0x05	; 5
    6ed6:	2c 91       	ld	r18, X
    6ed8:	82 2b       	or	r24, r18
    6eda:	41 e0       	ldi	r20, 0x01	; 1
    6edc:	fb 01       	movw	r30, r22
    6ede:	20 81       	ld	r18, Z
    6ee0:	31 81       	ldd	r19, Z+1	; 0x01
    6ee2:	82 17       	cp	r24, r18
    6ee4:	93 07       	cpc	r25, r19
    6ee6:	09 f4       	brne	.+2      	; 0x6eea <MB_M_Timer_ISR+0x3d0>
    6ee8:	40 e0       	ldi	r20, 0x00	; 0
    6eea:	84 2f       	mov	r24, r20
    6eec:	3f c0       	rjmp	.+126    	; 0x6f6c <MB_M_Timer_ISR+0x452>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6eee:	20 91 5c 02 	lds	r18, 0x025C
    6ef2:	22 23       	and	r18, r18
    6ef4:	69 f0       	breq	.+26     	; 0x6f10 <MB_M_Timer_ISR+0x3f6>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6ef6:	fe 01       	movw	r30, r28
    6ef8:	83 e0       	ldi	r24, 0x03	; 3
    6efa:	ee 0f       	add	r30, r30
    6efc:	ff 1f       	adc	r31, r31
    6efe:	8a 95       	dec	r24
    6f00:	e1 f7       	brne	.-8      	; 0x6efa <MB_M_Timer_ISR+0x3e0>
    6f02:	e3 5a       	subi	r30, 0xA3	; 163
    6f04:	fd 4f       	sbci	r31, 0xFD	; 253
    6f06:	22 81       	ldd	r18, Z+2	; 0x02
    6f08:	33 81       	ldd	r19, Z+3	; 0x03
		Qt				= MB_SingleQuery[MB_N].Qt;
    6f0a:	44 81       	ldd	r20, Z+4	; 0x04
    6f0c:	55 81       	ldd	r21, Z+5	; 0x05
    6f0e:	08 c0       	rjmp	.+16     	; 0x6f20 <MB_M_Timer_ISR+0x406>
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
    6f10:	fc 01       	movw	r30, r24
    6f12:	31 96       	adiw	r30, 0x01	; 1
    6f14:	25 91       	lpm	r18, Z+
    6f16:	34 91       	lpm	r19, Z
		Qt				= prw(&Query->Qt);
    6f18:	03 96       	adiw	r24, 0x03	; 3
    6f1a:	fc 01       	movw	r30, r24
    6f1c:	45 91       	lpm	r20, Z+
    6f1e:	54 91       	lpm	r21, Z
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6f20:	fe 01       	movw	r30, r28
    6f22:	e9 53       	subi	r30, 0x39	; 57
    6f24:	f7 4f       	sbci	r31, 0xF7	; 247
    6f26:	80 81       	ld	r24, Z
    6f28:	88 30       	cpi	r24, 0x08	; 8
    6f2a:	f9 f4       	brne	.+62     	; 0x6f6a <MB_M_Timer_ISR+0x450>
    6f2c:	ab 5c       	subi	r26, 0xCB	; 203
    6f2e:	b2 4f       	sbci	r27, 0xF2	; 242
    6f30:	12 96       	adiw	r26, 0x02	; 2
    6f32:	8c 91       	ld	r24, X
    6f34:	12 97       	sbiw	r26, 0x02	; 2
    6f36:	90 e0       	ldi	r25, 0x00	; 0
    6f38:	98 2f       	mov	r25, r24
    6f3a:	88 27       	eor	r24, r24
    6f3c:	13 96       	adiw	r26, 0x03	; 3
    6f3e:	6c 91       	ld	r22, X
    6f40:	13 97       	sbiw	r26, 0x03	; 3
    6f42:	86 2b       	or	r24, r22
    6f44:	82 17       	cp	r24, r18
    6f46:	93 07       	cpc	r25, r19
    6f48:	81 f4       	brne	.+32     	; 0x6f6a <MB_M_Timer_ISR+0x450>
    6f4a:	14 96       	adiw	r26, 0x04	; 4
    6f4c:	8c 91       	ld	r24, X
    6f4e:	14 97       	sbiw	r26, 0x04	; 4
    6f50:	90 e0       	ldi	r25, 0x00	; 0
    6f52:	98 2f       	mov	r25, r24
    6f54:	88 27       	eor	r24, r24
    6f56:	15 96       	adiw	r26, 0x05	; 5
    6f58:	2c 91       	ld	r18, X
    6f5a:	82 2b       	or	r24, r18
    6f5c:	21 e0       	ldi	r18, 0x01	; 1
    6f5e:	84 17       	cp	r24, r20
    6f60:	95 07       	cpc	r25, r21
    6f62:	09 f4       	brne	.+2      	; 0x6f66 <MB_M_Timer_ISR+0x44c>
    6f64:	20 e0       	ldi	r18, 0x00	; 0
    6f66:	82 2f       	mov	r24, r18
    6f68:	01 c0       	rjmp	.+2      	; 0x6f6c <MB_M_Timer_ISR+0x452>
    6f6a:	81 e0       	ldi	r24, 0x01	; 1
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    6f6c:	88 23       	and	r24, r24
    6f6e:	89 f0       	breq	.+34     	; 0x6f92 <MB_M_Timer_ISR+0x478>
				MB_CPT[MB_N][2]++;
    6f70:	fe 01       	movw	r30, r28
    6f72:	54 e0       	ldi	r21, 0x04	; 4
    6f74:	ee 0f       	add	r30, r30
    6f76:	ff 1f       	adc	r31, r31
    6f78:	5a 95       	dec	r21
    6f7a:	e1 f7       	brne	.-8      	; 0x6f74 <MB_M_Timer_ISR+0x45a>
    6f7c:	ea 5e       	subi	r30, 0xEA	; 234
    6f7e:	f4 4f       	sbci	r31, 0xF4	; 244
    6f80:	84 81       	ldd	r24, Z+4	; 0x04
    6f82:	95 81       	ldd	r25, Z+5	; 0x05
    6f84:	01 96       	adiw	r24, 0x01	; 1
    6f86:	95 83       	std	Z+5, r25	; 0x05
    6f88:	84 83       	std	Z+4, r24	; 0x04
				Over = FailSlave(MB_N);
    6f8a:	8d 2d       	mov	r24, r13
    6f8c:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <FailSlave>
    6f90:	45 c0       	rjmp	.+138    	; 0x701c <MB_M_Timer_ISR+0x502>
			}
			else if (LastProcSingle)
    6f92:	80 91 5c 02 	lds	r24, 0x025C
    6f96:	88 23       	and	r24, r24
    6f98:	19 f0       	breq	.+6      	; 0x6fa0 <MB_M_Timer_ISR+0x486>
				MB_SingleState[MB_N] = MB_SingleIdle;
    6f9a:	f7 01       	movw	r30, r14
    6f9c:	10 82       	st	Z, r1
    6f9e:	47 c0       	rjmp	.+142    	; 0x702e <MB_M_Timer_ISR+0x514>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    6fa0:	7e 01       	movw	r14, r28
    6fa2:	ee 0c       	add	r14, r14
    6fa4:	ff 1c       	adc	r15, r15
    6fa6:	ee 0c       	add	r14, r14
    6fa8:	ff 1c       	adc	r15, r15
    6faa:	97 01       	movw	r18, r14
    6fac:	2f 5f       	subi	r18, 0xFF	; 255
    6fae:	34 4f       	sbci	r19, 0xF4	; 244
    6fb0:	79 01       	movw	r14, r18
    6fb2:	81 e0       	ldi	r24, 0x01	; 1
    6fb4:	90 e0       	ldi	r25, 0x00	; 0
    6fb6:	a0 e0       	ldi	r26, 0x00	; 0
    6fb8:	b0 e0       	ldi	r27, 0x00	; 0
    6fba:	9e 01       	movw	r18, r28
    6fbc:	20 50       	subi	r18, 0x00	; 0
    6fbe:	3a 4f       	sbci	r19, 0xFA	; 250
    6fc0:	f9 01       	movw	r30, r18
    6fc2:	00 80       	ld	r0, Z
    6fc4:	04 c0       	rjmp	.+8      	; 0x6fce <MB_M_Timer_ISR+0x4b4>
    6fc6:	88 0f       	add	r24, r24
    6fc8:	99 1f       	adc	r25, r25
    6fca:	aa 1f       	adc	r26, r26
    6fcc:	bb 1f       	adc	r27, r27
    6fce:	0a 94       	dec	r0
    6fd0:	d2 f7       	brpl	.-12     	; 0x6fc6 <MB_M_Timer_ISR+0x4ac>
    6fd2:	80 95       	com	r24
    6fd4:	90 95       	com	r25
    6fd6:	a0 95       	com	r26
    6fd8:	b0 95       	com	r27
    6fda:	f7 01       	movw	r30, r14
    6fdc:	40 81       	ld	r20, Z
    6fde:	51 81       	ldd	r21, Z+1	; 0x01
    6fe0:	62 81       	ldd	r22, Z+2	; 0x02
    6fe2:	73 81       	ldd	r23, Z+3	; 0x03
    6fe4:	84 23       	and	r24, r20
    6fe6:	95 23       	and	r25, r21
    6fe8:	a6 23       	and	r26, r22
    6fea:	b7 23       	and	r27, r23
    6fec:	80 83       	st	Z, r24
    6fee:	91 83       	std	Z+1, r25	; 0x01
    6ff0:	a2 83       	std	Z+2, r26	; 0x02
    6ff2:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    6ff4:	fe 01       	movw	r30, r28
    6ff6:	e9 5f       	subi	r30, 0xF9	; 249
    6ff8:	f9 4f       	sbci	r31, 0xF9	; 249
    6ffa:	80 81       	ld	r24, Z
    6ffc:	8f 5f       	subi	r24, 0xFF	; 255
    6ffe:	80 83       	st	Z, r24
    7000:	f8 01       	movw	r30, r16
    7002:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7004:	04 91       	lpm	r16, Z
    7006:	80 13       	cpse	r24, r16
    7008:	04 c0       	rjmp	.+8      	; 0x7012 <MB_M_Timer_ISR+0x4f8>
					Over = NextSlave(MB_N);
    700a:	8d 2d       	mov	r24, r13
    700c:	0e 94 e0 2a 	call	0x55c0	; 0x55c0 <NextSlave>
    7010:	01 c0       	rjmp	.+2      	; 0x7014 <MB_M_Timer_ISR+0x4fa>

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
    7012:	80 e0       	ldi	r24, 0x00	; 0
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    7014:	fe 01       	movw	r30, r28
    7016:	e5 5a       	subi	r30, 0xA5	; 165
    7018:	fd 4f       	sbci	r31, 0xFD	; 253
    701a:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    701c:	88 23       	and	r24, r24
    701e:	39 f0       	breq	.+14     	; 0x702e <MB_M_Timer_ISR+0x514>
    7020:	cc 0f       	add	r28, r28
    7022:	dd 1f       	adc	r29, r29
    7024:	c6 5e       	subi	r28, 0xE6	; 230
    7026:	d9 4f       	sbci	r29, 0xF9	; 249
    7028:	68 81       	ld	r22, Y
    702a:	79 81       	ldd	r23, Y+1	; 0x01
    702c:	02 c0       	rjmp	.+4      	; 0x7032 <MB_M_Timer_ISR+0x518>
    702e:	65 e0       	ldi	r22, 0x05	; 5
    7030:	70 e0       	ldi	r23, 0x00	; 0
    7032:	80 91 56 02 	lds	r24, 0x0256
    7036:	8d 0d       	add	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    7038:	df 91       	pop	r29
    703a:	cf 91       	pop	r28
    703c:	1f 91       	pop	r17
    703e:	0f 91       	pop	r16
    7040:	ff 90       	pop	r15
    7042:	ef 90       	pop	r14
    7044:	df 90       	pop	r13
    7046:	cf 90       	pop	r12
    7048:	bf 90       	pop	r11
    704a:	af 90       	pop	r10
    704c:	9f 90       	pop	r9
    704e:	8f 90       	pop	r8
    7050:	7f 90       	pop	r7
    7052:	5f 90       	pop	r5
    7054:	4f 90       	pop	r4
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    7056:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    705a:	df 91       	pop	r29
    705c:	cf 91       	pop	r28
    705e:	1f 91       	pop	r17
    7060:	0f 91       	pop	r16
    7062:	ff 90       	pop	r15
    7064:	ef 90       	pop	r14
    7066:	df 90       	pop	r13
    7068:	cf 90       	pop	r12
    706a:	bf 90       	pop	r11
    706c:	af 90       	pop	r10
    706e:	9f 90       	pop	r9
    7070:	8f 90       	pop	r8
    7072:	7f 90       	pop	r7
    7074:	5f 90       	pop	r5
    7076:	4f 90       	pop	r4
    7078:	08 95       	ret

0000707a <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    707a:	e8 2f       	mov	r30, r24
    707c:	f0 e0       	ldi	r31, 0x00	; 0
    707e:	e1 50       	subi	r30, 0x01	; 1
    7080:	f5 4f       	sbci	r31, 0xF5	; 245
    7082:	60 81       	ld	r22, Z
    7084:	70 e0       	ldi	r23, 0x00	; 0
    7086:	90 91 56 02 	lds	r25, 0x0256
    708a:	89 0f       	add	r24, r25
    708c:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>

00007090 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    7090:	bf 92       	push	r11
    7092:	cf 92       	push	r12
    7094:	df 92       	push	r13
    7096:	ef 92       	push	r14
    7098:	ff 92       	push	r15
    709a:	0f 93       	push	r16
    709c:	1f 93       	push	r17
    709e:	cf 93       	push	r28
    70a0:	df 93       	push	r29
    70a2:	1f 92       	push	r1
    70a4:	cd b7       	in	r28, 0x3d	; 61
    70a6:	de b7       	in	r29, 0x3e	; 62
    70a8:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    70aa:	80 e0       	ldi	r24, 0x00	; 0
    70ac:	94 e1       	ldi	r25, 0x14	; 20
    70ae:	c8 2e       	mov	r12, r24
    70b0:	d1 2c       	mov	r13, r1
    70b2:	9c 9d       	mul	r25, r12
    70b4:	f0 01       	movw	r30, r0
    70b6:	9d 9d       	mul	r25, r13
    70b8:	f0 0d       	add	r31, r0
    70ba:	11 24       	eor	r1, r1
    70bc:	e7 56       	subi	r30, 0x67	; 103
    70be:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    70c0:	25 91       	lpm	r18, Z+
    70c2:	34 91       	lpm	r19, Z
    70c4:	e8 2e       	mov	r14, r24
    70c6:	f1 2c       	mov	r15, r1
    70c8:	a2 17       	cp	r26, r18
    70ca:	b3 07       	cpc	r27, r19
    70cc:	11 f0       	breq	.+4      	; 0x70d2 <Modbus_TX+0x42>
    70ce:	8f 5f       	subi	r24, 0xFF	; 255
    70d0:	ee cf       	rjmp	.-36     	; 0x70ae <Modbus_TX+0x1e>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    70d2:	86 01       	movw	r16, r12
    70d4:	02 5c       	subi	r16, 0xC2	; 194
    70d6:	1d 4f       	sbci	r17, 0xFD	; 253
    70d8:	f8 01       	movw	r30, r16
    70da:	90 81       	ld	r25, Z
    70dc:	69 2f       	mov	r22, r25
    70de:	70 e0       	ldi	r23, 0x00	; 0
    70e0:	a6 01       	movw	r20, r12
    70e2:	49 53       	subi	r20, 0x39	; 57
    70e4:	57 4f       	sbci	r21, 0xF7	; 247
    70e6:	fa 01       	movw	r30, r20
    70e8:	20 81       	ld	r18, Z
    70ea:	30 e0       	ldi	r19, 0x00	; 0
    70ec:	22 50       	subi	r18, 0x02	; 2
    70ee:	31 09       	sbc	r19, r1
    70f0:	62 17       	cp	r22, r18
    70f2:	73 07       	cpc	r23, r19
    70f4:	39 f5       	brne	.+78     	; 0x7144 <Modbus_TX+0xb4>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    70f6:	64 e1       	ldi	r22, 0x14	; 20
    70f8:	6c 9d       	mul	r22, r12
    70fa:	90 01       	movw	r18, r0
    70fc:	6d 9d       	mul	r22, r13
    70fe:	30 0d       	add	r19, r0
    7100:	11 24       	eor	r1, r1
    7102:	23 56       	subi	r18, 0x63	; 99
    7104:	30 4b       	sbci	r19, 0xB0	; 176
    7106:	f9 01       	movw	r30, r18
    7108:	65 91       	lpm	r22, Z+
    710a:	74 91       	lpm	r23, Z
    710c:	fb 01       	movw	r30, r22
    710e:	b0 80       	ld	r11, Z
    7110:	fb 2d       	mov	r31, r11
    7112:	ff 7d       	andi	r31, 0xDF	; 223
    7114:	bf 2e       	mov	r11, r31
    7116:	fb 01       	movw	r30, r22
    7118:	b0 82       	st	Z, r11
    711a:	f9 01       	movw	r30, r18
    711c:	25 91       	lpm	r18, Z+
    711e:	34 91       	lpm	r19, Z
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7120:	f9 01       	movw	r30, r18
    7122:	60 81       	ld	r22, Z
    7124:	60 64       	ori	r22, 0x40	; 64
    7126:	60 83       	st	Z, r22
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    7128:	24 e1       	ldi	r18, 0x14	; 20
    712a:	2c 9d       	mul	r18, r12
    712c:	f0 01       	movw	r30, r0
    712e:	2d 9d       	mul	r18, r13
    7130:	f0 0d       	add	r31, r0
    7132:	11 24       	eor	r1, r1
    7134:	e5 56       	subi	r30, 0x65	; 101
    7136:	f0 4b       	sbci	r31, 0xB0	; 176
    7138:	25 91       	lpm	r18, Z+
    713a:	34 91       	lpm	r19, Z
    713c:	f9 01       	movw	r30, r18
    713e:	60 81       	ld	r22, Z
    7140:	60 64       	ori	r22, 0x40	; 64
    7142:	60 83       	st	Z, r22
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    7144:	9f 5f       	subi	r25, 0xFF	; 255
    7146:	f8 01       	movw	r30, r16
    7148:	90 83       	st	Z, r25
    714a:	fa 01       	movw	r30, r20
    714c:	20 81       	ld	r18, Z
    714e:	92 17       	cp	r25, r18
    7150:	48 f4       	brcc	.+18     	; 0x7164 <Modbus_TX+0xd4>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    7152:	fc 2d       	mov	r31, r12
    7154:	ee 27       	eor	r30, r30
    7156:	e9 0f       	add	r30, r25
    7158:	f1 1d       	adc	r31, r1
    715a:	eb 5c       	subi	r30, 0xCB	; 203
    715c:	f2 4f       	sbci	r31, 0xF2	; 242
    715e:	80 81       	ld	r24, Z
    7160:	8c 93       	st	X, r24
		return;
    7162:	43 c0       	rjmp	.+134    	; 0x71ea <Modbus_TX+0x15a>
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    7164:	94 e1       	ldi	r25, 0x14	; 20
    7166:	9c 9d       	mul	r25, r12
    7168:	f0 01       	movw	r30, r0
    716a:	9d 9d       	mul	r25, r13
    716c:	f0 0d       	add	r31, r0
    716e:	11 24       	eor	r1, r1
    7170:	e3 56       	subi	r30, 0x63	; 99
    7172:	f0 4b       	sbci	r31, 0xB0	; 176
    7174:	a5 91       	lpm	r26, Z+
    7176:	b4 91       	lpm	r27, Z
    7178:	9c 91       	ld	r25, X
    717a:	9f 79       	andi	r25, 0x9F	; 159
    717c:	9c 93       	st	X, r25
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    717e:	94 e1       	ldi	r25, 0x14	; 20
    7180:	9c 9d       	mul	r25, r12
    7182:	90 01       	movw	r18, r0
    7184:	9d 9d       	mul	r25, r13
    7186:	30 0d       	add	r19, r0
    7188:	11 24       	eor	r1, r1
    718a:	2b 55       	subi	r18, 0x5B	; 91
    718c:	30 4b       	sbci	r19, 0xB0	; 176
    718e:	f9 01       	movw	r30, r18
    7190:	45 91       	lpm	r20, Z+
    7192:	54 91       	lpm	r21, Z
    7194:	89 83       	std	Y+1, r24	; 0x01
    7196:	fa 01       	movw	r30, r20
    7198:	09 95       	icall
	Count[MB_N] = 0;
    719a:	d8 01       	movw	r26, r16
    719c:	1c 92       	st	X, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    719e:	f6 01       	movw	r30, r12
    71a0:	e5 52       	subi	r30, 0x25	; 37
    71a2:	fc 4f       	sbci	r31, 0xFC	; 252
    71a4:	91 e0       	ldi	r25, 0x01	; 1
    71a6:	90 83       	st	Z, r25
	switch (prb(MB_Role+MB_N)) {
    71a8:	f7 01       	movw	r30, r14
    71aa:	e8 52       	subi	r30, 0x28	; 40
    71ac:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    71ae:	e4 91       	lpm	r30, Z
    71b0:	89 81       	ldd	r24, Y+1	; 0x01
    71b2:	ee 23       	and	r30, r30
    71b4:	71 f0       	breq	.+28     	; 0x71d2 <Modbus_TX+0x142>
    71b6:	e1 30       	cpi	r30, 0x01	; 1
    71b8:	c1 f4       	brne	.+48     	; 0x71ea <Modbus_TX+0x15a>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    71ba:	0f 90       	pop	r0
    71bc:	df 91       	pop	r29
    71be:	cf 91       	pop	r28
    71c0:	1f 91       	pop	r17
    71c2:	0f 91       	pop	r16
    71c4:	ff 90       	pop	r15
    71c6:	ef 90       	pop	r14
    71c8:	df 90       	pop	r13
    71ca:	cf 90       	pop	r12
    71cc:	bf 90       	pop	r11
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    71ce:	0c 94 3d 38 	jmp	0x707a	; 0x707a <MB_M_Tx>
		break;
	}
}
    71d2:	0f 90       	pop	r0
    71d4:	df 91       	pop	r29
    71d6:	cf 91       	pop	r28
    71d8:	1f 91       	pop	r17
    71da:	0f 91       	pop	r16
    71dc:	ff 90       	pop	r15
    71de:	ef 90       	pop	r14
    71e0:	df 90       	pop	r13
    71e2:	cf 90       	pop	r12
    71e4:	bf 90       	pop	r11
	Count[MB_N] = 0;
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
    71e6:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <MB_S_Tx>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    71ea:	0f 90       	pop	r0
    71ec:	df 91       	pop	r29
    71ee:	cf 91       	pop	r28
    71f0:	1f 91       	pop	r17
    71f2:	0f 91       	pop	r16
    71f4:	ff 90       	pop	r15
    71f6:	ef 90       	pop	r14
    71f8:	df 90       	pop	r13
    71fa:	cf 90       	pop	r12
    71fc:	bf 90       	pop	r11
    71fe:	08 95       	ret

00007200 <MB_M_Cycle>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    7200:	1f 93       	push	r17
    7202:	cf 93       	push	r28
    7204:	df 93       	push	r29
    7206:	18 2f       	mov	r17, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    7208:	c0 91 56 02 	lds	r28, 0x0256
    720c:	c8 0f       	add	r28, r24
    720e:	81 e0       	ldi	r24, 0x01	; 1
    7210:	8c 0f       	add	r24, r28
    7212:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    7216:	88 23       	and	r24, r24
    7218:	19 f0       	breq	.+6      	; 0x7220 <MB_M_Cycle+0x20>
		SlavesOn(MB_N);
    721a:	81 2f       	mov	r24, r17
    721c:	0e 94 c5 2a 	call	0x558a	; 0x558a <SlavesOn>

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    7220:	8c 2f       	mov	r24, r28
    7222:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    7226:	88 23       	and	r24, r24
    7228:	09 f4       	brne	.+2      	; 0x722c <MB_M_Cycle+0x2c>
    722a:	4f c0       	rjmp	.+158    	; 0x72ca <MB_M_Cycle+0xca>
		cli();
    722c:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    722e:	c1 2f       	mov	r28, r17
    7230:	d0 e0       	ldi	r29, 0x00	; 0
    7232:	fe 01       	movw	r30, r28
    7234:	e5 52       	subi	r30, 0x25	; 37
    7236:	fc 4f       	sbci	r31, 0xFC	; 252
    7238:	80 81       	ld	r24, Z
    723a:	81 30       	cpi	r24, 0x01	; 1
    723c:	11 f4       	brne	.+4      	; 0x7242 <MB_M_Cycle+0x42>
    723e:	85 e0       	ldi	r24, 0x05	; 5
    7240:	80 83       	st	Z, r24
		sei();
    7242:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    7244:	80 81       	ld	r24, Z
    7246:	84 30       	cpi	r24, 0x04	; 4
    7248:	a1 f0       	breq	.+40     	; 0x7272 <MB_M_Cycle+0x72>
    724a:	85 30       	cpi	r24, 0x05	; 5
    724c:	09 f0       	breq	.+2      	; 0x7250 <MB_M_Cycle+0x50>
    724e:	3d c0       	rjmp	.+122    	; 0x72ca <MB_M_Cycle+0xca>
	case MB_NoReply:
		FailSlave(MB_N);
    7250:	81 2f       	mov	r24, r17
    7252:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <FailSlave>
		switch (MB_SingleState[MB_N]) {
    7256:	fe 01       	movw	r30, r28
    7258:	e4 5e       	subi	r30, 0xE4	; 228
    725a:	f9 4f       	sbci	r31, 0xF9	; 249
    725c:	80 81       	ld	r24, Z
    725e:	88 23       	and	r24, r24
    7260:	09 f1       	breq	.+66     	; 0x72a4 <MB_M_Cycle+0xa4>
    7262:	81 30       	cpi	r24, 0x01	; 1
    7264:	31 f5       	brne	.+76     	; 0x72b2 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    7266:	c5 5a       	subi	r28, 0xA5	; 165
    7268:	dd 4f       	sbci	r29, 0xFD	; 253
    726a:	88 81       	ld	r24, Y
    726c:	81 11       	cpse	r24, r1
    726e:	21 c0       	rjmp	.+66     	; 0x72b2 <MB_M_Cycle+0xb2>
    7270:	1d c0       	rjmp	.+58     	; 0x72ac <MB_M_Cycle+0xac>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    7272:	f8 94       	cli
		USART_Func(MB_N, LED);
    7274:	84 e1       	ldi	r24, 0x14	; 20
    7276:	8c 9f       	mul	r24, r28
    7278:	f0 01       	movw	r30, r0
    727a:	8d 9f       	mul	r24, r29
    727c:	f0 0d       	add	r31, r0
    727e:	11 24       	eor	r1, r1
    7280:	e9 55       	subi	r30, 0x59	; 89
    7282:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7284:	25 91       	lpm	r18, Z+
    7286:	34 91       	lpm	r19, Z
    7288:	f9 01       	movw	r30, r18
    728a:	09 95       	icall
		sei();
    728c:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    728e:	c4 5e       	subi	r28, 0xE4	; 228
    7290:	d9 4f       	sbci	r29, 0xF9	; 249
    7292:	88 81       	ld	r24, Y
    7294:	88 23       	and	r24, r24
    7296:	31 f0       	breq	.+12     	; 0x72a4 <MB_M_Cycle+0xa4>
    7298:	81 30       	cpi	r24, 0x01	; 1
    729a:	59 f4       	brne	.+22     	; 0x72b2 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    729c:	80 91 5c 02 	lds	r24, 0x025C
    72a0:	88 23       	and	r24, r24
    72a2:	21 f0       	breq	.+8      	; 0x72ac <MB_M_Cycle+0xac>
				FormQuery(MB_N);
    72a4:	81 2f       	mov	r24, r17
    72a6:	0e 94 9d 31 	call	0x633a	; 0x633a <FormQuery>
    72aa:	03 c0       	rjmp	.+6      	; 0x72b2 <MB_M_Cycle+0xb2>
			else
				FormSingle(MB_N);
    72ac:	81 2f       	mov	r24, r17
    72ae:	0e 94 e7 31 	call	0x63ce	; 0x63ce <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    72b2:	80 91 56 02 	lds	r24, 0x0256
    72b6:	6f ef       	ldi	r22, 0xFF	; 255
    72b8:	7f ef       	ldi	r23, 0xFF	; 255
    72ba:	81 0f       	add	r24, r17
    72bc:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
		cli();
    72c0:	f8 94       	cli
		MB_Transm(MB_N);
    72c2:	81 2f       	mov	r24, r17
    72c4:	0e 94 90 2f 	call	0x5f20	; 0x5f20 <MB_Transm>
		sei();
    72c8:	78 94       	sei
		break;
	}
}
    72ca:	df 91       	pop	r29
    72cc:	cf 91       	pop	r28
    72ce:	1f 91       	pop	r17
    72d0:	08 95       	ret

000072d2 <MB_Cycle>:
{
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    72d2:	80 91 00 0b 	lds	r24, 0x0B00
    72d6:	80 ff       	sbrs	r24, 0
    72d8:	15 c0       	rjmp	.+42     	; 0x7304 <MB_Cycle+0x32>
			cli();
    72da:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    72dc:	80 91 00 0b 	lds	r24, 0x0B00
    72e0:	8e 7f       	andi	r24, 0xFE	; 254
    72e2:	80 93 00 0b 	sts	0x0B00, r24
			sei();
    72e6:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    72e8:	e8 ed       	ldi	r30, 0xD8	; 216
    72ea:	ff e4       	ldi	r31, 0x4F	; 79
    72ec:	e4 91       	lpm	r30, Z
			switch (prb(MB_Role+MB_N)) {
    72ee:	ee 23       	and	r30, r30
    72f0:	31 f0       	breq	.+12     	; 0x72fe <MB_Cycle+0x2c>
    72f2:	e1 30       	cpi	r30, 0x01	; 1
    72f4:	39 f4       	brne	.+14     	; 0x7304 <MB_Cycle+0x32>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    72f6:	80 e0       	ldi	r24, 0x00	; 0
    72f8:	0e 94 8d 35 	call	0x6b1a	; 0x6b1a <MB_M_Timer_ISR>
				break;
    72fc:	03 c0       	rjmp	.+6      	; 0x7304 <MB_Cycle+0x32>
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    72fe:	80 e0       	ldi	r24, 0x00	; 0
    7300:	0e 94 25 32 	call	0x644a	; 0x644a <MB_S_Timer_ISR>
    7304:	e8 ed       	ldi	r30, 0xD8	; 216
    7306:	ff e4       	ldi	r31, 0x4F	; 79
    7308:	e4 91       	lpm	r30, Z
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    730a:	e1 30       	cpi	r30, 0x01	; 1
    730c:	19 f4       	brne	.+6      	; 0x7314 <MB_Cycle+0x42>
			MB_M_Cycle(MB_N);
    730e:	80 e0       	ldi	r24, 0x00	; 0
    7310:	0c 94 00 39 	jmp	0x7200	; 0x7200 <MB_M_Cycle>
    7314:	08 95       	ret

00007316 <IP_compare_Const>:
	IP->IP1 = IP1;
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    7316:	0f 93       	push	r16
    7318:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    731a:	80 81       	ld	r24, Z
    731c:	86 13       	cpse	r24, r22
    731e:	09 c0       	rjmp	.+18     	; 0x7332 <IP_compare_Const+0x1c>
    7320:	81 81       	ldd	r24, Z+1	; 0x01
    7322:	84 13       	cpse	r24, r20
    7324:	06 c0       	rjmp	.+12     	; 0x7332 <IP_compare_Const+0x1c>
    7326:	82 81       	ldd	r24, Z+2	; 0x02
    7328:	82 13       	cpse	r24, r18
    732a:	03 c0       	rjmp	.+6      	; 0x7332 <IP_compare_Const+0x1c>
    732c:	81 e0       	ldi	r24, 0x01	; 1
    732e:	93 81       	ldd	r25, Z+3	; 0x03
    7330:	90 13       	cpse	r25, r16
	else return 0;
    7332:	80 e0       	ldi	r24, 0x00	; 0
}
    7334:	0f 91       	pop	r16
    7336:	08 95       	ret

00007338 <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    7338:	cf 92       	push	r12
    733a:	df 92       	push	r13
    733c:	ff 92       	push	r15
    733e:	0f 93       	push	r16
    7340:	1f 93       	push	r17
    7342:	cf 93       	push	r28
    7344:	df 93       	push	r29
    7346:	1f 92       	push	r1
    7348:	cd b7       	in	r28, 0x3d	; 61
    734a:	de b7       	in	r29, 0x3e	; 62
    734c:	6c 01       	movw	r12, r24
    734e:	f4 2e       	mov	r15, r20
    7350:	12 2f       	mov	r17, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7352:	69 83       	std	Y+1, r22	; 0x01
    7354:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    7358:	69 81       	ldd	r22, Y+1	; 0x01
    735a:	86 13       	cpse	r24, r22
    735c:	12 c0       	rjmp	.+36     	; 0x7382 <IP_E_compare_Const+0x4a>
    735e:	c6 01       	movw	r24, r12
    7360:	01 96       	adiw	r24, 0x01	; 1
    7362:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    7366:	8f 11       	cpse	r24, r15
    7368:	0c c0       	rjmp	.+24     	; 0x7382 <IP_E_compare_Const+0x4a>
    736a:	c6 01       	movw	r24, r12
    736c:	02 96       	adiw	r24, 0x02	; 2
    736e:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    7372:	81 13       	cpse	r24, r17
    7374:	06 c0       	rjmp	.+12     	; 0x7382 <IP_E_compare_Const+0x4a>
    7376:	c6 01       	movw	r24, r12
    7378:	03 96       	adiw	r24, 0x03	; 3
    737a:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    737e:	91 e0       	ldi	r25, 0x01	; 1
    7380:	80 13       	cpse	r24, r16
	else return 0;
    7382:	90 e0       	ldi	r25, 0x00	; 0
}
    7384:	89 2f       	mov	r24, r25
    7386:	0f 90       	pop	r0
    7388:	df 91       	pop	r29
    738a:	cf 91       	pop	r28
    738c:	1f 91       	pop	r17
    738e:	0f 91       	pop	r16
    7390:	ff 90       	pop	r15
    7392:	df 90       	pop	r13
    7394:	cf 90       	pop	r12
    7396:	08 95       	ret

00007398 <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    7398:	8f ef       	ldi	r24, 0xFF	; 255
    739a:	80 93 75 08 	sts	0x0875, r24
	GSM_RX_FIFO_End = 255;
    739e:	80 93 ff 05 	sts	0x05FF, r24
	GSM_RxCharN = 0;
    73a2:	10 92 32 0d 	sts	0x0D32, r1
    73a6:	08 95       	ret

000073a8 <GetByteFromFIFO>:
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    73a8:	fb 01       	movw	r30, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    73aa:	20 81       	ld	r18, Z
    73ac:	24 17       	cp	r18, r20
    73ae:	08 f0       	brcs	.+2      	; 0x73b2 <GetByteFromFIFO+0xa>
		*Index = 0;
    73b0:	10 82       	st	Z, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    73b2:	20 91 75 08 	lds	r18, 0x0875
    73b6:	a0 91 ff 05 	lds	r26, 0x05FF
    73ba:	a2 17       	cp	r26, r18
    73bc:	08 f5       	brcc	.+66     	; 0x7400 <GetByteFromFIFO+0x58>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    73be:	af 3f       	cpi	r26, 0xFF	; 255
    73c0:	81 f0       	breq	.+32     	; 0x73e2 <GetByteFromFIFO+0x3a>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    73c2:	40 91 fa 0a 	lds	r20, 0x0AFA
    73c6:	20 91 75 08 	lds	r18, 0x0875
    73ca:	50 e0       	ldi	r21, 0x00	; 0
    73cc:	30 e0       	ldi	r19, 0x00	; 0
    73ce:	2a 1b       	sub	r18, r26
    73d0:	31 09       	sbc	r19, r1
    73d2:	42 17       	cp	r20, r18
    73d4:	53 07       	cpc	r21, r19
    73d6:	2c f4       	brge	.+10     	; 0x73e2 <GetByteFromFIFO+0x3a>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    73d8:	20 91 75 08 	lds	r18, 0x0875
    73dc:	2a 1b       	sub	r18, r26
    73de:	20 93 fa 0a 	sts	0x0AFA, r18
		GSM_RX_FIFO_End++;
    73e2:	af 5f       	subi	r26, 0xFF	; 255
    73e4:	a0 93 ff 05 	sts	0x05FF, r26
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    73e8:	b0 e0       	ldi	r27, 0x00	; 0
    73ea:	ae 50       	subi	r26, 0x0E	; 14
    73ec:	bb 4f       	sbci	r27, 0xFB	; 251
    73ee:	2c 91       	ld	r18, X
    73f0:	30 81       	ld	r19, Z
    73f2:	dc 01       	movw	r26, r24
    73f4:	a3 0f       	add	r26, r19
    73f6:	b1 1d       	adc	r27, r1
    73f8:	2c 93       	st	X, r18
		*Index=*Index+1;
    73fa:	20 81       	ld	r18, Z
    73fc:	2f 5f       	subi	r18, 0xFF	; 255
    73fe:	20 83       	st	Z, r18
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7400:	60 91 ff 05 	lds	r22, 0x05FF
    7404:	20 91 75 08 	lds	r18, 0x0875
    7408:	26 17       	cp	r18, r22
    740a:	60 f5       	brcc	.+88     	; 0x7464 <GetByteFromFIFO+0xbc>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    740c:	6f 3f       	cpi	r22, 0xFF	; 255
    740e:	a1 f0       	breq	.+40     	; 0x7438 <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7410:	40 91 fa 0a 	lds	r20, 0x0AFA
    7414:	70 91 75 08 	lds	r23, 0x0875
    7418:	50 e0       	ldi	r21, 0x00	; 0
    741a:	2a ef       	ldi	r18, 0xFA	; 250
    741c:	30 e0       	ldi	r19, 0x00	; 0
    741e:	26 1b       	sub	r18, r22
    7420:	31 09       	sbc	r19, r1
    7422:	27 0f       	add	r18, r23
    7424:	31 1d       	adc	r19, r1
    7426:	42 17       	cp	r20, r18
    7428:	53 07       	cpc	r21, r19
    742a:	34 f4       	brge	.+12     	; 0x7438 <GetByteFromFIFO+0x90>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    742c:	20 91 75 08 	lds	r18, 0x0875
    7430:	26 50       	subi	r18, 0x06	; 6
    7432:	26 1b       	sub	r18, r22
    7434:	20 93 fa 0a 	sts	0x0AFA, r18
		GSM_RX_FIFO_End++;
    7438:	6f 5f       	subi	r22, 0xFF	; 255
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    743a:	6a 3f       	cpi	r22, 0xFA	; 250
    743c:	18 f4       	brcc	.+6      	; 0x7444 <GetByteFromFIFO+0x9c>
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    743e:	60 93 ff 05 	sts	0x05FF, r22
    7442:	02 c0       	rjmp	.+4      	; 0x7448 <GetByteFromFIFO+0xa0>
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    7444:	10 92 ff 05 	sts	0x05FF, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    7448:	a0 91 ff 05 	lds	r26, 0x05FF
    744c:	b0 e0       	ldi	r27, 0x00	; 0
    744e:	ae 50       	subi	r26, 0x0E	; 14
    7450:	bb 4f       	sbci	r27, 0xFB	; 251
    7452:	2c 91       	ld	r18, X
    7454:	30 81       	ld	r19, Z
    7456:	dc 01       	movw	r26, r24
    7458:	a3 0f       	add	r26, r19
    745a:	b1 1d       	adc	r27, r1
    745c:	2c 93       	st	X, r18
		*Index=*Index+1;
    745e:	80 81       	ld	r24, Z
    7460:	8f 5f       	subi	r24, 0xFF	; 255
    7462:	80 83       	st	Z, r24
    7464:	08 95       	ret

00007466 <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7466:	90 91 75 08 	lds	r25, 0x0875
    746a:	80 91 ff 05 	lds	r24, 0x05FF
    746e:	98 17       	cp	r25, r24
    7470:	39 f1       	breq	.+78     	; 0x74c0 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    7472:	44 e6       	ldi	r20, 0x64	; 100
    7474:	62 e3       	ldi	r22, 0x32	; 50
    7476:	7d e0       	ldi	r23, 0x0D	; 13
    7478:	86 e7       	ldi	r24, 0x76	; 118
    747a:	99 e0       	ldi	r25, 0x09	; 9
    747c:	0e 94 d4 39 	call	0x73a8	; 0x73a8 <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    7480:	80 91 32 0d 	lds	r24, 0x0D32
    7484:	82 30       	cpi	r24, 0x02	; 2
    7486:	78 f3       	brcs	.-34     	; 0x7466 <GetStringFromFIFO>
    7488:	e0 91 32 0d 	lds	r30, 0x0D32
    748c:	f0 e0       	ldi	r31, 0x00	; 0
    748e:	ec 58       	subi	r30, 0x8C	; 140
    7490:	f6 4f       	sbci	r31, 0xF6	; 246
    7492:	80 81       	ld	r24, Z
    7494:	8d 30       	cpi	r24, 0x0D	; 13
    7496:	39 f7       	brne	.-50     	; 0x7466 <GetStringFromFIFO>
    7498:	e0 91 32 0d 	lds	r30, 0x0D32
    749c:	f0 e0       	ldi	r31, 0x00	; 0
    749e:	eb 58       	subi	r30, 0x8B	; 139
    74a0:	f6 4f       	sbci	r31, 0xF6	; 246
    74a2:	80 81       	ld	r24, Z
    74a4:	8a 30       	cpi	r24, 0x0A	; 10
    74a6:	f9 f6       	brne	.-66     	; 0x7466 <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    74a8:	e0 91 32 0d 	lds	r30, 0x0D32
    74ac:	f0 e0       	ldi	r31, 0x00	; 0
    74ae:	ec 58       	subi	r30, 0x8C	; 140
    74b0:	f6 4f       	sbci	r31, 0xF6	; 246
    74b2:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    74b4:	80 91 32 0d 	lds	r24, 0x0D32
			GSM_RxCharN = 0;
    74b8:	10 92 32 0d 	sts	0x0D32, r1
    74bc:	81 50       	subi	r24, 0x01	; 1
    74be:	08 95       	ret
			return StrLength;
		}

	}//while

	return StrLength;
    74c0:	80 e0       	ldi	r24, 0x00	; 0
}
    74c2:	08 95       	ret

000074c4 <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    74c4:	80 91 32 0d 	lds	r24, 0x0D32
    74c8:	84 36       	cpi	r24, 0x64	; 100
    74ca:	18 f0       	brcs	.+6      	; 0x74d2 <ForceEndStringFromFIFO+0xe>
    74cc:	83 e6       	ldi	r24, 0x63	; 99
    74ce:	80 93 32 0d 	sts	0x0D32, r24
	StrLength = GSM_RxCharN;
    74d2:	80 91 32 0d 	lds	r24, 0x0D32
	GSM_RxStr[GSM_RxCharN]='\0';
    74d6:	e0 91 32 0d 	lds	r30, 0x0D32
    74da:	f0 e0       	ldi	r31, 0x00	; 0
    74dc:	ea 58       	subi	r30, 0x8A	; 138
    74de:	f6 4f       	sbci	r31, 0xF6	; 246
    74e0:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    74e2:	10 92 32 0d 	sts	0x0D32, r1
	return StrLength;
}
    74e6:	08 95       	ret

000074e8 <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    74e8:	cf 93       	push	r28
    74ea:	c8 2f       	mov	r28, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    74ec:	90 91 75 08 	lds	r25, 0x0875
    74f0:	80 91 ff 05 	lds	r24, 0x05FF
    74f4:	98 17       	cp	r25, r24
    74f6:	79 f0       	breq	.+30     	; 0x7516 <GetDataFromFIFO+0x2e>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    74f8:	44 e6       	ldi	r20, 0x64	; 100
    74fa:	62 e3       	ldi	r22, 0x32	; 50
    74fc:	7d e0       	ldi	r23, 0x0D	; 13
    74fe:	86 e7       	ldi	r24, 0x76	; 118
    7500:	99 e0       	ldi	r25, 0x09	; 9
    7502:	0e 94 d4 39 	call	0x73a8	; 0x73a8 <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    7506:	80 91 32 0d 	lds	r24, 0x0D32
    750a:	8c 17       	cp	r24, r28
    750c:	78 f3       	brcs	.-34     	; 0x74ec <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    750e:	10 92 32 0d 	sts	0x0D32, r1
			return Amount;
    7512:	8c 2f       	mov	r24, r28
    7514:	02 c0       	rjmp	.+4      	; 0x751a <GetDataFromFIFO+0x32>
		}
	}//while
	return GSM_RxCharN;
    7516:	80 91 32 0d 	lds	r24, 0x0D32
}
    751a:	cf 91       	pop	r28
    751c:	08 95       	ret

0000751e <strcpy_EE>:
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    751e:	df 92       	push	r13
    7520:	ef 92       	push	r14
    7522:	ff 92       	push	r15
    7524:	0f 93       	push	r16
    7526:	1f 93       	push	r17
    7528:	cf 93       	push	r28
    752a:	df 93       	push	r29
    752c:	8c 01       	movw	r16, r24
    752e:	7b 01       	movw	r14, r22
	uint8_t i=0;
    7530:	d1 2c       	mov	r13, r1
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    7532:	cd 2d       	mov	r28, r13
    7534:	d0 e0       	ldi	r29, 0x00	; 0
    7536:	c7 01       	movw	r24, r14
    7538:	8c 0f       	add	r24, r28
    753a:	9d 1f       	adc	r25, r29
    753c:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    7540:	98 2f       	mov	r25, r24
    7542:	9f 7d       	andi	r25, 0xDF	; 223
    7544:	29 f0       	breq	.+10     	; 0x7550 <strcpy_EE+0x32>
		str_RAM[i] = (char)erb(&str_EE[i]);
    7546:	c0 0f       	add	r28, r16
    7548:	d1 1f       	adc	r29, r17
    754a:	88 83       	st	Y, r24
		i++;
    754c:	d3 94       	inc	r13
    754e:	f1 cf       	rjmp	.-30     	; 0x7532 <strcpy_EE+0x14>
	}
	return i;	
}
    7550:	8d 2d       	mov	r24, r13
    7552:	df 91       	pop	r29
    7554:	cf 91       	pop	r28
    7556:	1f 91       	pop	r17
    7558:	0f 91       	pop	r16
    755a:	ff 90       	pop	r15
    755c:	ef 90       	pop	r14
    755e:	df 90       	pop	r13
    7560:	08 95       	ret

00007562 <GSM_Init>:
}
// ~~~~~~~~~~~
void
GSM_Init(void)
{	
	InitFIFO();
    7562:	0e 94 cc 39 	call	0x7398	; 0x7398 <InitFIFO>
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABl_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    7566:	8c ef       	ldi	r24, 0xFC	; 252
    7568:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    756a:	88 e9       	ldi	r24, 0x98	; 152
    756c:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    756e:	86 e8       	ldi	r24, 0x86	; 134
    7570:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    7574:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    7578:	87 e6       	ldi	r24, 0x67	; 103
    757a:	89 b9       	out	0x09, r24	; 9
	#endif

	GSM_PWRCNTRL_Config();
    757c:	0e 94 97 2e 	call	0x5d2e	; 0x5d2e <GSM_PWRCNTRL_Config>
	GSM_PWRCNTRL_ON();
    7580:	0e 94 9f 2e 	call	0x5d3e	; 0x5d3e <GSM_PWRCNTRL_ON>

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    7584:	80 91 0e 01 	lds	r24, 0x010E
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    7588:	80 93 54 02 	sts	0x0254, r24
	VacantTimer16Sys += n;
    758c:	91 e0       	ldi	r25, 0x01	; 1
    758e:	98 0f       	add	r25, r24
	TD_TCP_Connect = Timer16SysAlloc(1);
    7590:	90 93 53 02 	sts	0x0253, r25
    7594:	92 e0       	ldi	r25, 0x02	; 2
    7596:	98 0f       	add	r25, r24
	TD_RSSI = Timer16SysAlloc(1);
    7598:	90 93 52 02 	sts	0x0252, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    759c:	90 91 0d 01 	lds	r25, 0x010D
	VacantTimer32Sys += n;
    75a0:	21 e0       	ldi	r18, 0x01	; 1
    75a2:	29 0f       	add	r18, r25
    75a4:	20 93 0d 01 	sts	0x010D, r18
	TD_GSM_Reset = Timer32SysAlloc(1);
    75a8:	90 93 51 02 	sts	0x0251, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    75ac:	93 e0       	ldi	r25, 0x03	; 3
    75ae:	98 0f       	add	r25, r24
	TCP_CONNECT_check_timer = Timer16SysAlloc(1);
    75b0:	90 93 2d 0d 	sts	0x0D2D, r25
    75b4:	95 e0       	ldi	r25, 0x05	; 5
    75b6:	98 0f       	add	r25, r24
    75b8:	90 93 0e 01 	sts	0x010E, r25
    75bc:	8c 5f       	subi	r24, 0xFC	; 252
	GPRS_RECONNECT_timer = Timer16SysAlloc(1);
    75be:	80 93 05 06 	sts	0x0605, r24
/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    75c2:	10 92 6a 09 	sts	0x096A, r1
	GSM_State = GSM_PowerOn;
    75c6:	10 92 21 06 	sts	0x0621, r1
    75ca:	08 95       	ret

000075cc <GSM_Wait_Response>:
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    75cc:	bc 01       	movw	r22, r24
    75ce:	86 e7       	ldi	r24, 0x76	; 118
    75d0:	99 e0       	ldi	r25, 0x09	; 9
    75d2:	0e 94 45 6c 	call	0xd88a	; 0xd88a <strcmp>
    75d6:	21 e0       	ldi	r18, 0x01	; 1
    75d8:	89 2b       	or	r24, r25
    75da:	09 f0       	breq	.+2      	; 0x75de <GSM_Wait_Response+0x12>
    75dc:	20 e0       	ldi	r18, 0x00	; 0
	else return 1;
}
    75de:	82 2f       	mov	r24, r18
    75e0:	08 95       	ret

000075e2 <GSM_Wait_Response_P>:
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    75e2:	0f 93       	push	r16
    75e4:	1f 93       	push	r17
    75e6:	cf 93       	push	r28
    75e8:	df 93       	push	r29
    75ea:	1f 92       	push	r1
    75ec:	cd b7       	in	r28, 0x3d	; 61
    75ee:	de b7       	in	r29, 0x3e	; 62
    75f0:	8c 01       	movw	r16, r24
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    75f2:	80 91 54 02 	lds	r24, 0x0254
    75f6:	69 83       	std	Y+1, r22	; 0x01
    75f8:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    75fc:	69 81       	ldd	r22, Y+1	; 0x01
    75fe:	88 23       	and	r24, r24
    7600:	29 f0       	breq	.+10     	; 0x760c <GSM_Wait_Response_P+0x2a>
    7602:	66 23       	and	r22, r22
    7604:	19 f0       	breq	.+6      	; 0x760c <GSM_Wait_Response_P+0x2a>
		GSM_State = RestoreCMD;
    7606:	60 93 21 06 	sts	0x0621, r22
    760a:	0c c0       	rjmp	.+24     	; 0x7624 <GSM_Wait_Response_P+0x42>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    760c:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    7610:	88 23       	and	r24, r24
    7612:	41 f0       	breq	.+16     	; 0x7624 <GSM_Wait_Response_P+0x42>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    7614:	b8 01       	movw	r22, r16
    7616:	86 e7       	ldi	r24, 0x76	; 118
    7618:	99 e0       	ldi	r25, 0x09	; 9
    761a:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    761e:	21 e0       	ldi	r18, 0x01	; 1
    7620:	89 2b       	or	r24, r25
    7622:	09 f0       	breq	.+2      	; 0x7626 <GSM_Wait_Response_P+0x44>
		else return 1;
	}
	else return 0;
    7624:	20 e0       	ldi	r18, 0x00	; 0
}
    7626:	82 2f       	mov	r24, r18
    7628:	0f 90       	pop	r0
    762a:	df 91       	pop	r29
    762c:	cf 91       	pop	r28
    762e:	1f 91       	pop	r17
    7630:	0f 91       	pop	r16
    7632:	08 95       	ret

00007634 <GSM_Wait_Char>:
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    7634:	1f 93       	push	r17
    7636:	cf 93       	push	r28
    7638:	df 93       	push	r29
    763a:	1f 92       	push	r1
    763c:	cd b7       	in	r28, 0x3d	; 61
    763e:	de b7       	in	r29, 0x3e	; 62
    7640:	18 2f       	mov	r17, r24
	if(Timer16Stopp(TD_GSM)){
    7642:	80 91 54 02 	lds	r24, 0x0254
    7646:	69 83       	std	Y+1, r22	; 0x01
    7648:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    764c:	69 81       	ldd	r22, Y+1	; 0x01
    764e:	88 23       	and	r24, r24
    7650:	19 f0       	breq	.+6      	; 0x7658 <GSM_Wait_Char+0x24>
		GSM_State = RestoreCMD;
    7652:	60 93 21 06 	sts	0x0621, r22
    7656:	09 c0       	rjmp	.+18     	; 0x766a <GSM_Wait_Char+0x36>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    7658:	81 e0       	ldi	r24, 0x01	; 1
    765a:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <GetDataFromFIFO>
    765e:	88 23       	and	r24, r24
    7660:	21 f0       	breq	.+8      	; 0x766a <GSM_Wait_Char+0x36>
		if(GSM_RxStr[0] == Char)	return 1;
    7662:	81 e0       	ldi	r24, 0x01	; 1
    7664:	90 91 76 09 	lds	r25, 0x0976
    7668:	91 13       	cpse	r25, r17
		else return 0;
	}
	else return 0;
    766a:	80 e0       	ldi	r24, 0x00	; 0
}
    766c:	0f 90       	pop	r0
    766e:	df 91       	pop	r29
    7670:	cf 91       	pop	r28
    7672:	1f 91       	pop	r17
    7674:	08 95       	ret

00007676 <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    7676:	80 91 63 0a 	lds	r24, 0x0A63
    767a:	81 11       	cpse	r24, r1
    767c:	05 c0       	rjmp	.+10     	; 0x7688 <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    767e:	80 91 08 01 	lds	r24, 0x0108
    7682:	81 60       	ori	r24, 0x01	; 1
    7684:	80 93 08 01 	sts	0x0108, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    7688:	88 e9       	ldi	r24, 0x98	; 152
    768a:	8a b9       	out	0x0a, r24	; 10
    768c:	08 95       	ret

0000768e <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    768e:	1f 92       	push	r1
    7690:	0f 92       	push	r0
    7692:	0f b6       	in	r0, 0x3f	; 63
    7694:	0f 92       	push	r0
    7696:	11 24       	eor	r1, r1
    7698:	0b b6       	in	r0, 0x3b	; 59
    769a:	0f 92       	push	r0
    769c:	2f 93       	push	r18
    769e:	3f 93       	push	r19
    76a0:	4f 93       	push	r20
    76a2:	5f 93       	push	r21
    76a4:	6f 93       	push	r22
    76a6:	7f 93       	push	r23
    76a8:	8f 93       	push	r24
    76aa:	9f 93       	push	r25
    76ac:	af 93       	push	r26
    76ae:	bf 93       	push	r27
    76b0:	ef 93       	push	r30
    76b2:	ff 93       	push	r31
	GSM_TX();
    76b4:	0e 94 3b 3b 	call	0x7676	; 0x7676 <GSM_TX>
	GSM_LED = 1;
    76b8:	81 e0       	ldi	r24, 0x01	; 1
    76ba:	80 93 04 06 	sts	0x0604, r24
}
    76be:	ff 91       	pop	r31
    76c0:	ef 91       	pop	r30
    76c2:	bf 91       	pop	r27
    76c4:	af 91       	pop	r26
    76c6:	9f 91       	pop	r25
    76c8:	8f 91       	pop	r24
    76ca:	7f 91       	pop	r23
    76cc:	6f 91       	pop	r22
    76ce:	5f 91       	pop	r21
    76d0:	4f 91       	pop	r20
    76d2:	3f 91       	pop	r19
    76d4:	2f 91       	pop	r18
    76d6:	0f 90       	pop	r0
    76d8:	0b be       	out	0x3b, r0	; 59
    76da:	0f 90       	pop	r0
    76dc:	0f be       	out	0x3f, r0	; 63
    76de:	0f 90       	pop	r0
    76e0:	1f 90       	pop	r1
    76e2:	18 95       	reti

000076e4 <DI_State>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
    76e4:	e8 2f       	mov	r30, r24
    76e6:	e6 95       	lsr	r30
    76e8:	e6 95       	lsr	r30
    76ea:	e6 95       	lsr	r30
    76ec:	f0 e0       	ldi	r31, 0x00	; 0
    76ee:	ec 53       	subi	r30, 0x3C	; 60
    76f0:	f7 4f       	sbci	r31, 0xF7	; 247
    76f2:	20 81       	ld	r18, Z
    76f4:	30 e0       	ldi	r19, 0x00	; 0
    76f6:	87 70       	andi	r24, 0x07	; 7
    76f8:	02 c0       	rjmp	.+4      	; 0x76fe <DI_State+0x1a>
    76fa:	35 95       	asr	r19
    76fc:	27 95       	ror	r18
    76fe:	8a 95       	dec	r24
    7700:	e2 f7       	brpl	.-8      	; 0x76fa <DI_State+0x16>
}
    7702:	82 2f       	mov	r24, r18
    7704:	81 70       	andi	r24, 0x01	; 1
    7706:	08 95       	ret

00007708 <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
    7708:	e8 2f       	mov	r30, r24
    770a:	e6 95       	lsr	r30
    770c:	e6 95       	lsr	r30
    770e:	e6 95       	lsr	r30
    7710:	f0 e0       	ldi	r31, 0x00	; 0
    7712:	ea 53       	subi	r30, 0x3A	; 58
    7714:	f7 4f       	sbci	r31, 0xF7	; 247
    7716:	20 81       	ld	r18, Z
    7718:	30 e0       	ldi	r19, 0x00	; 0
    771a:	87 70       	andi	r24, 0x07	; 7
    771c:	02 c0       	rjmp	.+4      	; 0x7722 <DI_Status+0x1a>
    771e:	35 95       	asr	r19
    7720:	27 95       	ror	r18
    7722:	8a 95       	dec	r24
    7724:	e2 f7       	brpl	.-8      	; 0x771e <DI_Status+0x16>
}
    7726:	82 2f       	mov	r24, r18
    7728:	81 70       	andi	r24, 0x01	; 1
    772a:	08 95       	ret

0000772c <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    772c:	ff 92       	push	r15
    772e:	0f 93       	push	r16
    7730:	1f 93       	push	r17
    7732:	cf 93       	push	r28
    7734:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    7736:	c0 91 c4 08 	lds	r28, 0x08C4
    773a:	c0 93 c5 08 	sts	0x08C5, r28
    773e:	8e e5       	ldi	r24, 0x5E	; 94
    7740:	90 e0       	ldi	r25, 0x00	; 0
    7742:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    7746:	8c 27       	eor	r24, r28
    7748:	80 93 c6 08 	sts	0x08C6, r24
    774c:	81 e2       	ldi	r24, 0x21	; 33
    774e:	9d e4       	ldi	r25, 0x4D	; 77
    7750:	20 e0       	ldi	r18, 0x00	; 0
    7752:	30 e0       	ldi	r19, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    7754:	c1 e0       	ldi	r28, 0x01	; 1
    7756:	d0 e0       	ldi	r29, 0x00	; 0
    7758:	ae 01       	movw	r20, r28
    775a:	02 2e       	mov	r0, r18
    775c:	01 c0       	rjmp	.+2      	; 0x7760 <DigitIn+0x34>
    775e:	44 0f       	add	r20, r20
    7760:	0a 94       	dec	r0
    7762:	ea f7       	brpl	.-6      	; 0x775e <DigitIn+0x32>
    7764:	fc 01       	movw	r30, r24
    7766:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7768:	e4 91       	lpm	r30, Z
    776a:	dc 01       	movw	r26, r24
    776c:	12 96       	adiw	r26, 0x02	; 2
    776e:	f0 90 c4 08 	lds	r15, 0x08C4
			if(prb(&DI_M[D_N].Inversion)){
    7772:	ee 23       	and	r30, r30
    7774:	51 f0       	breq	.+20     	; 0x778a <DigitIn+0x5e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7776:	fc 01       	movw	r30, r24
    7778:	05 91       	lpm	r16, Z+
    777a:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    777c:	fd 01       	movw	r30, r26
    777e:	a4 91       	lpm	r26, Z
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    7780:	f8 01       	movw	r30, r16
    7782:	60 81       	ld	r22, Z
    7784:	a6 23       	and	r26, r22
    7786:	51 f0       	breq	.+20     	; 0x779c <DigitIn+0x70>
    7788:	0c c0       	rjmp	.+24     	; 0x77a2 <DigitIn+0x76>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    778a:	fc 01       	movw	r30, r24
    778c:	05 91       	lpm	r16, Z+
    778e:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7790:	fd 01       	movw	r30, r26
    7792:	a4 91       	lpm	r26, Z
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    7794:	f8 01       	movw	r30, r16
    7796:	60 81       	ld	r22, Z
    7798:	a6 23       	and	r26, r22
    779a:	19 f0       	breq	.+6      	; 0x77a2 <DigitIn+0x76>
					DigInput.State[Byte] &=~Bit;
    779c:	40 95       	com	r20
    779e:	4f 21       	and	r20, r15
    77a0:	01 c0       	rjmp	.+2      	; 0x77a4 <DigitIn+0x78>
				else
					DigInput.State[Byte]  |=Bit;
    77a2:	4f 29       	or	r20, r15
    77a4:	40 93 c4 08 	sts	0x08C4, r20
    77a8:	2f 5f       	subi	r18, 0xFF	; 255
    77aa:	3f 4f       	sbci	r19, 0xFF	; 255
    77ac:	08 96       	adiw	r24, 0x08	; 8
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    77ae:	24 30       	cpi	r18, 0x04	; 4
    77b0:	31 05       	cpc	r19, r1
    77b2:	09 f0       	breq	.+2      	; 0x77b6 <DigitIn+0x8a>
    77b4:	d1 cf       	rjmp	.-94     	; 0x7758 <DigitIn+0x2c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    77b6:	df 91       	pop	r29
    77b8:	cf 91       	pop	r28
    77ba:	1f 91       	pop	r17
    77bc:	0f 91       	pop	r16
    77be:	ff 90       	pop	r15
    77c0:	08 95       	ret

000077c2 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    77c2:	e8 2f       	mov	r30, r24
    77c4:	e6 95       	lsr	r30
    77c6:	e6 95       	lsr	r30
    77c8:	e6 95       	lsr	r30
    77ca:	f0 e0       	ldi	r31, 0x00	; 0
    77cc:	ee 58       	subi	r30, 0x8E	; 142
    77ce:	f6 4f       	sbci	r31, 0xF6	; 246
    77d0:	87 70       	andi	r24, 0x07	; 7
    77d2:	21 e0       	ldi	r18, 0x01	; 1
    77d4:	30 e0       	ldi	r19, 0x00	; 0
    77d6:	01 c0       	rjmp	.+2      	; 0x77da <SetDigOut+0x18>
    77d8:	22 0f       	add	r18, r18
    77da:	8a 95       	dec	r24
    77dc:	ea f7       	brpl	.-6      	; 0x77d8 <SetDigOut+0x16>
    77de:	80 81       	ld	r24, Z
    77e0:	82 2b       	or	r24, r18
    77e2:	80 83       	st	Z, r24
    77e4:	08 95       	ret

000077e6 <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    77e6:	e8 2f       	mov	r30, r24
    77e8:	e6 95       	lsr	r30
    77ea:	e6 95       	lsr	r30
    77ec:	e6 95       	lsr	r30
    77ee:	f0 e0       	ldi	r31, 0x00	; 0
    77f0:	ee 58       	subi	r30, 0x8E	; 142
    77f2:	f6 4f       	sbci	r31, 0xF6	; 246
    77f4:	87 70       	andi	r24, 0x07	; 7
    77f6:	21 e0       	ldi	r18, 0x01	; 1
    77f8:	30 e0       	ldi	r19, 0x00	; 0
    77fa:	01 c0       	rjmp	.+2      	; 0x77fe <ResDigOut+0x18>
    77fc:	22 0f       	add	r18, r18
    77fe:	8a 95       	dec	r24
    7800:	ea f7       	brpl	.-6      	; 0x77fc <ResDigOut+0x16>
    7802:	20 95       	com	r18
    7804:	80 81       	ld	r24, Z
    7806:	28 23       	and	r18, r24
    7808:	20 83       	st	Z, r18
    780a:	08 95       	ret

0000780c <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    780c:	80 91 70 09 	lds	r24, 0x0970
    7810:	80 93 71 09 	sts	0x0971, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    7814:	80 91 72 09 	lds	r24, 0x0972
    7818:	80 93 70 09 	sts	0x0970, r24
    781c:	80 e1       	ldi	r24, 0x10	; 16
    781e:	9d e4       	ldi	r25, 0x4D	; 77
    7820:	20 e0       	ldi	r18, 0x00	; 0
    7822:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    7824:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    7826:	40 91 70 09 	lds	r20, 0x0970
    782a:	50 e0       	ldi	r21, 0x00	; 0
    782c:	02 2e       	mov	r0, r18
    782e:	02 c0       	rjmp	.+4      	; 0x7834 <DigitOut+0x28>
    7830:	55 95       	asr	r21
    7832:	47 95       	ror	r20
    7834:	0a 94       	dec	r0
    7836:	e2 f7       	brpl	.-8      	; 0x7830 <DigitOut+0x24>
    7838:	bc 01       	movw	r22, r24
    783a:	6e 5f       	subi	r22, 0xFE	; 254
    783c:	7f 4f       	sbci	r23, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    783e:	fc 01       	movw	r30, r24
    7840:	40 ff       	sbrs	r20, 0
    7842:	07 c0       	rjmp	.+14     	; 0x7852 <DigitOut+0x46>
    7844:	a5 91       	lpm	r26, Z+
    7846:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7848:	fb 01       	movw	r30, r22
    784a:	64 91       	lpm	r22, Z
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    784c:	4c 91       	ld	r20, X
    784e:	46 2b       	or	r20, r22
    7850:	07 c0       	rjmp	.+14     	; 0x7860 <DigitOut+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7852:	a5 91       	lpm	r26, Z+
    7854:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7856:	fb 01       	movw	r30, r22
    7858:	64 91       	lpm	r22, Z
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    785a:	60 95       	com	r22
    785c:	4c 91       	ld	r20, X
    785e:	46 23       	and	r20, r22
    7860:	4c 93       	st	X, r20
		sei();
    7862:	78 94       	sei
    7864:	2f 5f       	subi	r18, 0xFF	; 255
    7866:	3f 4f       	sbci	r19, 0xFF	; 255
    7868:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    786a:	23 30       	cpi	r18, 0x03	; 3
    786c:	31 05       	cpc	r19, r1
    786e:	d1 f6       	brne	.-76     	; 0x7824 <DigitOut+0x18>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    7870:	08 95       	ret

00007872 <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    7872:	8e e0       	ldi	r24, 0x0E	; 14
    7874:	9d e4       	ldi	r25, 0x4D	; 77
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    7876:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7878:	fc 01       	movw	r30, r24
    787a:	a5 91       	lpm	r26, Z+
    787c:	b4 91       	lpm	r27, Z
    787e:	fc 01       	movw	r30, r24
    7880:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7882:	e4 91       	lpm	r30, Z
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    7884:	2c 91       	ld	r18, X
    7886:	2e 2b       	or	r18, r30
    7888:	2c 93       	st	X, r18
		sei();
    788a:	78 94       	sei
    788c:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    788e:	2d e4       	ldi	r18, 0x4D	; 77
    7890:	8d 31       	cpi	r24, 0x1D	; 29
    7892:	92 07       	cpc	r25, r18
    7894:	81 f7       	brne	.-32     	; 0x7876 <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    7896:	0c 94 06 3c 	jmp	0x780c	; 0x780c <DigitOut>

0000789a <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    789a:	28 2f       	mov	r18, r24
	uint16_t Pow = 1;
    789c:	81 e0       	ldi	r24, 0x01	; 1
    789e:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
		Pow *= 10;
    78a0:	3a e0       	ldi	r19, 0x0A	; 10
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    78a2:	21 50       	subi	r18, 0x01	; 1
    78a4:	38 f0       	brcs	.+14     	; 0x78b4 <Pow10+0x1a>
		Pow *= 10;
    78a6:	ac 01       	movw	r20, r24
    78a8:	34 9f       	mul	r19, r20
    78aa:	c0 01       	movw	r24, r0
    78ac:	35 9f       	mul	r19, r21
    78ae:	90 0d       	add	r25, r0
    78b0:	11 24       	eor	r1, r1
    78b2:	f7 cf       	rjmp	.-18     	; 0x78a2 <Pow10+0x8>
	return Pow;
}
    78b4:	08 95       	ret

000078b6 <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    78b6:	e8 2f       	mov	r30, r24
	uint32_t Pow = 1;
    78b8:	61 e0       	ldi	r22, 0x01	; 1
    78ba:	70 e0       	ldi	r23, 0x00	; 0
    78bc:	80 e0       	ldi	r24, 0x00	; 0
    78be:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
    78c0:	e1 50       	subi	r30, 0x01	; 1
    78c2:	38 f0       	brcs	.+14     	; 0x78d2 <PowL10+0x1c>
		Pow *= 10;
    78c4:	aa e0       	ldi	r26, 0x0A	; 10
    78c6:	b0 e0       	ldi	r27, 0x00	; 0
    78c8:	9b 01       	movw	r18, r22
    78ca:	ac 01       	movw	r20, r24
    78cc:	0e 94 29 75 	call	0xea52	; 0xea52 <__muluhisi3>
    78d0:	f7 cf       	rjmp	.-18     	; 0x78c0 <PowL10+0xa>
	return Pow;
}
    78d2:	08 95       	ret

000078d4 <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    78d4:	ff 92       	push	r15
    78d6:	0f 93       	push	r16
    78d8:	1f 93       	push	r17
    78da:	cf 93       	push	r28
    78dc:	df 93       	push	r29
    78de:	f8 2e       	mov	r15, r24
    78e0:	c0 e0       	ldi	r28, 0x00	; 0
    78e2:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    78e4:	06 2f       	mov	r16, r22
    78e6:	10 e0       	ldi	r17, 0x00	; 0

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    78e8:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    78ea:	8f 2d       	mov	r24, r15
    78ec:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <OW_MasterPullLowBus>
    78f0:	8a e1       	ldi	r24, 0x1A	; 26
    78f2:	8a 95       	dec	r24
    78f4:	f1 f7       	brne	.-4      	; 0x78f2 <OW_MasterTx_Command+0x1e>
    78f6:	00 c0       	rjmp	.+0      	; 0x78f8 <OW_MasterTx_Command+0x24>
		_delay_us(5);
		if(Command & (1<<i)){
    78f8:	98 01       	movw	r18, r16
    78fa:	0c 2e       	mov	r0, r28
    78fc:	02 c0       	rjmp	.+4      	; 0x7902 <OW_MasterTx_Command+0x2e>
    78fe:	35 95       	asr	r19
    7900:	27 95       	ror	r18
    7902:	0a 94       	dec	r0
    7904:	e2 f7       	brpl	.-8      	; 0x78fe <OW_MasterTx_Command+0x2a>
    7906:	20 ff       	sbrs	r18, 0
    7908:	0a c0       	rjmp	.+20     	; 0x791e <OW_MasterTx_Command+0x4a>
			OW_MasterReleaseBus(CH);
    790a:	8f 2d       	mov	r24, r15
    790c:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>
    7910:	83 e5       	ldi	r24, 0x53	; 83
    7912:	91 e0       	ldi	r25, 0x01	; 1
    7914:	01 97       	sbiw	r24, 0x01	; 1
    7916:	f1 f7       	brne	.-4      	; 0x7914 <OW_MasterTx_Command+0x40>
    7918:	00 c0       	rjmp	.+0      	; 0x791a <OW_MasterTx_Command+0x46>
    791a:	00 00       	nop
    791c:	07 c0       	rjmp	.+14     	; 0x792c <OW_MasterTx_Command+0x58>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    791e:	85 e5       	ldi	r24, 0x55	; 85
    7920:	90 e0       	ldi	r25, 0x00	; 0
    7922:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>
			OW_MasterReleaseBus(CH);
    7926:	8f 2d       	mov	r24, r15
    7928:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>
		}
		sei();
    792c:	78 94       	sei
    792e:	9a e1       	ldi	r25, 0x1A	; 26
    7930:	9a 95       	dec	r25
    7932:	f1 f7       	brne	.-4      	; 0x7930 <OW_MasterTx_Command+0x5c>
    7934:	00 c0       	rjmp	.+0      	; 0x7936 <OW_MasterTx_Command+0x62>
    7936:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    7938:	c8 30       	cpi	r28, 0x08	; 8
    793a:	d1 05       	cpc	r29, r1
    793c:	a9 f6       	brne	.-86     	; 0x78e8 <OW_MasterTx_Command+0x14>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    793e:	df 91       	pop	r29
    7940:	cf 91       	pop	r28
    7942:	1f 91       	pop	r17
    7944:	0f 91       	pop	r16
    7946:	ff 90       	pop	r15
    7948:	08 95       	ret

0000794a <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    794a:	ef 92       	push	r14
    794c:	ff 92       	push	r15
    794e:	0f 93       	push	r16
    7950:	1f 93       	push	r17
    7952:	cf 93       	push	r28
    7954:	df 93       	push	r29
    7956:	e8 2e       	mov	r14, r24
    7958:	c0 e0       	ldi	r28, 0x00	; 0
    795a:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	uint8_t Data = 0;
    795c:	f1 2c       	mov	r15, r1
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    795e:	01 e0       	ldi	r16, 0x01	; 1
    7960:	10 e0       	ldi	r17, 0x00	; 0
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    7962:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7964:	8e 2d       	mov	r24, r14
    7966:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <OW_MasterPullLowBus>
    796a:	8a e1       	ldi	r24, 0x1A	; 26
    796c:	8a 95       	dec	r24
    796e:	f1 f7       	brne	.-4      	; 0x796c <OW_MasterRx_Data+0x22>
    7970:	00 c0       	rjmp	.+0      	; 0x7972 <OW_MasterRx_Data+0x28>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    7972:	8e 2d       	mov	r24, r14
    7974:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>
    7978:	9a e1       	ldi	r25, 0x1A	; 26
    797a:	9a 95       	dec	r25
    797c:	f1 f7       	brne	.-4      	; 0x797a <OW_MasterRx_Data+0x30>
    797e:	00 c0       	rjmp	.+0      	; 0x7980 <OW_MasterRx_Data+0x36>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    7980:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    7984:	80 ff       	sbrs	r24, 0
    7986:	07 c0       	rjmp	.+14     	; 0x7996 <OW_MasterRx_Data+0x4c>
    7988:	98 01       	movw	r18, r16
    798a:	0c 2e       	mov	r0, r28
    798c:	01 c0       	rjmp	.+2      	; 0x7990 <OW_MasterRx_Data+0x46>
    798e:	22 0f       	add	r18, r18
    7990:	0a 94       	dec	r0
    7992:	ea f7       	brpl	.-6      	; 0x798e <OW_MasterRx_Data+0x44>
    7994:	f2 2a       	or	r15, r18
		sei();
    7996:	78 94       	sei
    7998:	8f ee       	ldi	r24, 0xEF	; 239
    799a:	90 e0       	ldi	r25, 0x00	; 0
    799c:	01 97       	sbiw	r24, 0x01	; 1
    799e:	f1 f7       	brne	.-4      	; 0x799c <OW_MasterRx_Data+0x52>
    79a0:	00 c0       	rjmp	.+0      	; 0x79a2 <OW_MasterRx_Data+0x58>
    79a2:	00 00       	nop
    79a4:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    79a6:	c8 30       	cpi	r28, 0x08	; 8
    79a8:	d1 05       	cpc	r29, r1
    79aa:	d9 f6       	brne	.-74     	; 0x7962 <OW_MasterRx_Data+0x18>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    79ac:	8f 2d       	mov	r24, r15
    79ae:	df 91       	pop	r29
    79b0:	cf 91       	pop	r28
    79b2:	1f 91       	pop	r17
    79b4:	0f 91       	pop	r16
    79b6:	ff 90       	pop	r15
    79b8:	ef 90       	pop	r14
    79ba:	08 95       	ret

000079bc <OneWire_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    79bc:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    79c0:	91 e0       	ldi	r25, 0x01	; 1
    79c2:	98 0f       	add	r25, r24
    79c4:	90 93 0f 01 	sts	0x010F, r25


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    79c8:	80 93 58 09 	sts	0x0958, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    79cc:	8a e0       	ldi	r24, 0x0A	; 10
    79ce:	80 93 f1 03 	sts	0x03F1, r24
    79d2:	08 95       	ret

000079d4 <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    79d4:	ff 92       	push	r15
    79d6:	0f 93       	push	r16
    79d8:	1f 93       	push	r17
    79da:	cf 93       	push	r28
    79dc:	df 93       	push	r29
    79de:	f8 2e       	mov	r15, r24
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    79e0:	08 2f       	mov	r16, r24
    79e2:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    79e4:	c8 01       	movw	r24, r16
    79e6:	83 5a       	subi	r24, 0xA3	; 163
    79e8:	9f 4f       	sbci	r25, 0xFF	; 255
    79ea:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    79ee:	e8 01       	movw	r28, r16
    79f0:	c0 52       	subi	r28, 0x20	; 32
    79f2:	d6 4f       	sbci	r29, 0xF6	; 246
    79f4:	81 11       	cpse	r24, r1
    79f6:	0c c0       	rjmp	.+24     	; 0x7a10 <OneWireStartADC+0x3c>
		Temperature[CH] = Therm_Off_Mark;
    79f8:	f8 01       	movw	r30, r16
    79fa:	ee 0f       	add	r30, r30
    79fc:	ff 1f       	adc	r31, r31
    79fe:	e4 51       	subi	r30, 0x14	; 20
    7a00:	fa 4f       	sbci	r31, 0xFA	; 250
    7a02:	80 e0       	ldi	r24, 0x00	; 0
    7a04:	90 e8       	ldi	r25, 0x80	; 128
    7a06:	91 83       	std	Z+1, r25	; 0x01
    7a08:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    7a0a:	82 e0       	ldi	r24, 0x02	; 2
    7a0c:	88 83       	st	Y, r24
		return;
    7a0e:	37 c0       	rjmp	.+110    	; 0x7a7e <OneWireStartADC+0xaa>
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7a10:	f8 94       	cli
    7a12:	8f 2d       	mov	r24, r15
    7a14:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <OW_MasterPullLowBus>
    7a18:	78 94       	sei
	Delay_us(580);	
    7a1a:	84 e4       	ldi	r24, 0x44	; 68
    7a1c:	92 e0       	ldi	r25, 0x02	; 2
    7a1e:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7a22:	f8 94       	cli
    7a24:	8f 2d       	mov	r24, r15
    7a26:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>
    7a2a:	87 e1       	ldi	r24, 0x17	; 23
    7a2c:	91 e0       	ldi	r25, 0x01	; 1
    7a2e:	01 97       	sbiw	r24, 0x01	; 1
    7a30:	f1 f7       	brne	.-4      	; 0x7a2e <OneWireStartADC+0x5a>
    7a32:	00 c0       	rjmp	.+0      	; 0x7a34 <OneWireStartADC+0x60>
    7a34:	00 00       	nop
    7a36:	80 91 63 00 	lds	r24, 0x0063
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    7a3a:	80 fd       	sbrc	r24, 0
    7a3c:	03 c0       	rjmp	.+6      	; 0x7a44 <OneWireStartADC+0x70>
    7a3e:	81 e0       	ldi	r24, 0x01	; 1
    7a40:	88 83       	st	Y, r24
    7a42:	08 c0       	rjmp	.+16     	; 0x7a54 <OneWireStartADC+0x80>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    7a44:	82 e0       	ldi	r24, 0x02	; 2
    7a46:	88 83       	st	Y, r24
		DS18B20_Error[CH]++;
    7a48:	f8 01       	movw	r30, r16
    7a4a:	ef 50       	subi	r30, 0x0F	; 15
    7a4c:	fc 4f       	sbci	r31, 0xFC	; 252
    7a4e:	80 81       	ld	r24, Z
    7a50:	8f 5f       	subi	r24, 0xFF	; 255
    7a52:	80 83       	st	Z, r24
	}
	sei();
    7a54:	78 94       	sei
	
	Delay_us(510);
    7a56:	8e ef       	ldi	r24, 0xFE	; 254
    7a58:	91 e0       	ldi	r25, 0x01	; 1
    7a5a:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7a5e:	88 81       	ld	r24, Y
    7a60:	82 30       	cpi	r24, 0x02	; 2
    7a62:	69 f0       	breq	.+26     	; 0x7a7e <OneWireStartADC+0xaa>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7a64:	6c ec       	ldi	r22, 0xCC	; 204
    7a66:	8f 2d       	mov	r24, r15
    7a68:	0e 94 6a 3c 	call	0x78d4	; 0x78d4 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7a6c:	64 e4       	ldi	r22, 0x44	; 68
    7a6e:	8f 2d       	mov	r24, r15
	}
}
    7a70:	df 91       	pop	r29
    7a72:	cf 91       	pop	r28
    7a74:	1f 91       	pop	r17
    7a76:	0f 91       	pop	r16
    7a78:	ff 90       	pop	r15
	
	Delay_us(510);

	if(DS18B20_Status[CH] != DS18B20_ERROR){
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7a7a:	0c 94 6a 3c 	jmp	0x78d4	; 0x78d4 <OW_MasterTx_Command>
	}
}
    7a7e:	df 91       	pop	r29
    7a80:	cf 91       	pop	r28
    7a82:	1f 91       	pop	r17
    7a84:	0f 91       	pop	r16
    7a86:	ff 90       	pop	r15
    7a88:	08 95       	ret

00007a8a <OneWireReadTemp>:
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    7a8a:	8f 92       	push	r8
    7a8c:	9f 92       	push	r9
    7a8e:	af 92       	push	r10
    7a90:	bf 92       	push	r11
    7a92:	cf 92       	push	r12
    7a94:	df 92       	push	r13
    7a96:	ef 92       	push	r14
    7a98:	ff 92       	push	r15
    7a9a:	1f 93       	push	r17
    7a9c:	cf 93       	push	r28
    7a9e:	df 93       	push	r29
    7aa0:	18 2f       	mov	r17, r24
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    7aa2:	c8 2f       	mov	r28, r24
    7aa4:	d0 e0       	ldi	r29, 0x00	; 0
    7aa6:	ce 01       	movw	r24, r28
    7aa8:	83 5a       	subi	r24, 0xA3	; 163
    7aaa:	9f 4f       	sbci	r25, 0xFF	; 255
    7aac:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    7ab0:	9e 01       	movw	r18, r28
    7ab2:	20 52       	subi	r18, 0x20	; 32
    7ab4:	36 4f       	sbci	r19, 0xF6	; 246
    7ab6:	79 01       	movw	r14, r18
    7ab8:	fe 01       	movw	r30, r28
    7aba:	ef 50       	subi	r30, 0x0F	; 15
    7abc:	fc 4f       	sbci	r31, 0xFC	; 252
    7abe:	81 11       	cpse	r24, r1
    7ac0:	0c c0       	rjmp	.+24     	; 0x7ada <OneWireReadTemp+0x50>
		Temperature[CH] = Therm_Off_Mark;
    7ac2:	cc 0f       	add	r28, r28
    7ac4:	dd 1f       	adc	r29, r29
    7ac6:	c4 51       	subi	r28, 0x14	; 20
    7ac8:	da 4f       	sbci	r29, 0xFA	; 250
    7aca:	80 e0       	ldi	r24, 0x00	; 0
    7acc:	90 e8       	ldi	r25, 0x80	; 128
    7ace:	99 83       	std	Y+1, r25	; 0x01
    7ad0:	88 83       	st	Y, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    7ad2:	d7 01       	movw	r26, r14
    7ad4:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    7ad6:	10 82       	st	Z, r1
		return;
    7ad8:	a0 c0       	rjmp	.+320    	; 0x7c1a <OneWireReadTemp+0x190>
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    7ada:	d9 01       	movw	r26, r18
    7adc:	8c 91       	ld	r24, X
    7ade:	82 30       	cpi	r24, 0x02	; 2
    7ae0:	79 f4       	brne	.+30     	; 0x7b00 <OneWireReadTemp+0x76>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    7ae2:	80 81       	ld	r24, Z
    7ae4:	8a 30       	cpi	r24, 0x0A	; 10
    7ae6:	48 f0       	brcs	.+18     	; 0x7afa <OneWireReadTemp+0x70>
    7ae8:	cc 0f       	add	r28, r28
    7aea:	dd 1f       	adc	r29, r29
    7aec:	c4 51       	subi	r28, 0x14	; 20
    7aee:	da 4f       	sbci	r29, 0xFA	; 250
    7af0:	81 e0       	ldi	r24, 0x01	; 1
    7af2:	90 e8       	ldi	r25, 0x80	; 128
    7af4:	99 83       	std	Y+1, r25	; 0x01
    7af6:	88 83       	st	Y, r24
    7af8:	90 c0       	rjmp	.+288    	; 0x7c1a <OneWireReadTemp+0x190>
		else DS18B20_Error[CH]++;
    7afa:	8f 5f       	subi	r24, 0xFF	; 255
    7afc:	80 83       	st	Z, r24
    7afe:	8d c0       	rjmp	.+282    	; 0x7c1a <OneWireReadTemp+0x190>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    7b00:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7b02:	f8 94       	cli
    7b04:	81 2f       	mov	r24, r17
    7b06:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <OW_MasterPullLowBus>
    7b0a:	78 94       	sei
	Delay_us(580);
    7b0c:	84 e4       	ldi	r24, 0x44	; 68
    7b0e:	92 e0       	ldi	r25, 0x02	; 2
    7b10:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7b14:	f8 94       	cli
    7b16:	81 2f       	mov	r24, r17
    7b18:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    7b1c:	86 e4       	ldi	r24, 0x46	; 70
    7b1e:	90 e0       	ldi	r25, 0x00	; 0
    7b20:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>
    7b24:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    7b28:	80 ff       	sbrs	r24, 0
    7b2a:	03 c0       	rjmp	.+6      	; 0x7b32 <OneWireReadTemp+0xa8>
    7b2c:	82 e0       	ldi	r24, 0x02	; 2
    7b2e:	f7 01       	movw	r30, r14
    7b30:	80 83       	st	Z, r24
	sei();
    7b32:	78 94       	sei
	Delay_us(510);
    7b34:	8e ef       	ldi	r24, 0xFE	; 254
    7b36:	91 e0       	ldi	r25, 0x01	; 1
    7b38:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7b3c:	d7 01       	movw	r26, r14
    7b3e:	8c 91       	ld	r24, X
    7b40:	82 30       	cpi	r24, 0x02	; 2
    7b42:	09 f4       	brne	.+2      	; 0x7b46 <OneWireReadTemp+0xbc>
    7b44:	6a c0       	rjmp	.+212    	; 0x7c1a <OneWireReadTemp+0x190>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7b46:	6c ec       	ldi	r22, 0xCC	; 204
    7b48:	81 2f       	mov	r24, r17
    7b4a:	0e 94 6a 3c 	call	0x78d4	; 0x78d4 <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    7b4e:	6e eb       	ldi	r22, 0xBE	; 190
    7b50:	81 2f       	mov	r24, r17
    7b52:	0e 94 6a 3c 	call	0x78d4	; 0x78d4 <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    7b56:	81 2f       	mov	r24, r17
    7b58:	0e 94 a5 3c 	call	0x794a	; 0x794a <OW_MasterRx_Data>
    7b5c:	e8 2e       	mov	r14, r24
    7b5e:	f1 2c       	mov	r15, r1
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    7b60:	81 2f       	mov	r24, r17
    7b62:	0e 94 a5 3c 	call	0x794a	; 0x794a <OW_MasterRx_Data>
    7b66:	f8 2a       	or	r15, r24
		Tres = (Tres*10)/16;
    7b68:	8a e0       	ldi	r24, 0x0A	; 10
    7b6a:	8e 9d       	mul	r24, r14
    7b6c:	b0 01       	movw	r22, r0
    7b6e:	8f 9d       	mul	r24, r15
    7b70:	70 0d       	add	r23, r0
    7b72:	11 24       	eor	r1, r1
    7b74:	77 ff       	sbrs	r23, 7
    7b76:	02 c0       	rjmp	.+4      	; 0x7b7c <OneWireReadTemp+0xf2>
    7b78:	61 5f       	subi	r22, 0xF1	; 241
    7b7a:	7f 4f       	sbci	r23, 0xFF	; 255
    7b7c:	4b 01       	movw	r8, r22
    7b7e:	94 e0       	ldi	r25, 0x04	; 4
    7b80:	95 94       	asr	r9
    7b82:	87 94       	ror	r8
    7b84:	9a 95       	dec	r25
    7b86:	e1 f7       	brne	.-8      	; 0x7b80 <OneWireReadTemp+0xf6>
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    7b88:	b2 e5       	ldi	r27, 0x52	; 82
    7b8a:	8b 16       	cp	r8, r27
    7b8c:	b3 e0       	ldi	r27, 0x03	; 3
    7b8e:	9b 06       	cpc	r9, r27
    7b90:	b1 f1       	breq	.+108    	; 0x7bfe <OneWireReadTemp+0x174>
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    7b92:	7e 01       	movw	r14, r28
    7b94:	ee 0c       	add	r14, r14
    7b96:	ff 1c       	adc	r15, r15
    7b98:	ce 0d       	add	r28, r14
    7b9a:	df 1d       	adc	r29, r15
    7b9c:	ce 01       	movw	r24, r28
    7b9e:	86 5a       	subi	r24, 0xA6	; 166
    7ba0:	9f 4f       	sbci	r25, 0xFF	; 255
    7ba2:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    7ba6:	d8 2e       	mov	r13, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    7ba8:	ce 01       	movw	r24, r28
    7baa:	85 5a       	subi	r24, 0xA5	; 165
    7bac:	9f 4f       	sbci	r25, 0xFF	; 255
    7bae:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    7bb2:	5c 01       	movw	r10, r24
    7bb4:	e7 01       	movw	r28, r14
    7bb6:	c4 51       	subi	r28, 0x14	; 20
    7bb8:	da 4f       	sbci	r29, 0xFA	; 250
    7bba:	b4 01       	movw	r22, r8
    7bbc:	6d 0d       	add	r22, r13
    7bbe:	71 1d       	adc	r23, r1
    7bc0:	d7 fc       	sbrc	r13, 7
    7bc2:	7a 95       	dec	r23
    7bc4:	88 27       	eor	r24, r24
    7bc6:	77 fd       	sbrc	r23, 7
    7bc8:	80 95       	com	r24
    7bca:	98 2f       	mov	r25, r24
    7bcc:	0e 94 a0 6d 	call	0xdb40	; 0xdb40 <__floatsisf>
    7bd0:	6b 01       	movw	r12, r22
    7bd2:	7c 01       	movw	r14, r24
    7bd4:	b5 01       	movw	r22, r10
    7bd6:	80 e0       	ldi	r24, 0x00	; 0
    7bd8:	90 e0       	ldi	r25, 0x00	; 0
    7bda:	0e 94 9e 6d 	call	0xdb3c	; 0xdb3c <__floatunsisf>
    7bde:	20 e0       	ldi	r18, 0x00	; 0
    7be0:	30 e0       	ldi	r19, 0x00	; 0
    7be2:	4a e7       	ldi	r20, 0x7A	; 122
    7be4:	54 e4       	ldi	r21, 0x44	; 68
    7be6:	0e 94 05 6d 	call	0xda0a	; 0xda0a <__divsf3>
    7bea:	9b 01       	movw	r18, r22
    7bec:	ac 01       	movw	r20, r24
    7bee:	c7 01       	movw	r24, r14
    7bf0:	b6 01       	movw	r22, r12
    7bf2:	0e 94 2c 6e 	call	0xdc58	; 0xdc58 <__mulsf3>
    7bf6:	0e 94 6d 6d 	call	0xdada	; 0xdada <__fixsfsi>
    7bfa:	79 83       	std	Y+1, r23	; 0x01
    7bfc:	68 83       	st	Y, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    7bfe:	f8 94       	cli
    7c00:	81 2f       	mov	r24, r17
    7c02:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <OW_MasterPullLowBus>
    7c06:	78 94       	sei
		Delay_us(580);	
    7c08:	84 e4       	ldi	r24, 0x44	; 68
    7c0a:	92 e0       	ldi	r25, 0x02	; 2
    7c0c:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    7c10:	f8 94       	cli
    7c12:	81 2f       	mov	r24, r17
    7c14:	0e 94 8a 2e 	call	0x5d14	; 0x5d14 <OW_MasterReleaseBus>
    7c18:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    7c1a:	df 91       	pop	r29
    7c1c:	cf 91       	pop	r28
    7c1e:	1f 91       	pop	r17
    7c20:	ff 90       	pop	r15
    7c22:	ef 90       	pop	r14
    7c24:	df 90       	pop	r13
    7c26:	cf 90       	pop	r12
    7c28:	bf 90       	pop	r11
    7c2a:	af 90       	pop	r10
    7c2c:	9f 90       	pop	r9
    7c2e:	8f 90       	pop	r8
    7c30:	08 95       	ret

00007c32 <DS18B20>:
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    7c32:	80 91 58 09 	lds	r24, 0x0958
    7c36:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    7c3a:	88 23       	and	r24, r24
    7c3c:	11 f1       	breq	.+68     	; 0x7c82 <DS18B20+0x50>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    7c3e:	80 91 50 02 	lds	r24, 0x0250
    7c42:	87 30       	cpi	r24, 0x07	; 7
    7c44:	18 f0       	brcs	.+6      	; 0x7c4c <DS18B20+0x1a>
    7c46:	81 e0       	ldi	r24, 0x01	; 1
    7c48:	80 93 50 02 	sts	0x0250, r24
		
			switch(DS18B20_Mode){
    7c4c:	80 91 50 02 	lds	r24, 0x0250
    7c50:	81 30       	cpi	r24, 0x01	; 1
    7c52:	39 f0       	breq	.+14     	; 0x7c62 <DS18B20+0x30>
    7c54:	84 30       	cpi	r24, 0x04	; 4
    7c56:	81 f4       	brne	.+32     	; 0x7c78 <DS18B20+0x46>
				StartTimer8(TD_DS18B20Read, 100);
				DS18B20_Mode = DS18B20_START_ADC3;
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    7c58:	80 e0       	ldi	r24, 0x00	; 0
    7c5a:	0e 94 45 3d 	call	0x7a8a	; 0x7a8a <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    7c5e:	86 e0       	ldi	r24, 0x06	; 6
    7c60:	09 c0       	rjmp	.+18     	; 0x7c74 <DS18B20+0x42>
			switch(DS18B20_Mode){
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    7c62:	80 e0       	ldi	r24, 0x00	; 0
    7c64:	0e 94 ea 3c 	call	0x79d4	; 0x79d4 <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    7c68:	64 e6       	ldi	r22, 0x64	; 100
    7c6a:	80 91 58 09 	lds	r24, 0x0958
    7c6e:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    7c72:	83 e0       	ldi	r24, 0x03	; 3
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
				DS18B20_Mode = DS18B20_READ_T3;
    7c74:	80 93 50 02 	sts	0x0250, r24
				break;
			}
			DS18B20_Mode++;
    7c78:	80 91 50 02 	lds	r24, 0x0250
    7c7c:	8f 5f       	subi	r24, 0xFF	; 255
    7c7e:	80 93 50 02 	sts	0x0250, r24
    7c82:	08 95       	ret

00007c84 <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7c84:	cf 93       	push	r28
    7c86:	df 93       	push	r29
    7c88:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7c8a:	ec 81       	ldd	r30, Y+4	; 0x04
    7c8c:	fd 81       	ldd	r31, Y+5	; 0x05
    7c8e:	65 91       	lpm	r22, Z+
    7c90:	74 91       	lpm	r23, Z
	strcpy_P(Param->Pos, prp(Param->Txt));
    7c92:	88 81       	ld	r24, Y
    7c94:	99 81       	ldd	r25, Y+1	; 0x01
    7c96:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7c9a:	a8 81       	ld	r26, Y
    7c9c:	b9 81       	ldd	r27, Y+1	; 0x01
    7c9e:	fd 01       	movw	r30, r26
    7ca0:	01 90       	ld	r0, Z+
    7ca2:	00 20       	and	r0, r0
    7ca4:	e9 f7       	brne	.-6      	; 0x7ca0 <PutEnum+0x1c>
    7ca6:	31 97       	sbiw	r30, 0x01	; 1
    7ca8:	4e 2f       	mov	r20, r30
    7caa:	4a 1b       	sub	r20, r26
    7cac:	80 e0       	ldi	r24, 0x00	; 0
    7cae:	90 e0       	ldi	r25, 0x00	; 0
    7cb0:	50 e2       	ldi	r21, 0x20	; 32
    7cb2:	24 2f       	mov	r18, r20
    7cb4:	28 0f       	add	r18, r24
    7cb6:	01 96       	adiw	r24, 0x01	; 1
    7cb8:	3b 81       	ldd	r19, Y+3	; 0x03
    7cba:	23 17       	cp	r18, r19
    7cbc:	30 f4       	brcc	.+12     	; 0x7cca <PutEnum+0x46>
    7cbe:	e8 81       	ld	r30, Y
    7cc0:	f9 81       	ldd	r31, Y+1	; 0x01
    7cc2:	e2 0f       	add	r30, r18
    7cc4:	f1 1d       	adc	r31, r1
    7cc6:	50 83       	st	Z, r21
    7cc8:	f4 cf       	rjmp	.-24     	; 0x7cb2 <PutEnum+0x2e>
}
    7cca:	df 91       	pop	r29
    7ccc:	cf 91       	pop	r28
    7cce:	08 95       	ret

00007cd0 <PutVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    7cd0:	cf 92       	push	r12
    7cd2:	df 92       	push	r13
    7cd4:	ef 92       	push	r14
    7cd6:	ff 92       	push	r15
    7cd8:	0f 93       	push	r16
    7cda:	1f 93       	push	r17
    7cdc:	cf 93       	push	r28
    7cde:	df 93       	push	r29
    7ce0:	cd b7       	in	r28, 0x3d	; 61
    7ce2:	de b7       	in	r29, 0x3e	; 62
    7ce4:	29 97       	sbiw	r28, 0x09	; 9
    7ce6:	0f b6       	in	r0, 0x3f	; 63
    7ce8:	f8 94       	cli
    7cea:	de bf       	out	0x3e, r29	; 62
    7cec:	0f be       	out	0x3f, r0	; 63
    7cee:	cd bf       	out	0x3d, r28	; 61
    7cf0:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7cf2:	67 37       	cpi	r22, 0x77	; 119
    7cf4:	19 f4       	brne	.+6      	; 0x7cfc <PutVal+0x2c>
    7cf6:	8f ef       	ldi	r24, 0xFF	; 255
    7cf8:	9f ef       	ldi	r25, 0xFF	; 255
    7cfa:	02 c0       	rjmp	.+4      	; 0x7d00 <PutVal+0x30>
    7cfc:	8f ef       	ldi	r24, 0xFF	; 255
    7cfe:	90 e0       	ldi	r25, 0x00	; 0
    7d00:	8e 19       	sub	r24, r14
    7d02:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7d04:	fa 01       	movw	r30, r20
    7d06:	24 81       	ldd	r18, Z+4	; 0x04
    7d08:	35 81       	ldd	r19, Z+5	; 0x05
    7d0a:	21 15       	cp	r18, r1
    7d0c:	31 05       	cpc	r19, r1
    7d0e:	69 f0       	breq	.+26     	; 0x7d2a <PutVal+0x5a>
    7d10:	82 30       	cpi	r24, 0x02	; 2
    7d12:	91 05       	cpc	r25, r1
    7d14:	50 f4       	brcc	.+20     	; 0x7d2a <PutVal+0x5a>
		Param->Txt += Idx;
    7d16:	88 0f       	add	r24, r24
    7d18:	99 1f       	adc	r25, r25
    7d1a:	82 0f       	add	r24, r18
    7d1c:	93 1f       	adc	r25, r19
    7d1e:	95 83       	std	Z+5, r25	; 0x05
    7d20:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7d22:	ca 01       	movw	r24, r20
    7d24:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
    7d28:	3f c0       	rjmp	.+126    	; 0x7da8 <PutVal+0xd8>
		return;
	}
	char Format[] = "% u.%. u";
    7d2a:	89 e0       	ldi	r24, 0x09	; 9
    7d2c:	e3 e1       	ldi	r30, 0x13	; 19
    7d2e:	f1 e0       	ldi	r31, 0x01	; 1
    7d30:	8e 01       	movw	r16, r28
    7d32:	0f 5f       	subi	r16, 0xFF	; 255
    7d34:	1f 4f       	sbci	r17, 0xFF	; 255
    7d36:	d8 01       	movw	r26, r16
    7d38:	01 90       	ld	r0, Z+
    7d3a:	0d 92       	st	X+, r0
    7d3c:	8a 95       	dec	r24
    7d3e:	e1 f7       	brne	.-8      	; 0x7d38 <PutVal+0x68>
	Format[1] = '0'+Param->Size;
    7d40:	fa 01       	movw	r30, r20
    7d42:	93 81       	ldd	r25, Z+3	; 0x03
    7d44:	90 5d       	subi	r25, 0xD0	; 208
    7d46:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    7d48:	82 81       	ldd	r24, Z+2	; 0x02
    7d4a:	c1 80       	ldd	r12, Z+1	; 0x01
    7d4c:	d0 80       	ld	r13, Z
    7d4e:	88 23       	and	r24, r24
    7d50:	e1 f0       	breq	.+56     	; 0x7d8a <PutVal+0xba>
		Format[1] -= Param->Prec+1;
    7d52:	98 1b       	sub	r25, r24
    7d54:	91 50       	subi	r25, 0x01	; 1
    7d56:	9a 83       	std	Y+2, r25	; 0x02
		Format[6] = '0'+Param->Prec;
    7d58:	90 e3       	ldi	r25, 0x30	; 48
    7d5a:	98 0f       	add	r25, r24
    7d5c:	9f 83       	std	Y+7, r25	; 0x07
		uint16_t Div=Pow10(Param->Prec);
    7d5e:	0e 94 4d 3c 	call	0x789a	; 0x789a <Pow10>
    7d62:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7d64:	c7 01       	movw	r24, r14
    7d66:	0e 94 ba 74 	call	0xe974	; 0xe974 <__udivmodhi4>
    7d6a:	9f 93       	push	r25
    7d6c:	8f 93       	push	r24
    7d6e:	7f 93       	push	r23
    7d70:	6f 93       	push	r22
    7d72:	1f 93       	push	r17
    7d74:	0f 93       	push	r16
    7d76:	cf 92       	push	r12
    7d78:	df 92       	push	r13
    7d7a:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    7d7e:	0f b6       	in	r0, 0x3f	; 63
    7d80:	f8 94       	cli
    7d82:	de bf       	out	0x3e, r29	; 62
    7d84:	0f be       	out	0x3f, r0	; 63
    7d86:	cd bf       	out	0x3d, r28	; 61
    7d88:	0f c0       	rjmp	.+30     	; 0x7da8 <PutVal+0xd8>
	}
	else {
		Format[3] = '\0';
    7d8a:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    7d8c:	ff 92       	push	r15
    7d8e:	ef 92       	push	r14
    7d90:	1f 93       	push	r17
    7d92:	0f 93       	push	r16
    7d94:	cf 92       	push	r12
    7d96:	df 92       	push	r13
    7d98:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    7d9c:	0f 90       	pop	r0
    7d9e:	0f 90       	pop	r0
    7da0:	0f 90       	pop	r0
    7da2:	0f 90       	pop	r0
    7da4:	0f 90       	pop	r0
    7da6:	0f 90       	pop	r0
	}
}
    7da8:	29 96       	adiw	r28, 0x09	; 9
    7daa:	0f b6       	in	r0, 0x3f	; 63
    7dac:	f8 94       	cli
    7dae:	de bf       	out	0x3e, r29	; 62
    7db0:	0f be       	out	0x3f, r0	; 63
    7db2:	cd bf       	out	0x3d, r28	; 61
    7db4:	df 91       	pop	r29
    7db6:	cf 91       	pop	r28
    7db8:	1f 91       	pop	r17
    7dba:	0f 91       	pop	r16
    7dbc:	ff 90       	pop	r15
    7dbe:	ef 90       	pop	r14
    7dc0:	df 90       	pop	r13
    7dc2:	cf 90       	pop	r12
    7dc4:	08 95       	ret

00007dc6 <Put_sVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    7dc6:	af 92       	push	r10
    7dc8:	bf 92       	push	r11
    7dca:	cf 92       	push	r12
    7dcc:	df 92       	push	r13
    7dce:	ef 92       	push	r14
    7dd0:	ff 92       	push	r15
    7dd2:	0f 93       	push	r16
    7dd4:	1f 93       	push	r17
    7dd6:	cf 93       	push	r28
    7dd8:	df 93       	push	r29
    7dda:	cd b7       	in	r28, 0x3d	; 61
    7ddc:	de b7       	in	r29, 0x3e	; 62
    7dde:	2a 97       	sbiw	r28, 0x0a	; 10
    7de0:	0f b6       	in	r0, 0x3f	; 63
    7de2:	f8 94       	cli
    7de4:	de bf       	out	0x3e, r29	; 62
    7de6:	0f be       	out	0x3f, r0	; 63
    7de8:	cd bf       	out	0x3d, r28	; 61
    7dea:	7c 01       	movw	r14, r24
    7dec:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    7dee:	67 37       	cpi	r22, 0x77	; 119
    7df0:	19 f4       	brne	.+6      	; 0x7df8 <Put_sVal+0x32>
    7df2:	80 e0       	ldi	r24, 0x00	; 0
    7df4:	90 e8       	ldi	r25, 0x80	; 128
    7df6:	02 c0       	rjmp	.+4      	; 0x7dfc <Put_sVal+0x36>
    7df8:	80 e8       	ldi	r24, 0x80	; 128
    7dfa:	90 e0       	ldi	r25, 0x00	; 0
    7dfc:	8e 0d       	add	r24, r14
    7dfe:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    7e00:	d8 01       	movw	r26, r16
    7e02:	14 96       	adiw	r26, 0x04	; 4
    7e04:	2d 91       	ld	r18, X+
    7e06:	3c 91       	ld	r19, X
    7e08:	15 97       	sbiw	r26, 0x05	; 5
    7e0a:	21 15       	cp	r18, r1
    7e0c:	31 05       	cpc	r19, r1
    7e0e:	79 f0       	breq	.+30     	; 0x7e2e <Put_sVal+0x68>
    7e10:	82 30       	cpi	r24, 0x02	; 2
    7e12:	91 05       	cpc	r25, r1
    7e14:	60 f4       	brcc	.+24     	; 0x7e2e <Put_sVal+0x68>
		Param->Txt += Idx;
    7e16:	88 0f       	add	r24, r24
    7e18:	99 1f       	adc	r25, r25
    7e1a:	82 0f       	add	r24, r18
    7e1c:	93 1f       	adc	r25, r19
    7e1e:	15 96       	adiw	r26, 0x05	; 5
    7e20:	9c 93       	st	X, r25
    7e22:	8e 93       	st	-X, r24
    7e24:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    7e26:	c8 01       	movw	r24, r16
    7e28:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
    7e2c:	65 c0       	rjmp	.+202    	; 0x7ef8 <Put_sVal+0x132>
		return;
	}
	char Format[] = "%+ d.%. u";
    7e2e:	8a e0       	ldi	r24, 0x0A	; 10
    7e30:	ec e1       	ldi	r30, 0x1C	; 28
    7e32:	f1 e0       	ldi	r31, 0x01	; 1
    7e34:	9e 01       	movw	r18, r28
    7e36:	2f 5f       	subi	r18, 0xFF	; 255
    7e38:	3f 4f       	sbci	r19, 0xFF	; 255
    7e3a:	69 01       	movw	r12, r18
    7e3c:	d9 01       	movw	r26, r18
    7e3e:	01 90       	ld	r0, Z+
    7e40:	0d 92       	st	X+, r0
    7e42:	8a 95       	dec	r24
    7e44:	e1 f7       	brne	.-8      	; 0x7e3e <Put_sVal+0x78>
	if(Val==0)
    7e46:	e1 14       	cp	r14, r1
    7e48:	f1 04       	cpc	r15, r1
    7e4a:	11 f4       	brne	.+4      	; 0x7e50 <Put_sVal+0x8a>
		Format[1] = ' ';
    7e4c:	80 e2       	ldi	r24, 0x20	; 32
    7e4e:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    7e50:	d8 01       	movw	r26, r16
    7e52:	13 96       	adiw	r26, 0x03	; 3
    7e54:	9c 91       	ld	r25, X
    7e56:	13 97       	sbiw	r26, 0x03	; 3
    7e58:	90 5d       	subi	r25, 0xD0	; 208
    7e5a:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7e5c:	12 96       	adiw	r26, 0x02	; 2
    7e5e:	8c 91       	ld	r24, X
    7e60:	12 97       	sbiw	r26, 0x02	; 2
    7e62:	11 96       	adiw	r26, 0x01	; 1
    7e64:	ac 90       	ld	r10, X
    7e66:	11 97       	sbiw	r26, 0x01	; 1
    7e68:	bc 90       	ld	r11, X
    7e6a:	88 23       	and	r24, r24
    7e6c:	b1 f1       	breq	.+108    	; 0x7eda <Put_sVal+0x114>
		Format[2] -= Param->Prec+1;
    7e6e:	98 1b       	sub	r25, r24
    7e70:	91 50       	subi	r25, 0x01	; 1
    7e72:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7e74:	90 e3       	ldi	r25, 0x30	; 48
    7e76:	98 0f       	add	r25, r24
    7e78:	98 87       	std	Y+8, r25	; 0x08
		int16_t Div=Pow10(Param->Prec);
    7e7a:	0e 94 4d 3c 	call	0x789a	; 0x789a <Pow10>
    7e7e:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    7e80:	c7 01       	movw	r24, r14
    7e82:	f7 fe       	sbrs	r15, 7
    7e84:	04 c0       	rjmp	.+8      	; 0x7e8e <Put_sVal+0xc8>
    7e86:	88 27       	eor	r24, r24
    7e88:	99 27       	eor	r25, r25
    7e8a:	8e 19       	sub	r24, r14
    7e8c:	9f 09       	sbc	r25, r15
    7e8e:	b9 01       	movw	r22, r18
    7e90:	0e 94 ba 74 	call	0xe974	; 0xe974 <__udivmodhi4>
    7e94:	9f 93       	push	r25
    7e96:	8f 93       	push	r24
    7e98:	c7 01       	movw	r24, r14
    7e9a:	b9 01       	movw	r22, r18
    7e9c:	0e 94 ce 74 	call	0xe99c	; 0xe99c <__divmodhi4>
    7ea0:	7f 93       	push	r23
    7ea2:	6f 93       	push	r22
    7ea4:	df 92       	push	r13
    7ea6:	cf 92       	push	r12
    7ea8:	af 92       	push	r10
    7eaa:	bf 92       	push	r11
    7eac:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
		if(Val<0) {
    7eb0:	0f b6       	in	r0, 0x3f	; 63
    7eb2:	f8 94       	cli
    7eb4:	de bf       	out	0x3e, r29	; 62
    7eb6:	0f be       	out	0x3f, r0	; 63
    7eb8:	cd bf       	out	0x3d, r28	; 61
    7eba:	f7 fe       	sbrs	r15, 7
    7ebc:	1d c0       	rjmp	.+58     	; 0x7ef8 <Put_sVal+0x132>
			while(*Param->Pos==' ')
    7ebe:	d8 01       	movw	r26, r16
    7ec0:	ed 91       	ld	r30, X+
    7ec2:	fc 91       	ld	r31, X
    7ec4:	80 81       	ld	r24, Z
    7ec6:	80 32       	cpi	r24, 0x20	; 32
    7ec8:	29 f4       	brne	.+10     	; 0x7ed4 <Put_sVal+0x10e>
				Param->Pos++;
    7eca:	31 96       	adiw	r30, 0x01	; 1
    7ecc:	d8 01       	movw	r26, r16
    7ece:	ed 93       	st	X+, r30
    7ed0:	fc 93       	st	X, r31
    7ed2:	f5 cf       	rjmp	.-22     	; 0x7ebe <Put_sVal+0xf8>
			*Param->Pos = '-';
    7ed4:	8d e2       	ldi	r24, 0x2D	; 45
    7ed6:	80 83       	st	Z, r24
    7ed8:	0f c0       	rjmp	.+30     	; 0x7ef8 <Put_sVal+0x132>
		}
	}
	else {
		Format[4] = '\0';
    7eda:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7edc:	ff 92       	push	r15
    7ede:	ef 92       	push	r14
    7ee0:	df 92       	push	r13
    7ee2:	cf 92       	push	r12
    7ee4:	af 92       	push	r10
    7ee6:	bf 92       	push	r11
    7ee8:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    7eec:	0f 90       	pop	r0
    7eee:	0f 90       	pop	r0
    7ef0:	0f 90       	pop	r0
    7ef2:	0f 90       	pop	r0
    7ef4:	0f 90       	pop	r0
    7ef6:	0f 90       	pop	r0
	}
}
    7ef8:	2a 96       	adiw	r28, 0x0a	; 10
    7efa:	0f b6       	in	r0, 0x3f	; 63
    7efc:	f8 94       	cli
    7efe:	de bf       	out	0x3e, r29	; 62
    7f00:	0f be       	out	0x3f, r0	; 63
    7f02:	cd bf       	out	0x3d, r28	; 61
    7f04:	df 91       	pop	r29
    7f06:	cf 91       	pop	r28
    7f08:	1f 91       	pop	r17
    7f0a:	0f 91       	pop	r16
    7f0c:	ff 90       	pop	r15
    7f0e:	ef 90       	pop	r14
    7f10:	df 90       	pop	r13
    7f12:	cf 90       	pop	r12
    7f14:	bf 90       	pop	r11
    7f16:	af 90       	pop	r10
    7f18:	08 95       	ret

00007f1a <Put_zVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    7f1a:	cf 92       	push	r12
    7f1c:	df 92       	push	r13
    7f1e:	ef 92       	push	r14
    7f20:	ff 92       	push	r15
    7f22:	0f 93       	push	r16
    7f24:	1f 93       	push	r17
    7f26:	cf 93       	push	r28
    7f28:	df 93       	push	r29
    7f2a:	cd b7       	in	r28, 0x3d	; 61
    7f2c:	de b7       	in	r29, 0x3e	; 62
    7f2e:	2a 97       	sbiw	r28, 0x0a	; 10
    7f30:	0f b6       	in	r0, 0x3f	; 63
    7f32:	f8 94       	cli
    7f34:	de bf       	out	0x3e, r29	; 62
    7f36:	0f be       	out	0x3f, r0	; 63
    7f38:	cd bf       	out	0x3d, r28	; 61
    7f3a:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7f3c:	67 37       	cpi	r22, 0x77	; 119
    7f3e:	19 f4       	brne	.+6      	; 0x7f46 <Put_zVal+0x2c>
    7f40:	8f ef       	ldi	r24, 0xFF	; 255
    7f42:	9f ef       	ldi	r25, 0xFF	; 255
    7f44:	02 c0       	rjmp	.+4      	; 0x7f4a <Put_zVal+0x30>
    7f46:	8f ef       	ldi	r24, 0xFF	; 255
    7f48:	90 e0       	ldi	r25, 0x00	; 0
    7f4a:	8e 19       	sub	r24, r14
    7f4c:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7f4e:	fa 01       	movw	r30, r20
    7f50:	24 81       	ldd	r18, Z+4	; 0x04
    7f52:	35 81       	ldd	r19, Z+5	; 0x05
    7f54:	21 15       	cp	r18, r1
    7f56:	31 05       	cpc	r19, r1
    7f58:	69 f0       	breq	.+26     	; 0x7f74 <Put_zVal+0x5a>
    7f5a:	82 30       	cpi	r24, 0x02	; 2
    7f5c:	91 05       	cpc	r25, r1
    7f5e:	50 f4       	brcc	.+20     	; 0x7f74 <Put_zVal+0x5a>
		Param->Txt += Idx;
    7f60:	88 0f       	add	r24, r24
    7f62:	99 1f       	adc	r25, r25
    7f64:	82 0f       	add	r24, r18
    7f66:	93 1f       	adc	r25, r19
    7f68:	95 83       	std	Z+5, r25	; 0x05
    7f6a:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7f6c:	ca 01       	movw	r24, r20
    7f6e:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
    7f72:	3f c0       	rjmp	.+126    	; 0x7ff2 <Put_zVal+0xd8>
		return;
	}
	char Format[] = "%0 u.%. u";
    7f74:	8a e0       	ldi	r24, 0x0A	; 10
    7f76:	e6 e2       	ldi	r30, 0x26	; 38
    7f78:	f1 e0       	ldi	r31, 0x01	; 1
    7f7a:	8e 01       	movw	r16, r28
    7f7c:	0f 5f       	subi	r16, 0xFF	; 255
    7f7e:	1f 4f       	sbci	r17, 0xFF	; 255
    7f80:	d8 01       	movw	r26, r16
    7f82:	01 90       	ld	r0, Z+
    7f84:	0d 92       	st	X+, r0
    7f86:	8a 95       	dec	r24
    7f88:	e1 f7       	brne	.-8      	; 0x7f82 <Put_zVal+0x68>
	Format[2] = '0'+Param->Size;
    7f8a:	fa 01       	movw	r30, r20
    7f8c:	93 81       	ldd	r25, Z+3	; 0x03
    7f8e:	90 5d       	subi	r25, 0xD0	; 208
    7f90:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7f92:	82 81       	ldd	r24, Z+2	; 0x02
    7f94:	c1 80       	ldd	r12, Z+1	; 0x01
    7f96:	d0 80       	ld	r13, Z
    7f98:	88 23       	and	r24, r24
    7f9a:	e1 f0       	breq	.+56     	; 0x7fd4 <Put_zVal+0xba>
		Format[2] -= Param->Prec+1;
    7f9c:	98 1b       	sub	r25, r24
    7f9e:	91 50       	subi	r25, 0x01	; 1
    7fa0:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7fa2:	90 e3       	ldi	r25, 0x30	; 48
    7fa4:	98 0f       	add	r25, r24
    7fa6:	98 87       	std	Y+8, r25	; 0x08
		uint16_t Div=Pow10(Param->Prec);
    7fa8:	0e 94 4d 3c 	call	0x789a	; 0x789a <Pow10>
    7fac:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7fae:	c7 01       	movw	r24, r14
    7fb0:	0e 94 ba 74 	call	0xe974	; 0xe974 <__udivmodhi4>
    7fb4:	9f 93       	push	r25
    7fb6:	8f 93       	push	r24
    7fb8:	7f 93       	push	r23
    7fba:	6f 93       	push	r22
    7fbc:	1f 93       	push	r17
    7fbe:	0f 93       	push	r16
    7fc0:	cf 92       	push	r12
    7fc2:	df 92       	push	r13
    7fc4:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    7fc8:	0f b6       	in	r0, 0x3f	; 63
    7fca:	f8 94       	cli
    7fcc:	de bf       	out	0x3e, r29	; 62
    7fce:	0f be       	out	0x3f, r0	; 63
    7fd0:	cd bf       	out	0x3d, r28	; 61
    7fd2:	0f c0       	rjmp	.+30     	; 0x7ff2 <Put_zVal+0xd8>
	}
	else {
		Format[4] = '\0';
    7fd4:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7fd6:	ff 92       	push	r15
    7fd8:	ef 92       	push	r14
    7fda:	1f 93       	push	r17
    7fdc:	0f 93       	push	r16
    7fde:	cf 92       	push	r12
    7fe0:	df 92       	push	r13
    7fe2:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    7fe6:	0f 90       	pop	r0
    7fe8:	0f 90       	pop	r0
    7fea:	0f 90       	pop	r0
    7fec:	0f 90       	pop	r0
    7fee:	0f 90       	pop	r0
    7ff0:	0f 90       	pop	r0
	}
}
    7ff2:	2a 96       	adiw	r28, 0x0a	; 10
    7ff4:	0f b6       	in	r0, 0x3f	; 63
    7ff6:	f8 94       	cli
    7ff8:	de bf       	out	0x3e, r29	; 62
    7ffa:	0f be       	out	0x3f, r0	; 63
    7ffc:	cd bf       	out	0x3d, r28	; 61
    7ffe:	df 91       	pop	r29
    8000:	cf 91       	pop	r28
    8002:	1f 91       	pop	r17
    8004:	0f 91       	pop	r16
    8006:	ff 90       	pop	r15
    8008:	ef 90       	pop	r14
    800a:	df 90       	pop	r13
    800c:	cf 90       	pop	r12
    800e:	08 95       	ret

00008010 <Put_zVal_h>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8010:	f9 01       	movw	r30, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8012:	42 36       	cpi	r20, 0x62	; 98
    8014:	29 f4       	brne	.+10     	; 0x8020 <Put_zVal_h+0x10>
    8016:	1f 92       	push	r1
    8018:	6f 93       	push	r22
    801a:	80 e3       	ldi	r24, 0x30	; 48
    801c:	91 e0       	ldi	r25, 0x01	; 1
    801e:	06 c0       	rjmp	.+12     	; 0x802c <Put_zVal_h+0x1c>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8020:	47 37       	cpi	r20, 0x77	; 119
    8022:	99 f4       	brne	.+38     	; 0x804a <Put_zVal_h+0x3a>
    8024:	7f 93       	push	r23
    8026:	6f 93       	push	r22
    8028:	86 e3       	ldi	r24, 0x36	; 54
    802a:	91 e0       	ldi	r25, 0x01	; 1
    802c:	9f 93       	push	r25
    802e:	8f 93       	push	r24
    8030:	81 81       	ldd	r24, Z+1	; 0x01
    8032:	8f 93       	push	r24
    8034:	80 81       	ld	r24, Z
    8036:	8f 93       	push	r24
    8038:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    803c:	0f 90       	pop	r0
    803e:	0f 90       	pop	r0
    8040:	0f 90       	pop	r0
    8042:	0f 90       	pop	r0
    8044:	0f 90       	pop	r0
    8046:	0f 90       	pop	r0
    8048:	08 95       	ret
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    804a:	4c 36       	cpi	r20, 0x6C	; 108
    804c:	b1 f4       	brne	.+44     	; 0x807a <Put_zVal_h+0x6a>
    804e:	9f 93       	push	r25
    8050:	8f 93       	push	r24
    8052:	7f 93       	push	r23
    8054:	6f 93       	push	r22
    8056:	8b e3       	ldi	r24, 0x3B	; 59
    8058:	91 e0       	ldi	r25, 0x01	; 1
    805a:	9f 93       	push	r25
    805c:	8f 93       	push	r24
    805e:	81 81       	ldd	r24, Z+1	; 0x01
    8060:	8f 93       	push	r24
    8062:	80 81       	ld	r24, Z
    8064:	8f 93       	push	r24
    8066:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    806a:	8d b7       	in	r24, 0x3d	; 61
    806c:	9e b7       	in	r25, 0x3e	; 62
    806e:	08 96       	adiw	r24, 0x08	; 8
    8070:	0f b6       	in	r0, 0x3f	; 63
    8072:	f8 94       	cli
    8074:	9e bf       	out	0x3e, r25	; 62
    8076:	0f be       	out	0x3f, r0	; 63
    8078:	8d bf       	out	0x3d, r24	; 61
    807a:	08 95       	ret

0000807c <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    807c:	af 92       	push	r10
    807e:	bf 92       	push	r11
    8080:	cf 92       	push	r12
    8082:	df 92       	push	r13
    8084:	ef 92       	push	r14
    8086:	ff 92       	push	r15
    8088:	0f 93       	push	r16
    808a:	1f 93       	push	r17
    808c:	cf 93       	push	r28
    808e:	df 93       	push	r29
    8090:	cd b7       	in	r28, 0x3d	; 61
    8092:	de b7       	in	r29, 0x3e	; 62
    8094:	2b 97       	sbiw	r28, 0x0b	; 11
    8096:	0f b6       	in	r0, 0x3f	; 63
    8098:	f8 94       	cli
    809a:	de bf       	out	0x3e, r29	; 62
    809c:	0f be       	out	0x3f, r0	; 63
    809e:	cd bf       	out	0x3d, r28	; 61
    80a0:	6b 01       	movw	r12, r22
    80a2:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    80a4:	8b 01       	movw	r16, r22
    80a6:	9c 01       	movw	r18, r24
    80a8:	00 95       	com	r16
    80aa:	10 95       	com	r17
    80ac:	20 95       	com	r18
    80ae:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    80b0:	fa 01       	movw	r30, r20
    80b2:	84 81       	ldd	r24, Z+4	; 0x04
    80b4:	95 81       	ldd	r25, Z+5	; 0x05
    80b6:	00 97       	sbiw	r24, 0x00	; 0
    80b8:	79 f0       	breq	.+30     	; 0x80d8 <PutDVal+0x5c>
    80ba:	02 30       	cpi	r16, 0x02	; 2
    80bc:	11 05       	cpc	r17, r1
    80be:	21 05       	cpc	r18, r1
    80c0:	31 05       	cpc	r19, r1
    80c2:	50 f4       	brcc	.+20     	; 0x80d8 <PutDVal+0x5c>
		Param->Txt += Idx;
    80c4:	00 0f       	add	r16, r16
    80c6:	11 1f       	adc	r17, r17
    80c8:	08 0f       	add	r16, r24
    80ca:	19 1f       	adc	r17, r25
    80cc:	15 83       	std	Z+5, r17	; 0x05
    80ce:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    80d0:	ca 01       	movw	r24, r20
    80d2:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
		return;
    80d6:	54 c0       	rjmp	.+168    	; 0x8180 <PutDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    80d8:	fa 01       	movw	r30, r20
    80da:	93 81       	ldd	r25, Z+3	; 0x03
    80dc:	9a 30       	cpi	r25, 0x0A	; 10
    80de:	81 f4       	brne	.+32     	; 0x8100 <PutDVal+0x84>
    80e0:	82 81       	ldd	r24, Z+2	; 0x02
    80e2:	81 11       	cpse	r24, r1
    80e4:	0d c0       	rjmp	.+26     	; 0x8100 <PutDVal+0x84>
		sprintf(Param->Pos, "%10lu", Val);
    80e6:	ff 92       	push	r15
    80e8:	ef 92       	push	r14
    80ea:	df 92       	push	r13
    80ec:	cf 92       	push	r12
    80ee:	81 e4       	ldi	r24, 0x41	; 65
    80f0:	91 e0       	ldi	r25, 0x01	; 1
    80f2:	9f 93       	push	r25
    80f4:	8f 93       	push	r24
    80f6:	81 81       	ldd	r24, Z+1	; 0x01
    80f8:	8f 93       	push	r24
    80fa:	80 81       	ld	r24, Z
    80fc:	8f 93       	push	r24
    80fe:	39 c0       	rjmp	.+114    	; 0x8172 <PutDVal+0xf6>
		return;
	}
	char Format[] = "% lu.%. lu";
    8100:	8b e0       	ldi	r24, 0x0B	; 11
    8102:	e7 e4       	ldi	r30, 0x47	; 71
    8104:	f1 e0       	ldi	r31, 0x01	; 1
    8106:	8e 01       	movw	r16, r28
    8108:	0f 5f       	subi	r16, 0xFF	; 255
    810a:	1f 4f       	sbci	r17, 0xFF	; 255
    810c:	d8 01       	movw	r26, r16
    810e:	01 90       	ld	r0, Z+
    8110:	0d 92       	st	X+, r0
    8112:	8a 95       	dec	r24
    8114:	e1 f7       	brne	.-8      	; 0x810e <PutDVal+0x92>
	Format[1] = '0'+Param->Size;
    8116:	90 5d       	subi	r25, 0xD0	; 208
    8118:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    811a:	fa 01       	movw	r30, r20
    811c:	82 81       	ldd	r24, Z+2	; 0x02
    811e:	a1 80       	ldd	r10, Z+1	; 0x01
    8120:	b0 80       	ld	r11, Z
    8122:	88 23       	and	r24, r24
    8124:	e9 f0       	breq	.+58     	; 0x8160 <PutDVal+0xe4>
		Format[1] -= Param->Prec+1;
    8126:	98 1b       	sub	r25, r24
    8128:	91 50       	subi	r25, 0x01	; 1
    812a:	9a 83       	std	Y+2, r25	; 0x02
		Format[7] = '0'+Param->Prec;
    812c:	90 e3       	ldi	r25, 0x30	; 48
    812e:	98 0f       	add	r25, r24
    8130:	98 87       	std	Y+8, r25	; 0x08
		uint32_t Div=PowL10(Param->Prec);
    8132:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <PowL10>
    8136:	9b 01       	movw	r18, r22
    8138:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    813a:	c7 01       	movw	r24, r14
    813c:	b6 01       	movw	r22, r12
    813e:	0e 94 e2 74 	call	0xe9c4	; 0xe9c4 <__udivmodsi4>
    8142:	9f 93       	push	r25
    8144:	8f 93       	push	r24
    8146:	7f 93       	push	r23
    8148:	6f 93       	push	r22
    814a:	5f 93       	push	r21
    814c:	4f 93       	push	r20
    814e:	3f 93       	push	r19
    8150:	2f 93       	push	r18
    8152:	1f 93       	push	r17
    8154:	0f 93       	push	r16
    8156:	af 92       	push	r10
    8158:	bf 92       	push	r11
    815a:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    815e:	0b c0       	rjmp	.+22     	; 0x8176 <PutDVal+0xfa>
	}
	else {
		Format[4] = '\0';
    8160:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    8162:	ff 92       	push	r15
    8164:	ef 92       	push	r14
    8166:	df 92       	push	r13
    8168:	cf 92       	push	r12
    816a:	1f 93       	push	r17
    816c:	0f 93       	push	r16
    816e:	af 92       	push	r10
    8170:	bf 92       	push	r11
    8172:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    8176:	0f b6       	in	r0, 0x3f	; 63
    8178:	f8 94       	cli
    817a:	de bf       	out	0x3e, r29	; 62
    817c:	0f be       	out	0x3f, r0	; 63
    817e:	cd bf       	out	0x3d, r28	; 61
	}
}
    8180:	2b 96       	adiw	r28, 0x0b	; 11
    8182:	0f b6       	in	r0, 0x3f	; 63
    8184:	f8 94       	cli
    8186:	de bf       	out	0x3e, r29	; 62
    8188:	0f be       	out	0x3f, r0	; 63
    818a:	cd bf       	out	0x3d, r28	; 61
    818c:	df 91       	pop	r29
    818e:	cf 91       	pop	r28
    8190:	1f 91       	pop	r17
    8192:	0f 91       	pop	r16
    8194:	ff 90       	pop	r15
    8196:	ef 90       	pop	r14
    8198:	df 90       	pop	r13
    819a:	cf 90       	pop	r12
    819c:	bf 90       	pop	r11
    819e:	af 90       	pop	r10
    81a0:	08 95       	ret

000081a2 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    81a2:	af 92       	push	r10
    81a4:	bf 92       	push	r11
    81a6:	cf 92       	push	r12
    81a8:	df 92       	push	r13
    81aa:	ef 92       	push	r14
    81ac:	ff 92       	push	r15
    81ae:	0f 93       	push	r16
    81b0:	1f 93       	push	r17
    81b2:	cf 93       	push	r28
    81b4:	df 93       	push	r29
    81b6:	cd b7       	in	r28, 0x3d	; 61
    81b8:	de b7       	in	r29, 0x3e	; 62
    81ba:	27 97       	sbiw	r28, 0x07	; 7
    81bc:	0f b6       	in	r0, 0x3f	; 63
    81be:	f8 94       	cli
    81c0:	de bf       	out	0x3e, r29	; 62
    81c2:	0f be       	out	0x3f, r0	; 63
    81c4:	cd bf       	out	0x3d, r28	; 61
    81c6:	6b 01       	movw	r12, r22
    81c8:	7c 01       	movw	r14, r24
    81ca:	5a 01       	movw	r10, r20
	uint32_t Idx = 0x80000000+Val;
    81cc:	8b 01       	movw	r16, r22
    81ce:	9c 01       	movw	r18, r24
    81d0:	30 58       	subi	r19, 0x80	; 128
	if(Param->Txt && Idx<2) {
    81d2:	da 01       	movw	r26, r20
    81d4:	14 96       	adiw	r26, 0x04	; 4
    81d6:	8d 91       	ld	r24, X+
    81d8:	9c 91       	ld	r25, X
    81da:	15 97       	sbiw	r26, 0x05	; 5
    81dc:	00 97       	sbiw	r24, 0x00	; 0
    81de:	89 f0       	breq	.+34     	; 0x8202 <Put_sDVal+0x60>
    81e0:	02 30       	cpi	r16, 0x02	; 2
    81e2:	11 05       	cpc	r17, r1
    81e4:	21 05       	cpc	r18, r1
    81e6:	31 05       	cpc	r19, r1
    81e8:	60 f4       	brcc	.+24     	; 0x8202 <Put_sDVal+0x60>
		Param->Txt += Idx;
    81ea:	00 0f       	add	r16, r16
    81ec:	11 1f       	adc	r17, r17
    81ee:	08 0f       	add	r16, r24
    81f0:	19 1f       	adc	r17, r25
    81f2:	15 96       	adiw	r26, 0x05	; 5
    81f4:	1c 93       	st	X, r17
    81f6:	0e 93       	st	-X, r16
    81f8:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    81fa:	ca 01       	movw	r24, r20
    81fc:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
		return;
    8200:	b7 c0       	rjmp	.+366    	; 0x8370 <Put_sDVal+0x1ce>
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8202:	f5 01       	movw	r30, r10
    8204:	83 81       	ldd	r24, Z+3	; 0x03
    8206:	9e 01       	movw	r18, r28
    8208:	2f 5f       	subi	r18, 0xFF	; 255
    820a:	3f 4f       	sbci	r19, 0xFF	; 255
    820c:	8a 30       	cpi	r24, 0x0A	; 10
    820e:	70 f0       	brcs	.+28     	; 0x822c <Put_sDVal+0x8a>
		char Format[] = "%+1 ld";
    8210:	97 e0       	ldi	r25, 0x07	; 7
    8212:	e2 e5       	ldi	r30, 0x52	; 82
    8214:	f1 e0       	ldi	r31, 0x01	; 1
    8216:	d9 01       	movw	r26, r18
    8218:	01 90       	ld	r0, Z+
    821a:	0d 92       	st	X+, r0
    821c:	9a 95       	dec	r25
    821e:	e1 f7       	brne	.-8      	; 0x8218 <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    8220:	6a e0       	ldi	r22, 0x0A	; 10
    8222:	0e 94 ae 74 	call	0xe95c	; 0xe95c <__udivmodqi4>
    8226:	90 5d       	subi	r25, 0xD0	; 208
    8228:	9c 83       	std	Y+4, r25	; 0x04
    822a:	0a c0       	rjmp	.+20     	; 0x8240 <Put_sDVal+0x9e>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+ ld";
    822c:	96 e0       	ldi	r25, 0x06	; 6
    822e:	e9 e5       	ldi	r30, 0x59	; 89
    8230:	f1 e0       	ldi	r31, 0x01	; 1
    8232:	d9 01       	movw	r26, r18
    8234:	01 90       	ld	r0, Z+
    8236:	0d 92       	st	X+, r0
    8238:	9a 95       	dec	r25
    823a:	e1 f7       	brne	.-8      	; 0x8234 <Put_sDVal+0x92>
		Format[2] = '0'+Param->Size;
    823c:	80 5d       	subi	r24, 0xD0	; 208
    823e:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    8240:	ff 92       	push	r15
    8242:	ef 92       	push	r14
    8244:	df 92       	push	r13
    8246:	cf 92       	push	r12
    8248:	3f 93       	push	r19
    824a:	2f 93       	push	r18
    824c:	d5 01       	movw	r26, r10
    824e:	11 96       	adiw	r26, 0x01	; 1
    8250:	8c 91       	ld	r24, X
    8252:	11 97       	sbiw	r26, 0x01	; 1
    8254:	8f 93       	push	r24
    8256:	8c 91       	ld	r24, X
    8258:	8f 93       	push	r24
    825a:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    825e:	0f b6       	in	r0, 0x3f	; 63
    8260:	f8 94       	cli
    8262:	de bf       	out	0x3e, r29	; 62
    8264:	0f be       	out	0x3f, r0	; 63
    8266:	cd bf       	out	0x3d, r28	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    8268:	c1 14       	cp	r12, r1
    826a:	d1 04       	cpc	r13, r1
    826c:	e1 04       	cpc	r14, r1
    826e:	f1 04       	cpc	r15, r1
    8270:	59 f4       	brne	.+22     	; 0x8288 <Put_sDVal+0xe6>
    8272:	d5 01       	movw	r26, r10
    8274:	13 96       	adiw	r26, 0x03	; 3
    8276:	8c 91       	ld	r24, X
    8278:	13 97       	sbiw	r26, 0x03	; 3
    827a:	ed 91       	ld	r30, X+
    827c:	fc 91       	ld	r31, X
    827e:	e8 0f       	add	r30, r24
    8280:	f1 1d       	adc	r31, r1
    8282:	32 97       	sbiw	r30, 0x02	; 2
    8284:	80 e2       	ldi	r24, 0x20	; 32
    8286:	80 83       	st	Z, r24

	if(Param->Prec){
    8288:	f5 01       	movw	r30, r10
    828a:	82 81       	ldd	r24, Z+2	; 0x02
    828c:	88 23       	and	r24, r24
    828e:	09 f4       	brne	.+2      	; 0x8292 <Put_sDVal+0xf0>
    8290:	6f c0       	rjmp	.+222    	; 0x8370 <Put_sDVal+0x1ce>
    8292:	60 e0       	ldi	r22, 0x00	; 0
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8294:	d5 01       	movw	r26, r10
    8296:	13 96       	adiw	r26, 0x03	; 3
    8298:	8c 91       	ld	r24, X
    829a:	13 97       	sbiw	r26, 0x03	; 3
    829c:	90 e0       	ldi	r25, 0x00	; 0
    829e:	12 96       	adiw	r26, 0x02	; 2
    82a0:	2c 91       	ld	r18, X
    82a2:	12 97       	sbiw	r26, 0x02	; 2
    82a4:	82 1b       	sub	r24, r18
    82a6:	91 09       	sbc	r25, r1
    82a8:	46 2f       	mov	r20, r22
    82aa:	50 e0       	ldi	r21, 0x00	; 0
    82ac:	2d 91       	ld	r18, X+
    82ae:	3c 91       	ld	r19, X
    82b0:	11 97       	sbiw	r26, 0x01	; 1
			Param->Pos[i] = Param->Pos[i+1];
    82b2:	f9 01       	movw	r30, r18
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    82b4:	48 17       	cp	r20, r24
    82b6:	59 07       	cpc	r21, r25
    82b8:	34 f4       	brge	.+12     	; 0x82c6 <Put_sDVal+0x124>
			Param->Pos[i] = Param->Pos[i+1];
    82ba:	e4 0f       	add	r30, r20
    82bc:	f5 1f       	adc	r31, r21
    82be:	81 81       	ldd	r24, Z+1	; 0x01
    82c0:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    82c2:	6f 5f       	subi	r22, 0xFF	; 255
    82c4:	e7 cf       	rjmp	.-50     	; 0x8294 <Put_sDVal+0xf2>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    82c6:	e8 0f       	add	r30, r24
    82c8:	f9 1f       	adc	r31, r25
    82ca:	31 97       	sbiw	r30, 0x01	; 1
    82cc:	2e e2       	ldi	r18, 0x2E	; 46
    82ce:	20 83       	st	Z, r18
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    82d0:	13 96       	adiw	r26, 0x03	; 3
    82d2:	2c 91       	ld	r18, X
    82d4:	13 97       	sbiw	r26, 0x03	; 3
    82d6:	82 2f       	mov	r24, r18
    82d8:	90 e0       	ldi	r25, 0x00	; 0
    82da:	12 96       	adiw	r26, 0x02	; 2
    82dc:	3c 91       	ld	r19, X
    82de:	12 97       	sbiw	r26, 0x02	; 2
    82e0:	83 1b       	sub	r24, r19
    82e2:	91 09       	sbc	r25, r1
    82e4:	ed 91       	ld	r30, X+
    82e6:	fc 91       	ld	r31, X
    82e8:	e8 0f       	add	r30, r24
    82ea:	f9 1f       	adc	r31, r25
    82ec:	32 97       	sbiw	r30, 0x02	; 2
    82ee:	80 81       	ld	r24, Z
		if(c ==' ' || c =='+' || c =='-'){
    82f0:	80 32       	cpi	r24, 0x20	; 32
    82f2:	21 f0       	breq	.+8      	; 0x82fc <Put_sDVal+0x15a>
    82f4:	8b 32       	cpi	r24, 0x2B	; 43
    82f6:	11 f0       	breq	.+4      	; 0x82fc <Put_sDVal+0x15a>
    82f8:	8d 32       	cpi	r24, 0x2D	; 45
    82fa:	d1 f5       	brne	.+116    	; 0x8370 <Put_sDVal+0x1ce>
			for(uint8_t i=Param->Size-1; i>1; i--){
    82fc:	21 50       	subi	r18, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    82fe:	40 e3       	ldi	r20, 0x30	; 48
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8300:	22 30       	cpi	r18, 0x02	; 2
    8302:	b0 f1       	brcs	.+108    	; 0x8370 <Put_sDVal+0x1ce>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8304:	82 2f       	mov	r24, r18
    8306:	90 e0       	ldi	r25, 0x00	; 0
    8308:	d5 01       	movw	r26, r10
    830a:	ed 91       	ld	r30, X+
    830c:	fc 91       	ld	r31, X
    830e:	e8 0f       	add	r30, r24
    8310:	f9 1f       	adc	r31, r25
    8312:	30 81       	ld	r19, Z
    8314:	30 32       	cpi	r19, 0x20	; 32
    8316:	21 f0       	breq	.+8      	; 0x8320 <Put_sDVal+0x17e>
    8318:	3b 32       	cpi	r19, 0x2B	; 43
    831a:	11 f0       	breq	.+4      	; 0x8320 <Put_sDVal+0x17e>
    831c:	3d 32       	cpi	r19, 0x2D	; 45
    831e:	09 f4       	brne	.+2      	; 0x8322 <Put_sDVal+0x180>
    8320:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    8322:	d5 01       	movw	r26, r10
    8324:	ed 91       	ld	r30, X+
    8326:	fc 91       	ld	r31, X
    8328:	11 97       	sbiw	r26, 0x01	; 1
    832a:	e8 0f       	add	r30, r24
    832c:	f9 1f       	adc	r31, r25
    832e:	30 81       	ld	r19, Z
    8330:	3e 32       	cpi	r19, 0x2E	; 46
    8332:	e1 f4       	brne	.+56     	; 0x836c <Put_sDVal+0x1ca>
					Param->Pos[i-1]='0';
    8334:	31 97       	sbiw	r30, 0x01	; 1
    8336:	20 e3       	ldi	r18, 0x30	; 48
    8338:	20 83       	st	Z, r18
					if(Val>0)Param->Pos[i-2]='+';
    833a:	1c 14       	cp	r1, r12
    833c:	1d 04       	cpc	r1, r13
    833e:	1e 04       	cpc	r1, r14
    8340:	1f 04       	cpc	r1, r15
    8342:	3c f4       	brge	.+14     	; 0x8352 <Put_sDVal+0x1b0>
    8344:	ed 91       	ld	r30, X+
    8346:	fc 91       	ld	r31, X
    8348:	e8 0f       	add	r30, r24
    834a:	f9 1f       	adc	r31, r25
    834c:	32 97       	sbiw	r30, 0x02	; 2
    834e:	8b e2       	ldi	r24, 0x2B	; 43
    8350:	0b c0       	rjmp	.+22     	; 0x8368 <Put_sDVal+0x1c6>
					if(Val<0)Param->Pos[i-2]='-';
    8352:	cd 28       	or	r12, r13
    8354:	ce 28       	or	r12, r14
    8356:	cf 28       	or	r12, r15
    8358:	59 f0       	breq	.+22     	; 0x8370 <Put_sDVal+0x1ce>
    835a:	d5 01       	movw	r26, r10
    835c:	ed 91       	ld	r30, X+
    835e:	fc 91       	ld	r31, X
    8360:	e8 0f       	add	r30, r24
    8362:	f9 1f       	adc	r31, r25
    8364:	32 97       	sbiw	r30, 0x02	; 2
    8366:	8d e2       	ldi	r24, 0x2D	; 45
    8368:	80 83       	st	Z, r24
    836a:	02 c0       	rjmp	.+4      	; 0x8370 <Put_sDVal+0x1ce>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    836c:	21 50       	subi	r18, 0x01	; 1
    836e:	c8 cf       	rjmp	.-112    	; 0x8300 <Put_sDVal+0x15e>
				}
			}
		}
	}

}
    8370:	27 96       	adiw	r28, 0x07	; 7
    8372:	0f b6       	in	r0, 0x3f	; 63
    8374:	f8 94       	cli
    8376:	de bf       	out	0x3e, r29	; 62
    8378:	0f be       	out	0x3f, r0	; 63
    837a:	cd bf       	out	0x3d, r28	; 61
    837c:	df 91       	pop	r29
    837e:	cf 91       	pop	r28
    8380:	1f 91       	pop	r17
    8382:	0f 91       	pop	r16
    8384:	ff 90       	pop	r15
    8386:	ef 90       	pop	r14
    8388:	df 90       	pop	r13
    838a:	cf 90       	pop	r12
    838c:	bf 90       	pop	r11
    838e:	af 90       	pop	r10
    8390:	08 95       	ret

00008392 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    8392:	af 92       	push	r10
    8394:	bf 92       	push	r11
    8396:	cf 92       	push	r12
    8398:	df 92       	push	r13
    839a:	ef 92       	push	r14
    839c:	ff 92       	push	r15
    839e:	0f 93       	push	r16
    83a0:	1f 93       	push	r17
    83a2:	cf 93       	push	r28
    83a4:	df 93       	push	r29
    83a6:	cd b7       	in	r28, 0x3d	; 61
    83a8:	de b7       	in	r29, 0x3e	; 62
    83aa:	2c 97       	sbiw	r28, 0x0c	; 12
    83ac:	0f b6       	in	r0, 0x3f	; 63
    83ae:	f8 94       	cli
    83b0:	de bf       	out	0x3e, r29	; 62
    83b2:	0f be       	out	0x3f, r0	; 63
    83b4:	cd bf       	out	0x3d, r28	; 61
    83b6:	6b 01       	movw	r12, r22
    83b8:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    83ba:	8b 01       	movw	r16, r22
    83bc:	9c 01       	movw	r18, r24
    83be:	00 95       	com	r16
    83c0:	10 95       	com	r17
    83c2:	20 95       	com	r18
    83c4:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    83c6:	fa 01       	movw	r30, r20
    83c8:	84 81       	ldd	r24, Z+4	; 0x04
    83ca:	95 81       	ldd	r25, Z+5	; 0x05
    83cc:	00 97       	sbiw	r24, 0x00	; 0
    83ce:	79 f0       	breq	.+30     	; 0x83ee <Put_zDVal+0x5c>
    83d0:	02 30       	cpi	r16, 0x02	; 2
    83d2:	11 05       	cpc	r17, r1
    83d4:	21 05       	cpc	r18, r1
    83d6:	31 05       	cpc	r19, r1
    83d8:	50 f4       	brcc	.+20     	; 0x83ee <Put_zDVal+0x5c>
		Param->Txt += Idx;
    83da:	00 0f       	add	r16, r16
    83dc:	11 1f       	adc	r17, r17
    83de:	08 0f       	add	r16, r24
    83e0:	19 1f       	adc	r17, r25
    83e2:	15 83       	std	Z+5, r17	; 0x05
    83e4:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    83e6:	ca 01       	movw	r24, r20
    83e8:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
		return;
    83ec:	54 c0       	rjmp	.+168    	; 0x8496 <Put_zDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    83ee:	fa 01       	movw	r30, r20
    83f0:	93 81       	ldd	r25, Z+3	; 0x03
    83f2:	9a 30       	cpi	r25, 0x0A	; 10
    83f4:	81 f4       	brne	.+32     	; 0x8416 <Put_zDVal+0x84>
    83f6:	82 81       	ldd	r24, Z+2	; 0x02
    83f8:	81 11       	cpse	r24, r1
    83fa:	0d c0       	rjmp	.+26     	; 0x8416 <Put_zDVal+0x84>
		sprintf(Param->Pos, "%010lu", Val);
    83fc:	ff 92       	push	r15
    83fe:	ef 92       	push	r14
    8400:	df 92       	push	r13
    8402:	cf 92       	push	r12
    8404:	8f e5       	ldi	r24, 0x5F	; 95
    8406:	91 e0       	ldi	r25, 0x01	; 1
    8408:	9f 93       	push	r25
    840a:	8f 93       	push	r24
    840c:	81 81       	ldd	r24, Z+1	; 0x01
    840e:	8f 93       	push	r24
    8410:	80 81       	ld	r24, Z
    8412:	8f 93       	push	r24
    8414:	39 c0       	rjmp	.+114    	; 0x8488 <Put_zDVal+0xf6>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    8416:	8c e0       	ldi	r24, 0x0C	; 12
    8418:	e6 e6       	ldi	r30, 0x66	; 102
    841a:	f1 e0       	ldi	r31, 0x01	; 1
    841c:	8e 01       	movw	r16, r28
    841e:	0f 5f       	subi	r16, 0xFF	; 255
    8420:	1f 4f       	sbci	r17, 0xFF	; 255
    8422:	d8 01       	movw	r26, r16
    8424:	01 90       	ld	r0, Z+
    8426:	0d 92       	st	X+, r0
    8428:	8a 95       	dec	r24
    842a:	e1 f7       	brne	.-8      	; 0x8424 <Put_zDVal+0x92>
	Format[2] = '0'+Param->Size;
    842c:	90 5d       	subi	r25, 0xD0	; 208
    842e:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    8430:	fa 01       	movw	r30, r20
    8432:	82 81       	ldd	r24, Z+2	; 0x02
    8434:	a1 80       	ldd	r10, Z+1	; 0x01
    8436:	b0 80       	ld	r11, Z
    8438:	88 23       	and	r24, r24
    843a:	e9 f0       	breq	.+58     	; 0x8476 <Put_zDVal+0xe4>
		Format[2] -= Param->Prec+1;
    843c:	98 1b       	sub	r25, r24
    843e:	91 50       	subi	r25, 0x01	; 1
    8440:	9b 83       	std	Y+3, r25	; 0x03
		Format[8] = '0'+Param->Prec;
    8442:	90 e3       	ldi	r25, 0x30	; 48
    8444:	98 0f       	add	r25, r24
    8446:	99 87       	std	Y+9, r25	; 0x09
		uint32_t Div=PowL10(Param->Prec);
    8448:	0e 94 5b 3c 	call	0x78b6	; 0x78b6 <PowL10>
    844c:	9b 01       	movw	r18, r22
    844e:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8450:	c7 01       	movw	r24, r14
    8452:	b6 01       	movw	r22, r12
    8454:	0e 94 e2 74 	call	0xe9c4	; 0xe9c4 <__udivmodsi4>
    8458:	9f 93       	push	r25
    845a:	8f 93       	push	r24
    845c:	7f 93       	push	r23
    845e:	6f 93       	push	r22
    8460:	5f 93       	push	r21
    8462:	4f 93       	push	r20
    8464:	3f 93       	push	r19
    8466:	2f 93       	push	r18
    8468:	1f 93       	push	r17
    846a:	0f 93       	push	r16
    846c:	af 92       	push	r10
    846e:	bf 92       	push	r11
    8470:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    8474:	0b c0       	rjmp	.+22     	; 0x848c <Put_zDVal+0xfa>
	}
	else {
		Format[5] = '\0';
    8476:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    8478:	ff 92       	push	r15
    847a:	ef 92       	push	r14
    847c:	df 92       	push	r13
    847e:	cf 92       	push	r12
    8480:	1f 93       	push	r17
    8482:	0f 93       	push	r16
    8484:	af 92       	push	r10
    8486:	bf 92       	push	r11
    8488:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    848c:	0f b6       	in	r0, 0x3f	; 63
    848e:	f8 94       	cli
    8490:	de bf       	out	0x3e, r29	; 62
    8492:	0f be       	out	0x3f, r0	; 63
    8494:	cd bf       	out	0x3d, r28	; 61
	}
}
    8496:	2c 96       	adiw	r28, 0x0c	; 12
    8498:	0f b6       	in	r0, 0x3f	; 63
    849a:	f8 94       	cli
    849c:	de bf       	out	0x3e, r29	; 62
    849e:	0f be       	out	0x3f, r0	; 63
    84a0:	cd bf       	out	0x3d, r28	; 61
    84a2:	df 91       	pop	r29
    84a4:	cf 91       	pop	r28
    84a6:	1f 91       	pop	r17
    84a8:	0f 91       	pop	r16
    84aa:	ff 90       	pop	r15
    84ac:	ef 90       	pop	r14
    84ae:	df 90       	pop	r13
    84b0:	cf 90       	pop	r12
    84b2:	bf 90       	pop	r11
    84b4:	af 90       	pop	r10
    84b6:	08 95       	ret

000084b8 <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    84b8:	1f 93       	push	r17
    84ba:	cf 93       	push	r28
    84bc:	df 93       	push	r29
    84be:	cd b7       	in	r28, 0x3d	; 61
    84c0:	de b7       	in	r29, 0x3e	; 62
    84c2:	27 97       	sbiw	r28, 0x07	; 7
    84c4:	0f b6       	in	r0, 0x3f	; 63
    84c6:	f8 94       	cli
    84c8:	de bf       	out	0x3e, r29	; 62
    84ca:	0f be       	out	0x3f, r0	; 63
    84cc:	cd bf       	out	0x3d, r28	; 61
	char Format[] = "%+ . f";
    84ce:	17 e0       	ldi	r17, 0x07	; 7
    84d0:	e2 e7       	ldi	r30, 0x72	; 114
    84d2:	f1 e0       	ldi	r31, 0x01	; 1
    84d4:	9e 01       	movw	r18, r28
    84d6:	2f 5f       	subi	r18, 0xFF	; 255
    84d8:	3f 4f       	sbci	r19, 0xFF	; 255
    84da:	d9 01       	movw	r26, r18
    84dc:	01 90       	ld	r0, Z+
    84de:	0d 92       	st	X+, r0
    84e0:	1a 95       	dec	r17
    84e2:	e1 f7       	brne	.-8      	; 0x84dc <Put_FFVal+0x24>
	Format[2] = '0'+Param->Size;
    84e4:	da 01       	movw	r26, r20
    84e6:	13 96       	adiw	r26, 0x03	; 3
    84e8:	ec 91       	ld	r30, X
    84ea:	13 97       	sbiw	r26, 0x03	; 3
    84ec:	e0 5d       	subi	r30, 0xD0	; 208
    84ee:	eb 83       	std	Y+3, r30	; 0x03
	Format[4] = '0'+Param->Prec;	
    84f0:	12 96       	adiw	r26, 0x02	; 2
    84f2:	ec 91       	ld	r30, X
    84f4:	12 97       	sbiw	r26, 0x02	; 2
    84f6:	e0 5d       	subi	r30, 0xD0	; 208
    84f8:	ed 83       	std	Y+5, r30	; 0x05
	sprintf(Param->Pos, Format, Val);
    84fa:	9f 93       	push	r25
    84fc:	8f 93       	push	r24
    84fe:	7f 93       	push	r23
    8500:	6f 93       	push	r22
    8502:	3f 93       	push	r19
    8504:	2f 93       	push	r18
    8506:	11 96       	adiw	r26, 0x01	; 1
    8508:	8c 91       	ld	r24, X
    850a:	11 97       	sbiw	r26, 0x01	; 1
    850c:	8f 93       	push	r24
    850e:	8c 91       	ld	r24, X
    8510:	8f 93       	push	r24
    8512:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    8516:	0f b6       	in	r0, 0x3f	; 63
    8518:	f8 94       	cli
    851a:	de bf       	out	0x3e, r29	; 62
    851c:	0f be       	out	0x3f, r0	; 63
    851e:	cd bf       	out	0x3d, r28	; 61
}
    8520:	27 96       	adiw	r28, 0x07	; 7
    8522:	0f b6       	in	r0, 0x3f	; 63
    8524:	f8 94       	cli
    8526:	de bf       	out	0x3e, r29	; 62
    8528:	0f be       	out	0x3f, r0	; 63
    852a:	cd bf       	out	0x3d, r28	; 61
    852c:	df 91       	pop	r29
    852e:	cf 91       	pop	r28
    8530:	1f 91       	pop	r17
    8532:	08 95       	ret

00008534 <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    8534:	0f 93       	push	r16
    8536:	1f 93       	push	r17
    8538:	cf 93       	push	r28
    853a:	df 93       	push	r29
    853c:	cd b7       	in	r28, 0x3d	; 61
    853e:	de b7       	in	r29, 0x3e	; 62
    8540:	28 97       	sbiw	r28, 0x08	; 8
    8542:	0f b6       	in	r0, 0x3f	; 63
    8544:	f8 94       	cli
    8546:	de bf       	out	0x3e, r29	; 62
    8548:	0f be       	out	0x3f, r0	; 63
    854a:	cd bf       	out	0x3d, r28	; 61
	if(Param->Size < 10){
    854c:	da 01       	movw	r26, r20
    854e:	13 96       	adiw	r26, 0x03	; 3
    8550:	1c 91       	ld	r17, X
    8552:	9e 01       	movw	r18, r28
    8554:	2f 5f       	subi	r18, 0xFF	; 255
    8556:	3f 4f       	sbci	r19, 0xFF	; 255
    8558:	1a 30       	cpi	r17, 0x0A	; 10
    855a:	88 f4       	brcc	.+34     	; 0x857e <Put_GFVal+0x4a>
		char Format[] = "%+ . g";
    855c:	07 e0       	ldi	r16, 0x07	; 7
    855e:	e9 e7       	ldi	r30, 0x79	; 121
    8560:	f1 e0       	ldi	r31, 0x01	; 1
    8562:	d9 01       	movw	r26, r18
    8564:	01 90       	ld	r0, Z+
    8566:	0d 92       	st	X+, r0
    8568:	0a 95       	dec	r16
    856a:	e1 f7       	brne	.-8      	; 0x8564 <Put_GFVal+0x30>
		Format[2] = '0'+Param->Size;
    856c:	10 5d       	subi	r17, 0xD0	; 208
    856e:	1b 83       	std	Y+3, r17	; 0x03
		Format[4] = '0'+Param->Prec;
    8570:	da 01       	movw	r26, r20
    8572:	12 96       	adiw	r26, 0x02	; 2
    8574:	ec 91       	ld	r30, X
    8576:	12 97       	sbiw	r26, 0x02	; 2
    8578:	e0 5d       	subi	r30, 0xD0	; 208
    857a:	ed 83       	std	Y+5, r30	; 0x05
    857c:	10 c0       	rjmp	.+32     	; 0x859e <Put_GFVal+0x6a>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    857e:	08 e0       	ldi	r16, 0x08	; 8
    8580:	e0 e8       	ldi	r30, 0x80	; 128
    8582:	f1 e0       	ldi	r31, 0x01	; 1
    8584:	d9 01       	movw	r26, r18
    8586:	01 90       	ld	r0, Z+
    8588:	0d 92       	st	X+, r0
    858a:	0a 95       	dec	r16
    858c:	e1 f7       	brne	.-8      	; 0x8586 <Put_GFVal+0x52>
		Format[3] = '0'+Param->Size-10;	
    858e:	1a 5d       	subi	r17, 0xDA	; 218
    8590:	1c 83       	std	Y+4, r17	; 0x04
		Format[5] = '0'+Param->Prec;
    8592:	da 01       	movw	r26, r20
    8594:	12 96       	adiw	r26, 0x02	; 2
    8596:	ec 91       	ld	r30, X
    8598:	12 97       	sbiw	r26, 0x02	; 2
    859a:	e0 5d       	subi	r30, 0xD0	; 208
    859c:	ee 83       	std	Y+6, r30	; 0x06
		sprintf(Param->Pos, Format, Val);
    859e:	9f 93       	push	r25
    85a0:	8f 93       	push	r24
    85a2:	7f 93       	push	r23
    85a4:	6f 93       	push	r22
    85a6:	3f 93       	push	r19
    85a8:	2f 93       	push	r18
    85aa:	11 96       	adiw	r26, 0x01	; 1
    85ac:	8c 91       	ld	r24, X
    85ae:	11 97       	sbiw	r26, 0x01	; 1
    85b0:	8f 93       	push	r24
    85b2:	8c 91       	ld	r24, X
    85b4:	8f 93       	push	r24
    85b6:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    85ba:	0f b6       	in	r0, 0x3f	; 63
    85bc:	f8 94       	cli
    85be:	de bf       	out	0x3e, r29	; 62
    85c0:	0f be       	out	0x3f, r0	; 63
    85c2:	cd bf       	out	0x3d, r28	; 61
	}
}
    85c4:	28 96       	adiw	r28, 0x08	; 8
    85c6:	0f b6       	in	r0, 0x3f	; 63
    85c8:	f8 94       	cli
    85ca:	de bf       	out	0x3e, r29	; 62
    85cc:	0f be       	out	0x3f, r0	; 63
    85ce:	cd bf       	out	0x3d, r28	; 61
    85d0:	df 91       	pop	r29
    85d2:	cf 91       	pop	r28
    85d4:	1f 91       	pop	r17
    85d6:	0f 91       	pop	r16
    85d8:	08 95       	ret

000085da <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    85da:	cf 92       	push	r12
    85dc:	df 92       	push	r13
    85de:	ef 92       	push	r14
    85e0:	ff 92       	push	r15
    85e2:	0f 93       	push	r16
    85e4:	1f 93       	push	r17
    85e6:	cf 93       	push	r28
    85e8:	df 93       	push	r29
    85ea:	cd b7       	in	r28, 0x3d	; 61
    85ec:	de b7       	in	r29, 0x3e	; 62
    85ee:	29 97       	sbiw	r28, 0x09	; 9
    85f0:	0f b6       	in	r0, 0x3f	; 63
    85f2:	f8 94       	cli
    85f4:	de bf       	out	0x3e, r29	; 62
    85f6:	0f be       	out	0x3f, r0	; 63
    85f8:	cd bf       	out	0x3d, r28	; 61
    85fa:	d8 2e       	mov	r13, r24
    85fc:	c9 2e       	mov	r12, r25
    85fe:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8600:	fb 01       	movw	r30, r22
    8602:	23 81       	ldd	r18, Z+3	; 0x03
    8604:	1f 92       	push	r1
    8606:	2f 93       	push	r18
    8608:	1f 92       	push	r1
    860a:	2f 93       	push	r18
    860c:	28 e8       	ldi	r18, 0x88	; 136
    860e:	31 e0       	ldi	r19, 0x01	; 1
    8610:	3f 93       	push	r19
    8612:	2f 93       	push	r18
    8614:	8e 01       	movw	r16, r28
    8616:	0f 5f       	subi	r16, 0xFF	; 255
    8618:	1f 4f       	sbci	r17, 0xFF	; 255
    861a:	1f 93       	push	r17
    861c:	0f 93       	push	r16
    861e:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
	sprintf(Param->Pos, Format, Val);
    8622:	cf 92       	push	r12
    8624:	df 92       	push	r13
    8626:	1f 93       	push	r17
    8628:	0f 93       	push	r16
    862a:	f7 01       	movw	r30, r14
    862c:	81 81       	ldd	r24, Z+1	; 0x01
    862e:	8f 93       	push	r24
    8630:	80 81       	ld	r24, Z
    8632:	8f 93       	push	r24
    8634:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    8638:	0f b6       	in	r0, 0x3f	; 63
    863a:	f8 94       	cli
    863c:	de bf       	out	0x3e, r29	; 62
    863e:	0f be       	out	0x3f, r0	; 63
    8640:	cd bf       	out	0x3d, r28	; 61
}
    8642:	29 96       	adiw	r28, 0x09	; 9
    8644:	0f b6       	in	r0, 0x3f	; 63
    8646:	f8 94       	cli
    8648:	de bf       	out	0x3e, r29	; 62
    864a:	0f be       	out	0x3f, r0	; 63
    864c:	cd bf       	out	0x3d, r28	; 61
    864e:	df 91       	pop	r29
    8650:	cf 91       	pop	r28
    8652:	1f 91       	pop	r17
    8654:	0f 91       	pop	r16
    8656:	ff 90       	pop	r15
    8658:	ef 90       	pop	r14
    865a:	df 90       	pop	r13
    865c:	cf 90       	pop	r12
    865e:	08 95       	ret

00008660 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    8660:	80 91 12 0b 	lds	r24, 0x0B12
    8664:	90 91 13 0b 	lds	r25, 0x0B13
    8668:	89 2b       	or	r24, r25
    866a:	31 f0       	breq	.+12     	; 0x8678 <HideMsg+0x18>
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    866c:	10 92 13 0b 	sts	0x0B13, r1
    8670:	10 92 12 0b 	sts	0x0B12, r1
		return 1;
    8674:	81 e0       	ldi	r24, 0x01	; 1
    8676:	08 95       	ret
	}
	else
		return 0;
    8678:	80 e0       	ldi	r24, 0x00	; 0
}
    867a:	08 95       	ret

0000867c <WebInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    867c:	80 91 0f 01 	lds	r24, 0x010F
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    8680:	80 93 2f 09 	sts	0x092F, r24
	VacantTimer8Sys += n;
    8684:	92 e0       	ldi	r25, 0x02	; 2
    8686:	98 0f       	add	r25, r24
    8688:	90 93 0f 01 	sts	0x010F, r25
    868c:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    868e:	80 93 32 09 	sts	0x0932, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    8692:	80 91 0e 01 	lds	r24, 0x010E
	TD_FlowDelay =  Timer16SysAlloc(1);
    8696:	80 93 3d 09 	sts	0x093D, r24
	VacantTimer16Sys += n;
    869a:	92 e0       	ldi	r25, 0x02	; 2
    869c:	98 0f       	add	r25, r24
    869e:	90 93 0e 01 	sts	0x010E, r25
    86a2:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    86a4:	80 93 57 09 	sts	0x0957, r24
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    86a8:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <Timer32Alloc>
    86ac:	80 93 16 06 	sts	0x0616, r24
	TD_WebSessTimeout	= Timer32Alloc();
    86b0:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <Timer32Alloc>
    86b4:	80 93 55 09 	sts	0x0955, r24
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    86b8:	80 91 12 01 	lds	r24, 0x0112
    86bc:	88 31       	cpi	r24, 0x18	; 24
    86be:	40 f4       	brcc	.+16     	; 0x86d0 <WebInit+0x54>
    86c0:	80 91 11 01 	lds	r24, 0x0111
    86c4:	88 32       	cpi	r24, 0x28	; 40
    86c6:	20 f4       	brcc	.+8      	; 0x86d0 <WebInit+0x54>
    86c8:	80 91 10 01 	lds	r24, 0x0110
    86cc:	80 32       	cpi	r24, 0x20	; 32
    86ce:	40 f0       	brcs	.+16     	; 0x86e0 <WebInit+0x64>

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
    86d0:	0e 94 30 43 	call	0x8660	; 0x8660 <HideMsg>
	CurrMsg = Msg;
    86d4:	87 ef       	ldi	r24, 0xF7	; 247
    86d6:	9c e4       	ldi	r25, 0x4C	; 76
    86d8:	90 93 13 0b 	sts	0x0B13, r25
    86dc:	80 93 12 0b 	sts	0x0B12, r24
    86e0:	08 95       	ret

000086e2 <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    86e2:	0f 93       	push	r16
    86e4:	1f 93       	push	r17
    86e6:	cf 93       	push	r28
    86e8:	df 93       	push	r29
    86ea:	8b 01       	movw	r16, r22
	if(prb(&Field->Prec)){
    86ec:	ec 01       	movw	r28, r24
    86ee:	2f 96       	adiw	r28, 0x0f	; 15

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    86f0:	fe 01       	movw	r30, r28
    86f2:	84 91       	lpm	r24, Z
    86f4:	88 23       	and	r24, r24
    86f6:	69 f1       	breq	.+90     	; 0x8752 <WebPresicionHanler+0x70>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    86f8:	6e e2       	ldi	r22, 0x2E	; 46
    86fa:	70 e0       	ldi	r23, 0x00	; 0
    86fc:	c8 01       	movw	r24, r16
    86fe:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
		if(p==NULL){
    8702:	00 97       	sbiw	r24, 0x00	; 0
    8704:	29 f4       	brne	.+10     	; 0x8710 <WebPresicionHanler+0x2e>
			p = strchr(BufStr,' ');	//else seek for first space
    8706:	60 e2       	ldi	r22, 0x20	; 32
    8708:	70 e0       	ldi	r23, 0x00	; 0
    870a:	c8 01       	movw	r24, r16
    870c:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8710:	dc 01       	movw	r26, r24
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    8712:	40 e3       	ldi	r20, 0x30	; 48
    8714:	fe 01       	movw	r30, r28
    8716:	24 91       	lpm	r18, Z
    8718:	3a 2f       	mov	r19, r26
    871a:	38 1b       	sub	r19, r24
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    871c:	32 17       	cp	r19, r18
    871e:	c8 f4       	brcc	.+50     	; 0x8752 <WebPresicionHanler+0x70>
			if(*p == ' ') *p='0'; 
    8720:	2c 91       	ld	r18, X
    8722:	20 32       	cpi	r18, 0x20	; 32
    8724:	09 f4       	brne	.+2      	; 0x8728 <WebPresicionHanler+0x46>
    8726:	4c 93       	st	X, r20
			if(*p == '.'){
    8728:	5c 91       	ld	r21, X
    872a:	5e 32       	cpi	r21, 0x2E	; 46
    872c:	81 f4       	brne	.+32     	; 0x874e <WebPresicionHanler+0x6c>
				if(isdigit(*(p+1))){
    872e:	11 96       	adiw	r26, 0x01	; 1
    8730:	6c 91       	ld	r22, X
    8732:	11 97       	sbiw	r26, 0x01	; 1
    8734:	26 2f       	mov	r18, r22
    8736:	30 e0       	ldi	r19, 0x00	; 0
    8738:	20 53       	subi	r18, 0x30	; 48
    873a:	31 09       	sbc	r19, r1
    873c:	2a 30       	cpi	r18, 0x0A	; 10
    873e:	31 05       	cpc	r19, r1
    8740:	28 f4       	brcc	.+10     	; 0x874c <WebPresicionHanler+0x6a>
					*p= *(p+1);
    8742:	6c 93       	st	X, r22
					*(p+1) = '.';
    8744:	11 96       	adiw	r26, 0x01	; 1
    8746:	5c 93       	st	X, r21
    8748:	11 97       	sbiw	r26, 0x01	; 1
    874a:	01 c0       	rjmp	.+2      	; 0x874e <WebPresicionHanler+0x6c>
				}
				else *p='0'; 
    874c:	4c 93       	st	X, r20
			}
			p++;
    874e:	11 96       	adiw	r26, 0x01	; 1
    8750:	e1 cf       	rjmp	.-62     	; 0x8714 <WebPresicionHanler+0x32>
		}
	}
	
}
    8752:	df 91       	pop	r29
    8754:	cf 91       	pop	r28
    8756:	1f 91       	pop	r17
    8758:	0f 91       	pop	r16
    875a:	08 95       	ret

0000875c <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    875c:	2f 92       	push	r2
    875e:	3f 92       	push	r3
    8760:	4f 92       	push	r4
    8762:	5f 92       	push	r5
    8764:	6f 92       	push	r6
    8766:	7f 92       	push	r7
    8768:	8f 92       	push	r8
    876a:	9f 92       	push	r9
    876c:	af 92       	push	r10
    876e:	bf 92       	push	r11
    8770:	cf 92       	push	r12
    8772:	df 92       	push	r13
    8774:	ef 92       	push	r14
    8776:	ff 92       	push	r15
    8778:	0f 93       	push	r16
    877a:	1f 93       	push	r17
    877c:	cf 93       	push	r28
    877e:	df 93       	push	r29
    8780:	cd b7       	in	r28, 0x3d	; 61
    8782:	de b7       	in	r29, 0x3e	; 62
    8784:	2e 97       	sbiw	r28, 0x0e	; 14
    8786:	0f b6       	in	r0, 0x3f	; 63
    8788:	f8 94       	cli
    878a:	de bf       	out	0x3e, r29	; 62
    878c:	0f be       	out	0x3f, r0	; 63
    878e:	cd bf       	out	0x3d, r28	; 61
    8790:	6c 01       	movw	r12, r24
    8792:	8b 01       	movw	r16, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    8794:	2d b7       	in	r18, 0x3d	; 61
    8796:	3e b7       	in	r19, 0x3e	; 62
    8798:	3e 87       	std	Y+14, r19	; 0x0e
    879a:	2d 87       	std	Y+13, r18	; 0x0d
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
    879c:	fc 01       	movw	r30, r24
    879e:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    87a0:	e5 90       	lpm	r14, Z+
    87a2:	f4 90       	lpm	r15, Z
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    87a4:	1c 01       	movw	r2, r24
    87a6:	3f e0       	ldi	r19, 0x0F	; 15
    87a8:	23 0e       	add	r2, r19
    87aa:	31 1c       	adc	r3, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    87ac:	f1 01       	movw	r30, r2
    87ae:	84 91       	lpm	r24, Z
    87b0:	98 2f       	mov	r25, r24
    87b2:	97 70       	andi	r25, 0x07	; 7
    87b4:	21 e0       	ldi	r18, 0x01	; 1
    87b6:	30 e0       	ldi	r19, 0x00	; 0
    87b8:	02 c0       	rjmp	.+4      	; 0x87be <WebBuf2Field+0x62>
    87ba:	22 0f       	add	r18, r18
    87bc:	33 1f       	adc	r19, r19
    87be:	9a 95       	dec	r25
    87c0:	e2 f7       	brpl	.-8      	; 0x87ba <WebBuf2Field+0x5e>
    87c2:	3a 87       	std	Y+10, r19	; 0x0a
    87c4:	29 87       	std	Y+9, r18	; 0x09
    87c6:	86 95       	lsr	r24
    87c8:	86 95       	lsr	r24
    87ca:	86 95       	lsr	r24
    87cc:	97 01       	movw	r18, r14
    87ce:	28 0f       	add	r18, r24
    87d0:	31 1d       	adc	r19, r1
    87d2:	3c 87       	std	Y+12, r19	; 0x0c
    87d4:	2b 87       	std	Y+11, r18	; 0x0b
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);
    87d6:	c6 01       	movw	r24, r12
    87d8:	03 96       	adiw	r24, 0x03	; 3
    87da:	0e 94 3f 29 	call	0x527e	; 0x527e <prd>
    87de:	2b 01       	movw	r4, r22
    87e0:	3c 01       	movw	r6, r24
    87e2:	c6 01       	movw	r24, r12
    87e4:	07 96       	adiw	r24, 0x07	; 7
    87e6:	0e 94 3f 29 	call	0x527e	; 0x527e <prd>
    87ea:	4b 01       	movw	r8, r22
    87ec:	5c 01       	movw	r10, r24

	uint32_t Temp=0;
    87ee:	1d 82       	std	Y+5, r1	; 0x05
    87f0:	1e 82       	std	Y+6, r1	; 0x06
    87f2:	1f 82       	std	Y+7, r1	; 0x07
    87f4:	18 86       	std	Y+8, r1	; 0x08
	float fTemp=0;
    87f6:	19 82       	std	Y+1, r1	; 0x01
    87f8:	1a 82       	std	Y+2, r1	; 0x02
    87fa:	1b 82       	std	Y+3, r1	; 0x03
    87fc:	1c 82       	std	Y+4, r1	; 0x04
    87fe:	f6 01       	movw	r30, r12
    8800:	84 91       	lpm	r24, Z


	switch(prb(&Field->Type)) {
    8802:	90 e0       	ldi	r25, 0x00	; 0
    8804:	83 32       	cpi	r24, 0x23	; 35
    8806:	91 05       	cpc	r25, r1
    8808:	08 f0       	brcs	.+2      	; 0x880c <WebBuf2Field+0xb0>
    880a:	f0 c2       	rjmp	.+1504   	; 0x8dec <WebBuf2Field+0x690>
    880c:	fc 01       	movw	r30, r24
    880e:	ea 59       	subi	r30, 0x9A	; 154
    8810:	ff 4f       	sbci	r31, 0xFF	; 255
    8812:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8816:	b8 01       	movw	r22, r16
    8818:	c6 01       	movw	r24, r12
    881a:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    881e:	ce 01       	movw	r24, r28
    8820:	05 96       	adiw	r24, 0x05	; 5
    8822:	9f 93       	push	r25
    8824:	8f 93       	push	r24
    8826:	82 e9       	ldi	r24, 0x92	; 146
    8828:	91 e0       	ldi	r25, 0x01	; 1
    882a:	9f 93       	push	r25
    882c:	8f 93       	push	r24
    882e:	1f 93       	push	r17
    8830:	0f 93       	push	r16
    8832:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		SetField(Temp, uint8_t);
    8836:	8d 81       	ldd	r24, Y+5	; 0x05
    8838:	9e 81       	ldd	r25, Y+6	; 0x06
    883a:	af 81       	ldd	r26, Y+7	; 0x07
    883c:	b8 85       	ldd	r27, Y+8	; 0x08
    883e:	0f 90       	pop	r0
    8840:	0f 90       	pop	r0
    8842:	0f 90       	pop	r0
    8844:	0f 90       	pop	r0
    8846:	0f 90       	pop	r0
    8848:	0f 90       	pop	r0
    884a:	b5 01       	movw	r22, r10
    884c:	a4 01       	movw	r20, r8
    884e:	55 27       	eor	r21, r21
    8850:	66 27       	eor	r22, r22
    8852:	77 27       	eor	r23, r23
    8854:	48 17       	cp	r20, r24
    8856:	59 07       	cpc	r21, r25
    8858:	6a 07       	cpc	r22, r26
    885a:	7b 07       	cpc	r23, r27
    885c:	08 f4       	brcc	.+2      	; 0x8860 <WebBuf2Field+0x104>
    885e:	5f c0       	rjmp	.+190    	; 0x891e <WebBuf2Field+0x1c2>
    8860:	b3 01       	movw	r22, r6
    8862:	a2 01       	movw	r20, r4
    8864:	55 27       	eor	r21, r21
    8866:	66 27       	eor	r22, r22
    8868:	77 27       	eor	r23, r23
    886a:	61 c0       	rjmp	.+194    	; 0x892e <WebBuf2Field+0x1d2>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    886c:	b8 01       	movw	r22, r16
    886e:	c6 01       	movw	r24, r12
    8870:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    8874:	ce 01       	movw	r24, r28
    8876:	05 96       	adiw	r24, 0x05	; 5
    8878:	9f 93       	push	r25
    887a:	8f 93       	push	r24
    887c:	82 e9       	ldi	r24, 0x92	; 146
    887e:	91 e0       	ldi	r25, 0x01	; 1
    8880:	9f 93       	push	r25
    8882:	8f 93       	push	r24
    8884:	1f 93       	push	r17
    8886:	0f 93       	push	r16
    8888:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    888c:	0f 90       	pop	r0
    888e:	0f 90       	pop	r0
    8890:	0f 90       	pop	r0
    8892:	0f 90       	pop	r0
    8894:	0f 90       	pop	r0
    8896:	0f 90       	pop	r0
    8898:	01 97       	sbiw	r24, 0x01	; 1
    889a:	09 f0       	breq	.+2      	; 0x889e <WebBuf2Field+0x142>
    889c:	a7 c2       	rjmp	.+1358   	; 0x8dec <WebBuf2Field+0x690>
			SetEEField(Temp, uint8_t, uint8_t, b);
    889e:	6d 81       	ldd	r22, Y+5	; 0x05
    88a0:	7e 81       	ldd	r23, Y+6	; 0x06
    88a2:	8f 81       	ldd	r24, Y+7	; 0x07
    88a4:	98 85       	ldd	r25, Y+8	; 0x08
    88a6:	95 01       	movw	r18, r10
    88a8:	84 01       	movw	r16, r8
    88aa:	11 27       	eor	r17, r17
    88ac:	22 27       	eor	r18, r18
    88ae:	33 27       	eor	r19, r19
    88b0:	06 17       	cp	r16, r22
    88b2:	17 07       	cpc	r17, r23
    88b4:	28 07       	cpc	r18, r24
    88b6:	39 07       	cpc	r19, r25
    88b8:	08 f4       	brcc	.+2      	; 0x88bc <WebBuf2Field+0x160>
    88ba:	5e c0       	rjmp	.+188    	; 0x8978 <WebBuf2Field+0x21c>
    88bc:	93 01       	movw	r18, r6
    88be:	82 01       	movw	r16, r4
    88c0:	11 27       	eor	r17, r17
    88c2:	22 27       	eor	r18, r18
    88c4:	33 27       	eor	r19, r19
    88c6:	60 17       	cp	r22, r16
    88c8:	71 07       	cpc	r23, r17
    88ca:	82 07       	cpc	r24, r18
    88cc:	93 07       	cpc	r25, r19
    88ce:	08 f0       	brcs	.+2      	; 0x88d2 <WebBuf2Field+0x176>
    88d0:	d7 c1       	rjmp	.+942    	; 0x8c80 <WebBuf2Field+0x524>
    88d2:	d3 c1       	rjmp	.+934    	; 0x8c7a <WebBuf2Field+0x51e>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    88d4:	b8 01       	movw	r22, r16
    88d6:	c6 01       	movw	r24, r12
    88d8:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    88dc:	ce 01       	movw	r24, r28
    88de:	05 96       	adiw	r24, 0x05	; 5
    88e0:	9f 93       	push	r25
    88e2:	8f 93       	push	r24
    88e4:	87 e9       	ldi	r24, 0x97	; 151
    88e6:	91 e0       	ldi	r25, 0x01	; 1
    88e8:	9f 93       	push	r25
    88ea:	8f 93       	push	r24
    88ec:	1f 93       	push	r17
    88ee:	0f 93       	push	r16
    88f0:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		SetField(Temp, int8_t);
    88f4:	8d 81       	ldd	r24, Y+5	; 0x05
    88f6:	9e 81       	ldd	r25, Y+6	; 0x06
    88f8:	af 81       	ldd	r26, Y+7	; 0x07
    88fa:	b8 85       	ldd	r27, Y+8	; 0x08
    88fc:	0f 90       	pop	r0
    88fe:	0f 90       	pop	r0
    8900:	0f 90       	pop	r0
    8902:	0f 90       	pop	r0
    8904:	0f 90       	pop	r0
    8906:	0f 90       	pop	r0
    8908:	48 2d       	mov	r20, r8
    890a:	55 27       	eor	r21, r21
    890c:	47 fd       	sbrc	r20, 7
    890e:	50 95       	com	r21
    8910:	65 2f       	mov	r22, r21
    8912:	75 2f       	mov	r23, r21
    8914:	48 17       	cp	r20, r24
    8916:	59 07       	cpc	r21, r25
    8918:	6a 07       	cpc	r22, r26
    891a:	7b 07       	cpc	r23, r27
    891c:	10 f4       	brcc	.+4      	; 0x8922 <WebBuf2Field+0x1c6>
    891e:	f7 01       	movw	r30, r14
    8920:	cc c1       	rjmp	.+920    	; 0x8cba <WebBuf2Field+0x55e>
    8922:	44 2d       	mov	r20, r4
    8924:	55 27       	eor	r21, r21
    8926:	47 fd       	sbrc	r20, 7
    8928:	50 95       	com	r21
    892a:	65 2f       	mov	r22, r21
    892c:	75 2f       	mov	r23, r21
    892e:	f7 01       	movw	r30, r14
    8930:	84 17       	cp	r24, r20
    8932:	95 07       	cpc	r25, r21
    8934:	a6 07       	cpc	r26, r22
    8936:	b7 07       	cpc	r27, r23
    8938:	08 f4       	brcc	.+2      	; 0x893c <WebBuf2Field+0x1e0>
    893a:	9b c1       	rjmp	.+822    	; 0x8c72 <WebBuf2Field+0x516>
    893c:	80 83       	st	Z, r24
    893e:	56 c2       	rjmp	.+1196   	; 0x8dec <WebBuf2Field+0x690>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    8940:	b8 01       	movw	r22, r16
    8942:	c6 01       	movw	r24, r12
    8944:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    8948:	ce 01       	movw	r24, r28
    894a:	05 96       	adiw	r24, 0x05	; 5
    894c:	9f 93       	push	r25
    894e:	8f 93       	push	r24
    8950:	87 e9       	ldi	r24, 0x97	; 151
    8952:	91 e0       	ldi	r25, 0x01	; 1
    8954:	9f 93       	push	r25
    8956:	8f 93       	push	r24
    8958:	1f 93       	push	r17
    895a:	0f 93       	push	r16
    895c:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    8960:	0f 90       	pop	r0
    8962:	0f 90       	pop	r0
    8964:	0f 90       	pop	r0
    8966:	0f 90       	pop	r0
    8968:	0f 90       	pop	r0
    896a:	0f 90       	pop	r0
    896c:	01 97       	sbiw	r24, 0x01	; 1
    896e:	09 f0       	breq	.+2      	; 0x8972 <WebBuf2Field+0x216>
    8970:	3d c2       	rjmp	.+1146   	; 0x8dec <WebBuf2Field+0x690>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    8972:	6d 81       	ldd	r22, Y+5	; 0x05
    8974:	86 16       	cp	r8, r22
    8976:	14 f4       	brge	.+4      	; 0x897c <WebBuf2Field+0x220>
    8978:	68 2d       	mov	r22, r8
    897a:	82 c1       	rjmp	.+772    	; 0x8c80 <WebBuf2Field+0x524>
    897c:	64 15       	cp	r22, r4
    897e:	0c f0       	brlt	.+2      	; 0x8982 <WebBuf2Field+0x226>
    8980:	7f c1       	rjmp	.+766    	; 0x8c80 <WebBuf2Field+0x524>
    8982:	7b c1       	rjmp	.+758    	; 0x8c7a <WebBuf2Field+0x51e>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8984:	b8 01       	movw	r22, r16
    8986:	c6 01       	movw	r24, r12
    8988:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    898c:	ce 01       	movw	r24, r28
    898e:	05 96       	adiw	r24, 0x05	; 5
    8990:	9f 93       	push	r25
    8992:	8f 93       	push	r24
    8994:	8b e9       	ldi	r24, 0x9B	; 155
    8996:	91 e0       	ldi	r25, 0x01	; 1
    8998:	9f 93       	push	r25
    899a:	8f 93       	push	r24
    899c:	1f 93       	push	r17
    899e:	0f 93       	push	r16
    89a0:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		SetField(Temp, uint16_t);
    89a4:	8d 81       	ldd	r24, Y+5	; 0x05
    89a6:	9e 81       	ldd	r25, Y+6	; 0x06
    89a8:	af 81       	ldd	r26, Y+7	; 0x07
    89aa:	b8 85       	ldd	r27, Y+8	; 0x08
    89ac:	0f 90       	pop	r0
    89ae:	0f 90       	pop	r0
    89b0:	0f 90       	pop	r0
    89b2:	0f 90       	pop	r0
    89b4:	0f 90       	pop	r0
    89b6:	0f 90       	pop	r0
    89b8:	b5 01       	movw	r22, r10
    89ba:	a4 01       	movw	r20, r8
    89bc:	66 27       	eor	r22, r22
    89be:	77 27       	eor	r23, r23
    89c0:	48 17       	cp	r20, r24
    89c2:	59 07       	cpc	r21, r25
    89c4:	6a 07       	cpc	r22, r26
    89c6:	7b 07       	cpc	r23, r27
    89c8:	08 f4       	brcc	.+2      	; 0x89cc <WebBuf2Field+0x270>
    89ca:	5b c0       	rjmp	.+182    	; 0x8a82 <WebBuf2Field+0x326>
    89cc:	b3 01       	movw	r22, r6
    89ce:	a2 01       	movw	r20, r4
    89d0:	66 27       	eor	r22, r22
    89d2:	77 27       	eor	r23, r23
    89d4:	5f c0       	rjmp	.+190    	; 0x8a94 <WebBuf2Field+0x338>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    89d6:	b8 01       	movw	r22, r16
    89d8:	c6 01       	movw	r24, r12
    89da:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    89de:	ce 01       	movw	r24, r28
    89e0:	05 96       	adiw	r24, 0x05	; 5
    89e2:	9f 93       	push	r25
    89e4:	8f 93       	push	r24
    89e6:	8f e9       	ldi	r24, 0x9F	; 159
    89e8:	91 e0       	ldi	r25, 0x01	; 1
    89ea:	9f 93       	push	r25
    89ec:	8f 93       	push	r24
    89ee:	1f 93       	push	r17
    89f0:	0f 93       	push	r16
    89f2:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    89f6:	0f 90       	pop	r0
    89f8:	0f 90       	pop	r0
    89fa:	0f 90       	pop	r0
    89fc:	0f 90       	pop	r0
    89fe:	0f 90       	pop	r0
    8a00:	0f 90       	pop	r0
    8a02:	01 97       	sbiw	r24, 0x01	; 1
    8a04:	09 f0       	breq	.+2      	; 0x8a08 <WebBuf2Field+0x2ac>
    8a06:	f2 c1       	rjmp	.+996    	; 0x8dec <WebBuf2Field+0x690>
			SetEEField(Temp, uint16_t, uint16_t, w);
    8a08:	6d 81       	ldd	r22, Y+5	; 0x05
    8a0a:	7e 81       	ldd	r23, Y+6	; 0x06
    8a0c:	8f 81       	ldd	r24, Y+7	; 0x07
    8a0e:	98 85       	ldd	r25, Y+8	; 0x08
    8a10:	95 01       	movw	r18, r10
    8a12:	84 01       	movw	r16, r8
    8a14:	22 27       	eor	r18, r18
    8a16:	33 27       	eor	r19, r19
    8a18:	06 17       	cp	r16, r22
    8a1a:	17 07       	cpc	r17, r23
    8a1c:	28 07       	cpc	r18, r24
    8a1e:	39 07       	cpc	r19, r25
    8a20:	08 f4       	brcc	.+2      	; 0x8a24 <WebBuf2Field+0x2c8>
    8a22:	64 c0       	rjmp	.+200    	; 0x8aec <WebBuf2Field+0x390>
    8a24:	93 01       	movw	r18, r6
    8a26:	82 01       	movw	r16, r4
    8a28:	22 27       	eor	r18, r18
    8a2a:	33 27       	eor	r19, r19
    8a2c:	60 17       	cp	r22, r16
    8a2e:	71 07       	cpc	r23, r17
    8a30:	82 07       	cpc	r24, r18
    8a32:	93 07       	cpc	r25, r19
    8a34:	08 f0       	brcs	.+2      	; 0x8a38 <WebBuf2Field+0x2dc>
    8a36:	60 c0       	rjmp	.+192    	; 0x8af8 <WebBuf2Field+0x39c>
    8a38:	5e c0       	rjmp	.+188    	; 0x8af6 <WebBuf2Field+0x39a>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    8a3a:	b8 01       	movw	r22, r16
    8a3c:	c6 01       	movw	r24, r12
    8a3e:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    8a42:	ce 01       	movw	r24, r28
    8a44:	05 96       	adiw	r24, 0x05	; 5
    8a46:	9f 93       	push	r25
    8a48:	8f 93       	push	r24
    8a4a:	84 ea       	ldi	r24, 0xA4	; 164
    8a4c:	91 e0       	ldi	r25, 0x01	; 1
    8a4e:	9f 93       	push	r25
    8a50:	8f 93       	push	r24
    8a52:	1f 93       	push	r17
    8a54:	0f 93       	push	r16
    8a56:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		SetField(Temp, int16_t);
    8a5a:	8d 81       	ldd	r24, Y+5	; 0x05
    8a5c:	9e 81       	ldd	r25, Y+6	; 0x06
    8a5e:	af 81       	ldd	r26, Y+7	; 0x07
    8a60:	b8 85       	ldd	r27, Y+8	; 0x08
    8a62:	0f 90       	pop	r0
    8a64:	0f 90       	pop	r0
    8a66:	0f 90       	pop	r0
    8a68:	0f 90       	pop	r0
    8a6a:	0f 90       	pop	r0
    8a6c:	0f 90       	pop	r0
    8a6e:	a4 01       	movw	r20, r8
    8a70:	66 27       	eor	r22, r22
    8a72:	57 fd       	sbrc	r21, 7
    8a74:	60 95       	com	r22
    8a76:	76 2f       	mov	r23, r22
    8a78:	48 17       	cp	r20, r24
    8a7a:	59 07       	cpc	r21, r25
    8a7c:	6a 07       	cpc	r22, r26
    8a7e:	7b 07       	cpc	r23, r27
    8a80:	20 f4       	brcc	.+8      	; 0x8a8a <WebBuf2Field+0x32e>
    8a82:	f7 01       	movw	r30, r14
    8a84:	91 82       	std	Z+1, r9	; 0x01
    8a86:	80 82       	st	Z, r8
    8a88:	b1 c1       	rjmp	.+866    	; 0x8dec <WebBuf2Field+0x690>
    8a8a:	a2 01       	movw	r20, r4
    8a8c:	66 27       	eor	r22, r22
    8a8e:	57 fd       	sbrc	r21, 7
    8a90:	60 95       	com	r22
    8a92:	76 2f       	mov	r23, r22
    8a94:	f7 01       	movw	r30, r14
    8a96:	84 17       	cp	r24, r20
    8a98:	95 07       	cpc	r25, r21
    8a9a:	a6 07       	cpc	r26, r22
    8a9c:	b7 07       	cpc	r27, r23
    8a9e:	18 f4       	brcc	.+6      	; 0x8aa6 <WebBuf2Field+0x34a>
    8aa0:	51 82       	std	Z+1, r5	; 0x01
    8aa2:	40 82       	st	Z, r4
    8aa4:	a3 c1       	rjmp	.+838    	; 0x8dec <WebBuf2Field+0x690>
    8aa6:	91 83       	std	Z+1, r25	; 0x01
    8aa8:	80 83       	st	Z, r24
    8aaa:	a0 c1       	rjmp	.+832    	; 0x8dec <WebBuf2Field+0x690>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8aac:	b8 01       	movw	r22, r16
    8aae:	c6 01       	movw	r24, r12
    8ab0:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    8ab4:	ce 01       	movw	r24, r28
    8ab6:	05 96       	adiw	r24, 0x05	; 5
    8ab8:	9f 93       	push	r25
    8aba:	8f 93       	push	r24
    8abc:	84 ea       	ldi	r24, 0xA4	; 164
    8abe:	91 e0       	ldi	r25, 0x01	; 1
    8ac0:	9f 93       	push	r25
    8ac2:	8f 93       	push	r24
    8ac4:	1f 93       	push	r17
    8ac6:	0f 93       	push	r16
    8ac8:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    8acc:	0f 90       	pop	r0
    8ace:	0f 90       	pop	r0
    8ad0:	0f 90       	pop	r0
    8ad2:	0f 90       	pop	r0
    8ad4:	0f 90       	pop	r0
    8ad6:	0f 90       	pop	r0
    8ad8:	01 97       	sbiw	r24, 0x01	; 1
    8ada:	09 f0       	breq	.+2      	; 0x8ade <WebBuf2Field+0x382>
    8adc:	87 c1       	rjmp	.+782    	; 0x8dec <WebBuf2Field+0x690>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    8ade:	6d 81       	ldd	r22, Y+5	; 0x05
    8ae0:	7e 81       	ldd	r23, Y+6	; 0x06
    8ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    8ae4:	98 85       	ldd	r25, Y+8	; 0x08
    8ae6:	86 16       	cp	r8, r22
    8ae8:	97 06       	cpc	r9, r23
    8aea:	14 f4       	brge	.+4      	; 0x8af0 <WebBuf2Field+0x394>
    8aec:	b4 01       	movw	r22, r8
    8aee:	04 c0       	rjmp	.+8      	; 0x8af8 <WebBuf2Field+0x39c>
    8af0:	64 15       	cp	r22, r4
    8af2:	75 05       	cpc	r23, r5
    8af4:	0c f4       	brge	.+2      	; 0x8af8 <WebBuf2Field+0x39c>
    8af6:	b2 01       	movw	r22, r4
    8af8:	c7 01       	movw	r24, r14
    8afa:	0e 94 ce 29 	call	0x539c	; 0x539c <eww>
    8afe:	76 c1       	rjmp	.+748    	; 0x8dec <WebBuf2Field+0x690>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    8b00:	f7 01       	movw	r30, r14
    8b02:	11 82       	std	Z+1, r1	; 0x01
    8b04:	10 82       	st	Z, r1
		break;
    8b06:	72 c1       	rjmp	.+740    	; 0x8dec <WebBuf2Field+0x690>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8b08:	b8 01       	movw	r22, r16
    8b0a:	c6 01       	movw	r24, r12
    8b0c:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    8b10:	ce 01       	movw	r24, r28
    8b12:	05 96       	adiw	r24, 0x05	; 5
    8b14:	9f 93       	push	r25
    8b16:	8f 93       	push	r24
    8b18:	8f e9       	ldi	r24, 0x9F	; 159
    8b1a:	91 e0       	ldi	r25, 0x01	; 1
    8b1c:	15 c0       	rjmp	.+42     	; 0x8b48 <WebBuf2Field+0x3ec>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8b1e:	b8 01       	movw	r22, r16
    8b20:	c6 01       	movw	r24, r12
    8b22:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8b26:	ce 01       	movw	r24, r28
    8b28:	05 96       	adiw	r24, 0x05	; 5
    8b2a:	9f 93       	push	r25
    8b2c:	8f 93       	push	r24
    8b2e:	8f e9       	ldi	r24, 0x9F	; 159
    8b30:	91 e0       	ldi	r25, 0x01	; 1
    8b32:	3e c0       	rjmp	.+124    	; 0x8bb0 <WebBuf2Field+0x454>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    8b34:	b8 01       	movw	r22, r16
    8b36:	c6 01       	movw	r24, r12
    8b38:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    8b3c:	ce 01       	movw	r24, r28
    8b3e:	05 96       	adiw	r24, 0x05	; 5
    8b40:	9f 93       	push	r25
    8b42:	8f 93       	push	r24
    8b44:	87 ea       	ldi	r24, 0xA7	; 167
    8b46:	91 e0       	ldi	r25, 0x01	; 1
    8b48:	9f 93       	push	r25
    8b4a:	8f 93       	push	r24
    8b4c:	1f 93       	push	r17
    8b4e:	0f 93       	push	r16
    8b50:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		SetField(Temp, int32_t);
    8b54:	8d 81       	ldd	r24, Y+5	; 0x05
    8b56:	9e 81       	ldd	r25, Y+6	; 0x06
    8b58:	af 81       	ldd	r26, Y+7	; 0x07
    8b5a:	b8 85       	ldd	r27, Y+8	; 0x08
    8b5c:	0f 90       	pop	r0
    8b5e:	0f 90       	pop	r0
    8b60:	0f 90       	pop	r0
    8b62:	0f 90       	pop	r0
    8b64:	0f 90       	pop	r0
    8b66:	0f 90       	pop	r0
    8b68:	f7 01       	movw	r30, r14
    8b6a:	88 16       	cp	r8, r24
    8b6c:	99 06       	cpc	r9, r25
    8b6e:	aa 06       	cpc	r10, r26
    8b70:	bb 06       	cpc	r11, r27
    8b72:	28 f4       	brcc	.+10     	; 0x8b7e <WebBuf2Field+0x422>
    8b74:	80 82       	st	Z, r8
    8b76:	91 82       	std	Z+1, r9	; 0x01
    8b78:	a2 82       	std	Z+2, r10	; 0x02
    8b7a:	b3 82       	std	Z+3, r11	; 0x03
    8b7c:	37 c1       	rjmp	.+622    	; 0x8dec <WebBuf2Field+0x690>
    8b7e:	84 15       	cp	r24, r4
    8b80:	95 05       	cpc	r25, r5
    8b82:	a6 05       	cpc	r26, r6
    8b84:	b7 05       	cpc	r27, r7
    8b86:	28 f4       	brcc	.+10     	; 0x8b92 <WebBuf2Field+0x436>
    8b88:	40 82       	st	Z, r4
    8b8a:	51 82       	std	Z+1, r5	; 0x01
    8b8c:	62 82       	std	Z+2, r6	; 0x02
    8b8e:	73 82       	std	Z+3, r7	; 0x03
    8b90:	2d c1       	rjmp	.+602    	; 0x8dec <WebBuf2Field+0x690>
    8b92:	80 83       	st	Z, r24
    8b94:	91 83       	std	Z+1, r25	; 0x01
    8b96:	a2 83       	std	Z+2, r26	; 0x02
    8b98:	b3 83       	std	Z+3, r27	; 0x03
    8b9a:	28 c1       	rjmp	.+592    	; 0x8dec <WebBuf2Field+0x690>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8b9c:	b8 01       	movw	r22, r16
    8b9e:	c6 01       	movw	r24, r12
    8ba0:	0e 94 71 43 	call	0x86e2	; 0x86e2 <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    8ba4:	ce 01       	movw	r24, r28
    8ba6:	05 96       	adiw	r24, 0x05	; 5
    8ba8:	9f 93       	push	r25
    8baa:	8f 93       	push	r24
    8bac:	87 ea       	ldi	r24, 0xA7	; 167
    8bae:	91 e0       	ldi	r25, 0x01	; 1
    8bb0:	9f 93       	push	r25
    8bb2:	8f 93       	push	r24
    8bb4:	1f 93       	push	r17
    8bb6:	0f 93       	push	r16
    8bb8:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    8bbc:	0f 90       	pop	r0
    8bbe:	0f 90       	pop	r0
    8bc0:	0f 90       	pop	r0
    8bc2:	0f 90       	pop	r0
    8bc4:	0f 90       	pop	r0
    8bc6:	0f 90       	pop	r0
    8bc8:	01 97       	sbiw	r24, 0x01	; 1
    8bca:	09 f0       	breq	.+2      	; 0x8bce <WebBuf2Field+0x472>
    8bcc:	0f c1       	rjmp	.+542    	; 0x8dec <WebBuf2Field+0x690>
			SetEEField(Temp, int32_t, uint32_t, d);
    8bce:	4d 81       	ldd	r20, Y+5	; 0x05
    8bd0:	5e 81       	ldd	r21, Y+6	; 0x06
    8bd2:	6f 81       	ldd	r22, Y+7	; 0x07
    8bd4:	78 85       	ldd	r23, Y+8	; 0x08
    8bd6:	84 16       	cp	r8, r20
    8bd8:	95 06       	cpc	r9, r21
    8bda:	a6 06       	cpc	r10, r22
    8bdc:	b7 06       	cpc	r11, r23
    8bde:	18 f4       	brcc	.+6      	; 0x8be6 <WebBuf2Field+0x48a>
    8be0:	b5 01       	movw	r22, r10
    8be2:	a4 01       	movw	r20, r8
    8be4:	07 c0       	rjmp	.+14     	; 0x8bf4 <WebBuf2Field+0x498>
    8be6:	44 15       	cp	r20, r4
    8be8:	55 05       	cpc	r21, r5
    8bea:	66 05       	cpc	r22, r6
    8bec:	77 05       	cpc	r23, r7
    8bee:	10 f4       	brcc	.+4      	; 0x8bf4 <WebBuf2Field+0x498>
    8bf0:	b3 01       	movw	r22, r6
    8bf2:	a2 01       	movw	r20, r4
    8bf4:	c7 01       	movw	r24, r14
    8bf6:	0e 94 d2 29 	call	0x53a4	; 0x53a4 <ewd>
    8bfa:	f8 c0       	rjmp	.+496    	; 0x8dec <WebBuf2Field+0x690>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    8bfc:	ce 01       	movw	r24, r28
    8bfe:	01 96       	adiw	r24, 0x01	; 1
    8c00:	9f 93       	push	r25
    8c02:	8f 93       	push	r24
    8c04:	8b ea       	ldi	r24, 0xAB	; 171
    8c06:	91 e0       	ldi	r25, 0x01	; 1
    8c08:	9f 93       	push	r25
    8c0a:	8f 93       	push	r24
    8c0c:	1f 93       	push	r17
    8c0e:	0f 93       	push	r16
    8c10:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		*(float*)Var = fTemp;
    8c14:	89 81       	ldd	r24, Y+1	; 0x01
    8c16:	9a 81       	ldd	r25, Y+2	; 0x02
    8c18:	ab 81       	ldd	r26, Y+3	; 0x03
    8c1a:	bc 81       	ldd	r27, Y+4	; 0x04
    8c1c:	f7 01       	movw	r30, r14
    8c1e:	80 83       	st	Z, r24
    8c20:	91 83       	std	Z+1, r25	; 0x01
    8c22:	a2 83       	std	Z+2, r26	; 0x02
    8c24:	b3 83       	std	Z+3, r27	; 0x03
		break;
    8c26:	0f 90       	pop	r0
    8c28:	0f 90       	pop	r0
    8c2a:	0f 90       	pop	r0
    8c2c:	0f 90       	pop	r0
    8c2e:	0f 90       	pop	r0
    8c30:	0f 90       	pop	r0
    8c32:	dc c0       	rjmp	.+440    	; 0x8dec <WebBuf2Field+0x690>
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    8c34:	9e 01       	movw	r18, r28
    8c36:	2f 5f       	subi	r18, 0xFF	; 255
    8c38:	3f 4f       	sbci	r19, 0xFF	; 255
    8c3a:	59 01       	movw	r10, r18
    8c3c:	bf 92       	push	r11
    8c3e:	2f 93       	push	r18
    8c40:	8b ea       	ldi	r24, 0xAB	; 171
    8c42:	91 e0       	ldi	r25, 0x01	; 1
    8c44:	9f 93       	push	r25
    8c46:	8f 93       	push	r24
    8c48:	1f 93       	push	r17
    8c4a:	0f 93       	push	r16
    8c4c:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
    8c50:	0f 90       	pop	r0
    8c52:	0f 90       	pop	r0
    8c54:	0f 90       	pop	r0
    8c56:	0f 90       	pop	r0
    8c58:	0f 90       	pop	r0
    8c5a:	0f 90       	pop	r0
    8c5c:	01 97       	sbiw	r24, 0x01	; 1
    8c5e:	09 f0       	breq	.+2      	; 0x8c62 <WebBuf2Field+0x506>
    8c60:	c5 c0       	rjmp	.+394    	; 0x8dec <WebBuf2Field+0x690>
			ewbl(&fTemp, (float*)Var, 4);
    8c62:	44 e0       	ldi	r20, 0x04	; 4
    8c64:	50 e0       	ldi	r21, 0x00	; 0
    8c66:	b7 01       	movw	r22, r14
    8c68:	c5 01       	movw	r24, r10
    8c6a:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
    8c6e:	be c0       	rjmp	.+380    	; 0x8dec <WebBuf2Field+0x690>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    8c70:	f7 01       	movw	r30, r14
    8c72:	40 82       	st	Z, r4
    8c74:	bb c0       	rjmp	.+374    	; 0x8dec <WebBuf2Field+0x690>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    8c76:	44 20       	and	r4, r4
    8c78:	11 f0       	breq	.+4      	; 0x8c7e <WebBuf2Field+0x522>
    8c7a:	64 2d       	mov	r22, r4
    8c7c:	01 c0       	rjmp	.+2      	; 0x8c80 <WebBuf2Field+0x524>
    8c7e:	60 e0       	ldi	r22, 0x00	; 0
    8c80:	c7 01       	movw	r24, r14
    8c82:	43 c0       	rjmp	.+134    	; 0x8d0a <WebBuf2Field+0x5ae>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8c84:	ce 01       	movw	r24, r28
    8c86:	05 96       	adiw	r24, 0x05	; 5
    8c88:	9f 93       	push	r25
    8c8a:	8f 93       	push	r24
    8c8c:	82 e9       	ldi	r24, 0x92	; 146
    8c8e:	91 e0       	ldi	r25, 0x01	; 1
    8c90:	9f 93       	push	r25
    8c92:	8f 93       	push	r24
    8c94:	1f 93       	push	r17
    8c96:	0f 93       	push	r16
    8c98:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
		if((unsigned short int)Temp)
    8c9c:	0f 90       	pop	r0
    8c9e:	0f 90       	pop	r0
    8ca0:	0f 90       	pop	r0
    8ca2:	0f 90       	pop	r0
    8ca4:	0f 90       	pop	r0
    8ca6:	0f 90       	pop	r0
    8ca8:	8d 81       	ldd	r24, Y+5	; 0x05
    8caa:	9e 81       	ldd	r25, Y+6	; 0x06
    8cac:	eb 85       	ldd	r30, Y+11	; 0x0b
    8cae:	fc 85       	ldd	r31, Y+12	; 0x0c
    8cb0:	20 81       	ld	r18, Z
			*BitVar |=Mask;
    8cb2:	89 84       	ldd	r8, Y+9	; 0x09
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
		if((unsigned short int)Temp)
    8cb4:	89 2b       	or	r24, r25
    8cb6:	19 f0       	breq	.+6      	; 0x8cbe <WebBuf2Field+0x562>
			*BitVar |=Mask;
    8cb8:	82 2a       	or	r8, r18
    8cba:	80 82       	st	Z, r8
    8cbc:	97 c0       	rjmp	.+302    	; 0x8dec <WebBuf2Field+0x690>
		else
			*BitVar &=~Mask;
    8cbe:	80 94       	com	r8
    8cc0:	82 22       	and	r8, r18
    8cc2:	eb 85       	ldd	r30, Y+11	; 0x0b
    8cc4:	fc 85       	ldd	r31, Y+12	; 0x0c
    8cc6:	f9 cf       	rjmp	.-14     	; 0x8cba <WebBuf2Field+0x55e>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8cc8:	ce 01       	movw	r24, r28
    8cca:	05 96       	adiw	r24, 0x05	; 5
    8ccc:	9f 93       	push	r25
    8cce:	8f 93       	push	r24
    8cd0:	82 e9       	ldi	r24, 0x92	; 146
    8cd2:	91 e0       	ldi	r25, 0x01	; 1
    8cd4:	9f 93       	push	r25
    8cd6:	8f 93       	push	r24
    8cd8:	1f 93       	push	r17
    8cda:	0f 93       	push	r16
    8cdc:	0e 94 c1 6c 	call	0xd982	; 0xd982 <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8ce0:	8b 85       	ldd	r24, Y+11	; 0x0b
    8ce2:	9c 85       	ldd	r25, Y+12	; 0x0c
    8ce4:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    8ce8:	0f 90       	pop	r0
    8cea:	0f 90       	pop	r0
    8cec:	0f 90       	pop	r0
    8cee:	0f 90       	pop	r0
    8cf0:	0f 90       	pop	r0
    8cf2:	0f 90       	pop	r0
    8cf4:	2d 81       	ldd	r18, Y+5	; 0x05
    8cf6:	3e 81       	ldd	r19, Y+6	; 0x06
    8cf8:	69 85       	ldd	r22, Y+9	; 0x09
    8cfa:	23 2b       	or	r18, r19
    8cfc:	11 f0       	breq	.+4      	; 0x8d02 <WebBuf2Field+0x5a6>
    8cfe:	68 2b       	or	r22, r24
    8d00:	02 c0       	rjmp	.+4      	; 0x8d06 <WebBuf2Field+0x5aa>
    8d02:	60 95       	com	r22
    8d04:	68 23       	and	r22, r24
    8d06:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d08:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d0a:	0e 94 c3 29 	call	0x5386	; 0x5386 <ewb>
		break;
    8d0e:	6e c0       	rjmp	.+220    	; 0x8dec <WebBuf2Field+0x690>
    8d10:	ad b6       	in	r10, 0x3d	; 61
    8d12:	be b6       	in	r11, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8d14:	f1 01       	movw	r30, r2
    8d16:	24 90       	lpm	r2, Z


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8d18:	31 2c       	mov	r3, r1
    8d1a:	2d b7       	in	r18, 0x3d	; 61
    8d1c:	3e b7       	in	r19, 0x3e	; 62
    8d1e:	22 19       	sub	r18, r2
    8d20:	33 09       	sbc	r19, r3
    8d22:	0f b6       	in	r0, 0x3f	; 63
    8d24:	f8 94       	cli
    8d26:	3e bf       	out	0x3e, r19	; 62
    8d28:	0f be       	out	0x3f, r0	; 63
    8d2a:	2d bf       	out	0x3d, r18	; 61
    8d2c:	6d b7       	in	r22, 0x3d	; 61
    8d2e:	7e b7       	in	r23, 0x3e	; 62
    8d30:	6f 5f       	subi	r22, 0xFF	; 255
    8d32:	7f 4f       	sbci	r23, 0xFF	; 255
		uint8_t i=0;
    8d34:	90 e0       	ldi	r25, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d36:	31 e0       	ldi	r19, 0x01	; 1
    8d38:	23 1a       	sub	r2, r19
    8d3a:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8d3c:	20 e2       	ldi	r18, 0x20	; 32
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d3e:	49 2f       	mov	r20, r25
    8d40:	50 e0       	ldi	r21, 0x00	; 0
    8d42:	fb 01       	movw	r30, r22
    8d44:	e4 0f       	add	r30, r20
    8d46:	f5 1f       	adc	r31, r21
    8d48:	42 15       	cp	r20, r2
    8d4a:	53 05       	cpc	r21, r3
    8d4c:	3c f0       	brlt	.+14     	; 0x8d5c <WebBuf2Field+0x600>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8d4e:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    8d50:	4f 5f       	subi	r20, 0xFF	; 255
    8d52:	5f 4f       	sbci	r21, 0xFF	; 255
    8d54:	c7 01       	movw	r24, r14
    8d56:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
    8d5a:	33 c0       	rjmp	.+102    	; 0x8dc2 <WebBuf2Field+0x666>
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d5c:	d8 01       	movw	r26, r16
    8d5e:	a4 0f       	add	r26, r20
    8d60:	b5 1f       	adc	r27, r21
    8d62:	8c 91       	ld	r24, X
    8d64:	80 32       	cpi	r24, 0x20	; 32
    8d66:	99 f3       	breq	.-26     	; 0x8d4e <WebBuf2Field+0x5f2>
    8d68:	86 32       	cpi	r24, 0x26	; 38
    8d6a:	89 f3       	breq	.-30     	; 0x8d4e <WebBuf2Field+0x5f2>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8d6c:	8b 32       	cpi	r24, 0x2B	; 43
    8d6e:	11 f4       	brne	.+4      	; 0x8d74 <WebBuf2Field+0x618>
    8d70:	20 83       	st	Z, r18
    8d72:	01 c0       	rjmp	.+2      	; 0x8d76 <WebBuf2Field+0x61a>
			else TempStr[i]=BufStr[i];
    8d74:	80 83       	st	Z, r24
			i++;
    8d76:	9f 5f       	subi	r25, 0xFF	; 255
    8d78:	e2 cf       	rjmp	.-60     	; 0x8d3e <WebBuf2Field+0x5e2>
    8d7a:	ad b6       	in	r10, 0x3d	; 61
    8d7c:	be b6       	in	r11, 0x3e	; 62
    8d7e:	f1 01       	movw	r30, r2
    8d80:	24 90       	lpm	r2, Z

		break;
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8d82:	31 2c       	mov	r3, r1
    8d84:	2d b7       	in	r18, 0x3d	; 61
    8d86:	3e b7       	in	r19, 0x3e	; 62
    8d88:	22 19       	sub	r18, r2
    8d8a:	33 09       	sbc	r19, r3
    8d8c:	0f b6       	in	r0, 0x3f	; 63
    8d8e:	f8 94       	cli
    8d90:	3e bf       	out	0x3e, r19	; 62
    8d92:	0f be       	out	0x3f, r0	; 63
    8d94:	2d bf       	out	0x3d, r18	; 61
    8d96:	8d b7       	in	r24, 0x3d	; 61
    8d98:	9e b7       	in	r25, 0x3e	; 62
    8d9a:	01 96       	adiw	r24, 0x01	; 1
		uint8_t i=0;
    8d9c:	30 e0       	ldi	r19, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d9e:	e1 e0       	ldi	r30, 0x01	; 1
    8da0:	2e 1a       	sub	r2, r30
    8da2:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8da4:	60 e2       	ldi	r22, 0x20	; 32
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8da6:	43 2f       	mov	r20, r19
    8da8:	50 e0       	ldi	r21, 0x00	; 0
    8daa:	fc 01       	movw	r30, r24
    8dac:	e4 0f       	add	r30, r20
    8dae:	f5 1f       	adc	r31, r21
    8db0:	42 15       	cp	r20, r2
    8db2:	53 05       	cpc	r21, r3
    8db4:	64 f0       	brlt	.+24     	; 0x8dce <WebBuf2Field+0x672>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8db6:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    8db8:	4f 5f       	subi	r20, 0xFF	; 255
    8dba:	5f 4f       	sbci	r21, 0xFF	; 255
    8dbc:	b7 01       	movw	r22, r14
    8dbe:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
    8dc2:	0f b6       	in	r0, 0x3f	; 63
    8dc4:	f8 94       	cli
    8dc6:	be be       	out	0x3e, r11	; 62
    8dc8:	0f be       	out	0x3f, r0	; 63
    8dca:	ad be       	out	0x3d, r10	; 61
		}
		break;
    8dcc:	0f c0       	rjmp	.+30     	; 0x8dec <WebBuf2Field+0x690>
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dce:	d8 01       	movw	r26, r16
    8dd0:	a4 0f       	add	r26, r20
    8dd2:	b5 1f       	adc	r27, r21
    8dd4:	2c 91       	ld	r18, X
    8dd6:	20 32       	cpi	r18, 0x20	; 32
    8dd8:	71 f3       	breq	.-36     	; 0x8db6 <WebBuf2Field+0x65a>
    8dda:	26 32       	cpi	r18, 0x26	; 38
    8ddc:	61 f3       	breq	.-40     	; 0x8db6 <WebBuf2Field+0x65a>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8dde:	2b 32       	cpi	r18, 0x2B	; 43
    8de0:	11 f4       	brne	.+4      	; 0x8de6 <WebBuf2Field+0x68a>
    8de2:	60 83       	st	Z, r22
    8de4:	01 c0       	rjmp	.+2      	; 0x8de8 <WebBuf2Field+0x68c>
			else TempStr[i]=BufStr[i];
    8de6:	20 83       	st	Z, r18
			i++;
    8de8:	3f 5f       	subi	r19, 0xFF	; 255
    8dea:	dd cf       	rjmp	.-70     	; 0x8da6 <WebBuf2Field+0x64a>
		ewbl(TempStr, Var, i+1);
		}
		break;
	}

	EventFunc(&Field->Act);
    8dec:	fb e0       	ldi	r31, 0x0B	; 11
    8dee:	cf 0e       	add	r12, r31
    8df0:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8df2:	f6 01       	movw	r30, r12
    8df4:	85 91       	lpm	r24, Z+
    8df6:	94 91       	lpm	r25, Z
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8df8:	00 97       	sbiw	r24, 0x00	; 0
    8dfa:	11 f0       	breq	.+4      	; 0x8e00 <WebBuf2Field+0x6a4>
		Func();
    8dfc:	fc 01       	movw	r30, r24
    8dfe:	09 95       	icall
}
    8e00:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e02:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e04:	0f b6       	in	r0, 0x3f	; 63
    8e06:	f8 94       	cli
    8e08:	3e bf       	out	0x3e, r19	; 62
    8e0a:	0f be       	out	0x3f, r0	; 63
    8e0c:	2d bf       	out	0x3d, r18	; 61
    8e0e:	2e 96       	adiw	r28, 0x0e	; 14
    8e10:	0f b6       	in	r0, 0x3f	; 63
    8e12:	f8 94       	cli
    8e14:	de bf       	out	0x3e, r29	; 62
    8e16:	0f be       	out	0x3f, r0	; 63
    8e18:	cd bf       	out	0x3d, r28	; 61
    8e1a:	df 91       	pop	r29
    8e1c:	cf 91       	pop	r28
    8e1e:	1f 91       	pop	r17
    8e20:	0f 91       	pop	r16
    8e22:	ff 90       	pop	r15
    8e24:	ef 90       	pop	r14
    8e26:	df 90       	pop	r13
    8e28:	cf 90       	pop	r12
    8e2a:	bf 90       	pop	r11
    8e2c:	af 90       	pop	r10
    8e2e:	9f 90       	pop	r9
    8e30:	8f 90       	pop	r8
    8e32:	7f 90       	pop	r7
    8e34:	6f 90       	pop	r6
    8e36:	5f 90       	pop	r5
    8e38:	4f 90       	pop	r4
    8e3a:	3f 90       	pop	r3
    8e3c:	2f 90       	pop	r2
    8e3e:	08 95       	ret

00008e40 <strcmp_PP>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8e40:	fc 01       	movw	r30, r24
    8e42:	24 91       	lpm	r18, Z
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    8e44:	22 23       	and	r18, r18
    8e46:	c1 f0       	breq	.+48     	; 0x8e78 <strcmp_PP+0x38>
    8e48:	fb 01       	movw	r30, r22
    8e4a:	24 91       	lpm	r18, Z
    8e4c:	22 23       	and	r18, r18
    8e4e:	a1 f0       	breq	.+40     	; 0x8e78 <strcmp_PP+0x38>
    8e50:	fc 01       	movw	r30, r24
    8e52:	24 91       	lpm	r18, Z
    8e54:	fb 01       	movw	r30, r22
    8e56:	34 91       	lpm	r19, Z
		if(prb(s1) > prb(s2)) return 1;
    8e58:	32 17       	cp	r19, r18
    8e5a:	50 f0       	brcs	.+20     	; 0x8e70 <strcmp_PP+0x30>
    8e5c:	fc 01       	movw	r30, r24
    8e5e:	24 91       	lpm	r18, Z
    8e60:	fb 01       	movw	r30, r22
    8e62:	34 91       	lpm	r19, Z
		if(prb(s1) < prb(s2)) return -1;
    8e64:	23 17       	cp	r18, r19
    8e66:	30 f0       	brcs	.+12     	; 0x8e74 <strcmp_PP+0x34>
		s1++;
    8e68:	01 96       	adiw	r24, 0x01	; 1
		s2++;
    8e6a:	6f 5f       	subi	r22, 0xFF	; 255
    8e6c:	7f 4f       	sbci	r23, 0xFF	; 255
    8e6e:	e8 cf       	rjmp	.-48     	; 0x8e40 <strcmp_PP>
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    8e70:	81 e0       	ldi	r24, 0x01	; 1
    8e72:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    8e74:	8f ef       	ldi	r24, 0xFF	; 255
    8e76:	08 95       	ret
		s1++;
		s2++;
	}
	return 0;	
    8e78:	80 e0       	ldi	r24, 0x00	; 0
}
    8e7a:	08 95       	ret

00008e7c <strcmp_E>:
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    8e7c:	ff 92       	push	r15
    8e7e:	0f 93       	push	r16
    8e80:	1f 93       	push	r17
    8e82:	cf 93       	push	r28
    8e84:	df 93       	push	r29
    8e86:	eb 01       	movw	r28, r22
    8e88:	8c 01       	movw	r16, r24
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8e8a:	f8 01       	movw	r30, r16
    8e8c:	f1 90       	ld	r15, Z+
    8e8e:	8f 01       	movw	r16, r30
    8e90:	ff 20       	and	r15, r15
    8e92:	49 f0       	breq	.+18     	; 0x8ea6 <strcmp_E+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8e94:	ce 01       	movw	r24, r28
    8e96:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8e9a:	8f 15       	cp	r24, r15
    8e9c:	50 f0       	brcs	.+20     	; 0x8eb2 <strcmp_E+0x36>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8e9e:	f8 16       	cp	r15, r24
    8ea0:	50 f0       	brcs	.+20     	; 0x8eb6 <strcmp_E+0x3a>
		str_RAM++;
		str_EE++;		
    8ea2:	21 96       	adiw	r28, 0x01	; 1
    8ea4:	f2 cf       	rjmp	.-28     	; 0x8e8a <strcmp_E+0xe>
    8ea6:	ce 01       	movw	r24, r28
    8ea8:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8eac:	81 11       	cpse	r24, r1
    8eae:	f2 cf       	rjmp	.-28     	; 0x8e94 <strcmp_E+0x18>
    8eb0:	03 c0       	rjmp	.+6      	; 0x8eb8 <strcmp_E+0x3c>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8eb2:	81 e0       	ldi	r24, 0x01	; 1
    8eb4:	01 c0       	rjmp	.+2      	; 0x8eb8 <strcmp_E+0x3c>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8eb6:	8f ef       	ldi	r24, 0xFF	; 255
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    8eb8:	df 91       	pop	r29
    8eba:	cf 91       	pop	r28
    8ebc:	1f 91       	pop	r17
    8ebe:	0f 91       	pop	r16
    8ec0:	ff 90       	pop	r15
    8ec2:	08 95       	ret

00008ec4 <SeekTagFORM>:
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
	static uint8_t match;
	switch(match) {
    8ec4:	40 91 3d 02 	lds	r20, 0x023D
    8ec8:	50 e0       	ldi	r21, 0x00	; 0
    8eca:	49 30       	cpi	r20, 0x09	; 9
    8ecc:	51 05       	cpc	r21, r1
    8ece:	88 f5       	brcc	.+98     	; 0x8f32 <SeekTagFORM+0x6e>
    8ed0:	fa 01       	movw	r30, r20
    8ed2:	e7 57       	subi	r30, 0x77	; 119
    8ed4:	ff 4f       	sbci	r31, 0xFF	; 255
    8ed6:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8eda:	8c 33       	cpi	r24, 0x3C	; 60
    8edc:	61 f5       	brne	.+88     	; 0x8f36 <SeekTagFORM+0x72>
    8ede:	81 e0       	ldi	r24, 0x01	; 1
    8ee0:	1f c0       	rjmp	.+62     	; 0x8f20 <SeekTagFORM+0x5c>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    8ee2:	8f 7d       	andi	r24, 0xDF	; 223
    8ee4:	86 34       	cpi	r24, 0x46	; 70
    8ee6:	29 f5       	brne	.+74     	; 0x8f32 <SeekTagFORM+0x6e>
    8ee8:	82 e0       	ldi	r24, 0x02	; 2
    8eea:	1a c0       	rjmp	.+52     	; 0x8f20 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    8eec:	8f 7d       	andi	r24, 0xDF	; 223
    8eee:	8f 34       	cpi	r24, 0x4F	; 79
    8ef0:	01 f5       	brne	.+64     	; 0x8f32 <SeekTagFORM+0x6e>
    8ef2:	83 e0       	ldi	r24, 0x03	; 3
    8ef4:	15 c0       	rjmp	.+42     	; 0x8f20 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    8ef6:	8f 7d       	andi	r24, 0xDF	; 223
    8ef8:	82 35       	cpi	r24, 0x52	; 82
    8efa:	d9 f4       	brne	.+54     	; 0x8f32 <SeekTagFORM+0x6e>
    8efc:	84 e0       	ldi	r24, 0x04	; 4
    8efe:	10 c0       	rjmp	.+32     	; 0x8f20 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    8f00:	8f 7d       	andi	r24, 0xDF	; 223
    8f02:	8d 34       	cpi	r24, 0x4D	; 77
    8f04:	b1 f4       	brne	.+44     	; 0x8f32 <SeekTagFORM+0x6e>
    8f06:	85 e0       	ldi	r24, 0x05	; 5
    8f08:	0b c0       	rjmp	.+22     	; 0x8f20 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    8f0a:	80 32       	cpi	r24, 0x20	; 32
    8f0c:	91 f4       	brne	.+36     	; 0x8f32 <SeekTagFORM+0x6e>
    8f0e:	86 e0       	ldi	r24, 0x06	; 6
    8f10:	07 c0       	rjmp	.+14     	; 0x8f20 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    8f12:	8e 33       	cpi	r24, 0x3E	; 62
    8f14:	81 f4       	brne	.+32     	; 0x8f36 <SeekTagFORM+0x72>
    8f16:	87 e0       	ldi	r24, 0x07	; 7
    8f18:	03 c0       	rjmp	.+6      	; 0x8f20 <SeekTagFORM+0x5c>
			break;
		case 7:
			if(ch=='\r') match = 8;
    8f1a:	8d 30       	cpi	r24, 0x0D	; 13
    8f1c:	51 f4       	brne	.+20     	; 0x8f32 <SeekTagFORM+0x6e>
    8f1e:	88 e0       	ldi	r24, 0x08	; 8
    8f20:	80 93 3d 02 	sts	0x023D, r24
    8f24:	08 c0       	rjmp	.+16     	; 0x8f36 <SeekTagFORM+0x72>
			else match = 0;
			break;
		case 8:
			match = 0;
    8f26:	10 92 3d 02 	sts	0x023D, r1
			if(ch=='\n') return 1;
    8f2a:	91 e0       	ldi	r25, 0x01	; 1
    8f2c:	8a 30       	cpi	r24, 0x0A	; 10
    8f2e:	19 f4       	brne	.+6      	; 0x8f36 <SeekTagFORM+0x72>
    8f30:	03 c0       	rjmp	.+6      	; 0x8f38 <SeekTagFORM+0x74>
			break;
		default:
			match = 0;
    8f32:	10 92 3d 02 	sts	0x023D, r1
	}
	return 0;
    8f36:	90 e0       	ldi	r25, 0x00	; 0

}
    8f38:	89 2f       	mov	r24, r25
    8f3a:	08 95       	ret

00008f3c <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    8f3c:	40 91 3c 02 	lds	r20, 0x023C
    8f40:	50 e0       	ldi	r21, 0x00	; 0
    8f42:	49 30       	cpi	r20, 0x09	; 9
    8f44:	51 05       	cpc	r21, r1
    8f46:	90 f5       	brcc	.+100    	; 0x8fac <SeekTagA_HREF+0x70>
    8f48:	fa 01       	movw	r30, r20
    8f4a:	ee 56       	subi	r30, 0x6E	; 110
    8f4c:	ff 4f       	sbci	r31, 0xFF	; 255
    8f4e:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8f52:	8c 33       	cpi	r24, 0x3C	; 60
    8f54:	69 f5       	brne	.+90     	; 0x8fb0 <SeekTagA_HREF+0x74>
    8f56:	81 e0       	ldi	r24, 0x01	; 1
    8f58:	20 c0       	rjmp	.+64     	; 0x8f9a <SeekTagA_HREF+0x5e>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    8f5a:	8f 7d       	andi	r24, 0xDF	; 223
    8f5c:	81 34       	cpi	r24, 0x41	; 65
    8f5e:	31 f5       	brne	.+76     	; 0x8fac <SeekTagA_HREF+0x70>
    8f60:	82 e0       	ldi	r24, 0x02	; 2
    8f62:	1b c0       	rjmp	.+54     	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    8f64:	80 32       	cpi	r24, 0x20	; 32
    8f66:	11 f5       	brne	.+68     	; 0x8fac <SeekTagA_HREF+0x70>
    8f68:	83 e0       	ldi	r24, 0x03	; 3
    8f6a:	17 c0       	rjmp	.+46     	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    8f6c:	8f 7d       	andi	r24, 0xDF	; 223
    8f6e:	88 34       	cpi	r24, 0x48	; 72
    8f70:	e9 f4       	brne	.+58     	; 0x8fac <SeekTagA_HREF+0x70>
    8f72:	84 e0       	ldi	r24, 0x04	; 4
    8f74:	12 c0       	rjmp	.+36     	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    8f76:	8f 7d       	andi	r24, 0xDF	; 223
    8f78:	82 35       	cpi	r24, 0x52	; 82
    8f7a:	c1 f4       	brne	.+48     	; 0x8fac <SeekTagA_HREF+0x70>
    8f7c:	85 e0       	ldi	r24, 0x05	; 5
    8f7e:	0d c0       	rjmp	.+26     	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    8f80:	8f 7d       	andi	r24, 0xDF	; 223
    8f82:	85 34       	cpi	r24, 0x45	; 69
    8f84:	99 f4       	brne	.+38     	; 0x8fac <SeekTagA_HREF+0x70>
    8f86:	86 e0       	ldi	r24, 0x06	; 6
    8f88:	08 c0       	rjmp	.+16     	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    8f8a:	8f 7d       	andi	r24, 0xDF	; 223
    8f8c:	86 34       	cpi	r24, 0x46	; 70
    8f8e:	71 f4       	brne	.+28     	; 0x8fac <SeekTagA_HREF+0x70>
    8f90:	87 e0       	ldi	r24, 0x07	; 7
    8f92:	03 c0       	rjmp	.+6      	; 0x8f9a <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    8f94:	82 32       	cpi	r24, 0x22	; 34
    8f96:	61 f4       	brne	.+24     	; 0x8fb0 <SeekTagA_HREF+0x74>
    8f98:	88 e0       	ldi	r24, 0x08	; 8
    8f9a:	80 93 3c 02 	sts	0x023C, r24
    8f9e:	08 c0       	rjmp	.+16     	; 0x8fb0 <SeekTagA_HREF+0x74>
			break;
		case 8:
			if(ch=='\"'){
    8fa0:	82 32       	cpi	r24, 0x22	; 34
    8fa2:	31 f4       	brne	.+12     	; 0x8fb0 <SeekTagA_HREF+0x74>
				match = 0;
    8fa4:	10 92 3c 02 	sts	0x023C, r1
				return 1;
    8fa8:	81 e0       	ldi	r24, 0x01	; 1
    8faa:	08 95       	ret
			}
			break;
		default:
			match = 0;
    8fac:	10 92 3c 02 	sts	0x023C, r1
	}
	return 0;
    8fb0:	80 e0       	ldi	r24, 0x00	; 0
}
    8fb2:	08 95       	ret

00008fb4 <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    8fb4:	40 91 3b 02 	lds	r20, 0x023B
    8fb8:	50 e0       	ldi	r21, 0x00	; 0
    8fba:	4a 30       	cpi	r20, 0x0A	; 10
    8fbc:	51 05       	cpc	r21, r1
    8fbe:	b8 f5       	brcc	.+110    	; 0x902e <SeekTagIMG_SRC+0x7a>
    8fc0:	fa 01       	movw	r30, r20
    8fc2:	e5 56       	subi	r30, 0x65	; 101
    8fc4:	ff 4f       	sbci	r31, 0xFF	; 255
    8fc6:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8fca:	8c 33       	cpi	r24, 0x3C	; 60
    8fcc:	91 f5       	brne	.+100    	; 0x9032 <SeekTagIMG_SRC+0x7e>
    8fce:	81 e0       	ldi	r24, 0x01	; 1
    8fd0:	25 c0       	rjmp	.+74     	; 0x901c <SeekTagIMG_SRC+0x68>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    8fd2:	8f 7d       	andi	r24, 0xDF	; 223
    8fd4:	89 34       	cpi	r24, 0x49	; 73
    8fd6:	59 f5       	brne	.+86     	; 0x902e <SeekTagIMG_SRC+0x7a>
    8fd8:	82 e0       	ldi	r24, 0x02	; 2
    8fda:	20 c0       	rjmp	.+64     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    8fdc:	8f 7d       	andi	r24, 0xDF	; 223
    8fde:	8d 34       	cpi	r24, 0x4D	; 77
    8fe0:	31 f5       	brne	.+76     	; 0x902e <SeekTagIMG_SRC+0x7a>
    8fe2:	83 e0       	ldi	r24, 0x03	; 3
    8fe4:	1b c0       	rjmp	.+54     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    8fe6:	8f 7d       	andi	r24, 0xDF	; 223
    8fe8:	87 34       	cpi	r24, 0x47	; 71
    8fea:	09 f5       	brne	.+66     	; 0x902e <SeekTagIMG_SRC+0x7a>
    8fec:	84 e0       	ldi	r24, 0x04	; 4
    8fee:	16 c0       	rjmp	.+44     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    8ff0:	80 32       	cpi	r24, 0x20	; 32
    8ff2:	e9 f4       	brne	.+58     	; 0x902e <SeekTagIMG_SRC+0x7a>
    8ff4:	85 e0       	ldi	r24, 0x05	; 5
    8ff6:	12 c0       	rjmp	.+36     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    8ff8:	8f 7d       	andi	r24, 0xDF	; 223
    8ffa:	83 35       	cpi	r24, 0x53	; 83
    8ffc:	c1 f4       	brne	.+48     	; 0x902e <SeekTagIMG_SRC+0x7a>
    8ffe:	86 e0       	ldi	r24, 0x06	; 6
    9000:	0d c0       	rjmp	.+26     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    9002:	8f 7d       	andi	r24, 0xDF	; 223
    9004:	82 35       	cpi	r24, 0x52	; 82
    9006:	99 f4       	brne	.+38     	; 0x902e <SeekTagIMG_SRC+0x7a>
    9008:	87 e0       	ldi	r24, 0x07	; 7
    900a:	08 c0       	rjmp	.+16     	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    900c:	8f 7d       	andi	r24, 0xDF	; 223
    900e:	83 34       	cpi	r24, 0x43	; 67
    9010:	71 f4       	brne	.+28     	; 0x902e <SeekTagIMG_SRC+0x7a>
    9012:	88 e0       	ldi	r24, 0x08	; 8
    9014:	03 c0       	rjmp	.+6      	; 0x901c <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    9016:	82 32       	cpi	r24, 0x22	; 34
    9018:	61 f4       	brne	.+24     	; 0x9032 <SeekTagIMG_SRC+0x7e>
    901a:	89 e0       	ldi	r24, 0x09	; 9
    901c:	80 93 3b 02 	sts	0x023B, r24
    9020:	08 c0       	rjmp	.+16     	; 0x9032 <SeekTagIMG_SRC+0x7e>
			break;
		case 9:
			if(ch=='\"'){
    9022:	82 32       	cpi	r24, 0x22	; 34
    9024:	31 f4       	brne	.+12     	; 0x9032 <SeekTagIMG_SRC+0x7e>
				match = 0;
    9026:	10 92 3b 02 	sts	0x023B, r1
				return 1;
    902a:	81 e0       	ldi	r24, 0x01	; 1
    902c:	08 95       	ret
			}
			break;
		default:
			match = 0;
    902e:	10 92 3b 02 	sts	0x023B, r1
	}
	return 0;
    9032:	80 e0       	ldi	r24, 0x00	; 0
}
    9034:	08 95       	ret

00009036 <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    9036:	cf 92       	push	r12
    9038:	df 92       	push	r13
    903a:	ef 92       	push	r14
    903c:	ff 92       	push	r15
    903e:	0f 93       	push	r16
    9040:	1f 93       	push	r17
    9042:	cf 93       	push	r28
    9044:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    9046:	80 91 6b 09 	lds	r24, 0x096B
    904a:	81 11       	cpse	r24, r1
    904c:	73 c0       	rjmp	.+230    	; 0x9134 <Web_Login_Error+0xfe>
//	if(strcmp_E(Web_Passw_Str, Web_Passws) ) return 3;
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
    904e:	10 92 59 0a 	sts	0x0A59, r1
    9052:	04 ef       	ldi	r16, 0xF4	; 244
    9054:	11 e0       	ldi	r17, 0x01	; 1
    9056:	ca e2       	ldi	r28, 0x2A	; 42
    9058:	d0 e0       	ldi	r29, 0x00	; 0
    905a:	ff 24       	eor	r15, r15
    905c:	f3 94       	inc	r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    905e:	f8 01       	movw	r30, r16
    9060:	65 91       	lpm	r22, Z+
    9062:	74 91       	lpm	r23, Z
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
    9064:	84 ee       	ldi	r24, 0xE4	; 228
    9066:	99 e0       	ldi	r25, 0x09	; 9
    9068:	0e 94 20 47 	call	0x8e40	; 0x8e40 <strcmp_PP>
    906c:	81 11       	cpse	r24, r1
    906e:	09 c0       	rjmp	.+18     	; 0x9082 <Web_Login_Error+0x4c>
    9070:	be 01       	movw	r22, r28
    9072:	8e ee       	ldi	r24, 0xEE	; 238
    9074:	95 e0       	ldi	r25, 0x05	; 5
    9076:	0e 94 3e 47 	call	0x8e7c	; 0x8e7c <strcmp_E>
    907a:	81 11       	cpse	r24, r1
    907c:	02 c0       	rjmp	.+4      	; 0x9082 <Web_Login_Error+0x4c>
    907e:	f0 92 59 0a 	sts	0x0A59, r15
    9082:	f3 94       	inc	r15
    9084:	00 5f       	subi	r16, 0xF0	; 240
    9086:	1f 4f       	sbci	r17, 0xFF	; 255
    9088:	2b 96       	adiw	r28, 0x0b	; 11
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    908a:	85 e0       	ldi	r24, 0x05	; 5
    908c:	f8 12       	cpse	r15, r24
    908e:	e7 cf       	rjmp	.-50     	; 0x905e <Web_Login_Error+0x28>
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
    9090:	80 91 59 0a 	lds	r24, 0x0A59
    9094:	88 23       	and	r24, r24
    9096:	09 f4       	brne	.+2      	; 0x909a <Web_Login_Error+0x64>
    9098:	4f c0       	rjmp	.+158    	; 0x9138 <Web_Login_Error+0x102>
	return 2;}


	WebSession = 1;
    909a:	81 e0       	ldi	r24, 0x01	; 1
    909c:	80 93 6b 09 	sts	0x096B, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    90a0:	c0 91 16 06 	lds	r28, 0x0616

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    90a4:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint32_t Time = Timer32[TimerN];
    90a8:	94 e0       	ldi	r25, 0x04	; 4
    90aa:	c9 9f       	mul	r28, r25
    90ac:	f0 01       	movw	r30, r0
    90ae:	11 24       	eor	r1, r1
    90b0:	e0 58       	subi	r30, 0x80	; 128
    90b2:	fd 4f       	sbci	r31, 0xFD	; 253
    90b4:	c0 80       	ld	r12, Z
    90b6:	d1 80       	ldd	r13, Z+1	; 0x01
    90b8:	e2 80       	ldd	r14, Z+2	; 0x02
    90ba:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    90bc:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
	srandom(Seed);
    90c0:	c7 01       	movw	r24, r14
    90c2:	b6 01       	movw	r22, r12
    90c4:	0e 94 bc 6b 	call	0xd778	; 0xd778 <srandom>
	random();// 
    90c8:	0e 94 b8 6b 	call	0xd770	; 0xd770 <random>
	Seed = random();
    90cc:	0e 94 b8 6b 	call	0xd770	; 0xd770 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    90d0:	9f 93       	push	r25
    90d2:	8f 93       	push	r24
    90d4:	7f 93       	push	r23
    90d6:	6f 93       	push	r22
    90d8:	8f ef       	ldi	r24, 0xFF	; 255
    90da:	92 e0       	ldi	r25, 0x02	; 2
    90dc:	9f 93       	push	r25
    90de:	8f 93       	push	r24
    90e0:	83 e2       	ldi	r24, 0x23	; 35
    90e2:	96 e0       	ldi	r25, 0x06	; 6
    90e4:	9f 93       	push	r25
    90e6:	8f 93       	push	r24
    90e8:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
	Seed = random();
    90ec:	0e 94 b8 6b 	call	0xd770	; 0xd770 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    90f0:	9f 93       	push	r25
    90f2:	8f 93       	push	r24
    90f4:	7f 93       	push	r23
    90f6:	6f 93       	push	r22
    90f8:	85 ef       	ldi	r24, 0xF5	; 245
    90fa:	92 e0       	ldi	r25, 0x02	; 2
    90fc:	9f 93       	push	r25
    90fe:	8f 93       	push	r24
    9100:	8b e2       	ldi	r24, 0x2B	; 43
    9102:	96 e0       	ldi	r25, 0x06	; 6
    9104:	9f 93       	push	r25
    9106:	8f 93       	push	r24
    9108:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    910c:	86 e5       	ldi	r24, 0x56	; 86
    910e:	90 e0       	ldi	r25, 0x00	; 0
    9110:	0e 94 76 73 	call	0xe6ec	; 0xe6ec <__eerd_dword_m128>
    9114:	ab 01       	movw	r20, r22
    9116:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    9118:	80 91 55 09 	lds	r24, 0x0955
    911c:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <StartTimer32>
	return 0;
    9120:	8d b7       	in	r24, 0x3d	; 61
    9122:	9e b7       	in	r25, 0x3e	; 62
    9124:	40 96       	adiw	r24, 0x10	; 16
    9126:	0f b6       	in	r0, 0x3f	; 63
    9128:	f8 94       	cli
    912a:	9e bf       	out	0x3e, r25	; 62
    912c:	0f be       	out	0x3f, r0	; 63
    912e:	8d bf       	out	0x3d, r24	; 61
    9130:	80 e0       	ldi	r24, 0x00	; 0
    9132:	03 c0       	rjmp	.+6      	; 0x913a <Web_Login_Error+0x104>
}
//--Session
uint8_t Web_Login_Error(void){

	//   ?
	if(WebSession) return 1;
    9134:	81 e0       	ldi	r24, 0x01	; 1
    9136:	01 c0       	rjmp	.+2      	; 0x913a <Web_Login_Error+0x104>
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
	return 2;}
    9138:	82 e0       	ldi	r24, 0x02	; 2
	Seed = random();
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}
    913a:	df 91       	pop	r29
    913c:	cf 91       	pop	r28
    913e:	1f 91       	pop	r17
    9140:	0f 91       	pop	r16
    9142:	ff 90       	pop	r15
    9144:	ef 90       	pop	r14
    9146:	df 90       	pop	r13
    9148:	cf 90       	pop	r12
    914a:	08 95       	ret

0000914c <WebRequest>:
}


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    914c:	2f 92       	push	r2
    914e:	3f 92       	push	r3
    9150:	4f 92       	push	r4
    9152:	5f 92       	push	r5
    9154:	6f 92       	push	r6
    9156:	7f 92       	push	r7
    9158:	8f 92       	push	r8
    915a:	9f 92       	push	r9
    915c:	af 92       	push	r10
    915e:	bf 92       	push	r11
    9160:	cf 92       	push	r12
    9162:	df 92       	push	r13
    9164:	ef 92       	push	r14
    9166:	ff 92       	push	r15
    9168:	0f 93       	push	r16
    916a:	1f 93       	push	r17
    916c:	cf 93       	push	r28
    916e:	df 93       	push	r29
    9170:	cd b7       	in	r28, 0x3d	; 61
    9172:	de b7       	in	r29, 0x3e	; 62
    9174:	2a 97       	sbiw	r28, 0x0a	; 10
    9176:	0f b6       	in	r0, 0x3f	; 63
    9178:	f8 94       	cli
    917a:	de bf       	out	0x3e, r29	; 62
    917c:	0f be       	out	0x3f, r0	; 63
    917e:	cd bf       	out	0x3d, r28	; 61
    9180:	9a 87       	std	Y+10, r25	; 0x0a
    9182:	89 87       	std	Y+9, r24	; 0x09
    9184:	69 83       	std	Y+1, r22	; 0x01
	
	
	WebStrLen = GetStringFromFIFO();
    9186:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    918a:	80 93 6a 08 	sts	0x086A, r24

	if(Web_POST==2){ 
    918e:	80 91 5a 09 	lds	r24, 0x095A
    9192:	82 30       	cpi	r24, 0x02	; 2
    9194:	a1 f4       	brne	.+40     	; 0x91be <WebRequest+0x72>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    9196:	80 91 2f 09 	lds	r24, 0x092F
    919a:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    919e:	88 23       	and	r24, r24
    91a0:	39 f0       	breq	.+14     	; 0x91b0 <WebRequest+0x64>
			WebStrLen = ForceEndStringFromFIFO();
    91a2:	0e 94 62 3a 	call	0x74c4	; 0x74c4 <ForceEndStringFromFIFO>
    91a6:	80 93 6a 08 	sts	0x086A, r24
			Web_POST=3;	
    91aa:	83 e0       	ldi	r24, 0x03	; 3
    91ac:	80 93 5a 09 	sts	0x095A, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    91b0:	80 91 6a 08 	lds	r24, 0x086A
    91b4:	88 23       	and	r24, r24
    91b6:	19 f0       	breq	.+6      	; 0x91be <WebRequest+0x72>
    91b8:	83 e0       	ldi	r24, 0x03	; 3
    91ba:	80 93 5a 09 	sts	0x095A, r24
	}

	//  
	if(WebStrLen){
    91be:	10 91 6a 08 	lds	r17, 0x086A
    91c2:	11 23       	and	r17, r17
    91c4:	f9 f0       	breq	.+62     	; 0x9204 <WebRequest+0xb8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    91c6:	e9 85       	ldd	r30, Y+9	; 0x09
    91c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    91ca:	25 90       	lpm	r2, Z+
    91cc:	34 90       	lpm	r3, Z
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    91ce:	6f ea       	ldi	r22, 0xAF	; 175
    91d0:	7b e4       	ldi	r23, 0x4B	; 75
    91d2:	86 e7       	ldi	r24, 0x76	; 118
    91d4:	99 e0       	ldi	r25, 0x09	; 9
    91d6:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    91da:	89 2b       	or	r24, r25
    91dc:	21 f0       	breq	.+8      	; 0x91e6 <WebRequest+0x9a>

			Web_POST = 1; 
    91de:	81 e0       	ldi	r24, 0x01	; 1
    91e0:	80 93 5a 09 	sts	0x095A, r24
    91e4:	0f c0       	rjmp	.+30     	; 0x9204 <WebRequest+0xb8>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    91e6:	80 91 5a 09 	lds	r24, 0x095A
    91ea:	81 30       	cpi	r24, 0x01	; 1
    91ec:	71 f4       	brne	.+28     	; 0x920a <WebRequest+0xbe>
    91ee:	11 30       	cpi	r17, 0x01	; 1
    91f0:	09 f0       	breq	.+2      	; 0x91f4 <WebRequest+0xa8>
    91f2:	8e c0       	rjmp	.+284    	; 0x9310 <WebRequest+0x1c4>
			Web_POST = 2;
    91f4:	82 e0       	ldi	r24, 0x02	; 2
    91f6:	80 93 5a 09 	sts	0x095A, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    91fa:	64 e6       	ldi	r22, 0x64	; 100
    91fc:	80 91 2f 09 	lds	r24, 0x092F
    9200:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
			return NULL;
    9204:	80 e0       	ldi	r24, 0x00	; 0
    9206:	90 e0       	ldi	r25, 0x00	; 0
    9208:	94 c1       	rjmp	.+808    	; 0x9532 <WebRequest+0x3e6>
		}
		if(Web_POST==3){	//  
    920a:	83 30       	cpi	r24, 0x03	; 3
    920c:	09 f0       	breq	.+2      	; 0x9210 <WebRequest+0xc4>
    920e:	80 c0       	rjmp	.+256    	; 0x9310 <WebRequest+0x1c4>
			Web_POST = 0;
    9210:	10 92 5a 09 	sts	0x095A, r1
			url = GSM_RxStr;

			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
    9214:	fc eb       	ldi	r31, 0xBC	; 188
    9216:	cf 2e       	mov	r12, r31
    9218:	fb e4       	ldi	r31, 0x4B	; 75
    921a:	df 2e       	mov	r13, r31
			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//For Debug
			#endif

			//URL 
			url = GSM_RxStr;
    921c:	a6 e7       	ldi	r26, 0x76	; 118
    921e:	ea 2e       	mov	r14, r26
    9220:	a9 e0       	ldi	r26, 0x09	; 9
    9222:	fa 2e       	mov	r15, r26
				varfield = p + 1;
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
    9224:	89 85       	ldd	r24, Y+9	; 0x09
    9226:	9a 85       	ldd	r25, Y+10	; 0x0a
    9228:	02 96       	adiw	r24, 0x02	; 2
    922a:	9a 83       	std	Y+2, r25	; 0x02
    922c:	89 83       	std	Y+1, r24	; 0x01
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    922e:	6d e3       	ldi	r22, 0x3D	; 61
    9230:	70 e0       	ldi	r23, 0x00	; 0
    9232:	c7 01       	movw	r24, r14
    9234:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    9238:	5c 01       	movw	r10, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) {
    923a:	00 97       	sbiw	r24, 0x00	; 0
    923c:	09 f4       	brne	.+2      	; 0x9240 <WebRequest+0xf4>
    923e:	4e c1       	rjmp	.+668    	; 0x94dc <WebRequest+0x390>
				return &Web_login;
				}
				nextvar=strchr(url+1,'&');
    9240:	66 e2       	ldi	r22, 0x26	; 38
    9242:	70 e0       	ldi	r23, 0x00	; 0
    9244:	c7 01       	movw	r24, r14
    9246:	01 96       	adiw	r24, 0x01	; 1
    9248:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    924c:	4c 01       	movw	r8, r24
				varfield = p + 1;
    924e:	85 01       	movw	r16, r10
    9250:	0f 5f       	subi	r16, 0xFF	; 255
    9252:	1f 4f       	sbci	r17, 0xFF	; 255
				*p = '\0';
    9254:	d5 01       	movw	r26, r10
    9256:	1c 92       	st	X, r1
    9258:	e9 81       	ldd	r30, Y+1	; 0x01
    925a:	fa 81       	ldd	r31, Y+2	; 0x02
    925c:	65 90       	lpm	r6, Z+
    925e:	74 90       	lpm	r7, Z
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9260:	20 e0       	ldi	r18, 0x00	; 0
    9262:	13 01       	movw	r2, r6
    9264:	b4 e0       	ldi	r27, 0x04	; 4
    9266:	2b 0e       	add	r2, r27
    9268:	31 1c       	adc	r3, r1
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    926a:	23 01       	movw	r4, r6
    926c:	e6 e0       	ldi	r30, 0x06	; 6
    926e:	4e 0e       	add	r4, r30
    9270:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9272:	f1 01       	movw	r30, r2
    9274:	85 91       	lpm	r24, Z+
    9276:	94 91       	lpm	r25, Z
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9278:	a2 2e       	mov	r10, r18
    927a:	b1 2c       	mov	r11, r1
    927c:	96 95       	lsr	r25
    927e:	87 95       	ror	r24
    9280:	96 95       	lsr	r25
    9282:	87 95       	ror	r24
    9284:	a8 16       	cp	r10, r24
    9286:	b9 06       	cpc	r11, r25
    9288:	50 f5       	brcc	.+84     	; 0x92de <WebRequest+0x192>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    928a:	f2 01       	movw	r30, r4
    928c:	85 91       	lpm	r24, Z+
    928e:	94 91       	lpm	r25, Z
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    9290:	00 97       	sbiw	r24, 0x00	; 0
    9292:	19 f1       	breq	.+70     	; 0x92da <WebRequest+0x18e>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    9294:	aa 0c       	add	r10, r10
    9296:	bb 1c       	adc	r11, r11
    9298:	aa 0c       	add	r10, r10
    929a:	bb 1c       	adc	r11, r11
    929c:	a8 0e       	add	r10, r24
    929e:	b9 1e       	adc	r11, r25
    92a0:	f5 01       	movw	r30, r10
    92a2:	65 91       	lpm	r22, Z+
    92a4:	74 91       	lpm	r23, Z
    92a6:	c7 01       	movw	r24, r14
    92a8:	28 87       	std	Y+8, r18	; 0x08
    92aa:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    92ae:	28 85       	ldd	r18, Y+8	; 0x08
    92b0:	89 2b       	or	r24, r25
    92b2:	99 f4       	brne	.+38     	; 0x92da <WebRequest+0x18e>
    92b4:	c8 01       	movw	r24, r16
    92b6:	8c 01       	movw	r16, r24
    92b8:	01 96       	adiw	r24, 0x01	; 1
								while(*varfield=='+') varfield++;	// ignore leading '+'
    92ba:	d8 01       	movw	r26, r16
    92bc:	3c 91       	ld	r19, X
    92be:	3b 32       	cpi	r19, 0x2B	; 43
    92c0:	d1 f3       	breq	.-12     	; 0x92b6 <WebRequest+0x16a>
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield); 
    92c2:	b2 e0       	ldi	r27, 0x02	; 2
    92c4:	ab 0e       	add	r10, r27
    92c6:	b1 1c       	adc	r11, r1
    92c8:	f5 01       	movw	r30, r10
    92ca:	85 91       	lpm	r24, Z+
    92cc:	94 91       	lpm	r25, Z
    92ce:	b8 01       	movw	r22, r16
    92d0:	28 87       	std	Y+8, r18	; 0x08
    92d2:	0e 94 ae 43 	call	0x875c	; 0x875c <WebBuf2Field>
								ptrPageVar = ptrPage;	//  -    ptrPage
    92d6:	63 01       	movw	r12, r6
    92d8:	28 85       	ldd	r18, Y+8	; 0x08
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92da:	2f 5f       	subi	r18, 0xFF	; 255
    92dc:	ca cf       	rjmp	.-108    	; 0x9272 <WebRequest+0x126>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    92de:	74 01       	movw	r14, r8
    92e0:	ef ef       	ldi	r30, 0xFF	; 255
    92e2:	ee 1a       	sub	r14, r30
    92e4:	fe 0a       	sbc	r15, r30
			}while(nextvar);	//     
    92e6:	89 28       	or	r8, r9
    92e8:	09 f0       	breq	.+2      	; 0x92ec <WebRequest+0x1a0>
    92ea:	a1 cf       	rjmp	.-190    	; 0x922e <WebRequest+0xe2>

			if(Web_LoginAttempt){				
    92ec:	80 91 34 08 	lds	r24, 0x0834
    92f0:	88 23       	and	r24, r24
    92f2:	09 f4       	brne	.+2      	; 0x92f6 <WebRequest+0x1aa>
    92f4:	18 c1       	rjmp	.+560    	; 0x9526 <WebRequest+0x3da>
				Web_LoginAttempt = 0;
    92f6:	10 92 34 08 	sts	0x0834, r1
				Web_Login_Code = Web_Login_Error();
    92fa:	0e 94 1b 48 	call	0x9036	; 0x9036 <Web_Login_Error>
    92fe:	80 93 03 06 	sts	0x0603, r24
				if(!Web_Login_Code){ return prp(ptrSite);}
    9302:	81 11       	cpse	r24, r1
    9304:	10 c1       	rjmp	.+544    	; 0x9526 <WebRequest+0x3da>
    9306:	e9 85       	ldd	r30, Y+9	; 0x09
    9308:	fa 85       	ldd	r31, Y+10	; 0x0a
    930a:	85 91       	lpm	r24, Z+
    930c:	94 91       	lpm	r25, Z
    930e:	11 c1       	rjmp	.+546    	; 0x9532 <WebRequest+0x3e6>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    9310:	66 eb       	ldi	r22, 0xB6	; 182
    9312:	7b e4       	ldi	r23, 0x4B	; 75
    9314:	86 e7       	ldi	r24, 0x76	; 118
    9316:	99 e0       	ldi	r25, 0x09	; 9
    9318:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    931c:	89 2b       	or	r24, r25
    931e:	09 f4       	brne	.+2      	; 0x9322 <WebRequest+0x1d6>
    9320:	71 cf       	rjmp	.-286    	; 0x9204 <WebRequest+0xb8>
    9322:	60 e2       	ldi	r22, 0x20	; 32
    9324:	70 e0       	ldi	r23, 0x00	; 0
    9326:	8a e7       	ldi	r24, 0x7A	; 122
    9328:	99 e0       	ldi	r25, 0x09	; 9
    932a:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    932e:	00 97       	sbiw	r24, 0x00	; 0
    9330:	09 f4       	brne	.+2      	; 0x9334 <WebRequest+0x1e8>
    9332:	68 cf       	rjmp	.-304    	; 0x9204 <WebRequest+0xb8>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    9334:	dc 01       	movw	r26, r24
    9336:	1c 92       	st	X, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9338:	64 e7       	ldi	r22, 0x74	; 116
    933a:	79 e3       	ldi	r23, 0x39	; 57
    933c:	8b e7       	ldi	r24, 0x7B	; 123
    933e:	99 e0       	ldi	r25, 0x09	; 9
    9340:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    9344:	89 2b       	or	r24, r25
    9346:	09 f4       	brne	.+2      	; 0x934a <WebRequest+0x1fe>
    9348:	eb c0       	rjmp	.+470    	; 0x9520 <WebRequest+0x3d4>
			url = strchr(url,'?');
    934a:	6f e3       	ldi	r22, 0x3F	; 63
    934c:	70 e0       	ldi	r23, 0x00	; 0
    934e:	8a e7       	ldi	r24, 0x7A	; 122
    9350:	99 e0       	ldi	r25, 0x09	; 9
    9352:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    9356:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    9358:	80 91 6b 09 	lds	r24, 0x096B
    935c:	88 23       	and	r24, r24
    935e:	09 f4       	brne	.+2      	; 0x9362 <WebRequest+0x216>
    9360:	bd c0       	rjmp	.+378    	; 0x94dc <WebRequest+0x390>
    9362:	01 15       	cp	r16, r1
    9364:	11 05       	cpc	r17, r1
    9366:	09 f4       	brne	.+2      	; 0x936a <WebRequest+0x21e>
    9368:	b9 c0       	rjmp	.+370    	; 0x94dc <WebRequest+0x390>
    936a:	48 e0       	ldi	r20, 0x08	; 8
    936c:	50 e0       	ldi	r21, 0x00	; 0
    936e:	6e e3       	ldi	r22, 0x3E	; 62
    9370:	7c e4       	ldi	r23, 0x4C	; 76
    9372:	c8 01       	movw	r24, r16
    9374:	0e 94 09 6c 	call	0xd812	; 0xd812 <strncmp_P>
    9378:	89 2b       	or	r24, r25
    937a:	09 f0       	breq	.+2      	; 0x937e <WebRequest+0x232>
    937c:	af c0       	rjmp	.+350    	; 0x94dc <WebRequest+0x390>
    937e:	40 e1       	ldi	r20, 0x10	; 16
    9380:	50 e0       	ldi	r21, 0x00	; 0
    9382:	63 e2       	ldi	r22, 0x23	; 35
    9384:	76 e0       	ldi	r23, 0x06	; 6
    9386:	c8 01       	movw	r24, r16
    9388:	08 96       	adiw	r24, 0x08	; 8
    938a:	0e 94 55 6c 	call	0xd8aa	; 0xd8aa <strncmp>
    938e:	89 2b       	or	r24, r25
    9390:	09 f0       	breq	.+2      	; 0x9394 <WebRequest+0x248>
    9392:	a4 c0       	rjmp	.+328    	; 0x94dc <WebRequest+0x390>
    9394:	61 01       	movw	r12, r2
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9396:	86 e5       	ldi	r24, 0x56	; 86
    9398:	90 e0       	ldi	r25, 0x00	; 0
    939a:	0e 94 76 73 	call	0xe6ec	; 0xe6ec <__eerd_dword_m128>
    939e:	ab 01       	movw	r20, r22
    93a0:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    93a2:	80 91 55 09 	lds	r24, 0x0955
    93a6:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <StartTimer32>
			
			*url = '\0';
    93aa:	f8 01       	movw	r30, r16
    93ac:	11 92       	st	Z+, r1
    93ae:	cf 01       	movw	r24, r30
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    93b0:	66 e2       	ldi	r22, 0x26	; 38
    93b2:	70 e0       	ldi	r23, 0x00	; 0
    93b4:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    93b8:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    93ba:	00 97       	sbiw	r24, 0x00	; 0
    93bc:	09 f4       	brne	.+2      	; 0x93c0 <WebRequest+0x274>
    93be:	77 c0       	rjmp	.+238    	; 0x94ae <WebRequest+0x362>
    93c0:	6c eb       	ldi	r22, 0xBC	; 188
    93c2:	26 2e       	mov	r2, r22
    93c4:	6b e4       	ldi	r22, 0x4B	; 75
    93c6:	36 2e       	mov	r3, r22
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    93c8:	6d e3       	ldi	r22, 0x3D	; 61
    93ca:	70 e0       	ldi	r23, 0x00	; 0
    93cc:	c8 01       	movw	r24, r16
    93ce:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    93d2:	5c 01       	movw	r10, r24
					if(p==NULL) return ptrPage;
    93d4:	00 97       	sbiw	r24, 0x00	; 0
    93d6:	09 f4       	brne	.+2      	; 0x93da <WebRequest+0x28e>
    93d8:	a6 c0       	rjmp	.+332    	; 0x9526 <WebRequest+0x3da>
					nextvar=strchr(url+1,'&');
    93da:	28 01       	movw	r4, r16
    93dc:	ff ef       	ldi	r31, 0xFF	; 255
    93de:	4f 1a       	sub	r4, r31
    93e0:	5f 0a       	sbc	r5, r31
    93e2:	66 e2       	ldi	r22, 0x26	; 38
    93e4:	70 e0       	ldi	r23, 0x00	; 0
    93e6:	c2 01       	movw	r24, r4
    93e8:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    93ec:	8c 01       	movw	r16, r24
					varfield = p + 1;
    93ee:	75 01       	movw	r14, r10
    93f0:	2f ef       	ldi	r18, 0xFF	; 255
    93f2:	e2 1a       	sub	r14, r18
    93f4:	f2 0a       	sbc	r15, r18
					*p = '\0';
    93f6:	d5 01       	movw	r26, r10
    93f8:	1c 92       	st	X, r1
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    93fa:	69 84       	ldd	r6, Y+9	; 0x09
    93fc:	7a 84       	ldd	r7, Y+10	; 0x0a
    93fe:	30 e0       	ldi	r19, 0x00	; 0
    9400:	29 81       	ldd	r18, Y+1	; 0x01
    9402:	32 17       	cp	r19, r18
    9404:	09 f4       	brne	.+2      	; 0x9408 <WebRequest+0x2bc>
    9406:	4e c0       	rjmp	.+156    	; 0x94a4 <WebRequest+0x358>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9408:	f3 01       	movw	r30, r6
    940a:	85 90       	lpm	r8, Z+
    940c:	94 90       	lpm	r9, Z
    940e:	64 01       	movw	r12, r8
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9410:	20 e0       	ldi	r18, 0x00	; 0
    9412:	f4 01       	movw	r30, r8
    9414:	34 96       	adiw	r30, 0x04	; 4
    9416:	fc 83       	std	Y+4, r31	; 0x04
    9418:	eb 83       	std	Y+3, r30	; 0x03
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    941a:	c4 01       	movw	r24, r8
    941c:	06 96       	adiw	r24, 0x06	; 6
    941e:	9e 83       	std	Y+6, r25	; 0x06
    9420:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9422:	eb 81       	ldd	r30, Y+3	; 0x03
    9424:	fc 81       	ldd	r31, Y+4	; 0x04
    9426:	85 91       	lpm	r24, Z+
    9428:	94 91       	lpm	r25, Z
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    942a:	a2 2e       	mov	r10, r18
    942c:	b1 2c       	mov	r11, r1
    942e:	96 95       	lsr	r25
    9430:	87 95       	ror	r24
    9432:	96 95       	lsr	r25
    9434:	87 95       	ror	r24
    9436:	a8 16       	cp	r10, r24
    9438:	b9 06       	cpc	r11, r25
    943a:	78 f5       	brcc	.+94     	; 0x949a <WebRequest+0x34e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    943c:	ed 81       	ldd	r30, Y+5	; 0x05
    943e:	fe 81       	ldd	r31, Y+6	; 0x06
    9440:	85 91       	lpm	r24, Z+
    9442:	94 91       	lpm	r25, Z
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    9444:	00 97       	sbiw	r24, 0x00	; 0
    9446:	39 f1       	breq	.+78     	; 0x9496 <WebRequest+0x34a>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    9448:	aa 0c       	add	r10, r10
    944a:	bb 1c       	adc	r11, r11
    944c:	aa 0c       	add	r10, r10
    944e:	bb 1c       	adc	r11, r11
    9450:	a8 0e       	add	r10, r24
    9452:	b9 1e       	adc	r11, r25
    9454:	f5 01       	movw	r30, r10
    9456:	65 91       	lpm	r22, Z+
    9458:	74 91       	lpm	r23, Z
    945a:	c2 01       	movw	r24, r4
    945c:	28 87       	std	Y+8, r18	; 0x08
    945e:	3f 83       	std	Y+7, r19	; 0x07
    9460:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    9464:	28 85       	ldd	r18, Y+8	; 0x08
    9466:	3f 81       	ldd	r19, Y+7	; 0x07
    9468:	89 2b       	or	r24, r25
    946a:	a9 f4       	brne	.+42     	; 0x9496 <WebRequest+0x34a>
    946c:	c7 01       	movw	r24, r14
    946e:	7c 01       	movw	r14, r24
    9470:	01 96       	adiw	r24, 0x01	; 1
									while(*varfield=='+') varfield++;	// ignore leading '+'
    9472:	d7 01       	movw	r26, r14
    9474:	4c 91       	ld	r20, X
    9476:	4b 32       	cpi	r20, 0x2B	; 43
    9478:	d1 f3       	breq	.-12     	; 0x946e <WebRequest+0x322>
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    947a:	b2 e0       	ldi	r27, 0x02	; 2
    947c:	ab 0e       	add	r10, r27
    947e:	b1 1c       	adc	r11, r1
    9480:	f5 01       	movw	r30, r10
    9482:	85 91       	lpm	r24, Z+
    9484:	94 91       	lpm	r25, Z
    9486:	b7 01       	movw	r22, r14
    9488:	28 87       	std	Y+8, r18	; 0x08
    948a:	3f 83       	std	Y+7, r19	; 0x07
    948c:	0e 94 ae 43 	call	0x875c	; 0x875c <WebBuf2Field>
									ptrPageVar = ptrPage;	//  -    ptrPage
    9490:	14 01       	movw	r2, r8
    9492:	3f 81       	ldd	r19, Y+7	; 0x07
    9494:	28 85       	ldd	r18, Y+8	; 0x08
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9496:	2f 5f       	subi	r18, 0xFF	; 255
    9498:	c4 cf       	rjmp	.-120    	; 0x9422 <WebRequest+0x2d6>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    949a:	3f 5f       	subi	r19, 0xFF	; 255
    949c:	e2 e0       	ldi	r30, 0x02	; 2
    949e:	6e 0e       	add	r6, r30
    94a0:	71 1c       	adc	r7, r1
    94a2:	ae cf       	rjmp	.-164    	; 0x9400 <WebRequest+0x2b4>
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    94a4:	01 15       	cp	r16, r1
    94a6:	11 05       	cpc	r17, r1
    94a8:	09 f0       	breq	.+2      	; 0x94ac <WebRequest+0x360>
    94aa:	8e cf       	rjmp	.-228    	; 0x93c8 <WebRequest+0x27c>
    94ac:	3e c0       	rjmp	.+124    	; 0x952a <WebRequest+0x3de>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    94ae:	66 e1       	ldi	r22, 0x16	; 22
    94b0:	73 e0       	ldi	r23, 0x03	; 3
    94b2:	8a e7       	ldi	r24, 0x7A	; 122
    94b4:	99 e0       	ldi	r25, 0x09	; 9
    94b6:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    94ba:	89 2b       	or	r24, r25
    94bc:	09 f4       	brne	.+2      	; 0x94c0 <WebRequest+0x374>
    94be:	35 c0       	rjmp	.+106    	; 0x952a <WebRequest+0x3de>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    94c0:	6a e0       	ldi	r22, 0x0A	; 10
    94c2:	73 e0       	ldi	r23, 0x03	; 3
    94c4:	8b e7       	ldi	r24, 0x7B	; 123
    94c6:	99 e0       	ldi	r25, 0x09	; 9
    94c8:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    94cc:	89 2b       	or	r24, r25
    94ce:	21 f0       	breq	.+8      	; 0x94d8 <WebRequest+0x38c>
    94d0:	e9 84       	ldd	r14, Y+9	; 0x09
    94d2:	fa 84       	ldd	r15, Y+10	; 0x0a
    94d4:	10 e0       	ldi	r17, 0x00	; 0
    94d6:	15 c0       	rjmp	.+42     	; 0x9502 <WebRequest+0x3b6>
				WebSession = 0;
    94d8:	10 92 6b 09 	sts	0x096B, r1
				return &Web_login;
    94dc:	85 e9       	ldi	r24, 0x95	; 149
    94de:	98 e4       	ldi	r25, 0x48	; 72
    94e0:	28 c0       	rjmp	.+80     	; 0x9532 <WebRequest+0x3e6>
    94e2:	f7 01       	movw	r30, r14
    94e4:	c5 90       	lpm	r12, Z+
    94e6:	d4 90       	lpm	r13, Z
    94e8:	f6 01       	movw	r30, r12
    94ea:	65 91       	lpm	r22, Z+
    94ec:	74 91       	lpm	r23, Z
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    94ee:	8b e7       	ldi	r24, 0x7B	; 123
    94f0:	99 e0       	ldi	r25, 0x09	; 9
    94f2:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    94f6:	a2 e0       	ldi	r26, 0x02	; 2
    94f8:	ea 0e       	add	r14, r26
    94fa:	f1 1c       	adc	r15, r1
    94fc:	89 2b       	or	r24, r25
    94fe:	29 f0       	breq	.+10     	; 0x950a <WebRequest+0x3be>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    9500:	1f 5f       	subi	r17, 0xFF	; 255
    9502:	29 81       	ldd	r18, Y+1	; 0x01
    9504:	12 13       	cpse	r17, r18
    9506:	ed cf       	rjmp	.-38     	; 0x94e2 <WebRequest+0x396>
    9508:	08 c0       	rjmp	.+16     	; 0x951a <WebRequest+0x3ce>
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    950a:	f6 01       	movw	r30, r12
    950c:	3c 96       	adiw	r30, 0x0c	; 12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    950e:	e4 91       	lpm	r30, Z
    9510:	80 91 59 0a 	lds	r24, 0x0A59
    9514:	8e 17       	cp	r24, r30
    9516:	58 f0       	brcs	.+22     	; 0x952e <WebRequest+0x3e2>
    9518:	06 c0       	rjmp	.+12     	; 0x9526 <WebRequest+0x3da>
					return ptrPage;				
				}
			}
			
			//  URL
			return &Web_error_page;
    951a:	8c eb       	ldi	r24, 0xBC	; 188
    951c:	9b e4       	ldi	r25, 0x4B	; 75
    951e:	09 c0       	rjmp	.+18     	; 0x9532 <WebRequest+0x3e6>
			#endif

			*p = '\0';

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9520:	89 ee       	ldi	r24, 0xE9	; 233
    9522:	93 e3       	ldi	r25, 0x33	; 51
    9524:	06 c0       	rjmp	.+12     	; 0x9532 <WebRequest+0x3e6>
    9526:	c6 01       	movw	r24, r12
    9528:	04 c0       	rjmp	.+8      	; 0x9532 <WebRequest+0x3e6>
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
				return ptrPage;			
    952a:	c1 01       	movw	r24, r2
    952c:	02 c0       	rjmp	.+4      	; 0x9532 <WebRequest+0x3e6>
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    952e:	80 eb       	ldi	r24, 0xB0	; 176
    9530:	92 e3       	ldi	r25, 0x32	; 50
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    9532:	2a 96       	adiw	r28, 0x0a	; 10
    9534:	0f b6       	in	r0, 0x3f	; 63
    9536:	f8 94       	cli
    9538:	de bf       	out	0x3e, r29	; 62
    953a:	0f be       	out	0x3f, r0	; 63
    953c:	cd bf       	out	0x3d, r28	; 61
    953e:	df 91       	pop	r29
    9540:	cf 91       	pop	r28
    9542:	1f 91       	pop	r17
    9544:	0f 91       	pop	r16
    9546:	ff 90       	pop	r15
    9548:	ef 90       	pop	r14
    954a:	df 90       	pop	r13
    954c:	cf 90       	pop	r12
    954e:	bf 90       	pop	r11
    9550:	af 90       	pop	r10
    9552:	9f 90       	pop	r9
    9554:	8f 90       	pop	r8
    9556:	7f 90       	pop	r7
    9558:	6f 90       	pop	r6
    955a:	5f 90       	pop	r5
    955c:	4f 90       	pop	r4
    955e:	3f 90       	pop	r3
    9560:	2f 90       	pop	r2
    9562:	08 95       	ret

00009564 <EM_InitFIFO>:
void EMeter_NoLink(void);
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){cli();
    9564:	f8 94       	cli
	EM_RX_FIFO_Begin = 255;
    9566:	8f ef       	ldi	r24, 0xFF	; 255
    9568:	80 93 5d 09 	sts	0x095D, r24
	EM_RX_FIFO_End = 255;
    956c:	80 93 25 0d 	sts	0x0D25, r24
	EMeter_RxCharN = 0;
    9570:	10 92 2c 0d 	sts	0x0D2C, r1
    9574:	10 92 2b 0d 	sts	0x0D2B, r1
	sei();
    9578:	78 94       	sei
    957a:	08 95       	ret

0000957c <EM_SetUARTParam>:
		EM_UART_BitQt = 3;		
	}
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
    957c:	29 2f       	mov	r18, r25
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    957e:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    9582:	80 93 58 0a 	sts	0x0A58, r24

	switch(EM_UART_Rate){
    9586:	90 e0       	ldi	r25, 0x00	; 0
    9588:	89 30       	cpi	r24, 0x09	; 9
    958a:	91 05       	cpc	r25, r1
    958c:	38 f5       	brcc	.+78     	; 0x95dc <EM_SetUARTParam+0x60>
    958e:	fc 01       	movw	r30, r24
    9590:	eb 55       	subi	r30, 0x5B	; 91
    9592:	ff 4f       	sbci	r31, 0xFF	; 255
    9594:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    9598:	83 e0       	ldi	r24, 0x03	; 3
    959a:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    959e:	82 e4       	ldi	r24, 0x42	; 66
    95a0:	20 c0       	rjmp	.+64     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    95a2:	81 e0       	ldi	r24, 0x01	; 1
    95a4:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    95a8:	80 ea       	ldi	r24, 0xA0	; 160
    95aa:	1b c0       	rjmp	.+54     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    95ac:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    95b0:	8f ec       	ldi	r24, 0xCF	; 207
    95b2:	17 c0       	rjmp	.+46     	; 0x95e2 <EM_SetUARTParam+0x66>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    95b4:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    95b8:	84 e4       	ldi	r24, 0x44	; 68
    95ba:	13 c0       	rjmp	.+38     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    95bc:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    95c0:	83 e3       	ldi	r24, 0x33	; 51
    95c2:	0f c0       	rjmp	.+30     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    95c4:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    95c8:	82 e2       	ldi	r24, 0x22	; 34
    95ca:	0b c0       	rjmp	.+22     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    95cc:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    95d0:	89 e1       	ldi	r24, 0x19	; 25
    95d2:	07 c0       	rjmp	.+14     	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    95d4:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    95d8:	80 e1       	ldi	r24, 0x10	; 16
    95da:	03 c0       	rjmp	.+6      	; 0x95e2 <EM_SetUARTParam+0x66>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    95dc:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    95e0:	87 e6       	ldi	r24, 0x67	; 103
    95e2:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    95e6:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    95ea:	82 2f       	mov	r24, r18
    95ec:	83 70       	andi	r24, 0x03	; 3
    95ee:	80 93 06 06 	sts	0x0606, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    95f2:	82 30       	cpi	r24, 0x02	; 2
    95f4:	41 f0       	breq	.+16     	; 0x9606 <EM_SetUARTParam+0x8a>
    95f6:	83 30       	cpi	r24, 0x03	; 3
    95f8:	51 f0       	breq	.+20     	; 0x960e <EM_SetUARTParam+0x92>
    95fa:	81 30       	cpi	r24, 0x01	; 1
    95fc:	41 f4       	brne	.+16     	; 0x960e <EM_SetUARTParam+0x92>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    95fe:	80 91 9d 00 	lds	r24, 0x009D
    9602:	80 62       	ori	r24, 0x20	; 32
    9604:	06 c0       	rjmp	.+12     	; 0x9612 <EM_SetUARTParam+0x96>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    9606:	80 91 9d 00 	lds	r24, 0x009D
    960a:	80 63       	ori	r24, 0x30	; 48
    960c:	02 c0       	rjmp	.+4      	; 0x9612 <EM_SetUARTParam+0x96>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    960e:	80 91 9d 00 	lds	r24, 0x009D
    9612:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    9616:	22 fb       	bst	r18, 2
    9618:	88 27       	eor	r24, r24
    961a:	80 f9       	bld	r24, 0
    961c:	80 93 30 09 	sts	0x0930, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    9620:	81 30       	cpi	r24, 0x01	; 1
    9622:	19 f0       	breq	.+6      	; 0x962a <EM_SetUARTParam+0xae>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    9624:	80 91 9d 00 	lds	r24, 0x009D
    9628:	03 c0       	rjmp	.+6      	; 0x9630 <EM_SetUARTParam+0xb4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    962a:	80 91 9d 00 	lds	r24, 0x009D
    962e:	88 60       	ori	r24, 0x08	; 8
    9630:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    9634:	92 2f       	mov	r25, r18
    9636:	96 95       	lsr	r25
    9638:	96 95       	lsr	r25
    963a:	96 95       	lsr	r25
    963c:	93 70       	andi	r25, 0x03	; 3
    963e:	90 93 5f 0a 	sts	0x0A5F, r25
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    9642:	80 91 9d 00 	lds	r24, 0x009D
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    9646:	92 30       	cpi	r25, 0x02	; 2
    9648:	31 f0       	breq	.+12     	; 0x9656 <EM_SetUARTParam+0xda>
    964a:	93 30       	cpi	r25, 0x03	; 3
    964c:	31 f0       	breq	.+12     	; 0x965a <EM_SetUARTParam+0xde>
    964e:	91 30       	cpi	r25, 0x01	; 1
    9650:	29 f4       	brne	.+10     	; 0x965c <EM_SetUARTParam+0xe0>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    9652:	82 60       	ori	r24, 0x02	; 2
    9654:	03 c0       	rjmp	.+6      	; 0x965c <EM_SetUARTParam+0xe0>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    9656:	84 60       	ori	r24, 0x04	; 4
    9658:	01 c0       	rjmp	.+2      	; 0x965c <EM_SetUARTParam+0xe0>
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    965a:	86 60       	ori	r24, 0x06	; 6
    965c:	80 93 9d 00 	sts	0x009D, r24
    9660:	08 95       	ret

00009662 <ApplyUARTParam>:
	}
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
    9662:	80 91 58 0a 	lds	r24, 0x0A58
    9666:	60 91 06 06 	lds	r22, 0x0606
    966a:	70 e0       	ldi	r23, 0x00	; 0
    966c:	76 2f       	mov	r23, r22
    966e:	66 27       	eor	r22, r22
    9670:	68 0f       	add	r22, r24
    9672:	71 1d       	adc	r23, r1
    9674:	80 91 30 09 	lds	r24, 0x0930
    9678:	90 e0       	ldi	r25, 0x00	; 0
    967a:	98 2f       	mov	r25, r24
    967c:	88 27       	eor	r24, r24
    967e:	99 0f       	add	r25, r25
    9680:	99 0f       	add	r25, r25
    9682:	68 0f       	add	r22, r24
    9684:	79 1f       	adc	r23, r25
    9686:	80 91 5f 0a 	lds	r24, 0x0A5F
    968a:	90 e0       	ldi	r25, 0x00	; 0
    968c:	98 2f       	mov	r25, r24
    968e:	88 27       	eor	r24, r24
    9690:	99 0f       	add	r25, r25
    9692:	99 0f       	add	r25, r25
    9694:	99 0f       	add	r25, r25
    9696:	68 0f       	add	r22, r24
    9698:	79 1f       	adc	r23, r25
	eww(&EM_UART_Param, Temp16);
    969a:	87 e2       	ldi	r24, 0x27	; 39
    969c:	90 e0       	ldi	r25, 0x00	; 0
    969e:	0e 94 ce 29 	call	0x539c	; 0x539c <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    96a2:	80 91 62 0a 	lds	r24, 0x0A62
    96a6:	81 11       	cpse	r24, r1
    96a8:	06 c0       	rjmp	.+12     	; 0x96b6 <ApplyUARTParam+0x54>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    96aa:	87 e2       	ldi	r24, 0x27	; 39
    96ac:	90 e0       	ldi	r25, 0x00	; 0
    96ae:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    96b2:	0e 94 be 4a 	call	0x957c	; 0x957c <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    96b6:	0c 94 1e 2a 	jmp	0x543c	; 0x543c <Modbus_ReadHoldReg>

000096ba <ChangeUARTParam>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    96ba:	89 e2       	ldi	r24, 0x29	; 41
    96bc:	90 e0       	ldi	r25, 0x00	; 0
    96be:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    96c2:	81 30       	cpi	r24, 0x01	; 1
    96c4:	51 f4       	brne	.+20     	; 0x96da <ChangeUARTParam+0x20>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    96c6:	93 e0       	ldi	r25, 0x03	; 3
    96c8:	90 93 58 0a 	sts	0x0A58, r25
		EM_UART_Parity = 1;
    96cc:	80 93 06 06 	sts	0x0606, r24
		EM_UART_StopBits = 0;
    96d0:	10 92 30 09 	sts	0x0930, r1
		EM_UART_BitQt = 2;
    96d4:	82 e0       	ldi	r24, 0x02	; 2
    96d6:	80 93 5f 0a 	sts	0x0A5F, r24
    96da:	89 e2       	ldi	r24, 0x29	; 41
    96dc:	90 e0       	ldi	r25, 0x00	; 0
    96de:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    96e2:	82 50       	subi	r24, 0x02	; 2
    96e4:	83 30       	cpi	r24, 0x03	; 3
    96e6:	48 f4       	brcc	.+18     	; 0x96fa <ChangeUARTParam+0x40>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    96e8:	83 e0       	ldi	r24, 0x03	; 3
    96ea:	80 93 58 0a 	sts	0x0A58, r24
		EM_UART_Parity = 0;
    96ee:	10 92 06 06 	sts	0x0606, r1
		EM_UART_StopBits = 0;
    96f2:	10 92 30 09 	sts	0x0930, r1
		EM_UART_BitQt = 3;		
    96f6:	80 93 5f 0a 	sts	0x0A5F, r24
	}
	ApplyUARTParam();
    96fa:	0c 94 31 4b 	jmp	0x9662	; 0x9662 <ApplyUARTParam>

000096fe <EMeter_ReInit>:
	}
}
void EMeter_ReInit(void){

	//RS485
	MB_PLC_Init();
    96fe:	0e 94 7a 2e 	call	0x5cf4	; 0x5cf4 <MB_PLC_Init>
	
	#ifdef CTS
		CTS_Config();
    9702:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <CTS_Config>
		CTS_OFF();
    9706:	0e 94 a5 2e 	call	0x5d4a	; 0x5d4a <CTS_OFF>
	#endif
	#ifdef RTS
		RTS_Config();
    970a:	0e 94 a7 2e 	call	0x5d4e	; 0x5d4e <RTS_Config>
	#endif

	EM_InitFIFO();
    970e:	0e 94 b2 4a 	call	0x9564	; 0x9564 <EM_InitFIFO>

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9712:	88 e9       	ldi	r24, 0x98	; 152
    9714:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    9718:	80 e4       	ldi	r24, 0x40	; 64
    971a:	80 93 9b 00 	sts	0x009B, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    971e:	87 e2       	ldi	r24, 0x27	; 39
    9720:	90 e0       	ldi	r25, 0x00	; 0
    9722:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    9726:	0e 94 be 4a 	call	0x957c	; 0x957c <EM_SetUARTParam>

	EM_HalfBufferStart= EMeter_RxStr;//----    
    972a:	86 e3       	ldi	r24, 0x36	; 54
    972c:	97 e0       	ldi	r25, 0x07	; 7
    972e:	90 93 75 09 	sts	0x0975, r25
    9732:	80 93 74 09 	sts	0x0974, r24
	EMeter_RxStr_Offset = EMeter_RxStr;
    9736:	90 93 02 06 	sts	0x0602, r25
    973a:	80 93 01 06 	sts	0x0601, r24
	EM_BufferReadEnable=0;//----- 
    973e:	10 92 3e 09 	sts	0x093E, r1
	EMeter_RxCharN=0;
    9742:	10 92 2c 0d 	sts	0x0D2C, r1
    9746:	10 92 2b 0d 	sts	0x0D2B, r1
    974a:	08 95       	ret

0000974c <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    974c:	80 91 63 0a 	lds	r24, 0x0A63
    9750:	88 23       	and	r24, r24
    9752:	31 f0       	breq	.+12     	; 0x9760 <GSM_CloseTransparent+0x14>
		cli();		
    9754:	f8 94       	cli
		Transparent = 0;
    9756:	10 92 63 0a 	sts	0x0A63, r1
		EMeter_ReInit();
    975a:	0e 94 7f 4b 	call	0x96fe	; 0x96fe <EMeter_ReInit>
		sei();		
    975e:	78 94       	sei
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    9760:	6f ef       	ldi	r22, 0xFF	; 255
    9762:	7f ef       	ldi	r23, 0xFF	; 255
    9764:	80 91 53 02 	lds	r24, 0x0253
    9768:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>

0000976c <GSM_Transparent2Modbus>:
}
// ~~~~~~~~~~~
void GSM_Transparent2Modbus(void)
{
	GSM_CloseTransparent();	
    976c:	0e 94 a6 4b 	call	0x974c	; 0x974c <GSM_CloseTransparent>
	GSM_State = GSM_Swtch2CommandMode;
    9770:	81 e6       	ldi	r24, 0x61	; 97
    9772:	80 93 21 06 	sts	0x0621, r24
    9776:	08 95       	ret

00009778 <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    9778:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    977c:	91 e0       	ldi	r25, 0x01	; 1
    977e:	98 0f       	add	r25, r24
    9780:	90 93 0e 01 	sts	0x010E, r25

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    9784:	80 93 25 0c 	sts	0x0C25, r24
	EMeter_ReInit();
    9788:	0e 94 7f 4b 	call	0x96fe	; 0x96fe <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    978c:	8a e0       	ldi	r24, 0x0A	; 10
    978e:	90 e0       	ldi	r25, 0x00	; 0
    9790:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	if(erb(&AutoSend)){
    9794:	88 23       	and	r24, r24
    9796:	49 f0       	breq	.+18     	; 0x97aa <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    9798:	68 ee       	ldi	r22, 0xE8	; 232
    979a:	73 e0       	ldi	r23, 0x03	; 3
    979c:	80 91 25 0c 	lds	r24, 0x0C25
    97a0:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
		EM_Mode = 0;
    97a4:	10 92 5e 0a 	sts	0x0A5E, r1
    97a8:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    97aa:	8f ef       	ldi	r24, 0xFF	; 255
    97ac:	80 93 5e 0a 	sts	0x0A5E, r24
    97b0:	08 95       	ret

000097b2 <USART_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    97b2:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    97b6:	91 e0       	ldi	r25, 0x01	; 1
    97b8:	98 0f       	add	r25, r24
    97ba:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
    97be:	80 93 3a 09 	sts	0x093A, r24

	MB_Init();
    97c2:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <MB_Init>
	EMeter_Init();
    97c6:	0e 94 bc 4b 	call	0x9778	; 0x9778 <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
    97ca:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
    97cc:	d8 9a       	sbi	0x1b, 0	; 27
    97ce:	85 e3       	ldi	r24, 0x35	; 53
    97d0:	8a 95       	dec	r24
    97d2:	f1 f7       	brne	.-4      	; 0x97d0 <USART_Init+0x1e>
    97d4:	00 00       	nop
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
    97d6:	c8 99       	sbic	0x19, 0	; 25
    97d8:	08 c0       	rjmp	.+16     	; 0x97ea <USART_Init+0x38>
		MB_Init();
    97da:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <MB_Init>
		UART_Soft = 1;
    97de:	81 e0       	ldi	r24, 0x01	; 1
    97e0:	80 93 62 0a 	sts	0x0A62, r24
		ModbusMode = 1;
    97e4:	80 93 da 03 	sts	0x03DA, r24
    97e8:	06 c0       	rjmp	.+12     	; 0x97f6 <USART_Init+0x44>
	}
	else{
		EMeter_ReInit();
    97ea:	0e 94 7f 4b 	call	0x96fe	; 0x96fe <EMeter_ReInit>
		UART_Soft = 0;
    97ee:	10 92 62 0a 	sts	0x0A62, r1
		ModbusMode = 0;
    97f2:	10 92 da 03 	sts	0x03DA, r1
	}
	
	GSM_Init();
    97f6:	0c 94 b1 3a 	jmp	0x7562	; 0x7562 <GSM_Init>

000097fa <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    97fa:	80 91 63 0a 	lds	r24, 0x0A63
    97fe:	88 23       	and	r24, r24
    9800:	91 f1       	breq	.+100    	; 0x9866 <EMeter_RX+0x6c>
					StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    9802:	60 91 0b 01 	lds	r22, 0x010B
    9806:	70 91 0c 01 	lds	r23, 0x010C
    980a:	80 91 2d 0d 	lds	r24, 0x0D2D
    980e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    9812:	60 91 09 01 	lds	r22, 0x0109
    9816:	70 91 0a 01 	lds	r23, 0x010A
    981a:	80 91 05 06 	lds	r24, 0x0605
    981e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
		char Char = UDR_EMETER;
    9822:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    9826:	80 91 5d 09 	lds	r24, 0x095D
    982a:	8f 5f       	subi	r24, 0xFF	; 255
    982c:	80 93 5d 09 	sts	0x095D, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    9830:	80 91 5d 09 	lds	r24, 0x095D
    9834:	8f 3f       	cpi	r24, 0xFF	; 255
    9836:	11 f4       	brne	.+4      	; 0x983c <EMeter_RX+0x42>
    9838:	10 92 5d 09 	sts	0x095D, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    983c:	e0 91 5d 09 	lds	r30, 0x095D
    9840:	f0 e0       	ldi	r31, 0x00	; 0
    9842:	ed 50       	subi	r30, 0x0D	; 13
    9844:	fc 4f       	sbci	r31, 0xFC	; 252
    9846:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    9848:	90 91 5d 09 	lds	r25, 0x095D
    984c:	80 91 25 0d 	lds	r24, 0x0D25
    9850:	98 13       	cpse	r25, r24
    9852:	06 c0       	rjmp	.+12     	; 0x9860 <EMeter_RX+0x66>
			EM_RX_FIFOOverFlow = 1;
    9854:	81 e0       	ldi	r24, 0x01	; 1
    9856:	80 93 11 0b 	sts	0x0B11, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    985a:	8f ef       	ldi	r24, 0xFF	; 255
    985c:	80 93 5b 0a 	sts	0x0A5B, r24
			
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    9860:	88 eb       	ldi	r24, 0xB8	; 184
    9862:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    9864:	5e 9a       	sbi	0x0b, 6	; 11
    9866:	08 95       	ret

00009868 <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    9868:	1f 92       	push	r1
    986a:	0f 92       	push	r0
    986c:	0f b6       	in	r0, 0x3f	; 63
    986e:	0f 92       	push	r0
    9870:	11 24       	eor	r1, r1
    9872:	0b b6       	in	r0, 0x3b	; 59
    9874:	0f 92       	push	r0
    9876:	2f 93       	push	r18
    9878:	3f 93       	push	r19
    987a:	4f 93       	push	r20
    987c:	5f 93       	push	r21
    987e:	6f 93       	push	r22
    9880:	7f 93       	push	r23
    9882:	8f 93       	push	r24
    9884:	9f 93       	push	r25
    9886:	af 93       	push	r26
    9888:	bf 93       	push	r27
    988a:	ef 93       	push	r30
    988c:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    988e:	80 91 da 03 	lds	r24, 0x03DA
    9892:	88 23       	and	r24, r24
    9894:	29 f0       	breq	.+10     	; 0x98a0 <__vector_30+0x38>
    9896:	8c e9       	ldi	r24, 0x9C	; 156
    9898:	90 e0       	ldi	r25, 0x00	; 0
    989a:	0e 94 d2 2f 	call	0x5fa4	; 0x5fa4 <Modbus_RX>
    989e:	02 c0       	rjmp	.+4      	; 0x98a4 <__vector_30+0x3c>
	else EMeter_RX();
    98a0:	0e 94 fd 4b 	call	0x97fa	; 0x97fa <EMeter_RX>
	COMM_LED = 1;
    98a4:	81 e0       	ldi	r24, 0x01	; 1
    98a6:	80 93 0a 06 	sts	0x060A, r24
}	
    98aa:	ff 91       	pop	r31
    98ac:	ef 91       	pop	r30
    98ae:	bf 91       	pop	r27
    98b0:	af 91       	pop	r26
    98b2:	9f 91       	pop	r25
    98b4:	8f 91       	pop	r24
    98b6:	7f 91       	pop	r23
    98b8:	6f 91       	pop	r22
    98ba:	5f 91       	pop	r21
    98bc:	4f 91       	pop	r20
    98be:	3f 91       	pop	r19
    98c0:	2f 91       	pop	r18
    98c2:	0f 90       	pop	r0
    98c4:	0b be       	out	0x3b, r0	; 59
    98c6:	0f 90       	pop	r0
    98c8:	0f be       	out	0x3f, r0	; 63
    98ca:	0f 90       	pop	r0
    98cc:	1f 90       	pop	r1
    98ce:	18 95       	reti

000098d0 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    98d0:	80 91 63 0a 	lds	r24, 0x0A63
    98d4:	88 23       	and	r24, r24
    98d6:	21 f0       	breq	.+8      	; 0x98e0 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    98d8:	88 e9       	ldi	r24, 0x98	; 152
    98da:	80 93 9a 00 	sts	0x009A, r24
    98de:	05 c0       	rjmp	.+10     	; 0x98ea <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    98e0:	88 e9       	ldi	r24, 0x98	; 152
    98e2:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    98e6:	10 92 47 09 	sts	0x0947, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    98ea:	94 98       	cbi	0x12, 4	; 18
    98ec:	08 95       	ret

000098ee <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    98ee:	1f 92       	push	r1
    98f0:	0f 92       	push	r0
    98f2:	0f b6       	in	r0, 0x3f	; 63
    98f4:	0f 92       	push	r0
    98f6:	11 24       	eor	r1, r1
    98f8:	0b b6       	in	r0, 0x3b	; 59
    98fa:	0f 92       	push	r0
    98fc:	2f 93       	push	r18
    98fe:	3f 93       	push	r19
    9900:	4f 93       	push	r20
    9902:	5f 93       	push	r21
    9904:	6f 93       	push	r22
    9906:	7f 93       	push	r23
    9908:	8f 93       	push	r24
    990a:	9f 93       	push	r25
    990c:	af 93       	push	r26
    990e:	bf 93       	push	r27
    9910:	ef 93       	push	r30
    9912:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    9914:	80 91 da 03 	lds	r24, 0x03DA
    9918:	88 23       	and	r24, r24
    991a:	29 f0       	breq	.+10     	; 0x9926 <__vector_32+0x38>
    991c:	8c e9       	ldi	r24, 0x9C	; 156
    991e:	90 e0       	ldi	r25, 0x00	; 0
    9920:	0e 94 48 38 	call	0x7090	; 0x7090 <Modbus_TX>
    9924:	02 c0       	rjmp	.+4      	; 0x992a <__vector_32+0x3c>
	else EMeter_TX();
    9926:	0e 94 68 4c 	call	0x98d0	; 0x98d0 <EMeter_TX>
	COMM_LED = 1;
    992a:	81 e0       	ldi	r24, 0x01	; 1
    992c:	80 93 0a 06 	sts	0x060A, r24
}
    9930:	ff 91       	pop	r31
    9932:	ef 91       	pop	r30
    9934:	bf 91       	pop	r27
    9936:	af 91       	pop	r26
    9938:	9f 91       	pop	r25
    993a:	8f 91       	pop	r24
    993c:	7f 91       	pop	r23
    993e:	6f 91       	pop	r22
    9940:	5f 91       	pop	r21
    9942:	4f 91       	pop	r20
    9944:	3f 91       	pop	r19
    9946:	2f 91       	pop	r18
    9948:	0f 90       	pop	r0
    994a:	0b be       	out	0x3b, r0	; 59
    994c:	0f 90       	pop	r0
    994e:	0f be       	out	0x3f, r0	; 63
    9950:	0f 90       	pop	r0
    9952:	1f 90       	pop	r1
    9954:	18 95       	reti

00009956 <EMeter_Link>:

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    9956:	81 e0       	ldi	r24, 0x01	; 1
    9958:	90 91 05 01 	lds	r25, 0x0105
    995c:	91 11       	cpse	r25, r1
    995e:	80 e0       	ldi	r24, 0x00	; 0
	else return 1;
}
    9960:	08 95       	ret

00009962 <IsEMReady>:
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    9962:	81 e0       	ldi	r24, 0x01	; 1
    9964:	90 91 5e 0a 	lds	r25, 0x0A5E
    9968:	9f 3f       	cpi	r25, 0xFF	; 255
    996a:	09 f0       	breq	.+2      	; 0x996e <IsEMReady+0xc>
    996c:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    996e:	08 95       	ret

00009970 <EMRead>:
    9970:	89 e2       	ldi	r24, 0x29	; 41
    9972:	90 e0       	ldi	r25, 0x00	; 0
    9974:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    9978:	84 30       	cpi	r24, 0x04	; 4
    997a:	11 f0       	breq	.+4      	; 0x9980 <EMRead+0x10>
    997c:	10 92 5e 0a 	sts	0x0A5E, r1
    9980:	08 95       	ret

00009982 <GPRS_AppInit>:

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    9982:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <Timer16Alloc>
    9986:	80 93 09 06 	sts	0x0609, r24
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    998a:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <Timer16Alloc>
    998e:	80 93 3c 09 	sts	0x093C, r24
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    9992:	0e 94 5d 2a 	call	0x54ba	; 0x54ba <Timer16Alloc>
    9996:	80 93 f9 0a 	sts	0x0AF9, r24
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    999a:	6f ef       	ldi	r22, 0xFF	; 255
    999c:	7f ef       	ldi	r23, 0xFF	; 255
    999e:	80 91 3c 09 	lds	r24, 0x093C
    99a2:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    99a6:	80 91 11 01 	lds	r24, 0x0111
    99aa:	88 32       	cpi	r24, 0x28	; 40
    99ac:	28 f0       	brcs	.+10     	; 0x99b8 <GPRS_AppInit+0x36>
    99ae:	80 91 56 09 	lds	r24, 0x0956
    99b2:	81 60       	ori	r24, 0x01	; 1
    99b4:	80 93 56 09 	sts	0x0956, r24
    99b8:	08 95       	ret

000099ba <GPRS_AddHeader>:
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    99ba:	0f 93       	push	r16
    99bc:	1f 93       	push	r17
    99be:	cf 93       	push	r28
    99c0:	df 93       	push	r29
    99c2:	00 d0       	rcall	.+0      	; 0x99c4 <GPRS_AddHeader+0xa>
    99c4:	1f 92       	push	r1
    99c6:	cd b7       	in	r28, 0x3d	; 61
    99c8:	de b7       	in	r29, 0x3e	; 62
    99ca:	8c 01       	movw	r16, r24

	Buf[0] = 5;	
    99cc:	85 e0       	ldi	r24, 0x05	; 5
    99ce:	f8 01       	movw	r30, r16
    99d0:	80 83       	st	Z, r24
	Buf[1] = 1;	
    99d2:	81 e0       	ldi	r24, 0x01	; 1
    99d4:	81 83       	std	Z+1, r24	; 0x01
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    99d6:	8c e0       	ldi	r24, 0x0C	; 12
    99d8:	91 e0       	ldi	r25, 0x01	; 1
    99da:	2b 83       	std	Y+3, r18	; 0x03
    99dc:	4a 83       	std	Y+2, r20	; 0x02
    99de:	69 83       	std	Y+1, r22	; 0x01
    99e0:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    99e4:	f8 01       	movw	r30, r16
    99e6:	92 83       	std	Z+2, r25	; 0x02
    99e8:	8c e0       	ldi	r24, 0x0C	; 12
    99ea:	91 e0       	ldi	r25, 0x01	; 1
    99ec:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    99f0:	f8 01       	movw	r30, r16
    99f2:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    99f4:	69 81       	ldd	r22, Y+1	; 0x01
    99f6:	64 83       	std	Z+4, r22	; 0x04
	Buf[5] = Size;	// -       
    99f8:	2b 81       	ldd	r18, Y+3	; 0x03
    99fa:	25 83       	std	Z+5, r18	; 0x05
	Buf[6] = Func;		
    99fc:	4a 81       	ldd	r20, Y+2	; 0x02
    99fe:	46 83       	std	Z+6, r20	; 0x06
}
    9a00:	0f 90       	pop	r0
    9a02:	0f 90       	pop	r0
    9a04:	0f 90       	pop	r0
    9a06:	df 91       	pop	r29
    9a08:	cf 91       	pop	r28
    9a0a:	1f 91       	pop	r17
    9a0c:	0f 91       	pop	r16
    9a0e:	08 95       	ret

00009a10 <GPRS_CurDataSend>:

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    9a10:	cf 92       	push	r12
    9a12:	df 92       	push	r13
    9a14:	ef 92       	push	r14
    9a16:	ff 92       	push	r15
    9a18:	0f 93       	push	r16
    9a1a:	1f 93       	push	r17
    9a1c:	cf 93       	push	r28
    9a1e:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    9a20:	86 e0       	ldi	r24, 0x06	; 6
    9a22:	80 93 26 0b 	sts	0x0B26, r24
	GPRS_Data_Out[1] = 1;	//   
    9a26:	81 e0       	ldi	r24, 0x01	; 1
    9a28:	80 93 27 0b 	sts	0x0B27, r24
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9a2c:	90 91 67 09 	lds	r25, 0x0967
    9a30:	90 93 28 0b 	sts	0x0B28, r25
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    9a34:	90 91 66 09 	lds	r25, 0x0966
    9a38:	90 93 29 0b 	sts	0x0B29, r25
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    9a3c:	90 91 65 09 	lds	r25, 0x0965
    9a40:	90 93 2a 0b 	sts	0x0B2A, r25
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    9a44:	90 91 64 09 	lds	r25, 0x0964
    9a48:	90 93 2b 0b 	sts	0x0B2B, r25
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    9a4c:	90 91 63 09 	lds	r25, 0x0963
    9a50:	90 93 2c 0b 	sts	0x0B2C, r25
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    9a54:	90 91 62 09 	lds	r25, 0x0962
    9a58:	90 93 2d 0b 	sts	0x0B2D, r25
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    9a5c:	90 91 61 09 	lds	r25, 0x0961
    9a60:	90 93 2e 0b 	sts	0x0B2E, r25
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9a64:	90 91 60 09 	lds	r25, 0x0960
    9a68:	90 93 2f 0b 	sts	0x0B2F, r25

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    9a6c:	80 93 30 0b 	sts	0x0B30, r24
	GPRS_Data_Out[11] = SW_VERSION;		//   
    9a70:	83 e0       	ldi	r24, 0x03	; 3
    9a72:	80 93 31 0b 	sts	0x0B31, r24
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    9a76:	87 e0       	ldi	r24, 0x07	; 7
    9a78:	80 93 32 0b 	sts	0x0B32, r24

	GPRS_Data_Out[13] = 60;			// -       
    9a7c:	8c e3       	ldi	r24, 0x3C	; 60
    9a7e:	80 93 33 0b 	sts	0x0B33, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    9a82:	80 91 09 0b 	lds	r24, 0x0B09
    9a86:	80 93 34 0b 	sts	0x0B34, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    9a8a:	80 91 0a 0b 	lds	r24, 0x0B0A
    9a8e:	80 93 35 0b 	sts	0x0B35, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    9a92:	80 91 0b 0b 	lds	r24, 0x0B0B
    9a96:	80 93 36 0b 	sts	0x0B36, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    9a9a:	80 91 0c 0b 	lds	r24, 0x0B0C
    9a9e:	80 93 37 0b 	sts	0x0B37, r24

	if(EMeter_Link()){
    9aa2:	0e 94 ab 4c 	call	0x9956	; 0x9956 <EMeter_Link>
    9aa6:	88 23       	and	r24, r24
    9aa8:	f1 f0       	breq	.+60     	; 0x9ae6 <GPRS_CurDataSend+0xd6>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9aaa:	89 e2       	ldi	r24, 0x29	; 41
    9aac:	90 e0       	ldi	r25, 0x00	; 0
    9aae:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9ab2:	81 30       	cpi	r24, 0x01	; 1
    9ab4:	a9 f4       	brne	.+42     	; 0x9ae0 <GPRS_CurDataSend+0xd0>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    9ab6:	8c e6       	ldi	r24, 0x6C	; 108
    9ab8:	98 e0       	ldi	r25, 0x08	; 8
    9aba:	9f 93       	push	r25
    9abc:	8f 93       	push	r24
    9abe:	8a ee       	ldi	r24, 0xEA	; 234
    9ac0:	92 e0       	ldi	r25, 0x02	; 2
    9ac2:	9f 93       	push	r25
    9ac4:	8f 93       	push	r24
    9ac6:	88 e3       	ldi	r24, 0x38	; 56
    9ac8:	9b e0       	ldi	r25, 0x0B	; 11
    9aca:	9f 93       	push	r25
    9acc:	8f 93       	push	r24
    9ace:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
    9ad2:	0f 90       	pop	r0
    9ad4:	0f 90       	pop	r0
    9ad6:	0f 90       	pop	r0
    9ad8:	0f 90       	pop	r0
    9ada:	0f 90       	pop	r0
    9adc:	0f 90       	pop	r0
    9ade:	11 c0       	rjmp	.+34     	; 0x9b02 <GPRS_CurDataSend+0xf2>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    9ae0:	8a ed       	ldi	r24, 0xDA	; 218
    9ae2:	92 e0       	ldi	r25, 0x02	; 2
    9ae4:	02 c0       	rjmp	.+4      	; 0x9aea <GPRS_CurDataSend+0xda>
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    9ae6:	8a ec       	ldi	r24, 0xCA	; 202
    9ae8:	92 e0       	ldi	r25, 0x02	; 2
    9aea:	9f 93       	push	r25
    9aec:	8f 93       	push	r24
    9aee:	88 e3       	ldi	r24, 0x38	; 56
    9af0:	9b e0       	ldi	r25, 0x0B	; 11
    9af2:	9f 93       	push	r25
    9af4:	8f 93       	push	r24
    9af6:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
    9afa:	0f 90       	pop	r0
    9afc:	0f 90       	pop	r0
    9afe:	0f 90       	pop	r0
    9b00:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    9b02:	10 92 48 0b 	sts	0x0B48, r1
    9b06:	10 92 47 0b 	sts	0x0B47, r1
	if(!EMeter_Link()){
    9b0a:	0e 94 ab 4c 	call	0x9956	; 0x9956 <EMeter_Link>
    9b0e:	e0 90 2e 0d 	lds	r14, 0x0D2E
    9b12:	f0 90 2f 0d 	lds	r15, 0x0D2F
    9b16:	00 91 de 03 	lds	r16, 0x03DE
    9b1a:	10 91 df 03 	lds	r17, 0x03DF
    9b1e:	c0 91 60 0a 	lds	r28, 0x0A60
    9b22:	d0 91 61 0a 	lds	r29, 0x0A61
    9b26:	81 11       	cpse	r24, r1
    9b28:	03 c0       	rjmp	.+6      	; 0x9b30 <GPRS_CurDataSend+0x120>
		ptr[0] |= (1<<0);
    9b2a:	81 e0       	ldi	r24, 0x01	; 1
    9b2c:	90 e0       	ldi	r25, 0x00	; 0
    9b2e:	ac c0       	rjmp	.+344    	; 0x9c88 <GPRS_CurDataSend+0x278>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    9b30:	e1 14       	cp	r14, r1
    9b32:	f1 04       	cpc	r15, r1
    9b34:	31 f4       	brne	.+12     	; 0x9b42 <GPRS_CurDataSend+0x132>
    9b36:	80 e2       	ldi	r24, 0x20	; 32
    9b38:	90 e0       	ldi	r25, 0x00	; 0
    9b3a:	90 93 48 0b 	sts	0x0B48, r25
    9b3e:	80 93 47 0b 	sts	0x0B47, r24
		if(Ub==0) ptr[0] |= (1<<6);
    9b42:	01 15       	cp	r16, r1
    9b44:	11 05       	cpc	r17, r1
    9b46:	49 f4       	brne	.+18     	; 0x9b5a <GPRS_CurDataSend+0x14a>
    9b48:	80 91 47 0b 	lds	r24, 0x0B47
    9b4c:	90 91 48 0b 	lds	r25, 0x0B48
    9b50:	80 64       	ori	r24, 0x40	; 64
    9b52:	90 93 48 0b 	sts	0x0B48, r25
    9b56:	80 93 47 0b 	sts	0x0B47, r24
		if(Uc==0) ptr[0] |= (1<<7);
    9b5a:	20 97       	sbiw	r28, 0x00	; 0
    9b5c:	49 f4       	brne	.+18     	; 0x9b70 <GPRS_CurDataSend+0x160>
    9b5e:	80 91 47 0b 	lds	r24, 0x0B47
    9b62:	90 91 48 0b 	lds	r25, 0x0B48
    9b66:	80 68       	ori	r24, 0x80	; 128
    9b68:	90 93 48 0b 	sts	0x0B48, r25
    9b6c:	80 93 47 0b 	sts	0x0B47, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    9b70:	40 91 4c 09 	lds	r20, 0x094C
    9b74:	50 91 4d 09 	lds	r21, 0x094D
    9b78:	60 91 4e 09 	lds	r22, 0x094E
    9b7c:	70 91 4f 09 	lds	r23, 0x094F
    9b80:	80 91 f5 0a 	lds	r24, 0x0AF5
    9b84:	90 91 f6 0a 	lds	r25, 0x0AF6
    9b88:	a0 91 f7 0a 	lds	r26, 0x0AF7
    9b8c:	b0 91 f8 0a 	lds	r27, 0x0AF8
    9b90:	48 17       	cp	r20, r24
    9b92:	59 07       	cpc	r21, r25
    9b94:	6a 07       	cpc	r22, r26
    9b96:	7b 07       	cpc	r23, r27
    9b98:	59 f4       	brne	.+22     	; 0x9bb0 <GPRS_CurDataSend+0x1a0>
    9b9a:	20 91 2d 09 	lds	r18, 0x092D
    9b9e:	30 91 2e 09 	lds	r19, 0x092E
    9ba2:	80 91 e2 09 	lds	r24, 0x09E2
    9ba6:	90 91 e3 09 	lds	r25, 0x09E3
    9baa:	28 17       	cp	r18, r24
    9bac:	39 07       	cpc	r19, r25
    9bae:	49 f0       	breq	.+18     	; 0x9bc2 <GPRS_CurDataSend+0x1b2>
    9bb0:	80 91 47 0b 	lds	r24, 0x0B47
    9bb4:	90 91 48 0b 	lds	r25, 0x0B48
    9bb8:	91 60       	ori	r25, 0x01	; 1
    9bba:	90 93 48 0b 	sts	0x0B48, r25
    9bbe:	80 93 47 0b 	sts	0x0B47, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    9bc2:	40 91 0d 0b 	lds	r20, 0x0B0D
    9bc6:	50 91 0e 0b 	lds	r21, 0x0B0E
    9bca:	60 91 0f 0b 	lds	r22, 0x0B0F
    9bce:	70 91 10 0b 	lds	r23, 0x0B10
    9bd2:	80 91 db 09 	lds	r24, 0x09DB
    9bd6:	90 91 dc 09 	lds	r25, 0x09DC
    9bda:	a0 91 dd 09 	lds	r26, 0x09DD
    9bde:	b0 91 de 09 	lds	r27, 0x09DE
    9be2:	48 17       	cp	r20, r24
    9be4:	59 07       	cpc	r21, r25
    9be6:	6a 07       	cpc	r22, r26
    9be8:	7b 07       	cpc	r23, r27
    9bea:	59 f4       	brne	.+22     	; 0x9c02 <GPRS_CurDataSend+0x1f2>
    9bec:	20 91 14 06 	lds	r18, 0x0614
    9bf0:	30 91 15 06 	lds	r19, 0x0615
    9bf4:	80 91 ee 03 	lds	r24, 0x03EE
    9bf8:	90 91 ef 03 	lds	r25, 0x03EF
    9bfc:	28 17       	cp	r18, r24
    9bfe:	39 07       	cpc	r19, r25
    9c00:	49 f0       	breq	.+18     	; 0x9c14 <GPRS_CurDataSend+0x204>
    9c02:	80 91 47 0b 	lds	r24, 0x0B47
    9c06:	90 91 48 0b 	lds	r25, 0x0B48
    9c0a:	92 60       	ori	r25, 0x02	; 2
    9c0c:	90 93 48 0b 	sts	0x0B48, r25
    9c10:	80 93 47 0b 	sts	0x0B47, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    9c14:	40 91 e5 03 	lds	r20, 0x03E5
    9c18:	50 91 e6 03 	lds	r21, 0x03E6
    9c1c:	60 91 e7 03 	lds	r22, 0x03E7
    9c20:	70 91 e8 03 	lds	r23, 0x03E8
    9c24:	80 91 10 06 	lds	r24, 0x0610
    9c28:	90 91 11 06 	lds	r25, 0x0611
    9c2c:	a0 91 12 06 	lds	r26, 0x0612
    9c30:	b0 91 13 06 	lds	r27, 0x0613
    9c34:	48 17       	cp	r20, r24
    9c36:	59 07       	cpc	r21, r25
    9c38:	6a 07       	cpc	r22, r26
    9c3a:	7b 07       	cpc	r23, r27
    9c3c:	59 f4       	brne	.+22     	; 0x9c54 <GPRS_CurDataSend+0x244>
    9c3e:	20 91 07 0b 	lds	r18, 0x0B07
    9c42:	30 91 08 0b 	lds	r19, 0x0B08
    9c46:	80 91 30 0d 	lds	r24, 0x0D30
    9c4a:	90 91 31 0d 	lds	r25, 0x0D31
    9c4e:	28 17       	cp	r18, r24
    9c50:	39 07       	cpc	r19, r25
    9c52:	49 f0       	breq	.+18     	; 0x9c66 <GPRS_CurDataSend+0x256>
    9c54:	80 91 47 0b 	lds	r24, 0x0B47
    9c58:	90 91 48 0b 	lds	r25, 0x0B48
    9c5c:	94 60       	ori	r25, 0x04	; 4
    9c5e:	90 93 48 0b 	sts	0x0B48, r25
    9c62:	80 93 47 0b 	sts	0x0B47, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    9c66:	80 91 41 09 	lds	r24, 0x0941
    9c6a:	90 91 42 09 	lds	r25, 0x0942
    9c6e:	a0 91 43 09 	lds	r26, 0x0943
    9c72:	b0 91 44 09 	lds	r27, 0x0944
    9c76:	89 2b       	or	r24, r25
    9c78:	8a 2b       	or	r24, r26
    9c7a:	8b 2b       	or	r24, r27
    9c7c:	49 f0       	breq	.+18     	; 0x9c90 <GPRS_CurDataSend+0x280>
    9c7e:	80 91 47 0b 	lds	r24, 0x0B47
    9c82:	90 91 48 0b 	lds	r25, 0x0B48
    9c86:	98 60       	ori	r25, 0x08	; 8
    9c88:	90 93 48 0b 	sts	0x0B48, r25
    9c8c:	80 93 47 0b 	sts	0x0B47, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    9c90:	80 e0       	ldi	r24, 0x00	; 0
    9c92:	0e 94 84 3b 	call	0x7708	; 0x7708 <DI_Status>
    9c96:	81 11       	cpse	r24, r1
    9c98:	09 c0       	rjmp	.+18     	; 0x9cac <GPRS_CurDataSend+0x29c>
    9c9a:	80 91 47 0b 	lds	r24, 0x0B47
    9c9e:	90 91 48 0b 	lds	r25, 0x0B48
    9ca2:	82 60       	ori	r24, 0x02	; 2
    9ca4:	90 93 48 0b 	sts	0x0B48, r25
    9ca8:	80 93 47 0b 	sts	0x0B47, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    9cac:	81 e0       	ldi	r24, 0x01	; 1
    9cae:	0e 94 84 3b 	call	0x7708	; 0x7708 <DI_Status>
    9cb2:	81 11       	cpse	r24, r1
    9cb4:	09 c0       	rjmp	.+18     	; 0x9cc8 <GPRS_CurDataSend+0x2b8>
    9cb6:	80 91 47 0b 	lds	r24, 0x0B47
    9cba:	90 91 48 0b 	lds	r25, 0x0B48
    9cbe:	84 60       	ori	r24, 0x04	; 4
    9cc0:	90 93 48 0b 	sts	0x0B48, r25
    9cc4:	80 93 47 0b 	sts	0x0B47, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    9cc8:	c0 90 ec 05 	lds	r12, 0x05EC
    9ccc:	d0 90 ed 05 	lds	r13, 0x05ED
    9cd0:	c6 01       	movw	r24, r12
    9cd2:	90 58       	subi	r25, 0x80	; 128
    9cd4:	02 97       	sbiw	r24, 0x02	; 2
    9cd6:	00 f1       	brcs	.+64     	; 0x9d18 <GPRS_CurDataSend+0x308>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9cd8:	8d e0       	ldi	r24, 0x0D	; 13
    9cda:	90 e0       	ldi	r25, 0x00	; 0
    9cdc:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    9ce0:	c8 16       	cp	r12, r24
    9ce2:	d9 06       	cpc	r13, r25
    9ce4:	4c f0       	brlt	.+18     	; 0x9cf8 <GPRS_CurDataSend+0x2e8>
    9ce6:	80 91 47 0b 	lds	r24, 0x0B47
    9cea:	90 91 48 0b 	lds	r25, 0x0B48
    9cee:	88 60       	ori	r24, 0x08	; 8
    9cf0:	90 93 48 0b 	sts	0x0B48, r25
    9cf4:	80 93 47 0b 	sts	0x0B47, r24
    9cf8:	8b e0       	ldi	r24, 0x0B	; 11
    9cfa:	90 e0       	ldi	r25, 0x00	; 0
    9cfc:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    9d00:	8c 15       	cp	r24, r12
    9d02:	9d 05       	cpc	r25, r13
    9d04:	4c f0       	brlt	.+18     	; 0x9d18 <GPRS_CurDataSend+0x308>
    9d06:	80 91 47 0b 	lds	r24, 0x0B47
    9d0a:	90 91 48 0b 	lds	r25, 0x0B48
    9d0e:	80 61       	ori	r24, 0x10	; 16
    9d10:	90 93 48 0b 	sts	0x0B48, r25
    9d14:	80 93 47 0b 	sts	0x0B47, r24
	}

	ptr[1] = Temperature[0];
    9d18:	d0 92 4a 0b 	sts	0x0B4A, r13
    9d1c:	c0 92 49 0b 	sts	0x0B49, r12

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    9d20:	80 91 40 02 	lds	r24, 0x0240
    9d24:	90 91 41 02 	lds	r25, 0x0241
    9d28:	a0 91 42 02 	lds	r26, 0x0242
    9d2c:	b0 91 43 02 	lds	r27, 0x0243
    9d30:	80 93 4b 0b 	sts	0x0B4B, r24
    9d34:	90 93 4c 0b 	sts	0x0B4C, r25
    9d38:	a0 93 4d 0b 	sts	0x0B4D, r26
    9d3c:	b0 93 4e 0b 	sts	0x0B4E, r27
	pi4[1] = E_Meter_RAM.Am;
    9d40:	80 91 44 02 	lds	r24, 0x0244
    9d44:	90 91 45 02 	lds	r25, 0x0245
    9d48:	a0 91 46 02 	lds	r26, 0x0246
    9d4c:	b0 91 47 02 	lds	r27, 0x0247
    9d50:	80 93 4f 0b 	sts	0x0B4F, r24
    9d54:	90 93 50 0b 	sts	0x0B50, r25
    9d58:	a0 93 51 0b 	sts	0x0B51, r26
    9d5c:	b0 93 52 0b 	sts	0x0B52, r27
	pi4[2] = E_Meter_RAM.Rp;
    9d60:	80 91 48 02 	lds	r24, 0x0248
    9d64:	90 91 49 02 	lds	r25, 0x0249
    9d68:	a0 91 4a 02 	lds	r26, 0x024A
    9d6c:	b0 91 4b 02 	lds	r27, 0x024B
    9d70:	80 93 53 0b 	sts	0x0B53, r24
    9d74:	90 93 54 0b 	sts	0x0B54, r25
    9d78:	a0 93 55 0b 	sts	0x0B55, r26
    9d7c:	b0 93 56 0b 	sts	0x0B56, r27
	pi4[3] = E_Meter_RAM.Rm;
    9d80:	80 91 4c 02 	lds	r24, 0x024C
    9d84:	90 91 4d 02 	lds	r25, 0x024D
    9d88:	a0 91 4e 02 	lds	r26, 0x024E
    9d8c:	b0 91 4f 02 	lds	r27, 0x024F
    9d90:	80 93 57 0b 	sts	0x0B57, r24
    9d94:	90 93 58 0b 	sts	0x0B58, r25
    9d98:	a0 93 59 0b 	sts	0x0B59, r26
    9d9c:	b0 93 5a 0b 	sts	0x0B5A, r27

	GPRS_Data_Out[53] = EM_Year;
    9da0:	80 91 73 09 	lds	r24, 0x0973
    9da4:	80 93 5b 0b 	sts	0x0B5B, r24
	GPRS_Data_Out[54] = EM_Month;
    9da8:	80 91 da 09 	lds	r24, 0x09DA
    9dac:	80 93 5c 0b 	sts	0x0B5C, r24
	GPRS_Data_Out[55] = EM_Day;
    9db0:	80 91 dc 03 	lds	r24, 0x03DC
    9db4:	80 93 5d 0b 	sts	0x0B5D, r24
	GPRS_Data_Out[56] = EM_Hour;
    9db8:	80 91 5b 09 	lds	r24, 0x095B
    9dbc:	80 93 5e 0b 	sts	0x0B5E, r24
	GPRS_Data_Out[57] = EM_Min;
    9dc0:	80 91 3b 09 	lds	r24, 0x093B
    9dc4:	80 93 5f 0b 	sts	0x0B5F, r24
	GPRS_Data_Out[58] = EM_Sec;
    9dc8:	80 91 08 06 	lds	r24, 0x0608
    9dcc:	80 93 60 0b 	sts	0x0B60, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
	ptr[0] = EM_PowerActive;
    9dd0:	80 91 5c 0a 	lds	r24, 0x0A5C
    9dd4:	90 91 5d 0a 	lds	r25, 0x0A5D
    9dd8:	90 93 62 0b 	sts	0x0B62, r25
    9ddc:	80 93 61 0b 	sts	0x0B61, r24
	ptr[1] = Ua;
    9de0:	f0 92 64 0b 	sts	0x0B64, r15
    9de4:	e0 92 63 0b 	sts	0x0B63, r14
	ptr[2] = Ub;
    9de8:	10 93 66 0b 	sts	0x0B66, r17
    9dec:	00 93 65 0b 	sts	0x0B65, r16
	ptr[3] = Uc;
    9df0:	d0 93 68 0b 	sts	0x0B68, r29
    9df4:	c0 93 67 0b 	sts	0x0B67, r28
	ptr[4] = Ia;
    9df8:	80 91 ec 03 	lds	r24, 0x03EC
    9dfc:	90 91 ed 03 	lds	r25, 0x03ED
    9e00:	90 93 6a 0b 	sts	0x0B6A, r25
    9e04:	80 93 69 0b 	sts	0x0B69, r24
	ptr[5] = Ib;
    9e08:	80 91 35 09 	lds	r24, 0x0935
    9e0c:	90 91 36 09 	lds	r25, 0x0936
    9e10:	90 93 6c 0b 	sts	0x0B6C, r25
    9e14:	80 93 6b 0b 	sts	0x0B6B, r24
	ptr[6] = Ic;
    9e18:	80 91 6e 09 	lds	r24, 0x096E
    9e1c:	90 91 6f 09 	lds	r25, 0x096F
    9e20:	90 93 6e 0b 	sts	0x0B6E, r25
    9e24:	80 93 6d 0b 	sts	0x0B6D, r24

	GPRS_Data_Out[73] = GSM_RSSI;
    9e28:	80 91 1f 06 	lds	r24, 0x061F
    9e2c:	80 93 6f 0b 	sts	0x0B6F, r24

	GPRS_FlgSz_Out = 74;	//    .     
    9e30:	8a e4       	ldi	r24, 0x4A	; 74
    9e32:	80 93 31 09 	sts	0x0931, r24
}
    9e36:	df 91       	pop	r29
    9e38:	cf 91       	pop	r28
    9e3a:	1f 91       	pop	r17
    9e3c:	0f 91       	pop	r16
    9e3e:	ff 90       	pop	r15
    9e40:	ef 90       	pop	r14
    9e42:	df 90       	pop	r13
    9e44:	cf 90       	pop	r12
    9e46:	08 95       	ret

00009e48 <GPRS_SendData>:

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    9e48:	cf 93       	push	r28
    9e4a:	df 93       	push	r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9e4c:	8a e0       	ldi	r24, 0x0A	; 10
    9e4e:	90 e0       	ldi	r25, 0x00	; 0
    9e50:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    9e54:	88 23       	and	r24, r24
    9e56:	09 f4       	brne	.+2      	; 0x9e5a <GPRS_SendData+0x12>
    9e58:	59 c0       	rjmp	.+178    	; 0x9f0c <GPRS_SendData+0xc4>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9e5a:	88 e0       	ldi	r24, 0x08	; 8
    9e5c:	90 e0       	ldi	r25, 0x00	; 0
    9e5e:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    9e62:	cc 97       	sbiw	r24, 0x3c	; 60
    9e64:	08 f4       	brcc	.+2      	; 0x9e68 <GPRS_SendData+0x20>
    9e66:	52 c0       	rjmp	.+164    	; 0x9f0c <GPRS_SendData+0xc4>
		if(Timer1s != Timer1sOld){
    9e68:	80 91 fb 0a 	lds	r24, 0x0AFB
    9e6c:	90 91 6d 09 	lds	r25, 0x096D
    9e70:	89 17       	cp	r24, r25
    9e72:	91 f0       	breq	.+36     	; 0x9e98 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    9e74:	80 93 6d 09 	sts	0x096D, r24
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    9e78:	c0 91 05 0b 	lds	r28, 0x0B05
    9e7c:	d0 91 06 0b 	lds	r29, 0x0B06
    9e80:	88 e0       	ldi	r24, 0x08	; 8
    9e82:	90 e0       	ldi	r25, 0x00	; 0
    9e84:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    9e88:	c8 17       	cp	r28, r24
    9e8a:	d9 07       	cpc	r29, r25
    9e8c:	28 f4       	brcc	.+10     	; 0x9e98 <GPRS_SendData+0x50>
    9e8e:	21 96       	adiw	r28, 0x01	; 1
    9e90:	d0 93 06 0b 	sts	0x0B06, r29
    9e94:	c0 93 05 0b 	sts	0x0B05, r28
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    9e98:	c0 91 05 0b 	lds	r28, 0x0B05
    9e9c:	d0 91 06 0b 	lds	r29, 0x0B06
    9ea0:	88 e0       	ldi	r24, 0x08	; 8
    9ea2:	90 e0       	ldi	r25, 0x00	; 0
    9ea4:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    9ea8:	4e 97       	sbiw	r24, 0x1e	; 30
    9eaa:	c8 17       	cp	r28, r24
    9eac:	d9 07       	cpc	r29, r25
    9eae:	29 f4       	brne	.+10     	; 0x9eba <GPRS_SendData+0x72>
			if(IsEMReady()) EMRead();			
    9eb0:	0e 94 b1 4c 	call	0x9962	; 0x9962 <IsEMReady>
    9eb4:	81 11       	cpse	r24, r1
    9eb6:	0e 94 b8 4c 	call	0x9970	; 0x9970 <EMRead>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    9eba:	c0 91 05 0b 	lds	r28, 0x0B05
    9ebe:	d0 91 06 0b 	lds	r29, 0x0B06
    9ec2:	88 e0       	ldi	r24, 0x08	; 8
    9ec4:	90 e0       	ldi	r25, 0x00	; 0
    9ec6:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    9eca:	0f 97       	sbiw	r24, 0x0f	; 15
    9ecc:	c8 17       	cp	r28, r24
    9ece:	d9 07       	cpc	r29, r25
    9ed0:	49 f4       	brne	.+18     	; 0x9ee4 <GPRS_SendData+0x9c>
			if(!EMeter_Link()){
    9ed2:	0e 94 ab 4c 	call	0x9956	; 0x9956 <EMeter_Link>
    9ed6:	81 11       	cpse	r24, r1
    9ed8:	05 c0       	rjmp	.+10     	; 0x9ee4 <GPRS_SendData+0x9c>
				if(IsEMReady()) EMRead();
    9eda:	0e 94 b1 4c 	call	0x9962	; 0x9962 <IsEMReady>
    9ede:	81 11       	cpse	r24, r1
    9ee0:	0e 94 b8 4c 	call	0x9970	; 0x9970 <EMRead>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    9ee4:	c0 91 05 0b 	lds	r28, 0x0B05
    9ee8:	d0 91 06 0b 	lds	r29, 0x0B06
    9eec:	88 e0       	ldi	r24, 0x08	; 8
    9eee:	90 e0       	ldi	r25, 0x00	; 0
    9ef0:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    9ef4:	c8 17       	cp	r28, r24
    9ef6:	d9 07       	cpc	r29, r25
    9ef8:	48 f0       	brcs	.+18     	; 0x9f0c <GPRS_SendData+0xc4>
			GPRS_DataTimer = 0;
    9efa:	10 92 06 0b 	sts	0x0B06, r1
    9efe:	10 92 05 0b 	sts	0x0B05, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    9f02:	80 91 4a 09 	lds	r24, 0x094A
    9f06:	81 60       	ori	r24, 0x01	; 1
    9f08:	80 93 4a 09 	sts	0x094A, r24
		}
	}
}
    9f0c:	df 91       	pop	r29
    9f0e:	cf 91       	pop	r28
    9f10:	08 95       	ret

00009f12 <GPRS_NewMsg>:

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    9f12:	90 91 56 09 	lds	r25, 0x0956
    9f16:	90 fd       	sbrc	r25, 0
    9f18:	5b c0       	rjmp	.+182    	; 0x9fd0 <GPRS_NewMsg+0xbe>
		GPRS_CrashID++;
    9f1a:	90 91 04 01 	lds	r25, 0x0104
    9f1e:	9f 5f       	subi	r25, 0xFF	; 255
    9f20:	90 93 04 01 	sts	0x0104, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    9f24:	26 e0       	ldi	r18, 0x06	; 6
    9f26:	20 93 f4 09 	sts	0x09F4, r18
		GPRS_CrashData[1] = 1;	
    9f2a:	21 e0       	ldi	r18, 0x01	; 1
    9f2c:	20 93 f5 09 	sts	0x09F5, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9f30:	30 91 67 09 	lds	r19, 0x0967
    9f34:	30 93 f6 09 	sts	0x09F6, r19
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    9f38:	30 91 66 09 	lds	r19, 0x0966
    9f3c:	30 93 f7 09 	sts	0x09F7, r19
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    9f40:	30 91 65 09 	lds	r19, 0x0965
    9f44:	30 93 f8 09 	sts	0x09F8, r19
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    9f48:	30 91 64 09 	lds	r19, 0x0964
    9f4c:	30 93 f9 09 	sts	0x09F9, r19
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    9f50:	30 91 63 09 	lds	r19, 0x0963
    9f54:	30 93 fa 09 	sts	0x09FA, r19
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    9f58:	30 91 62 09 	lds	r19, 0x0962
    9f5c:	30 93 fb 09 	sts	0x09FB, r19
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    9f60:	30 91 61 09 	lds	r19, 0x0961
    9f64:	30 93 fc 09 	sts	0x09FC, r19
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9f68:	30 91 60 09 	lds	r19, 0x0960
    9f6c:	30 93 fd 09 	sts	0x09FD, r19

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    9f70:	32 e0       	ldi	r19, 0x02	; 2
    9f72:	30 93 fe 09 	sts	0x09FE, r19
		GPRS_CrashData[11] = SW_VERSION;		//   
    9f76:	33 e0       	ldi	r19, 0x03	; 3
    9f78:	30 93 ff 09 	sts	0x09FF, r19
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    9f7c:	37 e0       	ldi	r19, 0x07	; 7
    9f7e:	30 93 00 0a 	sts	0x0A00, r19
		
		GPRS_CrashData[14] = Type;
    9f82:	80 93 02 0a 	sts	0x0A02, r24
		GPRS_CrashData[15] = 1;			//    
    9f86:	20 93 03 0a 	sts	0x0A03, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    9f8a:	90 93 04 0a 	sts	0x0A04, r25

		GPRS_CrashData[17] = 0;
    9f8e:	10 92 05 0a 	sts	0x0A05, r1
		GPRS_CrashData[18] = 0;
    9f92:	10 92 06 0a 	sts	0x0A06, r1
		GPRS_CrashData[19] = 0;
    9f96:	10 92 07 0a 	sts	0x0A07, r1
		GPRS_CrashData[20] = 0;
    9f9a:	10 92 08 0a 	sts	0x0A08, r1
		GPRS_CrashData[21] = 0;
    9f9e:	10 92 09 0a 	sts	0x0A09, r1
		GPRS_CrashData[22] = 0;
    9fa2:	10 92 0a 0a 	sts	0x0A0A, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    9fa6:	42 e3       	ldi	r20, 0x32	; 50
    9fa8:	50 e0       	ldi	r21, 0x00	; 0
    9faa:	8b e0       	ldi	r24, 0x0B	; 11
    9fac:	9a e0       	ldi	r25, 0x0A	; 10
    9fae:	0e 94 ec 6b 	call	0xd7d8	; 0xd7d8 <strlcpy_P>
    9fb2:	87 5f       	subi	r24, 0xF7	; 247
    9fb4:	80 93 01 0a 	sts	0x0A01, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
    9fb8:	80 91 4a 09 	lds	r24, 0x094A
    9fbc:	8f 7d       	andi	r24, 0xDF	; 223
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    9fbe:	80 64       	ori	r24, 0x40	; 64
    9fc0:	80 93 4a 09 	sts	0x094A, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    9fc4:	60 ee       	ldi	r22, 0xE0	; 224
    9fc6:	7e e2       	ldi	r23, 0x2E	; 46
    9fc8:	80 91 09 06 	lds	r24, 0x0609
    9fcc:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>
    9fd0:	08 95       	ret

00009fd2 <GPRS_SendNewCrash>:
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    9fd2:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    9fd4:	c0 91 01 0a 	lds	r28, 0x0A01
    9fd8:	c2 5f       	subi	r28, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    9fda:	4c 2f       	mov	r20, r28
    9fdc:	50 e0       	ldi	r21, 0x00	; 0
    9fde:	64 ef       	ldi	r22, 0xF4	; 244
    9fe0:	79 e0       	ldi	r23, 0x09	; 9
    9fe2:	86 e2       	ldi	r24, 0x26	; 38
    9fe4:	9b e0       	ldi	r25, 0x0B	; 11
    9fe6:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    9fea:	c0 93 31 09 	sts	0x0931, r28
}
    9fee:	cf 91       	pop	r28
    9ff0:	08 95       	ret

00009ff2 <GPRS_SendRepCrash>:
// --      
void GPRS_SendRepCrash(void){
    9ff2:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    9ff4:	c0 91 01 0a 	lds	r28, 0x0A01
    9ff8:	c2 5f       	subi	r28, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    9ffa:	82 e0       	ldi	r24, 0x02	; 2
    9ffc:	80 93 03 0a 	sts	0x0A03, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a000:	4c 2f       	mov	r20, r28
    a002:	50 e0       	ldi	r21, 0x00	; 0
    a004:	64 ef       	ldi	r22, 0xF4	; 244
    a006:	79 e0       	ldi	r23, 0x09	; 9
    a008:	86 e2       	ldi	r24, 0x26	; 38
    a00a:	9b e0       	ldi	r25, 0x0B	; 11
    a00c:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a010:	c0 93 31 09 	sts	0x0931, r28
}
    a014:	cf 91       	pop	r28
    a016:	08 95       	ret

0000a018 <GPRS_Check_PSW>:

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    a018:	0f 93       	push	r16
    a01a:	1f 93       	push	r17
    a01c:	cf 93       	push	r28
    a01e:	df 93       	push	r29
    a020:	8c 01       	movw	r16, r24
    a022:	c0 e0       	ldi	r28, 0x00	; 0
    a024:	d0 e0       	ldi	r29, 0x00	; 0
    a026:	ce 01       	movw	r24, r28
    a028:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a02c:	08 17       	cp	r16, r24
    a02e:	19 07       	cpc	r17, r25
    a030:	59 f0       	breq	.+22     	; 0xa048 <GPRS_Check_PSW+0x30>
    a032:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    a034:	80 e0       	ldi	r24, 0x00	; 0
    a036:	c8 30       	cpi	r28, 0x08	; 8
    a038:	d8 07       	cpc	r29, r24
    a03a:	a9 f7       	brne	.-22     	; 0xa026 <GPRS_Check_PSW+0xe>
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
    a03c:	81 e0       	ldi	r24, 0x01	; 1
    a03e:	0c 3f       	cpi	r16, 0xFC	; 252
    a040:	18 45       	sbci	r17, 0x58	; 88
    a042:	19 f0       	breq	.+6      	; 0xa04a <GPRS_Check_PSW+0x32>
    a044:	80 e0       	ldi	r24, 0x00	; 0
    a046:	01 c0       	rjmp	.+2      	; 0xa04a <GPRS_Check_PSW+0x32>
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a048:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(Pass == 22780) return 1;
	return 0;
}
    a04a:	df 91       	pop	r29
    a04c:	cf 91       	pop	r28
    a04e:	1f 91       	pop	r17
    a050:	0f 91       	pop	r16
    a052:	08 95       	ret

0000a054 <GPRS_Get_Session_ID>:
	}
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
    a054:	cf 93       	push	r28
    a056:	df 93       	push	r29
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    a058:	80 91 56 09 	lds	r24, 0x0956
    a05c:	83 ff       	sbrs	r24, 3
    a05e:	05 c0       	rjmp	.+10     	; 0xa06a <GPRS_Get_Session_ID+0x16>
    a060:	10 92 fe 0a 	sts	0x0AFE, r1
    a064:	10 92 fd 0a 	sts	0x0AFD, r1
    a068:	12 c0       	rjmp	.+36     	; 0xa08e <GPRS_Get_Session_ID+0x3a>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    a06a:	c0 91 3c 09 	lds	r28, 0x093C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    a06e:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint16_t Time = Timer16[TimerN];
    a072:	ec 2f       	mov	r30, r28
    a074:	f0 e0       	ldi	r31, 0x00	; 0
    a076:	ee 0f       	add	r30, r30
    a078:	ff 1f       	adc	r31, r31
    a07a:	e0 5e       	subi	r30, 0xE0	; 224
    a07c:	fc 4f       	sbci	r31, 0xFC	; 252
    a07e:	c0 81       	ld	r28, Z
    a080:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    a082:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
    a086:	d0 93 fe 0a 	sts	0x0AFE, r29
    a08a:	c0 93 fd 0a 	sts	0x0AFD, r28
	GPRS_Data_Out[0] = 5;	//    
    a08e:	85 e0       	ldi	r24, 0x05	; 5
    a090:	80 93 26 0b 	sts	0x0B26, r24
	GPRS_Data_Out[1] = 1;	//   
    a094:	81 e0       	ldi	r24, 0x01	; 1
    a096:	80 93 27 0b 	sts	0x0B27, r24
    a09a:	8c e0       	ldi	r24, 0x0C	; 12
    a09c:	91 e0       	ldi	r25, 0x01	; 1
    a09e:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a0a2:	90 93 28 0b 	sts	0x0B28, r25
    a0a6:	8c e0       	ldi	r24, 0x0C	; 12
    a0a8:	91 e0       	ldi	r25, 0x01	; 1
    a0aa:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a0ae:	80 93 29 0b 	sts	0x0B29, r24
	GPRS_Data_Out[4] = 4;
    a0b2:	84 e0       	ldi	r24, 0x04	; 4
    a0b4:	80 93 2a 0b 	sts	0x0B2A, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    a0b8:	80 91 fd 0a 	lds	r24, 0x0AFD
    a0bc:	90 91 fe 0a 	lds	r25, 0x0AFE
    a0c0:	90 93 2b 0b 	sts	0x0B2B, r25
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    a0c4:	80 93 2c 0b 	sts	0x0B2C, r24
	GPRS_FlgSz_Out = 7;					//    .     	
    a0c8:	87 e0       	ldi	r24, 0x07	; 7
    a0ca:	80 93 31 09 	sts	0x0931, r24
}
    a0ce:	df 91       	pop	r29
    a0d0:	cf 91       	pop	r28
    a0d2:	08 95       	ret

0000a0d4 <GPRS_RemoteDisplayControl>:

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    a0d4:	6f e0       	ldi	r22, 0x0F	; 15
    a0d6:	80 e0       	ldi	r24, 0x00	; 0
    a0d8:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    a0dc:	80 91 56 09 	lds	r24, 0x0956
    a0e0:	84 60       	ori	r24, 0x04	; 4
    a0e2:	80 93 56 09 	sts	0x0956, r24
    a0e6:	08 95       	ret

0000a0e8 <GPRS_SendDisplay>:
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
	GPRS_Data_Out[0] = 5;	//    
    a0e8:	85 e0       	ldi	r24, 0x05	; 5
    a0ea:	80 93 26 0b 	sts	0x0B26, r24
	GPRS_Data_Out[1] = 1;	//   
    a0ee:	81 e0       	ldi	r24, 0x01	; 1
    a0f0:	80 93 27 0b 	sts	0x0B27, r24
    a0f4:	8c e0       	ldi	r24, 0x0C	; 12
    a0f6:	91 e0       	ldi	r25, 0x01	; 1
    a0f8:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a0fc:	90 93 28 0b 	sts	0x0B28, r25
    a100:	8c e0       	ldi	r24, 0x0C	; 12
    a102:	91 e0       	ldi	r25, 0x01	; 1
    a104:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a108:	80 93 29 0b 	sts	0x0B29, r24
	GPRS_Data_Out[4] = 3;
    a10c:	83 e0       	ldi	r24, 0x03	; 3
    a10e:	80 93 2a 0b 	sts	0x0B2A, r24
	GPRS_Data_Out[5] = 34;
    a112:	82 e2       	ldi	r24, 0x22	; 34
    a114:	80 93 2b 0b 	sts	0x0B2B, r24
	GPRS_Data_Out[6] = 10;
    a118:	8a e0       	ldi	r24, 0x0A	; 10
    a11a:	80 93 2c 0b 	sts	0x0B2C, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    a11e:	80 93 2d 0b 	sts	0x0B2D, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    a122:	88 e2       	ldi	r24, 0x28	; 40
    a124:	80 93 31 09 	sts	0x0931, r24
    a128:	08 95       	ret

0000a12a <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    a12a:	cf 93       	push	r28
    a12c:	c8 2f       	mov	r28, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    a12e:	48 2f       	mov	r20, r24
    a130:	50 e0       	ldi	r21, 0x00	; 0
    a132:	67 e3       	ldi	r22, 0x37	; 55
    a134:	76 e0       	ldi	r23, 0x06	; 6
    a136:	86 e2       	ldi	r24, 0x26	; 38
    a138:	9b e0       	ldi	r25, 0x0B	; 11
    a13a:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    a13e:	c0 93 31 09 	sts	0x0931, r28
}
    a142:	cf 91       	pop	r28
    a144:	08 95       	ret

0000a146 <GPRS_ReadParamReply>:
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    a146:	1f 93       	push	r17
    a148:	cf 93       	push	r28
    a14a:	df 93       	push	r29
    a14c:	00 d0       	rcall	.+0      	; 0xa14e <GPRS_ReadParamReply+0x8>
    a14e:	cd b7       	in	r28, 0x3d	; 61
    a150:	de b7       	in	r29, 0x3e	; 62
    a152:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a154:	85 e0       	ldi	r24, 0x05	; 5
    a156:	80 93 37 06 	sts	0x0637, r24
	GPRS_ChangeData[1] = 1;	
    a15a:	81 e0       	ldi	r24, 0x01	; 1
    a15c:	80 93 38 06 	sts	0x0638, r24
    a160:	8c e0       	ldi	r24, 0x0C	; 12
    a162:	91 e0       	ldi	r25, 0x01	; 1
    a164:	4a 83       	std	Y+2, r20	; 0x02
    a166:	69 83       	std	Y+1, r22	; 0x01
    a168:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a16c:	90 93 39 06 	sts	0x0639, r25
    a170:	8c e0       	ldi	r24, 0x0C	; 12
    a172:	91 e0       	ldi	r25, 0x01	; 1
    a174:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a178:	80 93 3a 06 	sts	0x063A, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a17c:	83 e0       	ldi	r24, 0x03	; 3
    a17e:	80 93 3b 06 	sts	0x063B, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    a182:	4a 81       	ldd	r20, Y+2	; 0x02
    a184:	4d 5f       	subi	r20, 0xFD	; 253
    a186:	40 93 3c 06 	sts	0x063C, r20
	GPRS_ChangeData[6] = 7;
    a18a:	87 e0       	ldi	r24, 0x07	; 7
    a18c:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a190:	10 93 3e 06 	sts	0x063E, r17
	GPRS_ChangeData[8] = ParamID_Lo;
    a194:	69 81       	ldd	r22, Y+1	; 0x01
    a196:	60 93 3f 06 	sts	0x063F, r22
}
    a19a:	0f 90       	pop	r0
    a19c:	0f 90       	pop	r0
    a19e:	df 91       	pop	r29
    a1a0:	cf 91       	pop	r28
    a1a2:	1f 91       	pop	r17
    a1a4:	08 95       	ret

0000a1a6 <GPRS_WriteParamReply>:
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    a1a6:	1f 93       	push	r17
    a1a8:	cf 93       	push	r28
    a1aa:	df 93       	push	r29
    a1ac:	1f 92       	push	r1
    a1ae:	cd b7       	in	r28, 0x3d	; 61
    a1b0:	de b7       	in	r29, 0x3e	; 62
    a1b2:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a1b4:	85 e0       	ldi	r24, 0x05	; 5
    a1b6:	80 93 37 06 	sts	0x0637, r24
	GPRS_ChangeData[1] = 1;	
    a1ba:	81 e0       	ldi	r24, 0x01	; 1
    a1bc:	80 93 38 06 	sts	0x0638, r24
    a1c0:	8c e0       	ldi	r24, 0x0C	; 12
    a1c2:	91 e0       	ldi	r25, 0x01	; 1
    a1c4:	69 83       	std	Y+1, r22	; 0x01
    a1c6:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a1ca:	90 93 39 06 	sts	0x0639, r25
    a1ce:	8c e0       	ldi	r24, 0x0C	; 12
    a1d0:	91 e0       	ldi	r25, 0x01	; 1
    a1d2:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a1d6:	80 93 3a 06 	sts	0x063A, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a1da:	93 e0       	ldi	r25, 0x03	; 3
    a1dc:	90 93 3b 06 	sts	0x063B, r25
	GPRS_ChangeData[5] = 3;	// -       
    a1e0:	90 93 3c 06 	sts	0x063C, r25
	GPRS_ChangeData[6] = 8;
    a1e4:	88 e0       	ldi	r24, 0x08	; 8
    a1e6:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a1ea:	10 93 3e 06 	sts	0x063E, r17
	GPRS_ChangeData[8] = ParamID_Lo;	
    a1ee:	69 81       	ldd	r22, Y+1	; 0x01
    a1f0:	60 93 3f 06 	sts	0x063F, r22
}
    a1f4:	0f 90       	pop	r0
    a1f6:	df 91       	pop	r29
    a1f8:	cf 91       	pop	r28
    a1fa:	1f 91       	pop	r17
    a1fc:	08 95       	ret

0000a1fe <GPRS_Param>:

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    a1fe:	cf 92       	push	r12
    a200:	ef 92       	push	r14
    a202:	0f 93       	push	r16
    a204:	1f 93       	push	r17
    a206:	cf 93       	push	r28
    a208:	df 93       	push	r29
    a20a:	d8 2f       	mov	r29, r24
    a20c:	16 2f       	mov	r17, r22
    a20e:	ca 01       	movw	r24, r20
    a210:	c2 2f       	mov	r28, r18
	if(Cmd==READ_PARAM ){
    a212:	01 3c       	cpi	r16, 0xC1	; 193
    a214:	b9 f4       	brne	.+46     	; 0xa244 <GPRS_Param+0x46>
		if(MemCopy){
    a216:	ee 20       	and	r14, r14
    a218:	61 f0       	breq	.+24     	; 0xa232 <GPRS_Param+0x34>
    a21a:	42 2f       	mov	r20, r18
    a21c:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    a21e:	bc 01       	movw	r22, r24
    a220:	80 e4       	ldi	r24, 0x40	; 64
    a222:	96 e0       	ldi	r25, 0x06	; 6
    a224:	cc 20       	and	r12, r12
    a226:	19 f0       	breq	.+6      	; 0xa22e <GPRS_Param+0x30>
    a228:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
    a22c:	02 c0       	rjmp	.+4      	; 0xa232 <GPRS_Param+0x34>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a22e:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    a232:	4c 2f       	mov	r20, r28
    a234:	61 2f       	mov	r22, r17
    a236:	8d 2f       	mov	r24, r29
    a238:	0e 94 a3 50 	call	0xa146	; 0xa146 <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    a23c:	c7 5f       	subi	r28, 0xF7	; 247
    a23e:	c0 93 0b 06 	sts	0x060B, r28
    a242:	19 c0       	rjmp	.+50     	; 0xa276 <GPRS_Param+0x78>
	}
	if(Cmd==WRITE_PARAM){
    a244:	0c 34       	cpi	r16, 0x4C	; 76
    a246:	b9 f4       	brne	.+46     	; 0xa276 <GPRS_Param+0x78>
		if(MemCopy){
    a248:	ee 20       	and	r14, r14
    a24a:	71 f0       	breq	.+28     	; 0xa268 <GPRS_Param+0x6a>
    a24c:	42 2f       	mov	r20, r18
    a24e:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    a250:	cc 20       	and	r12, r12
    a252:	29 f0       	breq	.+10     	; 0xa25e <GPRS_Param+0x60>
    a254:	62 e4       	ldi	r22, 0x42	; 66
    a256:	78 e0       	ldi	r23, 0x08	; 8
    a258:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
    a25c:	05 c0       	rjmp	.+10     	; 0xa268 <GPRS_Param+0x6a>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    a25e:	bc 01       	movw	r22, r24
    a260:	82 e4       	ldi	r24, 0x42	; 66
    a262:	98 e0       	ldi	r25, 0x08	; 8
    a264:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    a268:	61 2f       	mov	r22, r17
    a26a:	8d 2f       	mov	r24, r29
    a26c:	0e 94 d3 50 	call	0xa1a6	; 0xa1a6 <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    a270:	89 e0       	ldi	r24, 0x09	; 9
    a272:	80 93 0b 06 	sts	0x060B, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a276:	80 91 4a 09 	lds	r24, 0x094A
    a27a:	88 60       	ori	r24, 0x08	; 8
    a27c:	80 93 4a 09 	sts	0x094A, r24
}
    a280:	df 91       	pop	r29
    a282:	cf 91       	pop	r28
    a284:	1f 91       	pop	r17
    a286:	0f 91       	pop	r16
    a288:	ef 90       	pop	r14
    a28a:	cf 90       	pop	r12
    a28c:	08 95       	ret

0000a28e <GPRS_CriticalCMD_Process>:

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    a28e:	80 91 dd 03 	lds	r24, 0x03DD
    a292:	88 23       	and	r24, r24
    a294:	f9 f0       	breq	.+62     	; 0xa2d4 <GPRS_CriticalCMD_Process+0x46>
    a296:	80 91 f9 0a 	lds	r24, 0x0AF9
    a29a:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    a29e:	88 23       	and	r24, r24
    a2a0:	c9 f0       	breq	.+50     	; 0xa2d4 <GPRS_CriticalCMD_Process+0x46>
		switch(GPRS_CriticalCMD){
    a2a2:	80 91 dd 03 	lds	r24, 0x03DD
    a2a6:	82 30       	cpi	r24, 0x02	; 2
    a2a8:	69 f0       	breq	.+26     	; 0xa2c4 <GPRS_CriticalCMD_Process+0x36>
    a2aa:	20 f4       	brcc	.+8      	; 0xa2b4 <GPRS_CriticalCMD_Process+0x26>
    a2ac:	81 30       	cpi	r24, 0x01	; 1
    a2ae:	81 f4       	brne	.+32     	; 0xa2d0 <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    a2b0:	f8 94       	cli
    a2b2:	07 c0       	rjmp	.+14     	; 0xa2c2 <GPRS_CriticalCMD_Process+0x34>
    a2b4:	83 30       	cpi	r24, 0x03	; 3
    a2b6:	51 f0       	breq	.+20     	; 0xa2cc <GPRS_CriticalCMD_Process+0x3e>
    a2b8:	84 30       	cpi	r24, 0x04	; 4
    a2ba:	51 f4       	brne	.+20     	; 0xa2d0 <GPRS_CriticalCMD_Process+0x42>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
			case GPRS_UPDATER:		Start_Updater(); break;
    a2bc:	0e 94 fa 28 	call	0x51f4	; 0x51f4 <Start_Updater>
    a2c0:	07 c0       	rjmp	.+14     	; 0xa2d0 <GPRS_CriticalCMD_Process+0x42>
    a2c2:	ff cf       	rjmp	.-2      	; 0xa2c2 <GPRS_CriticalCMD_Process+0x34>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    a2c4:	88 e5       	ldi	r24, 0x58	; 88
    a2c6:	80 93 21 06 	sts	0x0621, r24
    a2ca:	02 c0       	rjmp	.+4      	; 0xa2d0 <GPRS_CriticalCMD_Process+0x42>
void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
		switch(GPRS_CriticalCMD){
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    a2cc:	0e 94 c7 29 	call	0x538e	; 0x538e <Start_Bootloader>
			case GPRS_UPDATER:		Start_Updater(); break;
		}
		GPRS_CriticalCMD = 0;
    a2d0:	10 92 dd 03 	sts	0x03DD, r1
    a2d4:	08 95       	ret

0000a2d6 <GPRS_Param00>:
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    a2d6:	cf 92       	push	r12
    a2d8:	ef 92       	push	r14
    a2da:	0f 93       	push	r16
    a2dc:	cf 93       	push	r28
    a2de:	c8 2f       	mov	r28, r24
    a2e0:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    a2e2:	84 30       	cpi	r24, 0x04	; 4
    a2e4:	61 f1       	breq	.+88     	; 0xa33e <GPRS_Param00+0x68>
    a2e6:	28 f4       	brcc	.+10     	; 0xa2f2 <GPRS_Param00+0x1c>
    a2e8:	81 30       	cpi	r24, 0x01	; 1
    a2ea:	49 f0       	breq	.+18     	; 0xa2fe <GPRS_Param00+0x28>
    a2ec:	82 30       	cpi	r24, 0x02	; 2
    a2ee:	89 f0       	breq	.+34     	; 0xa312 <GPRS_Param00+0x3c>
    a2f0:	50 c0       	rjmp	.+160    	; 0xa392 <GPRS_Param00+0xbc>
    a2f2:	86 30       	cpi	r24, 0x06	; 6
    a2f4:	a1 f1       	breq	.+104    	; 0xa35e <GPRS_Param00+0x88>
    a2f6:	58 f1       	brcs	.+86     	; 0xa34e <GPRS_Param00+0x78>
    a2f8:	87 30       	cpi	r24, 0x07	; 7
    a2fa:	c9 f1       	breq	.+114    	; 0xa36e <GPRS_Param00+0x98>
    a2fc:	4a c0       	rjmp	.+148    	; 0xa392 <GPRS_Param00+0xbc>
		case 1:	if(Cmd==READ_PARAM){
    a2fe:	61 3c       	cpi	r22, 0xC1	; 193
    a300:	09 f0       	breq	.+2      	; 0xa304 <GPRS_Param00+0x2e>
    a302:	47 c0       	rjmp	.+142    	; 0xa392 <GPRS_Param00+0xbc>
					GPRS_ChangeData[9] = SW_VERSION;
    a304:	83 e0       	ldi	r24, 0x03	; 3
    a306:	80 93 40 06 	sts	0x0640, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    a30a:	87 e0       	ldi	r24, 0x07	; 7
    a30c:	80 93 41 06 	sts	0x0641, r24
    a310:	3e c0       	rjmp	.+124    	; 0xa38e <GPRS_Param00+0xb8>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    a312:	61 3c       	cpi	r22, 0xC1	; 193
    a314:	49 f4       	brne	.+18     	; 0xa328 <GPRS_Param00+0x52>
    a316:	42 e0       	ldi	r20, 0x02	; 2
    a318:	50 e0       	ldi	r21, 0x00	; 0
    a31a:	6c e0       	ldi	r22, 0x0C	; 12
    a31c:	71 e0       	ldi	r23, 0x01	; 1
    a31e:	80 e4       	ldi	r24, 0x40	; 64
    a320:	96 e0       	ldi	r25, 0x06	; 6
    a322:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a326:	33 c0       	rjmp	.+102    	; 0xa38e <GPRS_Param00+0xb8>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    a328:	6c 34       	cpi	r22, 0x4C	; 76
    a32a:	89 f5       	brne	.+98     	; 0xa38e <GPRS_Param00+0xb8>
    a32c:	42 e0       	ldi	r20, 0x02	; 2
    a32e:	50 e0       	ldi	r21, 0x00	; 0
    a330:	6c e0       	ldi	r22, 0x0C	; 12
    a332:	71 e0       	ldi	r23, 0x01	; 1
    a334:	82 e4       	ldi	r24, 0x42	; 66
    a336:	98 e0       	ldi	r25, 0x08	; 8
    a338:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
    a33c:	28 c0       	rjmp	.+80     	; 0xa38e <GPRS_Param00+0xb8>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    a33e:	6c 34       	cpi	r22, 0x4C	; 76
    a340:	41 f5       	brne	.+80     	; 0xa392 <GPRS_Param00+0xbc>
    a342:	80 91 42 08 	lds	r24, 0x0842
    a346:	88 23       	and	r24, r24
    a348:	21 f1       	breq	.+72     	; 0xa392 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    a34a:	81 e0       	ldi	r24, 0x01	; 1
    a34c:	17 c0       	rjmp	.+46     	; 0xa37c <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a34e:	6c 34       	cpi	r22, 0x4C	; 76
    a350:	01 f5       	brne	.+64     	; 0xa392 <GPRS_Param00+0xbc>
    a352:	80 91 42 08 	lds	r24, 0x0842
    a356:	88 23       	and	r24, r24
    a358:	e1 f0       	breq	.+56     	; 0xa392 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    a35a:	82 e0       	ldi	r24, 0x02	; 2
    a35c:	0f c0       	rjmp	.+30     	; 0xa37c <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a35e:	6c 34       	cpi	r22, 0x4C	; 76
    a360:	c1 f4       	brne	.+48     	; 0xa392 <GPRS_Param00+0xbc>
    a362:	80 91 42 08 	lds	r24, 0x0842
    a366:	88 23       	and	r24, r24
    a368:	a1 f0       	breq	.+40     	; 0xa392 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    a36a:	83 e0       	ldi	r24, 0x03	; 3
    a36c:	07 c0       	rjmp	.+14     	; 0xa37c <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a36e:	6c 34       	cpi	r22, 0x4C	; 76
    a370:	81 f4       	brne	.+32     	; 0xa392 <GPRS_Param00+0xbc>
    a372:	80 91 42 08 	lds	r24, 0x0842
    a376:	88 23       	and	r24, r24
    a378:	61 f0       	breq	.+24     	; 0xa392 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    a37a:	84 e0       	ldi	r24, 0x04	; 4
    a37c:	80 93 dd 03 	sts	0x03DD, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    a380:	60 e9       	ldi	r22, 0x90	; 144
    a382:	71 e0       	ldi	r23, 0x01	; 1
    a384:	80 91 f9 0a 	lds	r24, 0x0AF9
    a388:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    a38c:	02 c0       	rjmp	.+4      	; 0xa392 <GPRS_Param00+0xbc>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
				param_size = sizeof(Vega_SN);
    a38e:	22 e0       	ldi	r18, 0x02	; 2
    a390:	01 c0       	rjmp	.+2      	; 0xa394 <GPRS_Param00+0xbe>
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
	uint8_t param_size = 0;
    a392:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a394:	c1 2c       	mov	r12, r1
    a396:	e1 2c       	mov	r14, r1
    a398:	40 e0       	ldi	r20, 0x00	; 0
    a39a:	50 e0       	ldi	r21, 0x00	; 0
    a39c:	6c 2f       	mov	r22, r28
    a39e:	80 e0       	ldi	r24, 0x00	; 0
    a3a0:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a3a4:	cf 91       	pop	r28
    a3a6:	0f 91       	pop	r16
    a3a8:	ef 90       	pop	r14
    a3aa:	cf 90       	pop	r12
    a3ac:	08 95       	ret

0000a3ae <GPRS_Param01>:
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a3ae:	cf 92       	push	r12
    a3b0:	ef 92       	push	r14
    a3b2:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a3b4:	c1 2c       	mov	r12, r1
    a3b6:	e1 2c       	mov	r14, r1
    a3b8:	06 2f       	mov	r16, r22
    a3ba:	20 e0       	ldi	r18, 0x00	; 0
    a3bc:	40 e0       	ldi	r20, 0x00	; 0
    a3be:	50 e0       	ldi	r21, 0x00	; 0
    a3c0:	68 2f       	mov	r22, r24
    a3c2:	81 e0       	ldi	r24, 0x01	; 1
    a3c4:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a3c8:	0f 91       	pop	r16
    a3ca:	ef 90       	pop	r14
    a3cc:	cf 90       	pop	r12
    a3ce:	08 95       	ret

0000a3d0 <GPRS_Param02>:
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a3d0:	cf 92       	push	r12
    a3d2:	ef 92       	push	r14
    a3d4:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    a3d6:	c1 2c       	mov	r12, r1
    a3d8:	e1 2c       	mov	r14, r1
    a3da:	06 2f       	mov	r16, r22
    a3dc:	21 e0       	ldi	r18, 0x01	; 1
    a3de:	40 e0       	ldi	r20, 0x00	; 0
    a3e0:	50 e0       	ldi	r21, 0x00	; 0
    a3e2:	68 2f       	mov	r22, r24
    a3e4:	82 e0       	ldi	r24, 0x02	; 2
    a3e6:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a3ea:	0f 91       	pop	r16
    a3ec:	ef 90       	pop	r14
    a3ee:	cf 90       	pop	r12
    a3f0:	08 95       	ret

0000a3f2 <GPRS_Param03>:
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a3f2:	cf 92       	push	r12
    a3f4:	ef 92       	push	r14
    a3f6:	0f 93       	push	r16
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a3f8:	c1 2c       	mov	r12, r1
    a3fa:	ee 24       	eor	r14, r14
    a3fc:	e3 94       	inc	r14
    a3fe:	06 2f       	mov	r16, r22
    a400:	20 e0       	ldi	r18, 0x00	; 0
    a402:	40 e0       	ldi	r20, 0x00	; 0
    a404:	50 e0       	ldi	r21, 0x00	; 0
    a406:	68 2f       	mov	r22, r24
    a408:	83 e0       	ldi	r24, 0x03	; 3
    a40a:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a40e:	0f 91       	pop	r16
    a410:	ef 90       	pop	r14
    a412:	cf 90       	pop	r12
    a414:	08 95       	ret

0000a416 <GPRS_Param04>:

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a416:	cf 92       	push	r12
    a418:	ef 92       	push	r14
    a41a:	0f 93       	push	r16
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a41c:	c1 2c       	mov	r12, r1
    a41e:	ee 24       	eor	r14, r14
    a420:	e3 94       	inc	r14
    a422:	06 2f       	mov	r16, r22
    a424:	20 e0       	ldi	r18, 0x00	; 0
    a426:	40 e0       	ldi	r20, 0x00	; 0
    a428:	50 e0       	ldi	r21, 0x00	; 0
    a42a:	68 2f       	mov	r22, r24
    a42c:	84 e0       	ldi	r24, 0x04	; 4
    a42e:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a432:	0f 91       	pop	r16
    a434:	ef 90       	pop	r14
    a436:	cf 90       	pop	r12
    a438:	08 95       	ret

0000a43a <GPRS_Param05>:

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a43a:	cf 92       	push	r12
    a43c:	ef 92       	push	r14
    a43e:	0f 93       	push	r16
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a440:	c1 2c       	mov	r12, r1
    a442:	ee 24       	eor	r14, r14
    a444:	e3 94       	inc	r14
    a446:	06 2f       	mov	r16, r22
    a448:	20 e0       	ldi	r18, 0x00	; 0
    a44a:	40 e0       	ldi	r20, 0x00	; 0
    a44c:	50 e0       	ldi	r21, 0x00	; 0
    a44e:	68 2f       	mov	r22, r24
    a450:	85 e0       	ldi	r24, 0x05	; 5
    a452:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a456:	0f 91       	pop	r16
    a458:	ef 90       	pop	r14
    a45a:	cf 90       	pop	r12
    a45c:	08 95       	ret

0000a45e <GPRS_Param06>:

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a45e:	cf 92       	push	r12
    a460:	ef 92       	push	r14
    a462:	0f 93       	push	r16
    a464:	2f ef       	ldi	r18, 0xFF	; 255
    a466:	28 0f       	add	r18, r24
    a468:	27 30       	cpi	r18, 0x07	; 7
    a46a:	68 f4       	brcc	.+26     	; 0xa486 <GPRS_Param06+0x28>
    a46c:	30 e0       	ldi	r19, 0x00	; 0
    a46e:	f9 01       	movw	r30, r18
    a470:	ee 0f       	add	r30, r30
    a472:	ff 1f       	adc	r31, r31
    a474:	ea 51       	subi	r30, 0x1A	; 26
    a476:	fe 4f       	sbci	r31, 0xFE	; 254
    a478:	40 81       	ld	r20, Z
    a47a:	51 81       	ldd	r21, Z+1	; 0x01
    a47c:	f9 01       	movw	r30, r18
    a47e:	e1 52       	subi	r30, 0x21	; 33
    a480:	fe 4f       	sbci	r31, 0xFE	; 254
    a482:	20 81       	ld	r18, Z
    a484:	03 c0       	rjmp	.+6      	; 0xa48c <GPRS_Param06+0x2e>
    a486:	20 e0       	ldi	r18, 0x00	; 0
    a488:	40 e0       	ldi	r20, 0x00	; 0
    a48a:	50 e0       	ldi	r21, 0x00	; 0
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a48c:	c1 2c       	mov	r12, r1
    a48e:	ee 24       	eor	r14, r14
    a490:	e3 94       	inc	r14
    a492:	06 2f       	mov	r16, r22
    a494:	68 2f       	mov	r22, r24
    a496:	86 e0       	ldi	r24, 0x06	; 6
    a498:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a49c:	0f 91       	pop	r16
    a49e:	ef 90       	pop	r14
    a4a0:	cf 90       	pop	r12
    a4a2:	08 95       	ret

0000a4a4 <GPRS_Param07>:
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4a4:	cf 92       	push	r12
    a4a6:	ef 92       	push	r14
    a4a8:	0f 93       	push	r16
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a4aa:	c1 2c       	mov	r12, r1
    a4ac:	ee 24       	eor	r14, r14
    a4ae:	e3 94       	inc	r14
    a4b0:	06 2f       	mov	r16, r22
    a4b2:	20 e0       	ldi	r18, 0x00	; 0
    a4b4:	40 e0       	ldi	r20, 0x00	; 0
    a4b6:	50 e0       	ldi	r21, 0x00	; 0
    a4b8:	68 2f       	mov	r22, r24
    a4ba:	87 e0       	ldi	r24, 0x07	; 7
    a4bc:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a4c0:	0f 91       	pop	r16
    a4c2:	ef 90       	pop	r14
    a4c4:	cf 90       	pop	r12
    a4c6:	08 95       	ret

0000a4c8 <GPRS_Param08>:

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4c8:	cf 92       	push	r12
    a4ca:	ef 92       	push	r14
    a4cc:	0f 93       	push	r16
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    a4ce:	c1 2c       	mov	r12, r1
    a4d0:	ee 24       	eor	r14, r14
    a4d2:	e3 94       	inc	r14
    a4d4:	06 2f       	mov	r16, r22
    a4d6:	20 e0       	ldi	r18, 0x00	; 0
    a4d8:	40 e0       	ldi	r20, 0x00	; 0
    a4da:	50 e0       	ldi	r21, 0x00	; 0
    a4dc:	68 2f       	mov	r22, r24
    a4de:	88 e0       	ldi	r24, 0x08	; 8
    a4e0:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a4e4:	0f 91       	pop	r16
    a4e6:	ef 90       	pop	r14
    a4e8:	cf 90       	pop	r12
    a4ea:	08 95       	ret

0000a4ec <GPRS_Param09>:

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4ec:	cf 92       	push	r12
    a4ee:	ef 92       	push	r14
    a4f0:	0f 93       	push	r16
    a4f2:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a4f4:	48 2f       	mov	r20, r24
    a4f6:	50 e0       	ldi	r21, 0x00	; 0
    a4f8:	fa 01       	movw	r30, r20
    a4fa:	31 97       	sbiw	r30, 0x01	; 1
    a4fc:	e6 31       	cpi	r30, 0x16	; 22
    a4fe:	f1 05       	cpc	r31, r1
    a500:	08 f0       	brcs	.+2      	; 0xa504 <GPRS_Param09+0x18>
    a502:	78 c0       	rjmp	.+240    	; 0xa5f4 <GPRS_Param09+0x108>
    a504:	e2 55       	subi	r30, 0x52	; 82
    a506:	ff 4f       	sbci	r31, 0xFF	; 255
    a508:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
    a50c:	23 e1       	ldi	r18, 0x13	; 19
    a50e:	42 e5       	ldi	r20, 0x52	; 82
    a510:	51 e0       	ldi	r21, 0x01	; 1
    a512:	7b c0       	rjmp	.+246    	; 0xa60a <GPRS_Param09+0x11e>
void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:
			if(Cmd==READ_PARAM){
    a514:	61 3c       	cpi	r22, 0xC1	; 193
    a516:	91 f4       	brne	.+36     	; 0xa53c <GPRS_Param09+0x50>
    a518:	4f e0       	ldi	r20, 0x0F	; 15
    a51a:	50 e0       	ldi	r21, 0x00	; 0
    a51c:	6a e7       	ldi	r22, 0x7A	; 122
    a51e:	71 e0       	ldi	r23, 0x01	; 1
    a520:	80 e4       	ldi	r24, 0x40	; 64
    a522:	96 e0       	ldi	r25, 0x06	; 6
    a524:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a528:	4f e0       	ldi	r20, 0x0F	; 15
    a52a:	50 e0       	ldi	r21, 0x00	; 0
    a52c:	68 e9       	ldi	r22, 0x98	; 152
    a52e:	71 e0       	ldi	r23, 0x01	; 1
    a530:	8f e4       	ldi	r24, 0x4F	; 79
    a532:	96 e0       	ldi	r25, 0x06	; 6
    a534:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
    a538:	2e e1       	ldi	r18, 0x1E	; 30
    a53a:	5f c0       	rjmp	.+190    	; 0xa5fa <GPRS_Param09+0x10e>
			}
			if(Cmd==WRITE_PARAM){
    a53c:	6c 34       	cpi	r22, 0x4C	; 76
    a53e:	09 f0       	breq	.+2      	; 0xa542 <GPRS_Param09+0x56>
    a540:	6f c0       	rjmp	.+222    	; 0xa620 <GPRS_Param09+0x134>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    a542:	4f e0       	ldi	r20, 0x0F	; 15
    a544:	50 e0       	ldi	r21, 0x00	; 0
    a546:	6a e7       	ldi	r22, 0x7A	; 122
    a548:	71 e0       	ldi	r23, 0x01	; 1
    a54a:	82 e4       	ldi	r24, 0x42	; 66
    a54c:	98 e0       	ldi	r25, 0x08	; 8
    a54e:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    a552:	4f e0       	ldi	r20, 0x0F	; 15
    a554:	50 e0       	ldi	r21, 0x00	; 0
    a556:	6c e3       	ldi	r22, 0x3C	; 60
    a558:	73 e0       	ldi	r23, 0x03	; 3
    a55a:	81 e5       	ldi	r24, 0x51	; 81
    a55c:	98 e0       	ldi	r25, 0x08	; 8
    a55e:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
    a562:	5e c0       	rjmp	.+188    	; 0xa620 <GPRS_Param09+0x134>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    a564:	24 e0       	ldi	r18, 0x04	; 4
    a566:	46 e4       	ldi	r20, 0x46	; 70
    a568:	51 e0       	ldi	r21, 0x01	; 1
    a56a:	4f c0       	rjmp	.+158    	; 0xa60a <GPRS_Param09+0x11e>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    a56c:	24 e0       	ldi	r18, 0x04	; 4
    a56e:	4a e4       	ldi	r20, 0x4A	; 74
    a570:	51 e0       	ldi	r21, 0x01	; 1
    a572:	4b c0       	rjmp	.+150    	; 0xa60a <GPRS_Param09+0x11e>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    a574:	24 e0       	ldi	r18, 0x04	; 4
    a576:	4e e4       	ldi	r20, 0x4E	; 78
    a578:	51 e0       	ldi	r21, 0x01	; 1
    a57a:	47 c0       	rjmp	.+142    	; 0xa60a <GPRS_Param09+0x11e>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    a57c:	22 e0       	ldi	r18, 0x02	; 2
    a57e:	4a e2       	ldi	r20, 0x2A	; 42
    a580:	51 e0       	ldi	r21, 0x01	; 1
    a582:	43 c0       	rjmp	.+134    	; 0xa60a <GPRS_Param09+0x11e>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    a584:	22 e0       	ldi	r18, 0x02	; 2
    a586:	4c e2       	ldi	r20, 0x2C	; 44
    a588:	51 e0       	ldi	r21, 0x01	; 1
    a58a:	3f c0       	rjmp	.+126    	; 0xa60a <GPRS_Param09+0x11e>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    a58c:	22 e0       	ldi	r18, 0x02	; 2
    a58e:	4e e2       	ldi	r20, 0x2E	; 46
    a590:	51 e0       	ldi	r21, 0x01	; 1
    a592:	3b c0       	rjmp	.+118    	; 0xa60a <GPRS_Param09+0x11e>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    a594:	22 e0       	ldi	r18, 0x02	; 2
    a596:	40 e3       	ldi	r20, 0x30	; 48
    a598:	51 e0       	ldi	r21, 0x01	; 1
    a59a:	37 c0       	rjmp	.+110    	; 0xa60a <GPRS_Param09+0x11e>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    a59c:	24 e0       	ldi	r18, 0x04	; 4
    a59e:	40 e1       	ldi	r20, 0x10	; 16
    a5a0:	51 e0       	ldi	r21, 0x01	; 1
    a5a2:	33 c0       	rjmp	.+102    	; 0xa60a <GPRS_Param09+0x11e>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    a5a4:	24 e0       	ldi	r18, 0x04	; 4
    a5a6:	44 e1       	ldi	r20, 0x14	; 20
    a5a8:	51 e0       	ldi	r21, 0x01	; 1
    a5aa:	2f c0       	rjmp	.+94     	; 0xa60a <GPRS_Param09+0x11e>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    a5ac:	24 e0       	ldi	r18, 0x04	; 4
    a5ae:	48 e1       	ldi	r20, 0x18	; 24
    a5b0:	51 e0       	ldi	r21, 0x01	; 1
    a5b2:	2b c0       	rjmp	.+86     	; 0xa60a <GPRS_Param09+0x11e>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    a5b4:	24 e0       	ldi	r18, 0x04	; 4
    a5b6:	4c e1       	ldi	r20, 0x1C	; 28
    a5b8:	51 e0       	ldi	r21, 0x01	; 1
    a5ba:	27 c0       	rjmp	.+78     	; 0xa60a <GPRS_Param09+0x11e>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    a5bc:	22 e0       	ldi	r18, 0x02	; 2
    a5be:	40 e2       	ldi	r20, 0x20	; 32
    a5c0:	51 e0       	ldi	r21, 0x01	; 1
    a5c2:	23 c0       	rjmp	.+70     	; 0xa60a <GPRS_Param09+0x11e>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    a5c4:	22 e0       	ldi	r18, 0x02	; 2
    a5c6:	4e e0       	ldi	r20, 0x0E	; 14
    a5c8:	51 e0       	ldi	r21, 0x01	; 1
    a5ca:	1f c0       	rjmp	.+62     	; 0xa60a <GPRS_Param09+0x11e>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    a5cc:	21 e0       	ldi	r18, 0x01	; 1
    a5ce:	40 e6       	ldi	r20, 0x60	; 96
    a5d0:	50 e0       	ldi	r21, 0x00	; 0
    a5d2:	1b c0       	rjmp	.+54     	; 0xa60a <GPRS_Param09+0x11e>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    a5d4:	2c e0       	ldi	r18, 0x0C	; 12
    a5d6:	43 ee       	ldi	r20, 0xE3	; 227
    a5d8:	50 e0       	ldi	r21, 0x00	; 0
    a5da:	17 c0       	rjmp	.+46     	; 0xa60a <GPRS_Param09+0x11e>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    a5dc:	2c e0       	ldi	r18, 0x0C	; 12
    a5de:	40 ef       	ldi	r20, 0xF0	; 240
    a5e0:	50 e0       	ldi	r21, 0x00	; 0
    a5e2:	13 c0       	rjmp	.+38     	; 0xa60a <GPRS_Param09+0x11e>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    a5e4:	2c e0       	ldi	r18, 0x0C	; 12
    a5e6:	4d ef       	ldi	r20, 0xFD	; 253
    a5e8:	50 e0       	ldi	r21, 0x00	; 0
    a5ea:	0f c0       	rjmp	.+30     	; 0xa60a <GPRS_Param09+0x11e>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;
    a5ec:	22 e0       	ldi	r18, 0x02	; 2
    a5ee:	48 e0       	ldi	r20, 0x08	; 8
    a5f0:	50 e0       	ldi	r21, 0x00	; 0
    a5f2:	0b c0       	rjmp	.+22     	; 0xa60a <GPRS_Param09+0x11e>
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a5f4:	20 e0       	ldi	r18, 0x00	; 0
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a5f6:	81 30       	cpi	r24, 0x01	; 1
    a5f8:	31 f4       	brne	.+12     	; 0xa606 <GPRS_Param09+0x11a>
    a5fa:	c1 2c       	mov	r12, r1
    a5fc:	e1 2c       	mov	r14, r1
    a5fe:	40 e0       	ldi	r20, 0x00	; 0
    a600:	50 e0       	ldi	r21, 0x00	; 0
    a602:	61 e0       	ldi	r22, 0x01	; 1
    a604:	06 c0       	rjmp	.+12     	; 0xa612 <GPRS_Param09+0x126>
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a606:	40 e0       	ldi	r20, 0x00	; 0
    a608:	50 e0       	ldi	r21, 0x00	; 0

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a60a:	c1 2c       	mov	r12, r1
    a60c:	ee 24       	eor	r14, r14
    a60e:	e3 94       	inc	r14
    a610:	68 2f       	mov	r22, r24
    a612:	89 e0       	ldi	r24, 0x09	; 9
    a614:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a618:	0f 91       	pop	r16
    a61a:	ef 90       	pop	r14
    a61c:	cf 90       	pop	r12
    a61e:	08 95       	ret
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a620:	20 e0       	ldi	r18, 0x00	; 0
    a622:	eb cf       	rjmp	.-42     	; 0xa5fa <GPRS_Param09+0x10e>
			if(Cmd==WRITE_PARAM){
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
    a624:	23 e1       	ldi	r18, 0x13	; 19
    a626:	46 e6       	ldi	r20, 0x66	; 102
    a628:	51 e0       	ldi	r21, 0x01	; 1
    a62a:	ef cf       	rjmp	.-34     	; 0xa60a <GPRS_Param09+0x11e>
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    a62c:	24 e0       	ldi	r18, 0x04	; 4
    a62e:	42 e4       	ldi	r20, 0x42	; 66
    a630:	51 e0       	ldi	r21, 0x01	; 1
    a632:	eb cf       	rjmp	.-42     	; 0xa60a <GPRS_Param09+0x11e>

0000a634 <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a634:	cf 92       	push	r12
    a636:	ef 92       	push	r14
    a638:	0f 93       	push	r16
    a63a:	ef ef       	ldi	r30, 0xFF	; 255
    a63c:	e8 0f       	add	r30, r24
    a63e:	e5 30       	cpi	r30, 0x05	; 5
    a640:	48 f4       	brcc	.+18     	; 0xa654 <GPRS_Param10+0x20>
    a642:	f0 e0       	ldi	r31, 0x00	; 0
    a644:	ee 0f       	add	r30, r30
    a646:	ff 1f       	adc	r31, r31
    a648:	eb 52       	subi	r30, 0x2B	; 43
    a64a:	fe 4f       	sbci	r31, 0xFE	; 254
    a64c:	40 81       	ld	r20, Z
    a64e:	51 81       	ldd	r21, Z+1	; 0x01
    a650:	22 e0       	ldi	r18, 0x02	; 2
    a652:	03 c0       	rjmp	.+6      	; 0xa65a <GPRS_Param10+0x26>
    a654:	20 e0       	ldi	r18, 0x00	; 0
    a656:	40 e0       	ldi	r20, 0x00	; 0
    a658:	50 e0       	ldi	r21, 0x00	; 0
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a65a:	c1 2c       	mov	r12, r1
    a65c:	ee 24       	eor	r14, r14
    a65e:	e3 94       	inc	r14
    a660:	06 2f       	mov	r16, r22
    a662:	68 2f       	mov	r22, r24
    a664:	8a e0       	ldi	r24, 0x0A	; 10
    a666:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
}
    a66a:	0f 91       	pop	r16
    a66c:	ef 90       	pop	r14
    a66e:	cf 90       	pop	r12
    a670:	08 95       	ret

0000a672 <GPRS_Param11>:
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a672:	cf 92       	push	r12
    a674:	ef 92       	push	r14
    a676:	0f 93       	push	r16
    a678:	cf 93       	push	r28
    a67a:	c8 2f       	mov	r28, r24
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a67c:	81 30       	cpi	r24, 0x01	; 1
    a67e:	21 f4       	brne	.+8      	; 0xa688 <GPRS_Param11+0x16>
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
    a680:	21 e0       	ldi	r18, 0x01	; 1
    a682:	49 e2       	ldi	r20, 0x29	; 41
    a684:	50 e0       	ldi	r21, 0x00	; 0
    a686:	03 c0       	rjmp	.+6      	; 0xa68e <GPRS_Param11+0x1c>
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a688:	20 e0       	ldi	r18, 0x00	; 0
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a68a:	40 e0       	ldi	r20, 0x00	; 0
    a68c:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a68e:	c1 2c       	mov	r12, r1
    a690:	ee 24       	eor	r14, r14
    a692:	e3 94       	inc	r14
    a694:	06 2f       	mov	r16, r22
    a696:	6c 2f       	mov	r22, r28
    a698:	8b e0       	ldi	r24, 0x0B	; 11
    a69a:	0e 94 ff 50 	call	0xa1fe	; 0xa1fe <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a69e:	c1 30       	cpi	r28, 0x01	; 1
    a6a0:	31 f4       	brne	.+12     	; 0xa6ae <GPRS_Param11+0x3c>
#endif
}
    a6a2:	cf 91       	pop	r28
    a6a4:	0f 91       	pop	r16
    a6a6:	ef 90       	pop	r14
    a6a8:	cf 90       	pop	r12
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a6aa:	0c 94 7f 4b 	jmp	0x96fe	; 0x96fe <EMeter_ReInit>
#endif
}
    a6ae:	cf 91       	pop	r28
    a6b0:	0f 91       	pop	r16
    a6b2:	ef 90       	pop	r14
    a6b4:	cf 90       	pop	r12
    a6b6:	08 95       	ret

0000a6b8 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
    a6b8:	0f 93       	push	r16
    a6ba:	1f 93       	push	r17
    a6bc:	08 2f       	mov	r16, r24
    a6be:	86 2f       	mov	r24, r22
    a6c0:	64 2f       	mov	r22, r20
	switch(ParamID_Hi){
    a6c2:	10 e0       	ldi	r17, 0x00	; 0
    a6c4:	0c 30       	cpi	r16, 0x0C	; 12
    a6c6:	11 05       	cpc	r17, r1
    a6c8:	a8 f5       	brcc	.+106    	; 0xa734 <GPRS_Parameter+0x7c>
    a6ca:	f8 01       	movw	r30, r16
    a6cc:	ec 53       	subi	r30, 0x3C	; 60
    a6ce:	ff 4f       	sbci	r31, 0xFF	; 255
    a6d0:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6d4:	1f 91       	pop	r17
    a6d6:	0f 91       	pop	r16
#endif
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    a6d8:	0c 94 6b 51 	jmp	0xa2d6	; 0xa2d6 <GPRS_Param00>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6dc:	1f 91       	pop	r17
    a6de:	0f 91       	pop	r16
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    a6e0:	0c 94 d7 51 	jmp	0xa3ae	; 0xa3ae <GPRS_Param01>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6e4:	1f 91       	pop	r17
    a6e6:	0f 91       	pop	r16

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    a6e8:	0c 94 e8 51 	jmp	0xa3d0	; 0xa3d0 <GPRS_Param02>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6ec:	1f 91       	pop	r17
    a6ee:	0f 91       	pop	r16
void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    a6f0:	0c 94 f9 51 	jmp	0xa3f2	; 0xa3f2 <GPRS_Param03>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6f4:	1f 91       	pop	r17
    a6f6:	0f 91       	pop	r16
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    a6f8:	0c 94 0b 52 	jmp	0xa416	; 0xa416 <GPRS_Param04>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a6fc:	1f 91       	pop	r17
    a6fe:	0f 91       	pop	r16
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    a700:	0c 94 1d 52 	jmp	0xa43a	; 0xa43a <GPRS_Param05>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a704:	1f 91       	pop	r17
    a706:	0f 91       	pop	r16
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    a708:	0c 94 2f 52 	jmp	0xa45e	; 0xa45e <GPRS_Param06>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a70c:	1f 91       	pop	r17
    a70e:	0f 91       	pop	r16
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    a710:	0c 94 52 52 	jmp	0xa4a4	; 0xa4a4 <GPRS_Param07>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a714:	1f 91       	pop	r17
    a716:	0f 91       	pop	r16
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    a718:	0c 94 64 52 	jmp	0xa4c8	; 0xa4c8 <GPRS_Param08>
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a71c:	1f 91       	pop	r17
    a71e:	0f 91       	pop	r16
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    a720:	0c 94 76 52 	jmp	0xa4ec	; 0xa4ec <GPRS_Param09>
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a724:	1f 91       	pop	r17
    a726:	0f 91       	pop	r16
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    a728:	0c 94 1a 53 	jmp	0xa634	; 0xa634 <GPRS_Param10>
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a72c:	1f 91       	pop	r17
    a72e:	0f 91       	pop	r16
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    a730:	0c 94 39 53 	jmp	0xa672	; 0xa672 <GPRS_Param11>
	}
}
    a734:	1f 91       	pop	r17
    a736:	0f 91       	pop	r16
    a738:	08 95       	ret

0000a73a <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    a73a:	cf 93       	push	r28
    a73c:	c8 2f       	mov	r28, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    a73e:	82 30       	cpi	r24, 0x02	; 2
    a740:	09 f0       	breq	.+2      	; 0xa744 <ReadParamBlock+0xa>
    a742:	80 c0       	rjmp	.+256    	; 0xa844 <ReadParamBlock+0x10a>
    a744:	4f e0       	ldi	r20, 0x0F	; 15
    a746:	50 e0       	ldi	r21, 0x00	; 0
    a748:	6a e7       	ldi	r22, 0x7A	; 122
    a74a:	71 e0       	ldi	r23, 0x01	; 1
    a74c:	8f e3       	ldi	r24, 0x3F	; 63
    a74e:	96 e0       	ldi	r25, 0x06	; 6
    a750:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a754:	4f e0       	ldi	r20, 0x0F	; 15
    a756:	50 e0       	ldi	r21, 0x00	; 0
    a758:	6c e3       	ldi	r22, 0x3C	; 60
    a75a:	73 e0       	ldi	r23, 0x03	; 3
    a75c:	8e e4       	ldi	r24, 0x4E	; 78
    a75e:	96 e0       	ldi	r25, 0x06	; 6
    a760:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a764:	43 e1       	ldi	r20, 0x13	; 19
    a766:	50 e0       	ldi	r21, 0x00	; 0
    a768:	66 e6       	ldi	r22, 0x66	; 102
    a76a:	71 e0       	ldi	r23, 0x01	; 1
    a76c:	8d e5       	ldi	r24, 0x5D	; 93
    a76e:	96 e0       	ldi	r25, 0x06	; 6
    a770:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a774:	44 e1       	ldi	r20, 0x14	; 20
    a776:	50 e0       	ldi	r21, 0x00	; 0
    a778:	62 e5       	ldi	r22, 0x52	; 82
    a77a:	71 e0       	ldi	r23, 0x01	; 1
    a77c:	80 e7       	ldi	r24, 0x70	; 112
    a77e:	96 e0       	ldi	r25, 0x06	; 6
    a780:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a784:	40 e1       	ldi	r20, 0x10	; 16
    a786:	50 e0       	ldi	r21, 0x00	; 0
    a788:	62 e4       	ldi	r22, 0x42	; 66
    a78a:	71 e0       	ldi	r23, 0x01	; 1
    a78c:	83 e8       	ldi	r24, 0x83	; 131
    a78e:	96 e0       	ldi	r25, 0x06	; 6
    a790:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a794:	48 e0       	ldi	r20, 0x08	; 8
    a796:	50 e0       	ldi	r21, 0x00	; 0
    a798:	6a e2       	ldi	r22, 0x2A	; 42
    a79a:	71 e0       	ldi	r23, 0x01	; 1
    a79c:	83 e9       	ldi	r24, 0x93	; 147
    a79e:	96 e0       	ldi	r25, 0x06	; 6
    a7a0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7a4:	40 e1       	ldi	r20, 0x10	; 16
    a7a6:	50 e0       	ldi	r21, 0x00	; 0
    a7a8:	60 e1       	ldi	r22, 0x10	; 16
    a7aa:	71 e0       	ldi	r23, 0x01	; 1
    a7ac:	8b e9       	ldi	r24, 0x9B	; 155
    a7ae:	96 e0       	ldi	r25, 0x06	; 6
    a7b0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7b4:	42 e0       	ldi	r20, 0x02	; 2
    a7b6:	50 e0       	ldi	r21, 0x00	; 0
    a7b8:	60 e2       	ldi	r22, 0x20	; 32
    a7ba:	71 e0       	ldi	r23, 0x01	; 1
    a7bc:	8b ea       	ldi	r24, 0xAB	; 171
    a7be:	96 e0       	ldi	r25, 0x06	; 6
    a7c0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7c4:	42 e0       	ldi	r20, 0x02	; 2
    a7c6:	50 e0       	ldi	r21, 0x00	; 0
    a7c8:	6e e0       	ldi	r22, 0x0E	; 14
    a7ca:	71 e0       	ldi	r23, 0x01	; 1
    a7cc:	8d ea       	ldi	r24, 0xAD	; 173
    a7ce:	96 e0       	ldi	r25, 0x06	; 6
    a7d0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7d4:	41 e0       	ldi	r20, 0x01	; 1
    a7d6:	50 e0       	ldi	r21, 0x00	; 0
    a7d8:	60 e6       	ldi	r22, 0x60	; 96
    a7da:	70 e0       	ldi	r23, 0x00	; 0
    a7dc:	8f ea       	ldi	r24, 0xAF	; 175
    a7de:	96 e0       	ldi	r25, 0x06	; 6
    a7e0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7e4:	4c e0       	ldi	r20, 0x0C	; 12
    a7e6:	50 e0       	ldi	r21, 0x00	; 0
    a7e8:	63 ee       	ldi	r22, 0xE3	; 227
    a7ea:	70 e0       	ldi	r23, 0x00	; 0
    a7ec:	80 eb       	ldi	r24, 0xB0	; 176
    a7ee:	96 e0       	ldi	r25, 0x06	; 6
    a7f0:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a7f4:	4c e0       	ldi	r20, 0x0C	; 12
    a7f6:	50 e0       	ldi	r21, 0x00	; 0
    a7f8:	60 ef       	ldi	r22, 0xF0	; 240
    a7fa:	70 e0       	ldi	r23, 0x00	; 0
    a7fc:	8c eb       	ldi	r24, 0xBC	; 188
    a7fe:	96 e0       	ldi	r25, 0x06	; 6
    a800:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a804:	4c e0       	ldi	r20, 0x0C	; 12
    a806:	50 e0       	ldi	r21, 0x00	; 0
    a808:	6d ef       	ldi	r22, 0xFD	; 253
    a80a:	70 e0       	ldi	r23, 0x00	; 0
    a80c:	88 ec       	ldi	r24, 0xC8	; 200
    a80e:	96 e0       	ldi	r25, 0x06	; 6
    a810:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
    a814:	42 e0       	ldi	r20, 0x02	; 2
    a816:	50 e0       	ldi	r21, 0x00	; 0
    a818:	68 e0       	ldi	r22, 0x08	; 8
    a81a:	70 e0       	ldi	r23, 0x00	; 0
    a81c:	84 ed       	ldi	r24, 0xD4	; 212
    a81e:	96 e0       	ldi	r25, 0x06	; 6
    a820:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    a824:	c0 93 3e 06 	sts	0x063E, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a828:	29 e9       	ldi	r18, 0x99	; 153
    a82a:	41 e1       	ldi	r20, 0x11	; 17
    a82c:	63 e0       	ldi	r22, 0x03	; 3
    a82e:	87 e3       	ldi	r24, 0x37	; 55
    a830:	96 e0       	ldi	r25, 0x06	; 6
    a832:	0e 94 dd 4c 	call	0x99ba	; 0x99ba <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a836:	80 91 4a 09 	lds	r24, 0x094A
    a83a:	88 60       	ori	r24, 0x08	; 8
    a83c:	80 93 4a 09 	sts	0x094A, r24
		GPRS_ChangeReplySize = blocksize;
    a840:	8f e9       	ldi	r24, 0x9F	; 159
    a842:	17 c0       	rjmp	.+46     	; 0xa872 <ReadParamBlock+0x138>
	}

	if(Block == 3){
    a844:	83 30       	cpi	r24, 0x03	; 3
    a846:	c1 f4       	brne	.+48     	; 0xa878 <ReadParamBlock+0x13e>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a848:	89 e2       	ldi	r24, 0x29	; 41
    a84a:	90 e0       	ldi	r25, 0x00	; 0
    a84c:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    a850:	80 93 3f 06 	sts	0x063F, r24

		GPRS_ChangeData[7] = Block;
    a854:	c0 93 3e 06 	sts	0x063E, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a858:	23 e0       	ldi	r18, 0x03	; 3
    a85a:	41 e1       	ldi	r20, 0x11	; 17
    a85c:	63 e0       	ldi	r22, 0x03	; 3
    a85e:	87 e3       	ldi	r24, 0x37	; 55
    a860:	96 e0       	ldi	r25, 0x06	; 6
    a862:	0e 94 dd 4c 	call	0x99ba	; 0x99ba <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a866:	80 91 4a 09 	lds	r24, 0x094A
    a86a:	88 60       	ori	r24, 0x08	; 8
    a86c:	80 93 4a 09 	sts	0x094A, r24
		GPRS_ChangeReplySize = blocksize;
    a870:	89 e0       	ldi	r24, 0x09	; 9
    a872:	80 93 0b 06 	sts	0x060B, r24
    a876:	01 c0       	rjmp	.+2      	; 0xa87a <ReadParamBlock+0x140>

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){

	uint8_t blocksize=8;
    a878:	88 e0       	ldi	r24, 0x08	; 8
		GPRS_ChangeReplySize = blocksize;
	}

	return blocksize;
	
}
    a87a:	cf 91       	pop	r28
    a87c:	08 95       	ret

0000a87e <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){
    a87e:	cf 93       	push	r28

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    a880:	c0 91 4b 09 	lds	r28, 0x094B
    a884:	cc 23       	and	r28, r28
    a886:	09 f4       	brne	.+2      	; 0xa88a <GPRS_ReciveData+0xc>
    a888:	8a c0       	rjmp	.+276    	; 0xa99e <GPRS_ReciveData+0x120>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    a88a:	80 91 37 08 	lds	r24, 0x0837
    a88e:	85 30       	cpi	r24, 0x05	; 5
    a890:	09 f0       	breq	.+2      	; 0xa894 <GPRS_ReciveData+0x16>
    a892:	85 c0       	rjmp	.+266    	; 0xa99e <GPRS_ReciveData+0x120>
    a894:	80 91 38 08 	lds	r24, 0x0838
    a898:	81 30       	cpi	r24, 0x01	; 1
    a89a:	09 f0       	breq	.+2      	; 0xa89e <GPRS_ReciveData+0x20>
    a89c:	80 c0       	rjmp	.+256    	; 0xa99e <GPRS_ReciveData+0x120>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
    a89e:	80 91 39 08 	lds	r24, 0x0839
    a8a2:	90 e0       	ldi	r25, 0x00	; 0
    a8a4:	98 2f       	mov	r25, r24
    a8a6:	88 27       	eor	r24, r24
    a8a8:	20 91 3a 08 	lds	r18, 0x083A
		if(GPRS_Check_PSW(Psw) == 0){
    a8ac:	82 0f       	add	r24, r18
    a8ae:	91 1d       	adc	r25, r1
    a8b0:	0e 94 0c 50 	call	0xa018	; 0xa018 <GPRS_Check_PSW>
    a8b4:	81 11       	cpse	r24, r1
    a8b6:	06 c0       	rjmp	.+12     	; 0xa8c4 <GPRS_ReciveData+0x46>
			GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a8b8:	80 91 56 09 	lds	r24, 0x0956
    a8bc:	88 60       	ori	r24, 0x08	; 8
    a8be:	80 93 56 09 	sts	0x0956, r24
    a8c2:	1b c0       	rjmp	.+54     	; 0xa8fa <GPRS_ReciveData+0x7c>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    a8c4:	80 91 3b 08 	lds	r24, 0x083B
    a8c8:	84 30       	cpi	r24, 0x04	; 4
    a8ca:	d9 f4       	brne	.+54     	; 0xa902 <GPRS_ReciveData+0x84>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a8cc:	8c e0       	ldi	r24, 0x0C	; 12
    a8ce:	91 e0       	ldi	r25, 0x01	; 1
    a8d0:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    a8d4:	20 91 3c 08 	lds	r18, 0x083C
    a8d8:	30 e0       	ldi	r19, 0x00	; 0
    a8da:	32 2f       	mov	r19, r18
    a8dc:	22 27       	eor	r18, r18
    a8de:	40 91 3d 08 	lds	r20, 0x083D
    a8e2:	24 0f       	add	r18, r20
    a8e4:	31 1d       	adc	r19, r1
    a8e6:	40 91 56 09 	lds	r20, 0x0956
    a8ea:	82 17       	cp	r24, r18
    a8ec:	93 07       	cpc	r25, r19
    a8ee:	11 f4       	brne	.+4      	; 0xa8f4 <GPRS_ReciveData+0x76>
    a8f0:	47 7f       	andi	r20, 0xF7	; 247
    a8f2:	01 c0       	rjmp	.+2      	; 0xa8f6 <GPRS_ReciveData+0x78>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a8f4:	48 60       	ori	r20, 0x08	; 8
    a8f6:	40 93 56 09 	sts	0x0956, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    a8fa:	80 91 4a 09 	lds	r24, 0x094A
    a8fe:	80 61       	ori	r24, 0x10	; 16
    a900:	2e c0       	rjmp	.+92     	; 0xa95e <GPRS_ReciveData+0xe0>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    a902:	83 30       	cpi	r24, 0x03	; 3
    a904:	09 f0       	breq	.+2      	; 0xa908 <GPRS_ReciveData+0x8a>
    a906:	4b c0       	rjmp	.+150    	; 0xa99e <GPRS_ReciveData+0x120>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    a908:	20 91 fd 0a 	lds	r18, 0x0AFD
    a90c:	30 91 fe 0a 	lds	r19, 0x0AFE
    a910:	21 15       	cp	r18, r1
    a912:	31 05       	cpc	r19, r1
    a914:	89 f2       	breq	.-94     	; 0xa8b8 <GPRS_ReciveData+0x3a>
    a916:	80 91 3c 08 	lds	r24, 0x083C
    a91a:	90 e0       	ldi	r25, 0x00	; 0
    a91c:	98 2f       	mov	r25, r24
    a91e:	88 27       	eor	r24, r24
    a920:	40 91 3d 08 	lds	r20, 0x083D
    a924:	84 0f       	add	r24, r20
    a926:	91 1d       	adc	r25, r1
    a928:	28 17       	cp	r18, r24
    a92a:	39 07       	cpc	r19, r25
    a92c:	29 f6       	brne	.-118    	; 0xa8b8 <GPRS_ReciveData+0x3a>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    a92e:	90 91 3e 08 	lds	r25, 0x083E
			
			switch(GPRS_Data_In[8]){
    a932:	80 91 3f 08 	lds	r24, 0x083F
    a936:	88 30       	cpi	r24, 0x08	; 8
    a938:	d9 f0       	breq	.+54     	; 0xa970 <GPRS_ReciveData+0xf2>
    a93a:	28 f4       	brcc	.+10     	; 0xa946 <GPRS_ReciveData+0xc8>
    a93c:	81 30       	cpi	r24, 0x01	; 1
    a93e:	41 f0       	breq	.+16     	; 0xa950 <GPRS_ReciveData+0xd2>
    a940:	87 30       	cpi	r24, 0x07	; 7
    a942:	81 f0       	breq	.+32     	; 0xa964 <GPRS_ReciveData+0xe6>
    a944:	2c c0       	rjmp	.+88     	; 0xa99e <GPRS_ReciveData+0x120>
    a946:	8a 30       	cpi	r24, 0x0A	; 10
    a948:	d9 f0       	breq	.+54     	; 0xa980 <GPRS_ReciveData+0x102>
    a94a:	81 31       	cpi	r24, 0x11	; 17
    a94c:	01 f1       	breq	.+64     	; 0xa98e <GPRS_ReciveData+0x110>
    a94e:	27 c0       	rjmp	.+78     	; 0xa99e <GPRS_ReciveData+0x120>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    a950:	91 30       	cpi	r25, 0x01	; 1
    a952:	29 f5       	brne	.+74     	; 0xa99e <GPRS_ReciveData+0x120>
    a954:	c9 30       	cpi	r28, 0x09	; 9
    a956:	19 f5       	brne	.+70     	; 0xa99e <GPRS_ReciveData+0x120>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    a958:	80 91 4a 09 	lds	r24, 0x094A
    a95c:	82 60       	ori	r24, 0x02	; 2
    a95e:	80 93 4a 09 	sts	0x094A, r24
    a962:	1d c0       	rjmp	.+58     	; 0xa99e <GPRS_ReciveData+0x120>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    a964:	93 30       	cpi	r25, 0x03	; 3
    a966:	d9 f4       	brne	.+54     	; 0xa99e <GPRS_ReciveData+0x120>
    a968:	cb 30       	cpi	r28, 0x0B	; 11
    a96a:	c9 f4       	brne	.+50     	; 0xa99e <GPRS_ReciveData+0x120>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    a96c:	41 ec       	ldi	r20, 0xC1	; 193
    a96e:	01 c0       	rjmp	.+2      	; 0xa972 <GPRS_ReciveData+0xf4>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    a970:	4c e4       	ldi	r20, 0x4C	; 76
    a972:	60 91 41 08 	lds	r22, 0x0841
    a976:	80 91 40 08 	lds	r24, 0x0840
    a97a:	0e 94 5c 53 	call	0xa6b8	; 0xa6b8 <GPRS_Parameter>
				break;
    a97e:	0f c0       	rjmp	.+30     	; 0xa99e <GPRS_ReciveData+0x120>
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    a980:	92 30       	cpi	r25, 0x02	; 2
    a982:	69 f4       	brne	.+26     	; 0xa99e <GPRS_ReciveData+0x120>
    a984:	ca 30       	cpi	r28, 0x0A	; 10
    a986:	59 f4       	brne	.+22     	; 0xa99e <GPRS_ReciveData+0x120>
					GPRS_RemoteDisplayControl();
    a988:	0e 94 6a 50 	call	0xa0d4	; 0xa0d4 <GPRS_RemoteDisplayControl>
    a98c:	08 c0       	rjmp	.+16     	; 0xa99e <GPRS_ReciveData+0x120>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    a98e:	92 30       	cpi	r25, 0x02	; 2
    a990:	31 f4       	brne	.+12     	; 0xa99e <GPRS_ReciveData+0x120>
    a992:	ca 30       	cpi	r28, 0x0A	; 10
    a994:	21 f4       	brne	.+8      	; 0xa99e <GPRS_ReciveData+0x120>
					ReadParamBlock	(GPRS_Data_In[9]);
    a996:	80 91 40 08 	lds	r24, 0x0840
    a99a:	0e 94 9d 53 	call	0xa73a	; 0xa73a <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
    a99e:	10 92 4b 09 	sts	0x094B, r1
	}//   
	else GPRS_FlgSz_In = 0;
}
    a9a2:	cf 91       	pop	r28
    a9a4:	08 95       	ret

0000a9a6 <GPRS_Arbitr>:
// -----                  
void GPRS_Arbitr(void){
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    a9a6:	80 91 4a 09 	lds	r24, 0x094A
    a9aa:	86 ff       	sbrs	r24, 6
    a9ac:	06 c0       	rjmp	.+12     	; 0xa9ba <GPRS_Arbitr+0x14>
		GPRS_SendNewCrash();
    a9ae:	0e 94 e9 4f 	call	0x9fd2	; 0x9fd2 <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    a9b2:	80 91 4a 09 	lds	r24, 0x094A
    a9b6:	8f 7b       	andi	r24, 0xBF	; 191
    a9b8:	3d c0       	rjmp	.+122    	; 0xaa34 <GPRS_Arbitr+0x8e>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    a9ba:	85 ff       	sbrs	r24, 5
    a9bc:	0d c0       	rjmp	.+26     	; 0xa9d8 <GPRS_Arbitr+0x32>
		GPRS_SendRepCrash();
    a9be:	0e 94 f9 4f 	call	0x9ff2	; 0x9ff2 <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    a9c2:	80 91 4a 09 	lds	r24, 0x094A
    a9c6:	8f 7d       	andi	r24, 0xDF	; 223
    a9c8:	80 93 4a 09 	sts	0x094A, r24
		GPRS_Protocol_Out = UDP;
    a9cc:	10 92 69 09 	sts	0x0969, r1
		IP_SendMask = 0b11111110;	//   IP1
    a9d0:	8e ef       	ldi	r24, 0xFE	; 254
    a9d2:	80 93 69 08 	sts	0x0869, r24
    a9d6:	34 c0       	rjmp	.+104    	; 0xaa40 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    a9d8:	84 ff       	sbrs	r24, 4
    a9da:	06 c0       	rjmp	.+12     	; 0xa9e8 <GPRS_Arbitr+0x42>
		GPRS_Get_Session_ID();
    a9dc:	0e 94 2a 50 	call	0xa054	; 0xa054 <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    a9e0:	80 91 4a 09 	lds	r24, 0x094A
    a9e4:	8f 7e       	andi	r24, 0xEF	; 239
    a9e6:	19 c0       	rjmp	.+50     	; 0xaa1a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    a9e8:	83 ff       	sbrs	r24, 3
    a9ea:	08 c0       	rjmp	.+16     	; 0xa9fc <GPRS_Arbitr+0x56>
		GPRS_SendChange(GPRS_ChangeReplySize);
    a9ec:	80 91 0b 06 	lds	r24, 0x060B
    a9f0:	0e 94 95 50 	call	0xa12a	; 0xa12a <GPRS_SendChange>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    a9f4:	80 91 4a 09 	lds	r24, 0x094A
    a9f8:	87 7f       	andi	r24, 0xF7	; 247
    a9fa:	0f c0       	rjmp	.+30     	; 0xaa1a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    a9fc:	82 ff       	sbrs	r24, 2
    a9fe:	06 c0       	rjmp	.+12     	; 0xaa0c <GPRS_Arbitr+0x66>
		GPRS_SendDisplay();
    aa00:	0e 94 74 50 	call	0xa0e8	; 0xa0e8 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    aa04:	80 91 4a 09 	lds	r24, 0x094A
    aa08:	8b 7f       	andi	r24, 0xFB	; 251
    aa0a:	07 c0       	rjmp	.+14     	; 0xaa1a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    aa0c:	81 ff       	sbrs	r24, 1
    aa0e:	0b c0       	rjmp	.+22     	; 0xaa26 <GPRS_Arbitr+0x80>
		GPRS_CurDataSend();
    aa10:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    aa14:	80 91 4a 09 	lds	r24, 0x094A
    aa18:	8d 7f       	andi	r24, 0xFD	; 253
    aa1a:	80 93 4a 09 	sts	0x094A, r24
		GPRS_Protocol_Out = TCP;
    aa1e:	81 e0       	ldi	r24, 0x01	; 1
    aa20:	80 93 69 09 	sts	0x0969, r24
    aa24:	0d c0       	rjmp	.+26     	; 0xaa40 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    aa26:	80 ff       	sbrs	r24, 0
    aa28:	0f c0       	rjmp	.+30     	; 0xaa48 <GPRS_Arbitr+0xa2>
		GPRS_CurDataSend();
    aa2a:	0e 94 08 4d 	call	0x9a10	; 0x9a10 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    aa2e:	80 91 4a 09 	lds	r24, 0x094A
    aa32:	8e 7f       	andi	r24, 0xFE	; 254
    aa34:	80 93 4a 09 	sts	0x094A, r24
		GPRS_Protocol_Out = UDP;
    aa38:	10 92 69 09 	sts	0x0969, r1
		IP_SendMask = 0;	//   IP
    aa3c:	10 92 69 08 	sts	0x0869, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    aa40:	80 91 31 09 	lds	r24, 0x0931
    aa44:	80 93 68 09 	sts	0x0968, r24
    aa48:	08 95       	ret

0000aa4a <GPRS_App>:
		return;
	}
}
// -----   ApplCycle
void GPRS_App(void){
    aa4a:	cf 93       	push	r28
    aa4c:	df 93       	push	r29

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    aa4e:	c0 91 3c 09 	lds	r28, 0x093C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aa52:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint16_t Time = Timer16[TimerN];
    aa56:	ec 2f       	mov	r30, r28
    aa58:	f0 e0       	ldi	r31, 0x00	; 0
    aa5a:	ee 0f       	add	r30, r30
    aa5c:	ff 1f       	adc	r31, r31
    aa5e:	e0 5e       	subi	r30, 0xE0	; 224
    aa60:	fc 4f       	sbci	r31, 0xFC	; 252
    aa62:	c0 81       	ld	r28, Z
    aa64:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    aa66:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
    aa6a:	c8 3c       	cpi	r28, 0xC8	; 200
    aa6c:	d1 05       	cpc	r29, r1
    aa6e:	30 f4       	brcc	.+12     	; 0xaa7c <GPRS_App+0x32>
    aa70:	6f ef       	ldi	r22, 0xFF	; 255
    aa72:	7f ef       	ldi	r23, 0xFF	; 255
    aa74:	80 91 3c 09 	lds	r24, 0x093C
    aa78:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    aa7c:	80 91 07 01 	lds	r24, 0x0107
    aa80:	8f 3f       	cpi	r24, 0xFF	; 255
    aa82:	31 f4       	brne	.+12     	; 0xaa90 <GPRS_App+0x46>
		GPRS_Session_ID = 0;
    aa84:	10 92 fe 0a 	sts	0x0AFE, r1
    aa88:	10 92 fd 0a 	sts	0x0AFD, r1
		GPRS_LoginLevel = 0;
    aa8c:	10 92 c3 08 	sts	0x08C3, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    aa90:	c0 91 09 06 	lds	r28, 0x0609

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aa94:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint16_t Time = Timer16[TimerN];
    aa98:	ec 2f       	mov	r30, r28
    aa9a:	f0 e0       	ldi	r31, 0x00	; 0
    aa9c:	ee 0f       	add	r30, r30
    aa9e:	ff 1f       	adc	r31, r31
    aaa0:	e0 5e       	subi	r30, 0xE0	; 224
    aaa2:	fc 4f       	sbci	r31, 0xFC	; 252
    aaa4:	c0 81       	ld	r28, Z
    aaa6:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    aaa8:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
    aaac:	d0 93 fa 05 	sts	0x05FA, r29
    aab0:	c0 93 f9 05 	sts	0x05F9, r28

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    aab4:	80 91 56 09 	lds	r24, 0x0956
    aab8:	80 fd       	sbrc	r24, 0
    aaba:	1b c0       	rjmp	.+54     	; 0xaaf2 <GPRS_App+0xa8>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    aabc:	0e 94 3f 54 	call	0xa87e	; 0xa87e <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    aac0:	80 e0       	ldi	r24, 0x00	; 0
    aac2:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    aac6:	88 23       	and	r24, r24
    aac8:	61 f0       	breq	.+24     	; 0xaae2 <GPRS_App+0x98>
    aaca:	90 91 56 09 	lds	r25, 0x0956
    aace:	92 ff       	sbrs	r25, 2
    aad0:	08 c0       	rjmp	.+16     	; 0xaae2 <GPRS_App+0x98>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    aad2:	80 91 4a 09 	lds	r24, 0x094A
    aad6:	84 60       	ori	r24, 0x04	; 4
    aad8:	80 93 4a 09 	sts	0x094A, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    aadc:	9b 7f       	andi	r25, 0xFB	; 251
    aade:	90 93 56 09 	sts	0x0956, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    aae2:	0e 94 24 4f 	call	0x9e48	; 0x9e48 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    aae6:	80 91 31 09 	lds	r24, 0x0931
    aaea:	81 11       	cpse	r24, r1
    aaec:	02 c0       	rjmp	.+4      	; 0xaaf2 <GPRS_App+0xa8>
    aaee:	0e 94 d3 54 	call	0xa9a6	; 0xa9a6 <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
}
    aaf2:	df 91       	pop	r29
    aaf4:	cf 91       	pop	r28
		GPRS_SendData();
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
	}

	GPRS_CriticalCMD_Process();
    aaf6:	0c 94 47 51 	jmp	0xa28e	; 0xa28e <GPRS_CriticalCMD_Process>

0000aafa <GSMApply>:
}

void 
GSMApply(void){//=====================================================   GSM

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    aafa:	4e e1       	ldi	r20, 0x1E	; 30
    aafc:	50 e0       	ldi	r21, 0x00	; 0
    aafe:	6a e7       	ldi	r22, 0x7A	; 122
    ab00:	71 e0       	ldi	r23, 0x01	; 1
    ab02:	88 e7       	ldi	r24, 0x78	; 120
    ab04:	98 e0       	ldi	r25, 0x08	; 8
    ab06:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
	wdt_reset();
    ab0a:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    ab0c:	44 e1       	ldi	r20, 0x14	; 20
    ab0e:	50 e0       	ldi	r21, 0x00	; 0
    ab10:	66 e6       	ldi	r22, 0x66	; 102
    ab12:	71 e0       	ldi	r23, 0x01	; 1
    ab14:	86 e9       	ldi	r24, 0x96	; 150
    ab16:	98 e0       	ldi	r25, 0x08	; 8
    ab18:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
	wdt_reset();
    ab1c:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    ab1e:	44 e1       	ldi	r20, 0x14	; 20
    ab20:	50 e0       	ldi	r21, 0x00	; 0
    ab22:	62 e5       	ldi	r22, 0x52	; 82
    ab24:	71 e0       	ldi	r23, 0x01	; 1
    ab26:	8a ea       	ldi	r24, 0xAA	; 170
    ab28:	98 e0       	ldi	r25, 0x08	; 8
    ab2a:	0e 94 d6 29 	call	0x53ac	; 0x53ac <ewbl>
	wdt_reset();
    ab2e:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    ab30:	60 91 be 08 	lds	r22, 0x08BE
    ab34:	70 91 bf 08 	lds	r23, 0x08BF
    ab38:	80 e2       	ldi	r24, 0x20	; 32
    ab3a:	91 e0       	ldi	r25, 0x01	; 1
    ab3c:	0e 94 ce 29 	call	0x539c	; 0x539c <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    ab40:	60 91 c0 08 	lds	r22, 0x08C0
    ab44:	70 91 c1 08 	lds	r23, 0x08C1
    ab48:	8e e0       	ldi	r24, 0x0E	; 14
    ab4a:	91 e0       	ldi	r25, 0x01	; 1
    ab4c:	0c 94 ce 29 	jmp	0x539c	; 0x539c <eww>

0000ab50 <Modbus_App>:
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    ab50:	cf 93       	push	r28
    ab52:	df 93       	push	r29

	IntOff();
    ab54:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	MBInput1[0] = DigInput.State[0];
    ab58:	80 91 c4 08 	lds	r24, 0x08C4
    ab5c:	80 93 f0 03 	sts	0x03F0, r24

	MBInReg1[0] = (SW_VERSION << 8) + 	SW_SUBVERSION;
    ab60:	87 e0       	ldi	r24, 0x07	; 7
    ab62:	93 e0       	ldi	r25, 0x03	; 3
    ab64:	90 93 66 0a 	sts	0x0A66, r25
    ab68:	80 93 65 0a 	sts	0x0A65, r24
	MBInReg1[1] = MemFail;
    ab6c:	80 91 64 0a 	lds	r24, 0x0A64
    ab70:	90 e0       	ldi	r25, 0x00	; 0
    ab72:	90 93 68 0a 	sts	0x0A68, r25
    ab76:	80 93 67 0a 	sts	0x0A67, r24
	MBInReg1[2] = (uint16_t)(LiveTime & 0x0000FFFF);
    ab7a:	80 91 50 09 	lds	r24, 0x0950
    ab7e:	90 91 51 09 	lds	r25, 0x0951
    ab82:	a0 91 52 09 	lds	r26, 0x0952
    ab86:	b0 91 53 09 	lds	r27, 0x0953
    ab8a:	90 93 6a 0a 	sts	0x0A6A, r25
    ab8e:	80 93 69 0a 	sts	0x0A69, r24
	MBInReg1[3] = (uint16_t)(LiveTime>>16);
    ab92:	80 91 50 09 	lds	r24, 0x0950
    ab96:	90 91 51 09 	lds	r25, 0x0951
    ab9a:	a0 91 52 09 	lds	r26, 0x0952
    ab9e:	b0 91 53 09 	lds	r27, 0x0953
    aba2:	b0 93 6c 0a 	sts	0x0A6C, r27
    aba6:	a0 93 6b 0a 	sts	0x0A6B, r26
	MBInReg1[4] = (uint16_t)Temperature[0];	
    abaa:	80 91 ec 05 	lds	r24, 0x05EC
    abae:	90 91 ed 05 	lds	r25, 0x05ED
    abb2:	90 93 6e 0a 	sts	0x0A6E, r25
    abb6:	80 93 6d 0a 	sts	0x0A6D, r24
	MBInReg1[5] = (uint16_t)GSM_State;
    abba:	80 91 21 06 	lds	r24, 0x0621
    abbe:	90 e0       	ldi	r25, 0x00	; 0
    abc0:	90 93 70 0a 	sts	0x0A70, r25
    abc4:	80 93 6f 0a 	sts	0x0A6F, r24
	MBInReg1[6] = GSM_MyIP.IP1;
    abc8:	80 91 09 0b 	lds	r24, 0x0B09
    abcc:	90 e0       	ldi	r25, 0x00	; 0
    abce:	90 93 72 0a 	sts	0x0A72, r25
    abd2:	80 93 71 0a 	sts	0x0A71, r24
	MBInReg1[7] = GSM_MyIP.IP2;
    abd6:	80 91 0a 0b 	lds	r24, 0x0B0A
    abda:	90 e0       	ldi	r25, 0x00	; 0
    abdc:	90 93 74 0a 	sts	0x0A74, r25
    abe0:	80 93 73 0a 	sts	0x0A73, r24
	MBInReg1[8] = GSM_MyIP.IP3;
    abe4:	80 91 0b 0b 	lds	r24, 0x0B0B
    abe8:	90 e0       	ldi	r25, 0x00	; 0
    abea:	90 93 76 0a 	sts	0x0A76, r25
    abee:	80 93 75 0a 	sts	0x0A75, r24
	MBInReg1[9] = GSM_MyIP.IP4;
    abf2:	80 91 0c 0b 	lds	r24, 0x0B0C
    abf6:	90 e0       	ldi	r25, 0x00	; 0
    abf8:	90 93 78 0a 	sts	0x0A78, r25
    abfc:	80 93 77 0a 	sts	0x0A77, r24
	MBInReg1[10] = GSM_ClientIP.IP1;
    ac00:	80 91 27 0d 	lds	r24, 0x0D27
    ac04:	90 e0       	ldi	r25, 0x00	; 0
    ac06:	90 93 7a 0a 	sts	0x0A7A, r25
    ac0a:	80 93 79 0a 	sts	0x0A79, r24
	MBInReg1[11] = GSM_ClientIP.IP2;
    ac0e:	80 91 28 0d 	lds	r24, 0x0D28
    ac12:	90 e0       	ldi	r25, 0x00	; 0
    ac14:	90 93 7c 0a 	sts	0x0A7C, r25
    ac18:	80 93 7b 0a 	sts	0x0A7B, r24
	MBInReg1[12] = GSM_ClientIP.IP3;
    ac1c:	80 91 29 0d 	lds	r24, 0x0D29
    ac20:	90 e0       	ldi	r25, 0x00	; 0
    ac22:	90 93 7e 0a 	sts	0x0A7E, r25
    ac26:	80 93 7d 0a 	sts	0x0A7D, r24
	MBInReg1[13] = GSM_ClientIP.IP4;
    ac2a:	80 91 2a 0d 	lds	r24, 0x0D2A
    ac2e:	90 e0       	ldi	r25, 0x00	; 0
    ac30:	90 93 80 0a 	sts	0x0A80, r25
    ac34:	80 93 7f 0a 	sts	0x0A7F, r24
	MBInReg1[14] = GSM_RX_FIFOMax;
    ac38:	80 91 fa 0a 	lds	r24, 0x0AFA
    ac3c:	90 e0       	ldi	r25, 0x00	; 0
    ac3e:	90 93 82 0a 	sts	0x0A82, r25
    ac42:	80 93 81 0a 	sts	0x0A81, r24
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    ac46:	80 91 6c 09 	lds	r24, 0x096C
    ac4a:	90 e0       	ldi	r25, 0x00	; 0
    ac4c:	90 93 84 0a 	sts	0x0A84, r25
    ac50:	80 93 83 0a 	sts	0x0A83, r24
	MBInReg1[16] = EM_RX_FIFOMax;
    ac54:	80 91 5b 0a 	lds	r24, 0x0A5B
    ac58:	90 e0       	ldi	r25, 0x00	; 0
    ac5a:	90 93 86 0a 	sts	0x0A86, r25
    ac5e:	80 93 85 0a 	sts	0x0A85, r24
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    ac62:	80 91 60 09 	lds	r24, 0x0960
    ac66:	80 93 87 0a 	sts	0x0A87, r24
    ac6a:	80 91 61 09 	lds	r24, 0x0961
    ac6e:	80 93 88 0a 	sts	0x0A88, r24
    ac72:	80 91 62 09 	lds	r24, 0x0962
    ac76:	80 93 89 0a 	sts	0x0A89, r24
    ac7a:	80 91 63 09 	lds	r24, 0x0963
    ac7e:	80 93 8a 0a 	sts	0x0A8A, r24
    ac82:	80 91 64 09 	lds	r24, 0x0964
    ac86:	80 93 8b 0a 	sts	0x0A8B, r24
    ac8a:	80 91 65 09 	lds	r24, 0x0965
    ac8e:	80 93 8c 0a 	sts	0x0A8C, r24
    ac92:	80 91 66 09 	lds	r24, 0x0966
    ac96:	80 93 8d 0a 	sts	0x0A8D, r24
    ac9a:	80 91 67 09 	lds	r24, 0x0967
    ac9e:	80 93 8e 0a 	sts	0x0A8E, r24
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    aca2:	80 91 49 09 	lds	r24, 0x0949
    aca6:	90 e0       	ldi	r25, 0x00	; 0
    aca8:	90 93 90 0a 	sts	0x0A90, r25
    acac:	80 93 8f 0a 	sts	0x0A8F, r24
	MBInReg1[22] = (uint16_t)Web_POST;
    acb0:	80 91 5a 09 	lds	r24, 0x095A
    acb4:	90 e0       	ldi	r25, 0x00	; 0
    acb6:	90 93 92 0a 	sts	0x0A92, r25
    acba:	80 93 91 0a 	sts	0x0A91, r24
	MBInReg1[23] = (uint16_t)AppProtocol;
    acbe:	80 91 e1 09 	lds	r24, 0x09E1
    acc2:	90 e0       	ldi	r25, 0x00	; 0
    acc4:	90 93 94 0a 	sts	0x0A94, r25
    acc8:	80 93 93 0a 	sts	0x0A93, r24
	MBInReg1[24] = (uint16_t)WebSession;
    accc:	80 91 6b 09 	lds	r24, 0x096B
    acd0:	90 e0       	ldi	r25, 0x00	; 0
    acd2:	90 93 96 0a 	sts	0x0A96, r25
    acd6:	80 93 95 0a 	sts	0x0A95, r24
	MBInReg1[25] = (uint16_t)WebMode;
    acda:	80 91 06 01 	lds	r24, 0x0106
    acde:	90 e0       	ldi	r25, 0x00	; 0
    ace0:	90 93 98 0a 	sts	0x0A98, r25
    ace4:	80 93 97 0a 	sts	0x0A97, r24
	MBInReg1[26] = (uint16_t)WebStrLen;
    ace8:	80 91 6a 08 	lds	r24, 0x086A
    acec:	90 e0       	ldi	r25, 0x00	; 0
    acee:	90 93 9a 0a 	sts	0x0A9A, r25
    acf2:	80 93 99 0a 	sts	0x0A99, r24

	IntOn();
    acf6:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    acfa:	80 91 d9 03 	lds	r24, 0x03D9
    acfe:	80 ff       	sbrs	r24, 0
    ad00:	10 c0       	rjmp	.+32     	; 0xad22 <Modbus_App+0x1d2>
		GSMApply();						//  MB RAM  EEPROM
    ad02:	0e 94 7d 55 	call	0xaafa	; 0xaafa <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    ad06:	0e 94 1e 2a 	call	0x543c	; 0x543c <Modbus_ReadHoldReg>
    ad0a:	88 e5       	ldi	r24, 0x58	; 88
    ad0c:	80 93 21 06 	sts	0x0621, r24
		ResetGSMState();				// 
		IntOff();
    ad10:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    ad14:	80 91 d9 03 	lds	r24, 0x03D9
    ad18:	8e 7f       	andi	r24, 0xFE	; 254
    ad1a:	80 93 d9 03 	sts	0x03D9, r24
		IntOn();
    ad1e:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
	}
	
	IntOff();
    ad22:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    ad26:	c0 91 76 08 	lds	r28, 0x0876
    ad2a:	d0 91 77 08 	lds	r29, 0x0877
    ad2e:	87 e2       	ldi	r24, 0x27	; 39
    ad30:	90 e0       	ldi	r25, 0x00	; 0
    ad32:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    ad36:	c8 17       	cp	r28, r24
    ad38:	d9 07       	cpc	r29, r25
    ad3a:	29 f0       	breq	.+10     	; 0xad46 <Modbus_App+0x1f6>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    ad3c:	be 01       	movw	r22, r28
    ad3e:	87 e2       	ldi	r24, 0x27	; 39
    ad40:	90 e0       	ldi	r25, 0x00	; 0
    ad42:	0e 94 ce 29 	call	0x539c	; 0x539c <eww>
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    ad46:	df 91       	pop	r29
    ad48:	cf 91       	pop	r28
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
		eww(&EM_UART_Param, MBHoldReg1[0]);
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
    ad4a:	0c 94 16 2a 	jmp	0x542c	; 0x542c <IntOn>

0000ad4e <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    ad4e:	81 e0       	ldi	r24, 0x01	; 1
    ad50:	80 93 df 09 	sts	0x09DF, r24
	ModbusMode = 0;
    ad54:	10 92 da 03 	sts	0x03DA, r1
	EM_InitFIFO();
    ad58:	0e 94 b2 4a 	call	0x9564	; 0x9564 <EM_InitFIFO>
	cli();
    ad5c:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    ad5e:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    ad60:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ad64:	88 e0       	ldi	r24, 0x08	; 8
    ad66:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    ad6a:	85 e0       	ldi	r24, 0x05	; 5
    ad6c:	99 e1       	ldi	r25, 0x19	; 25
    ad6e:	0e 94 be 4a 	call	0x957c	; 0x957c <EM_SetUARTParam>
	sei();	
    ad72:	78 94       	sei
    ad74:	08 95       	ret

0000ad76 <StopDebug>:
}

void StopDebug(void){
	GSM_DebugMode = 0;
    ad76:	10 92 df 09 	sts	0x09DF, r1
	ModbusMode = 1;
    ad7a:	81 e0       	ldi	r24, 0x01	; 1
    ad7c:	80 93 da 03 	sts	0x03DA, r24
	cli();
    ad80:	f8 94       	cli
	MB_Init();
    ad82:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <MB_Init>
	sei();
    ad86:	78 94       	sei
    ad88:	08 95       	ret

0000ad8a <SendDebug>:
}

//  ISR
void SendDebug(uint8_t Char){
	//---FIFO
	EM_RX_FIFO_Begin++;
    ad8a:	90 91 5d 09 	lds	r25, 0x095D
    ad8e:	9f 5f       	subi	r25, 0xFF	; 255
    ad90:	90 93 5d 09 	sts	0x095D, r25
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    ad94:	90 91 5d 09 	lds	r25, 0x095D
    ad98:	9f 3f       	cpi	r25, 0xFF	; 255
    ad9a:	11 f4       	brne	.+4      	; 0xada0 <SendDebug+0x16>
    ad9c:	10 92 5d 09 	sts	0x095D, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    ada0:	e0 91 5d 09 	lds	r30, 0x095D
    ada4:	f0 e0       	ldi	r31, 0x00	; 0
    ada6:	ed 50       	subi	r30, 0x0D	; 13
    ada8:	fc 4f       	sbci	r31, 0xFC	; 252
    adaa:	80 83       	st	Z, r24
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    adac:	90 91 5d 09 	lds	r25, 0x095D
    adb0:	80 91 25 0d 	lds	r24, 0x0D25
    adb4:	98 13       	cpse	r25, r24
    adb6:	06 c0       	rjmp	.+12     	; 0xadc4 <SendDebug+0x3a>
		EM_RX_FIFOOverFlow = 1;
    adb8:	81 e0       	ldi	r24, 0x01	; 1
    adba:	80 93 11 0b 	sts	0x0B11, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    adbe:	8f ef       	ldi	r24, 0xFF	; 255
    adc0:	80 93 5b 0a 	sts	0x0A5B, r24
    adc4:	08 95       	ret

0000adc6 <GSM_RX>:
}
// ~~~~~~~~~
void
GSM_RX(void)
{
	char Char = UDR_GSM;
    adc6:	8c b1       	in	r24, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    adc8:	90 91 75 08 	lds	r25, 0x0875
    adcc:	9f 5f       	subi	r25, 0xFF	; 255
    adce:	90 93 75 08 	sts	0x0875, r25
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    add2:	90 91 75 08 	lds	r25, 0x0875
    add6:	9a 3f       	cpi	r25, 0xFA	; 250
    add8:	10 f0       	brcs	.+4      	; 0xadde <GSM_RX+0x18>
    adda:	10 92 75 08 	sts	0x0875, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    adde:	e0 91 75 08 	lds	r30, 0x0875
    ade2:	f0 e0       	ldi	r31, 0x00	; 0
    ade4:	ee 50       	subi	r30, 0x0E	; 14
    ade6:	fb 4f       	sbci	r31, 0xFB	; 251
    ade8:	80 83       	st	Z, r24
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    adea:	20 91 75 08 	lds	r18, 0x0875
    adee:	90 91 ff 05 	lds	r25, 0x05FF
    adf2:	29 13       	cpse	r18, r25
    adf4:	06 c0       	rjmp	.+12     	; 0xae02 <GSM_RX+0x3c>
		GSM_RX_FIFOOverFlow = 1;
    adf6:	91 e0       	ldi	r25, 0x01	; 1
    adf8:	90 93 5a 0a 	sts	0x0A5A, r25
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    adfc:	9a ef       	ldi	r25, 0xFA	; 250
    adfe:	90 93 fa 0a 	sts	0x0AFA, r25
	}

	//---In Transparent Mode
	if(Transparent){
    ae02:	90 91 63 0a 	lds	r25, 0x0A63
    ae06:	99 23       	and	r25, r25
    ae08:	a1 f0       	breq	.+40     	; 0xae32 <GSM_RX+0x6c>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ae0a:	98 eb       	ldi	r25, 0xB8	; 184
    ae0c:	90 93 9a 00 	sts	0x009A, r25
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    ae10:	90 91 9b 00 	lds	r25, 0x009B
    ae14:	90 64       	ori	r25, 0x40	; 64
    ae16:	90 93 9b 00 	sts	0x009B, r25

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    ae1a:	20 91 75 08 	lds	r18, 0x0875
    ae1e:	90 91 e5 0a 	lds	r25, 0x0AE5
    ae22:	29 13       	cpse	r18, r25
    ae24:	06 c0       	rjmp	.+12     	; 0xae32 <GSM_RX+0x6c>
			GSM_RX_FIFOOverFlow_Transp = 1;
    ae26:	91 e0       	ldi	r25, 0x01	; 1
    ae28:	90 93 37 0e 	sts	0x0E37, r25
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    ae2c:	9a ef       	ldi	r25, 0xFA	; 250
    ae2e:	90 93 6c 09 	sts	0x096C, r25
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    ae32:	90 91 df 09 	lds	r25, 0x09DF
    ae36:	99 23       	and	r25, r25
    ae38:	29 f0       	breq	.+10     	; 0xae44 <GSM_RX+0x7e>
		SendDebug(Char);
    ae3a:	0e 94 c5 56 	call	0xad8a	; 0xad8a <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    ae3e:	88 e2       	ldi	r24, 0x28	; 40
    ae40:	80 93 9a 00 	sts	0x009A, r24
    ae44:	08 95       	ret

0000ae46 <__vector_18>:
}
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    ae46:	1f 92       	push	r1
    ae48:	0f 92       	push	r0
    ae4a:	0f b6       	in	r0, 0x3f	; 63
    ae4c:	0f 92       	push	r0
    ae4e:	11 24       	eor	r1, r1
    ae50:	0b b6       	in	r0, 0x3b	; 59
    ae52:	0f 92       	push	r0
    ae54:	2f 93       	push	r18
    ae56:	3f 93       	push	r19
    ae58:	4f 93       	push	r20
    ae5a:	5f 93       	push	r21
    ae5c:	6f 93       	push	r22
    ae5e:	7f 93       	push	r23
    ae60:	8f 93       	push	r24
    ae62:	9f 93       	push	r25
    ae64:	af 93       	push	r26
    ae66:	bf 93       	push	r27
    ae68:	ef 93       	push	r30
    ae6a:	ff 93       	push	r31
	GSM_RX();
    ae6c:	0e 94 e3 56 	call	0xadc6	; 0xadc6 <GSM_RX>
	GSM_LED = 1;
    ae70:	81 e0       	ldi	r24, 0x01	; 1
    ae72:	80 93 04 06 	sts	0x0604, r24
}
    ae76:	ff 91       	pop	r31
    ae78:	ef 91       	pop	r30
    ae7a:	bf 91       	pop	r27
    ae7c:	af 91       	pop	r26
    ae7e:	9f 91       	pop	r25
    ae80:	8f 91       	pop	r24
    ae82:	7f 91       	pop	r23
    ae84:	6f 91       	pop	r22
    ae86:	5f 91       	pop	r21
    ae88:	4f 91       	pop	r20
    ae8a:	3f 91       	pop	r19
    ae8c:	2f 91       	pop	r18
    ae8e:	0f 90       	pop	r0
    ae90:	0b be       	out	0x3b, r0	; 59
    ae92:	0f 90       	pop	r0
    ae94:	0f be       	out	0x3f, r0	; 63
    ae96:	0f 90       	pop	r0
    ae98:	1f 90       	pop	r1
    ae9a:	18 95       	reti

0000ae9c <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    ae9c:	80 91 26 0c 	lds	r24, 0x0C26
    aea0:	8c b9       	out	0x0c, r24	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    aea2:	80 91 df 09 	lds	r24, 0x09DF
    aea6:	88 23       	and	r24, r24
    aea8:	49 f0       	breq	.+18     	; 0xaebc <GSM_SendFirstChar+0x20>
		SendDebug(GSM_TxStr[0]);
    aeaa:	80 91 26 0c 	lds	r24, 0x0C26
    aeae:	0e 94 c5 56 	call	0xad8a	; 0xad8a <SendDebug>
		cli();
    aeb2:	f8 94       	cli
    aeb4:	88 e2       	ldi	r24, 0x28	; 40
    aeb6:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    aeba:	78 94       	sei
	}

	GSM_TxCharN = 1;
    aebc:	81 e0       	ldi	r24, 0x01	; 1
    aebe:	80 93 33 0d 	sts	0x0D33, r24
	cli();
    aec2:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    aec4:	80 91 08 01 	lds	r24, 0x0108
    aec8:	8e 7f       	andi	r24, 0xFE	; 254
    aeca:	80 93 08 01 	sts	0x0108, r24
	sei();
    aece:	78 94       	sei
	cli();
    aed0:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    aed2:	88 eb       	ldi	r24, 0xB8	; 184
    aed4:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    aed6:	78 94       	sei
    aed8:	08 95       	ret

0000aeda <GSM_SendCR>:
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    aeda:	cf 93       	push	r28
    aedc:	df 93       	push	r29
    aede:	ec 01       	movw	r28, r24


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    aee0:	0e 94 00 6c 	call	0xd800	; 0xd800 <__strlen_P>
	GSMTxSz = strlen_P(Str_P);
    aee4:	80 93 45 09 	sts	0x0945, r24
	sprintf_P(GSM_TxStr, Str_P);
    aee8:	df 93       	push	r29
    aeea:	cf 93       	push	r28
    aeec:	86 e2       	ldi	r24, 0x26	; 38
    aeee:	9c e0       	ldi	r25, 0x0C	; 12
    aef0:	9f 93       	push	r25
    aef2:	8f 93       	push	r24
    aef4:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    aef8:	80 91 45 09 	lds	r24, 0x0945
    aefc:	90 e0       	ldi	r25, 0x00	; 0
    aefe:	6c ec       	ldi	r22, 0xCC	; 204
    af00:	71 e0       	ldi	r23, 0x01	; 1
    af02:	8a 5d       	subi	r24, 0xDA	; 218
    af04:	93 4f       	sbci	r25, 0xF3	; 243
    af06:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
	GSMTxSz++;
    af0a:	80 91 45 09 	lds	r24, 0x0945
    af0e:	8f 5f       	subi	r24, 0xFF	; 255
    af10:	80 93 45 09 	sts	0x0945, r24
	GSM_SendFirstChar();
    af14:	0f 90       	pop	r0
    af16:	0f 90       	pop	r0
    af18:	0f 90       	pop	r0
    af1a:	0f 90       	pop	r0
}
    af1c:	df 91       	pop	r29
    af1e:	cf 91       	pop	r28
void GSM_SendCR(prog_char *Str_P){
	GSMTxSz = strlen_P(Str_P);
	sprintf_P(GSM_TxStr, Str_P);
	sprintf(GSM_TxStr + GSMTxSz, "\r");
	GSMTxSz++;
	GSM_SendFirstChar();
    af20:	0c 94 4e 57 	jmp	0xae9c	; 0xae9c <GSM_SendFirstChar>

0000af24 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    af24:	cf 93       	push	r28
    af26:	df 93       	push	r29
    af28:	00 d0       	rcall	.+0      	; 0xaf2a <GSM_Execute_Command+0x6>
    af2a:	cd b7       	in	r28, 0x3d	; 61
    af2c:	de b7       	in	r29, 0x3e	; 62
	if(GSM_Flag & (1<<flg_TxCStr)){
    af2e:	20 91 08 01 	lds	r18, 0x0108
    af32:	20 ff       	sbrs	r18, 0
    af34:	0e c0       	rjmp	.+28     	; 0xaf52 <GSM_Execute_Command+0x2e>
		GSM_SendCR(Str_P);
    af36:	69 83       	std	Y+1, r22	; 0x01
    af38:	7a 83       	std	Y+2, r23	; 0x02
    af3a:	0e 94 6d 57 	call	0xaeda	; 0xaeda <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    af3e:	69 81       	ldd	r22, Y+1	; 0x01
    af40:	7a 81       	ldd	r23, Y+2	; 0x02
    af42:	80 91 54 02 	lds	r24, 0x0254
	}
}
    af46:	0f 90       	pop	r0
    af48:	0f 90       	pop	r0
    af4a:	df 91       	pop	r29
    af4c:	cf 91       	pop	r28
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
	if(GSM_Flag & (1<<flg_TxCStr)){
		GSM_SendCR(Str_P);
		StartTimer16(TD_GSM, Timeout);
    af4e:	0c 94 99 2a 	jmp	0x5532	; 0x5532 <StartTimer16>
	}
}
    af52:	0f 90       	pop	r0
    af54:	0f 90       	pop	r0
    af56:	df 91       	pop	r29
    af58:	cf 91       	pop	r28
    af5a:	08 95       	ret

0000af5c <GSM_AddHeaderSendData>:
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    af5c:	60 93 45 09 	sts	0x0945, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    af60:	40 91 45 09 	lds	r20, 0x0945
    af64:	50 e0       	ldi	r21, 0x00	; 0
    af66:	bc 01       	movw	r22, r24
    af68:	86 e2       	ldi	r24, 0x26	; 38
    af6a:	9c e0       	ldi	r25, 0x0C	; 12
    af6c:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
	GSM_SendFirstChar();
    af70:	0c 94 4e 57 	jmp	0xae9c	; 0xae9c <GSM_SendFirstChar>

0000af74 <GSM_SendData>:
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    af74:	60 93 45 09 	sts	0x0945, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    af78:	40 91 45 09 	lds	r20, 0x0945
    af7c:	50 e0       	ldi	r21, 0x00	; 0
    af7e:	bc 01       	movw	r22, r24
    af80:	86 e2       	ldi	r24, 0x26	; 38
    af82:	9c e0       	ldi	r25, 0x0C	; 12
    af84:	0e 94 31 6c 	call	0xd862	; 0xd862 <memcpy>
	GSM_SendFirstChar();
    af88:	0c 94 4e 57 	jmp	0xae9c	; 0xae9c <GSM_SendFirstChar>

0000af8c <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    af8c:	2f 92       	push	r2
    af8e:	3f 92       	push	r3
    af90:	4f 92       	push	r4
    af92:	5f 92       	push	r5
    af94:	6f 92       	push	r6
    af96:	7f 92       	push	r7
    af98:	8f 92       	push	r8
    af9a:	9f 92       	push	r9
    af9c:	af 92       	push	r10
    af9e:	bf 92       	push	r11
    afa0:	cf 92       	push	r12
    afa2:	df 92       	push	r13
    afa4:	ef 92       	push	r14
    afa6:	ff 92       	push	r15
    afa8:	0f 93       	push	r16
    afaa:	1f 93       	push	r17
    afac:	cf 93       	push	r28
    afae:	df 93       	push	r29
    afb0:	cd b7       	in	r28, 0x3d	; 61
    afb2:	de b7       	in	r29, 0x3e	; 62
    afb4:	2e 97       	sbiw	r28, 0x0e	; 14
    afb6:	0f b6       	in	r0, 0x3f	; 63
    afb8:	f8 94       	cli
    afba:	de bf       	out	0x3e, r29	; 62
    afbc:	0f be       	out	0x3f, r0	; 63
    afbe:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    afc0:	80 91 6a 09 	lds	r24, 0x096A
    afc4:	88 23       	and	r24, r24
    afc6:	31 f0       	breq	.+12     	; 0xafd4 <GSM_Cycle+0x48>
    afc8:	82 30       	cpi	r24, 0x02	; 2
    afca:	11 f4       	brne	.+4      	; 0xafd0 <GSM_Cycle+0x44>
    afcc:	0c 94 ea 63 	jmp	0xc7d4	; 0xc7d4 <GSM_Cycle+0x1848>
    afd0:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    afd4:	80 91 21 06 	lds	r24, 0x0621
    afd8:	90 e0       	ldi	r25, 0x00	; 0
    afda:	89 36       	cpi	r24, 0x69	; 105
    afdc:	91 05       	cpc	r25, r1
    afde:	10 f0       	brcs	.+4      	; 0xafe4 <GSM_Cycle+0x58>
    afe0:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    afe4:	fc 01       	movw	r30, r24
    afe6:	e0 53       	subi	r30, 0x30	; 48
    afe8:	ff 4f       	sbci	r31, 0xFF	; 255
    afea:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>

		case GSM_PowerOn:
		    Transparent_Application_state = INIT;
    afee:	10 92 40 09 	sts	0x0940, r1
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    aff2:	60 ed       	ldi	r22, 0xD0	; 208
    aff4:	77 e0       	ldi	r23, 0x07	; 7
    aff6:	80 91 54 02 	lds	r24, 0x0254
    affa:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    affe:	40 e0       	ldi	r20, 0x00	; 0
    b000:	56 ed       	ldi	r21, 0xD6	; 214
    b002:	63 e8       	ldi	r22, 0x83	; 131
    b004:	70 e0       	ldi	r23, 0x00	; 0
    b006:	80 91 51 02 	lds	r24, 0x0251
    b00a:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <StartTimer32>
			GSM_PWRCNTRL_ON();
    b00e:	0e 94 9f 2e 	call	0x5d3e	; 0x5d3e <GSM_PWRCNTRL_ON>
			InitFIFO();
    b012:	0e 94 cc 39 	call	0x7398	; 0x7398 <InitFIFO>
			GSM_Modem = NOT_RECOGNIZED;
    b016:	10 92 6b 08 	sts	0x086B, r1
			GSM_State = GSM_WAIT_RDY;
    b01a:	81 e0       	ldi	r24, 0x01	; 1
    b01c:	80 93 21 06 	sts	0x0621, r24
    b020:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    b024:	68 e5       	ldi	r22, 0x58	; 88
    b026:	8c e6       	ldi	r24, 0x6C	; 108
    b028:	9f e4       	ldi	r25, 0x4F	; 79
    b02a:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b02e:	88 23       	and	r24, r24
    b030:	11 f4       	brne	.+4      	; 0xb036 <GSM_Cycle+0xaa>
    b032:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b036:	80 91 21 06 	lds	r24, 0x0621
    b03a:	8f 5f       	subi	r24, 0xFF	; 255
    b03c:	80 93 21 06 	sts	0x0621, r24
    b040:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    b044:	68 e8       	ldi	r22, 0x88	; 136
    b046:	73 e1       	ldi	r23, 0x13	; 19
    b048:	8b e6       	ldi	r24, 0x6B	; 107
    b04a:	9e e4       	ldi	r25, 0x4E	; 78
    b04c:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b050:	80 91 21 06 	lds	r24, 0x0621
    b054:	8f 5f       	subi	r24, 0xFF	; 255
    b056:	80 93 21 06 	sts	0x0621, r24
    b05a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b05e:	80 91 54 02 	lds	r24, 0x0254
    b062:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    b066:	88 23       	and	r24, r24
    b068:	19 f0       	breq	.+6      	; 0xb070 <GSM_Cycle+0xe4>
    b06a:	88 e5       	ldi	r24, 0x58	; 88
    b06c:	80 93 21 06 	sts	0x0621, r24
			if(GetStringFromFIFO()){
    b070:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    b074:	88 23       	and	r24, r24
    b076:	e9 f0       	breq	.+58     	; 0xb0b2 <GSM_Cycle+0x126>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    b078:	6e e7       	ldi	r22, 0x7E	; 126
    b07a:	7f e4       	ldi	r23, 0x4F	; 79
    b07c:	86 e7       	ldi	r24, 0x76	; 118
    b07e:	99 e0       	ldi	r25, 0x09	; 9
    b080:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    b084:	89 2b       	or	r24, r25
    b086:	19 f4       	brne	.+6      	; 0xb08e <GSM_Cycle+0x102>
    b088:	81 e0       	ldi	r24, 0x01	; 1
    b08a:	80 93 6b 08 	sts	0x086B, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    b08e:	60 e7       	ldi	r22, 0x70	; 112
    b090:	7f e4       	ldi	r23, 0x4F	; 79
    b092:	86 e7       	ldi	r24, 0x76	; 118
    b094:	99 e0       	ldi	r25, 0x09	; 9
    b096:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    b09a:	89 2b       	or	r24, r25
    b09c:	19 f4       	brne	.+6      	; 0xb0a4 <GSM_Cycle+0x118>
    b09e:	82 e0       	ldi	r24, 0x02	; 2
    b0a0:	80 93 6b 08 	sts	0x086B, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    b0a4:	80 91 6b 08 	lds	r24, 0x086B
    b0a8:	88 23       	and	r24, r24
    b0aa:	19 f0       	breq	.+6      	; 0xb0b2 <GSM_Cycle+0x126>
    b0ac:	86 e0       	ldi	r24, 0x06	; 6
    b0ae:	80 93 21 06 	sts	0x0621, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    b0b2:	68 e5       	ldi	r22, 0x58	; 88
    b0b4:	81 e6       	ldi	r24, 0x61	; 97
    b0b6:	9f e4       	ldi	r25, 0x4F	; 79
    b0b8:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b0bc:	88 23       	and	r24, r24
    b0be:	11 f4       	brne	.+4      	; 0xb0c4 <GSM_Cycle+0x138>
    b0c0:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    b0c4:	80 91 6b 08 	lds	r24, 0x086B
    b0c8:	82 30       	cpi	r24, 0x02	; 2
    b0ca:	29 f4       	brne	.+10     	; 0xb0d6 <GSM_Cycle+0x14a>
    b0cc:	87 e0       	ldi	r24, 0x07	; 7
    b0ce:	80 93 21 06 	sts	0x0621, r24
    b0d2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				else GSM_State = GSM_SEND_E0;
    b0d6:	88 e0       	ldi	r24, 0x08	; 8
    b0d8:	80 93 21 06 	sts	0x0621, r24
    b0dc:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    b0e0:	68 e5       	ldi	r22, 0x58	; 88
    b0e2:	87 e5       	ldi	r24, 0x57	; 87
    b0e4:	9f e4       	ldi	r25, 0x4F	; 79
    b0e6:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b0ea:	88 23       	and	r24, r24
    b0ec:	11 f4       	brne	.+4      	; 0xb0f2 <GSM_Cycle+0x166>
    b0ee:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b0f2:	80 91 21 06 	lds	r24, 0x0621
    b0f6:	8f 5f       	subi	r24, 0xFF	; 255
    b0f8:	80 93 21 06 	sts	0x0621, r24
    b0fc:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    b100:	64 e6       	ldi	r22, 0x64	; 100
    b102:	70 e0       	ldi	r23, 0x00	; 0
    b104:	83 e7       	ldi	r24, 0x73	; 115
    b106:	9e e4       	ldi	r25, 0x4E	; 78
    b108:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b10c:	80 91 21 06 	lds	r24, 0x0621
    b110:	8f 5f       	subi	r24, 0xFF	; 255
    b112:	80 93 21 06 	sts	0x0621, r24
    b116:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b11a:	68 e5       	ldi	r22, 0x58	; 88
    b11c:	84 e1       	ldi	r24, 0x14	; 20
    b11e:	9f e4       	ldi	r25, 0x4F	; 79
    b120:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b124:	88 23       	and	r24, r24
    b126:	11 f4       	brne	.+4      	; 0xb12c <GSM_Cycle+0x1a0>
    b128:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b12c:	80 91 21 06 	lds	r24, 0x0621
    b130:	8f 5f       	subi	r24, 0xFF	; 255
    b132:	80 93 21 06 	sts	0x0621, r24
    b136:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    b13a:	64 e6       	ldi	r22, 0x64	; 100
    b13c:	70 e0       	ldi	r23, 0x00	; 0
    b13e:	81 e6       	ldi	r24, 0x61	; 97
    b140:	9e e4       	ldi	r25, 0x4E	; 78
    b142:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b146:	80 91 21 06 	lds	r24, 0x0621
    b14a:	8f 5f       	subi	r24, 0xFF	; 255
    b14c:	80 93 21 06 	sts	0x0621, r24
    b150:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b154:	68 e5       	ldi	r22, 0x58	; 88
    b156:	84 e1       	ldi	r24, 0x14	; 20
    b158:	9f e4       	ldi	r25, 0x4F	; 79
    b15a:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b15e:	88 23       	and	r24, r24
    b160:	11 f4       	brne	.+4      	; 0xb166 <GSM_Cycle+0x1da>
    b162:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b166:	80 91 21 06 	lds	r24, 0x0621
    b16a:	8f 5f       	subi	r24, 0xFF	; 255
    b16c:	80 93 21 06 	sts	0x0621, r24
    b170:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_CCID:
			GSM_RxStr[19] = 0;
    b174:	10 92 89 09 	sts	0x0989, r1
			GSM_Execute_Command(AT_CCID,300*GSM_DEBUG_DELAY); GSM_State++;
    b178:	6c e2       	ldi	r22, 0x2C	; 44
    b17a:	71 e0       	ldi	r23, 0x01	; 1
    b17c:	89 e5       	ldi	r24, 0x59	; 89
    b17e:	9e e4       	ldi	r25, 0x4E	; 78
    b180:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b184:	80 91 21 06 	lds	r24, 0x0621
    b188:	8f 5f       	subi	r24, 0xFF	; 255
    b18a:	80 93 21 06 	sts	0x0621, r24
    b18e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CCID_READ:
			//8938001300106446004F
			if(GetStringFromFIFO() && ((GSM_RxStr[19] == 'F')||(GSM_RxStr[19] == 'f')) ){
    b192:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    b196:	88 23       	and	r24, r24
    b198:	11 f4       	brne	.+4      	; 0xb19e <GSM_Cycle+0x212>
    b19a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b19e:	80 91 89 09 	lds	r24, 0x0989
    b1a2:	8f 7d       	andi	r24, 0xDF	; 223
    b1a4:	86 34       	cpi	r24, 0x46	; 70
    b1a6:	11 f0       	breq	.+4      	; 0xb1ac <GSM_Cycle+0x220>
    b1a8:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>



				GSM_RxStr[18] = ' ';
    b1ac:	10 e2       	ldi	r17, 0x20	; 32
    b1ae:	10 93 88 09 	sts	0x0988, r17
				sscanf_P(GSM_RxStr+9,PSTR("%lud"), (long unsigned int*)&ICCID2);
    b1b2:	8c e0       	ldi	r24, 0x0C	; 12
    b1b4:	96 e0       	ldi	r25, 0x06	; 6
    b1b6:	9f 93       	push	r25
    b1b8:	8f 93       	push	r24
    b1ba:	8d e7       	ldi	r24, 0x7D	; 125
    b1bc:	93 e0       	ldi	r25, 0x03	; 3
    b1be:	9f 93       	push	r25
    b1c0:	8f 93       	push	r24
    b1c2:	8f e7       	ldi	r24, 0x7F	; 127
    b1c4:	99 e0       	ldi	r25, 0x09	; 9
    b1c6:	9f 93       	push	r25
    b1c8:	8f 93       	push	r24
    b1ca:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				GSM_RxStr[9] = ' ';
    b1ce:	10 93 7f 09 	sts	0x097F, r17
				sscanf_P(GSM_RxStr+5,PSTR("%u"), (unsigned int*)&ICCID1);
    b1d2:	84 e1       	ldi	r24, 0x14	; 20
    b1d4:	9b e0       	ldi	r25, 0x0B	; 11
    b1d6:	9f 93       	push	r25
    b1d8:	8f 93       	push	r24
    b1da:	8a e7       	ldi	r24, 0x7A	; 122
    b1dc:	93 e0       	ldi	r25, 0x03	; 3
    b1de:	9f 93       	push	r25
    b1e0:	8f 93       	push	r24
    b1e2:	8b e7       	ldi	r24, 0x7B	; 123
    b1e4:	99 e0       	ldi	r25, 0x09	; 9
    b1e6:	9f 93       	push	r25
    b1e8:	8f 93       	push	r24
    b1ea:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				if((ICCID1 == 0) || (ICCID2==0)) GSM_State = GSM_ReStart1;
    b1ee:	40 91 14 0b 	lds	r20, 0x0B14
    b1f2:	50 91 15 0b 	lds	r21, 0x0B15
    b1f6:	0f b6       	in	r0, 0x3f	; 63
    b1f8:	f8 94       	cli
    b1fa:	de bf       	out	0x3e, r29	; 62
    b1fc:	0f be       	out	0x3f, r0	; 63
    b1fe:	cd bf       	out	0x3d, r28	; 61
    b200:	41 15       	cp	r20, r1
    b202:	51 05       	cpc	r21, r1
    b204:	69 f0       	breq	.+26     	; 0xb220 <GSM_Cycle+0x294>
    b206:	40 90 0c 06 	lds	r4, 0x060C
    b20a:	50 90 0d 06 	lds	r5, 0x060D
    b20e:	60 90 0e 06 	lds	r6, 0x060E
    b212:	70 90 0f 06 	lds	r7, 0x060F
    b216:	41 14       	cp	r4, r1
    b218:	51 04       	cpc	r5, r1
    b21a:	61 04       	cpc	r6, r1
    b21c:	71 04       	cpc	r7, r1
    b21e:	29 f4       	brne	.+10     	; 0xb22a <GSM_Cycle+0x29e>
    b220:	88 e5       	ldi	r24, 0x58	; 88
    b222:	80 93 21 06 	sts	0x0621, r24
    b226:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				else{
					ICCID = (uint64_t)ICCID1 * 1000000000UL + (uint64_t)ICCID2;
    b22a:	a1 2c       	mov	r10, r1
    b22c:	6a ec       	ldi	r22, 0xCA	; 202
    b22e:	b6 2e       	mov	r11, r22
    b230:	7a e9       	ldi	r23, 0x9A	; 154
    b232:	c7 2e       	mov	r12, r23
    b234:	eb e3       	ldi	r30, 0x3B	; 59
    b236:	de 2e       	mov	r13, r30
    b238:	e1 2c       	mov	r14, r1
    b23a:	f1 2c       	mov	r15, r1
    b23c:	00 e0       	ldi	r16, 0x00	; 0
    b23e:	10 e0       	ldi	r17, 0x00	; 0
    b240:	9a 01       	movw	r18, r20
    b242:	40 e0       	ldi	r20, 0x00	; 0
    b244:	50 e0       	ldi	r21, 0x00	; 0
    b246:	60 e0       	ldi	r22, 0x00	; 0
    b248:	70 e0       	ldi	r23, 0x00	; 0
    b24a:	80 e0       	ldi	r24, 0x00	; 0
    b24c:	90 e0       	ldi	r25, 0x00	; 0
    b24e:	0e 94 3c 75 	call	0xea78	; 0xea78 <__muldi3>
    b252:	12 01       	movw	r2, r4
    b254:	23 01       	movw	r4, r6
    b256:	51 01       	movw	r10, r2
    b258:	62 01       	movw	r12, r4
    b25a:	0e 94 95 75 	call	0xeb2a	; 0xeb2a <__adddi3>
    b25e:	20 93 60 09 	sts	0x0960, r18
    b262:	30 93 61 09 	sts	0x0961, r19
    b266:	40 93 62 09 	sts	0x0962, r20
    b26a:	50 93 63 09 	sts	0x0963, r21
    b26e:	60 93 64 09 	sts	0x0964, r22
    b272:	70 93 65 09 	sts	0x0965, r23
    b276:	80 93 66 09 	sts	0x0966, r24
    b27a:	90 93 67 09 	sts	0x0967, r25
					GSM_State++;
    b27e:	80 91 21 06 	lds	r24, 0x0621
    b282:	8f 5f       	subi	r24, 0xFF	; 255
    b284:	80 93 21 06 	sts	0x0621, r24
    b288:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				}
			}
			break;
		case GSM_WAIT_CCID_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b28c:	68 e5       	ldi	r22, 0x58	; 88
    b28e:	84 e1       	ldi	r24, 0x14	; 20
    b290:	9f e4       	ldi	r25, 0x4F	; 79
    b292:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b296:	88 23       	and	r24, r24
    b298:	11 f4       	brne	.+4      	; 0xb29e <GSM_Cycle+0x312>
    b29a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b29e:	80 91 21 06 	lds	r24, 0x0621
    b2a2:	8f 5f       	subi	r24, 0xFF	; 255
    b2a4:	80 93 21 06 	sts	0x0621, r24
    b2a8:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    b2ac:	64 e6       	ldi	r22, 0x64	; 100
    b2ae:	70 e0       	ldi	r23, 0x00	; 0
    b2b0:	8f e4       	ldi	r24, 0x4F	; 79
    b2b2:	9e e4       	ldi	r25, 0x4E	; 78
    b2b4:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b2b8:	80 91 21 06 	lds	r24, 0x0621
    b2bc:	8f 5f       	subi	r24, 0xFF	; 255
    b2be:	80 93 21 06 	sts	0x0621, r24
    b2c2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b2c6:	68 e5       	ldi	r22, 0x58	; 88
    b2c8:	84 e1       	ldi	r24, 0x14	; 20
    b2ca:	9f e4       	ldi	r25, 0x4F	; 79
    b2cc:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b2d0:	88 23       	and	r24, r24
    b2d2:	11 f4       	brne	.+4      	; 0xb2d8 <GSM_Cycle+0x34c>
    b2d4:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b2d8:	80 91 21 06 	lds	r24, 0x0621
    b2dc:	8f 5f       	subi	r24, 0xFF	; 255
    b2de:	80 93 21 06 	sts	0x0621, r24
    b2e2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    b2e6:	64 e6       	ldi	r22, 0x64	; 100
    b2e8:	70 e0       	ldi	r23, 0x00	; 0
    b2ea:	8c e3       	ldi	r24, 0x3C	; 60
    b2ec:	9e e4       	ldi	r25, 0x4E	; 78
    b2ee:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b2f2:	80 91 21 06 	lds	r24, 0x0621
    b2f6:	8f 5f       	subi	r24, 0xFF	; 255
    b2f8:	80 93 21 06 	sts	0x0621, r24
    b2fc:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b300:	68 e5       	ldi	r22, 0x58	; 88
    b302:	84 e1       	ldi	r24, 0x14	; 20
    b304:	9f e4       	ldi	r25, 0x4F	; 79
    b306:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b30a:	88 23       	and	r24, r24
    b30c:	11 f4       	brne	.+4      	; 0xb312 <GSM_Cycle+0x386>
    b30e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b312:	80 91 21 06 	lds	r24, 0x0621
    b316:	8f 5f       	subi	r24, 0xFF	; 255
    b318:	80 93 21 06 	sts	0x0621, r24
    b31c:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    b320:	64 e6       	ldi	r22, 0x64	; 100
    b322:	70 e0       	ldi	r23, 0x00	; 0
    b324:	88 e1       	ldi	r24, 0x18	; 24
    b326:	9e e4       	ldi	r25, 0x4E	; 78
    b328:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
			GSM_State++; 
    b32c:	80 91 21 06 	lds	r24, 0x0621
    b330:	8f 5f       	subi	r24, 0xFF	; 255
    b332:	80 93 21 06 	sts	0x0621, r24
    b336:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b33a:	68 e5       	ldi	r22, 0x58	; 88
    b33c:	84 e1       	ldi	r24, 0x14	; 20
    b33e:	9f e4       	ldi	r25, 0x4F	; 79
    b340:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b344:	88 23       	and	r24, r24
    b346:	11 f4       	brne	.+4      	; 0xb34c <GSM_Cycle+0x3c0>
    b348:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;*/
				GSM_State++;
    b34c:	80 91 21 06 	lds	r24, 0x0621
    b350:	8f 5f       	subi	r24, 0xFF	; 255
    b352:	80 93 21 06 	sts	0x0621, r24
    b356:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_SEND_CIPMODE:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    b35a:	64 e6       	ldi	r22, 0x64	; 100
    b35c:	70 e0       	ldi	r23, 0x00	; 0
    b35e:	84 e2       	ldi	r24, 0x24	; 36
    b360:	9e e4       	ldi	r25, 0x4E	; 78
    b362:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
			GSM_State++;
    b366:	80 91 21 06 	lds	r24, 0x0621
    b36a:	8f 5f       	subi	r24, 0xFF	; 255
    b36c:	80 93 21 06 	sts	0x0621, r24
    b370:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b374:	68 e5       	ldi	r22, 0x58	; 88
    b376:	84 e1       	ldi	r24, 0x14	; 20
    b378:	9f e4       	ldi	r25, 0x4F	; 79
    b37a:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b37e:	88 23       	and	r24, r24
    b380:	11 f4       	brne	.+4      	; 0xb386 <GSM_Cycle+0x3fa>
    b382:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				GSM_State++;
    b386:	80 91 21 06 	lds	r24, 0x0621
    b38a:	8f 5f       	subi	r24, 0xFF	; 255
    b38c:	80 93 21 06 	sts	0x0621, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    b390:	68 ee       	ldi	r22, 0xE8	; 232
    b392:	73 e0       	ldi	r23, 0x03	; 3
    b394:	80 91 54 02 	lds	r24, 0x0254
    b398:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    b39c:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    b3a0:	10 92 e0 03 	sts	0x03E0, r1
			GSM_State++;
    b3a4:	80 91 21 06 	lds	r24, 0x0621
    b3a8:	8f 5f       	subi	r24, 0xFF	; 255
    b3aa:	80 93 21 06 	sts	0x0621, r24
    b3ae:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    b3b2:	64 ef       	ldi	r22, 0xF4	; 244
    b3b4:	71 e0       	ldi	r23, 0x01	; 1
    b3b6:	8d e0       	ldi	r24, 0x0D	; 13
    b3b8:	9e e4       	ldi	r25, 0x4E	; 78
    b3ba:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b3be:	80 91 e0 03 	lds	r24, 0x03E0
    b3c2:	8f 5f       	subi	r24, 0xFF	; 255
    b3c4:	80 93 e0 03 	sts	0x03E0, r24
    b3c8:	80 91 21 06 	lds	r24, 0x0621
    b3cc:	8f 5f       	subi	r24, 0xFF	; 255
    b3ce:	80 93 21 06 	sts	0x0621, r24
    b3d2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    b3d6:	80 91 e0 03 	lds	r24, 0x03E0
    b3da:	85 31       	cpi	r24, 0x15	; 21
    b3dc:	18 f0       	brcs	.+6      	; 0xb3e4 <GSM_Cycle+0x458>
    b3de:	88 e5       	ldi	r24, 0x58	; 88
    b3e0:	80 93 21 06 	sts	0x0621, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    b3e4:	68 e1       	ldi	r22, 0x18	; 24
    b3e6:	84 e1       	ldi	r24, 0x14	; 20
    b3e8:	9f e4       	ldi	r25, 0x4F	; 79
    b3ea:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b3ee:	88 23       	and	r24, r24
    b3f0:	11 f4       	brne	.+4      	; 0xb3f6 <GSM_Cycle+0x46a>
    b3f2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b3f6:	80 91 21 06 	lds	r24, 0x0621
    b3fa:	8f 5f       	subi	r24, 0xFF	; 255
    b3fc:	80 93 21 06 	sts	0x0621, r24
    b400:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    b404:	80 91 08 01 	lds	r24, 0x0108
    b408:	80 ff       	sbrs	r24, 0
    b40a:	6d c0       	rjmp	.+218    	; 0xb4e6 <GSM_Cycle+0x55a>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    b40c:	8e ef       	ldi	r24, 0xFE	; 254
    b40e:	9d e4       	ldi	r25, 0x4D	; 77
    b410:	9f 93       	push	r25
    b412:	8f 93       	push	r24
    b414:	86 e2       	ldi	r24, 0x26	; 38
    b416:	9c e0       	ldi	r25, 0x0C	; 12
    b418:	9f 93       	push	r25
    b41a:	8f 93       	push	r24
    b41c:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
    b420:	8e e0       	ldi	r24, 0x0E	; 14
    b422:	80 93 45 09 	sts	0x0945, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    b426:	10 91 45 09 	lds	r17, 0x0945
    b42a:	80 91 45 09 	lds	r24, 0x0945
    b42e:	90 e0       	ldi	r25, 0x00	; 0
    b430:	6a e7       	ldi	r22, 0x7A	; 122
    b432:	71 e0       	ldi	r23, 0x01	; 1
    b434:	8a 5d       	subi	r24, 0xDA	; 218
    b436:	93 4f       	sbci	r25, 0xF3	; 243
    b438:	0e 94 8f 3a 	call	0x751e	; 0x751e <strcpy_EE>
    b43c:	81 0f       	add	r24, r17
    b43e:	80 93 45 09 	sts	0x0945, r24
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    b442:	80 91 45 09 	lds	r24, 0x0945
    b446:	90 e0       	ldi	r25, 0x00	; 0
    b448:	66 eb       	ldi	r22, 0xB6	; 182
    b44a:	71 e0       	ldi	r23, 0x01	; 1
    b44c:	8a 5d       	subi	r24, 0xDA	; 218
    b44e:	93 4f       	sbci	r25, 0xF3	; 243
    b450:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
    b454:	80 91 45 09 	lds	r24, 0x0945
    b458:	8d 5f       	subi	r24, 0xFD	; 253
    b45a:	80 93 45 09 	sts	0x0945, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    b45e:	10 91 45 09 	lds	r17, 0x0945
    b462:	80 91 45 09 	lds	r24, 0x0945
    b466:	90 e0       	ldi	r25, 0x00	; 0
    b468:	66 e6       	ldi	r22, 0x66	; 102
    b46a:	71 e0       	ldi	r23, 0x01	; 1
    b46c:	8a 5d       	subi	r24, 0xDA	; 218
    b46e:	93 4f       	sbci	r25, 0xF3	; 243
    b470:	0e 94 8f 3a 	call	0x751e	; 0x751e <strcpy_EE>
    b474:	81 0f       	add	r24, r17
    b476:	80 93 45 09 	sts	0x0945, r24
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    b47a:	80 91 45 09 	lds	r24, 0x0945
    b47e:	90 e0       	ldi	r25, 0x00	; 0
    b480:	66 eb       	ldi	r22, 0xB6	; 182
    b482:	71 e0       	ldi	r23, 0x01	; 1
    b484:	8a 5d       	subi	r24, 0xDA	; 218
    b486:	93 4f       	sbci	r25, 0xF3	; 243
    b488:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
    b48c:	80 91 45 09 	lds	r24, 0x0945
    b490:	8d 5f       	subi	r24, 0xFD	; 253
    b492:	80 93 45 09 	sts	0x0945, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    b496:	10 91 45 09 	lds	r17, 0x0945
    b49a:	80 91 45 09 	lds	r24, 0x0945
    b49e:	90 e0       	ldi	r25, 0x00	; 0
    b4a0:	62 e5       	ldi	r22, 0x52	; 82
    b4a2:	71 e0       	ldi	r23, 0x01	; 1
    b4a4:	8a 5d       	subi	r24, 0xDA	; 218
    b4a6:	93 4f       	sbci	r25, 0xF3	; 243
    b4a8:	0e 94 8f 3a 	call	0x751e	; 0x751e <strcpy_EE>
    b4ac:	81 0f       	add	r24, r17
    b4ae:	80 93 45 09 	sts	0x0945, r24
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    b4b2:	80 91 45 09 	lds	r24, 0x0945
    b4b6:	90 e0       	ldi	r25, 0x00	; 0
    b4b8:	6b ec       	ldi	r22, 0xCB	; 203
    b4ba:	71 e0       	ldi	r23, 0x01	; 1
    b4bc:	8a 5d       	subi	r24, 0xDA	; 218
    b4be:	93 4f       	sbci	r25, 0xF3	; 243
    b4c0:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
    b4c4:	80 91 45 09 	lds	r24, 0x0945
    b4c8:	8e 5f       	subi	r24, 0xFE	; 254
    b4ca:	80 93 45 09 	sts	0x0945, r24
				GSM_SendFirstChar();
    b4ce:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    b4d2:	6c e2       	ldi	r22, 0x2C	; 44
    b4d4:	71 e0       	ldi	r23, 0x01	; 1
    b4d6:	80 91 54 02 	lds	r24, 0x0254
    b4da:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    b4de:	0f 90       	pop	r0
    b4e0:	0f 90       	pop	r0
    b4e2:	0f 90       	pop	r0
    b4e4:	0f 90       	pop	r0
			}
			GSM_State++;
    b4e6:	80 91 21 06 	lds	r24, 0x0621
    b4ea:	8f 5f       	subi	r24, 0xFF	; 255
    b4ec:	80 93 21 06 	sts	0x0621, r24
    b4f0:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b4f4:	68 e5       	ldi	r22, 0x58	; 88
    b4f6:	84 e1       	ldi	r24, 0x14	; 20
    b4f8:	9f e4       	ldi	r25, 0x4F	; 79
    b4fa:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b4fe:	88 23       	and	r24, r24
    b500:	11 f4       	brne	.+4      	; 0xb506 <GSM_Cycle+0x57a>
    b502:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b506:	80 91 21 06 	lds	r24, 0x0621
    b50a:	8f 5f       	subi	r24, 0xFF	; 255
    b50c:	80 93 21 06 	sts	0x0621, r24
    b510:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    b514:	6c e2       	ldi	r22, 0x2C	; 44
    b516:	71 e0       	ldi	r23, 0x01	; 1
    b518:	86 ef       	ldi	r24, 0xF6	; 246
    b51a:	9d e4       	ldi	r25, 0x4D	; 77
    b51c:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b520:	80 91 21 06 	lds	r24, 0x0621
    b524:	8f 5f       	subi	r24, 0xFF	; 255
    b526:	80 93 21 06 	sts	0x0621, r24
    b52a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b52e:	68 e5       	ldi	r22, 0x58	; 88
    b530:	84 e1       	ldi	r24, 0x14	; 20
    b532:	9f e4       	ldi	r25, 0x4F	; 79
    b534:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b538:	88 23       	and	r24, r24
    b53a:	11 f4       	brne	.+4      	; 0xb540 <GSM_Cycle+0x5b4>
    b53c:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b540:	80 91 21 06 	lds	r24, 0x0621
    b544:	8f 5f       	subi	r24, 0xFF	; 255
    b546:	80 93 21 06 	sts	0x0621, r24
    b54a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    b54e:	60 ee       	ldi	r22, 0xE0	; 224
    b550:	7e e2       	ldi	r23, 0x2E	; 46
    b552:	8d ee       	ldi	r24, 0xED	; 237
    b554:	9d e4       	ldi	r25, 0x4D	; 77
    b556:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b55a:	80 91 21 06 	lds	r24, 0x0621
    b55e:	8f 5f       	subi	r24, 0xFF	; 255
    b560:	80 93 21 06 	sts	0x0621, r24
    b564:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b568:	68 e5       	ldi	r22, 0x58	; 88
    b56a:	84 e1       	ldi	r24, 0x14	; 20
    b56c:	9f e4       	ldi	r25, 0x4F	; 79
    b56e:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b572:	88 23       	and	r24, r24
    b574:	11 f4       	brne	.+4      	; 0xb57a <GSM_Cycle+0x5ee>
    b576:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b57a:	80 91 21 06 	lds	r24, 0x0621
    b57e:	8f 5f       	subi	r24, 0xFF	; 255
    b580:	80 93 21 06 	sts	0x0621, r24
    b584:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    b588:	68 ee       	ldi	r22, 0xE8	; 232
    b58a:	73 e0       	ldi	r23, 0x03	; 3
    b58c:	84 ee       	ldi	r24, 0xE4	; 228
    b58e:	9d e4       	ldi	r25, 0x4D	; 77
    b590:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b594:	80 91 21 06 	lds	r24, 0x0621
    b598:	8f 5f       	subi	r24, 0xFF	; 255
    b59a:	80 93 21 06 	sts	0x0621, r24
    b59e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b5a2:	80 91 54 02 	lds	r24, 0x0254
    b5a6:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    b5aa:	88 23       	and	r24, r24
    b5ac:	19 f0       	breq	.+6      	; 0xb5b4 <GSM_Cycle+0x628>
    b5ae:	88 e5       	ldi	r24, 0x58	; 88
    b5b0:	80 93 21 06 	sts	0x0621, r24
			if(GetStringFromFIFO()){
    b5b4:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    b5b8:	88 23       	and	r24, r24
    b5ba:	11 f4       	brne	.+4      	; 0xb5c0 <GSM_Cycle+0x634>
    b5bc:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    b5c0:	10 92 09 0b 	sts	0x0B09, r1
	IP->IP2 = IP2;
    b5c4:	10 92 0a 0b 	sts	0x0B0A, r1
	IP->IP3 = IP3;
    b5c8:	10 92 0b 0b 	sts	0x0B0B, r1
	IP->IP4 = IP4;
    b5cc:	10 92 0c 0b 	sts	0x0B0C, r1
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b5d0:	40 e0       	ldi	r20, 0x00	; 0
    b5d2:	a6 e7       	ldi	r26, 0x76	; 118
    b5d4:	b9 e0       	ldi	r27, 0x09	; 9
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b5d6:	50 e2       	ldi	r21, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b5d8:	86 e7       	ldi	r24, 0x76	; 118
    b5da:	99 e0       	ldi	r25, 0x09	; 9
    b5dc:	fd 01       	movw	r30, r26
    b5de:	01 90       	ld	r0, Z+
    b5e0:	00 20       	and	r0, r0
    b5e2:	e9 f7       	brne	.-6      	; 0xb5de <GSM_Cycle+0x652>
    b5e4:	31 97       	sbiw	r30, 0x01	; 1
    b5e6:	e6 57       	subi	r30, 0x76	; 118
    b5e8:	f9 40       	sbci	r31, 0x09	; 9
    b5ea:	24 2f       	mov	r18, r20
    b5ec:	30 e0       	ldi	r19, 0x00	; 0
    b5ee:	2e 17       	cp	r18, r30
    b5f0:	3f 07       	cpc	r19, r31
    b5f2:	58 f4       	brcc	.+22     	; 0xb60a <GSM_Cycle+0x67e>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b5f4:	f9 01       	movw	r30, r18
    b5f6:	ea 58       	subi	r30, 0x8A	; 138
    b5f8:	f6 4f       	sbci	r31, 0xF6	; 246
    b5fa:	80 81       	ld	r24, Z
    b5fc:	90 e0       	ldi	r25, 0x00	; 0
    b5fe:	c0 97       	sbiw	r24, 0x30	; 48
    b600:	0a 97       	sbiw	r24, 0x0a	; 10
    b602:	08 f0       	brcs	.+2      	; 0xb606 <GSM_Cycle+0x67a>
    b604:	50 83       	st	Z, r21
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b606:	4f 5f       	subi	r20, 0xFF	; 255
    b608:	e7 cf       	rjmp	.-50     	; 0xb5d8 <GSM_Cycle+0x64c>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    b60a:	2c e0       	ldi	r18, 0x0C	; 12
    b60c:	3b e0       	ldi	r19, 0x0B	; 11
    b60e:	3f 93       	push	r19
    b610:	2f 93       	push	r18
    b612:	2b e0       	ldi	r18, 0x0B	; 11
    b614:	3b e0       	ldi	r19, 0x0B	; 11
    b616:	3f 93       	push	r19
    b618:	2f 93       	push	r18
    b61a:	2a e0       	ldi	r18, 0x0A	; 10
    b61c:	3b e0       	ldi	r19, 0x0B	; 11
    b61e:	3f 93       	push	r19
    b620:	2f 93       	push	r18
    b622:	29 e0       	ldi	r18, 0x09	; 9
    b624:	3b e0       	ldi	r19, 0x0B	; 11
    b626:	3f 93       	push	r19
    b628:	2f 93       	push	r18
    b62a:	26 e6       	ldi	r18, 0x66	; 102
    b62c:	33 e0       	ldi	r19, 0x03	; 3
    b62e:	3f 93       	push	r19
    b630:	2f 93       	push	r18
    b632:	9f 93       	push	r25
    b634:	8f 93       	push	r24
    b636:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
    b63a:	00 e0       	ldi	r16, 0x00	; 0
    b63c:	20 e0       	ldi	r18, 0x00	; 0
    b63e:	40 e0       	ldi	r20, 0x00	; 0
    b640:	60 e0       	ldi	r22, 0x00	; 0
    b642:	89 e0       	ldi	r24, 0x09	; 9
    b644:	9b e0       	ldi	r25, 0x0B	; 11
    b646:	0e 94 8b 39 	call	0x7316	; 0x7316 <IP_compare_Const>
    b64a:	0f b6       	in	r0, 0x3f	; 63
    b64c:	f8 94       	cli
    b64e:	de bf       	out	0x3e, r29	; 62
    b650:	0f be       	out	0x3f, r0	; 63
    b652:	cd bf       	out	0x3d, r28	; 61
    b654:	81 11       	cpse	r24, r1
    b656:	03 c0       	rjmp	.+6      	; 0xb65e <GSM_Cycle+0x6d2>
				/*	if(GSM_MultiCon) GSM_State++;
					else GSM_State = GSM_SEND_CIPSERVER;*/
					GSM_State=GSM_SEND_CIPSTART_TCP;
    b658:	82 e2       	ldi	r24, 0x22	; 34
    b65a:	80 93 21 06 	sts	0x0621, r24
				}
				TempNum=0;	//
    b65e:	10 92 e1 03 	sts	0x03E1, r1
    b662:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    b666:	80 91 08 01 	lds	r24, 0x0108
    b66a:	80 fd       	sbrc	r24, 0
    b66c:	02 c0       	rjmp	.+4      	; 0xb672 <GSM_Cycle+0x6e6>
    b66e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				GSMTxSz = strlen_P(AT_CIPSTART_TCP);
    b672:	82 e1       	ldi	r24, 0x12	; 18
    b674:	80 93 45 09 	sts	0x0945, r24
				sprintf_P(GSM_TxStr, AT_CIPSTART_TCP);
    b678:	8c eb       	ldi	r24, 0xBC	; 188
    b67a:	9d e4       	ldi	r25, 0x4D	; 77
    b67c:	9f 93       	push	r25
    b67e:	8f 93       	push	r24
    b680:	06 e2       	ldi	r16, 0x26	; 38
    b682:	1c e0       	ldi	r17, 0x0C	; 12
    b684:	1f 93       	push	r17
    b686:	0f 93       	push	r16
    b688:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
    b68c:	82 e2       	ldi	r24, 0x22	; 34
    b68e:	91 e0       	ldi	r25, 0x01	; 1
    b690:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    b694:	68 2e       	mov	r6, r24
    b696:	59 2e       	mov	r5, r25
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b698:	85 e3       	ldi	r24, 0x35	; 53
    b69a:	91 e0       	ldi	r25, 0x01	; 1
    b69c:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b6a0:	78 2e       	mov	r7, r24
    b6a2:	84 e3       	ldi	r24, 0x34	; 52
    b6a4:	91 e0       	ldi	r25, 0x01	; 1
    b6a6:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b6aa:	88 2e       	mov	r8, r24
    b6ac:	83 e3       	ldi	r24, 0x33	; 51
    b6ae:	91 e0       	ldi	r25, 0x01	; 1
    b6b0:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b6b4:	98 2e       	mov	r9, r24
    b6b6:	82 e3       	ldi	r24, 0x32	; 50
    b6b8:	91 e0       	ldi	r25, 0x01	; 1
    b6ba:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
				
				sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2),
    b6be:	90 91 45 09 	lds	r25, 0x0945
    b6c2:	5f 92       	push	r5
    b6c4:	6f 92       	push	r6
    b6c6:	1f 92       	push	r1
    b6c8:	7f 92       	push	r7
    b6ca:	1f 92       	push	r1
    b6cc:	8f 92       	push	r8
    b6ce:	1f 92       	push	r1
    b6d0:	9f 92       	push	r9
    b6d2:	1f 92       	push	r1
    b6d4:	8f 93       	push	r24
    b6d6:	2a eb       	ldi	r18, 0xBA	; 186
    b6d8:	31 e0       	ldi	r19, 0x01	; 1
    b6da:	3f 93       	push	r19
    b6dc:	2f 93       	push	r18
    b6de:	89 2f       	mov	r24, r25
    b6e0:	90 e0       	ldi	r25, 0x00	; 0
    b6e2:	8a 5d       	subi	r24, 0xDA	; 218
    b6e4:	93 4f       	sbci	r25, 0xF3	; 243
    b6e6:	9f 93       	push	r25
    b6e8:	8f 93       	push	r24
    b6ea:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
				(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
				GSMTxSz = strlen(GSM_TxStr);
    b6ee:	f8 01       	movw	r30, r16
    b6f0:	01 90       	ld	r0, Z+
    b6f2:	00 20       	and	r0, r0
    b6f4:	e9 f7       	brne	.-6      	; 0xb6f0 <GSM_Cycle+0x764>
    b6f6:	31 97       	sbiw	r30, 0x01	; 1
    b6f8:	e6 52       	subi	r30, 0x26	; 38
    b6fa:	fc 40       	sbci	r31, 0x0C	; 12
    b6fc:	e0 93 45 09 	sts	0x0945, r30
				GSM_SendFirstChar();
    b700:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    b704:	68 ee       	ldi	r22, 0xE8	; 232
    b706:	73 e0       	ldi	r23, 0x03	; 3
    b708:	80 91 54 02 	lds	r24, 0x0254
    b70c:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State=GSM_WAIT_CIPSTART_TCP_OK;
    b710:	83 e2       	ldi	r24, 0x23	; 35
    b712:	80 93 21 06 	sts	0x0621, r24
    b716:	0f b6       	in	r0, 0x3f	; 63
    b718:	f8 94       	cli
    b71a:	de bf       	out	0x3e, r29	; 62
    b71c:	0f be       	out	0x3f, r0	; 63
    b71e:	cd bf       	out	0x3d, r28	; 61
    b720:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}		
			break;
		case GSM_WAIT_CIPSTART_TCP_OK:
	
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_WAIT_CIPSTART_TCP_CONNECT;
    b724:	68 e5       	ldi	r22, 0x58	; 88
    b726:	84 e1       	ldi	r24, 0x14	; 20
    b728:	9f e4       	ldi	r25, 0x4F	; 79
    b72a:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b72e:	88 23       	and	r24, r24
    b730:	11 f4       	brne	.+4      	; 0xb736 <GSM_Cycle+0x7aa>
    b732:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b736:	84 e2       	ldi	r24, 0x24	; 36
    b738:	80 93 21 06 	sts	0x0621, r24
    b73c:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			if(GetStringFromFIFO()){
			SetDigOut(2);*/
			/*	char RightAnswer[sizeof(RESP_CONNECT)];
				strcpy_P(RightAnswer, RESP_CONNECT);*/
				//RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b740:	68 e5       	ldi	r22, 0x58	; 88
    b742:	8c e0       	ldi	r24, 0x0C	; 12
    b744:	9f e4       	ldi	r25, 0x4F	; 79
    b746:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b74a:	88 23       	and	r24, r24
    b74c:	11 f4       	brne	.+4      	; 0xb752 <GSM_Cycle+0x7c6>
    b74e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				/*	if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
					else GSM_State = GSM_SEND_CIPSTART;*/
					GSM_State = GSM_SEND_IDENTIFICATION;
    b752:	85 e2       	ldi	r24, 0x25	; 37
    b754:	80 93 21 06 	sts	0x0621, r24
    b758:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				}
		//	}
			break;
		case GSM_SEND_IDENTIFICATION:
			if(GSM_Flag & (1<<flg_TxCStr)){
    b75c:	80 91 08 01 	lds	r24, 0x0108
    b760:	80 fd       	sbrc	r24, 0
    b762:	02 c0       	rjmp	.+4      	; 0xb768 <GSM_Cycle+0x7dc>
    b764:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				GSMTxSz = strlen_P(MODEM_EQUAL);
    b768:	89 e0       	ldi	r24, 0x09	; 9
    b76a:	80 93 45 09 	sts	0x0945, r24
				sprintf_P(GSM_TxStr, MODEM_EQUAL);
    b76e:	8c e8       	ldi	r24, 0x8C	; 140
    b770:	9e e4       	ldi	r25, 0x4E	; 78
    b772:	9f 93       	push	r25
    b774:	8f 93       	push	r24
    b776:	86 e2       	ldi	r24, 0x26	; 38
    b778:	9c e0       	ldi	r25, 0x0C	; 12
    b77a:	9f 93       	push	r25
    b77c:	8f 93       	push	r24
    b77e:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
				GSM_SendFirstChar();
    b782:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b786:	64 ef       	ldi	r22, 0xF4	; 244
    b788:	71 e0       	ldi	r23, 0x01	; 1
    b78a:	80 91 54 02 	lds	r24, 0x0254
    b78e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State++;
    b792:	80 91 21 06 	lds	r24, 0x0621
    b796:	8f 5f       	subi	r24, 0xFF	; 255
    b798:	80 93 21 06 	sts	0x0621, r24
    b79c:	0f 90       	pop	r0
    b79e:	0f 90       	pop	r0
    b7a0:	0f 90       	pop	r0
    b7a2:	0f 90       	pop	r0
    b7a4:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_WAIT_IDENTIFICATION_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1))
    b7a8:	68 e5       	ldi	r22, 0x58	; 88
    b7aa:	84 e1       	ldi	r24, 0x14	; 20
    b7ac:	9f e4       	ldi	r25, 0x4F	; 79
    b7ae:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b7b2:	88 23       	and	r24, r24
    b7b4:	11 f4       	brne	.+4      	; 0xb7ba <GSM_Cycle+0x82e>
    b7b6:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			{
				EM_InitFIFO(); 
    b7ba:	0e 94 b2 4a 	call	0x9564	; 0x9564 <EM_InitFIFO>
				InitFIFO();
    b7be:	0e 94 cc 39 	call	0x7398	; 0x7398 <InitFIFO>
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b7c2:	80 91 ff 05 	lds	r24, 0x05FF
    b7c6:	80 93 e5 0a 	sts	0x0AE5, r24
				GSM_State=GSM_ProtocolMode;
    b7ca:	8f e5       	ldi	r24, 0x5F	; 95
    b7cc:	80 93 21 06 	sts	0x0621, r24
				StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b7d0:	60 91 0b 01 	lds	r22, 0x010B
    b7d4:	70 91 0c 01 	lds	r23, 0x010C
    b7d8:	80 91 2d 0d 	lds	r24, 0x0D2D
    b7dc:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b7e0:	60 91 09 01 	lds	r22, 0x0109
    b7e4:	70 91 0a 01 	lds	r23, 0x010A
    b7e8:	80 91 05 06 	lds	r24, 0x0605
    b7ec:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    b7f0:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_SEND_CIPSTATUS:
			GSM_Execute_Command(AT_CIPSTATUS, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_STATE_CONNECT_OK;			
    b7f4:	64 ef       	ldi	r22, 0xF4	; 244
    b7f6:	71 e0       	ldi	r23, 0x01	; 1
    b7f8:	80 e9       	ldi	r24, 0x90	; 144
    b7fa:	9d e4       	ldi	r25, 0x4D	; 77
    b7fc:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b800:	88 e2       	ldi	r24, 0x28	; 40
    b802:	80 93 21 06 	sts	0x0621, r24
    b806:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_STATE_CONNECT_OK:
			if(GSM_Wait_Response_P(RESP_STATE_CONNECT_OK, GSM_ReStart1)){
    b80a:	68 e5       	ldi	r22, 0x58	; 88
    b80c:	8a e9       	ldi	r24, 0x9A	; 154
    b80e:	9e e4       	ldi	r25, 0x4E	; 78
    b810:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b814:	88 23       	and	r24, r24
    b816:	11 f4       	brne	.+4      	; 0xb81c <GSM_Cycle+0x890>
    b818:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				GSM_State = GSM_SEND_ATO;
    b81c:	89 e2       	ldi	r24, 0x29	; 41
    b81e:	80 93 21 06 	sts	0x0621, r24
    b822:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_SEND_ATO:
			GSM_Execute_Command(AT_ATO, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_ATO_CONNECT;
    b826:	64 ef       	ldi	r22, 0xF4	; 244
    b828:	71 e0       	ldi	r23, 0x01	; 1
    b82a:	8c e8       	ldi	r24, 0x8C	; 140
    b82c:	9d e4       	ldi	r25, 0x4D	; 77
    b82e:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    b832:	8a e2       	ldi	r24, 0x2A	; 42
    b834:	80 93 21 06 	sts	0x0621, r24
    b838:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_ATO_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b83c:	68 e5       	ldi	r22, 0x58	; 88
    b83e:	8c e0       	ldi	r24, 0x0C	; 12
    b840:	9f e4       	ldi	r25, 0x4F	; 79
    b842:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b846:	88 23       	and	r24, r24
    b848:	11 f4       	brne	.+4      	; 0xb84e <GSM_Cycle+0x8c2>
    b84a:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
				switch(Transparent_Application_state){
    b84e:	80 91 40 09 	lds	r24, 0x0940
    b852:	82 30       	cpi	r24, 0x02	; 2
    b854:	49 f0       	breq	.+18     	; 0xb868 <GSM_Cycle+0x8dc>
    b856:	83 30       	cpi	r24, 0x03	; 3
    b858:	b9 f4       	brne	.+46     	; 0xb888 <GSM_Cycle+0x8fc>
					case CHECK_CONNECTION_STATE:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b85a:	60 91 0b 01 	lds	r22, 0x010B
    b85e:	70 91 0c 01 	lds	r23, 0x010C
    b862:	80 91 2d 0d 	lds	r24, 0x0D2D
    b866:	0e c0       	rjmp	.+28     	; 0xb884 <GSM_Cycle+0x8f8>
						break;
					case RECONNECT:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b868:	60 91 0b 01 	lds	r22, 0x010B
    b86c:	70 91 0c 01 	lds	r23, 0x010C
    b870:	80 91 2d 0d 	lds	r24, 0x0D2D
    b874:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
						StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b878:	60 91 09 01 	lds	r22, 0x0109
    b87c:	70 91 0a 01 	lds	r23, 0x010A
    b880:	80 91 05 06 	lds	r24, 0x0605
    b884:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
						break;
					default:break;
				}
				GSM_State = GSM_ProtocolMode;
    b888:	8f e5       	ldi	r24, 0x5F	; 95
    b88a:	80 93 21 06 	sts	0x0621, r24
    b88e:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    b892:	10 91 e1 03 	lds	r17, 0x03E1
    b896:	34 e0       	ldi	r19, 0x04	; 4
    b898:	13 9f       	mul	r17, r19
    b89a:	c0 01       	movw	r24, r0
    b89c:	11 24       	eor	r1, r1
    b89e:	00 e0       	ldi	r16, 0x00	; 0
    b8a0:	20 e0       	ldi	r18, 0x00	; 0
    b8a2:	40 e0       	ldi	r20, 0x00	; 0
    b8a4:	60 e0       	ldi	r22, 0x00	; 0
    b8a6:	8e 5b       	subi	r24, 0xBE	; 190
    b8a8:	9e 4f       	sbci	r25, 0xFE	; 254
    b8aa:	0e 94 9c 39 	call	0x7338	; 0x7338 <IP_E_compare_Const>
    b8ae:	88 23       	and	r24, r24
    b8b0:	61 f0       	breq	.+24     	; 0xb8ca <GSM_Cycle+0x93e>
				TempNum++;
    b8b2:	1f 5f       	subi	r17, 0xFF	; 255
    b8b4:	10 93 e1 03 	sts	0x03E1, r17
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    b8b8:	14 30       	cpi	r17, 0x04	; 4
    b8ba:	10 f4       	brcc	.+4      	; 0xb8c0 <GSM_Cycle+0x934>
    b8bc:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
    b8c0:	81 e3       	ldi	r24, 0x31	; 49
    b8c2:	80 93 21 06 	sts	0x0621, r24
    b8c6:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    b8ca:	80 91 08 01 	lds	r24, 0x0108
    b8ce:	80 fd       	sbrc	r24, 0
    b8d0:	02 c0       	rjmp	.+4      	; 0xb8d6 <GSM_Cycle+0x94a>
    b8d2:	0c 94 70 64 	jmp	0xc8e0	; 0xc8e0 <GSM_Cycle+0x1954>
					GSMTxSz = strlen_P(AT_CIPSTART);
    b8d6:	84 e1       	ldi	r24, 0x14	; 20
    b8d8:	80 93 45 09 	sts	0x0945, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    b8dc:	8f ec       	ldi	r24, 0xCF	; 207
    b8de:	9d e4       	ldi	r25, 0x4D	; 77
    b8e0:	9f 93       	push	r25
    b8e2:	8f 93       	push	r24
    b8e4:	86 e2       	ldi	r24, 0x26	; 38
    b8e6:	88 2e       	mov	r8, r24
    b8e8:	8c e0       	ldi	r24, 0x0C	; 12
    b8ea:	98 2e       	mov	r9, r24
    b8ec:	9f 92       	push	r9
    b8ee:	8f 92       	push	r8
    b8f0:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    b8f4:	00 91 e1 03 	lds	r16, 0x03E1
    b8f8:	80 e3       	ldi	r24, 0x30	; 48
    b8fa:	80 0f       	add	r24, r16
    b8fc:	80 93 32 0c 	sts	0x0C32, r24
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
    b900:	10 e0       	ldi	r17, 0x00	; 0
    b902:	c8 01       	movw	r24, r16
    b904:	88 0f       	add	r24, r24
    b906:	99 1f       	adc	r25, r25
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b908:	86 5d       	subi	r24, 0xD6	; 214
    b90a:	9e 4f       	sbci	r25, 0xFE	; 254
    b90c:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
    b910:	48 2e       	mov	r4, r24
    b912:	39 2e       	mov	r3, r25
    b914:	00 0f       	add	r16, r16
    b916:	11 1f       	adc	r17, r17
    b918:	00 0f       	add	r16, r16
    b91a:	11 1f       	adc	r17, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b91c:	c8 01       	movw	r24, r16
    b91e:	8b 5b       	subi	r24, 0xBB	; 187
    b920:	9e 4f       	sbci	r25, 0xFE	; 254
    b922:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b926:	58 2e       	mov	r5, r24
    b928:	c8 01       	movw	r24, r16
    b92a:	8c 5b       	subi	r24, 0xBC	; 188
    b92c:	9e 4f       	sbci	r25, 0xFE	; 254
    b92e:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b932:	68 2e       	mov	r6, r24
    b934:	c8 01       	movw	r24, r16
    b936:	8d 5b       	subi	r24, 0xBD	; 189
    b938:	9e 4f       	sbci	r25, 0xFE	; 254
    b93a:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    b93e:	78 2e       	mov	r7, r24
    b940:	c8 01       	movw	r24, r16
    b942:	8e 5b       	subi	r24, 0xBE	; 190
    b944:	9e 4f       	sbci	r25, 0xFE	; 254
    b946:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
					GSMTxSz = strlen_P(AT_CIPSTART);
					sprintf_P(GSM_TxStr, AT_CIPSTART);
					GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    b94a:	90 91 45 09 	lds	r25, 0x0945
    b94e:	3f 92       	push	r3
    b950:	4f 92       	push	r4
    b952:	1f 92       	push	r1
    b954:	5f 92       	push	r5
    b956:	1f 92       	push	r1
    b958:	6f 92       	push	r6
    b95a:	1f 92       	push	r1
    b95c:	7f 92       	push	r7
    b95e:	1f 92       	push	r1
    b960:	8f 93       	push	r24
    b962:	2a eb       	ldi	r18, 0xBA	; 186
    b964:	31 e0       	ldi	r19, 0x01	; 1
    b966:	3f 93       	push	r19
    b968:	2f 93       	push	r18
    b96a:	89 2f       	mov	r24, r25
    b96c:	90 e0       	ldi	r25, 0x00	; 0
    b96e:	8a 5d       	subi	r24, 0xDA	; 218
    b970:	93 4f       	sbci	r25, 0xF3	; 243
    b972:	9f 93       	push	r25
    b974:	8f 93       	push	r24
    b976:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    b97a:	f4 01       	movw	r30, r8
    b97c:	01 90       	ld	r0, Z+
    b97e:	00 20       	and	r0, r0
    b980:	e9 f7       	brne	.-6      	; 0xb97c <GSM_Cycle+0x9f0>
    b982:	31 97       	sbiw	r30, 0x01	; 1
    b984:	e6 52       	subi	r30, 0x26	; 38
    b986:	fc 40       	sbci	r31, 0x0C	; 12
    b988:	e0 93 45 09 	sts	0x0945, r30
					GSM_SendFirstChar();
    b98c:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b990:	64 ef       	ldi	r22, 0xF4	; 244
    b992:	71 e0       	ldi	r23, 0x01	; 1
    b994:	80 91 54 02 	lds	r24, 0x0254
    b998:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					GSM_State++;
    b99c:	80 91 21 06 	lds	r24, 0x0621
    b9a0:	8f 5f       	subi	r24, 0xFF	; 255
    b9a2:	80 93 21 06 	sts	0x0621, r24
    b9a6:	0f b6       	in	r0, 0x3f	; 63
    b9a8:	f8 94       	cli
    b9aa:	de bf       	out	0x3e, r29	; 62
    b9ac:	0f be       	out	0x3f, r0	; 63
    b9ae:	cd bf       	out	0x3d, r28	; 61
    b9b0:	97 c7       	rjmp	.+3886   	; 0xc8e0 <GSM_Cycle+0x1954>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b9b2:	68 e5       	ldi	r22, 0x58	; 88
    b9b4:	84 e1       	ldi	r24, 0x14	; 20
    b9b6:	9f e4       	ldi	r25, 0x4F	; 79
    b9b8:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    b9bc:	88 23       	and	r24, r24
    b9be:	09 f4       	brne	.+2      	; 0xb9c2 <GSM_Cycle+0xa36>
    b9c0:	8f c7       	rjmp	.+3870   	; 0xc8e0 <GSM_Cycle+0x1954>
    b9c2:	80 91 21 06 	lds	r24, 0x0621
    b9c6:	8f 5f       	subi	r24, 0xFF	; 255
    b9c8:	80 93 21 06 	sts	0x0621, r24
    b9cc:	89 c7       	rjmp	.+3858   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b9ce:	80 91 54 02 	lds	r24, 0x0254
    b9d2:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    b9d6:	88 23       	and	r24, r24
    b9d8:	19 f0       	breq	.+6      	; 0xb9e0 <GSM_Cycle+0xa54>
    b9da:	88 e5       	ldi	r24, 0x58	; 88
    b9dc:	80 93 21 06 	sts	0x0621, r24
			if(GetStringFromFIFO()){
    b9e0:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    b9e4:	88 23       	and	r24, r24
    b9e6:	09 f4       	brne	.+2      	; 0xb9ea <GSM_Cycle+0xa5e>
    b9e8:	7b c7       	rjmp	.+3830   	; 0xc8e0 <GSM_Cycle+0x1954>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    b9ea:	6e ef       	ldi	r22, 0xFE	; 254
    b9ec:	7e e4       	ldi	r23, 0x4E	; 78
    b9ee:	ce 01       	movw	r24, r28
    b9f0:	01 96       	adiw	r24, 0x01	; 1
    b9f2:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    b9f6:	10 91 e1 03 	lds	r17, 0x03E1
    b9fa:	80 e3       	ldi	r24, 0x30	; 48
    b9fc:	81 0f       	add	r24, r17
    b9fe:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    ba00:	68 e5       	ldi	r22, 0x58	; 88
    ba02:	ce 01       	movw	r24, r28
    ba04:	01 96       	adiw	r24, 0x01	; 1
    ba06:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <GSM_Wait_Response>
    ba0a:	88 23       	and	r24, r24
    ba0c:	09 f4       	brne	.+2      	; 0xba10 <GSM_Cycle+0xa84>
    ba0e:	68 c7       	rjmp	.+3792   	; 0xc8e0 <GSM_Cycle+0x1954>
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    ba10:	1f 5f       	subi	r17, 0xFF	; 255
    ba12:	10 93 e1 03 	sts	0x03E1, r17
    ba16:	14 30       	cpi	r17, 0x04	; 4
    ba18:	20 f0       	brcs	.+8      	; 0xba22 <GSM_Cycle+0xa96>
    ba1a:	81 e3       	ldi	r24, 0x31	; 49
    ba1c:	80 93 21 06 	sts	0x0621, r24
    ba20:	5f c7       	rjmp	.+3774   	; 0xc8e0 <GSM_Cycle+0x1954>
					else GSM_State = GSM_SEND_CIPSTART;
    ba22:	8b e2       	ldi	r24, 0x2B	; 43
    ba24:	80 93 21 06 	sts	0x0621, r24
    ba28:	5b c7       	rjmp	.+3766   	; 0xc8e0 <GSM_Cycle+0x1954>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    ba2a:	80 91 08 01 	lds	r24, 0x0108
    ba2e:	80 ff       	sbrs	r24, 0
    ba30:	57 c7       	rjmp	.+3758   	; 0xc8e0 <GSM_Cycle+0x1954>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    ba32:	8f e0       	ldi	r24, 0x0F	; 15
    ba34:	80 93 45 09 	sts	0x0945, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    ba38:	8c ea       	ldi	r24, 0xAC	; 172
    ba3a:	9d e4       	ldi	r25, 0x4D	; 77
    ba3c:	9f 93       	push	r25
    ba3e:	8f 93       	push	r24
    ba40:	06 e2       	ldi	r16, 0x26	; 38
    ba42:	1c e0       	ldi	r17, 0x0C	; 12
    ba44:	1f 93       	push	r17
    ba46:	0f 93       	push	r16
    ba48:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ba4c:	80 e2       	ldi	r24, 0x20	; 32
    ba4e:	91 e0       	ldi	r25, 0x01	; 1
    ba50:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    ba54:	40 91 45 09 	lds	r20, 0x0945
    ba58:	9f 93       	push	r25
    ba5a:	8f 93       	push	r24
    ba5c:	21 ed       	ldi	r18, 0xD1	; 209
    ba5e:	31 e0       	ldi	r19, 0x01	; 1
    ba60:	3f 93       	push	r19
    ba62:	2f 93       	push	r18
    ba64:	84 2f       	mov	r24, r20
    ba66:	90 e0       	ldi	r25, 0x00	; 0
    ba68:	8a 5d       	subi	r24, 0xDA	; 218
    ba6a:	93 4f       	sbci	r25, 0xF3	; 243
    ba6c:	9f 93       	push	r25
    ba6e:	8f 93       	push	r24
    ba70:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    ba74:	f8 01       	movw	r30, r16
    ba76:	01 90       	ld	r0, Z+
    ba78:	00 20       	and	r0, r0
    ba7a:	e9 f7       	brne	.-6      	; 0xba76 <GSM_Cycle+0xaea>
    ba7c:	31 97       	sbiw	r30, 0x01	; 1
    ba7e:	e6 52       	subi	r30, 0x26	; 38
    ba80:	fc 40       	sbci	r31, 0x0C	; 12
    ba82:	e0 93 45 09 	sts	0x0945, r30
				GSM_SendFirstChar();
    ba86:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    ba8a:	64 ef       	ldi	r22, 0xF4	; 244
    ba8c:	71 e0       	ldi	r23, 0x01	; 1
    ba8e:	80 91 54 02 	lds	r24, 0x0254
    ba92:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State++;
    ba96:	80 91 21 06 	lds	r24, 0x0621
    ba9a:	8f 5f       	subi	r24, 0xFF	; 255
    ba9c:	80 93 21 06 	sts	0x0621, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    baa0:	6f ef       	ldi	r22, 0xFF	; 255
    baa2:	7f ef       	ldi	r23, 0xFF	; 255
    baa4:	80 91 53 02 	lds	r24, 0x0253
    baa8:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    baac:	0f b6       	in	r0, 0x3f	; 63
    baae:	f8 94       	cli
    bab0:	de bf       	out	0x3e, r29	; 62
    bab2:	0f be       	out	0x3f, r0	; 63
    bab4:	cd bf       	out	0x3d, r28	; 61
    bab6:	14 c7       	rjmp	.+3624   	; 0xc8e0 <GSM_Cycle+0x1954>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    bab8:	68 e5       	ldi	r22, 0x58	; 88
    baba:	84 e1       	ldi	r24, 0x14	; 20
    babc:	9f e4       	ldi	r25, 0x4F	; 79
    babe:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    bac2:	88 23       	and	r24, r24
    bac4:	09 f4       	brne	.+2      	; 0xbac8 <GSM_Cycle+0xb3c>
    bac6:	0c c7       	rjmp	.+3608   	; 0xc8e0 <GSM_Cycle+0x1954>
    bac8:	80 91 21 06 	lds	r24, 0x0621
    bacc:	8f 5f       	subi	r24, 0xFF	; 255
    bace:	80 93 21 06 	sts	0x0621, r24
    bad2:	06 c7       	rjmp	.+3596   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    bad4:	68 e5       	ldi	r22, 0x58	; 88
    bad6:	84 ef       	ldi	r24, 0xF4	; 244
    bad8:	9e e4       	ldi	r25, 0x4E	; 78
    bada:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    bade:	88 23       	and	r24, r24
    bae0:	09 f4       	brne	.+2      	; 0xbae4 <GSM_Cycle+0xb58>
    bae2:	fe c6       	rjmp	.+3580   	; 0xc8e0 <GSM_Cycle+0x1954>
    bae4:	81 e3       	ldi	r24, 0x31	; 49
    bae6:	80 93 21 06 	sts	0x0621, r24
    baea:	fa c6       	rjmp	.+3572   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    baec:	80 91 6b 09 	lds	r24, 0x096B
    baf0:	81 11       	cpse	r24, r1
    baf2:	3c c0       	rjmp	.+120    	; 0xbb6c <GSM_Cycle+0xbe0>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    baf4:	80 91 31 09 	lds	r24, 0x0931
    baf8:	88 23       	and	r24, r24
    bafa:	41 f1       	breq	.+80     	; 0xbb4c <GSM_Cycle+0xbc0>
					if(GSM_MultiCon == 1){
    bafc:	80 91 38 0e 	lds	r24, 0x0E38
    bb00:	81 30       	cpi	r24, 0x01	; 1
    bb02:	e9 f4       	brne	.+58     	; 0xbb3e <GSM_Cycle+0xbb2>
						if(GPRS_Protocol_Out == UDP){
    bb04:	80 91 69 09 	lds	r24, 0x0969
    bb08:	81 11       	cpse	r24, r1
    bb0a:	09 c0       	rjmp	.+18     	; 0xbb1e <GSM_Cycle+0xb92>
							TempNum = 0;
    bb0c:	10 92 e1 03 	sts	0x03E1, r1
							GSM_State = GSM_SEND_CIPSEND;
    bb10:	83 e3       	ldi	r24, 0x33	; 51
    bb12:	80 93 21 06 	sts	0x0621, r24
							ResetTimer16(TD_GSM);
    bb16:	80 91 54 02 	lds	r24, 0x0254
    bb1a:	0e 94 86 2c 	call	0x590c	; 0x590c <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    bb1e:	80 91 69 09 	lds	r24, 0x0969
    bb22:	81 30       	cpi	r24, 0x01	; 1
    bb24:	09 f0       	breq	.+2      	; 0xbb28 <GSM_Cycle+0xb9c>
    bb26:	dc c6       	rjmp	.+3512   	; 0xc8e0 <GSM_Cycle+0x1954>
							if(GSM_ActiveConnection == NO_CONNECTION){
    bb28:	80 91 07 01 	lds	r24, 0x0107
    bb2c:	8f 3f       	cpi	r24, 0xFF	; 255
    bb2e:	19 f4       	brne	.+6      	; 0xbb36 <GSM_Cycle+0xbaa>
								GPRS_FlgSz_Out = 0;
    bb30:	10 92 31 09 	sts	0x0931, r1
    bb34:	d5 c6       	rjmp	.+3498   	; 0xc8e0 <GSM_Cycle+0x1954>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    bb36:	83 e3       	ldi	r24, 0x33	; 51
    bb38:	80 93 21 06 	sts	0x0621, r24
    bb3c:	d1 c6       	rjmp	.+3490   	; 0xc8e0 <GSM_Cycle+0x1954>
						}
					}
					else{
						GSM_MultiCon = 1;
    bb3e:	81 e0       	ldi	r24, 0x01	; 1
    bb40:	80 93 38 0e 	sts	0x0E38, r24
						GSM_State = GSM_CIPSHUT;
    bb44:	80 e5       	ldi	r24, 0x50	; 80
    bb46:	80 93 21 06 	sts	0x0621, r24
    bb4a:	ca c6       	rjmp	.+3476   	; 0xc8e0 <GSM_Cycle+0x1954>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    bb4c:	80 91 54 09 	lds	r24, 0x0954
    bb50:	88 23       	and	r24, r24
    bb52:	61 f0       	breq	.+24     	; 0xbb6c <GSM_Cycle+0xbe0>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bb54:	80 e6       	ldi	r24, 0x60	; 96
    bb56:	90 e0       	ldi	r25, 0x00	; 0
    bb58:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    bb5c:	88 23       	and	r24, r24
    bb5e:	31 f0       	breq	.+12     	; 0xbb6c <GSM_Cycle+0xbe0>
					GSM_State = GSM_SEND_CMGS;
    bb60:	88 e3       	ldi	r24, 0x38	; 56
    bb62:	80 93 21 06 	sts	0x0621, r24
					TempNum = 0;
    bb66:	10 92 e1 03 	sts	0x03E1, r1
    bb6a:	ba c6       	rjmp	.+3444   	; 0xc8e0 <GSM_Cycle+0x1954>
					break;
				}
			}

			if(GetStringFromFIFO()){
    bb6c:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    bb70:	88 23       	and	r24, r24
    bb72:	31 f0       	breq	.+12     	; 0xbb80 <GSM_Cycle+0xbf4>
				GSM_State = GSM_AnalyzeURC;
    bb74:	82 e3       	ldi	r24, 0x32	; 50
    bb76:	80 93 21 06 	sts	0x0621, r24
				TempNum = 0;
    bb7a:	10 92 e1 03 	sts	0x03E1, r1
    bb7e:	b0 c6       	rjmp	.+3424   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			if(!IsWebSession()){
    bb80:	80 91 6b 09 	lds	r24, 0x096B
    bb84:	81 11       	cpse	r24, r1
    bb86:	ac c6       	rjmp	.+3416   	; 0xc8e0 <GSM_Cycle+0x1954>
				if(Timer16Stopp(TD_TCP_Connect) ){
    bb88:	80 91 53 02 	lds	r24, 0x0253
    bb8c:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    bb90:	88 23       	and	r24, r24
    bb92:	21 f0       	breq	.+8      	; 0xbb9c <GSM_Cycle+0xc10>
					GSM_State = GSM_CIPSHUT;
    bb94:	80 e5       	ldi	r24, 0x50	; 80
    bb96:	80 93 21 06 	sts	0x0621, r24
    bb9a:	a2 c6       	rjmp	.+3396   	; 0xc8e0 <GSM_Cycle+0x1954>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    bb9c:	80 91 52 02 	lds	r24, 0x0252
    bba0:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    bba4:	88 23       	and	r24, r24
    bba6:	21 f0       	breq	.+8      	; 0xbbb0 <GSM_Cycle+0xc24>
					GSM_State = GSM_SEND_CSQ;
    bba8:	8d e5       	ldi	r24, 0x5D	; 93
    bbaa:	80 93 21 06 	sts	0x0621, r24
    bbae:	98 c6       	rjmp	.+3376   	; 0xc8e0 <GSM_Cycle+0x1954>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    bbb0:	80 91 51 02 	lds	r24, 0x0251
    bbb4:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <Timer32Stopp>
    bbb8:	88 23       	and	r24, r24
    bbba:	09 f4       	brne	.+2      	; 0xbbbe <GSM_Cycle+0xc32>
    bbbc:	91 c6       	rjmp	.+3362   	; 0xc8e0 <GSM_Cycle+0x1954>
					GSM_State = GSM_ReStart1;
    bbbe:	88 e5       	ldi	r24, 0x58	; 88
    bbc0:	80 93 21 06 	sts	0x0621, r24
    bbc4:	8d c6       	rjmp	.+3354   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    bbc6:	6d e4       	ldi	r22, 0x4D	; 77
    bbc8:	7f e4       	ldi	r23, 0x4F	; 79
    bbca:	86 e7       	ldi	r24, 0x76	; 118
    bbcc:	99 e0       	ldi	r25, 0x09	; 9
    bbce:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bbd2:	89 2b       	or	r24, r25
    bbd4:	21 f0       	breq	.+8      	; 0xbbde <GSM_Cycle+0xc52>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    bbd6:	8c e3       	ldi	r24, 0x3C	; 60
    bbd8:	80 93 21 06 	sts	0x0621, r24
    bbdc:	81 c6       	rjmp	.+3330   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    bbde:	65 e4       	ldi	r22, 0x45	; 69
    bbe0:	7f e4       	ldi	r23, 0x4F	; 79
    bbe2:	86 e7       	ldi	r24, 0x76	; 118
    bbe4:	99 e0       	ldi	r25, 0x09	; 9
    bbe6:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bbea:	89 2b       	or	r24, r25
    bbec:	61 f0       	breq	.+24     	; 0xbc06 <GSM_Cycle+0xc7a>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    bbee:	68 ee       	ldi	r22, 0xE8	; 232
    bbf0:	73 e0       	ldi	r23, 0x03	; 3
    bbf2:	80 91 53 02 	lds	r24, 0x0253
    bbf6:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_CSD = 0;
    bbfa:	10 92 39 09 	sts	0x0939, r1
				GSM_State = GSM_ProtocolMode;
    bbfe:	8f e5       	ldi	r24, 0x5F	; 95
    bc00:	80 93 21 06 	sts	0x0621, r24
    bc04:	6d c6       	rjmp	.+3290   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    bc06:	62 e2       	ldi	r22, 0x22	; 34
    bc08:	7f e4       	ldi	r23, 0x4F	; 79
    bc0a:	86 e7       	ldi	r24, 0x76	; 118
    bc0c:	99 e0       	ldi	r25, 0x09	; 9
    bc0e:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bc12:	89 2b       	or	r24, r25
    bc14:	51 f0       	breq	.+20     	; 0xbc2a <GSM_Cycle+0xc9e>
				StartTimer16(TD_GSM, 150);
    bc16:	66 e9       	ldi	r22, 0x96	; 150
    bc18:	70 e0       	ldi	r23, 0x00	; 0
    bc1a:	80 91 54 02 	lds	r24, 0x0254
    bc1e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    bc22:	84 e6       	ldi	r24, 0x64	; 100
    bc24:	80 93 21 06 	sts	0x0621, r24
    bc28:	5b c6       	rjmp	.+3254   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    bc2a:	62 e3       	ldi	r22, 0x32	; 50
    bc2c:	7f e4       	ldi	r23, 0x4F	; 79
    bc2e:	86 e7       	ldi	r24, 0x76	; 118
    bc30:	99 e0       	ldi	r25, 0x09	; 9
    bc32:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bc36:	89 2b       	or	r24, r25
    bc38:	49 f1       	breq	.+82     	; 0xbc8c <GSM_Cycle+0xd00>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    bc3a:	81 ee       	ldi	r24, 0xE1	; 225
    bc3c:	93 e0       	ldi	r25, 0x03	; 3
    bc3e:	9f 93       	push	r25
    bc40:	8f 93       	push	r24
    bc42:	89 e5       	ldi	r24, 0x59	; 89
    bc44:	93 e0       	ldi	r25, 0x03	; 3
    bc46:	9f 93       	push	r25
    bc48:	8f 93       	push	r24
    bc4a:	86 e7       	ldi	r24, 0x76	; 118
    bc4c:	99 e0       	ldi	r25, 0x09	; 9
    bc4e:	9f 93       	push	r25
    bc50:	8f 93       	push	r24
    bc52:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    bc56:	0f 90       	pop	r0
    bc58:	0f 90       	pop	r0
    bc5a:	0f 90       	pop	r0
    bc5c:	0f 90       	pop	r0
    bc5e:	0f 90       	pop	r0
    bc60:	0f 90       	pop	r0
    bc62:	90 91 07 01 	lds	r25, 0x0107
    bc66:	80 91 e1 03 	lds	r24, 0x03E1
    bc6a:	98 13       	cpse	r25, r24
    bc6c:	0b c0       	rjmp	.+22     	; 0xbc84 <GSM_Cycle+0xcf8>
					GSM_ActiveConnection = NO_CONNECTION;
    bc6e:	8f ef       	ldi	r24, 0xFF	; 255
    bc70:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    bc74:	10 92 27 0d 	sts	0x0D27, r1
	IP->IP2 = IP2;
    bc78:	10 92 28 0d 	sts	0x0D28, r1
	IP->IP3 = IP3;
    bc7c:	10 92 29 0d 	sts	0x0D29, r1
	IP->IP4 = IP4;
    bc80:	10 92 2a 0d 	sts	0x0D2A, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    bc84:	81 e3       	ldi	r24, 0x31	; 49
    bc86:	80 93 21 06 	sts	0x0621, r24
    bc8a:	2a c6       	rjmp	.+3156   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    bc8c:	67 e2       	ldi	r22, 0x27	; 39
    bc8e:	7f e4       	ldi	r23, 0x4F	; 79
    bc90:	86 e7       	ldi	r24, 0x76	; 118
    bc92:	99 e0       	ldi	r25, 0x09	; 9
    bc94:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bc98:	89 2b       	or	r24, r25
    bc9a:	21 f0       	breq	.+8      	; 0xbca4 <GSM_Cycle+0xd18>
				GSM_State = GSM_SEND_E0;
    bc9c:	88 e0       	ldi	r24, 0x08	; 8
    bc9e:	80 93 21 06 	sts	0x0621, r24
    bca2:	1e c6       	rjmp	.+3132   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    bca4:	6b e3       	ldi	r22, 0x3B	; 59
    bca6:	7f e4       	ldi	r23, 0x4F	; 79
    bca8:	86 e7       	ldi	r24, 0x76	; 118
    bcaa:	99 e0       	ldi	r25, 0x09	; 9
    bcac:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bcb0:	89 2b       	or	r24, r25
    bcb2:	41 f0       	breq	.+16     	; 0xbcc4 <GSM_Cycle+0xd38>
    bcb4:	80 91 4b 09 	lds	r24, 0x094B
    bcb8:	81 11       	cpse	r24, r1
    bcba:	04 c0       	rjmp	.+8      	; 0xbcc4 <GSM_Cycle+0xd38>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    bcbc:	8f e3       	ldi	r24, 0x3F	; 63
    bcbe:	80 93 21 06 	sts	0x0621, r24
    bcc2:	0e c6       	rjmp	.+3100   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    bcc4:	61 ec       	ldi	r22, 0xC1	; 193
    bcc6:	7e e4       	ldi	r23, 0x4E	; 78
    bcc8:	86 e7       	ldi	r24, 0x76	; 118
    bcca:	99 e0       	ldi	r25, 0x09	; 9
    bccc:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    bcd0:	89 2b       	or	r24, r25
    bcd2:	21 f0       	breq	.+8      	; 0xbcdc <GSM_Cycle+0xd50>
				GSM_State = GSM_WAIT_CSQ;
    bcd4:	8e e5       	ldi	r24, 0x5E	; 94
    bcd6:	80 93 21 06 	sts	0x0621, r24
    bcda:	02 c6       	rjmp	.+3076   	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    bcdc:	81 e3       	ldi	r24, 0x31	; 49
    bcde:	80 93 21 06 	sts	0x0621, r24
    bce2:	fe c5       	rjmp	.+3068   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    bce4:	80 91 69 09 	lds	r24, 0x0969
    bce8:	81 11       	cpse	r24, r1
    bcea:	74 c0       	rjmp	.+232    	; 0xbdd4 <GSM_Cycle+0xe48>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    bcec:	10 91 e1 03 	lds	r17, 0x03E1
    bcf0:	f4 e0       	ldi	r31, 0x04	; 4
    bcf2:	1f 9f       	mul	r17, r31
    bcf4:	c0 01       	movw	r24, r0
    bcf6:	11 24       	eor	r1, r1
    bcf8:	00 e0       	ldi	r16, 0x00	; 0
    bcfa:	20 e0       	ldi	r18, 0x00	; 0
    bcfc:	40 e0       	ldi	r20, 0x00	; 0
    bcfe:	60 e0       	ldi	r22, 0x00	; 0
    bd00:	8e 5b       	subi	r24, 0xBE	; 190
    bd02:	9e 4f       	sbci	r25, 0xFE	; 254
    bd04:	0e 94 9c 39 	call	0x7338	; 0x7338 <IP_E_compare_Const>
    bd08:	81 11       	cpse	r24, r1
    bd0a:	0b c0       	rjmp	.+22     	; 0xbd22 <GSM_Cycle+0xd96>
    bd0c:	80 91 69 08 	lds	r24, 0x0869
    bd10:	90 e0       	ldi	r25, 0x00	; 0
    bd12:	01 2e       	mov	r0, r17
    bd14:	02 c0       	rjmp	.+4      	; 0xbd1a <GSM_Cycle+0xd8e>
    bd16:	95 95       	asr	r25
    bd18:	87 95       	ror	r24
    bd1a:	0a 94       	dec	r0
    bd1c:	e2 f7       	brpl	.-8      	; 0xbd16 <GSM_Cycle+0xd8a>
    bd1e:	80 ff       	sbrs	r24, 0
    bd20:	12 c0       	rjmp	.+36     	; 0xbd46 <GSM_Cycle+0xdba>
					TempNum++;
    bd22:	1f 5f       	subi	r17, 0xFF	; 255
    bd24:	10 93 e1 03 	sts	0x03E1, r17
					if(TempNum>3){
    bd28:	14 30       	cpi	r17, 0x04	; 4
    bd2a:	08 f4       	brcc	.+2      	; 0xbd2e <GSM_Cycle+0xda2>
    bd2c:	53 c0       	rjmp	.+166    	; 0xbdd4 <GSM_Cycle+0xe48>
						StartTimer16(TD_GSM,150);
    bd2e:	66 e9       	ldi	r22, 0x96	; 150
    bd30:	70 e0       	ldi	r23, 0x00	; 0
    bd32:	80 91 54 02 	lds	r24, 0x0254
    bd36:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    bd3a:	87 e3       	ldi	r24, 0x37	; 55
    bd3c:	80 93 21 06 	sts	0x0621, r24
						GPRS_FlgSz_Out = 0;
    bd40:	10 92 31 09 	sts	0x0931, r1
    bd44:	47 c0       	rjmp	.+142    	; 0xbdd4 <GSM_Cycle+0xe48>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    bd46:	80 91 08 01 	lds	r24, 0x0108
    bd4a:	80 ff       	sbrs	r24, 0
    bd4c:	43 c0       	rjmp	.+134    	; 0xbdd4 <GSM_Cycle+0xe48>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    bd4e:	80 91 54 02 	lds	r24, 0x0254
    bd52:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    bd56:	88 23       	and	r24, r24
    bd58:	e9 f1       	breq	.+122    	; 0xbdd4 <GSM_Cycle+0xe48>
							GSMTxSz = strlen_P(AT_CIPSEND);
    bd5a:	8b e0       	ldi	r24, 0x0B	; 11
    bd5c:	80 93 45 09 	sts	0x0945, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    bd60:	80 e8       	ldi	r24, 0x80	; 128
    bd62:	9d e4       	ldi	r25, 0x4D	; 77
    bd64:	9f 93       	push	r25
    bd66:	8f 93       	push	r24
    bd68:	06 e2       	ldi	r16, 0x26	; 38
    bd6a:	1c e0       	ldi	r17, 0x0C	; 12
    bd6c:	1f 93       	push	r17
    bd6e:	0f 93       	push	r16
    bd70:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    bd74:	80 91 45 09 	lds	r24, 0x0945
    bd78:	90 91 31 09 	lds	r25, 0x0931
    bd7c:	1f 92       	push	r1
    bd7e:	9f 93       	push	r25
    bd80:	90 91 e1 03 	lds	r25, 0x03E1
    bd84:	1f 92       	push	r1
    bd86:	9f 93       	push	r25
    bd88:	2e ec       	ldi	r18, 0xCE	; 206
    bd8a:	31 e0       	ldi	r19, 0x01	; 1
    bd8c:	3f 93       	push	r19
    bd8e:	2f 93       	push	r18
    bd90:	90 e0       	ldi	r25, 0x00	; 0
    bd92:	8a 5d       	subi	r24, 0xDA	; 218
    bd94:	93 4f       	sbci	r25, 0xF3	; 243
    bd96:	9f 93       	push	r25
    bd98:	8f 93       	push	r24
    bd9a:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    bd9e:	f8 01       	movw	r30, r16
    bda0:	01 90       	ld	r0, Z+
    bda2:	00 20       	and	r0, r0
    bda4:	e9 f7       	brne	.-6      	; 0xbda0 <GSM_Cycle+0xe14>
    bda6:	31 97       	sbiw	r30, 0x01	; 1
    bda8:	e6 52       	subi	r30, 0x26	; 38
    bdaa:	fc 40       	sbci	r31, 0x0C	; 12
    bdac:	e0 93 45 09 	sts	0x0945, r30
							GSM_SendFirstChar();
    bdb0:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bdb4:	64 ef       	ldi	r22, 0xF4	; 244
    bdb6:	71 e0       	ldi	r23, 0x01	; 1
    bdb8:	80 91 54 02 	lds	r24, 0x0254
    bdbc:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
							GSM_State++;
    bdc0:	80 91 21 06 	lds	r24, 0x0621
    bdc4:	8f 5f       	subi	r24, 0xFF	; 255
    bdc6:	80 93 21 06 	sts	0x0621, r24
    bdca:	0f b6       	in	r0, 0x3f	; 63
    bdcc:	f8 94       	cli
    bdce:	de bf       	out	0x3e, r29	; 62
    bdd0:	0f be       	out	0x3f, r0	; 63
    bdd2:	cd bf       	out	0x3d, r28	; 61
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    bdd4:	80 91 69 09 	lds	r24, 0x0969
    bdd8:	81 30       	cpi	r24, 0x01	; 1
    bdda:	09 f0       	breq	.+2      	; 0xbdde <GSM_Cycle+0xe52>
    bddc:	81 c5       	rjmp	.+2818   	; 0xc8e0 <GSM_Cycle+0x1954>
				if(GSM_Flag & (1<<flg_TxCStr)){
    bdde:	80 91 08 01 	lds	r24, 0x0108
    bde2:	80 ff       	sbrs	r24, 0
    bde4:	7d c5       	rjmp	.+2810   	; 0xc8e0 <GSM_Cycle+0x1954>
					GSMTxSz = strlen_P(AT_CIPSEND);
    bde6:	8b e0       	ldi	r24, 0x0B	; 11
    bde8:	80 93 45 09 	sts	0x0945, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    bdec:	80 e8       	ldi	r24, 0x80	; 128
    bdee:	9d e4       	ldi	r25, 0x4D	; 77
    bdf0:	9f 93       	push	r25
    bdf2:	8f 93       	push	r24
    bdf4:	06 e2       	ldi	r16, 0x26	; 38
    bdf6:	1c e0       	ldi	r17, 0x0C	; 12
    bdf8:	1f 93       	push	r17
    bdfa:	0f 93       	push	r16
    bdfc:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    be00:	80 91 45 09 	lds	r24, 0x0945
    be04:	90 91 31 09 	lds	r25, 0x0931
    be08:	1f 92       	push	r1
    be0a:	9f 93       	push	r25
    be0c:	90 91 07 01 	lds	r25, 0x0107
    be10:	1f 92       	push	r1
    be12:	9f 93       	push	r25
    be14:	2e ec       	ldi	r18, 0xCE	; 206
    be16:	31 e0       	ldi	r19, 0x01	; 1
    be18:	3f 93       	push	r19
    be1a:	2f 93       	push	r18
    be1c:	90 e0       	ldi	r25, 0x00	; 0
    be1e:	8a 5d       	subi	r24, 0xDA	; 218
    be20:	93 4f       	sbci	r25, 0xF3	; 243
    be22:	9f 93       	push	r25
    be24:	8f 93       	push	r24
    be26:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    be2a:	f8 01       	movw	r30, r16
    be2c:	01 90       	ld	r0, Z+
    be2e:	00 20       	and	r0, r0
    be30:	e9 f7       	brne	.-6      	; 0xbe2c <GSM_Cycle+0xea0>
    be32:	31 97       	sbiw	r30, 0x01	; 1
    be34:	e6 52       	subi	r30, 0x26	; 38
    be36:	fc 40       	sbci	r31, 0x0C	; 12
    be38:	e0 93 45 09 	sts	0x0945, r30
					GSM_SendFirstChar();
    be3c:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    be40:	64 ef       	ldi	r22, 0xF4	; 244
    be42:	71 e0       	ldi	r23, 0x01	; 1
    be44:	80 91 54 02 	lds	r24, 0x0254
    be48:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					GSM_State++;
    be4c:	80 91 21 06 	lds	r24, 0x0621
    be50:	8f 5f       	subi	r24, 0xFF	; 255
    be52:	80 93 21 06 	sts	0x0621, r24
    be56:	0f b6       	in	r0, 0x3f	; 63
    be58:	f8 94       	cli
    be5a:	de bf       	out	0x3e, r29	; 62
    be5c:	0f be       	out	0x3f, r0	; 63
    be5e:	cd bf       	out	0x3d, r28	; 61
    be60:	3f c5       	rjmp	.+2686   	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    be62:	61 e3       	ldi	r22, 0x31	; 49
    be64:	8e e3       	ldi	r24, 0x3E	; 62
    be66:	0e 94 1a 3b 	call	0x7634	; 0x7634 <GSM_Wait_Char>
    be6a:	88 23       	and	r24, r24
    be6c:	29 f0       	breq	.+10     	; 0xbe78 <GSM_Cycle+0xeec>
    be6e:	80 91 21 06 	lds	r24, 0x0621
    be72:	8f 5f       	subi	r24, 0xFF	; 255
    be74:	80 93 21 06 	sts	0x0621, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    be78:	80 91 21 06 	lds	r24, 0x0621
    be7c:	81 33       	cpi	r24, 0x31	; 49
    be7e:	09 f0       	breq	.+2      	; 0xbe82 <GSM_Cycle+0xef6>
    be80:	2f c5       	rjmp	.+2654   	; 0xc8e0 <GSM_Cycle+0x1954>
    be82:	10 92 31 09 	sts	0x0931, r1
    be86:	2c c5       	rjmp	.+2648   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    be88:	60 91 31 09 	lds	r22, 0x0931
    be8c:	86 e2       	ldi	r24, 0x26	; 38
    be8e:	9b e0       	ldi	r25, 0x0B	; 11
    be90:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_AddHeaderSendData>
			GSM_State++;
    be94:	80 91 21 06 	lds	r24, 0x0621
    be98:	8f 5f       	subi	r24, 0xFF	; 255
    be9a:	80 93 21 06 	sts	0x0621, r24
    be9e:	20 c5       	rjmp	.+2624   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    bea0:	80 91 54 02 	lds	r24, 0x0254
    bea4:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    bea8:	88 23       	and	r24, r24
    beaa:	29 f0       	breq	.+10     	; 0xbeb6 <GSM_Cycle+0xf2a>
				GSM_State = GSM_ServerIdle;
    beac:	81 e3       	ldi	r24, 0x31	; 49
    beae:	80 93 21 06 	sts	0x0621, r24
				GPRS_FlgSz_Out = 0;
    beb2:	10 92 31 09 	sts	0x0931, r1
			}

			if(GetStringFromFIFO()){
    beb6:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    beba:	88 23       	and	r24, r24
    bebc:	09 f4       	brne	.+2      	; 0xbec0 <GSM_Cycle+0xf34>
    bebe:	10 c5       	rjmp	.+2592   	; 0xc8e0 <GSM_Cycle+0x1954>
				if(GPRS_Protocol_Out == UDP){
    bec0:	80 91 69 09 	lds	r24, 0x0969
    bec4:	81 11       	cpse	r24, r1
    bec6:	27 c0       	rjmp	.+78     	; 0xbf16 <GSM_Cycle+0xf8a>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    bec8:	6c ed       	ldi	r22, 0xDC	; 220
    beca:	7e e4       	ldi	r23, 0x4E	; 78
    becc:	ce 01       	movw	r24, r28
    bece:	01 96       	adiw	r24, 0x01	; 1
    bed0:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    bed4:	80 91 e1 03 	lds	r24, 0x03E1
    bed8:	80 5d       	subi	r24, 0xD0	; 208
    beda:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bedc:	68 e5       	ldi	r22, 0x58	; 88
    bede:	ce 01       	movw	r24, r28
    bee0:	01 96       	adiw	r24, 0x01	; 1
    bee2:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <GSM_Wait_Response>
    bee6:	88 23       	and	r24, r24
    bee8:	b1 f0       	breq	.+44     	; 0xbf16 <GSM_Cycle+0xf8a>
						StartTimer16(TD_GSM,500);//min~ 2 sec
    beea:	64 ef       	ldi	r22, 0xF4	; 244
    beec:	71 e0       	ldi	r23, 0x01	; 1
    beee:	80 91 54 02 	lds	r24, 0x0254
    bef2:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
						if(++TempNum>3){
    bef6:	80 91 e1 03 	lds	r24, 0x03E1
    befa:	8f 5f       	subi	r24, 0xFF	; 255
    befc:	80 93 e1 03 	sts	0x03E1, r24
    bf00:	84 30       	cpi	r24, 0x04	; 4
    bf02:	30 f0       	brcs	.+12     	; 0xbf10 <GSM_Cycle+0xf84>
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    bf04:	87 e3       	ldi	r24, 0x37	; 55
    bf06:	80 93 21 06 	sts	0x0621, r24
							GPRS_FlgSz_Out = 0;
    bf0a:	10 92 31 09 	sts	0x0931, r1
    bf0e:	03 c0       	rjmp	.+6      	; 0xbf16 <GSM_Cycle+0xf8a>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    bf10:	83 e3       	ldi	r24, 0x33	; 51
    bf12:	80 93 21 06 	sts	0x0621, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    bf16:	80 91 69 09 	lds	r24, 0x0969
    bf1a:	81 30       	cpi	r24, 0x01	; 1
    bf1c:	09 f0       	breq	.+2      	; 0xbf20 <GSM_Cycle+0xf94>
    bf1e:	e0 c4       	rjmp	.+2496   	; 0xc8e0 <GSM_Cycle+0x1954>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    bf20:	6c ed       	ldi	r22, 0xDC	; 220
    bf22:	7e e4       	ldi	r23, 0x4E	; 78
    bf24:	ce 01       	movw	r24, r28
    bf26:	01 96       	adiw	r24, 0x01	; 1
    bf28:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    bf2c:	80 91 07 01 	lds	r24, 0x0107
    bf30:	80 5d       	subi	r24, 0xD0	; 208
    bf32:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bf34:	68 e5       	ldi	r22, 0x58	; 88
    bf36:	ce 01       	movw	r24, r28
    bf38:	01 96       	adiw	r24, 0x01	; 1
    bf3a:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <GSM_Wait_Response>
    bf3e:	88 23       	and	r24, r24
    bf40:	09 f4       	brne	.+2      	; 0xbf44 <GSM_Cycle+0xfb8>
    bf42:	ce c4       	rjmp	.+2460   	; 0xc8e0 <GSM_Cycle+0x1954>
						GPRS_FlgSz_Out = 0;
    bf44:	10 92 31 09 	sts	0x0931, r1
    bf48:	cb c4       	rjmp	.+2454   	; 0xc8e0 <GSM_Cycle+0x1954>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    bf4a:	80 91 54 02 	lds	r24, 0x0254
    bf4e:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    bf52:	88 23       	and	r24, r24
    bf54:	09 f4       	brne	.+2      	; 0xbf58 <GSM_Cycle+0xfcc>
    bf56:	c4 c4       	rjmp	.+2440   	; 0xc8e0 <GSM_Cycle+0x1954>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    bf58:	10 92 38 0e 	sts	0x0E38, r1
				if(sendsWithoutReconnect<3)
    bf5c:	80 91 55 02 	lds	r24, 0x0255
    bf60:	83 30       	cpi	r24, 0x03	; 3
    bf62:	10 f4       	brcc	.+4      	; 0xbf68 <GSM_Cycle+0xfdc>
				{
					GSM_State = GSM_CIPSHUT;
    bf64:	80 e5       	ldi	r24, 0x50	; 80
    bf66:	03 c0       	rjmp	.+6      	; 0xbf6e <GSM_Cycle+0xfe2>
				}
				else{
					sendsWithoutReconnect=0;
    bf68:	10 92 55 02 	sts	0x0255, r1
					GSM_State = GSM_CIPSHUT_;
    bf6c:	82 e5       	ldi	r24, 0x52	; 82
    bf6e:	80 93 21 06 	sts	0x0621, r24
				}
				sendsWithoutReconnect++;
    bf72:	80 91 55 02 	lds	r24, 0x0255
    bf76:	8f 5f       	subi	r24, 0xFF	; 255
    bf78:	80 93 55 02 	sts	0x0255, r24
    bf7c:	b1 c4       	rjmp	.+2402   	; 0xc8e0 <GSM_Cycle+0x1954>

			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bf7e:	68 ee       	ldi	r22, 0xE8	; 232
    bf80:	73 e0       	ldi	r23, 0x03	; 3
    bf82:	87 e5       	ldi	r24, 0x57	; 87
    bf84:	9d e4       	ldi	r25, 0x4D	; 77
    bf86:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    bf8a:	80 91 21 06 	lds	r24, 0x0621
    bf8e:	8f 5f       	subi	r24, 0xFF	; 255
    bf90:	80 93 21 06 	sts	0x0621, r24
    bf94:	a5 c4       	rjmp	.+2378   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    bf96:	68 e5       	ldi	r22, 0x58	; 88
    bf98:	89 eb       	ldi	r24, 0xB9	; 185
    bf9a:	9e e4       	ldi	r25, 0x4E	; 78
    bf9c:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    bfa0:	88 23       	and	r24, r24
    bfa2:	09 f4       	brne	.+2      	; 0xbfa6 <GSM_Cycle+0x101a>
    bfa4:	9d c4       	rjmp	.+2362   	; 0xc8e0 <GSM_Cycle+0x1954>
    bfa6:	83 e1       	ldi	r24, 0x13	; 19
    bfa8:	80 93 21 06 	sts	0x0621, r24
    bfac:	99 c4       	rjmp	.+2354   	; 0xc8e0 <GSM_Cycle+0x1954>
		//------------------------


				//------------------------  GPRS
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bfae:	68 ee       	ldi	r22, 0xE8	; 232
    bfb0:	73 e0       	ldi	r23, 0x03	; 3
    bfb2:	87 e5       	ldi	r24, 0x57	; 87
    bfb4:	9d e4       	ldi	r25, 0x4D	; 77
    bfb6:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    bfba:	80 91 21 06 	lds	r24, 0x0621
    bfbe:	8f 5f       	subi	r24, 0xFF	; 255
    bfc0:	80 93 21 06 	sts	0x0621, r24
    bfc4:	8d c4       	rjmp	.+2330   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    bfc6:	68 e5       	ldi	r22, 0x58	; 88
    bfc8:	89 eb       	ldi	r24, 0xB9	; 185
    bfca:	9e e4       	ldi	r25, 0x4E	; 78
    bfcc:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    bfd0:	88 23       	and	r24, r24
    bfd2:	09 f4       	brne	.+2      	; 0xbfd6 <GSM_Cycle+0x104a>
    bfd4:	85 c4       	rjmp	.+2314   	; 0xc8e0 <GSM_Cycle+0x1954>
    bfd6:	80 91 21 06 	lds	r24, 0x0621
    bfda:	8f 5f       	subi	r24, 0xFF	; 255
    bfdc:	80 93 21 06 	sts	0x0621, r24
    bfe0:	7f c4       	rjmp	.+2302   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bfe2:	68 ee       	ldi	r22, 0xE8	; 232
    bfe4:	73 e0       	ldi	r23, 0x03	; 3
    bfe6:	8c e4       	ldi	r24, 0x4C	; 76
    bfe8:	9d e4       	ldi	r25, 0x4D	; 77
    bfea:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    bfee:	80 91 21 06 	lds	r24, 0x0621
    bff2:	8f 5f       	subi	r24, 0xFF	; 255
    bff4:	80 93 21 06 	sts	0x0621, r24
    bff8:	73 c4       	rjmp	.+2278   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    bffa:	68 e5       	ldi	r22, 0x58	; 88
    bffc:	84 e1       	ldi	r24, 0x14	; 20
    bffe:	9f e4       	ldi	r25, 0x4F	; 79
    c000:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c004:	88 23       	and	r24, r24
    c006:	09 f4       	brne	.+2      	; 0xc00a <GSM_Cycle+0x107e>
    c008:	6b c4       	rjmp	.+2262   	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_GSM, 1000);
    c00a:	68 ee       	ldi	r22, 0xE8	; 232
    c00c:	73 e0       	ldi	r23, 0x03	; 3
    c00e:	80 91 54 02 	lds	r24, 0x0254
    c012:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			 	GSM_State = GSM_SEND_CIPMUX;
    c016:	83 e1       	ldi	r24, 0x13	; 19
    c018:	80 93 21 06 	sts	0x0621, r24
    c01c:	61 c4       	rjmp	.+2242   	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c01e:	80 91 08 01 	lds	r24, 0x0108
    c022:	80 ff       	sbrs	r24, 0
    c024:	5d c4       	rjmp	.+2234   	; 0xc8e0 <GSM_Cycle+0x1954>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
    c026:	60 91 e1 03 	lds	r22, 0x03E1
    c02a:	9d e0       	ldi	r25, 0x0D	; 13
    c02c:	69 9f       	mul	r22, r25
    c02e:	b0 01       	movw	r22, r0
    c030:	11 24       	eor	r1, r1
    c032:	6d 51       	subi	r22, 0x1D	; 29
    c034:	7f 4f       	sbci	r23, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c036:	4d e0       	ldi	r20, 0x0D	; 13
    c038:	50 e0       	ldi	r21, 0x00	; 0
    c03a:	86 e2       	ldi	r24, 0x26	; 38
    c03c:	9c e0       	ldi	r25, 0x0C	; 12
    c03e:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
				GSMTxSz = strlen(GSM_TxStr);
    c042:	e6 e2       	ldi	r30, 0x26	; 38
    c044:	fc e0       	ldi	r31, 0x0C	; 12
    c046:	01 90       	ld	r0, Z+
    c048:	00 20       	and	r0, r0
    c04a:	e9 f7       	brne	.-6      	; 0xc046 <GSM_Cycle+0x10ba>
    c04c:	31 97       	sbiw	r30, 0x01	; 1
    c04e:	e6 52       	subi	r30, 0x26	; 38
    c050:	fc 40       	sbci	r31, 0x0C	; 12
    c052:	e0 93 45 09 	sts	0x0945, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c056:	80 e0       	ldi	r24, 0x00	; 0
		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
    c058:	90 e0       	ldi	r25, 0x00	; 0
				for(uint8_t i=0; i<GSMTxSz; i++)
    c05a:	20 91 45 09 	lds	r18, 0x0945
    c05e:	82 17       	cp	r24, r18
    c060:	50 f4       	brcc	.+20     	; 0xc076 <GSM_Cycle+0x10ea>
					if(GSM_TxStr[i] != '0') j++;
    c062:	e8 2f       	mov	r30, r24
    c064:	f0 e0       	ldi	r31, 0x00	; 0
    c066:	ea 5d       	subi	r30, 0xDA	; 218
    c068:	f3 4f       	sbci	r31, 0xF3	; 243
    c06a:	20 81       	ld	r18, Z
    c06c:	20 33       	cpi	r18, 0x30	; 48
    c06e:	09 f0       	breq	.+2      	; 0xc072 <GSM_Cycle+0x10e6>
    c070:	9f 5f       	subi	r25, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c072:	8f 5f       	subi	r24, 0xFF	; 255
    c074:	f2 cf       	rjmp	.-28     	; 0xc05a <GSM_Cycle+0x10ce>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c076:	99 23       	and	r25, r25
    c078:	09 f4       	brne	.+2      	; 0xc07c <GSM_Cycle+0x10f0>
    c07a:	4b c0       	rjmp	.+150    	; 0xc112 <GSM_Cycle+0x1186>
					GSMTxSz = strlen_P(AT_CMGS);
    c07c:	8a e0       	ldi	r24, 0x0A	; 10
    c07e:	80 93 45 09 	sts	0x0945, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    c082:	81 e3       	ldi	r24, 0x31	; 49
    c084:	9e e4       	ldi	r25, 0x4E	; 78
    c086:	9f 93       	push	r25
    c088:	8f 93       	push	r24
    c08a:	06 e2       	ldi	r16, 0x26	; 38
    c08c:	1c e0       	ldi	r17, 0x0C	; 12
    c08e:	1f 93       	push	r17
    c090:	0f 93       	push	r16
    c092:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    c096:	60 91 e1 03 	lds	r22, 0x03E1
    c09a:	80 91 45 09 	lds	r24, 0x0945
    c09e:	ed e0       	ldi	r30, 0x0D	; 13
    c0a0:	6e 9f       	mul	r22, r30
    c0a2:	b0 01       	movw	r22, r0
    c0a4:	11 24       	eor	r1, r1
    c0a6:	6d 51       	subi	r22, 0x1D	; 29
    c0a8:	7f 4f       	sbci	r23, 0xFF	; 255
    c0aa:	90 e0       	ldi	r25, 0x00	; 0
    c0ac:	4d e0       	ldi	r20, 0x0D	; 13
    c0ae:	50 e0       	ldi	r21, 0x00	; 0
    c0b0:	8a 5d       	subi	r24, 0xDA	; 218
    c0b2:	93 4f       	sbci	r25, 0xF3	; 243
    c0b4:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    c0b8:	d8 01       	movw	r26, r16
    c0ba:	0d 90       	ld	r0, X+
    c0bc:	00 20       	and	r0, r0
    c0be:	e9 f7       	brne	.-6      	; 0xc0ba <GSM_Cycle+0x112e>
    c0c0:	11 97       	sbiw	r26, 0x01	; 1
    c0c2:	a6 52       	subi	r26, 0x26	; 38
    c0c4:	bc 40       	sbci	r27, 0x0C	; 12
    c0c6:	a0 93 45 09 	sts	0x0945, r26
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    c0ca:	80 91 45 09 	lds	r24, 0x0945
    c0ce:	90 e0       	ldi	r25, 0x00	; 0
    c0d0:	6b ec       	ldi	r22, 0xCB	; 203
    c0d2:	71 e0       	ldi	r23, 0x01	; 1
    c0d4:	8a 5d       	subi	r24, 0xDA	; 218
    c0d6:	93 4f       	sbci	r25, 0xF3	; 243
    c0d8:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    c0dc:	f8 01       	movw	r30, r16
    c0de:	01 90       	ld	r0, Z+
    c0e0:	00 20       	and	r0, r0
    c0e2:	e9 f7       	brne	.-6      	; 0xc0de <GSM_Cycle+0x1152>
    c0e4:	31 97       	sbiw	r30, 0x01	; 1
    c0e6:	e6 52       	subi	r30, 0x26	; 38
    c0e8:	fc 40       	sbci	r31, 0x0C	; 12
    c0ea:	e0 93 45 09 	sts	0x0945, r30
					GSM_SendFirstChar();
    c0ee:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c0f2:	64 ef       	ldi	r22, 0xF4	; 244
    c0f4:	71 e0       	ldi	r23, 0x01	; 1
    c0f6:	80 91 54 02 	lds	r24, 0x0254
    c0fa:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					GSM_State++;
    c0fe:	80 91 21 06 	lds	r24, 0x0621
    c102:	8f 5f       	subi	r24, 0xFF	; 255
    c104:	80 93 21 06 	sts	0x0621, r24
    c108:	0f 90       	pop	r0
    c10a:	0f 90       	pop	r0
    c10c:	0f 90       	pop	r0
    c10e:	0f 90       	pop	r0
    c110:	e7 c3       	rjmp	.+1998   	; 0xc8e0 <GSM_Cycle+0x1954>
				}
				else{
					TempNum++;
    c112:	80 91 e1 03 	lds	r24, 0x03E1
    c116:	8f 5f       	subi	r24, 0xFF	; 255
    c118:	80 93 e1 03 	sts	0x03E1, r24
					if(TempNum>=MaxTelephDirSz){
    c11c:	83 30       	cpi	r24, 0x03	; 3
    c11e:	08 f4       	brcc	.+2      	; 0xc122 <GSM_Cycle+0x1196>
    c120:	df c3       	rjmp	.+1982   	; 0xc8e0 <GSM_Cycle+0x1954>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    c122:	81 e3       	ldi	r24, 0x31	; 49
    c124:	80 93 21 06 	sts	0x0621, r24
						SMS_FlgSz_Out = 0;
    c128:	10 92 54 09 	sts	0x0954, r1
    c12c:	d9 c3       	rjmp	.+1970   	; 0xc8e0 <GSM_Cycle+0x1954>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c12e:	68 e5       	ldi	r22, 0x58	; 88
    c130:	8e e3       	ldi	r24, 0x3E	; 62
    c132:	0e 94 1a 3b 	call	0x7634	; 0x7634 <GSM_Wait_Char>
    c136:	88 23       	and	r24, r24
    c138:	09 f4       	brne	.+2      	; 0xc13c <GSM_Cycle+0x11b0>
    c13a:	d2 c3       	rjmp	.+1956   	; 0xc8e0 <GSM_Cycle+0x1954>
    c13c:	80 91 21 06 	lds	r24, 0x0621
    c140:	8f 5f       	subi	r24, 0xFF	; 255
    c142:	80 93 21 06 	sts	0x0621, r24
    c146:	cc c3       	rjmp	.+1944   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c148:	60 91 54 09 	lds	r22, 0x0954
    c14c:	e6 2f       	mov	r30, r22
    c14e:	f0 e0       	ldi	r31, 0x00	; 0
    c150:	e8 53       	subi	r30, 0x38	; 56
    c152:	f7 4f       	sbci	r31, 0xF7	; 247
    c154:	8a e1       	ldi	r24, 0x1A	; 26
    c156:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c158:	6f 5f       	subi	r22, 0xFF	; 255
    c15a:	88 ec       	ldi	r24, 0xC8	; 200
    c15c:	98 e0       	ldi	r25, 0x08	; 8
    c15e:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <GSM_SendData>
			GSM_State++;
    c162:	80 91 21 06 	lds	r24, 0x0621
    c166:	8f 5f       	subi	r24, 0xFF	; 255
    c168:	80 93 21 06 	sts	0x0621, r24
    c16c:	b9 c3       	rjmp	.+1906   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c16e:	68 e5       	ldi	r22, 0x58	; 88
    c170:	84 e1       	ldi	r24, 0x14	; 20
    c172:	9f e4       	ldi	r25, 0x4F	; 79
    c174:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c178:	88 23       	and	r24, r24
    c17a:	09 f4       	brne	.+2      	; 0xc17e <GSM_Cycle+0x11f2>
    c17c:	b1 c3       	rjmp	.+1890   	; 0xc8e0 <GSM_Cycle+0x1954>
				if(++TempNum>=MaxTelephDirSz){
    c17e:	80 91 e1 03 	lds	r24, 0x03E1
    c182:	8f 5f       	subi	r24, 0xFF	; 255
    c184:	80 93 e1 03 	sts	0x03E1, r24
    c188:	83 30       	cpi	r24, 0x03	; 3
    c18a:	30 f0       	brcs	.+12     	; 0xc198 <GSM_Cycle+0x120c>
					GSM_State = GSM_ServerIdle;
    c18c:	81 e3       	ldi	r24, 0x31	; 49
    c18e:	80 93 21 06 	sts	0x0621, r24
					SMS_FlgSz_Out = 0;
    c192:	10 92 54 09 	sts	0x0954, r1
    c196:	a4 c3       	rjmp	.+1864   	; 0xc8e0 <GSM_Cycle+0x1954>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    c198:	88 e3       	ldi	r24, 0x38	; 56
    c19a:	80 93 21 06 	sts	0x0621, r24
    c19e:	a0 c3       	rjmp	.+1856   	; 0xc8e0 <GSM_Cycle+0x1954>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    c1a0:	8a e2       	ldi	r24, 0x2A	; 42
    c1a2:	9d e0       	ldi	r25, 0x0D	; 13
    c1a4:	9f 93       	push	r25
    c1a6:	8f 93       	push	r24
    c1a8:	89 e2       	ldi	r24, 0x29	; 41
    c1aa:	9d e0       	ldi	r25, 0x0D	; 13
    c1ac:	9f 93       	push	r25
    c1ae:	8f 93       	push	r24
    c1b0:	88 e2       	ldi	r24, 0x28	; 40
    c1b2:	9d e0       	ldi	r25, 0x0D	; 13
    c1b4:	9f 93       	push	r25
    c1b6:	8f 93       	push	r24
    c1b8:	87 e2       	ldi	r24, 0x27	; 39
    c1ba:	9d e0       	ldi	r25, 0x0D	; 13
    c1bc:	9f 93       	push	r25
    c1be:	8f 93       	push	r24
    c1c0:	8b e3       	ldi	r24, 0x3B	; 59
    c1c2:	93 e0       	ldi	r25, 0x03	; 3
    c1c4:	9f 93       	push	r25
    c1c6:	8f 93       	push	r24
    c1c8:	86 e7       	ldi	r24, 0x76	; 118
    c1ca:	99 e0       	ldi	r25, 0x09	; 9
    c1cc:	9f 93       	push	r25
    c1ce:	8f 93       	push	r24
    c1d0:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    c1d4:	10 92 e1 03 	sts	0x03E1, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c1d8:	10 91 2a 0d 	lds	r17, 0x0D2A
    c1dc:	70 90 29 0d 	lds	r7, 0x0D29
    c1e0:	60 90 28 0d 	lds	r6, 0x0D28
    c1e4:	50 90 27 0d 	lds	r5, 0x0D27
    c1e8:	00 e1       	ldi	r16, 0x10	; 16
    c1ea:	80 2e       	mov	r8, r16
    c1ec:	01 e0       	ldi	r16, 0x01	; 1
    c1ee:	90 2e       	mov	r9, r16
    c1f0:	0f b6       	in	r0, 0x3f	; 63
    c1f2:	f8 94       	cli
    c1f4:	de bf       	out	0x3e, r29	; 62
    c1f6:	0f be       	out	0x3f, r0	; 63
    c1f8:	cd bf       	out	0x3d, r28	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    c1fa:	0f ef       	ldi	r16, 0xFF	; 255
    c1fc:	2f ef       	ldi	r18, 0xFF	; 255
    c1fe:	4f ef       	ldi	r20, 0xFF	; 255
    c200:	6f ef       	ldi	r22, 0xFF	; 255
    c202:	c4 01       	movw	r24, r8
    c204:	0e 94 9c 39 	call	0x7338	; 0x7338 <IP_E_compare_Const>
    c208:	88 23       	and	r24, r24
    c20a:	21 f0       	breq	.+8      	; 0xc214 <GSM_Cycle+0x1288>
					TempNum = 1;
    c20c:	81 e0       	ldi	r24, 0x01	; 1
    c20e:	80 93 e1 03 	sts	0x03E1, r24
    c212:	1a c0       	rjmp	.+52     	; 0xc248 <GSM_Cycle+0x12bc>
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    c214:	00 e0       	ldi	r16, 0x00	; 0
    c216:	20 e0       	ldi	r18, 0x00	; 0
    c218:	40 e0       	ldi	r20, 0x00	; 0
    c21a:	60 e0       	ldi	r22, 0x00	; 0
    c21c:	c4 01       	movw	r24, r8
    c21e:	0e 94 9c 39 	call	0x7338	; 0x7338 <IP_E_compare_Const>
    c222:	81 11       	cpse	r24, r1
    c224:	09 c0       	rjmp	.+18     	; 0xc238 <GSM_Cycle+0x12ac>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c226:	01 2f       	mov	r16, r17
    c228:	27 2d       	mov	r18, r7
    c22a:	46 2d       	mov	r20, r6
    c22c:	65 2d       	mov	r22, r5
    c22e:	c4 01       	movw	r24, r8
    c230:	0e 94 9c 39 	call	0x7338	; 0x7338 <IP_E_compare_Const>
    c234:	81 11       	cpse	r24, r1
    c236:	ea cf       	rjmp	.-44     	; 0xc20c <GSM_Cycle+0x1280>
    c238:	34 e0       	ldi	r19, 0x04	; 4
    c23a:	83 0e       	add	r8, r19
    c23c:	91 1c       	adc	r9, r1
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    c23e:	80 e2       	ldi	r24, 0x20	; 32
    c240:	88 16       	cp	r8, r24
    c242:	81 e0       	ldi	r24, 0x01	; 1
    c244:	98 06       	cpc	r9, r24
    c246:	c9 f6       	brne	.-78     	; 0xc1fa <GSM_Cycle+0x126e>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    c248:	80 91 e1 03 	lds	r24, 0x03E1
    c24c:	88 23       	and	r24, r24
    c24e:	89 f0       	breq	.+34     	; 0xc272 <GSM_Cycle+0x12e6>
				GSM_State = GSM_ServerIdle;
    c250:	81 e3       	ldi	r24, 0x31	; 49
    c252:	80 93 21 06 	sts	0x0621, r24
				GSM_ActiveConnection = GSM_Temp;
    c256:	80 91 e0 03 	lds	r24, 0x03E0
    c25a:	80 93 07 01 	sts	0x0107, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c25e:	8e e0       	ldi	r24, 0x0E	; 14
    c260:	91 e0       	ldi	r25, 0x01	; 1
    c262:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c266:	bc 01       	movw	r22, r24
    c268:	80 91 53 02 	lds	r24, 0x0253
    c26c:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
    c270:	37 c3       	rjmp	.+1646   	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    c272:	8d e3       	ldi	r24, 0x3D	; 61
    c274:	80 93 21 06 	sts	0x0621, r24
    c278:	33 c3       	rjmp	.+1638   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    c27a:	80 91 08 01 	lds	r24, 0x0108
    c27e:	80 ff       	sbrs	r24, 0
    c280:	2f c3       	rjmp	.+1630   	; 0xc8e0 <GSM_Cycle+0x1954>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    c282:	8f e0       	ldi	r24, 0x0F	; 15
    c284:	80 93 45 09 	sts	0x0945, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    c288:	80 e7       	ldi	r24, 0x70	; 112
    c28a:	9d e4       	ldi	r25, 0x4D	; 77
    c28c:	9f 93       	push	r25
    c28e:	8f 93       	push	r24
    c290:	86 e2       	ldi	r24, 0x26	; 38
    c292:	9c e0       	ldi	r25, 0x0C	; 12
    c294:	9f 93       	push	r25
    c296:	8f 93       	push	r24
    c298:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    c29c:	80 91 45 09 	lds	r24, 0x0945
    c2a0:	90 e0       	ldi	r25, 0x00	; 0
    c2a2:	6c ec       	ldi	r22, 0xCC	; 204
    c2a4:	71 e0       	ldi	r23, 0x01	; 1
    c2a6:	8a 5d       	subi	r24, 0xDA	; 218
    c2a8:	93 4f       	sbci	r25, 0xF3	; 243
    c2aa:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <strcpy>
				GSMTxSz++;
    c2ae:	80 91 45 09 	lds	r24, 0x0945
    c2b2:	8f 5f       	subi	r24, 0xFF	; 255
    c2b4:	80 93 45 09 	sts	0x0945, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    c2b8:	80 91 e0 03 	lds	r24, 0x03E0
    c2bc:	80 5d       	subi	r24, 0xD0	; 208
    c2be:	80 93 32 0c 	sts	0x0C32, r24
				GSM_SendFirstChar();
    c2c2:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c2c6:	64 ef       	ldi	r22, 0xF4	; 244
    c2c8:	71 e0       	ldi	r23, 0x01	; 1
    c2ca:	80 91 54 02 	lds	r24, 0x0254
    c2ce:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State++;
    c2d2:	80 91 21 06 	lds	r24, 0x0621
    c2d6:	8f 5f       	subi	r24, 0xFF	; 255
    c2d8:	80 93 21 06 	sts	0x0621, r24
    c2dc:	0f 90       	pop	r0
    c2de:	0f 90       	pop	r0
    c2e0:	0f 90       	pop	r0
    c2e2:	0f 90       	pop	r0
    c2e4:	fd c2       	rjmp	.+1530   	; 0xc8e0 <GSM_Cycle+0x1954>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c2e6:	80 91 54 02 	lds	r24, 0x0254
    c2ea:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c2ee:	88 23       	and	r24, r24
    c2f0:	19 f0       	breq	.+6      	; 0xc2f8 <GSM_Cycle+0x136c>
    c2f2:	88 e5       	ldi	r24, 0x58	; 88
    c2f4:	80 93 21 06 	sts	0x0621, r24
			if(GetStringFromFIFO()){
    c2f8:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    c2fc:	88 23       	and	r24, r24
    c2fe:	09 f4       	brne	.+2      	; 0xc302 <GSM_Cycle+0x1376>
    c300:	ef c2       	rjmp	.+1502   	; 0xc8e0 <GSM_Cycle+0x1954>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    c302:	67 ec       	ldi	r22, 0xC7	; 199
    c304:	7e e4       	ldi	r23, 0x4E	; 78
    c306:	ce 01       	movw	r24, r28
    c308:	01 96       	adiw	r24, 0x01	; 1
    c30a:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    c30e:	80 91 e0 03 	lds	r24, 0x03E0
    c312:	80 5d       	subi	r24, 0xD0	; 208
    c314:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c316:	68 e5       	ldi	r22, 0x58	; 88
    c318:	ce 01       	movw	r24, r28
    c31a:	01 96       	adiw	r24, 0x01	; 1
    c31c:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <GSM_Wait_Response>
    c320:	88 23       	and	r24, r24
    c322:	09 f4       	brne	.+2      	; 0xc326 <GSM_Cycle+0x139a>
    c324:	dd c2       	rjmp	.+1466   	; 0xc8e0 <GSM_Cycle+0x1954>
					GSM_State = GSM_ServerIdle;
    c326:	81 e3       	ldi	r24, 0x31	; 49
    c328:	80 93 21 06 	sts	0x0621, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    c32c:	80 91 07 01 	lds	r24, 0x0107
    c330:	8f 3f       	cpi	r24, 0xFF	; 255
    c332:	09 f4       	brne	.+2      	; 0xc336 <GSM_Cycle+0x13aa>
    c334:	d5 c2       	rjmp	.+1450   	; 0xc8e0 <GSM_Cycle+0x1954>
    c336:	80 91 53 02 	lds	r24, 0x0253
    c33a:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c33e:	88 23       	and	r24, r24
    c340:	09 f4       	brne	.+2      	; 0xc344 <GSM_Cycle+0x13b8>
    c342:	ce c2       	rjmp	.+1436   	; 0xc8e0 <GSM_Cycle+0x1954>
						GSM_ActiveConnection = NO_CONNECTION;
    c344:	8f ef       	ldi	r24, 0xFF	; 255
    c346:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c34a:	10 92 27 0d 	sts	0x0D27, r1
	IP->IP2 = IP2;
    c34e:	10 92 28 0d 	sts	0x0D28, r1
	IP->IP3 = IP3;
    c352:	10 92 29 0d 	sts	0x0D29, r1
	IP->IP4 = IP4;
    c356:	10 92 2a 0d 	sts	0x0D2A, r1
    c35a:	c2 c2       	rjmp	.+1412   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    c35c:	80 ee       	ldi	r24, 0xE0	; 224
    c35e:	93 e0       	ldi	r25, 0x03	; 3
    c360:	9f 93       	push	r25
    c362:	8f 93       	push	r24
    c364:	ce 01       	movw	r24, r28
    c366:	01 96       	adiw	r24, 0x01	; 1
    c368:	9f 93       	push	r25
    c36a:	8f 93       	push	r24
    c36c:	88 e2       	ldi	r24, 0x28	; 40
    c36e:	93 e0       	ldi	r25, 0x03	; 3
    c370:	9f 93       	push	r25
    c372:	8f 93       	push	r24
    c374:	86 e7       	ldi	r24, 0x76	; 118
    c376:	99 e0       	ldi	r25, 0x09	; 9
    c378:	9f 93       	push	r25
    c37a:	8f 93       	push	r24
    c37c:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    c380:	0f b6       	in	r0, 0x3f	; 63
    c382:	f8 94       	cli
    c384:	de bf       	out	0x3e, r29	; 62
    c386:	0f be       	out	0x3f, r0	; 63
    c388:	cd bf       	out	0x3d, r28	; 61
    c38a:	99 81       	ldd	r25, Y+1	; 0x01
    c38c:	80 91 07 01 	lds	r24, 0x0107
    c390:	98 13       	cpse	r25, r24
    c392:	0c c0       	rjmp	.+24     	; 0xc3ac <GSM_Cycle+0x1420>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c394:	64 ef       	ldi	r22, 0xF4	; 244
    c396:	71 e0       	ldi	r23, 0x01	; 1
    c398:	80 91 54 02 	lds	r24, 0x0254
    c39c:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					GSM_State++;
    c3a0:	80 91 21 06 	lds	r24, 0x0621
    c3a4:	8f 5f       	subi	r24, 0xFF	; 255
    c3a6:	80 93 21 06 	sts	0x0621, r24
    c3aa:	9a c2       	rjmp	.+1332   	; 0xc8e0 <GSM_Cycle+0x1954>
					break;
				}
				GSM_State = GSM_ServerIdle;
    c3ac:	81 e3       	ldi	r24, 0x31	; 49
    c3ae:	80 93 21 06 	sts	0x0621, r24
    c3b2:	96 c2       	rjmp	.+1324   	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    c3b4:	80 91 54 02 	lds	r24, 0x0254
    c3b8:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c3bc:	88 23       	and	r24, r24
    c3be:	19 f0       	breq	.+6      	; 0xc3c6 <GSM_Cycle+0x143a>
    c3c0:	88 e5       	ldi	r24, 0x58	; 88
    c3c2:	80 93 21 06 	sts	0x0621, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    c3c6:	80 91 e0 03 	lds	r24, 0x03E0
    c3ca:	80 93 4b 09 	sts	0x094B, r24

			GSM_State = GSM_ServerIdle;
    c3ce:	81 e3       	ldi	r24, 0x31	; 49
    c3d0:	80 93 21 06 	sts	0x0621, r24
    c3d4:	85 c2       	rjmp	.+1290   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c3d6:	60 e7       	ldi	r22, 0x70	; 112
    c3d8:	77 e1       	ldi	r23, 0x17	; 23
    c3da:	82 e6       	ldi	r24, 0x62	; 98
    c3dc:	9d e4       	ldi	r25, 0x4D	; 77
    c3de:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c3e2:	80 91 21 06 	lds	r24, 0x0621
    c3e6:	8f 5f       	subi	r24, 0xFF	; 255
    c3e8:	80 93 21 06 	sts	0x0621, r24
    c3ec:	79 c2       	rjmp	.+1266   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c3ee:	80 91 54 02 	lds	r24, 0x0254
    c3f2:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c3f6:	88 23       	and	r24, r24
    c3f8:	19 f0       	breq	.+6      	; 0xc400 <GSM_Cycle+0x1474>
    c3fa:	88 e5       	ldi	r24, 0x58	; 88
    c3fc:	80 93 21 06 	sts	0x0621, r24
			//  
			if(GetStringFromFIFO()){
    c400:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    c404:	88 23       	and	r24, r24
    c406:	09 f4       	brne	.+2      	; 0xc40a <GSM_Cycle+0x147e>
    c408:	6b c2       	rjmp	.+1238   	; 0xc8e0 <GSM_Cycle+0x1954>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
    c40a:	63 ed       	ldi	r22, 0xD3	; 211
    c40c:	7e e4       	ldi	r23, 0x4E	; 78
    c40e:	86 e7       	ldi	r24, 0x76	; 118
    c410:	99 e0       	ldi	r25, 0x09	; 9
    c412:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    c416:	89 2b       	or	r24, r25
    c418:	49 f0       	breq	.+18     	; 0xc42c <GSM_Cycle+0x14a0>
    c41a:	64 e3       	ldi	r22, 0x34	; 52
    c41c:	7f e4       	ldi	r23, 0x4F	; 79
    c41e:	86 e7       	ldi	r24, 0x76	; 118
    c420:	99 e0       	ldi	r25, 0x09	; 9
    c422:	0e 94 dc 6b 	call	0xd7b8	; 0xd7b8 <strcmp_P>
    c426:	89 2b       	or	r24, r25
    c428:	09 f0       	breq	.+2      	; 0xc42c <GSM_Cycle+0x14a0>
    c42a:	5a c2       	rjmp	.+1204   	; 0xc8e0 <GSM_Cycle+0x1954>
					GSM_State = GSM_ServerIdle;
    c42c:	81 e3       	ldi	r24, 0x31	; 49
    c42e:	80 93 21 06 	sts	0x0621, r24
					GPRS_FlgSz_Out = 0;						
    c432:	10 92 31 09 	sts	0x0931, r1
    c436:	54 c2       	rjmp	.+1192   	; 0xc8e0 <GSM_Cycle+0x1954>
		//------------------------

		/*NEW COMMIT*/
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
    c438:	0e 94 9b 2e 	call	0x5d36	; 0x5d36 <GSM_PWRCNTRL_OFF>
			StartTimer16(TD_GSM,1000);
    c43c:	68 ee       	ldi	r22, 0xE8	; 232
    c43e:	73 e0       	ldi	r23, 0x03	; 3
    c440:	80 91 54 02 	lds	r24, 0x0254
    c444:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			RxBufOverFlow = 0;
    c448:	10 92 26 0d 	sts	0x0D26, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
    c44c:	10 92 54 09 	sts	0x0954, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c450:	8f ef       	ldi	r24, 0xFF	; 255
    c452:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c456:	10 92 27 0d 	sts	0x0D27, r1
	IP->IP2 = IP2;
    c45a:	10 92 28 0d 	sts	0x0D28, r1
	IP->IP3 = IP3;
    c45e:	10 92 29 0d 	sts	0x0D29, r1
	IP->IP4 = IP4;
    c462:	10 92 2a 0d 	sts	0x0D2A, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c466:	80 91 08 01 	lds	r24, 0x0108
    c46a:	81 60       	ori	r24, 0x01	; 1
    c46c:	80 93 08 01 	sts	0x0108, r24
			GSM_State++;
    c470:	80 91 21 06 	lds	r24, 0x0621
    c474:	8f 5f       	subi	r24, 0xFF	; 255
    c476:	80 93 21 06 	sts	0x0621, r24
    c47a:	32 c2       	rjmp	.+1124   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c47c:	80 91 54 02 	lds	r24, 0x0254
    c480:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c484:	88 23       	and	r24, r24
    c486:	09 f4       	brne	.+2      	; 0xc48a <GSM_Cycle+0x14fe>
    c488:	2b c2       	rjmp	.+1110   	; 0xc8e0 <GSM_Cycle+0x1954>
				GSM_State = GSM_PowerOn;
    c48a:	10 92 21 06 	sts	0x0621, r1
    c48e:	28 c2       	rjmp	.+1104   	; 0xc8e0 <GSM_Cycle+0x1954>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
    c490:	64 ef       	ldi	r22, 0xF4	; 244
    c492:	71 e0       	ldi	r23, 0x01	; 1
    c494:	8d e9       	ldi	r24, 0x9D	; 157
    c496:	9d e4       	ldi	r25, 0x4D	; 77
    c498:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c49c:	80 91 21 06 	lds	r24, 0x0621
    c4a0:	8f 5f       	subi	r24, 0xFF	; 255
    c4a2:	80 93 21 06 	sts	0x0621, r24
    c4a6:	1c c2       	rjmp	.+1080   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c4a8:	68 e5       	ldi	r22, 0x58	; 88
    c4aa:	84 e1       	ldi	r24, 0x14	; 20
    c4ac:	9f e4       	ldi	r25, 0x4F	; 79
    c4ae:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c4b2:	88 23       	and	r24, r24
    c4b4:	09 f4       	brne	.+2      	; 0xc4b8 <GSM_Cycle+0x152c>
    c4b6:	14 c2       	rjmp	.+1064   	; 0xc8e0 <GSM_Cycle+0x1954>
    c4b8:	80 91 21 06 	lds	r24, 0x0621
    c4bc:	8f 5f       	subi	r24, 0xFF	; 255
    c4be:	80 93 21 06 	sts	0x0621, r24
    c4c2:	0e c2       	rjmp	.+1052   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
    c4c4:	68 e5       	ldi	r22, 0x58	; 88
    c4c6:	87 ee       	ldi	r24, 0xE7	; 231
    c4c8:	9e e4       	ldi	r25, 0x4E	; 78
    c4ca:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c4ce:	88 23       	and	r24, r24
    c4d0:	09 f4       	brne	.+2      	; 0xc4d4 <GSM_Cycle+0x1548>
    c4d2:	06 c2       	rjmp	.+1036   	; 0xc8e0 <GSM_Cycle+0x1954>
    c4d4:	8e e2       	ldi	r24, 0x2E	; 46
    c4d6:	80 93 21 06 	sts	0x0621, r24
    c4da:	02 c2       	rjmp	.+1028   	; 0xc8e0 <GSM_Cycle+0x1954>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c4dc:	64 ef       	ldi	r22, 0xF4	; 244
    c4de:	71 e0       	ldi	r23, 0x01	; 1
    c4e0:	85 e4       	ldi	r24, 0x45	; 69
    c4e2:	9d e4       	ldi	r25, 0x4D	; 77
    c4e4:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
    c4e8:	60 e7       	ldi	r22, 0x70	; 112
    c4ea:	77 e1       	ldi	r23, 0x17	; 23
    c4ec:	80 91 52 02 	lds	r24, 0x0252
    c4f0:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			GSM_State = GSM_ServerIdle;
    c4f4:	81 e3       	ldi	r24, 0x31	; 49
    c4f6:	80 93 21 06 	sts	0x0621, r24
    c4fa:	f2 c1       	rjmp	.+996    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
    c4fc:	8f ef       	ldi	r24, 0xFF	; 255
    c4fe:	80 93 1f 06 	sts	0x061F, r24
    c502:	80 93 59 09 	sts	0x0959, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    c506:	89 e5       	ldi	r24, 0x59	; 89
    c508:	99 e0       	ldi	r25, 0x09	; 9
    c50a:	9f 93       	push	r25
    c50c:	8f 93       	push	r24
    c50e:	8f e1       	ldi	r24, 0x1F	; 31
    c510:	96 e0       	ldi	r25, 0x06	; 6
    c512:	9f 93       	push	r25
    c514:	8f 93       	push	r24
    c516:	88 e1       	ldi	r24, 0x18	; 24
    c518:	93 e0       	ldi	r25, 0x03	; 3
    c51a:	9f 93       	push	r25
    c51c:	8f 93       	push	r24
    c51e:	86 e7       	ldi	r24, 0x76	; 118
    c520:	99 e0       	ldi	r25, 0x09	; 9
    c522:	9f 93       	push	r25
    c524:	8f 93       	push	r24
    c526:	0e 94 e3 6c 	call	0xd9c6	; 0xd9c6 <sscanf_P>
			GSM_State = GSM_ServerIdle;
    c52a:	81 e3       	ldi	r24, 0x31	; 49
    c52c:	80 93 21 06 	sts	0x0621, r24
    c530:	0f b6       	in	r0, 0x3f	; 63
    c532:	f8 94       	cli
    c534:	de bf       	out	0x3e, r29	; 62
    c536:	0f be       	out	0x3f, r0	; 63
    c538:	cd bf       	out	0x3d, r28	; 61
    c53a:	d2 c1       	rjmp	.+932    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			Transparent_Application_state = WAIT_REQUEST;
    c53c:	81 e0       	ldi	r24, 0x01	; 1
    c53e:	80 93 40 09 	sts	0x0940, r24
			Transparent = 1;
    c542:	80 93 63 0a 	sts	0x0A63, r24
			if(Timer16Stopp(GPRS_RECONNECT_timer)){
    c546:	80 91 05 06 	lds	r24, 0x0605
    c54a:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c54e:	88 23       	and	r24, r24
    c550:	49 f0       	breq	.+18     	; 0xc564 <GSM_Cycle+0x15d8>
				GSM_State = GSM_Swtch2CommandMode;
    c552:	81 e6       	ldi	r24, 0x61	; 97
    c554:	80 93 21 06 	sts	0x0621, r24
				Transparent_Application_state = RECONNECT;
    c558:	82 e0       	ldi	r24, 0x02	; 2
    c55a:	80 93 40 09 	sts	0x0940, r24
				Transparent = 0;
    c55e:	10 92 63 0a 	sts	0x0A63, r1
    c562:	be c1       	rjmp	.+892    	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}
			if(Timer16Stopp(TCP_CONNECT_check_timer)){
    c564:	80 91 2d 0d 	lds	r24, 0x0D2D
    c568:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c56c:	88 23       	and	r24, r24
    c56e:	09 f4       	brne	.+2      	; 0xc572 <GSM_Cycle+0x15e6>
    c570:	b7 c1       	rjmp	.+878    	; 0xc8e0 <GSM_Cycle+0x1954>
				GSM_State = GSM_Swtch2CommandMode;
    c572:	81 e6       	ldi	r24, 0x61	; 97
    c574:	80 93 21 06 	sts	0x0621, r24
				Transparent_Application_state = CHECK_CONNECTION_STATE;
    c578:	83 e0       	ldi	r24, 0x03	; 3
    c57a:	80 93 40 09 	sts	0x0940, r24
				Transparent = 0;
    c57e:	10 92 63 0a 	sts	0x0A63, r1
    c582:	ae c1       	rjmp	.+860    	; 0xc8e0 <GSM_Cycle+0x1954>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c584:	90 91 75 08 	lds	r25, 0x0875
    c588:	80 91 ff 05 	lds	r24, 0x05FF
    c58c:	98 17       	cp	r25, r24
    c58e:	49 f0       	breq	.+18     	; 0xc5a2 <GSM_Cycle+0x1616>
    c590:	8e e0       	ldi	r24, 0x0E	; 14
    c592:	91 e0       	ldi	r25, 0x01	; 1
    c594:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c598:	bc 01       	movw	r22, r24
    c59a:	80 91 53 02 	lds	r24, 0x0253
    c59e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
    c5a2:	80 91 e1 09 	lds	r24, 0x09E1
    c5a6:	81 30       	cpi	r24, 0x01	; 1
    c5a8:	71 f1       	breq	.+92     	; 0xc606 <GSM_Cycle+0x167a>
				if(GetStringFromFIFO()){
    c5aa:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    c5ae:	88 23       	and	r24, r24
    c5b0:	51 f1       	breq	.+84     	; 0xc606 <GSM_Cycle+0x167a>
								
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c5b2:	64 e3       	ldi	r22, 0x34	; 52
    c5b4:	7f e4       	ldi	r23, 0x4F	; 79
    c5b6:	86 e7       	ldi	r24, 0x76	; 118
    c5b8:	99 e0       	ldi	r25, 0x09	; 9
    c5ba:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    c5be:	89 2b       	or	r24, r25
    c5c0:	31 f0       	breq	.+12     	; 0xc5ce <GSM_Cycle+0x1642>
						GSM_State = GSM_ServerIdle;
    c5c2:	81 e3       	ldi	r24, 0x31	; 49
    c5c4:	80 93 21 06 	sts	0x0621, r24
						GSM_CloseTransparent();
    c5c8:	0e 94 a6 4b 	call	0x974c	; 0x974c <GSM_CloseTransparent>
    c5cc:	89 c1       	rjmp	.+786    	; 0xc8e0 <GSM_Cycle+0x1954>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
    c5ce:	67 e1       	ldi	r22, 0x17	; 23
    c5d0:	7f e4       	ldi	r23, 0x4F	; 79
    c5d2:	86 e7       	ldi	r24, 0x76	; 118
    c5d4:	99 e0       	ldi	r25, 0x09	; 9
    c5d6:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    c5da:	89 2b       	or	r24, r25
    c5dc:	31 f0       	breq	.+12     	; 0xc5ea <GSM_Cycle+0x165e>
						GSM_State = GSM_ServerIdle;
    c5de:	81 e3       	ldi	r24, 0x31	; 49
    c5e0:	80 93 21 06 	sts	0x0621, r24
						GSM_CloseTransparent();
    c5e4:	0e 94 a6 4b 	call	0x974c	; 0x974c <GSM_CloseTransparent>
    c5e8:	7b c1       	rjmp	.+758    	; 0xc8e0 <GSM_Cycle+0x1954>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    c5ea:	67 e2       	ldi	r22, 0x27	; 39
    c5ec:	7f e4       	ldi	r23, 0x4F	; 79
    c5ee:	86 e7       	ldi	r24, 0x76	; 118
    c5f0:	99 e0       	ldi	r25, 0x09	; 9
    c5f2:	0e 94 17 6c 	call	0xd82e	; 0xd82e <strstr_P>
    c5f6:	89 2b       	or	r24, r25
    c5f8:	31 f0       	breq	.+12     	; 0xc606 <GSM_Cycle+0x167a>
						GSM_State = GSM_SEND_E0;
    c5fa:	88 e0       	ldi	r24, 0x08	; 8
    c5fc:	80 93 21 06 	sts	0x0621, r24
						GSM_CloseTransparent();
    c600:	0e 94 a6 4b 	call	0x974c	; 0x974c <GSM_CloseTransparent>
    c604:	6d c1       	rjmp	.+730    	; 0xc8e0 <GSM_Cycle+0x1954>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    c606:	80 91 53 02 	lds	r24, 0x0253
    c60a:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c60e:	88 23       	and	r24, r24
    c610:	09 f4       	brne	.+2      	; 0xc614 <GSM_Cycle+0x1688>
    c612:	66 c1       	rjmp	.+716    	; 0xc8e0 <GSM_Cycle+0x1954>
				GSM_State = GSM_Swtch2CommandMode;
    c614:	81 e6       	ldi	r24, 0x61	; 97
    c616:	80 93 21 06 	sts	0x0621, r24
				GSM_CloseTransparent();
    c61a:	0e 94 a6 4b 	call	0x974c	; 0x974c <GSM_CloseTransparent>
    c61e:	60 c1       	rjmp	.+704    	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}
			break;

		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
    c620:	6e e6       	ldi	r22, 0x6E	; 110
    c622:	70 e0       	ldi	r23, 0x00	; 0
    c624:	80 91 54 02 	lds	r24, 0x0254
    c628:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			//WebClose();
			GSM_State++;
    c62c:	80 91 21 06 	lds	r24, 0x0621
    c630:	8f 5f       	subi	r24, 0xFF	; 255
    c632:	80 93 21 06 	sts	0x0621, r24
    c636:	54 c1       	rjmp	.+680    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c638:	80 91 54 02 	lds	r24, 0x0254
    c63c:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c640:	88 23       	and	r24, r24
    c642:	09 f4       	brne	.+2      	; 0xc646 <GSM_Cycle+0x16ba>
    c644:	4d c1       	rjmp	.+666    	; 0xc8e0 <GSM_Cycle+0x1954>
						if(GSM_Flag & (1<<flg_TxCStr)){
    c646:	80 91 08 01 	lds	r24, 0x0108
    c64a:	80 ff       	sbrs	r24, 0
    c64c:	49 c1       	rjmp	.+658    	; 0xc8e0 <GSM_Cycle+0x1954>
							GSMTxSz = strlen_P(ESC_SEQ);
    c64e:	83 e0       	ldi	r24, 0x03	; 3
    c650:	80 93 45 09 	sts	0x0945, r24
							sprintf_P(GSM_TxStr, ESC_SEQ);
    c654:	86 e9       	ldi	r24, 0x96	; 150
    c656:	9e e4       	ldi	r25, 0x4E	; 78
    c658:	9f 93       	push	r25
    c65a:	8f 93       	push	r24
    c65c:	86 e2       	ldi	r24, 0x26	; 38
    c65e:	9c e0       	ldi	r25, 0x0C	; 12
    c660:	9f 93       	push	r25
    c662:	8f 93       	push	r24
    c664:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
							GSM_SendFirstChar();
    c668:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c66c:	64 ef       	ldi	r22, 0xF4	; 244
    c66e:	71 e0       	ldi	r23, 0x01	; 1
    c670:	80 91 54 02 	lds	r24, 0x0254
    c674:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
							GSM_State++;
    c678:	80 91 21 06 	lds	r24, 0x0621
    c67c:	8f 5f       	subi	r24, 0xFF	; 255
    c67e:	80 93 21 06 	sts	0x0621, r24
    c682:	0f 90       	pop	r0
    c684:	0f 90       	pop	r0
    c686:	0f 90       	pop	r0
    c688:	0f 90       	pop	r0
    c68a:	2a c1       	rjmp	.+596    	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;*/
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c68c:	68 e5       	ldi	r22, 0x58	; 88
    c68e:	84 e1       	ldi	r24, 0x14	; 20
    c690:	9f e4       	ldi	r25, 0x4F	; 79
    c692:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c696:	88 23       	and	r24, r24
    c698:	09 f4       	brne	.+2      	; 0xc69c <GSM_Cycle+0x1710>
    c69a:	22 c1       	rjmp	.+580    	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    c69c:	6f ef       	ldi	r22, 0xFF	; 255
    c69e:	7f ef       	ldi	r23, 0xFF	; 255
    c6a0:	80 91 53 02 	lds	r24, 0x0253
    c6a4:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				/*if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
				else GSM_State = GSM_SEND_CIPCLOSE;*/
				switch(Transparent_Application_state){
    c6a8:	80 91 40 09 	lds	r24, 0x0940
    c6ac:	82 30       	cpi	r24, 0x02	; 2
    c6ae:	41 f0       	breq	.+16     	; 0xc6c0 <GSM_Cycle+0x1734>
    c6b0:	83 30       	cpi	r24, 0x03	; 3
    c6b2:	51 f4       	brne	.+20     	; 0xc6c8 <GSM_Cycle+0x173c>
					case CHECK_CONNECTION_STATE:
						GSM_State = GSM_SEND_CIPSTATUS;
    c6b4:	87 e2       	ldi	r24, 0x27	; 39
    c6b6:	80 93 21 06 	sts	0x0621, r24
						InitFIFO();
    c6ba:	0e 94 cc 39 	call	0x7398	; 0x7398 <InitFIFO>
    c6be:	10 c1       	rjmp	.+544    	; 0xc8e0 <GSM_Cycle+0x1954>
						break;
					case RECONNECT:
						GSM_State = GSM_CIPSHUT_;
    c6c0:	82 e5       	ldi	r24, 0x52	; 82
    c6c2:	80 93 21 06 	sts	0x0621, r24
    c6c6:	0c c1       	rjmp	.+536    	; 0xc8e0 <GSM_Cycle+0x1954>
						break;
					default:GSM_State = GSM_ReStart1;
    c6c8:	88 e5       	ldi	r24, 0x58	; 88
    c6ca:	80 93 21 06 	sts	0x0621, r24
    c6ce:	08 c1       	rjmp	.+528    	; 0xc8e0 <GSM_Cycle+0x1954>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
    c6d0:	80 91 54 02 	lds	r24, 0x0254
    c6d4:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c6d8:	88 23       	and	r24, r24
    c6da:	19 f0       	breq	.+6      	; 0xc6e2 <GSM_Cycle+0x1756>
    c6dc:	87 e6       	ldi	r24, 0x67	; 103
    c6de:	80 93 21 06 	sts	0x0621, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c6e2:	8f e5       	ldi	r24, 0x5F	; 95
    c6e4:	90 e0       	ldi	r25, 0x00	; 0
    c6e6:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
    c6ea:	81 11       	cpse	r24, r1
    c6ec:	04 c0       	rjmp	.+8      	; 0xc6f6 <GSM_Cycle+0x176a>
				GSM_State = GSM_SEND_ATA;
    c6ee:	85 e6       	ldi	r24, 0x65	; 101
    c6f0:	80 93 21 06 	sts	0x0621, r24
    c6f4:	f5 c0       	rjmp	.+490    	; 0xc8e0 <GSM_Cycle+0x1954>
				break;
			}
			if(GetStringFromFIFO() > 25){
    c6f6:	0e 94 33 3a 	call	0x7466	; 0x7466 <GetStringFromFIFO>
    c6fa:	8a 31       	cpi	r24, 0x1A	; 26
    c6fc:	08 f4       	brcc	.+2      	; 0xc700 <GSM_Cycle+0x1774>
    c6fe:	f0 c0       	rjmp	.+480    	; 0xc8e0 <GSM_Cycle+0x1954>
				char *qoute_open = strchr(GSM_RxStr,'"');
    c700:	62 e2       	ldi	r22, 0x22	; 34
    c702:	70 e0       	ldi	r23, 0x00	; 0
    c704:	86 e7       	ldi	r24, 0x76	; 118
    c706:	99 e0       	ldi	r25, 0x09	; 9
    c708:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
    c70c:	4c 01       	movw	r8, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
    c70e:	62 e2       	ldi	r22, 0x22	; 34
    c710:	70 e0       	ldi	r23, 0x00	; 0
    c712:	01 96       	adiw	r24, 0x01	; 1
    c714:	0e 94 3a 6c 	call	0xd874	; 0xd874 <strchr>
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
    c718:	81 14       	cp	r8, r1
    c71a:	91 04       	cpc	r9, r1
    c71c:	11 f0       	breq	.+4      	; 0xc722 <GSM_Cycle+0x1796>
    c71e:	00 97       	sbiw	r24, 0x00	; 0
    c720:	21 f4       	brne	.+8      	; 0xc72a <GSM_Cycle+0x179e>
					GSM_State = GSM_SEND_ATH;
    c722:	87 e6       	ldi	r24, 0x67	; 103
    c724:	80 93 21 06 	sts	0x0621, r24
    c728:	db c0       	rjmp	.+438    	; 0xc8e0 <GSM_Cycle+0x1954>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
    c72a:	fc 01       	movw	r30, r24
    c72c:	10 82       	st	Z, r1
    c72e:	01 e6       	ldi	r16, 0x61	; 97
    c730:	10 e0       	ldi	r17, 0x00	; 0
				for(uint8_t i = 0; i<10; i++){
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
    c732:	f2 e0       	ldi	r31, 0x02	; 2
    c734:	8f 0e       	add	r8, r31
    c736:	91 1c       	adc	r9, r1
    c738:	b7 e6       	ldi	r27, 0x67	; 103
    c73a:	7b 2e       	mov	r7, r27
    c73c:	b8 01       	movw	r22, r16
    c73e:	c4 01       	movw	r24, r8
    c740:	0e 94 3e 47 	call	0x8e7c	; 0x8e7c <strcmp_E>
    c744:	88 23       	and	r24, r24
    c746:	49 f0       	breq	.+18     	; 0xc75a <GSM_Cycle+0x17ce>
    c748:	70 92 21 06 	sts	0x0621, r7
    c74c:	03 5f       	subi	r16, 0xF3	; 243
    c74e:	1f 4f       	sbci	r17, 0xFF	; 255
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
    c750:	20 e0       	ldi	r18, 0x00	; 0
    c752:	03 3e       	cpi	r16, 0xE3	; 227
    c754:	12 07       	cpc	r17, r18
    c756:	91 f7       	brne	.-28     	; 0xc73c <GSM_Cycle+0x17b0>
    c758:	c3 c0       	rjmp	.+390    	; 0xc8e0 <GSM_Cycle+0x1954>
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
    c75a:	85 e6       	ldi	r24, 0x65	; 101
    c75c:	80 93 21 06 	sts	0x0621, r24
    c760:	bf c0       	rjmp	.+382    	; 0xc8e0 <GSM_Cycle+0x1954>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c762:	60 e7       	ldi	r22, 0x70	; 112
    c764:	77 e1       	ldi	r23, 0x17	; 23
    c766:	81 e4       	ldi	r24, 0x41	; 65
    c768:	9d e4       	ldi	r25, 0x4D	; 77
    c76a:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c76e:	80 91 21 06 	lds	r24, 0x0621
    c772:	8f 5f       	subi	r24, 0xFF	; 255
    c774:	80 93 21 06 	sts	0x0621, r24
    c778:	b3 c0       	rjmp	.+358    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
    c77a:	67 e6       	ldi	r22, 0x67	; 103
    c77c:	8c ea       	ldi	r24, 0xAC	; 172
    c77e:	9e e4       	ldi	r25, 0x4E	; 78
    c780:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c784:	88 23       	and	r24, r24
    c786:	09 f4       	brne	.+2      	; 0xc78a <GSM_Cycle+0x17fe>
    c788:	ab c0       	rjmp	.+342    	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_TCP_Connect, 500);	//   
    c78a:	64 ef       	ldi	r22, 0xF4	; 244
    c78c:	71 e0       	ldi	r23, 0x01	; 1
    c78e:	80 91 53 02 	lds	r24, 0x0253
    c792:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_CSD = 1;
    c796:	81 e0       	ldi	r24, 0x01	; 1
    c798:	80 93 39 09 	sts	0x0939, r24
				GSM_State = GSM_ProtocolMode;
    c79c:	8f e5       	ldi	r24, 0x5F	; 95
    c79e:	80 93 21 06 	sts	0x0621, r24
    c7a2:	9e c0       	rjmp	.+316    	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
    c7a4:	6c e2       	ldi	r22, 0x2C	; 44
    c7a6:	71 e0       	ldi	r23, 0x01	; 1
    c7a8:	8d e3       	ldi	r24, 0x3D	; 61
    c7aa:	9d e4       	ldi	r25, 0x4D	; 77
    c7ac:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c7b0:	80 91 21 06 	lds	r24, 0x0621
    c7b4:	8f 5f       	subi	r24, 0xFF	; 255
    c7b6:	80 93 21 06 	sts	0x0621, r24
    c7ba:	92 c0       	rjmp	.+292    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    c7bc:	68 e5       	ldi	r22, 0x58	; 88
    c7be:	84 e1       	ldi	r24, 0x14	; 20
    c7c0:	9f e4       	ldi	r25, 0x4F	; 79
    c7c2:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c7c6:	88 23       	and	r24, r24
    c7c8:	09 f4       	brne	.+2      	; 0xc7cc <GSM_Cycle+0x1840>
    c7ca:	8a c0       	rjmp	.+276    	; 0xc8e0 <GSM_Cycle+0x1954>
    c7cc:	81 e3       	ldi	r24, 0x31	; 49
    c7ce:	80 93 21 06 	sts	0x0621, r24
    c7d2:	86 c0       	rjmp	.+268    	; 0xc8e0 <GSM_Cycle+0x1954>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c7d4:	80 91 21 06 	lds	r24, 0x0621
    c7d8:	90 e0       	ldi	r25, 0x00	; 0
    c7da:	89 30       	cpi	r24, 0x09	; 9
    c7dc:	91 05       	cpc	r25, r1
    c7de:	08 f0       	brcs	.+2      	; 0xc7e2 <GSM_Cycle+0x1856>
    c7e0:	7d c0       	rjmp	.+250    	; 0xc8dc <GSM_Cycle+0x1950>
    c7e2:	fc 01       	movw	r30, r24
    c7e4:	e7 5c       	subi	r30, 0xC7	; 199
    c7e6:	fe 4f       	sbci	r31, 0xFE	; 254
    c7e8:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c7ec:	68 ec       	ldi	r22, 0xC8	; 200
    c7ee:	70 e0       	ldi	r23, 0x00	; 0
    c7f0:	80 91 54 02 	lds	r24, 0x0254
    c7f4:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
			GSM_PWRCNTRL_ON();
    c7f8:	0e 94 9f 2e 	call	0x5d3e	; 0x5d3e <GSM_PWRCNTRL_ON>
			GSM_State++;
    c7fc:	80 91 21 06 	lds	r24, 0x0621
    c800:	8f 5f       	subi	r24, 0xFF	; 255
    c802:	80 93 21 06 	sts	0x0621, r24
    c806:	6c c0       	rjmp	.+216    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    c808:	80 91 54 02 	lds	r24, 0x0254
    c80c:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c810:	88 23       	and	r24, r24
    c812:	31 f0       	breq	.+12     	; 0xc820 <GSM_Cycle+0x1894>
    c814:	64 e6       	ldi	r22, 0x64	; 100
    c816:	70 e0       	ldi	r23, 0x00	; 0
    c818:	89 e8       	ldi	r24, 0x89	; 137
    c81a:	9e e4       	ldi	r25, 0x4E	; 78
    c81c:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c820:	80 91 21 06 	lds	r24, 0x0621
    c824:	8f 5f       	subi	r24, 0xFF	; 255
    c826:	80 93 21 06 	sts	0x0621, r24
    c82a:	5a c0       	rjmp	.+180    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    c82c:	61 e0       	ldi	r22, 0x01	; 1
    c82e:	84 e1       	ldi	r24, 0x14	; 20
    c830:	9f e4       	ldi	r25, 0x4F	; 79
    c832:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c836:	88 23       	and	r24, r24
    c838:	09 f4       	brne	.+2      	; 0xc83c <GSM_Cycle+0x18b0>
    c83a:	52 c0       	rjmp	.+164    	; 0xc8e0 <GSM_Cycle+0x1954>
    c83c:	80 91 21 06 	lds	r24, 0x0621
    c840:	8f 5f       	subi	r24, 0xFF	; 255
    c842:	80 93 21 06 	sts	0x0621, r24
    c846:	4c c0       	rjmp	.+152    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c848:	64 e6       	ldi	r22, 0x64	; 100
    c84a:	70 e0       	ldi	r23, 0x00	; 0
    c84c:	8d e7       	ldi	r24, 0x7D	; 125
    c84e:	9e e4       	ldi	r25, 0x4E	; 78
    c850:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c854:	80 91 21 06 	lds	r24, 0x0621
    c858:	8f 5f       	subi	r24, 0xFF	; 255
    c85a:	80 93 21 06 	sts	0x0621, r24
    c85e:	40 c0       	rjmp	.+128    	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c860:	61 e0       	ldi	r22, 0x01	; 1
    c862:	84 e1       	ldi	r24, 0x14	; 20
    c864:	9f e4       	ldi	r25, 0x4F	; 79
    c866:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c86a:	88 23       	and	r24, r24
    c86c:	c9 f1       	breq	.+114    	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_GSM,200);
    c86e:	68 ec       	ldi	r22, 0xC8	; 200
    c870:	70 e0       	ldi	r23, 0x00	; 0
    c872:	80 91 54 02 	lds	r24, 0x0254
    c876:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State++;
    c87a:	80 91 21 06 	lds	r24, 0x0621
    c87e:	8f 5f       	subi	r24, 0xFF	; 255
    c880:	80 93 21 06 	sts	0x0621, r24
    c884:	2d c0       	rjmp	.+90     	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c886:	64 e6       	ldi	r22, 0x64	; 100
    c888:	70 e0       	ldi	r23, 0x00	; 0
    c88a:	88 e7       	ldi	r24, 0x78	; 120
    c88c:	9e e4       	ldi	r25, 0x4E	; 78
    c88e:	0e 94 92 57 	call	0xaf24	; 0xaf24 <GSM_Execute_Command>
    c892:	80 91 21 06 	lds	r24, 0x0621
    c896:	8f 5f       	subi	r24, 0xFF	; 255
    c898:	80 93 21 06 	sts	0x0621, r24
    c89c:	21 c0       	rjmp	.+66     	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c89e:	61 e0       	ldi	r22, 0x01	; 1
    c8a0:	84 e1       	ldi	r24, 0x14	; 20
    c8a2:	9f e4       	ldi	r25, 0x4F	; 79
    c8a4:	0e 94 f1 3a 	call	0x75e2	; 0x75e2 <GSM_Wait_Response_P>
    c8a8:	88 23       	and	r24, r24
    c8aa:	d1 f0       	breq	.+52     	; 0xc8e0 <GSM_Cycle+0x1954>
				StartTimer16(TD_GSM,200);
    c8ac:	68 ec       	ldi	r22, 0xC8	; 200
    c8ae:	70 e0       	ldi	r23, 0x00	; 0
    c8b0:	80 91 54 02 	lds	r24, 0x0254
    c8b4:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				GSM_State++;
    c8b8:	80 91 21 06 	lds	r24, 0x0621
    c8bc:	8f 5f       	subi	r24, 0xFF	; 255
    c8be:	80 93 21 06 	sts	0x0621, r24
    c8c2:	0e c0       	rjmp	.+28     	; 0xc8e0 <GSM_Cycle+0x1954>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    c8c4:	80 91 54 02 	lds	r24, 0x0254
    c8c8:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    c8cc:	88 23       	and	r24, r24
    c8ce:	41 f0       	breq	.+16     	; 0xc8e0 <GSM_Cycle+0x1954>
    c8d0:	80 91 21 06 	lds	r24, 0x0621
    c8d4:	8f 5f       	subi	r24, 0xFF	; 255
    c8d6:	80 93 21 06 	sts	0x0621, r24
    c8da:	02 c0       	rjmp	.+4      	; 0xc8e0 <GSM_Cycle+0x1954>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c8dc:	10 92 21 06 	sts	0x0621, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
    c8e0:	80 91 21 06 	lds	r24, 0x0621
    c8e4:	88 35       	cpi	r24, 0x58	; 88
    c8e6:	41 f0       	breq	.+16     	; 0xc8f8 <GSM_Cycle+0x196c>
    c8e8:	80 91 21 06 	lds	r24, 0x0621
    c8ec:	89 35       	cpi	r24, 0x59	; 89
    c8ee:	21 f0       	breq	.+8      	; 0xc8f8 <GSM_Cycle+0x196c>
    c8f0:	80 91 21 06 	lds	r24, 0x0621
    c8f4:	80 93 49 09 	sts	0x0949, r24
}
    c8f8:	2e 96       	adiw	r28, 0x0e	; 14
    c8fa:	0f b6       	in	r0, 0x3f	; 63
    c8fc:	f8 94       	cli
    c8fe:	de bf       	out	0x3e, r29	; 62
    c900:	0f be       	out	0x3f, r0	; 63
    c902:	cd bf       	out	0x3d, r28	; 61
    c904:	df 91       	pop	r29
    c906:	cf 91       	pop	r28
    c908:	1f 91       	pop	r17
    c90a:	0f 91       	pop	r16
    c90c:	ff 90       	pop	r15
    c90e:	ef 90       	pop	r14
    c910:	df 90       	pop	r13
    c912:	cf 90       	pop	r12
    c914:	bf 90       	pop	r11
    c916:	af 90       	pop	r10
    c918:	9f 90       	pop	r9
    c91a:	8f 90       	pop	r8
    c91c:	7f 90       	pop	r7
    c91e:	6f 90       	pop	r6
    c920:	5f 90       	pop	r5
    c922:	4f 90       	pop	r4
    c924:	3f 90       	pop	r3
    c926:	2f 90       	pop	r2
    c928:	08 95       	ret

0000c92a <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
    c92a:	80 91 62 0a 	lds	r24, 0x0A62
    c92e:	88 23       	and	r24, r24
    c930:	b9 f0       	breq	.+46     	; 0xc960 <USART_Cycle+0x36>

		if(ModbusMode) MB_Cycle();
    c932:	80 91 da 03 	lds	r24, 0x03DA
    c936:	81 11       	cpse	r24, r1
    c938:	0e 94 69 39 	call	0x72d2	; 0x72d2 <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
    c93c:	c8 9b       	sbis	0x19, 0	; 25
    c93e:	27 c0       	rjmp	.+78     	; 0xc98e <USART_Cycle+0x64>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
    c940:	80 91 3a 09 	lds	r24, 0x093A
    c944:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    c948:	88 23       	and	r24, r24
    c94a:	31 f1       	breq	.+76     	; 0xc998 <USART_Cycle+0x6e>
				cli();
    c94c:	f8 94       	cli
				EMeter_ReInit();
    c94e:	0e 94 7f 4b 	call	0x96fe	; 0x96fe <EMeter_ReInit>
				UART_Soft = 0;
    c952:	10 92 62 0a 	sts	0x0A62, r1
				ModbusMode = 0;				
    c956:	10 92 da 03 	sts	0x03DA, r1
				GSM_DebugMode = 0;	
    c95a:	10 92 df 09 	sts	0x09DF, r1
    c95e:	15 c0       	rjmp	.+42     	; 0xc98a <USART_Cycle+0x60>
			}
		}
	}
	else{
	//	EMeter_Cycle();
		if(!(PINA & (1<<PA0))){
    c960:	c8 99       	sbic	0x19, 0	; 25
    c962:	15 c0       	rjmp	.+42     	; 0xc98e <USART_Cycle+0x64>
			if(Timer8Stopp(TD_UART_Soft)){
    c964:	80 91 3a 09 	lds	r24, 0x093A
    c968:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    c96c:	88 23       	and	r24, r24
    c96e:	a1 f0       	breq	.+40     	; 0xc998 <USART_Cycle+0x6e>
				if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
    c970:	80 91 63 0a 	lds	r24, 0x0A63
    c974:	81 11       	cpse	r24, r1
    c976:	0e 94 b6 4b 	call	0x976c	; 0x976c <GSM_Transparent2Modbus>
				cli();
    c97a:	f8 94       	cli
				MB_Init();
    c97c:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <MB_Init>
				UART_Soft = 1;
    c980:	81 e0       	ldi	r24, 0x01	; 1
    c982:	80 93 62 0a 	sts	0x0A62, r24
				ModbusMode = 1;
    c986:	80 93 da 03 	sts	0x03DA, r24
				sei();
    c98a:	78 94       	sei
    c98c:	05 c0       	rjmp	.+10     	; 0xc998 <USART_Cycle+0x6e>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
    c98e:	6a e0       	ldi	r22, 0x0A	; 10
    c990:	80 91 3a 09 	lds	r24, 0x093A
    c994:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
    c998:	0c 94 c6 57 	jmp	0xaf8c	; 0xaf8c <GSM_Cycle>

0000c99c <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    c99c:	2f 92       	push	r2
    c99e:	3f 92       	push	r3
    c9a0:	4f 92       	push	r4
    c9a2:	5f 92       	push	r5
    c9a4:	6f 92       	push	r6
    c9a6:	7f 92       	push	r7
    c9a8:	8f 92       	push	r8
    c9aa:	9f 92       	push	r9
    c9ac:	af 92       	push	r10
    c9ae:	bf 92       	push	r11
    c9b0:	cf 92       	push	r12
    c9b2:	df 92       	push	r13
    c9b4:	ef 92       	push	r14
    c9b6:	ff 92       	push	r15
    c9b8:	0f 93       	push	r16
    c9ba:	1f 93       	push	r17
    c9bc:	cf 93       	push	r28
    c9be:	df 93       	push	r29
    c9c0:	cd b7       	in	r28, 0x3d	; 61
    c9c2:	de b7       	in	r29, 0x3e	; 62
    c9c4:	2c 97       	sbiw	r28, 0x0c	; 12
    c9c6:	0f b6       	in	r0, 0x3f	; 63
    c9c8:	f8 94       	cli
    c9ca:	de bf       	out	0x3e, r29	; 62
    c9cc:	0f be       	out	0x3f, r0	; 63
    c9ce:	cd bf       	out	0x3d, r28	; 61
    c9d0:	8c 01       	movw	r16, r24
    c9d2:	b6 2e       	mov	r11, r22
	}
	else{
		StartTimeoutWaitRequest = 0;
	}

}
    c9d4:	2d b6       	in	r2, 0x3d	; 61
    c9d6:	3e b6       	in	r3, 0x3e	; 62
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	//static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    c9d8:	f0 90 16 06 	lds	r15, 0x0616

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    c9dc:	0e 94 0e 2a 	call	0x541c	; 0x541c <IntOff>
	uint32_t Time = Timer32[TimerN];
    c9e0:	24 e0       	ldi	r18, 0x04	; 4
    c9e2:	f2 9e       	mul	r15, r18
    c9e4:	f0 01       	movw	r30, r0
    c9e6:	11 24       	eor	r1, r1
    c9e8:	e0 58       	subi	r30, 0x80	; 128
    c9ea:	fd 4f       	sbci	r31, 0xFD	; 253
    c9ec:	c0 80       	ld	r12, Z
    c9ee:	d1 80       	ldd	r13, Z+1	; 0x01
    c9f0:	e2 80       	ldd	r14, Z+2	; 0x02
    c9f2:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    c9f4:	0e 94 16 2a 	call	0x542c	; 0x542c <IntOn>
    c9f8:	38 ec       	ldi	r19, 0xC8	; 200
    c9fa:	c3 16       	cp	r12, r19
    c9fc:	d1 04       	cpc	r13, r1
    c9fe:	e1 04       	cpc	r14, r1
    ca00:	f1 04       	cpc	r15, r1
    ca02:	38 f4       	brcc	.+14     	; 0xca12 <WebServer+0x76>
    ca04:	4f ef       	ldi	r20, 0xFF	; 255
    ca06:	5f ef       	ldi	r21, 0xFF	; 255
    ca08:	ba 01       	movw	r22, r20
    ca0a:	80 91 16 06 	lds	r24, 0x0616
    ca0e:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    ca12:	80 91 55 09 	lds	r24, 0x0955
    ca16:	0e 94 5b 2c 	call	0x58b6	; 0x58b6 <Timer32Stopp>
    ca1a:	81 11       	cpse	r24, r1
    ca1c:	10 92 6b 09 	sts	0x096B, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    ca20:	80 91 21 06 	lds	r24, 0x0621
    ca24:	80 36       	cpi	r24, 0x60	; 96
    ca26:	09 f0       	breq	.+2      	; 0xca2a <WebServer+0x8e>
    ca28:	e1 c3       	rjmp	.+1986   	; 0xd1ec <WebServer+0x850>
    ca2a:	80 91 e1 09 	lds	r24, 0x09E1
    ca2e:	81 30       	cpi	r24, 0x01	; 1
    ca30:	09 f0       	breq	.+2      	; 0xca34 <WebServer+0x98>
    ca32:	dc c3       	rjmp	.+1976   	; 0xd1ec <WebServer+0x850>
		
		// 
		if(WebMode == 254){
    ca34:	80 91 06 01 	lds	r24, 0x0106
    ca38:	8e 3f       	cpi	r24, 0xFE	; 254
    ca3a:	71 f5       	brne	.+92     	; 0xca98 <WebServer+0xfc>
			ptrPage = WebRequest(ptrSite, SiteSize);
    ca3c:	6b 2d       	mov	r22, r11
    ca3e:	c8 01       	movw	r24, r16
    ca40:	0e 94 a6 48 	call	0x914c	; 0x914c <WebRequest>
    ca44:	90 93 3a 02 	sts	0x023A, r25
    ca48:	80 93 39 02 	sts	0x0239, r24
			if(ptrPage != NULL){
    ca4c:	89 2b       	or	r24, r25
    ca4e:	41 f0       	breq	.+16     	; 0xca60 <WebServer+0xc4>
				WebMode = 255;
    ca50:	8f ef       	ldi	r24, 0xFF	; 255
    ca52:	80 93 06 01 	sts	0x0106, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    ca56:	64 e1       	ldi	r22, 0x14	; 20
    ca58:	80 91 32 09 	lds	r24, 0x0932
    ca5c:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    ca60:	80 91 38 02 	lds	r24, 0x0238
    ca64:	88 23       	and	r24, r24
    ca66:	79 f0       	breq	.+30     	; 0xca86 <WebServer+0xea>
				if(Timer16Stopp(TD_WaitReqTimout)){
    ca68:	80 91 57 09 	lds	r24, 0x0957
    ca6c:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    ca70:	88 23       	and	r24, r24
    ca72:	91 f0       	breq	.+36     	; 0xca98 <WebServer+0xfc>
					GSM_State = GSM_Swtch2CommandMode;
    ca74:	81 e6       	ldi	r24, 0x61	; 97
    ca76:	80 93 21 06 	sts	0x0621, r24
					Web_POST = 0;
    ca7a:	10 92 5a 09 	sts	0x095A, r1
					WebMode = 254;
    ca7e:	8e ef       	ldi	r24, 0xFE	; 254
    ca80:	80 93 06 01 	sts	0x0106, r24
					return;				
    ca84:	b5 c3       	rjmp	.+1898   	; 0xd1f0 <WebServer+0x854>
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    ca86:	68 ee       	ldi	r22, 0xE8	; 232
    ca88:	73 e0       	ldi	r23, 0x03	; 3
    ca8a:	80 91 57 09 	lds	r24, 0x0957
    ca8e:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				StartTimeoutWaitRequest = 1;
    ca92:	81 e0       	ldi	r24, 0x01	; 1
    ca94:	80 93 38 02 	sts	0x0238, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    ca98:	80 91 08 01 	lds	r24, 0x0108
    ca9c:	80 ff       	sbrs	r24, 0
    ca9e:	a8 c3       	rjmp	.+1872   	; 0xd1f0 <WebServer+0x854>
    caa0:	80 91 3d 09 	lds	r24, 0x093D
    caa4:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    caa8:	88 23       	and	r24, r24
    caaa:	09 f4       	brne	.+2      	; 0xcaae <WebServer+0x112>
    caac:	a1 c3       	rjmp	.+1858   	; 0xd1f0 <WebServer+0x854>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    caae:	80 91 06 01 	lds	r24, 0x0106
    cab2:	8f 3f       	cpi	r24, 0xFF	; 255
    cab4:	39 f4       	brne	.+14     	; 0xcac4 <WebServer+0x128>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    cab6:	80 91 32 09 	lds	r24, 0x0932
    caba:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    cabe:	81 11       	cpse	r24, r1
					WebMode = 0;
    cac0:	10 92 06 01 	sts	0x0106, r1
				}
			}

			// 
			if(WebMode == 2){
    cac4:	80 91 06 01 	lds	r24, 0x0106
    cac8:	82 30       	cpi	r24, 0x02	; 2
    caca:	59 f4       	brne	.+22     	; 0xcae2 <WebServer+0x146>
				GSM_State = GSM_Swtch2CommandMode;
    cacc:	81 e6       	ldi	r24, 0x61	; 97
    cace:	80 93 21 06 	sts	0x0621, r24
				WebMode = 254;
    cad2:	8e ef       	ldi	r24, 0xFE	; 254
    cad4:	80 93 06 01 	sts	0x0106, r24
				Web_Login_Code = 0;
    cad8:	10 92 03 06 	sts	0x0603, r1
				Web_POST = 0;
    cadc:	10 92 5a 09 	sts	0x095A, r1
				return;
    cae0:	87 c3       	rjmp	.+1806   	; 0xd1f0 <WebServer+0x854>
			}
			
			//   
			if(WebMode == 0){
    cae2:	81 11       	cpse	r24, r1
    cae4:	df c0       	rjmp	.+446    	; 0xcca4 <WebServer+0x308>
				//Not Found
				if(ptrPage == &Web_error_page){
    cae6:	80 91 39 02 	lds	r24, 0x0239
    caea:	90 91 3a 02 	lds	r25, 0x023A
    caee:	8c 5b       	subi	r24, 0xBC	; 188
    caf0:	9b 44       	sbci	r25, 0x4B	; 75
    caf2:	b9 f4       	brne	.+46     	; 0xcb22 <WebServer+0x186>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    caf4:	44 e7       	ldi	r20, 0x74	; 116
    caf6:	50 e0       	ldi	r21, 0x00	; 0
    caf8:	69 ec       	ldi	r22, 0xC9	; 201
    cafa:	7b e4       	ldi	r23, 0x4B	; 75
    cafc:	86 e2       	ldi	r24, 0x26	; 38
    cafe:	9c e0       	ldi	r25, 0x0C	; 12
    cb00:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    cb04:	84 e7       	ldi	r24, 0x74	; 116
    cb06:	80 93 45 09 	sts	0x0945, r24
					GSM_SendFirstChar();
    cb0a:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    cb0e:	68 ec       	ldi	r22, 0xC8	; 200
    cb10:	70 e0       	ldi	r23, 0x00	; 0
    cb12:	80 91 3d 09 	lds	r24, 0x093D
    cb16:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
					WebMode = 2;
    cb1a:	82 e0       	ldi	r24, 0x02	; 2
    cb1c:	80 93 06 01 	sts	0x0106, r24
    cb20:	c1 c0       	rjmp	.+386    	; 0xcca4 <WebServer+0x308>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    cb22:	41 e1       	ldi	r20, 0x11	; 17
    cb24:	50 e0       	ldi	r21, 0x00	; 0
    cb26:	65 ee       	ldi	r22, 0xE5	; 229
    cb28:	7c e4       	ldi	r23, 0x4C	; 76
    cb2a:	86 e2       	ldi	r24, 0x26	; 38
    cb2c:	9c e0       	ldi	r25, 0x0C	; 12
    cb2e:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    cb32:	4e e0       	ldi	r20, 0x0E	; 14
    cb34:	50 e0       	ldi	r21, 0x00	; 0
    cb36:	66 ed       	ldi	r22, 0xD6	; 214
    cb38:	7c e4       	ldi	r23, 0x4C	; 76
    cb3a:	87 e3       	ldi	r24, 0x37	; 55
    cb3c:	9c e0       	ldi	r25, 0x0C	; 12
    cb3e:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cb42:	e0 91 39 02 	lds	r30, 0x0239
    cb46:	f0 91 3a 02 	lds	r31, 0x023A
    cb4a:	85 91       	lpm	r24, Z+
    cb4c:	94 91       	lpm	r25, Z
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    cb4e:	6e e2       	ldi	r22, 0x2E	; 46
    cb50:	70 e0       	ldi	r23, 0x00	; 0
    cb52:	0e 94 d1 6b 	call	0xd7a2	; 0xd7a2 <strchr_P>
					if(ext_point_ptr){ 
    cb56:	00 97       	sbiw	r24, 0x00	; 0
    cb58:	09 f4       	brne	.+2      	; 0xcb5c <WebServer+0x1c0>
    cb5a:	89 c0       	rjmp	.+274    	; 0xcc6e <WebServer+0x2d2>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    cb5c:	7c 01       	movw	r14, r24
    cb5e:	5f ef       	ldi	r21, 0xFF	; 255
    cb60:	e5 1a       	sub	r14, r21
    cb62:	f5 0a       	sbc	r15, r21
    cb64:	b7 01       	movw	r22, r14
    cb66:	85 e9       	ldi	r24, 0x95	; 149
    cb68:	9c e4       	ldi	r25, 0x4C	; 76
    cb6a:	0e 94 20 47 	call	0x8e40	; 0x8e40 <strcmp_PP>
    cb6e:	81 11       	cpse	r24, r1
    cb70:	0b c0       	rjmp	.+22     	; 0xcb88 <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    cb72:	41 e2       	ldi	r20, 0x21	; 33
    cb74:	50 e0       	ldi	r21, 0x00	; 0
    cb76:	61 ea       	ldi	r22, 0xA1	; 161
    cb78:	7c e4       	ldi	r23, 0x4C	; 76
    cb7a:	85 e4       	ldi	r24, 0x45	; 69
    cb7c:	9c e0       	ldi	r25, 0x0C	; 12
    cb7e:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
							i += sizeof(html_cp1251_str)-1;
    cb82:	00 e4       	ldi	r16, 0x40	; 64
    cb84:	10 e0       	ldi	r17, 0x00	; 0
    cb86:	67 c0       	rjmp	.+206    	; 0xcc56 <WebServer+0x2ba>
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    cb88:	46 e0       	ldi	r20, 0x06	; 6
    cb8a:	50 e0       	ldi	r21, 0x00	; 0
    cb8c:	6a e9       	ldi	r22, 0x9A	; 154
    cb8e:	7c e4       	ldi	r23, 0x4C	; 76
    cb90:	85 e4       	ldi	r24, 0x45	; 69
    cb92:	9c e0       	ldi	r25, 0x0C	; 12
    cb94:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    cb98:	b7 01       	movw	r22, r14
    cb9a:	81 e9       	ldi	r24, 0x91	; 145
    cb9c:	9c e4       	ldi	r25, 0x4C	; 76
    cb9e:	0e 94 20 47 	call	0x8e40	; 0x8e40 <strcmp_PP>
    cba2:	81 11       	cpse	r24, r1
    cba4:	0b c0       	rjmp	.+22     	; 0xcbbc <WebServer+0x220>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    cba6:	43 e0       	ldi	r20, 0x03	; 3
    cba8:	50 e0       	ldi	r21, 0x00	; 0
    cbaa:	61 e9       	ldi	r22, 0x91	; 145
    cbac:	7c e4       	ldi	r23, 0x4C	; 76
    cbae:	8b e4       	ldi	r24, 0x4B	; 75
    cbb0:	9c e0       	ldi	r25, 0x0C	; 12
    cbb2:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
								i += sizeof(ico_str)-1;
    cbb6:	08 e2       	ldi	r16, 0x28	; 40
    cbb8:	10 e0       	ldi	r17, 0x00	; 0
    cbba:	02 c0       	rjmp	.+4      	; 0xcbc0 <WebServer+0x224>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
							i += sizeof(image_str)-1;
    cbbc:	05 e2       	ldi	r16, 0x25	; 37
    cbbe:	10 e0       	ldi	r17, 0x00	; 0
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    cbc0:	b7 01       	movw	r22, r14
    cbc2:	8d e8       	ldi	r24, 0x8D	; 141
    cbc4:	9c e4       	ldi	r25, 0x4C	; 76
    cbc6:	0e 94 20 47 	call	0x8e40	; 0x8e40 <strcmp_PP>
    cbca:	81 11       	cpse	r24, r1
    cbcc:	0b c0       	rjmp	.+22     	; 0xcbe4 <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    cbce:	43 e0       	ldi	r20, 0x03	; 3
    cbd0:	50 e0       	ldi	r21, 0x00	; 0
    cbd2:	6d e8       	ldi	r22, 0x8D	; 141
    cbd4:	7c e4       	ldi	r23, 0x4C	; 76
    cbd6:	c8 01       	movw	r24, r16
    cbd8:	8a 5d       	subi	r24, 0xDA	; 218
    cbda:	93 4f       	sbci	r25, 0xF3	; 243
    cbdc:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
								i += sizeof(gif_str)-1;								
    cbe0:	0d 5f       	subi	r16, 0xFD	; 253
    cbe2:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    cbe4:	b7 01       	movw	r22, r14
    cbe6:	88 e8       	ldi	r24, 0x88	; 136
    cbe8:	9c e4       	ldi	r25, 0x4C	; 76
    cbea:	0e 94 20 47 	call	0x8e40	; 0x8e40 <strcmp_PP>
    cbee:	81 11       	cpse	r24, r1
    cbf0:	0b c0       	rjmp	.+22     	; 0xcc08 <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    cbf2:	44 e0       	ldi	r20, 0x04	; 4
    cbf4:	50 e0       	ldi	r21, 0x00	; 0
    cbf6:	68 e8       	ldi	r22, 0x88	; 136
    cbf8:	7c e4       	ldi	r23, 0x4C	; 76
    cbfa:	c8 01       	movw	r24, r16
    cbfc:	8a 5d       	subi	r24, 0xDA	; 218
    cbfe:	93 4f       	sbci	r25, 0xF3	; 243
    cc00:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    cc04:	0c 5f       	subi	r16, 0xFC	; 252
    cc06:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    cc08:	42 e1       	ldi	r20, 0x12	; 18
    cc0a:	50 e0       	ldi	r21, 0x00	; 0
    cc0c:	63 ec       	ldi	r22, 0xC3	; 195
    cc0e:	7c e4       	ldi	r23, 0x4C	; 76
    cc10:	c8 01       	movw	r24, r16
    cc12:	8a 5d       	subi	r24, 0xDA	; 218
    cc14:	93 4f       	sbci	r25, 0xF3	; 243
    cc16:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
							i += sizeof(Content_Length)-1;
    cc1a:	0e 5e       	subi	r16, 0xEE	; 238
    cc1c:	1f 4f       	sbci	r17, 0xFF	; 255
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    cc1e:	e0 91 39 02 	lds	r30, 0x0239
    cc22:	f0 91 3a 02 	lds	r31, 0x023A
    cc26:	38 96       	adiw	r30, 0x08	; 8

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cc28:	85 91       	lpm	r24, Z+
    cc2a:	94 91       	lpm	r25, Z
    cc2c:	9f 93       	push	r25
    cc2e:	8f 93       	push	r24
    cc30:	85 e0       	ldi	r24, 0x05	; 5
    cc32:	93 e0       	ldi	r25, 0x03	; 3
    cc34:	9f 93       	push	r25
    cc36:	8f 93       	push	r24
    cc38:	c8 01       	movw	r24, r16
    cc3a:	8a 5d       	subi	r24, 0xDA	; 218
    cc3c:	93 4f       	sbci	r25, 0xF3	; 243
    cc3e:	9f 93       	push	r25
    cc40:	8f 93       	push	r24
    cc42:	0e 94 92 6c 	call	0xd924	; 0xd924 <sprintf_P>
    cc46:	08 0f       	add	r16, r24
    cc48:	19 1f       	adc	r17, r25
    cc4a:	0f 90       	pop	r0
    cc4c:	0f 90       	pop	r0
    cc4e:	0f 90       	pop	r0
    cc50:	0f 90       	pop	r0
    cc52:	0f 90       	pop	r0
    cc54:	0f 90       	pop	r0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    cc56:	45 e1       	ldi	r20, 0x15	; 21
    cc58:	50 e0       	ldi	r21, 0x00	; 0
    cc5a:	62 e7       	ldi	r22, 0x72	; 114
    cc5c:	7c e4       	ldi	r23, 0x4C	; 76
    cc5e:	c8 01       	movw	r24, r16
    cc60:	8a 5d       	subi	r24, 0xDA	; 218
    cc62:	93 4f       	sbci	r25, 0xF3	; 243
    cc64:	0e 94 c8 6b 	call	0xd790	; 0xd790 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    cc68:	0b 5e       	subi	r16, 0xEB	; 235
    cc6a:	1f 4f       	sbci	r17, 0xFF	; 255
    cc6c:	02 c0       	rjmp	.+4      	; 0xcc72 <WebServer+0x2d6>
					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
					i += sizeof(Content_Type)-1;
    cc6e:	0f e1       	ldi	r16, 0x1F	; 31
    cc70:	10 e0       	ldi	r17, 0x00	; 0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
						i += sizeof(Connection_Close)-1;

					}
					WebDataCnt = 0;
    cc72:	10 92 eb 03 	sts	0x03EB, r1
    cc76:	10 92 ea 03 	sts	0x03EA, r1
					WebInputHiddenCnt = 0;
    cc7a:	10 92 e3 03 	sts	0x03E3, r1
					WebHrefHiddenCnt = 0;
    cc7e:	10 92 22 06 	sts	0x0622, r1
					WebImgSrcHiddenCnt = 0;
    cc82:	10 92 e2 03 	sts	0x03E2, r1
					ptrIF = prp(&ptrPage->IF_List);
    cc86:	e0 91 39 02 	lds	r30, 0x0239
    cc8a:	f0 91 3a 02 	lds	r31, 0x023A
    cc8e:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cc90:	85 91       	lpm	r24, Z+
    cc92:	94 91       	lpm	r25, Z
    cc94:	90 93 37 02 	sts	0x0237, r25
    cc98:	80 93 36 02 	sts	0x0236, r24
					WebMode = 1;
    cc9c:	81 e0       	ldi	r24, 0x01	; 1
    cc9e:	80 93 06 01 	sts	0x0106, r24
    cca2:	02 c0       	rjmp	.+4      	; 0xcca8 <WebServer+0x30c>


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){

			uint16_t i=0;
    cca4:	00 e0       	ldi	r16, 0x00	; 0
    cca6:	10 e0       	ldi	r17, 0x00	; 0
					WebMode = 1;
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    cca8:	80 91 06 01 	lds	r24, 0x0106
    ccac:	81 30       	cpi	r24, 0x01	; 1
    ccae:	09 f0       	breq	.+2      	; 0xccb2 <WebServer+0x316>
    ccb0:	9f c2       	rjmp	.+1342   	; 0xd1f0 <WebServer+0x854>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    ccb2:	bb 24       	eor	r11, r11
    ccb4:	b3 94       	inc	r11
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    ccb6:	0f 3f       	cpi	r16, 0xFF	; 255
    ccb8:	11 05       	cpc	r17, r1
    ccba:	08 f0       	brcs	.+2      	; 0xccbe <WebServer+0x322>
    ccbc:	b0 c0       	rjmp	.+352    	; 0xce1e <WebServer+0x482>
					char ch;
					if(WebImgSrcHiddenCnt){
    ccbe:	80 91 e2 03 	lds	r24, 0x03E2
    ccc2:	c0 90 39 02 	lds	r12, 0x0239
    ccc6:	d0 90 3a 02 	lds	r13, 0x023A
    ccca:	88 23       	and	r24, r24
    cccc:	a1 f0       	breq	.+40     	; 0xccf6 <WebServer+0x35a>
    ccce:	e8 2f       	mov	r30, r24
    ccd0:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    ccd2:	89 30       	cpi	r24, 0x09	; 9
    ccd4:	20 f0       	brcs	.+8      	; 0xccde <WebServer+0x342>
    ccd6:	e6 5e       	subi	r30, 0xE6	; 230
    ccd8:	f9 4f       	sbci	r31, 0xF9	; 249
    ccda:	a0 80       	ld	r10, Z
    ccdc:	03 c0       	rjmp	.+6      	; 0xcce4 <WebServer+0x348>
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
    ccde:	e3 5c       	subi	r30, 0xC3	; 195
    cce0:	f3 4b       	sbci	r31, 0xB3	; 179

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cce2:	a4 90       	lpm	r10, Z
						WebImgSrcHiddenCnt++ ;
    cce4:	8f 5f       	subi	r24, 0xFF	; 255
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    cce6:	89 31       	cpi	r24, 0x19	; 25
    cce8:	18 f4       	brcc	.+6      	; 0xccf0 <WebServer+0x354>
					char ch;
					if(WebImgSrcHiddenCnt){
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    ccea:	80 93 e2 03 	sts	0x03E2, r24
    ccee:	46 c0       	rjmp	.+140    	; 0xcd7c <WebServer+0x3e0>
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    ccf0:	10 92 e2 03 	sts	0x03E2, r1
    ccf4:	43 c0       	rjmp	.+134    	; 0xcd7c <WebServer+0x3e0>
					}
					else{
						if(WebHrefHiddenCnt){
    ccf6:	80 91 22 06 	lds	r24, 0x0622
    ccfa:	88 23       	and	r24, r24
    ccfc:	a1 f0       	breq	.+40     	; 0xcd26 <WebServer+0x38a>
    ccfe:	e8 2f       	mov	r30, r24
    cd00:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    cd02:	89 30       	cpi	r24, 0x09	; 9
    cd04:	20 f0       	brcs	.+8      	; 0xcd0e <WebServer+0x372>
    cd06:	e6 5e       	subi	r30, 0xE6	; 230
    cd08:	f9 4f       	sbci	r31, 0xF9	; 249
    cd0a:	a0 80       	ld	r10, Z
    cd0c:	03 c0       	rjmp	.+6      	; 0xcd14 <WebServer+0x378>
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
    cd0e:	e3 5c       	subi	r30, 0xC3	; 195
    cd10:	f3 4b       	sbci	r31, 0xB3	; 179
    cd12:	a4 90       	lpm	r10, Z
							WebHrefHiddenCnt++ ;
    cd14:	8f 5f       	subi	r24, 0xFF	; 255
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    cd16:	89 31       	cpi	r24, 0x19	; 25
    cd18:	18 f4       	brcc	.+6      	; 0xcd20 <WebServer+0x384>
					else{
						if(WebHrefHiddenCnt){
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    cd1a:	80 93 22 06 	sts	0x0622, r24
    cd1e:	2e c0       	rjmp	.+92     	; 0xcd7c <WebServer+0x3e0>
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    cd20:	10 92 22 06 	sts	0x0622, r1
    cd24:	2b c0       	rjmp	.+86     	; 0xcd7c <WebServer+0x3e0>
						}
						else{
							if(WebInputHiddenCnt){
    cd26:	80 91 e3 03 	lds	r24, 0x03E3
    cd2a:	88 23       	and	r24, r24
    cd2c:	a1 f0       	breq	.+40     	; 0xcd56 <WebServer+0x3ba>
    cd2e:	e8 2f       	mov	r30, r24
    cd30:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    cd32:	8b 32       	cpi	r24, 0x2B	; 43
    cd34:	20 f0       	brcs	.+8      	; 0xcd3e <WebServer+0x3a2>
    cd36:	e8 50       	subi	r30, 0x08	; 8
    cd38:	fa 4f       	sbci	r31, 0xFA	; 250
    cd3a:	a0 80       	ld	r10, Z
    cd3c:	03 c0       	rjmp	.+6      	; 0xcd44 <WebServer+0x3a8>
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
    cd3e:	ea 5b       	subi	r30, 0xBA	; 186
    cd40:	f3 4b       	sbci	r31, 0xB3	; 179
    cd42:	a4 90       	lpm	r10, Z
								WebInputHiddenCnt++ ;
    cd44:	8f 5f       	subi	r24, 0xFF	; 255
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    cd46:	8e 33       	cpi	r24, 0x3E	; 62
    cd48:	18 f4       	brcc	.+6      	; 0xcd50 <WebServer+0x3b4>
						else{
							if(WebInputHiddenCnt){
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    cd4a:	80 93 e3 03 	sts	0x03E3, r24
    cd4e:	16 c0       	rjmp	.+44     	; 0xcd7c <WebServer+0x3e0>
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    cd50:	10 92 e3 03 	sts	0x03E3, r1
    cd54:	13 c0       	rjmp	.+38     	; 0xcd7c <WebServer+0x3e0>
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    cd56:	f6 01       	movw	r30, r12
    cd58:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cd5a:	25 91       	lpm	r18, Z+
    cd5c:	34 91       	lpm	r19, Z
    cd5e:	80 91 ea 03 	lds	r24, 0x03EA
    cd62:	90 91 eb 03 	lds	r25, 0x03EB
    cd66:	ac 01       	movw	r20, r24
    cd68:	4f 5f       	subi	r20, 0xFF	; 255
    cd6a:	5f 4f       	sbci	r21, 0xFF	; 255
    cd6c:	50 93 eb 03 	sts	0x03EB, r21
    cd70:	40 93 ea 03 	sts	0x03EA, r20
    cd74:	f9 01       	movw	r30, r18
    cd76:	e8 0f       	add	r30, r24
    cd78:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cd7a:	a4 90       	lpm	r10, Z
							}
						}
					}

					GSM_TxStr[i++] = ch;
    cd7c:	78 01       	movw	r14, r16
    cd7e:	8f ef       	ldi	r24, 0xFF	; 255
    cd80:	e8 1a       	sub	r14, r24
    cd82:	f8 0a       	sbc	r15, r24
    cd84:	d8 01       	movw	r26, r16
    cd86:	aa 5d       	subi	r26, 0xDA	; 218
    cd88:	b3 4f       	sbci	r27, 0xF3	; 243
    cd8a:	ac 92       	st	X, r10
					if(ptrPage != &Web_login){	//  login.html   !
    cd8c:	95 e9       	ldi	r25, 0x95	; 149
    cd8e:	c9 16       	cp	r12, r25
    cd90:	98 e4       	ldi	r25, 0x48	; 72
    cd92:	d9 06       	cpc	r13, r25
    cd94:	59 f1       	breq	.+86     	; 0xcdec <WebServer+0x450>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    cd96:	8a 2d       	mov	r24, r10
    cd98:	0e 94 62 47 	call	0x8ec4	; 0x8ec4 <SeekTagFORM>
    cd9c:	81 11       	cpse	r24, r1
    cd9e:	b0 92 e3 03 	sts	0x03E3, r11
						if(SeekTagA_HREF(ch)){ 
    cda2:	8a 2d       	mov	r24, r10
    cda4:	0e 94 9e 47 	call	0x8f3c	; 0x8f3c <SeekTagA_HREF>
    cda8:	88 23       	and	r24, r24
    cdaa:	69 f0       	breq	.+26     	; 0xcdc6 <WebServer+0x42a>
							WebHrefHiddenCnt = 1;
    cdac:	b0 92 22 06 	sts	0x0622, r11
							i--;
							WebDataCnt--;
    cdb0:	20 91 ea 03 	lds	r18, 0x03EA
    cdb4:	30 91 eb 03 	lds	r19, 0x03EB
    cdb8:	21 50       	subi	r18, 0x01	; 1
    cdba:	31 09       	sbc	r19, r1
    cdbc:	30 93 eb 03 	sts	0x03EB, r19
    cdc0:	20 93 ea 03 	sts	0x03EA, r18
    cdc4:	78 01       	movw	r14, r16
						}
						if(SeekTagIMG_SRC(ch)){ 
    cdc6:	8a 2d       	mov	r24, r10
    cdc8:	0e 94 da 47 	call	0x8fb4	; 0x8fb4 <SeekTagIMG_SRC>
    cdcc:	88 23       	and	r24, r24
    cdce:	71 f0       	breq	.+28     	; 0xcdec <WebServer+0x450>
							WebImgSrcHiddenCnt = 1;
    cdd0:	b0 92 e2 03 	sts	0x03E2, r11
							i--;
    cdd4:	e1 e0       	ldi	r30, 0x01	; 1
    cdd6:	ee 1a       	sub	r14, r30
    cdd8:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    cdda:	80 91 ea 03 	lds	r24, 0x03EA
    cdde:	90 91 eb 03 	lds	r25, 0x03EB
    cde2:	01 97       	sbiw	r24, 0x01	; 1
    cde4:	90 93 eb 03 	sts	0x03EB, r25
    cde8:	80 93 ea 03 	sts	0x03EA, r24
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    cdec:	f8 e0       	ldi	r31, 0x08	; 8
    cdee:	cf 0e       	add	r12, r31
    cdf0:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cdf2:	f6 01       	movw	r30, r12
    cdf4:	85 91       	lpm	r24, Z+
    cdf6:	94 91       	lpm	r25, Z
    cdf8:	20 91 ea 03 	lds	r18, 0x03EA
    cdfc:	30 91 eb 03 	lds	r19, 0x03EB
    ce00:	28 17       	cp	r18, r24
    ce02:	39 07       	cpc	r19, r25
    ce04:	10 f4       	brcc	.+4      	; 0xce0a <WebServer+0x46e>
    ce06:	87 01       	movw	r16, r14
    ce08:	56 cf       	rjmp	.-340    	; 0xccb6 <WebServer+0x31a>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    ce0a:	68 ec       	ldi	r22, 0xC8	; 200
    ce0c:	70 e0       	ldi	r23, 0x00	; 0
    ce0e:	80 91 3d 09 	lds	r24, 0x093D
    ce12:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
						WebMode = 2;
    ce16:	82 e0       	ldi	r24, 0x02	; 2
    ce18:	80 93 06 01 	sts	0x0106, r24
						break;
    ce1c:	87 01       	movw	r16, r14
					}
				}
				//
				if(ptrIF != NULL){
    ce1e:	c0 90 36 02 	lds	r12, 0x0236
    ce22:	d0 90 37 02 	lds	r13, 0x0237
    ce26:	c1 14       	cp	r12, r1
    ce28:	d1 04       	cpc	r13, r1
    ce2a:	09 f4       	brne	.+2      	; 0xce2e <WebServer+0x492>
    ce2c:	be c1       	rjmp	.+892    	; 0xd1aa <WebServer+0x80e>
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    ce2e:	e0 91 39 02 	lds	r30, 0x0239
    ce32:	f0 91 3a 02 	lds	r31, 0x023A
    ce36:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce38:	25 91       	lpm	r18, Z+
    ce3a:	34 91       	lpm	r19, Z
    ce3c:	80 91 ea 03 	lds	r24, 0x03EA
    ce40:	90 91 eb 03 	lds	r25, 0x03EB
    ce44:	f9 01       	movw	r30, r18
    ce46:	e8 0f       	add	r30, r24
    ce48:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ce4a:	24 91       	lpm	r18, Z
    ce4c:	2b 37       	cpi	r18, 0x7B	; 123
    ce4e:	a1 f4       	brne	.+40     	; 0xce78 <WebServer+0x4dc>
    ce50:	80 1b       	sub	r24, r16
    ce52:	91 0b       	sbc	r25, r17
    ce54:	ac 01       	movw	r20, r24
    ce56:	40 0f       	add	r20, r16
    ce58:	51 1f       	adc	r21, r17
						while(GSM_TxStr[i-1] == '{'){
    ce5a:	98 01       	movw	r18, r16
    ce5c:	21 50       	subi	r18, 0x01	; 1
    ce5e:	31 09       	sbc	r19, r1
    ce60:	f9 01       	movw	r30, r18
    ce62:	ea 5d       	subi	r30, 0xDA	; 218
    ce64:	f3 4f       	sbci	r31, 0xF3	; 243
    ce66:	60 81       	ld	r22, Z
    ce68:	6b 37       	cpi	r22, 0x7B	; 123
    ce6a:	11 f4       	brne	.+4      	; 0xce70 <WebServer+0x4d4>
							WebDataCnt--;
							i--;
    ce6c:	89 01       	movw	r16, r18
    ce6e:	f2 cf       	rjmp	.-28     	; 0xce54 <WebServer+0x4b8>
    ce70:	50 93 eb 03 	sts	0x03EB, r21
    ce74:	40 93 ea 03 	sts	0x03EA, r20
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    ce78:	0b 87       	std	Y+11, r16	; 0x0b
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    ce7a:	61 2c       	mov	r6, r1
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    ce7c:	aa 24       	eor	r10, r10
    ce7e:	a3 94       	inc	r10
    ce80:	b1 2c       	mov	r11, r1
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    ce82:	ab e3       	ldi	r26, 0x3B	; 59
    ce84:	4a 2e       	mov	r4, r26
    ce86:	a1 e0       	ldi	r26, 0x01	; 1
    ce88:	5a 2e       	mov	r5, r26
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    ce8a:	4b 85       	ldd	r20, Y+11	; 0x0b
    ce8c:	64 16       	cp	r6, r20
    ce8e:	08 f0       	brcs	.+2      	; 0xce92 <WebServer+0x4f6>
    ce90:	88 c1       	rjmp	.+784    	; 0xd1a2 <WebServer+0x806>
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    ce92:	e6 2c       	mov	r14, r6
    ce94:	f1 2c       	mov	r15, r1
    ce96:	97 01       	movw	r18, r14
    ce98:	2a 5d       	subi	r18, 0xDA	; 218
    ce9a:	33 4f       	sbci	r19, 0xF3	; 243
    ce9c:	79 01       	movw	r14, r18
    ce9e:	3a 83       	std	Y+2, r19	; 0x02
    cea0:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
    cea2:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    cea4:	f9 01       	movw	r30, r18
    cea6:	70 80       	ld	r7, Z
    cea8:	fb e7       	ldi	r31, 0x7B	; 123
    ceaa:	7f 12       	cpse	r7, r31
    ceac:	6f c1       	rjmp	.+734    	; 0xd18c <WebServer+0x7f0>
    ceae:	80 e0       	ldi	r24, 0x00	; 0
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    ceb0:	8f 5f       	subi	r24, 0xFF	; 255
    ceb2:	48 2f       	mov	r20, r24
    ceb4:	50 e0       	ldi	r21, 0x00	; 0
    ceb6:	f7 01       	movw	r30, r14
    ceb8:	e4 0f       	add	r30, r20
    ceba:	f5 1f       	adc	r31, r21
    cebc:	70 80       	ld	r7, Z
    cebe:	2b e7       	ldi	r18, 0x7B	; 123
    cec0:	72 16       	cp	r7, r18
    cec2:	b1 f3       	breq	.-20     	; 0xceb0 <WebServer+0x514>
    cec4:	8c 83       	std	Y+4, r24	; 0x04
			Param.Prec = prb(&IF->Prec);
    cec6:	f6 01       	movw	r30, r12
    cec8:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ceca:	e4 91       	lpm	r30, Z
    cecc:	eb 83       	std	Y+3, r30	; 0x03
			Param.Txt = prp(&IF->EnumList);
    cece:	f6 01       	movw	r30, r12
    ced0:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ced2:	85 90       	lpm	r8, Z+
    ced4:	94 90       	lpm	r9, Z
    ced6:	9e 82       	std	Y+6, r9	; 0x06
    ced8:	8d 82       	std	Y+5, r8	; 0x05
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    ceda:	f6 01       	movw	r30, r12
    cedc:	31 96       	adiw	r30, 0x01	; 1
    cede:	a5 91       	lpm	r26, Z+
    cee0:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cee2:	f6 01       	movw	r30, r12
    cee4:	64 91       	lpm	r22, Z
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    cee6:	70 e0       	ldi	r23, 0x00	; 0
    cee8:	63 32       	cpi	r22, 0x23	; 35
    ceea:	71 05       	cpc	r23, r1
    ceec:	08 f0       	brcs	.+2      	; 0xcef0 <WebServer+0x554>
    ceee:	4b c1       	rjmp	.+662    	; 0xd186 <WebServer+0x7ea>
    cef0:	fb 01       	movw	r30, r22
    cef2:	ee 5b       	subi	r30, 0xBE	; 190
    cef4:	fe 4f       	sbci	r31, 0xFE	; 254
    cef6:	0c 94 23 75 	jmp	0xea46	; 0xea46 <__tablejump2__>
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    cefa:	8c 91       	ld	r24, X
    cefc:	03 c0       	rjmp	.+6      	; 0xcf04 <WebServer+0x568>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cefe:	cd 01       	movw	r24, r26
    cf00:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    cf04:	ae 01       	movw	r20, r28
    cf06:	4f 5f       	subi	r20, 0xFF	; 255
    cf08:	5f 4f       	sbci	r21, 0xFF	; 255
    cf0a:	62 e6       	ldi	r22, 0x62	; 98
    cf0c:	90 e0       	ldi	r25, 0x00	; 0
    cf0e:	0e 94 68 3e 	call	0x7cd0	; 0x7cd0 <PutVal>
    cf12:	39 c1       	rjmp	.+626    	; 0xd186 <WebServer+0x7ea>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    cf14:	8c 91       	ld	r24, X
    cf16:	03 c0       	rjmp	.+6      	; 0xcf1e <WebServer+0x582>
    cf18:	cd 01       	movw	r24, r26
    cf1a:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    cf1e:	ae 01       	movw	r20, r28
    cf20:	4f 5f       	subi	r20, 0xFF	; 255
    cf22:	5f 4f       	sbci	r21, 0xFF	; 255
    cf24:	62 e6       	ldi	r22, 0x62	; 98
    cf26:	99 27       	eor	r25, r25
    cf28:	87 fd       	sbrc	r24, 7
    cf2a:	90 95       	com	r25
    cf2c:	0e 94 e3 3e 	call	0x7dc6	; 0x7dc6 <Put_sVal>
    cf30:	2a c1       	rjmp	.+596    	; 0xd186 <WebServer+0x7ea>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    cf32:	8c 91       	ld	r24, X
    cf34:	03 c0       	rjmp	.+6      	; 0xcf3c <WebServer+0x5a0>
    cf36:	cd 01       	movw	r24, r26
    cf38:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    cf3c:	ae 01       	movw	r20, r28
    cf3e:	4f 5f       	subi	r20, 0xFF	; 255
    cf40:	5f 4f       	sbci	r21, 0xFF	; 255
    cf42:	62 e6       	ldi	r22, 0x62	; 98
    cf44:	90 e0       	ldi	r25, 0x00	; 0
    cf46:	0e 94 8d 3f 	call	0x7f1a	; 0x7f1a <Put_zVal>
    cf4a:	1d c1       	rjmp	.+570    	; 0xd186 <WebServer+0x7ea>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    cf4c:	6c 91       	ld	r22, X
    cf4e:	70 e0       	ldi	r23, 0x00	; 0
    cf50:	80 e0       	ldi	r24, 0x00	; 0
    cf52:	90 e0       	ldi	r25, 0x00	; 0
    cf54:	9e 01       	movw	r18, r28
    cf56:	2f 5f       	subi	r18, 0xFF	; 255
    cf58:	3f 4f       	sbci	r19, 0xFF	; 255
    cf5a:	42 e6       	ldi	r20, 0x62	; 98
    cf5c:	08 c0       	rjmp	.+16     	; 0xcf6e <WebServer+0x5d2>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    cf5e:	6d 91       	ld	r22, X+
    cf60:	7c 91       	ld	r23, X
    cf62:	80 e0       	ldi	r24, 0x00	; 0
    cf64:	90 e0       	ldi	r25, 0x00	; 0
    cf66:	9e 01       	movw	r18, r28
    cf68:	2f 5f       	subi	r18, 0xFF	; 255
    cf6a:	3f 4f       	sbci	r19, 0xFF	; 255
    cf6c:	47 e7       	ldi	r20, 0x77	; 119
    cf6e:	0e 94 08 40 	call	0x8010	; 0x8010 <Put_zVal_h>
    cf72:	09 c1       	rjmp	.+530    	; 0xd186 <WebServer+0x7ea>
    cf74:	13 96       	adiw	r26, 0x03	; 3
    cf76:	8c 91       	ld	r24, X
    cf78:	13 97       	sbiw	r26, 0x03	; 3
    cf7a:	8f 93       	push	r24
    cf7c:	12 96       	adiw	r26, 0x02	; 2
    cf7e:	8c 91       	ld	r24, X
    cf80:	12 97       	sbiw	r26, 0x02	; 2
    cf82:	8f 93       	push	r24
    cf84:	11 96       	adiw	r26, 0x01	; 1
    cf86:	8c 91       	ld	r24, X
    cf88:	11 97       	sbiw	r26, 0x01	; 1
    cf8a:	8f 93       	push	r24
    cf8c:	8c 91       	ld	r24, X
    cf8e:	8f 93       	push	r24
    cf90:	5f 92       	push	r5
    cf92:	4f 92       	push	r4
    cf94:	ff 92       	push	r15
    cf96:	ef 92       	push	r14
    cf98:	0e 94 63 6c 	call	0xd8c6	; 0xd8c6 <sprintf>
    cf9c:	2d b7       	in	r18, 0x3d	; 61
    cf9e:	3e b7       	in	r19, 0x3e	; 62
    cfa0:	28 5f       	subi	r18, 0xF8	; 248
    cfa2:	3f 4f       	sbci	r19, 0xFF	; 255
    cfa4:	0f b6       	in	r0, 0x3f	; 63
    cfa6:	f8 94       	cli
    cfa8:	3e bf       	out	0x3e, r19	; 62
    cfaa:	0f be       	out	0x3f, r0	; 63
    cfac:	2d bf       	out	0x3d, r18	; 61
    cfae:	eb c0       	rjmp	.+470    	; 0xd186 <WebServer+0x7ea>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    cfb0:	ae 01       	movw	r20, r28
    cfb2:	4f 5f       	subi	r20, 0xFF	; 255
    cfb4:	5f 4f       	sbci	r21, 0xFF	; 255
    cfb6:	67 e7       	ldi	r22, 0x77	; 119
    cfb8:	8d 91       	ld	r24, X+
    cfba:	9c 91       	ld	r25, X
    cfbc:	a8 cf       	rjmp	.-176    	; 0xcf0e <WebServer+0x572>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    cfbe:	cd 01       	movw	r24, r26
    cfc0:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    cfc4:	ae 01       	movw	r20, r28
    cfc6:	4f 5f       	subi	r20, 0xFF	; 255
    cfc8:	5f 4f       	sbci	r21, 0xFF	; 255
    cfca:	67 e7       	ldi	r22, 0x77	; 119
    cfcc:	a0 cf       	rjmp	.-192    	; 0xcf0e <WebServer+0x572>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    cfce:	ae 01       	movw	r20, r28
    cfd0:	4f 5f       	subi	r20, 0xFF	; 255
    cfd2:	5f 4f       	sbci	r21, 0xFF	; 255
    cfd4:	67 e7       	ldi	r22, 0x77	; 119
    cfd6:	8d 91       	ld	r24, X+
    cfd8:	9c 91       	ld	r25, X
    cfda:	a8 cf       	rjmp	.-176    	; 0xcf2c <WebServer+0x590>
    cfdc:	cd 01       	movw	r24, r26
    cfde:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    cfe2:	ae 01       	movw	r20, r28
    cfe4:	4f 5f       	subi	r20, 0xFF	; 255
    cfe6:	5f 4f       	sbci	r21, 0xFF	; 255
    cfe8:	67 e7       	ldi	r22, 0x77	; 119
    cfea:	a0 cf       	rjmp	.-192    	; 0xcf2c <WebServer+0x590>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    cfec:	ae 01       	movw	r20, r28
    cfee:	4f 5f       	subi	r20, 0xFF	; 255
    cff0:	5f 4f       	sbci	r21, 0xFF	; 255
    cff2:	67 e7       	ldi	r22, 0x77	; 119
    cff4:	8d 91       	ld	r24, X+
    cff6:	9c 91       	ld	r25, X
    cff8:	a6 cf       	rjmp	.-180    	; 0xcf46 <WebServer+0x5aa>
    cffa:	cd 01       	movw	r24, r26
    cffc:	0e 94 7c 73 	call	0xe6f8	; 0xe6f8 <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    d000:	ae 01       	movw	r20, r28
    d002:	4f 5f       	subi	r20, 0xFF	; 255
    d004:	5f 4f       	sbci	r21, 0xFF	; 255
    d006:	67 e7       	ldi	r22, 0x77	; 119
    d008:	9e cf       	rjmp	.-196    	; 0xcf46 <WebServer+0x5aa>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    d00a:	6d 91       	ld	r22, X+
    d00c:	7d 91       	ld	r23, X+
    d00e:	8d 91       	ld	r24, X+
    d010:	9c 91       	ld	r25, X
    d012:	03 c0       	rjmp	.+6      	; 0xd01a <WebServer+0x67e>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    d014:	cd 01       	movw	r24, r26
    d016:	0e 94 76 73 	call	0xe6ec	; 0xe6ec <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    d01a:	ae 01       	movw	r20, r28
    d01c:	4f 5f       	subi	r20, 0xFF	; 255
    d01e:	5f 4f       	sbci	r21, 0xFF	; 255
    d020:	0e 94 3e 40 	call	0x807c	; 0x807c <PutDVal>
    d024:	b0 c0       	rjmp	.+352    	; 0xd186 <WebServer+0x7ea>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    d026:	6d 91       	ld	r22, X+
    d028:	7d 91       	ld	r23, X+
    d02a:	8d 91       	ld	r24, X+
    d02c:	9c 91       	ld	r25, X
    d02e:	03 c0       	rjmp	.+6      	; 0xd036 <WebServer+0x69a>
    d030:	cd 01       	movw	r24, r26
    d032:	0e 94 76 73 	call	0xe6ec	; 0xe6ec <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    d036:	ae 01       	movw	r20, r28
    d038:	4f 5f       	subi	r20, 0xFF	; 255
    d03a:	5f 4f       	sbci	r21, 0xFF	; 255
    d03c:	0e 94 d1 40 	call	0x81a2	; 0x81a2 <Put_sDVal>
    d040:	a2 c0       	rjmp	.+324    	; 0xd186 <WebServer+0x7ea>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    d042:	6d 91       	ld	r22, X+
    d044:	7d 91       	ld	r23, X+
    d046:	8d 91       	ld	r24, X+
    d048:	9c 91       	ld	r25, X
    d04a:	03 c0       	rjmp	.+6      	; 0xd052 <WebServer+0x6b6>
    d04c:	cd 01       	movw	r24, r26
    d04e:	0e 94 76 73 	call	0xe6ec	; 0xe6ec <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    d052:	ae 01       	movw	r20, r28
    d054:	4f 5f       	subi	r20, 0xFF	; 255
    d056:	5f 4f       	sbci	r21, 0xFF	; 255
    d058:	0e 94 c9 41 	call	0x8392	; 0x8392 <Put_zDVal>
    d05c:	94 c0       	rjmp	.+296    	; 0xd186 <WebServer+0x7ea>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    d05e:	6d 91       	ld	r22, X+
    d060:	7d 91       	ld	r23, X+
    d062:	8d 91       	ld	r24, X+
    d064:	9c 91       	ld	r25, X
    d066:	0b c0       	rjmp	.+22     	; 0xd07e <WebServer+0x6e2>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d068:	44 e0       	ldi	r20, 0x04	; 4
    d06a:	50 e0       	ldi	r21, 0x00	; 0
    d06c:	bd 01       	movw	r22, r26
    d06e:	ce 01       	movw	r24, r28
    d070:	07 96       	adiw	r24, 0x07	; 7
    d072:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    d076:	6f 81       	ldd	r22, Y+7	; 0x07
    d078:	78 85       	ldd	r23, Y+8	; 0x08
    d07a:	89 85       	ldd	r24, Y+9	; 0x09
    d07c:	9a 85       	ldd	r25, Y+10	; 0x0a
    d07e:	ae 01       	movw	r20, r28
    d080:	4f 5f       	subi	r20, 0xFF	; 255
    d082:	5f 4f       	sbci	r21, 0xFF	; 255
    d084:	0e 94 5c 42 	call	0x84b8	; 0x84b8 <Put_FFVal>
    d088:	7e c0       	rjmp	.+252    	; 0xd186 <WebServer+0x7ea>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    d08a:	6d 91       	ld	r22, X+
    d08c:	7d 91       	ld	r23, X+
    d08e:	8d 91       	ld	r24, X+
    d090:	9c 91       	ld	r25, X
    d092:	0b c0       	rjmp	.+22     	; 0xd0aa <WebServer+0x70e>
    d094:	44 e0       	ldi	r20, 0x04	; 4
    d096:	50 e0       	ldi	r21, 0x00	; 0
    d098:	bd 01       	movw	r22, r26
    d09a:	ce 01       	movw	r24, r28
    d09c:	07 96       	adiw	r24, 0x07	; 7
    d09e:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    d0a2:	6f 81       	ldd	r22, Y+7	; 0x07
    d0a4:	78 85       	ldd	r23, Y+8	; 0x08
    d0a6:	89 85       	ldd	r24, Y+9	; 0x09
    d0a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    d0aa:	ae 01       	movw	r20, r28
    d0ac:	4f 5f       	subi	r20, 0xFF	; 255
    d0ae:	5f 4f       	sbci	r21, 0xFF	; 255
    d0b0:	0e 94 9a 42 	call	0x8534	; 0x8534 <Put_GFVal>
    d0b4:	68 c0       	rjmp	.+208    	; 0xd186 <WebServer+0x7ea>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    d0b6:	8c 91       	ld	r24, X
    d0b8:	03 c0       	rjmp	.+6      	; 0xd0c0 <WebServer+0x724>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d0ba:	cd 01       	movw	r24, r26
    d0bc:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    d0c0:	88 0e       	add	r8, r24
    d0c2:	91 1c       	adc	r9, r1
    d0c4:	88 0e       	add	r8, r24
    d0c6:	91 1c       	adc	r9, r1
    d0c8:	9e 82       	std	Y+6, r9	; 0x06
    d0ca:	8d 82       	std	Y+5, r8	; 0x05
		PutEnum(Param);
    d0cc:	ce 01       	movw	r24, r28
    d0ce:	01 96       	adiw	r24, 0x01	; 1
    d0d0:	0e 94 42 3e 	call	0x7c84	; 0x7c84 <PutEnum>
    d0d4:	58 c0       	rjmp	.+176    	; 0xd186 <WebServer+0x7ea>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d0d6:	2b 81       	ldd	r18, Y+3	; 0x03
    d0d8:	82 2f       	mov	r24, r18
    d0da:	86 95       	lsr	r24
    d0dc:	86 95       	lsr	r24
    d0de:	86 95       	lsr	r24
    d0e0:	a8 0f       	add	r26, r24
    d0e2:	b1 1d       	adc	r27, r1
    d0e4:	8c 91       	ld	r24, X
    d0e6:	90 e0       	ldi	r25, 0x00	; 0
    d0e8:	0e c0       	rjmp	.+28     	; 0xd106 <WebServer+0x76a>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d0ea:	2b 81       	ldd	r18, Y+3	; 0x03
    d0ec:	82 2f       	mov	r24, r18
    d0ee:	86 95       	lsr	r24
    d0f0:	86 95       	lsr	r24
    d0f2:	86 95       	lsr	r24
    d0f4:	fd 01       	movw	r30, r26
    d0f6:	e8 0f       	add	r30, r24
    d0f8:	f1 1d       	adc	r31, r1
    d0fa:	cf 01       	movw	r24, r30
    d0fc:	2c 87       	std	Y+12, r18	; 0x0c
    d0fe:	0e 94 6e 73 	call	0xe6dc	; 0xe6dc <__eerd_byte_m128>
    d102:	90 e0       	ldi	r25, 0x00	; 0
    d104:	2c 85       	ldd	r18, Y+12	; 0x0c
    d106:	27 70       	andi	r18, 0x07	; 7
    d108:	a5 01       	movw	r20, r10
    d10a:	02 c0       	rjmp	.+4      	; 0xd110 <WebServer+0x774>
    d10c:	44 0f       	add	r20, r20
    d10e:	55 1f       	adc	r21, r21
    d110:	2a 95       	dec	r18
    d112:	e2 f7       	brpl	.-8      	; 0xd10c <WebServer+0x770>
    d114:	84 23       	and	r24, r20
    d116:	95 23       	and	r25, r21
    d118:	89 2b       	or	r24, r25
    d11a:	19 f0       	breq	.+6      	; 0xd122 <WebServer+0x786>
    d11c:	e2 e0       	ldi	r30, 0x02	; 2
    d11e:	f0 e0       	ldi	r31, 0x00	; 0
    d120:	02 c0       	rjmp	.+4      	; 0xd126 <WebServer+0x78a>
    d122:	e0 e0       	ldi	r30, 0x00	; 0
    d124:	f0 e0       	ldi	r31, 0x00	; 0
    d126:	e8 0d       	add	r30, r8
    d128:	f9 1d       	adc	r31, r9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d12a:	65 91       	lpm	r22, Z+
    d12c:	74 91       	lpm	r23, Z
    d12e:	c7 01       	movw	r24, r14
    d130:	0e 94 e5 6b 	call	0xd7ca	; 0xd7ca <strcpy_P>
    d134:	28 c0       	rjmp	.+80     	; 0xd186 <WebServer+0x7ea>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    d136:	be 01       	movw	r22, r28
    d138:	6f 5f       	subi	r22, 0xFF	; 255
    d13a:	7f 4f       	sbci	r23, 0xFF	; 255
    d13c:	cd 01       	movw	r24, r26
    d13e:	0e 94 ed 42 	call	0x85da	; 0x85da <Put_TextValAlignLeft>
    d142:	21 c0       	rjmp	.+66     	; 0xd186 <WebServer+0x7ea>
    d144:	8d b6       	in	r8, 0x3d	; 61
    d146:	9e b6       	in	r9, 0x3e	; 62
		break;
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    d148:	ca 01       	movw	r24, r20
    d14a:	01 96       	adiw	r24, 0x01	; 1
    d14c:	ed b7       	in	r30, 0x3d	; 61
    d14e:	fe b7       	in	r31, 0x3e	; 62
    d150:	e8 1b       	sub	r30, r24
    d152:	f9 0b       	sbc	r31, r25
    d154:	0f b6       	in	r0, 0x3f	; 63
    d156:	f8 94       	cli
    d158:	fe bf       	out	0x3e, r31	; 62
    d15a:	0f be       	out	0x3f, r0	; 63
    d15c:	ed bf       	out	0x3d, r30	; 61
    d15e:	2d b7       	in	r18, 0x3d	; 61
    d160:	3e b7       	in	r19, 0x3e	; 62
    d162:	2f 5f       	subi	r18, 0xFF	; 255
    d164:	3f 4f       	sbci	r19, 0xFF	; 255
    d166:	79 01       	movw	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d168:	bd 01       	movw	r22, r26
    d16a:	c9 01       	movw	r24, r18
    d16c:	0e 94 5e 73 	call	0xe6bc	; 0xe6bc <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    d170:	be 01       	movw	r22, r28
    d172:	6f 5f       	subi	r22, 0xFF	; 255
    d174:	7f 4f       	sbci	r23, 0xFF	; 255
    d176:	c7 01       	movw	r24, r14
    d178:	0e 94 ed 42 	call	0x85da	; 0x85da <Put_TextValAlignLeft>
    d17c:	0f b6       	in	r0, 0x3f	; 63
    d17e:	f8 94       	cli
    d180:	9e be       	out	0x3e, r9	; 62
    d182:	0f be       	out	0x3f, r0	; 63
    d184:	8d be       	out	0x3d, r8	; 61
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    d186:	36 e0       	ldi	r19, 0x06	; 6
    d188:	c3 0e       	add	r12, r19
    d18a:	d1 1c       	adc	r13, r1
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    d18c:	8c 81       	ldd	r24, Y+4	; 0x04
    d18e:	86 0d       	add	r24, r6
    d190:	e8 2f       	mov	r30, r24
    d192:	f0 e0       	ldi	r31, 0x00	; 0
    d194:	ea 5d       	subi	r30, 0xDA	; 218
    d196:	f3 4f       	sbci	r31, 0xF3	; 243
    d198:	70 82       	st	Z, r7
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    d19a:	66 24       	eor	r6, r6
    d19c:	63 94       	inc	r6
    d19e:	68 0e       	add	r6, r24
    d1a0:	74 ce       	rjmp	.-792    	; 0xce8a <WebServer+0x4ee>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    d1a2:	d0 92 37 02 	sts	0x0237, r13
    d1a6:	c0 92 36 02 	sts	0x0236, r12
				}
				GSMTxSz = i;
    d1aa:	00 93 45 09 	sts	0x0945, r16
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d1ae:	20 91 45 09 	lds	r18, 0x0945
    d1b2:	80 91 34 02 	lds	r24, 0x0234
    d1b6:	90 91 35 02 	lds	r25, 0x0235
    d1ba:	82 0f       	add	r24, r18
    d1bc:	91 1d       	adc	r25, r1
				if(PacketByteCount >= MaxPacketSz){
    d1be:	81 15       	cp	r24, r1
    d1c0:	54 e0       	ldi	r21, 0x04	; 4
    d1c2:	95 07       	cpc	r25, r21
    d1c4:	28 f4       	brcc	.+10     	; 0xd1d0 <WebServer+0x834>
					}
					ptrIF = PutWebLine(ptrIF, i);
				}
				GSMTxSz = i;
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d1c6:	90 93 35 02 	sts	0x0235, r25
    d1ca:	80 93 34 02 	sts	0x0234, r24
    d1ce:	0b c0       	rjmp	.+22     	; 0xd1e6 <WebServer+0x84a>
				if(PacketByteCount >= MaxPacketSz){
					PacketByteCount -= MaxPacketSz;
    d1d0:	94 50       	subi	r25, 0x04	; 4
    d1d2:	90 93 35 02 	sts	0x0235, r25
    d1d6:	80 93 34 02 	sts	0x0234, r24
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    d1da:	68 ec       	ldi	r22, 0xC8	; 200
    d1dc:	70 e0       	ldi	r23, 0x00	; 0
    d1de:	80 91 3d 09 	lds	r24, 0x093D
    d1e2:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
				}
				GSM_SendFirstChar();
    d1e6:	0e 94 4e 57 	call	0xae9c	; 0xae9c <GSM_SendFirstChar>
    d1ea:	02 c0       	rjmp	.+4      	; 0xd1f0 <WebServer+0x854>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    d1ec:	10 92 38 02 	sts	0x0238, r1
	}

}
    d1f0:	0f b6       	in	r0, 0x3f	; 63
    d1f2:	f8 94       	cli
    d1f4:	3e be       	out	0x3e, r3	; 62
    d1f6:	0f be       	out	0x3f, r0	; 63
    d1f8:	2d be       	out	0x3d, r2	; 61
    d1fa:	2c 96       	adiw	r28, 0x0c	; 12
    d1fc:	0f b6       	in	r0, 0x3f	; 63
    d1fe:	f8 94       	cli
    d200:	de bf       	out	0x3e, r29	; 62
    d202:	0f be       	out	0x3f, r0	; 63
    d204:	cd bf       	out	0x3d, r28	; 61
    d206:	df 91       	pop	r29
    d208:	cf 91       	pop	r28
    d20a:	1f 91       	pop	r17
    d20c:	0f 91       	pop	r16
    d20e:	ff 90       	pop	r15
    d210:	ef 90       	pop	r14
    d212:	df 90       	pop	r13
    d214:	cf 90       	pop	r12
    d216:	bf 90       	pop	r11
    d218:	af 90       	pop	r10
    d21a:	9f 90       	pop	r9
    d21c:	8f 90       	pop	r8
    d21e:	7f 90       	pop	r7
    d220:	6f 90       	pop	r6
    d222:	5f 90       	pop	r5
    d224:	4f 90       	pop	r4
    d226:	3f 90       	pop	r3
    d228:	2f 90       	pop	r2
    d22a:	08 95       	ret

0000d22c <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    d22c:	80 91 63 0a 	lds	r24, 0x0A63
    d230:	88 23       	and	r24, r24
    d232:	09 f4       	brne	.+2      	; 0xd236 <GSM_DRE+0xa>
    d234:	55 c0       	rjmp	.+170    	; 0xd2e0 <GSM_DRE+0xb4>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d236:	90 91 5d 09 	lds	r25, 0x095D
    d23a:	80 91 25 0d 	lds	r24, 0x0D25
    d23e:	98 17       	cp	r25, r24
    d240:	a1 f0       	breq	.+40     	; 0xd26a <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    d242:	80 91 25 0d 	lds	r24, 0x0D25
    d246:	8f 5f       	subi	r24, 0xFF	; 255
    d248:	80 93 25 0d 	sts	0x0D25, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d24c:	80 91 25 0d 	lds	r24, 0x0D25
    d250:	8f 3f       	cpi	r24, 0xFF	; 255
    d252:	11 f4       	brne	.+4      	; 0xd258 <GSM_DRE+0x2c>
    d254:	10 92 25 0d 	sts	0x0D25, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    d258:	e0 91 25 0d 	lds	r30, 0x0D25
    d25c:	f0 e0       	ldi	r31, 0x00	; 0
    d25e:	ed 50       	subi	r30, 0x0D	; 13
    d260:	fc 4f       	sbci	r31, 0xFC	; 252
    d262:	80 81       	ld	r24, Z
    d264:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    d266:	5e 9a       	sbi	0x0b, 6	; 11
    d268:	02 c0       	rjmp	.+4      	; 0xd26e <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d26a:	88 ed       	ldi	r24, 0xD8	; 216
    d26c:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    d26e:	90 91 5d 09 	lds	r25, 0x095D
    d272:	80 91 25 0d 	lds	r24, 0x0D25
    d276:	89 17       	cp	r24, r25
    d278:	a0 f4       	brcc	.+40     	; 0xd2a2 <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    d27a:	20 91 5b 0a 	lds	r18, 0x0A5B
    d27e:	80 91 5d 09 	lds	r24, 0x095D
    d282:	40 91 25 0d 	lds	r20, 0x0D25
    d286:	30 e0       	ldi	r19, 0x00	; 0
    d288:	90 e0       	ldi	r25, 0x00	; 0
    d28a:	84 1b       	sub	r24, r20
    d28c:	91 09       	sbc	r25, r1
    d28e:	28 17       	cp	r18, r24
    d290:	39 07       	cpc	r19, r25
    d292:	3c f4       	brge	.+14     	; 0xd2a2 <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    d294:	80 91 5d 09 	lds	r24, 0x095D
    d298:	90 91 25 0d 	lds	r25, 0x0D25
    d29c:	89 1b       	sub	r24, r25
    d29e:	80 93 5b 0a 	sts	0x0A5B, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    d2a2:	90 91 25 0d 	lds	r25, 0x0D25
    d2a6:	80 91 5d 09 	lds	r24, 0x095D
    d2aa:	89 17       	cp	r24, r25
    d2ac:	e8 f5       	brcc	.+122    	; 0xd328 <GSM_DRE+0xfc>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    d2ae:	20 91 5b 0a 	lds	r18, 0x0A5B
    d2b2:	50 91 25 0d 	lds	r21, 0x0D25
    d2b6:	40 91 5d 09 	lds	r20, 0x095D
    d2ba:	30 e0       	ldi	r19, 0x00	; 0
    d2bc:	8f ef       	ldi	r24, 0xFF	; 255
    d2be:	90 e0       	ldi	r25, 0x00	; 0
    d2c0:	85 1b       	sub	r24, r21
    d2c2:	91 09       	sbc	r25, r1
    d2c4:	84 0f       	add	r24, r20
    d2c6:	91 1d       	adc	r25, r1
    d2c8:	28 17       	cp	r18, r24
    d2ca:	39 07       	cpc	r19, r25
    d2cc:	6c f5       	brge	.+90     	; 0xd328 <GSM_DRE+0xfc>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    d2ce:	80 91 5d 09 	lds	r24, 0x095D
    d2d2:	90 91 25 0d 	lds	r25, 0x0D25
    d2d6:	81 50       	subi	r24, 0x01	; 1
    d2d8:	89 1b       	sub	r24, r25
    d2da:	80 93 5b 0a 	sts	0x0A5B, r24
    d2de:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    d2e0:	90 91 33 0d 	lds	r25, 0x0D33
    d2e4:	80 91 45 09 	lds	r24, 0x0945
    d2e8:	98 17       	cp	r25, r24
    d2ea:	e0 f4       	brcc	.+56     	; 0xd324 <GSM_DRE+0xf8>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    d2ec:	e0 91 33 0d 	lds	r30, 0x0D33
    d2f0:	f0 e0       	ldi	r31, 0x00	; 0
    d2f2:	ea 5d       	subi	r30, 0xDA	; 218
    d2f4:	f3 4f       	sbci	r31, 0xF3	; 243
    d2f6:	80 81       	ld	r24, Z
    d2f8:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    d2fa:	80 91 df 09 	lds	r24, 0x09DF
    d2fe:	88 23       	and	r24, r24
    d300:	59 f0       	breq	.+22     	; 0xd318 <GSM_DRE+0xec>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    d302:	e0 91 33 0d 	lds	r30, 0x0D33
    d306:	f0 e0       	ldi	r31, 0x00	; 0
    d308:	ea 5d       	subi	r30, 0xDA	; 218
    d30a:	f3 4f       	sbci	r31, 0xF3	; 243
    d30c:	80 81       	ld	r24, Z
    d30e:	0e 94 c5 56 	call	0xad8a	; 0xad8a <SendDebug>
    d312:	88 e2       	ldi	r24, 0x28	; 40
    d314:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    d318:	80 91 33 0d 	lds	r24, 0x0D33
    d31c:	8f 5f       	subi	r24, 0xFF	; 255
    d31e:	80 93 33 0d 	sts	0x0D33, r24
    d322:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d324:	88 ed       	ldi	r24, 0xD8	; 216
    d326:	8a b9       	out	0x0a, r24	; 10
    d328:	08 95       	ret

0000d32a <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    d32a:	1f 92       	push	r1
    d32c:	0f 92       	push	r0
    d32e:	0f b6       	in	r0, 0x3f	; 63
    d330:	0f 92       	push	r0
    d332:	11 24       	eor	r1, r1
    d334:	0b b6       	in	r0, 0x3b	; 59
    d336:	0f 92       	push	r0
    d338:	2f 93       	push	r18
    d33a:	3f 93       	push	r19
    d33c:	4f 93       	push	r20
    d33e:	5f 93       	push	r21
    d340:	6f 93       	push	r22
    d342:	7f 93       	push	r23
    d344:	8f 93       	push	r24
    d346:	9f 93       	push	r25
    d348:	af 93       	push	r26
    d34a:	bf 93       	push	r27
    d34c:	ef 93       	push	r30
    d34e:	ff 93       	push	r31
	GSM_DRE();
    d350:	0e 94 16 69 	call	0xd22c	; 0xd22c <GSM_DRE>
	GSM_LED = 1;
    d354:	81 e0       	ldi	r24, 0x01	; 1
    d356:	80 93 04 06 	sts	0x0604, r24
}
    d35a:	ff 91       	pop	r31
    d35c:	ef 91       	pop	r30
    d35e:	bf 91       	pop	r27
    d360:	af 91       	pop	r26
    d362:	9f 91       	pop	r25
    d364:	8f 91       	pop	r24
    d366:	7f 91       	pop	r23
    d368:	6f 91       	pop	r22
    d36a:	5f 91       	pop	r21
    d36c:	4f 91       	pop	r20
    d36e:	3f 91       	pop	r19
    d370:	2f 91       	pop	r18
    d372:	0f 90       	pop	r0
    d374:	0b be       	out	0x3b, r0	; 59
    d376:	0f 90       	pop	r0
    d378:	0f be       	out	0x3f, r0	; 63
    d37a:	0f 90       	pop	r0
    d37c:	1f 90       	pop	r1
    d37e:	18 95       	reti

0000d380 <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d380:	90 91 5d 09 	lds	r25, 0x095D
    d384:	80 91 25 0d 	lds	r24, 0x0D25
    d388:	98 17       	cp	r25, r24
    d38a:	a1 f0       	breq	.+40     	; 0xd3b4 <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    d38c:	80 91 25 0d 	lds	r24, 0x0D25
    d390:	8f 5f       	subi	r24, 0xFF	; 255
    d392:	80 93 25 0d 	sts	0x0D25, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d396:	80 91 25 0d 	lds	r24, 0x0D25
    d39a:	8f 3f       	cpi	r24, 0xFF	; 255
    d39c:	11 f4       	brne	.+4      	; 0xd3a2 <Debug_DRE+0x22>
    d39e:	10 92 25 0d 	sts	0x0D25, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    d3a2:	e0 91 25 0d 	lds	r30, 0x0D25
    d3a6:	f0 e0       	ldi	r31, 0x00	; 0
    d3a8:	ed 50       	subi	r30, 0x0D	; 13
    d3aa:	fc 4f       	sbci	r31, 0xFC	; 252
    d3ac:	80 81       	ld	r24, Z
    d3ae:	80 93 9c 00 	sts	0x009C, r24
    d3b2:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    d3b4:	88 e0       	ldi	r24, 0x08	; 8
    d3b6:	80 93 9a 00 	sts	0x009A, r24
    d3ba:	08 95       	ret

0000d3bc <EMeter_DRE>:
	}*/
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    d3bc:	80 91 df 09 	lds	r24, 0x09DF
    d3c0:	81 11       	cpse	r24, r1
    d3c2:	0c 94 c0 69 	jmp	0xd380	; 0xd380 <Debug_DRE>
	else{
		if(Transparent){
    d3c6:	80 91 63 0a 	lds	r24, 0x0A63
    d3ca:	88 23       	and	r24, r24
    d3cc:	09 f4       	brne	.+2      	; 0xd3d0 <EMeter_DRE+0x14>
    d3ce:	5c c0       	rjmp	.+184    	; 0xd488 <EMeter_DRE+0xcc>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    d3d0:	90 91 75 08 	lds	r25, 0x0875
    d3d4:	80 91 e5 0a 	lds	r24, 0x0AE5
    d3d8:	98 17       	cp	r25, r24
    d3da:	d1 f0       	breq	.+52     	; 0xd410 <EMeter_DRE+0x54>
		GSM_RX_FIFO_End_Transp++;
    d3dc:	80 91 e5 0a 	lds	r24, 0x0AE5
    d3e0:	8f 5f       	subi	r24, 0xFF	; 255
    d3e2:	80 93 e5 0a 	sts	0x0AE5, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    d3e6:	80 91 e5 0a 	lds	r24, 0x0AE5
    d3ea:	8a 3f       	cpi	r24, 0xFA	; 250
    d3ec:	10 f0       	brcs	.+4      	; 0xd3f2 <EMeter_DRE+0x36>
    d3ee:	10 92 e5 0a 	sts	0x0AE5, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    d3f2:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    d3f4:	e0 91 e5 0a 	lds	r30, 0x0AE5
    d3f8:	f0 e0       	ldi	r31, 0x00	; 0
    d3fa:	ee 50       	subi	r30, 0x0E	; 14
    d3fc:	fb 4f       	sbci	r31, 0xFB	; 251
    d3fe:	80 81       	ld	r24, Z
    d400:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    d404:	80 91 9b 00 	lds	r24, 0x009B
    d408:	80 64       	ori	r24, 0x40	; 64
    d40a:	80 93 9b 00 	sts	0x009B, r24
    d40e:	03 c0       	rjmp	.+6      	; 0xd416 <EMeter_DRE+0x5a>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d410:	88 ed       	ldi	r24, 0xD8	; 216
    d412:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    d416:	90 91 75 08 	lds	r25, 0x0875
    d41a:	80 91 e5 0a 	lds	r24, 0x0AE5
    d41e:	89 17       	cp	r24, r25
    d420:	a0 f4       	brcc	.+40     	; 0xd44a <EMeter_DRE+0x8e>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    d422:	20 91 6c 09 	lds	r18, 0x096C
    d426:	80 91 75 08 	lds	r24, 0x0875
    d42a:	40 91 e5 0a 	lds	r20, 0x0AE5
    d42e:	30 e0       	ldi	r19, 0x00	; 0
    d430:	90 e0       	ldi	r25, 0x00	; 0
    d432:	84 1b       	sub	r24, r20
    d434:	91 09       	sbc	r25, r1
    d436:	28 17       	cp	r18, r24
    d438:	39 07       	cpc	r19, r25
    d43a:	3c f4       	brge	.+14     	; 0xd44a <EMeter_DRE+0x8e>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    d43c:	80 91 75 08 	lds	r24, 0x0875
    d440:	90 91 e5 0a 	lds	r25, 0x0AE5
    d444:	89 1b       	sub	r24, r25
    d446:	80 93 6c 09 	sts	0x096C, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    d44a:	90 91 e5 0a 	lds	r25, 0x0AE5
    d44e:	80 91 75 08 	lds	r24, 0x0875
    d452:	89 17       	cp	r24, r25
    d454:	80 f5       	brcc	.+96     	; 0xd4b6 <EMeter_DRE+0xfa>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    d456:	20 91 6c 09 	lds	r18, 0x096C
    d45a:	50 91 e5 0a 	lds	r21, 0x0AE5
    d45e:	40 91 75 08 	lds	r20, 0x0875
    d462:	30 e0       	ldi	r19, 0x00	; 0
    d464:	8a ef       	ldi	r24, 0xFA	; 250
    d466:	90 e0       	ldi	r25, 0x00	; 0
    d468:	85 1b       	sub	r24, r21
    d46a:	91 09       	sbc	r25, r1
    d46c:	84 0f       	add	r24, r20
    d46e:	91 1d       	adc	r25, r1
    d470:	28 17       	cp	r18, r24
    d472:	39 07       	cpc	r19, r25
    d474:	04 f5       	brge	.+64     	; 0xd4b6 <EMeter_DRE+0xfa>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    d476:	80 91 75 08 	lds	r24, 0x0875
    d47a:	90 91 e5 0a 	lds	r25, 0x0AE5
    d47e:	86 50       	subi	r24, 0x06	; 6
    d480:	89 1b       	sub	r24, r25
    d482:	80 93 6c 09 	sts	0x096C, r24
    d486:	08 95       	ret
			GetByteFromGSM_FIFO_Transp();
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    d488:	90 91 3f 09 	lds	r25, 0x093F
    d48c:	80 91 34 0d 	lds	r24, 0x0D34
    d490:	98 17       	cp	r25, r24
    d492:	70 f4       	brcc	.+28     	; 0xd4b0 <EMeter_DRE+0xf4>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    d494:	e0 91 3f 09 	lds	r30, 0x093F
    d498:	f0 e0       	ldi	r31, 0x00	; 0
    d49a:	ea 51       	subi	r30, 0x1A	; 26
    d49c:	f5 4f       	sbci	r31, 0xF5	; 245
    d49e:	80 81       	ld	r24, Z
    d4a0:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    d4a4:	80 91 3f 09 	lds	r24, 0x093F
    d4a8:	8f 5f       	subi	r24, 0xFF	; 255
    d4aa:	80 93 3f 09 	sts	0x093F, r24
    d4ae:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d4b0:	88 ed       	ldi	r24, 0xD8	; 216
    d4b2:	80 93 9a 00 	sts	0x009A, r24
    d4b6:	08 95       	ret

0000d4b8 <__vector_31>:
}

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    d4b8:	1f 92       	push	r1
    d4ba:	0f 92       	push	r0
    d4bc:	0f b6       	in	r0, 0x3f	; 63
    d4be:	0f 92       	push	r0
    d4c0:	11 24       	eor	r1, r1
    d4c2:	0b b6       	in	r0, 0x3b	; 59
    d4c4:	0f 92       	push	r0
    d4c6:	2f 93       	push	r18
    d4c8:	3f 93       	push	r19
    d4ca:	4f 93       	push	r20
    d4cc:	5f 93       	push	r21
    d4ce:	6f 93       	push	r22
    d4d0:	7f 93       	push	r23
    d4d2:	8f 93       	push	r24
    d4d4:	9f 93       	push	r25
    d4d6:	af 93       	push	r26
    d4d8:	bf 93       	push	r27
    d4da:	ef 93       	push	r30
    d4dc:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    d4de:	80 91 da 03 	lds	r24, 0x03DA
    d4e2:	88 23       	and	r24, r24
    d4e4:	29 f0       	breq	.+10     	; 0xd4f0 <__vector_31+0x38>
    d4e6:	8c e9       	ldi	r24, 0x9C	; 156
    d4e8:	90 e0       	ldi	r25, 0x00	; 0
    d4ea:	0e 94 48 38 	call	0x7090	; 0x7090 <Modbus_TX>
    d4ee:	02 c0       	rjmp	.+4      	; 0xd4f4 <__vector_31+0x3c>
	else EMeter_DRE();
    d4f0:	0e 94 de 69 	call	0xd3bc	; 0xd3bc <EMeter_DRE>
	COMM_LED = 1;
    d4f4:	81 e0       	ldi	r24, 0x01	; 1
    d4f6:	80 93 0a 06 	sts	0x060A, r24
}
    d4fa:	ff 91       	pop	r31
    d4fc:	ef 91       	pop	r30
    d4fe:	bf 91       	pop	r27
    d500:	af 91       	pop	r26
    d502:	9f 91       	pop	r25
    d504:	8f 91       	pop	r24
    d506:	7f 91       	pop	r23
    d508:	6f 91       	pop	r22
    d50a:	5f 91       	pop	r21
    d50c:	4f 91       	pop	r20
    d50e:	3f 91       	pop	r19
    d510:	2f 91       	pop	r18
    d512:	0f 90       	pop	r0
    d514:	0b be       	out	0x3b, r0	; 59
    d516:	0f 90       	pop	r0
    d518:	0f be       	out	0x3f, r0	; 63
    d51a:	0f 90       	pop	r0
    d51c:	1f 90       	pop	r1
    d51e:	18 95       	reti

0000d520 <ToggleLED>:

//#include "web.h"
#include "web_vem_levels.h"

void ToggleLED(uint8_t DO){
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    d520:	40 91 50 09 	lds	r20, 0x0950
    d524:	50 91 51 09 	lds	r21, 0x0951
    d528:	60 91 52 09 	lds	r22, 0x0952
    d52c:	70 91 53 09 	lds	r23, 0x0953
    d530:	42 fd       	sbrc	r20, 2
    d532:	0c 94 f3 3b 	jmp	0x77e6	; 0x77e6 <ResDigOut>
	else SetDigOut(DO);
    d536:	0c 94 e1 3b 	jmp	0x77c2	; 0x77c2 <SetDigOut>

0000d53a <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    d53a:	0e 94 1e 2a 	call	0x543c	; 0x543c <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    d53e:	0e 94 c1 4c 	call	0x9982	; 0x9982 <GPRS_AppInit>
	#endif

	WebInit();
    d542:	0c 94 3e 43 	jmp	0x867c	; 0x867c <WebInit>

0000d546 <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
    d546:	69 e0       	ldi	r22, 0x09	; 9
    d548:	82 e8       	ldi	r24, 0x82	; 130
    d54a:	95 e0       	ldi	r25, 0x05	; 5
    d54c:	0e 94 ce 64 	call	0xc99c	; 0xc99c <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
    d550:	0e 94 25 55 	call	0xaa4a	; 0xaa4a <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
    d554:	0e 94 a8 55 	call	0xab50	; 0xab50 <Modbus_App>
		}
	*/	


	// GSM_DebugMode
	if(UART_Soft){
    d558:	80 91 62 0a 	lds	r24, 0x0A62
    d55c:	88 23       	and	r24, r24
    d55e:	09 f1       	breq	.+66     	; 0xd5a2 <ApplCycle+0x5c>
		if(GSM_DebugMode){
    d560:	80 91 df 09 	lds	r24, 0x09DF
    d564:	88 23       	and	r24, r24
    d566:	81 f0       	breq	.+32     	; 0xd588 <ApplCycle+0x42>
			if( DI_State(DI_BL) ){
    d568:	83 e0       	ldi	r24, 0x03	; 3
    d56a:	0e 94 72 3b 	call	0x76e4	; 0x76e4 <DI_State>
    d56e:	88 23       	and	r24, r24
    d570:	41 f0       	breq	.+16     	; 0xd582 <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
    d572:	81 e0       	ldi	r24, 0x01	; 1
    d574:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    d578:	88 23       	and	r24, r24
    d57a:	51 f1       	breq	.+84     	; 0xd5d0 <ApplCycle+0x8a>
					StopDebug();
    d57c:	0e 94 bb 56 	call	0xad76	; 0xad76 <StopDebug>
    d580:	22 c0       	rjmp	.+68     	; 0xd5c6 <ApplCycle+0x80>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
    d582:	62 e3       	ldi	r22, 0x32	; 50
    d584:	70 e0       	ldi	r23, 0x00	; 0
    d586:	21 c0       	rjmp	.+66     	; 0xd5ca <ApplCycle+0x84>
		}
		else{
			if( DI_State(DI_BL) ){
    d588:	83 e0       	ldi	r24, 0x03	; 3
    d58a:	0e 94 72 3b 	call	0x76e4	; 0x76e4 <DI_State>
    d58e:	88 23       	and	r24, r24
    d590:	69 f0       	breq	.+26     	; 0xd5ac <ApplCycle+0x66>
				if(Timer16Stopp(TD_GotoDebug)){
    d592:	81 e0       	ldi	r24, 0x01	; 1
    d594:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    d598:	88 23       	and	r24, r24
    d59a:	d1 f0       	breq	.+52     	; 0xd5d0 <ApplCycle+0x8a>
					StartDebug();
    d59c:	0e 94 a7 56 	call	0xad4e	; 0xad4e <StartDebug>
    d5a0:	12 c0       	rjmp	.+36     	; 0xd5c6 <ApplCycle+0x80>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
    d5a2:	83 e0       	ldi	r24, 0x03	; 3
    d5a4:	0e 94 72 3b 	call	0x76e4	; 0x76e4 <DI_State>
    d5a8:	81 11       	cpse	r24, r1
    d5aa:	03 c0       	rjmp	.+6      	; 0xd5b2 <ApplCycle+0x6c>
				if(Timer16Stopp(TD_GotoDebug)){
					StartDebug();
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,100);
    d5ac:	64 e6       	ldi	r22, 0x64	; 100
    d5ae:	70 e0       	ldi	r23, 0x00	; 0
    d5b0:	0c c0       	rjmp	.+24     	; 0xd5ca <ApplCycle+0x84>
		}
	}
	else{
		if( DI_State(DI_BL) ){
			if(Timer16Stopp(TD_GotoDebug)){
    d5b2:	81 e0       	ldi	r24, 0x01	; 1
    d5b4:	0e 94 34 2c 	call	0x5868	; 0x5868 <Timer16Stopp>
    d5b8:	88 23       	and	r24, r24
    d5ba:	51 f0       	breq	.+20     	; 0xd5d0 <ApplCycle+0x8a>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
    d5bc:	68 ef       	ldi	r22, 0xF8	; 248
    d5be:	7c e4       	ldi	r23, 0x4C	; 76
    d5c0:	82 e0       	ldi	r24, 0x02	; 2
    d5c2:	0e 94 89 4f 	call	0x9f12	; 0x9f12 <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
    d5c6:	64 ef       	ldi	r22, 0xF4	; 244
    d5c8:	71 e0       	ldi	r23, 0x01	; 1
    d5ca:	81 e0       	ldi	r24, 0x01	; 1
    d5cc:	0e 94 99 2a 	call	0x5532	; 0x5532 <StartTimer16>
		}
	}
	else ResDigOut(DO_BL);*/

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
    d5d0:	80 91 04 06 	lds	r24, 0x0604
    d5d4:	81 30       	cpi	r24, 0x01	; 1
    d5d6:	39 f4       	brne	.+14     	; 0xd5e6 <ApplCycle+0xa0>
		StartTimer8(TD_GSM_LED,5);
    d5d8:	65 e0       	ldi	r22, 0x05	; 5
    d5da:	83 e0       	ldi	r24, 0x03	; 3
    d5dc:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
		GSM_LED = 2;
    d5e0:	82 e0       	ldi	r24, 0x02	; 2
    d5e2:	80 93 04 06 	sts	0x0604, r24
	}
	if(GSM_LED ==2){
    d5e6:	80 91 04 06 	lds	r24, 0x0604
    d5ea:	82 30       	cpi	r24, 0x02	; 2
    d5ec:	31 f4       	brne	.+12     	; 0xd5fa <ApplCycle+0xb4>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
    d5ee:	83 e0       	ldi	r24, 0x03	; 3
    d5f0:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    d5f4:	81 11       	cpse	r24, r1
    d5f6:	10 92 04 06 	sts	0x0604, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ProtocolMode){
    d5fa:	80 91 21 06 	lds	r24, 0x0621
    d5fe:	8f 35       	cpi	r24, 0x5F	; 95
    d600:	61 f4       	brne	.+24     	; 0xd61a <ApplCycle+0xd4>
		if(GSM_LED) ToggleLED(DO_GSM);
    d602:	80 91 04 06 	lds	r24, 0x0604
    d606:	88 23       	and	r24, r24
    d608:	21 f0       	breq	.+8      	; 0xd612 <ApplCycle+0xcc>
    d60a:	80 e0       	ldi	r24, 0x00	; 0
    d60c:	0e 94 90 6a 	call	0xd520	; 0xd520 <ToggleLED>
    d610:	0a c0       	rjmp	.+20     	; 0xd626 <ApplCycle+0xe0>
		else SetDigOut(DO_GSM);
    d612:	80 e0       	ldi	r24, 0x00	; 0
    d614:	0e 94 e1 3b 	call	0x77c2	; 0x77c2 <SetDigOut>
    d618:	06 c0       	rjmp	.+12     	; 0xd626 <ApplCycle+0xe0>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
    d61a:	80 91 04 06 	lds	r24, 0x0604
    d61e:	81 11       	cpse	r24, r1
    d620:	f4 cf       	rjmp	.-24     	; 0xd60a <ApplCycle+0xc4>
		else ResDigOut(DO_GSM);
    d622:	0e 94 f3 3b 	call	0x77e6	; 0x77e6 <ResDigOut>
	}


	//----   COMM_LED  /  UART1
	if(COMM_LED == 1){
    d626:	80 91 0a 06 	lds	r24, 0x060A
    d62a:	81 30       	cpi	r24, 0x01	; 1
    d62c:	39 f4       	brne	.+14     	; 0xd63c <ApplCycle+0xf6>
		StartTimer8(TD_COMM_LED,5);
    d62e:	65 e0       	ldi	r22, 0x05	; 5
    d630:	82 e0       	ldi	r24, 0x02	; 2
    d632:	0e 94 6b 2a 	call	0x54d6	; 0x54d6 <StartTimer8>
		COMM_LED = 2;
    d636:	82 e0       	ldi	r24, 0x02	; 2
    d638:	80 93 0a 06 	sts	0x060A, r24
	}
	if(COMM_LED ==2){
    d63c:	80 91 0a 06 	lds	r24, 0x060A
    d640:	82 30       	cpi	r24, 0x02	; 2
    d642:	29 f4       	brne	.+10     	; 0xd64e <ApplCycle+0x108>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
    d644:	0e 94 19 2c 	call	0x5832	; 0x5832 <Timer8Stopp>
    d648:	81 11       	cpse	r24, r1
    d64a:	10 92 0a 06 	sts	0x060A, r1
	}
	//   COMM_LED 
	if(EMeter_Link()){
    d64e:	0e 94 ab 4c 	call	0x9956	; 0x9956 <EMeter_Link>
    d652:	88 23       	and	r24, r24
    d654:	51 f0       	breq	.+20     	; 0xd66a <ApplCycle+0x124>
		if(COMM_LED) ToggleLED(DO_RS);
    d656:	80 91 0a 06 	lds	r24, 0x060A
    d65a:	88 23       	and	r24, r24
    d65c:	19 f0       	breq	.+6      	; 0xd664 <ApplCycle+0x11e>
    d65e:	81 e0       	ldi	r24, 0x01	; 1
    d660:	0c 94 90 6a 	jmp	0xd520	; 0xd520 <ToggleLED>
		else SetDigOut(DO_RS);
    d664:	81 e0       	ldi	r24, 0x01	; 1
    d666:	0c 94 e1 3b 	jmp	0x77c2	; 0x77c2 <SetDigOut>
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
    d66a:	80 91 0a 06 	lds	r24, 0x060A
    d66e:	81 11       	cpse	r24, r1
    d670:	f6 cf       	rjmp	.-20     	; 0xd65e <ApplCycle+0x118>
		else ResDigOut(DO_RS);
    d672:	81 e0       	ldi	r24, 0x01	; 1
    d674:	0c 94 f3 3b 	jmp	0x77e6	; 0x77e6 <ResDigOut>

0000d678 <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimersInc();
    d678:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <TimersInc>
	TimeInit();
    d67c:	0e 94 b5 2c 	call	0x596a	; 0x596a <TimeInit>
	MemCheckInit();
    d680:	0e 94 f4 29 	call	0x53e8	; 0x53e8 <MemCheckInit>

// ~~~~~~~~~~
void
DI_Init(void)
{
	DI_Init_Hard();
    d684:	0e 94 d3 28 	call	0x51a6	; 0x51a6 <DI_Init_Hard>
	LED_Init();
	DigitInit();
    d688:	0e 94 39 3c 	call	0x7872	; 0x7872 <DO_Init>
	OneWire_Init();
    d68c:	0e 94 de 3c 	call	0x79bc	; 0x79bc <OneWire_Init>
	USART_Init();
    d690:	0e 94 d9 4b 	call	0x97b2	; 0x97b2 <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    d694:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {TimersInc();
    d696:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <TimersInc>
		wdt_reset();
    d69a:	a8 95       	wdr
		DigitIn();
    d69c:	0e 94 96 3b 	call	0x772c	; 0x772c <DigitIn>
		DS18B20();
    d6a0:	0e 94 19 3e 	call	0x7c32	; 0x7c32 <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
    d6a4:	80 91 50 02 	lds	r24, 0x0250
    d6a8:	87 30       	cpi	r24, 0x07	; 7
    d6aa:	a9 f7       	brne	.-22     	; 0xd696 <main+0x1e>

//	MemCheckMsg();

	ApplInit();
    d6ac:	0e 94 9d 6a 	call	0xd53a	; 0xd53a <ApplInit>
	
	ScanCycleInit();
    d6b0:	0e 94 f3 2c 	call	0x59e6	; 0x59e6 <ScanCycleInit>

	for(;;) {TimersInc();
    d6b4:	0e 94 49 2d 	call	0x5a92	; 0x5a92 <TimersInc>
		sei();
    d6b8:	78 94       	sei

		TimeCycle();
    d6ba:	0e 94 45 2e 	call	0x5c8a	; 0x5c8a <TimeCycle>
		DigitIn();
    d6be:	0e 94 96 3b 	call	0x772c	; 0x772c <DigitIn>
		DS18B20();
    d6c2:	0e 94 19 3e 	call	0x7c32	; 0x7c32 <DS18B20>
		USART_Cycle();
    d6c6:	0e 94 95 64 	call	0xc92a	; 0xc92a <USART_Cycle>

		ApplCycle();
    d6ca:	0e 94 a3 6a 	call	0xd546	; 0xd546 <ApplCycle>

		DigitOut();
    d6ce:	0e 94 06 3c 	call	0x780c	; 0x780c <DigitOut>
    d6d2:	f0 cf       	rjmp	.-32     	; 0xd6b4 <main+0x3c>

0000d6d4 <do_random>:
    d6d4:	8f 92       	push	r8
    d6d6:	9f 92       	push	r9
    d6d8:	af 92       	push	r10
    d6da:	bf 92       	push	r11
    d6dc:	cf 92       	push	r12
    d6de:	df 92       	push	r13
    d6e0:	ef 92       	push	r14
    d6e2:	ff 92       	push	r15
    d6e4:	cf 93       	push	r28
    d6e6:	df 93       	push	r29
    d6e8:	ec 01       	movw	r28, r24
    d6ea:	68 81       	ld	r22, Y
    d6ec:	79 81       	ldd	r23, Y+1	; 0x01
    d6ee:	8a 81       	ldd	r24, Y+2	; 0x02
    d6f0:	9b 81       	ldd	r25, Y+3	; 0x03
    d6f2:	61 15       	cp	r22, r1
    d6f4:	71 05       	cpc	r23, r1
    d6f6:	81 05       	cpc	r24, r1
    d6f8:	91 05       	cpc	r25, r1
    d6fa:	21 f4       	brne	.+8      	; 0xd704 <do_random+0x30>
    d6fc:	64 e2       	ldi	r22, 0x24	; 36
    d6fe:	79 ed       	ldi	r23, 0xD9	; 217
    d700:	8b e5       	ldi	r24, 0x5B	; 91
    d702:	97 e0       	ldi	r25, 0x07	; 7
    d704:	2d e1       	ldi	r18, 0x1D	; 29
    d706:	33 ef       	ldi	r19, 0xF3	; 243
    d708:	41 e0       	ldi	r20, 0x01	; 1
    d70a:	50 e0       	ldi	r21, 0x00	; 0
    d70c:	0e 94 04 75 	call	0xea08	; 0xea08 <__divmodsi4>
    d710:	49 01       	movw	r8, r18
    d712:	5a 01       	movw	r10, r20
    d714:	9b 01       	movw	r18, r22
    d716:	ac 01       	movw	r20, r24
    d718:	a7 ea       	ldi	r26, 0xA7	; 167
    d71a:	b1 e4       	ldi	r27, 0x41	; 65
    d71c:	0e 94 29 75 	call	0xea52	; 0xea52 <__muluhisi3>
    d720:	6b 01       	movw	r12, r22
    d722:	7c 01       	movw	r14, r24
    d724:	ac ee       	ldi	r26, 0xEC	; 236
    d726:	b4 ef       	ldi	r27, 0xF4	; 244
    d728:	a5 01       	movw	r20, r10
    d72a:	94 01       	movw	r18, r8
    d72c:	0e 94 37 75 	call	0xea6e	; 0xea6e <__mulohisi3>
    d730:	c6 0e       	add	r12, r22
    d732:	d7 1e       	adc	r13, r23
    d734:	e8 1e       	adc	r14, r24
    d736:	f9 1e       	adc	r15, r25
    d738:	f7 fe       	sbrs	r15, 7
    d73a:	06 c0       	rjmp	.+12     	; 0xd748 <do_random+0x74>
    d73c:	81 e0       	ldi	r24, 0x01	; 1
    d73e:	c8 1a       	sub	r12, r24
    d740:	d1 08       	sbc	r13, r1
    d742:	e1 08       	sbc	r14, r1
    d744:	80 e8       	ldi	r24, 0x80	; 128
    d746:	f8 0a       	sbc	r15, r24
    d748:	c8 82       	st	Y, r12
    d74a:	d9 82       	std	Y+1, r13	; 0x01
    d74c:	ea 82       	std	Y+2, r14	; 0x02
    d74e:	fb 82       	std	Y+3, r15	; 0x03
    d750:	c7 01       	movw	r24, r14
    d752:	b6 01       	movw	r22, r12
    d754:	9f 77       	andi	r25, 0x7F	; 127
    d756:	df 91       	pop	r29
    d758:	cf 91       	pop	r28
    d75a:	ff 90       	pop	r15
    d75c:	ef 90       	pop	r14
    d75e:	df 90       	pop	r13
    d760:	cf 90       	pop	r12
    d762:	bf 90       	pop	r11
    d764:	af 90       	pop	r10
    d766:	9f 90       	pop	r9
    d768:	8f 90       	pop	r8
    d76a:	08 95       	ret

0000d76c <random_r>:
    d76c:	0c 94 6a 6b 	jmp	0xd6d4	; 0xd6d4 <do_random>

0000d770 <random>:
    d770:	80 e0       	ldi	r24, 0x00	; 0
    d772:	91 e0       	ldi	r25, 0x01	; 1
    d774:	0c 94 6a 6b 	jmp	0xd6d4	; 0xd6d4 <do_random>

0000d778 <srandom>:
    d778:	60 93 00 01 	sts	0x0100, r22
    d77c:	70 93 01 01 	sts	0x0101, r23
    d780:	80 93 02 01 	sts	0x0102, r24
    d784:	90 93 03 01 	sts	0x0103, r25
    d788:	08 95       	ret

0000d78a <exit>:
    d78a:	f8 94       	cli
    d78c:	0c 94 ad 75 	jmp	0xeb5a	; 0xeb5a <_exit>

0000d790 <memcpy_P>:
    d790:	fb 01       	movw	r30, r22
    d792:	dc 01       	movw	r26, r24
    d794:	02 c0       	rjmp	.+4      	; 0xd79a <memcpy_P+0xa>
    d796:	05 90       	lpm	r0, Z+
    d798:	0d 92       	st	X+, r0
    d79a:	41 50       	subi	r20, 0x01	; 1
    d79c:	50 40       	sbci	r21, 0x00	; 0
    d79e:	d8 f7       	brcc	.-10     	; 0xd796 <memcpy_P+0x6>
    d7a0:	08 95       	ret

0000d7a2 <strchr_P>:
    d7a2:	fc 01       	movw	r30, r24
    d7a4:	05 90       	lpm	r0, Z+
    d7a6:	06 16       	cp	r0, r22
    d7a8:	21 f0       	breq	.+8      	; 0xd7b2 <strchr_P+0x10>
    d7aa:	00 20       	and	r0, r0
    d7ac:	d9 f7       	brne	.-10     	; 0xd7a4 <strchr_P+0x2>
    d7ae:	c0 01       	movw	r24, r0
    d7b0:	08 95       	ret
    d7b2:	31 97       	sbiw	r30, 0x01	; 1
    d7b4:	cf 01       	movw	r24, r30
    d7b6:	08 95       	ret

0000d7b8 <strcmp_P>:
    d7b8:	fb 01       	movw	r30, r22
    d7ba:	dc 01       	movw	r26, r24
    d7bc:	8d 91       	ld	r24, X+
    d7be:	05 90       	lpm	r0, Z+
    d7c0:	80 19       	sub	r24, r0
    d7c2:	01 10       	cpse	r0, r1
    d7c4:	d9 f3       	breq	.-10     	; 0xd7bc <strcmp_P+0x4>
    d7c6:	99 0b       	sbc	r25, r25
    d7c8:	08 95       	ret

0000d7ca <strcpy_P>:
    d7ca:	fb 01       	movw	r30, r22
    d7cc:	dc 01       	movw	r26, r24
    d7ce:	05 90       	lpm	r0, Z+
    d7d0:	0d 92       	st	X+, r0
    d7d2:	00 20       	and	r0, r0
    d7d4:	e1 f7       	brne	.-8      	; 0xd7ce <strcpy_P+0x4>
    d7d6:	08 95       	ret

0000d7d8 <strlcpy_P>:
    d7d8:	dc 01       	movw	r26, r24
    d7da:	fb 01       	movw	r30, r22
    d7dc:	41 50       	subi	r20, 0x01	; 1
    d7de:	50 40       	sbci	r21, 0x00	; 0
    d7e0:	58 f0       	brcs	.+22     	; 0xd7f8 <strlcpy_P+0x20>
    d7e2:	49 f0       	breq	.+18     	; 0xd7f6 <strlcpy_P+0x1e>
    d7e4:	05 90       	lpm	r0, Z+
    d7e6:	0d 92       	st	X+, r0
    d7e8:	00 20       	and	r0, r0
    d7ea:	c1 f7       	brne	.-16     	; 0xd7dc <strlcpy_P+0x4>
    d7ec:	e6 1b       	sub	r30, r22
    d7ee:	f7 0b       	sbc	r31, r23
    d7f0:	31 97       	sbiw	r30, 0x01	; 1
    d7f2:	cf 01       	movw	r24, r30
    d7f4:	08 95       	ret
    d7f6:	1c 92       	st	X, r1
    d7f8:	05 90       	lpm	r0, Z+
    d7fa:	00 20       	and	r0, r0
    d7fc:	e9 f7       	brne	.-6      	; 0xd7f8 <strlcpy_P+0x20>
    d7fe:	f6 cf       	rjmp	.-20     	; 0xd7ec <strlcpy_P+0x14>

0000d800 <__strlen_P>:
    d800:	fc 01       	movw	r30, r24
    d802:	05 90       	lpm	r0, Z+
    d804:	00 20       	and	r0, r0
    d806:	e9 f7       	brne	.-6      	; 0xd802 <__strlen_P+0x2>
    d808:	80 95       	com	r24
    d80a:	90 95       	com	r25
    d80c:	8e 0f       	add	r24, r30
    d80e:	9f 1f       	adc	r25, r31
    d810:	08 95       	ret

0000d812 <strncmp_P>:
    d812:	fb 01       	movw	r30, r22
    d814:	dc 01       	movw	r26, r24
    d816:	41 50       	subi	r20, 0x01	; 1
    d818:	50 40       	sbci	r21, 0x00	; 0
    d81a:	30 f0       	brcs	.+12     	; 0xd828 <strncmp_P+0x16>
    d81c:	8d 91       	ld	r24, X+
    d81e:	05 90       	lpm	r0, Z+
    d820:	80 19       	sub	r24, r0
    d822:	19 f4       	brne	.+6      	; 0xd82a <strncmp_P+0x18>
    d824:	00 20       	and	r0, r0
    d826:	b9 f7       	brne	.-18     	; 0xd816 <strncmp_P+0x4>
    d828:	88 1b       	sub	r24, r24
    d82a:	99 0b       	sbc	r25, r25
    d82c:	08 95       	ret

0000d82e <strstr_P>:
    d82e:	fb 01       	movw	r30, r22
    d830:	55 91       	lpm	r21, Z+
    d832:	55 23       	and	r21, r21
    d834:	a9 f0       	breq	.+42     	; 0xd860 <strstr_P+0x32>
    d836:	bf 01       	movw	r22, r30
    d838:	dc 01       	movw	r26, r24
    d83a:	4d 91       	ld	r20, X+
    d83c:	45 17       	cp	r20, r21
    d83e:	41 11       	cpse	r20, r1
    d840:	e1 f7       	brne	.-8      	; 0xd83a <strstr_P+0xc>
    d842:	59 f4       	brne	.+22     	; 0xd85a <strstr_P+0x2c>
    d844:	cd 01       	movw	r24, r26
    d846:	05 90       	lpm	r0, Z+
    d848:	00 20       	and	r0, r0
    d84a:	49 f0       	breq	.+18     	; 0xd85e <strstr_P+0x30>
    d84c:	4d 91       	ld	r20, X+
    d84e:	40 15       	cp	r20, r0
    d850:	41 11       	cpse	r20, r1
    d852:	c9 f3       	breq	.-14     	; 0xd846 <strstr_P+0x18>
    d854:	fb 01       	movw	r30, r22
    d856:	41 11       	cpse	r20, r1
    d858:	ef cf       	rjmp	.-34     	; 0xd838 <strstr_P+0xa>
    d85a:	81 e0       	ldi	r24, 0x01	; 1
    d85c:	90 e0       	ldi	r25, 0x00	; 0
    d85e:	01 97       	sbiw	r24, 0x01	; 1
    d860:	08 95       	ret

0000d862 <memcpy>:
    d862:	fb 01       	movw	r30, r22
    d864:	dc 01       	movw	r26, r24
    d866:	02 c0       	rjmp	.+4      	; 0xd86c <memcpy+0xa>
    d868:	01 90       	ld	r0, Z+
    d86a:	0d 92       	st	X+, r0
    d86c:	41 50       	subi	r20, 0x01	; 1
    d86e:	50 40       	sbci	r21, 0x00	; 0
    d870:	d8 f7       	brcc	.-10     	; 0xd868 <memcpy+0x6>
    d872:	08 95       	ret

0000d874 <strchr>:
    d874:	fc 01       	movw	r30, r24
    d876:	81 91       	ld	r24, Z+
    d878:	86 17       	cp	r24, r22
    d87a:	21 f0       	breq	.+8      	; 0xd884 <strchr+0x10>
    d87c:	88 23       	and	r24, r24
    d87e:	d9 f7       	brne	.-10     	; 0xd876 <strchr+0x2>
    d880:	99 27       	eor	r25, r25
    d882:	08 95       	ret
    d884:	31 97       	sbiw	r30, 0x01	; 1
    d886:	cf 01       	movw	r24, r30
    d888:	08 95       	ret

0000d88a <strcmp>:
    d88a:	fb 01       	movw	r30, r22
    d88c:	dc 01       	movw	r26, r24
    d88e:	8d 91       	ld	r24, X+
    d890:	01 90       	ld	r0, Z+
    d892:	80 19       	sub	r24, r0
    d894:	01 10       	cpse	r0, r1
    d896:	d9 f3       	breq	.-10     	; 0xd88e <strcmp+0x4>
    d898:	99 0b       	sbc	r25, r25
    d89a:	08 95       	ret

0000d89c <strcpy>:
    d89c:	fb 01       	movw	r30, r22
    d89e:	dc 01       	movw	r26, r24
    d8a0:	01 90       	ld	r0, Z+
    d8a2:	0d 92       	st	X+, r0
    d8a4:	00 20       	and	r0, r0
    d8a6:	e1 f7       	brne	.-8      	; 0xd8a0 <strcpy+0x4>
    d8a8:	08 95       	ret

0000d8aa <strncmp>:
    d8aa:	fb 01       	movw	r30, r22
    d8ac:	dc 01       	movw	r26, r24
    d8ae:	41 50       	subi	r20, 0x01	; 1
    d8b0:	50 40       	sbci	r21, 0x00	; 0
    d8b2:	30 f0       	brcs	.+12     	; 0xd8c0 <strncmp+0x16>
    d8b4:	8d 91       	ld	r24, X+
    d8b6:	01 90       	ld	r0, Z+
    d8b8:	80 19       	sub	r24, r0
    d8ba:	19 f4       	brne	.+6      	; 0xd8c2 <strncmp+0x18>
    d8bc:	00 20       	and	r0, r0
    d8be:	b9 f7       	brne	.-18     	; 0xd8ae <strncmp+0x4>
    d8c0:	88 1b       	sub	r24, r24
    d8c2:	99 0b       	sbc	r25, r25
    d8c4:	08 95       	ret

0000d8c6 <sprintf>:
    d8c6:	0f 93       	push	r16
    d8c8:	1f 93       	push	r17
    d8ca:	cf 93       	push	r28
    d8cc:	df 93       	push	r29
    d8ce:	cd b7       	in	r28, 0x3d	; 61
    d8d0:	de b7       	in	r29, 0x3e	; 62
    d8d2:	2e 97       	sbiw	r28, 0x0e	; 14
    d8d4:	0f b6       	in	r0, 0x3f	; 63
    d8d6:	f8 94       	cli
    d8d8:	de bf       	out	0x3e, r29	; 62
    d8da:	0f be       	out	0x3f, r0	; 63
    d8dc:	cd bf       	out	0x3d, r28	; 61
    d8de:	0d 89       	ldd	r16, Y+21	; 0x15
    d8e0:	1e 89       	ldd	r17, Y+22	; 0x16
    d8e2:	86 e0       	ldi	r24, 0x06	; 6
    d8e4:	8c 83       	std	Y+4, r24	; 0x04
    d8e6:	1a 83       	std	Y+2, r17	; 0x02
    d8e8:	09 83       	std	Y+1, r16	; 0x01
    d8ea:	8f ef       	ldi	r24, 0xFF	; 255
    d8ec:	9f e7       	ldi	r25, 0x7F	; 127
    d8ee:	9e 83       	std	Y+6, r25	; 0x06
    d8f0:	8d 83       	std	Y+5, r24	; 0x05
    d8f2:	ae 01       	movw	r20, r28
    d8f4:	47 5e       	subi	r20, 0xE7	; 231
    d8f6:	5f 4f       	sbci	r21, 0xFF	; 255
    d8f8:	6f 89       	ldd	r22, Y+23	; 0x17
    d8fa:	78 8d       	ldd	r23, Y+24	; 0x18
    d8fc:	ce 01       	movw	r24, r28
    d8fe:	01 96       	adiw	r24, 0x01	; 1
    d900:	0e 94 8f 6e 	call	0xdd1e	; 0xdd1e <vfprintf>
    d904:	ef 81       	ldd	r30, Y+7	; 0x07
    d906:	f8 85       	ldd	r31, Y+8	; 0x08
    d908:	e0 0f       	add	r30, r16
    d90a:	f1 1f       	adc	r31, r17
    d90c:	10 82       	st	Z, r1
    d90e:	2e 96       	adiw	r28, 0x0e	; 14
    d910:	0f b6       	in	r0, 0x3f	; 63
    d912:	f8 94       	cli
    d914:	de bf       	out	0x3e, r29	; 62
    d916:	0f be       	out	0x3f, r0	; 63
    d918:	cd bf       	out	0x3d, r28	; 61
    d91a:	df 91       	pop	r29
    d91c:	cf 91       	pop	r28
    d91e:	1f 91       	pop	r17
    d920:	0f 91       	pop	r16
    d922:	08 95       	ret

0000d924 <sprintf_P>:
    d924:	0f 93       	push	r16
    d926:	1f 93       	push	r17
    d928:	cf 93       	push	r28
    d92a:	df 93       	push	r29
    d92c:	cd b7       	in	r28, 0x3d	; 61
    d92e:	de b7       	in	r29, 0x3e	; 62
    d930:	2e 97       	sbiw	r28, 0x0e	; 14
    d932:	0f b6       	in	r0, 0x3f	; 63
    d934:	f8 94       	cli
    d936:	de bf       	out	0x3e, r29	; 62
    d938:	0f be       	out	0x3f, r0	; 63
    d93a:	cd bf       	out	0x3d, r28	; 61
    d93c:	0d 89       	ldd	r16, Y+21	; 0x15
    d93e:	1e 89       	ldd	r17, Y+22	; 0x16
    d940:	8e e0       	ldi	r24, 0x0E	; 14
    d942:	8c 83       	std	Y+4, r24	; 0x04
    d944:	1a 83       	std	Y+2, r17	; 0x02
    d946:	09 83       	std	Y+1, r16	; 0x01
    d948:	8f ef       	ldi	r24, 0xFF	; 255
    d94a:	9f e7       	ldi	r25, 0x7F	; 127
    d94c:	9e 83       	std	Y+6, r25	; 0x06
    d94e:	8d 83       	std	Y+5, r24	; 0x05
    d950:	ae 01       	movw	r20, r28
    d952:	47 5e       	subi	r20, 0xE7	; 231
    d954:	5f 4f       	sbci	r21, 0xFF	; 255
    d956:	6f 89       	ldd	r22, Y+23	; 0x17
    d958:	78 8d       	ldd	r23, Y+24	; 0x18
    d95a:	ce 01       	movw	r24, r28
    d95c:	01 96       	adiw	r24, 0x01	; 1
    d95e:	0e 94 8f 6e 	call	0xdd1e	; 0xdd1e <vfprintf>
    d962:	ef 81       	ldd	r30, Y+7	; 0x07
    d964:	f8 85       	ldd	r31, Y+8	; 0x08
    d966:	e0 0f       	add	r30, r16
    d968:	f1 1f       	adc	r31, r17
    d96a:	10 82       	st	Z, r1
    d96c:	2e 96       	adiw	r28, 0x0e	; 14
    d96e:	0f b6       	in	r0, 0x3f	; 63
    d970:	f8 94       	cli
    d972:	de bf       	out	0x3e, r29	; 62
    d974:	0f be       	out	0x3f, r0	; 63
    d976:	cd bf       	out	0x3d, r28	; 61
    d978:	df 91       	pop	r29
    d97a:	cf 91       	pop	r28
    d97c:	1f 91       	pop	r17
    d97e:	0f 91       	pop	r16
    d980:	08 95       	ret

0000d982 <sscanf>:
    d982:	cf 93       	push	r28
    d984:	df 93       	push	r29
    d986:	cd b7       	in	r28, 0x3d	; 61
    d988:	de b7       	in	r29, 0x3e	; 62
    d98a:	2e 97       	sbiw	r28, 0x0e	; 14
    d98c:	0f b6       	in	r0, 0x3f	; 63
    d98e:	f8 94       	cli
    d990:	de bf       	out	0x3e, r29	; 62
    d992:	0f be       	out	0x3f, r0	; 63
    d994:	cd bf       	out	0x3d, r28	; 61
    d996:	85 e0       	ldi	r24, 0x05	; 5
    d998:	8c 83       	std	Y+4, r24	; 0x04
    d99a:	8b 89       	ldd	r24, Y+19	; 0x13
    d99c:	9c 89       	ldd	r25, Y+20	; 0x14
    d99e:	9a 83       	std	Y+2, r25	; 0x02
    d9a0:	89 83       	std	Y+1, r24	; 0x01
    d9a2:	ae 01       	movw	r20, r28
    d9a4:	49 5e       	subi	r20, 0xE9	; 233
    d9a6:	5f 4f       	sbci	r21, 0xFF	; 255
    d9a8:	6d 89       	ldd	r22, Y+21	; 0x15
    d9aa:	7e 89       	ldd	r23, Y+22	; 0x16
    d9ac:	ce 01       	movw	r24, r28
    d9ae:	01 96       	adiw	r24, 0x01	; 1
    d9b0:	0e 94 27 72 	call	0xe44e	; 0xe44e <vfscanf>
    d9b4:	2e 96       	adiw	r28, 0x0e	; 14
    d9b6:	0f b6       	in	r0, 0x3f	; 63
    d9b8:	f8 94       	cli
    d9ba:	de bf       	out	0x3e, r29	; 62
    d9bc:	0f be       	out	0x3f, r0	; 63
    d9be:	cd bf       	out	0x3d, r28	; 61
    d9c0:	df 91       	pop	r29
    d9c2:	cf 91       	pop	r28
    d9c4:	08 95       	ret

0000d9c6 <sscanf_P>:
    d9c6:	cf 93       	push	r28
    d9c8:	df 93       	push	r29
    d9ca:	cd b7       	in	r28, 0x3d	; 61
    d9cc:	de b7       	in	r29, 0x3e	; 62
    d9ce:	2e 97       	sbiw	r28, 0x0e	; 14
    d9d0:	0f b6       	in	r0, 0x3f	; 63
    d9d2:	f8 94       	cli
    d9d4:	de bf       	out	0x3e, r29	; 62
    d9d6:	0f be       	out	0x3f, r0	; 63
    d9d8:	cd bf       	out	0x3d, r28	; 61
    d9da:	8d e0       	ldi	r24, 0x0D	; 13
    d9dc:	8c 83       	std	Y+4, r24	; 0x04
    d9de:	8b 89       	ldd	r24, Y+19	; 0x13
    d9e0:	9c 89       	ldd	r25, Y+20	; 0x14
    d9e2:	9a 83       	std	Y+2, r25	; 0x02
    d9e4:	89 83       	std	Y+1, r24	; 0x01
    d9e6:	ae 01       	movw	r20, r28
    d9e8:	49 5e       	subi	r20, 0xE9	; 233
    d9ea:	5f 4f       	sbci	r21, 0xFF	; 255
    d9ec:	6d 89       	ldd	r22, Y+21	; 0x15
    d9ee:	7e 89       	ldd	r23, Y+22	; 0x16
    d9f0:	ce 01       	movw	r24, r28
    d9f2:	01 96       	adiw	r24, 0x01	; 1
    d9f4:	0e 94 27 72 	call	0xe44e	; 0xe44e <vfscanf>
    d9f8:	2e 96       	adiw	r28, 0x0e	; 14
    d9fa:	0f b6       	in	r0, 0x3f	; 63
    d9fc:	f8 94       	cli
    d9fe:	de bf       	out	0x3e, r29	; 62
    da00:	0f be       	out	0x3f, r0	; 63
    da02:	cd bf       	out	0x3d, r28	; 61
    da04:	df 91       	pop	r29
    da06:	cf 91       	pop	r28
    da08:	08 95       	ret

0000da0a <__divsf3>:
    da0a:	0c d0       	rcall	.+24     	; 0xda24 <__divsf3x>
    da0c:	eb c0       	rjmp	.+470    	; 0xdbe4 <__fp_round>
    da0e:	e3 d0       	rcall	.+454    	; 0xdbd6 <__fp_pscB>
    da10:	40 f0       	brcs	.+16     	; 0xda22 <__divsf3+0x18>
    da12:	da d0       	rcall	.+436    	; 0xdbc8 <__fp_pscA>
    da14:	30 f0       	brcs	.+12     	; 0xda22 <__divsf3+0x18>
    da16:	21 f4       	brne	.+8      	; 0xda20 <__divsf3+0x16>
    da18:	5f 3f       	cpi	r21, 0xFF	; 255
    da1a:	19 f0       	breq	.+6      	; 0xda22 <__divsf3+0x18>
    da1c:	cc c0       	rjmp	.+408    	; 0xdbb6 <__fp_inf>
    da1e:	51 11       	cpse	r21, r1
    da20:	15 c1       	rjmp	.+554    	; 0xdc4c <__fp_szero>
    da22:	cf c0       	rjmp	.+414    	; 0xdbc2 <__fp_nan>

0000da24 <__divsf3x>:
    da24:	f0 d0       	rcall	.+480    	; 0xdc06 <__fp_split3>
    da26:	98 f3       	brcs	.-26     	; 0xda0e <__divsf3+0x4>

0000da28 <__divsf3_pse>:
    da28:	99 23       	and	r25, r25
    da2a:	c9 f3       	breq	.-14     	; 0xda1e <__divsf3+0x14>
    da2c:	55 23       	and	r21, r21
    da2e:	b1 f3       	breq	.-20     	; 0xda1c <__divsf3+0x12>
    da30:	95 1b       	sub	r25, r21
    da32:	55 0b       	sbc	r21, r21
    da34:	bb 27       	eor	r27, r27
    da36:	aa 27       	eor	r26, r26
    da38:	62 17       	cp	r22, r18
    da3a:	73 07       	cpc	r23, r19
    da3c:	84 07       	cpc	r24, r20
    da3e:	38 f0       	brcs	.+14     	; 0xda4e <__divsf3_pse+0x26>
    da40:	9f 5f       	subi	r25, 0xFF	; 255
    da42:	5f 4f       	sbci	r21, 0xFF	; 255
    da44:	22 0f       	add	r18, r18
    da46:	33 1f       	adc	r19, r19
    da48:	44 1f       	adc	r20, r20
    da4a:	aa 1f       	adc	r26, r26
    da4c:	a9 f3       	breq	.-22     	; 0xda38 <__divsf3_pse+0x10>
    da4e:	33 d0       	rcall	.+102    	; 0xdab6 <__divsf3_pse+0x8e>
    da50:	0e 2e       	mov	r0, r30
    da52:	3a f0       	brmi	.+14     	; 0xda62 <__divsf3_pse+0x3a>
    da54:	e0 e8       	ldi	r30, 0x80	; 128
    da56:	30 d0       	rcall	.+96     	; 0xdab8 <__divsf3_pse+0x90>
    da58:	91 50       	subi	r25, 0x01	; 1
    da5a:	50 40       	sbci	r21, 0x00	; 0
    da5c:	e6 95       	lsr	r30
    da5e:	00 1c       	adc	r0, r0
    da60:	ca f7       	brpl	.-14     	; 0xda54 <__divsf3_pse+0x2c>
    da62:	29 d0       	rcall	.+82     	; 0xdab6 <__divsf3_pse+0x8e>
    da64:	fe 2f       	mov	r31, r30
    da66:	27 d0       	rcall	.+78     	; 0xdab6 <__divsf3_pse+0x8e>
    da68:	66 0f       	add	r22, r22
    da6a:	77 1f       	adc	r23, r23
    da6c:	88 1f       	adc	r24, r24
    da6e:	bb 1f       	adc	r27, r27
    da70:	26 17       	cp	r18, r22
    da72:	37 07       	cpc	r19, r23
    da74:	48 07       	cpc	r20, r24
    da76:	ab 07       	cpc	r26, r27
    da78:	b0 e8       	ldi	r27, 0x80	; 128
    da7a:	09 f0       	breq	.+2      	; 0xda7e <__divsf3_pse+0x56>
    da7c:	bb 0b       	sbc	r27, r27
    da7e:	80 2d       	mov	r24, r0
    da80:	bf 01       	movw	r22, r30
    da82:	ff 27       	eor	r31, r31
    da84:	93 58       	subi	r25, 0x83	; 131
    da86:	5f 4f       	sbci	r21, 0xFF	; 255
    da88:	2a f0       	brmi	.+10     	; 0xda94 <__divsf3_pse+0x6c>
    da8a:	9e 3f       	cpi	r25, 0xFE	; 254
    da8c:	51 05       	cpc	r21, r1
    da8e:	68 f0       	brcs	.+26     	; 0xdaaa <__divsf3_pse+0x82>
    da90:	92 c0       	rjmp	.+292    	; 0xdbb6 <__fp_inf>
    da92:	dc c0       	rjmp	.+440    	; 0xdc4c <__fp_szero>
    da94:	5f 3f       	cpi	r21, 0xFF	; 255
    da96:	ec f3       	brlt	.-6      	; 0xda92 <__divsf3_pse+0x6a>
    da98:	98 3e       	cpi	r25, 0xE8	; 232
    da9a:	dc f3       	brlt	.-10     	; 0xda92 <__divsf3_pse+0x6a>
    da9c:	86 95       	lsr	r24
    da9e:	77 95       	ror	r23
    daa0:	67 95       	ror	r22
    daa2:	b7 95       	ror	r27
    daa4:	f7 95       	ror	r31
    daa6:	9f 5f       	subi	r25, 0xFF	; 255
    daa8:	c9 f7       	brne	.-14     	; 0xda9c <__divsf3_pse+0x74>
    daaa:	88 0f       	add	r24, r24
    daac:	91 1d       	adc	r25, r1
    daae:	96 95       	lsr	r25
    dab0:	87 95       	ror	r24
    dab2:	97 f9       	bld	r25, 7
    dab4:	08 95       	ret
    dab6:	e1 e0       	ldi	r30, 0x01	; 1
    dab8:	66 0f       	add	r22, r22
    daba:	77 1f       	adc	r23, r23
    dabc:	88 1f       	adc	r24, r24
    dabe:	bb 1f       	adc	r27, r27
    dac0:	62 17       	cp	r22, r18
    dac2:	73 07       	cpc	r23, r19
    dac4:	84 07       	cpc	r24, r20
    dac6:	ba 07       	cpc	r27, r26
    dac8:	20 f0       	brcs	.+8      	; 0xdad2 <__divsf3_pse+0xaa>
    daca:	62 1b       	sub	r22, r18
    dacc:	73 0b       	sbc	r23, r19
    dace:	84 0b       	sbc	r24, r20
    dad0:	ba 0b       	sbc	r27, r26
    dad2:	ee 1f       	adc	r30, r30
    dad4:	88 f7       	brcc	.-30     	; 0xdab8 <__divsf3_pse+0x90>
    dad6:	e0 95       	com	r30
    dad8:	08 95       	ret

0000dada <__fixsfsi>:
    dada:	04 d0       	rcall	.+8      	; 0xdae4 <__fixunssfsi>
    dadc:	68 94       	set
    dade:	b1 11       	cpse	r27, r1
    dae0:	b5 c0       	rjmp	.+362    	; 0xdc4c <__fp_szero>
    dae2:	08 95       	ret

0000dae4 <__fixunssfsi>:
    dae4:	98 d0       	rcall	.+304    	; 0xdc16 <__fp_splitA>
    dae6:	88 f0       	brcs	.+34     	; 0xdb0a <__fixunssfsi+0x26>
    dae8:	9f 57       	subi	r25, 0x7F	; 127
    daea:	90 f0       	brcs	.+36     	; 0xdb10 <__fixunssfsi+0x2c>
    daec:	b9 2f       	mov	r27, r25
    daee:	99 27       	eor	r25, r25
    daf0:	b7 51       	subi	r27, 0x17	; 23
    daf2:	a0 f0       	brcs	.+40     	; 0xdb1c <__fixunssfsi+0x38>
    daf4:	d1 f0       	breq	.+52     	; 0xdb2a <__fixunssfsi+0x46>
    daf6:	66 0f       	add	r22, r22
    daf8:	77 1f       	adc	r23, r23
    dafa:	88 1f       	adc	r24, r24
    dafc:	99 1f       	adc	r25, r25
    dafe:	1a f0       	brmi	.+6      	; 0xdb06 <__fixunssfsi+0x22>
    db00:	ba 95       	dec	r27
    db02:	c9 f7       	brne	.-14     	; 0xdaf6 <__fixunssfsi+0x12>
    db04:	12 c0       	rjmp	.+36     	; 0xdb2a <__fixunssfsi+0x46>
    db06:	b1 30       	cpi	r27, 0x01	; 1
    db08:	81 f0       	breq	.+32     	; 0xdb2a <__fixunssfsi+0x46>
    db0a:	9f d0       	rcall	.+318    	; 0xdc4a <__fp_zero>
    db0c:	b1 e0       	ldi	r27, 0x01	; 1
    db0e:	08 95       	ret
    db10:	9c c0       	rjmp	.+312    	; 0xdc4a <__fp_zero>
    db12:	67 2f       	mov	r22, r23
    db14:	78 2f       	mov	r23, r24
    db16:	88 27       	eor	r24, r24
    db18:	b8 5f       	subi	r27, 0xF8	; 248
    db1a:	39 f0       	breq	.+14     	; 0xdb2a <__fixunssfsi+0x46>
    db1c:	b9 3f       	cpi	r27, 0xF9	; 249
    db1e:	cc f3       	brlt	.-14     	; 0xdb12 <__fixunssfsi+0x2e>
    db20:	86 95       	lsr	r24
    db22:	77 95       	ror	r23
    db24:	67 95       	ror	r22
    db26:	b3 95       	inc	r27
    db28:	d9 f7       	brne	.-10     	; 0xdb20 <__fixunssfsi+0x3c>
    db2a:	3e f4       	brtc	.+14     	; 0xdb3a <__fixunssfsi+0x56>
    db2c:	90 95       	com	r25
    db2e:	80 95       	com	r24
    db30:	70 95       	com	r23
    db32:	61 95       	neg	r22
    db34:	7f 4f       	sbci	r23, 0xFF	; 255
    db36:	8f 4f       	sbci	r24, 0xFF	; 255
    db38:	9f 4f       	sbci	r25, 0xFF	; 255
    db3a:	08 95       	ret

0000db3c <__floatunsisf>:
    db3c:	e8 94       	clt
    db3e:	09 c0       	rjmp	.+18     	; 0xdb52 <__floatsisf+0x12>

0000db40 <__floatsisf>:
    db40:	97 fb       	bst	r25, 7
    db42:	3e f4       	brtc	.+14     	; 0xdb52 <__floatsisf+0x12>
    db44:	90 95       	com	r25
    db46:	80 95       	com	r24
    db48:	70 95       	com	r23
    db4a:	61 95       	neg	r22
    db4c:	7f 4f       	sbci	r23, 0xFF	; 255
    db4e:	8f 4f       	sbci	r24, 0xFF	; 255
    db50:	9f 4f       	sbci	r25, 0xFF	; 255
    db52:	99 23       	and	r25, r25
    db54:	a9 f0       	breq	.+42     	; 0xdb80 <__floatsisf+0x40>
    db56:	f9 2f       	mov	r31, r25
    db58:	96 e9       	ldi	r25, 0x96	; 150
    db5a:	bb 27       	eor	r27, r27
    db5c:	93 95       	inc	r25
    db5e:	f6 95       	lsr	r31
    db60:	87 95       	ror	r24
    db62:	77 95       	ror	r23
    db64:	67 95       	ror	r22
    db66:	b7 95       	ror	r27
    db68:	f1 11       	cpse	r31, r1
    db6a:	f8 cf       	rjmp	.-16     	; 0xdb5c <__floatsisf+0x1c>
    db6c:	fa f4       	brpl	.+62     	; 0xdbac <__floatsisf+0x6c>
    db6e:	bb 0f       	add	r27, r27
    db70:	11 f4       	brne	.+4      	; 0xdb76 <__floatsisf+0x36>
    db72:	60 ff       	sbrs	r22, 0
    db74:	1b c0       	rjmp	.+54     	; 0xdbac <__floatsisf+0x6c>
    db76:	6f 5f       	subi	r22, 0xFF	; 255
    db78:	7f 4f       	sbci	r23, 0xFF	; 255
    db7a:	8f 4f       	sbci	r24, 0xFF	; 255
    db7c:	9f 4f       	sbci	r25, 0xFF	; 255
    db7e:	16 c0       	rjmp	.+44     	; 0xdbac <__floatsisf+0x6c>
    db80:	88 23       	and	r24, r24
    db82:	11 f0       	breq	.+4      	; 0xdb88 <__floatsisf+0x48>
    db84:	96 e9       	ldi	r25, 0x96	; 150
    db86:	11 c0       	rjmp	.+34     	; 0xdbaa <__floatsisf+0x6a>
    db88:	77 23       	and	r23, r23
    db8a:	21 f0       	breq	.+8      	; 0xdb94 <__floatsisf+0x54>
    db8c:	9e e8       	ldi	r25, 0x8E	; 142
    db8e:	87 2f       	mov	r24, r23
    db90:	76 2f       	mov	r23, r22
    db92:	05 c0       	rjmp	.+10     	; 0xdb9e <__floatsisf+0x5e>
    db94:	66 23       	and	r22, r22
    db96:	71 f0       	breq	.+28     	; 0xdbb4 <__floatsisf+0x74>
    db98:	96 e8       	ldi	r25, 0x86	; 134
    db9a:	86 2f       	mov	r24, r22
    db9c:	70 e0       	ldi	r23, 0x00	; 0
    db9e:	60 e0       	ldi	r22, 0x00	; 0
    dba0:	2a f0       	brmi	.+10     	; 0xdbac <__floatsisf+0x6c>
    dba2:	9a 95       	dec	r25
    dba4:	66 0f       	add	r22, r22
    dba6:	77 1f       	adc	r23, r23
    dba8:	88 1f       	adc	r24, r24
    dbaa:	da f7       	brpl	.-10     	; 0xdba2 <__floatsisf+0x62>
    dbac:	88 0f       	add	r24, r24
    dbae:	96 95       	lsr	r25
    dbb0:	87 95       	ror	r24
    dbb2:	97 f9       	bld	r25, 7
    dbb4:	08 95       	ret

0000dbb6 <__fp_inf>:
    dbb6:	97 f9       	bld	r25, 7
    dbb8:	9f 67       	ori	r25, 0x7F	; 127
    dbba:	80 e8       	ldi	r24, 0x80	; 128
    dbbc:	70 e0       	ldi	r23, 0x00	; 0
    dbbe:	60 e0       	ldi	r22, 0x00	; 0
    dbc0:	08 95       	ret

0000dbc2 <__fp_nan>:
    dbc2:	9f ef       	ldi	r25, 0xFF	; 255
    dbc4:	80 ec       	ldi	r24, 0xC0	; 192
    dbc6:	08 95       	ret

0000dbc8 <__fp_pscA>:
    dbc8:	00 24       	eor	r0, r0
    dbca:	0a 94       	dec	r0
    dbcc:	16 16       	cp	r1, r22
    dbce:	17 06       	cpc	r1, r23
    dbd0:	18 06       	cpc	r1, r24
    dbd2:	09 06       	cpc	r0, r25
    dbd4:	08 95       	ret

0000dbd6 <__fp_pscB>:
    dbd6:	00 24       	eor	r0, r0
    dbd8:	0a 94       	dec	r0
    dbda:	12 16       	cp	r1, r18
    dbdc:	13 06       	cpc	r1, r19
    dbde:	14 06       	cpc	r1, r20
    dbe0:	05 06       	cpc	r0, r21
    dbe2:	08 95       	ret

0000dbe4 <__fp_round>:
    dbe4:	09 2e       	mov	r0, r25
    dbe6:	03 94       	inc	r0
    dbe8:	00 0c       	add	r0, r0
    dbea:	11 f4       	brne	.+4      	; 0xdbf0 <__fp_round+0xc>
    dbec:	88 23       	and	r24, r24
    dbee:	52 f0       	brmi	.+20     	; 0xdc04 <__fp_round+0x20>
    dbf0:	bb 0f       	add	r27, r27
    dbf2:	40 f4       	brcc	.+16     	; 0xdc04 <__fp_round+0x20>
    dbf4:	bf 2b       	or	r27, r31
    dbf6:	11 f4       	brne	.+4      	; 0xdbfc <__fp_round+0x18>
    dbf8:	60 ff       	sbrs	r22, 0
    dbfa:	04 c0       	rjmp	.+8      	; 0xdc04 <__fp_round+0x20>
    dbfc:	6f 5f       	subi	r22, 0xFF	; 255
    dbfe:	7f 4f       	sbci	r23, 0xFF	; 255
    dc00:	8f 4f       	sbci	r24, 0xFF	; 255
    dc02:	9f 4f       	sbci	r25, 0xFF	; 255
    dc04:	08 95       	ret

0000dc06 <__fp_split3>:
    dc06:	57 fd       	sbrc	r21, 7
    dc08:	90 58       	subi	r25, 0x80	; 128
    dc0a:	44 0f       	add	r20, r20
    dc0c:	55 1f       	adc	r21, r21
    dc0e:	59 f0       	breq	.+22     	; 0xdc26 <__fp_splitA+0x10>
    dc10:	5f 3f       	cpi	r21, 0xFF	; 255
    dc12:	71 f0       	breq	.+28     	; 0xdc30 <__fp_splitA+0x1a>
    dc14:	47 95       	ror	r20

0000dc16 <__fp_splitA>:
    dc16:	88 0f       	add	r24, r24
    dc18:	97 fb       	bst	r25, 7
    dc1a:	99 1f       	adc	r25, r25
    dc1c:	61 f0       	breq	.+24     	; 0xdc36 <__fp_splitA+0x20>
    dc1e:	9f 3f       	cpi	r25, 0xFF	; 255
    dc20:	79 f0       	breq	.+30     	; 0xdc40 <__fp_splitA+0x2a>
    dc22:	87 95       	ror	r24
    dc24:	08 95       	ret
    dc26:	12 16       	cp	r1, r18
    dc28:	13 06       	cpc	r1, r19
    dc2a:	14 06       	cpc	r1, r20
    dc2c:	55 1f       	adc	r21, r21
    dc2e:	f2 cf       	rjmp	.-28     	; 0xdc14 <__fp_split3+0xe>
    dc30:	46 95       	lsr	r20
    dc32:	f1 df       	rcall	.-30     	; 0xdc16 <__fp_splitA>
    dc34:	08 c0       	rjmp	.+16     	; 0xdc46 <__fp_splitA+0x30>
    dc36:	16 16       	cp	r1, r22
    dc38:	17 06       	cpc	r1, r23
    dc3a:	18 06       	cpc	r1, r24
    dc3c:	99 1f       	adc	r25, r25
    dc3e:	f1 cf       	rjmp	.-30     	; 0xdc22 <__fp_splitA+0xc>
    dc40:	86 95       	lsr	r24
    dc42:	71 05       	cpc	r23, r1
    dc44:	61 05       	cpc	r22, r1
    dc46:	08 94       	sec
    dc48:	08 95       	ret

0000dc4a <__fp_zero>:
    dc4a:	e8 94       	clt

0000dc4c <__fp_szero>:
    dc4c:	bb 27       	eor	r27, r27
    dc4e:	66 27       	eor	r22, r22
    dc50:	77 27       	eor	r23, r23
    dc52:	cb 01       	movw	r24, r22
    dc54:	97 f9       	bld	r25, 7
    dc56:	08 95       	ret

0000dc58 <__mulsf3>:
    dc58:	0b d0       	rcall	.+22     	; 0xdc70 <__mulsf3x>
    dc5a:	c4 cf       	rjmp	.-120    	; 0xdbe4 <__fp_round>
    dc5c:	b5 df       	rcall	.-150    	; 0xdbc8 <__fp_pscA>
    dc5e:	28 f0       	brcs	.+10     	; 0xdc6a <__mulsf3+0x12>
    dc60:	ba df       	rcall	.-140    	; 0xdbd6 <__fp_pscB>
    dc62:	18 f0       	brcs	.+6      	; 0xdc6a <__mulsf3+0x12>
    dc64:	95 23       	and	r25, r21
    dc66:	09 f0       	breq	.+2      	; 0xdc6a <__mulsf3+0x12>
    dc68:	a6 cf       	rjmp	.-180    	; 0xdbb6 <__fp_inf>
    dc6a:	ab cf       	rjmp	.-170    	; 0xdbc2 <__fp_nan>
    dc6c:	11 24       	eor	r1, r1
    dc6e:	ee cf       	rjmp	.-36     	; 0xdc4c <__fp_szero>

0000dc70 <__mulsf3x>:
    dc70:	ca df       	rcall	.-108    	; 0xdc06 <__fp_split3>
    dc72:	a0 f3       	brcs	.-24     	; 0xdc5c <__mulsf3+0x4>

0000dc74 <__mulsf3_pse>:
    dc74:	95 9f       	mul	r25, r21
    dc76:	d1 f3       	breq	.-12     	; 0xdc6c <__mulsf3+0x14>
    dc78:	95 0f       	add	r25, r21
    dc7a:	50 e0       	ldi	r21, 0x00	; 0
    dc7c:	55 1f       	adc	r21, r21
    dc7e:	62 9f       	mul	r22, r18
    dc80:	f0 01       	movw	r30, r0
    dc82:	72 9f       	mul	r23, r18
    dc84:	bb 27       	eor	r27, r27
    dc86:	f0 0d       	add	r31, r0
    dc88:	b1 1d       	adc	r27, r1
    dc8a:	63 9f       	mul	r22, r19
    dc8c:	aa 27       	eor	r26, r26
    dc8e:	f0 0d       	add	r31, r0
    dc90:	b1 1d       	adc	r27, r1
    dc92:	aa 1f       	adc	r26, r26
    dc94:	64 9f       	mul	r22, r20
    dc96:	66 27       	eor	r22, r22
    dc98:	b0 0d       	add	r27, r0
    dc9a:	a1 1d       	adc	r26, r1
    dc9c:	66 1f       	adc	r22, r22
    dc9e:	82 9f       	mul	r24, r18
    dca0:	22 27       	eor	r18, r18
    dca2:	b0 0d       	add	r27, r0
    dca4:	a1 1d       	adc	r26, r1
    dca6:	62 1f       	adc	r22, r18
    dca8:	73 9f       	mul	r23, r19
    dcaa:	b0 0d       	add	r27, r0
    dcac:	a1 1d       	adc	r26, r1
    dcae:	62 1f       	adc	r22, r18
    dcb0:	83 9f       	mul	r24, r19
    dcb2:	a0 0d       	add	r26, r0
    dcb4:	61 1d       	adc	r22, r1
    dcb6:	22 1f       	adc	r18, r18
    dcb8:	74 9f       	mul	r23, r20
    dcba:	33 27       	eor	r19, r19
    dcbc:	a0 0d       	add	r26, r0
    dcbe:	61 1d       	adc	r22, r1
    dcc0:	23 1f       	adc	r18, r19
    dcc2:	84 9f       	mul	r24, r20
    dcc4:	60 0d       	add	r22, r0
    dcc6:	21 1d       	adc	r18, r1
    dcc8:	82 2f       	mov	r24, r18
    dcca:	76 2f       	mov	r23, r22
    dccc:	6a 2f       	mov	r22, r26
    dcce:	11 24       	eor	r1, r1
    dcd0:	9f 57       	subi	r25, 0x7F	; 127
    dcd2:	50 40       	sbci	r21, 0x00	; 0
    dcd4:	8a f0       	brmi	.+34     	; 0xdcf8 <__mulsf3_pse+0x84>
    dcd6:	e1 f0       	breq	.+56     	; 0xdd10 <__mulsf3_pse+0x9c>
    dcd8:	88 23       	and	r24, r24
    dcda:	4a f0       	brmi	.+18     	; 0xdcee <__mulsf3_pse+0x7a>
    dcdc:	ee 0f       	add	r30, r30
    dcde:	ff 1f       	adc	r31, r31
    dce0:	bb 1f       	adc	r27, r27
    dce2:	66 1f       	adc	r22, r22
    dce4:	77 1f       	adc	r23, r23
    dce6:	88 1f       	adc	r24, r24
    dce8:	91 50       	subi	r25, 0x01	; 1
    dcea:	50 40       	sbci	r21, 0x00	; 0
    dcec:	a9 f7       	brne	.-22     	; 0xdcd8 <__mulsf3_pse+0x64>
    dcee:	9e 3f       	cpi	r25, 0xFE	; 254
    dcf0:	51 05       	cpc	r21, r1
    dcf2:	70 f0       	brcs	.+28     	; 0xdd10 <__mulsf3_pse+0x9c>
    dcf4:	60 cf       	rjmp	.-320    	; 0xdbb6 <__fp_inf>
    dcf6:	aa cf       	rjmp	.-172    	; 0xdc4c <__fp_szero>
    dcf8:	5f 3f       	cpi	r21, 0xFF	; 255
    dcfa:	ec f3       	brlt	.-6      	; 0xdcf6 <__mulsf3_pse+0x82>
    dcfc:	98 3e       	cpi	r25, 0xE8	; 232
    dcfe:	dc f3       	brlt	.-10     	; 0xdcf6 <__mulsf3_pse+0x82>
    dd00:	86 95       	lsr	r24
    dd02:	77 95       	ror	r23
    dd04:	67 95       	ror	r22
    dd06:	b7 95       	ror	r27
    dd08:	f7 95       	ror	r31
    dd0a:	e7 95       	ror	r30
    dd0c:	9f 5f       	subi	r25, 0xFF	; 255
    dd0e:	c1 f7       	brne	.-16     	; 0xdd00 <__mulsf3_pse+0x8c>
    dd10:	fe 2b       	or	r31, r30
    dd12:	88 0f       	add	r24, r24
    dd14:	91 1d       	adc	r25, r1
    dd16:	96 95       	lsr	r25
    dd18:	87 95       	ror	r24
    dd1a:	97 f9       	bld	r25, 7
    dd1c:	08 95       	ret

0000dd1e <vfprintf>:
    dd1e:	2f 92       	push	r2
    dd20:	3f 92       	push	r3
    dd22:	4f 92       	push	r4
    dd24:	5f 92       	push	r5
    dd26:	6f 92       	push	r6
    dd28:	7f 92       	push	r7
    dd2a:	8f 92       	push	r8
    dd2c:	9f 92       	push	r9
    dd2e:	af 92       	push	r10
    dd30:	bf 92       	push	r11
    dd32:	cf 92       	push	r12
    dd34:	df 92       	push	r13
    dd36:	ef 92       	push	r14
    dd38:	ff 92       	push	r15
    dd3a:	0f 93       	push	r16
    dd3c:	1f 93       	push	r17
    dd3e:	cf 93       	push	r28
    dd40:	df 93       	push	r29
    dd42:	cd b7       	in	r28, 0x3d	; 61
    dd44:	de b7       	in	r29, 0x3e	; 62
    dd46:	2c 97       	sbiw	r28, 0x0c	; 12
    dd48:	0f b6       	in	r0, 0x3f	; 63
    dd4a:	f8 94       	cli
    dd4c:	de bf       	out	0x3e, r29	; 62
    dd4e:	0f be       	out	0x3f, r0	; 63
    dd50:	cd bf       	out	0x3d, r28	; 61
    dd52:	7c 01       	movw	r14, r24
    dd54:	6b 01       	movw	r12, r22
    dd56:	8a 01       	movw	r16, r20
    dd58:	fc 01       	movw	r30, r24
    dd5a:	17 82       	std	Z+7, r1	; 0x07
    dd5c:	16 82       	std	Z+6, r1	; 0x06
    dd5e:	83 81       	ldd	r24, Z+3	; 0x03
    dd60:	81 ff       	sbrs	r24, 1
    dd62:	bd c1       	rjmp	.+890    	; 0xe0de <vfprintf+0x3c0>
    dd64:	ce 01       	movw	r24, r28
    dd66:	01 96       	adiw	r24, 0x01	; 1
    dd68:	4c 01       	movw	r8, r24
    dd6a:	f7 01       	movw	r30, r14
    dd6c:	93 81       	ldd	r25, Z+3	; 0x03
    dd6e:	f6 01       	movw	r30, r12
    dd70:	93 fd       	sbrc	r25, 3
    dd72:	85 91       	lpm	r24, Z+
    dd74:	93 ff       	sbrs	r25, 3
    dd76:	81 91       	ld	r24, Z+
    dd78:	6f 01       	movw	r12, r30
    dd7a:	88 23       	and	r24, r24
    dd7c:	09 f4       	brne	.+2      	; 0xdd80 <vfprintf+0x62>
    dd7e:	ab c1       	rjmp	.+854    	; 0xe0d6 <vfprintf+0x3b8>
    dd80:	85 32       	cpi	r24, 0x25	; 37
    dd82:	39 f4       	brne	.+14     	; 0xdd92 <vfprintf+0x74>
    dd84:	93 fd       	sbrc	r25, 3
    dd86:	85 91       	lpm	r24, Z+
    dd88:	93 ff       	sbrs	r25, 3
    dd8a:	81 91       	ld	r24, Z+
    dd8c:	6f 01       	movw	r12, r30
    dd8e:	85 32       	cpi	r24, 0x25	; 37
    dd90:	29 f4       	brne	.+10     	; 0xdd9c <vfprintf+0x7e>
    dd92:	b7 01       	movw	r22, r14
    dd94:	90 e0       	ldi	r25, 0x00	; 0
    dd96:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    dd9a:	e7 cf       	rjmp	.-50     	; 0xdd6a <vfprintf+0x4c>
    dd9c:	51 2c       	mov	r5, r1
    dd9e:	31 2c       	mov	r3, r1
    dda0:	20 e0       	ldi	r18, 0x00	; 0
    dda2:	20 32       	cpi	r18, 0x20	; 32
    dda4:	a0 f4       	brcc	.+40     	; 0xddce <vfprintf+0xb0>
    dda6:	8b 32       	cpi	r24, 0x2B	; 43
    dda8:	69 f0       	breq	.+26     	; 0xddc4 <vfprintf+0xa6>
    ddaa:	30 f4       	brcc	.+12     	; 0xddb8 <vfprintf+0x9a>
    ddac:	80 32       	cpi	r24, 0x20	; 32
    ddae:	59 f0       	breq	.+22     	; 0xddc6 <vfprintf+0xa8>
    ddb0:	83 32       	cpi	r24, 0x23	; 35
    ddb2:	69 f4       	brne	.+26     	; 0xddce <vfprintf+0xb0>
    ddb4:	20 61       	ori	r18, 0x10	; 16
    ddb6:	2c c0       	rjmp	.+88     	; 0xde10 <vfprintf+0xf2>
    ddb8:	8d 32       	cpi	r24, 0x2D	; 45
    ddba:	39 f0       	breq	.+14     	; 0xddca <vfprintf+0xac>
    ddbc:	80 33       	cpi	r24, 0x30	; 48
    ddbe:	39 f4       	brne	.+14     	; 0xddce <vfprintf+0xb0>
    ddc0:	21 60       	ori	r18, 0x01	; 1
    ddc2:	26 c0       	rjmp	.+76     	; 0xde10 <vfprintf+0xf2>
    ddc4:	22 60       	ori	r18, 0x02	; 2
    ddc6:	24 60       	ori	r18, 0x04	; 4
    ddc8:	23 c0       	rjmp	.+70     	; 0xde10 <vfprintf+0xf2>
    ddca:	28 60       	ori	r18, 0x08	; 8
    ddcc:	21 c0       	rjmp	.+66     	; 0xde10 <vfprintf+0xf2>
    ddce:	27 fd       	sbrc	r18, 7
    ddd0:	27 c0       	rjmp	.+78     	; 0xde20 <vfprintf+0x102>
    ddd2:	30 ed       	ldi	r19, 0xD0	; 208
    ddd4:	38 0f       	add	r19, r24
    ddd6:	3a 30       	cpi	r19, 0x0A	; 10
    ddd8:	78 f4       	brcc	.+30     	; 0xddf8 <vfprintf+0xda>
    ddda:	26 ff       	sbrs	r18, 6
    dddc:	06 c0       	rjmp	.+12     	; 0xddea <vfprintf+0xcc>
    ddde:	fa e0       	ldi	r31, 0x0A	; 10
    dde0:	5f 9e       	mul	r5, r31
    dde2:	30 0d       	add	r19, r0
    dde4:	11 24       	eor	r1, r1
    dde6:	53 2e       	mov	r5, r19
    dde8:	13 c0       	rjmp	.+38     	; 0xde10 <vfprintf+0xf2>
    ddea:	8a e0       	ldi	r24, 0x0A	; 10
    ddec:	38 9e       	mul	r3, r24
    ddee:	30 0d       	add	r19, r0
    ddf0:	11 24       	eor	r1, r1
    ddf2:	33 2e       	mov	r3, r19
    ddf4:	20 62       	ori	r18, 0x20	; 32
    ddf6:	0c c0       	rjmp	.+24     	; 0xde10 <vfprintf+0xf2>
    ddf8:	8e 32       	cpi	r24, 0x2E	; 46
    ddfa:	21 f4       	brne	.+8      	; 0xde04 <vfprintf+0xe6>
    ddfc:	26 fd       	sbrc	r18, 6
    ddfe:	6b c1       	rjmp	.+726    	; 0xe0d6 <vfprintf+0x3b8>
    de00:	20 64       	ori	r18, 0x40	; 64
    de02:	06 c0       	rjmp	.+12     	; 0xde10 <vfprintf+0xf2>
    de04:	8c 36       	cpi	r24, 0x6C	; 108
    de06:	11 f4       	brne	.+4      	; 0xde0c <vfprintf+0xee>
    de08:	20 68       	ori	r18, 0x80	; 128
    de0a:	02 c0       	rjmp	.+4      	; 0xde10 <vfprintf+0xf2>
    de0c:	88 36       	cpi	r24, 0x68	; 104
    de0e:	41 f4       	brne	.+16     	; 0xde20 <vfprintf+0x102>
    de10:	f6 01       	movw	r30, r12
    de12:	93 fd       	sbrc	r25, 3
    de14:	85 91       	lpm	r24, Z+
    de16:	93 ff       	sbrs	r25, 3
    de18:	81 91       	ld	r24, Z+
    de1a:	6f 01       	movw	r12, r30
    de1c:	81 11       	cpse	r24, r1
    de1e:	c1 cf       	rjmp	.-126    	; 0xdda2 <vfprintf+0x84>
    de20:	98 2f       	mov	r25, r24
    de22:	9f 7d       	andi	r25, 0xDF	; 223
    de24:	95 54       	subi	r25, 0x45	; 69
    de26:	93 30       	cpi	r25, 0x03	; 3
    de28:	28 f4       	brcc	.+10     	; 0xde34 <vfprintf+0x116>
    de2a:	0c 5f       	subi	r16, 0xFC	; 252
    de2c:	1f 4f       	sbci	r17, 0xFF	; 255
    de2e:	ff e3       	ldi	r31, 0x3F	; 63
    de30:	f9 83       	std	Y+1, r31	; 0x01
    de32:	0d c0       	rjmp	.+26     	; 0xde4e <vfprintf+0x130>
    de34:	83 36       	cpi	r24, 0x63	; 99
    de36:	31 f0       	breq	.+12     	; 0xde44 <vfprintf+0x126>
    de38:	83 37       	cpi	r24, 0x73	; 115
    de3a:	71 f0       	breq	.+28     	; 0xde58 <vfprintf+0x13a>
    de3c:	83 35       	cpi	r24, 0x53	; 83
    de3e:	09 f0       	breq	.+2      	; 0xde42 <vfprintf+0x124>
    de40:	5b c0       	rjmp	.+182    	; 0xdef8 <vfprintf+0x1da>
    de42:	22 c0       	rjmp	.+68     	; 0xde88 <vfprintf+0x16a>
    de44:	f8 01       	movw	r30, r16
    de46:	80 81       	ld	r24, Z
    de48:	89 83       	std	Y+1, r24	; 0x01
    de4a:	0e 5f       	subi	r16, 0xFE	; 254
    de4c:	1f 4f       	sbci	r17, 0xFF	; 255
    de4e:	44 24       	eor	r4, r4
    de50:	43 94       	inc	r4
    de52:	51 2c       	mov	r5, r1
    de54:	54 01       	movw	r10, r8
    de56:	15 c0       	rjmp	.+42     	; 0xde82 <vfprintf+0x164>
    de58:	38 01       	movw	r6, r16
    de5a:	f2 e0       	ldi	r31, 0x02	; 2
    de5c:	6f 0e       	add	r6, r31
    de5e:	71 1c       	adc	r7, r1
    de60:	f8 01       	movw	r30, r16
    de62:	a0 80       	ld	r10, Z
    de64:	b1 80       	ldd	r11, Z+1	; 0x01
    de66:	26 ff       	sbrs	r18, 6
    de68:	03 c0       	rjmp	.+6      	; 0xde70 <vfprintf+0x152>
    de6a:	65 2d       	mov	r22, r5
    de6c:	70 e0       	ldi	r23, 0x00	; 0
    de6e:	02 c0       	rjmp	.+4      	; 0xde74 <vfprintf+0x156>
    de70:	6f ef       	ldi	r22, 0xFF	; 255
    de72:	7f ef       	ldi	r23, 0xFF	; 255
    de74:	c5 01       	movw	r24, r10
    de76:	2c 87       	std	Y+12, r18	; 0x0c
    de78:	0e 94 b9 73 	call	0xe772	; 0xe772 <strnlen>
    de7c:	2c 01       	movw	r4, r24
    de7e:	83 01       	movw	r16, r6
    de80:	2c 85       	ldd	r18, Y+12	; 0x0c
    de82:	2f 77       	andi	r18, 0x7F	; 127
    de84:	22 2e       	mov	r2, r18
    de86:	17 c0       	rjmp	.+46     	; 0xdeb6 <vfprintf+0x198>
    de88:	38 01       	movw	r6, r16
    de8a:	f2 e0       	ldi	r31, 0x02	; 2
    de8c:	6f 0e       	add	r6, r31
    de8e:	71 1c       	adc	r7, r1
    de90:	f8 01       	movw	r30, r16
    de92:	a0 80       	ld	r10, Z
    de94:	b1 80       	ldd	r11, Z+1	; 0x01
    de96:	26 ff       	sbrs	r18, 6
    de98:	03 c0       	rjmp	.+6      	; 0xdea0 <vfprintf+0x182>
    de9a:	65 2d       	mov	r22, r5
    de9c:	70 e0       	ldi	r23, 0x00	; 0
    de9e:	02 c0       	rjmp	.+4      	; 0xdea4 <vfprintf+0x186>
    dea0:	6f ef       	ldi	r22, 0xFF	; 255
    dea2:	7f ef       	ldi	r23, 0xFF	; 255
    dea4:	c5 01       	movw	r24, r10
    dea6:	2c 87       	std	Y+12, r18	; 0x0c
    dea8:	0e 94 ae 73 	call	0xe75c	; 0xe75c <strnlen_P>
    deac:	2c 01       	movw	r4, r24
    deae:	2c 85       	ldd	r18, Y+12	; 0x0c
    deb0:	20 68       	ori	r18, 0x80	; 128
    deb2:	22 2e       	mov	r2, r18
    deb4:	83 01       	movw	r16, r6
    deb6:	23 fc       	sbrc	r2, 3
    deb8:	1b c0       	rjmp	.+54     	; 0xdef0 <vfprintf+0x1d2>
    deba:	83 2d       	mov	r24, r3
    debc:	90 e0       	ldi	r25, 0x00	; 0
    debe:	48 16       	cp	r4, r24
    dec0:	59 06       	cpc	r5, r25
    dec2:	b0 f4       	brcc	.+44     	; 0xdef0 <vfprintf+0x1d2>
    dec4:	b7 01       	movw	r22, r14
    dec6:	80 e2       	ldi	r24, 0x20	; 32
    dec8:	90 e0       	ldi	r25, 0x00	; 0
    deca:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    dece:	3a 94       	dec	r3
    ded0:	f4 cf       	rjmp	.-24     	; 0xdeba <vfprintf+0x19c>
    ded2:	f5 01       	movw	r30, r10
    ded4:	27 fc       	sbrc	r2, 7
    ded6:	85 91       	lpm	r24, Z+
    ded8:	27 fe       	sbrs	r2, 7
    deda:	81 91       	ld	r24, Z+
    dedc:	5f 01       	movw	r10, r30
    dede:	b7 01       	movw	r22, r14
    dee0:	90 e0       	ldi	r25, 0x00	; 0
    dee2:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    dee6:	31 10       	cpse	r3, r1
    dee8:	3a 94       	dec	r3
    deea:	f1 e0       	ldi	r31, 0x01	; 1
    deec:	4f 1a       	sub	r4, r31
    deee:	51 08       	sbc	r5, r1
    def0:	41 14       	cp	r4, r1
    def2:	51 04       	cpc	r5, r1
    def4:	71 f7       	brne	.-36     	; 0xded2 <vfprintf+0x1b4>
    def6:	e5 c0       	rjmp	.+458    	; 0xe0c2 <vfprintf+0x3a4>
    def8:	84 36       	cpi	r24, 0x64	; 100
    defa:	11 f0       	breq	.+4      	; 0xdf00 <vfprintf+0x1e2>
    defc:	89 36       	cpi	r24, 0x69	; 105
    defe:	39 f5       	brne	.+78     	; 0xdf4e <vfprintf+0x230>
    df00:	f8 01       	movw	r30, r16
    df02:	27 ff       	sbrs	r18, 7
    df04:	07 c0       	rjmp	.+14     	; 0xdf14 <vfprintf+0x1f6>
    df06:	60 81       	ld	r22, Z
    df08:	71 81       	ldd	r23, Z+1	; 0x01
    df0a:	82 81       	ldd	r24, Z+2	; 0x02
    df0c:	93 81       	ldd	r25, Z+3	; 0x03
    df0e:	0c 5f       	subi	r16, 0xFC	; 252
    df10:	1f 4f       	sbci	r17, 0xFF	; 255
    df12:	08 c0       	rjmp	.+16     	; 0xdf24 <vfprintf+0x206>
    df14:	60 81       	ld	r22, Z
    df16:	71 81       	ldd	r23, Z+1	; 0x01
    df18:	88 27       	eor	r24, r24
    df1a:	77 fd       	sbrc	r23, 7
    df1c:	80 95       	com	r24
    df1e:	98 2f       	mov	r25, r24
    df20:	0e 5f       	subi	r16, 0xFE	; 254
    df22:	1f 4f       	sbci	r17, 0xFF	; 255
    df24:	2f 76       	andi	r18, 0x6F	; 111
    df26:	b2 2e       	mov	r11, r18
    df28:	97 ff       	sbrs	r25, 7
    df2a:	09 c0       	rjmp	.+18     	; 0xdf3e <vfprintf+0x220>
    df2c:	90 95       	com	r25
    df2e:	80 95       	com	r24
    df30:	70 95       	com	r23
    df32:	61 95       	neg	r22
    df34:	7f 4f       	sbci	r23, 0xFF	; 255
    df36:	8f 4f       	sbci	r24, 0xFF	; 255
    df38:	9f 4f       	sbci	r25, 0xFF	; 255
    df3a:	20 68       	ori	r18, 0x80	; 128
    df3c:	b2 2e       	mov	r11, r18
    df3e:	2a e0       	ldi	r18, 0x0A	; 10
    df40:	30 e0       	ldi	r19, 0x00	; 0
    df42:	a4 01       	movw	r20, r8
    df44:	0e 94 4d 74 	call	0xe89a	; 0xe89a <__ultoa_invert>
    df48:	a8 2e       	mov	r10, r24
    df4a:	a8 18       	sub	r10, r8
    df4c:	44 c0       	rjmp	.+136    	; 0xdfd6 <vfprintf+0x2b8>
    df4e:	85 37       	cpi	r24, 0x75	; 117
    df50:	29 f4       	brne	.+10     	; 0xdf5c <vfprintf+0x23e>
    df52:	2f 7e       	andi	r18, 0xEF	; 239
    df54:	b2 2e       	mov	r11, r18
    df56:	2a e0       	ldi	r18, 0x0A	; 10
    df58:	30 e0       	ldi	r19, 0x00	; 0
    df5a:	25 c0       	rjmp	.+74     	; 0xdfa6 <vfprintf+0x288>
    df5c:	f2 2f       	mov	r31, r18
    df5e:	f9 7f       	andi	r31, 0xF9	; 249
    df60:	bf 2e       	mov	r11, r31
    df62:	8f 36       	cpi	r24, 0x6F	; 111
    df64:	c1 f0       	breq	.+48     	; 0xdf96 <vfprintf+0x278>
    df66:	18 f4       	brcc	.+6      	; 0xdf6e <vfprintf+0x250>
    df68:	88 35       	cpi	r24, 0x58	; 88
    df6a:	79 f0       	breq	.+30     	; 0xdf8a <vfprintf+0x26c>
    df6c:	b4 c0       	rjmp	.+360    	; 0xe0d6 <vfprintf+0x3b8>
    df6e:	80 37       	cpi	r24, 0x70	; 112
    df70:	19 f0       	breq	.+6      	; 0xdf78 <vfprintf+0x25a>
    df72:	88 37       	cpi	r24, 0x78	; 120
    df74:	21 f0       	breq	.+8      	; 0xdf7e <vfprintf+0x260>
    df76:	af c0       	rjmp	.+350    	; 0xe0d6 <vfprintf+0x3b8>
    df78:	2f 2f       	mov	r18, r31
    df7a:	20 61       	ori	r18, 0x10	; 16
    df7c:	b2 2e       	mov	r11, r18
    df7e:	b4 fe       	sbrs	r11, 4
    df80:	0d c0       	rjmp	.+26     	; 0xdf9c <vfprintf+0x27e>
    df82:	8b 2d       	mov	r24, r11
    df84:	84 60       	ori	r24, 0x04	; 4
    df86:	b8 2e       	mov	r11, r24
    df88:	09 c0       	rjmp	.+18     	; 0xdf9c <vfprintf+0x27e>
    df8a:	24 ff       	sbrs	r18, 4
    df8c:	0a c0       	rjmp	.+20     	; 0xdfa2 <vfprintf+0x284>
    df8e:	9f 2f       	mov	r25, r31
    df90:	96 60       	ori	r25, 0x06	; 6
    df92:	b9 2e       	mov	r11, r25
    df94:	06 c0       	rjmp	.+12     	; 0xdfa2 <vfprintf+0x284>
    df96:	28 e0       	ldi	r18, 0x08	; 8
    df98:	30 e0       	ldi	r19, 0x00	; 0
    df9a:	05 c0       	rjmp	.+10     	; 0xdfa6 <vfprintf+0x288>
    df9c:	20 e1       	ldi	r18, 0x10	; 16
    df9e:	30 e0       	ldi	r19, 0x00	; 0
    dfa0:	02 c0       	rjmp	.+4      	; 0xdfa6 <vfprintf+0x288>
    dfa2:	20 e1       	ldi	r18, 0x10	; 16
    dfa4:	32 e0       	ldi	r19, 0x02	; 2
    dfa6:	f8 01       	movw	r30, r16
    dfa8:	b7 fe       	sbrs	r11, 7
    dfaa:	07 c0       	rjmp	.+14     	; 0xdfba <vfprintf+0x29c>
    dfac:	60 81       	ld	r22, Z
    dfae:	71 81       	ldd	r23, Z+1	; 0x01
    dfb0:	82 81       	ldd	r24, Z+2	; 0x02
    dfb2:	93 81       	ldd	r25, Z+3	; 0x03
    dfb4:	0c 5f       	subi	r16, 0xFC	; 252
    dfb6:	1f 4f       	sbci	r17, 0xFF	; 255
    dfb8:	06 c0       	rjmp	.+12     	; 0xdfc6 <vfprintf+0x2a8>
    dfba:	60 81       	ld	r22, Z
    dfbc:	71 81       	ldd	r23, Z+1	; 0x01
    dfbe:	80 e0       	ldi	r24, 0x00	; 0
    dfc0:	90 e0       	ldi	r25, 0x00	; 0
    dfc2:	0e 5f       	subi	r16, 0xFE	; 254
    dfc4:	1f 4f       	sbci	r17, 0xFF	; 255
    dfc6:	a4 01       	movw	r20, r8
    dfc8:	0e 94 4d 74 	call	0xe89a	; 0xe89a <__ultoa_invert>
    dfcc:	a8 2e       	mov	r10, r24
    dfce:	a8 18       	sub	r10, r8
    dfd0:	fb 2d       	mov	r31, r11
    dfd2:	ff 77       	andi	r31, 0x7F	; 127
    dfd4:	bf 2e       	mov	r11, r31
    dfd6:	b6 fe       	sbrs	r11, 6
    dfd8:	0b c0       	rjmp	.+22     	; 0xdff0 <vfprintf+0x2d2>
    dfda:	2b 2d       	mov	r18, r11
    dfdc:	2e 7f       	andi	r18, 0xFE	; 254
    dfde:	a5 14       	cp	r10, r5
    dfe0:	50 f4       	brcc	.+20     	; 0xdff6 <vfprintf+0x2d8>
    dfe2:	b4 fe       	sbrs	r11, 4
    dfe4:	0a c0       	rjmp	.+20     	; 0xdffa <vfprintf+0x2dc>
    dfe6:	b2 fc       	sbrc	r11, 2
    dfe8:	08 c0       	rjmp	.+16     	; 0xdffa <vfprintf+0x2dc>
    dfea:	2b 2d       	mov	r18, r11
    dfec:	2e 7e       	andi	r18, 0xEE	; 238
    dfee:	05 c0       	rjmp	.+10     	; 0xdffa <vfprintf+0x2dc>
    dff0:	7a 2c       	mov	r7, r10
    dff2:	2b 2d       	mov	r18, r11
    dff4:	03 c0       	rjmp	.+6      	; 0xdffc <vfprintf+0x2de>
    dff6:	7a 2c       	mov	r7, r10
    dff8:	01 c0       	rjmp	.+2      	; 0xdffc <vfprintf+0x2de>
    dffa:	75 2c       	mov	r7, r5
    dffc:	24 ff       	sbrs	r18, 4
    dffe:	0d c0       	rjmp	.+26     	; 0xe01a <vfprintf+0x2fc>
    e000:	fe 01       	movw	r30, r28
    e002:	ea 0d       	add	r30, r10
    e004:	f1 1d       	adc	r31, r1
    e006:	80 81       	ld	r24, Z
    e008:	80 33       	cpi	r24, 0x30	; 48
    e00a:	11 f4       	brne	.+4      	; 0xe010 <vfprintf+0x2f2>
    e00c:	29 7e       	andi	r18, 0xE9	; 233
    e00e:	09 c0       	rjmp	.+18     	; 0xe022 <vfprintf+0x304>
    e010:	22 ff       	sbrs	r18, 2
    e012:	06 c0       	rjmp	.+12     	; 0xe020 <vfprintf+0x302>
    e014:	73 94       	inc	r7
    e016:	73 94       	inc	r7
    e018:	04 c0       	rjmp	.+8      	; 0xe022 <vfprintf+0x304>
    e01a:	82 2f       	mov	r24, r18
    e01c:	86 78       	andi	r24, 0x86	; 134
    e01e:	09 f0       	breq	.+2      	; 0xe022 <vfprintf+0x304>
    e020:	73 94       	inc	r7
    e022:	23 fd       	sbrc	r18, 3
    e024:	13 c0       	rjmp	.+38     	; 0xe04c <vfprintf+0x32e>
    e026:	20 ff       	sbrs	r18, 0
    e028:	06 c0       	rjmp	.+12     	; 0xe036 <vfprintf+0x318>
    e02a:	5a 2c       	mov	r5, r10
    e02c:	73 14       	cp	r7, r3
    e02e:	18 f4       	brcc	.+6      	; 0xe036 <vfprintf+0x318>
    e030:	53 0c       	add	r5, r3
    e032:	57 18       	sub	r5, r7
    e034:	73 2c       	mov	r7, r3
    e036:	73 14       	cp	r7, r3
    e038:	68 f4       	brcc	.+26     	; 0xe054 <vfprintf+0x336>
    e03a:	b7 01       	movw	r22, r14
    e03c:	80 e2       	ldi	r24, 0x20	; 32
    e03e:	90 e0       	ldi	r25, 0x00	; 0
    e040:	2c 87       	std	Y+12, r18	; 0x0c
    e042:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e046:	73 94       	inc	r7
    e048:	2c 85       	ldd	r18, Y+12	; 0x0c
    e04a:	f5 cf       	rjmp	.-22     	; 0xe036 <vfprintf+0x318>
    e04c:	73 14       	cp	r7, r3
    e04e:	10 f4       	brcc	.+4      	; 0xe054 <vfprintf+0x336>
    e050:	37 18       	sub	r3, r7
    e052:	01 c0       	rjmp	.+2      	; 0xe056 <vfprintf+0x338>
    e054:	31 2c       	mov	r3, r1
    e056:	24 ff       	sbrs	r18, 4
    e058:	12 c0       	rjmp	.+36     	; 0xe07e <vfprintf+0x360>
    e05a:	b7 01       	movw	r22, r14
    e05c:	80 e3       	ldi	r24, 0x30	; 48
    e05e:	90 e0       	ldi	r25, 0x00	; 0
    e060:	2c 87       	std	Y+12, r18	; 0x0c
    e062:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e066:	2c 85       	ldd	r18, Y+12	; 0x0c
    e068:	22 ff       	sbrs	r18, 2
    e06a:	17 c0       	rjmp	.+46     	; 0xe09a <vfprintf+0x37c>
    e06c:	21 ff       	sbrs	r18, 1
    e06e:	03 c0       	rjmp	.+6      	; 0xe076 <vfprintf+0x358>
    e070:	88 e5       	ldi	r24, 0x58	; 88
    e072:	90 e0       	ldi	r25, 0x00	; 0
    e074:	02 c0       	rjmp	.+4      	; 0xe07a <vfprintf+0x35c>
    e076:	88 e7       	ldi	r24, 0x78	; 120
    e078:	90 e0       	ldi	r25, 0x00	; 0
    e07a:	b7 01       	movw	r22, r14
    e07c:	0c c0       	rjmp	.+24     	; 0xe096 <vfprintf+0x378>
    e07e:	82 2f       	mov	r24, r18
    e080:	86 78       	andi	r24, 0x86	; 134
    e082:	59 f0       	breq	.+22     	; 0xe09a <vfprintf+0x37c>
    e084:	21 fd       	sbrc	r18, 1
    e086:	02 c0       	rjmp	.+4      	; 0xe08c <vfprintf+0x36e>
    e088:	80 e2       	ldi	r24, 0x20	; 32
    e08a:	01 c0       	rjmp	.+2      	; 0xe08e <vfprintf+0x370>
    e08c:	8b e2       	ldi	r24, 0x2B	; 43
    e08e:	27 fd       	sbrc	r18, 7
    e090:	8d e2       	ldi	r24, 0x2D	; 45
    e092:	b7 01       	movw	r22, r14
    e094:	90 e0       	ldi	r25, 0x00	; 0
    e096:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e09a:	a5 14       	cp	r10, r5
    e09c:	38 f4       	brcc	.+14     	; 0xe0ac <vfprintf+0x38e>
    e09e:	b7 01       	movw	r22, r14
    e0a0:	80 e3       	ldi	r24, 0x30	; 48
    e0a2:	90 e0       	ldi	r25, 0x00	; 0
    e0a4:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e0a8:	5a 94       	dec	r5
    e0aa:	f7 cf       	rjmp	.-18     	; 0xe09a <vfprintf+0x37c>
    e0ac:	aa 94       	dec	r10
    e0ae:	f4 01       	movw	r30, r8
    e0b0:	ea 0d       	add	r30, r10
    e0b2:	f1 1d       	adc	r31, r1
    e0b4:	80 81       	ld	r24, Z
    e0b6:	b7 01       	movw	r22, r14
    e0b8:	90 e0       	ldi	r25, 0x00	; 0
    e0ba:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e0be:	a1 10       	cpse	r10, r1
    e0c0:	f5 cf       	rjmp	.-22     	; 0xe0ac <vfprintf+0x38e>
    e0c2:	33 20       	and	r3, r3
    e0c4:	09 f4       	brne	.+2      	; 0xe0c8 <vfprintf+0x3aa>
    e0c6:	51 ce       	rjmp	.-862    	; 0xdd6a <vfprintf+0x4c>
    e0c8:	b7 01       	movw	r22, r14
    e0ca:	80 e2       	ldi	r24, 0x20	; 32
    e0cc:	90 e0       	ldi	r25, 0x00	; 0
    e0ce:	0e 94 02 74 	call	0xe804	; 0xe804 <fputc>
    e0d2:	3a 94       	dec	r3
    e0d4:	f6 cf       	rjmp	.-20     	; 0xe0c2 <vfprintf+0x3a4>
    e0d6:	f7 01       	movw	r30, r14
    e0d8:	86 81       	ldd	r24, Z+6	; 0x06
    e0da:	97 81       	ldd	r25, Z+7	; 0x07
    e0dc:	02 c0       	rjmp	.+4      	; 0xe0e2 <vfprintf+0x3c4>
    e0de:	8f ef       	ldi	r24, 0xFF	; 255
    e0e0:	9f ef       	ldi	r25, 0xFF	; 255
    e0e2:	2c 96       	adiw	r28, 0x0c	; 12
    e0e4:	0f b6       	in	r0, 0x3f	; 63
    e0e6:	f8 94       	cli
    e0e8:	de bf       	out	0x3e, r29	; 62
    e0ea:	0f be       	out	0x3f, r0	; 63
    e0ec:	cd bf       	out	0x3d, r28	; 61
    e0ee:	df 91       	pop	r29
    e0f0:	cf 91       	pop	r28
    e0f2:	1f 91       	pop	r17
    e0f4:	0f 91       	pop	r16
    e0f6:	ff 90       	pop	r15
    e0f8:	ef 90       	pop	r14
    e0fa:	df 90       	pop	r13
    e0fc:	cf 90       	pop	r12
    e0fe:	bf 90       	pop	r11
    e100:	af 90       	pop	r10
    e102:	9f 90       	pop	r9
    e104:	8f 90       	pop	r8
    e106:	7f 90       	pop	r7
    e108:	6f 90       	pop	r6
    e10a:	5f 90       	pop	r5
    e10c:	4f 90       	pop	r4
    e10e:	3f 90       	pop	r3
    e110:	2f 90       	pop	r2
    e112:	08 95       	ret

0000e114 <putval>:
    e114:	20 fd       	sbrc	r18, 0
    e116:	09 c0       	rjmp	.+18     	; 0xe12a <putval+0x16>
    e118:	fc 01       	movw	r30, r24
    e11a:	23 fd       	sbrc	r18, 3
    e11c:	05 c0       	rjmp	.+10     	; 0xe128 <putval+0x14>
    e11e:	22 ff       	sbrs	r18, 2
    e120:	02 c0       	rjmp	.+4      	; 0xe126 <putval+0x12>
    e122:	73 83       	std	Z+3, r23	; 0x03
    e124:	62 83       	std	Z+2, r22	; 0x02
    e126:	51 83       	std	Z+1, r21	; 0x01
    e128:	40 83       	st	Z, r20
    e12a:	08 95       	ret

0000e12c <mulacc>:
    e12c:	44 fd       	sbrc	r20, 4
    e12e:	10 c0       	rjmp	.+32     	; 0xe150 <mulacc+0x24>
    e130:	46 fd       	sbrc	r20, 6
    e132:	10 c0       	rjmp	.+32     	; 0xe154 <mulacc+0x28>
    e134:	db 01       	movw	r26, r22
    e136:	fc 01       	movw	r30, r24
    e138:	aa 0f       	add	r26, r26
    e13a:	bb 1f       	adc	r27, r27
    e13c:	ee 1f       	adc	r30, r30
    e13e:	ff 1f       	adc	r31, r31
    e140:	10 94       	com	r1
    e142:	d1 f7       	brne	.-12     	; 0xe138 <mulacc+0xc>
    e144:	6a 0f       	add	r22, r26
    e146:	7b 1f       	adc	r23, r27
    e148:	8e 1f       	adc	r24, r30
    e14a:	9f 1f       	adc	r25, r31
    e14c:	31 e0       	ldi	r19, 0x01	; 1
    e14e:	03 c0       	rjmp	.+6      	; 0xe156 <mulacc+0x2a>
    e150:	33 e0       	ldi	r19, 0x03	; 3
    e152:	01 c0       	rjmp	.+2      	; 0xe156 <mulacc+0x2a>
    e154:	34 e0       	ldi	r19, 0x04	; 4
    e156:	66 0f       	add	r22, r22
    e158:	77 1f       	adc	r23, r23
    e15a:	88 1f       	adc	r24, r24
    e15c:	99 1f       	adc	r25, r25
    e15e:	31 50       	subi	r19, 0x01	; 1
    e160:	d1 f7       	brne	.-12     	; 0xe156 <mulacc+0x2a>
    e162:	62 0f       	add	r22, r18
    e164:	71 1d       	adc	r23, r1
    e166:	81 1d       	adc	r24, r1
    e168:	91 1d       	adc	r25, r1
    e16a:	08 95       	ret

0000e16c <skip_spaces>:
    e16c:	0f 93       	push	r16
    e16e:	1f 93       	push	r17
    e170:	cf 93       	push	r28
    e172:	df 93       	push	r29
    e174:	8c 01       	movw	r16, r24
    e176:	c8 01       	movw	r24, r16
    e178:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e17c:	ec 01       	movw	r28, r24
    e17e:	97 fd       	sbrc	r25, 7
    e180:	08 c0       	rjmp	.+16     	; 0xe192 <skip_spaces+0x26>
    e182:	0e 94 a6 73 	call	0xe74c	; 0xe74c <isspace>
    e186:	89 2b       	or	r24, r25
    e188:	b1 f7       	brne	.-20     	; 0xe176 <skip_spaces+0xa>
    e18a:	b8 01       	movw	r22, r16
    e18c:	ce 01       	movw	r24, r28
    e18e:	0e 94 34 74 	call	0xe868	; 0xe868 <ungetc>
    e192:	ce 01       	movw	r24, r28
    e194:	df 91       	pop	r29
    e196:	cf 91       	pop	r28
    e198:	1f 91       	pop	r17
    e19a:	0f 91       	pop	r16
    e19c:	08 95       	ret

0000e19e <conv_int>:
    e19e:	8f 92       	push	r8
    e1a0:	9f 92       	push	r9
    e1a2:	af 92       	push	r10
    e1a4:	cf 92       	push	r12
    e1a6:	df 92       	push	r13
    e1a8:	ef 92       	push	r14
    e1aa:	ff 92       	push	r15
    e1ac:	0f 93       	push	r16
    e1ae:	1f 93       	push	r17
    e1b0:	cf 93       	push	r28
    e1b2:	df 93       	push	r29
    e1b4:	ec 01       	movw	r28, r24
    e1b6:	a6 2e       	mov	r10, r22
    e1b8:	4a 01       	movw	r8, r20
    e1ba:	02 2f       	mov	r16, r18
    e1bc:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e1c0:	ac 01       	movw	r20, r24
    e1c2:	55 27       	eor	r21, r21
    e1c4:	4b 32       	cpi	r20, 0x2B	; 43
    e1c6:	51 05       	cpc	r21, r1
    e1c8:	21 f0       	breq	.+8      	; 0xe1d2 <conv_int+0x34>
    e1ca:	4d 32       	cpi	r20, 0x2D	; 45
    e1cc:	51 05       	cpc	r21, r1
    e1ce:	51 f4       	brne	.+20     	; 0xe1e4 <conv_int+0x46>
    e1d0:	00 68       	ori	r16, 0x80	; 128
    e1d2:	aa 94       	dec	r10
    e1d4:	11 f4       	brne	.+4      	; 0xe1da <conv_int+0x3c>
    e1d6:	80 e0       	ldi	r24, 0x00	; 0
    e1d8:	67 c0       	rjmp	.+206    	; 0xe2a8 <conv_int+0x10a>
    e1da:	ce 01       	movw	r24, r28
    e1dc:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e1e0:	97 fd       	sbrc	r25, 7
    e1e2:	f9 cf       	rjmp	.-14     	; 0xe1d6 <conv_int+0x38>
    e1e4:	10 2f       	mov	r17, r16
    e1e6:	1d 7f       	andi	r17, 0xFD	; 253
    e1e8:	30 2f       	mov	r19, r16
    e1ea:	30 73       	andi	r19, 0x30	; 48
    e1ec:	01 f5       	brne	.+64     	; 0xe22e <conv_int+0x90>
    e1ee:	80 33       	cpi	r24, 0x30	; 48
    e1f0:	f1 f4       	brne	.+60     	; 0xe22e <conv_int+0x90>
    e1f2:	ff 24       	eor	r15, r15
    e1f4:	fa 94       	dec	r15
    e1f6:	fa 0c       	add	r15, r10
    e1f8:	09 f4       	brne	.+2      	; 0xe1fc <conv_int+0x5e>
    e1fa:	42 c0       	rjmp	.+132    	; 0xe280 <conv_int+0xe2>
    e1fc:	ce 01       	movw	r24, r28
    e1fe:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e202:	97 fd       	sbrc	r25, 7
    e204:	3d c0       	rjmp	.+122    	; 0xe280 <conv_int+0xe2>
    e206:	38 2f       	mov	r19, r24
    e208:	3f 7d       	andi	r19, 0xDF	; 223
    e20a:	38 35       	cpi	r19, 0x58	; 88
    e20c:	51 f4       	brne	.+20     	; 0xe222 <conv_int+0x84>
    e20e:	12 64       	ori	r17, 0x42	; 66
    e210:	aa 94       	dec	r10
    e212:	aa 94       	dec	r10
    e214:	a9 f1       	breq	.+106    	; 0xe280 <conv_int+0xe2>
    e216:	ce 01       	movw	r24, r28
    e218:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e21c:	97 ff       	sbrs	r25, 7
    e21e:	07 c0       	rjmp	.+14     	; 0xe22e <conv_int+0x90>
    e220:	2f c0       	rjmp	.+94     	; 0xe280 <conv_int+0xe2>
    e222:	06 ff       	sbrs	r16, 6
    e224:	02 c0       	rjmp	.+4      	; 0xe22a <conv_int+0x8c>
    e226:	12 60       	ori	r17, 0x02	; 2
    e228:	01 c0       	rjmp	.+2      	; 0xe22c <conv_int+0x8e>
    e22a:	12 61       	ori	r17, 0x12	; 18
    e22c:	af 2c       	mov	r10, r15
    e22e:	c1 2c       	mov	r12, r1
    e230:	d1 2c       	mov	r13, r1
    e232:	76 01       	movw	r14, r12
    e234:	20 ed       	ldi	r18, 0xD0	; 208
    e236:	28 0f       	add	r18, r24
    e238:	28 30       	cpi	r18, 0x08	; 8
    e23a:	80 f0       	brcs	.+32     	; 0xe25c <conv_int+0xbe>
    e23c:	14 ff       	sbrs	r17, 4
    e23e:	04 c0       	rjmp	.+8      	; 0xe248 <conv_int+0xaa>
    e240:	be 01       	movw	r22, r28
    e242:	0e 94 34 74 	call	0xe868	; 0xe868 <ungetc>
    e246:	19 c0       	rjmp	.+50     	; 0xe27a <conv_int+0xdc>
    e248:	2a 30       	cpi	r18, 0x0A	; 10
    e24a:	40 f0       	brcs	.+16     	; 0xe25c <conv_int+0xbe>
    e24c:	16 ff       	sbrs	r17, 6
    e24e:	f8 cf       	rjmp	.-16     	; 0xe240 <conv_int+0xa2>
    e250:	2f 7d       	andi	r18, 0xDF	; 223
    e252:	3f ee       	ldi	r19, 0xEF	; 239
    e254:	32 0f       	add	r19, r18
    e256:	36 30       	cpi	r19, 0x06	; 6
    e258:	98 f7       	brcc	.-26     	; 0xe240 <conv_int+0xa2>
    e25a:	27 50       	subi	r18, 0x07	; 7
    e25c:	41 2f       	mov	r20, r17
    e25e:	c7 01       	movw	r24, r14
    e260:	b6 01       	movw	r22, r12
    e262:	0e 94 96 70 	call	0xe12c	; 0xe12c <mulacc>
    e266:	6b 01       	movw	r12, r22
    e268:	7c 01       	movw	r14, r24
    e26a:	12 60       	ori	r17, 0x02	; 2
    e26c:	aa 94       	dec	r10
    e26e:	59 f0       	breq	.+22     	; 0xe286 <conv_int+0xe8>
    e270:	ce 01       	movw	r24, r28
    e272:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e276:	97 ff       	sbrs	r25, 7
    e278:	dd cf       	rjmp	.-70     	; 0xe234 <conv_int+0x96>
    e27a:	11 fd       	sbrc	r17, 1
    e27c:	04 c0       	rjmp	.+8      	; 0xe286 <conv_int+0xe8>
    e27e:	ab cf       	rjmp	.-170    	; 0xe1d6 <conv_int+0x38>
    e280:	c1 2c       	mov	r12, r1
    e282:	d1 2c       	mov	r13, r1
    e284:	76 01       	movw	r14, r12
    e286:	17 ff       	sbrs	r17, 7
    e288:	08 c0       	rjmp	.+16     	; 0xe29a <conv_int+0xfc>
    e28a:	f0 94       	com	r15
    e28c:	e0 94       	com	r14
    e28e:	d0 94       	com	r13
    e290:	c0 94       	com	r12
    e292:	c1 1c       	adc	r12, r1
    e294:	d1 1c       	adc	r13, r1
    e296:	e1 1c       	adc	r14, r1
    e298:	f1 1c       	adc	r15, r1
    e29a:	21 2f       	mov	r18, r17
    e29c:	b7 01       	movw	r22, r14
    e29e:	a6 01       	movw	r20, r12
    e2a0:	c4 01       	movw	r24, r8
    e2a2:	0e 94 8a 70 	call	0xe114	; 0xe114 <putval>
    e2a6:	81 e0       	ldi	r24, 0x01	; 1
    e2a8:	df 91       	pop	r29
    e2aa:	cf 91       	pop	r28
    e2ac:	1f 91       	pop	r17
    e2ae:	0f 91       	pop	r16
    e2b0:	ff 90       	pop	r15
    e2b2:	ef 90       	pop	r14
    e2b4:	df 90       	pop	r13
    e2b6:	cf 90       	pop	r12
    e2b8:	af 90       	pop	r10
    e2ba:	9f 90       	pop	r9
    e2bc:	8f 90       	pop	r8
    e2be:	08 95       	ret

0000e2c0 <conv_brk>:
    e2c0:	7f 92       	push	r7
    e2c2:	8f 92       	push	r8
    e2c4:	9f 92       	push	r9
    e2c6:	af 92       	push	r10
    e2c8:	bf 92       	push	r11
    e2ca:	cf 92       	push	r12
    e2cc:	df 92       	push	r13
    e2ce:	ef 92       	push	r14
    e2d0:	ff 92       	push	r15
    e2d2:	0f 93       	push	r16
    e2d4:	1f 93       	push	r17
    e2d6:	cf 93       	push	r28
    e2d8:	df 93       	push	r29
    e2da:	cd b7       	in	r28, 0x3d	; 61
    e2dc:	de b7       	in	r29, 0x3e	; 62
    e2de:	a1 97       	sbiw	r28, 0x21	; 33
    e2e0:	0f b6       	in	r0, 0x3f	; 63
    e2e2:	f8 94       	cli
    e2e4:	de bf       	out	0x3e, r29	; 62
    e2e6:	0f be       	out	0x3f, r0	; 63
    e2e8:	cd bf       	out	0x3d, r28	; 61
    e2ea:	5c 01       	movw	r10, r24
    e2ec:	7a 01       	movw	r14, r20
    e2ee:	8e 01       	movw	r16, r28
    e2f0:	0f 5f       	subi	r16, 0xFF	; 255
    e2f2:	1f 4f       	sbci	r17, 0xFF	; 255
    e2f4:	68 01       	movw	r12, r16
    e2f6:	80 e2       	ldi	r24, 0x20	; 32
    e2f8:	d8 01       	movw	r26, r16
    e2fa:	1d 92       	st	X+, r1
    e2fc:	8a 95       	dec	r24
    e2fe:	e9 f7       	brne	.-6      	; 0xe2fa <conv_brk+0x3a>
    e300:	f5 01       	movw	r30, r10
    e302:	73 80       	ldd	r7, Z+3	; 0x03
    e304:	40 e0       	ldi	r20, 0x00	; 0
    e306:	50 e0       	ldi	r21, 0x00	; 0
    e308:	81 2c       	mov	r8, r1
    e30a:	b0 e0       	ldi	r27, 0x00	; 0
    e30c:	91 2c       	mov	r9, r1
    e30e:	81 e0       	ldi	r24, 0x01	; 1
    e310:	90 e0       	ldi	r25, 0x00	; 0
    e312:	f9 01       	movw	r30, r18
    e314:	73 fc       	sbrc	r7, 3
    e316:	a5 91       	lpm	r26, Z+
    e318:	73 fe       	sbrs	r7, 3
    e31a:	a1 91       	ld	r26, Z+
    e31c:	8f 01       	movw	r16, r30
    e31e:	7a 2f       	mov	r23, r26
    e320:	9f 01       	movw	r18, r30
    e322:	a1 11       	cpse	r26, r1
    e324:	03 c0       	rjmp	.+6      	; 0xe32c <conv_brk+0x6c>
    e326:	80 e0       	ldi	r24, 0x00	; 0
    e328:	90 e0       	ldi	r25, 0x00	; 0
    e32a:	7d c0       	rjmp	.+250    	; 0xe426 <conv_brk+0x166>
    e32c:	ae 35       	cpi	r26, 0x5E	; 94
    e32e:	19 f4       	brne	.+6      	; 0xe336 <conv_brk+0x76>
    e330:	41 15       	cp	r20, r1
    e332:	51 05       	cpc	r21, r1
    e334:	59 f1       	breq	.+86     	; 0xe38c <conv_brk+0xcc>
    e336:	e9 2d       	mov	r30, r9
    e338:	f0 e0       	ldi	r31, 0x00	; 0
    e33a:	e4 17       	cp	r30, r20
    e33c:	f5 07       	cpc	r31, r21
    e33e:	3c f4       	brge	.+14     	; 0xe34e <conv_brk+0x8e>
    e340:	ad 35       	cpi	r26, 0x5D	; 93
    e342:	69 f1       	breq	.+90     	; 0xe39e <conv_brk+0xde>
    e344:	ad 32       	cpi	r26, 0x2D	; 45
    e346:	19 f4       	brne	.+6      	; 0xe34e <conv_brk+0x8e>
    e348:	bb 23       	and	r27, r27
    e34a:	19 f1       	breq	.+70     	; 0xe392 <conv_brk+0xd2>
    e34c:	03 c0       	rjmp	.+6      	; 0xe354 <conv_brk+0x94>
    e34e:	b1 11       	cpse	r27, r1
    e350:	01 c0       	rjmp	.+2      	; 0xe354 <conv_brk+0x94>
    e352:	8a 2e       	mov	r8, r26
    e354:	e7 2f       	mov	r30, r23
    e356:	e6 95       	lsr	r30
    e358:	e6 95       	lsr	r30
    e35a:	e6 95       	lsr	r30
    e35c:	86 01       	movw	r16, r12
    e35e:	0e 0f       	add	r16, r30
    e360:	11 1d       	adc	r17, r1
    e362:	f8 01       	movw	r30, r16
    e364:	a7 2f       	mov	r26, r23
    e366:	a7 70       	andi	r26, 0x07	; 7
    e368:	8c 01       	movw	r16, r24
    e36a:	02 c0       	rjmp	.+4      	; 0xe370 <conv_brk+0xb0>
    e36c:	00 0f       	add	r16, r16
    e36e:	11 1f       	adc	r17, r17
    e370:	aa 95       	dec	r26
    e372:	e2 f7       	brpl	.-8      	; 0xe36c <conv_brk+0xac>
    e374:	d8 01       	movw	r26, r16
    e376:	b0 81       	ld	r27, Z
    e378:	ba 2b       	or	r27, r26
    e37a:	b0 83       	st	Z, r27
    e37c:	78 15       	cp	r23, r8
    e37e:	59 f0       	breq	.+22     	; 0xe396 <conv_brk+0xd6>
    e380:	78 15       	cp	r23, r8
    e382:	10 f4       	brcc	.+4      	; 0xe388 <conv_brk+0xc8>
    e384:	7f 5f       	subi	r23, 0xFF	; 255
    e386:	e6 cf       	rjmp	.-52     	; 0xe354 <conv_brk+0x94>
    e388:	71 50       	subi	r23, 0x01	; 1
    e38a:	e4 cf       	rjmp	.-56     	; 0xe354 <conv_brk+0x94>
    e38c:	99 24       	eor	r9, r9
    e38e:	93 94       	inc	r9
    e390:	03 c0       	rjmp	.+6      	; 0xe398 <conv_brk+0xd8>
    e392:	b1 e0       	ldi	r27, 0x01	; 1
    e394:	01 c0       	rjmp	.+2      	; 0xe398 <conv_brk+0xd8>
    e396:	b0 e0       	ldi	r27, 0x00	; 0
    e398:	4f 5f       	subi	r20, 0xFF	; 255
    e39a:	5f 4f       	sbci	r21, 0xFF	; 255
    e39c:	ba cf       	rjmp	.-140    	; 0xe312 <conv_brk+0x52>
    e39e:	bb 23       	and	r27, r27
    e3a0:	19 f0       	breq	.+6      	; 0xe3a8 <conv_brk+0xe8>
    e3a2:	8e 81       	ldd	r24, Y+6	; 0x06
    e3a4:	80 62       	ori	r24, 0x20	; 32
    e3a6:	8e 83       	std	Y+6, r24	; 0x06
    e3a8:	91 10       	cpse	r9, r1
    e3aa:	03 c0       	rjmp	.+6      	; 0xe3b2 <conv_brk+0xf2>
    e3ac:	99 24       	eor	r9, r9
    e3ae:	93 94       	inc	r9
    e3b0:	15 c0       	rjmp	.+42     	; 0xe3dc <conv_brk+0x11c>
    e3b2:	f6 01       	movw	r30, r12
    e3b4:	ce 01       	movw	r24, r28
    e3b6:	81 96       	adiw	r24, 0x21	; 33
    e3b8:	20 81       	ld	r18, Z
    e3ba:	20 95       	com	r18
    e3bc:	21 93       	st	Z+, r18
    e3be:	e8 17       	cp	r30, r24
    e3c0:	f9 07       	cpc	r31, r25
    e3c2:	d1 f7       	brne	.-12     	; 0xe3b8 <conv_brk+0xf8>
    e3c4:	f3 cf       	rjmp	.-26     	; 0xe3ac <conv_brk+0xec>
    e3c6:	e1 14       	cp	r14, r1
    e3c8:	f1 04       	cpc	r15, r1
    e3ca:	29 f0       	breq	.+10     	; 0xe3d6 <conv_brk+0x116>
    e3cc:	d7 01       	movw	r26, r14
    e3ce:	8c 93       	st	X, r24
    e3d0:	f7 01       	movw	r30, r14
    e3d2:	31 96       	adiw	r30, 0x01	; 1
    e3d4:	7f 01       	movw	r14, r30
    e3d6:	61 50       	subi	r22, 0x01	; 1
    e3d8:	01 f1       	breq	.+64     	; 0xe41a <conv_brk+0x15a>
    e3da:	91 2c       	mov	r9, r1
    e3dc:	c5 01       	movw	r24, r10
    e3de:	69 a3       	std	Y+33, r22	; 0x21
    e3e0:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e3e4:	69 a1       	ldd	r22, Y+33	; 0x21
    e3e6:	97 fd       	sbrc	r25, 7
    e3e8:	16 c0       	rjmp	.+44     	; 0xe416 <conv_brk+0x156>
    e3ea:	28 2f       	mov	r18, r24
    e3ec:	26 95       	lsr	r18
    e3ee:	26 95       	lsr	r18
    e3f0:	26 95       	lsr	r18
    e3f2:	f6 01       	movw	r30, r12
    e3f4:	e2 0f       	add	r30, r18
    e3f6:	f1 1d       	adc	r31, r1
    e3f8:	20 81       	ld	r18, Z
    e3fa:	30 e0       	ldi	r19, 0x00	; 0
    e3fc:	ac 01       	movw	r20, r24
    e3fe:	47 70       	andi	r20, 0x07	; 7
    e400:	55 27       	eor	r21, r21
    e402:	02 c0       	rjmp	.+4      	; 0xe408 <conv_brk+0x148>
    e404:	35 95       	asr	r19
    e406:	27 95       	ror	r18
    e408:	4a 95       	dec	r20
    e40a:	e2 f7       	brpl	.-8      	; 0xe404 <conv_brk+0x144>
    e40c:	20 fd       	sbrc	r18, 0
    e40e:	db cf       	rjmp	.-74     	; 0xe3c6 <conv_brk+0x106>
    e410:	b5 01       	movw	r22, r10
    e412:	0e 94 34 74 	call	0xe868	; 0xe868 <ungetc>
    e416:	91 10       	cpse	r9, r1
    e418:	86 cf       	rjmp	.-244    	; 0xe326 <conv_brk+0x66>
    e41a:	e1 14       	cp	r14, r1
    e41c:	f1 04       	cpc	r15, r1
    e41e:	11 f0       	breq	.+4      	; 0xe424 <conv_brk+0x164>
    e420:	d7 01       	movw	r26, r14
    e422:	1c 92       	st	X, r1
    e424:	c8 01       	movw	r24, r16
    e426:	a1 96       	adiw	r28, 0x21	; 33
    e428:	0f b6       	in	r0, 0x3f	; 63
    e42a:	f8 94       	cli
    e42c:	de bf       	out	0x3e, r29	; 62
    e42e:	0f be       	out	0x3f, r0	; 63
    e430:	cd bf       	out	0x3d, r28	; 61
    e432:	df 91       	pop	r29
    e434:	cf 91       	pop	r28
    e436:	1f 91       	pop	r17
    e438:	0f 91       	pop	r16
    e43a:	ff 90       	pop	r15
    e43c:	ef 90       	pop	r14
    e43e:	df 90       	pop	r13
    e440:	cf 90       	pop	r12
    e442:	bf 90       	pop	r11
    e444:	af 90       	pop	r10
    e446:	9f 90       	pop	r9
    e448:	8f 90       	pop	r8
    e44a:	7f 90       	pop	r7
    e44c:	08 95       	ret

0000e44e <vfscanf>:
    e44e:	4f 92       	push	r4
    e450:	5f 92       	push	r5
    e452:	7f 92       	push	r7
    e454:	8f 92       	push	r8
    e456:	9f 92       	push	r9
    e458:	af 92       	push	r10
    e45a:	bf 92       	push	r11
    e45c:	cf 92       	push	r12
    e45e:	df 92       	push	r13
    e460:	ef 92       	push	r14
    e462:	ff 92       	push	r15
    e464:	0f 93       	push	r16
    e466:	1f 93       	push	r17
    e468:	cf 93       	push	r28
    e46a:	df 93       	push	r29
    e46c:	1f 92       	push	r1
    e46e:	cd b7       	in	r28, 0x3d	; 61
    e470:	de b7       	in	r29, 0x3e	; 62
    e472:	8c 01       	movw	r16, r24
    e474:	2b 01       	movw	r4, r22
    e476:	7a 01       	movw	r14, r20
    e478:	fc 01       	movw	r30, r24
    e47a:	17 82       	std	Z+7, r1	; 0x07
    e47c:	16 82       	std	Z+6, r1	; 0x06
    e47e:	a1 2c       	mov	r10, r1
    e480:	f8 01       	movw	r30, r16
    e482:	d3 80       	ldd	r13, Z+3	; 0x03
    e484:	f2 01       	movw	r30, r4
    e486:	d3 fc       	sbrc	r13, 3
    e488:	85 91       	lpm	r24, Z+
    e48a:	d3 fe       	sbrs	r13, 3
    e48c:	81 91       	ld	r24, Z+
    e48e:	38 2f       	mov	r19, r24
    e490:	2f 01       	movw	r4, r30
    e492:	88 23       	and	r24, r24
    e494:	09 f4       	brne	.+2      	; 0xe498 <vfscanf+0x4a>
    e496:	fc c0       	rjmp	.+504    	; 0xe690 <vfscanf+0x242>
    e498:	90 e0       	ldi	r25, 0x00	; 0
    e49a:	39 83       	std	Y+1, r19	; 0x01
    e49c:	0e 94 a6 73 	call	0xe74c	; 0xe74c <isspace>
    e4a0:	39 81       	ldd	r19, Y+1	; 0x01
    e4a2:	89 2b       	or	r24, r25
    e4a4:	21 f0       	breq	.+8      	; 0xe4ae <vfscanf+0x60>
    e4a6:	c8 01       	movw	r24, r16
    e4a8:	0e 94 b6 70 	call	0xe16c	; 0xe16c <skip_spaces>
    e4ac:	e9 cf       	rjmp	.-46     	; 0xe480 <vfscanf+0x32>
    e4ae:	35 32       	cpi	r19, 0x25	; 37
    e4b0:	41 f4       	brne	.+16     	; 0xe4c2 <vfscanf+0x74>
    e4b2:	f2 01       	movw	r30, r4
    e4b4:	d3 fc       	sbrc	r13, 3
    e4b6:	35 91       	lpm	r19, Z+
    e4b8:	d3 fe       	sbrs	r13, 3
    e4ba:	31 91       	ld	r19, Z+
    e4bc:	2f 01       	movw	r4, r30
    e4be:	35 32       	cpi	r19, 0x25	; 37
    e4c0:	69 f4       	brne	.+26     	; 0xe4dc <vfscanf+0x8e>
    e4c2:	c8 01       	movw	r24, r16
    e4c4:	39 83       	std	Y+1, r19	; 0x01
    e4c6:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e4ca:	39 81       	ldd	r19, Y+1	; 0x01
    e4cc:	97 fd       	sbrc	r25, 7
    e4ce:	de c0       	rjmp	.+444    	; 0xe68c <vfscanf+0x23e>
    e4d0:	38 17       	cp	r19, r24
    e4d2:	b1 f2       	breq	.-84     	; 0xe480 <vfscanf+0x32>
    e4d4:	b8 01       	movw	r22, r16
    e4d6:	0e 94 34 74 	call	0xe868	; 0xe868 <ungetc>
    e4da:	da c0       	rjmp	.+436    	; 0xe690 <vfscanf+0x242>
    e4dc:	3a 32       	cpi	r19, 0x2A	; 42
    e4de:	41 f4       	brne	.+16     	; 0xe4f0 <vfscanf+0xa2>
    e4e0:	d3 fc       	sbrc	r13, 3
    e4e2:	35 91       	lpm	r19, Z+
    e4e4:	d3 fe       	sbrs	r13, 3
    e4e6:	31 91       	ld	r19, Z+
    e4e8:	2f 01       	movw	r4, r30
    e4ea:	bb 24       	eor	r11, r11
    e4ec:	b3 94       	inc	r11
    e4ee:	01 c0       	rjmp	.+2      	; 0xe4f2 <vfscanf+0xa4>
    e4f0:	b1 2c       	mov	r11, r1
    e4f2:	71 2c       	mov	r7, r1
    e4f4:	20 ed       	ldi	r18, 0xD0	; 208
    e4f6:	23 0f       	add	r18, r19
    e4f8:	2a 30       	cpi	r18, 0x0A	; 10
    e4fa:	90 f4       	brcc	.+36     	; 0xe520 <vfscanf+0xd2>
    e4fc:	fb 2d       	mov	r31, r11
    e4fe:	f2 60       	ori	r31, 0x02	; 2
    e500:	bf 2e       	mov	r11, r31
    e502:	67 2d       	mov	r22, r7
    e504:	70 e0       	ldi	r23, 0x00	; 0
    e506:	80 e0       	ldi	r24, 0x00	; 0
    e508:	90 e0       	ldi	r25, 0x00	; 0
    e50a:	40 e2       	ldi	r20, 0x20	; 32
    e50c:	0e 94 96 70 	call	0xe12c	; 0xe12c <mulacc>
    e510:	76 2e       	mov	r7, r22
    e512:	f2 01       	movw	r30, r4
    e514:	d3 fc       	sbrc	r13, 3
    e516:	35 91       	lpm	r19, Z+
    e518:	d3 fe       	sbrs	r13, 3
    e51a:	31 91       	ld	r19, Z+
    e51c:	2f 01       	movw	r4, r30
    e51e:	ea cf       	rjmp	.-44     	; 0xe4f4 <vfscanf+0xa6>
    e520:	b1 fe       	sbrs	r11, 1
    e522:	03 c0       	rjmp	.+6      	; 0xe52a <vfscanf+0xdc>
    e524:	71 10       	cpse	r7, r1
    e526:	03 c0       	rjmp	.+6      	; 0xe52e <vfscanf+0xe0>
    e528:	b3 c0       	rjmp	.+358    	; 0xe690 <vfscanf+0x242>
    e52a:	77 24       	eor	r7, r7
    e52c:	7a 94       	dec	r7
    e52e:	38 36       	cpi	r19, 0x68	; 104
    e530:	19 f0       	breq	.+6      	; 0xe538 <vfscanf+0xea>
    e532:	3c 36       	cpi	r19, 0x6C	; 108
    e534:	61 f0       	breq	.+24     	; 0xe54e <vfscanf+0x100>
    e536:	14 c0       	rjmp	.+40     	; 0xe560 <vfscanf+0x112>
    e538:	f2 01       	movw	r30, r4
    e53a:	d3 fc       	sbrc	r13, 3
    e53c:	35 91       	lpm	r19, Z+
    e53e:	d3 fe       	sbrs	r13, 3
    e540:	31 91       	ld	r19, Z+
    e542:	2f 01       	movw	r4, r30
    e544:	38 36       	cpi	r19, 0x68	; 104
    e546:	61 f4       	brne	.+24     	; 0xe560 <vfscanf+0x112>
    e548:	fb 2d       	mov	r31, r11
    e54a:	f8 60       	ori	r31, 0x08	; 8
    e54c:	bf 2e       	mov	r11, r31
    e54e:	8b 2d       	mov	r24, r11
    e550:	84 60       	ori	r24, 0x04	; 4
    e552:	b8 2e       	mov	r11, r24
    e554:	f2 01       	movw	r30, r4
    e556:	d3 fc       	sbrc	r13, 3
    e558:	35 91       	lpm	r19, Z+
    e55a:	d3 fe       	sbrs	r13, 3
    e55c:	31 91       	ld	r19, Z+
    e55e:	2f 01       	movw	r4, r30
    e560:	33 23       	and	r19, r19
    e562:	09 f4       	brne	.+2      	; 0xe566 <vfscanf+0x118>
    e564:	95 c0       	rjmp	.+298    	; 0xe690 <vfscanf+0x242>
    e566:	63 2f       	mov	r22, r19
    e568:	70 e0       	ldi	r23, 0x00	; 0
    e56a:	89 ed       	ldi	r24, 0xD9	; 217
    e56c:	9f e4       	ldi	r25, 0x4F	; 79
    e56e:	39 83       	std	Y+1, r19	; 0x01
    e570:	0e 94 d1 6b 	call	0xd7a2	; 0xd7a2 <strchr_P>
    e574:	39 81       	ldd	r19, Y+1	; 0x01
    e576:	89 2b       	or	r24, r25
    e578:	09 f4       	brne	.+2      	; 0xe57c <vfscanf+0x12e>
    e57a:	8a c0       	rjmp	.+276    	; 0xe690 <vfscanf+0x242>
    e57c:	b0 fc       	sbrc	r11, 0
    e57e:	07 c0       	rjmp	.+14     	; 0xe58e <vfscanf+0x140>
    e580:	f7 01       	movw	r30, r14
    e582:	c0 80       	ld	r12, Z
    e584:	d1 80       	ldd	r13, Z+1	; 0x01
    e586:	c7 01       	movw	r24, r14
    e588:	02 96       	adiw	r24, 0x02	; 2
    e58a:	7c 01       	movw	r14, r24
    e58c:	02 c0       	rjmp	.+4      	; 0xe592 <vfscanf+0x144>
    e58e:	c1 2c       	mov	r12, r1
    e590:	d1 2c       	mov	r13, r1
    e592:	3e 36       	cpi	r19, 0x6E	; 110
    e594:	51 f4       	brne	.+20     	; 0xe5aa <vfscanf+0x15c>
    e596:	f8 01       	movw	r30, r16
    e598:	46 81       	ldd	r20, Z+6	; 0x06
    e59a:	57 81       	ldd	r21, Z+7	; 0x07
    e59c:	60 e0       	ldi	r22, 0x00	; 0
    e59e:	70 e0       	ldi	r23, 0x00	; 0
    e5a0:	2b 2d       	mov	r18, r11
    e5a2:	c6 01       	movw	r24, r12
    e5a4:	0e 94 8a 70 	call	0xe114	; 0xe114 <putval>
    e5a8:	6b cf       	rjmp	.-298    	; 0xe480 <vfscanf+0x32>
    e5aa:	33 36       	cpi	r19, 0x63	; 99
    e5ac:	a1 f4       	brne	.+40     	; 0xe5d6 <vfscanf+0x188>
    e5ae:	b1 fc       	sbrc	r11, 1
    e5b0:	02 c0       	rjmp	.+4      	; 0xe5b6 <vfscanf+0x168>
    e5b2:	77 24       	eor	r7, r7
    e5b4:	73 94       	inc	r7
    e5b6:	c8 01       	movw	r24, r16
    e5b8:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e5bc:	97 fd       	sbrc	r25, 7
    e5be:	66 c0       	rjmp	.+204    	; 0xe68c <vfscanf+0x23e>
    e5c0:	c1 14       	cp	r12, r1
    e5c2:	d1 04       	cpc	r13, r1
    e5c4:	29 f0       	breq	.+10     	; 0xe5d0 <vfscanf+0x182>
    e5c6:	f6 01       	movw	r30, r12
    e5c8:	80 83       	st	Z, r24
    e5ca:	c6 01       	movw	r24, r12
    e5cc:	01 96       	adiw	r24, 0x01	; 1
    e5ce:	6c 01       	movw	r12, r24
    e5d0:	7a 94       	dec	r7
    e5d2:	89 f7       	brne	.-30     	; 0xe5b6 <vfscanf+0x168>
    e5d4:	57 c0       	rjmp	.+174    	; 0xe684 <vfscanf+0x236>
    e5d6:	3b 35       	cpi	r19, 0x5B	; 91
    e5d8:	59 f4       	brne	.+22     	; 0xe5f0 <vfscanf+0x1a2>
    e5da:	92 01       	movw	r18, r4
    e5dc:	a6 01       	movw	r20, r12
    e5de:	67 2d       	mov	r22, r7
    e5e0:	c8 01       	movw	r24, r16
    e5e2:	0e 94 60 71 	call	0xe2c0	; 0xe2c0 <conv_brk>
    e5e6:	2c 01       	movw	r4, r24
    e5e8:	00 97       	sbiw	r24, 0x00	; 0
    e5ea:	09 f0       	breq	.+2      	; 0xe5ee <vfscanf+0x1a0>
    e5ec:	4b c0       	rjmp	.+150    	; 0xe684 <vfscanf+0x236>
    e5ee:	45 c0       	rjmp	.+138    	; 0xe67a <vfscanf+0x22c>
    e5f0:	c8 01       	movw	r24, r16
    e5f2:	39 83       	std	Y+1, r19	; 0x01
    e5f4:	0e 94 b6 70 	call	0xe16c	; 0xe16c <skip_spaces>
    e5f8:	39 81       	ldd	r19, Y+1	; 0x01
    e5fa:	97 fd       	sbrc	r25, 7
    e5fc:	47 c0       	rjmp	.+142    	; 0xe68c <vfscanf+0x23e>
    e5fe:	3f 36       	cpi	r19, 0x6F	; 111
    e600:	69 f1       	breq	.+90     	; 0xe65c <vfscanf+0x20e>
    e602:	28 f4       	brcc	.+10     	; 0xe60e <vfscanf+0x1c0>
    e604:	34 36       	cpi	r19, 0x64	; 100
    e606:	31 f1       	breq	.+76     	; 0xe654 <vfscanf+0x206>
    e608:	39 36       	cpi	r19, 0x69	; 105
    e60a:	79 f1       	breq	.+94     	; 0xe66a <vfscanf+0x21c>
    e60c:	2b c0       	rjmp	.+86     	; 0xe664 <vfscanf+0x216>
    e60e:	33 37       	cpi	r19, 0x73	; 115
    e610:	69 f0       	breq	.+26     	; 0xe62c <vfscanf+0x1de>
    e612:	35 37       	cpi	r19, 0x75	; 117
    e614:	f9 f0       	breq	.+62     	; 0xe654 <vfscanf+0x206>
    e616:	26 c0       	rjmp	.+76     	; 0xe664 <vfscanf+0x216>
    e618:	c1 14       	cp	r12, r1
    e61a:	d1 04       	cpc	r13, r1
    e61c:	29 f0       	breq	.+10     	; 0xe628 <vfscanf+0x1da>
    e61e:	f6 01       	movw	r30, r12
    e620:	80 82       	st	Z, r8
    e622:	c6 01       	movw	r24, r12
    e624:	01 96       	adiw	r24, 0x01	; 1
    e626:	6c 01       	movw	r12, r24
    e628:	7a 94       	dec	r7
    e62a:	71 f0       	breq	.+28     	; 0xe648 <vfscanf+0x1fa>
    e62c:	c8 01       	movw	r24, r16
    e62e:	0e 94 c4 73 	call	0xe788	; 0xe788 <fgetc>
    e632:	4c 01       	movw	r8, r24
    e634:	97 fd       	sbrc	r25, 7
    e636:	08 c0       	rjmp	.+16     	; 0xe648 <vfscanf+0x1fa>
    e638:	0e 94 a6 73 	call	0xe74c	; 0xe74c <isspace>
    e63c:	89 2b       	or	r24, r25
    e63e:	61 f3       	breq	.-40     	; 0xe618 <vfscanf+0x1ca>
    e640:	b8 01       	movw	r22, r16
    e642:	c4 01       	movw	r24, r8
    e644:	0e 94 34 74 	call	0xe868	; 0xe868 <ungetc>
    e648:	c1 14       	cp	r12, r1
    e64a:	d1 04       	cpc	r13, r1
    e64c:	d9 f0       	breq	.+54     	; 0xe684 <vfscanf+0x236>
    e64e:	f6 01       	movw	r30, r12
    e650:	10 82       	st	Z, r1
    e652:	18 c0       	rjmp	.+48     	; 0xe684 <vfscanf+0x236>
    e654:	fb 2d       	mov	r31, r11
    e656:	f0 62       	ori	r31, 0x20	; 32
    e658:	bf 2e       	mov	r11, r31
    e65a:	07 c0       	rjmp	.+14     	; 0xe66a <vfscanf+0x21c>
    e65c:	8b 2d       	mov	r24, r11
    e65e:	80 61       	ori	r24, 0x10	; 16
    e660:	b8 2e       	mov	r11, r24
    e662:	03 c0       	rjmp	.+6      	; 0xe66a <vfscanf+0x21c>
    e664:	9b 2d       	mov	r25, r11
    e666:	90 64       	ori	r25, 0x40	; 64
    e668:	b9 2e       	mov	r11, r25
    e66a:	2b 2d       	mov	r18, r11
    e66c:	a6 01       	movw	r20, r12
    e66e:	67 2d       	mov	r22, r7
    e670:	c8 01       	movw	r24, r16
    e672:	0e 94 cf 70 	call	0xe19e	; 0xe19e <conv_int>
    e676:	81 11       	cpse	r24, r1
    e678:	05 c0       	rjmp	.+10     	; 0xe684 <vfscanf+0x236>
    e67a:	f8 01       	movw	r30, r16
    e67c:	83 81       	ldd	r24, Z+3	; 0x03
    e67e:	80 73       	andi	r24, 0x30	; 48
    e680:	29 f4       	brne	.+10     	; 0xe68c <vfscanf+0x23e>
    e682:	06 c0       	rjmp	.+12     	; 0xe690 <vfscanf+0x242>
    e684:	b0 fc       	sbrc	r11, 0
    e686:	fc ce       	rjmp	.-520    	; 0xe480 <vfscanf+0x32>
    e688:	a3 94       	inc	r10
    e68a:	fa ce       	rjmp	.-524    	; 0xe480 <vfscanf+0x32>
    e68c:	aa 20       	and	r10, r10
    e68e:	19 f0       	breq	.+6      	; 0xe696 <vfscanf+0x248>
    e690:	8a 2d       	mov	r24, r10
    e692:	90 e0       	ldi	r25, 0x00	; 0
    e694:	02 c0       	rjmp	.+4      	; 0xe69a <vfscanf+0x24c>
    e696:	8f ef       	ldi	r24, 0xFF	; 255
    e698:	9f ef       	ldi	r25, 0xFF	; 255
    e69a:	0f 90       	pop	r0
    e69c:	df 91       	pop	r29
    e69e:	cf 91       	pop	r28
    e6a0:	1f 91       	pop	r17
    e6a2:	0f 91       	pop	r16
    e6a4:	ff 90       	pop	r15
    e6a6:	ef 90       	pop	r14
    e6a8:	df 90       	pop	r13
    e6aa:	cf 90       	pop	r12
    e6ac:	bf 90       	pop	r11
    e6ae:	af 90       	pop	r10
    e6b0:	9f 90       	pop	r9
    e6b2:	8f 90       	pop	r8
    e6b4:	7f 90       	pop	r7
    e6b6:	5f 90       	pop	r5
    e6b8:	4f 90       	pop	r4
    e6ba:	08 95       	ret

0000e6bc <__eerd_block_m128>:
    e6bc:	dc 01       	movw	r26, r24
    e6be:	cb 01       	movw	r24, r22

0000e6c0 <__eerd_blraw_m128>:
    e6c0:	fc 01       	movw	r30, r24
    e6c2:	e1 99       	sbic	0x1c, 1	; 28
    e6c4:	fe cf       	rjmp	.-4      	; 0xe6c2 <__eerd_blraw_m128+0x2>
    e6c6:	06 c0       	rjmp	.+12     	; 0xe6d4 <__eerd_blraw_m128+0x14>
    e6c8:	ff bb       	out	0x1f, r31	; 31
    e6ca:	ee bb       	out	0x1e, r30	; 30
    e6cc:	e0 9a       	sbi	0x1c, 0	; 28
    e6ce:	31 96       	adiw	r30, 0x01	; 1
    e6d0:	0d b2       	in	r0, 0x1d	; 29
    e6d2:	0d 92       	st	X+, r0
    e6d4:	41 50       	subi	r20, 0x01	; 1
    e6d6:	50 40       	sbci	r21, 0x00	; 0
    e6d8:	b8 f7       	brcc	.-18     	; 0xe6c8 <__eerd_blraw_m128+0x8>
    e6da:	08 95       	ret

0000e6dc <__eerd_byte_m128>:
    e6dc:	e1 99       	sbic	0x1c, 1	; 28
    e6de:	fe cf       	rjmp	.-4      	; 0xe6dc <__eerd_byte_m128>
    e6e0:	9f bb       	out	0x1f, r25	; 31
    e6e2:	8e bb       	out	0x1e, r24	; 30
    e6e4:	e0 9a       	sbi	0x1c, 0	; 28
    e6e6:	99 27       	eor	r25, r25
    e6e8:	8d b3       	in	r24, 0x1d	; 29
    e6ea:	08 95       	ret

0000e6ec <__eerd_dword_m128>:
    e6ec:	a6 e1       	ldi	r26, 0x16	; 22
    e6ee:	b0 e0       	ldi	r27, 0x00	; 0
    e6f0:	44 e0       	ldi	r20, 0x04	; 4
    e6f2:	50 e0       	ldi	r21, 0x00	; 0
    e6f4:	0c 94 60 73 	jmp	0xe6c0	; 0xe6c0 <__eerd_blraw_m128>

0000e6f8 <__eerd_word_m128>:
    e6f8:	a8 e1       	ldi	r26, 0x18	; 24
    e6fa:	b0 e0       	ldi	r27, 0x00	; 0
    e6fc:	42 e0       	ldi	r20, 0x02	; 2
    e6fe:	50 e0       	ldi	r21, 0x00	; 0
    e700:	0c 94 60 73 	jmp	0xe6c0	; 0xe6c0 <__eerd_blraw_m128>

0000e704 <__eewr_block_m128>:
    e704:	dc 01       	movw	r26, r24
    e706:	cb 01       	movw	r24, r22
    e708:	03 c0       	rjmp	.+6      	; 0xe710 <__eewr_block_m128+0xc>
    e70a:	2d 91       	ld	r18, X+
    e70c:	0e 94 8d 73 	call	0xe71a	; 0xe71a <__eewr_r18_m128>
    e710:	41 50       	subi	r20, 0x01	; 1
    e712:	50 40       	sbci	r21, 0x00	; 0
    e714:	d0 f7       	brcc	.-12     	; 0xe70a <__eewr_block_m128+0x6>
    e716:	08 95       	ret

0000e718 <__eewr_byte_m128>:
    e718:	26 2f       	mov	r18, r22

0000e71a <__eewr_r18_m128>:
    e71a:	e1 99       	sbic	0x1c, 1	; 28
    e71c:	fe cf       	rjmp	.-4      	; 0xe71a <__eewr_r18_m128>
    e71e:	9f bb       	out	0x1f, r25	; 31
    e720:	8e bb       	out	0x1e, r24	; 30
    e722:	2d bb       	out	0x1d, r18	; 29
    e724:	0f b6       	in	r0, 0x3f	; 63
    e726:	f8 94       	cli
    e728:	e2 9a       	sbi	0x1c, 2	; 28
    e72a:	e1 9a       	sbi	0x1c, 1	; 28
    e72c:	0f be       	out	0x3f, r0	; 63
    e72e:	01 96       	adiw	r24, 0x01	; 1
    e730:	08 95       	ret

0000e732 <__eewr_dword_m128>:
    e732:	24 2f       	mov	r18, r20
    e734:	0e 94 8d 73 	call	0xe71a	; 0xe71a <__eewr_r18_m128>
    e738:	25 2f       	mov	r18, r21
    e73a:	0e 94 8d 73 	call	0xe71a	; 0xe71a <__eewr_r18_m128>
    e73e:	0c 94 a1 73 	jmp	0xe742	; 0xe742 <__eewr_word_m128>

0000e742 <__eewr_word_m128>:
    e742:	0e 94 8c 73 	call	0xe718	; 0xe718 <__eewr_byte_m128>
    e746:	27 2f       	mov	r18, r23
    e748:	0c 94 8d 73 	jmp	0xe71a	; 0xe71a <__eewr_r18_m128>

0000e74c <isspace>:
    e74c:	91 11       	cpse	r25, r1
    e74e:	03 c1       	rjmp	.+518    	; 0xe956 <__ctype_isfalse>
    e750:	80 32       	cpi	r24, 0x20	; 32
    e752:	19 f0       	breq	.+6      	; 0xe75a <isspace+0xe>
    e754:	89 50       	subi	r24, 0x09	; 9
    e756:	85 50       	subi	r24, 0x05	; 5
    e758:	d0 f7       	brcc	.-12     	; 0xe74e <isspace+0x2>
    e75a:	08 95       	ret

0000e75c <strnlen_P>:
    e75c:	fc 01       	movw	r30, r24
    e75e:	05 90       	lpm	r0, Z+
    e760:	61 50       	subi	r22, 0x01	; 1
    e762:	70 40       	sbci	r23, 0x00	; 0
    e764:	01 10       	cpse	r0, r1
    e766:	d8 f7       	brcc	.-10     	; 0xe75e <strnlen_P+0x2>
    e768:	80 95       	com	r24
    e76a:	90 95       	com	r25
    e76c:	8e 0f       	add	r24, r30
    e76e:	9f 1f       	adc	r25, r31
    e770:	08 95       	ret

0000e772 <strnlen>:
    e772:	fc 01       	movw	r30, r24
    e774:	61 50       	subi	r22, 0x01	; 1
    e776:	70 40       	sbci	r23, 0x00	; 0
    e778:	01 90       	ld	r0, Z+
    e77a:	01 10       	cpse	r0, r1
    e77c:	d8 f7       	brcc	.-10     	; 0xe774 <strnlen+0x2>
    e77e:	80 95       	com	r24
    e780:	90 95       	com	r25
    e782:	8e 0f       	add	r24, r30
    e784:	9f 1f       	adc	r25, r31
    e786:	08 95       	ret

0000e788 <fgetc>:
    e788:	cf 93       	push	r28
    e78a:	df 93       	push	r29
    e78c:	ec 01       	movw	r28, r24
    e78e:	2b 81       	ldd	r18, Y+3	; 0x03
    e790:	20 ff       	sbrs	r18, 0
    e792:	33 c0       	rjmp	.+102    	; 0xe7fa <fgetc+0x72>
    e794:	26 ff       	sbrs	r18, 6
    e796:	0a c0       	rjmp	.+20     	; 0xe7ac <fgetc+0x24>
    e798:	2f 7b       	andi	r18, 0xBF	; 191
    e79a:	2b 83       	std	Y+3, r18	; 0x03
    e79c:	8e 81       	ldd	r24, Y+6	; 0x06
    e79e:	9f 81       	ldd	r25, Y+7	; 0x07
    e7a0:	01 96       	adiw	r24, 0x01	; 1
    e7a2:	9f 83       	std	Y+7, r25	; 0x07
    e7a4:	8e 83       	std	Y+6, r24	; 0x06
    e7a6:	8a 81       	ldd	r24, Y+2	; 0x02
    e7a8:	90 e0       	ldi	r25, 0x00	; 0
    e7aa:	29 c0       	rjmp	.+82     	; 0xe7fe <fgetc+0x76>
    e7ac:	22 ff       	sbrs	r18, 2
    e7ae:	0f c0       	rjmp	.+30     	; 0xe7ce <fgetc+0x46>
    e7b0:	e8 81       	ld	r30, Y
    e7b2:	f9 81       	ldd	r31, Y+1	; 0x01
    e7b4:	80 81       	ld	r24, Z
    e7b6:	99 27       	eor	r25, r25
    e7b8:	87 fd       	sbrc	r24, 7
    e7ba:	90 95       	com	r25
    e7bc:	00 97       	sbiw	r24, 0x00	; 0
    e7be:	19 f4       	brne	.+6      	; 0xe7c6 <fgetc+0x3e>
    e7c0:	20 62       	ori	r18, 0x20	; 32
    e7c2:	2b 83       	std	Y+3, r18	; 0x03
    e7c4:	1a c0       	rjmp	.+52     	; 0xe7fa <fgetc+0x72>
    e7c6:	31 96       	adiw	r30, 0x01	; 1
    e7c8:	f9 83       	std	Y+1, r31	; 0x01
    e7ca:	e8 83       	st	Y, r30
    e7cc:	0e c0       	rjmp	.+28     	; 0xe7ea <fgetc+0x62>
    e7ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    e7d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    e7d2:	09 95       	icall
    e7d4:	97 ff       	sbrs	r25, 7
    e7d6:	09 c0       	rjmp	.+18     	; 0xe7ea <fgetc+0x62>
    e7d8:	2b 81       	ldd	r18, Y+3	; 0x03
    e7da:	01 96       	adiw	r24, 0x01	; 1
    e7dc:	11 f4       	brne	.+4      	; 0xe7e2 <fgetc+0x5a>
    e7de:	80 e1       	ldi	r24, 0x10	; 16
    e7e0:	01 c0       	rjmp	.+2      	; 0xe7e4 <fgetc+0x5c>
    e7e2:	80 e2       	ldi	r24, 0x20	; 32
    e7e4:	82 2b       	or	r24, r18
    e7e6:	8b 83       	std	Y+3, r24	; 0x03
    e7e8:	08 c0       	rjmp	.+16     	; 0xe7fa <fgetc+0x72>
    e7ea:	2e 81       	ldd	r18, Y+6	; 0x06
    e7ec:	3f 81       	ldd	r19, Y+7	; 0x07
    e7ee:	2f 5f       	subi	r18, 0xFF	; 255
    e7f0:	3f 4f       	sbci	r19, 0xFF	; 255
    e7f2:	3f 83       	std	Y+7, r19	; 0x07
    e7f4:	2e 83       	std	Y+6, r18	; 0x06
    e7f6:	99 27       	eor	r25, r25
    e7f8:	02 c0       	rjmp	.+4      	; 0xe7fe <fgetc+0x76>
    e7fa:	8f ef       	ldi	r24, 0xFF	; 255
    e7fc:	9f ef       	ldi	r25, 0xFF	; 255
    e7fe:	df 91       	pop	r29
    e800:	cf 91       	pop	r28
    e802:	08 95       	ret

0000e804 <fputc>:
    e804:	0f 93       	push	r16
    e806:	1f 93       	push	r17
    e808:	cf 93       	push	r28
    e80a:	df 93       	push	r29
    e80c:	18 2f       	mov	r17, r24
    e80e:	09 2f       	mov	r16, r25
    e810:	eb 01       	movw	r28, r22
    e812:	8b 81       	ldd	r24, Y+3	; 0x03
    e814:	81 fd       	sbrc	r24, 1
    e816:	03 c0       	rjmp	.+6      	; 0xe81e <fputc+0x1a>
    e818:	8f ef       	ldi	r24, 0xFF	; 255
    e81a:	9f ef       	ldi	r25, 0xFF	; 255
    e81c:	20 c0       	rjmp	.+64     	; 0xe85e <fputc+0x5a>
    e81e:	82 ff       	sbrs	r24, 2
    e820:	10 c0       	rjmp	.+32     	; 0xe842 <fputc+0x3e>
    e822:	4e 81       	ldd	r20, Y+6	; 0x06
    e824:	5f 81       	ldd	r21, Y+7	; 0x07
    e826:	2c 81       	ldd	r18, Y+4	; 0x04
    e828:	3d 81       	ldd	r19, Y+5	; 0x05
    e82a:	42 17       	cp	r20, r18
    e82c:	53 07       	cpc	r21, r19
    e82e:	7c f4       	brge	.+30     	; 0xe84e <fputc+0x4a>
    e830:	e8 81       	ld	r30, Y
    e832:	f9 81       	ldd	r31, Y+1	; 0x01
    e834:	9f 01       	movw	r18, r30
    e836:	2f 5f       	subi	r18, 0xFF	; 255
    e838:	3f 4f       	sbci	r19, 0xFF	; 255
    e83a:	39 83       	std	Y+1, r19	; 0x01
    e83c:	28 83       	st	Y, r18
    e83e:	10 83       	st	Z, r17
    e840:	06 c0       	rjmp	.+12     	; 0xe84e <fputc+0x4a>
    e842:	e8 85       	ldd	r30, Y+8	; 0x08
    e844:	f9 85       	ldd	r31, Y+9	; 0x09
    e846:	81 2f       	mov	r24, r17
    e848:	09 95       	icall
    e84a:	89 2b       	or	r24, r25
    e84c:	29 f7       	brne	.-54     	; 0xe818 <fputc+0x14>
    e84e:	2e 81       	ldd	r18, Y+6	; 0x06
    e850:	3f 81       	ldd	r19, Y+7	; 0x07
    e852:	2f 5f       	subi	r18, 0xFF	; 255
    e854:	3f 4f       	sbci	r19, 0xFF	; 255
    e856:	3f 83       	std	Y+7, r19	; 0x07
    e858:	2e 83       	std	Y+6, r18	; 0x06
    e85a:	81 2f       	mov	r24, r17
    e85c:	90 2f       	mov	r25, r16
    e85e:	df 91       	pop	r29
    e860:	cf 91       	pop	r28
    e862:	1f 91       	pop	r17
    e864:	0f 91       	pop	r16
    e866:	08 95       	ret

0000e868 <ungetc>:
    e868:	fb 01       	movw	r30, r22
    e86a:	23 81       	ldd	r18, Z+3	; 0x03
    e86c:	20 ff       	sbrs	r18, 0
    e86e:	12 c0       	rjmp	.+36     	; 0xe894 <ungetc+0x2c>
    e870:	26 fd       	sbrc	r18, 6
    e872:	10 c0       	rjmp	.+32     	; 0xe894 <ungetc+0x2c>
    e874:	8f 3f       	cpi	r24, 0xFF	; 255
    e876:	3f ef       	ldi	r19, 0xFF	; 255
    e878:	93 07       	cpc	r25, r19
    e87a:	61 f0       	breq	.+24     	; 0xe894 <ungetc+0x2c>
    e87c:	82 83       	std	Z+2, r24	; 0x02
    e87e:	2f 7d       	andi	r18, 0xDF	; 223
    e880:	20 64       	ori	r18, 0x40	; 64
    e882:	23 83       	std	Z+3, r18	; 0x03
    e884:	26 81       	ldd	r18, Z+6	; 0x06
    e886:	37 81       	ldd	r19, Z+7	; 0x07
    e888:	21 50       	subi	r18, 0x01	; 1
    e88a:	31 09       	sbc	r19, r1
    e88c:	37 83       	std	Z+7, r19	; 0x07
    e88e:	26 83       	std	Z+6, r18	; 0x06
    e890:	99 27       	eor	r25, r25
    e892:	08 95       	ret
    e894:	8f ef       	ldi	r24, 0xFF	; 255
    e896:	9f ef       	ldi	r25, 0xFF	; 255
    e898:	08 95       	ret

0000e89a <__ultoa_invert>:
    e89a:	fa 01       	movw	r30, r20
    e89c:	aa 27       	eor	r26, r26
    e89e:	28 30       	cpi	r18, 0x08	; 8
    e8a0:	51 f1       	breq	.+84     	; 0xe8f6 <__ultoa_invert+0x5c>
    e8a2:	20 31       	cpi	r18, 0x10	; 16
    e8a4:	81 f1       	breq	.+96     	; 0xe906 <__ultoa_invert+0x6c>
    e8a6:	e8 94       	clt
    e8a8:	6f 93       	push	r22
    e8aa:	6e 7f       	andi	r22, 0xFE	; 254
    e8ac:	6e 5f       	subi	r22, 0xFE	; 254
    e8ae:	7f 4f       	sbci	r23, 0xFF	; 255
    e8b0:	8f 4f       	sbci	r24, 0xFF	; 255
    e8b2:	9f 4f       	sbci	r25, 0xFF	; 255
    e8b4:	af 4f       	sbci	r26, 0xFF	; 255
    e8b6:	b1 e0       	ldi	r27, 0x01	; 1
    e8b8:	3e d0       	rcall	.+124    	; 0xe936 <__ultoa_invert+0x9c>
    e8ba:	b4 e0       	ldi	r27, 0x04	; 4
    e8bc:	3c d0       	rcall	.+120    	; 0xe936 <__ultoa_invert+0x9c>
    e8be:	67 0f       	add	r22, r23
    e8c0:	78 1f       	adc	r23, r24
    e8c2:	89 1f       	adc	r24, r25
    e8c4:	9a 1f       	adc	r25, r26
    e8c6:	a1 1d       	adc	r26, r1
    e8c8:	68 0f       	add	r22, r24
    e8ca:	79 1f       	adc	r23, r25
    e8cc:	8a 1f       	adc	r24, r26
    e8ce:	91 1d       	adc	r25, r1
    e8d0:	a1 1d       	adc	r26, r1
    e8d2:	6a 0f       	add	r22, r26
    e8d4:	71 1d       	adc	r23, r1
    e8d6:	81 1d       	adc	r24, r1
    e8d8:	91 1d       	adc	r25, r1
    e8da:	a1 1d       	adc	r26, r1
    e8dc:	20 d0       	rcall	.+64     	; 0xe91e <__ultoa_invert+0x84>
    e8de:	09 f4       	brne	.+2      	; 0xe8e2 <__ultoa_invert+0x48>
    e8e0:	68 94       	set
    e8e2:	3f 91       	pop	r19
    e8e4:	2a e0       	ldi	r18, 0x0A	; 10
    e8e6:	26 9f       	mul	r18, r22
    e8e8:	11 24       	eor	r1, r1
    e8ea:	30 19       	sub	r19, r0
    e8ec:	30 5d       	subi	r19, 0xD0	; 208
    e8ee:	31 93       	st	Z+, r19
    e8f0:	de f6       	brtc	.-74     	; 0xe8a8 <__ultoa_invert+0xe>
    e8f2:	cf 01       	movw	r24, r30
    e8f4:	08 95       	ret
    e8f6:	46 2f       	mov	r20, r22
    e8f8:	47 70       	andi	r20, 0x07	; 7
    e8fa:	40 5d       	subi	r20, 0xD0	; 208
    e8fc:	41 93       	st	Z+, r20
    e8fe:	b3 e0       	ldi	r27, 0x03	; 3
    e900:	0f d0       	rcall	.+30     	; 0xe920 <__ultoa_invert+0x86>
    e902:	c9 f7       	brne	.-14     	; 0xe8f6 <__ultoa_invert+0x5c>
    e904:	f6 cf       	rjmp	.-20     	; 0xe8f2 <__ultoa_invert+0x58>
    e906:	46 2f       	mov	r20, r22
    e908:	4f 70       	andi	r20, 0x0F	; 15
    e90a:	40 5d       	subi	r20, 0xD0	; 208
    e90c:	4a 33       	cpi	r20, 0x3A	; 58
    e90e:	18 f0       	brcs	.+6      	; 0xe916 <__ultoa_invert+0x7c>
    e910:	49 5d       	subi	r20, 0xD9	; 217
    e912:	31 fd       	sbrc	r19, 1
    e914:	40 52       	subi	r20, 0x20	; 32
    e916:	41 93       	st	Z+, r20
    e918:	02 d0       	rcall	.+4      	; 0xe91e <__ultoa_invert+0x84>
    e91a:	a9 f7       	brne	.-22     	; 0xe906 <__ultoa_invert+0x6c>
    e91c:	ea cf       	rjmp	.-44     	; 0xe8f2 <__ultoa_invert+0x58>
    e91e:	b4 e0       	ldi	r27, 0x04	; 4
    e920:	a6 95       	lsr	r26
    e922:	97 95       	ror	r25
    e924:	87 95       	ror	r24
    e926:	77 95       	ror	r23
    e928:	67 95       	ror	r22
    e92a:	ba 95       	dec	r27
    e92c:	c9 f7       	brne	.-14     	; 0xe920 <__ultoa_invert+0x86>
    e92e:	00 97       	sbiw	r24, 0x00	; 0
    e930:	61 05       	cpc	r22, r1
    e932:	71 05       	cpc	r23, r1
    e934:	08 95       	ret
    e936:	9b 01       	movw	r18, r22
    e938:	ac 01       	movw	r20, r24
    e93a:	0a 2e       	mov	r0, r26
    e93c:	06 94       	lsr	r0
    e93e:	57 95       	ror	r21
    e940:	47 95       	ror	r20
    e942:	37 95       	ror	r19
    e944:	27 95       	ror	r18
    e946:	ba 95       	dec	r27
    e948:	c9 f7       	brne	.-14     	; 0xe93c <__ultoa_invert+0xa2>
    e94a:	62 0f       	add	r22, r18
    e94c:	73 1f       	adc	r23, r19
    e94e:	84 1f       	adc	r24, r20
    e950:	95 1f       	adc	r25, r21
    e952:	a0 1d       	adc	r26, r0
    e954:	08 95       	ret

0000e956 <__ctype_isfalse>:
    e956:	99 27       	eor	r25, r25
    e958:	88 27       	eor	r24, r24

0000e95a <__ctype_istrue>:
    e95a:	08 95       	ret

0000e95c <__udivmodqi4>:
    e95c:	99 1b       	sub	r25, r25
    e95e:	79 e0       	ldi	r23, 0x09	; 9
    e960:	04 c0       	rjmp	.+8      	; 0xe96a <__udivmodqi4_ep>

0000e962 <__udivmodqi4_loop>:
    e962:	99 1f       	adc	r25, r25
    e964:	96 17       	cp	r25, r22
    e966:	08 f0       	brcs	.+2      	; 0xe96a <__udivmodqi4_ep>
    e968:	96 1b       	sub	r25, r22

0000e96a <__udivmodqi4_ep>:
    e96a:	88 1f       	adc	r24, r24
    e96c:	7a 95       	dec	r23
    e96e:	c9 f7       	brne	.-14     	; 0xe962 <__udivmodqi4_loop>
    e970:	80 95       	com	r24
    e972:	08 95       	ret

0000e974 <__udivmodhi4>:
    e974:	aa 1b       	sub	r26, r26
    e976:	bb 1b       	sub	r27, r27
    e978:	51 e1       	ldi	r21, 0x11	; 17
    e97a:	07 c0       	rjmp	.+14     	; 0xe98a <__udivmodhi4_ep>

0000e97c <__udivmodhi4_loop>:
    e97c:	aa 1f       	adc	r26, r26
    e97e:	bb 1f       	adc	r27, r27
    e980:	a6 17       	cp	r26, r22
    e982:	b7 07       	cpc	r27, r23
    e984:	10 f0       	brcs	.+4      	; 0xe98a <__udivmodhi4_ep>
    e986:	a6 1b       	sub	r26, r22
    e988:	b7 0b       	sbc	r27, r23

0000e98a <__udivmodhi4_ep>:
    e98a:	88 1f       	adc	r24, r24
    e98c:	99 1f       	adc	r25, r25
    e98e:	5a 95       	dec	r21
    e990:	a9 f7       	brne	.-22     	; 0xe97c <__udivmodhi4_loop>
    e992:	80 95       	com	r24
    e994:	90 95       	com	r25
    e996:	bc 01       	movw	r22, r24
    e998:	cd 01       	movw	r24, r26
    e99a:	08 95       	ret

0000e99c <__divmodhi4>:
    e99c:	97 fb       	bst	r25, 7
    e99e:	07 2e       	mov	r0, r23
    e9a0:	16 f4       	brtc	.+4      	; 0xe9a6 <__divmodhi4+0xa>
    e9a2:	00 94       	com	r0
    e9a4:	07 d0       	rcall	.+14     	; 0xe9b4 <__divmodhi4_neg1>
    e9a6:	77 fd       	sbrc	r23, 7
    e9a8:	09 d0       	rcall	.+18     	; 0xe9bc <__divmodhi4_neg2>
    e9aa:	0e 94 ba 74 	call	0xe974	; 0xe974 <__udivmodhi4>
    e9ae:	07 fc       	sbrc	r0, 7
    e9b0:	05 d0       	rcall	.+10     	; 0xe9bc <__divmodhi4_neg2>
    e9b2:	3e f4       	brtc	.+14     	; 0xe9c2 <__divmodhi4_exit>

0000e9b4 <__divmodhi4_neg1>:
    e9b4:	90 95       	com	r25
    e9b6:	81 95       	neg	r24
    e9b8:	9f 4f       	sbci	r25, 0xFF	; 255
    e9ba:	08 95       	ret

0000e9bc <__divmodhi4_neg2>:
    e9bc:	70 95       	com	r23
    e9be:	61 95       	neg	r22
    e9c0:	7f 4f       	sbci	r23, 0xFF	; 255

0000e9c2 <__divmodhi4_exit>:
    e9c2:	08 95       	ret

0000e9c4 <__udivmodsi4>:
    e9c4:	a1 e2       	ldi	r26, 0x21	; 33
    e9c6:	1a 2e       	mov	r1, r26
    e9c8:	aa 1b       	sub	r26, r26
    e9ca:	bb 1b       	sub	r27, r27
    e9cc:	fd 01       	movw	r30, r26
    e9ce:	0d c0       	rjmp	.+26     	; 0xe9ea <__udivmodsi4_ep>

0000e9d0 <__udivmodsi4_loop>:
    e9d0:	aa 1f       	adc	r26, r26
    e9d2:	bb 1f       	adc	r27, r27
    e9d4:	ee 1f       	adc	r30, r30
    e9d6:	ff 1f       	adc	r31, r31
    e9d8:	a2 17       	cp	r26, r18
    e9da:	b3 07       	cpc	r27, r19
    e9dc:	e4 07       	cpc	r30, r20
    e9de:	f5 07       	cpc	r31, r21
    e9e0:	20 f0       	brcs	.+8      	; 0xe9ea <__udivmodsi4_ep>
    e9e2:	a2 1b       	sub	r26, r18
    e9e4:	b3 0b       	sbc	r27, r19
    e9e6:	e4 0b       	sbc	r30, r20
    e9e8:	f5 0b       	sbc	r31, r21

0000e9ea <__udivmodsi4_ep>:
    e9ea:	66 1f       	adc	r22, r22
    e9ec:	77 1f       	adc	r23, r23
    e9ee:	88 1f       	adc	r24, r24
    e9f0:	99 1f       	adc	r25, r25
    e9f2:	1a 94       	dec	r1
    e9f4:	69 f7       	brne	.-38     	; 0xe9d0 <__udivmodsi4_loop>
    e9f6:	60 95       	com	r22
    e9f8:	70 95       	com	r23
    e9fa:	80 95       	com	r24
    e9fc:	90 95       	com	r25
    e9fe:	9b 01       	movw	r18, r22
    ea00:	ac 01       	movw	r20, r24
    ea02:	bd 01       	movw	r22, r26
    ea04:	cf 01       	movw	r24, r30
    ea06:	08 95       	ret

0000ea08 <__divmodsi4>:
    ea08:	05 2e       	mov	r0, r21
    ea0a:	97 fb       	bst	r25, 7
    ea0c:	1e f4       	brtc	.+6      	; 0xea14 <__divmodsi4+0xc>
    ea0e:	00 94       	com	r0
    ea10:	0e 94 1b 75 	call	0xea36	; 0xea36 <__negsi2>
    ea14:	57 fd       	sbrc	r21, 7
    ea16:	07 d0       	rcall	.+14     	; 0xea26 <__divmodsi4_neg2>
    ea18:	0e 94 e2 74 	call	0xe9c4	; 0xe9c4 <__udivmodsi4>
    ea1c:	07 fc       	sbrc	r0, 7
    ea1e:	03 d0       	rcall	.+6      	; 0xea26 <__divmodsi4_neg2>
    ea20:	4e f4       	brtc	.+18     	; 0xea34 <__divmodsi4_exit>
    ea22:	0c 94 1b 75 	jmp	0xea36	; 0xea36 <__negsi2>

0000ea26 <__divmodsi4_neg2>:
    ea26:	50 95       	com	r21
    ea28:	40 95       	com	r20
    ea2a:	30 95       	com	r19
    ea2c:	21 95       	neg	r18
    ea2e:	3f 4f       	sbci	r19, 0xFF	; 255
    ea30:	4f 4f       	sbci	r20, 0xFF	; 255
    ea32:	5f 4f       	sbci	r21, 0xFF	; 255

0000ea34 <__divmodsi4_exit>:
    ea34:	08 95       	ret

0000ea36 <__negsi2>:
    ea36:	90 95       	com	r25
    ea38:	80 95       	com	r24
    ea3a:	70 95       	com	r23
    ea3c:	61 95       	neg	r22
    ea3e:	7f 4f       	sbci	r23, 0xFF	; 255
    ea40:	8f 4f       	sbci	r24, 0xFF	; 255
    ea42:	9f 4f       	sbci	r25, 0xFF	; 255
    ea44:	08 95       	ret

0000ea46 <__tablejump2__>:
    ea46:	ee 0f       	add	r30, r30
    ea48:	ff 1f       	adc	r31, r31

0000ea4a <__tablejump__>:
    ea4a:	05 90       	lpm	r0, Z+
    ea4c:	f4 91       	lpm	r31, Z
    ea4e:	e0 2d       	mov	r30, r0
    ea50:	09 94       	ijmp

0000ea52 <__muluhisi3>:
    ea52:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    ea56:	a5 9f       	mul	r26, r21
    ea58:	90 0d       	add	r25, r0
    ea5a:	b4 9f       	mul	r27, r20
    ea5c:	90 0d       	add	r25, r0
    ea5e:	a4 9f       	mul	r26, r20
    ea60:	80 0d       	add	r24, r0
    ea62:	91 1d       	adc	r25, r1
    ea64:	11 24       	eor	r1, r1
    ea66:	08 95       	ret

0000ea68 <__mulshisi3>:
    ea68:	b7 ff       	sbrs	r27, 7
    ea6a:	0c 94 29 75 	jmp	0xea52	; 0xea52 <__muluhisi3>

0000ea6e <__mulohisi3>:
    ea6e:	0e 94 29 75 	call	0xea52	; 0xea52 <__muluhisi3>
    ea72:	82 1b       	sub	r24, r18
    ea74:	93 0b       	sbc	r25, r19
    ea76:	08 95       	ret

0000ea78 <__muldi3>:
    ea78:	df 93       	push	r29
    ea7a:	cf 93       	push	r28
    ea7c:	1f 93       	push	r17
    ea7e:	0f 93       	push	r16
    ea80:	9a 9d       	mul	r25, r10
    ea82:	f0 2d       	mov	r31, r0
    ea84:	21 9f       	mul	r18, r17
    ea86:	f0 0d       	add	r31, r0
    ea88:	8b 9d       	mul	r24, r11
    ea8a:	f0 0d       	add	r31, r0
    ea8c:	8a 9d       	mul	r24, r10
    ea8e:	e0 2d       	mov	r30, r0
    ea90:	f1 0d       	add	r31, r1
    ea92:	03 9f       	mul	r16, r19
    ea94:	f0 0d       	add	r31, r0
    ea96:	02 9f       	mul	r16, r18
    ea98:	e0 0d       	add	r30, r0
    ea9a:	f1 1d       	adc	r31, r1
    ea9c:	4e 9d       	mul	r20, r14
    ea9e:	e0 0d       	add	r30, r0
    eaa0:	f1 1d       	adc	r31, r1
    eaa2:	5e 9d       	mul	r21, r14
    eaa4:	f0 0d       	add	r31, r0
    eaa6:	4f 9d       	mul	r20, r15
    eaa8:	f0 0d       	add	r31, r0
    eaaa:	7f 93       	push	r23
    eaac:	6f 93       	push	r22
    eaae:	bf 92       	push	r11
    eab0:	af 92       	push	r10
    eab2:	5f 93       	push	r21
    eab4:	4f 93       	push	r20
    eab6:	d5 01       	movw	r26, r10
    eab8:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eabc:	8b 01       	movw	r16, r22
    eabe:	ac 01       	movw	r20, r24
    eac0:	d7 01       	movw	r26, r14
    eac2:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eac6:	eb 01       	movw	r28, r22
    eac8:	e8 0f       	add	r30, r24
    eaca:	f9 1f       	adc	r31, r25
    eacc:	d6 01       	movw	r26, r12
    eace:	0e 94 8c 75 	call	0xeb18	; 0xeb18 <__muldi3_6>
    ead2:	2f 91       	pop	r18
    ead4:	3f 91       	pop	r19
    ead6:	d6 01       	movw	r26, r12
    ead8:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eadc:	c6 0f       	add	r28, r22
    eade:	d7 1f       	adc	r29, r23
    eae0:	e8 1f       	adc	r30, r24
    eae2:	f9 1f       	adc	r31, r25
    eae4:	af 91       	pop	r26
    eae6:	bf 91       	pop	r27
    eae8:	0e 94 8c 75 	call	0xeb18	; 0xeb18 <__muldi3_6>
    eaec:	2f 91       	pop	r18
    eaee:	3f 91       	pop	r19
    eaf0:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eaf4:	c6 0f       	add	r28, r22
    eaf6:	d7 1f       	adc	r29, r23
    eaf8:	e8 1f       	adc	r30, r24
    eafa:	f9 1f       	adc	r31, r25
    eafc:	d6 01       	movw	r26, r12
    eafe:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eb02:	e6 0f       	add	r30, r22
    eb04:	f7 1f       	adc	r31, r23
    eb06:	98 01       	movw	r18, r16
    eb08:	be 01       	movw	r22, r28
    eb0a:	cf 01       	movw	r24, r30
    eb0c:	11 24       	eor	r1, r1
    eb0e:	0f 91       	pop	r16
    eb10:	1f 91       	pop	r17
    eb12:	cf 91       	pop	r28
    eb14:	df 91       	pop	r29
    eb16:	08 95       	ret

0000eb18 <__muldi3_6>:
    eb18:	0e 94 9e 75 	call	0xeb3c	; 0xeb3c <__umulhisi3>
    eb1c:	46 0f       	add	r20, r22
    eb1e:	57 1f       	adc	r21, r23
    eb20:	c8 1f       	adc	r28, r24
    eb22:	d9 1f       	adc	r29, r25
    eb24:	08 f4       	brcc	.+2      	; 0xeb28 <__muldi3_6+0x10>
    eb26:	31 96       	adiw	r30, 0x01	; 1
    eb28:	08 95       	ret

0000eb2a <__adddi3>:
    eb2a:	2a 0d       	add	r18, r10
    eb2c:	3b 1d       	adc	r19, r11
    eb2e:	4c 1d       	adc	r20, r12
    eb30:	5d 1d       	adc	r21, r13
    eb32:	6e 1d       	adc	r22, r14
    eb34:	7f 1d       	adc	r23, r15
    eb36:	80 1f       	adc	r24, r16
    eb38:	91 1f       	adc	r25, r17
    eb3a:	08 95       	ret

0000eb3c <__umulhisi3>:
    eb3c:	a2 9f       	mul	r26, r18
    eb3e:	b0 01       	movw	r22, r0
    eb40:	b3 9f       	mul	r27, r19
    eb42:	c0 01       	movw	r24, r0
    eb44:	a3 9f       	mul	r26, r19
    eb46:	70 0d       	add	r23, r0
    eb48:	81 1d       	adc	r24, r1
    eb4a:	11 24       	eor	r1, r1
    eb4c:	91 1d       	adc	r25, r1
    eb4e:	b2 9f       	mul	r27, r18
    eb50:	70 0d       	add	r23, r0
    eb52:	81 1d       	adc	r24, r1
    eb54:	11 24       	eor	r1, r1
    eb56:	91 1d       	adc	r25, r1
    eb58:	08 95       	ret

0000eb5a <_exit>:
    eb5a:	f8 94       	cli

0000eb5c <__stop_program>:
    eb5c:	ff cf       	rjmp	.-2      	; 0xeb5c <__stop_program>
