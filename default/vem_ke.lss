
vem_ke.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000013a  00800100  0000ea70  0000eb24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000ea70  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c12  0080023a  0080023a  0000ec5e  2**0
                  ALLOC
  3 .eeprom       000001ae  00810000  00810000  0000ec5e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  0000ee0c  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000009d8  00000000  00000000  0000ee68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014bcf  00000000  00000000  0000f840  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009c8  00000000  00000000  0002440f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e8c  00000000  00000000  00024dd7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000024c0  00000000  00000000  00028c64  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000424c  00000000  00000000  0002b124  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000100a3  00000000  00000000  0002f370  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d28  00000000  00000000  0003f413  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 f2 27 	jmp	0x4fe4	; 0x4fe4 <__ctors_end>
       4:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
       8:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
       c:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      10:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      14:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      18:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      1c:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      20:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      24:	0c 94 0d 2f 	jmp	0x5e1a	; 0x5e1a <__vector_9>
      28:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      2c:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      30:	0c 94 31 2d 	jmp	0x5a62	; 0x5a62 <__vector_12>
      34:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      38:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      3c:	0c 94 dd 2e 	jmp	0x5dba	; 0x5dba <__vector_15>
      40:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      44:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      48:	0c 94 83 57 	jmp	0xaf06	; 0xaf06 <__vector_18>
      4c:	0c 94 7a 69 	jmp	0xd2f4	; 0xd2f4 <__vector_19>
      50:	0c 94 7a 3b 	jmp	0x76f4	; 0x76f4 <__vector_20>
      54:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      58:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      5c:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      60:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      64:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      68:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      6c:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      70:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      74:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      78:	0c 94 64 4c 	jmp	0x98c8	; 0x98c8 <__vector_30>
      7c:	0c 94 43 6a 	jmp	0xd486	; 0xd486 <__vector_31>
      80:	0c 94 a7 4c 	jmp	0x994e	; 0x994e <__vector_32>
      84:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      88:	0c 94 11 28 	jmp	0x5022	; 0x5022 <__bad_interrupt>
      8c:	d0 32       	cpi	r29, 0x20	; 32
      8e:	d0 32       	cpi	r29, 0x20	; 32
      90:	5c 33       	cpi	r21, 0x3C	; 60
      92:	5c 33       	cpi	r21, 0x3C	; 60
      94:	b8 34       	cpi	r27, 0x48	; 72
      96:	b7 33       	cpi	r27, 0x37	; 55
      98:	b8 34       	cpi	r27, 0x48	; 72
      9a:	b8 34       	cpi	r27, 0x48	; 72
      9c:	b8 34       	cpi	r27, 0x48	; 72
      9e:	b8 34       	cpi	r27, 0x48	; 72
      a0:	b8 34       	cpi	r27, 0x48	; 72
      a2:	b8 34       	cpi	r27, 0x48	; 72
      a4:	b8 34       	cpi	r27, 0x48	; 72
      a6:	b8 34       	cpi	r27, 0x48	; 72
      a8:	e6 33       	cpi	r30, 0x36	; 54
      aa:	5f 34       	cpi	r21, 0x4F	; 79
      ac:	55 36       	cpi	r21, 0x65	; 101
      ae:	55 36       	cpi	r21, 0x65	; 101
      b0:	eb 36       	cpi	r30, 0x6B	; 107
      b2:	eb 36       	cpi	r30, 0x6B	; 107
      b4:	fc 37       	cpi	r31, 0x7C	; 124
      b6:	57 37       	cpi	r21, 0x77	; 119
      b8:	fc 37       	cpi	r31, 0x7C	; 124
      ba:	fc 37       	cpi	r31, 0x7C	; 124
      bc:	fc 37       	cpi	r31, 0x7C	; 124
      be:	fc 37       	cpi	r31, 0x7C	; 124
      c0:	fc 37       	cpi	r31, 0x7C	; 124
      c2:	fc 37       	cpi	r31, 0x7C	; 124
      c4:	fc 37       	cpi	r31, 0x7C	; 124
      c6:	fc 37       	cpi	r31, 0x7C	; 124
      c8:	aa 37       	cpi	r26, 0x7A	; 122
      ca:	aa 37       	cpi	r26, 0x7A	; 122
      cc:	3e 44       	sbci	r19, 0x4E	; 78
      ce:	69 44       	sbci	r22, 0x49	; 73
      d0:	9d 44       	sbci	r25, 0x4D	; 77
      d2:	d3 44       	sbci	r29, 0x43	; 67
      d4:	3e 44       	sbci	r19, 0x4E	; 78
      d6:	69 44       	sbci	r22, 0x49	; 73
      d8:	29 47       	sbci	r18, 0x79	; 121
      da:	f5 44       	sbci	r31, 0x45	; 69
      dc:	1e 45       	sbci	r17, 0x5E	; 94
      de:	50 45       	sbci	r21, 0x50	; 80
      e0:	89 45       	sbci	r24, 0x59	; 89
      e2:	f5 44       	sbci	r31, 0x45	; 69
      e4:	1e 45       	sbci	r17, 0x5E	; 94
      e6:	b3 45       	sbci	r27, 0x53	; 83
      e8:	b3 45       	sbci	r27, 0x53	; 83
      ea:	29 47       	sbci	r18, 0x79	; 121
      ec:	b7 45       	sbci	r27, 0x57	; 87
      ee:	c2 45       	sbci	r28, 0x52	; 82
      f0:	cd 45       	sbci	r28, 0x5D	; 93
      f2:	01 46       	sbci	r16, 0x61	; 97
      f4:	b7 45       	sbci	r27, 0x57	; 87
      f6:	c2 45       	sbci	r28, 0x52	; 82
      f8:	29 47       	sbci	r18, 0x79	; 121
      fa:	29 47       	sbci	r18, 0x79	; 121
      fc:	29 47       	sbci	r18, 0x79	; 121
      fe:	31 46       	sbci	r19, 0x61	; 97
     100:	4d 46       	sbci	r20, 0x6D	; 109
     102:	31 46       	sbci	r19, 0x61	; 97
     104:	4d 46       	sbci	r20, 0x6D	; 109
     106:	6b 46       	sbci	r22, 0x6B	; 107
     108:	6e 46       	sbci	r22, 0x6E	; 110
     10a:	75 46       	sbci	r23, 0x65	; 101
     10c:	97 46       	sbci	r25, 0x67	; 103
     10e:	bb 46       	sbci	r27, 0x6B	; 107
     110:	f0 46       	sbci	r31, 0x60	; 96
     112:	a0 47       	sbci	r26, 0x70	; 112
     114:	a4 47       	sbci	r26, 0x74	; 116
     116:	a9 47       	sbci	r26, 0x79	; 121
     118:	ae 47       	sbci	r26, 0x7E	; 126
     11a:	b3 47       	sbci	r27, 0x73	; 115
     11c:	b8 47       	sbci	r27, 0x78	; 120
     11e:	bc 47       	sbci	r27, 0x7C	; 124
     120:	c0 47       	sbci	r28, 0x70	; 112
     122:	c6 47       	sbci	r28, 0x76	; 118
     124:	dc 47       	sbci	r29, 0x7C	; 124
     126:	e0 47       	sbci	r30, 0x70	; 112
     128:	e5 47       	sbci	r30, 0x75	; 117
     12a:	e9 47       	sbci	r30, 0x79	; 121
     12c:	ee 47       	sbci	r30, 0x7E	; 126
     12e:	f3 47       	sbci	r31, 0x73	; 115
     130:	f8 47       	sbci	r31, 0x78	; 120
     132:	fd 47       	sbci	r31, 0x7D	; 125
     134:	03 48       	sbci	r16, 0x83	; 131
     136:	18 48       	sbci	r17, 0x88	; 136
     138:	1c 48       	sbci	r17, 0x8C	; 140
     13a:	21 48       	sbci	r18, 0x81	; 129
     13c:	26 48       	sbci	r18, 0x86	; 134
     13e:	2b 48       	sbci	r18, 0x8B	; 139
     140:	2f 48       	sbci	r18, 0x8F	; 143
     142:	34 48       	sbci	r19, 0x84	; 132
     144:	39 48       	sbci	r19, 0x89	; 137
     146:	3e 48       	sbci	r19, 0x8E	; 142
     148:	44 48       	sbci	r20, 0x84	; 132
     14a:	ff 4a       	sbci	r31, 0xAF	; 175
     14c:	04 4b       	sbci	r16, 0xB4	; 180
     14e:	09 4b       	sbci	r16, 0xB9	; 185
     150:	21 4b       	sbci	r18, 0xB1	; 177
     152:	0d 4b       	sbci	r16, 0xBD	; 189
     154:	11 4b       	sbci	r17, 0xB1	; 177
     156:	15 4b       	sbci	r17, 0xB5	; 181
     158:	19 4b       	sbci	r17, 0xB9	; 185
     15a:	1d 4b       	sbci	r17, 0xBD	; 189
     15c:	b7 52       	subi	r27, 0x27	; 39
     15e:	3f 53       	subi	r19, 0x3F	; 63
     160:	b3 52       	subi	r27, 0x23	; 35
     162:	43 53       	subi	r20, 0x33	; 51
     164:	df 52       	subi	r29, 0x2F	; 47
     166:	e3 52       	subi	r30, 0x23	; 35
     168:	e7 52       	subi	r30, 0x27	; 39
     16a:	eb 52       	subi	r30, 0x2B	; 43
     16c:	ef 52       	subi	r30, 0x2F	; 47
     16e:	f3 52       	subi	r31, 0x23	; 35
     170:	f7 52       	subi	r31, 0x27	; 39
     172:	fb 52       	subi	r31, 0x2B	; 43
     174:	ff 52       	subi	r31, 0x2F	; 47
     176:	03 53       	subi	r16, 0x33	; 51
     178:	07 53       	subi	r16, 0x37	; 55
     17a:	0b 53       	subi	r16, 0x3B	; 59
     17c:	0f 53       	subi	r16, 0x3F	; 63
     17e:	13 53       	subi	r17, 0x33	; 51
     180:	17 53       	subi	r17, 0x37	; 55
     182:	1b 53       	subi	r17, 0x3B	; 59
     184:	1f 53       	subi	r17, 0x3F	; 63
     186:	23 53       	subi	r18, 0x33	; 51
     188:	97 53       	subi	r25, 0x37	; 55
     18a:	9b 53       	subi	r25, 0x3B	; 59
     18c:	9f 53       	subi	r25, 0x3F	; 63
     18e:	a3 53       	subi	r26, 0x33	; 51
     190:	a7 53       	subi	r26, 0x37	; 55
     192:	ab 53       	subi	r26, 0x3B	; 59
     194:	af 53       	subi	r26, 0x3F	; 63
     196:	b3 53       	subi	r27, 0x33	; 51
     198:	b7 53       	subi	r27, 0x37	; 55
     19a:	bb 53       	subi	r27, 0x3B	; 59
     19c:	bf 53       	subi	r27, 0x3F	; 63
     19e:	c3 53       	subi	r28, 0x33	; 51
     1a0:	50 58       	subi	r21, 0x80	; 128
     1a2:	6d 58       	subi	r22, 0x8D	; 141
     1a4:	7d 58       	subi	r23, 0x8D	; 141
     1a6:	8a 58       	subi	r24, 0x8A	; 138
     1a8:	61 64       	ori	r22, 0x41	; 65
     1aa:	61 64       	ori	r22, 0x41	; 65
     1ac:	b4 58       	subi	r27, 0x84	; 132
     1ae:	cb 58       	subi	r28, 0x8B	; 139
     1b0:	db 58       	subi	r29, 0x8B	; 139
     1b2:	e8 58       	subi	r30, 0x88	; 136
     1b4:	f8 58       	subi	r31, 0x88	; 136
     1b6:	05 59       	subi	r16, 0x95	; 149
     1b8:	61 64       	ori	r22, 0x41	; 65
     1ba:	61 64       	ori	r22, 0x41	; 65
     1bc:	61 64       	ori	r22, 0x41	; 65
     1be:	13 59       	subi	r17, 0x93	; 147
     1c0:	20 59       	subi	r18, 0x90	; 144
     1c2:	30 59       	subi	r19, 0x90	; 144
     1c4:	3d 59       	subi	r19, 0x9D	; 157
     1c6:	4d 59       	subi	r20, 0x9D	; 157
     1c8:	5a 59       	subi	r21, 0x9A	; 154
     1ca:	6a 59       	subi	r22, 0x9A	; 154
     1cc:	77 59       	subi	r23, 0x97	; 151
     1ce:	8d 59       	subi	r24, 0x9D	; 157
     1d0:	9a 59       	subi	r25, 0x9A	; 154
     1d2:	aa 59       	subi	r26, 0x9A	; 154
     1d4:	b3 59       	subi	r27, 0x93	; 147
     1d6:	c5 59       	subi	r28, 0x95	; 149
     1d8:	dc 59       	subi	r29, 0x9C	; 156
     1da:	54 5a       	subi	r21, 0xA4	; 164
     1dc:	64 5a       	subi	r22, 0xA4	; 164
     1de:	71 5a       	subi	r23, 0xA1	; 161
     1e0:	81 5a       	subi	r24, 0xA1	; 161
     1e2:	8e 5a       	subi	r24, 0xAE	; 174
     1e4:	9e 5a       	subi	r25, 0xAE	; 174
     1e6:	ab 5a       	subi	r26, 0xAB	; 171
     1e8:	0d 5b       	subi	r16, 0xBD	; 189
     1ea:	6c 5b       	subi	r22, 0xBC	; 188
     1ec:	7a 5b       	subi	r23, 0xBA	; 186
     1ee:	88 5b       	subi	r24, 0xB8	; 184
     1f0:	b5 5b       	subi	r27, 0xB5	; 181
     1f2:	db 5b       	subi	r29, 0xBB	; 187
     1f4:	e6 5b       	subi	r30, 0xB6	; 182
     1f6:	f4 5b       	subi	r31, 0xB4	; 180
     1f8:	ff 5b       	subi	r31, 0xBF	; 191
     1fa:	2e 5c       	subi	r18, 0xCE	; 206
     1fc:	be 5c       	subi	r27, 0xCE	; 206
     1fe:	cc 5c       	subi	r28, 0xCC	; 204
     200:	fa 5c       	subi	r31, 0xCA	; 202
     202:	41 5d       	subi	r20, 0xD1	; 209
     204:	4f 5d       	subi	r20, 0xDF	; 223
     206:	5b 5d       	subi	r21, 0xDB	; 219
     208:	c8 5d       	subi	r28, 0xD8	; 216
     20a:	57 5e       	subi	r21, 0xE7	; 231
     20c:	16 5f       	subi	r17, 0xF6	; 246
     20e:	29 5f       	subi	r18, 0xF9	; 249
     210:	35 5f       	subi	r19, 0xF5	; 245
     212:	8a 5f       	subi	r24, 0xFA	; 250
     214:	f4 5f       	subi	r31, 0xF4	; 244
     216:	7c 60       	ori	r23, 0x0C	; 12
     218:	89 60       	ori	r24, 0x09	; 9
     21a:	9c 60       	ori	r25, 0x0C	; 12
     21c:	b5 60       	ori	r27, 0x05	; 5
     21e:	22 61       	ori	r18, 0x12	; 18
     220:	58 61       	ori	r21, 0x18	; 24
     222:	93 61       	ori	r25, 0x13	; 19
     224:	bf 61       	ori	r27, 0x1F	; 31
     226:	d0 61       	ori	r29, 0x10	; 16
     228:	dc 61       	ori	r29, 0x1C	; 28
     22a:	61 64       	ori	r22, 0x41	; 65
     22c:	61 64       	ori	r22, 0x41	; 65
     22e:	61 64       	ori	r22, 0x41	; 65
     230:	61 64       	ori	r22, 0x41	; 65
     232:	61 64       	ori	r22, 0x41	; 65
     234:	61 64       	ori	r22, 0x41	; 65
     236:	61 64       	ori	r22, 0x41	; 65
     238:	61 64       	ori	r22, 0x41	; 65
     23a:	61 64       	ori	r22, 0x41	; 65
     23c:	61 64       	ori	r22, 0x41	; 65
     23e:	61 64       	ori	r22, 0x41	; 65
     240:	61 64       	ori	r22, 0x41	; 65
     242:	61 64       	ori	r22, 0x41	; 65
     244:	a4 5f       	subi	r26, 0xF4	; 244
     246:	b0 5f       	subi	r27, 0xF0	; 240
     248:	bc 5f       	subi	r27, 0xFC	; 252
     24a:	c8 5f       	subi	r28, 0xF8	; 248
     24c:	d6 5f       	subi	r29, 0xF6	; 246
     24e:	e2 5f       	subi	r30, 0xF2	; 242
     250:	61 64       	ori	r22, 0x41	; 65
     252:	61 64       	ori	r22, 0x41	; 65
     254:	01 62       	ori	r16, 0x21	; 33
     256:	23 62       	ori	r18, 0x23	; 35
     258:	2d 62       	ori	r18, 0x2D	; 45
     25a:	39 62       	ori	r19, 0x29	; 41
     25c:	47 62       	ori	r20, 0x27	; 39
     25e:	53 62       	ori	r21, 0x23	; 35
     260:	63 62       	ori	r22, 0x23	; 35
     262:	83 62       	ori	r24, 0x23	; 35
     264:	b3 62       	ori	r27, 0x23	; 35
     266:	01 63       	ori	r16, 0x31	; 49
     268:	0d 63       	ori	r16, 0x3D	; 61
     26a:	37 63       	ori	r19, 0x37	; 55
     26c:	59 63       	ori	r21, 0x39	; 57
     26e:	a2 63       	ori	r26, 0x32	; 50
     270:	ae 63       	ori	r26, 0x3E	; 62
     272:	c3 63       	ori	r28, 0x33	; 51
     274:	cf 63       	ori	r28, 0x3F	; 63
     276:	e7 63       	ori	r30, 0x37	; 55
     278:	f5 63       	ori	r31, 0x35	; 53
     27a:	07 64       	ori	r16, 0x47	; 71
     27c:	15 64       	ori	r17, 0x45	; 69
     27e:	21 64       	ori	r18, 0x41	; 65
     280:	34 64       	ori	r19, 0x44	; 68
     282:	40 64       	ori	r20, 0x40	; 64
     284:	53 64       	ori	r21, 0x43	; 67
     286:	61 64       	ori	r22, 0x41	; 65
     288:	62 67       	ori	r22, 0x72	; 114
     28a:	64 67       	ori	r22, 0x74	; 116
     28c:	6f 67       	ori	r22, 0x7F	; 127
     28e:	71 67       	ori	r23, 0x71	; 113
     290:	7e 67       	ori	r23, 0x7E	; 126
     292:	80 67       	ori	r24, 0x70	; 112
     294:	8b 67       	ori	r24, 0x7B	; 123
     296:	bd 67       	ori	r27, 0x7D	; 125
     298:	c4 67       	ori	r28, 0x74	; 116
     29a:	cc 67       	ori	r28, 0x7C	; 124
     29c:	d3 67       	ori	r29, 0x73	; 115
     29e:	db 67       	ori	r29, 0x7B	; 123
     2a0:	e2 67       	ori	r30, 0x72	; 114
     2a2:	bd 67       	ori	r27, 0x7D	; 125
     2a4:	db 67       	ori	r29, 0x7B	; 123
     2a6:	94 67       	ori	r25, 0x74	; 116
     2a8:	ea 67       	ori	r30, 0x7A	; 122
     2aa:	ef 67       	ori	r30, 0x7F	; 127
     2ac:	f8 67       	ori	r31, 0x78	; 120
     2ae:	fd 67       	ori	r31, 0x7D	; 125
     2b0:	06 68       	ori	r16, 0x86	; 134
     2b2:	0b 68       	ori	r16, 0x8B	; 139
     2b4:	ea 67       	ori	r30, 0x7A	; 122
     2b6:	06 68       	ori	r16, 0x86	; 134
     2b8:	9f 67       	ori	r25, 0x7F	; 127
     2ba:	14 68       	ori	r17, 0x84	; 132
     2bc:	19 68       	ori	r17, 0x89	; 137
     2be:	2a 68       	ori	r18, 0x8A	; 138
     2c0:	2f 68       	ori	r18, 0x8F	; 143
     2c2:	40 68       	ori	r20, 0x80	; 128
     2c4:	42 68       	ori	r20, 0x82	; 130
     2c6:	50 68       	ori	r21, 0x80	; 128
     2c8:	5a 68       	ori	r21, 0x8A	; 138
     2ca:	80 68       	ori	r24, 0x80	; 128
     2cc:	87 68       	ori	r24, 0x87	; 135

000002ce <__trampolines_end>:
     2ce:	ed e5       	ldi	r30, 0x5D	; 93
     2d0:	f2 20       	and	r15, r2
     2d2:	f1 e2       	ldi	r31, 0x21	; 33
     2d4:	ff e7       	ldi	r31, 0x7F	; 127
     2d6:	e8 20       	and	r14, r8
     2d8:	f1 20       	and	r15, r1
     2da:	dd d1       	rcall	.+954    	; 0x696 <system_page+0x54>
     2dc:	20 00       	.word	0x0020	; ????

000002de <__c.5163>:
     2de:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000002ee <__c.5161>:
     2ee:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000002f9 <__c.4707>:
     2f9:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

00000303 <__c.4705>:
     303:	25 30 38 6c 78 00                                   %08lx.

00000309 <__c.4688>:
     309:	25 75 0d 0a 00                                      %u...

0000030e <__c.4589>:
     30e:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

0000031a <__c.4587>:
     31a:	2f 00                                               /.

0000031c <__c.3743>:
     31c:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

0000032c <__c.3731>:
     32c:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
     33c:	68 75 00                                            hu.

0000033f <__c.3720>:
     33f:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
     34f:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

0000035d <__c.3695>:
     35d:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

0000036a <__c.3671>:
     36a:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
     37a:	68 68 75 00                                         hhu.

0000037e <aCRCLo.1930>:
     37e:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     38e:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     39e:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     3ae:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     3be:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     3ce:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     3de:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     3ee:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     3fe:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     40e:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     41e:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     42e:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     43e:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     44e:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     45e:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     46e:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

0000047e <aCRCHi.1929>:
     47e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     48e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     49e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4ae:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4be:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4ce:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4de:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4ee:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4fe:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     50e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     51e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     52e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     53e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     54e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     55e:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     56e:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

0000057e <WebSite>:
     57e:	53 45 91 48 e5 33 7c 39 d0 1c dc 16 8a 0c 90 05     SE.H.3|9........
     58e:	ac 32                                               .2

00000590 <Web_system>:
     590:	7e 0c 3c 0c 18 00 9d 05 fa 05 42 06 04              ~.<.......B..

0000059d <system_OField>:
     59d:	3c 06 2c 06 25 06 15 06 0a 06 fa 05 f0 05 e0 05     <.,.%...........
     5ad:	da 05 ca 05 c5 05 b5 05                             ........

000005b5 <Web_Tlow>:
     5b5:	0a 0b 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005c5 <var_Tlow>:
     5c5:	54 6c 6f 77 00                                      Tlow.

000005ca <Web_Thigh>:
     5ca:	0a 0d 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005da <var_Thigh>:
     5da:	54 68 69 67 68 00                                   Thigh.

000005e0 <Web_BLupgrade>:
     5e0:	00 1f 06 00 00 00 00 ff 00 00 00 f9 28 00 00 00     ............(...

000005f0 <var_BLupgrade>:
     5f0:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

000005fa <Web_Bootloader>:
     5fa:	00 1f 06 00 00 00 00 ff 00 00 00 c6 29 00 00 00     ............)...

0000060a <var_Bootloader>:
     60a:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

00000615 <Web_Reboot>:
     615:	00 1f 06 00 00 00 00 ff 00 00 00 f3 28 00 00 00     ............(...

00000625 <var_Reboot>:
     625:	52 65 62 6f 6f 74 00                                Reboot.

0000062c <Web_Title>:
     62c:	22 0f 00 00 00 00 00 02 00 00 00 00 00 00 00 15     "...............

0000063c <var_Title>:
     63c:	54 69 74 6c 65 00                                   Title.

00000642 <system_page>:
     642:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     652:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     662:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     672:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     682:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     692:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     6a2:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     6b2:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     6c2:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     6d2:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     6e2:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     6f2:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     702:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     712:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
     722:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     732:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     742:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     752:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     762:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     772:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     782:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     792:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     7a2:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     7b2:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     7c2:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     7d2:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     7e2:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     7f2:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     802:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     812:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     822:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     832:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
     842:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
     852:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
     862:	cd e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0     ........ .......
     872:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     882:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74     'text' name='Tit
     892:	6c 65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61     le' size='40' va
     8a2:	6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     lue='{{{{{{{{{{{
     8b2:	7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69     {{{{{{{{{'>...<i
     8c2:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     8d2:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
     8e2:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
     8f2:	0d 0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b     ........... :{{{
     902:	7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46     {{{{{{{{ .....<F
     912:	4f 52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     ORM action='/' m
     922:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c     ethod='GET'>...<
     932:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
     942:	69 74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74     it' name='Reboot
     952:	27 20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27     ' value='Reboot'
     962:	3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1     >..</FORM>......
     972:	e8 ff 20 cf ce 3a 20 34 2e 30 31 0d 0a 3c 46 4f     .. ..: 4.01..<FO
     982:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
     992:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
     9a2:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     9b2:	74 27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61     t' name='Bootloa
     9c2:	64 65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74     der' value='Boot
     9d2:	6c 6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52     loader' color='R
     9e2:	45 44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     ED'>..</FORM>..<
     9f2:	2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69     /BR>..<FORM acti
     a02:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
     a12:	45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ET'>...<input ty
     a22:	70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65     pe='submit' name
     a32:	3d 27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c     ='BLupgrade' val
     a42:	75 65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d     ue='BLupgrade'>.
     a52:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
     a62:	0a 3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0     .<H2>...........
     a72:	3c 2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3     </H2>...........
     a82:	f0 e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43     ..:{{{{{{{&#176C
     a92:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
     aa2:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
     ab2:	47 45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff     GET'>...........
     ac2:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     ad2:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69     'text' name='Thi
     ae2:	67 68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c     gh' size='5' val
     af2:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31     ue='{{{{{{{'>&#1
     b02:	37 36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     76C...<input typ
     b12:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
     b22:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
     b32:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
     b42:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
     b52:	27 47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff     'GET'>..........
     b62:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     b72:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f     'text' name='Tlo
     b82:	77 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     w' size='5' valu
     b92:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
     ba2:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
     bb2:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
     bc2:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
     bd2:	3c 2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d     </BR>....... GSM
     be2:	2d 3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32     ->EM: {{{/(max 2
     bf2:	35 30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3     50)....</BR>....
     c02:	f4 e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b     ... EM->GSM: {{{
     c12:	2f 28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f     /(max 250)....</
     c22:	42 52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     BR>....</BODY>..
     c32:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00000c3c <system_IField>:
     c3c:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
     c4c:	00 00 14 12 06 00 00 00 22 0f 00 00 00 15 10 63     ........"......c
     c5c:	09 00 00 02 09 f2 05 00 00 01 0a 0d 00 00 00 01     ................
     c6c:	0a 0b 00 00 00 01 00 7f 09 00 00 00 00 6e 0a 00     .............n..
	...

00000c7e <name_system>:
     c7e:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000c8a <Web_csd>:
     c8a:	d3 16 73 16 2c 00 97 0c c7 08 ac 0d 02              ..s.,........

00000c97 <csd_OField>:
     c97:	a5 0d 95 0d 90 0d 80 0d 7b 0d 6b 0d 66 0d 56 0d     ........{.k.f.V.
     ca7:	51 0d 41 0d 3c 0d 2c 0d 27 0d 17 0d 12 0d 02 0d     Q.A.<.,.'.......
     cb7:	fd 0c ed 0c e8 0c d8 0c d3 0c c3 0c                 ............

00000cc3 <Web_CSD_Number9>:
     cc3:	22 d6 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cd3 <var_CSD_Number9>:
     cd3:	43 53 44 39 00                                      CSD9.

00000cd8 <Web_CSD_Number8>:
     cd8:	22 c9 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000ce8 <var_CSD_Number8>:
     ce8:	43 53 44 38 00                                      CSD8.

00000ced <Web_CSD_Number7>:
     ced:	22 bc 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cfd <var_CSD_Number7>:
     cfd:	43 53 44 37 00                                      CSD7.

00000d02 <Web_CSD_Number6>:
     d02:	22 af 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d12 <var_CSD_Number6>:
     d12:	43 53 44 36 00                                      CSD6.

00000d17 <Web_CSD_Number5>:
     d17:	22 a2 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d27 <var_CSD_Number5>:
     d27:	43 53 44 35 00                                      CSD5.

00000d2c <Web_CSD_Number4>:
     d2c:	22 95 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d3c <var_CSD_Number4>:
     d3c:	43 53 44 34 00                                      CSD4.

00000d41 <Web_CSD_Number3>:
     d41:	22 88 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d51 <var_CSD_Number3>:
     d51:	43 53 44 33 00                                      CSD3.

00000d56 <Web_CSD_Number2>:
     d56:	22 7b 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "{..............

00000d66 <var_CSD_Number2>:
     d66:	43 53 44 32 00                                      CSD2.

00000d6b <Web_CSD_Number1>:
     d6b:	22 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "n..............

00000d7b <var_CSD_Number1>:
     d7b:	43 53 44 31 00                                      CSD1.

00000d80 <Web_CSD_Number0>:
     d80:	22 61 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "a..............

00000d90 <var_CSD_Number0>:
     d90:	43 53 44 30 00                                      CSD0.

00000d95 <Web_CLIP>:
     d95:	01 5f 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ._..............

00000da5 <var_CLIP>:
     da5:	43 4c 49 50 4f 6e 00                                CLIPOn.

00000dac <csd_page>:
     dac:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     dbc:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     dcc:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     ddc:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     dec:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     dfc:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     e0c:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     e1c:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     e2c:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     e3c:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     e4c:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     e5c:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     e6c:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     e7c:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
     e8c:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     e9c:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     eac:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     ebc:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     ecc:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     edc:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     eec:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     efc:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     f0c:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     f1c:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     f2c:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     f3c:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     f4c:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     f5c:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     f6c:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     f7c:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     f8c:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     f9c:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f     .</a>..<HR>..<fo
     fac:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
     fbc:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0     thod='GET'>.....
     fcc:	ee e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a     ...... ......:..
     fdc:	09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43     .<SELECT NAME="C
     fec:	4c 49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49     LIPOn"> ...<OPTI
     ffc:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    100c:	7b 7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49     {{{>... ...<OPTI
    101c:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    102c:	7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43     {{{>.....</SELEC
    103c:	54 3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T> ...<input typ
    104c:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    105c:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    106c:	0a 3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5     .<h3>...........
    107c:	20 ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52      ......</h3></BR
    108c:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    109c:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10ac:	3e 0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75     >....1: ...<inpu
    10bc:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    10cc:	6d 65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27     me='CSD0' size='
    10dc:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    10ec:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    10fc:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    110c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    111c:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    112c:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    113c:	47 45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c     GET'>....2: ...<
    114c:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    115c:	27 20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69     ' name='CSD1' si
    116c:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    117c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    118c:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    119c:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    11ac:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    11bc:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    11cc:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20     od='GET'>....3: 
    11dc:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    11ec:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32     text' name='CSD2
    11fc:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    120c:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    121c:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    122c:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    123c:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    124c:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    125c:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    126c:	b9 34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .4: ...<input ty
    127c:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    128c:	43 53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD3' size='12' 
    129c:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    12ac:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    12bc:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    12cc:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    12dc:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    12ec:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    12fc:	3e 0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75     >....5: ...<inpu
    130c:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    131c:	6d 65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27     me='CSD4' size='
    132c:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    133c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    134c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    135c:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    136c:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    137c:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    138c:	47 45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c     GET'>....6: ...<
    139c:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    13ac:	27 20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69     ' name='CSD5' si
    13bc:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    13cc:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    13dc:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    13ec:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    13fc:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    140c:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    141c:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20     od='GET'>....7: 
    142c:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    143c:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36     text' name='CSD6
    144c:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    145c:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    146c:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    147c:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    148c:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    149c:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    14ac:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    14bc:	b9 38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .8: ...<input ty
    14cc:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    14dc:	43 53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD7' size='12' 
    14ec:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    14fc:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    150c:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    151c:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    152c:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    153c:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    154c:	3e 0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75     >....9: ...<inpu
    155c:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    156c:	6d 65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27     me='CSD8' size='
    157c:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    158c:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    159c:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    15ac:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    15bc:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    15cc:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    15dc:	47 45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09     GET'>....10: ...
    15ec:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    15fc:	74 27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73     t' name='CSD9' s
    160c:	69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27     ize='12' value='
    161c:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a     {{{{{{{{{{{{'>..
    162c:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    163c:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    164c:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    165c:	3e 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     >.. </BODY>..</H
    166c:	54 4d 4c 3e 0d 0a 00                                TML>...

00001673 <csd_IField>:
    1673:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    1683:	00 00 14 12 06 00 00 00 1e 5f 00 31 45 00 1e 5f     ........._.1E.._
    1693:	00 2d 45 00 22 61 00 00 00 0d 22 6e 00 00 00 0d     .-E."a...."n....
    16a3:	22 7b 00 00 00 0d 22 88 00 00 00 0d 22 95 00 00     "{...."....."...
    16b3:	00 0d 22 a2 00 00 00 0d 22 af 00 00 00 0d 22 bc     ..".....".....".
    16c3:	00 00 00 0d 22 c9 00 00 00 0d 22 d6 00 00 00 0d     ....".....".....

000016d3 <name_csd>:
    16d3:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

000016dc <Web_gsm>:
    16dc:	c7 1c 97 1c 1c 00 e9 16 cf 04 c8 17 04              .............

000016e9 <gsm_OField>:
    16e9:	bf 17 af 17 9c 17 8c 17 7f 17 6f 17 69 17 59 17     ..........o.i.Y.
    16f9:	4d 17 3d 17 31 17 21 17 15 17 05 17                 M.=.1.!.....

00001705 <Web_SMS_Number3>:
    1705:	22 fd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001715 <var_SMS_Number3>:
    1715:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

00001721 <Web_SMS_Number2>:
    1721:	22 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001731 <var_SMS_Number2>:
    1731:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

0000173d <Web_SMS_Number1>:
    173d:	22 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000174d <var_SMS_Number1>:
    174d:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

00001759 <Web_SMS>:
    1759:	01 60 00 00 00 00 00 01 00 00 00 00 00 00 00 00     .`..............

00001769 <var_SMS>:
    1769:	53 4d 53 4f 6e 00                                   SMSOn.

0000176f <Web_GPRS_apn_psw>:
    176f:	22 54 01 00 00 00 00 02 00 00 00 1d 2a 00 00 14     "T..........*...

0000177f <var_GPRS_apn_psw>:
    177f:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

0000178c <Web_GPRS_apn_user_name>:
    178c:	22 68 01 00 00 00 00 02 00 00 00 1d 2a 00 00 14     "h..........*...

0000179c <var_GPRS_apn_user_name>:
    179c:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    17ac:	6d 65 00                                            me.

000017af <Web_GPRS_apn1>:
    17af:	22 7c 01 00 00 00 00 02 00 00 00 1d 2a 00 00 1e     "|..........*...

000017bf <var_GPRS_apn1>:
    17bf:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000017c8 <gsm_page>:
    17c8:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    17d8:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    17e8:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    17f8:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    1808:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    1818:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    1828:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    1838:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    1848:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    1858:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    1868:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    1878:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    1888:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    1898:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
    18a8:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    18b8:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    18c8:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    18d8:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    18e8:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    18f8:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    1908:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    1918:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    1928:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    1938:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    1948:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    1958:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    1968:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    1978:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    1988:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    1998:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    19a8:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    19b8:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee     .</a>..<HR>.....
    19c8:	e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20     .... ....... {{ 
    19d8:	28 30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33     (0-31)</BR>..<h3
    19e8:	3e 47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d     >GPRS</h3></BR>.
    19f8:	0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f     .<form action='/
    1a08:	27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d     ' method='GET'>.
    1a18:	0a 09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c     ..APN name: ...<
    1a28:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1a38:	27 20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e     ' name='GPRS_apn
    1a48:	27 20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75     ' size='29' valu
    1a58:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    1a68:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    1a78:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    1a88:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    1a98:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    1aa8:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    1ab8:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1ac8:	47 45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d     GET'>...User nam
    1ad8:	65 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     e: ...<input typ
    1ae8:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47     e='text' name='G
    1af8:	50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d     PRS_apn_user_nam
    1b08:	65 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     e' size='19' val
    1b18:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1b28:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1b38:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1b48:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1b58:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    1b68:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    1b78:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50     ethod='GET'>...P
    1b88:	61 73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70     assword: ...<inp
    1b98:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    1ba8:	61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73     ame='GPRS_apn_ps
    1bb8:	77 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     w' size='19' val
    1bc8:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1bd8:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1be8:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1bf8:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1c08:	66 6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f     form..</BR>..<FO
    1c18:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    1c28:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    1c38:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    1c48:	74 27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53     t' name='ResetGS
    1c58:	4d 27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47     M' value='ResetG
    1c68:	53 4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     SM'>..</FORM>..<
    1c78:	2f 42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f     /BR></BR>.. </BO
    1c88:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

00001c97 <gsm_IField>:
    1c97:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    1ca7:	00 00 14 12 06 00 00 00 00 25 06 00 00 00 22 7c     .........%...."|
    1cb7:	01 00 00 1e 22 68 01 00 00 14 22 54 01 00 00 14     ...."h...."T....

00001cc7 <name_gsm>:
    1cc7:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

00001cd0 <Web_network>:
    1cd0:	9f 32 9d 31 a0 00 dd 1c 4a 10 53 21 04              .2.1....J.S!.

00001cdd <network_OField>:
    1cdd:	44 21 34 21 20 21 10 21 fe 20 ee 20 8d 1d 7d 1d     D!4! !.!. . ..}.
    1ced:	e5 20 d5 20 cc 20 bc 20 b3 20 a3 20 9a 20 8a 20     . . . . . . . . 
    1cfd:	81 20 71 20 68 20 58 20 4f 20 3f 20 36 20 26 20     . q h X O ? 6 & 
    1d0d:	1d 20 0d 20 04 20 f4 1f eb 1f db 1f d2 1f c2 1f     . . . ..........
    1d1d:	b9 1f a9 1f a0 1f 90 1f 87 1f 77 1f 6e 1f 5e 1f     ..........w.n.^.
    1d2d:	58 1f 48 1f 42 1f 32 1f 2c 1f 1c 1f 16 1f 06 1f     X.H.B.2.,.......
    1d3d:	00 1f f0 1e ea 1e da 1e d4 1e c4 1e be 1e ae 1e     ................
    1d4d:	a8 1e 98 1e 92 1e 82 1e 7c 1e 6c 1e 66 1e 56 1e     ........|.l.f.V.
    1d5d:	50 1e 40 1e 3a 1e 2a 1e 24 1e 14 1e 0e 1e fe 1d     P.@.:.*.$.......
    1d6d:	f4 1d e4 1d da 1d ca 1d c0 1d b0 1d a6 1d 96 1d     ................

00001d7d <Web_ResetGSM>:
    1d7d:	00 1f 06 00 00 00 00 ff 00 00 00 f5 28 00 00 00     ............(...

00001d8d <var_ResetGSM>:
    1d8d:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00001d96 <Web_UDP3_Port>:
    1d96:	08 30 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .0..............

00001da6 <var_UDP3_Port>:
    1da6:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

00001db0 <Web_UDP2_Port>:
    1db0:	08 2e 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00001dc0 <var_UDP2_Port>:
    1dc0:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00001dca <Web_UDP1_Port>:
    1dca:	08 2c 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .,..............

00001dda <var_UDP1_Port>:
    1dda:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

00001de4 <Web_UDP0_Port>:
    1de4:	08 2a 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .*..............

00001df4 <var_UDP0_Port>:
    1df4:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

00001dfe <Web_UDP3_IP4>:
    1dfe:	01 51 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Q..............

00001e0e <var_UDP3_IP4>:
    1e0e:	55 44 50 33 34 00                                   UDP34.

00001e14 <Web_UDP3_IP3>:
    1e14:	01 50 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .P..............

00001e24 <var_UDP3_IP3>:
    1e24:	55 44 50 33 33 00                                   UDP33.

00001e2a <Web_UDP3_IP2>:
    1e2a:	01 4f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .O..............

00001e3a <var_UDP3_IP2>:
    1e3a:	55 44 50 33 32 00                                   UDP32.

00001e40 <Web_UDP3_IP1>:
    1e40:	01 4e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .N..............

00001e50 <var_UDP3_IP1>:
    1e50:	55 44 50 33 31 00                                   UDP31.

00001e56 <Web_UDP2_IP4>:
    1e56:	01 4d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .M..............

00001e66 <var_UDP2_IP4>:
    1e66:	55 44 50 32 34 00                                   UDP24.

00001e6c <Web_UDP2_IP3>:
    1e6c:	01 4c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .L..............

00001e7c <var_UDP2_IP3>:
    1e7c:	55 44 50 32 33 00                                   UDP23.

00001e82 <Web_UDP2_IP2>:
    1e82:	01 4b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .K..............

00001e92 <var_UDP2_IP2>:
    1e92:	55 44 50 32 32 00                                   UDP22.

00001e98 <Web_UDP2_IP1>:
    1e98:	01 4a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .J..............

00001ea8 <var_UDP2_IP1>:
    1ea8:	55 44 50 32 31 00                                   UDP21.

00001eae <Web_UDP1_IP4>:
    1eae:	01 49 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .I..............

00001ebe <var_UDP1_IP4>:
    1ebe:	55 44 50 31 34 00                                   UDP14.

00001ec4 <Web_UDP1_IP3>:
    1ec4:	01 48 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .H..............

00001ed4 <var_UDP1_IP3>:
    1ed4:	55 44 50 31 33 00                                   UDP13.

00001eda <Web_UDP1_IP2>:
    1eda:	01 47 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .G..............

00001eea <var_UDP1_IP2>:
    1eea:	55 44 50 31 32 00                                   UDP12.

00001ef0 <Web_UDP1_IP1>:
    1ef0:	01 46 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .F..............

00001f00 <var_UDP1_IP1>:
    1f00:	55 44 50 31 31 00                                   UDP11.

00001f06 <Web_UDP0_IP4>:
    1f06:	01 45 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .E..............

00001f16 <var_UDP0_IP4>:
    1f16:	55 44 50 30 34 00                                   UDP04.

00001f1c <Web_UDP0_IP3>:
    1f1c:	01 44 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .D..............

00001f2c <var_UDP0_IP3>:
    1f2c:	55 44 50 30 33 00                                   UDP03.

00001f32 <Web_UDP0_IP2>:
    1f32:	01 43 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .C..............

00001f42 <var_UDP0_IP2>:
    1f42:	55 44 50 30 32 00                                   UDP02.

00001f48 <Web_UDP0_IP1>:
    1f48:	01 42 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .B..............

00001f58 <var_UDP0_IP1>:
    1f58:	55 44 50 30 31 00                                   UDP01.

00001f5e <Web_Cli3_IP4>:
    1f5e:	01 1f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f6e <var_Cli3_IP4>:
    1f6e:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00001f77 <Web_Cli3_IP3>:
    1f77:	01 1e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f87 <var_Cli3_IP3>:
    1f87:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00001f90 <Web_Cli3_IP2>:
    1f90:	01 1d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fa0 <var_Cli3_IP2>:
    1fa0:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00001fa9 <Web_Cli3_IP1>:
    1fa9:	01 1c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fb9 <var_Cli3_IP1>:
    1fb9:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00001fc2 <Web_Cli2_IP4>:
    1fc2:	01 1b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fd2 <var_Cli2_IP4>:
    1fd2:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

00001fdb <Web_Cli2_IP3>:
    1fdb:	01 1a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001feb <var_Cli2_IP3>:
    1feb:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00001ff4 <Web_Cli2_IP2>:
    1ff4:	01 19 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002004 <var_Cli2_IP2>:
    2004:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

0000200d <Web_Cli2_IP1>:
    200d:	01 18 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000201d <var_Cli2_IP1>:
    201d:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

00002026 <Web_Cli1_IP4>:
    2026:	01 17 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002036 <var_Cli1_IP4>:
    2036:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

0000203f <Web_Cli1_IP3>:
    203f:	01 16 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000204f <var_Cli1_IP3>:
    204f:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

00002058 <Web_Cli1_IP2>:
    2058:	01 15 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002068 <var_Cli1_IP2>:
    2068:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

00002071 <Web_Cli1_IP1>:
    2071:	01 14 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002081 <var_Cli1_IP1>:
    2081:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

0000208a <Web_Cli0_IP4>:
    208a:	01 13 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000209a <var_Cli0_IP4>:
    209a:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

000020a3 <Web_Cli0_IP3>:
    20a3:	01 12 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020b3 <var_Cli0_IP3>:
    20b3:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

000020bc <Web_Cli0_IP2>:
    20bc:	01 11 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020cc <var_Cli0_IP2>:
    20cc:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

000020d5 <Web_Cli0_IP1>:
    20d5:	01 10 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020e5 <var_Cli0_IP1>:
    20e5:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

000020ee <Web_WebMaxSessionTime>:
    20ee:	11 56 00 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .V........;.....

000020fe <var_WebMaxSessionTime>:
    20fe:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    210e:	65 00                                               e.

00002110 <Web_TCP_CONNECT_timeout>:
    2110:	08 0e 01 00 00 00 00 ff ff 00 00 1d 2a 00 00 02     ............*...

00002120 <var_TCP_CONNECT_timeout>:
    2120:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2130:	6f 75 74 00                                         out.

00002134 <Web_TCP_ListenPort>:
    2134:	08 20 01 00 00 00 00 ff ff 00 00 1d 2a 00 00 00     . ..........*...

00002144 <var_TCP_ListenPort>:
    2144:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

00002153 <network_page>:
    2153:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    2163:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    2173:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    2183:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    2193:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    21a3:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    21b3:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    21c3:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    21d3:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    21e3:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    21f3:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    2203:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    2213:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    2223:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
    2233:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    2243:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    2253:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    2263:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    2273:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    2283:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    2293:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    22a3:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    22b3:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    22c3:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    22d3:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    22e3:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    22f3:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    2303:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    2313:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    2323:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    2333:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    2343:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
    2353:	68 33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72     h3>TCP/IP Server
    2363:	3c 2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </h3>..<form act
    2373:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    2383:	47 45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70     GET'>...Listen p
    2393:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    23a3:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    23b3:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20     TCP_ListenPort' 
    23c3:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    23d3:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    23e3:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    23f3:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2403:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2413:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2423:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50     hod='GET'>...TCP
    2433:	2f 49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74     /IP connection t
    2443:	69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74     imeout:...<input
    2453:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    2463:	65 3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74     e='TCP_CONNECT_t
    2473:	69 6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27     imeout' size='7'
    2483:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e      value='{{{{{{'>
    2493:	73 65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     sec...<input typ
    24a3:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    24b3:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    24c3:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
    24d3:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    24e3:	27 47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e     'GET'>...Session
    24f3:	20 74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70      timeout:...<inp
    2503:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2513:	61 6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69     ame='WebMaxSessi
    2523:	6f 6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27     onTime' size='7'
    2533:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b      value='{{{{{{{{
    2543:	7b 7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74     {{'>sec...<input
    2553:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2563:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2573:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68     rm>..</BR>....<h
    2583:	33 3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68     3>IP Firewall</h
    2593:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    25a3:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    25b3:	27 3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70     '>...IP1:...<inp
    25c3:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    25d3:	61 6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73     ame='Cli0_IP1' s
    25e3:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    25f3:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    2603:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2613:	27 43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d     'Cli0_IP2' size=
    2623:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2633:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2643:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    2653:	30 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20     0_IP3' size='3' 
    2663:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2673:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2683:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50     t' name='Cli0_IP
    2693:	34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     4' size='3' valu
    26a3:	65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     e='{{{'>...<inpu
    26b3:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    26c3:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    26d3:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    26e3:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    26f3:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50     thod='GET'>...IP
    2703:	32 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     2:...<input type
    2713:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    2723:	69 31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27     i1_IP1' size='3'
    2733:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    2743:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    2753:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49     xt' name='Cli1_I
    2763:	50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P2' size='3' val
    2773:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2783:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2793:	6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20     name='Cli1_IP3' 
    27a3:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    27b3:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    27c3:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    27d3:	3d 27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65     ='Cli1_IP4' size
    27e3:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    27f3:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2803:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2813:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2823:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    2833:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    2843:	45 54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69     ET'>...IP3:...<i
    2853:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2863:	20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27      name='Cli2_IP1'
    2873:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    2883:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    2893:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    28a3:	65 3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a     e='Cli2_IP2' siz
    28b3:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    28c3:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    28d3:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    28e3:	6c 69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33     li2_IP3' size='3
    28f3:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    2903:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2913:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f     ext' name='Cli2_
    2923:	49 50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP4' size='3' va
    2933:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     lue='{{{'>...<in
    2943:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    2953:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    2963:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c     /form>..</BR>..<
    2973:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    2983:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    2993:	49 50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     IP4:...<input ty
    29a3:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29b3:	43 6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27     Cli3_IP1' size='
    29c3:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    29d3:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    29e3:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33     text' name='Cli3
    29f3:	5f 49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP2' size='3' v
    2a03:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2a13:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2a23:	27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33     ' name='Cli3_IP3
    2a33:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2a43:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2a53:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a63:	6d 65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69     me='Cli3_IP4' si
    2a73:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2a83:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2a93:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2aa3:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2ab3:	0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63     .</BR>..<FORM ac
    2ac3:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2ad3:	27 47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     'GET'>...<input 
    2ae3:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61     type='submit' na
    2af3:	6d 65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61     me='ResetGSM' va
    2b03:	6c 75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d     lue='ResetGSM'>.
    2b13:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
    2b23:	0a 0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0     .....<h3>.......
    2b33:	20 f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a      ....... ......:
    2b43:	3c 2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a     </h3>..</BR>....
    2b53:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    2b63:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    2b73:	55 44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d     UDP Server1 IP:.
    2b83:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2b93:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31     ext' name='UDP01
    2ba3:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2bb3:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2bc3:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2bd3:	6d 65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d     me='UDP02' size=
    2be3:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2bf3:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2c03:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2c13:	30 33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     03' size='3' val
    2c23:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2c33:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2c43:	6e 61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a     name='UDP04' siz
    2c53:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2c63:	27 3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70     '>..Port:...<inp
    2c73:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2c83:	61 6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20     ame='UDP0_Port' 
    2c93:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2ca3:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2cb3:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2cc3:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2cd3:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2ce3:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2cf3:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20     hod='GET'>..UDP 
    2d03:	53 65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69     Server2 IP:...<i
    2d13:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2d23:	20 6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69      name='UDP11' si
    2d33:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2d43:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2d53:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2d63:	55 44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20     UDP12' size='3' 
    2d73:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2d83:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2d93:	74 27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20     t' name='UDP13' 
    2da3:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2db3:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2dc3:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2dd3:	3d 27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33     ='UDP14' size='3
    2de3:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a     ' value='{{{'>..
    2df3:	50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74     Port:...<input t
    2e03:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2e13:	27 55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65     'UDP1_Port' size
    2e23:	3d 27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b     ='5' value='{{{{
    2e33:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2e43:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2e53:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2e63:	0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20     .</BR>....<form 
    2e73:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    2e83:	64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65     d='GET'>..UDP Se
    2e93:	72 76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70     rver3 IP:...<inp
    2ea3:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2eb3:	61 6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65     ame='UDP21' size
    2ec3:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2ed3:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    2ee3:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2ef3:	50 32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P22' size='3' va
    2f03:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    2f13:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2f23:	20 6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69      name='UDP23' si
    2f33:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2f43:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2f53:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2f63:	55 44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20     UDP24' size='3' 
    2f73:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f     value='{{{'>..Po
    2f83:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    2f93:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2fa3:	44 50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27     DP2_Port' size='
    2fb3:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    2fc3:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2fd3:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2fe3:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2ff3:	2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63     /BR>....<form ac
    3003:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    3013:	27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76     'GET'>..UDP Serv
    3023:	65 72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74     er4 IP:...<input
    3033:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    3043:	65 3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27     e='UDP31' size='
    3053:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    3063:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    3073:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    3083:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    3093:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    30a3:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    30b3:	61 6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65     ame='UDP33' size
    30c3:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    30d3:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    30e3:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    30f3:	50 33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P34' size='3' va
    3103:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74     lue='{{{'>..Port
    3113:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    3123:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    3133:	33 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27     3_Port' size='5'
    3143:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d      value='{{{{{'>.
    3153:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    3163:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    3173:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    3183:	52 3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a     R>.... </BODY>..
    3193:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

0000319d <network_IField>:
    319d:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    31ad:	00 00 14 12 06 00 00 00 08 20 01 00 00 00 08 0e     ......... ......
    31bd:	01 00 00 02 11 56 00 00 00 02 01 10 01 00 00 00     .....V..........
    31cd:	01 11 01 00 00 00 01 12 01 00 00 00 01 13 01 00     ................
    31dd:	00 00 01 14 01 00 00 00 01 15 01 00 00 00 01 16     ................
    31ed:	01 00 00 00 01 17 01 00 00 00 01 18 01 00 00 00     ................
    31fd:	01 19 01 00 00 00 01 1a 01 00 00 00 01 1b 01 00     ................
    320d:	00 00 01 1c 01 00 00 00 01 1d 01 00 00 00 01 1e     ................
    321d:	01 00 00 00 01 1f 01 00 00 00 01 42 01 00 00 00     ...........B....
    322d:	01 43 01 00 00 00 01 44 01 00 00 00 01 45 01 00     .C.....D.....E..
    323d:	00 00 08 2a 01 00 00 00 01 46 01 00 00 00 01 47     ...*.....F.....G
    324d:	01 00 00 00 01 48 01 00 00 00 01 49 01 00 00 00     .....H.....I....
    325d:	08 2c 01 00 00 00 01 4a 01 00 00 00 01 4b 01 00     .,.....J.....K..
    326d:	00 00 01 4c 01 00 00 00 01 4d 01 00 00 00 08 2e     ...L.....M......
    327d:	01 00 00 00 01 4e 01 00 00 00 01 4f 01 00 00 00     .....N.....O....
    328d:	01 50 01 00 00 00 01 51 01 00 00 00 08 30 01 00     .P.....Q.....0..
	...

0000329f <name_network>:
    329f:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

000032ac <Web_name_access_error>:
    32ac:	d3 33 00 00 00 00 00 00 1a 01 b9 32 00              .3.........2.

000032b9 <name_access_error_page>:
    32b9:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    32c9:	3c 54 49 54 4c 45 3e ce f8 e8 e1 ea e0 20 e4 ee     <TITLE>...... ..
    32d9:	f1 f2 f3 ef e0 3c 2f 54 49 54 4c 45 3e 0d 0a 3c     .....</TITLE>..<
    32e9:	6d 65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d     meta http-equiv=
    32f9:	22 43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63     "Content-Type" c
    3309:	6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d     ontent="text/htm
    3319:	6c 3b 20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f     l; charset=windo
    3329:	77 73 2d 31 32 35 31 22 3e 0d 0a 3c 2f 48 45 41     ws-1251">..</HEA
    3339:	44 3e 0d 0a 3c 63 65 6e 74 65 72 3e 0d 0a 3c 68     D>..<center>..<h
    3349:	65 61 64 3e 0d 0a 3c 68 33 3e c2 e0 f8 20 f3 f0     ead>..<h3>... ..
    3359:	ee e2 e5 ed fc 20 e4 ee f1 f2 f3 ef e0 20 ed e5     ..... ....... ..
    3369:	20 ef ee e7 e2 ee eb ff e5 f2 20 ef f0 ee f1 ec      ......... .....
    3379:	e0 f2 f0 e8 e2 e0 f2 fc 20 fd f2 f3 20 f1 f2 f0     ........ ... ...
    3389:	e0 ed e8 f6 f3 3c 2f 68 33 3e 0d 0a 3c 61 20 68     .....</h3>..<a h
    3399:	72 65 66 3d 22 69 6e 64 65 78 2e 68 74 6d 6c 22     ref="index.html"
    33a9:	3e cd e0 e7 e0 e4 20 ed e0 20 e3 eb e0 e2 ed f3     >..... .. ......
    33b9:	fe 20 f1 f2 f0 e0 ed e8 f6 f3 3c 2f 61 3e 0d 0a     . ........</a>..
    33c9:	3c 2f 68 74 6d 6c 3e 0d 0a 00                       </html>...

000033d3 <name_access_error>:
    33d3:	61 63 63 65 73 73 5f 65 72 72 6f 72 2e 68 74 6d     access_error.htm
    33e3:	6c 00                                               l.

000033e5 <Web_favicon>:
    33e5:	70 39 00 00 00 00 00 00 7e 05 f2 33 00              p9......~..3.

000033f2 <favicon>:
    33f2:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    3402:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    3412:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    3422:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    3432:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    3442:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    3452:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    3462:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    3472:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    3482:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    3492:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    34a2:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    34b2:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    34c2:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    382e:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    383e:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    384e:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    385e:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    386e:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    387e:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    388e:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    389e:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    38ae:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    38be:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    38ce:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    38de:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    38ee:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    38fe:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    390e:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    391e:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    392e:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00003970 <name_favicon>:
    3970:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

0000397c <Web_emeter>:
    397c:	47 45 53 43 1c 00 89 39 00 09 53 3a 02              GESC...9..S:.

00003989 <emeter_OField>:
    3989:	48 3a 38 3a 33 3a 23 3a 1d 3a 0d 3a 06 3a f6 39     H:8:3:#:.:.:.:.9
    3999:	ed 39 dd 39 b5 39 a5 39 d4 39 c4 39                 .9.9.9.9.9.9

000039a5 <Web_CurrDataPeriod>:
    39a5:	08 08 00 3c 00 00 00 ff ff 00 00 00 00 00 00 00     ...<............

000039b5 <var_CurrDataPeriod>:
    39b5:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

000039c4 <Web_AutoSend>:
    39c4:	01 0a 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

000039d4 <var_AutoSend>:
    39d4:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

000039dd <Web_EM_UART_StopBits>:
    39dd:	00 42 09 00 00 00 00 01 00 00 00 64 4b 00 00 00     .B.........dK...

000039ed <var_EM_UART_StopBits>:
    39ed:	53 74 6f 70 42 69 74 73 00                          StopBits.

000039f6 <Web_EM_UART_Parity>:
    39f6:	00 0c 06 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00003a06 <var_EM_UART_Parity>:
    3a06:	50 61 72 69 74 79 00                                Parity.

00003a0d <Web_EM_UART_BitQt>:
    3a0d:	00 72 0a 00 00 00 00 03 00 00 00 00 00 00 00 00     .r..............

00003a1d <var_EM_UART_BitQt>:
    3a1d:	42 69 74 51 74 00                                   BitQt.

00003a23 <Web_EM_UART_Rate>:
    3a23:	00 6b 0a 00 00 00 00 08 00 00 00 00 00 00 00 00     .k..............

00003a33 <var_EM_UART_Rate>:
    3a33:	52 61 74 65 00                                      Rate.

00003a38 <Web_EMeterType>:
    3a38:	01 29 00 00 00 00 00 04 00 00 00 90 4b 00 00 00     .)..........K...

00003a48 <var_EMeterType>:
    3a48:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

00003a53 <emeter_page>:
    3a53:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3a63:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3a73:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3a83:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3a93:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3aa3:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3ab3:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3ac3:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    3ad3:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    3ae3:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    3af3:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    3b03:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    3b13:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    3b23:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
    3b33:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3b43:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3b53:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3b63:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    3b73:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    3b83:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3b93:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    3ba3:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    3bb3:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    3bc3:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    3bd3:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    3be3:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    3bf3:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    3c03:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    3c13:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    3c23:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    3c33:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    3c43:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    3c53:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    3c63:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    3c73:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    3c83:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    3c93:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    3ca3:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    3cb3:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    3cc3:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42     {{{{ ....*...</B
    3cd3:	52 3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea     R>..<h3>... ....
    3ce3:	f2 f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33     ...........:</h3
    3cf3:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    3d03:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    3d13:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    3d23:	3d 22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d     ="EMeterType"> .
    3d33:	0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    3d43:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    3d53:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    3d63:	7b 7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26     {{{{{{{{>Landis&
    3d73:	47 79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     Gyr..<OPTION VAL
    3d83:	55 45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb     UE=2 {{{{{{{{>..
    3d93:	c2 c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     .....<OPTION VAL
    3da3:	55 45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5     UE=3 {{{{{{{{>..
    3db3:	f0 ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49     ......230..<OPTI
    3dc3:	4f 4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b     ON VALUE=4 {{{{{
    3dd3:	7b 7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d     {{{>..... ......
    3de3:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c     ..</SELECT> ...<
    3df3:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e03:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e13:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d     .</form>..</BR>.
    3e23:	0a 0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb     ...<h3>.........
    3e33:	20 52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68      RS232/RS485:</h
    3e43:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    3e53:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    3e63:	27 3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a     '>.............:
    3e73:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    3e83:	22 52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49     "Rate"> ...<OPTI
    3e93:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    3ea3:	7b 7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f     {{{>1200bps...<O
    3eb3:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b     PTION VALUE=1 {{
    3ec3:	7b 7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a     {{{{{{>2400bps..
    3ed3:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32     .<OPTION VALUE=2
    3ee3:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70      {{{{{{{{>4800bp
    3ef3:	73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     s...<OPTION VALU
    3f03:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30     E=3 {{{{{{{{>960
    3f13:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3f23:	41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=4 {{{{{{{{>
    3f33:	31 34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49     14400bps...<OPTI
    3f43:	4f 4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b     ON VALUE=5 {{{{{
    3f53:	7b 7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c     {{{>19200bps...<
    3f63:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b     OPTION VALUE=6 {
    3f73:	7b 7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73     {{{{{{{>28800bps
    3f83:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    3f93:	3d 37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30     =7 {{{{{{{{>3840
    3fa3:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3fb3:	41 4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=8 {{{{{{{{>
    3fc3:	35 37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c     57600bps...</SEL
    3fd3:	45 43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1     ECT>............
    3fe3:	f2 e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45     ... ...:...<SELE
    3ff3:	43 54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e     CT NAME="BitQt">
    4003:	20 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55      ...<OPTION VALU
    4013:	45 3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a     E=0 {{{{{{{{>5..
    4023:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4033:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f      {{{{{{{{>6...<O
    4043:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4053:	7b 7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49     {{{{{{>7...<OPTI
    4063:	4f 4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b     ON VALUE=3 {{{{{
    4073:	7b 7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{{>8...</SELECT
    4083:	3e 20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a     > .............:
    4093:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    40a3:	22 50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50     "Parity"> ...<OP
    40b3:	54 49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b     TION VALUE=0 {{{
    40c3:	7b 7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54     {{{{{>......<OPT
    40d3:	49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b     ION VALUE=1 {{{{
    40e3:	7b 7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f     {{{{>.........<O
    40f3:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    4103:	7b 7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d     {{{{{{>.........
    4113:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a     ..</SELECT> ....
    4123:	09 d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53     .....-....:...<S
    4133:	45 4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70     ELECT NAME="Stop
    4143:	42 69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Bits"> ...<OPTIO
    4153:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    4163:	7b 7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     {{>1...<OPTION V
    4173:	41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=1 {{{{{{{{>
    4183:	32 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a     2...</SELECT> ..
    4193:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    41a3:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    41b3:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    41c3:	42 52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1     BR>..<h3>..... .
    41d3:	f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42     .......:</h3></B
    41e3:	52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     R>..<form action
    41f3:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    4203:	27 3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d     '>...<SELECT NAM
    4213:	45 3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a     E="AutoSend"> ..
    4223:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    4233:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    4243:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    4253:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c      {{{{{{{{>.....<
    4263:	2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70     /SELECT> ...<inp
    4273:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    4283:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    4293:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    42a3:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    42b3:	47 45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d     GET'>.. ......:.
    42c3:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    42d3:	65 78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44     ext' name='CurrD
    42e3:	61 74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d     ataPeriod' size=
    42f3:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    4303:	27 3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75     '>.........<inpu
    4313:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    4323:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    4333:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42     orm>..</BR>..</B
    4343:	4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00     ODY>..</HTML>...

00004353 <emeter_IField>:
    4353:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    4363:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    4373:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    4383:	1e 29 00 23 45 00 1e 29 00 19 45 00 1e 29 00 0f     .).#E..)..E..)..
    4393:	45 00 1e 29 00 05 45 00 1e 29 00 fb 44 00 1d 6b     E..)..E..)..D..k
    43a3:	0a e9 44 00 1d 6b 0a d7 44 00 1d 6b 0a c5 44 00     ..D..k..D..k..D.
    43b3:	1d 6b 0a b3 44 00 1d 6b 0a a1 44 00 1d 6b 0a 8f     .k..D..k..D..k..
    43c3:	44 00 1d 6b 0a 7d 44 00 1d 6b 0a 6b 44 00 1d 6b     D..k.}D..k.kD..k
    43d3:	0a 59 44 00 1d 72 0a 51 44 00 1d 72 0a 49 44 00     .YD..r.QD..r.ID.
    43e3:	1d 72 0a 41 44 00 1d 72 0a 39 44 00 1d 0c 06 33     .r.AD..r.9D....3
    43f3:	44 00 1d 0c 06 2d 44 00 1d 0c 06 27 44 00 1d 42     D....-D....'D..B
    4403:	09 23 44 00 1d 42 09 1f 44 00 1e 0a 00 31 45 00     .#D..B..D....1E.
    4413:	1e 0a 00 2d 45 00 08 08 00 00 00 00                 ...-E.......

0000441f <STB_2_List>:
    441f:	3e 45 35 45                                         >E5E

00004423 <STB_1_List>:
    4423:	35 45 3e 45                                         5E>E

00004427 <PAR_O_List>:
    4427:	3e 45 3e 45 35 45                                   >E>E5E

0000442d <PAR_E_List>:
    442d:	3e 45 35 45 3e 45                                   >E5E>E

00004433 <PAR_N_List>:
    4433:	35 45 3e 45 3e 45                                   5E>E>E

00004439 <BIT8_List>:
    4439:	3e 45 3e 45 3e 45 35 45                             >E>E>E5E

00004441 <BIT7_List>:
    4441:	3e 45 3e 45 35 45 3e 45                             >E>E5E>E

00004449 <BIT6_List>:
    4449:	3e 45 35 45 3e 45 3e 45                             >E5E>E>E

00004451 <BIT5_List>:
    4451:	35 45 3e 45 3e 45 3e 45                             5E>E>E>E

00004459 <BR57600_List>:
    4459:	3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45     >E>E>E>E>E>E>E>E
    4469:	35 45                                               5E

0000446b <BR34800_List>:
    446b:	3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 35 45     >E>E>E>E>E>E>E5E
    447b:	3e 45                                               >E

0000447d <BR28800_List>:
    447d:	3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 35 45 3e 45     >E>E>E>E>E>E5E>E
    448d:	3e 45                                               >E

0000448f <BR19200_List>:
    448f:	3e 45 3e 45 3e 45 3e 45 3e 45 35 45 3e 45 3e 45     >E>E>E>E>E5E>E>E
    449f:	3e 45                                               >E

000044a1 <BR14400_List>:
    44a1:	3e 45 3e 45 3e 45 3e 45 35 45 3e 45 3e 45 3e 45     >E>E>E>E5E>E>E>E
    44b1:	3e 45                                               >E

000044b3 <BR9600_List>:
    44b3:	3e 45 3e 45 3e 45 35 45 3e 45 3e 45 3e 45 3e 45     >E>E>E5E>E>E>E>E
    44c3:	3e 45                                               >E

000044c5 <BR4800_List>:
    44c5:	3e 45 3e 45 35 45 3e 45 3e 45 3e 45 3e 45 3e 45     >E>E5E>E>E>E>E>E
    44d5:	3e 45                                               >E

000044d7 <BR2400_List>:
    44d7:	3e 45 35 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45     >E5E>E>E>E>E>E>E
    44e7:	3e 45                                               >E

000044e9 <BR1200_List>:
    44e9:	35 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45 3e 45     5E>E>E>E>E>E>E>E
    44f9:	3e 45                                               >E

000044fb <ELVIN_MODEM_List>:
    44fb:	3e 45 3e 45 3e 45 3e 45 35 45                       >E>E>E>E5E

00004505 <MERCURY_230_List>:
    4505:	3e 45 3e 45 3e 45 35 45 3e 45                       >E>E>E5E>E

0000450f <ELVIN_List>:
    450f:	3e 45 3e 45 35 45 3e 45 3e 45                       >E>E5E>E>E

00004519 <LANDIS_GYR_ZMR110_List>:
    4519:	3e 45 35 45 3e 45 3e 45 3e 45                       >E5E>E>E>E

00004523 <EM_NONE_List>:
    4523:	35 45 3e 45 3e 45 3e 45 3e 45                       5E>E>E>E>E

0000452d <ON_List>:
    452d:	3e 45 35 45                                         >E5E

00004531 <OFF_List>:
    4531:	35 45 3e 45                                         5E>E

00004535 <Selected_Str>:
    4535:	73 65 6c 65 63 74 65 64 00                          selected.

0000453e <Space_Str>:
    453e:	20 20 20 20 20 20 20 20 00                                  .

00004547 <name_emeter>:
    4547:	65 6d 65 74 65 72 2e 68 74 6d 6c 00                 emeter.html.

00004553 <Web_index>:
    4553:	86 48 4a 48 00 00 00 00 ea 02 60 45 00              .HJH......`E.

00004560 <index_page>:
    4560:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4570:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4580:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4590:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    45a0:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    45b0:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    45c0:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    45d0:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    45e0:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    45f0:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    4600:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    4610:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    4620:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    4630:	09 53 57 3a 20 34 2e 30 31 3c 2f 42 52 3e 0d 0a     .SW: 4.01</BR>..
    4640:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4650:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4660:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    4670:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    4680:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    4690:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    46a0:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    46b0:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    46c0:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    46d0:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    46e0:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    46f0:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    4700:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    4710:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    4720:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    4730:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    4740:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    4750:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    4760:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    4770:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    4780:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    4790:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    47a0:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    47b0:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    47c0:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    47d0:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 68 33     {{{{ ....*...<h3
    47e0:	3e d3 f0 ee e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0     >....... .......
    47f0:	3a 3c 2f 68 33 3e 0d 0a 20 7b 7b 20 28 30 2d 33     :</h3>.. {{ (0-3
    4800:	31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e cd e0 f0     1)</BR>..<h3>...
    4810:	e0 e1 ee f2 ea e0 20 3a 3c 2f 68 33 3e 0d 0a 7b     ...... :</h3>..{
    4820:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a     {{{{{{{{{{ .....
    4830:	3c 2f 42 52 3e 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     </BR>..</BODY>..
    4840:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

0000484a <index_IField>:
    484a:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    485a:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    486a:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    487a:	00 25 06 00 00 00 10 63 09 00 00 02                 .%.....c....

00004886 <name_index>:
    4886:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

00004891 <Web_login>:
    4891:	a0 4b b8 4a 08 00 9e 48 e3 01 d5 48 00              .K.J...H...H.

0000489e <vars_loginOField>:
    489e:	cf 48 bf 48 b6 48 a6 48                             .H.H.H.H

000048a6 <Web_PasswOF>:
    48a6:	21 f4 05 00 00 00 00 02 00 00 00 fd 28 00 00 0b     !...........(...

000048b6 <vars_Passw>:
    48b6:	70 61 73 73 77 6f 72 64 00                          password.

000048bf <Web_LoginOF>:
    48bf:	21 f7 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !...............

000048cf <vars_Login>:
    48cf:	6c 6f 67 69 6e 00                                   login.

000048d5 <login_page>:
    48d5:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    48e5:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    48f5:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4905:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    4915:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    4925:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    4935:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    4945:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    4955:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
    4965:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
    4975:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4985:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    4995:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49a5:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
    49b5:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
    49c5:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
    49d5:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    49e5:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
    49f5:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
    4a05:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
    4a15:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
    4a25:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
    4a35:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
    4a45:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
    4a55:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
    4a65:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
    4a75:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    4a85:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    4a95:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
    4aa5:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
    4ab5:	0d 0a 00                                            ...

00004ab8 <login_InField>:
    4ab8:	22 0f 00 00 00 15 1d 09 06 d0 4a 00 07 27 0b 00     ".........J..'..
    4ac8:	00 00 14 12 06 00 00 00                             ........

00004ad0 <Web_LoginMsg_List>:
    4ad0:	6e 4b 3c 4b 0a 4b d8 4a                             nK<K.K.J

00004ad8 <Login_PSW_Str>:
    4ad8:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
    4ae8:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
    4af8:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b08:	20 00                                                .

00004b0a <Login_Login_Str>:
    4b0a:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
    4b1a:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
    4b2a:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b3a:	20 00                                                .

00004b3c <Login_Busy_Str>:
    4b3c:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
    4b4c:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
    4b5c:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
    4b6c:	2e 00                                               ..

00004b6e <Login_Welcome_Str>:
    4b6e:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
    4b7e:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
    4b8e:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
    4b9e:	20 00                                                .

00004ba0 <name_login>:
    4ba0:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

00004bab <METHOD_POST>:
    4bab:	50 4f 53 54 20 2f 00                                POST /.

00004bb2 <METHOD_GET>:
    4bb2:	47 45 54 20 2f 00                                   GET /.

00004bb8 <Web_error_page>:
	...
    4bc0:	75 00 c5 4b 00                                      u..K.

00004bc5 <error_page>:
    4bc5:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    4bd5:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
    4be5:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
    4bf5:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
    4c05:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
    4c15:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
    4c25:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
    4c35:	2f 68 31 3e 00                                      /h1>.

00004c3a <SESSID_pstr>:
    4c3a:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00004c43 <inputSESSID_Str>:
    4c43:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
    4c53:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
    4c63:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

00004c6e <Connection_Close>:
    4c6e:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    4c7e:	65 0d 0a 0d 0a 00                                   e.....

00004c84 <jpeg_str>:
    4c84:	6a 70 65 67 00                                      jpeg.

00004c89 <gif_str>:
    4c89:	67 69 66 00                                         gif.

00004c8d <ico_str>:
    4c8d:	69 63 6f 00                                         ico.

00004c91 <html_str>:
    4c91:	68 74 6d 6c 00                                      html.

00004c96 <image_str>:
    4c96:	69 6d 61 67 65 2f 00                                image/.

00004c9d <html_cp1251_str>:
    4c9d:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
    4cad:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
    4cbd:	0a 00                                               ..

00004cbf <Content_Length>:
    4cbf:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    4ccf:	3a 20 00                                            : .

00004cd2 <Content_Type>:
    4cd2:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

00004ce1 <HTTP_200_OK>:
    4ce1:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    4cf1:	0a 00                                               ..

00004cf3 <MsgErr41>:
    4cf3:	29                                                  )

00004cf4 <TestMsg_str>:
    4cf4:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
    4d04:	e8 e5 00                                            ...

00004d07 <MB_Master_List>:
    4d07:	00 00 00                                            ...

00004d0a <DO_M>:
    4d0a:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004d19 <DI_M>:
    4d19:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4d29:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004d39 <AT_ATH>:
    4d39:	41 54 48 00                                         ATH.

00004d3d <AT_ATA>:
    4d3d:	41 54 41 00                                         ATA.

00004d41 <AT_CSQ>:
    4d41:	41 54 2b 43 53 51 00                                AT+CSQ.

00004d48 <AT_CGATT_0>:
    4d48:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

00004d53 <AT_CIPSHUT>:
    4d53:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

00004d5e <AT_CIPCLOSE>:
    4d5e:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00004d6c <AT_CIPCLOSE_1>:
    4d6c:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00004d7c <AT_CIPSEND>:
    4d7c:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00004d88 <AT_ATO>:
    4d88:	41 54 4f 00                                         ATO.

00004d8c <AT_CIPSTATUS>:
    4d8c:	41 54 2b 43 49 50 53 54 41 54 55 53 00              AT+CIPSTATUS.

00004d99 <AT_SERVERCLOSE>:
    4d99:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00004da8 <AT_CIPSERVER>:
    4da8:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00004db8 <AT_CIPSTART_TCP>:
    4db8:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
    4dc8:	22 2c 00                                            ",.

00004dcb <AT_CIPSTART>:
    4dcb:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
    4ddb:	44 50 22 2c 00                                      DP",.

00004de0 <AT_CIFSR>:
    4de0:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00004de9 <AT_CIICR>:
    4de9:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00004df2 <AT_CSTT>:
    4df2:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00004dfa <AT_CIPCSGP>:
    4dfa:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00004e09 <AT_CGATT>:
    4e09:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00004e14 <AT_CIPTKA>:
    4e14:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
    4e24:	30 2c 31 00                                         0,1.

00004e28 <AT_CIPMUX_0>:
    4e28:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00004e34 <AT_CIPMODE_1>:
    4e34:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00004e41 <AT_CMGS>:
    4e41:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

00004e4c <AT_CSMP>:
    4e4c:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
    4e5c:	2c 30 00                                            ,0.

00004e5f <AT_CMGF>:
    4e5f:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

00004e69 <AT_CLIP>:
    4e69:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00004e73 <AT_CGMM>:
    4e73:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00004e7b <AT_E0>:
    4e7b:	41 54 45 30 00                                      ATE0.

00004e80 <AT_W>:
    4e80:	41 54 26 57 00                                      AT&W.

00004e85 <AT_IPR9600>:
    4e85:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00004e91 <AT_AT>:
    4e91:	41 54 00                                            AT.

00004e94 <ESC_SEQ>:
    4e94:	2b 2b 2b 00                                         +++.

00004e98 <RESP_STATE_CONNECT_OK>:
    4e98:	53 54 41 54 45 3a 20 43 4f 4e 4e 45 43 54 20 4f     STATE: CONNECT O
    4ea8:	4b 00                                               K.

00004eaa <RESP_CONNECT_9600>:
    4eaa:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00004eb7 <RESP_SHUT_OK>:
    4eb7:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00004ebf <RESP_CSQ>:
    4ebf:	2b 43 53 51 3a 00                                   +CSQ:.

00004ec5 <RESP_CLOSE_OK_FAST>:
    4ec5:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00004ed1 <RESP_CLOSE_OK>:
    4ed1:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00004eda <RESP_SEND_OK>:
    4eda:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00004ee5 <RESP_SERVER_CLOSE>:
    4ee5:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00004ef2 <RESP_SERVER_OK>:
    4ef2:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00004efc <RESP_CONNECT_OK>:
    4efc:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00004f0a <RESP_CONNECT>:
    4f0a:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f12 <RESP_OK>:
    4f12:	4f 4b 00                                            OK.

00004f15 <URC_NO_CARRIER>:
    4f15:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00004f20 <URC_RING>:
    4f20:	52 49 4e 47 00                                      RING.

00004f25 <URC_PDPDEACT>:
    4f25:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

00004f30 <URC_CLOSED>:
    4f30:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

00004f39 <URC_RECEIVE>:
    4f39:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

00004f43 <URC_CONNECT>:
    4f43:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f4b <URC_REMOTE_IP>:
    4f4b:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

00004f55 <URC_SMS_READY>:
    4f55:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00004f5f <URC_CALL_READY>:
    4f5f:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

00004f6a <URC_RDY>:
    4f6a:	52 44 59 00                                         RDY.

00004f6e <GSM_SIMCOM_SIM800>:
    4f6e:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00004f7c <GSM_SIMCOM_SIM900R>:
    4f7c:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00004f8b <MB_Timer>:
    4f8b:	52 00 51 00 28 28 44 00 43 00 2e 28                 R.Q.((D.C..(

00004f97 <MB_Port>:
    4f97:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 20 28 25 28     ............ (%(
    4fa7:	26 28 27 28                                         &('(

00004fab <BR_Tbl>:
    4fab:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
    4fbb:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00004fc6 <Modbus_Map>:
    4fc6:	df 03 08 00 f6 03 08 00 7c 08 2c 00 78 0a 1e 00     ........|.,.x...

00004fd6 <MB_Role>:
	...

00004fd7 <__c.2299>:
    4fd7:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00004fe4 <__ctors_end>:
    4fe4:	11 24       	eor	r1, r1
    4fe6:	1f be       	out	0x3f, r1	; 63
    4fe8:	cf ef       	ldi	r28, 0xFF	; 255
    4fea:	d0 e1       	ldi	r29, 0x10	; 16
    4fec:	de bf       	out	0x3e, r29	; 62
    4fee:	cd bf       	out	0x3d, r28	; 61

00004ff0 <__do_copy_data>:
    4ff0:	12 e0       	ldi	r17, 0x02	; 2
    4ff2:	a0 e0       	ldi	r26, 0x00	; 0
    4ff4:	b1 e0       	ldi	r27, 0x01	; 1
    4ff6:	e0 e7       	ldi	r30, 0x70	; 112
    4ff8:	fa ee       	ldi	r31, 0xEA	; 234
    4ffa:	00 e0       	ldi	r16, 0x00	; 0
    4ffc:	0b bf       	out	0x3b, r16	; 59
    4ffe:	02 c0       	rjmp	.+4      	; 0x5004 <__do_copy_data+0x14>
    5000:	07 90       	elpm	r0, Z+
    5002:	0d 92       	st	X+, r0
    5004:	aa 33       	cpi	r26, 0x3A	; 58
    5006:	b1 07       	cpc	r27, r17
    5008:	d9 f7       	brne	.-10     	; 0x5000 <__do_copy_data+0x10>

0000500a <__do_clear_bss>:
    500a:	2e e0       	ldi	r18, 0x0E	; 14
    500c:	aa e3       	ldi	r26, 0x3A	; 58
    500e:	b2 e0       	ldi	r27, 0x02	; 2
    5010:	01 c0       	rjmp	.+2      	; 0x5014 <.do_clear_bss_start>

00005012 <.do_clear_bss_loop>:
    5012:	1d 92       	st	X+, r1

00005014 <.do_clear_bss_start>:
    5014:	ac 34       	cpi	r26, 0x4C	; 76
    5016:	b2 07       	cpc	r27, r18
    5018:	e1 f7       	brne	.-8      	; 0x5012 <.do_clear_bss_loop>
    501a:	0e 94 27 6b 	call	0xd64e	; 0xd64e <main>
    501e:	0c 94 b0 6b 	jmp	0xd760	; 0xd760 <exit>

00005022 <__bad_interrupt>:
    5022:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00005026 <rrb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
	return *addr;
}
    5026:	fc 01       	movw	r30, r24
    5028:	80 81       	ld	r24, Z
    502a:	08 95       	ret

0000502c <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    502c:	fc 01       	movw	r30, r24
    502e:	84 91       	lpm	r24, Z
}
    5030:	08 95       	ret

00005032 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    5032:	a0 e0       	ldi	r26, 0x00	; 0
    5034:	b0 e0       	ldi	r27, 0x00	; 0
    5036:	11 96       	adiw	r26, 0x01	; 1
}
    5038:	ab bf       	out	0x3b, r26	; 59
    503a:	fc 01       	movw	r30, r24
    503c:	87 91       	elpm	r24, Z+
    503e:	08 95       	ret

00005040 <RS485_1>:
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
}

void RS485_0(void) {}
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5040:	82 b3       	in	r24, 0x12	; 18
    5042:	90 e1       	ldi	r25, 0x10	; 16
    5044:	89 27       	eor	r24, r25
    5046:	82 bb       	out	0x12, r24	; 18
    5048:	08 95       	ret

0000504a <MB_LED1>:

void MB_LED0(void) {}
void MB_LED1(void) {}
    504a:	08 95       	ret

0000504c <MB_LED_Err_On_1>:

void MB_LED_Err_On_0(void)	{}
void MB_LED_Err_Off_0(void)	{}
void MB_LED_Err_On_1(void)	{}
    504c:	08 95       	ret

0000504e <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    504e:	08 95       	ret

00005050 <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    5050:	8f e0       	ldi	r24, 0x0F	; 15
    5052:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    5054:	87 b7       	in	r24, 0x37	; 55
    5056:	82 60       	ori	r24, 0x02	; 2
    5058:	87 bf       	out	0x37, r24	; 55
    505a:	08 95       	ret

0000505c <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    505c:	8d e0       	ldi	r24, 0x0D	; 13
    505e:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    5060:	87 b7       	in	r24, 0x37	; 55
    5062:	80 68       	ori	r24, 0x80	; 128
    5064:	87 bf       	out	0x37, r24	; 55
    5066:	08 95       	ret

00005068 <MB_Timer_ISR>:
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5068:	60 e0       	ldi	r22, 0x00	; 0
    506a:	76 e0       	ldi	r23, 0x06	; 6
    506c:	26 2f       	mov	r18, r22
    506e:	30 e0       	ldi	r19, 0x00	; 0
    5070:	72 9f       	mul	r23, r18
    5072:	f0 01       	movw	r30, r0
    5074:	73 9f       	mul	r23, r19
    5076:	f0 0d       	add	r31, r0
    5078:	11 24       	eor	r1, r1
    507a:	e5 57       	subi	r30, 0x75	; 117
    507c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    507e:	45 91       	lpm	r20, Z+
    5080:	54 91       	lpm	r21, Z
    5082:	e6 2f       	mov	r30, r22
    5084:	f0 e0       	ldi	r31, 0x00	; 0
    5086:	84 17       	cp	r24, r20
    5088:	95 07       	cpc	r25, r21
    508a:	11 f0       	breq	.+4      	; 0x5090 <MB_Timer_ISR+0x28>
    508c:	6f 5f       	subi	r22, 0xFF	; 255
    508e:	ee cf       	rjmp	.-36     	; 0x506c <MB_Timer_ISR+0x4>

	
	switch (prb(MB_Role+MB_N)){
    5090:	ea 52       	subi	r30, 0x2A	; 42
    5092:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5094:	e4 91       	lpm	r30, Z
    5096:	ee 23       	and	r30, r30
    5098:	19 f0       	breq	.+6      	; 0x50a0 <MB_Timer_ISR+0x38>
    509a:	e1 30       	cpi	r30, 0x01	; 1
    509c:	f9 f0       	breq	.+62     	; 0x50dc <MB_Timer_ISR+0x74>
    509e:	08 95       	ret
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    50a0:	f2 2f       	mov	r31, r18
    50a2:	ee 27       	eor	r30, r30
    50a4:	e8 5b       	subi	r30, 0xB8	; 184
    50a6:	f2 4f       	sbci	r31, 0xF2	; 242
    50a8:	90 81       	ld	r25, Z
    50aa:	f9 01       	movw	r30, r18
    50ac:	e8 50       	subi	r30, 0x08	; 8
    50ae:	fc 4f       	sbci	r31, 0xFC	; 252
    50b0:	80 81       	ld	r24, Z
    50b2:	98 17       	cp	r25, r24
    50b4:	99 f0       	breq	.+38     	; 0x50dc <MB_Timer_ISR+0x74>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    50b6:	f9 01       	movw	r30, r18
    50b8:	ef 51       	subi	r30, 0x1F	; 31
    50ba:	fc 4f       	sbci	r31, 0xFC	; 252
    50bc:	81 e0       	ldi	r24, 0x01	; 1
    50be:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    50c0:	f9 01       	movw	r30, r18
    50c2:	84 e0       	ldi	r24, 0x04	; 4
    50c4:	ee 0f       	add	r30, r30
    50c6:	ff 1f       	adc	r31, r31
    50c8:	8a 95       	dec	r24
    50ca:	e1 f7       	brne	.-8      	; 0x50c4 <MB_Timer_ISR+0x5c>
    50cc:	e7 5d       	subi	r30, 0xD7	; 215
    50ce:	f4 4f       	sbci	r31, 0xF4	; 244
    50d0:	80 81       	ld	r24, Z
    50d2:	91 81       	ldd	r25, Z+1	; 0x01
    50d4:	01 96       	adiw	r24, 0x01	; 1
    50d6:	91 83       	std	Z+1, r25	; 0x01
    50d8:	80 83       	st	Z, r24
    50da:	08 95       	ret
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    50dc:	30 91 13 0b 	lds	r19, 0x0B13
    50e0:	81 e0       	ldi	r24, 0x01	; 1
    50e2:	90 e0       	ldi	r25, 0x00	; 0
    50e4:	02 2e       	mov	r0, r18
    50e6:	01 c0       	rjmp	.+2      	; 0x50ea <MB_Timer_ISR+0x82>
    50e8:	88 0f       	add	r24, r24
    50ea:	0a 94       	dec	r0
    50ec:	ea f7       	brpl	.-6      	; 0x50e8 <MB_Timer_ISR+0x80>
    50ee:	38 2b       	or	r19, r24
    50f0:	30 93 13 0b 	sts	0x0B13, r19
    50f4:	08 95       	ret

000050f6 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    50f6:	28 2f       	mov	r18, r24
    50f8:	30 e0       	ldi	r19, 0x00	; 0
    50fa:	94 e1       	ldi	r25, 0x14	; 20
    50fc:	89 9f       	mul	r24, r25
    50fe:	f0 01       	movw	r30, r0
    5100:	11 24       	eor	r1, r1
    5102:	e7 56       	subi	r30, 0x67	; 103
    5104:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5106:	a5 91       	lpm	r26, Z+
    5108:	b4 91       	lpm	r27, Z
    510a:	9c 91       	ld	r25, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    510c:	f9 01       	movw	r30, r18
    510e:	e7 52       	subi	r30, 0x27	; 39
    5110:	f7 4f       	sbci	r31, 0xF7	; 247
    5112:	40 81       	ld	r20, Z
    5114:	51 e0       	ldi	r21, 0x01	; 1
    5116:	54 0f       	add	r21, r20
    5118:	50 83       	st	Z, r21
    511a:	54 e1       	ldi	r21, 0x14	; 20
    511c:	52 9f       	mul	r21, r18
    511e:	f0 01       	movw	r30, r0
    5120:	53 9f       	mul	r21, r19
    5122:	f0 0d       	add	r31, r0
    5124:	11 24       	eor	r1, r1
    5126:	e9 56       	subi	r30, 0x69	; 105
    5128:	f0 4b       	sbci	r31, 0xB0	; 176
    512a:	a5 91       	lpm	r26, Z+
    512c:	b4 91       	lpm	r27, Z
    512e:	5c 91       	ld	r21, X
    5130:	f2 2f       	mov	r31, r18
    5132:	ee 27       	eor	r30, r30
    5134:	e4 0f       	add	r30, r20
    5136:	f1 1d       	adc	r31, r1
    5138:	e8 5b       	subi	r30, 0xB8	; 184
    513a:	f2 4f       	sbci	r31, 0xF2	; 242
    513c:	50 83       	st	Z, r21
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    513e:	93 ff       	sbrs	r25, 3
    5140:	0e c0       	rjmp	.+28     	; 0x515e <MBRecept+0x68>
		MB_CPT[MB_N][7]++;
    5142:	f9 01       	movw	r30, r18
    5144:	24 e0       	ldi	r18, 0x04	; 4
    5146:	ee 0f       	add	r30, r30
    5148:	ff 1f       	adc	r31, r31
    514a:	2a 95       	dec	r18
    514c:	e1 f7       	brne	.-8      	; 0x5146 <MBRecept+0x50>
    514e:	e7 5d       	subi	r30, 0xD7	; 215
    5150:	f4 4f       	sbci	r31, 0xF4	; 244
    5152:	26 85       	ldd	r18, Z+14	; 0x0e
    5154:	37 85       	ldd	r19, Z+15	; 0x0f
    5156:	2f 5f       	subi	r18, 0xFF	; 255
    5158:	3f 4f       	sbci	r19, 0xFF	; 255
    515a:	37 87       	std	Z+15, r19	; 0x0f
    515c:	26 87       	std	Z+14, r18	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    515e:	9c 71       	andi	r25, 0x1C	; 28
    5160:	59 f0       	breq	.+22     	; 0x5178 <MBRecept+0x82>
		MB_Err |=(1<<MB_N);
    5162:	21 e0       	ldi	r18, 0x01	; 1
    5164:	30 e0       	ldi	r19, 0x00	; 0
    5166:	01 c0       	rjmp	.+2      	; 0x516a <MBRecept+0x74>
    5168:	22 0f       	add	r18, r18
    516a:	8a 95       	dec	r24
    516c:	ea f7       	brpl	.-6      	; 0x5168 <MBRecept+0x72>
    516e:	80 91 6b 02 	lds	r24, 0x026B
    5172:	82 2b       	or	r24, r18
    5174:	80 93 6b 02 	sts	0x026B, r24
    5178:	08 95       	ret

0000517a <GetSlave>:

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    517a:	43 e0       	ldi	r20, 0x03	; 3
    517c:	84 9f       	mul	r24, r20
    517e:	f0 01       	movw	r30, r0
    5180:	11 24       	eor	r1, r1
    5182:	e9 5f       	subi	r30, 0xF9	; 249
    5184:	f2 4b       	sbci	r31, 0xB2	; 178
    5186:	25 91       	lpm	r18, Z+
    5188:	34 91       	lpm	r19, Z
    518a:	e8 2f       	mov	r30, r24
    518c:	f0 e0       	ldi	r31, 0x00	; 0
    518e:	ea 5f       	subi	r30, 0xFA	; 250
    5190:	f9 4f       	sbci	r31, 0xF9	; 249
    5192:	80 81       	ld	r24, Z
}
    5194:	a9 01       	movw	r20, r18
    5196:	64 e0       	ldi	r22, 0x04	; 4
    5198:	86 9f       	mul	r24, r22
    519a:	40 0d       	add	r20, r0
    519c:	51 1d       	adc	r21, r1
    519e:	11 24       	eor	r1, r1
    51a0:	ca 01       	movw	r24, r20
    51a2:	08 95       	ret

000051a4 <DI_Init_Hard>:
static T_DI_M DI_M[] PROGMEM = DI_Map_Own;

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
    51a4:	89 e1       	ldi	r24, 0x19	; 25
    51a6:	9d e4       	ldi	r25, 0x4D	; 77
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    51a8:	f8 94       	cli
    51aa:	fc 01       	movw	r30, r24
    51ac:	a5 91       	lpm	r26, Z+
    51ae:	b4 91       	lpm	r27, Z
    51b0:	ac 01       	movw	r20, r24
    51b2:	4a 5f       	subi	r20, 0xFA	; 250
    51b4:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51b6:	fa 01       	movw	r30, r20
    51b8:	34 91       	lpm	r19, Z
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    51ba:	30 95       	com	r19
    51bc:	2c 91       	ld	r18, X
    51be:	23 23       	and	r18, r19
    51c0:	2c 93       	st	X, r18
    51c2:	9c 01       	movw	r18, r24
    51c4:	2e 5f       	subi	r18, 0xFE	; 254
    51c6:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    51c8:	f9 01       	movw	r30, r18
    51ca:	a5 91       	lpm	r26, Z+
    51cc:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51ce:	fa 01       	movw	r30, r20
    51d0:	44 91       	lpm	r20, Z
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    51d2:	2c 91       	ld	r18, X
    51d4:	24 2b       	or	r18, r20
    51d6:	2c 93       	st	X, r18
		sei();
    51d8:	78 94       	sei
    51da:	08 96       	adiw	r24, 0x08	; 8

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    51dc:	fd e4       	ldi	r31, 0x4D	; 77
    51de:	89 33       	cpi	r24, 0x39	; 57
    51e0:	9f 07       	cpc	r25, r31
    51e2:	11 f7       	brne	.-60     	; 0x51a8 <DI_Init_Hard+0x4>
		cli();
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
		sei();
	}
}
    51e4:	08 95       	ret

000051e6 <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    51e6:	f8 94       	cli
    51e8:	ff cf       	rjmp	.-2      	; 0x51e8 <Reboot+0x2>

000051ea <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    51ea:	8a e5       	ldi	r24, 0x5A	; 90
    51ec:	80 93 27 06 	sts	0x0627, r24
    51f0:	08 95       	ret

000051f2 <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    51f2:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    51f4:	e0 e0       	ldi	r30, 0x00	; 0
    51f6:	ff ef       	ldi	r31, 0xFF	; 255
    51f8:	09 94       	ijmp

000051fa <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    51fa:	81 e0       	ldi	r24, 0x01	; 1
    51fc:	80 93 3a 08 	sts	0x083A, r24
    5200:	08 95       	ret

00005202 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5202:	0c 94 59 73 	jmp	0xe6b2	; 0xe6b2 <__eerd_byte_m128>

00005206 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5206:	0f 93       	push	r16
    5208:	1f 93       	push	r17
    520a:	cf 93       	push	r28
    520c:	df 93       	push	r29
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    520e:	c8 2f       	mov	r28, r24
    5210:	d0 e0       	ldi	r29, 0x00	; 0
    5212:	fe 01       	movw	r30, r28
    5214:	ee 5d       	subi	r30, 0xDE	; 222
    5216:	f9 4f       	sbci	r31, 0xF9	; 249
    5218:	90 81       	ld	r25, Z
    521a:	92 30       	cpi	r25, 0x02	; 2
    521c:	09 f1       	breq	.+66     	; 0x5260 <GetReg+0x5a>
    521e:	fe 01       	movw	r30, r28
    5220:	a4 e0       	ldi	r26, 0x04	; 4
    5222:	ee 0f       	add	r30, r30
    5224:	ff 1f       	adc	r31, r31
    5226:	aa 95       	dec	r26
    5228:	e1 f7       	brne	.-8      	; 0x5222 <GetReg+0x1c>
    522a:	e2 53       	subi	r30, 0x32	; 50
    522c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    522e:	05 91       	lpm	r16, Z+
    5230:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    5232:	0e 94 bd 28 	call	0x517a	; 0x517a <GetSlave>
    5236:	01 96       	adiw	r24, 0x01	; 1
    5238:	fc 01       	movw	r30, r24
    523a:	85 91       	lpm	r24, Z+
    523c:	94 91       	lpm	r25, Z
    523e:	c3 5f       	subi	r28, 0xF3	; 243
    5240:	d9 4f       	sbci	r29, 0xF9	; 249
    5242:	28 81       	ld	r18, Y
    5244:	fc 01       	movw	r30, r24
    5246:	37 e0       	ldi	r19, 0x07	; 7
    5248:	23 9f       	mul	r18, r19
    524a:	e0 0d       	add	r30, r0
    524c:	f1 1d       	adc	r31, r1
    524e:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5250:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5252:	85 91       	lpm	r24, Z+
    5254:	94 91       	lpm	r25, Z
    5256:	88 0f       	add	r24, r24
    5258:	99 1f       	adc	r25, r25
    525a:	80 0f       	add	r24, r16
    525c:	91 1f       	adc	r25, r17
    525e:	09 c0       	rjmp	.+18     	; 0x5272 <GetReg+0x6c>
    5260:	73 e0       	ldi	r23, 0x03	; 3
    5262:	cc 0f       	add	r28, r28
    5264:	dd 1f       	adc	r29, r29
    5266:	7a 95       	dec	r23
    5268:	e1 f7       	brne	.-8      	; 0x5262 <GetReg+0x5c>
    526a:	cd 59       	subi	r28, 0x9D	; 157
    526c:	dd 4f       	sbci	r29, 0xFD	; 253
    526e:	8e 81       	ldd	r24, Y+6	; 0x06
    5270:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5272:	df 91       	pop	r29
    5274:	cf 91       	pop	r28
    5276:	1f 91       	pop	r17
    5278:	0f 91       	pop	r16
    527a:	08 95       	ret

0000527c <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    527c:	fc 01       	movw	r30, r24
    527e:	65 91       	lpm	r22, Z+
    5280:	75 91       	lpm	r23, Z+
    5282:	85 91       	lpm	r24, Z+
    5284:	94 91       	lpm	r25, Z
}
    5286:	08 95       	ret

00005288 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    5288:	8f 92       	push	r8
    528a:	9f 92       	push	r9
    528c:	af 92       	push	r10
    528e:	bf 92       	push	r11
    5290:	cf 92       	push	r12
    5292:	df 92       	push	r13
    5294:	ef 92       	push	r14
    5296:	ff 92       	push	r15
    5298:	0f 93       	push	r16
    529a:	1f 93       	push	r17
    529c:	cf 93       	push	r28
    529e:	df 93       	push	r29
    52a0:	00 d0       	rcall	.+0      	; 0x52a2 <CRC_Seed+0x1a>
    52a2:	00 d0       	rcall	.+0      	; 0x52a4 <CRC_Seed+0x1c>
    52a4:	cd b7       	in	r28, 0x3d	; 61
    52a6:	de b7       	in	r29, 0x3e	; 62
    52a8:	4c 01       	movw	r8, r24
    52aa:	5b 01       	movw	r10, r22
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52ac:	c1 2c       	mov	r12, r1
    52ae:	d1 2c       	mov	r13, r1
    52b0:	76 01       	movw	r14, r12
    52b2:	c2 16       	cp	r12, r18
    52b4:	d3 06       	cpc	r13, r19
    52b6:	e4 06       	cpc	r14, r20
    52b8:	f5 06       	cpc	r15, r21
    52ba:	f9 f0       	breq	.+62     	; 0x52fa <CRC_Seed+0x72>
    52bc:	c5 01       	movw	r24, r10
    52be:	8c 0d       	add	r24, r12
    52c0:	9d 1d       	adc	r25, r13
		uint8_t j = CRCLo^GetByte(Block+i);
    52c2:	29 83       	std	Y+1, r18	; 0x01
    52c4:	3a 83       	std	Y+2, r19	; 0x02
    52c6:	4b 83       	std	Y+3, r20	; 0x03
    52c8:	5c 83       	std	Y+4, r21	; 0x04
    52ca:	f4 01       	movw	r30, r8
    52cc:	09 95       	icall
    52ce:	80 27       	eor	r24, r16
		CRCLo = CRCHi^prb(aCRCHi+j);
    52d0:	68 2f       	mov	r22, r24
    52d2:	70 e0       	ldi	r23, 0x00	; 0
    52d4:	fb 01       	movw	r30, r22
    52d6:	e2 58       	subi	r30, 0x82	; 130
    52d8:	fb 4f       	sbci	r31, 0xFB	; 251

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52da:	04 91       	lpm	r16, Z
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    52dc:	01 27       	eor	r16, r17
		CRCHi = prb(aCRCLo+j);
    52de:	fb 01       	movw	r30, r22
    52e0:	e2 58       	subi	r30, 0x82	; 130
    52e2:	fc 4f       	sbci	r31, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52e4:	14 91       	lpm	r17, Z
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52e6:	ff ef       	ldi	r31, 0xFF	; 255
    52e8:	cf 1a       	sub	r12, r31
    52ea:	df 0a       	sbc	r13, r31
    52ec:	ef 0a       	sbc	r14, r31
    52ee:	ff 0a       	sbc	r15, r31
    52f0:	5c 81       	ldd	r21, Y+4	; 0x04
    52f2:	4b 81       	ldd	r20, Y+3	; 0x03
    52f4:	3a 81       	ldd	r19, Y+2	; 0x02
    52f6:	29 81       	ldd	r18, Y+1	; 0x01
    52f8:	dc cf       	rjmp	.-72     	; 0x52b2 <CRC_Seed+0x2a>
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
    52fa:	80 2f       	mov	r24, r16
    52fc:	90 e0       	ldi	r25, 0x00	; 0
}
    52fe:	91 2b       	or	r25, r17
    5300:	0f 90       	pop	r0
    5302:	0f 90       	pop	r0
    5304:	0f 90       	pop	r0
    5306:	0f 90       	pop	r0
    5308:	df 91       	pop	r29
    530a:	cf 91       	pop	r28
    530c:	1f 91       	pop	r17
    530e:	0f 91       	pop	r16
    5310:	ff 90       	pop	r15
    5312:	ef 90       	pop	r14
    5314:	df 90       	pop	r13
    5316:	cf 90       	pop	r12
    5318:	bf 90       	pop	r11
    531a:	af 90       	pop	r10
    531c:	9f 90       	pop	r9
    531e:	8f 90       	pop	r8
    5320:	08 95       	ret

00005322 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    5322:	0f 93       	push	r16
    5324:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    5326:	0f ef       	ldi	r16, 0xFF	; 255
    5328:	1f ef       	ldi	r17, 0xFF	; 255
    532a:	0e 94 44 29 	call	0x5288	; 0x5288 <CRC_Seed>
}
    532e:	1f 91       	pop	r17
    5330:	0f 91       	pop	r16
    5332:	08 95       	ret

00005334 <CRC_EEPROM_calc>:
}

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    5334:	0f 93       	push	r16
    5336:	1f 93       	push	r17
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
    5338:	29 ea       	ldi	r18, 0xA9	; 169
    533a:	31 e0       	ldi	r19, 0x01	; 1
// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
    533c:	40 e0       	ldi	r20, 0x00	; 0
    533e:	50 e0       	ldi	r21, 0x00	; 0
    5340:	60 e0       	ldi	r22, 0x00	; 0
    5342:	70 e0       	ldi	r23, 0x00	; 0
    5344:	81 e0       	ldi	r24, 0x01	; 1
    5346:	99 e2       	ldi	r25, 0x29	; 41
    5348:	0e 94 91 29 	call	0x5322	; 0x5322 <CRC>
    534c:	2b ef       	ldi	r18, 0xFB	; 251
    534e:	3f e0       	ldi	r19, 0x0F	; 15
    5350:	29 5a       	subi	r18, 0xA9	; 169
    5352:	31 40       	sbci	r19, 0x01	; 1
    5354:	40 e0       	ldi	r20, 0x00	; 0
    5356:	50 e0       	ldi	r21, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
    5358:	8c 01       	movw	r16, r24
    535a:	6e ea       	ldi	r22, 0xAE	; 174
    535c:	71 e0       	ldi	r23, 0x01	; 1
    535e:	81 e0       	ldi	r24, 0x01	; 1
    5360:	99 e2       	ldi	r25, 0x29	; 41
    5362:	0e 94 44 29 	call	0x5288	; 0x5288 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    5366:	1f 91       	pop	r17
    5368:	0f 91       	pop	r16
    536a:	08 95       	ret

0000536c <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    536c:	80 91 77 0a 	lds	r24, 0x0A77
    5370:	81 fd       	sbrc	r24, 1
    5372:	07 c0       	rjmp	.+14     	; 0x5382 <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5374:	0e 94 9a 29 	call	0x5334	; 0x5334 <CRC_EEPROM_calc>
    5378:	bc 01       	movw	r22, r24
    537a:	8b ea       	ldi	r24, 0xAB	; 171
    537c:	91 e0       	ldi	r25, 0x01	; 1
    537e:	0c 94 8c 73 	jmp	0xe718	; 0xe718 <__eewr_word_m128>
    5382:	08 95       	ret

00005384 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    5384:	0e 94 77 73 	call	0xe6ee	; 0xe6ee <__eewr_byte_m128>
	CRC_EEPROM_upd();
    5388:	0c 94 b6 29 	jmp	0x536c	; 0x536c <CRC_EEPROM_upd>

0000538c <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    538c:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    538e:	6f ef       	ldi	r22, 0xFF	; 255
    5390:	8f ef       	ldi	r24, 0xFF	; 255
    5392:	9f e0       	ldi	r25, 0x0F	; 15
    5394:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
    5398:	ff cf       	rjmp	.-2      	; 0x5398 <Start_Bootloader+0xc>

0000539a <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    539a:	0e 94 8c 73 	call	0xe718	; 0xe718 <__eewr_word_m128>
	CRC_EEPROM_upd();
    539e:	0c 94 b6 29 	jmp	0x536c	; 0x536c <CRC_EEPROM_upd>

000053a2 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    53a2:	0e 94 84 73 	call	0xe708	; 0xe708 <__eewr_dword_m128>
	CRC_EEPROM_upd();
    53a6:	0c 94 b6 29 	jmp	0x536c	; 0x536c <CRC_EEPROM_upd>

000053aa <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    53aa:	0e 94 6d 73 	call	0xe6da	; 0xe6da <__eewr_block_m128>
	CRC_EEPROM_upd();
    53ae:	0c 94 b6 29 	jmp	0x536c	; 0x536c <CRC_EEPROM_upd>

000053b2 <CRC_Flash_calc>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    53b2:	0f 93       	push	r16
    53b4:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    53b6:	20 e0       	ldi	r18, 0x00	; 0
    53b8:	30 e0       	ldi	r19, 0x00	; 0
    53ba:	41 e0       	ldi	r20, 0x01	; 1
    53bc:	50 e0       	ldi	r21, 0x00	; 0
    53be:	60 e0       	ldi	r22, 0x00	; 0
    53c0:	70 e0       	ldi	r23, 0x00	; 0
    53c2:	86 e1       	ldi	r24, 0x16	; 22
    53c4:	98 e2       	ldi	r25, 0x28	; 40
    53c6:	0e 94 91 29 	call	0x5322	; 0x5322 <CRC>
    53ca:	8c 01       	movw	r16, r24
    53cc:	20 e0       	ldi	r18, 0x00	; 0
    53ce:	30 e0       	ldi	r19, 0x00	; 0
    53d0:	41 e0       	ldi	r20, 0x01	; 1
    53d2:	50 e0       	ldi	r21, 0x00	; 0
    53d4:	60 e0       	ldi	r22, 0x00	; 0
    53d6:	70 e0       	ldi	r23, 0x00	; 0
    53d8:	89 e1       	ldi	r24, 0x19	; 25
    53da:	98 e2       	ldi	r25, 0x28	; 40
    53dc:	0e 94 44 29 	call	0x5288	; 0x5288 <CRC_Seed>
	#endif
}
    53e0:	1f 91       	pop	r17
    53e2:	0f 91       	pop	r16
    53e4:	08 95       	ret

000053e6 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    53e6:	8d ea       	ldi	r24, 0xAD	; 173
    53e8:	91 e0       	ldi	r25, 0x01	; 1
    53ea:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    53ee:	81 11       	cpse	r24, r1
    53f0:	13 c0       	rjmp	.+38     	; 0x5418 <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    53f2:	0e 94 d9 29 	call	0x53b2	; 0x53b2 <CRC_Flash_calc>
    53f6:	bc 01       	movw	r22, r24
    53f8:	89 ea       	ldi	r24, 0xA9	; 169
    53fa:	91 e0       	ldi	r25, 0x01	; 1
    53fc:	0e 94 8c 73 	call	0xe718	; 0xe718 <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5400:	0e 94 9a 29 	call	0x5334	; 0x5334 <CRC_EEPROM_calc>
    5404:	bc 01       	movw	r22, r24
    5406:	8b ea       	ldi	r24, 0xAB	; 171
    5408:	91 e0       	ldi	r25, 0x01	; 1
    540a:	0e 94 8c 73 	call	0xe718	; 0xe718 <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    540e:	61 e0       	ldi	r22, 0x01	; 1
    5410:	8d ea       	ldi	r24, 0xAD	; 173
    5412:	91 e0       	ldi	r25, 0x01	; 1
    5414:	0c 94 77 73 	jmp	0xe6ee	; 0xe6ee <__eewr_byte_m128>
    5418:	08 95       	ret

0000541a <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    541a:	8f b7       	in	r24, 0x3f	; 63
    541c:	80 78       	andi	r24, 0x80	; 128
    541e:	80 93 de 03 	sts	0x03DE, r24
	cli();
    5422:	f8 94       	cli
	return interru_enub_flg;
}
    5424:	80 91 de 03 	lds	r24, 0x03DE
    5428:	08 95       	ret

0000542a <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    542a:	80 91 de 03 	lds	r24, 0x03DE
    542e:	88 23       	and	r24, r24
    5430:	09 f0       	breq	.+2      	; 0x5434 <IntOn+0xa>
		sei();
    5432:	78 94       	sei
	return interru_enub_flg;
}
    5434:	80 91 de 03 	lds	r24, 0x03DE
    5438:	08 95       	ret

0000543a <Modbus_ReadHoldReg>:
	eww(&SerialNum, MBHoldReg1[43]);
	
}

void Modbus_ReadHoldReg(void){
	IntOff();
    543a:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    543e:	87 e2       	ldi	r24, 0x27	; 39
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	MBHoldReg1[0] = erw(&EM_UART_Param);
    5446:	90 93 7d 08 	sts	0x087D, r25
    544a:	80 93 7c 08 	sts	0x087C, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    544e:	4e e1       	ldi	r20, 0x1E	; 30
    5450:	50 e0       	ldi	r21, 0x00	; 0
    5452:	6c e7       	ldi	r22, 0x7C	; 124
    5454:	71 e0       	ldi	r23, 0x01	; 1
    5456:	8e e7       	ldi	r24, 0x7E	; 126
    5458:	98 e0       	ldi	r25, 0x08	; 8
    545a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    545e:	44 e1       	ldi	r20, 0x14	; 20
    5460:	50 e0       	ldi	r21, 0x00	; 0
    5462:	68 e6       	ldi	r22, 0x68	; 104
    5464:	71 e0       	ldi	r23, 0x01	; 1
    5466:	8c e9       	ldi	r24, 0x9C	; 156
    5468:	98 e0       	ldi	r25, 0x08	; 8
    546a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    546e:	44 e1       	ldi	r20, 0x14	; 20
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	64 e5       	ldi	r22, 0x54	; 84
    5474:	71 e0       	ldi	r23, 0x01	; 1
    5476:	80 eb       	ldi	r24, 0xB0	; 176
    5478:	98 e0       	ldi	r25, 0x08	; 8
    547a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    547e:	80 e2       	ldi	r24, 0x20	; 32
    5480:	91 e0       	ldi	r25, 0x01	; 1
    5482:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    5486:	90 93 c5 08 	sts	0x08C5, r25
    548a:	80 93 c4 08 	sts	0x08C4, r24
    548e:	8e e0       	ldi	r24, 0x0E	; 14
    5490:	91 e0       	ldi	r25, 0x01	; 1
    5492:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    5496:	90 93 c7 08 	sts	0x08C7, r25
    549a:	80 93 c6 08 	sts	0x08C6, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    549e:	82 e3       	ldi	r24, 0x32	; 50
    54a0:	91 e0       	ldi	r25, 0x01	; 1
    54a2:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MBHoldReg1[38] = erb(&TCP_ServerIP->IP1);
    54a6:	90 e0       	ldi	r25, 0x00	; 0
    54a8:	90 93 c9 08 	sts	0x08C9, r25
    54ac:	80 93 c8 08 	sts	0x08C8, r24
    54b0:	83 e3       	ldi	r24, 0x33	; 51
    54b2:	91 e0       	ldi	r25, 0x01	; 1
    54b4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MBHoldReg1[39] = erb(&TCP_ServerIP->IP2);
    54b8:	90 e0       	ldi	r25, 0x00	; 0
    54ba:	90 93 cb 08 	sts	0x08CB, r25
    54be:	80 93 ca 08 	sts	0x08CA, r24
    54c2:	84 e3       	ldi	r24, 0x34	; 52
    54c4:	91 e0       	ldi	r25, 0x01	; 1
    54c6:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MBHoldReg1[40] = erb(&TCP_ServerIP->IP3);
    54ca:	90 e0       	ldi	r25, 0x00	; 0
    54cc:	90 93 cd 08 	sts	0x08CD, r25
    54d0:	80 93 cc 08 	sts	0x08CC, r24
    54d4:	85 e3       	ldi	r24, 0x35	; 53
    54d6:	91 e0       	ldi	r25, 0x01	; 1
    54d8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MBHoldReg1[41] = erb(&TCP_ServerIP->IP4);
    54dc:	90 e0       	ldi	r25, 0x00	; 0
    54de:	90 93 cf 08 	sts	0x08CF, r25
    54e2:	80 93 ce 08 	sts	0x08CE, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    54e6:	82 e2       	ldi	r24, 0x22	; 34
    54e8:	91 e0       	ldi	r25, 0x01	; 1
    54ea:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	MBHoldReg1[42] = erw(&TCP_ServerPort[0]);
    54ee:	90 93 d1 08 	sts	0x08D1, r25
    54f2:	80 93 d0 08 	sts	0x08D0, r24
    54f6:	82 e5       	ldi	r24, 0x52	; 82
    54f8:	91 e0       	ldi	r25, 0x01	; 1
    54fa:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	MBHoldReg1[43] = erw(&SerialNum);
    54fe:	90 93 d3 08 	sts	0x08D3, r25
    5502:	80 93 d2 08 	sts	0x08D2, r24
	IntOn();
    5506:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

0000550a <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    550a:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    550c:	2f e0       	ldi	r18, 0x0F	; 15
    550e:	88 e1       	ldi	r24, 0x18	; 24
    5510:	90 e0       	ldi	r25, 0x00	; 0
    5512:	0f b6       	in	r0, 0x3f	; 63
    5514:	f8 94       	cli
    5516:	a8 95       	wdr
    5518:	81 bd       	out	0x21, r24	; 33
    551a:	0f be       	out	0x3f, r0	; 63
    551c:	21 bd       	out	0x21, r18	; 33
    551e:	08 95       	ret

00005520 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    5520:	80 91 11 01 	lds	r24, 0x0111
	VacantTimer16++;
    5524:	91 e0       	ldi	r25, 0x01	; 1
    5526:	98 0f       	add	r25, r24
    5528:	90 93 11 01 	sts	0x0111, r25
	return N;
}
    552c:	08 95       	ret

0000552e <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    552e:	80 91 10 01 	lds	r24, 0x0110
	VacantTimer32++;
    5532:	91 e0       	ldi	r25, 0x01	; 1
    5534:	98 0f       	add	r25, r24
    5536:	90 93 10 01 	sts	0x0110, r25
	return N;
}
    553a:	08 95       	ret

0000553c <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    553c:	1f 93       	push	r17
    553e:	cf 93       	push	r28
    5540:	df 93       	push	r29
    5542:	1f 92       	push	r1
    5544:	cd b7       	in	r28, 0x3d	; 61
    5546:	de b7       	in	r29, 0x3e	; 62
    5548:	18 2f       	mov	r17, r24
	IntOff();
    554a:	69 83       	std	Y+1, r22	; 0x01
    554c:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	if ((Timer8[TimerN]=Timeout)>0)
    5550:	e1 2f       	mov	r30, r17
    5552:	f0 e0       	ldi	r31, 0x00	; 0
    5554:	ea 55       	subi	r30, 0x5A	; 90
    5556:	fc 4f       	sbci	r31, 0xFC	; 252
    5558:	69 81       	ldd	r22, Y+1	; 0x01
    555a:	60 83       	st	Z, r22
    555c:	e1 2f       	mov	r30, r17
    555e:	e6 95       	lsr	r30
    5560:	e6 95       	lsr	r30
    5562:	e6 95       	lsr	r30
    5564:	17 70       	andi	r17, 0x07	; 7
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5566:	f0 e0       	ldi	r31, 0x00	; 0
    5568:	e3 58       	subi	r30, 0x83	; 131
    556a:	fd 4f       	sbci	r31, 0xFD	; 253
    556c:	80 81       	ld	r24, Z
    556e:	21 e0       	ldi	r18, 0x01	; 1
    5570:	30 e0       	ldi	r19, 0x00	; 0
    5572:	01 2e       	mov	r0, r17
    5574:	01 c0       	rjmp	.+2      	; 0x5578 <StartTimer8+0x3c>
    5576:	22 0f       	add	r18, r18
    5578:	0a 94       	dec	r0
    557a:	ea f7       	brpl	.-6      	; 0x5576 <StartTimer8+0x3a>

void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    557c:	66 23       	and	r22, r22
    557e:	21 f0       	breq	.+8      	; 0x5588 <StartTimer8+0x4c>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5580:	20 95       	com	r18
    5582:	28 23       	and	r18, r24
    5584:	20 83       	st	Z, r18
    5586:	02 c0       	rjmp	.+4      	; 0x558c <StartTimer8+0x50>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    5588:	82 2b       	or	r24, r18
    558a:	80 83       	st	Z, r24
	IntOn();
}
    558c:	0f 90       	pop	r0
    558e:	df 91       	pop	r29
    5590:	cf 91       	pop	r28
    5592:	1f 91       	pop	r17
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5594:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

00005598 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    5598:	1f 93       	push	r17
    559a:	cf 93       	push	r28
    559c:	df 93       	push	r29
    559e:	18 2f       	mov	r17, r24
    55a0:	eb 01       	movw	r28, r22
	IntOff();
    55a2:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	if ((Timer16[TimerN]=Timeout)>0)
    55a6:	e1 2f       	mov	r30, r17
    55a8:	f0 e0       	ldi	r31, 0x00	; 0
    55aa:	ee 0f       	add	r30, r30
    55ac:	ff 1f       	adc	r31, r31
    55ae:	ea 5d       	subi	r30, 0xDA	; 218
    55b0:	fc 4f       	sbci	r31, 0xFC	; 252
    55b2:	d1 83       	std	Z+1, r29	; 0x01
    55b4:	c0 83       	st	Z, r28
    55b6:	e1 2f       	mov	r30, r17
    55b8:	e6 95       	lsr	r30
    55ba:	e6 95       	lsr	r30
    55bc:	e6 95       	lsr	r30
    55be:	17 70       	andi	r17, 0x07	; 7
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55c0:	f0 e0       	ldi	r31, 0x00	; 0
    55c2:	ec 58       	subi	r30, 0x8C	; 140
    55c4:	fd 4f       	sbci	r31, 0xFD	; 253
    55c6:	80 81       	ld	r24, Z
    55c8:	21 e0       	ldi	r18, 0x01	; 1
    55ca:	30 e0       	ldi	r19, 0x00	; 0
    55cc:	01 2e       	mov	r0, r17
    55ce:	01 c0       	rjmp	.+2      	; 0x55d2 <StartTimer16+0x3a>
    55d0:	22 0f       	add	r18, r18
    55d2:	0a 94       	dec	r0
    55d4:	ea f7       	brpl	.-6      	; 0x55d0 <StartTimer16+0x38>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    55d6:	cd 2b       	or	r28, r29
    55d8:	21 f0       	breq	.+8      	; 0x55e2 <StartTimer16+0x4a>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55da:	20 95       	com	r18
    55dc:	28 23       	and	r18, r24
    55de:	20 83       	st	Z, r18
    55e0:	02 c0       	rjmp	.+4      	; 0x55e6 <StartTimer16+0x4e>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    55e2:	82 2b       	or	r24, r18
    55e4:	80 83       	st	Z, r24
	IntOn();
}
    55e6:	df 91       	pop	r29
    55e8:	cf 91       	pop	r28
    55ea:	1f 91       	pop	r17
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    55ec:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

000055f0 <SlavesOn>:

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    55f0:	28 2f       	mov	r18, r24
    55f2:	30 e0       	ldi	r19, 0x00	; 0
    55f4:	f9 01       	movw	r30, r18
    55f6:	ee 0f       	add	r30, r30
    55f8:	ff 1f       	adc	r31, r31
    55fa:	ee 0f       	add	r30, r30
    55fc:	ff 1f       	adc	r31, r31
    55fe:	e3 5a       	subi	r30, 0xA3	; 163
    5600:	fd 4f       	sbci	r31, 0xFD	; 253
    5602:	10 82       	st	Z, r1
    5604:	11 82       	std	Z+1, r1	; 0x01
    5606:	12 82       	std	Z+2, r1	; 0x02
    5608:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    560a:	f9 01       	movw	r30, r18
    560c:	e6 51       	subi	r30, 0x16	; 22
    560e:	fc 4f       	sbci	r31, 0xFC	; 252
    5610:	60 81       	ld	r22, Z
    5612:	94 e6       	ldi	r25, 0x64	; 100
    5614:	69 9f       	mul	r22, r25
    5616:	b0 01       	movw	r22, r0
    5618:	11 24       	eor	r1, r1
    561a:	90 91 5c 02 	lds	r25, 0x025C
    561e:	9f 5f       	subi	r25, 0xFF	; 255
    5620:	89 0f       	add	r24, r25
    5622:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>

00005626 <NextSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    5626:	4f 92       	push	r4
    5628:	5f 92       	push	r5
    562a:	6f 92       	push	r6
    562c:	7f 92       	push	r7
    562e:	8f 92       	push	r8
    5630:	9f 92       	push	r9
    5632:	af 92       	push	r10
    5634:	bf 92       	push	r11
    5636:	cf 92       	push	r12
    5638:	df 92       	push	r13
    563a:	ef 92       	push	r14
    563c:	ff 92       	push	r15
    563e:	0f 93       	push	r16
    5640:	1f 93       	push	r17
    5642:	cf 93       	push	r28
    5644:	df 93       	push	r29
    5646:	98 2e       	mov	r9, r24
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
    5648:	83 e0       	ldi	r24, 0x03	; 3
    564a:	98 9e       	mul	r9, r24
    564c:	f0 01       	movw	r30, r0
    564e:	11 24       	eor	r1, r1
    5650:	e7 5f       	subi	r30, 0xF7	; 247
    5652:	f2 4b       	sbci	r31, 0xB2	; 178

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5654:	74 90       	lpm	r7, Z
// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	uint8_t i = 0;
    5656:	81 2c       	mov	r8, r1

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
    5658:	61 2c       	mov	r6, r1
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    565a:	09 2d       	mov	r16, r9
    565c:	10 e0       	ldi	r17, 0x00	; 0
    565e:	e8 01       	movw	r28, r16
    5660:	ca 5f       	subi	r28, 0xFA	; 250
    5662:	d9 4f       	sbci	r29, 0xF9	; 249
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5664:	98 01       	movw	r18, r16
    5666:	22 0f       	add	r18, r18
    5668:	33 1f       	adc	r19, r19
    566a:	f9 01       	movw	r30, r18
    566c:	e7 5b       	subi	r30, 0xB7	; 183
    566e:	f6 4f       	sbci	r31, 0xF6	; 246
    5670:	5f 01       	movw	r10, r30
    5672:	c9 01       	movw	r24, r18
    5674:	85 5c       	subi	r24, 0xC5	; 197
    5676:	97 4f       	sbci	r25, 0xF7	; 247
    5678:	6c 01       	movw	r12, r24
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    567a:	78 01       	movw	r14, r16
    567c:	ee 0c       	add	r14, r14
    567e:	ff 1c       	adc	r15, r15
    5680:	ee 0c       	add	r14, r14
    5682:	ff 1c       	adc	r15, r15
    5684:	f7 01       	movw	r30, r14
    5686:	e3 5a       	subi	r30, 0xA3	; 163
    5688:	fd 4f       	sbci	r31, 0xFD	; 253
    568a:	7f 01       	movw	r14, r30
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    568c:	98 81       	ld	r25, Y
    568e:	9f 5f       	subi	r25, 0xFF	; 255
    5690:	98 83       	st	Y, r25
    5692:	97 11       	cpse	r25, r7
    5694:	27 c0       	rjmp	.+78     	; 0x56e4 <NextSlave+0xbe>
			CurrSlave[MB_N] = 0;
    5696:	18 82       	st	Y, r1
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5698:	60 90 5c 02 	lds	r6, 0x025C
    569c:	63 94       	inc	r6
    569e:	63 94       	inc	r6
    56a0:	69 0c       	add	r6, r9

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    56a2:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint16_t Time = Timer16[TimerN];
    56a6:	a6 2d       	mov	r26, r6
    56a8:	b0 e0       	ldi	r27, 0x00	; 0
    56aa:	aa 0f       	add	r26, r26
    56ac:	bb 1f       	adc	r27, r27
    56ae:	aa 5d       	subi	r26, 0xDA	; 218
    56b0:	bc 4f       	sbci	r27, 0xFC	; 252
    56b2:	4d 90       	ld	r4, X+
    56b4:	5c 90       	ld	r5, X
	IntOn();
    56b6:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
    56ba:	92 01       	movw	r18, r4
    56bc:	20 95       	com	r18
    56be:	30 95       	com	r19
    56c0:	f5 01       	movw	r30, r10
    56c2:	31 83       	std	Z+1, r19	; 0x01
    56c4:	20 83       	st	Z, r18
    56c6:	f6 01       	movw	r30, r12
    56c8:	40 81       	ld	r20, Z
    56ca:	51 81       	ldd	r21, Z+1	; 0x01
    56cc:	42 17       	cp	r20, r18
    56ce:	53 07       	cpc	r21, r19
    56d0:	10 f4       	brcc	.+4      	; 0x56d6 <NextSlave+0xb0>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    56d2:	31 83       	std	Z+1, r19	; 0x01
    56d4:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    56d6:	6f ef       	ldi	r22, 0xFF	; 255
    56d8:	7f ef       	ldi	r23, 0xFF	; 255
    56da:	86 2d       	mov	r24, r6
    56dc:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;
    56e0:	66 24       	eor	r6, r6
    56e2:	63 94       	inc	r6

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    56e4:	f7 01       	movw	r30, r14
    56e6:	40 81       	ld	r20, Z
    56e8:	51 81       	ldd	r21, Z+1	; 0x01
    56ea:	62 81       	ldd	r22, Z+2	; 0x02
    56ec:	73 81       	ldd	r23, Z+3	; 0x03
    56ee:	08 80       	ld	r0, Y
    56f0:	04 c0       	rjmp	.+8      	; 0x56fa <NextSlave+0xd4>
    56f2:	76 95       	lsr	r23
    56f4:	67 95       	ror	r22
    56f6:	57 95       	ror	r21
    56f8:	47 95       	ror	r20
    56fa:	0a 94       	dec	r0
    56fc:	d2 f7       	brpl	.-12     	; 0x56f2 <NextSlave+0xcc>
    56fe:	40 ff       	sbrs	r20, 0
    5700:	03 c0       	rjmp	.+6      	; 0x5708 <NextSlave+0xe2>
    5702:	83 94       	inc	r8
    5704:	87 14       	cp	r8, r7
    5706:	10 f2       	brcs	.-124    	; 0x568c <NextSlave+0x66>
	if (i==SlaveQt) {
    5708:	87 10       	cpse	r8, r7
    570a:	09 c0       	rjmp	.+18     	; 0x571e <NextSlave+0xf8>
		SlavesOn(MB_N);
    570c:	89 2d       	mov	r24, r9
    570e:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <SlavesOn>
		if (++CurrSlave[MB_N]==SlaveQt)
    5712:	98 81       	ld	r25, Y
    5714:	9f 5f       	subi	r25, 0xFF	; 255
    5716:	98 83       	st	Y, r25
    5718:	98 11       	cpse	r25, r8
    571a:	01 c0       	rjmp	.+2      	; 0x571e <NextSlave+0xf8>
			CurrSlave[MB_N] = 0;
    571c:	18 82       	st	Y, r1
	}
	CurrQuery[MB_N] = 0;
    571e:	f8 01       	movw	r30, r16
    5720:	e3 5f       	subi	r30, 0xF3	; 243
    5722:	f9 4f       	sbci	r31, 0xF9	; 249
    5724:	10 82       	st	Z, r1
	return Over;
}
    5726:	86 2d       	mov	r24, r6
    5728:	df 91       	pop	r29
    572a:	cf 91       	pop	r28
    572c:	1f 91       	pop	r17
    572e:	0f 91       	pop	r16
    5730:	ff 90       	pop	r15
    5732:	ef 90       	pop	r14
    5734:	df 90       	pop	r13
    5736:	cf 90       	pop	r12
    5738:	bf 90       	pop	r11
    573a:	af 90       	pop	r10
    573c:	9f 90       	pop	r9
    573e:	8f 90       	pop	r8
    5740:	7f 90       	pop	r7
    5742:	6f 90       	pop	r6
    5744:	5f 90       	pop	r5
    5746:	4f 90       	pop	r4
    5748:	08 95       	ret

0000574a <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    574a:	0f 93       	push	r16
    574c:	1f 93       	push	r17
    574e:	cf 93       	push	r28
    5750:	df 93       	push	r29
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    5752:	28 2f       	mov	r18, r24
    5754:	30 e0       	ldi	r19, 0x00	; 0
    5756:	f9 01       	movw	r30, r18
    5758:	ee 5d       	subi	r30, 0xDE	; 222
    575a:	f9 4f       	sbci	r31, 0xF9	; 249
    575c:	90 81       	ld	r25, Z
    575e:	92 30       	cpi	r25, 0x02	; 2
    5760:	11 f4       	brne	.+4      	; 0x5766 <FailSlave+0x1c>
		MB_SingleState[MB_N] = MB_SingleIdle;
    5762:	10 82       	st	Z, r1
    5764:	54 c0       	rjmp	.+168    	; 0x580e <FailSlave+0xc4>
	else{
		MB_CPT[MB_N][4]++;	// -    
    5766:	f9 01       	movw	r30, r18
    5768:	d4 e0       	ldi	r29, 0x04	; 4
    576a:	ee 0f       	add	r30, r30
    576c:	ff 1f       	adc	r31, r31
    576e:	da 95       	dec	r29
    5770:	e1 f7       	brne	.-8      	; 0x576a <FailSlave+0x20>
    5772:	e7 5d       	subi	r30, 0xD7	; 215
    5774:	f4 4f       	sbci	r31, 0xF4	; 244
    5776:	40 85       	ldd	r20, Z+8	; 0x08
    5778:	51 85       	ldd	r21, Z+9	; 0x09
    577a:	4f 5f       	subi	r20, 0xFF	; 255
    577c:	5f 4f       	sbci	r21, 0xFF	; 255
    577e:	51 87       	std	Z+9, r21	; 0x09
    5780:	40 87       	std	Z+8, r20	; 0x08
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    5782:	f9 01       	movw	r30, r18
    5784:	ef 59       	subi	r30, 0x9F	; 159
    5786:	fd 4f       	sbci	r31, 0xFD	; 253
    5788:	90 81       	ld	r25, Z
    578a:	9f 5f       	subi	r25, 0xFF	; 255
    578c:	90 83       	st	Z, r25
    578e:	d9 01       	movw	r26, r18
    5790:	ac 52       	subi	r26, 0x2C	; 44
    5792:	b7 4f       	sbci	r27, 0xF7	; 247
    5794:	4c 91       	ld	r20, X
    5796:	94 13       	cpse	r25, r20
    5798:	3a c0       	rjmp	.+116    	; 0x580e <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    579a:	d9 01       	movw	r26, r18
    579c:	aa 5f       	subi	r26, 0xFA	; 250
    579e:	b9 4f       	sbci	r27, 0xF9	; 249
    57a0:	41 e0       	ldi	r20, 0x01	; 1
    57a2:	50 e0       	ldi	r21, 0x00	; 0
    57a4:	60 e0       	ldi	r22, 0x00	; 0
    57a6:	70 e0       	ldi	r23, 0x00	; 0
    57a8:	0c 90       	ld	r0, X
    57aa:	04 c0       	rjmp	.+8      	; 0x57b4 <FailSlave+0x6a>
    57ac:	44 0f       	add	r20, r20
    57ae:	55 1f       	adc	r21, r21
    57b0:	66 1f       	adc	r22, r22
    57b2:	77 1f       	adc	r23, r23
    57b4:	0a 94       	dec	r0
    57b6:	d2 f7       	brpl	.-12     	; 0x57ac <FailSlave+0x62>
			SlaveOff[MB_N] |=S_N;
    57b8:	d9 01       	movw	r26, r18
    57ba:	aa 0f       	add	r26, r26
    57bc:	bb 1f       	adc	r27, r27
    57be:	aa 0f       	add	r26, r26
    57c0:	bb 1f       	adc	r27, r27
    57c2:	ed 01       	movw	r28, r26
    57c4:	cc 5e       	subi	r28, 0xEC	; 236
    57c6:	d4 4f       	sbci	r29, 0xF4	; 244
    57c8:	08 81       	ld	r16, Y
    57ca:	19 81       	ldd	r17, Y+1	; 0x01
    57cc:	2a 81       	ldd	r18, Y+2	; 0x02
    57ce:	3b 81       	ldd	r19, Y+3	; 0x03
    57d0:	04 2b       	or	r16, r20
    57d2:	15 2b       	or	r17, r21
    57d4:	26 2b       	or	r18, r22
    57d6:	37 2b       	or	r19, r23
    57d8:	08 83       	st	Y, r16
    57da:	19 83       	std	Y+1, r17	; 0x01
    57dc:	2a 83       	std	Y+2, r18	; 0x02
    57de:	3b 83       	std	Y+3, r19	; 0x03
			SlaveSkip[MB_N] |=S_N;
    57e0:	a3 5a       	subi	r26, 0xA3	; 163
    57e2:	bd 4f       	sbci	r27, 0xFD	; 253
    57e4:	0d 91       	ld	r16, X+
    57e6:	1d 91       	ld	r17, X+
    57e8:	2d 91       	ld	r18, X+
    57ea:	3c 91       	ld	r19, X
    57ec:	13 97       	sbiw	r26, 0x03	; 3
    57ee:	04 2b       	or	r16, r20
    57f0:	15 2b       	or	r17, r21
    57f2:	26 2b       	or	r18, r22
    57f4:	37 2b       	or	r19, r23
    57f6:	0d 93       	st	X+, r16
    57f8:	1d 93       	st	X+, r17
    57fa:	2d 93       	st	X+, r18
    57fc:	3c 93       	st	X, r19
    57fe:	13 97       	sbiw	r26, 0x03	; 3
			Try[MB_N] = 0;
    5800:	10 82       	st	Z, r1
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    5802:	df 91       	pop	r29
    5804:	cf 91       	pop	r28
    5806:	1f 91       	pop	r17
    5808:	0f 91       	pop	r16
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
			SlaveOff[MB_N] |=S_N;
			SlaveSkip[MB_N] |=S_N;
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
    580a:	0c 94 13 2b 	jmp	0x5626	; 0x5626 <NextSlave>
		}
	}
	return Over;
}
    580e:	80 e0       	ldi	r24, 0x00	; 0
    5810:	df 91       	pop	r29
    5812:	cf 91       	pop	r28
    5814:	1f 91       	pop	r17
    5816:	0f 91       	pop	r16
    5818:	08 95       	ret

0000581a <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    581a:	1f 93       	push	r17
    581c:	cf 93       	push	r28
    581e:	df 93       	push	r29
    5820:	00 d0       	rcall	.+0      	; 0x5822 <StartTimer32+0x8>
    5822:	00 d0       	rcall	.+0      	; 0x5824 <StartTimer32+0xa>
    5824:	cd b7       	in	r28, 0x3d	; 61
    5826:	de b7       	in	r29, 0x3e	; 62
    5828:	18 2f       	mov	r17, r24
	IntOff();
    582a:	49 83       	std	Y+1, r20	; 0x01
    582c:	5a 83       	std	Y+2, r21	; 0x02
    582e:	6b 83       	std	Y+3, r22	; 0x03
    5830:	7c 83       	std	Y+4, r23	; 0x04
    5832:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	if ((Timer32[TimerN]=Timeout)>0)
    5836:	84 e0       	ldi	r24, 0x04	; 4
    5838:	18 9f       	mul	r17, r24
    583a:	f0 01       	movw	r30, r0
    583c:	11 24       	eor	r1, r1
    583e:	ea 57       	subi	r30, 0x7A	; 122
    5840:	fd 4f       	sbci	r31, 0xFD	; 253
    5842:	49 81       	ldd	r20, Y+1	; 0x01
    5844:	5a 81       	ldd	r21, Y+2	; 0x02
    5846:	6b 81       	ldd	r22, Y+3	; 0x03
    5848:	7c 81       	ldd	r23, Y+4	; 0x04
    584a:	40 83       	st	Z, r20
    584c:	51 83       	std	Z+1, r21	; 0x01
    584e:	62 83       	std	Z+2, r22	; 0x02
    5850:	73 83       	std	Z+3, r23	; 0x03
    5852:	e1 2f       	mov	r30, r17
    5854:	e6 95       	lsr	r30
    5856:	e6 95       	lsr	r30
    5858:	e6 95       	lsr	r30
    585a:	17 70       	andi	r17, 0x07	; 7
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    585c:	f0 e0       	ldi	r31, 0x00	; 0
    585e:	e2 59       	subi	r30, 0x92	; 146
    5860:	fd 4f       	sbci	r31, 0xFD	; 253
    5862:	80 81       	ld	r24, Z
    5864:	21 e0       	ldi	r18, 0x01	; 1
    5866:	30 e0       	ldi	r19, 0x00	; 0
    5868:	01 2e       	mov	r0, r17
    586a:	01 c0       	rjmp	.+2      	; 0x586e <StartTimer32+0x54>
    586c:	22 0f       	add	r18, r18
    586e:	0a 94       	dec	r0
    5870:	ea f7       	brpl	.-6      	; 0x586c <StartTimer32+0x52>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    5872:	45 2b       	or	r20, r21
    5874:	46 2b       	or	r20, r22
    5876:	47 2b       	or	r20, r23
    5878:	21 f0       	breq	.+8      	; 0x5882 <StartTimer32+0x68>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    587a:	20 95       	com	r18
    587c:	28 23       	and	r18, r24
    587e:	20 83       	st	Z, r18
    5880:	02 c0       	rjmp	.+4      	; 0x5886 <StartTimer32+0x6c>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    5882:	82 2b       	or	r24, r18
    5884:	80 83       	st	Z, r24
	IntOn();
}
    5886:	0f 90       	pop	r0
    5888:	0f 90       	pop	r0
    588a:	0f 90       	pop	r0
    588c:	0f 90       	pop	r0
    588e:	df 91       	pop	r29
    5890:	cf 91       	pop	r28
    5892:	1f 91       	pop	r17
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    5894:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

00005898 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    5898:	a8 2f       	mov	r26, r24
    589a:	a6 95       	lsr	r26
    589c:	a6 95       	lsr	r26
    589e:	a6 95       	lsr	r26
    58a0:	b0 e0       	ldi	r27, 0x00	; 0
    58a2:	a3 58       	subi	r26, 0x83	; 131
    58a4:	bd 4f       	sbci	r27, 0xFD	; 253
    58a6:	2c 91       	ld	r18, X
    58a8:	30 e0       	ldi	r19, 0x00	; 0
    58aa:	98 2f       	mov	r25, r24
    58ac:	97 70       	andi	r25, 0x07	; 7
    58ae:	02 c0       	rjmp	.+4      	; 0x58b4 <Timer8Stopp+0x1c>
    58b0:	35 95       	asr	r19
    58b2:	27 95       	ror	r18
    58b4:	9a 95       	dec	r25
    58b6:	e2 f7       	brpl	.-8      	; 0x58b0 <Timer8Stopp+0x18>
    58b8:	20 ff       	sbrs	r18, 0
    58ba:	07 c0       	rjmp	.+14     	; 0x58ca <Timer8Stopp+0x32>
    58bc:	e8 2f       	mov	r30, r24
    58be:	f0 e0       	ldi	r31, 0x00	; 0
    58c0:	ea 55       	subi	r30, 0x5A	; 90
    58c2:	fc 4f       	sbci	r31, 0xFC	; 252
    58c4:	90 81       	ld	r25, Z
    58c6:	81 e0       	ldi	r24, 0x01	; 1
    58c8:	91 11       	cpse	r25, r1
    58ca:	80 e0       	ldi	r24, 0x00	; 0
}
    58cc:	08 95       	ret

000058ce <Timer16Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
    58ce:	cf 93       	push	r28
    58d0:	c8 2f       	mov	r28, r24
	IntOff();
    58d2:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    58d6:	ac 2f       	mov	r26, r28
    58d8:	a6 95       	lsr	r26
    58da:	a6 95       	lsr	r26
    58dc:	a6 95       	lsr	r26
    58de:	b0 e0       	ldi	r27, 0x00	; 0
    58e0:	ac 58       	subi	r26, 0x8C	; 140
    58e2:	bd 4f       	sbci	r27, 0xFD	; 253
    58e4:	2c 91       	ld	r18, X
    58e6:	30 e0       	ldi	r19, 0x00	; 0
    58e8:	8c 2f       	mov	r24, r28
    58ea:	87 70       	andi	r24, 0x07	; 7
    58ec:	02 c0       	rjmp	.+4      	; 0x58f2 <Timer16Stopp+0x24>
    58ee:	35 95       	asr	r19
    58f0:	27 95       	ror	r18
    58f2:	8a 95       	dec	r24
    58f4:	e2 f7       	brpl	.-8      	; 0x58ee <Timer16Stopp+0x20>
    58f6:	20 ff       	sbrs	r18, 0
    58f8:	0b c0       	rjmp	.+22     	; 0x5910 <Timer16Stopp+0x42>
    58fa:	ec 2f       	mov	r30, r28
    58fc:	f0 e0       	ldi	r31, 0x00	; 0
    58fe:	ee 0f       	add	r30, r30
    5900:	ff 1f       	adc	r31, r31
    5902:	ea 5d       	subi	r30, 0xDA	; 218
    5904:	fc 4f       	sbci	r31, 0xFC	; 252
    5906:	20 81       	ld	r18, Z
    5908:	31 81       	ldd	r19, Z+1	; 0x01
    590a:	c1 e0       	ldi	r28, 0x01	; 1
    590c:	23 2b       	or	r18, r19
    590e:	09 f0       	breq	.+2      	; 0x5912 <Timer16Stopp+0x44>
    5910:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5912:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
	return T_S;
}
    5916:	8c 2f       	mov	r24, r28
    5918:	cf 91       	pop	r28
    591a:	08 95       	ret

0000591c <Timer32Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
    591c:	cf 93       	push	r28
    591e:	c8 2f       	mov	r28, r24
	IntOff();
    5920:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    5924:	ac 2f       	mov	r26, r28
    5926:	a6 95       	lsr	r26
    5928:	a6 95       	lsr	r26
    592a:	a6 95       	lsr	r26
    592c:	b0 e0       	ldi	r27, 0x00	; 0
    592e:	a2 59       	subi	r26, 0x92	; 146
    5930:	bd 4f       	sbci	r27, 0xFD	; 253
    5932:	2c 91       	ld	r18, X
    5934:	30 e0       	ldi	r19, 0x00	; 0
    5936:	8c 2f       	mov	r24, r28
    5938:	87 70       	andi	r24, 0x07	; 7
    593a:	02 c0       	rjmp	.+4      	; 0x5940 <Timer32Stopp+0x24>
    593c:	35 95       	asr	r19
    593e:	27 95       	ror	r18
    5940:	8a 95       	dec	r24
    5942:	e2 f7       	brpl	.-8      	; 0x593c <Timer32Stopp+0x20>
    5944:	20 ff       	sbrs	r18, 0
    5946:	0f c0       	rjmp	.+30     	; 0x5966 <Timer32Stopp+0x4a>
    5948:	84 e0       	ldi	r24, 0x04	; 4
    594a:	c8 9f       	mul	r28, r24
    594c:	f0 01       	movw	r30, r0
    594e:	11 24       	eor	r1, r1
    5950:	ea 57       	subi	r30, 0x7A	; 122
    5952:	fd 4f       	sbci	r31, 0xFD	; 253
    5954:	40 81       	ld	r20, Z
    5956:	51 81       	ldd	r21, Z+1	; 0x01
    5958:	62 81       	ldd	r22, Z+2	; 0x02
    595a:	73 81       	ldd	r23, Z+3	; 0x03
    595c:	c1 e0       	ldi	r28, 0x01	; 1
    595e:	45 2b       	or	r20, r21
    5960:	46 2b       	or	r20, r22
    5962:	47 2b       	or	r20, r23
    5964:	09 f0       	breq	.+2      	; 0x5968 <Timer32Stopp+0x4c>
    5966:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5968:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
	return T_S;
}
    596c:	8c 2f       	mov	r24, r28
    596e:	cf 91       	pop	r28
    5970:	08 95       	ret

00005972 <ResetTimer16>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    5972:	cf 93       	push	r28
    5974:	c8 2f       	mov	r28, r24
	IntOff();
    5976:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    597a:	ac 2f       	mov	r26, r28
    597c:	a6 95       	lsr	r26
    597e:	a6 95       	lsr	r26
    5980:	a6 95       	lsr	r26
    5982:	b0 e0       	ldi	r27, 0x00	; 0
    5984:	ac 58       	subi	r26, 0x8C	; 140
    5986:	bd 4f       	sbci	r27, 0xFD	; 253
    5988:	8c 91       	ld	r24, X
    598a:	9c 2f       	mov	r25, r28
    598c:	97 70       	andi	r25, 0x07	; 7
    598e:	21 e0       	ldi	r18, 0x01	; 1
    5990:	30 e0       	ldi	r19, 0x00	; 0
    5992:	01 c0       	rjmp	.+2      	; 0x5996 <ResetTimer16+0x24>
    5994:	22 0f       	add	r18, r18
    5996:	9a 95       	dec	r25
    5998:	ea f7       	brpl	.-6      	; 0x5994 <ResetTimer16+0x22>
    599a:	82 2b       	or	r24, r18
    599c:	8c 93       	st	X, r24
	Timer16[TimerN] = 0;
    599e:	ec 2f       	mov	r30, r28
    59a0:	f0 e0       	ldi	r31, 0x00	; 0
    59a2:	ee 0f       	add	r30, r30
    59a4:	ff 1f       	adc	r31, r31
    59a6:	ea 5d       	subi	r30, 0xDA	; 218
    59a8:	fc 4f       	sbci	r31, 0xFC	; 252
    59aa:	11 82       	std	Z+1, r1	; 0x01
    59ac:	10 82       	st	Z, r1
	IntOn();
}
    59ae:	cf 91       	pop	r28
ResetTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
	Timer16[TimerN] = 0;
	IntOn();
    59b0:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

000059b4 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    59b4:	60 91 23 06 	lds	r22, 0x0623
    59b8:	85 ea       	ldi	r24, 0xA5	; 165
    59ba:	91 e0       	ldi	r25, 0x01	; 1
    59bc:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    59c0:	60 91 48 0e 	lds	r22, 0x0E48
    59c4:	70 91 49 0e 	lds	r23, 0x0E49
    59c8:	83 ea       	ldi	r24, 0xA3	; 163
    59ca:	91 e0       	ldi	r25, 0x01	; 1
    59cc:	0c 94 cd 29 	jmp	0x539a	; 0x539a <eww>

000059d0 <TimeInit>:
		CCP = CCP_IOREG_gc; CLK.CTRL = CLK_SCLKSEL_PLL_gc;
		CCP = CCP_IOREG_gc; CLK.LOCK = CLK_LOCK_bm;
	#endif

	// WDT
	WdtOn();
    59d0:	0e 94 85 2a 	call	0x550a	; 0x550a <WdtOn>

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    59d4:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    59d6:	8a ee       	ldi	r24, 0xEA	; 234
    59d8:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
    59da:	80 e2       	ldi	r24, 0x20	; 32
    59dc:	9e e4       	ldi	r25, 0x4E	; 78
    59de:	9b bd       	out	0x2b, r25	; 43
    59e0:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
    59e2:	87 b7       	in	r24, 0x37	; 55
    59e4:	80 61       	ori	r24, 0x10	; 16
    59e6:	87 bf       	out	0x37, r24	; 55
    59e8:	80 e0       	ldi	r24, 0x00	; 0
    59ea:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    59ec:	2f ef       	ldi	r18, 0xFF	; 255
    59ee:	fc 01       	movw	r30, r24
    59f0:	e3 58       	subi	r30, 0x83	; 131
    59f2:	fd 4f       	sbci	r31, 0xFD	; 253
    59f4:	20 83       	st	Z, r18
    59f6:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    59f8:	87 30       	cpi	r24, 0x07	; 7
    59fa:	91 05       	cpc	r25, r1
    59fc:	c1 f7       	brne	.-16     	; 0x59ee <TimeInit+0x1e>
    59fe:	80 e0       	ldi	r24, 0x00	; 0
    5a00:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    5a02:	3f ef       	ldi	r19, 0xFF	; 255
    5a04:	fc 01       	movw	r30, r24
    5a06:	ec 58       	subi	r30, 0x8C	; 140
    5a08:	fd 4f       	sbci	r31, 0xFD	; 253
    5a0a:	2f ef       	ldi	r18, 0xFF	; 255
    5a0c:	30 83       	st	Z, r19
    5a0e:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    5a10:	89 30       	cpi	r24, 0x09	; 9
    5a12:	91 05       	cpc	r25, r1
    5a14:	b9 f7       	brne	.-18     	; 0x5a04 <TimeInit+0x34>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    5a16:	20 93 6e 02 	sts	0x026E, r18
    5a1a:	20 93 6f 02 	sts	0x026F, r18
    5a1e:	20 93 70 02 	sts	0x0270, r18
    5a22:	20 93 71 02 	sts	0x0271, r18
    5a26:	20 93 72 02 	sts	0x0272, r18
    5a2a:	20 93 73 02 	sts	0x0273, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5a2e:	85 ea       	ldi	r24, 0xA5	; 165
    5a30:	91 e0       	ldi	r25, 0x01	; 1
    5a32:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    5a36:	80 93 23 06 	sts	0x0623, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5a3a:	83 ea       	ldi	r24, 0xA3	; 163
    5a3c:	91 e0       	ldi	r25, 0x01	; 1
    5a3e:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
    5a42:	90 93 49 0e 	sts	0x0E49, r25
    5a46:	80 93 48 0e 	sts	0x0E48, r24
    5a4a:	08 95       	ret

00005a4c <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    5a4c:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    5a50:	91 e0       	ldi	r25, 0x01	; 1
    5a52:	98 0f       	add	r25, r24
    5a54:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    5a58:	80 93 6d 02 	sts	0x026D, r24
	StartTimer8(TD_Scan, 0xFF);
    5a5c:	6f ef       	ldi	r22, 0xFF	; 255
    5a5e:	0c 94 9e 2a 	jmp	0x553c	; 0x553c <StartTimer8>

00005a62 <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    5a62:	1f 92       	push	r1
    5a64:	0f 92       	push	r0
    5a66:	0f b6       	in	r0, 0x3f	; 63
    5a68:	0f 92       	push	r0
    5a6a:	11 24       	eor	r1, r1
    5a6c:	0b b6       	in	r0, 0x3b	; 59
    5a6e:	0f 92       	push	r0
    5a70:	2f 93       	push	r18
    5a72:	3f 93       	push	r19
    5a74:	4f 93       	push	r20
    5a76:	5f 93       	push	r21
    5a78:	6f 93       	push	r22
    5a7a:	8f 93       	push	r24
    5a7c:	9f 93       	push	r25
    5a7e:	ef 93       	push	r30
    5a80:	ff 93       	push	r31
	TickCounter++;
    5a82:	80 91 6c 02 	lds	r24, 0x026C
    5a86:	8f 5f       	subi	r24, 0xFF	; 255
    5a88:	80 93 6c 02 	sts	0x026C, r24
    5a8c:	80 e0       	ldi	r24, 0x00	; 0
    5a8e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5a90:	41 e0       	ldi	r20, 0x01	; 1
    5a92:	50 e0       	ldi	r21, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    5a94:	20 91 84 02 	lds	r18, 0x0284
    5a98:	30 e0       	ldi	r19, 0x00	; 0
    5a9a:	08 2e       	mov	r0, r24
    5a9c:	02 c0       	rjmp	.+4      	; 0x5aa2 <__vector_12+0x40>
    5a9e:	35 95       	asr	r19
    5aa0:	27 95       	ror	r18
    5aa2:	0a 94       	dec	r0
    5aa4:	e2 f7       	brpl	.-8      	; 0x5a9e <__vector_12+0x3c>
    5aa6:	20 fd       	sbrc	r18, 0
    5aa8:	13 c0       	rjmp	.+38     	; 0x5ad0 <__vector_12+0x6e>
    5aaa:	fc 01       	movw	r30, r24
    5aac:	ea 52       	subi	r30, 0x2A	; 42
    5aae:	fc 4f       	sbci	r31, 0xFC	; 252
    5ab0:	20 81       	ld	r18, Z
    5ab2:	21 50       	subi	r18, 0x01	; 1
    5ab4:	20 83       	st	Z, r18
    5ab6:	21 11       	cpse	r18, r1
    5ab8:	0b c0       	rjmp	.+22     	; 0x5ad0 <__vector_12+0x6e>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5aba:	60 91 84 02 	lds	r22, 0x0284
    5abe:	9a 01       	movw	r18, r20
    5ac0:	08 2e       	mov	r0, r24
    5ac2:	01 c0       	rjmp	.+2      	; 0x5ac6 <__vector_12+0x64>
    5ac4:	22 0f       	add	r18, r18
    5ac6:	0a 94       	dec	r0
    5ac8:	ea f7       	brpl	.-6      	; 0x5ac4 <__vector_12+0x62>
    5aca:	62 2b       	or	r22, r18
    5acc:	60 93 84 02 	sts	0x0284, r22
    5ad0:	01 96       	adiw	r24, 0x01	; 1
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    5ad2:	88 30       	cpi	r24, 0x08	; 8
    5ad4:	91 05       	cpc	r25, r1
    5ad6:	f1 f6       	brne	.-68     	; 0x5a94 <__vector_12+0x32>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    5ad8:	ff 91       	pop	r31
    5ada:	ef 91       	pop	r30
    5adc:	9f 91       	pop	r25
    5ade:	8f 91       	pop	r24
    5ae0:	6f 91       	pop	r22
    5ae2:	5f 91       	pop	r21
    5ae4:	4f 91       	pop	r20
    5ae6:	3f 91       	pop	r19
    5ae8:	2f 91       	pop	r18
    5aea:	0f 90       	pop	r0
    5aec:	0b be       	out	0x3b, r0	; 59
    5aee:	0f 90       	pop	r0
    5af0:	0f be       	out	0x3f, r0	; 63
    5af2:	0f 90       	pop	r0
    5af4:	1f 90       	pop	r1
    5af6:	18 95       	reti

00005af8 <TimersInc>:
void 
TimersInc(void)
{
    5af8:	ef 92       	push	r14
    5afa:	ff 92       	push	r15
    5afc:	0f 93       	push	r16
    5afe:	1f 93       	push	r17
    5b00:	cf 93       	push	r28
    5b02:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    5b04:	f8 94       	cli
	TickCounterVar = TickCounter;
    5b06:	00 91 6c 02 	lds	r16, 0x026C
	TickCounter = 0;
    5b0a:	10 92 6c 02 	sts	0x026C, r1
	sei();
    5b0e:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b10:	10 e0       	ldi	r17, 0x00	; 0
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    5b12:	ee 24       	eor	r14, r14
    5b14:	e3 94       	inc	r14
    5b16:	f1 2c       	mov	r15, r1
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b18:	10 17       	cp	r17, r16
    5b1a:	09 f4       	brne	.+2      	; 0x5b1e <TimersInc+0x26>
    5b1c:	e2 c0       	rjmp	.+452    	; 0x5ce2 <TimersInc+0x1ea>
		LiveTime++;
    5b1e:	80 91 63 09 	lds	r24, 0x0963
    5b22:	90 91 64 09 	lds	r25, 0x0964
    5b26:	a0 91 65 09 	lds	r26, 0x0965
    5b2a:	b0 91 66 09 	lds	r27, 0x0966
    5b2e:	01 96       	adiw	r24, 0x01	; 1
    5b30:	a1 1d       	adc	r26, r1
    5b32:	b1 1d       	adc	r27, r1
    5b34:	80 93 63 09 	sts	0x0963, r24
    5b38:	90 93 64 09 	sts	0x0964, r25
    5b3c:	a0 93 65 09 	sts	0x0965, r26
    5b40:	b0 93 66 09 	sts	0x0966, r27
    5b44:	80 e0       	ldi	r24, 0x00	; 0
    5b46:	90 e0       	ldi	r25, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    5b48:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    5b4a:	e8 2f       	mov	r30, r24
    5b4c:	e6 95       	lsr	r30
    5b4e:	e6 95       	lsr	r30
    5b50:	e6 95       	lsr	r30
    5b52:	f0 e0       	ldi	r31, 0x00	; 0
    5b54:	e3 58       	subi	r30, 0x83	; 131
    5b56:	fd 4f       	sbci	r31, 0xFD	; 253
    5b58:	20 81       	ld	r18, Z
    5b5a:	58 2f       	mov	r21, r24
    5b5c:	57 70       	andi	r21, 0x07	; 7
    5b5e:	30 e0       	ldi	r19, 0x00	; 0
    5b60:	05 2e       	mov	r0, r21
    5b62:	02 c0       	rjmp	.+4      	; 0x5b68 <TimersInc+0x70>
    5b64:	35 95       	asr	r19
    5b66:	27 95       	ror	r18
    5b68:	0a 94       	dec	r0
    5b6a:	e2 f7       	brpl	.-8      	; 0x5b64 <TimersInc+0x6c>
    5b6c:	20 fd       	sbrc	r18, 0
    5b6e:	11 c0       	rjmp	.+34     	; 0x5b92 <TimersInc+0x9a>
    5b70:	dc 01       	movw	r26, r24
    5b72:	aa 55       	subi	r26, 0x5A	; 90
    5b74:	bc 4f       	sbci	r27, 0xFC	; 252
    5b76:	3c 91       	ld	r19, X
    5b78:	31 50       	subi	r19, 0x01	; 1
    5b7a:	3c 93       	st	X, r19
    5b7c:	31 11       	cpse	r19, r1
    5b7e:	09 c0       	rjmp	.+18     	; 0x5b92 <TimersInc+0x9a>
				Timer8Flg[i/8] |=(1<<i%8);
    5b80:	40 81       	ld	r20, Z
    5b82:	97 01       	movw	r18, r14
    5b84:	05 2e       	mov	r0, r21
    5b86:	01 c0       	rjmp	.+2      	; 0x5b8a <TimersInc+0x92>
    5b88:	22 0f       	add	r18, r18
    5b8a:	0a 94       	dec	r0
    5b8c:	ea f7       	brpl	.-6      	; 0x5b88 <TimersInc+0x90>
    5b8e:	42 2b       	or	r20, r18
    5b90:	40 83       	st	Z, r20
			sei();
    5b92:	78 94       	sei
    5b94:	01 96       	adiw	r24, 0x01	; 1
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    5b96:	80 33       	cpi	r24, 0x30	; 48
    5b98:	91 05       	cpc	r25, r1
    5b9a:	b1 f6       	brne	.-84     	; 0x5b48 <TimersInc+0x50>
    5b9c:	80 e0       	ldi	r24, 0x00	; 0
    5b9e:	90 e0       	ldi	r25, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    5ba0:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    5ba2:	e8 2f       	mov	r30, r24
    5ba4:	e6 95       	lsr	r30
    5ba6:	e6 95       	lsr	r30
    5ba8:	e6 95       	lsr	r30
    5baa:	f0 e0       	ldi	r31, 0x00	; 0
    5bac:	ec 58       	subi	r30, 0x8C	; 140
    5bae:	fd 4f       	sbci	r31, 0xFD	; 253
    5bb0:	20 81       	ld	r18, Z
    5bb2:	58 2f       	mov	r21, r24
    5bb4:	57 70       	andi	r21, 0x07	; 7
    5bb6:	30 e0       	ldi	r19, 0x00	; 0
    5bb8:	05 2e       	mov	r0, r21
    5bba:	02 c0       	rjmp	.+4      	; 0x5bc0 <TimersInc+0xc8>
    5bbc:	35 95       	asr	r19
    5bbe:	27 95       	ror	r18
    5bc0:	0a 94       	dec	r0
    5bc2:	e2 f7       	brpl	.-8      	; 0x5bbc <TimersInc+0xc4>
    5bc4:	20 fd       	sbrc	r18, 0
    5bc6:	18 c0       	rjmp	.+48     	; 0x5bf8 <TimersInc+0x100>
    5bc8:	dc 01       	movw	r26, r24
    5bca:	aa 0f       	add	r26, r26
    5bcc:	bb 1f       	adc	r27, r27
    5bce:	aa 5d       	subi	r26, 0xDA	; 218
    5bd0:	bc 4f       	sbci	r27, 0xFC	; 252
    5bd2:	2d 91       	ld	r18, X+
    5bd4:	3c 91       	ld	r19, X
    5bd6:	11 97       	sbiw	r26, 0x01	; 1
    5bd8:	21 50       	subi	r18, 0x01	; 1
    5bda:	31 09       	sbc	r19, r1
    5bdc:	11 96       	adiw	r26, 0x01	; 1
    5bde:	3c 93       	st	X, r19
    5be0:	2e 93       	st	-X, r18
    5be2:	23 2b       	or	r18, r19
    5be4:	49 f4       	brne	.+18     	; 0x5bf8 <TimersInc+0x100>
				Timer16Flg[i/8] |=(1<<i%8);
    5be6:	40 81       	ld	r20, Z
    5be8:	97 01       	movw	r18, r14
    5bea:	05 2e       	mov	r0, r21
    5bec:	01 c0       	rjmp	.+2      	; 0x5bf0 <TimersInc+0xf8>
    5bee:	22 0f       	add	r18, r18
    5bf0:	0a 94       	dec	r0
    5bf2:	ea f7       	brpl	.-6      	; 0x5bee <TimersInc+0xf6>
    5bf4:	42 2b       	or	r20, r18
    5bf6:	40 83       	st	Z, r20
			sei();
    5bf8:	78 94       	sei
    5bfa:	01 96       	adiw	r24, 0x01	; 1
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    5bfc:	80 34       	cpi	r24, 0x40	; 64
    5bfe:	91 05       	cpc	r25, r1
    5c00:	79 f6       	brne	.-98     	; 0x5ba0 <TimersInc+0xa8>
    5c02:	20 e0       	ldi	r18, 0x00	; 0
    5c04:	30 e0       	ldi	r19, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    5c06:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    5c08:	e2 2f       	mov	r30, r18
    5c0a:	e6 95       	lsr	r30
    5c0c:	e6 95       	lsr	r30
    5c0e:	e6 95       	lsr	r30
    5c10:	f0 e0       	ldi	r31, 0x00	; 0
    5c12:	e2 59       	subi	r30, 0x92	; 146
    5c14:	fd 4f       	sbci	r31, 0xFD	; 253
    5c16:	80 81       	ld	r24, Z
    5c18:	62 2f       	mov	r22, r18
    5c1a:	67 70       	andi	r22, 0x07	; 7
    5c1c:	90 e0       	ldi	r25, 0x00	; 0
    5c1e:	06 2e       	mov	r0, r22
    5c20:	02 c0       	rjmp	.+4      	; 0x5c26 <TimersInc+0x12e>
    5c22:	95 95       	asr	r25
    5c24:	87 95       	ror	r24
    5c26:	0a 94       	dec	r0
    5c28:	e2 f7       	brpl	.-8      	; 0x5c22 <TimersInc+0x12a>
    5c2a:	80 fd       	sbrc	r24, 0
    5c2c:	20 c0       	rjmp	.+64     	; 0x5c6e <TimersInc+0x176>
    5c2e:	a9 01       	movw	r20, r18
    5c30:	44 0f       	add	r20, r20
    5c32:	55 1f       	adc	r21, r21
    5c34:	44 0f       	add	r20, r20
    5c36:	55 1f       	adc	r21, r21
    5c38:	4a 57       	subi	r20, 0x7A	; 122
    5c3a:	5d 4f       	sbci	r21, 0xFD	; 253
    5c3c:	ea 01       	movw	r28, r20
    5c3e:	88 81       	ld	r24, Y
    5c40:	99 81       	ldd	r25, Y+1	; 0x01
    5c42:	aa 81       	ldd	r26, Y+2	; 0x02
    5c44:	bb 81       	ldd	r27, Y+3	; 0x03
    5c46:	01 97       	sbiw	r24, 0x01	; 1
    5c48:	a1 09       	sbc	r26, r1
    5c4a:	b1 09       	sbc	r27, r1
    5c4c:	88 83       	st	Y, r24
    5c4e:	99 83       	std	Y+1, r25	; 0x01
    5c50:	aa 83       	std	Y+2, r26	; 0x02
    5c52:	bb 83       	std	Y+3, r27	; 0x03
    5c54:	89 2b       	or	r24, r25
    5c56:	8a 2b       	or	r24, r26
    5c58:	8b 2b       	or	r24, r27
    5c5a:	49 f4       	brne	.+18     	; 0x5c6e <TimersInc+0x176>
				Timer32Flg[i/8] |=(1<<i%8);	
    5c5c:	40 81       	ld	r20, Z
    5c5e:	c7 01       	movw	r24, r14
    5c60:	06 2e       	mov	r0, r22
    5c62:	01 c0       	rjmp	.+2      	; 0x5c66 <TimersInc+0x16e>
    5c64:	88 0f       	add	r24, r24
    5c66:	0a 94       	dec	r0
    5c68:	ea f7       	brpl	.-6      	; 0x5c64 <TimersInc+0x16c>
    5c6a:	48 2b       	or	r20, r24
    5c6c:	40 83       	st	Z, r20
			sei();
    5c6e:	78 94       	sei
    5c70:	2f 5f       	subi	r18, 0xFF	; 255
    5c72:	3f 4f       	sbci	r19, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    5c74:	28 32       	cpi	r18, 0x28	; 40
    5c76:	31 05       	cpc	r19, r1
    5c78:	31 f6       	brne	.-116    	; 0x5c06 <TimersInc+0x10e>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    5c7a:	80 91 45 02 	lds	r24, 0x0245
    5c7e:	8f 5f       	subi	r24, 0xFF	; 255
    5c80:	80 93 45 02 	sts	0x0245, r24
    5c84:	84 36       	cpi	r24, 0x64	; 100
    5c86:	59 f5       	brne	.+86     	; 0x5cde <TimersInc+0x1e6>
			Timer10ms = 0;
    5c88:	10 92 45 02 	sts	0x0245, r1
			ScanPerSec = ScanCount;
    5c8c:	80 91 45 09 	lds	r24, 0x0945
    5c90:	90 91 46 09 	lds	r25, 0x0946
    5c94:	90 93 72 09 	sts	0x0972, r25
    5c98:	80 93 71 09 	sts	0x0971, r24
 			ScanCount = 0;
    5c9c:	10 92 46 09 	sts	0x0946, r1
    5ca0:	10 92 45 09 	sts	0x0945, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    5ca4:	80 91 0e 0b 	lds	r24, 0x0B0E
    5ca8:	8f 5f       	subi	r24, 0xFF	; 255
    5caa:	80 93 0e 0b 	sts	0x0B0E, r24
    5cae:	8c 33       	cpi	r24, 0x3C	; 60
    5cb0:	b1 f4       	brne	.+44     	; 0x5cde <TimersInc+0x1e6>
		Timer1s = 0;
    5cb2:	10 92 0e 0b 	sts	0x0B0E, r1
		if (++Timer1min==60) {
    5cb6:	80 91 23 06 	lds	r24, 0x0623
    5cba:	8f 5f       	subi	r24, 0xFF	; 255
    5cbc:	80 93 23 06 	sts	0x0623, r24
    5cc0:	8c 33       	cpi	r24, 0x3C	; 60
    5cc2:	69 f4       	brne	.+26     	; 0x5cde <TimersInc+0x1e6>
			Timer1min = 0;
    5cc4:	10 92 23 06 	sts	0x0623, r1
			++Timer1hour;
    5cc8:	80 91 48 0e 	lds	r24, 0x0E48
    5ccc:	90 91 49 0e 	lds	r25, 0x0E49
    5cd0:	01 96       	adiw	r24, 0x01	; 1
    5cd2:	90 93 49 0e 	sts	0x0E49, r25
    5cd6:	80 93 48 0e 	sts	0x0E48, r24
			OnTimeSave();
    5cda:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <OnTimeSave>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5cde:	1f 5f       	subi	r17, 0xFF	; 255
    5ce0:	1b cf       	rjmp	.-458    	; 0x5b18 <TimersInc+0x20>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    5ce2:	df 91       	pop	r29
    5ce4:	cf 91       	pop	r28
    5ce6:	1f 91       	pop	r17
    5ce8:	0f 91       	pop	r16
    5cea:	ff 90       	pop	r15
    5cec:	ef 90       	pop	r14
    5cee:	08 95       	ret

00005cf0 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    5cf0:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    5cf2:	80 91 45 09 	lds	r24, 0x0945
    5cf6:	90 91 46 09 	lds	r25, 0x0946
    5cfa:	01 96       	adiw	r24, 0x01	; 1
    5cfc:	90 93 46 09 	sts	0x0946, r25
    5d00:	80 93 45 09 	sts	0x0945, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    5d04:	80 91 6d 02 	lds	r24, 0x026D
    5d08:	e8 2f       	mov	r30, r24
    5d0a:	f0 e0       	ldi	r31, 0x00	; 0
    5d0c:	ea 55       	subi	r30, 0x5A	; 90
    5d0e:	fc 4f       	sbci	r31, 0xFC	; 252
    5d10:	90 81       	ld	r25, Z
    5d12:	90 95       	com	r25
    5d14:	90 93 3e 09 	sts	0x093E, r25
    5d18:	20 91 24 06 	lds	r18, 0x0624
    5d1c:	29 17       	cp	r18, r25
    5d1e:	10 f4       	brcc	.+4      	; 0x5d24 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    5d20:	90 93 24 06 	sts	0x0624, r25
	StartTimer8(TD_Scan, 0xFF);
    5d24:	6f ef       	ldi	r22, 0xFF	; 255
    5d26:	0c 94 9e 2a 	jmp	0x553c	; 0x553c <StartTimer8>

00005d2a <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    5d2a:	bc 01       	movw	r22, r24
    5d2c:	80 e0       	ldi	r24, 0x00	; 0
    5d2e:	90 e0       	ldi	r25, 0x00	; 0
    5d30:	0e 94 89 6d 	call	0xdb12	; 0xdb12 <__floatunsisf>
    5d34:	2d ec       	ldi	r18, 0xCD	; 205
    5d36:	3c ec       	ldi	r19, 0xCC	; 204
    5d38:	4c e4       	ldi	r20, 0x4C	; 76
    5d3a:	5f e3       	ldi	r21, 0x3F	; 63
    5d3c:	0e 94 17 6e 	call	0xdc2e	; 0xdc2e <__mulsf3>
    5d40:	0e 94 5d 6d 	call	0xdaba	; 0xdaba <__fixunssfsi>
	while (Delay--)
    5d44:	61 15       	cp	r22, r1
    5d46:	71 05       	cpc	r23, r1
    5d48:	39 f0       	breq	.+14     	; 0x5d58 <Delay_us+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5d4a:	85 e0       	ldi	r24, 0x05	; 5
    5d4c:	8a 95       	dec	r24
    5d4e:	f1 f7       	brne	.-4      	; 0x5d4c <Delay_us+0x22>
    5d50:	00 00       	nop
    5d52:	61 50       	subi	r22, 0x01	; 1
    5d54:	71 09       	sbc	r23, r1
    5d56:	f6 cf       	rjmp	.-20     	; 0x5d44 <Delay_us+0x1a>
		_delay_us(1);
}
    5d58:	08 95       	ret

00005d5a <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5d5a:	8c 9a       	sbi	0x11, 4	; 17
    5d5c:	94 98       	cbi	0x12, 4	; 18
    5d5e:	08 95       	ret

00005d60 <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    5d60:	81 11       	cpse	r24, r1
    5d62:	0a c0       	rjmp	.+20     	; 0x5d78 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5d64:	80 91 64 00 	lds	r24, 0x0064
    5d68:	81 60       	ori	r24, 0x01	; 1
    5d6a:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d6e:	80 91 65 00 	lds	r24, 0x0065
    5d72:	8e 7f       	andi	r24, 0xFE	; 254
    5d74:	80 93 65 00 	sts	0x0065, r24
    5d78:	08 95       	ret

00005d7a <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5d7a:	81 11       	cpse	r24, r1
    5d7c:	0a c0       	rjmp	.+20     	; 0x5d92 <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    5d7e:	80 91 64 00 	lds	r24, 0x0064
    5d82:	8e 7f       	andi	r24, 0xFE	; 254
    5d84:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d88:	80 91 65 00 	lds	r24, 0x0065
    5d8c:	8e 7f       	andi	r24, 0xFE	; 254
    5d8e:	80 93 65 00 	sts	0x0065, r24
    5d92:	08 95       	ret

00005d94 <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    5d94:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    5d96:	17 9a       	sbi	0x02, 7	; 2
	sei();
    5d98:	78 94       	sei
    5d9a:	08 95       	ret

00005d9c <GSM_PWRCNTRL_OFF>:
}
void GSM_PWRCNTRL_OFF(void){
	cli();
    5d9c:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    5d9e:	1f 98       	cbi	0x03, 7	; 3
	sei();
    5da0:	78 94       	sei
    5da2:	08 95       	ret

00005da4 <GSM_PWRCNTRL_ON>:
}
void GSM_PWRCNTRL_ON(void){
	cli();
    5da4:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    5da6:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    5da8:	78 94       	sei
    5daa:	08 95       	ret

00005dac <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    5dac:	8d 9a       	sbi	0x11, 5	; 17
    5dae:	08 95       	ret

00005db0 <CTS_OFF>:
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    5db0:	95 98       	cbi	0x12, 5	; 18
    5db2:	08 95       	ret

00005db4 <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    5db4:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    5db6:	96 9a       	sbi	0x12, 6	; 18
    5db8:	08 95       	ret

00005dba <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    5dba:	1f 92       	push	r1
    5dbc:	0f 92       	push	r0
    5dbe:	0f b6       	in	r0, 0x3f	; 63
    5dc0:	0f 92       	push	r0
    5dc2:	11 24       	eor	r1, r1
    5dc4:	0b b6       	in	r0, 0x3b	; 59
    5dc6:	0f 92       	push	r0
    5dc8:	2f 93       	push	r18
    5dca:	3f 93       	push	r19
    5dcc:	4f 93       	push	r20
    5dce:	5f 93       	push	r21
    5dd0:	6f 93       	push	r22
    5dd2:	7f 93       	push	r23
    5dd4:	8f 93       	push	r24
    5dd6:	9f 93       	push	r25
    5dd8:	af 93       	push	r26
    5dda:	bf 93       	push	r27
    5ddc:	ef 93       	push	r30
    5dde:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5de0:	83 b7       	in	r24, 0x33	; 51
    5de2:	88 7f       	andi	r24, 0xF8	; 248
    5de4:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    5de6:	87 b7       	in	r24, 0x37	; 55
    5de8:	8d 7f       	andi	r24, 0xFD	; 253
    5dea:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    5dec:	82 e5       	ldi	r24, 0x52	; 82
    5dee:	90 e0       	ldi	r25, 0x00	; 0
    5df0:	0e 94 34 28 	call	0x5068	; 0x5068 <MB_Timer_ISR>
}
    5df4:	ff 91       	pop	r31
    5df6:	ef 91       	pop	r30
    5df8:	bf 91       	pop	r27
    5dfa:	af 91       	pop	r26
    5dfc:	9f 91       	pop	r25
    5dfe:	8f 91       	pop	r24
    5e00:	7f 91       	pop	r23
    5e02:	6f 91       	pop	r22
    5e04:	5f 91       	pop	r21
    5e06:	4f 91       	pop	r20
    5e08:	3f 91       	pop	r19
    5e0a:	2f 91       	pop	r18
    5e0c:	0f 90       	pop	r0
    5e0e:	0b be       	out	0x3b, r0	; 59
    5e10:	0f 90       	pop	r0
    5e12:	0f be       	out	0x3f, r0	; 63
    5e14:	0f 90       	pop	r0
    5e16:	1f 90       	pop	r1
    5e18:	18 95       	reti

00005e1a <__vector_9>:

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    5e1a:	1f 92       	push	r1
    5e1c:	0f 92       	push	r0
    5e1e:	0f b6       	in	r0, 0x3f	; 63
    5e20:	0f 92       	push	r0
    5e22:	11 24       	eor	r1, r1
    5e24:	0b b6       	in	r0, 0x3b	; 59
    5e26:	0f 92       	push	r0
    5e28:	2f 93       	push	r18
    5e2a:	3f 93       	push	r19
    5e2c:	4f 93       	push	r20
    5e2e:	5f 93       	push	r21
    5e30:	6f 93       	push	r22
    5e32:	7f 93       	push	r23
    5e34:	8f 93       	push	r24
    5e36:	9f 93       	push	r25
    5e38:	af 93       	push	r26
    5e3a:	bf 93       	push	r27
    5e3c:	ef 93       	push	r30
    5e3e:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5e40:	85 b5       	in	r24, 0x25	; 37
    5e42:	88 7f       	andi	r24, 0xF8	; 248
    5e44:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    5e46:	87 b7       	in	r24, 0x37	; 55
    5e48:	8f 77       	andi	r24, 0x7F	; 127
    5e4a:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    5e4c:	84 e4       	ldi	r24, 0x44	; 68
    5e4e:	90 e0       	ldi	r25, 0x00	; 0
    5e50:	0e 94 34 28 	call	0x5068	; 0x5068 <MB_Timer_ISR>
}
    5e54:	ff 91       	pop	r31
    5e56:	ef 91       	pop	r30
    5e58:	bf 91       	pop	r27
    5e5a:	af 91       	pop	r26
    5e5c:	9f 91       	pop	r25
    5e5e:	8f 91       	pop	r24
    5e60:	7f 91       	pop	r23
    5e62:	6f 91       	pop	r22
    5e64:	5f 91       	pop	r21
    5e66:	4f 91       	pop	r20
    5e68:	3f 91       	pop	r19
    5e6a:	2f 91       	pop	r18
    5e6c:	0f 90       	pop	r0
    5e6e:	0b be       	out	0x3b, r0	; 59
    5e70:	0f 90       	pop	r0
    5e72:	0f be       	out	0x3f, r0	; 63
    5e74:	0f 90       	pop	r0
    5e76:	1f 90       	pop	r1
    5e78:	18 95       	reti

00005e7a <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    5e7a:	ff 92       	push	r15
    5e7c:	0f 93       	push	r16
    5e7e:	1f 93       	push	r17
    5e80:	cf 93       	push	r28
    5e82:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    5e84:	08 2f       	mov	r16, r24
    5e86:	10 e0       	ldi	r17, 0x00	; 0
    5e88:	e8 01       	movw	r28, r16
    5e8a:	cc 0f       	add	r28, r28
    5e8c:	dd 1f       	adc	r29, r29
    5e8e:	c0 0f       	add	r28, r16
    5e90:	d1 1f       	adc	r29, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5e92:	ce 01       	movw	r24, r28
    5e94:	81 56       	subi	r24, 0x61	; 97
    5e96:	9e 4f       	sbci	r25, 0xFE	; 254
    5e98:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    5e9c:	f8 2e       	mov	r15, r24
    5e9e:	c0 56       	subi	r28, 0x60	; 96
    5ea0:	de 4f       	sbci	r29, 0xFE	; 254
    5ea2:	ce 01       	movw	r24, r28
    5ea4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    5ea8:	f1 10       	cpse	r15, r1
    5eaa:	04 c0       	rjmp	.+8      	; 0x5eb4 <SetParity+0x3a>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    5eac:	81 30       	cpi	r24, 0x01	; 1
    5eae:	39 f4       	brne	.+14     	; 0x5ebe <SetParity+0x44>
			case 1:
				ucsrc &=~(1<<3);
    5eb0:	96 e8       	ldi	r25, 0x86	; 134
    5eb2:	08 c0       	rjmp	.+16     	; 0x5ec4 <SetParity+0x4a>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    5eb4:	91 e0       	ldi	r25, 0x01	; 1
    5eb6:	f9 12       	cpse	r15, r25
    5eb8:	04 c0       	rjmp	.+8      	; 0x5ec2 <SetParity+0x48>
			case EvenParity:
				ucsrc = (ucsrc |(1<<5)) &~(1<<4);
    5eba:	96 ea       	ldi	r25, 0xA6	; 166
    5ebc:	03 c0       	rjmp	.+6      	; 0x5ec4 <SetParity+0x4a>
{
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
			ucsrc &=~(1<<5) &~(1<<4);
    5ebe:	9e e8       	ldi	r25, 0x8E	; 142
    5ec0:	01 c0       	rjmp	.+2      	; 0x5ec4 <SetParity+0x4a>
				ucsrc  |=(1<<3);
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
    5ec2:	96 eb       	ldi	r25, 0xB6	; 182
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    5ec4:	24 e1       	ldi	r18, 0x14	; 20
    5ec6:	20 9f       	mul	r18, r16
    5ec8:	f0 01       	movw	r30, r0
    5eca:	21 9f       	mul	r18, r17
    5ecc:	f0 0d       	add	r31, r0
    5ece:	11 24       	eor	r1, r1
    5ed0:	e3 56       	subi	r30, 0x63	; 99
    5ed2:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ed4:	a5 91       	lpm	r26, Z+
    5ed6:	b4 91       	lpm	r27, Z
    5ed8:	9c 93       	st	X, r25
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    5eda:	ff 20       	and	r15, r15
    5edc:	59 f0       	breq	.+22     	; 0x5ef4 <SetParity+0x7a>
    5ede:	81 30       	cpi	r24, 0x01	; 1
    5ee0:	49 f0       	breq	.+18     	; 0x5ef4 <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
    5ee2:	61 e0       	ldi	r22, 0x01	; 1
    5ee4:	ce 01       	movw	r24, r28
}
    5ee6:	df 91       	pop	r29
    5ee8:	cf 91       	pop	r28
    5eea:	1f 91       	pop	r17
    5eec:	0f 91       	pop	r16
    5eee:	ff 90       	pop	r15
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
    5ef0:	0c 94 c2 29 	jmp	0x5384	; 0x5384 <ewb>
}
    5ef4:	df 91       	pop	r29
    5ef6:	cf 91       	pop	r28
    5ef8:	1f 91       	pop	r17
    5efa:	0f 91       	pop	r16
    5efc:	ff 90       	pop	r15
    5efe:	08 95       	ret

00005f00 <SetBAUD>:

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    5f00:	cf 93       	push	r28
    5f02:	df 93       	push	r29
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    5f04:	c8 2f       	mov	r28, r24
    5f06:	d0 e0       	ldi	r29, 0x00	; 0
    5f08:	ce 01       	movw	r24, r28
    5f0a:	88 0f       	add	r24, r24
    5f0c:	99 1f       	adc	r25, r25
    5f0e:	8c 0f       	add	r24, r28
    5f10:	9d 1f       	adc	r25, r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5f12:	8f 55       	subi	r24, 0x5F	; 95
    5f14:	9e 4f       	sbci	r25, 0xFE	; 254
    5f16:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    5f1a:	fe 01       	movw	r30, r28
    5f1c:	e1 59       	subi	r30, 0x91	; 145
    5f1e:	f6 4f       	sbci	r31, 0xF6	; 246
    5f20:	80 83       	st	Z, r24
    5f22:	23 e0       	ldi	r18, 0x03	; 3
    5f24:	82 9f       	mul	r24, r18
    5f26:	c0 01       	movw	r24, r0
    5f28:	11 24       	eor	r1, r1
    5f2a:	85 55       	subi	r24, 0x55	; 85
    5f2c:	90 4b       	sbci	r25, 0xB0	; 176
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    5f2e:	24 e1       	ldi	r18, 0x14	; 20
    5f30:	2c 9f       	mul	r18, r28
    5f32:	f0 01       	movw	r30, r0
    5f34:	2d 9f       	mul	r18, r29
    5f36:	f0 0d       	add	r31, r0
    5f38:	11 24       	eor	r1, r1
    5f3a:	ef 55       	subi	r30, 0x5F	; 95
    5f3c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f3e:	a5 91       	lpm	r26, Z+
    5f40:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f42:	fc 01       	movw	r30, r24
    5f44:	24 91       	lpm	r18, Z
    5f46:	2c 93       	st	X, r18
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    5f48:	24 e1       	ldi	r18, 0x14	; 20
    5f4a:	2c 9f       	mul	r18, r28
    5f4c:	f0 01       	movw	r30, r0
    5f4e:	2d 9f       	mul	r18, r29
    5f50:	f0 0d       	add	r31, r0
    5f52:	11 24       	eor	r1, r1
    5f54:	e1 56       	subi	r30, 0x61	; 97
    5f56:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f58:	a5 91       	lpm	r26, Z+
    5f5a:	b4 91       	lpm	r27, Z
    5f5c:	fc 01       	movw	r30, r24
    5f5e:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f60:	e4 91       	lpm	r30, Z
    5f62:	ec 93       	st	X, r30

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    5f64:	26 e0       	ldi	r18, 0x06	; 6
    5f66:	2c 9f       	mul	r18, r28
    5f68:	f0 01       	movw	r30, r0
    5f6a:	2d 9f       	mul	r18, r29
    5f6c:	f0 0d       	add	r31, r0
    5f6e:	11 24       	eor	r1, r1
    5f70:	e3 57       	subi	r30, 0x73	; 115
    5f72:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f74:	a5 91       	lpm	r26, Z+
    5f76:	b4 91       	lpm	r27, Z
    5f78:	fc 01       	movw	r30, r24
    5f7a:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f7c:	84 91       	lpm	r24, Z
    5f7e:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    5f80:	df 91       	pop	r29
    5f82:	cf 91       	pop	r28
    5f84:	08 95       	ret

00005f86 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5f86:	cf 93       	push	r28
    5f88:	df 93       	push	r29
	MB_State[MB_N] = MB_Trans;
    5f8a:	c8 2f       	mov	r28, r24
    5f8c:	d0 e0       	ldi	r29, 0x00	; 0
    5f8e:	fe 01       	movw	r30, r28
    5f90:	ef 51       	subi	r30, 0x1F	; 31
    5f92:	fc 4f       	sbci	r31, 0xFC	; 252
    5f94:	83 e0       	ldi	r24, 0x03	; 3
    5f96:	80 83       	st	Z, r24
	USART_Func(MB_N, RS485);
    5f98:	84 e1       	ldi	r24, 0x14	; 20
    5f9a:	8c 9f       	mul	r24, r28
    5f9c:	f0 01       	movw	r30, r0
    5f9e:	8d 9f       	mul	r24, r29
    5fa0:	f0 0d       	add	r31, r0
    5fa2:	11 24       	eor	r1, r1
    5fa4:	ed 55       	subi	r30, 0x5D	; 93
    5fa6:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fa8:	85 91       	lpm	r24, Z+
    5faa:	94 91       	lpm	r25, Z
    5fac:	fc 01       	movw	r30, r24
    5fae:	09 95       	icall
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5fb0:	84 e1       	ldi	r24, 0x14	; 20
    5fb2:	8c 9f       	mul	r24, r28
    5fb4:	f0 01       	movw	r30, r0
    5fb6:	8d 9f       	mul	r24, r29
    5fb8:	f0 0d       	add	r31, r0
    5fba:	11 24       	eor	r1, r1
    5fbc:	e9 56       	subi	r30, 0x69	; 105
    5fbe:	f0 4b       	sbci	r31, 0xB0	; 176
    5fc0:	a5 91       	lpm	r26, Z+
    5fc2:	b4 91       	lpm	r27, Z
    5fc4:	fc 2f       	mov	r31, r28
    5fc6:	ee 27       	eor	r30, r30
    5fc8:	e8 5b       	subi	r30, 0xB8	; 184
    5fca:	f2 4f       	sbci	r31, 0xF2	; 242
    5fcc:	80 81       	ld	r24, Z
    5fce:	8c 93       	st	X, r24

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5fd0:	84 e1       	ldi	r24, 0x14	; 20
    5fd2:	8c 9f       	mul	r24, r28
    5fd4:	f0 01       	movw	r30, r0
    5fd6:	8d 9f       	mul	r24, r29
    5fd8:	f0 0d       	add	r31, r0
    5fda:	11 24       	eor	r1, r1
    5fdc:	e7 56       	subi	r30, 0x67	; 103
    5fde:	f0 4b       	sbci	r31, 0xB0	; 176
    5fe0:	a5 91       	lpm	r26, Z+
    5fe2:	b4 91       	lpm	r27, Z
    5fe4:	8c 91       	ld	r24, X
    5fe6:	80 64       	ori	r24, 0x40	; 64
    5fe8:	8c 93       	st	X, r24
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    5fea:	84 e1       	ldi	r24, 0x14	; 20
    5fec:	8c 9f       	mul	r24, r28
    5fee:	f0 01       	movw	r30, r0
    5ff0:	8d 9f       	mul	r24, r29
    5ff2:	f0 0d       	add	r31, r0
    5ff4:	11 24       	eor	r1, r1
    5ff6:	e5 56       	subi	r30, 0x65	; 101
    5ff8:	f0 4b       	sbci	r31, 0xB0	; 176
    5ffa:	a5 91       	lpm	r26, Z+
    5ffc:	b4 91       	lpm	r27, Z
    5ffe:	8c 91       	ld	r24, X
    6000:	80 62       	ori	r24, 0x20	; 32
    6002:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    6004:	df 91       	pop	r29
    6006:	cf 91       	pop	r28
    6008:	08 95       	ret

0000600a <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    600a:	cf 93       	push	r28
    600c:	df 93       	push	r29
    600e:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6010:	80 e0       	ldi	r24, 0x00	; 0
    6012:	94 e1       	ldi	r25, 0x14	; 20
    6014:	c8 2f       	mov	r28, r24
    6016:	d0 e0       	ldi	r29, 0x00	; 0
    6018:	9c 9f       	mul	r25, r28
    601a:	f0 01       	movw	r30, r0
    601c:	9d 9f       	mul	r25, r29
    601e:	f0 0d       	add	r31, r0
    6020:	11 24       	eor	r1, r1
    6022:	e9 56       	subi	r30, 0x69	; 105
    6024:	f0 4b       	sbci	r31, 0xB0	; 176
    6026:	25 91       	lpm	r18, Z+
    6028:	34 91       	lpm	r19, Z
    602a:	a2 17       	cp	r26, r18
    602c:	b3 07       	cpc	r27, r19
    602e:	11 f0       	breq	.+4      	; 0x6034 <Modbus_RX+0x2a>
    6030:	8f 5f       	subi	r24, 0xFF	; 255
    6032:	f0 cf       	rjmp	.-32     	; 0x6014 <Modbus_RX+0xa>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    6034:	fe 01       	movw	r30, r28
    6036:	ef 51       	subi	r30, 0x1F	; 31
    6038:	fc 4f       	sbci	r31, 0xFC	; 252
    603a:	90 81       	ld	r25, Z
    603c:	92 30       	cpi	r25, 0x02	; 2
    603e:	a1 f1       	breq	.+104    	; 0x60a8 <Modbus_RX+0x9e>
    6040:	40 f5       	brcc	.+80     	; 0x6092 <Modbus_RX+0x88>
    6042:	99 23       	and	r25, r25
    6044:	51 f1       	breq	.+84     	; 0x609a <Modbus_RX+0x90>
    6046:	91 30       	cpi	r25, 0x01	; 1
    6048:	09 f0       	breq	.+2      	; 0x604c <Modbus_RX+0x42>
    604a:	3b c0       	rjmp	.+118    	; 0x60c2 <Modbus_RX+0xb8>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    604c:	92 e0       	ldi	r25, 0x02	; 2
    604e:	90 83       	st	Z, r25
		MB_Err &=~(1<<MB_N);
    6050:	21 e0       	ldi	r18, 0x01	; 1
    6052:	30 e0       	ldi	r19, 0x00	; 0
    6054:	08 2e       	mov	r0, r24
    6056:	01 c0       	rjmp	.+2      	; 0x605a <Modbus_RX+0x50>
    6058:	22 0f       	add	r18, r18
    605a:	0a 94       	dec	r0
    605c:	ea f7       	brpl	.-6      	; 0x6058 <Modbus_RX+0x4e>
    605e:	20 95       	com	r18
    6060:	90 91 6b 02 	lds	r25, 0x026B
    6064:	92 23       	and	r25, r18
    6066:	90 93 6b 02 	sts	0x026B, r25
		MB_Frame_Sz[MB_N] = 0;
    606a:	fe 01       	movw	r30, r28
    606c:	e7 52       	subi	r30, 0x27	; 39
    606e:	f7 4f       	sbci	r31, 0xF7	; 247
    6070:	10 82       	st	Z, r1
		MBRecept(MB_N);
    6072:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <MBRecept>
		MB_StartTimer(MB_N);
    6076:	86 e0       	ldi	r24, 0x06	; 6
    6078:	8c 9f       	mul	r24, r28
    607a:	f0 01       	movw	r30, r0
    607c:	8d 9f       	mul	r24, r29
    607e:	f0 0d       	add	r31, r0
    6080:	11 24       	eor	r1, r1
    6082:	e1 57       	subi	r30, 0x71	; 113
    6084:	f0 4b       	sbci	r31, 0xB0	; 176
    6086:	85 91       	lpm	r24, Z+
    6088:	94 91       	lpm	r25, Z
    608a:	fc 01       	movw	r30, r24
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    608c:	df 91       	pop	r29
    608e:	cf 91       	pop	r28
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
		MB_Err &=~(1<<MB_N);
		MB_Frame_Sz[MB_N] = 0;
		MBRecept(MB_N);
		MB_StartTimer(MB_N);
    6090:	09 94       	ijmp
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    6092:	96 30       	cpi	r25, 0x06	; 6
    6094:	b0 f4       	brcc	.+44     	; 0x60c2 <Modbus_RX+0xb8>
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    6096:	8c 91       	ld	r24, X
		break;
    6098:	14 c0       	rjmp	.+40     	; 0x60c2 <Modbus_RX+0xb8>
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    609a:	8c 91       	ld	r24, X
    609c:	fc 2f       	mov	r31, r28
    609e:	ee 27       	eor	r30, r30
    60a0:	e8 5b       	subi	r30, 0xB8	; 184
    60a2:	f2 4f       	sbci	r31, 0xF2	; 242
    60a4:	80 83       	st	Z, r24
    60a6:	02 c0       	rjmp	.+4      	; 0x60ac <Modbus_RX+0xa2>
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    60a8:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <MBRecept>
		MB_ClearTimer(MB_N);
    60ac:	86 e0       	ldi	r24, 0x06	; 6
    60ae:	8c 9f       	mul	r24, r28
    60b0:	f0 01       	movw	r30, r0
    60b2:	8d 9f       	mul	r24, r29
    60b4:	f0 0d       	add	r31, r0
    60b6:	11 24       	eor	r1, r1
    60b8:	e5 57       	subi	r30, 0x75	; 117
    60ba:	f0 4b       	sbci	r31, 0xB0	; 176
    60bc:	a5 91       	lpm	r26, Z+
    60be:	b4 91       	lpm	r27, Z
    60c0:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    60c2:	df 91       	pop	r29
    60c4:	cf 91       	pop	r28
    60c6:	08 95       	ret

000060c8 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    60c8:	0f 93       	push	r16
    60ca:	1f 93       	push	r17
    60cc:	cf 93       	push	r28
    60ce:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    60d0:	c8 2f       	mov	r28, r24
    60d2:	d0 e0       	ldi	r29, 0x00	; 0
    60d4:	fe 01       	movw	r30, r28
    60d6:	e7 52       	subi	r30, 0x27	; 39
    60d8:	f7 4f       	sbci	r31, 0xF7	; 247
    60da:	90 81       	ld	r25, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    60dc:	20 91 6b 02 	lds	r18, 0x026B
    60e0:	30 e0       	ldi	r19, 0x00	; 0
    60e2:	02 c0       	rjmp	.+4      	; 0x60e8 <CommErr+0x20>
    60e4:	35 95       	asr	r19
    60e6:	27 95       	ror	r18
    60e8:	8a 95       	dec	r24
    60ea:	e2 f7       	brpl	.-8      	; 0x60e4 <CommErr+0x1c>
    60ec:	20 fd       	sbrc	r18, 0
    60ee:	1b c0       	rjmp	.+54     	; 0x6126 <CommErr+0x5e>
    60f0:	93 30       	cpi	r25, 0x03	; 3
    60f2:	c8 f0       	brcs	.+50     	; 0x6126 <CommErr+0x5e>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    60f4:	2e ef       	ldi	r18, 0xFE	; 254
    60f6:	29 0f       	add	r18, r25
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    60f8:	7c 2f       	mov	r23, r28
    60fa:	66 27       	eor	r22, r22
    60fc:	68 5b       	subi	r22, 0xB8	; 184
    60fe:	72 4f       	sbci	r23, 0xF2	; 242
    6100:	fb 01       	movw	r30, r22
    6102:	e2 0f       	add	r30, r18
    6104:	f1 1d       	adc	r31, r1
    6106:	00 81       	ld	r16, Z
    6108:	11 81       	ldd	r17, Z+1	; 0x01
    610a:	30 e0       	ldi	r19, 0x00	; 0
    610c:	40 e0       	ldi	r20, 0x00	; 0
    610e:	50 e0       	ldi	r21, 0x00	; 0
    6110:	83 e1       	ldi	r24, 0x13	; 19
    6112:	98 e2       	ldi	r25, 0x28	; 40
    6114:	0e 94 91 29 	call	0x5322	; 0x5322 <CRC>
    6118:	21 e0       	ldi	r18, 0x01	; 1
    611a:	08 17       	cp	r16, r24
    611c:	19 07       	cpc	r17, r25
    611e:	09 f4       	brne	.+2      	; 0x6122 <CommErr+0x5a>
    6120:	20 e0       	ldi	r18, 0x00	; 0
    6122:	12 2f       	mov	r17, r18
    6124:	01 c0       	rjmp	.+2      	; 0x6128 <CommErr+0x60>
    6126:	11 e0       	ldi	r17, 0x01	; 1
    6128:	fe 01       	movw	r30, r28
    612a:	54 e0       	ldi	r21, 0x04	; 4
    612c:	ee 0f       	add	r30, r30
    612e:	ff 1f       	adc	r31, r31
    6130:	5a 95       	dec	r21
    6132:	e1 f7       	brne	.-8      	; 0x612c <CommErr+0x64>
	if (Err) {
		MB_CPT[MB_N][1]++;
    6134:	e7 5d       	subi	r30, 0xD7	; 215
    6136:	f4 4f       	sbci	r31, 0xF4	; 244
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
	if (Err) {
    6138:	11 23       	and	r17, r17
    613a:	79 f0       	breq	.+30     	; 0x615a <CommErr+0x92>
		MB_CPT[MB_N][1]++;
    613c:	22 81       	ldd	r18, Z+2	; 0x02
    613e:	33 81       	ldd	r19, Z+3	; 0x03
    6140:	2f 5f       	subi	r18, 0xFF	; 255
    6142:	3f 4f       	sbci	r19, 0xFF	; 255
    6144:	33 83       	std	Z+3, r19	; 0x03
    6146:	22 83       	std	Z+2, r18	; 0x02
		USART_Func(MB_N, LED_Err_On);
    6148:	84 e1       	ldi	r24, 0x14	; 20
    614a:	8c 9f       	mul	r24, r28
    614c:	f0 01       	movw	r30, r0
    614e:	8d 9f       	mul	r24, r29
    6150:	f0 0d       	add	r31, r0
    6152:	11 24       	eor	r1, r1
    6154:	e9 55       	subi	r30, 0x59	; 89
    6156:	f0 4b       	sbci	r31, 0xB0	; 176
    6158:	0e c0       	rjmp	.+28     	; 0x6176 <CommErr+0xae>
	}
	else {
		MB_CPT[MB_N][0]++;
    615a:	20 81       	ld	r18, Z
    615c:	31 81       	ldd	r19, Z+1	; 0x01
    615e:	2f 5f       	subi	r18, 0xFF	; 255
    6160:	3f 4f       	sbci	r19, 0xFF	; 255
    6162:	31 83       	std	Z+1, r19	; 0x01
    6164:	20 83       	st	Z, r18
		USART_Func(MB_N, LED_Err_Off);
    6166:	84 e1       	ldi	r24, 0x14	; 20
    6168:	8c 9f       	mul	r24, r28
    616a:	f0 01       	movw	r30, r0
    616c:	8d 9f       	mul	r24, r29
    616e:	f0 0d       	add	r31, r0
    6170:	11 24       	eor	r1, r1
    6172:	e7 55       	subi	r30, 0x57	; 87
    6174:	f0 4b       	sbci	r31, 0xB0	; 176
    6176:	25 91       	lpm	r18, Z+
    6178:	34 91       	lpm	r19, Z
    617a:	f9 01       	movw	r30, r18
    617c:	09 95       	icall
	}
	return Err;
}
    617e:	81 2f       	mov	r24, r17
    6180:	df 91       	pop	r29
    6182:	cf 91       	pop	r28
    6184:	1f 91       	pop	r17
    6186:	0f 91       	pop	r16
    6188:	08 95       	ret

0000618a <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    618a:	cf 93       	push	r28
    618c:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    618e:	68 2f       	mov	r22, r24
    6190:	70 e0       	ldi	r23, 0x00	; 0
    6192:	fb 01       	movw	r30, r22
    6194:	e7 52       	subi	r30, 0x27	; 39
    6196:	f7 4f       	sbci	r31, 0xF7	; 247
    6198:	20 81       	ld	r18, Z
    619a:	22 50       	subi	r18, 0x02	; 2
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    619c:	76 2f       	mov	r23, r22
    619e:	66 27       	eor	r22, r22
    61a0:	68 5b       	subi	r22, 0xB8	; 184
    61a2:	72 4f       	sbci	r23, 0xF2	; 242
    61a4:	eb 01       	movw	r28, r22
    61a6:	c2 0f       	add	r28, r18
    61a8:	d1 1d       	adc	r29, r1
    61aa:	30 e0       	ldi	r19, 0x00	; 0
    61ac:	40 e0       	ldi	r20, 0x00	; 0
    61ae:	50 e0       	ldi	r21, 0x00	; 0
    61b0:	83 e1       	ldi	r24, 0x13	; 19
    61b2:	98 e2       	ldi	r25, 0x28	; 40
    61b4:	0e 94 91 29 	call	0x5322	; 0x5322 <CRC>
    61b8:	99 83       	std	Y+1, r25	; 0x01
    61ba:	88 83       	st	Y, r24
}
    61bc:	df 91       	pop	r29
    61be:	cf 91       	pop	r28
    61c0:	08 95       	ret

000061c2 <FormData>:
}

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    61c2:	bf 92       	push	r11
    61c4:	cf 92       	push	r12
    61c6:	df 92       	push	r13
    61c8:	ef 92       	push	r14
    61ca:	ff 92       	push	r15
    61cc:	0f 93       	push	r16
    61ce:	1f 93       	push	r17
    61d0:	cf 93       	push	r28
    61d2:	df 93       	push	r29
    61d4:	b8 2e       	mov	r11, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    61d6:	c8 2f       	mov	r28, r24
    61d8:	d0 e0       	ldi	r29, 0x00	; 0
    61da:	dc 2e       	mov	r13, r28
    61dc:	cc 24       	eor	r12, r12
    61de:	86 01       	movw	r16, r12
    61e0:	08 5b       	subi	r16, 0xB8	; 184
    61e2:	12 4f       	sbci	r17, 0xF2	; 242
    61e4:	f8 01       	movw	r30, r16
    61e6:	81 81       	ldd	r24, Z+1	; 0x01
    61e8:	86 30       	cpi	r24, 0x06	; 6
    61ea:	f1 f0       	breq	.+60     	; 0x6228 <FormData+0x66>
    61ec:	48 f4       	brcc	.+18     	; 0x6200 <FormData+0x3e>
    61ee:	81 50       	subi	r24, 0x01	; 1
    61f0:	84 30       	cpi	r24, 0x04	; 4
    61f2:	08 f0       	brcs	.+2      	; 0x61f6 <FormData+0x34>
    61f4:	c9 c0       	rjmp	.+402    	; 0x6388 <FormData+0x1c6>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    61f6:	c7 52       	subi	r28, 0x27	; 39
    61f8:	d7 4f       	sbci	r29, 0xF7	; 247
    61fa:	88 e0       	ldi	r24, 0x08	; 8
    61fc:	88 83       	st	Y, r24
		break;
    61fe:	c4 c0       	rjmp	.+392    	; 0x6388 <FormData+0x1c6>
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    6200:	8f 30       	cpi	r24, 0x0F	; 15
    6202:	11 f1       	breq	.+68     	; 0x6248 <FormData+0x86>
    6204:	80 31       	cpi	r24, 0x10	; 16
    6206:	09 f0       	breq	.+2      	; 0x620a <FormData+0x48>
    6208:	bf c0       	rjmp	.+382    	; 0x6388 <FormData+0x1c6>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    620a:	f8 01       	movw	r30, r16
    620c:	85 81       	ldd	r24, Z+5	; 0x05
    620e:	88 0f       	add	r24, r24
    6210:	86 83       	std	Z+6, r24	; 0x06
    6212:	c7 52       	subi	r28, 0x27	; 39
    6214:	d7 4f       	sbci	r29, 0xF7	; 247
    6216:	87 5f       	subi	r24, 0xF7	; 247
    6218:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    621a:	8b 2d       	mov	r24, r11
    621c:	0e 94 03 29 	call	0x5206	; 0x5206 <GetReg>
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6220:	20 e0       	ldi	r18, 0x00	; 0
    6222:	e8 01       	movw	r28, r16
    6224:	25 96       	adiw	r28, 0x05	; 5
    6226:	9a c0       	rjmp	.+308    	; 0x635c <FormData+0x19a>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    6228:	c7 52       	subi	r28, 0x27	; 39
    622a:	d7 4f       	sbci	r29, 0xF7	; 247
    622c:	88 e0       	ldi	r24, 0x08	; 8
    622e:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6230:	8b 2d       	mov	r24, r11
    6232:	0e 94 03 29 	call	0x5206	; 0x5206 <GetReg>
		MB_Frame[MB_N][4] = *Reg>>8;
    6236:	fc 01       	movw	r30, r24
    6238:	21 81       	ldd	r18, Z+1	; 0x01
    623a:	f8 01       	movw	r30, r16
    623c:	24 83       	std	Z+4, r18	; 0x04
		MB_Frame[MB_N][5] = *Reg;
    623e:	fc 01       	movw	r30, r24
    6240:	80 81       	ld	r24, Z
    6242:	f8 01       	movw	r30, r16
    6244:	85 83       	std	Z+5, r24	; 0x05
		break;
    6246:	a0 c0       	rjmp	.+320    	; 0x6388 <FormData+0x1c6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6248:	f8 01       	movw	r30, r16
    624a:	e4 80       	ldd	r14, Z+4	; 0x04
    624c:	f1 2c       	mov	r15, r1
    624e:	fe 2c       	mov	r15, r14
    6250:	ee 24       	eor	r14, r14
    6252:	85 81       	ldd	r24, Z+5	; 0x05
    6254:	e8 2a       	or	r14, r24
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    6256:	c7 01       	movw	r24, r14
    6258:	13 e0       	ldi	r17, 0x03	; 3
    625a:	96 95       	lsr	r25
    625c:	87 95       	ror	r24
    625e:	1a 95       	dec	r17
    6260:	e1 f7       	brne	.-8      	; 0x625a <FormData+0x98>
    6262:	97 01       	movw	r18, r14
    6264:	27 70       	andi	r18, 0x07	; 7
    6266:	33 27       	eor	r19, r19
    6268:	41 e0       	ldi	r20, 0x01	; 1
    626a:	23 2b       	or	r18, r19
    626c:	09 f4       	brne	.+2      	; 0x6270 <FormData+0xae>
    626e:	40 e0       	ldi	r20, 0x00	; 0
    6270:	24 2f       	mov	r18, r20
    6272:	28 0f       	add	r18, r24
    6274:	f6 01       	movw	r30, r12
    6276:	e8 5b       	subi	r30, 0xB8	; 184
    6278:	f2 4f       	sbci	r31, 0xF2	; 242
    627a:	26 83       	std	Z+6, r18	; 0x06
    627c:	de 01       	movw	r26, r28
    627e:	a7 52       	subi	r26, 0x27	; 39
    6280:	b7 4f       	sbci	r27, 0xF7	; 247
    6282:	27 5f       	subi	r18, 0xF7	; 247
    6284:	2c 93       	st	X, r18
		MB_Frame[MB_N][7+Qt/8] = 0;
    6286:	e8 0f       	add	r30, r24
    6288:	f9 1f       	adc	r31, r25
    628a:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    628c:	fe 01       	movw	r30, r28
    628e:	ee 5d       	subi	r30, 0xDE	; 222
    6290:	f9 4f       	sbci	r31, 0xF9	; 249
    6292:	80 81       	ld	r24, Z
    6294:	82 30       	cpi	r24, 0x02	; 2
    6296:	f9 f0       	breq	.+62     	; 0x62d6 <FormData+0x114>
			Discr = prp(&Modbus_Map[MB_N].Coil);
    6298:	fe 01       	movw	r30, r28
    629a:	a4 e0       	ldi	r26, 0x04	; 4
    629c:	ee 0f       	add	r30, r30
    629e:	ff 1f       	adc	r31, r31
    62a0:	aa 95       	dec	r26
    62a2:	e1 f7       	brne	.-8      	; 0x629c <FormData+0xda>
    62a4:	ea 53       	subi	r30, 0x3A	; 58
    62a6:	f0 4b       	sbci	r31, 0xB0	; 176
    62a8:	05 91       	lpm	r16, Z+
    62aa:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    62ac:	8b 2d       	mov	r24, r11
    62ae:	0e 94 bd 28 	call	0x517a	; 0x517a <GetSlave>
    62b2:	01 96       	adiw	r24, 0x01	; 1
    62b4:	fc 01       	movw	r30, r24
    62b6:	85 91       	lpm	r24, Z+
    62b8:	94 91       	lpm	r25, Z
    62ba:	c3 5f       	subi	r28, 0xF3	; 243
    62bc:	d9 4f       	sbci	r29, 0xF9	; 249
    62be:	28 81       	ld	r18, Y
    62c0:	fc 01       	movw	r30, r24
    62c2:	37 e0       	ldi	r19, 0x07	; 7
    62c4:	23 9f       	mul	r18, r19
    62c6:	e0 0d       	add	r30, r0
    62c8:	f1 1d       	adc	r31, r1
    62ca:	11 24       	eor	r1, r1
		MB_Frame[MB_N][7+Qt/8] = 0;
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    62cc:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    62ce:	85 91       	lpm	r24, Z+
    62d0:	94 91       	lpm	r25, Z
    62d2:	78 2f       	mov	r23, r24
    62d4:	0a c0       	rjmp	.+20     	; 0x62ea <FormData+0x128>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    62d6:	f3 e0       	ldi	r31, 0x03	; 3
    62d8:	cc 0f       	add	r28, r28
    62da:	dd 1f       	adc	r29, r29
    62dc:	fa 95       	dec	r31
    62de:	e1 f7       	brne	.-8      	; 0x62d8 <FormData+0x116>
    62e0:	cd 59       	subi	r28, 0x9D	; 157
    62e2:	dd 4f       	sbci	r29, 0xFD	; 253
    62e4:	0e 81       	ldd	r16, Y+6	; 0x06
    62e6:	1f 81       	ldd	r17, Y+7	; 0x07
			Pin = 0;
    62e8:	70 e0       	ldi	r23, 0x00	; 0
		}
		for (uint8_t i=0; i<Qt; i++) {
    62ea:	60 e0       	ldi	r22, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62ec:	41 e0       	ldi	r20, 0x01	; 1
    62ee:	50 e0       	ldi	r21, 0x00	; 0
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    62f0:	26 2f       	mov	r18, r22
    62f2:	30 e0       	ldi	r19, 0x00	; 0
    62f4:	2e 15       	cp	r18, r14
    62f6:	3f 05       	cpc	r19, r15
    62f8:	08 f0       	brcs	.+2      	; 0x62fc <FormData+0x13a>
    62fa:	46 c0       	rjmp	.+140    	; 0x6388 <FormData+0x1c6>
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62fc:	e6 2f       	mov	r30, r22
    62fe:	e6 95       	lsr	r30
    6300:	e6 95       	lsr	r30
    6302:	e6 95       	lsr	r30
    6304:	e9 5f       	subi	r30, 0xF9	; 249
    6306:	86 2f       	mov	r24, r22
    6308:	87 70       	andi	r24, 0x07	; 7
    630a:	9a 01       	movw	r18, r20
    630c:	02 c0       	rjmp	.+4      	; 0x6312 <FormData+0x150>
    630e:	22 0f       	add	r18, r18
    6310:	33 1f       	adc	r19, r19
    6312:	8a 95       	dec	r24
    6314:	e2 f7       	brpl	.-8      	; 0x630e <FormData+0x14c>
    6316:	c9 01       	movw	r24, r18
			if (Discr[j/8] &(1<<j%8))
    6318:	f6 2f       	mov	r31, r22
    631a:	f7 0f       	add	r31, r23
    631c:	2f 2f       	mov	r18, r31
    631e:	26 95       	lsr	r18
    6320:	26 95       	lsr	r18
    6322:	26 95       	lsr	r18
    6324:	d8 01       	movw	r26, r16
    6326:	a2 0f       	add	r26, r18
    6328:	b1 1d       	adc	r27, r1
    632a:	2c 91       	ld	r18, X
    632c:	30 e0       	ldi	r19, 0x00	; 0
    632e:	f7 70       	andi	r31, 0x07	; 7
    6330:	02 c0       	rjmp	.+4      	; 0x6336 <FormData+0x174>
    6332:	35 95       	asr	r19
    6334:	27 95       	ror	r18
    6336:	fa 95       	dec	r31
    6338:	e2 f7       	brpl	.-8      	; 0x6332 <FormData+0x170>
    633a:	f0 e0       	ldi	r31, 0x00	; 0
				MB_Frame[MB_N][Byte] |=Bit;
    633c:	ec 0d       	add	r30, r12
    633e:	fd 1d       	adc	r31, r13
    6340:	e8 5b       	subi	r30, 0xB8	; 184
    6342:	f2 4f       	sbci	r31, 0xF2	; 242
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
			if (Discr[j/8] &(1<<j%8))
    6344:	20 ff       	sbrs	r18, 0
    6346:	04 c0       	rjmp	.+8      	; 0x6350 <FormData+0x18e>
				MB_Frame[MB_N][Byte] |=Bit;
    6348:	90 81       	ld	r25, Z
    634a:	98 2b       	or	r25, r24
    634c:	90 83       	st	Z, r25
    634e:	04 c0       	rjmp	.+8      	; 0x6358 <FormData+0x196>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    6350:	80 95       	com	r24
    6352:	90 81       	ld	r25, Z
    6354:	89 23       	and	r24, r25
    6356:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6358:	6f 5f       	subi	r22, 0xFF	; 255
    635a:	ca cf       	rjmp	.-108    	; 0x62f0 <FormData+0x12e>
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    635c:	38 81       	ld	r19, Y
    635e:	23 17       	cp	r18, r19
    6360:	98 f4       	brcc	.+38     	; 0x6388 <FormData+0x1c6>
			uint8_t j = i*2;
    6362:	32 2f       	mov	r19, r18
    6364:	33 0f       	add	r19, r19
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6366:	fc 01       	movw	r30, r24
    6368:	e2 0f       	add	r30, r18
    636a:	f1 1d       	adc	r31, r1
    636c:	e2 0f       	add	r30, r18
    636e:	f1 1d       	adc	r31, r1
    6370:	d8 01       	movw	r26, r16
    6372:	a3 0f       	add	r26, r19
    6374:	b1 1d       	adc	r27, r1
    6376:	31 81       	ldd	r19, Z+1	; 0x01
    6378:	17 96       	adiw	r26, 0x07	; 7
    637a:	3c 93       	st	X, r19
    637c:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    637e:	30 81       	ld	r19, Z
    6380:	18 96       	adiw	r26, 0x08	; 8
    6382:	3c 93       	st	X, r19
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6384:	2f 5f       	subi	r18, 0xFF	; 255
    6386:	ea cf       	rjmp	.-44     	; 0x635c <FormData+0x19a>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6388:	8b 2d       	mov	r24, r11
}
    638a:	df 91       	pop	r29
    638c:	cf 91       	pop	r28
    638e:	1f 91       	pop	r17
    6390:	0f 91       	pop	r16
    6392:	ff 90       	pop	r15
    6394:	ef 90       	pop	r14
    6396:	df 90       	pop	r13
    6398:	cf 90       	pop	r12
    639a:	bf 90       	pop	r11
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    639c:	0c 94 c5 30 	jmp	0x618a	; 0x618a <SetCRC_MB>

000063a0 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    63a0:	cf 93       	push	r28
    63a2:	c8 2f       	mov	r28, r24
	MB_Slave *Slave = GetSlave(MB_N);
    63a4:	0e 94 bd 28 	call	0x517a	; 0x517a <GetSlave>
    63a8:	bc 01       	movw	r22, r24
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    63aa:	fc 01       	movw	r30, r24
    63ac:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    63ae:	45 91       	lpm	r20, Z+
    63b0:	54 91       	lpm	r21, Z
    63b2:	2c 2f       	mov	r18, r28
    63b4:	30 e0       	ldi	r19, 0x00	; 0
    63b6:	f9 01       	movw	r30, r18
    63b8:	e3 5f       	subi	r30, 0xF3	; 243
    63ba:	f9 4f       	sbci	r31, 0xF9	; 249
    63bc:	80 81       	ld	r24, Z
    63be:	97 e0       	ldi	r25, 0x07	; 7
    63c0:	89 9f       	mul	r24, r25
    63c2:	40 0d       	add	r20, r0
    63c4:	51 1d       	adc	r21, r1
    63c6:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    63c8:	fb 01       	movw	r30, r22
    63ca:	64 91       	lpm	r22, Z

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    63cc:	b2 2f       	mov	r27, r18
    63ce:	aa 27       	eor	r26, r26
    63d0:	a8 5b       	subi	r26, 0xB8	; 184
    63d2:	b2 4f       	sbci	r27, 0xF2	; 242
    63d4:	6c 93       	st	X, r22
    63d6:	fa 01       	movw	r30, r20
    63d8:	84 91       	lpm	r24, Z
	MB_Frame[MB_N][1] = prb(&Query->Func);
    63da:	f2 2f       	mov	r31, r18
    63dc:	ee 27       	eor	r30, r30
    63de:	e8 5b       	subi	r30, 0xB8	; 184
    63e0:	f2 4f       	sbci	r31, 0xF2	; 242
    63e2:	81 83       	std	Z+1, r24	; 0x01
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    63e4:	fa 01       	movw	r30, r20
    63e6:	32 96       	adiw	r30, 0x02	; 2
    63e8:	e4 91       	lpm	r30, Z
    63ea:	b2 2f       	mov	r27, r18
    63ec:	aa 27       	eor	r26, r26
    63ee:	a8 5b       	subi	r26, 0xB8	; 184
    63f0:	b2 4f       	sbci	r27, 0xF2	; 242
    63f2:	12 96       	adiw	r26, 0x02	; 2
    63f4:	ec 93       	st	X, r30
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    63f6:	fa 01       	movw	r30, r20
    63f8:	31 96       	adiw	r30, 0x01	; 1
    63fa:	e4 91       	lpm	r30, Z
    63fc:	b2 2f       	mov	r27, r18
    63fe:	aa 27       	eor	r26, r26
    6400:	a8 5b       	subi	r26, 0xB8	; 184
    6402:	b2 4f       	sbci	r27, 0xF2	; 242
    6404:	13 96       	adiw	r26, 0x03	; 3
    6406:	ec 93       	st	X, r30
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6408:	fa 01       	movw	r30, r20
    640a:	34 96       	adiw	r30, 0x04	; 4
    640c:	e4 91       	lpm	r30, Z
    640e:	b2 2f       	mov	r27, r18
    6410:	aa 27       	eor	r26, r26
    6412:	a8 5b       	subi	r26, 0xB8	; 184
    6414:	b2 4f       	sbci	r27, 0xF2	; 242
    6416:	14 96       	adiw	r26, 0x04	; 4
    6418:	ec 93       	st	X, r30
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    641a:	fa 01       	movw	r30, r20
    641c:	33 96       	adiw	r30, 0x03	; 3
    641e:	44 91       	lpm	r20, Z
    6420:	b2 2f       	mov	r27, r18
    6422:	aa 27       	eor	r26, r26
    6424:	a8 5b       	subi	r26, 0xB8	; 184
    6426:	b2 4f       	sbci	r27, 0xF2	; 242
    6428:	15 96       	adiw	r26, 0x05	; 5
    642a:	4c 93       	st	X, r20

	FormData(MB_N);
    642c:	8c 2f       	mov	r24, r28
}
    642e:	cf 91       	pop	r28
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);

	FormData(MB_N);
    6430:	0c 94 e1 30 	jmp	0x61c2	; 0x61c2 <FormData>

00006434 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6434:	28 2f       	mov	r18, r24
    6436:	30 e0       	ldi	r19, 0x00	; 0
    6438:	f2 2f       	mov	r31, r18
    643a:	ee 27       	eor	r30, r30
    643c:	e8 5b       	subi	r30, 0xB8	; 184
    643e:	f2 4f       	sbci	r31, 0xF2	; 242
    6440:	d9 01       	movw	r26, r18
    6442:	93 e0       	ldi	r25, 0x03	; 3
    6444:	aa 0f       	add	r26, r26
    6446:	bb 1f       	adc	r27, r27
    6448:	9a 95       	dec	r25
    644a:	e1 f7       	brne	.-8      	; 0x6444 <FormSingle+0x10>
    644c:	ad 59       	subi	r26, 0x9D	; 157
    644e:	bd 4f       	sbci	r27, 0xFD	; 253
    6450:	9c 91       	ld	r25, X
    6452:	90 83       	st	Z, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    6454:	11 96       	adiw	r26, 0x01	; 1
    6456:	9c 91       	ld	r25, X
    6458:	11 97       	sbiw	r26, 0x01	; 1
    645a:	91 83       	std	Z+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    645c:	12 96       	adiw	r26, 0x02	; 2
    645e:	9c 91       	ld	r25, X
    6460:	12 97       	sbiw	r26, 0x02	; 2
    6462:	13 96       	adiw	r26, 0x03	; 3
    6464:	4c 91       	ld	r20, X
    6466:	13 97       	sbiw	r26, 0x03	; 3
    6468:	42 83       	std	Z+2, r20	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    646a:	93 83       	std	Z+3, r25	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    646c:	14 96       	adiw	r26, 0x04	; 4
    646e:	9c 91       	ld	r25, X
    6470:	14 97       	sbiw	r26, 0x04	; 4
    6472:	15 96       	adiw	r26, 0x05	; 5
    6474:	4c 91       	ld	r20, X
    6476:	44 83       	std	Z+4, r20	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6478:	95 83       	std	Z+5, r25	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    647a:	f9 01       	movw	r30, r18
    647c:	ee 5d       	subi	r30, 0xDE	; 222
    647e:	f9 4f       	sbci	r31, 0xF9	; 249
    6480:	92 e0       	ldi	r25, 0x02	; 2
    6482:	90 83       	st	Z, r25
	FormData(MB_N);
    6484:	0c 94 e1 30 	jmp	0x61c2	; 0x61c2 <FormData>

00006488 <MB_FrameReg>:
    6488:	e8 2f       	mov	r30, r24
    648a:	f0 e0       	ldi	r31, 0x00	; 0
    648c:	70 e0       	ldi	r23, 0x00	; 0
    648e:	fe 2f       	mov	r31, r30
    6490:	ee 27       	eor	r30, r30
    6492:	df 01       	movw	r26, r30
    6494:	a8 5b       	subi	r26, 0xB8	; 184
    6496:	b2 4f       	sbci	r27, 0xF2	; 242
    6498:	a6 0f       	add	r26, r22
    649a:	b7 1f       	adc	r27, r23
    649c:	11 96       	adiw	r26, 0x01	; 1
    649e:	8c 91       	ld	r24, X
    64a0:	e6 0f       	add	r30, r22
    64a2:	f7 1f       	adc	r31, r23
    64a4:	e8 5b       	subi	r30, 0xB8	; 184
    64a6:	f2 4f       	sbci	r31, 0xF2	; 242
    64a8:	20 81       	ld	r18, Z
    64aa:	90 e0       	ldi	r25, 0x00	; 0
}
    64ac:	92 2b       	or	r25, r18
    64ae:	08 95       	ret

000064b0 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    64b0:	2f 92       	push	r2
    64b2:	3f 92       	push	r3
    64b4:	4f 92       	push	r4
    64b6:	5f 92       	push	r5
    64b8:	6f 92       	push	r6
    64ba:	7f 92       	push	r7
    64bc:	8f 92       	push	r8
    64be:	9f 92       	push	r9
    64c0:	af 92       	push	r10
    64c2:	bf 92       	push	r11
    64c4:	cf 92       	push	r12
    64c6:	df 92       	push	r13
    64c8:	ef 92       	push	r14
    64ca:	ff 92       	push	r15
    64cc:	0f 93       	push	r16
    64ce:	1f 93       	push	r17
    64d0:	cf 93       	push	r28
    64d2:	df 93       	push	r29
    64d4:	00 d0       	rcall	.+0      	; 0x64d6 <MB_S_Timer_ISR+0x26>
    64d6:	00 d0       	rcall	.+0      	; 0x64d8 <MB_S_Timer_ISR+0x28>
    64d8:	1f 92       	push	r1
    64da:	cd b7       	in	r28, 0x3d	; 61
    64dc:	de b7       	in	r29, 0x3e	; 62
    64de:	78 2e       	mov	r7, r24
	switch (MB_State[MB_N]) {
    64e0:	c8 2e       	mov	r12, r24
    64e2:	d1 2c       	mov	r13, r1
    64e4:	96 01       	movw	r18, r12
    64e6:	2f 51       	subi	r18, 0x1F	; 31
    64e8:	3c 4f       	sbci	r19, 0xFC	; 252
    64ea:	59 01       	movw	r10, r18
    64ec:	d9 01       	movw	r26, r18
    64ee:	8c 91       	ld	r24, X
    64f0:	88 23       	and	r24, r24
    64f2:	59 f0       	breq	.+22     	; 0x650a <MB_S_Timer_ISR+0x5a>
    64f4:	82 30       	cpi	r24, 0x02	; 2
    64f6:	09 f0       	breq	.+2      	; 0x64fa <MB_S_Timer_ISR+0x4a>
    64f8:	aa c2       	rjmp	.+1364   	; 0x6a4e <MB_S_Timer_ISR+0x59e>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    64fa:	84 e0       	ldi	r24, 0x04	; 4
    64fc:	d9 01       	movw	r26, r18
    64fe:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    6500:	87 2d       	mov	r24, r7
    6502:	0e 94 64 30 	call	0x60c8	; 0x60c8 <CommErr>
    6506:	88 23       	and	r24, r24
    6508:	21 f0       	breq	.+8      	; 0x6512 <MB_S_Timer_ISR+0x62>
		MB_State[MB_N] = MB_Idle;
    650a:	81 e0       	ldi	r24, 0x01	; 1
    650c:	f5 01       	movw	r30, r10
    650e:	80 83       	st	Z, r24
    6510:	9e c2       	rjmp	.+1340   	; 0x6a4e <MB_S_Timer_ISR+0x59e>
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    6512:	3c 2d       	mov	r19, r12
    6514:	22 27       	eor	r18, r18
    6516:	3d 83       	std	Y+5, r19	; 0x05
    6518:	2c 83       	std	Y+4, r18	; 0x04
    651a:	f9 01       	movw	r30, r18
    651c:	e8 5b       	subi	r30, 0xB8	; 184
    651e:	f2 4f       	sbci	r31, 0xF2	; 242
    6520:	80 81       	ld	r24, Z
    6522:	88 23       	and	r24, r24
    6524:	51 f0       	breq	.+20     	; 0x653a <MB_S_Timer_ISR+0x8a>
    6526:	f6 01       	movw	r30, r12
    6528:	e8 50       	subi	r30, 0x08	; 8
    652a:	fc 4f       	sbci	r31, 0xFC	; 252
    652c:	90 81       	ld	r25, Z
    652e:	89 17       	cp	r24, r25
    6530:	21 f0       	breq	.+8      	; 0x653a <MB_S_Timer_ISR+0x8a>
		MB_State[MB_N] = MB_Idle;
    6532:	81 e0       	ldi	r24, 0x01	; 1
    6534:	d5 01       	movw	r26, r10
    6536:	8c 93       	st	X, r24
    6538:	8a c2       	rjmp	.+1300   	; 0x6a4e <MB_S_Timer_ISR+0x59e>
		return;
	}
	USART_Func(MB_N, LED);
    653a:	84 e1       	ldi	r24, 0x14	; 20
    653c:	8c 9d       	mul	r24, r12
    653e:	40 01       	movw	r8, r0
    6540:	8d 9d       	mul	r24, r13
    6542:	90 0c       	add	r9, r0
    6544:	11 24       	eor	r1, r1
    6546:	f4 01       	movw	r30, r8
    6548:	eb 55       	subi	r30, 0x5B	; 91
    654a:	f0 4b       	sbci	r31, 0xB0	; 176
    654c:	4f 01       	movw	r8, r30

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    654e:	25 91       	lpm	r18, Z+
    6550:	34 91       	lpm	r19, Z
    6552:	f9 01       	movw	r30, r18
    6554:	09 95       	icall
	MB_CPT[MB_N][3]++;
    6556:	86 01       	movw	r16, r12
    6558:	e4 e0       	ldi	r30, 0x04	; 4
    655a:	00 0f       	add	r16, r16
    655c:	11 1f       	adc	r17, r17
    655e:	ea 95       	dec	r30
    6560:	e1 f7       	brne	.-8      	; 0x655a <MB_S_Timer_ISR+0xaa>
    6562:	f8 01       	movw	r30, r16
    6564:	e7 5d       	subi	r30, 0xD7	; 215
    6566:	f4 4f       	sbci	r31, 0xF4	; 244
    6568:	86 81       	ldd	r24, Z+6	; 0x06
    656a:	97 81       	ldd	r25, Z+7	; 0x07
    656c:	01 96       	adiw	r24, 0x01	; 1
    656e:	97 83       	std	Z+7, r25	; 0x07
    6570:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6572:	ec 81       	ldd	r30, Y+4	; 0x04
    6574:	fd 81       	ldd	r31, Y+5	; 0x05
    6576:	e8 5b       	subi	r30, 0xB8	; 184
    6578:	f2 4f       	sbci	r31, 0xF2	; 242
    657a:	e2 80       	ldd	r14, Z+2	; 0x02
    657c:	f1 2c       	mov	r15, r1
    657e:	fe 2c       	mov	r15, r14
    6580:	ee 24       	eor	r14, r14
    6582:	83 81       	ldd	r24, Z+3	; 0x03
    6584:	e8 2a       	or	r14, r24
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6586:	61 81       	ldd	r22, Z+1	; 0x01
    6588:	86 2f       	mov	r24, r22
    658a:	90 e0       	ldi	r25, 0x00	; 0
    658c:	fc 01       	movw	r30, r24
    658e:	31 97       	sbiw	r30, 0x01	; 1
    6590:	e0 31       	cpi	r30, 0x10	; 16
    6592:	f1 05       	cpc	r31, r1
    6594:	08 f0       	brcs	.+2      	; 0x6598 <MB_S_Timer_ISR+0xe8>
    6596:	ec c1       	rjmp	.+984    	; 0x6970 <MB_S_Timer_ISR+0x4c0>
    6598:	ea 5b       	subi	r30, 0xBA	; 186
    659a:	ff 4f       	sbci	r31, 0xFF	; 255
    659c:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    65a0:	ec 81       	ldd	r30, Y+4	; 0x04
    65a2:	fd 81       	ldd	r31, Y+5	; 0x05
    65a4:	e8 5b       	subi	r30, 0xB8	; 184
    65a6:	f2 4f       	sbci	r31, 0xF2	; 242
    65a8:	80 81       	ld	r24, Z
    65aa:	88 23       	and	r24, r24
    65ac:	09 f4       	brne	.+2      	; 0x65b0 <MB_S_Timer_ISR+0x100>
    65ae:	dd c0       	rjmp	.+442    	; 0x676a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    65b0:	d6 01       	movw	r26, r12
    65b2:	a7 52       	subi	r26, 0x27	; 39
    65b4:	b7 4f       	sbci	r27, 0xF7	; 247
    65b6:	8c 91       	ld	r24, X
    65b8:	88 30       	cpi	r24, 0x08	; 8
    65ba:	09 f0       	breq	.+2      	; 0x65be <MB_S_Timer_ISR+0x10e>
    65bc:	8c c0       	rjmp	.+280    	; 0x66d6 <MB_S_Timer_ISR+0x226>
    65be:	24 81       	ldd	r18, Z+4	; 0x04
    65c0:	30 e0       	ldi	r19, 0x00	; 0
    65c2:	32 2f       	mov	r19, r18
    65c4:	22 27       	eor	r18, r18
    65c6:	85 81       	ldd	r24, Z+5	; 0x05
    65c8:	28 2b       	or	r18, r24
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65ca:	a9 01       	movw	r20, r18
    65cc:	4e 0d       	add	r20, r14
    65ce:	5f 1d       	adc	r21, r15
    65d0:	f8 01       	movw	r30, r16
    65d2:	61 30       	cpi	r22, 0x01	; 1
    65d4:	61 f4       	brne	.+24     	; 0x65ee <MB_S_Timer_ISR+0x13e>
    65d6:	e8 53       	subi	r30, 0x38	; 56
    65d8:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    65da:	85 91       	lpm	r24, Z+
    65dc:	94 91       	lpm	r25, Z
    65de:	84 17       	cp	r24, r20
    65e0:	95 07       	cpc	r25, r21
    65e2:	08 f4       	brcc	.+2      	; 0x65e6 <MB_S_Timer_ISR+0x136>
    65e4:	96 c1       	rjmp	.+812    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    65e6:	f8 01       	movw	r30, r16
    65e8:	ea 53       	subi	r30, 0x3A	; 58
    65ea:	f0 4b       	sbci	r31, 0xB0	; 176
    65ec:	0b c0       	rjmp	.+22     	; 0x6604 <MB_S_Timer_ISR+0x154>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65ee:	e4 53       	subi	r30, 0x34	; 52
    65f0:	f0 4b       	sbci	r31, 0xB0	; 176
    65f2:	85 91       	lpm	r24, Z+
    65f4:	94 91       	lpm	r25, Z
    65f6:	84 17       	cp	r24, r20
    65f8:	95 07       	cpc	r25, r21
    65fa:	08 f4       	brcc	.+2      	; 0x65fe <MB_S_Timer_ISR+0x14e>
    65fc:	8a c1       	rjmp	.+788    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    65fe:	f8 01       	movw	r30, r16
    6600:	e6 53       	subi	r30, 0x36	; 54
    6602:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6604:	65 91       	lpm	r22, Z+
    6606:	74 91       	lpm	r23, Z
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    6608:	e1 e0       	ldi	r30, 0x01	; 1
    660a:	a9 01       	movw	r20, r18
    660c:	47 70       	andi	r20, 0x07	; 7
    660e:	55 27       	eor	r21, r21
    6610:	45 2b       	or	r20, r21
    6612:	09 f4       	brne	.+2      	; 0x6616 <MB_S_Timer_ISR+0x166>
    6614:	e0 e0       	ldi	r30, 0x00	; 0
    6616:	c9 01       	movw	r24, r18
    6618:	43 e0       	ldi	r20, 0x03	; 3
    661a:	96 95       	lsr	r25
    661c:	87 95       	ror	r24
    661e:	4a 95       	dec	r20
    6620:	e1 f7       	brne	.-8      	; 0x661a <MB_S_Timer_ISR+0x16a>
    6622:	8e 0f       	add	r24, r30
    6624:	ec 81       	ldd	r30, Y+4	; 0x04
    6626:	fd 81       	ldd	r31, Y+5	; 0x05
    6628:	e8 5b       	subi	r30, 0xB8	; 184
    662a:	f2 4f       	sbci	r31, 0xF2	; 242
    662c:	82 83       	std	Z+2, r24	; 0x02
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    662e:	8b 5f       	subi	r24, 0xFB	; 251
    6630:	8c 93       	st	X, r24
	for (uint8_t i=0; i<Qt; i++) {
    6632:	a0 e0       	ldi	r26, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6634:	22 24       	eor	r2, r2
    6636:	23 94       	inc	r2
    6638:	31 2c       	mov	r3, r1
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    663a:	4a 2f       	mov	r20, r26
    663c:	50 e0       	ldi	r21, 0x00	; 0
    663e:	42 17       	cp	r20, r18
    6640:	53 07       	cpc	r21, r19
    6642:	08 f0       	brcs	.+2      	; 0x6646 <MB_S_Timer_ISR+0x196>
    6644:	93 c1       	rjmp	.+806    	; 0x696c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    6646:	4e 0d       	add	r20, r14
    6648:	5f 1d       	adc	r21, r15
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    664a:	ba 2f       	mov	r27, r26
    664c:	b6 95       	lsr	r27
    664e:	b6 95       	lsr	r27
    6650:	b6 95       	lsr	r27
    6652:	bd 5f       	subi	r27, 0xFD	; 253
    6654:	8a 2f       	mov	r24, r26
    6656:	87 70       	andi	r24, 0x07	; 7
    6658:	21 01       	movw	r4, r2
    665a:	01 c0       	rjmp	.+2      	; 0x665e <MB_S_Timer_ISR+0x1ae>
    665c:	44 0c       	add	r4, r4
    665e:	8a 95       	dec	r24
    6660:	ea f7       	brpl	.-6      	; 0x665c <MB_S_Timer_ISR+0x1ac>
		if (Discr[j/8] &(1<<j%8))
    6662:	fa 01       	movw	r30, r20
    6664:	83 e0       	ldi	r24, 0x03	; 3
    6666:	f6 95       	lsr	r31
    6668:	e7 95       	ror	r30
    666a:	8a 95       	dec	r24
    666c:	e1 f7       	brne	.-8      	; 0x6666 <MB_S_Timer_ISR+0x1b6>
    666e:	e6 0f       	add	r30, r22
    6670:	f7 1f       	adc	r31, r23
    6672:	80 81       	ld	r24, Z
    6674:	90 e0       	ldi	r25, 0x00	; 0
    6676:	47 70       	andi	r20, 0x07	; 7
    6678:	55 27       	eor	r21, r21
    667a:	02 c0       	rjmp	.+4      	; 0x6680 <MB_S_Timer_ISR+0x1d0>
    667c:	95 95       	asr	r25
    667e:	87 95       	ror	r24
    6680:	4a 95       	dec	r20
    6682:	e2 f7       	brpl	.-8      	; 0x667c <MB_S_Timer_ISR+0x1cc>
    6684:	eb 2f       	mov	r30, r27
    6686:	f0 e0       	ldi	r31, 0x00	; 0
    6688:	80 ff       	sbrs	r24, 0
    668a:	0a c0       	rjmp	.+20     	; 0x66a0 <MB_S_Timer_ISR+0x1f0>
			MB_Frame[MB_N][Byte] |=Bit;
    668c:	8c 81       	ldd	r24, Y+4	; 0x04
    668e:	9d 81       	ldd	r25, Y+5	; 0x05
    6690:	e8 0f       	add	r30, r24
    6692:	f9 1f       	adc	r31, r25
    6694:	e8 5b       	subi	r30, 0xB8	; 184
    6696:	f2 4f       	sbci	r31, 0xF2	; 242
    6698:	80 81       	ld	r24, Z
    669a:	84 29       	or	r24, r4
    669c:	80 83       	st	Z, r24
    669e:	0a c0       	rjmp	.+20     	; 0x66b4 <MB_S_Timer_ISR+0x204>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    66a0:	8c 81       	ldd	r24, Y+4	; 0x04
    66a2:	9d 81       	ldd	r25, Y+5	; 0x05
    66a4:	e8 0f       	add	r30, r24
    66a6:	f9 1f       	adc	r31, r25
    66a8:	e8 5b       	subi	r30, 0xB8	; 184
    66aa:	f2 4f       	sbci	r31, 0xF2	; 242
    66ac:	40 94       	com	r4
    66ae:	80 81       	ld	r24, Z
    66b0:	48 22       	and	r4, r24
    66b2:	40 82       	st	Z, r4
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    66b4:	af 5f       	subi	r26, 0xFF	; 255
    66b6:	c1 cf       	rjmp	.-126    	; 0x663a <MB_S_Timer_ISR+0x18a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    66b8:	ec 81       	ldd	r30, Y+4	; 0x04
    66ba:	fd 81       	ldd	r31, Y+5	; 0x05
    66bc:	e8 5b       	subi	r30, 0xB8	; 184
    66be:	f2 4f       	sbci	r31, 0xF2	; 242
    66c0:	80 81       	ld	r24, Z
    66c2:	88 23       	and	r24, r24
    66c4:	09 f4       	brne	.+2      	; 0x66c8 <MB_S_Timer_ISR+0x218>
    66c6:	51 c0       	rjmp	.+162    	; 0x676a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    66c8:	96 01       	movw	r18, r12
    66ca:	27 52       	subi	r18, 0x27	; 39
    66cc:	37 4f       	sbci	r19, 0xF7	; 247
    66ce:	d9 01       	movw	r26, r18
    66d0:	8c 91       	ld	r24, X
    66d2:	88 30       	cpi	r24, 0x08	; 8
    66d4:	11 f0       	breq	.+4      	; 0x66da <MB_S_Timer_ISR+0x22a>
		return MB_Frame[MB_N][2]=IllegData;
    66d6:	83 e0       	ldi	r24, 0x03	; 3
    66d8:	0f c1       	rjmp	.+542    	; 0x68f8 <MB_S_Timer_ISR+0x448>
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    66da:	75 81       	ldd	r23, Z+5	; 0x05
    66dc:	c7 01       	movw	r24, r14
    66de:	87 0f       	add	r24, r23
    66e0:	91 1d       	adc	r25, r1
    66e2:	f8 01       	movw	r30, r16
    66e4:	63 30       	cpi	r22, 0x03	; 3
    66e6:	61 f4       	brne	.+24     	; 0x6700 <MB_S_Timer_ISR+0x250>
    66e8:	e0 53       	subi	r30, 0x30	; 48
    66ea:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    66ec:	45 91       	lpm	r20, Z+
    66ee:	54 91       	lpm	r21, Z
    66f0:	48 17       	cp	r20, r24
    66f2:	59 07       	cpc	r21, r25
    66f4:	08 f4       	brcc	.+2      	; 0x66f8 <MB_S_Timer_ISR+0x248>
    66f6:	0d c1       	rjmp	.+538    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    66f8:	f8 01       	movw	r30, r16
    66fa:	e2 53       	subi	r30, 0x32	; 50
    66fc:	f0 4b       	sbci	r31, 0xB0	; 176
    66fe:	0b c0       	rjmp	.+22     	; 0x6716 <MB_S_Timer_ISR+0x266>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    6700:	ec 52       	subi	r30, 0x2C	; 44
    6702:	f0 4b       	sbci	r31, 0xB0	; 176
    6704:	45 91       	lpm	r20, Z+
    6706:	54 91       	lpm	r21, Z
    6708:	48 17       	cp	r20, r24
    670a:	59 07       	cpc	r21, r25
    670c:	08 f4       	brcc	.+2      	; 0x6710 <MB_S_Timer_ISR+0x260>
    670e:	01 c1       	rjmp	.+514    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6710:	f8 01       	movw	r30, r16
    6712:	ee 52       	subi	r30, 0x2E	; 46
    6714:	f0 4b       	sbci	r31, 0xB0	; 176
    6716:	85 91       	lpm	r24, Z+
    6718:	94 91       	lpm	r25, Z
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    671a:	77 0f       	add	r23, r23
    671c:	ac 81       	ldd	r26, Y+4	; 0x04
    671e:	bd 81       	ldd	r27, Y+5	; 0x05
    6720:	a8 5b       	subi	r26, 0xB8	; 184
    6722:	b2 4f       	sbci	r27, 0xF2	; 242
    6724:	12 96       	adiw	r26, 0x02	; 2
    6726:	7c 93       	st	X, r23
    6728:	12 97       	sbiw	r26, 0x02	; 2
    672a:	7b 5f       	subi	r23, 0xFB	; 251
    672c:	f9 01       	movw	r30, r18
    672e:	70 83       	st	Z, r23
	uint8_t Qt = MB_Frame[MB_N][5];
    6730:	15 96       	adiw	r26, 0x05	; 5
    6732:	5c 91       	ld	r21, X
    6734:	15 97       	sbiw	r26, 0x05	; 5
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6736:	f7 01       	movw	r30, r14
    6738:	ee 0f       	add	r30, r30
    673a:	ff 1f       	adc	r31, r31
    673c:	e8 0f       	add	r30, r24
    673e:	f9 1f       	adc	r31, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6740:	40 e0       	ldi	r20, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    6742:	cd 01       	movw	r24, r26
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6744:	45 17       	cp	r20, r21
    6746:	09 f4       	brne	.+2      	; 0x674a <MB_S_Timer_ISR+0x29a>
    6748:	11 c1       	rjmp	.+546    	; 0x696c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
    674a:	64 2f       	mov	r22, r20
    674c:	66 0f       	add	r22, r22
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    674e:	7c 01       	movw	r14, r24
    6750:	e6 0e       	add	r14, r22
    6752:	f1 1c       	adc	r15, r1
    6754:	61 81       	ldd	r22, Z+1	; 0x01
    6756:	d7 01       	movw	r26, r14
    6758:	13 96       	adiw	r26, 0x03	; 3
    675a:	6c 93       	st	X, r22
		MB_Frame[MB_N][4+j] = Reg[i];
    675c:	20 81       	ld	r18, Z
    675e:	32 96       	adiw	r30, 0x02	; 2
    6760:	d7 01       	movw	r26, r14
    6762:	14 96       	adiw	r26, 0x04	; 4
    6764:	2c 93       	st	X, r18
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6766:	4f 5f       	subi	r20, 0xFF	; 255
    6768:	ed cf       	rjmp	.-38     	; 0x6744 <MB_S_Timer_ISR+0x294>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
    676a:	9f ef       	ldi	r25, 0xFF	; 255
    676c:	08 c1       	rjmp	.+528    	; 0x697e <MB_S_Timer_ISR+0x4ce>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    676e:	d6 01       	movw	r26, r12
    6770:	a7 52       	subi	r26, 0x27	; 39
    6772:	b7 4f       	sbci	r27, 0xF7	; 247
    6774:	8c 91       	ld	r24, X
    6776:	88 30       	cpi	r24, 0x08	; 8
    6778:	09 f0       	breq	.+2      	; 0x677c <MB_S_Timer_ISR+0x2cc>
    677a:	b9 c0       	rjmp	.+370    	; 0x68ee <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    677c:	f8 01       	movw	r30, r16
    677e:	e0 53       	subi	r30, 0x30	; 48
    6780:	f0 4b       	sbci	r31, 0xB0	; 176
    6782:	85 91       	lpm	r24, Z+
    6784:	94 91       	lpm	r25, Z
    6786:	97 01       	movw	r18, r14
    6788:	2f 5f       	subi	r18, 0xFF	; 255
    678a:	3f 4f       	sbci	r19, 0xFF	; 255
    678c:	82 17       	cp	r24, r18
    678e:	93 07       	cpc	r25, r19
    6790:	08 f4       	brcc	.+2      	; 0x6794 <MB_S_Timer_ISR+0x2e4>
    6792:	bf c0       	rjmp	.+382    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    6794:	88 e0       	ldi	r24, 0x08	; 8
    6796:	8c 93       	st	X, r24
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    6798:	f8 01       	movw	r30, r16
    679a:	e2 53       	subi	r30, 0x32	; 50
    679c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    679e:	85 91       	lpm	r24, Z+
    67a0:	94 91       	lpm	r25, Z
    67a2:	f7 01       	movw	r30, r14
    67a4:	ee 0f       	add	r30, r30
    67a6:	ff 1f       	adc	r31, r31
    67a8:	e8 0f       	add	r30, r24
    67aa:	f9 1f       	adc	r31, r25
    67ac:	ac 81       	ldd	r26, Y+4	; 0x04
    67ae:	bd 81       	ldd	r27, Y+5	; 0x05
    67b0:	a8 5b       	subi	r26, 0xB8	; 184
    67b2:	b2 4f       	sbci	r27, 0xF2	; 242
    67b4:	14 96       	adiw	r26, 0x04	; 4
    67b6:	8c 91       	ld	r24, X
    67b8:	14 97       	sbiw	r26, 0x04	; 4
    67ba:	90 e0       	ldi	r25, 0x00	; 0
    67bc:	98 2f       	mov	r25, r24
    67be:	88 27       	eor	r24, r24
    67c0:	15 96       	adiw	r26, 0x05	; 5
    67c2:	2c 91       	ld	r18, X
    67c4:	82 2b       	or	r24, r18
    67c6:	91 83       	std	Z+1, r25	; 0x01
    67c8:	80 83       	st	Z, r24
    67ca:	d0 c0       	rjmp	.+416    	; 0x696c <MB_S_Timer_ISR+0x4bc>
    67cc:	ec 81       	ldd	r30, Y+4	; 0x04
    67ce:	fd 81       	ldd	r31, Y+5	; 0x05
    67d0:	e8 5b       	subi	r30, 0xB8	; 184
    67d2:	f2 4f       	sbci	r31, 0xF2	; 242
    67d4:	64 80       	ldd	r6, Z+4	; 0x04
    67d6:	85 81       	ldd	r24, Z+5	; 0x05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    67d8:	66 81       	ldd	r22, Z+6	; 0x06
    67da:	d6 01       	movw	r26, r12
    67dc:	a7 52       	subi	r26, 0x27	; 39
    67de:	b7 4f       	sbci	r27, 0xF7	; 247
    67e0:	4c 91       	ld	r20, X
    67e2:	50 e0       	ldi	r21, 0x00	; 0
    67e4:	70 e0       	ldi	r23, 0x00	; 0
    67e6:	9b 01       	movw	r18, r22
    67e8:	27 5f       	subi	r18, 0xF7	; 247
    67ea:	3f 4f       	sbci	r19, 0xFF	; 255
    67ec:	42 17       	cp	r20, r18
    67ee:	53 07       	cpc	r21, r19
    67f0:	09 f0       	breq	.+2      	; 0x67f4 <MB_S_Timer_ISR+0x344>
    67f2:	7d c0       	rjmp	.+250    	; 0x68ee <MB_S_Timer_ISR+0x43e>
    67f4:	90 e0       	ldi	r25, 0x00	; 0
    67f6:	96 29       	or	r25, r6
    67f8:	9c 01       	movw	r18, r24
    67fa:	27 70       	andi	r18, 0x07	; 7
    67fc:	33 27       	eor	r19, r19
    67fe:	41 e0       	ldi	r20, 0x01	; 1
    6800:	50 e0       	ldi	r21, 0x00	; 0
    6802:	23 2b       	or	r18, r19
    6804:	11 f4       	brne	.+4      	; 0x680a <MB_S_Timer_ISR+0x35a>
    6806:	40 e0       	ldi	r20, 0x00	; 0
    6808:	50 e0       	ldi	r21, 0x00	; 0
    680a:	9c 01       	movw	r18, r24
    680c:	e3 e0       	ldi	r30, 0x03	; 3
    680e:	36 95       	lsr	r19
    6810:	27 95       	ror	r18
    6812:	ea 95       	dec	r30
    6814:	e1 f7       	brne	.-8      	; 0x680e <MB_S_Timer_ISR+0x35e>
    6816:	24 0f       	add	r18, r20
    6818:	35 1f       	adc	r19, r21
    681a:	26 17       	cp	r18, r22
    681c:	37 07       	cpc	r19, r23
    681e:	09 f0       	breq	.+2      	; 0x6822 <MB_S_Timer_ISR+0x372>
    6820:	66 c0       	rjmp	.+204    	; 0x68ee <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    6822:	f8 01       	movw	r30, r16
    6824:	e8 53       	subi	r30, 0x38	; 56
    6826:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6828:	25 91       	lpm	r18, Z+
    682a:	34 91       	lpm	r19, Z
    682c:	ac 01       	movw	r20, r24
    682e:	4e 0d       	add	r20, r14
    6830:	5f 1d       	adc	r21, r15
    6832:	24 17       	cp	r18, r20
    6834:	35 07       	cpc	r19, r21
    6836:	08 f4       	brcc	.+2      	; 0x683a <MB_S_Timer_ISR+0x38a>
    6838:	6c c0       	rjmp	.+216    	; 0x6912 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
    683a:	f8 01       	movw	r30, r16
    683c:	ea 53       	subi	r30, 0x3A	; 58
    683e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6840:	25 90       	lpm	r2, Z+
    6842:	34 90       	lpm	r3, Z
	MB_Frame_Sz[MB_N] = 8;
    6844:	28 e0       	ldi	r18, 0x08	; 8
    6846:	2c 93       	st	X, r18
	for (uint8_t i=0; i<Qt; i++) {
    6848:	51 2c       	mov	r5, r1
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    684a:	6c 81       	ldd	r22, Y+4	; 0x04
    684c:	7d 81       	ldd	r23, Y+5	; 0x05
    684e:	68 5b       	subi	r22, 0xB8	; 184
    6850:	72 4f       	sbci	r23, 0xF2	; 242
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    6852:	45 2d       	mov	r20, r5
    6854:	50 e0       	ldi	r21, 0x00	; 0
    6856:	48 17       	cp	r20, r24
    6858:	59 07       	cpc	r21, r25
    685a:	08 f0       	brcs	.+2      	; 0x685e <MB_S_Timer_ISR+0x3ae>
    685c:	87 c0       	rjmp	.+270    	; 0x696c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    685e:	4e 0d       	add	r20, r14
    6860:	5f 1d       	adc	r21, r15
		uint16_t Byte=j/8, Bit=1<<j%8;
    6862:	fa 01       	movw	r30, r20
    6864:	a3 e0       	ldi	r26, 0x03	; 3
    6866:	f6 95       	lsr	r31
    6868:	e7 95       	ror	r30
    686a:	aa 95       	dec	r26
    686c:	e1 f7       	brne	.-8      	; 0x6866 <MB_S_Timer_ISR+0x3b6>
    686e:	47 70       	andi	r20, 0x07	; 7
    6870:	55 27       	eor	r21, r21
    6872:	21 e0       	ldi	r18, 0x01	; 1
    6874:	30 e0       	ldi	r19, 0x00	; 0
    6876:	02 c0       	rjmp	.+4      	; 0x687c <MB_S_Timer_ISR+0x3cc>
    6878:	22 0f       	add	r18, r18
    687a:	33 1f       	adc	r19, r19
    687c:	4a 95       	dec	r20
    687e:	e2 f7       	brpl	.-8      	; 0x6878 <MB_S_Timer_ISR+0x3c8>
    6880:	a9 01       	movw	r20, r18
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6882:	25 2d       	mov	r18, r5
    6884:	26 95       	lsr	r18
    6886:	26 95       	lsr	r18
    6888:	26 95       	lsr	r18
    688a:	db 01       	movw	r26, r22
    688c:	a2 0f       	add	r26, r18
    688e:	b1 1d       	adc	r27, r1
    6890:	17 96       	adiw	r26, 0x07	; 7
    6892:	2c 91       	ld	r18, X
    6894:	30 e0       	ldi	r19, 0x00	; 0
    6896:	a5 2d       	mov	r26, r5
    6898:	a7 70       	andi	r26, 0x07	; 7
    689a:	02 c0       	rjmp	.+4      	; 0x68a0 <MB_S_Timer_ISR+0x3f0>
    689c:	35 95       	asr	r19
    689e:	27 95       	ror	r18
    68a0:	aa 95       	dec	r26
    68a2:	e2 f7       	brpl	.-8      	; 0x689c <MB_S_Timer_ISR+0x3ec>
    68a4:	e2 0d       	add	r30, r2
    68a6:	f3 1d       	adc	r31, r3
    68a8:	20 ff       	sbrs	r18, 0
    68aa:	03 c0       	rjmp	.+6      	; 0x68b2 <MB_S_Timer_ISR+0x402>
			Coil[Byte] |=Bit;
    68ac:	20 81       	ld	r18, Z
    68ae:	24 2b       	or	r18, r20
    68b0:	03 c0       	rjmp	.+6      	; 0x68b8 <MB_S_Timer_ISR+0x408>
		else
			Coil[Byte] &=~Bit;
    68b2:	40 95       	com	r20
    68b4:	20 81       	ld	r18, Z
    68b6:	24 23       	and	r18, r20
    68b8:	20 83       	st	Z, r18
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    68ba:	53 94       	inc	r5
    68bc:	ca cf       	rjmp	.-108    	; 0x6852 <MB_S_Timer_ISR+0x3a2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    68be:	ec 81       	ldd	r30, Y+4	; 0x04
    68c0:	fd 81       	ldd	r31, Y+5	; 0x05
    68c2:	e8 5b       	subi	r30, 0xB8	; 184
    68c4:	f2 4f       	sbci	r31, 0xF2	; 242
    68c6:	46 81       	ldd	r20, Z+6	; 0x06
    68c8:	50 e0       	ldi	r21, 0x00	; 0
    68ca:	d6 01       	movw	r26, r12
    68cc:	a7 52       	subi	r26, 0x27	; 39
    68ce:	b7 4f       	sbci	r27, 0xF7	; 247
    68d0:	2c 91       	ld	r18, X
    68d2:	30 e0       	ldi	r19, 0x00	; 0
    68d4:	ca 01       	movw	r24, r20
    68d6:	09 96       	adiw	r24, 0x09	; 9
    68d8:	28 17       	cp	r18, r24
    68da:	39 07       	cpc	r19, r25
    68dc:	41 f4       	brne	.+16     	; 0x68ee <MB_S_Timer_ISR+0x43e>
    68de:	85 81       	ldd	r24, Z+5	; 0x05
    68e0:	90 e0       	ldi	r25, 0x00	; 0
    68e2:	9c 01       	movw	r18, r24
    68e4:	22 0f       	add	r18, r18
    68e6:	33 1f       	adc	r19, r19
    68e8:	24 17       	cp	r18, r20
    68ea:	35 07       	cpc	r19, r21
    68ec:	41 f0       	breq	.+16     	; 0x68fe <MB_S_Timer_ISR+0x44e>
		return MB_Frame[MB_N][2]=IllegData;
    68ee:	83 e0       	ldi	r24, 0x03	; 3
    68f0:	ec 81       	ldd	r30, Y+4	; 0x04
    68f2:	fd 81       	ldd	r31, Y+5	; 0x05
    68f4:	e8 5b       	subi	r30, 0xB8	; 184
    68f6:	f2 4f       	sbci	r31, 0xF2	; 242
    68f8:	82 83       	std	Z+2, r24	; 0x02
    68fa:	93 e0       	ldi	r25, 0x03	; 3
    68fc:	40 c0       	rjmp	.+128    	; 0x697e <MB_S_Timer_ISR+0x4ce>
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    68fe:	f8 01       	movw	r30, r16
    6900:	e0 53       	subi	r30, 0x30	; 48
    6902:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6904:	25 91       	lpm	r18, Z+
    6906:	34 91       	lpm	r19, Z
    6908:	8e 0d       	add	r24, r14
    690a:	9f 1d       	adc	r25, r15
    690c:	28 17       	cp	r18, r24
    690e:	39 07       	cpc	r19, r25
    6910:	40 f4       	brcc	.+16     	; 0x6922 <MB_S_Timer_ISR+0x472>
		return MB_Frame[MB_N][2]=IllegAddr;
    6912:	82 e0       	ldi	r24, 0x02	; 2
    6914:	ec 81       	ldd	r30, Y+4	; 0x04
    6916:	fd 81       	ldd	r31, Y+5	; 0x05
    6918:	e8 5b       	subi	r30, 0xB8	; 184
    691a:	f2 4f       	sbci	r31, 0xF2	; 242
    691c:	82 83       	std	Z+2, r24	; 0x02
    691e:	92 e0       	ldi	r25, 0x02	; 2
    6920:	2e c0       	rjmp	.+92     	; 0x697e <MB_S_Timer_ISR+0x4ce>
	MB_Frame_Sz[MB_N] = 8;
    6922:	88 e0       	ldi	r24, 0x08	; 8
    6924:	8c 93       	st	X, r24
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    6926:	f8 01       	movw	r30, r16
    6928:	e2 53       	subi	r30, 0x32	; 50
    692a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    692c:	25 90       	lpm	r2, Z+
    692e:	34 90       	lpm	r3, Z
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6930:	61 2c       	mov	r6, r1
    6932:	2c 81       	ldd	r18, Y+4	; 0x04
    6934:	3d 81       	ldd	r19, Y+5	; 0x05
    6936:	23 5b       	subi	r18, 0xB3	; 179
    6938:	32 4f       	sbci	r19, 0xF2	; 242
    693a:	3a 83       	std	Y+2, r19	; 0x02
    693c:	29 83       	std	Y+1, r18	; 0x01
    693e:	e9 81       	ldd	r30, Y+1	; 0x01
    6940:	fa 81       	ldd	r31, Y+2	; 0x02
    6942:	80 81       	ld	r24, Z
    6944:	68 16       	cp	r6, r24
    6946:	90 f4       	brcc	.+36     	; 0x696c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    6948:	27 01       	movw	r4, r14
    694a:	46 0c       	add	r4, r6
    694c:	51 1c       	adc	r5, r1
    694e:	44 0c       	add	r4, r4
    6950:	55 1c       	adc	r5, r5
    6952:	42 0c       	add	r4, r2
    6954:	53 1c       	adc	r5, r3
    6956:	66 2d       	mov	r22, r6
    6958:	66 0f       	add	r22, r22
    695a:	69 5f       	subi	r22, 0xF9	; 249
    695c:	87 2d       	mov	r24, r7
    695e:	0e 94 44 32 	call	0x6488	; 0x6488 <MB_FrameReg>
    6962:	d2 01       	movw	r26, r4
    6964:	8d 93       	st	X+, r24
    6966:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6968:	63 94       	inc	r6
    696a:	e9 cf       	rjmp	.-46     	; 0x693e <MB_S_Timer_ISR+0x48e>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
	}
	return 0;
    696c:	90 e0       	ldi	r25, 0x00	; 0
    696e:	07 c0       	rjmp	.+14     	; 0x697e <MB_S_Timer_ISR+0x4ce>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6970:	81 e0       	ldi	r24, 0x01	; 1
    6972:	ec 81       	ldd	r30, Y+4	; 0x04
    6974:	fd 81       	ldd	r31, Y+5	; 0x05
    6976:	e8 5b       	subi	r30, 0xB8	; 184
    6978:	f2 4f       	sbci	r31, 0xF2	; 242
    697a:	82 83       	std	Z+2, r24	; 0x02
    697c:	91 e0       	ldi	r25, 0x01	; 1
		break;
	}
	if (MB_Frame[MB_N][0]) {
    697e:	ec 81       	ldd	r30, Y+4	; 0x04
    6980:	fd 81       	ldd	r31, Y+5	; 0x05
    6982:	e8 5b       	subi	r30, 0xB8	; 184
    6984:	f2 4f       	sbci	r31, 0xF2	; 242
    6986:	80 81       	ld	r24, Z
    6988:	88 23       	and	r24, r24
    698a:	79 f0       	breq	.+30     	; 0x69aa <MB_S_Timer_ISR+0x4fa>
		if (Err) {
    698c:	99 23       	and	r25, r25
    698e:	41 f0       	breq	.+16     	; 0x69a0 <MB_S_Timer_ISR+0x4f0>
			MB_Frame[MB_N][1] |=(1<<7);
    6990:	81 81       	ldd	r24, Z+1	; 0x01
    6992:	80 68       	ori	r24, 0x80	; 128
    6994:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    6996:	f6 01       	movw	r30, r12
    6998:	e7 52       	subi	r30, 0x27	; 39
    699a:	f7 4f       	sbci	r31, 0xF7	; 247
    699c:	85 e0       	ldi	r24, 0x05	; 5
    699e:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    69a0:	87 2d       	mov	r24, r7
    69a2:	9b 83       	std	Y+3, r25	; 0x03
    69a4:	0e 94 c5 30 	call	0x618a	; 0x618a <SetCRC_MB>
    69a8:	9b 81       	ldd	r25, Y+3	; 0x03
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    69aa:	99 23       	and	r25, r25
    69ac:	41 f0       	breq	.+16     	; 0x69be <MB_S_Timer_ISR+0x50e>
		MB_CPT[MB_N][2]++;
    69ae:	f8 01       	movw	r30, r16
    69b0:	e7 5d       	subi	r30, 0xD7	; 215
    69b2:	f4 4f       	sbci	r31, 0xF4	; 244
    69b4:	84 81       	ldd	r24, Z+4	; 0x04
    69b6:	95 81       	ldd	r25, Z+5	; 0x05
    69b8:	01 96       	adiw	r24, 0x01	; 1
    69ba:	95 83       	std	Z+5, r25	; 0x05
    69bc:	84 83       	std	Z+4, r24	; 0x04
	if (MB_Frame[MB_N][0])
    69be:	ec 81       	ldd	r30, Y+4	; 0x04
    69c0:	fd 81       	ldd	r31, Y+5	; 0x05
    69c2:	e8 5b       	subi	r30, 0xB8	; 184
    69c4:	f2 4f       	sbci	r31, 0xF2	; 242
    69c6:	80 81       	ld	r24, Z
    69c8:	88 23       	and	r24, r24
    69ca:	d1 f0       	breq	.+52     	; 0x6a00 <MB_S_Timer_ISR+0x550>
		MB_Transm(MB_N);
    69cc:	87 2d       	mov	r24, r7
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69ce:	0f 90       	pop	r0
    69d0:	0f 90       	pop	r0
    69d2:	0f 90       	pop	r0
    69d4:	0f 90       	pop	r0
    69d6:	0f 90       	pop	r0
    69d8:	df 91       	pop	r29
    69da:	cf 91       	pop	r28
    69dc:	1f 91       	pop	r17
    69de:	0f 91       	pop	r16
    69e0:	ff 90       	pop	r15
    69e2:	ef 90       	pop	r14
    69e4:	df 90       	pop	r13
    69e6:	cf 90       	pop	r12
    69e8:	bf 90       	pop	r11
    69ea:	af 90       	pop	r10
    69ec:	9f 90       	pop	r9
    69ee:	8f 90       	pop	r8
    69f0:	7f 90       	pop	r7
    69f2:	6f 90       	pop	r6
    69f4:	5f 90       	pop	r5
    69f6:	4f 90       	pop	r4
    69f8:	3f 90       	pop	r3
    69fa:	2f 90       	pop	r2
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    69fc:	0c 94 c3 2f 	jmp	0x5f86	; 0x5f86 <MB_Transm>
	else {
		MB_CPT[MB_N][4]++;
    6a00:	f8 01       	movw	r30, r16
    6a02:	e7 5d       	subi	r30, 0xD7	; 215
    6a04:	f4 4f       	sbci	r31, 0xF4	; 244
    6a06:	80 85       	ldd	r24, Z+8	; 0x08
    6a08:	91 85       	ldd	r25, Z+9	; 0x09
    6a0a:	01 96       	adiw	r24, 0x01	; 1
    6a0c:	91 87       	std	Z+9, r25	; 0x09
    6a0e:	80 87       	std	Z+8, r24	; 0x08
		MB_State[MB_N] = MB_Idle;
    6a10:	81 e0       	ldi	r24, 0x01	; 1
    6a12:	d5 01       	movw	r26, r10
    6a14:	8c 93       	st	X, r24
    6a16:	f4 01       	movw	r30, r8
    6a18:	85 91       	lpm	r24, Z+
    6a1a:	94 91       	lpm	r25, Z
		USART_Func(MB_N, LED);
    6a1c:	fc 01       	movw	r30, r24
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a1e:	0f 90       	pop	r0
    6a20:	0f 90       	pop	r0
    6a22:	0f 90       	pop	r0
    6a24:	0f 90       	pop	r0
    6a26:	0f 90       	pop	r0
    6a28:	df 91       	pop	r29
    6a2a:	cf 91       	pop	r28
    6a2c:	1f 91       	pop	r17
    6a2e:	0f 91       	pop	r16
    6a30:	ff 90       	pop	r15
    6a32:	ef 90       	pop	r14
    6a34:	df 90       	pop	r13
    6a36:	cf 90       	pop	r12
    6a38:	bf 90       	pop	r11
    6a3a:	af 90       	pop	r10
    6a3c:	9f 90       	pop	r9
    6a3e:	8f 90       	pop	r8
    6a40:	7f 90       	pop	r7
    6a42:	6f 90       	pop	r6
    6a44:	5f 90       	pop	r5
    6a46:	4f 90       	pop	r4
    6a48:	3f 90       	pop	r3
    6a4a:	2f 90       	pop	r2
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
		MB_State[MB_N] = MB_Idle;
		USART_Func(MB_N, LED);
    6a4c:	09 94       	ijmp
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a4e:	0f 90       	pop	r0
    6a50:	0f 90       	pop	r0
    6a52:	0f 90       	pop	r0
    6a54:	0f 90       	pop	r0
    6a56:	0f 90       	pop	r0
    6a58:	df 91       	pop	r29
    6a5a:	cf 91       	pop	r28
    6a5c:	1f 91       	pop	r17
    6a5e:	0f 91       	pop	r16
    6a60:	ff 90       	pop	r15
    6a62:	ef 90       	pop	r14
    6a64:	df 90       	pop	r13
    6a66:	cf 90       	pop	r12
    6a68:	bf 90       	pop	r11
    6a6a:	af 90       	pop	r10
    6a6c:	9f 90       	pop	r9
    6a6e:	8f 90       	pop	r8
    6a70:	7f 90       	pop	r7
    6a72:	6f 90       	pop	r6
    6a74:	5f 90       	pop	r5
    6a76:	4f 90       	pop	r4
    6a78:	3f 90       	pop	r3
    6a7a:	2f 90       	pop	r2
    6a7c:	08 95       	ret

00006a7e <MB_S_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6a7e:	24 e1       	ldi	r18, 0x14	; 20
    6a80:	82 9f       	mul	r24, r18
    6a82:	c0 01       	movw	r24, r0
    6a84:	11 24       	eor	r1, r1
    6a86:	8b 55       	subi	r24, 0x5B	; 91
    6a88:	90 4b       	sbci	r25, 0xB0	; 176
    6a8a:	fc 01       	movw	r30, r24
    6a8c:	85 91       	lpm	r24, Z+
    6a8e:	94 91       	lpm	r25, Z
    6a90:	fc 01       	movw	r30, r24
    6a92:	09 94       	ijmp

00006a94 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    6a94:	cf 93       	push	r28
    6a96:	df 93       	push	r29
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    6a98:	c8 2f       	mov	r28, r24
    6a9a:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6a9c:	ce 01       	movw	r24, r28
    6a9e:	8e 55       	subi	r24, 0x5E	; 94
    6aa0:	9e 4f       	sbci	r25, 0xFE	; 254
    6aa2:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    6aa6:	c8 50       	subi	r28, 0x08	; 8
    6aa8:	dc 4f       	sbci	r29, 0xFC	; 252
    6aaa:	88 83       	st	Y, r24
	#endif
}
    6aac:	df 91       	pop	r29
    6aae:	cf 91       	pop	r28
    6ab0:	08 95       	ret

00006ab2 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    6ab2:	0f 93       	push	r16
    6ab4:	1f 93       	push	r17
    6ab6:	cf 93       	push	r28
    6ab8:	df 93       	push	r29
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    6aba:	c8 2f       	mov	r28, r24
    6abc:	d0 e0       	ldi	r29, 0x00	; 0
    6abe:	95 e0       	ldi	r25, 0x05	; 5
    6ac0:	89 9f       	mul	r24, r25
    6ac2:	80 01       	movw	r16, r0
    6ac4:	11 24       	eor	r1, r1
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    6ac6:	c8 01       	movw	r24, r16
    6ac8:	86 56       	subi	r24, 0x66	; 102
    6aca:	9e 4f       	sbci	r25, 0xFE	; 254
    6acc:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    6ad0:	fe 01       	movw	r30, r28
    6ad2:	ee 0f       	add	r30, r30
    6ad4:	ff 1f       	adc	r31, r31
    6ad6:	e0 5e       	subi	r30, 0xE0	; 224
    6ad8:	f9 4f       	sbci	r31, 0xF9	; 249
    6ada:	91 83       	std	Z+1, r25	; 0x01
    6adc:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6ade:	c8 01       	movw	r24, r16
    6ae0:	84 56       	subi	r24, 0x64	; 100
    6ae2:	9e 4f       	sbci	r25, 0xFE	; 254
    6ae4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    6ae8:	fe 01       	movw	r30, r28
    6aea:	ee 5e       	subi	r30, 0xEE	; 238
    6aec:	f4 4f       	sbci	r31, 0xF4	; 244
    6aee:	80 83       	st	Z, r24
    6af0:	c8 01       	movw	r24, r16
    6af2:	83 56       	subi	r24, 0x63	; 99
    6af4:	9e 4f       	sbci	r25, 0xFE	; 254
    6af6:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    6afa:	fe 01       	movw	r30, r28
    6afc:	ec 52       	subi	r30, 0x2C	; 44
    6afe:	f7 4f       	sbci	r31, 0xF7	; 247
    6b00:	80 83       	st	Z, r24
    6b02:	c8 01       	movw	r24, r16
    6b04:	82 56       	subi	r24, 0x62	; 98
    6b06:	9e 4f       	sbci	r25, 0xFE	; 254
    6b08:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    6b0c:	c6 51       	subi	r28, 0x16	; 22
    6b0e:	dc 4f       	sbci	r29, 0xFC	; 252
    6b10:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    6b12:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    6b16:	93 e0       	ldi	r25, 0x03	; 3
    6b18:	98 0f       	add	r25, r24
    6b1a:	90 93 0e 01 	sts	0x010E, r25

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    6b1e:	80 93 5c 02 	sts	0x025C, r24
}
    6b22:	df 91       	pop	r29
    6b24:	cf 91       	pop	r28
    6b26:	1f 91       	pop	r17
    6b28:	0f 91       	pop	r16
    6b2a:	08 95       	ret

00006b2c <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    6b2c:	0e 94 ad 2e 	call	0x5d5a	; 0x5d5a <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    6b30:	10 92 e1 03 	sts	0x03E1, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b34:	e9 e9       	ldi	r30, 0x99	; 153
    6b36:	ff e4       	ldi	r31, 0x4F	; 79
    6b38:	a5 91       	lpm	r26, Z+
    6b3a:	b4 91       	lpm	r27, Z
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    6b3c:	8c ef       	ldi	r24, 0xFC	; 252
    6b3e:	8c 93       	st	X, r24
    6b40:	eb e9       	ldi	r30, 0x9B	; 155
    6b42:	ff e4       	ldi	r31, 0x4F	; 79
    6b44:	a5 91       	lpm	r26, Z+
    6b46:	b4 91       	lpm	r27, Z
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    6b48:	88 e9       	ldi	r24, 0x98	; 152
    6b4a:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    6b4c:	80 e0       	ldi	r24, 0x00	; 0
    6b4e:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <SetParity>
		SetBAUD(MB_N);
    6b52:	80 e0       	ldi	r24, 0x00	; 0
    6b54:	0e 94 80 2f 	call	0x5f00	; 0x5f00 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6b58:	e6 ed       	ldi	r30, 0xD6	; 214
    6b5a:	ff e4       	ldi	r31, 0x4F	; 79
    6b5c:	e4 91       	lpm	r30, Z
		switch (prb(MB_Role+MB_N)) {
    6b5e:	ee 23       	and	r30, r30
    6b60:	31 f0       	breq	.+12     	; 0x6b6e <MB_Init+0x42>
    6b62:	e1 30       	cpi	r30, 0x01	; 1
    6b64:	39 f4       	brne	.+14     	; 0x6b74 <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    6b66:	80 e0       	ldi	r24, 0x00	; 0
    6b68:	0e 94 59 35 	call	0x6ab2	; 0x6ab2 <MB_M_Init>
			break;
    6b6c:	03 c0       	rjmp	.+6      	; 0x6b74 <MB_Init+0x48>
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
		case Role_Slave:
			MB_S_Init(MB_N);
    6b6e:	80 e0       	ldi	r24, 0x00	; 0
    6b70:	0e 94 4a 35 	call	0x6a94	; 0x6a94 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b74:	ef e8       	ldi	r30, 0x8F	; 143
    6b76:	ff e4       	ldi	r31, 0x4F	; 79
    6b78:	25 91       	lpm	r18, Z+
    6b7a:	34 91       	lpm	r19, Z
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    6b7c:	f9 01       	movw	r30, r18
    6b7e:	09 94       	ijmp

00006b80 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6b80:	4f 92       	push	r4
    6b82:	5f 92       	push	r5
    6b84:	7f 92       	push	r7
    6b86:	8f 92       	push	r8
    6b88:	9f 92       	push	r9
    6b8a:	af 92       	push	r10
    6b8c:	bf 92       	push	r11
    6b8e:	cf 92       	push	r12
    6b90:	df 92       	push	r13
    6b92:	ef 92       	push	r14
    6b94:	ff 92       	push	r15
    6b96:	0f 93       	push	r16
    6b98:	1f 93       	push	r17
    6b9a:	cf 93       	push	r28
    6b9c:	df 93       	push	r29
    6b9e:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    6ba0:	c8 2f       	mov	r28, r24
    6ba2:	d0 e0       	ldi	r29, 0x00	; 0
    6ba4:	fe 01       	movw	r30, r28
    6ba6:	ef 51       	subi	r30, 0x1F	; 31
    6ba8:	fc 4f       	sbci	r31, 0xFC	; 252
    6baa:	80 81       	ld	r24, Z
    6bac:	88 23       	and	r24, r24
    6bae:	19 f0       	breq	.+6      	; 0x6bb6 <MB_M_Timer_ISR+0x36>
    6bb0:	82 30       	cpi	r24, 0x02	; 2
    6bb2:	f1 f0       	breq	.+60     	; 0x6bf0 <MB_M_Timer_ISR+0x70>
    6bb4:	85 c2       	rjmp	.+1290   	; 0x70c0 <MB_M_Timer_ISR+0x540>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6bb6:	80 91 5c 02 	lds	r24, 0x025C
    6bba:	8e 5f       	subi	r24, 0xFE	; 254
    6bbc:	6f ef       	ldi	r22, 0xFF	; 255
    6bbe:	7f ef       	ldi	r23, 0xFF	; 255
    6bc0:	8d 0d       	add	r24, r13
    6bc2:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
		FormQuery(MB_N);
    6bc6:	8d 2d       	mov	r24, r13
    6bc8:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <FormQuery>
		MB_Transm(MB_N);
    6bcc:	8d 2d       	mov	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6bce:	df 91       	pop	r29
    6bd0:	cf 91       	pop	r28
    6bd2:	1f 91       	pop	r17
    6bd4:	0f 91       	pop	r16
    6bd6:	ff 90       	pop	r15
    6bd8:	ef 90       	pop	r14
    6bda:	df 90       	pop	r13
    6bdc:	cf 90       	pop	r12
    6bde:	bf 90       	pop	r11
    6be0:	af 90       	pop	r10
    6be2:	9f 90       	pop	r9
    6be4:	8f 90       	pop	r8
    6be6:	7f 90       	pop	r7
    6be8:	5f 90       	pop	r5
    6bea:	4f 90       	pop	r4
{
	switch (MB_State[MB_N]) {
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
    6bec:	0c 94 c3 2f 	jmp	0x5f86	; 0x5f86 <MB_Transm>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6bf0:	84 e0       	ldi	r24, 0x04	; 4
    6bf2:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6bf4:	9e 01       	movw	r18, r28
    6bf6:	2e 5d       	subi	r18, 0xDE	; 222
    6bf8:	39 4f       	sbci	r19, 0xF9	; 249
    6bfa:	79 01       	movw	r14, r18
    6bfc:	f9 01       	movw	r30, r18
    6bfe:	90 81       	ld	r25, Z
    6c00:	81 e0       	ldi	r24, 0x01	; 1
    6c02:	92 30       	cpi	r25, 0x02	; 2
    6c04:	09 f0       	breq	.+2      	; 0x6c08 <MB_M_Timer_ISR+0x88>
    6c06:	80 e0       	ldi	r24, 0x00	; 0
    6c08:	80 93 62 02 	sts	0x0262, r24
	if (CommErr(MB_N))
    6c0c:	8d 2d       	mov	r24, r13
    6c0e:	0e 94 64 30 	call	0x60c8	; 0x60c8 <CommErr>
    6c12:	81 11       	cpse	r24, r1
    6c14:	ed c1       	rjmp	.+986    	; 0x6ff0 <MB_M_Timer_ISR+0x470>
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6c16:	84 e1       	ldi	r24, 0x14	; 20
    6c18:	8c 9f       	mul	r24, r28
    6c1a:	f0 01       	movw	r30, r0
    6c1c:	8d 9f       	mul	r24, r29
    6c1e:	f0 0d       	add	r31, r0
    6c20:	11 24       	eor	r1, r1
    6c22:	eb 55       	subi	r30, 0x5B	; 91
    6c24:	f0 4b       	sbci	r31, 0xB0	; 176
    6c26:	85 91       	lpm	r24, Z+
    6c28:	94 91       	lpm	r25, Z
    6c2a:	fc 01       	movw	r30, r24
    6c2c:	09 95       	icall
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6c2e:	80 91 62 02 	lds	r24, 0x0262
    6c32:	88 23       	and	r24, r24
    6c34:	79 f0       	breq	.+30     	; 0x6c54 <MB_M_Timer_ISR+0xd4>
			Addr = MB_SingleQuery[MB_N].Addr;
    6c36:	fe 01       	movw	r30, r28
    6c38:	63 e0       	ldi	r22, 0x03	; 3
    6c3a:	ee 0f       	add	r30, r30
    6c3c:	ff 1f       	adc	r31, r31
    6c3e:	6a 95       	dec	r22
    6c40:	e1 f7       	brne	.-8      	; 0x6c3a <MB_M_Timer_ISR+0xba>
    6c42:	ed 59       	subi	r30, 0x9D	; 157
    6c44:	fd 4f       	sbci	r31, 0xFD	; 253
    6c46:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6c48:	41 81       	ldd	r20, Z+1	; 0x01
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
    6c4a:	80 e0       	ldi	r24, 0x00	; 0
    6c4c:	90 e0       	ldi	r25, 0x00	; 0
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
    6c4e:	00 e0       	ldi	r16, 0x00	; 0
    6c50:	10 e0       	ldi	r17, 0x00	; 0
    6c52:	15 c0       	rjmp	.+42     	; 0x6c7e <MB_M_Timer_ISR+0xfe>
		if (LastProcSingle) {
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
    6c54:	8d 2d       	mov	r24, r13
    6c56:	0e 94 bd 28 	call	0x517a	; 0x517a <GetSlave>
    6c5a:	8c 01       	movw	r16, r24
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6c5c:	fc 01       	movw	r30, r24
    6c5e:	31 96       	adiw	r30, 0x01	; 1
    6c60:	85 91       	lpm	r24, Z+
    6c62:	94 91       	lpm	r25, Z
    6c64:	fe 01       	movw	r30, r28
    6c66:	e3 5f       	subi	r30, 0xF3	; 243
    6c68:	f9 4f       	sbci	r31, 0xF9	; 249
    6c6a:	20 81       	ld	r18, Z
    6c6c:	f7 e0       	ldi	r31, 0x07	; 7
    6c6e:	2f 9f       	mul	r18, r31
    6c70:	80 0d       	add	r24, r0
    6c72:	91 1d       	adc	r25, r1
    6c74:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6c76:	f8 01       	movw	r30, r16
    6c78:	24 91       	lpm	r18, Z
    6c7a:	fc 01       	movw	r30, r24
    6c7c:	44 91       	lpm	r20, Z
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6c7e:	bc 2f       	mov	r27, r28
    6c80:	aa 27       	eor	r26, r26
    6c82:	fd 01       	movw	r30, r26
    6c84:	e8 5b       	subi	r30, 0xB8	; 184
    6c86:	f2 4f       	sbci	r31, 0xF2	; 242
    6c88:	30 81       	ld	r19, Z
    6c8a:	32 13       	cpse	r19, r18
    6c8c:	b1 c1       	rjmp	.+866    	; 0x6ff0 <MB_M_Timer_ISR+0x470>
    6c8e:	c1 80       	ldd	r12, Z+1	; 0x01
    6c90:	c4 12       	cpse	r12, r20
    6c92:	ae c1       	rjmp	.+860    	; 0x6ff0 <MB_M_Timer_ISR+0x470>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err = 0;
			switch (Func) {
    6c94:	50 e0       	ldi	r21, 0x00	; 0
    6c96:	fa 01       	movw	r30, r20
    6c98:	31 97       	sbiw	r30, 0x01	; 1
    6c9a:	e0 31       	cpi	r30, 0x10	; 16
    6c9c:	f1 05       	cpc	r31, r1
    6c9e:	08 f0       	brcs	.+2      	; 0x6ca2 <MB_M_Timer_ISR+0x122>
    6ca0:	ab c1       	rjmp	.+854    	; 0x6ff8 <MB_M_Timer_ISR+0x478>
    6ca2:	ea 5a       	subi	r30, 0xAA	; 170
    6ca4:	ff 4f       	sbci	r31, 0xFF	; 255
    6ca6:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6caa:	20 91 62 02 	lds	r18, 0x0262
    6cae:	22 23       	and	r18, r18
    6cb0:	51 f0       	breq	.+20     	; 0x6cc6 <MB_M_Timer_ISR+0x146>
    6cb2:	fe 01       	movw	r30, r28
    6cb4:	43 e0       	ldi	r20, 0x03	; 3
    6cb6:	ee 0f       	add	r30, r30
    6cb8:	ff 1f       	adc	r31, r31
    6cba:	4a 95       	dec	r20
    6cbc:	e1 f7       	brne	.-8      	; 0x6cb6 <MB_M_Timer_ISR+0x136>
    6cbe:	ed 59       	subi	r30, 0x9D	; 157
    6cc0:	fd 4f       	sbci	r31, 0xFD	; 253
    6cc2:	64 81       	ldd	r22, Z+4	; 0x04
    6cc4:	03 c0       	rjmp	.+6      	; 0x6ccc <MB_M_Timer_ISR+0x14c>
    6cc6:	fc 01       	movw	r30, r24
    6cc8:	33 96       	adiw	r30, 0x03	; 3
    6cca:	64 91       	lpm	r22, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6ccc:	fd 01       	movw	r30, r26
    6cce:	e8 5b       	subi	r30, 0xB8	; 184
    6cd0:	f2 4f       	sbci	r31, 0xF2	; 242
    6cd2:	22 81       	ldd	r18, Z+2	; 0x02
    6cd4:	30 e0       	ldi	r19, 0x00	; 0
    6cd6:	fe 01       	movw	r30, r28
    6cd8:	e7 52       	subi	r30, 0x27	; 39
    6cda:	f7 4f       	sbci	r31, 0xF7	; 247
    6cdc:	e0 81       	ld	r30, Z
    6cde:	f0 e0       	ldi	r31, 0x00	; 0
    6ce0:	a9 01       	movw	r20, r18
    6ce2:	4b 5f       	subi	r20, 0xFB	; 251
    6ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    6ce6:	e4 17       	cp	r30, r20
    6ce8:	f5 07       	cpc	r31, r21
    6cea:	09 f0       	breq	.+2      	; 0x6cee <MB_M_Timer_ISR+0x16e>
    6cec:	74 c1       	rjmp	.+744    	; 0x6fd6 <MB_M_Timer_ISR+0x456>
    6cee:	e6 2f       	mov	r30, r22
    6cf0:	e6 95       	lsr	r30
    6cf2:	e6 95       	lsr	r30
    6cf4:	e6 95       	lsr	r30
    6cf6:	f0 e0       	ldi	r31, 0x00	; 0
    6cf8:	41 e0       	ldi	r20, 0x01	; 1
    6cfa:	50 e0       	ldi	r21, 0x00	; 0
    6cfc:	76 2f       	mov	r23, r22
    6cfe:	77 70       	andi	r23, 0x07	; 7
    6d00:	11 f4       	brne	.+4      	; 0x6d06 <MB_M_Timer_ISR+0x186>
    6d02:	40 e0       	ldi	r20, 0x00	; 0
    6d04:	50 e0       	ldi	r21, 0x00	; 0
    6d06:	4e 0f       	add	r20, r30
    6d08:	5f 1f       	adc	r21, r31
    6d0a:	42 17       	cp	r20, r18
    6d0c:	53 07       	cpc	r21, r19
    6d0e:	09 f0       	breq	.+2      	; 0x6d12 <MB_M_Timer_ISR+0x192>
    6d10:	62 c1       	rjmp	.+708    	; 0x6fd6 <MB_M_Timer_ISR+0x456>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d12:	20 91 62 02 	lds	r18, 0x0262
		Discr = MB_SingleQuery[MB_N].Buf;
    6d16:	fe 01       	movw	r30, r28
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d18:	22 23       	and	r18, r18
    6d1a:	59 f0       	breq	.+22     	; 0x6d32 <MB_M_Timer_ISR+0x1b2>
		Discr = MB_SingleQuery[MB_N].Buf;
    6d1c:	33 e0       	ldi	r19, 0x03	; 3
    6d1e:	ee 0f       	add	r30, r30
    6d20:	ff 1f       	adc	r31, r31
    6d22:	3a 95       	dec	r19
    6d24:	e1 f7       	brne	.-8      	; 0x6d1e <MB_M_Timer_ISR+0x19e>
    6d26:	ed 59       	subi	r30, 0x9D	; 157
    6d28:	fd 4f       	sbci	r31, 0xFD	; 253
    6d2a:	46 81       	ldd	r20, Z+6	; 0x06
    6d2c:	57 81       	ldd	r21, Z+7	; 0x07
		Pin = 0;
    6d2e:	c1 2c       	mov	r12, r1
    6d30:	14 c0       	rjmp	.+40     	; 0x6d5a <MB_M_Timer_ISR+0x1da>
    6d32:	24 e0       	ldi	r18, 0x04	; 4
    6d34:	ee 0f       	add	r30, r30
    6d36:	ff 1f       	adc	r31, r31
    6d38:	2a 95       	dec	r18
    6d3a:	e1 f7       	brne	.-8      	; 0x6d34 <MB_M_Timer_ISR+0x1b4>
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6d3c:	21 e0       	ldi	r18, 0x01	; 1
    6d3e:	c2 12       	cpse	r12, r18
    6d40:	03 c0       	rjmp	.+6      	; 0x6d48 <MB_M_Timer_ISR+0x1c8>
    6d42:	ea 53       	subi	r30, 0x3A	; 58
    6d44:	f0 4b       	sbci	r31, 0xB0	; 176
    6d46:	02 c0       	rjmp	.+4      	; 0x6d4c <MB_M_Timer_ISR+0x1cc>
    6d48:	e6 53       	subi	r30, 0x36	; 54
    6d4a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6d4c:	45 91       	lpm	r20, Z+
    6d4e:	54 91       	lpm	r21, Z
		Pin = prw(&Query->AllocAddr);
    6d50:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6d52:	fc 01       	movw	r30, r24
    6d54:	85 91       	lpm	r24, Z+
    6d56:	94 91       	lpm	r25, Z
    6d58:	c8 2e       	mov	r12, r24
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d5a:	20 e0       	ldi	r18, 0x00	; 0
    6d5c:	30 e0       	ldi	r19, 0x00	; 0
    6d5e:	86 2e       	mov	r8, r22
    6d60:	91 2c       	mov	r9, r1
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d62:	aa 24       	eor	r10, r10
    6d64:	a3 94       	inc	r10
    6d66:	b1 2c       	mov	r11, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d68:	a8 5b       	subi	r26, 0xB8	; 184
    6d6a:	b2 4f       	sbci	r27, 0xF2	; 242
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d6c:	28 15       	cp	r18, r8
    6d6e:	39 05       	cpc	r19, r9
    6d70:	08 f0       	brcs	.+2      	; 0x6d74 <MB_M_Timer_ISR+0x1f4>
    6d72:	42 c1       	rjmp	.+644    	; 0x6ff8 <MB_M_Timer_ISR+0x478>
    6d74:	ec 2d       	mov	r30, r12
    6d76:	e2 0f       	add	r30, r18
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d78:	7e 2e       	mov	r7, r30
    6d7a:	76 94       	lsr	r7
    6d7c:	76 94       	lsr	r7
    6d7e:	76 94       	lsr	r7
    6d80:	e7 70       	andi	r30, 0x07	; 7
    6d82:	25 01       	movw	r4, r10
    6d84:	01 c0       	rjmp	.+2      	; 0x6d88 <MB_M_Timer_ISR+0x208>
    6d86:	44 0c       	add	r4, r4
    6d88:	ea 95       	dec	r30
    6d8a:	ea f7       	brpl	.-6      	; 0x6d86 <MB_M_Timer_ISR+0x206>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d8c:	c9 01       	movw	r24, r18
    6d8e:	63 e0       	ldi	r22, 0x03	; 3
    6d90:	96 95       	lsr	r25
    6d92:	87 95       	ror	r24
    6d94:	6a 95       	dec	r22
    6d96:	e1 f7       	brne	.-8      	; 0x6d90 <MB_M_Timer_ISR+0x210>
    6d98:	8a 0f       	add	r24, r26
    6d9a:	9b 1f       	adc	r25, r27
    6d9c:	fc 01       	movw	r30, r24
    6d9e:	63 81       	ldd	r22, Z+3	; 0x03
    6da0:	70 e0       	ldi	r23, 0x00	; 0
    6da2:	c9 01       	movw	r24, r18
    6da4:	87 70       	andi	r24, 0x07	; 7
    6da6:	99 27       	eor	r25, r25
    6da8:	02 c0       	rjmp	.+4      	; 0x6dae <MB_M_Timer_ISR+0x22e>
    6daa:	75 95       	asr	r23
    6dac:	67 95       	ror	r22
    6dae:	8a 95       	dec	r24
    6db0:	e2 f7       	brpl	.-8      	; 0x6daa <MB_M_Timer_ISR+0x22a>
    6db2:	87 2d       	mov	r24, r7
    6db4:	90 e0       	ldi	r25, 0x00	; 0
			Discr[Byte] |=Bit;
    6db6:	84 0f       	add	r24, r20
    6db8:	95 1f       	adc	r25, r21
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6dba:	60 ff       	sbrs	r22, 0
    6dbc:	04 c0       	rjmp	.+8      	; 0x6dc6 <MB_M_Timer_ISR+0x246>
			Discr[Byte] |=Bit;
    6dbe:	fc 01       	movw	r30, r24
    6dc0:	60 81       	ld	r22, Z
    6dc2:	64 29       	or	r22, r4
    6dc4:	04 c0       	rjmp	.+8      	; 0x6dce <MB_M_Timer_ISR+0x24e>
		else
			Discr[Byte] &=~Bit;
    6dc6:	40 94       	com	r4
    6dc8:	fc 01       	movw	r30, r24
    6dca:	60 81       	ld	r22, Z
    6dcc:	64 21       	and	r22, r4
    6dce:	60 83       	st	Z, r22
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6dd0:	2f 5f       	subi	r18, 0xFF	; 255
    6dd2:	3f 4f       	sbci	r19, 0xFF	; 255
    6dd4:	cb cf       	rjmp	.-106    	; 0x6d6c <MB_M_Timer_ISR+0x1ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6dd6:	a8 5b       	subi	r26, 0xB8	; 184
    6dd8:	b2 4f       	sbci	r27, 0xF2	; 242
    6dda:	12 96       	adiw	r26, 0x02	; 2
    6ddc:	4c 91       	ld	r20, X
    6dde:	fe 01       	movw	r30, r28
    6de0:	e7 52       	subi	r30, 0x27	; 39
    6de2:	f7 4f       	sbci	r31, 0xF7	; 247
    6de4:	e0 81       	ld	r30, Z
    6de6:	f0 e0       	ldi	r31, 0x00	; 0
    6de8:	64 2f       	mov	r22, r20
    6dea:	70 e0       	ldi	r23, 0x00	; 0
    6dec:	9b 01       	movw	r18, r22
    6dee:	2b 5f       	subi	r18, 0xFB	; 251
    6df0:	3f 4f       	sbci	r19, 0xFF	; 255
    6df2:	e2 17       	cp	r30, r18
    6df4:	f3 07       	cpc	r31, r19
    6df6:	09 f0       	breq	.+2      	; 0x6dfa <MB_M_Timer_ISR+0x27a>
    6df8:	ee c0       	rjmp	.+476    	; 0x6fd6 <MB_M_Timer_ISR+0x456>
    6dfa:	20 91 62 02 	lds	r18, 0x0262
    6dfe:	22 23       	and	r18, r18
    6e00:	59 f0       	breq	.+22     	; 0x6e18 <MB_M_Timer_ISR+0x298>
    6e02:	fe 01       	movw	r30, r28
    6e04:	a3 e0       	ldi	r26, 0x03	; 3
    6e06:	ee 0f       	add	r30, r30
    6e08:	ff 1f       	adc	r31, r31
    6e0a:	aa 95       	dec	r26
    6e0c:	e1 f7       	brne	.-8      	; 0x6e06 <MB_M_Timer_ISR+0x286>
    6e0e:	ed 59       	subi	r30, 0x9D	; 157
    6e10:	fd 4f       	sbci	r31, 0xFD	; 253
    6e12:	24 81       	ldd	r18, Z+4	; 0x04
    6e14:	35 81       	ldd	r19, Z+5	; 0x05
    6e16:	04 c0       	rjmp	.+8      	; 0x6e20 <MB_M_Timer_ISR+0x2a0>
    6e18:	fc 01       	movw	r30, r24
    6e1a:	33 96       	adiw	r30, 0x03	; 3
    6e1c:	25 91       	lpm	r18, Z+
    6e1e:	34 91       	lpm	r19, Z
    6e20:	22 0f       	add	r18, r18
    6e22:	33 1f       	adc	r19, r19
    6e24:	26 17       	cp	r18, r22
    6e26:	37 07       	cpc	r19, r23
    6e28:	09 f0       	breq	.+2      	; 0x6e2c <MB_M_Timer_ISR+0x2ac>
    6e2a:	d5 c0       	rjmp	.+426    	; 0x6fd6 <MB_M_Timer_ISR+0x456>
		return 1;
	uint16_t *Reg = LastProcSingle ?
    6e2c:	20 91 62 02 	lds	r18, 0x0262
		MB_SingleQuery[MB_N].Buf
	:
    6e30:	fe 01       	movw	r30, r28
    6e32:	22 23       	and	r18, r18
    6e34:	51 f0       	breq	.+20     	; 0x6e4a <MB_M_Timer_ISR+0x2ca>
    6e36:	33 e0       	ldi	r19, 0x03	; 3
    6e38:	ee 0f       	add	r30, r30
    6e3a:	ff 1f       	adc	r31, r31
    6e3c:	3a 95       	dec	r19
    6e3e:	e1 f7       	brne	.-8      	; 0x6e38 <MB_M_Timer_ISR+0x2b8>
    6e40:	ed 59       	subi	r30, 0x9D	; 157
    6e42:	fd 4f       	sbci	r31, 0xFD	; 253
    6e44:	a6 80       	ldd	r10, Z+6	; 0x06
    6e46:	b7 80       	ldd	r11, Z+7	; 0x07
    6e48:	17 c0       	rjmp	.+46     	; 0x6e78 <MB_M_Timer_ISR+0x2f8>
    6e4a:	24 e0       	ldi	r18, 0x04	; 4
    6e4c:	ee 0f       	add	r30, r30
    6e4e:	ff 1f       	adc	r31, r31
    6e50:	2a 95       	dec	r18
    6e52:	e1 f7       	brne	.-8      	; 0x6e4c <MB_M_Timer_ISR+0x2cc>
    6e54:	23 e0       	ldi	r18, 0x03	; 3
    6e56:	c2 12       	cpse	r12, r18
    6e58:	03 c0       	rjmp	.+6      	; 0x6e60 <MB_M_Timer_ISR+0x2e0>
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e5a:	e2 53       	subi	r30, 0x32	; 50
    6e5c:	f0 4b       	sbci	r31, 0xB0	; 176
    6e5e:	02 c0       	rjmp	.+4      	; 0x6e64 <MB_M_Timer_ISR+0x2e4>
    6e60:	ee 52       	subi	r30, 0x2E	; 46
    6e62:	f0 4b       	sbci	r31, 0xB0	; 176
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e64:	25 91       	lpm	r18, Z+
    6e66:	34 91       	lpm	r19, Z
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e68:	05 96       	adiw	r24, 0x05	; 5
    6e6a:	fc 01       	movw	r30, r24
    6e6c:	a5 90       	lpm	r10, Z+
    6e6e:	b4 90       	lpm	r11, Z
    6e70:	aa 0c       	add	r10, r10
    6e72:	bb 1c       	adc	r11, r11
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e74:	a2 0e       	add	r10, r18
    6e76:	b3 1e       	adc	r11, r19
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6e78:	46 95       	lsr	r20
    6e7a:	cc 24       	eor	r12, r12
    6e7c:	ca 94       	dec	r12
    6e7e:	c4 0e       	add	r12, r20
    6e80:	74 2e       	mov	r7, r20
    6e82:	77 0c       	add	r7, r7
    6e84:	7a 94       	dec	r7
    6e86:	7a 94       	dec	r7
    6e88:	ff ef       	ldi	r31, 0xFF	; 255
    6e8a:	cf 16       	cp	r12, r31
    6e8c:	09 f4       	brne	.+2      	; 0x6e90 <MB_M_Timer_ISR+0x310>
    6e8e:	b4 c0       	rjmp	.+360    	; 0x6ff8 <MB_M_Timer_ISR+0x478>
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6e90:	8c 2c       	mov	r8, r12
    6e92:	88 0c       	add	r8, r8
    6e94:	99 08       	sbc	r9, r9
    6e96:	8a 0c       	add	r8, r10
    6e98:	9b 1c       	adc	r9, r11
    6e9a:	63 e0       	ldi	r22, 0x03	; 3
    6e9c:	67 0d       	add	r22, r7
    6e9e:	8d 2d       	mov	r24, r13
    6ea0:	0e 94 44 32 	call	0x6488	; 0x6488 <MB_FrameReg>
    6ea4:	f4 01       	movw	r30, r8
    6ea6:	91 83       	std	Z+1, r25	; 0x01
    6ea8:	80 83       	st	Z, r24
    6eaa:	ca 94       	dec	r12
    6eac:	eb cf       	rjmp	.-42     	; 0x6e84 <MB_M_Timer_ISR+0x304>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6eae:	20 91 62 02 	lds	r18, 0x0262
    6eb2:	22 23       	and	r18, r18
    6eb4:	69 f0       	breq	.+26     	; 0x6ed0 <MB_M_Timer_ISR+0x350>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6eb6:	fe 01       	movw	r30, r28
    6eb8:	83 e0       	ldi	r24, 0x03	; 3
    6eba:	ee 0f       	add	r30, r30
    6ebc:	ff 1f       	adc	r31, r31
    6ebe:	8a 95       	dec	r24
    6ec0:	e1 f7       	brne	.-8      	; 0x6eba <MB_M_Timer_ISR+0x33a>
    6ec2:	ed 59       	subi	r30, 0x9D	; 157
    6ec4:	fd 4f       	sbci	r31, 0xFD	; 253
    6ec6:	22 81       	ldd	r18, Z+2	; 0x02
    6ec8:	33 81       	ldd	r19, Z+3	; 0x03
		Reg = MB_SingleQuery[MB_N].Buf;
    6eca:	66 81       	ldd	r22, Z+6	; 0x06
    6ecc:	77 81       	ldd	r23, Z+7	; 0x07
    6ece:	17 c0       	rjmp	.+46     	; 0x6efe <MB_M_Timer_ISR+0x37e>
	}
	else {
		StartAddr = prw(&Query->StartAddr);
    6ed0:	fc 01       	movw	r30, r24
    6ed2:	31 96       	adiw	r30, 0x01	; 1
    6ed4:	25 91       	lpm	r18, Z+
    6ed6:	34 91       	lpm	r19, Z
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6ed8:	fe 01       	movw	r30, r28
    6eda:	54 e0       	ldi	r21, 0x04	; 4
    6edc:	ee 0f       	add	r30, r30
    6ede:	ff 1f       	adc	r31, r31
    6ee0:	5a 95       	dec	r21
    6ee2:	e1 f7       	brne	.-8      	; 0x6edc <MB_M_Timer_ISR+0x35c>
    6ee4:	e2 53       	subi	r30, 0x32	; 50
    6ee6:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ee8:	45 91       	lpm	r20, Z+
    6eea:	54 91       	lpm	r21, Z
    6eec:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6eee:	fc 01       	movw	r30, r24
    6ef0:	85 91       	lpm	r24, Z+
    6ef2:	94 91       	lpm	r25, Z
    6ef4:	bc 01       	movw	r22, r24
    6ef6:	66 0f       	add	r22, r22
    6ef8:	77 1f       	adc	r23, r23
    6efa:	64 0f       	add	r22, r20
    6efc:	75 1f       	adc	r23, r21
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6efe:	ce 01       	movw	r24, r28
    6f00:	87 52       	subi	r24, 0x27	; 39
    6f02:	97 4f       	sbci	r25, 0xF7	; 247
    6f04:	fc 01       	movw	r30, r24
    6f06:	80 81       	ld	r24, Z
    6f08:	88 30       	cpi	r24, 0x08	; 8
    6f0a:	09 f0       	breq	.+2      	; 0x6f0e <MB_M_Timer_ISR+0x38e>
    6f0c:	61 c0       	rjmp	.+194    	; 0x6fd0 <MB_M_Timer_ISR+0x450>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6f0e:	a8 5b       	subi	r26, 0xB8	; 184
    6f10:	b2 4f       	sbci	r27, 0xF2	; 242
    6f12:	12 96       	adiw	r26, 0x02	; 2
    6f14:	8c 91       	ld	r24, X
    6f16:	12 97       	sbiw	r26, 0x02	; 2
    6f18:	90 e0       	ldi	r25, 0x00	; 0
    6f1a:	98 2f       	mov	r25, r24
    6f1c:	88 27       	eor	r24, r24
    6f1e:	13 96       	adiw	r26, 0x03	; 3
    6f20:	4c 91       	ld	r20, X
    6f22:	13 97       	sbiw	r26, 0x03	; 3
    6f24:	84 2b       	or	r24, r20
    6f26:	82 17       	cp	r24, r18
    6f28:	93 07       	cpc	r25, r19
    6f2a:	09 f0       	breq	.+2      	; 0x6f2e <MB_M_Timer_ISR+0x3ae>
    6f2c:	51 c0       	rjmp	.+162    	; 0x6fd0 <MB_M_Timer_ISR+0x450>
    6f2e:	14 96       	adiw	r26, 0x04	; 4
    6f30:	8c 91       	ld	r24, X
    6f32:	14 97       	sbiw	r26, 0x04	; 4
    6f34:	90 e0       	ldi	r25, 0x00	; 0
    6f36:	98 2f       	mov	r25, r24
    6f38:	88 27       	eor	r24, r24
    6f3a:	15 96       	adiw	r26, 0x05	; 5
    6f3c:	2c 91       	ld	r18, X
    6f3e:	82 2b       	or	r24, r18
    6f40:	41 e0       	ldi	r20, 0x01	; 1
    6f42:	fb 01       	movw	r30, r22
    6f44:	20 81       	ld	r18, Z
    6f46:	31 81       	ldd	r19, Z+1	; 0x01
    6f48:	82 17       	cp	r24, r18
    6f4a:	93 07       	cpc	r25, r19
    6f4c:	09 f4       	brne	.+2      	; 0x6f50 <MB_M_Timer_ISR+0x3d0>
    6f4e:	40 e0       	ldi	r20, 0x00	; 0
    6f50:	84 2f       	mov	r24, r20
    6f52:	3f c0       	rjmp	.+126    	; 0x6fd2 <MB_M_Timer_ISR+0x452>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6f54:	20 91 62 02 	lds	r18, 0x0262
    6f58:	22 23       	and	r18, r18
    6f5a:	69 f0       	breq	.+26     	; 0x6f76 <MB_M_Timer_ISR+0x3f6>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6f5c:	fe 01       	movw	r30, r28
    6f5e:	83 e0       	ldi	r24, 0x03	; 3
    6f60:	ee 0f       	add	r30, r30
    6f62:	ff 1f       	adc	r31, r31
    6f64:	8a 95       	dec	r24
    6f66:	e1 f7       	brne	.-8      	; 0x6f60 <MB_M_Timer_ISR+0x3e0>
    6f68:	ed 59       	subi	r30, 0x9D	; 157
    6f6a:	fd 4f       	sbci	r31, 0xFD	; 253
    6f6c:	22 81       	ldd	r18, Z+2	; 0x02
    6f6e:	33 81       	ldd	r19, Z+3	; 0x03
		Qt				= MB_SingleQuery[MB_N].Qt;
    6f70:	44 81       	ldd	r20, Z+4	; 0x04
    6f72:	55 81       	ldd	r21, Z+5	; 0x05
    6f74:	08 c0       	rjmp	.+16     	; 0x6f86 <MB_M_Timer_ISR+0x406>
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
    6f76:	fc 01       	movw	r30, r24
    6f78:	31 96       	adiw	r30, 0x01	; 1
    6f7a:	25 91       	lpm	r18, Z+
    6f7c:	34 91       	lpm	r19, Z
		Qt				= prw(&Query->Qt);
    6f7e:	03 96       	adiw	r24, 0x03	; 3
    6f80:	fc 01       	movw	r30, r24
    6f82:	45 91       	lpm	r20, Z+
    6f84:	54 91       	lpm	r21, Z
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6f86:	fe 01       	movw	r30, r28
    6f88:	e7 52       	subi	r30, 0x27	; 39
    6f8a:	f7 4f       	sbci	r31, 0xF7	; 247
    6f8c:	80 81       	ld	r24, Z
    6f8e:	88 30       	cpi	r24, 0x08	; 8
    6f90:	f9 f4       	brne	.+62     	; 0x6fd0 <MB_M_Timer_ISR+0x450>
    6f92:	a8 5b       	subi	r26, 0xB8	; 184
    6f94:	b2 4f       	sbci	r27, 0xF2	; 242
    6f96:	12 96       	adiw	r26, 0x02	; 2
    6f98:	8c 91       	ld	r24, X
    6f9a:	12 97       	sbiw	r26, 0x02	; 2
    6f9c:	90 e0       	ldi	r25, 0x00	; 0
    6f9e:	98 2f       	mov	r25, r24
    6fa0:	88 27       	eor	r24, r24
    6fa2:	13 96       	adiw	r26, 0x03	; 3
    6fa4:	6c 91       	ld	r22, X
    6fa6:	13 97       	sbiw	r26, 0x03	; 3
    6fa8:	86 2b       	or	r24, r22
    6faa:	82 17       	cp	r24, r18
    6fac:	93 07       	cpc	r25, r19
    6fae:	81 f4       	brne	.+32     	; 0x6fd0 <MB_M_Timer_ISR+0x450>
    6fb0:	14 96       	adiw	r26, 0x04	; 4
    6fb2:	8c 91       	ld	r24, X
    6fb4:	14 97       	sbiw	r26, 0x04	; 4
    6fb6:	90 e0       	ldi	r25, 0x00	; 0
    6fb8:	98 2f       	mov	r25, r24
    6fba:	88 27       	eor	r24, r24
    6fbc:	15 96       	adiw	r26, 0x05	; 5
    6fbe:	2c 91       	ld	r18, X
    6fc0:	82 2b       	or	r24, r18
    6fc2:	21 e0       	ldi	r18, 0x01	; 1
    6fc4:	84 17       	cp	r24, r20
    6fc6:	95 07       	cpc	r25, r21
    6fc8:	09 f4       	brne	.+2      	; 0x6fcc <MB_M_Timer_ISR+0x44c>
    6fca:	20 e0       	ldi	r18, 0x00	; 0
    6fcc:	82 2f       	mov	r24, r18
    6fce:	01 c0       	rjmp	.+2      	; 0x6fd2 <MB_M_Timer_ISR+0x452>
    6fd0:	81 e0       	ldi	r24, 0x01	; 1
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    6fd2:	88 23       	and	r24, r24
    6fd4:	89 f0       	breq	.+34     	; 0x6ff8 <MB_M_Timer_ISR+0x478>
				MB_CPT[MB_N][2]++;
    6fd6:	fe 01       	movw	r30, r28
    6fd8:	54 e0       	ldi	r21, 0x04	; 4
    6fda:	ee 0f       	add	r30, r30
    6fdc:	ff 1f       	adc	r31, r31
    6fde:	5a 95       	dec	r21
    6fe0:	e1 f7       	brne	.-8      	; 0x6fda <MB_M_Timer_ISR+0x45a>
    6fe2:	e7 5d       	subi	r30, 0xD7	; 215
    6fe4:	f4 4f       	sbci	r31, 0xF4	; 244
    6fe6:	84 81       	ldd	r24, Z+4	; 0x04
    6fe8:	95 81       	ldd	r25, Z+5	; 0x05
    6fea:	01 96       	adiw	r24, 0x01	; 1
    6fec:	95 83       	std	Z+5, r25	; 0x05
    6fee:	84 83       	std	Z+4, r24	; 0x04
				Over = FailSlave(MB_N);
    6ff0:	8d 2d       	mov	r24, r13
    6ff2:	0e 94 a5 2b 	call	0x574a	; 0x574a <FailSlave>
    6ff6:	45 c0       	rjmp	.+138    	; 0x7082 <MB_M_Timer_ISR+0x502>
			}
			else if (LastProcSingle)
    6ff8:	80 91 62 02 	lds	r24, 0x0262
    6ffc:	88 23       	and	r24, r24
    6ffe:	19 f0       	breq	.+6      	; 0x7006 <MB_M_Timer_ISR+0x486>
				MB_SingleState[MB_N] = MB_SingleIdle;
    7000:	f7 01       	movw	r30, r14
    7002:	10 82       	st	Z, r1
    7004:	47 c0       	rjmp	.+142    	; 0x7094 <MB_M_Timer_ISR+0x514>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    7006:	7e 01       	movw	r14, r28
    7008:	ee 0c       	add	r14, r14
    700a:	ff 1c       	adc	r15, r15
    700c:	ee 0c       	add	r14, r14
    700e:	ff 1c       	adc	r15, r15
    7010:	97 01       	movw	r18, r14
    7012:	2c 5e       	subi	r18, 0xEC	; 236
    7014:	34 4f       	sbci	r19, 0xF4	; 244
    7016:	79 01       	movw	r14, r18
    7018:	81 e0       	ldi	r24, 0x01	; 1
    701a:	90 e0       	ldi	r25, 0x00	; 0
    701c:	a0 e0       	ldi	r26, 0x00	; 0
    701e:	b0 e0       	ldi	r27, 0x00	; 0
    7020:	9e 01       	movw	r18, r28
    7022:	2a 5f       	subi	r18, 0xFA	; 250
    7024:	39 4f       	sbci	r19, 0xF9	; 249
    7026:	f9 01       	movw	r30, r18
    7028:	00 80       	ld	r0, Z
    702a:	04 c0       	rjmp	.+8      	; 0x7034 <MB_M_Timer_ISR+0x4b4>
    702c:	88 0f       	add	r24, r24
    702e:	99 1f       	adc	r25, r25
    7030:	aa 1f       	adc	r26, r26
    7032:	bb 1f       	adc	r27, r27
    7034:	0a 94       	dec	r0
    7036:	d2 f7       	brpl	.-12     	; 0x702c <MB_M_Timer_ISR+0x4ac>
    7038:	80 95       	com	r24
    703a:	90 95       	com	r25
    703c:	a0 95       	com	r26
    703e:	b0 95       	com	r27
    7040:	f7 01       	movw	r30, r14
    7042:	40 81       	ld	r20, Z
    7044:	51 81       	ldd	r21, Z+1	; 0x01
    7046:	62 81       	ldd	r22, Z+2	; 0x02
    7048:	73 81       	ldd	r23, Z+3	; 0x03
    704a:	84 23       	and	r24, r20
    704c:	95 23       	and	r25, r21
    704e:	a6 23       	and	r26, r22
    7050:	b7 23       	and	r27, r23
    7052:	80 83       	st	Z, r24
    7054:	91 83       	std	Z+1, r25	; 0x01
    7056:	a2 83       	std	Z+2, r26	; 0x02
    7058:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    705a:	fe 01       	movw	r30, r28
    705c:	e3 5f       	subi	r30, 0xF3	; 243
    705e:	f9 4f       	sbci	r31, 0xF9	; 249
    7060:	80 81       	ld	r24, Z
    7062:	8f 5f       	subi	r24, 0xFF	; 255
    7064:	80 83       	st	Z, r24
    7066:	f8 01       	movw	r30, r16
    7068:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    706a:	04 91       	lpm	r16, Z
    706c:	80 13       	cpse	r24, r16
    706e:	04 c0       	rjmp	.+8      	; 0x7078 <MB_M_Timer_ISR+0x4f8>
					Over = NextSlave(MB_N);
    7070:	8d 2d       	mov	r24, r13
    7072:	0e 94 13 2b 	call	0x5626	; 0x5626 <NextSlave>
    7076:	01 c0       	rjmp	.+2      	; 0x707a <MB_M_Timer_ISR+0x4fa>

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
    7078:	80 e0       	ldi	r24, 0x00	; 0
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    707a:	fe 01       	movw	r30, r28
    707c:	ef 59       	subi	r30, 0x9F	; 159
    707e:	fd 4f       	sbci	r31, 0xFD	; 253
    7080:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    7082:	88 23       	and	r24, r24
    7084:	39 f0       	breq	.+14     	; 0x7094 <MB_M_Timer_ISR+0x514>
    7086:	cc 0f       	add	r28, r28
    7088:	dd 1f       	adc	r29, r29
    708a:	c0 5e       	subi	r28, 0xE0	; 224
    708c:	d9 4f       	sbci	r29, 0xF9	; 249
    708e:	68 81       	ld	r22, Y
    7090:	79 81       	ldd	r23, Y+1	; 0x01
    7092:	02 c0       	rjmp	.+4      	; 0x7098 <MB_M_Timer_ISR+0x518>
    7094:	65 e0       	ldi	r22, 0x05	; 5
    7096:	70 e0       	ldi	r23, 0x00	; 0
    7098:	80 91 5c 02 	lds	r24, 0x025C
    709c:	8d 0d       	add	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    709e:	df 91       	pop	r29
    70a0:	cf 91       	pop	r28
    70a2:	1f 91       	pop	r17
    70a4:	0f 91       	pop	r16
    70a6:	ff 90       	pop	r15
    70a8:	ef 90       	pop	r14
    70aa:	df 90       	pop	r13
    70ac:	cf 90       	pop	r12
    70ae:	bf 90       	pop	r11
    70b0:	af 90       	pop	r10
    70b2:	9f 90       	pop	r9
    70b4:	8f 90       	pop	r8
    70b6:	7f 90       	pop	r7
    70b8:	5f 90       	pop	r5
    70ba:	4f 90       	pop	r4
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    70bc:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    70c0:	df 91       	pop	r29
    70c2:	cf 91       	pop	r28
    70c4:	1f 91       	pop	r17
    70c6:	0f 91       	pop	r16
    70c8:	ff 90       	pop	r15
    70ca:	ef 90       	pop	r14
    70cc:	df 90       	pop	r13
    70ce:	cf 90       	pop	r12
    70d0:	bf 90       	pop	r11
    70d2:	af 90       	pop	r10
    70d4:	9f 90       	pop	r9
    70d6:	8f 90       	pop	r8
    70d8:	7f 90       	pop	r7
    70da:	5f 90       	pop	r5
    70dc:	4f 90       	pop	r4
    70de:	08 95       	ret

000070e0 <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    70e0:	e8 2f       	mov	r30, r24
    70e2:	f0 e0       	ldi	r31, 0x00	; 0
    70e4:	ee 5e       	subi	r30, 0xEE	; 238
    70e6:	f4 4f       	sbci	r31, 0xF4	; 244
    70e8:	60 81       	ld	r22, Z
    70ea:	70 e0       	ldi	r23, 0x00	; 0
    70ec:	90 91 5c 02 	lds	r25, 0x025C
    70f0:	89 0f       	add	r24, r25
    70f2:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>

000070f6 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    70f6:	bf 92       	push	r11
    70f8:	cf 92       	push	r12
    70fa:	df 92       	push	r13
    70fc:	ef 92       	push	r14
    70fe:	ff 92       	push	r15
    7100:	0f 93       	push	r16
    7102:	1f 93       	push	r17
    7104:	cf 93       	push	r28
    7106:	df 93       	push	r29
    7108:	1f 92       	push	r1
    710a:	cd b7       	in	r28, 0x3d	; 61
    710c:	de b7       	in	r29, 0x3e	; 62
    710e:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7110:	80 e0       	ldi	r24, 0x00	; 0
    7112:	94 e1       	ldi	r25, 0x14	; 20
    7114:	c8 2e       	mov	r12, r24
    7116:	d1 2c       	mov	r13, r1
    7118:	9c 9d       	mul	r25, r12
    711a:	f0 01       	movw	r30, r0
    711c:	9d 9d       	mul	r25, r13
    711e:	f0 0d       	add	r31, r0
    7120:	11 24       	eor	r1, r1
    7122:	e9 56       	subi	r30, 0x69	; 105
    7124:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7126:	25 91       	lpm	r18, Z+
    7128:	34 91       	lpm	r19, Z
    712a:	e8 2e       	mov	r14, r24
    712c:	f1 2c       	mov	r15, r1
    712e:	a2 17       	cp	r26, r18
    7130:	b3 07       	cpc	r27, r19
    7132:	11 f0       	breq	.+4      	; 0x7138 <Modbus_TX+0x42>
    7134:	8f 5f       	subi	r24, 0xFF	; 255
    7136:	ee cf       	rjmp	.-36     	; 0x7114 <Modbus_TX+0x1e>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    7138:	86 01       	movw	r16, r12
    713a:	0c 5b       	subi	r16, 0xBC	; 188
    713c:	1d 4f       	sbci	r17, 0xFD	; 253
    713e:	f8 01       	movw	r30, r16
    7140:	90 81       	ld	r25, Z
    7142:	69 2f       	mov	r22, r25
    7144:	70 e0       	ldi	r23, 0x00	; 0
    7146:	a6 01       	movw	r20, r12
    7148:	47 52       	subi	r20, 0x27	; 39
    714a:	57 4f       	sbci	r21, 0xF7	; 247
    714c:	fa 01       	movw	r30, r20
    714e:	20 81       	ld	r18, Z
    7150:	30 e0       	ldi	r19, 0x00	; 0
    7152:	22 50       	subi	r18, 0x02	; 2
    7154:	31 09       	sbc	r19, r1
    7156:	62 17       	cp	r22, r18
    7158:	73 07       	cpc	r23, r19
    715a:	39 f5       	brne	.+78     	; 0x71aa <Modbus_TX+0xb4>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    715c:	64 e1       	ldi	r22, 0x14	; 20
    715e:	6c 9d       	mul	r22, r12
    7160:	90 01       	movw	r18, r0
    7162:	6d 9d       	mul	r22, r13
    7164:	30 0d       	add	r19, r0
    7166:	11 24       	eor	r1, r1
    7168:	25 56       	subi	r18, 0x65	; 101
    716a:	30 4b       	sbci	r19, 0xB0	; 176
    716c:	f9 01       	movw	r30, r18
    716e:	65 91       	lpm	r22, Z+
    7170:	74 91       	lpm	r23, Z
    7172:	fb 01       	movw	r30, r22
    7174:	b0 80       	ld	r11, Z
    7176:	fb 2d       	mov	r31, r11
    7178:	ff 7d       	andi	r31, 0xDF	; 223
    717a:	bf 2e       	mov	r11, r31
    717c:	fb 01       	movw	r30, r22
    717e:	b0 82       	st	Z, r11
    7180:	f9 01       	movw	r30, r18
    7182:	25 91       	lpm	r18, Z+
    7184:	34 91       	lpm	r19, Z
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7186:	f9 01       	movw	r30, r18
    7188:	60 81       	ld	r22, Z
    718a:	60 64       	ori	r22, 0x40	; 64
    718c:	60 83       	st	Z, r22
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    718e:	24 e1       	ldi	r18, 0x14	; 20
    7190:	2c 9d       	mul	r18, r12
    7192:	f0 01       	movw	r30, r0
    7194:	2d 9d       	mul	r18, r13
    7196:	f0 0d       	add	r31, r0
    7198:	11 24       	eor	r1, r1
    719a:	e7 56       	subi	r30, 0x67	; 103
    719c:	f0 4b       	sbci	r31, 0xB0	; 176
    719e:	25 91       	lpm	r18, Z+
    71a0:	34 91       	lpm	r19, Z
    71a2:	f9 01       	movw	r30, r18
    71a4:	60 81       	ld	r22, Z
    71a6:	60 64       	ori	r22, 0x40	; 64
    71a8:	60 83       	st	Z, r22
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    71aa:	9f 5f       	subi	r25, 0xFF	; 255
    71ac:	f8 01       	movw	r30, r16
    71ae:	90 83       	st	Z, r25
    71b0:	fa 01       	movw	r30, r20
    71b2:	20 81       	ld	r18, Z
    71b4:	92 17       	cp	r25, r18
    71b6:	48 f4       	brcc	.+18     	; 0x71ca <Modbus_TX+0xd4>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    71b8:	fc 2d       	mov	r31, r12
    71ba:	ee 27       	eor	r30, r30
    71bc:	e9 0f       	add	r30, r25
    71be:	f1 1d       	adc	r31, r1
    71c0:	e8 5b       	subi	r30, 0xB8	; 184
    71c2:	f2 4f       	sbci	r31, 0xF2	; 242
    71c4:	80 81       	ld	r24, Z
    71c6:	8c 93       	st	X, r24
		return;
    71c8:	43 c0       	rjmp	.+134    	; 0x7250 <Modbus_TX+0x15a>
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    71ca:	94 e1       	ldi	r25, 0x14	; 20
    71cc:	9c 9d       	mul	r25, r12
    71ce:	f0 01       	movw	r30, r0
    71d0:	9d 9d       	mul	r25, r13
    71d2:	f0 0d       	add	r31, r0
    71d4:	11 24       	eor	r1, r1
    71d6:	e5 56       	subi	r30, 0x65	; 101
    71d8:	f0 4b       	sbci	r31, 0xB0	; 176
    71da:	a5 91       	lpm	r26, Z+
    71dc:	b4 91       	lpm	r27, Z
    71de:	9c 91       	ld	r25, X
    71e0:	9f 79       	andi	r25, 0x9F	; 159
    71e2:	9c 93       	st	X, r25
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    71e4:	94 e1       	ldi	r25, 0x14	; 20
    71e6:	9c 9d       	mul	r25, r12
    71e8:	90 01       	movw	r18, r0
    71ea:	9d 9d       	mul	r25, r13
    71ec:	30 0d       	add	r19, r0
    71ee:	11 24       	eor	r1, r1
    71f0:	2d 55       	subi	r18, 0x5D	; 93
    71f2:	30 4b       	sbci	r19, 0xB0	; 176
    71f4:	f9 01       	movw	r30, r18
    71f6:	45 91       	lpm	r20, Z+
    71f8:	54 91       	lpm	r21, Z
    71fa:	89 83       	std	Y+1, r24	; 0x01
    71fc:	fa 01       	movw	r30, r20
    71fe:	09 95       	icall
	Count[MB_N] = 0;
    7200:	d8 01       	movw	r26, r16
    7202:	1c 92       	st	X, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    7204:	f6 01       	movw	r30, r12
    7206:	ef 51       	subi	r30, 0x1F	; 31
    7208:	fc 4f       	sbci	r31, 0xFC	; 252
    720a:	91 e0       	ldi	r25, 0x01	; 1
    720c:	90 83       	st	Z, r25
	switch (prb(MB_Role+MB_N)) {
    720e:	f7 01       	movw	r30, r14
    7210:	ea 52       	subi	r30, 0x2A	; 42
    7212:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7214:	e4 91       	lpm	r30, Z
    7216:	89 81       	ldd	r24, Y+1	; 0x01
    7218:	ee 23       	and	r30, r30
    721a:	71 f0       	breq	.+28     	; 0x7238 <Modbus_TX+0x142>
    721c:	e1 30       	cpi	r30, 0x01	; 1
    721e:	c1 f4       	brne	.+48     	; 0x7250 <Modbus_TX+0x15a>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7220:	0f 90       	pop	r0
    7222:	df 91       	pop	r29
    7224:	cf 91       	pop	r28
    7226:	1f 91       	pop	r17
    7228:	0f 91       	pop	r16
    722a:	ff 90       	pop	r15
    722c:	ef 90       	pop	r14
    722e:	df 90       	pop	r13
    7230:	cf 90       	pop	r12
    7232:	bf 90       	pop	r11
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    7234:	0c 94 70 38 	jmp	0x70e0	; 0x70e0 <MB_M_Tx>
		break;
	}
}
    7238:	0f 90       	pop	r0
    723a:	df 91       	pop	r29
    723c:	cf 91       	pop	r28
    723e:	1f 91       	pop	r17
    7240:	0f 91       	pop	r16
    7242:	ff 90       	pop	r15
    7244:	ef 90       	pop	r14
    7246:	df 90       	pop	r13
    7248:	cf 90       	pop	r12
    724a:	bf 90       	pop	r11
	Count[MB_N] = 0;
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
    724c:	0c 94 3f 35 	jmp	0x6a7e	; 0x6a7e <MB_S_Tx>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7250:	0f 90       	pop	r0
    7252:	df 91       	pop	r29
    7254:	cf 91       	pop	r28
    7256:	1f 91       	pop	r17
    7258:	0f 91       	pop	r16
    725a:	ff 90       	pop	r15
    725c:	ef 90       	pop	r14
    725e:	df 90       	pop	r13
    7260:	cf 90       	pop	r12
    7262:	bf 90       	pop	r11
    7264:	08 95       	ret

00007266 <MB_M_Cycle>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    7266:	1f 93       	push	r17
    7268:	cf 93       	push	r28
    726a:	df 93       	push	r29
    726c:	18 2f       	mov	r17, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    726e:	c0 91 5c 02 	lds	r28, 0x025C
    7272:	c8 0f       	add	r28, r24
    7274:	81 e0       	ldi	r24, 0x01	; 1
    7276:	8c 0f       	add	r24, r28
    7278:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    727c:	88 23       	and	r24, r24
    727e:	19 f0       	breq	.+6      	; 0x7286 <MB_M_Cycle+0x20>
		SlavesOn(MB_N);
    7280:	81 2f       	mov	r24, r17
    7282:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <SlavesOn>

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    7286:	8c 2f       	mov	r24, r28
    7288:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    728c:	88 23       	and	r24, r24
    728e:	09 f4       	brne	.+2      	; 0x7292 <MB_M_Cycle+0x2c>
    7290:	4f c0       	rjmp	.+158    	; 0x7330 <MB_M_Cycle+0xca>
		cli();
    7292:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    7294:	c1 2f       	mov	r28, r17
    7296:	d0 e0       	ldi	r29, 0x00	; 0
    7298:	fe 01       	movw	r30, r28
    729a:	ef 51       	subi	r30, 0x1F	; 31
    729c:	fc 4f       	sbci	r31, 0xFC	; 252
    729e:	80 81       	ld	r24, Z
    72a0:	81 30       	cpi	r24, 0x01	; 1
    72a2:	11 f4       	brne	.+4      	; 0x72a8 <MB_M_Cycle+0x42>
    72a4:	85 e0       	ldi	r24, 0x05	; 5
    72a6:	80 83       	st	Z, r24
		sei();
    72a8:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    72aa:	80 81       	ld	r24, Z
    72ac:	84 30       	cpi	r24, 0x04	; 4
    72ae:	a1 f0       	breq	.+40     	; 0x72d8 <MB_M_Cycle+0x72>
    72b0:	85 30       	cpi	r24, 0x05	; 5
    72b2:	09 f0       	breq	.+2      	; 0x72b6 <MB_M_Cycle+0x50>
    72b4:	3d c0       	rjmp	.+122    	; 0x7330 <MB_M_Cycle+0xca>
	case MB_NoReply:
		FailSlave(MB_N);
    72b6:	81 2f       	mov	r24, r17
    72b8:	0e 94 a5 2b 	call	0x574a	; 0x574a <FailSlave>
		switch (MB_SingleState[MB_N]) {
    72bc:	fe 01       	movw	r30, r28
    72be:	ee 5d       	subi	r30, 0xDE	; 222
    72c0:	f9 4f       	sbci	r31, 0xF9	; 249
    72c2:	80 81       	ld	r24, Z
    72c4:	88 23       	and	r24, r24
    72c6:	09 f1       	breq	.+66     	; 0x730a <MB_M_Cycle+0xa4>
    72c8:	81 30       	cpi	r24, 0x01	; 1
    72ca:	31 f5       	brne	.+76     	; 0x7318 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    72cc:	cf 59       	subi	r28, 0x9F	; 159
    72ce:	dd 4f       	sbci	r29, 0xFD	; 253
    72d0:	88 81       	ld	r24, Y
    72d2:	81 11       	cpse	r24, r1
    72d4:	21 c0       	rjmp	.+66     	; 0x7318 <MB_M_Cycle+0xb2>
    72d6:	1d c0       	rjmp	.+58     	; 0x7312 <MB_M_Cycle+0xac>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    72d8:	f8 94       	cli
		USART_Func(MB_N, LED);
    72da:	84 e1       	ldi	r24, 0x14	; 20
    72dc:	8c 9f       	mul	r24, r28
    72de:	f0 01       	movw	r30, r0
    72e0:	8d 9f       	mul	r24, r29
    72e2:	f0 0d       	add	r31, r0
    72e4:	11 24       	eor	r1, r1
    72e6:	eb 55       	subi	r30, 0x5B	; 91
    72e8:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    72ea:	25 91       	lpm	r18, Z+
    72ec:	34 91       	lpm	r19, Z
    72ee:	f9 01       	movw	r30, r18
    72f0:	09 95       	icall
		sei();
    72f2:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    72f4:	ce 5d       	subi	r28, 0xDE	; 222
    72f6:	d9 4f       	sbci	r29, 0xF9	; 249
    72f8:	88 81       	ld	r24, Y
    72fa:	88 23       	and	r24, r24
    72fc:	31 f0       	breq	.+12     	; 0x730a <MB_M_Cycle+0xa4>
    72fe:	81 30       	cpi	r24, 0x01	; 1
    7300:	59 f4       	brne	.+22     	; 0x7318 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    7302:	80 91 62 02 	lds	r24, 0x0262
    7306:	88 23       	and	r24, r24
    7308:	21 f0       	breq	.+8      	; 0x7312 <MB_M_Cycle+0xac>
				FormQuery(MB_N);
    730a:	81 2f       	mov	r24, r17
    730c:	0e 94 d0 31 	call	0x63a0	; 0x63a0 <FormQuery>
    7310:	03 c0       	rjmp	.+6      	; 0x7318 <MB_M_Cycle+0xb2>
			else
				FormSingle(MB_N);
    7312:	81 2f       	mov	r24, r17
    7314:	0e 94 1a 32 	call	0x6434	; 0x6434 <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    7318:	80 91 5c 02 	lds	r24, 0x025C
    731c:	6f ef       	ldi	r22, 0xFF	; 255
    731e:	7f ef       	ldi	r23, 0xFF	; 255
    7320:	81 0f       	add	r24, r17
    7322:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
		cli();
    7326:	f8 94       	cli
		MB_Transm(MB_N);
    7328:	81 2f       	mov	r24, r17
    732a:	0e 94 c3 2f 	call	0x5f86	; 0x5f86 <MB_Transm>
		sei();
    732e:	78 94       	sei
		break;
	}
}
    7330:	df 91       	pop	r29
    7332:	cf 91       	pop	r28
    7334:	1f 91       	pop	r17
    7336:	08 95       	ret

00007338 <MB_Cycle>:
{
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    7338:	80 91 13 0b 	lds	r24, 0x0B13
    733c:	80 ff       	sbrs	r24, 0
    733e:	15 c0       	rjmp	.+42     	; 0x736a <MB_Cycle+0x32>
			cli();
    7340:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    7342:	80 91 13 0b 	lds	r24, 0x0B13
    7346:	8e 7f       	andi	r24, 0xFE	; 254
    7348:	80 93 13 0b 	sts	0x0B13, r24
			sei();
    734c:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    734e:	e6 ed       	ldi	r30, 0xD6	; 214
    7350:	ff e4       	ldi	r31, 0x4F	; 79
    7352:	e4 91       	lpm	r30, Z
			switch (prb(MB_Role+MB_N)) {
    7354:	ee 23       	and	r30, r30
    7356:	31 f0       	breq	.+12     	; 0x7364 <MB_Cycle+0x2c>
    7358:	e1 30       	cpi	r30, 0x01	; 1
    735a:	39 f4       	brne	.+14     	; 0x736a <MB_Cycle+0x32>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    735c:	80 e0       	ldi	r24, 0x00	; 0
    735e:	0e 94 c0 35 	call	0x6b80	; 0x6b80 <MB_M_Timer_ISR>
				break;
    7362:	03 c0       	rjmp	.+6      	; 0x736a <MB_Cycle+0x32>
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    7364:	80 e0       	ldi	r24, 0x00	; 0
    7366:	0e 94 58 32 	call	0x64b0	; 0x64b0 <MB_S_Timer_ISR>
    736a:	e6 ed       	ldi	r30, 0xD6	; 214
    736c:	ff e4       	ldi	r31, 0x4F	; 79
    736e:	e4 91       	lpm	r30, Z
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7370:	e1 30       	cpi	r30, 0x01	; 1
    7372:	19 f4       	brne	.+6      	; 0x737a <MB_Cycle+0x42>
			MB_M_Cycle(MB_N);
    7374:	80 e0       	ldi	r24, 0x00	; 0
    7376:	0c 94 33 39 	jmp	0x7266	; 0x7266 <MB_M_Cycle>
    737a:	08 95       	ret

0000737c <IP_compare_Const>:
	IP->IP1 = IP1;
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    737c:	0f 93       	push	r16
    737e:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7380:	80 81       	ld	r24, Z
    7382:	86 13       	cpse	r24, r22
    7384:	09 c0       	rjmp	.+18     	; 0x7398 <IP_compare_Const+0x1c>
    7386:	81 81       	ldd	r24, Z+1	; 0x01
    7388:	84 13       	cpse	r24, r20
    738a:	06 c0       	rjmp	.+12     	; 0x7398 <IP_compare_Const+0x1c>
    738c:	82 81       	ldd	r24, Z+2	; 0x02
    738e:	82 13       	cpse	r24, r18
    7390:	03 c0       	rjmp	.+6      	; 0x7398 <IP_compare_Const+0x1c>
    7392:	81 e0       	ldi	r24, 0x01	; 1
    7394:	93 81       	ldd	r25, Z+3	; 0x03
    7396:	90 13       	cpse	r25, r16
	else return 0;
    7398:	80 e0       	ldi	r24, 0x00	; 0
}
    739a:	0f 91       	pop	r16
    739c:	08 95       	ret

0000739e <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    739e:	cf 92       	push	r12
    73a0:	df 92       	push	r13
    73a2:	ff 92       	push	r15
    73a4:	0f 93       	push	r16
    73a6:	1f 93       	push	r17
    73a8:	cf 93       	push	r28
    73aa:	df 93       	push	r29
    73ac:	1f 92       	push	r1
    73ae:	cd b7       	in	r28, 0x3d	; 61
    73b0:	de b7       	in	r29, 0x3e	; 62
    73b2:	6c 01       	movw	r12, r24
    73b4:	f4 2e       	mov	r15, r20
    73b6:	12 2f       	mov	r17, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    73b8:	69 83       	std	Y+1, r22	; 0x01
    73ba:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    73be:	69 81       	ldd	r22, Y+1	; 0x01
    73c0:	86 13       	cpse	r24, r22
    73c2:	12 c0       	rjmp	.+36     	; 0x73e8 <IP_E_compare_Const+0x4a>
    73c4:	c6 01       	movw	r24, r12
    73c6:	01 96       	adiw	r24, 0x01	; 1
    73c8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    73cc:	8f 11       	cpse	r24, r15
    73ce:	0c c0       	rjmp	.+24     	; 0x73e8 <IP_E_compare_Const+0x4a>
    73d0:	c6 01       	movw	r24, r12
    73d2:	02 96       	adiw	r24, 0x02	; 2
    73d4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    73d8:	81 13       	cpse	r24, r17
    73da:	06 c0       	rjmp	.+12     	; 0x73e8 <IP_E_compare_Const+0x4a>
    73dc:	c6 01       	movw	r24, r12
    73de:	03 96       	adiw	r24, 0x03	; 3
    73e0:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    73e4:	91 e0       	ldi	r25, 0x01	; 1
    73e6:	80 13       	cpse	r24, r16
	else return 0;
    73e8:	90 e0       	ldi	r25, 0x00	; 0
}
    73ea:	89 2f       	mov	r24, r25
    73ec:	0f 90       	pop	r0
    73ee:	df 91       	pop	r29
    73f0:	cf 91       	pop	r28
    73f2:	1f 91       	pop	r17
    73f4:	0f 91       	pop	r16
    73f6:	ff 90       	pop	r15
    73f8:	df 90       	pop	r13
    73fa:	cf 90       	pop	r12
    73fc:	08 95       	ret

000073fe <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    73fe:	8f ef       	ldi	r24, 0xFF	; 255
    7400:	80 93 7b 08 	sts	0x087B, r24
	GSM_RX_FIFO_End = 255;
    7404:	80 93 05 06 	sts	0x0605, r24
	GSM_RxCharN = 0;
    7408:	10 92 45 0d 	sts	0x0D45, r1
    740c:	08 95       	ret

0000740e <GetByteFromFIFO>:
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    740e:	fb 01       	movw	r30, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7410:	20 81       	ld	r18, Z
    7412:	24 17       	cp	r18, r20
    7414:	08 f0       	brcs	.+2      	; 0x7418 <GetByteFromFIFO+0xa>
		*Index = 0;
    7416:	10 82       	st	Z, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7418:	20 91 7b 08 	lds	r18, 0x087B
    741c:	a0 91 05 06 	lds	r26, 0x0605
    7420:	a2 17       	cp	r26, r18
    7422:	08 f5       	brcc	.+66     	; 0x7466 <GetByteFromFIFO+0x58>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    7424:	af 3f       	cpi	r26, 0xFF	; 255
    7426:	81 f0       	breq	.+32     	; 0x7448 <GetByteFromFIFO+0x3a>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7428:	40 91 0d 0b 	lds	r20, 0x0B0D
    742c:	20 91 7b 08 	lds	r18, 0x087B
    7430:	50 e0       	ldi	r21, 0x00	; 0
    7432:	30 e0       	ldi	r19, 0x00	; 0
    7434:	2a 1b       	sub	r18, r26
    7436:	31 09       	sbc	r19, r1
    7438:	42 17       	cp	r20, r18
    743a:	53 07       	cpc	r21, r19
    743c:	2c f4       	brge	.+10     	; 0x7448 <GetByteFromFIFO+0x3a>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    743e:	20 91 7b 08 	lds	r18, 0x087B
    7442:	2a 1b       	sub	r18, r26
    7444:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    7448:	af 5f       	subi	r26, 0xFF	; 255
    744a:	a0 93 05 06 	sts	0x0605, r26
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    744e:	b0 e0       	ldi	r27, 0x00	; 0
    7450:	a8 50       	subi	r26, 0x08	; 8
    7452:	bb 4f       	sbci	r27, 0xFB	; 251
    7454:	2c 91       	ld	r18, X
    7456:	30 81       	ld	r19, Z
    7458:	dc 01       	movw	r26, r24
    745a:	a3 0f       	add	r26, r19
    745c:	b1 1d       	adc	r27, r1
    745e:	2c 93       	st	X, r18
		*Index=*Index+1;
    7460:	20 81       	ld	r18, Z
    7462:	2f 5f       	subi	r18, 0xFF	; 255
    7464:	20 83       	st	Z, r18
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7466:	60 91 05 06 	lds	r22, 0x0605
    746a:	20 91 7b 08 	lds	r18, 0x087B
    746e:	26 17       	cp	r18, r22
    7470:	60 f5       	brcc	.+88     	; 0x74ca <GetByteFromFIFO+0xbc>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    7472:	6f 3f       	cpi	r22, 0xFF	; 255
    7474:	a1 f0       	breq	.+40     	; 0x749e <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7476:	40 91 0d 0b 	lds	r20, 0x0B0D
    747a:	70 91 7b 08 	lds	r23, 0x087B
    747e:	50 e0       	ldi	r21, 0x00	; 0
    7480:	2a ef       	ldi	r18, 0xFA	; 250
    7482:	30 e0       	ldi	r19, 0x00	; 0
    7484:	26 1b       	sub	r18, r22
    7486:	31 09       	sbc	r19, r1
    7488:	27 0f       	add	r18, r23
    748a:	31 1d       	adc	r19, r1
    748c:	42 17       	cp	r20, r18
    748e:	53 07       	cpc	r21, r19
    7490:	34 f4       	brge	.+12     	; 0x749e <GetByteFromFIFO+0x90>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    7492:	20 91 7b 08 	lds	r18, 0x087B
    7496:	26 50       	subi	r18, 0x06	; 6
    7498:	26 1b       	sub	r18, r22
    749a:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    749e:	6f 5f       	subi	r22, 0xFF	; 255
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    74a0:	6a 3f       	cpi	r22, 0xFA	; 250
    74a2:	18 f4       	brcc	.+6      	; 0x74aa <GetByteFromFIFO+0x9c>
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    74a4:	60 93 05 06 	sts	0x0605, r22
    74a8:	02 c0       	rjmp	.+4      	; 0x74ae <GetByteFromFIFO+0xa0>
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    74aa:	10 92 05 06 	sts	0x0605, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    74ae:	a0 91 05 06 	lds	r26, 0x0605
    74b2:	b0 e0       	ldi	r27, 0x00	; 0
    74b4:	a8 50       	subi	r26, 0x08	; 8
    74b6:	bb 4f       	sbci	r27, 0xFB	; 251
    74b8:	2c 91       	ld	r18, X
    74ba:	30 81       	ld	r19, Z
    74bc:	dc 01       	movw	r26, r24
    74be:	a3 0f       	add	r26, r19
    74c0:	b1 1d       	adc	r27, r1
    74c2:	2c 93       	st	X, r18
		*Index=*Index+1;
    74c4:	80 81       	ld	r24, Z
    74c6:	8f 5f       	subi	r24, 0xFF	; 255
    74c8:	80 83       	st	Z, r24
    74ca:	08 95       	ret

000074cc <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    74cc:	90 91 7b 08 	lds	r25, 0x087B
    74d0:	80 91 05 06 	lds	r24, 0x0605
    74d4:	98 17       	cp	r25, r24
    74d6:	39 f1       	breq	.+78     	; 0x7526 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    74d8:	44 e6       	ldi	r20, 0x64	; 100
    74da:	65 e4       	ldi	r22, 0x45	; 69
    74dc:	7d e0       	ldi	r23, 0x0D	; 13
    74de:	89 e8       	ldi	r24, 0x89	; 137
    74e0:	99 e0       	ldi	r25, 0x09	; 9
    74e2:	0e 94 07 3a 	call	0x740e	; 0x740e <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    74e6:	80 91 45 0d 	lds	r24, 0x0D45
    74ea:	82 30       	cpi	r24, 0x02	; 2
    74ec:	78 f3       	brcs	.-34     	; 0x74cc <GetStringFromFIFO>
    74ee:	e0 91 45 0d 	lds	r30, 0x0D45
    74f2:	f0 e0       	ldi	r31, 0x00	; 0
    74f4:	e9 57       	subi	r30, 0x79	; 121
    74f6:	f6 4f       	sbci	r31, 0xF6	; 246
    74f8:	80 81       	ld	r24, Z
    74fa:	8d 30       	cpi	r24, 0x0D	; 13
    74fc:	39 f7       	brne	.-50     	; 0x74cc <GetStringFromFIFO>
    74fe:	e0 91 45 0d 	lds	r30, 0x0D45
    7502:	f0 e0       	ldi	r31, 0x00	; 0
    7504:	e8 57       	subi	r30, 0x78	; 120
    7506:	f6 4f       	sbci	r31, 0xF6	; 246
    7508:	80 81       	ld	r24, Z
    750a:	8a 30       	cpi	r24, 0x0A	; 10
    750c:	f9 f6       	brne	.-66     	; 0x74cc <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    750e:	e0 91 45 0d 	lds	r30, 0x0D45
    7512:	f0 e0       	ldi	r31, 0x00	; 0
    7514:	e9 57       	subi	r30, 0x79	; 121
    7516:	f6 4f       	sbci	r31, 0xF6	; 246
    7518:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    751a:	80 91 45 0d 	lds	r24, 0x0D45
			GSM_RxCharN = 0;
    751e:	10 92 45 0d 	sts	0x0D45, r1
    7522:	81 50       	subi	r24, 0x01	; 1
    7524:	08 95       	ret
			return StrLength;
		}

	}//while

	return StrLength;
    7526:	80 e0       	ldi	r24, 0x00	; 0
}
    7528:	08 95       	ret

0000752a <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    752a:	80 91 45 0d 	lds	r24, 0x0D45
    752e:	84 36       	cpi	r24, 0x64	; 100
    7530:	18 f0       	brcs	.+6      	; 0x7538 <ForceEndStringFromFIFO+0xe>
    7532:	83 e6       	ldi	r24, 0x63	; 99
    7534:	80 93 45 0d 	sts	0x0D45, r24
	StrLength = GSM_RxCharN;
    7538:	80 91 45 0d 	lds	r24, 0x0D45
	GSM_RxStr[GSM_RxCharN]='\0';
    753c:	e0 91 45 0d 	lds	r30, 0x0D45
    7540:	f0 e0       	ldi	r31, 0x00	; 0
    7542:	e7 57       	subi	r30, 0x77	; 119
    7544:	f6 4f       	sbci	r31, 0xF6	; 246
    7546:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    7548:	10 92 45 0d 	sts	0x0D45, r1
	return StrLength;
}
    754c:	08 95       	ret

0000754e <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    754e:	cf 93       	push	r28
    7550:	c8 2f       	mov	r28, r24
	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7552:	90 91 7b 08 	lds	r25, 0x087B
    7556:	80 91 05 06 	lds	r24, 0x0605
    755a:	98 17       	cp	r25, r24
    755c:	79 f0       	breq	.+30     	; 0x757c <GetDataFromFIFO+0x2e>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    755e:	44 e6       	ldi	r20, 0x64	; 100
    7560:	65 e4       	ldi	r22, 0x45	; 69
    7562:	7d e0       	ldi	r23, 0x0D	; 13
    7564:	89 e8       	ldi	r24, 0x89	; 137
    7566:	99 e0       	ldi	r25, 0x09	; 9
    7568:	0e 94 07 3a 	call	0x740e	; 0x740e <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    756c:	80 91 45 0d 	lds	r24, 0x0D45
    7570:	8c 17       	cp	r24, r28
    7572:	78 f3       	brcs	.-34     	; 0x7552 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7574:	10 92 45 0d 	sts	0x0D45, r1
			return Amount;
    7578:	8c 2f       	mov	r24, r28
    757a:	02 c0       	rjmp	.+4      	; 0x7580 <GetDataFromFIFO+0x32>
		}
	}//while
	return GSM_RxCharN;
    757c:	80 91 45 0d 	lds	r24, 0x0D45
}
    7580:	cf 91       	pop	r28
    7582:	08 95       	ret

00007584 <strcpy_EE>:
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    7584:	df 92       	push	r13
    7586:	ef 92       	push	r14
    7588:	ff 92       	push	r15
    758a:	0f 93       	push	r16
    758c:	1f 93       	push	r17
    758e:	cf 93       	push	r28
    7590:	df 93       	push	r29
    7592:	8c 01       	movw	r16, r24
    7594:	7b 01       	movw	r14, r22
	uint8_t i=0;
    7596:	d1 2c       	mov	r13, r1
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    7598:	cd 2d       	mov	r28, r13
    759a:	d0 e0       	ldi	r29, 0x00	; 0
    759c:	c7 01       	movw	r24, r14
    759e:	8c 0f       	add	r24, r28
    75a0:	9d 1f       	adc	r25, r29
    75a2:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    75a6:	98 2f       	mov	r25, r24
    75a8:	9f 7d       	andi	r25, 0xDF	; 223
    75aa:	29 f0       	breq	.+10     	; 0x75b6 <strcpy_EE+0x32>
		str_RAM[i] = (char)erb(&str_EE[i]);
    75ac:	c0 0f       	add	r28, r16
    75ae:	d1 1f       	adc	r29, r17
    75b0:	88 83       	st	Y, r24
		i++;
    75b2:	d3 94       	inc	r13
    75b4:	f1 cf       	rjmp	.-30     	; 0x7598 <strcpy_EE+0x14>
	}
	return i;	
}
    75b6:	8d 2d       	mov	r24, r13
    75b8:	df 91       	pop	r29
    75ba:	cf 91       	pop	r28
    75bc:	1f 91       	pop	r17
    75be:	0f 91       	pop	r16
    75c0:	ff 90       	pop	r15
    75c2:	ef 90       	pop	r14
    75c4:	df 90       	pop	r13
    75c6:	08 95       	ret

000075c8 <GSM_Init>:
}
// ~~~~~~~~~~~
void
GSM_Init(void)
{	
	InitFIFO();
    75c8:	0e 94 ff 39 	call	0x73fe	; 0x73fe <InitFIFO>
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABl_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    75cc:	8c ef       	ldi	r24, 0xFC	; 252
    75ce:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    75d0:	88 e9       	ldi	r24, 0x98	; 152
    75d2:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    75d4:	86 e8       	ldi	r24, 0x86	; 134
    75d6:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    75da:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    75de:	87 e6       	ldi	r24, 0x67	; 103
    75e0:	89 b9       	out	0x09, r24	; 9
	#endif

	GSM_PWRCNTRL_Config();
    75e2:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <GSM_PWRCNTRL_Config>
	GSM_PWRCNTRL_ON();
    75e6:	0e 94 d2 2e 	call	0x5da4	; 0x5da4 <GSM_PWRCNTRL_ON>

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    75ea:	80 91 0e 01 	lds	r24, 0x010E
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    75ee:	80 93 5a 02 	sts	0x025A, r24
	VacantTimer16Sys += n;
    75f2:	91 e0       	ldi	r25, 0x01	; 1
    75f4:	98 0f       	add	r25, r24
	TD_TCP_Connect = Timer16SysAlloc(1);
    75f6:	90 93 59 02 	sts	0x0259, r25
    75fa:	92 e0       	ldi	r25, 0x02	; 2
    75fc:	98 0f       	add	r25, r24
	TD_RSSI = Timer16SysAlloc(1);
    75fe:	90 93 58 02 	sts	0x0258, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    7602:	90 91 0d 01 	lds	r25, 0x010D
	VacantTimer32Sys += n;
    7606:	21 e0       	ldi	r18, 0x01	; 1
    7608:	29 0f       	add	r18, r25
    760a:	20 93 0d 01 	sts	0x010D, r18
	TD_GSM_Reset = Timer32SysAlloc(1);
    760e:	90 93 57 02 	sts	0x0257, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    7612:	93 e0       	ldi	r25, 0x03	; 3
    7614:	98 0f       	add	r25, r24
	TCP_CONNECT_check_timer = Timer16SysAlloc(1);
    7616:	90 93 40 0d 	sts	0x0D40, r25
    761a:	95 e0       	ldi	r25, 0x05	; 5
    761c:	98 0f       	add	r25, r24
    761e:	90 93 0e 01 	sts	0x010E, r25
    7622:	8c 5f       	subi	r24, 0xFC	; 252
	GPRS_RECONNECT_timer = Timer16SysAlloc(1);
    7624:	80 93 0b 06 	sts	0x060B, r24
/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    7628:	10 92 7d 09 	sts	0x097D, r1
	GSM_State = GSM_PowerOn;
    762c:	10 92 27 06 	sts	0x0627, r1
    7630:	08 95       	ret

00007632 <GSM_Wait_Response>:
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    7632:	bc 01       	movw	r22, r24
    7634:	89 e8       	ldi	r24, 0x89	; 137
    7636:	99 e0       	ldi	r25, 0x09	; 9
    7638:	0e 94 30 6c 	call	0xd860	; 0xd860 <strcmp>
    763c:	21 e0       	ldi	r18, 0x01	; 1
    763e:	89 2b       	or	r24, r25
    7640:	09 f0       	breq	.+2      	; 0x7644 <GSM_Wait_Response+0x12>
    7642:	20 e0       	ldi	r18, 0x00	; 0
	else return 1;
}
    7644:	82 2f       	mov	r24, r18
    7646:	08 95       	ret

00007648 <GSM_Wait_Response_P>:
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    7648:	0f 93       	push	r16
    764a:	1f 93       	push	r17
    764c:	cf 93       	push	r28
    764e:	df 93       	push	r29
    7650:	1f 92       	push	r1
    7652:	cd b7       	in	r28, 0x3d	; 61
    7654:	de b7       	in	r29, 0x3e	; 62
    7656:	8c 01       	movw	r16, r24
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    7658:	80 91 5a 02 	lds	r24, 0x025A
    765c:	69 83       	std	Y+1, r22	; 0x01
    765e:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    7662:	69 81       	ldd	r22, Y+1	; 0x01
    7664:	88 23       	and	r24, r24
    7666:	29 f0       	breq	.+10     	; 0x7672 <GSM_Wait_Response_P+0x2a>
    7668:	66 23       	and	r22, r22
    766a:	19 f0       	breq	.+6      	; 0x7672 <GSM_Wait_Response_P+0x2a>
		GSM_State = RestoreCMD;
    766c:	60 93 27 06 	sts	0x0627, r22
    7670:	0c c0       	rjmp	.+24     	; 0x768a <GSM_Wait_Response_P+0x42>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    7672:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    7676:	88 23       	and	r24, r24
    7678:	41 f0       	breq	.+16     	; 0x768a <GSM_Wait_Response_P+0x42>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    767a:	b8 01       	movw	r22, r16
    767c:	89 e8       	ldi	r24, 0x89	; 137
    767e:	99 e0       	ldi	r25, 0x09	; 9
    7680:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    7684:	21 e0       	ldi	r18, 0x01	; 1
    7686:	89 2b       	or	r24, r25
    7688:	09 f0       	breq	.+2      	; 0x768c <GSM_Wait_Response_P+0x44>
		else return 1;
	}
	else return 0;
    768a:	20 e0       	ldi	r18, 0x00	; 0
}
    768c:	82 2f       	mov	r24, r18
    768e:	0f 90       	pop	r0
    7690:	df 91       	pop	r29
    7692:	cf 91       	pop	r28
    7694:	1f 91       	pop	r17
    7696:	0f 91       	pop	r16
    7698:	08 95       	ret

0000769a <GSM_Wait_Char>:
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    769a:	1f 93       	push	r17
    769c:	cf 93       	push	r28
    769e:	df 93       	push	r29
    76a0:	1f 92       	push	r1
    76a2:	cd b7       	in	r28, 0x3d	; 61
    76a4:	de b7       	in	r29, 0x3e	; 62
    76a6:	18 2f       	mov	r17, r24
	if(Timer16Stopp(TD_GSM)){
    76a8:	80 91 5a 02 	lds	r24, 0x025A
    76ac:	69 83       	std	Y+1, r22	; 0x01
    76ae:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    76b2:	69 81       	ldd	r22, Y+1	; 0x01
    76b4:	88 23       	and	r24, r24
    76b6:	19 f0       	breq	.+6      	; 0x76be <GSM_Wait_Char+0x24>
		GSM_State = RestoreCMD;
    76b8:	60 93 27 06 	sts	0x0627, r22
    76bc:	09 c0       	rjmp	.+18     	; 0x76d0 <GSM_Wait_Char+0x36>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    76be:	81 e0       	ldi	r24, 0x01	; 1
    76c0:	0e 94 a7 3a 	call	0x754e	; 0x754e <GetDataFromFIFO>
    76c4:	88 23       	and	r24, r24
    76c6:	21 f0       	breq	.+8      	; 0x76d0 <GSM_Wait_Char+0x36>
		if(GSM_RxStr[0] == Char)	return 1;
    76c8:	81 e0       	ldi	r24, 0x01	; 1
    76ca:	90 91 89 09 	lds	r25, 0x0989
    76ce:	91 13       	cpse	r25, r17
		else return 0;
	}
	else return 0;
    76d0:	80 e0       	ldi	r24, 0x00	; 0
}
    76d2:	0f 90       	pop	r0
    76d4:	df 91       	pop	r29
    76d6:	cf 91       	pop	r28
    76d8:	1f 91       	pop	r17
    76da:	08 95       	ret

000076dc <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    76dc:	80 91 76 0a 	lds	r24, 0x0A76
    76e0:	81 11       	cpse	r24, r1
    76e2:	05 c0       	rjmp	.+10     	; 0x76ee <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    76e4:	80 91 08 01 	lds	r24, 0x0108
    76e8:	81 60       	ori	r24, 0x01	; 1
    76ea:	80 93 08 01 	sts	0x0108, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    76ee:	88 e9       	ldi	r24, 0x98	; 152
    76f0:	8a b9       	out	0x0a, r24	; 10
    76f2:	08 95       	ret

000076f4 <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    76f4:	1f 92       	push	r1
    76f6:	0f 92       	push	r0
    76f8:	0f b6       	in	r0, 0x3f	; 63
    76fa:	0f 92       	push	r0
    76fc:	11 24       	eor	r1, r1
    76fe:	0b b6       	in	r0, 0x3b	; 59
    7700:	0f 92       	push	r0
    7702:	2f 93       	push	r18
    7704:	3f 93       	push	r19
    7706:	4f 93       	push	r20
    7708:	5f 93       	push	r21
    770a:	6f 93       	push	r22
    770c:	7f 93       	push	r23
    770e:	8f 93       	push	r24
    7710:	9f 93       	push	r25
    7712:	af 93       	push	r26
    7714:	bf 93       	push	r27
    7716:	ef 93       	push	r30
    7718:	ff 93       	push	r31
	GSM_TX();
    771a:	0e 94 6e 3b 	call	0x76dc	; 0x76dc <GSM_TX>
	GSM_LED = 1;
    771e:	81 e0       	ldi	r24, 0x01	; 1
    7720:	80 93 0a 06 	sts	0x060A, r24
}
    7724:	ff 91       	pop	r31
    7726:	ef 91       	pop	r30
    7728:	bf 91       	pop	r27
    772a:	af 91       	pop	r26
    772c:	9f 91       	pop	r25
    772e:	8f 91       	pop	r24
    7730:	7f 91       	pop	r23
    7732:	6f 91       	pop	r22
    7734:	5f 91       	pop	r21
    7736:	4f 91       	pop	r20
    7738:	3f 91       	pop	r19
    773a:	2f 91       	pop	r18
    773c:	0f 90       	pop	r0
    773e:	0b be       	out	0x3b, r0	; 59
    7740:	0f 90       	pop	r0
    7742:	0f be       	out	0x3f, r0	; 63
    7744:	0f 90       	pop	r0
    7746:	1f 90       	pop	r1
    7748:	18 95       	reti

0000774a <DI_State>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
    774a:	e8 2f       	mov	r30, r24
    774c:	e6 95       	lsr	r30
    774e:	e6 95       	lsr	r30
    7750:	e6 95       	lsr	r30
    7752:	f0 e0       	ldi	r31, 0x00	; 0
    7754:	ea 52       	subi	r30, 0x2A	; 42
    7756:	f7 4f       	sbci	r31, 0xF7	; 247
    7758:	20 81       	ld	r18, Z
    775a:	30 e0       	ldi	r19, 0x00	; 0
    775c:	87 70       	andi	r24, 0x07	; 7
    775e:	02 c0       	rjmp	.+4      	; 0x7764 <DI_State+0x1a>
    7760:	35 95       	asr	r19
    7762:	27 95       	ror	r18
    7764:	8a 95       	dec	r24
    7766:	e2 f7       	brpl	.-8      	; 0x7760 <DI_State+0x16>
}
    7768:	82 2f       	mov	r24, r18
    776a:	81 70       	andi	r24, 0x01	; 1
    776c:	08 95       	ret

0000776e <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
    776e:	e8 2f       	mov	r30, r24
    7770:	e6 95       	lsr	r30
    7772:	e6 95       	lsr	r30
    7774:	e6 95       	lsr	r30
    7776:	f0 e0       	ldi	r31, 0x00	; 0
    7778:	e8 52       	subi	r30, 0x28	; 40
    777a:	f7 4f       	sbci	r31, 0xF7	; 247
    777c:	20 81       	ld	r18, Z
    777e:	30 e0       	ldi	r19, 0x00	; 0
    7780:	87 70       	andi	r24, 0x07	; 7
    7782:	02 c0       	rjmp	.+4      	; 0x7788 <DI_Status+0x1a>
    7784:	35 95       	asr	r19
    7786:	27 95       	ror	r18
    7788:	8a 95       	dec	r24
    778a:	e2 f7       	brpl	.-8      	; 0x7784 <DI_Status+0x16>
}
    778c:	82 2f       	mov	r24, r18
    778e:	81 70       	andi	r24, 0x01	; 1
    7790:	08 95       	ret

00007792 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    7792:	ff 92       	push	r15
    7794:	0f 93       	push	r16
    7796:	1f 93       	push	r17
    7798:	cf 93       	push	r28
    779a:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    779c:	c0 91 d6 08 	lds	r28, 0x08D6
    77a0:	c0 93 d7 08 	sts	0x08D7, r28
    77a4:	8e e5       	ldi	r24, 0x5E	; 94
    77a6:	90 e0       	ldi	r25, 0x00	; 0
    77a8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    77ac:	8c 27       	eor	r24, r28
    77ae:	80 93 d8 08 	sts	0x08D8, r24
    77b2:	8d e1       	ldi	r24, 0x1D	; 29
    77b4:	9d e4       	ldi	r25, 0x4D	; 77
    77b6:	20 e0       	ldi	r18, 0x00	; 0
    77b8:	30 e0       	ldi	r19, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    77ba:	c1 e0       	ldi	r28, 0x01	; 1
    77bc:	d0 e0       	ldi	r29, 0x00	; 0
    77be:	ae 01       	movw	r20, r28
    77c0:	02 2e       	mov	r0, r18
    77c2:	01 c0       	rjmp	.+2      	; 0x77c6 <DigitIn+0x34>
    77c4:	44 0f       	add	r20, r20
    77c6:	0a 94       	dec	r0
    77c8:	ea f7       	brpl	.-6      	; 0x77c4 <DigitIn+0x32>
    77ca:	fc 01       	movw	r30, r24
    77cc:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77ce:	e4 91       	lpm	r30, Z
    77d0:	dc 01       	movw	r26, r24
    77d2:	12 96       	adiw	r26, 0x02	; 2
    77d4:	f0 90 d6 08 	lds	r15, 0x08D6
			if(prb(&DI_M[D_N].Inversion)){
    77d8:	ee 23       	and	r30, r30
    77da:	51 f0       	breq	.+20     	; 0x77f0 <DigitIn+0x5e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    77dc:	fc 01       	movw	r30, r24
    77de:	05 91       	lpm	r16, Z+
    77e0:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77e2:	fd 01       	movw	r30, r26
    77e4:	a4 91       	lpm	r26, Z
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    77e6:	f8 01       	movw	r30, r16
    77e8:	60 81       	ld	r22, Z
    77ea:	a6 23       	and	r26, r22
    77ec:	51 f0       	breq	.+20     	; 0x7802 <DigitIn+0x70>
    77ee:	0c c0       	rjmp	.+24     	; 0x7808 <DigitIn+0x76>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    77f0:	fc 01       	movw	r30, r24
    77f2:	05 91       	lpm	r16, Z+
    77f4:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77f6:	fd 01       	movw	r30, r26
    77f8:	a4 91       	lpm	r26, Z
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    77fa:	f8 01       	movw	r30, r16
    77fc:	60 81       	ld	r22, Z
    77fe:	a6 23       	and	r26, r22
    7800:	19 f0       	breq	.+6      	; 0x7808 <DigitIn+0x76>
					DigInput.State[Byte] &=~Bit;
    7802:	40 95       	com	r20
    7804:	4f 21       	and	r20, r15
    7806:	01 c0       	rjmp	.+2      	; 0x780a <DigitIn+0x78>
				else
					DigInput.State[Byte]  |=Bit;
    7808:	4f 29       	or	r20, r15
    780a:	40 93 d6 08 	sts	0x08D6, r20
    780e:	2f 5f       	subi	r18, 0xFF	; 255
    7810:	3f 4f       	sbci	r19, 0xFF	; 255
    7812:	08 96       	adiw	r24, 0x08	; 8
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7814:	24 30       	cpi	r18, 0x04	; 4
    7816:	31 05       	cpc	r19, r1
    7818:	09 f0       	breq	.+2      	; 0x781c <DigitIn+0x8a>
    781a:	d1 cf       	rjmp	.-94     	; 0x77be <DigitIn+0x2c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    781c:	df 91       	pop	r29
    781e:	cf 91       	pop	r28
    7820:	1f 91       	pop	r17
    7822:	0f 91       	pop	r16
    7824:	ff 90       	pop	r15
    7826:	08 95       	ret

00007828 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7828:	e8 2f       	mov	r30, r24
    782a:	e6 95       	lsr	r30
    782c:	e6 95       	lsr	r30
    782e:	e6 95       	lsr	r30
    7830:	f0 e0       	ldi	r31, 0x00	; 0
    7832:	eb 57       	subi	r30, 0x7B	; 123
    7834:	f6 4f       	sbci	r31, 0xF6	; 246
    7836:	87 70       	andi	r24, 0x07	; 7
    7838:	21 e0       	ldi	r18, 0x01	; 1
    783a:	30 e0       	ldi	r19, 0x00	; 0
    783c:	01 c0       	rjmp	.+2      	; 0x7840 <SetDigOut+0x18>
    783e:	22 0f       	add	r18, r18
    7840:	8a 95       	dec	r24
    7842:	ea f7       	brpl	.-6      	; 0x783e <SetDigOut+0x16>
    7844:	80 81       	ld	r24, Z
    7846:	82 2b       	or	r24, r18
    7848:	80 83       	st	Z, r24
    784a:	08 95       	ret

0000784c <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    784c:	e8 2f       	mov	r30, r24
    784e:	e6 95       	lsr	r30
    7850:	e6 95       	lsr	r30
    7852:	e6 95       	lsr	r30
    7854:	f0 e0       	ldi	r31, 0x00	; 0
    7856:	eb 57       	subi	r30, 0x7B	; 123
    7858:	f6 4f       	sbci	r31, 0xF6	; 246
    785a:	87 70       	andi	r24, 0x07	; 7
    785c:	21 e0       	ldi	r18, 0x01	; 1
    785e:	30 e0       	ldi	r19, 0x00	; 0
    7860:	01 c0       	rjmp	.+2      	; 0x7864 <ResDigOut+0x18>
    7862:	22 0f       	add	r18, r18
    7864:	8a 95       	dec	r24
    7866:	ea f7       	brpl	.-6      	; 0x7862 <ResDigOut+0x16>
    7868:	20 95       	com	r18
    786a:	80 81       	ld	r24, Z
    786c:	28 23       	and	r18, r24
    786e:	20 83       	st	Z, r18
    7870:	08 95       	ret

00007872 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7872:	80 91 83 09 	lds	r24, 0x0983
    7876:	80 93 84 09 	sts	0x0984, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    787a:	80 91 85 09 	lds	r24, 0x0985
    787e:	80 93 83 09 	sts	0x0983, r24
    7882:	8c e0       	ldi	r24, 0x0C	; 12
    7884:	9d e4       	ldi	r25, 0x4D	; 77
    7886:	20 e0       	ldi	r18, 0x00	; 0
    7888:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    788a:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    788c:	40 91 83 09 	lds	r20, 0x0983
    7890:	50 e0       	ldi	r21, 0x00	; 0
    7892:	02 2e       	mov	r0, r18
    7894:	02 c0       	rjmp	.+4      	; 0x789a <DigitOut+0x28>
    7896:	55 95       	asr	r21
    7898:	47 95       	ror	r20
    789a:	0a 94       	dec	r0
    789c:	e2 f7       	brpl	.-8      	; 0x7896 <DigitOut+0x24>
    789e:	bc 01       	movw	r22, r24
    78a0:	6e 5f       	subi	r22, 0xFE	; 254
    78a2:	7f 4f       	sbci	r23, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78a4:	fc 01       	movw	r30, r24
    78a6:	40 ff       	sbrs	r20, 0
    78a8:	07 c0       	rjmp	.+14     	; 0x78b8 <DigitOut+0x46>
    78aa:	a5 91       	lpm	r26, Z+
    78ac:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78ae:	fb 01       	movw	r30, r22
    78b0:	64 91       	lpm	r22, Z
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    78b2:	4c 91       	ld	r20, X
    78b4:	46 2b       	or	r20, r22
    78b6:	07 c0       	rjmp	.+14     	; 0x78c6 <DigitOut+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78b8:	a5 91       	lpm	r26, Z+
    78ba:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78bc:	fb 01       	movw	r30, r22
    78be:	64 91       	lpm	r22, Z
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    78c0:	60 95       	com	r22
    78c2:	4c 91       	ld	r20, X
    78c4:	46 23       	and	r20, r22
    78c6:	4c 93       	st	X, r20
		sei();
    78c8:	78 94       	sei
    78ca:	2f 5f       	subi	r18, 0xFF	; 255
    78cc:	3f 4f       	sbci	r19, 0xFF	; 255
    78ce:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    78d0:	23 30       	cpi	r18, 0x03	; 3
    78d2:	31 05       	cpc	r19, r1
    78d4:	d1 f6       	brne	.-76     	; 0x788a <DigitOut+0x18>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    78d6:	08 95       	ret

000078d8 <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    78d8:	8a e0       	ldi	r24, 0x0A	; 10
    78da:	9d e4       	ldi	r25, 0x4D	; 77
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    78dc:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78de:	fc 01       	movw	r30, r24
    78e0:	a5 91       	lpm	r26, Z+
    78e2:	b4 91       	lpm	r27, Z
    78e4:	fc 01       	movw	r30, r24
    78e6:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78e8:	e4 91       	lpm	r30, Z
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    78ea:	2c 91       	ld	r18, X
    78ec:	2e 2b       	or	r18, r30
    78ee:	2c 93       	st	X, r18
		sei();
    78f0:	78 94       	sei
    78f2:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    78f4:	2d e4       	ldi	r18, 0x4D	; 77
    78f6:	89 31       	cpi	r24, 0x19	; 25
    78f8:	92 07       	cpc	r25, r18
    78fa:	81 f7       	brne	.-32     	; 0x78dc <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    78fc:	0c 94 39 3c 	jmp	0x7872	; 0x7872 <DigitOut>

00007900 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    7900:	28 2f       	mov	r18, r24
	uint16_t Pow = 1;
    7902:	81 e0       	ldi	r24, 0x01	; 1
    7904:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
		Pow *= 10;
    7906:	3a e0       	ldi	r19, 0x0A	; 10
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    7908:	21 50       	subi	r18, 0x01	; 1
    790a:	38 f0       	brcs	.+14     	; 0x791a <Pow10+0x1a>
		Pow *= 10;
    790c:	ac 01       	movw	r20, r24
    790e:	34 9f       	mul	r19, r20
    7910:	c0 01       	movw	r24, r0
    7912:	35 9f       	mul	r19, r21
    7914:	90 0d       	add	r25, r0
    7916:	11 24       	eor	r1, r1
    7918:	f7 cf       	rjmp	.-18     	; 0x7908 <Pow10+0x8>
	return Pow;
}
    791a:	08 95       	ret

0000791c <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    791c:	e8 2f       	mov	r30, r24
	uint32_t Pow = 1;
    791e:	61 e0       	ldi	r22, 0x01	; 1
    7920:	70 e0       	ldi	r23, 0x00	; 0
    7922:	80 e0       	ldi	r24, 0x00	; 0
    7924:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
    7926:	e1 50       	subi	r30, 0x01	; 1
    7928:	38 f0       	brcs	.+14     	; 0x7938 <PowL10+0x1c>
		Pow *= 10;
    792a:	aa e0       	ldi	r26, 0x0A	; 10
    792c:	b0 e0       	ldi	r27, 0x00	; 0
    792e:	9b 01       	movw	r18, r22
    7930:	ac 01       	movw	r20, r24
    7932:	0e 94 14 75 	call	0xea28	; 0xea28 <__muluhisi3>
    7936:	f7 cf       	rjmp	.-18     	; 0x7926 <PowL10+0xa>
	return Pow;
}
    7938:	08 95       	ret

0000793a <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    793a:	ff 92       	push	r15
    793c:	0f 93       	push	r16
    793e:	1f 93       	push	r17
    7940:	cf 93       	push	r28
    7942:	df 93       	push	r29
    7944:	f8 2e       	mov	r15, r24
    7946:	c0 e0       	ldi	r28, 0x00	; 0
    7948:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    794a:	06 2f       	mov	r16, r22
    794c:	10 e0       	ldi	r17, 0x00	; 0

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    794e:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7950:	8f 2d       	mov	r24, r15
    7952:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <OW_MasterPullLowBus>
    7956:	8a e1       	ldi	r24, 0x1A	; 26
    7958:	8a 95       	dec	r24
    795a:	f1 f7       	brne	.-4      	; 0x7958 <OW_MasterTx_Command+0x1e>
    795c:	00 c0       	rjmp	.+0      	; 0x795e <OW_MasterTx_Command+0x24>
		_delay_us(5);
		if(Command & (1<<i)){
    795e:	98 01       	movw	r18, r16
    7960:	0c 2e       	mov	r0, r28
    7962:	02 c0       	rjmp	.+4      	; 0x7968 <OW_MasterTx_Command+0x2e>
    7964:	35 95       	asr	r19
    7966:	27 95       	ror	r18
    7968:	0a 94       	dec	r0
    796a:	e2 f7       	brpl	.-8      	; 0x7964 <OW_MasterTx_Command+0x2a>
    796c:	20 ff       	sbrs	r18, 0
    796e:	0a c0       	rjmp	.+20     	; 0x7984 <OW_MasterTx_Command+0x4a>
			OW_MasterReleaseBus(CH);
    7970:	8f 2d       	mov	r24, r15
    7972:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>
    7976:	83 e5       	ldi	r24, 0x53	; 83
    7978:	91 e0       	ldi	r25, 0x01	; 1
    797a:	01 97       	sbiw	r24, 0x01	; 1
    797c:	f1 f7       	brne	.-4      	; 0x797a <OW_MasterTx_Command+0x40>
    797e:	00 c0       	rjmp	.+0      	; 0x7980 <OW_MasterTx_Command+0x46>
    7980:	00 00       	nop
    7982:	07 c0       	rjmp	.+14     	; 0x7992 <OW_MasterTx_Command+0x58>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    7984:	85 e5       	ldi	r24, 0x55	; 85
    7986:	90 e0       	ldi	r25, 0x00	; 0
    7988:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>
			OW_MasterReleaseBus(CH);
    798c:	8f 2d       	mov	r24, r15
    798e:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>
		}
		sei();
    7992:	78 94       	sei
    7994:	9a e1       	ldi	r25, 0x1A	; 26
    7996:	9a 95       	dec	r25
    7998:	f1 f7       	brne	.-4      	; 0x7996 <OW_MasterTx_Command+0x5c>
    799a:	00 c0       	rjmp	.+0      	; 0x799c <OW_MasterTx_Command+0x62>
    799c:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    799e:	c8 30       	cpi	r28, 0x08	; 8
    79a0:	d1 05       	cpc	r29, r1
    79a2:	a9 f6       	brne	.-86     	; 0x794e <OW_MasterTx_Command+0x14>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    79a4:	df 91       	pop	r29
    79a6:	cf 91       	pop	r28
    79a8:	1f 91       	pop	r17
    79aa:	0f 91       	pop	r16
    79ac:	ff 90       	pop	r15
    79ae:	08 95       	ret

000079b0 <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    79b0:	ef 92       	push	r14
    79b2:	ff 92       	push	r15
    79b4:	0f 93       	push	r16
    79b6:	1f 93       	push	r17
    79b8:	cf 93       	push	r28
    79ba:	df 93       	push	r29
    79bc:	e8 2e       	mov	r14, r24
    79be:	c0 e0       	ldi	r28, 0x00	; 0
    79c0:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	uint8_t Data = 0;
    79c2:	f1 2c       	mov	r15, r1
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79c4:	01 e0       	ldi	r16, 0x01	; 1
    79c6:	10 e0       	ldi	r17, 0x00	; 0
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    79c8:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    79ca:	8e 2d       	mov	r24, r14
    79cc:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <OW_MasterPullLowBus>
    79d0:	8a e1       	ldi	r24, 0x1A	; 26
    79d2:	8a 95       	dec	r24
    79d4:	f1 f7       	brne	.-4      	; 0x79d2 <OW_MasterRx_Data+0x22>
    79d6:	00 c0       	rjmp	.+0      	; 0x79d8 <OW_MasterRx_Data+0x28>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    79d8:	8e 2d       	mov	r24, r14
    79da:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>
    79de:	9a e1       	ldi	r25, 0x1A	; 26
    79e0:	9a 95       	dec	r25
    79e2:	f1 f7       	brne	.-4      	; 0x79e0 <OW_MasterRx_Data+0x30>
    79e4:	00 c0       	rjmp	.+0      	; 0x79e6 <OW_MasterRx_Data+0x36>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    79e6:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79ea:	80 ff       	sbrs	r24, 0
    79ec:	07 c0       	rjmp	.+14     	; 0x79fc <OW_MasterRx_Data+0x4c>
    79ee:	98 01       	movw	r18, r16
    79f0:	0c 2e       	mov	r0, r28
    79f2:	01 c0       	rjmp	.+2      	; 0x79f6 <OW_MasterRx_Data+0x46>
    79f4:	22 0f       	add	r18, r18
    79f6:	0a 94       	dec	r0
    79f8:	ea f7       	brpl	.-6      	; 0x79f4 <OW_MasterRx_Data+0x44>
    79fa:	f2 2a       	or	r15, r18
		sei();
    79fc:	78 94       	sei
    79fe:	8f ee       	ldi	r24, 0xEF	; 239
    7a00:	90 e0       	ldi	r25, 0x00	; 0
    7a02:	01 97       	sbiw	r24, 0x01	; 1
    7a04:	f1 f7       	brne	.-4      	; 0x7a02 <OW_MasterRx_Data+0x52>
    7a06:	00 c0       	rjmp	.+0      	; 0x7a08 <OW_MasterRx_Data+0x58>
    7a08:	00 00       	nop
    7a0a:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    7a0c:	c8 30       	cpi	r28, 0x08	; 8
    7a0e:	d1 05       	cpc	r29, r1
    7a10:	d9 f6       	brne	.-74     	; 0x79c8 <OW_MasterRx_Data+0x18>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    7a12:	8f 2d       	mov	r24, r15
    7a14:	df 91       	pop	r29
    7a16:	cf 91       	pop	r28
    7a18:	1f 91       	pop	r17
    7a1a:	0f 91       	pop	r16
    7a1c:	ff 90       	pop	r15
    7a1e:	ef 90       	pop	r14
    7a20:	08 95       	ret

00007a22 <OneWire_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7a22:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    7a26:	91 e0       	ldi	r25, 0x01	; 1
    7a28:	98 0f       	add	r25, r24
    7a2a:	90 93 0f 01 	sts	0x010F, r25


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    7a2e:	80 93 6b 09 	sts	0x096B, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    7a32:	8a e0       	ldi	r24, 0x0A	; 10
    7a34:	80 93 f7 03 	sts	0x03F7, r24
    7a38:	08 95       	ret

00007a3a <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    7a3a:	ff 92       	push	r15
    7a3c:	0f 93       	push	r16
    7a3e:	1f 93       	push	r17
    7a40:	cf 93       	push	r28
    7a42:	df 93       	push	r29
    7a44:	f8 2e       	mov	r15, r24
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    7a46:	08 2f       	mov	r16, r24
    7a48:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7a4a:	c8 01       	movw	r24, r16
    7a4c:	83 5a       	subi	r24, 0xA3	; 163
    7a4e:	9f 4f       	sbci	r25, 0xFF	; 255
    7a50:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    7a54:	e8 01       	movw	r28, r16
    7a56:	cd 50       	subi	r28, 0x0D	; 13
    7a58:	d6 4f       	sbci	r29, 0xF6	; 246
    7a5a:	81 11       	cpse	r24, r1
    7a5c:	0c c0       	rjmp	.+24     	; 0x7a76 <OneWireStartADC+0x3c>
		Temperature[CH] = Therm_Off_Mark;
    7a5e:	f8 01       	movw	r30, r16
    7a60:	ee 0f       	add	r30, r30
    7a62:	ff 1f       	adc	r31, r31
    7a64:	ee 50       	subi	r30, 0x0E	; 14
    7a66:	fa 4f       	sbci	r31, 0xFA	; 250
    7a68:	80 e0       	ldi	r24, 0x00	; 0
    7a6a:	90 e8       	ldi	r25, 0x80	; 128
    7a6c:	91 83       	std	Z+1, r25	; 0x01
    7a6e:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    7a70:	82 e0       	ldi	r24, 0x02	; 2
    7a72:	88 83       	st	Y, r24
		return;
    7a74:	37 c0       	rjmp	.+110    	; 0x7ae4 <OneWireStartADC+0xaa>
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7a76:	f8 94       	cli
    7a78:	8f 2d       	mov	r24, r15
    7a7a:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <OW_MasterPullLowBus>
    7a7e:	78 94       	sei
	Delay_us(580);	
    7a80:	84 e4       	ldi	r24, 0x44	; 68
    7a82:	92 e0       	ldi	r25, 0x02	; 2
    7a84:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7a88:	f8 94       	cli
    7a8a:	8f 2d       	mov	r24, r15
    7a8c:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>
    7a90:	87 e1       	ldi	r24, 0x17	; 23
    7a92:	91 e0       	ldi	r25, 0x01	; 1
    7a94:	01 97       	sbiw	r24, 0x01	; 1
    7a96:	f1 f7       	brne	.-4      	; 0x7a94 <OneWireStartADC+0x5a>
    7a98:	00 c0       	rjmp	.+0      	; 0x7a9a <OneWireStartADC+0x60>
    7a9a:	00 00       	nop
    7a9c:	80 91 63 00 	lds	r24, 0x0063
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    7aa0:	80 fd       	sbrc	r24, 0
    7aa2:	03 c0       	rjmp	.+6      	; 0x7aaa <OneWireStartADC+0x70>
    7aa4:	81 e0       	ldi	r24, 0x01	; 1
    7aa6:	88 83       	st	Y, r24
    7aa8:	08 c0       	rjmp	.+16     	; 0x7aba <OneWireStartADC+0x80>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    7aaa:	82 e0       	ldi	r24, 0x02	; 2
    7aac:	88 83       	st	Y, r24
		DS18B20_Error[CH]++;
    7aae:	f8 01       	movw	r30, r16
    7ab0:	e9 50       	subi	r30, 0x09	; 9
    7ab2:	fc 4f       	sbci	r31, 0xFC	; 252
    7ab4:	80 81       	ld	r24, Z
    7ab6:	8f 5f       	subi	r24, 0xFF	; 255
    7ab8:	80 83       	st	Z, r24
	}
	sei();
    7aba:	78 94       	sei
	
	Delay_us(510);
    7abc:	8e ef       	ldi	r24, 0xFE	; 254
    7abe:	91 e0       	ldi	r25, 0x01	; 1
    7ac0:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7ac4:	88 81       	ld	r24, Y
    7ac6:	82 30       	cpi	r24, 0x02	; 2
    7ac8:	69 f0       	breq	.+26     	; 0x7ae4 <OneWireStartADC+0xaa>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7aca:	6c ec       	ldi	r22, 0xCC	; 204
    7acc:	8f 2d       	mov	r24, r15
    7ace:	0e 94 9d 3c 	call	0x793a	; 0x793a <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7ad2:	64 e4       	ldi	r22, 0x44	; 68
    7ad4:	8f 2d       	mov	r24, r15
	}
}
    7ad6:	df 91       	pop	r29
    7ad8:	cf 91       	pop	r28
    7ada:	1f 91       	pop	r17
    7adc:	0f 91       	pop	r16
    7ade:	ff 90       	pop	r15
	
	Delay_us(510);

	if(DS18B20_Status[CH] != DS18B20_ERROR){
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7ae0:	0c 94 9d 3c 	jmp	0x793a	; 0x793a <OW_MasterTx_Command>
	}
}
    7ae4:	df 91       	pop	r29
    7ae6:	cf 91       	pop	r28
    7ae8:	1f 91       	pop	r17
    7aea:	0f 91       	pop	r16
    7aec:	ff 90       	pop	r15
    7aee:	08 95       	ret

00007af0 <OneWireReadTemp>:
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    7af0:	8f 92       	push	r8
    7af2:	9f 92       	push	r9
    7af4:	af 92       	push	r10
    7af6:	bf 92       	push	r11
    7af8:	cf 92       	push	r12
    7afa:	df 92       	push	r13
    7afc:	ef 92       	push	r14
    7afe:	ff 92       	push	r15
    7b00:	1f 93       	push	r17
    7b02:	cf 93       	push	r28
    7b04:	df 93       	push	r29
    7b06:	18 2f       	mov	r17, r24
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    7b08:	c8 2f       	mov	r28, r24
    7b0a:	d0 e0       	ldi	r29, 0x00	; 0
    7b0c:	ce 01       	movw	r24, r28
    7b0e:	83 5a       	subi	r24, 0xA3	; 163
    7b10:	9f 4f       	sbci	r25, 0xFF	; 255
    7b12:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    7b16:	9e 01       	movw	r18, r28
    7b18:	2d 50       	subi	r18, 0x0D	; 13
    7b1a:	36 4f       	sbci	r19, 0xF6	; 246
    7b1c:	79 01       	movw	r14, r18
    7b1e:	fe 01       	movw	r30, r28
    7b20:	e9 50       	subi	r30, 0x09	; 9
    7b22:	fc 4f       	sbci	r31, 0xFC	; 252
    7b24:	81 11       	cpse	r24, r1
    7b26:	0c c0       	rjmp	.+24     	; 0x7b40 <OneWireReadTemp+0x50>
		Temperature[CH] = Therm_Off_Mark;
    7b28:	cc 0f       	add	r28, r28
    7b2a:	dd 1f       	adc	r29, r29
    7b2c:	ce 50       	subi	r28, 0x0E	; 14
    7b2e:	da 4f       	sbci	r29, 0xFA	; 250
    7b30:	80 e0       	ldi	r24, 0x00	; 0
    7b32:	90 e8       	ldi	r25, 0x80	; 128
    7b34:	99 83       	std	Y+1, r25	; 0x01
    7b36:	88 83       	st	Y, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    7b38:	d7 01       	movw	r26, r14
    7b3a:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    7b3c:	10 82       	st	Z, r1
		return;
    7b3e:	a0 c0       	rjmp	.+320    	; 0x7c80 <OneWireReadTemp+0x190>
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    7b40:	d9 01       	movw	r26, r18
    7b42:	8c 91       	ld	r24, X
    7b44:	82 30       	cpi	r24, 0x02	; 2
    7b46:	79 f4       	brne	.+30     	; 0x7b66 <OneWireReadTemp+0x76>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    7b48:	80 81       	ld	r24, Z
    7b4a:	8a 30       	cpi	r24, 0x0A	; 10
    7b4c:	48 f0       	brcs	.+18     	; 0x7b60 <OneWireReadTemp+0x70>
    7b4e:	cc 0f       	add	r28, r28
    7b50:	dd 1f       	adc	r29, r29
    7b52:	ce 50       	subi	r28, 0x0E	; 14
    7b54:	da 4f       	sbci	r29, 0xFA	; 250
    7b56:	81 e0       	ldi	r24, 0x01	; 1
    7b58:	90 e8       	ldi	r25, 0x80	; 128
    7b5a:	99 83       	std	Y+1, r25	; 0x01
    7b5c:	88 83       	st	Y, r24
    7b5e:	90 c0       	rjmp	.+288    	; 0x7c80 <OneWireReadTemp+0x190>
		else DS18B20_Error[CH]++;
    7b60:	8f 5f       	subi	r24, 0xFF	; 255
    7b62:	80 83       	st	Z, r24
    7b64:	8d c0       	rjmp	.+282    	; 0x7c80 <OneWireReadTemp+0x190>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    7b66:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7b68:	f8 94       	cli
    7b6a:	81 2f       	mov	r24, r17
    7b6c:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <OW_MasterPullLowBus>
    7b70:	78 94       	sei
	Delay_us(580);
    7b72:	84 e4       	ldi	r24, 0x44	; 68
    7b74:	92 e0       	ldi	r25, 0x02	; 2
    7b76:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7b7a:	f8 94       	cli
    7b7c:	81 2f       	mov	r24, r17
    7b7e:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    7b82:	86 e4       	ldi	r24, 0x46	; 70
    7b84:	90 e0       	ldi	r25, 0x00	; 0
    7b86:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>
    7b8a:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    7b8e:	80 ff       	sbrs	r24, 0
    7b90:	03 c0       	rjmp	.+6      	; 0x7b98 <OneWireReadTemp+0xa8>
    7b92:	82 e0       	ldi	r24, 0x02	; 2
    7b94:	f7 01       	movw	r30, r14
    7b96:	80 83       	st	Z, r24
	sei();
    7b98:	78 94       	sei
	Delay_us(510);
    7b9a:	8e ef       	ldi	r24, 0xFE	; 254
    7b9c:	91 e0       	ldi	r25, 0x01	; 1
    7b9e:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7ba2:	d7 01       	movw	r26, r14
    7ba4:	8c 91       	ld	r24, X
    7ba6:	82 30       	cpi	r24, 0x02	; 2
    7ba8:	09 f4       	brne	.+2      	; 0x7bac <OneWireReadTemp+0xbc>
    7baa:	6a c0       	rjmp	.+212    	; 0x7c80 <OneWireReadTemp+0x190>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7bac:	6c ec       	ldi	r22, 0xCC	; 204
    7bae:	81 2f       	mov	r24, r17
    7bb0:	0e 94 9d 3c 	call	0x793a	; 0x793a <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    7bb4:	6e eb       	ldi	r22, 0xBE	; 190
    7bb6:	81 2f       	mov	r24, r17
    7bb8:	0e 94 9d 3c 	call	0x793a	; 0x793a <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    7bbc:	81 2f       	mov	r24, r17
    7bbe:	0e 94 d8 3c 	call	0x79b0	; 0x79b0 <OW_MasterRx_Data>
    7bc2:	e8 2e       	mov	r14, r24
    7bc4:	f1 2c       	mov	r15, r1
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    7bc6:	81 2f       	mov	r24, r17
    7bc8:	0e 94 d8 3c 	call	0x79b0	; 0x79b0 <OW_MasterRx_Data>
    7bcc:	f8 2a       	or	r15, r24
		Tres = (Tres*10)/16;
    7bce:	8a e0       	ldi	r24, 0x0A	; 10
    7bd0:	8e 9d       	mul	r24, r14
    7bd2:	b0 01       	movw	r22, r0
    7bd4:	8f 9d       	mul	r24, r15
    7bd6:	70 0d       	add	r23, r0
    7bd8:	11 24       	eor	r1, r1
    7bda:	77 ff       	sbrs	r23, 7
    7bdc:	02 c0       	rjmp	.+4      	; 0x7be2 <OneWireReadTemp+0xf2>
    7bde:	61 5f       	subi	r22, 0xF1	; 241
    7be0:	7f 4f       	sbci	r23, 0xFF	; 255
    7be2:	4b 01       	movw	r8, r22
    7be4:	94 e0       	ldi	r25, 0x04	; 4
    7be6:	95 94       	asr	r9
    7be8:	87 94       	ror	r8
    7bea:	9a 95       	dec	r25
    7bec:	e1 f7       	brne	.-8      	; 0x7be6 <OneWireReadTemp+0xf6>
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    7bee:	b2 e5       	ldi	r27, 0x52	; 82
    7bf0:	8b 16       	cp	r8, r27
    7bf2:	b3 e0       	ldi	r27, 0x03	; 3
    7bf4:	9b 06       	cpc	r9, r27
    7bf6:	b1 f1       	breq	.+108    	; 0x7c64 <OneWireReadTemp+0x174>
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    7bf8:	7e 01       	movw	r14, r28
    7bfa:	ee 0c       	add	r14, r14
    7bfc:	ff 1c       	adc	r15, r15
    7bfe:	ce 0d       	add	r28, r14
    7c00:	df 1d       	adc	r29, r15
    7c02:	ce 01       	movw	r24, r28
    7c04:	86 5a       	subi	r24, 0xA6	; 166
    7c06:	9f 4f       	sbci	r25, 0xFF	; 255
    7c08:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    7c0c:	d8 2e       	mov	r13, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    7c0e:	ce 01       	movw	r24, r28
    7c10:	85 5a       	subi	r24, 0xA5	; 165
    7c12:	9f 4f       	sbci	r25, 0xFF	; 255
    7c14:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    7c18:	5c 01       	movw	r10, r24
    7c1a:	e7 01       	movw	r28, r14
    7c1c:	ce 50       	subi	r28, 0x0E	; 14
    7c1e:	da 4f       	sbci	r29, 0xFA	; 250
    7c20:	b4 01       	movw	r22, r8
    7c22:	6d 0d       	add	r22, r13
    7c24:	71 1d       	adc	r23, r1
    7c26:	d7 fc       	sbrc	r13, 7
    7c28:	7a 95       	dec	r23
    7c2a:	88 27       	eor	r24, r24
    7c2c:	77 fd       	sbrc	r23, 7
    7c2e:	80 95       	com	r24
    7c30:	98 2f       	mov	r25, r24
    7c32:	0e 94 8b 6d 	call	0xdb16	; 0xdb16 <__floatsisf>
    7c36:	6b 01       	movw	r12, r22
    7c38:	7c 01       	movw	r14, r24
    7c3a:	b5 01       	movw	r22, r10
    7c3c:	80 e0       	ldi	r24, 0x00	; 0
    7c3e:	90 e0       	ldi	r25, 0x00	; 0
    7c40:	0e 94 89 6d 	call	0xdb12	; 0xdb12 <__floatunsisf>
    7c44:	20 e0       	ldi	r18, 0x00	; 0
    7c46:	30 e0       	ldi	r19, 0x00	; 0
    7c48:	4a e7       	ldi	r20, 0x7A	; 122
    7c4a:	54 e4       	ldi	r21, 0x44	; 68
    7c4c:	0e 94 f0 6c 	call	0xd9e0	; 0xd9e0 <__divsf3>
    7c50:	9b 01       	movw	r18, r22
    7c52:	ac 01       	movw	r20, r24
    7c54:	c7 01       	movw	r24, r14
    7c56:	b6 01       	movw	r22, r12
    7c58:	0e 94 17 6e 	call	0xdc2e	; 0xdc2e <__mulsf3>
    7c5c:	0e 94 58 6d 	call	0xdab0	; 0xdab0 <__fixsfsi>
    7c60:	79 83       	std	Y+1, r23	; 0x01
    7c62:	68 83       	st	Y, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    7c64:	f8 94       	cli
    7c66:	81 2f       	mov	r24, r17
    7c68:	0e 94 b0 2e 	call	0x5d60	; 0x5d60 <OW_MasterPullLowBus>
    7c6c:	78 94       	sei
		Delay_us(580);	
    7c6e:	84 e4       	ldi	r24, 0x44	; 68
    7c70:	92 e0       	ldi	r25, 0x02	; 2
    7c72:	0e 94 95 2e 	call	0x5d2a	; 0x5d2a <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    7c76:	f8 94       	cli
    7c78:	81 2f       	mov	r24, r17
    7c7a:	0e 94 bd 2e 	call	0x5d7a	; 0x5d7a <OW_MasterReleaseBus>
    7c7e:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    7c80:	df 91       	pop	r29
    7c82:	cf 91       	pop	r28
    7c84:	1f 91       	pop	r17
    7c86:	ff 90       	pop	r15
    7c88:	ef 90       	pop	r14
    7c8a:	df 90       	pop	r13
    7c8c:	cf 90       	pop	r12
    7c8e:	bf 90       	pop	r11
    7c90:	af 90       	pop	r10
    7c92:	9f 90       	pop	r9
    7c94:	8f 90       	pop	r8
    7c96:	08 95       	ret

00007c98 <DS18B20>:
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    7c98:	80 91 6b 09 	lds	r24, 0x096B
    7c9c:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    7ca0:	88 23       	and	r24, r24
    7ca2:	11 f1       	breq	.+68     	; 0x7ce8 <DS18B20+0x50>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    7ca4:	80 91 56 02 	lds	r24, 0x0256
    7ca8:	87 30       	cpi	r24, 0x07	; 7
    7caa:	18 f0       	brcs	.+6      	; 0x7cb2 <DS18B20+0x1a>
    7cac:	81 e0       	ldi	r24, 0x01	; 1
    7cae:	80 93 56 02 	sts	0x0256, r24
		
			switch(DS18B20_Mode){
    7cb2:	80 91 56 02 	lds	r24, 0x0256
    7cb6:	81 30       	cpi	r24, 0x01	; 1
    7cb8:	39 f0       	breq	.+14     	; 0x7cc8 <DS18B20+0x30>
    7cba:	84 30       	cpi	r24, 0x04	; 4
    7cbc:	81 f4       	brne	.+32     	; 0x7cde <DS18B20+0x46>
				StartTimer8(TD_DS18B20Read, 100);
				DS18B20_Mode = DS18B20_START_ADC3;
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    7cbe:	80 e0       	ldi	r24, 0x00	; 0
    7cc0:	0e 94 78 3d 	call	0x7af0	; 0x7af0 <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    7cc4:	86 e0       	ldi	r24, 0x06	; 6
    7cc6:	09 c0       	rjmp	.+18     	; 0x7cda <DS18B20+0x42>
			switch(DS18B20_Mode){
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    7cc8:	80 e0       	ldi	r24, 0x00	; 0
    7cca:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    7cce:	64 e6       	ldi	r22, 0x64	; 100
    7cd0:	80 91 6b 09 	lds	r24, 0x096B
    7cd4:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    7cd8:	83 e0       	ldi	r24, 0x03	; 3
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
				DS18B20_Mode = DS18B20_READ_T3;
    7cda:	80 93 56 02 	sts	0x0256, r24
				break;
			}
			DS18B20_Mode++;
    7cde:	80 91 56 02 	lds	r24, 0x0256
    7ce2:	8f 5f       	subi	r24, 0xFF	; 255
    7ce4:	80 93 56 02 	sts	0x0256, r24
    7ce8:	08 95       	ret

00007cea <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7cea:	cf 93       	push	r28
    7cec:	df 93       	push	r29
    7cee:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7cf0:	ec 81       	ldd	r30, Y+4	; 0x04
    7cf2:	fd 81       	ldd	r31, Y+5	; 0x05
    7cf4:	65 91       	lpm	r22, Z+
    7cf6:	74 91       	lpm	r23, Z
	strcpy_P(Param->Pos, prp(Param->Txt));
    7cf8:	88 81       	ld	r24, Y
    7cfa:	99 81       	ldd	r25, Y+1	; 0x01
    7cfc:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7d00:	a8 81       	ld	r26, Y
    7d02:	b9 81       	ldd	r27, Y+1	; 0x01
    7d04:	fd 01       	movw	r30, r26
    7d06:	01 90       	ld	r0, Z+
    7d08:	00 20       	and	r0, r0
    7d0a:	e9 f7       	brne	.-6      	; 0x7d06 <PutEnum+0x1c>
    7d0c:	31 97       	sbiw	r30, 0x01	; 1
    7d0e:	4e 2f       	mov	r20, r30
    7d10:	4a 1b       	sub	r20, r26
    7d12:	80 e0       	ldi	r24, 0x00	; 0
    7d14:	90 e0       	ldi	r25, 0x00	; 0
    7d16:	50 e2       	ldi	r21, 0x20	; 32
    7d18:	24 2f       	mov	r18, r20
    7d1a:	28 0f       	add	r18, r24
    7d1c:	01 96       	adiw	r24, 0x01	; 1
    7d1e:	3b 81       	ldd	r19, Y+3	; 0x03
    7d20:	23 17       	cp	r18, r19
    7d22:	30 f4       	brcc	.+12     	; 0x7d30 <PutEnum+0x46>
    7d24:	e8 81       	ld	r30, Y
    7d26:	f9 81       	ldd	r31, Y+1	; 0x01
    7d28:	e2 0f       	add	r30, r18
    7d2a:	f1 1d       	adc	r31, r1
    7d2c:	50 83       	st	Z, r21
    7d2e:	f4 cf       	rjmp	.-24     	; 0x7d18 <PutEnum+0x2e>
}
    7d30:	df 91       	pop	r29
    7d32:	cf 91       	pop	r28
    7d34:	08 95       	ret

00007d36 <PutVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    7d36:	cf 92       	push	r12
    7d38:	df 92       	push	r13
    7d3a:	ef 92       	push	r14
    7d3c:	ff 92       	push	r15
    7d3e:	0f 93       	push	r16
    7d40:	1f 93       	push	r17
    7d42:	cf 93       	push	r28
    7d44:	df 93       	push	r29
    7d46:	cd b7       	in	r28, 0x3d	; 61
    7d48:	de b7       	in	r29, 0x3e	; 62
    7d4a:	29 97       	sbiw	r28, 0x09	; 9
    7d4c:	0f b6       	in	r0, 0x3f	; 63
    7d4e:	f8 94       	cli
    7d50:	de bf       	out	0x3e, r29	; 62
    7d52:	0f be       	out	0x3f, r0	; 63
    7d54:	cd bf       	out	0x3d, r28	; 61
    7d56:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7d58:	67 37       	cpi	r22, 0x77	; 119
    7d5a:	19 f4       	brne	.+6      	; 0x7d62 <PutVal+0x2c>
    7d5c:	8f ef       	ldi	r24, 0xFF	; 255
    7d5e:	9f ef       	ldi	r25, 0xFF	; 255
    7d60:	02 c0       	rjmp	.+4      	; 0x7d66 <PutVal+0x30>
    7d62:	8f ef       	ldi	r24, 0xFF	; 255
    7d64:	90 e0       	ldi	r25, 0x00	; 0
    7d66:	8e 19       	sub	r24, r14
    7d68:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7d6a:	fa 01       	movw	r30, r20
    7d6c:	24 81       	ldd	r18, Z+4	; 0x04
    7d6e:	35 81       	ldd	r19, Z+5	; 0x05
    7d70:	21 15       	cp	r18, r1
    7d72:	31 05       	cpc	r19, r1
    7d74:	69 f0       	breq	.+26     	; 0x7d90 <PutVal+0x5a>
    7d76:	82 30       	cpi	r24, 0x02	; 2
    7d78:	91 05       	cpc	r25, r1
    7d7a:	50 f4       	brcc	.+20     	; 0x7d90 <PutVal+0x5a>
		Param->Txt += Idx;
    7d7c:	88 0f       	add	r24, r24
    7d7e:	99 1f       	adc	r25, r25
    7d80:	82 0f       	add	r24, r18
    7d82:	93 1f       	adc	r25, r19
    7d84:	95 83       	std	Z+5, r25	; 0x05
    7d86:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7d88:	ca 01       	movw	r24, r20
    7d8a:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
    7d8e:	3f c0       	rjmp	.+126    	; 0x7e0e <PutVal+0xd8>
		return;
	}
	char Format[] = "% u.%. u";
    7d90:	89 e0       	ldi	r24, 0x09	; 9
    7d92:	e3 e1       	ldi	r30, 0x13	; 19
    7d94:	f1 e0       	ldi	r31, 0x01	; 1
    7d96:	8e 01       	movw	r16, r28
    7d98:	0f 5f       	subi	r16, 0xFF	; 255
    7d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    7d9c:	d8 01       	movw	r26, r16
    7d9e:	01 90       	ld	r0, Z+
    7da0:	0d 92       	st	X+, r0
    7da2:	8a 95       	dec	r24
    7da4:	e1 f7       	brne	.-8      	; 0x7d9e <PutVal+0x68>
	Format[1] = '0'+Param->Size;
    7da6:	fa 01       	movw	r30, r20
    7da8:	93 81       	ldd	r25, Z+3	; 0x03
    7daa:	90 5d       	subi	r25, 0xD0	; 208
    7dac:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    7dae:	82 81       	ldd	r24, Z+2	; 0x02
    7db0:	c1 80       	ldd	r12, Z+1	; 0x01
    7db2:	d0 80       	ld	r13, Z
    7db4:	88 23       	and	r24, r24
    7db6:	e1 f0       	breq	.+56     	; 0x7df0 <PutVal+0xba>
		Format[1] -= Param->Prec+1;
    7db8:	98 1b       	sub	r25, r24
    7dba:	91 50       	subi	r25, 0x01	; 1
    7dbc:	9a 83       	std	Y+2, r25	; 0x02
		Format[6] = '0'+Param->Prec;
    7dbe:	90 e3       	ldi	r25, 0x30	; 48
    7dc0:	98 0f       	add	r25, r24
    7dc2:	9f 83       	std	Y+7, r25	; 0x07
		uint16_t Div=Pow10(Param->Prec);
    7dc4:	0e 94 80 3c 	call	0x7900	; 0x7900 <Pow10>
    7dc8:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7dca:	c7 01       	movw	r24, r14
    7dcc:	0e 94 a5 74 	call	0xe94a	; 0xe94a <__udivmodhi4>
    7dd0:	9f 93       	push	r25
    7dd2:	8f 93       	push	r24
    7dd4:	7f 93       	push	r23
    7dd6:	6f 93       	push	r22
    7dd8:	1f 93       	push	r17
    7dda:	0f 93       	push	r16
    7ddc:	cf 92       	push	r12
    7dde:	df 92       	push	r13
    7de0:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    7de4:	0f b6       	in	r0, 0x3f	; 63
    7de6:	f8 94       	cli
    7de8:	de bf       	out	0x3e, r29	; 62
    7dea:	0f be       	out	0x3f, r0	; 63
    7dec:	cd bf       	out	0x3d, r28	; 61
    7dee:	0f c0       	rjmp	.+30     	; 0x7e0e <PutVal+0xd8>
	}
	else {
		Format[3] = '\0';
    7df0:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    7df2:	ff 92       	push	r15
    7df4:	ef 92       	push	r14
    7df6:	1f 93       	push	r17
    7df8:	0f 93       	push	r16
    7dfa:	cf 92       	push	r12
    7dfc:	df 92       	push	r13
    7dfe:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    7e02:	0f 90       	pop	r0
    7e04:	0f 90       	pop	r0
    7e06:	0f 90       	pop	r0
    7e08:	0f 90       	pop	r0
    7e0a:	0f 90       	pop	r0
    7e0c:	0f 90       	pop	r0
	}
}
    7e0e:	29 96       	adiw	r28, 0x09	; 9
    7e10:	0f b6       	in	r0, 0x3f	; 63
    7e12:	f8 94       	cli
    7e14:	de bf       	out	0x3e, r29	; 62
    7e16:	0f be       	out	0x3f, r0	; 63
    7e18:	cd bf       	out	0x3d, r28	; 61
    7e1a:	df 91       	pop	r29
    7e1c:	cf 91       	pop	r28
    7e1e:	1f 91       	pop	r17
    7e20:	0f 91       	pop	r16
    7e22:	ff 90       	pop	r15
    7e24:	ef 90       	pop	r14
    7e26:	df 90       	pop	r13
    7e28:	cf 90       	pop	r12
    7e2a:	08 95       	ret

00007e2c <Put_sVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    7e2c:	af 92       	push	r10
    7e2e:	bf 92       	push	r11
    7e30:	cf 92       	push	r12
    7e32:	df 92       	push	r13
    7e34:	ef 92       	push	r14
    7e36:	ff 92       	push	r15
    7e38:	0f 93       	push	r16
    7e3a:	1f 93       	push	r17
    7e3c:	cf 93       	push	r28
    7e3e:	df 93       	push	r29
    7e40:	cd b7       	in	r28, 0x3d	; 61
    7e42:	de b7       	in	r29, 0x3e	; 62
    7e44:	2a 97       	sbiw	r28, 0x0a	; 10
    7e46:	0f b6       	in	r0, 0x3f	; 63
    7e48:	f8 94       	cli
    7e4a:	de bf       	out	0x3e, r29	; 62
    7e4c:	0f be       	out	0x3f, r0	; 63
    7e4e:	cd bf       	out	0x3d, r28	; 61
    7e50:	7c 01       	movw	r14, r24
    7e52:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    7e54:	67 37       	cpi	r22, 0x77	; 119
    7e56:	19 f4       	brne	.+6      	; 0x7e5e <Put_sVal+0x32>
    7e58:	80 e0       	ldi	r24, 0x00	; 0
    7e5a:	90 e8       	ldi	r25, 0x80	; 128
    7e5c:	02 c0       	rjmp	.+4      	; 0x7e62 <Put_sVal+0x36>
    7e5e:	80 e8       	ldi	r24, 0x80	; 128
    7e60:	90 e0       	ldi	r25, 0x00	; 0
    7e62:	8e 0d       	add	r24, r14
    7e64:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    7e66:	d8 01       	movw	r26, r16
    7e68:	14 96       	adiw	r26, 0x04	; 4
    7e6a:	2d 91       	ld	r18, X+
    7e6c:	3c 91       	ld	r19, X
    7e6e:	15 97       	sbiw	r26, 0x05	; 5
    7e70:	21 15       	cp	r18, r1
    7e72:	31 05       	cpc	r19, r1
    7e74:	79 f0       	breq	.+30     	; 0x7e94 <Put_sVal+0x68>
    7e76:	82 30       	cpi	r24, 0x02	; 2
    7e78:	91 05       	cpc	r25, r1
    7e7a:	60 f4       	brcc	.+24     	; 0x7e94 <Put_sVal+0x68>
		Param->Txt += Idx;
    7e7c:	88 0f       	add	r24, r24
    7e7e:	99 1f       	adc	r25, r25
    7e80:	82 0f       	add	r24, r18
    7e82:	93 1f       	adc	r25, r19
    7e84:	15 96       	adiw	r26, 0x05	; 5
    7e86:	9c 93       	st	X, r25
    7e88:	8e 93       	st	-X, r24
    7e8a:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    7e8c:	c8 01       	movw	r24, r16
    7e8e:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
    7e92:	65 c0       	rjmp	.+202    	; 0x7f5e <Put_sVal+0x132>
		return;
	}
	char Format[] = "%+ d.%. u";
    7e94:	8a e0       	ldi	r24, 0x0A	; 10
    7e96:	ec e1       	ldi	r30, 0x1C	; 28
    7e98:	f1 e0       	ldi	r31, 0x01	; 1
    7e9a:	9e 01       	movw	r18, r28
    7e9c:	2f 5f       	subi	r18, 0xFF	; 255
    7e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    7ea0:	69 01       	movw	r12, r18
    7ea2:	d9 01       	movw	r26, r18
    7ea4:	01 90       	ld	r0, Z+
    7ea6:	0d 92       	st	X+, r0
    7ea8:	8a 95       	dec	r24
    7eaa:	e1 f7       	brne	.-8      	; 0x7ea4 <Put_sVal+0x78>
	if(Val==0)
    7eac:	e1 14       	cp	r14, r1
    7eae:	f1 04       	cpc	r15, r1
    7eb0:	11 f4       	brne	.+4      	; 0x7eb6 <Put_sVal+0x8a>
		Format[1] = ' ';
    7eb2:	80 e2       	ldi	r24, 0x20	; 32
    7eb4:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    7eb6:	d8 01       	movw	r26, r16
    7eb8:	13 96       	adiw	r26, 0x03	; 3
    7eba:	9c 91       	ld	r25, X
    7ebc:	13 97       	sbiw	r26, 0x03	; 3
    7ebe:	90 5d       	subi	r25, 0xD0	; 208
    7ec0:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7ec2:	12 96       	adiw	r26, 0x02	; 2
    7ec4:	8c 91       	ld	r24, X
    7ec6:	12 97       	sbiw	r26, 0x02	; 2
    7ec8:	11 96       	adiw	r26, 0x01	; 1
    7eca:	ac 90       	ld	r10, X
    7ecc:	11 97       	sbiw	r26, 0x01	; 1
    7ece:	bc 90       	ld	r11, X
    7ed0:	88 23       	and	r24, r24
    7ed2:	b1 f1       	breq	.+108    	; 0x7f40 <Put_sVal+0x114>
		Format[2] -= Param->Prec+1;
    7ed4:	98 1b       	sub	r25, r24
    7ed6:	91 50       	subi	r25, 0x01	; 1
    7ed8:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7eda:	90 e3       	ldi	r25, 0x30	; 48
    7edc:	98 0f       	add	r25, r24
    7ede:	98 87       	std	Y+8, r25	; 0x08
		int16_t Div=Pow10(Param->Prec);
    7ee0:	0e 94 80 3c 	call	0x7900	; 0x7900 <Pow10>
    7ee4:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    7ee6:	c7 01       	movw	r24, r14
    7ee8:	f7 fe       	sbrs	r15, 7
    7eea:	04 c0       	rjmp	.+8      	; 0x7ef4 <Put_sVal+0xc8>
    7eec:	88 27       	eor	r24, r24
    7eee:	99 27       	eor	r25, r25
    7ef0:	8e 19       	sub	r24, r14
    7ef2:	9f 09       	sbc	r25, r15
    7ef4:	b9 01       	movw	r22, r18
    7ef6:	0e 94 a5 74 	call	0xe94a	; 0xe94a <__udivmodhi4>
    7efa:	9f 93       	push	r25
    7efc:	8f 93       	push	r24
    7efe:	c7 01       	movw	r24, r14
    7f00:	b9 01       	movw	r22, r18
    7f02:	0e 94 b9 74 	call	0xe972	; 0xe972 <__divmodhi4>
    7f06:	7f 93       	push	r23
    7f08:	6f 93       	push	r22
    7f0a:	df 92       	push	r13
    7f0c:	cf 92       	push	r12
    7f0e:	af 92       	push	r10
    7f10:	bf 92       	push	r11
    7f12:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
		if(Val<0) {
    7f16:	0f b6       	in	r0, 0x3f	; 63
    7f18:	f8 94       	cli
    7f1a:	de bf       	out	0x3e, r29	; 62
    7f1c:	0f be       	out	0x3f, r0	; 63
    7f1e:	cd bf       	out	0x3d, r28	; 61
    7f20:	f7 fe       	sbrs	r15, 7
    7f22:	1d c0       	rjmp	.+58     	; 0x7f5e <Put_sVal+0x132>
			while(*Param->Pos==' ')
    7f24:	d8 01       	movw	r26, r16
    7f26:	ed 91       	ld	r30, X+
    7f28:	fc 91       	ld	r31, X
    7f2a:	80 81       	ld	r24, Z
    7f2c:	80 32       	cpi	r24, 0x20	; 32
    7f2e:	29 f4       	brne	.+10     	; 0x7f3a <Put_sVal+0x10e>
				Param->Pos++;
    7f30:	31 96       	adiw	r30, 0x01	; 1
    7f32:	d8 01       	movw	r26, r16
    7f34:	ed 93       	st	X+, r30
    7f36:	fc 93       	st	X, r31
    7f38:	f5 cf       	rjmp	.-22     	; 0x7f24 <Put_sVal+0xf8>
			*Param->Pos = '-';
    7f3a:	8d e2       	ldi	r24, 0x2D	; 45
    7f3c:	80 83       	st	Z, r24
    7f3e:	0f c0       	rjmp	.+30     	; 0x7f5e <Put_sVal+0x132>
		}
	}
	else {
		Format[4] = '\0';
    7f40:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7f42:	ff 92       	push	r15
    7f44:	ef 92       	push	r14
    7f46:	df 92       	push	r13
    7f48:	cf 92       	push	r12
    7f4a:	af 92       	push	r10
    7f4c:	bf 92       	push	r11
    7f4e:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    7f52:	0f 90       	pop	r0
    7f54:	0f 90       	pop	r0
    7f56:	0f 90       	pop	r0
    7f58:	0f 90       	pop	r0
    7f5a:	0f 90       	pop	r0
    7f5c:	0f 90       	pop	r0
	}
}
    7f5e:	2a 96       	adiw	r28, 0x0a	; 10
    7f60:	0f b6       	in	r0, 0x3f	; 63
    7f62:	f8 94       	cli
    7f64:	de bf       	out	0x3e, r29	; 62
    7f66:	0f be       	out	0x3f, r0	; 63
    7f68:	cd bf       	out	0x3d, r28	; 61
    7f6a:	df 91       	pop	r29
    7f6c:	cf 91       	pop	r28
    7f6e:	1f 91       	pop	r17
    7f70:	0f 91       	pop	r16
    7f72:	ff 90       	pop	r15
    7f74:	ef 90       	pop	r14
    7f76:	df 90       	pop	r13
    7f78:	cf 90       	pop	r12
    7f7a:	bf 90       	pop	r11
    7f7c:	af 90       	pop	r10
    7f7e:	08 95       	ret

00007f80 <Put_zVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    7f80:	cf 92       	push	r12
    7f82:	df 92       	push	r13
    7f84:	ef 92       	push	r14
    7f86:	ff 92       	push	r15
    7f88:	0f 93       	push	r16
    7f8a:	1f 93       	push	r17
    7f8c:	cf 93       	push	r28
    7f8e:	df 93       	push	r29
    7f90:	cd b7       	in	r28, 0x3d	; 61
    7f92:	de b7       	in	r29, 0x3e	; 62
    7f94:	2a 97       	sbiw	r28, 0x0a	; 10
    7f96:	0f b6       	in	r0, 0x3f	; 63
    7f98:	f8 94       	cli
    7f9a:	de bf       	out	0x3e, r29	; 62
    7f9c:	0f be       	out	0x3f, r0	; 63
    7f9e:	cd bf       	out	0x3d, r28	; 61
    7fa0:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7fa2:	67 37       	cpi	r22, 0x77	; 119
    7fa4:	19 f4       	brne	.+6      	; 0x7fac <Put_zVal+0x2c>
    7fa6:	8f ef       	ldi	r24, 0xFF	; 255
    7fa8:	9f ef       	ldi	r25, 0xFF	; 255
    7faa:	02 c0       	rjmp	.+4      	; 0x7fb0 <Put_zVal+0x30>
    7fac:	8f ef       	ldi	r24, 0xFF	; 255
    7fae:	90 e0       	ldi	r25, 0x00	; 0
    7fb0:	8e 19       	sub	r24, r14
    7fb2:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7fb4:	fa 01       	movw	r30, r20
    7fb6:	24 81       	ldd	r18, Z+4	; 0x04
    7fb8:	35 81       	ldd	r19, Z+5	; 0x05
    7fba:	21 15       	cp	r18, r1
    7fbc:	31 05       	cpc	r19, r1
    7fbe:	69 f0       	breq	.+26     	; 0x7fda <Put_zVal+0x5a>
    7fc0:	82 30       	cpi	r24, 0x02	; 2
    7fc2:	91 05       	cpc	r25, r1
    7fc4:	50 f4       	brcc	.+20     	; 0x7fda <Put_zVal+0x5a>
		Param->Txt += Idx;
    7fc6:	88 0f       	add	r24, r24
    7fc8:	99 1f       	adc	r25, r25
    7fca:	82 0f       	add	r24, r18
    7fcc:	93 1f       	adc	r25, r19
    7fce:	95 83       	std	Z+5, r25	; 0x05
    7fd0:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7fd2:	ca 01       	movw	r24, r20
    7fd4:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
    7fd8:	3f c0       	rjmp	.+126    	; 0x8058 <Put_zVal+0xd8>
		return;
	}
	char Format[] = "%0 u.%. u";
    7fda:	8a e0       	ldi	r24, 0x0A	; 10
    7fdc:	e6 e2       	ldi	r30, 0x26	; 38
    7fde:	f1 e0       	ldi	r31, 0x01	; 1
    7fe0:	8e 01       	movw	r16, r28
    7fe2:	0f 5f       	subi	r16, 0xFF	; 255
    7fe4:	1f 4f       	sbci	r17, 0xFF	; 255
    7fe6:	d8 01       	movw	r26, r16
    7fe8:	01 90       	ld	r0, Z+
    7fea:	0d 92       	st	X+, r0
    7fec:	8a 95       	dec	r24
    7fee:	e1 f7       	brne	.-8      	; 0x7fe8 <Put_zVal+0x68>
	Format[2] = '0'+Param->Size;
    7ff0:	fa 01       	movw	r30, r20
    7ff2:	93 81       	ldd	r25, Z+3	; 0x03
    7ff4:	90 5d       	subi	r25, 0xD0	; 208
    7ff6:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7ff8:	82 81       	ldd	r24, Z+2	; 0x02
    7ffa:	c1 80       	ldd	r12, Z+1	; 0x01
    7ffc:	d0 80       	ld	r13, Z
    7ffe:	88 23       	and	r24, r24
    8000:	e1 f0       	breq	.+56     	; 0x803a <Put_zVal+0xba>
		Format[2] -= Param->Prec+1;
    8002:	98 1b       	sub	r25, r24
    8004:	91 50       	subi	r25, 0x01	; 1
    8006:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    8008:	90 e3       	ldi	r25, 0x30	; 48
    800a:	98 0f       	add	r25, r24
    800c:	98 87       	std	Y+8, r25	; 0x08
		uint16_t Div=Pow10(Param->Prec);
    800e:	0e 94 80 3c 	call	0x7900	; 0x7900 <Pow10>
    8012:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8014:	c7 01       	movw	r24, r14
    8016:	0e 94 a5 74 	call	0xe94a	; 0xe94a <__udivmodhi4>
    801a:	9f 93       	push	r25
    801c:	8f 93       	push	r24
    801e:	7f 93       	push	r23
    8020:	6f 93       	push	r22
    8022:	1f 93       	push	r17
    8024:	0f 93       	push	r16
    8026:	cf 92       	push	r12
    8028:	df 92       	push	r13
    802a:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    802e:	0f b6       	in	r0, 0x3f	; 63
    8030:	f8 94       	cli
    8032:	de bf       	out	0x3e, r29	; 62
    8034:	0f be       	out	0x3f, r0	; 63
    8036:	cd bf       	out	0x3d, r28	; 61
    8038:	0f c0       	rjmp	.+30     	; 0x8058 <Put_zVal+0xd8>
	}
	else {
		Format[4] = '\0';
    803a:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    803c:	ff 92       	push	r15
    803e:	ef 92       	push	r14
    8040:	1f 93       	push	r17
    8042:	0f 93       	push	r16
    8044:	cf 92       	push	r12
    8046:	df 92       	push	r13
    8048:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    804c:	0f 90       	pop	r0
    804e:	0f 90       	pop	r0
    8050:	0f 90       	pop	r0
    8052:	0f 90       	pop	r0
    8054:	0f 90       	pop	r0
    8056:	0f 90       	pop	r0
	}
}
    8058:	2a 96       	adiw	r28, 0x0a	; 10
    805a:	0f b6       	in	r0, 0x3f	; 63
    805c:	f8 94       	cli
    805e:	de bf       	out	0x3e, r29	; 62
    8060:	0f be       	out	0x3f, r0	; 63
    8062:	cd bf       	out	0x3d, r28	; 61
    8064:	df 91       	pop	r29
    8066:	cf 91       	pop	r28
    8068:	1f 91       	pop	r17
    806a:	0f 91       	pop	r16
    806c:	ff 90       	pop	r15
    806e:	ef 90       	pop	r14
    8070:	df 90       	pop	r13
    8072:	cf 90       	pop	r12
    8074:	08 95       	ret

00008076 <Put_zVal_h>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8076:	f9 01       	movw	r30, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8078:	42 36       	cpi	r20, 0x62	; 98
    807a:	29 f4       	brne	.+10     	; 0x8086 <Put_zVal_h+0x10>
    807c:	1f 92       	push	r1
    807e:	6f 93       	push	r22
    8080:	80 e3       	ldi	r24, 0x30	; 48
    8082:	91 e0       	ldi	r25, 0x01	; 1
    8084:	06 c0       	rjmp	.+12     	; 0x8092 <Put_zVal_h+0x1c>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8086:	47 37       	cpi	r20, 0x77	; 119
    8088:	99 f4       	brne	.+38     	; 0x80b0 <Put_zVal_h+0x3a>
    808a:	7f 93       	push	r23
    808c:	6f 93       	push	r22
    808e:	86 e3       	ldi	r24, 0x36	; 54
    8090:	91 e0       	ldi	r25, 0x01	; 1
    8092:	9f 93       	push	r25
    8094:	8f 93       	push	r24
    8096:	81 81       	ldd	r24, Z+1	; 0x01
    8098:	8f 93       	push	r24
    809a:	80 81       	ld	r24, Z
    809c:	8f 93       	push	r24
    809e:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    80a2:	0f 90       	pop	r0
    80a4:	0f 90       	pop	r0
    80a6:	0f 90       	pop	r0
    80a8:	0f 90       	pop	r0
    80aa:	0f 90       	pop	r0
    80ac:	0f 90       	pop	r0
    80ae:	08 95       	ret
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    80b0:	4c 36       	cpi	r20, 0x6C	; 108
    80b2:	b1 f4       	brne	.+44     	; 0x80e0 <Put_zVal_h+0x6a>
    80b4:	9f 93       	push	r25
    80b6:	8f 93       	push	r24
    80b8:	7f 93       	push	r23
    80ba:	6f 93       	push	r22
    80bc:	8b e3       	ldi	r24, 0x3B	; 59
    80be:	91 e0       	ldi	r25, 0x01	; 1
    80c0:	9f 93       	push	r25
    80c2:	8f 93       	push	r24
    80c4:	81 81       	ldd	r24, Z+1	; 0x01
    80c6:	8f 93       	push	r24
    80c8:	80 81       	ld	r24, Z
    80ca:	8f 93       	push	r24
    80cc:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    80d0:	8d b7       	in	r24, 0x3d	; 61
    80d2:	9e b7       	in	r25, 0x3e	; 62
    80d4:	08 96       	adiw	r24, 0x08	; 8
    80d6:	0f b6       	in	r0, 0x3f	; 63
    80d8:	f8 94       	cli
    80da:	9e bf       	out	0x3e, r25	; 62
    80dc:	0f be       	out	0x3f, r0	; 63
    80de:	8d bf       	out	0x3d, r24	; 61
    80e0:	08 95       	ret

000080e2 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    80e2:	af 92       	push	r10
    80e4:	bf 92       	push	r11
    80e6:	cf 92       	push	r12
    80e8:	df 92       	push	r13
    80ea:	ef 92       	push	r14
    80ec:	ff 92       	push	r15
    80ee:	0f 93       	push	r16
    80f0:	1f 93       	push	r17
    80f2:	cf 93       	push	r28
    80f4:	df 93       	push	r29
    80f6:	cd b7       	in	r28, 0x3d	; 61
    80f8:	de b7       	in	r29, 0x3e	; 62
    80fa:	2b 97       	sbiw	r28, 0x0b	; 11
    80fc:	0f b6       	in	r0, 0x3f	; 63
    80fe:	f8 94       	cli
    8100:	de bf       	out	0x3e, r29	; 62
    8102:	0f be       	out	0x3f, r0	; 63
    8104:	cd bf       	out	0x3d, r28	; 61
    8106:	6b 01       	movw	r12, r22
    8108:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    810a:	8b 01       	movw	r16, r22
    810c:	9c 01       	movw	r18, r24
    810e:	00 95       	com	r16
    8110:	10 95       	com	r17
    8112:	20 95       	com	r18
    8114:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    8116:	fa 01       	movw	r30, r20
    8118:	84 81       	ldd	r24, Z+4	; 0x04
    811a:	95 81       	ldd	r25, Z+5	; 0x05
    811c:	00 97       	sbiw	r24, 0x00	; 0
    811e:	79 f0       	breq	.+30     	; 0x813e <PutDVal+0x5c>
    8120:	02 30       	cpi	r16, 0x02	; 2
    8122:	11 05       	cpc	r17, r1
    8124:	21 05       	cpc	r18, r1
    8126:	31 05       	cpc	r19, r1
    8128:	50 f4       	brcc	.+20     	; 0x813e <PutDVal+0x5c>
		Param->Txt += Idx;
    812a:	00 0f       	add	r16, r16
    812c:	11 1f       	adc	r17, r17
    812e:	08 0f       	add	r16, r24
    8130:	19 1f       	adc	r17, r25
    8132:	15 83       	std	Z+5, r17	; 0x05
    8134:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    8136:	ca 01       	movw	r24, r20
    8138:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
		return;
    813c:	54 c0       	rjmp	.+168    	; 0x81e6 <PutDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    813e:	fa 01       	movw	r30, r20
    8140:	93 81       	ldd	r25, Z+3	; 0x03
    8142:	9a 30       	cpi	r25, 0x0A	; 10
    8144:	81 f4       	brne	.+32     	; 0x8166 <PutDVal+0x84>
    8146:	82 81       	ldd	r24, Z+2	; 0x02
    8148:	81 11       	cpse	r24, r1
    814a:	0d c0       	rjmp	.+26     	; 0x8166 <PutDVal+0x84>
		sprintf(Param->Pos, "%10lu", Val);
    814c:	ff 92       	push	r15
    814e:	ef 92       	push	r14
    8150:	df 92       	push	r13
    8152:	cf 92       	push	r12
    8154:	81 e4       	ldi	r24, 0x41	; 65
    8156:	91 e0       	ldi	r25, 0x01	; 1
    8158:	9f 93       	push	r25
    815a:	8f 93       	push	r24
    815c:	81 81       	ldd	r24, Z+1	; 0x01
    815e:	8f 93       	push	r24
    8160:	80 81       	ld	r24, Z
    8162:	8f 93       	push	r24
    8164:	39 c0       	rjmp	.+114    	; 0x81d8 <PutDVal+0xf6>
		return;
	}
	char Format[] = "% lu.%. lu";
    8166:	8b e0       	ldi	r24, 0x0B	; 11
    8168:	e7 e4       	ldi	r30, 0x47	; 71
    816a:	f1 e0       	ldi	r31, 0x01	; 1
    816c:	8e 01       	movw	r16, r28
    816e:	0f 5f       	subi	r16, 0xFF	; 255
    8170:	1f 4f       	sbci	r17, 0xFF	; 255
    8172:	d8 01       	movw	r26, r16
    8174:	01 90       	ld	r0, Z+
    8176:	0d 92       	st	X+, r0
    8178:	8a 95       	dec	r24
    817a:	e1 f7       	brne	.-8      	; 0x8174 <PutDVal+0x92>
	Format[1] = '0'+Param->Size;
    817c:	90 5d       	subi	r25, 0xD0	; 208
    817e:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    8180:	fa 01       	movw	r30, r20
    8182:	82 81       	ldd	r24, Z+2	; 0x02
    8184:	a1 80       	ldd	r10, Z+1	; 0x01
    8186:	b0 80       	ld	r11, Z
    8188:	88 23       	and	r24, r24
    818a:	e9 f0       	breq	.+58     	; 0x81c6 <PutDVal+0xe4>
		Format[1] -= Param->Prec+1;
    818c:	98 1b       	sub	r25, r24
    818e:	91 50       	subi	r25, 0x01	; 1
    8190:	9a 83       	std	Y+2, r25	; 0x02
		Format[7] = '0'+Param->Prec;
    8192:	90 e3       	ldi	r25, 0x30	; 48
    8194:	98 0f       	add	r25, r24
    8196:	98 87       	std	Y+8, r25	; 0x08
		uint32_t Div=PowL10(Param->Prec);
    8198:	0e 94 8e 3c 	call	0x791c	; 0x791c <PowL10>
    819c:	9b 01       	movw	r18, r22
    819e:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    81a0:	c7 01       	movw	r24, r14
    81a2:	b6 01       	movw	r22, r12
    81a4:	0e 94 cd 74 	call	0xe99a	; 0xe99a <__udivmodsi4>
    81a8:	9f 93       	push	r25
    81aa:	8f 93       	push	r24
    81ac:	7f 93       	push	r23
    81ae:	6f 93       	push	r22
    81b0:	5f 93       	push	r21
    81b2:	4f 93       	push	r20
    81b4:	3f 93       	push	r19
    81b6:	2f 93       	push	r18
    81b8:	1f 93       	push	r17
    81ba:	0f 93       	push	r16
    81bc:	af 92       	push	r10
    81be:	bf 92       	push	r11
    81c0:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    81c4:	0b c0       	rjmp	.+22     	; 0x81dc <PutDVal+0xfa>
	}
	else {
		Format[4] = '\0';
    81c6:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    81c8:	ff 92       	push	r15
    81ca:	ef 92       	push	r14
    81cc:	df 92       	push	r13
    81ce:	cf 92       	push	r12
    81d0:	1f 93       	push	r17
    81d2:	0f 93       	push	r16
    81d4:	af 92       	push	r10
    81d6:	bf 92       	push	r11
    81d8:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    81dc:	0f b6       	in	r0, 0x3f	; 63
    81de:	f8 94       	cli
    81e0:	de bf       	out	0x3e, r29	; 62
    81e2:	0f be       	out	0x3f, r0	; 63
    81e4:	cd bf       	out	0x3d, r28	; 61
	}
}
    81e6:	2b 96       	adiw	r28, 0x0b	; 11
    81e8:	0f b6       	in	r0, 0x3f	; 63
    81ea:	f8 94       	cli
    81ec:	de bf       	out	0x3e, r29	; 62
    81ee:	0f be       	out	0x3f, r0	; 63
    81f0:	cd bf       	out	0x3d, r28	; 61
    81f2:	df 91       	pop	r29
    81f4:	cf 91       	pop	r28
    81f6:	1f 91       	pop	r17
    81f8:	0f 91       	pop	r16
    81fa:	ff 90       	pop	r15
    81fc:	ef 90       	pop	r14
    81fe:	df 90       	pop	r13
    8200:	cf 90       	pop	r12
    8202:	bf 90       	pop	r11
    8204:	af 90       	pop	r10
    8206:	08 95       	ret

00008208 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8208:	af 92       	push	r10
    820a:	bf 92       	push	r11
    820c:	cf 92       	push	r12
    820e:	df 92       	push	r13
    8210:	ef 92       	push	r14
    8212:	ff 92       	push	r15
    8214:	0f 93       	push	r16
    8216:	1f 93       	push	r17
    8218:	cf 93       	push	r28
    821a:	df 93       	push	r29
    821c:	cd b7       	in	r28, 0x3d	; 61
    821e:	de b7       	in	r29, 0x3e	; 62
    8220:	27 97       	sbiw	r28, 0x07	; 7
    8222:	0f b6       	in	r0, 0x3f	; 63
    8224:	f8 94       	cli
    8226:	de bf       	out	0x3e, r29	; 62
    8228:	0f be       	out	0x3f, r0	; 63
    822a:	cd bf       	out	0x3d, r28	; 61
    822c:	6b 01       	movw	r12, r22
    822e:	7c 01       	movw	r14, r24
    8230:	5a 01       	movw	r10, r20
	uint32_t Idx = 0x80000000+Val;
    8232:	8b 01       	movw	r16, r22
    8234:	9c 01       	movw	r18, r24
    8236:	30 58       	subi	r19, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8238:	da 01       	movw	r26, r20
    823a:	14 96       	adiw	r26, 0x04	; 4
    823c:	8d 91       	ld	r24, X+
    823e:	9c 91       	ld	r25, X
    8240:	15 97       	sbiw	r26, 0x05	; 5
    8242:	00 97       	sbiw	r24, 0x00	; 0
    8244:	89 f0       	breq	.+34     	; 0x8268 <Put_sDVal+0x60>
    8246:	02 30       	cpi	r16, 0x02	; 2
    8248:	11 05       	cpc	r17, r1
    824a:	21 05       	cpc	r18, r1
    824c:	31 05       	cpc	r19, r1
    824e:	60 f4       	brcc	.+24     	; 0x8268 <Put_sDVal+0x60>
		Param->Txt += Idx;
    8250:	00 0f       	add	r16, r16
    8252:	11 1f       	adc	r17, r17
    8254:	08 0f       	add	r16, r24
    8256:	19 1f       	adc	r17, r25
    8258:	15 96       	adiw	r26, 0x05	; 5
    825a:	1c 93       	st	X, r17
    825c:	0e 93       	st	-X, r16
    825e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    8260:	ca 01       	movw	r24, r20
    8262:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
		return;
    8266:	b7 c0       	rjmp	.+366    	; 0x83d6 <Put_sDVal+0x1ce>
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8268:	f5 01       	movw	r30, r10
    826a:	83 81       	ldd	r24, Z+3	; 0x03
    826c:	9e 01       	movw	r18, r28
    826e:	2f 5f       	subi	r18, 0xFF	; 255
    8270:	3f 4f       	sbci	r19, 0xFF	; 255
    8272:	8a 30       	cpi	r24, 0x0A	; 10
    8274:	70 f0       	brcs	.+28     	; 0x8292 <Put_sDVal+0x8a>
		char Format[] = "%+1 ld";
    8276:	97 e0       	ldi	r25, 0x07	; 7
    8278:	e2 e5       	ldi	r30, 0x52	; 82
    827a:	f1 e0       	ldi	r31, 0x01	; 1
    827c:	d9 01       	movw	r26, r18
    827e:	01 90       	ld	r0, Z+
    8280:	0d 92       	st	X+, r0
    8282:	9a 95       	dec	r25
    8284:	e1 f7       	brne	.-8      	; 0x827e <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    8286:	6a e0       	ldi	r22, 0x0A	; 10
    8288:	0e 94 99 74 	call	0xe932	; 0xe932 <__udivmodqi4>
    828c:	90 5d       	subi	r25, 0xD0	; 208
    828e:	9c 83       	std	Y+4, r25	; 0x04
    8290:	0a c0       	rjmp	.+20     	; 0x82a6 <Put_sDVal+0x9e>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+ ld";
    8292:	96 e0       	ldi	r25, 0x06	; 6
    8294:	e9 e5       	ldi	r30, 0x59	; 89
    8296:	f1 e0       	ldi	r31, 0x01	; 1
    8298:	d9 01       	movw	r26, r18
    829a:	01 90       	ld	r0, Z+
    829c:	0d 92       	st	X+, r0
    829e:	9a 95       	dec	r25
    82a0:	e1 f7       	brne	.-8      	; 0x829a <Put_sDVal+0x92>
		Format[2] = '0'+Param->Size;
    82a2:	80 5d       	subi	r24, 0xD0	; 208
    82a4:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    82a6:	ff 92       	push	r15
    82a8:	ef 92       	push	r14
    82aa:	df 92       	push	r13
    82ac:	cf 92       	push	r12
    82ae:	3f 93       	push	r19
    82b0:	2f 93       	push	r18
    82b2:	d5 01       	movw	r26, r10
    82b4:	11 96       	adiw	r26, 0x01	; 1
    82b6:	8c 91       	ld	r24, X
    82b8:	11 97       	sbiw	r26, 0x01	; 1
    82ba:	8f 93       	push	r24
    82bc:	8c 91       	ld	r24, X
    82be:	8f 93       	push	r24
    82c0:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    82c4:	0f b6       	in	r0, 0x3f	; 63
    82c6:	f8 94       	cli
    82c8:	de bf       	out	0x3e, r29	; 62
    82ca:	0f be       	out	0x3f, r0	; 63
    82cc:	cd bf       	out	0x3d, r28	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    82ce:	c1 14       	cp	r12, r1
    82d0:	d1 04       	cpc	r13, r1
    82d2:	e1 04       	cpc	r14, r1
    82d4:	f1 04       	cpc	r15, r1
    82d6:	59 f4       	brne	.+22     	; 0x82ee <Put_sDVal+0xe6>
    82d8:	d5 01       	movw	r26, r10
    82da:	13 96       	adiw	r26, 0x03	; 3
    82dc:	8c 91       	ld	r24, X
    82de:	13 97       	sbiw	r26, 0x03	; 3
    82e0:	ed 91       	ld	r30, X+
    82e2:	fc 91       	ld	r31, X
    82e4:	e8 0f       	add	r30, r24
    82e6:	f1 1d       	adc	r31, r1
    82e8:	32 97       	sbiw	r30, 0x02	; 2
    82ea:	80 e2       	ldi	r24, 0x20	; 32
    82ec:	80 83       	st	Z, r24

	if(Param->Prec){
    82ee:	f5 01       	movw	r30, r10
    82f0:	82 81       	ldd	r24, Z+2	; 0x02
    82f2:	88 23       	and	r24, r24
    82f4:	09 f4       	brne	.+2      	; 0x82f8 <Put_sDVal+0xf0>
    82f6:	6f c0       	rjmp	.+222    	; 0x83d6 <Put_sDVal+0x1ce>
    82f8:	60 e0       	ldi	r22, 0x00	; 0
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    82fa:	d5 01       	movw	r26, r10
    82fc:	13 96       	adiw	r26, 0x03	; 3
    82fe:	8c 91       	ld	r24, X
    8300:	13 97       	sbiw	r26, 0x03	; 3
    8302:	90 e0       	ldi	r25, 0x00	; 0
    8304:	12 96       	adiw	r26, 0x02	; 2
    8306:	2c 91       	ld	r18, X
    8308:	12 97       	sbiw	r26, 0x02	; 2
    830a:	82 1b       	sub	r24, r18
    830c:	91 09       	sbc	r25, r1
    830e:	46 2f       	mov	r20, r22
    8310:	50 e0       	ldi	r21, 0x00	; 0
    8312:	2d 91       	ld	r18, X+
    8314:	3c 91       	ld	r19, X
    8316:	11 97       	sbiw	r26, 0x01	; 1
			Param->Pos[i] = Param->Pos[i+1];
    8318:	f9 01       	movw	r30, r18
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    831a:	48 17       	cp	r20, r24
    831c:	59 07       	cpc	r21, r25
    831e:	34 f4       	brge	.+12     	; 0x832c <Put_sDVal+0x124>
			Param->Pos[i] = Param->Pos[i+1];
    8320:	e4 0f       	add	r30, r20
    8322:	f5 1f       	adc	r31, r21
    8324:	81 81       	ldd	r24, Z+1	; 0x01
    8326:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8328:	6f 5f       	subi	r22, 0xFF	; 255
    832a:	e7 cf       	rjmp	.-50     	; 0x82fa <Put_sDVal+0xf2>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    832c:	e8 0f       	add	r30, r24
    832e:	f9 1f       	adc	r31, r25
    8330:	31 97       	sbiw	r30, 0x01	; 1
    8332:	2e e2       	ldi	r18, 0x2E	; 46
    8334:	20 83       	st	Z, r18
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8336:	13 96       	adiw	r26, 0x03	; 3
    8338:	2c 91       	ld	r18, X
    833a:	13 97       	sbiw	r26, 0x03	; 3
    833c:	82 2f       	mov	r24, r18
    833e:	90 e0       	ldi	r25, 0x00	; 0
    8340:	12 96       	adiw	r26, 0x02	; 2
    8342:	3c 91       	ld	r19, X
    8344:	12 97       	sbiw	r26, 0x02	; 2
    8346:	83 1b       	sub	r24, r19
    8348:	91 09       	sbc	r25, r1
    834a:	ed 91       	ld	r30, X+
    834c:	fc 91       	ld	r31, X
    834e:	e8 0f       	add	r30, r24
    8350:	f9 1f       	adc	r31, r25
    8352:	32 97       	sbiw	r30, 0x02	; 2
    8354:	80 81       	ld	r24, Z
		if(c ==' ' || c =='+' || c =='-'){
    8356:	80 32       	cpi	r24, 0x20	; 32
    8358:	21 f0       	breq	.+8      	; 0x8362 <Put_sDVal+0x15a>
    835a:	8b 32       	cpi	r24, 0x2B	; 43
    835c:	11 f0       	breq	.+4      	; 0x8362 <Put_sDVal+0x15a>
    835e:	8d 32       	cpi	r24, 0x2D	; 45
    8360:	d1 f5       	brne	.+116    	; 0x83d6 <Put_sDVal+0x1ce>
			for(uint8_t i=Param->Size-1; i>1; i--){
    8362:	21 50       	subi	r18, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8364:	40 e3       	ldi	r20, 0x30	; 48
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8366:	22 30       	cpi	r18, 0x02	; 2
    8368:	b0 f1       	brcs	.+108    	; 0x83d6 <Put_sDVal+0x1ce>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    836a:	82 2f       	mov	r24, r18
    836c:	90 e0       	ldi	r25, 0x00	; 0
    836e:	d5 01       	movw	r26, r10
    8370:	ed 91       	ld	r30, X+
    8372:	fc 91       	ld	r31, X
    8374:	e8 0f       	add	r30, r24
    8376:	f9 1f       	adc	r31, r25
    8378:	30 81       	ld	r19, Z
    837a:	30 32       	cpi	r19, 0x20	; 32
    837c:	21 f0       	breq	.+8      	; 0x8386 <Put_sDVal+0x17e>
    837e:	3b 32       	cpi	r19, 0x2B	; 43
    8380:	11 f0       	breq	.+4      	; 0x8386 <Put_sDVal+0x17e>
    8382:	3d 32       	cpi	r19, 0x2D	; 45
    8384:	09 f4       	brne	.+2      	; 0x8388 <Put_sDVal+0x180>
    8386:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    8388:	d5 01       	movw	r26, r10
    838a:	ed 91       	ld	r30, X+
    838c:	fc 91       	ld	r31, X
    838e:	11 97       	sbiw	r26, 0x01	; 1
    8390:	e8 0f       	add	r30, r24
    8392:	f9 1f       	adc	r31, r25
    8394:	30 81       	ld	r19, Z
    8396:	3e 32       	cpi	r19, 0x2E	; 46
    8398:	e1 f4       	brne	.+56     	; 0x83d2 <Put_sDVal+0x1ca>
					Param->Pos[i-1]='0';
    839a:	31 97       	sbiw	r30, 0x01	; 1
    839c:	20 e3       	ldi	r18, 0x30	; 48
    839e:	20 83       	st	Z, r18
					if(Val>0)Param->Pos[i-2]='+';
    83a0:	1c 14       	cp	r1, r12
    83a2:	1d 04       	cpc	r1, r13
    83a4:	1e 04       	cpc	r1, r14
    83a6:	1f 04       	cpc	r1, r15
    83a8:	3c f4       	brge	.+14     	; 0x83b8 <Put_sDVal+0x1b0>
    83aa:	ed 91       	ld	r30, X+
    83ac:	fc 91       	ld	r31, X
    83ae:	e8 0f       	add	r30, r24
    83b0:	f9 1f       	adc	r31, r25
    83b2:	32 97       	sbiw	r30, 0x02	; 2
    83b4:	8b e2       	ldi	r24, 0x2B	; 43
    83b6:	0b c0       	rjmp	.+22     	; 0x83ce <Put_sDVal+0x1c6>
					if(Val<0)Param->Pos[i-2]='-';
    83b8:	cd 28       	or	r12, r13
    83ba:	ce 28       	or	r12, r14
    83bc:	cf 28       	or	r12, r15
    83be:	59 f0       	breq	.+22     	; 0x83d6 <Put_sDVal+0x1ce>
    83c0:	d5 01       	movw	r26, r10
    83c2:	ed 91       	ld	r30, X+
    83c4:	fc 91       	ld	r31, X
    83c6:	e8 0f       	add	r30, r24
    83c8:	f9 1f       	adc	r31, r25
    83ca:	32 97       	sbiw	r30, 0x02	; 2
    83cc:	8d e2       	ldi	r24, 0x2D	; 45
    83ce:	80 83       	st	Z, r24
    83d0:	02 c0       	rjmp	.+4      	; 0x83d6 <Put_sDVal+0x1ce>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    83d2:	21 50       	subi	r18, 0x01	; 1
    83d4:	c8 cf       	rjmp	.-112    	; 0x8366 <Put_sDVal+0x15e>
				}
			}
		}
	}

}
    83d6:	27 96       	adiw	r28, 0x07	; 7
    83d8:	0f b6       	in	r0, 0x3f	; 63
    83da:	f8 94       	cli
    83dc:	de bf       	out	0x3e, r29	; 62
    83de:	0f be       	out	0x3f, r0	; 63
    83e0:	cd bf       	out	0x3d, r28	; 61
    83e2:	df 91       	pop	r29
    83e4:	cf 91       	pop	r28
    83e6:	1f 91       	pop	r17
    83e8:	0f 91       	pop	r16
    83ea:	ff 90       	pop	r15
    83ec:	ef 90       	pop	r14
    83ee:	df 90       	pop	r13
    83f0:	cf 90       	pop	r12
    83f2:	bf 90       	pop	r11
    83f4:	af 90       	pop	r10
    83f6:	08 95       	ret

000083f8 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    83f8:	af 92       	push	r10
    83fa:	bf 92       	push	r11
    83fc:	cf 92       	push	r12
    83fe:	df 92       	push	r13
    8400:	ef 92       	push	r14
    8402:	ff 92       	push	r15
    8404:	0f 93       	push	r16
    8406:	1f 93       	push	r17
    8408:	cf 93       	push	r28
    840a:	df 93       	push	r29
    840c:	cd b7       	in	r28, 0x3d	; 61
    840e:	de b7       	in	r29, 0x3e	; 62
    8410:	2c 97       	sbiw	r28, 0x0c	; 12
    8412:	0f b6       	in	r0, 0x3f	; 63
    8414:	f8 94       	cli
    8416:	de bf       	out	0x3e, r29	; 62
    8418:	0f be       	out	0x3f, r0	; 63
    841a:	cd bf       	out	0x3d, r28	; 61
    841c:	6b 01       	movw	r12, r22
    841e:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    8420:	8b 01       	movw	r16, r22
    8422:	9c 01       	movw	r18, r24
    8424:	00 95       	com	r16
    8426:	10 95       	com	r17
    8428:	20 95       	com	r18
    842a:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    842c:	fa 01       	movw	r30, r20
    842e:	84 81       	ldd	r24, Z+4	; 0x04
    8430:	95 81       	ldd	r25, Z+5	; 0x05
    8432:	00 97       	sbiw	r24, 0x00	; 0
    8434:	79 f0       	breq	.+30     	; 0x8454 <Put_zDVal+0x5c>
    8436:	02 30       	cpi	r16, 0x02	; 2
    8438:	11 05       	cpc	r17, r1
    843a:	21 05       	cpc	r18, r1
    843c:	31 05       	cpc	r19, r1
    843e:	50 f4       	brcc	.+20     	; 0x8454 <Put_zDVal+0x5c>
		Param->Txt += Idx;
    8440:	00 0f       	add	r16, r16
    8442:	11 1f       	adc	r17, r17
    8444:	08 0f       	add	r16, r24
    8446:	19 1f       	adc	r17, r25
    8448:	15 83       	std	Z+5, r17	; 0x05
    844a:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    844c:	ca 01       	movw	r24, r20
    844e:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
		return;
    8452:	54 c0       	rjmp	.+168    	; 0x84fc <Put_zDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    8454:	fa 01       	movw	r30, r20
    8456:	93 81       	ldd	r25, Z+3	; 0x03
    8458:	9a 30       	cpi	r25, 0x0A	; 10
    845a:	81 f4       	brne	.+32     	; 0x847c <Put_zDVal+0x84>
    845c:	82 81       	ldd	r24, Z+2	; 0x02
    845e:	81 11       	cpse	r24, r1
    8460:	0d c0       	rjmp	.+26     	; 0x847c <Put_zDVal+0x84>
		sprintf(Param->Pos, "%010lu", Val);
    8462:	ff 92       	push	r15
    8464:	ef 92       	push	r14
    8466:	df 92       	push	r13
    8468:	cf 92       	push	r12
    846a:	8f e5       	ldi	r24, 0x5F	; 95
    846c:	91 e0       	ldi	r25, 0x01	; 1
    846e:	9f 93       	push	r25
    8470:	8f 93       	push	r24
    8472:	81 81       	ldd	r24, Z+1	; 0x01
    8474:	8f 93       	push	r24
    8476:	80 81       	ld	r24, Z
    8478:	8f 93       	push	r24
    847a:	39 c0       	rjmp	.+114    	; 0x84ee <Put_zDVal+0xf6>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    847c:	8c e0       	ldi	r24, 0x0C	; 12
    847e:	e6 e6       	ldi	r30, 0x66	; 102
    8480:	f1 e0       	ldi	r31, 0x01	; 1
    8482:	8e 01       	movw	r16, r28
    8484:	0f 5f       	subi	r16, 0xFF	; 255
    8486:	1f 4f       	sbci	r17, 0xFF	; 255
    8488:	d8 01       	movw	r26, r16
    848a:	01 90       	ld	r0, Z+
    848c:	0d 92       	st	X+, r0
    848e:	8a 95       	dec	r24
    8490:	e1 f7       	brne	.-8      	; 0x848a <Put_zDVal+0x92>
	Format[2] = '0'+Param->Size;
    8492:	90 5d       	subi	r25, 0xD0	; 208
    8494:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    8496:	fa 01       	movw	r30, r20
    8498:	82 81       	ldd	r24, Z+2	; 0x02
    849a:	a1 80       	ldd	r10, Z+1	; 0x01
    849c:	b0 80       	ld	r11, Z
    849e:	88 23       	and	r24, r24
    84a0:	e9 f0       	breq	.+58     	; 0x84dc <Put_zDVal+0xe4>
		Format[2] -= Param->Prec+1;
    84a2:	98 1b       	sub	r25, r24
    84a4:	91 50       	subi	r25, 0x01	; 1
    84a6:	9b 83       	std	Y+3, r25	; 0x03
		Format[8] = '0'+Param->Prec;
    84a8:	90 e3       	ldi	r25, 0x30	; 48
    84aa:	98 0f       	add	r25, r24
    84ac:	99 87       	std	Y+9, r25	; 0x09
		uint32_t Div=PowL10(Param->Prec);
    84ae:	0e 94 8e 3c 	call	0x791c	; 0x791c <PowL10>
    84b2:	9b 01       	movw	r18, r22
    84b4:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    84b6:	c7 01       	movw	r24, r14
    84b8:	b6 01       	movw	r22, r12
    84ba:	0e 94 cd 74 	call	0xe99a	; 0xe99a <__udivmodsi4>
    84be:	9f 93       	push	r25
    84c0:	8f 93       	push	r24
    84c2:	7f 93       	push	r23
    84c4:	6f 93       	push	r22
    84c6:	5f 93       	push	r21
    84c8:	4f 93       	push	r20
    84ca:	3f 93       	push	r19
    84cc:	2f 93       	push	r18
    84ce:	1f 93       	push	r17
    84d0:	0f 93       	push	r16
    84d2:	af 92       	push	r10
    84d4:	bf 92       	push	r11
    84d6:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    84da:	0b c0       	rjmp	.+22     	; 0x84f2 <Put_zDVal+0xfa>
	}
	else {
		Format[5] = '\0';
    84dc:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    84de:	ff 92       	push	r15
    84e0:	ef 92       	push	r14
    84e2:	df 92       	push	r13
    84e4:	cf 92       	push	r12
    84e6:	1f 93       	push	r17
    84e8:	0f 93       	push	r16
    84ea:	af 92       	push	r10
    84ec:	bf 92       	push	r11
    84ee:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    84f2:	0f b6       	in	r0, 0x3f	; 63
    84f4:	f8 94       	cli
    84f6:	de bf       	out	0x3e, r29	; 62
    84f8:	0f be       	out	0x3f, r0	; 63
    84fa:	cd bf       	out	0x3d, r28	; 61
	}
}
    84fc:	2c 96       	adiw	r28, 0x0c	; 12
    84fe:	0f b6       	in	r0, 0x3f	; 63
    8500:	f8 94       	cli
    8502:	de bf       	out	0x3e, r29	; 62
    8504:	0f be       	out	0x3f, r0	; 63
    8506:	cd bf       	out	0x3d, r28	; 61
    8508:	df 91       	pop	r29
    850a:	cf 91       	pop	r28
    850c:	1f 91       	pop	r17
    850e:	0f 91       	pop	r16
    8510:	ff 90       	pop	r15
    8512:	ef 90       	pop	r14
    8514:	df 90       	pop	r13
    8516:	cf 90       	pop	r12
    8518:	bf 90       	pop	r11
    851a:	af 90       	pop	r10
    851c:	08 95       	ret

0000851e <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    851e:	1f 93       	push	r17
    8520:	cf 93       	push	r28
    8522:	df 93       	push	r29
    8524:	cd b7       	in	r28, 0x3d	; 61
    8526:	de b7       	in	r29, 0x3e	; 62
    8528:	27 97       	sbiw	r28, 0x07	; 7
    852a:	0f b6       	in	r0, 0x3f	; 63
    852c:	f8 94       	cli
    852e:	de bf       	out	0x3e, r29	; 62
    8530:	0f be       	out	0x3f, r0	; 63
    8532:	cd bf       	out	0x3d, r28	; 61
	char Format[] = "%+ . f";
    8534:	17 e0       	ldi	r17, 0x07	; 7
    8536:	e2 e7       	ldi	r30, 0x72	; 114
    8538:	f1 e0       	ldi	r31, 0x01	; 1
    853a:	9e 01       	movw	r18, r28
    853c:	2f 5f       	subi	r18, 0xFF	; 255
    853e:	3f 4f       	sbci	r19, 0xFF	; 255
    8540:	d9 01       	movw	r26, r18
    8542:	01 90       	ld	r0, Z+
    8544:	0d 92       	st	X+, r0
    8546:	1a 95       	dec	r17
    8548:	e1 f7       	brne	.-8      	; 0x8542 <Put_FFVal+0x24>
	Format[2] = '0'+Param->Size;
    854a:	da 01       	movw	r26, r20
    854c:	13 96       	adiw	r26, 0x03	; 3
    854e:	ec 91       	ld	r30, X
    8550:	13 97       	sbiw	r26, 0x03	; 3
    8552:	e0 5d       	subi	r30, 0xD0	; 208
    8554:	eb 83       	std	Y+3, r30	; 0x03
	Format[4] = '0'+Param->Prec;	
    8556:	12 96       	adiw	r26, 0x02	; 2
    8558:	ec 91       	ld	r30, X
    855a:	12 97       	sbiw	r26, 0x02	; 2
    855c:	e0 5d       	subi	r30, 0xD0	; 208
    855e:	ed 83       	std	Y+5, r30	; 0x05
	sprintf(Param->Pos, Format, Val);
    8560:	9f 93       	push	r25
    8562:	8f 93       	push	r24
    8564:	7f 93       	push	r23
    8566:	6f 93       	push	r22
    8568:	3f 93       	push	r19
    856a:	2f 93       	push	r18
    856c:	11 96       	adiw	r26, 0x01	; 1
    856e:	8c 91       	ld	r24, X
    8570:	11 97       	sbiw	r26, 0x01	; 1
    8572:	8f 93       	push	r24
    8574:	8c 91       	ld	r24, X
    8576:	8f 93       	push	r24
    8578:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    857c:	0f b6       	in	r0, 0x3f	; 63
    857e:	f8 94       	cli
    8580:	de bf       	out	0x3e, r29	; 62
    8582:	0f be       	out	0x3f, r0	; 63
    8584:	cd bf       	out	0x3d, r28	; 61
}
    8586:	27 96       	adiw	r28, 0x07	; 7
    8588:	0f b6       	in	r0, 0x3f	; 63
    858a:	f8 94       	cli
    858c:	de bf       	out	0x3e, r29	; 62
    858e:	0f be       	out	0x3f, r0	; 63
    8590:	cd bf       	out	0x3d, r28	; 61
    8592:	df 91       	pop	r29
    8594:	cf 91       	pop	r28
    8596:	1f 91       	pop	r17
    8598:	08 95       	ret

0000859a <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    859a:	0f 93       	push	r16
    859c:	1f 93       	push	r17
    859e:	cf 93       	push	r28
    85a0:	df 93       	push	r29
    85a2:	cd b7       	in	r28, 0x3d	; 61
    85a4:	de b7       	in	r29, 0x3e	; 62
    85a6:	28 97       	sbiw	r28, 0x08	; 8
    85a8:	0f b6       	in	r0, 0x3f	; 63
    85aa:	f8 94       	cli
    85ac:	de bf       	out	0x3e, r29	; 62
    85ae:	0f be       	out	0x3f, r0	; 63
    85b0:	cd bf       	out	0x3d, r28	; 61
	if(Param->Size < 10){
    85b2:	da 01       	movw	r26, r20
    85b4:	13 96       	adiw	r26, 0x03	; 3
    85b6:	1c 91       	ld	r17, X
    85b8:	9e 01       	movw	r18, r28
    85ba:	2f 5f       	subi	r18, 0xFF	; 255
    85bc:	3f 4f       	sbci	r19, 0xFF	; 255
    85be:	1a 30       	cpi	r17, 0x0A	; 10
    85c0:	88 f4       	brcc	.+34     	; 0x85e4 <Put_GFVal+0x4a>
		char Format[] = "%+ . g";
    85c2:	07 e0       	ldi	r16, 0x07	; 7
    85c4:	e9 e7       	ldi	r30, 0x79	; 121
    85c6:	f1 e0       	ldi	r31, 0x01	; 1
    85c8:	d9 01       	movw	r26, r18
    85ca:	01 90       	ld	r0, Z+
    85cc:	0d 92       	st	X+, r0
    85ce:	0a 95       	dec	r16
    85d0:	e1 f7       	brne	.-8      	; 0x85ca <Put_GFVal+0x30>
		Format[2] = '0'+Param->Size;
    85d2:	10 5d       	subi	r17, 0xD0	; 208
    85d4:	1b 83       	std	Y+3, r17	; 0x03
		Format[4] = '0'+Param->Prec;
    85d6:	da 01       	movw	r26, r20
    85d8:	12 96       	adiw	r26, 0x02	; 2
    85da:	ec 91       	ld	r30, X
    85dc:	12 97       	sbiw	r26, 0x02	; 2
    85de:	e0 5d       	subi	r30, 0xD0	; 208
    85e0:	ed 83       	std	Y+5, r30	; 0x05
    85e2:	10 c0       	rjmp	.+32     	; 0x8604 <Put_GFVal+0x6a>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    85e4:	08 e0       	ldi	r16, 0x08	; 8
    85e6:	e0 e8       	ldi	r30, 0x80	; 128
    85e8:	f1 e0       	ldi	r31, 0x01	; 1
    85ea:	d9 01       	movw	r26, r18
    85ec:	01 90       	ld	r0, Z+
    85ee:	0d 92       	st	X+, r0
    85f0:	0a 95       	dec	r16
    85f2:	e1 f7       	brne	.-8      	; 0x85ec <Put_GFVal+0x52>
		Format[3] = '0'+Param->Size-10;	
    85f4:	1a 5d       	subi	r17, 0xDA	; 218
    85f6:	1c 83       	std	Y+4, r17	; 0x04
		Format[5] = '0'+Param->Prec;
    85f8:	da 01       	movw	r26, r20
    85fa:	12 96       	adiw	r26, 0x02	; 2
    85fc:	ec 91       	ld	r30, X
    85fe:	12 97       	sbiw	r26, 0x02	; 2
    8600:	e0 5d       	subi	r30, 0xD0	; 208
    8602:	ee 83       	std	Y+6, r30	; 0x06
		sprintf(Param->Pos, Format, Val);
    8604:	9f 93       	push	r25
    8606:	8f 93       	push	r24
    8608:	7f 93       	push	r23
    860a:	6f 93       	push	r22
    860c:	3f 93       	push	r19
    860e:	2f 93       	push	r18
    8610:	11 96       	adiw	r26, 0x01	; 1
    8612:	8c 91       	ld	r24, X
    8614:	11 97       	sbiw	r26, 0x01	; 1
    8616:	8f 93       	push	r24
    8618:	8c 91       	ld	r24, X
    861a:	8f 93       	push	r24
    861c:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    8620:	0f b6       	in	r0, 0x3f	; 63
    8622:	f8 94       	cli
    8624:	de bf       	out	0x3e, r29	; 62
    8626:	0f be       	out	0x3f, r0	; 63
    8628:	cd bf       	out	0x3d, r28	; 61
	}
}
    862a:	28 96       	adiw	r28, 0x08	; 8
    862c:	0f b6       	in	r0, 0x3f	; 63
    862e:	f8 94       	cli
    8630:	de bf       	out	0x3e, r29	; 62
    8632:	0f be       	out	0x3f, r0	; 63
    8634:	cd bf       	out	0x3d, r28	; 61
    8636:	df 91       	pop	r29
    8638:	cf 91       	pop	r28
    863a:	1f 91       	pop	r17
    863c:	0f 91       	pop	r16
    863e:	08 95       	ret

00008640 <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8640:	cf 92       	push	r12
    8642:	df 92       	push	r13
    8644:	ef 92       	push	r14
    8646:	ff 92       	push	r15
    8648:	0f 93       	push	r16
    864a:	1f 93       	push	r17
    864c:	cf 93       	push	r28
    864e:	df 93       	push	r29
    8650:	cd b7       	in	r28, 0x3d	; 61
    8652:	de b7       	in	r29, 0x3e	; 62
    8654:	29 97       	sbiw	r28, 0x09	; 9
    8656:	0f b6       	in	r0, 0x3f	; 63
    8658:	f8 94       	cli
    865a:	de bf       	out	0x3e, r29	; 62
    865c:	0f be       	out	0x3f, r0	; 63
    865e:	cd bf       	out	0x3d, r28	; 61
    8660:	d8 2e       	mov	r13, r24
    8662:	c9 2e       	mov	r12, r25
    8664:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8666:	fb 01       	movw	r30, r22
    8668:	23 81       	ldd	r18, Z+3	; 0x03
    866a:	1f 92       	push	r1
    866c:	2f 93       	push	r18
    866e:	1f 92       	push	r1
    8670:	2f 93       	push	r18
    8672:	28 e8       	ldi	r18, 0x88	; 136
    8674:	31 e0       	ldi	r19, 0x01	; 1
    8676:	3f 93       	push	r19
    8678:	2f 93       	push	r18
    867a:	8e 01       	movw	r16, r28
    867c:	0f 5f       	subi	r16, 0xFF	; 255
    867e:	1f 4f       	sbci	r17, 0xFF	; 255
    8680:	1f 93       	push	r17
    8682:	0f 93       	push	r16
    8684:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
	sprintf(Param->Pos, Format, Val);
    8688:	cf 92       	push	r12
    868a:	df 92       	push	r13
    868c:	1f 93       	push	r17
    868e:	0f 93       	push	r16
    8690:	f7 01       	movw	r30, r14
    8692:	81 81       	ldd	r24, Z+1	; 0x01
    8694:	8f 93       	push	r24
    8696:	80 81       	ld	r24, Z
    8698:	8f 93       	push	r24
    869a:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    869e:	0f b6       	in	r0, 0x3f	; 63
    86a0:	f8 94       	cli
    86a2:	de bf       	out	0x3e, r29	; 62
    86a4:	0f be       	out	0x3f, r0	; 63
    86a6:	cd bf       	out	0x3d, r28	; 61
}
    86a8:	29 96       	adiw	r28, 0x09	; 9
    86aa:	0f b6       	in	r0, 0x3f	; 63
    86ac:	f8 94       	cli
    86ae:	de bf       	out	0x3e, r29	; 62
    86b0:	0f be       	out	0x3f, r0	; 63
    86b2:	cd bf       	out	0x3d, r28	; 61
    86b4:	df 91       	pop	r29
    86b6:	cf 91       	pop	r28
    86b8:	1f 91       	pop	r17
    86ba:	0f 91       	pop	r16
    86bc:	ff 90       	pop	r15
    86be:	ef 90       	pop	r14
    86c0:	df 90       	pop	r13
    86c2:	cf 90       	pop	r12
    86c4:	08 95       	ret

000086c6 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    86c6:	80 91 25 0b 	lds	r24, 0x0B25
    86ca:	90 91 26 0b 	lds	r25, 0x0B26
    86ce:	89 2b       	or	r24, r25
    86d0:	31 f0       	breq	.+12     	; 0x86de <HideMsg+0x18>
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    86d2:	10 92 26 0b 	sts	0x0B26, r1
    86d6:	10 92 25 0b 	sts	0x0B25, r1
		return 1;
    86da:	81 e0       	ldi	r24, 0x01	; 1
    86dc:	08 95       	ret
	}
	else
		return 0;
    86de:	80 e0       	ldi	r24, 0x00	; 0
}
    86e0:	08 95       	ret

000086e2 <WebInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    86e2:	80 91 0f 01 	lds	r24, 0x010F
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    86e6:	80 93 41 09 	sts	0x0941, r24
	VacantTimer8Sys += n;
    86ea:	92 e0       	ldi	r25, 0x02	; 2
    86ec:	98 0f       	add	r25, r24
    86ee:	90 93 0f 01 	sts	0x010F, r25
    86f2:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    86f4:	80 93 44 09 	sts	0x0944, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    86f8:	80 91 0e 01 	lds	r24, 0x010E
	TD_FlowDelay =  Timer16SysAlloc(1);
    86fc:	80 93 4f 09 	sts	0x094F, r24
	VacantTimer16Sys += n;
    8700:	92 e0       	ldi	r25, 0x02	; 2
    8702:	98 0f       	add	r25, r24
    8704:	90 93 0e 01 	sts	0x010E, r25
    8708:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    870a:	80 93 6a 09 	sts	0x096A, r24
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    870e:	0e 94 97 2a 	call	0x552e	; 0x552e <Timer32Alloc>
    8712:	80 93 1c 06 	sts	0x061C, r24
	TD_WebSessTimeout	= Timer32Alloc();
    8716:	0e 94 97 2a 	call	0x552e	; 0x552e <Timer32Alloc>
    871a:	80 93 68 09 	sts	0x0968, r24
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    871e:	80 91 12 01 	lds	r24, 0x0112
    8722:	88 31       	cpi	r24, 0x18	; 24
    8724:	40 f4       	brcc	.+16     	; 0x8736 <WebInit+0x54>
    8726:	80 91 11 01 	lds	r24, 0x0111
    872a:	88 32       	cpi	r24, 0x28	; 40
    872c:	20 f4       	brcc	.+8      	; 0x8736 <WebInit+0x54>
    872e:	80 91 10 01 	lds	r24, 0x0110
    8732:	80 32       	cpi	r24, 0x20	; 32
    8734:	40 f0       	brcs	.+16     	; 0x8746 <WebInit+0x64>

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
    8736:	0e 94 63 43 	call	0x86c6	; 0x86c6 <HideMsg>
	CurrMsg = Msg;
    873a:	83 ef       	ldi	r24, 0xF3	; 243
    873c:	9c e4       	ldi	r25, 0x4C	; 76
    873e:	90 93 26 0b 	sts	0x0B26, r25
    8742:	80 93 25 0b 	sts	0x0B25, r24
    8746:	08 95       	ret

00008748 <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8748:	0f 93       	push	r16
    874a:	1f 93       	push	r17
    874c:	cf 93       	push	r28
    874e:	df 93       	push	r29
    8750:	8b 01       	movw	r16, r22
	if(prb(&Field->Prec)){
    8752:	ec 01       	movw	r28, r24
    8754:	2f 96       	adiw	r28, 0x0f	; 15

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8756:	fe 01       	movw	r30, r28
    8758:	84 91       	lpm	r24, Z
    875a:	88 23       	and	r24, r24
    875c:	69 f1       	breq	.+90     	; 0x87b8 <WebPresicionHanler+0x70>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    875e:	6e e2       	ldi	r22, 0x2E	; 46
    8760:	70 e0       	ldi	r23, 0x00	; 0
    8762:	c8 01       	movw	r24, r16
    8764:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
		if(p==NULL){
    8768:	00 97       	sbiw	r24, 0x00	; 0
    876a:	29 f4       	brne	.+10     	; 0x8776 <WebPresicionHanler+0x2e>
			p = strchr(BufStr,' ');	//else seek for first space
    876c:	60 e2       	ldi	r22, 0x20	; 32
    876e:	70 e0       	ldi	r23, 0x00	; 0
    8770:	c8 01       	movw	r24, r16
    8772:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8776:	dc 01       	movw	r26, r24
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    8778:	40 e3       	ldi	r20, 0x30	; 48
    877a:	fe 01       	movw	r30, r28
    877c:	24 91       	lpm	r18, Z
    877e:	3a 2f       	mov	r19, r26
    8780:	38 1b       	sub	r19, r24
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    8782:	32 17       	cp	r19, r18
    8784:	c8 f4       	brcc	.+50     	; 0x87b8 <WebPresicionHanler+0x70>
			if(*p == ' ') *p='0'; 
    8786:	2c 91       	ld	r18, X
    8788:	20 32       	cpi	r18, 0x20	; 32
    878a:	09 f4       	brne	.+2      	; 0x878e <WebPresicionHanler+0x46>
    878c:	4c 93       	st	X, r20
			if(*p == '.'){
    878e:	5c 91       	ld	r21, X
    8790:	5e 32       	cpi	r21, 0x2E	; 46
    8792:	81 f4       	brne	.+32     	; 0x87b4 <WebPresicionHanler+0x6c>
				if(isdigit(*(p+1))){
    8794:	11 96       	adiw	r26, 0x01	; 1
    8796:	6c 91       	ld	r22, X
    8798:	11 97       	sbiw	r26, 0x01	; 1
    879a:	26 2f       	mov	r18, r22
    879c:	30 e0       	ldi	r19, 0x00	; 0
    879e:	20 53       	subi	r18, 0x30	; 48
    87a0:	31 09       	sbc	r19, r1
    87a2:	2a 30       	cpi	r18, 0x0A	; 10
    87a4:	31 05       	cpc	r19, r1
    87a6:	28 f4       	brcc	.+10     	; 0x87b2 <WebPresicionHanler+0x6a>
					*p= *(p+1);
    87a8:	6c 93       	st	X, r22
					*(p+1) = '.';
    87aa:	11 96       	adiw	r26, 0x01	; 1
    87ac:	5c 93       	st	X, r21
    87ae:	11 97       	sbiw	r26, 0x01	; 1
    87b0:	01 c0       	rjmp	.+2      	; 0x87b4 <WebPresicionHanler+0x6c>
				}
				else *p='0'; 
    87b2:	4c 93       	st	X, r20
			}
			p++;
    87b4:	11 96       	adiw	r26, 0x01	; 1
    87b6:	e1 cf       	rjmp	.-62     	; 0x877a <WebPresicionHanler+0x32>
		}
	}
	
}
    87b8:	df 91       	pop	r29
    87ba:	cf 91       	pop	r28
    87bc:	1f 91       	pop	r17
    87be:	0f 91       	pop	r16
    87c0:	08 95       	ret

000087c2 <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    87c2:	2f 92       	push	r2
    87c4:	3f 92       	push	r3
    87c6:	4f 92       	push	r4
    87c8:	5f 92       	push	r5
    87ca:	6f 92       	push	r6
    87cc:	7f 92       	push	r7
    87ce:	8f 92       	push	r8
    87d0:	9f 92       	push	r9
    87d2:	af 92       	push	r10
    87d4:	bf 92       	push	r11
    87d6:	cf 92       	push	r12
    87d8:	df 92       	push	r13
    87da:	ef 92       	push	r14
    87dc:	ff 92       	push	r15
    87de:	0f 93       	push	r16
    87e0:	1f 93       	push	r17
    87e2:	cf 93       	push	r28
    87e4:	df 93       	push	r29
    87e6:	cd b7       	in	r28, 0x3d	; 61
    87e8:	de b7       	in	r29, 0x3e	; 62
    87ea:	2e 97       	sbiw	r28, 0x0e	; 14
    87ec:	0f b6       	in	r0, 0x3f	; 63
    87ee:	f8 94       	cli
    87f0:	de bf       	out	0x3e, r29	; 62
    87f2:	0f be       	out	0x3f, r0	; 63
    87f4:	cd bf       	out	0x3d, r28	; 61
    87f6:	6c 01       	movw	r12, r24
    87f8:	8b 01       	movw	r16, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    87fa:	2d b7       	in	r18, 0x3d	; 61
    87fc:	3e b7       	in	r19, 0x3e	; 62
    87fe:	3e 87       	std	Y+14, r19	; 0x0e
    8800:	2d 87       	std	Y+13, r18	; 0x0d
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
    8802:	fc 01       	movw	r30, r24
    8804:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8806:	e5 90       	lpm	r14, Z+
    8808:	f4 90       	lpm	r15, Z
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    880a:	1c 01       	movw	r2, r24
    880c:	3f e0       	ldi	r19, 0x0F	; 15
    880e:	23 0e       	add	r2, r19
    8810:	31 1c       	adc	r3, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8812:	f1 01       	movw	r30, r2
    8814:	84 91       	lpm	r24, Z
    8816:	98 2f       	mov	r25, r24
    8818:	97 70       	andi	r25, 0x07	; 7
    881a:	21 e0       	ldi	r18, 0x01	; 1
    881c:	30 e0       	ldi	r19, 0x00	; 0
    881e:	02 c0       	rjmp	.+4      	; 0x8824 <WebBuf2Field+0x62>
    8820:	22 0f       	add	r18, r18
    8822:	33 1f       	adc	r19, r19
    8824:	9a 95       	dec	r25
    8826:	e2 f7       	brpl	.-8      	; 0x8820 <WebBuf2Field+0x5e>
    8828:	3a 87       	std	Y+10, r19	; 0x0a
    882a:	29 87       	std	Y+9, r18	; 0x09
    882c:	86 95       	lsr	r24
    882e:	86 95       	lsr	r24
    8830:	86 95       	lsr	r24
    8832:	97 01       	movw	r18, r14
    8834:	28 0f       	add	r18, r24
    8836:	31 1d       	adc	r19, r1
    8838:	3c 87       	std	Y+12, r19	; 0x0c
    883a:	2b 87       	std	Y+11, r18	; 0x0b
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);
    883c:	c6 01       	movw	r24, r12
    883e:	03 96       	adiw	r24, 0x03	; 3
    8840:	0e 94 3e 29 	call	0x527c	; 0x527c <prd>
    8844:	2b 01       	movw	r4, r22
    8846:	3c 01       	movw	r6, r24
    8848:	c6 01       	movw	r24, r12
    884a:	07 96       	adiw	r24, 0x07	; 7
    884c:	0e 94 3e 29 	call	0x527c	; 0x527c <prd>
    8850:	4b 01       	movw	r8, r22
    8852:	5c 01       	movw	r10, r24

	uint32_t Temp=0;
    8854:	1d 82       	std	Y+5, r1	; 0x05
    8856:	1e 82       	std	Y+6, r1	; 0x06
    8858:	1f 82       	std	Y+7, r1	; 0x07
    885a:	18 86       	std	Y+8, r1	; 0x08
	float fTemp=0;
    885c:	19 82       	std	Y+1, r1	; 0x01
    885e:	1a 82       	std	Y+2, r1	; 0x02
    8860:	1b 82       	std	Y+3, r1	; 0x03
    8862:	1c 82       	std	Y+4, r1	; 0x04
    8864:	f6 01       	movw	r30, r12
    8866:	84 91       	lpm	r24, Z


	switch(prb(&Field->Type)) {
    8868:	90 e0       	ldi	r25, 0x00	; 0
    886a:	83 32       	cpi	r24, 0x23	; 35
    886c:	91 05       	cpc	r25, r1
    886e:	08 f0       	brcs	.+2      	; 0x8872 <WebBuf2Field+0xb0>
    8870:	f0 c2       	rjmp	.+1504   	; 0x8e52 <WebBuf2Field+0x690>
    8872:	fc 01       	movw	r30, r24
    8874:	ea 59       	subi	r30, 0x9A	; 154
    8876:	ff 4f       	sbci	r31, 0xFF	; 255
    8878:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    887c:	b8 01       	movw	r22, r16
    887e:	c6 01       	movw	r24, r12
    8880:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    8884:	ce 01       	movw	r24, r28
    8886:	05 96       	adiw	r24, 0x05	; 5
    8888:	9f 93       	push	r25
    888a:	8f 93       	push	r24
    888c:	82 e9       	ldi	r24, 0x92	; 146
    888e:	91 e0       	ldi	r25, 0x01	; 1
    8890:	9f 93       	push	r25
    8892:	8f 93       	push	r24
    8894:	1f 93       	push	r17
    8896:	0f 93       	push	r16
    8898:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		SetField(Temp, uint8_t);
    889c:	8d 81       	ldd	r24, Y+5	; 0x05
    889e:	9e 81       	ldd	r25, Y+6	; 0x06
    88a0:	af 81       	ldd	r26, Y+7	; 0x07
    88a2:	b8 85       	ldd	r27, Y+8	; 0x08
    88a4:	0f 90       	pop	r0
    88a6:	0f 90       	pop	r0
    88a8:	0f 90       	pop	r0
    88aa:	0f 90       	pop	r0
    88ac:	0f 90       	pop	r0
    88ae:	0f 90       	pop	r0
    88b0:	b5 01       	movw	r22, r10
    88b2:	a4 01       	movw	r20, r8
    88b4:	55 27       	eor	r21, r21
    88b6:	66 27       	eor	r22, r22
    88b8:	77 27       	eor	r23, r23
    88ba:	48 17       	cp	r20, r24
    88bc:	59 07       	cpc	r21, r25
    88be:	6a 07       	cpc	r22, r26
    88c0:	7b 07       	cpc	r23, r27
    88c2:	08 f4       	brcc	.+2      	; 0x88c6 <WebBuf2Field+0x104>
    88c4:	5f c0       	rjmp	.+190    	; 0x8984 <WebBuf2Field+0x1c2>
    88c6:	b3 01       	movw	r22, r6
    88c8:	a2 01       	movw	r20, r4
    88ca:	55 27       	eor	r21, r21
    88cc:	66 27       	eor	r22, r22
    88ce:	77 27       	eor	r23, r23
    88d0:	61 c0       	rjmp	.+194    	; 0x8994 <WebBuf2Field+0x1d2>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    88d2:	b8 01       	movw	r22, r16
    88d4:	c6 01       	movw	r24, r12
    88d6:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    88da:	ce 01       	movw	r24, r28
    88dc:	05 96       	adiw	r24, 0x05	; 5
    88de:	9f 93       	push	r25
    88e0:	8f 93       	push	r24
    88e2:	82 e9       	ldi	r24, 0x92	; 146
    88e4:	91 e0       	ldi	r25, 0x01	; 1
    88e6:	9f 93       	push	r25
    88e8:	8f 93       	push	r24
    88ea:	1f 93       	push	r17
    88ec:	0f 93       	push	r16
    88ee:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    88f2:	0f 90       	pop	r0
    88f4:	0f 90       	pop	r0
    88f6:	0f 90       	pop	r0
    88f8:	0f 90       	pop	r0
    88fa:	0f 90       	pop	r0
    88fc:	0f 90       	pop	r0
    88fe:	01 97       	sbiw	r24, 0x01	; 1
    8900:	09 f0       	breq	.+2      	; 0x8904 <WebBuf2Field+0x142>
    8902:	a7 c2       	rjmp	.+1358   	; 0x8e52 <WebBuf2Field+0x690>
			SetEEField(Temp, uint8_t, uint8_t, b);
    8904:	6d 81       	ldd	r22, Y+5	; 0x05
    8906:	7e 81       	ldd	r23, Y+6	; 0x06
    8908:	8f 81       	ldd	r24, Y+7	; 0x07
    890a:	98 85       	ldd	r25, Y+8	; 0x08
    890c:	95 01       	movw	r18, r10
    890e:	84 01       	movw	r16, r8
    8910:	11 27       	eor	r17, r17
    8912:	22 27       	eor	r18, r18
    8914:	33 27       	eor	r19, r19
    8916:	06 17       	cp	r16, r22
    8918:	17 07       	cpc	r17, r23
    891a:	28 07       	cpc	r18, r24
    891c:	39 07       	cpc	r19, r25
    891e:	08 f4       	brcc	.+2      	; 0x8922 <WebBuf2Field+0x160>
    8920:	5e c0       	rjmp	.+188    	; 0x89de <WebBuf2Field+0x21c>
    8922:	93 01       	movw	r18, r6
    8924:	82 01       	movw	r16, r4
    8926:	11 27       	eor	r17, r17
    8928:	22 27       	eor	r18, r18
    892a:	33 27       	eor	r19, r19
    892c:	60 17       	cp	r22, r16
    892e:	71 07       	cpc	r23, r17
    8930:	82 07       	cpc	r24, r18
    8932:	93 07       	cpc	r25, r19
    8934:	08 f0       	brcs	.+2      	; 0x8938 <WebBuf2Field+0x176>
    8936:	d7 c1       	rjmp	.+942    	; 0x8ce6 <WebBuf2Field+0x524>
    8938:	d3 c1       	rjmp	.+934    	; 0x8ce0 <WebBuf2Field+0x51e>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    893a:	b8 01       	movw	r22, r16
    893c:	c6 01       	movw	r24, r12
    893e:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    8942:	ce 01       	movw	r24, r28
    8944:	05 96       	adiw	r24, 0x05	; 5
    8946:	9f 93       	push	r25
    8948:	8f 93       	push	r24
    894a:	87 e9       	ldi	r24, 0x97	; 151
    894c:	91 e0       	ldi	r25, 0x01	; 1
    894e:	9f 93       	push	r25
    8950:	8f 93       	push	r24
    8952:	1f 93       	push	r17
    8954:	0f 93       	push	r16
    8956:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		SetField(Temp, int8_t);
    895a:	8d 81       	ldd	r24, Y+5	; 0x05
    895c:	9e 81       	ldd	r25, Y+6	; 0x06
    895e:	af 81       	ldd	r26, Y+7	; 0x07
    8960:	b8 85       	ldd	r27, Y+8	; 0x08
    8962:	0f 90       	pop	r0
    8964:	0f 90       	pop	r0
    8966:	0f 90       	pop	r0
    8968:	0f 90       	pop	r0
    896a:	0f 90       	pop	r0
    896c:	0f 90       	pop	r0
    896e:	48 2d       	mov	r20, r8
    8970:	55 27       	eor	r21, r21
    8972:	47 fd       	sbrc	r20, 7
    8974:	50 95       	com	r21
    8976:	65 2f       	mov	r22, r21
    8978:	75 2f       	mov	r23, r21
    897a:	48 17       	cp	r20, r24
    897c:	59 07       	cpc	r21, r25
    897e:	6a 07       	cpc	r22, r26
    8980:	7b 07       	cpc	r23, r27
    8982:	10 f4       	brcc	.+4      	; 0x8988 <WebBuf2Field+0x1c6>
    8984:	f7 01       	movw	r30, r14
    8986:	cc c1       	rjmp	.+920    	; 0x8d20 <WebBuf2Field+0x55e>
    8988:	44 2d       	mov	r20, r4
    898a:	55 27       	eor	r21, r21
    898c:	47 fd       	sbrc	r20, 7
    898e:	50 95       	com	r21
    8990:	65 2f       	mov	r22, r21
    8992:	75 2f       	mov	r23, r21
    8994:	f7 01       	movw	r30, r14
    8996:	84 17       	cp	r24, r20
    8998:	95 07       	cpc	r25, r21
    899a:	a6 07       	cpc	r26, r22
    899c:	b7 07       	cpc	r27, r23
    899e:	08 f4       	brcc	.+2      	; 0x89a2 <WebBuf2Field+0x1e0>
    89a0:	9b c1       	rjmp	.+822    	; 0x8cd8 <WebBuf2Field+0x516>
    89a2:	80 83       	st	Z, r24
    89a4:	56 c2       	rjmp	.+1196   	; 0x8e52 <WebBuf2Field+0x690>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    89a6:	b8 01       	movw	r22, r16
    89a8:	c6 01       	movw	r24, r12
    89aa:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    89ae:	ce 01       	movw	r24, r28
    89b0:	05 96       	adiw	r24, 0x05	; 5
    89b2:	9f 93       	push	r25
    89b4:	8f 93       	push	r24
    89b6:	87 e9       	ldi	r24, 0x97	; 151
    89b8:	91 e0       	ldi	r25, 0x01	; 1
    89ba:	9f 93       	push	r25
    89bc:	8f 93       	push	r24
    89be:	1f 93       	push	r17
    89c0:	0f 93       	push	r16
    89c2:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    89c6:	0f 90       	pop	r0
    89c8:	0f 90       	pop	r0
    89ca:	0f 90       	pop	r0
    89cc:	0f 90       	pop	r0
    89ce:	0f 90       	pop	r0
    89d0:	0f 90       	pop	r0
    89d2:	01 97       	sbiw	r24, 0x01	; 1
    89d4:	09 f0       	breq	.+2      	; 0x89d8 <WebBuf2Field+0x216>
    89d6:	3d c2       	rjmp	.+1146   	; 0x8e52 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    89d8:	6d 81       	ldd	r22, Y+5	; 0x05
    89da:	86 16       	cp	r8, r22
    89dc:	14 f4       	brge	.+4      	; 0x89e2 <WebBuf2Field+0x220>
    89de:	68 2d       	mov	r22, r8
    89e0:	82 c1       	rjmp	.+772    	; 0x8ce6 <WebBuf2Field+0x524>
    89e2:	64 15       	cp	r22, r4
    89e4:	0c f0       	brlt	.+2      	; 0x89e8 <WebBuf2Field+0x226>
    89e6:	7f c1       	rjmp	.+766    	; 0x8ce6 <WebBuf2Field+0x524>
    89e8:	7b c1       	rjmp	.+758    	; 0x8ce0 <WebBuf2Field+0x51e>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    89ea:	b8 01       	movw	r22, r16
    89ec:	c6 01       	movw	r24, r12
    89ee:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    89f2:	ce 01       	movw	r24, r28
    89f4:	05 96       	adiw	r24, 0x05	; 5
    89f6:	9f 93       	push	r25
    89f8:	8f 93       	push	r24
    89fa:	8b e9       	ldi	r24, 0x9B	; 155
    89fc:	91 e0       	ldi	r25, 0x01	; 1
    89fe:	9f 93       	push	r25
    8a00:	8f 93       	push	r24
    8a02:	1f 93       	push	r17
    8a04:	0f 93       	push	r16
    8a06:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		SetField(Temp, uint16_t);
    8a0a:	8d 81       	ldd	r24, Y+5	; 0x05
    8a0c:	9e 81       	ldd	r25, Y+6	; 0x06
    8a0e:	af 81       	ldd	r26, Y+7	; 0x07
    8a10:	b8 85       	ldd	r27, Y+8	; 0x08
    8a12:	0f 90       	pop	r0
    8a14:	0f 90       	pop	r0
    8a16:	0f 90       	pop	r0
    8a18:	0f 90       	pop	r0
    8a1a:	0f 90       	pop	r0
    8a1c:	0f 90       	pop	r0
    8a1e:	b5 01       	movw	r22, r10
    8a20:	a4 01       	movw	r20, r8
    8a22:	66 27       	eor	r22, r22
    8a24:	77 27       	eor	r23, r23
    8a26:	48 17       	cp	r20, r24
    8a28:	59 07       	cpc	r21, r25
    8a2a:	6a 07       	cpc	r22, r26
    8a2c:	7b 07       	cpc	r23, r27
    8a2e:	08 f4       	brcc	.+2      	; 0x8a32 <WebBuf2Field+0x270>
    8a30:	5b c0       	rjmp	.+182    	; 0x8ae8 <WebBuf2Field+0x326>
    8a32:	b3 01       	movw	r22, r6
    8a34:	a2 01       	movw	r20, r4
    8a36:	66 27       	eor	r22, r22
    8a38:	77 27       	eor	r23, r23
    8a3a:	5f c0       	rjmp	.+190    	; 0x8afa <WebBuf2Field+0x338>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8a3c:	b8 01       	movw	r22, r16
    8a3e:	c6 01       	movw	r24, r12
    8a40:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8a44:	ce 01       	movw	r24, r28
    8a46:	05 96       	adiw	r24, 0x05	; 5
    8a48:	9f 93       	push	r25
    8a4a:	8f 93       	push	r24
    8a4c:	8f e9       	ldi	r24, 0x9F	; 159
    8a4e:	91 e0       	ldi	r25, 0x01	; 1
    8a50:	9f 93       	push	r25
    8a52:	8f 93       	push	r24
    8a54:	1f 93       	push	r17
    8a56:	0f 93       	push	r16
    8a58:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    8a5c:	0f 90       	pop	r0
    8a5e:	0f 90       	pop	r0
    8a60:	0f 90       	pop	r0
    8a62:	0f 90       	pop	r0
    8a64:	0f 90       	pop	r0
    8a66:	0f 90       	pop	r0
    8a68:	01 97       	sbiw	r24, 0x01	; 1
    8a6a:	09 f0       	breq	.+2      	; 0x8a6e <WebBuf2Field+0x2ac>
    8a6c:	f2 c1       	rjmp	.+996    	; 0x8e52 <WebBuf2Field+0x690>
			SetEEField(Temp, uint16_t, uint16_t, w);
    8a6e:	6d 81       	ldd	r22, Y+5	; 0x05
    8a70:	7e 81       	ldd	r23, Y+6	; 0x06
    8a72:	8f 81       	ldd	r24, Y+7	; 0x07
    8a74:	98 85       	ldd	r25, Y+8	; 0x08
    8a76:	95 01       	movw	r18, r10
    8a78:	84 01       	movw	r16, r8
    8a7a:	22 27       	eor	r18, r18
    8a7c:	33 27       	eor	r19, r19
    8a7e:	06 17       	cp	r16, r22
    8a80:	17 07       	cpc	r17, r23
    8a82:	28 07       	cpc	r18, r24
    8a84:	39 07       	cpc	r19, r25
    8a86:	08 f4       	brcc	.+2      	; 0x8a8a <WebBuf2Field+0x2c8>
    8a88:	64 c0       	rjmp	.+200    	; 0x8b52 <WebBuf2Field+0x390>
    8a8a:	93 01       	movw	r18, r6
    8a8c:	82 01       	movw	r16, r4
    8a8e:	22 27       	eor	r18, r18
    8a90:	33 27       	eor	r19, r19
    8a92:	60 17       	cp	r22, r16
    8a94:	71 07       	cpc	r23, r17
    8a96:	82 07       	cpc	r24, r18
    8a98:	93 07       	cpc	r25, r19
    8a9a:	08 f0       	brcs	.+2      	; 0x8a9e <WebBuf2Field+0x2dc>
    8a9c:	60 c0       	rjmp	.+192    	; 0x8b5e <WebBuf2Field+0x39c>
    8a9e:	5e c0       	rjmp	.+188    	; 0x8b5c <WebBuf2Field+0x39a>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    8aa0:	b8 01       	movw	r22, r16
    8aa2:	c6 01       	movw	r24, r12
    8aa4:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    8aa8:	ce 01       	movw	r24, r28
    8aaa:	05 96       	adiw	r24, 0x05	; 5
    8aac:	9f 93       	push	r25
    8aae:	8f 93       	push	r24
    8ab0:	84 ea       	ldi	r24, 0xA4	; 164
    8ab2:	91 e0       	ldi	r25, 0x01	; 1
    8ab4:	9f 93       	push	r25
    8ab6:	8f 93       	push	r24
    8ab8:	1f 93       	push	r17
    8aba:	0f 93       	push	r16
    8abc:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		SetField(Temp, int16_t);
    8ac0:	8d 81       	ldd	r24, Y+5	; 0x05
    8ac2:	9e 81       	ldd	r25, Y+6	; 0x06
    8ac4:	af 81       	ldd	r26, Y+7	; 0x07
    8ac6:	b8 85       	ldd	r27, Y+8	; 0x08
    8ac8:	0f 90       	pop	r0
    8aca:	0f 90       	pop	r0
    8acc:	0f 90       	pop	r0
    8ace:	0f 90       	pop	r0
    8ad0:	0f 90       	pop	r0
    8ad2:	0f 90       	pop	r0
    8ad4:	a4 01       	movw	r20, r8
    8ad6:	66 27       	eor	r22, r22
    8ad8:	57 fd       	sbrc	r21, 7
    8ada:	60 95       	com	r22
    8adc:	76 2f       	mov	r23, r22
    8ade:	48 17       	cp	r20, r24
    8ae0:	59 07       	cpc	r21, r25
    8ae2:	6a 07       	cpc	r22, r26
    8ae4:	7b 07       	cpc	r23, r27
    8ae6:	20 f4       	brcc	.+8      	; 0x8af0 <WebBuf2Field+0x32e>
    8ae8:	f7 01       	movw	r30, r14
    8aea:	91 82       	std	Z+1, r9	; 0x01
    8aec:	80 82       	st	Z, r8
    8aee:	b1 c1       	rjmp	.+866    	; 0x8e52 <WebBuf2Field+0x690>
    8af0:	a2 01       	movw	r20, r4
    8af2:	66 27       	eor	r22, r22
    8af4:	57 fd       	sbrc	r21, 7
    8af6:	60 95       	com	r22
    8af8:	76 2f       	mov	r23, r22
    8afa:	f7 01       	movw	r30, r14
    8afc:	84 17       	cp	r24, r20
    8afe:	95 07       	cpc	r25, r21
    8b00:	a6 07       	cpc	r26, r22
    8b02:	b7 07       	cpc	r27, r23
    8b04:	18 f4       	brcc	.+6      	; 0x8b0c <WebBuf2Field+0x34a>
    8b06:	51 82       	std	Z+1, r5	; 0x01
    8b08:	40 82       	st	Z, r4
    8b0a:	a3 c1       	rjmp	.+838    	; 0x8e52 <WebBuf2Field+0x690>
    8b0c:	91 83       	std	Z+1, r25	; 0x01
    8b0e:	80 83       	st	Z, r24
    8b10:	a0 c1       	rjmp	.+832    	; 0x8e52 <WebBuf2Field+0x690>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8b12:	b8 01       	movw	r22, r16
    8b14:	c6 01       	movw	r24, r12
    8b16:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    8b1a:	ce 01       	movw	r24, r28
    8b1c:	05 96       	adiw	r24, 0x05	; 5
    8b1e:	9f 93       	push	r25
    8b20:	8f 93       	push	r24
    8b22:	84 ea       	ldi	r24, 0xA4	; 164
    8b24:	91 e0       	ldi	r25, 0x01	; 1
    8b26:	9f 93       	push	r25
    8b28:	8f 93       	push	r24
    8b2a:	1f 93       	push	r17
    8b2c:	0f 93       	push	r16
    8b2e:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    8b32:	0f 90       	pop	r0
    8b34:	0f 90       	pop	r0
    8b36:	0f 90       	pop	r0
    8b38:	0f 90       	pop	r0
    8b3a:	0f 90       	pop	r0
    8b3c:	0f 90       	pop	r0
    8b3e:	01 97       	sbiw	r24, 0x01	; 1
    8b40:	09 f0       	breq	.+2      	; 0x8b44 <WebBuf2Field+0x382>
    8b42:	87 c1       	rjmp	.+782    	; 0x8e52 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    8b44:	6d 81       	ldd	r22, Y+5	; 0x05
    8b46:	7e 81       	ldd	r23, Y+6	; 0x06
    8b48:	8f 81       	ldd	r24, Y+7	; 0x07
    8b4a:	98 85       	ldd	r25, Y+8	; 0x08
    8b4c:	86 16       	cp	r8, r22
    8b4e:	97 06       	cpc	r9, r23
    8b50:	14 f4       	brge	.+4      	; 0x8b56 <WebBuf2Field+0x394>
    8b52:	b4 01       	movw	r22, r8
    8b54:	04 c0       	rjmp	.+8      	; 0x8b5e <WebBuf2Field+0x39c>
    8b56:	64 15       	cp	r22, r4
    8b58:	75 05       	cpc	r23, r5
    8b5a:	0c f4       	brge	.+2      	; 0x8b5e <WebBuf2Field+0x39c>
    8b5c:	b2 01       	movw	r22, r4
    8b5e:	c7 01       	movw	r24, r14
    8b60:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>
    8b64:	76 c1       	rjmp	.+748    	; 0x8e52 <WebBuf2Field+0x690>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    8b66:	f7 01       	movw	r30, r14
    8b68:	11 82       	std	Z+1, r1	; 0x01
    8b6a:	10 82       	st	Z, r1
		break;
    8b6c:	72 c1       	rjmp	.+740    	; 0x8e52 <WebBuf2Field+0x690>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8b6e:	b8 01       	movw	r22, r16
    8b70:	c6 01       	movw	r24, r12
    8b72:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    8b76:	ce 01       	movw	r24, r28
    8b78:	05 96       	adiw	r24, 0x05	; 5
    8b7a:	9f 93       	push	r25
    8b7c:	8f 93       	push	r24
    8b7e:	8f e9       	ldi	r24, 0x9F	; 159
    8b80:	91 e0       	ldi	r25, 0x01	; 1
    8b82:	15 c0       	rjmp	.+42     	; 0x8bae <WebBuf2Field+0x3ec>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8b84:	b8 01       	movw	r22, r16
    8b86:	c6 01       	movw	r24, r12
    8b88:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8b8c:	ce 01       	movw	r24, r28
    8b8e:	05 96       	adiw	r24, 0x05	; 5
    8b90:	9f 93       	push	r25
    8b92:	8f 93       	push	r24
    8b94:	8f e9       	ldi	r24, 0x9F	; 159
    8b96:	91 e0       	ldi	r25, 0x01	; 1
    8b98:	3e c0       	rjmp	.+124    	; 0x8c16 <WebBuf2Field+0x454>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    8b9a:	b8 01       	movw	r22, r16
    8b9c:	c6 01       	movw	r24, r12
    8b9e:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    8ba2:	ce 01       	movw	r24, r28
    8ba4:	05 96       	adiw	r24, 0x05	; 5
    8ba6:	9f 93       	push	r25
    8ba8:	8f 93       	push	r24
    8baa:	87 ea       	ldi	r24, 0xA7	; 167
    8bac:	91 e0       	ldi	r25, 0x01	; 1
    8bae:	9f 93       	push	r25
    8bb0:	8f 93       	push	r24
    8bb2:	1f 93       	push	r17
    8bb4:	0f 93       	push	r16
    8bb6:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		SetField(Temp, int32_t);
    8bba:	8d 81       	ldd	r24, Y+5	; 0x05
    8bbc:	9e 81       	ldd	r25, Y+6	; 0x06
    8bbe:	af 81       	ldd	r26, Y+7	; 0x07
    8bc0:	b8 85       	ldd	r27, Y+8	; 0x08
    8bc2:	0f 90       	pop	r0
    8bc4:	0f 90       	pop	r0
    8bc6:	0f 90       	pop	r0
    8bc8:	0f 90       	pop	r0
    8bca:	0f 90       	pop	r0
    8bcc:	0f 90       	pop	r0
    8bce:	f7 01       	movw	r30, r14
    8bd0:	88 16       	cp	r8, r24
    8bd2:	99 06       	cpc	r9, r25
    8bd4:	aa 06       	cpc	r10, r26
    8bd6:	bb 06       	cpc	r11, r27
    8bd8:	28 f4       	brcc	.+10     	; 0x8be4 <WebBuf2Field+0x422>
    8bda:	80 82       	st	Z, r8
    8bdc:	91 82       	std	Z+1, r9	; 0x01
    8bde:	a2 82       	std	Z+2, r10	; 0x02
    8be0:	b3 82       	std	Z+3, r11	; 0x03
    8be2:	37 c1       	rjmp	.+622    	; 0x8e52 <WebBuf2Field+0x690>
    8be4:	84 15       	cp	r24, r4
    8be6:	95 05       	cpc	r25, r5
    8be8:	a6 05       	cpc	r26, r6
    8bea:	b7 05       	cpc	r27, r7
    8bec:	28 f4       	brcc	.+10     	; 0x8bf8 <WebBuf2Field+0x436>
    8bee:	40 82       	st	Z, r4
    8bf0:	51 82       	std	Z+1, r5	; 0x01
    8bf2:	62 82       	std	Z+2, r6	; 0x02
    8bf4:	73 82       	std	Z+3, r7	; 0x03
    8bf6:	2d c1       	rjmp	.+602    	; 0x8e52 <WebBuf2Field+0x690>
    8bf8:	80 83       	st	Z, r24
    8bfa:	91 83       	std	Z+1, r25	; 0x01
    8bfc:	a2 83       	std	Z+2, r26	; 0x02
    8bfe:	b3 83       	std	Z+3, r27	; 0x03
    8c00:	28 c1       	rjmp	.+592    	; 0x8e52 <WebBuf2Field+0x690>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8c02:	b8 01       	movw	r22, r16
    8c04:	c6 01       	movw	r24, r12
    8c06:	0e 94 a4 43 	call	0x8748	; 0x8748 <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    8c0a:	ce 01       	movw	r24, r28
    8c0c:	05 96       	adiw	r24, 0x05	; 5
    8c0e:	9f 93       	push	r25
    8c10:	8f 93       	push	r24
    8c12:	87 ea       	ldi	r24, 0xA7	; 167
    8c14:	91 e0       	ldi	r25, 0x01	; 1
    8c16:	9f 93       	push	r25
    8c18:	8f 93       	push	r24
    8c1a:	1f 93       	push	r17
    8c1c:	0f 93       	push	r16
    8c1e:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    8c22:	0f 90       	pop	r0
    8c24:	0f 90       	pop	r0
    8c26:	0f 90       	pop	r0
    8c28:	0f 90       	pop	r0
    8c2a:	0f 90       	pop	r0
    8c2c:	0f 90       	pop	r0
    8c2e:	01 97       	sbiw	r24, 0x01	; 1
    8c30:	09 f0       	breq	.+2      	; 0x8c34 <WebBuf2Field+0x472>
    8c32:	0f c1       	rjmp	.+542    	; 0x8e52 <WebBuf2Field+0x690>
			SetEEField(Temp, int32_t, uint32_t, d);
    8c34:	4d 81       	ldd	r20, Y+5	; 0x05
    8c36:	5e 81       	ldd	r21, Y+6	; 0x06
    8c38:	6f 81       	ldd	r22, Y+7	; 0x07
    8c3a:	78 85       	ldd	r23, Y+8	; 0x08
    8c3c:	84 16       	cp	r8, r20
    8c3e:	95 06       	cpc	r9, r21
    8c40:	a6 06       	cpc	r10, r22
    8c42:	b7 06       	cpc	r11, r23
    8c44:	18 f4       	brcc	.+6      	; 0x8c4c <WebBuf2Field+0x48a>
    8c46:	b5 01       	movw	r22, r10
    8c48:	a4 01       	movw	r20, r8
    8c4a:	07 c0       	rjmp	.+14     	; 0x8c5a <WebBuf2Field+0x498>
    8c4c:	44 15       	cp	r20, r4
    8c4e:	55 05       	cpc	r21, r5
    8c50:	66 05       	cpc	r22, r6
    8c52:	77 05       	cpc	r23, r7
    8c54:	10 f4       	brcc	.+4      	; 0x8c5a <WebBuf2Field+0x498>
    8c56:	b3 01       	movw	r22, r6
    8c58:	a2 01       	movw	r20, r4
    8c5a:	c7 01       	movw	r24, r14
    8c5c:	0e 94 d1 29 	call	0x53a2	; 0x53a2 <ewd>
    8c60:	f8 c0       	rjmp	.+496    	; 0x8e52 <WebBuf2Field+0x690>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    8c62:	ce 01       	movw	r24, r28
    8c64:	01 96       	adiw	r24, 0x01	; 1
    8c66:	9f 93       	push	r25
    8c68:	8f 93       	push	r24
    8c6a:	8b ea       	ldi	r24, 0xAB	; 171
    8c6c:	91 e0       	ldi	r25, 0x01	; 1
    8c6e:	9f 93       	push	r25
    8c70:	8f 93       	push	r24
    8c72:	1f 93       	push	r17
    8c74:	0f 93       	push	r16
    8c76:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		*(float*)Var = fTemp;
    8c7a:	89 81       	ldd	r24, Y+1	; 0x01
    8c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    8c7e:	ab 81       	ldd	r26, Y+3	; 0x03
    8c80:	bc 81       	ldd	r27, Y+4	; 0x04
    8c82:	f7 01       	movw	r30, r14
    8c84:	80 83       	st	Z, r24
    8c86:	91 83       	std	Z+1, r25	; 0x01
    8c88:	a2 83       	std	Z+2, r26	; 0x02
    8c8a:	b3 83       	std	Z+3, r27	; 0x03
		break;
    8c8c:	0f 90       	pop	r0
    8c8e:	0f 90       	pop	r0
    8c90:	0f 90       	pop	r0
    8c92:	0f 90       	pop	r0
    8c94:	0f 90       	pop	r0
    8c96:	0f 90       	pop	r0
    8c98:	dc c0       	rjmp	.+440    	; 0x8e52 <WebBuf2Field+0x690>
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    8c9a:	9e 01       	movw	r18, r28
    8c9c:	2f 5f       	subi	r18, 0xFF	; 255
    8c9e:	3f 4f       	sbci	r19, 0xFF	; 255
    8ca0:	59 01       	movw	r10, r18
    8ca2:	bf 92       	push	r11
    8ca4:	2f 93       	push	r18
    8ca6:	8b ea       	ldi	r24, 0xAB	; 171
    8ca8:	91 e0       	ldi	r25, 0x01	; 1
    8caa:	9f 93       	push	r25
    8cac:	8f 93       	push	r24
    8cae:	1f 93       	push	r17
    8cb0:	0f 93       	push	r16
    8cb2:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
    8cb6:	0f 90       	pop	r0
    8cb8:	0f 90       	pop	r0
    8cba:	0f 90       	pop	r0
    8cbc:	0f 90       	pop	r0
    8cbe:	0f 90       	pop	r0
    8cc0:	0f 90       	pop	r0
    8cc2:	01 97       	sbiw	r24, 0x01	; 1
    8cc4:	09 f0       	breq	.+2      	; 0x8cc8 <WebBuf2Field+0x506>
    8cc6:	c5 c0       	rjmp	.+394    	; 0x8e52 <WebBuf2Field+0x690>
			ewbl(&fTemp, (float*)Var, 4);
    8cc8:	44 e0       	ldi	r20, 0x04	; 4
    8cca:	50 e0       	ldi	r21, 0x00	; 0
    8ccc:	b7 01       	movw	r22, r14
    8cce:	c5 01       	movw	r24, r10
    8cd0:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
    8cd4:	be c0       	rjmp	.+380    	; 0x8e52 <WebBuf2Field+0x690>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    8cd6:	f7 01       	movw	r30, r14
    8cd8:	40 82       	st	Z, r4
    8cda:	bb c0       	rjmp	.+374    	; 0x8e52 <WebBuf2Field+0x690>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    8cdc:	44 20       	and	r4, r4
    8cde:	11 f0       	breq	.+4      	; 0x8ce4 <WebBuf2Field+0x522>
    8ce0:	64 2d       	mov	r22, r4
    8ce2:	01 c0       	rjmp	.+2      	; 0x8ce6 <WebBuf2Field+0x524>
    8ce4:	60 e0       	ldi	r22, 0x00	; 0
    8ce6:	c7 01       	movw	r24, r14
    8ce8:	43 c0       	rjmp	.+134    	; 0x8d70 <WebBuf2Field+0x5ae>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8cea:	ce 01       	movw	r24, r28
    8cec:	05 96       	adiw	r24, 0x05	; 5
    8cee:	9f 93       	push	r25
    8cf0:	8f 93       	push	r24
    8cf2:	82 e9       	ldi	r24, 0x92	; 146
    8cf4:	91 e0       	ldi	r25, 0x01	; 1
    8cf6:	9f 93       	push	r25
    8cf8:	8f 93       	push	r24
    8cfa:	1f 93       	push	r17
    8cfc:	0f 93       	push	r16
    8cfe:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
		if((unsigned short int)Temp)
    8d02:	0f 90       	pop	r0
    8d04:	0f 90       	pop	r0
    8d06:	0f 90       	pop	r0
    8d08:	0f 90       	pop	r0
    8d0a:	0f 90       	pop	r0
    8d0c:	0f 90       	pop	r0
    8d0e:	8d 81       	ldd	r24, Y+5	; 0x05
    8d10:	9e 81       	ldd	r25, Y+6	; 0x06
    8d12:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d14:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d16:	20 81       	ld	r18, Z
			*BitVar |=Mask;
    8d18:	89 84       	ldd	r8, Y+9	; 0x09
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
		if((unsigned short int)Temp)
    8d1a:	89 2b       	or	r24, r25
    8d1c:	19 f0       	breq	.+6      	; 0x8d24 <WebBuf2Field+0x562>
			*BitVar |=Mask;
    8d1e:	82 2a       	or	r8, r18
    8d20:	80 82       	st	Z, r8
    8d22:	97 c0       	rjmp	.+302    	; 0x8e52 <WebBuf2Field+0x690>
		else
			*BitVar &=~Mask;
    8d24:	80 94       	com	r8
    8d26:	82 22       	and	r8, r18
    8d28:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d2a:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d2c:	f9 cf       	rjmp	.-14     	; 0x8d20 <WebBuf2Field+0x55e>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8d2e:	ce 01       	movw	r24, r28
    8d30:	05 96       	adiw	r24, 0x05	; 5
    8d32:	9f 93       	push	r25
    8d34:	8f 93       	push	r24
    8d36:	82 e9       	ldi	r24, 0x92	; 146
    8d38:	91 e0       	ldi	r25, 0x01	; 1
    8d3a:	9f 93       	push	r25
    8d3c:	8f 93       	push	r24
    8d3e:	1f 93       	push	r17
    8d40:	0f 93       	push	r16
    8d42:	0e 94 ac 6c 	call	0xd958	; 0xd958 <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8d46:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d48:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d4a:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    8d4e:	0f 90       	pop	r0
    8d50:	0f 90       	pop	r0
    8d52:	0f 90       	pop	r0
    8d54:	0f 90       	pop	r0
    8d56:	0f 90       	pop	r0
    8d58:	0f 90       	pop	r0
    8d5a:	2d 81       	ldd	r18, Y+5	; 0x05
    8d5c:	3e 81       	ldd	r19, Y+6	; 0x06
    8d5e:	69 85       	ldd	r22, Y+9	; 0x09
    8d60:	23 2b       	or	r18, r19
    8d62:	11 f0       	breq	.+4      	; 0x8d68 <WebBuf2Field+0x5a6>
    8d64:	68 2b       	or	r22, r24
    8d66:	02 c0       	rjmp	.+4      	; 0x8d6c <WebBuf2Field+0x5aa>
    8d68:	60 95       	com	r22
    8d6a:	68 23       	and	r22, r24
    8d6c:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d6e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d70:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
		break;
    8d74:	6e c0       	rjmp	.+220    	; 0x8e52 <WebBuf2Field+0x690>
    8d76:	ad b6       	in	r10, 0x3d	; 61
    8d78:	be b6       	in	r11, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8d7a:	f1 01       	movw	r30, r2
    8d7c:	24 90       	lpm	r2, Z


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8d7e:	31 2c       	mov	r3, r1
    8d80:	2d b7       	in	r18, 0x3d	; 61
    8d82:	3e b7       	in	r19, 0x3e	; 62
    8d84:	22 19       	sub	r18, r2
    8d86:	33 09       	sbc	r19, r3
    8d88:	0f b6       	in	r0, 0x3f	; 63
    8d8a:	f8 94       	cli
    8d8c:	3e bf       	out	0x3e, r19	; 62
    8d8e:	0f be       	out	0x3f, r0	; 63
    8d90:	2d bf       	out	0x3d, r18	; 61
    8d92:	6d b7       	in	r22, 0x3d	; 61
    8d94:	7e b7       	in	r23, 0x3e	; 62
    8d96:	6f 5f       	subi	r22, 0xFF	; 255
    8d98:	7f 4f       	sbci	r23, 0xFF	; 255
		uint8_t i=0;
    8d9a:	90 e0       	ldi	r25, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8d9c:	31 e0       	ldi	r19, 0x01	; 1
    8d9e:	23 1a       	sub	r2, r19
    8da0:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8da2:	20 e2       	ldi	r18, 0x20	; 32
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8da4:	49 2f       	mov	r20, r25
    8da6:	50 e0       	ldi	r21, 0x00	; 0
    8da8:	fb 01       	movw	r30, r22
    8daa:	e4 0f       	add	r30, r20
    8dac:	f5 1f       	adc	r31, r21
    8dae:	42 15       	cp	r20, r2
    8db0:	53 05       	cpc	r21, r3
    8db2:	3c f0       	brlt	.+14     	; 0x8dc2 <WebBuf2Field+0x600>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8db4:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    8db6:	4f 5f       	subi	r20, 0xFF	; 255
    8db8:	5f 4f       	sbci	r21, 0xFF	; 255
    8dba:	c7 01       	movw	r24, r14
    8dbc:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
    8dc0:	33 c0       	rjmp	.+102    	; 0x8e28 <WebBuf2Field+0x666>
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dc2:	d8 01       	movw	r26, r16
    8dc4:	a4 0f       	add	r26, r20
    8dc6:	b5 1f       	adc	r27, r21
    8dc8:	8c 91       	ld	r24, X
    8dca:	80 32       	cpi	r24, 0x20	; 32
    8dcc:	99 f3       	breq	.-26     	; 0x8db4 <WebBuf2Field+0x5f2>
    8dce:	86 32       	cpi	r24, 0x26	; 38
    8dd0:	89 f3       	breq	.-30     	; 0x8db4 <WebBuf2Field+0x5f2>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8dd2:	8b 32       	cpi	r24, 0x2B	; 43
    8dd4:	11 f4       	brne	.+4      	; 0x8dda <WebBuf2Field+0x618>
    8dd6:	20 83       	st	Z, r18
    8dd8:	01 c0       	rjmp	.+2      	; 0x8ddc <WebBuf2Field+0x61a>
			else TempStr[i]=BufStr[i];
    8dda:	80 83       	st	Z, r24
			i++;
    8ddc:	9f 5f       	subi	r25, 0xFF	; 255
    8dde:	e2 cf       	rjmp	.-60     	; 0x8da4 <WebBuf2Field+0x5e2>
    8de0:	ad b6       	in	r10, 0x3d	; 61
    8de2:	be b6       	in	r11, 0x3e	; 62
    8de4:	f1 01       	movw	r30, r2
    8de6:	24 90       	lpm	r2, Z

		break;
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8de8:	31 2c       	mov	r3, r1
    8dea:	2d b7       	in	r18, 0x3d	; 61
    8dec:	3e b7       	in	r19, 0x3e	; 62
    8dee:	22 19       	sub	r18, r2
    8df0:	33 09       	sbc	r19, r3
    8df2:	0f b6       	in	r0, 0x3f	; 63
    8df4:	f8 94       	cli
    8df6:	3e bf       	out	0x3e, r19	; 62
    8df8:	0f be       	out	0x3f, r0	; 63
    8dfa:	2d bf       	out	0x3d, r18	; 61
    8dfc:	8d b7       	in	r24, 0x3d	; 61
    8dfe:	9e b7       	in	r25, 0x3e	; 62
    8e00:	01 96       	adiw	r24, 0x01	; 1
		uint8_t i=0;
    8e02:	30 e0       	ldi	r19, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e04:	e1 e0       	ldi	r30, 0x01	; 1
    8e06:	2e 1a       	sub	r2, r30
    8e08:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e0a:	60 e2       	ldi	r22, 0x20	; 32
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e0c:	43 2f       	mov	r20, r19
    8e0e:	50 e0       	ldi	r21, 0x00	; 0
    8e10:	fc 01       	movw	r30, r24
    8e12:	e4 0f       	add	r30, r20
    8e14:	f5 1f       	adc	r31, r21
    8e16:	42 15       	cp	r20, r2
    8e18:	53 05       	cpc	r21, r3
    8e1a:	64 f0       	brlt	.+24     	; 0x8e34 <WebBuf2Field+0x672>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8e1c:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    8e1e:	4f 5f       	subi	r20, 0xFF	; 255
    8e20:	5f 4f       	sbci	r21, 0xFF	; 255
    8e22:	b7 01       	movw	r22, r14
    8e24:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
    8e28:	0f b6       	in	r0, 0x3f	; 63
    8e2a:	f8 94       	cli
    8e2c:	be be       	out	0x3e, r11	; 62
    8e2e:	0f be       	out	0x3f, r0	; 63
    8e30:	ad be       	out	0x3d, r10	; 61
		}
		break;
    8e32:	0f c0       	rjmp	.+30     	; 0x8e52 <WebBuf2Field+0x690>
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e34:	d8 01       	movw	r26, r16
    8e36:	a4 0f       	add	r26, r20
    8e38:	b5 1f       	adc	r27, r21
    8e3a:	2c 91       	ld	r18, X
    8e3c:	20 32       	cpi	r18, 0x20	; 32
    8e3e:	71 f3       	breq	.-36     	; 0x8e1c <WebBuf2Field+0x65a>
    8e40:	26 32       	cpi	r18, 0x26	; 38
    8e42:	61 f3       	breq	.-40     	; 0x8e1c <WebBuf2Field+0x65a>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e44:	2b 32       	cpi	r18, 0x2B	; 43
    8e46:	11 f4       	brne	.+4      	; 0x8e4c <WebBuf2Field+0x68a>
    8e48:	60 83       	st	Z, r22
    8e4a:	01 c0       	rjmp	.+2      	; 0x8e4e <WebBuf2Field+0x68c>
			else TempStr[i]=BufStr[i];
    8e4c:	20 83       	st	Z, r18
			i++;
    8e4e:	3f 5f       	subi	r19, 0xFF	; 255
    8e50:	dd cf       	rjmp	.-70     	; 0x8e0c <WebBuf2Field+0x64a>
		ewbl(TempStr, Var, i+1);
		}
		break;
	}

	EventFunc(&Field->Act);
    8e52:	fb e0       	ldi	r31, 0x0B	; 11
    8e54:	cf 0e       	add	r12, r31
    8e56:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8e58:	f6 01       	movw	r30, r12
    8e5a:	85 91       	lpm	r24, Z+
    8e5c:	94 91       	lpm	r25, Z
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8e5e:	00 97       	sbiw	r24, 0x00	; 0
    8e60:	11 f0       	breq	.+4      	; 0x8e66 <WebBuf2Field+0x6a4>
		Func();
    8e62:	fc 01       	movw	r30, r24
    8e64:	09 95       	icall
}
    8e66:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e68:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e6a:	0f b6       	in	r0, 0x3f	; 63
    8e6c:	f8 94       	cli
    8e6e:	3e bf       	out	0x3e, r19	; 62
    8e70:	0f be       	out	0x3f, r0	; 63
    8e72:	2d bf       	out	0x3d, r18	; 61
    8e74:	2e 96       	adiw	r28, 0x0e	; 14
    8e76:	0f b6       	in	r0, 0x3f	; 63
    8e78:	f8 94       	cli
    8e7a:	de bf       	out	0x3e, r29	; 62
    8e7c:	0f be       	out	0x3f, r0	; 63
    8e7e:	cd bf       	out	0x3d, r28	; 61
    8e80:	df 91       	pop	r29
    8e82:	cf 91       	pop	r28
    8e84:	1f 91       	pop	r17
    8e86:	0f 91       	pop	r16
    8e88:	ff 90       	pop	r15
    8e8a:	ef 90       	pop	r14
    8e8c:	df 90       	pop	r13
    8e8e:	cf 90       	pop	r12
    8e90:	bf 90       	pop	r11
    8e92:	af 90       	pop	r10
    8e94:	9f 90       	pop	r9
    8e96:	8f 90       	pop	r8
    8e98:	7f 90       	pop	r7
    8e9a:	6f 90       	pop	r6
    8e9c:	5f 90       	pop	r5
    8e9e:	4f 90       	pop	r4
    8ea0:	3f 90       	pop	r3
    8ea2:	2f 90       	pop	r2
    8ea4:	08 95       	ret

00008ea6 <strcmp_PP>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8ea6:	fc 01       	movw	r30, r24
    8ea8:	24 91       	lpm	r18, Z
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    8eaa:	22 23       	and	r18, r18
    8eac:	c1 f0       	breq	.+48     	; 0x8ede <strcmp_PP+0x38>
    8eae:	fb 01       	movw	r30, r22
    8eb0:	24 91       	lpm	r18, Z
    8eb2:	22 23       	and	r18, r18
    8eb4:	a1 f0       	breq	.+40     	; 0x8ede <strcmp_PP+0x38>
    8eb6:	fc 01       	movw	r30, r24
    8eb8:	24 91       	lpm	r18, Z
    8eba:	fb 01       	movw	r30, r22
    8ebc:	34 91       	lpm	r19, Z
		if(prb(s1) > prb(s2)) return 1;
    8ebe:	32 17       	cp	r19, r18
    8ec0:	50 f0       	brcs	.+20     	; 0x8ed6 <strcmp_PP+0x30>
    8ec2:	fc 01       	movw	r30, r24
    8ec4:	24 91       	lpm	r18, Z
    8ec6:	fb 01       	movw	r30, r22
    8ec8:	34 91       	lpm	r19, Z
		if(prb(s1) < prb(s2)) return -1;
    8eca:	23 17       	cp	r18, r19
    8ecc:	30 f0       	brcs	.+12     	; 0x8eda <strcmp_PP+0x34>
		s1++;
    8ece:	01 96       	adiw	r24, 0x01	; 1
		s2++;
    8ed0:	6f 5f       	subi	r22, 0xFF	; 255
    8ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    8ed4:	e8 cf       	rjmp	.-48     	; 0x8ea6 <strcmp_PP>
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    8ed6:	81 e0       	ldi	r24, 0x01	; 1
    8ed8:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    8eda:	8f ef       	ldi	r24, 0xFF	; 255
    8edc:	08 95       	ret
		s1++;
		s2++;
	}
	return 0;	
    8ede:	80 e0       	ldi	r24, 0x00	; 0
}
    8ee0:	08 95       	ret

00008ee2 <strcmp_E>:
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    8ee2:	ff 92       	push	r15
    8ee4:	0f 93       	push	r16
    8ee6:	1f 93       	push	r17
    8ee8:	cf 93       	push	r28
    8eea:	df 93       	push	r29
    8eec:	eb 01       	movw	r28, r22
    8eee:	8c 01       	movw	r16, r24
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8ef0:	f8 01       	movw	r30, r16
    8ef2:	f1 90       	ld	r15, Z+
    8ef4:	8f 01       	movw	r16, r30
    8ef6:	ff 20       	and	r15, r15
    8ef8:	49 f0       	breq	.+18     	; 0x8f0c <strcmp_E+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8efa:	ce 01       	movw	r24, r28
    8efc:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8f00:	8f 15       	cp	r24, r15
    8f02:	50 f0       	brcs	.+20     	; 0x8f18 <strcmp_E+0x36>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8f04:	f8 16       	cp	r15, r24
    8f06:	50 f0       	brcs	.+20     	; 0x8f1c <strcmp_E+0x3a>
		str_RAM++;
		str_EE++;		
    8f08:	21 96       	adiw	r28, 0x01	; 1
    8f0a:	f2 cf       	rjmp	.-28     	; 0x8ef0 <strcmp_E+0xe>
    8f0c:	ce 01       	movw	r24, r28
    8f0e:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8f12:	81 11       	cpse	r24, r1
    8f14:	f2 cf       	rjmp	.-28     	; 0x8efa <strcmp_E+0x18>
    8f16:	03 c0       	rjmp	.+6      	; 0x8f1e <strcmp_E+0x3c>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8f18:	81 e0       	ldi	r24, 0x01	; 1
    8f1a:	01 c0       	rjmp	.+2      	; 0x8f1e <strcmp_E+0x3c>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8f1c:	8f ef       	ldi	r24, 0xFF	; 255
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    8f1e:	df 91       	pop	r29
    8f20:	cf 91       	pop	r28
    8f22:	1f 91       	pop	r17
    8f24:	0f 91       	pop	r16
    8f26:	ff 90       	pop	r15
    8f28:	08 95       	ret

00008f2a <SeekTagFORM>:
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
	static uint8_t match;
	switch(match) {
    8f2a:	40 91 43 02 	lds	r20, 0x0243
    8f2e:	50 e0       	ldi	r21, 0x00	; 0
    8f30:	49 30       	cpi	r20, 0x09	; 9
    8f32:	51 05       	cpc	r21, r1
    8f34:	88 f5       	brcc	.+98     	; 0x8f98 <SeekTagFORM+0x6e>
    8f36:	fa 01       	movw	r30, r20
    8f38:	e7 57       	subi	r30, 0x77	; 119
    8f3a:	ff 4f       	sbci	r31, 0xFF	; 255
    8f3c:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8f40:	8c 33       	cpi	r24, 0x3C	; 60
    8f42:	61 f5       	brne	.+88     	; 0x8f9c <SeekTagFORM+0x72>
    8f44:	81 e0       	ldi	r24, 0x01	; 1
    8f46:	1f c0       	rjmp	.+62     	; 0x8f86 <SeekTagFORM+0x5c>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    8f48:	8f 7d       	andi	r24, 0xDF	; 223
    8f4a:	86 34       	cpi	r24, 0x46	; 70
    8f4c:	29 f5       	brne	.+74     	; 0x8f98 <SeekTagFORM+0x6e>
    8f4e:	82 e0       	ldi	r24, 0x02	; 2
    8f50:	1a c0       	rjmp	.+52     	; 0x8f86 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    8f52:	8f 7d       	andi	r24, 0xDF	; 223
    8f54:	8f 34       	cpi	r24, 0x4F	; 79
    8f56:	01 f5       	brne	.+64     	; 0x8f98 <SeekTagFORM+0x6e>
    8f58:	83 e0       	ldi	r24, 0x03	; 3
    8f5a:	15 c0       	rjmp	.+42     	; 0x8f86 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    8f5c:	8f 7d       	andi	r24, 0xDF	; 223
    8f5e:	82 35       	cpi	r24, 0x52	; 82
    8f60:	d9 f4       	brne	.+54     	; 0x8f98 <SeekTagFORM+0x6e>
    8f62:	84 e0       	ldi	r24, 0x04	; 4
    8f64:	10 c0       	rjmp	.+32     	; 0x8f86 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    8f66:	8f 7d       	andi	r24, 0xDF	; 223
    8f68:	8d 34       	cpi	r24, 0x4D	; 77
    8f6a:	b1 f4       	brne	.+44     	; 0x8f98 <SeekTagFORM+0x6e>
    8f6c:	85 e0       	ldi	r24, 0x05	; 5
    8f6e:	0b c0       	rjmp	.+22     	; 0x8f86 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    8f70:	80 32       	cpi	r24, 0x20	; 32
    8f72:	91 f4       	brne	.+36     	; 0x8f98 <SeekTagFORM+0x6e>
    8f74:	86 e0       	ldi	r24, 0x06	; 6
    8f76:	07 c0       	rjmp	.+14     	; 0x8f86 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    8f78:	8e 33       	cpi	r24, 0x3E	; 62
    8f7a:	81 f4       	brne	.+32     	; 0x8f9c <SeekTagFORM+0x72>
    8f7c:	87 e0       	ldi	r24, 0x07	; 7
    8f7e:	03 c0       	rjmp	.+6      	; 0x8f86 <SeekTagFORM+0x5c>
			break;
		case 7:
			if(ch=='\r') match = 8;
    8f80:	8d 30       	cpi	r24, 0x0D	; 13
    8f82:	51 f4       	brne	.+20     	; 0x8f98 <SeekTagFORM+0x6e>
    8f84:	88 e0       	ldi	r24, 0x08	; 8
    8f86:	80 93 43 02 	sts	0x0243, r24
    8f8a:	08 c0       	rjmp	.+16     	; 0x8f9c <SeekTagFORM+0x72>
			else match = 0;
			break;
		case 8:
			match = 0;
    8f8c:	10 92 43 02 	sts	0x0243, r1
			if(ch=='\n') return 1;
    8f90:	91 e0       	ldi	r25, 0x01	; 1
    8f92:	8a 30       	cpi	r24, 0x0A	; 10
    8f94:	19 f4       	brne	.+6      	; 0x8f9c <SeekTagFORM+0x72>
    8f96:	03 c0       	rjmp	.+6      	; 0x8f9e <SeekTagFORM+0x74>
			break;
		default:
			match = 0;
    8f98:	10 92 43 02 	sts	0x0243, r1
	}
	return 0;
    8f9c:	90 e0       	ldi	r25, 0x00	; 0

}
    8f9e:	89 2f       	mov	r24, r25
    8fa0:	08 95       	ret

00008fa2 <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    8fa2:	40 91 42 02 	lds	r20, 0x0242
    8fa6:	50 e0       	ldi	r21, 0x00	; 0
    8fa8:	49 30       	cpi	r20, 0x09	; 9
    8faa:	51 05       	cpc	r21, r1
    8fac:	90 f5       	brcc	.+100    	; 0x9012 <SeekTagA_HREF+0x70>
    8fae:	fa 01       	movw	r30, r20
    8fb0:	ee 56       	subi	r30, 0x6E	; 110
    8fb2:	ff 4f       	sbci	r31, 0xFF	; 255
    8fb4:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8fb8:	8c 33       	cpi	r24, 0x3C	; 60
    8fba:	69 f5       	brne	.+90     	; 0x9016 <SeekTagA_HREF+0x74>
    8fbc:	81 e0       	ldi	r24, 0x01	; 1
    8fbe:	20 c0       	rjmp	.+64     	; 0x9000 <SeekTagA_HREF+0x5e>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    8fc0:	8f 7d       	andi	r24, 0xDF	; 223
    8fc2:	81 34       	cpi	r24, 0x41	; 65
    8fc4:	31 f5       	brne	.+76     	; 0x9012 <SeekTagA_HREF+0x70>
    8fc6:	82 e0       	ldi	r24, 0x02	; 2
    8fc8:	1b c0       	rjmp	.+54     	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    8fca:	80 32       	cpi	r24, 0x20	; 32
    8fcc:	11 f5       	brne	.+68     	; 0x9012 <SeekTagA_HREF+0x70>
    8fce:	83 e0       	ldi	r24, 0x03	; 3
    8fd0:	17 c0       	rjmp	.+46     	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    8fd2:	8f 7d       	andi	r24, 0xDF	; 223
    8fd4:	88 34       	cpi	r24, 0x48	; 72
    8fd6:	e9 f4       	brne	.+58     	; 0x9012 <SeekTagA_HREF+0x70>
    8fd8:	84 e0       	ldi	r24, 0x04	; 4
    8fda:	12 c0       	rjmp	.+36     	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    8fdc:	8f 7d       	andi	r24, 0xDF	; 223
    8fde:	82 35       	cpi	r24, 0x52	; 82
    8fe0:	c1 f4       	brne	.+48     	; 0x9012 <SeekTagA_HREF+0x70>
    8fe2:	85 e0       	ldi	r24, 0x05	; 5
    8fe4:	0d c0       	rjmp	.+26     	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    8fe6:	8f 7d       	andi	r24, 0xDF	; 223
    8fe8:	85 34       	cpi	r24, 0x45	; 69
    8fea:	99 f4       	brne	.+38     	; 0x9012 <SeekTagA_HREF+0x70>
    8fec:	86 e0       	ldi	r24, 0x06	; 6
    8fee:	08 c0       	rjmp	.+16     	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    8ff0:	8f 7d       	andi	r24, 0xDF	; 223
    8ff2:	86 34       	cpi	r24, 0x46	; 70
    8ff4:	71 f4       	brne	.+28     	; 0x9012 <SeekTagA_HREF+0x70>
    8ff6:	87 e0       	ldi	r24, 0x07	; 7
    8ff8:	03 c0       	rjmp	.+6      	; 0x9000 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    8ffa:	82 32       	cpi	r24, 0x22	; 34
    8ffc:	61 f4       	brne	.+24     	; 0x9016 <SeekTagA_HREF+0x74>
    8ffe:	88 e0       	ldi	r24, 0x08	; 8
    9000:	80 93 42 02 	sts	0x0242, r24
    9004:	08 c0       	rjmp	.+16     	; 0x9016 <SeekTagA_HREF+0x74>
			break;
		case 8:
			if(ch=='\"'){
    9006:	82 32       	cpi	r24, 0x22	; 34
    9008:	31 f4       	brne	.+12     	; 0x9016 <SeekTagA_HREF+0x74>
				match = 0;
    900a:	10 92 42 02 	sts	0x0242, r1
				return 1;
    900e:	81 e0       	ldi	r24, 0x01	; 1
    9010:	08 95       	ret
			}
			break;
		default:
			match = 0;
    9012:	10 92 42 02 	sts	0x0242, r1
	}
	return 0;
    9016:	80 e0       	ldi	r24, 0x00	; 0
}
    9018:	08 95       	ret

0000901a <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    901a:	40 91 41 02 	lds	r20, 0x0241
    901e:	50 e0       	ldi	r21, 0x00	; 0
    9020:	4a 30       	cpi	r20, 0x0A	; 10
    9022:	51 05       	cpc	r21, r1
    9024:	b8 f5       	brcc	.+110    	; 0x9094 <SeekTagIMG_SRC+0x7a>
    9026:	fa 01       	movw	r30, r20
    9028:	e5 56       	subi	r30, 0x65	; 101
    902a:	ff 4f       	sbci	r31, 0xFF	; 255
    902c:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    9030:	8c 33       	cpi	r24, 0x3C	; 60
    9032:	91 f5       	brne	.+100    	; 0x9098 <SeekTagIMG_SRC+0x7e>
    9034:	81 e0       	ldi	r24, 0x01	; 1
    9036:	25 c0       	rjmp	.+74     	; 0x9082 <SeekTagIMG_SRC+0x68>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    9038:	8f 7d       	andi	r24, 0xDF	; 223
    903a:	89 34       	cpi	r24, 0x49	; 73
    903c:	59 f5       	brne	.+86     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    903e:	82 e0       	ldi	r24, 0x02	; 2
    9040:	20 c0       	rjmp	.+64     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    9042:	8f 7d       	andi	r24, 0xDF	; 223
    9044:	8d 34       	cpi	r24, 0x4D	; 77
    9046:	31 f5       	brne	.+76     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    9048:	83 e0       	ldi	r24, 0x03	; 3
    904a:	1b c0       	rjmp	.+54     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    904c:	8f 7d       	andi	r24, 0xDF	; 223
    904e:	87 34       	cpi	r24, 0x47	; 71
    9050:	09 f5       	brne	.+66     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    9052:	84 e0       	ldi	r24, 0x04	; 4
    9054:	16 c0       	rjmp	.+44     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    9056:	80 32       	cpi	r24, 0x20	; 32
    9058:	e9 f4       	brne	.+58     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    905a:	85 e0       	ldi	r24, 0x05	; 5
    905c:	12 c0       	rjmp	.+36     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    905e:	8f 7d       	andi	r24, 0xDF	; 223
    9060:	83 35       	cpi	r24, 0x53	; 83
    9062:	c1 f4       	brne	.+48     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    9064:	86 e0       	ldi	r24, 0x06	; 6
    9066:	0d c0       	rjmp	.+26     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    9068:	8f 7d       	andi	r24, 0xDF	; 223
    906a:	82 35       	cpi	r24, 0x52	; 82
    906c:	99 f4       	brne	.+38     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    906e:	87 e0       	ldi	r24, 0x07	; 7
    9070:	08 c0       	rjmp	.+16     	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    9072:	8f 7d       	andi	r24, 0xDF	; 223
    9074:	83 34       	cpi	r24, 0x43	; 67
    9076:	71 f4       	brne	.+28     	; 0x9094 <SeekTagIMG_SRC+0x7a>
    9078:	88 e0       	ldi	r24, 0x08	; 8
    907a:	03 c0       	rjmp	.+6      	; 0x9082 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    907c:	82 32       	cpi	r24, 0x22	; 34
    907e:	61 f4       	brne	.+24     	; 0x9098 <SeekTagIMG_SRC+0x7e>
    9080:	89 e0       	ldi	r24, 0x09	; 9
    9082:	80 93 41 02 	sts	0x0241, r24
    9086:	08 c0       	rjmp	.+16     	; 0x9098 <SeekTagIMG_SRC+0x7e>
			break;
		case 9:
			if(ch=='\"'){
    9088:	82 32       	cpi	r24, 0x22	; 34
    908a:	31 f4       	brne	.+12     	; 0x9098 <SeekTagIMG_SRC+0x7e>
				match = 0;
    908c:	10 92 41 02 	sts	0x0241, r1
				return 1;
    9090:	81 e0       	ldi	r24, 0x01	; 1
    9092:	08 95       	ret
			}
			break;
		default:
			match = 0;
    9094:	10 92 41 02 	sts	0x0241, r1
	}
	return 0;
    9098:	80 e0       	ldi	r24, 0x00	; 0
}
    909a:	08 95       	ret

0000909c <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    909c:	cf 92       	push	r12
    909e:	df 92       	push	r13
    90a0:	ef 92       	push	r14
    90a2:	ff 92       	push	r15
    90a4:	0f 93       	push	r16
    90a6:	1f 93       	push	r17
    90a8:	cf 93       	push	r28
    90aa:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    90ac:	80 91 7e 09 	lds	r24, 0x097E
    90b0:	81 11       	cpse	r24, r1
    90b2:	73 c0       	rjmp	.+230    	; 0x919a <Web_Login_Error+0xfe>
//	if(strcmp_E(Web_Passw_Str, Web_Passws) ) return 3;
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
    90b4:	10 92 6c 0a 	sts	0x0A6C, r1
    90b8:	0a ef       	ldi	r16, 0xFA	; 250
    90ba:	11 e0       	ldi	r17, 0x01	; 1
    90bc:	ca e2       	ldi	r28, 0x2A	; 42
    90be:	d0 e0       	ldi	r29, 0x00	; 0
    90c0:	ff 24       	eor	r15, r15
    90c2:	f3 94       	inc	r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    90c4:	f8 01       	movw	r30, r16
    90c6:	65 91       	lpm	r22, Z+
    90c8:	74 91       	lpm	r23, Z
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
    90ca:	87 ef       	ldi	r24, 0xF7	; 247
    90cc:	99 e0       	ldi	r25, 0x09	; 9
    90ce:	0e 94 53 47 	call	0x8ea6	; 0x8ea6 <strcmp_PP>
    90d2:	81 11       	cpse	r24, r1
    90d4:	09 c0       	rjmp	.+18     	; 0x90e8 <Web_Login_Error+0x4c>
    90d6:	be 01       	movw	r22, r28
    90d8:	84 ef       	ldi	r24, 0xF4	; 244
    90da:	95 e0       	ldi	r25, 0x05	; 5
    90dc:	0e 94 71 47 	call	0x8ee2	; 0x8ee2 <strcmp_E>
    90e0:	81 11       	cpse	r24, r1
    90e2:	02 c0       	rjmp	.+4      	; 0x90e8 <Web_Login_Error+0x4c>
    90e4:	f0 92 6c 0a 	sts	0x0A6C, r15
    90e8:	f3 94       	inc	r15
    90ea:	00 5f       	subi	r16, 0xF0	; 240
    90ec:	1f 4f       	sbci	r17, 0xFF	; 255
    90ee:	2b 96       	adiw	r28, 0x0b	; 11
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    90f0:	85 e0       	ldi	r24, 0x05	; 5
    90f2:	f8 12       	cpse	r15, r24
    90f4:	e7 cf       	rjmp	.-50     	; 0x90c4 <Web_Login_Error+0x28>
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
    90f6:	80 91 6c 0a 	lds	r24, 0x0A6C
    90fa:	88 23       	and	r24, r24
    90fc:	09 f4       	brne	.+2      	; 0x9100 <Web_Login_Error+0x64>
    90fe:	4f c0       	rjmp	.+158    	; 0x919e <Web_Login_Error+0x102>
	return 2;}


	WebSession = 1;
    9100:	81 e0       	ldi	r24, 0x01	; 1
    9102:	80 93 7e 09 	sts	0x097E, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    9106:	c0 91 1c 06 	lds	r28, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    910a:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint32_t Time = Timer32[TimerN];
    910e:	94 e0       	ldi	r25, 0x04	; 4
    9110:	c9 9f       	mul	r28, r25
    9112:	f0 01       	movw	r30, r0
    9114:	11 24       	eor	r1, r1
    9116:	ea 57       	subi	r30, 0x7A	; 122
    9118:	fd 4f       	sbci	r31, 0xFD	; 253
    911a:	c0 80       	ld	r12, Z
    911c:	d1 80       	ldd	r13, Z+1	; 0x01
    911e:	e2 80       	ldd	r14, Z+2	; 0x02
    9120:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    9122:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
	srandom(Seed);
    9126:	c7 01       	movw	r24, r14
    9128:	b6 01       	movw	r22, r12
    912a:	0e 94 a7 6b 	call	0xd74e	; 0xd74e <srandom>
	random();// 
    912e:	0e 94 a3 6b 	call	0xd746	; 0xd746 <random>
	Seed = random();
    9132:	0e 94 a3 6b 	call	0xd746	; 0xd746 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    9136:	9f 93       	push	r25
    9138:	8f 93       	push	r24
    913a:	7f 93       	push	r23
    913c:	6f 93       	push	r22
    913e:	83 e0       	ldi	r24, 0x03	; 3
    9140:	93 e0       	ldi	r25, 0x03	; 3
    9142:	9f 93       	push	r25
    9144:	8f 93       	push	r24
    9146:	89 e2       	ldi	r24, 0x29	; 41
    9148:	96 e0       	ldi	r25, 0x06	; 6
    914a:	9f 93       	push	r25
    914c:	8f 93       	push	r24
    914e:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
	Seed = random();
    9152:	0e 94 a3 6b 	call	0xd746	; 0xd746 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    9156:	9f 93       	push	r25
    9158:	8f 93       	push	r24
    915a:	7f 93       	push	r23
    915c:	6f 93       	push	r22
    915e:	89 ef       	ldi	r24, 0xF9	; 249
    9160:	92 e0       	ldi	r25, 0x02	; 2
    9162:	9f 93       	push	r25
    9164:	8f 93       	push	r24
    9166:	81 e3       	ldi	r24, 0x31	; 49
    9168:	96 e0       	ldi	r25, 0x06	; 6
    916a:	9f 93       	push	r25
    916c:	8f 93       	push	r24
    916e:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9172:	86 e5       	ldi	r24, 0x56	; 86
    9174:	90 e0       	ldi	r25, 0x00	; 0
    9176:	0e 94 61 73 	call	0xe6c2	; 0xe6c2 <__eerd_dword_m128>
    917a:	ab 01       	movw	r20, r22
    917c:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    917e:	80 91 68 09 	lds	r24, 0x0968
    9182:	0e 94 0d 2c 	call	0x581a	; 0x581a <StartTimer32>
	return 0;
    9186:	8d b7       	in	r24, 0x3d	; 61
    9188:	9e b7       	in	r25, 0x3e	; 62
    918a:	40 96       	adiw	r24, 0x10	; 16
    918c:	0f b6       	in	r0, 0x3f	; 63
    918e:	f8 94       	cli
    9190:	9e bf       	out	0x3e, r25	; 62
    9192:	0f be       	out	0x3f, r0	; 63
    9194:	8d bf       	out	0x3d, r24	; 61
    9196:	80 e0       	ldi	r24, 0x00	; 0
    9198:	03 c0       	rjmp	.+6      	; 0x91a0 <Web_Login_Error+0x104>
}
//--Session
uint8_t Web_Login_Error(void){

	//   ?
	if(WebSession) return 1;
    919a:	81 e0       	ldi	r24, 0x01	; 1
    919c:	01 c0       	rjmp	.+2      	; 0x91a0 <Web_Login_Error+0x104>
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
	return 2;}
    919e:	82 e0       	ldi	r24, 0x02	; 2
	Seed = random();
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}
    91a0:	df 91       	pop	r29
    91a2:	cf 91       	pop	r28
    91a4:	1f 91       	pop	r17
    91a6:	0f 91       	pop	r16
    91a8:	ff 90       	pop	r15
    91aa:	ef 90       	pop	r14
    91ac:	df 90       	pop	r13
    91ae:	cf 90       	pop	r12
    91b0:	08 95       	ret

000091b2 <WebRequest>:
}


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    91b2:	2f 92       	push	r2
    91b4:	3f 92       	push	r3
    91b6:	4f 92       	push	r4
    91b8:	5f 92       	push	r5
    91ba:	6f 92       	push	r6
    91bc:	7f 92       	push	r7
    91be:	8f 92       	push	r8
    91c0:	9f 92       	push	r9
    91c2:	af 92       	push	r10
    91c4:	bf 92       	push	r11
    91c6:	cf 92       	push	r12
    91c8:	df 92       	push	r13
    91ca:	ef 92       	push	r14
    91cc:	ff 92       	push	r15
    91ce:	0f 93       	push	r16
    91d0:	1f 93       	push	r17
    91d2:	cf 93       	push	r28
    91d4:	df 93       	push	r29
    91d6:	cd b7       	in	r28, 0x3d	; 61
    91d8:	de b7       	in	r29, 0x3e	; 62
    91da:	2a 97       	sbiw	r28, 0x0a	; 10
    91dc:	0f b6       	in	r0, 0x3f	; 63
    91de:	f8 94       	cli
    91e0:	de bf       	out	0x3e, r29	; 62
    91e2:	0f be       	out	0x3f, r0	; 63
    91e4:	cd bf       	out	0x3d, r28	; 61
    91e6:	9a 87       	std	Y+10, r25	; 0x0a
    91e8:	89 87       	std	Y+9, r24	; 0x09
    91ea:	69 83       	std	Y+1, r22	; 0x01
	
	
	WebStrLen = GetStringFromFIFO();
    91ec:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    91f0:	80 93 70 08 	sts	0x0870, r24

	if(Web_POST==2){ 
    91f4:	80 91 6d 09 	lds	r24, 0x096D
    91f8:	82 30       	cpi	r24, 0x02	; 2
    91fa:	a1 f4       	brne	.+40     	; 0x9224 <WebRequest+0x72>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    91fc:	80 91 41 09 	lds	r24, 0x0941
    9200:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    9204:	88 23       	and	r24, r24
    9206:	39 f0       	breq	.+14     	; 0x9216 <WebRequest+0x64>
			WebStrLen = ForceEndStringFromFIFO();
    9208:	0e 94 95 3a 	call	0x752a	; 0x752a <ForceEndStringFromFIFO>
    920c:	80 93 70 08 	sts	0x0870, r24
			Web_POST=3;	
    9210:	83 e0       	ldi	r24, 0x03	; 3
    9212:	80 93 6d 09 	sts	0x096D, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    9216:	80 91 70 08 	lds	r24, 0x0870
    921a:	88 23       	and	r24, r24
    921c:	19 f0       	breq	.+6      	; 0x9224 <WebRequest+0x72>
    921e:	83 e0       	ldi	r24, 0x03	; 3
    9220:	80 93 6d 09 	sts	0x096D, r24
	}

	//  
	if(WebStrLen){
    9224:	10 91 70 08 	lds	r17, 0x0870
    9228:	11 23       	and	r17, r17
    922a:	f9 f0       	breq	.+62     	; 0x926a <WebRequest+0xb8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    922c:	e9 85       	ldd	r30, Y+9	; 0x09
    922e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9230:	25 90       	lpm	r2, Z+
    9232:	34 90       	lpm	r3, Z
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    9234:	6b ea       	ldi	r22, 0xAB	; 171
    9236:	7b e4       	ldi	r23, 0x4B	; 75
    9238:	89 e8       	ldi	r24, 0x89	; 137
    923a:	99 e0       	ldi	r25, 0x09	; 9
    923c:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    9240:	89 2b       	or	r24, r25
    9242:	21 f0       	breq	.+8      	; 0x924c <WebRequest+0x9a>

			Web_POST = 1; 
    9244:	81 e0       	ldi	r24, 0x01	; 1
    9246:	80 93 6d 09 	sts	0x096D, r24
    924a:	0f c0       	rjmp	.+30     	; 0x926a <WebRequest+0xb8>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    924c:	80 91 6d 09 	lds	r24, 0x096D
    9250:	81 30       	cpi	r24, 0x01	; 1
    9252:	71 f4       	brne	.+28     	; 0x9270 <WebRequest+0xbe>
    9254:	11 30       	cpi	r17, 0x01	; 1
    9256:	09 f0       	breq	.+2      	; 0x925a <WebRequest+0xa8>
    9258:	8e c0       	rjmp	.+284    	; 0x9376 <WebRequest+0x1c4>
			Web_POST = 2;
    925a:	82 e0       	ldi	r24, 0x02	; 2
    925c:	80 93 6d 09 	sts	0x096D, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    9260:	64 e6       	ldi	r22, 0x64	; 100
    9262:	80 91 41 09 	lds	r24, 0x0941
    9266:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
			return NULL;
    926a:	80 e0       	ldi	r24, 0x00	; 0
    926c:	90 e0       	ldi	r25, 0x00	; 0
    926e:	94 c1       	rjmp	.+808    	; 0x9598 <WebRequest+0x3e6>
		}
		if(Web_POST==3){	//  
    9270:	83 30       	cpi	r24, 0x03	; 3
    9272:	09 f0       	breq	.+2      	; 0x9276 <WebRequest+0xc4>
    9274:	80 c0       	rjmp	.+256    	; 0x9376 <WebRequest+0x1c4>
			Web_POST = 0;
    9276:	10 92 6d 09 	sts	0x096D, r1
			url = GSM_RxStr;

			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
    927a:	f8 eb       	ldi	r31, 0xB8	; 184
    927c:	cf 2e       	mov	r12, r31
    927e:	fb e4       	ldi	r31, 0x4B	; 75
    9280:	df 2e       	mov	r13, r31
			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//For Debug
			#endif

			//URL 
			url = GSM_RxStr;
    9282:	a9 e8       	ldi	r26, 0x89	; 137
    9284:	ea 2e       	mov	r14, r26
    9286:	a9 e0       	ldi	r26, 0x09	; 9
    9288:	fa 2e       	mov	r15, r26
				varfield = p + 1;
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
    928a:	89 85       	ldd	r24, Y+9	; 0x09
    928c:	9a 85       	ldd	r25, Y+10	; 0x0a
    928e:	02 96       	adiw	r24, 0x02	; 2
    9290:	9a 83       	std	Y+2, r25	; 0x02
    9292:	89 83       	std	Y+1, r24	; 0x01
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    9294:	6d e3       	ldi	r22, 0x3D	; 61
    9296:	70 e0       	ldi	r23, 0x00	; 0
    9298:	c7 01       	movw	r24, r14
    929a:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    929e:	5c 01       	movw	r10, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) {
    92a0:	00 97       	sbiw	r24, 0x00	; 0
    92a2:	09 f4       	brne	.+2      	; 0x92a6 <WebRequest+0xf4>
    92a4:	4e c1       	rjmp	.+668    	; 0x9542 <WebRequest+0x390>
				return &Web_login;
				}
				nextvar=strchr(url+1,'&');
    92a6:	66 e2       	ldi	r22, 0x26	; 38
    92a8:	70 e0       	ldi	r23, 0x00	; 0
    92aa:	c7 01       	movw	r24, r14
    92ac:	01 96       	adiw	r24, 0x01	; 1
    92ae:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    92b2:	4c 01       	movw	r8, r24
				varfield = p + 1;
    92b4:	85 01       	movw	r16, r10
    92b6:	0f 5f       	subi	r16, 0xFF	; 255
    92b8:	1f 4f       	sbci	r17, 0xFF	; 255
				*p = '\0';
    92ba:	d5 01       	movw	r26, r10
    92bc:	1c 92       	st	X, r1
    92be:	e9 81       	ldd	r30, Y+1	; 0x01
    92c0:	fa 81       	ldd	r31, Y+2	; 0x02
    92c2:	65 90       	lpm	r6, Z+
    92c4:	74 90       	lpm	r7, Z
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92c6:	20 e0       	ldi	r18, 0x00	; 0
    92c8:	13 01       	movw	r2, r6
    92ca:	b4 e0       	ldi	r27, 0x04	; 4
    92cc:	2b 0e       	add	r2, r27
    92ce:	31 1c       	adc	r3, r1
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    92d0:	23 01       	movw	r4, r6
    92d2:	e6 e0       	ldi	r30, 0x06	; 6
    92d4:	4e 0e       	add	r4, r30
    92d6:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    92d8:	f1 01       	movw	r30, r2
    92da:	85 91       	lpm	r24, Z+
    92dc:	94 91       	lpm	r25, Z
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92de:	a2 2e       	mov	r10, r18
    92e0:	b1 2c       	mov	r11, r1
    92e2:	96 95       	lsr	r25
    92e4:	87 95       	ror	r24
    92e6:	96 95       	lsr	r25
    92e8:	87 95       	ror	r24
    92ea:	a8 16       	cp	r10, r24
    92ec:	b9 06       	cpc	r11, r25
    92ee:	50 f5       	brcc	.+84     	; 0x9344 <WebRequest+0x192>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    92f0:	f2 01       	movw	r30, r4
    92f2:	85 91       	lpm	r24, Z+
    92f4:	94 91       	lpm	r25, Z
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    92f6:	00 97       	sbiw	r24, 0x00	; 0
    92f8:	19 f1       	breq	.+70     	; 0x9340 <WebRequest+0x18e>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    92fa:	aa 0c       	add	r10, r10
    92fc:	bb 1c       	adc	r11, r11
    92fe:	aa 0c       	add	r10, r10
    9300:	bb 1c       	adc	r11, r11
    9302:	a8 0e       	add	r10, r24
    9304:	b9 1e       	adc	r11, r25
    9306:	f5 01       	movw	r30, r10
    9308:	65 91       	lpm	r22, Z+
    930a:	74 91       	lpm	r23, Z
    930c:	c7 01       	movw	r24, r14
    930e:	28 87       	std	Y+8, r18	; 0x08
    9310:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    9314:	28 85       	ldd	r18, Y+8	; 0x08
    9316:	89 2b       	or	r24, r25
    9318:	99 f4       	brne	.+38     	; 0x9340 <WebRequest+0x18e>
    931a:	c8 01       	movw	r24, r16
    931c:	8c 01       	movw	r16, r24
    931e:	01 96       	adiw	r24, 0x01	; 1
								while(*varfield=='+') varfield++;	// ignore leading '+'
    9320:	d8 01       	movw	r26, r16
    9322:	3c 91       	ld	r19, X
    9324:	3b 32       	cpi	r19, 0x2B	; 43
    9326:	d1 f3       	breq	.-12     	; 0x931c <WebRequest+0x16a>
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield); 
    9328:	b2 e0       	ldi	r27, 0x02	; 2
    932a:	ab 0e       	add	r10, r27
    932c:	b1 1c       	adc	r11, r1
    932e:	f5 01       	movw	r30, r10
    9330:	85 91       	lpm	r24, Z+
    9332:	94 91       	lpm	r25, Z
    9334:	b8 01       	movw	r22, r16
    9336:	28 87       	std	Y+8, r18	; 0x08
    9338:	0e 94 e1 43 	call	0x87c2	; 0x87c2 <WebBuf2Field>
								ptrPageVar = ptrPage;	//  -    ptrPage
    933c:	63 01       	movw	r12, r6
    933e:	28 85       	ldd	r18, Y+8	; 0x08
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9340:	2f 5f       	subi	r18, 0xFF	; 255
    9342:	ca cf       	rjmp	.-108    	; 0x92d8 <WebRequest+0x126>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    9344:	74 01       	movw	r14, r8
    9346:	ef ef       	ldi	r30, 0xFF	; 255
    9348:	ee 1a       	sub	r14, r30
    934a:	fe 0a       	sbc	r15, r30
			}while(nextvar);	//     
    934c:	89 28       	or	r8, r9
    934e:	09 f0       	breq	.+2      	; 0x9352 <WebRequest+0x1a0>
    9350:	a1 cf       	rjmp	.-190    	; 0x9294 <WebRequest+0xe2>

			if(Web_LoginAttempt){				
    9352:	80 91 3a 08 	lds	r24, 0x083A
    9356:	88 23       	and	r24, r24
    9358:	09 f4       	brne	.+2      	; 0x935c <WebRequest+0x1aa>
    935a:	18 c1       	rjmp	.+560    	; 0x958c <WebRequest+0x3da>
				Web_LoginAttempt = 0;
    935c:	10 92 3a 08 	sts	0x083A, r1
				Web_Login_Code = Web_Login_Error();
    9360:	0e 94 4e 48 	call	0x909c	; 0x909c <Web_Login_Error>
    9364:	80 93 09 06 	sts	0x0609, r24
				if(!Web_Login_Code){ return prp(ptrSite);}
    9368:	81 11       	cpse	r24, r1
    936a:	10 c1       	rjmp	.+544    	; 0x958c <WebRequest+0x3da>
    936c:	e9 85       	ldd	r30, Y+9	; 0x09
    936e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9370:	85 91       	lpm	r24, Z+
    9372:	94 91       	lpm	r25, Z
    9374:	11 c1       	rjmp	.+546    	; 0x9598 <WebRequest+0x3e6>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    9376:	62 eb       	ldi	r22, 0xB2	; 178
    9378:	7b e4       	ldi	r23, 0x4B	; 75
    937a:	89 e8       	ldi	r24, 0x89	; 137
    937c:	99 e0       	ldi	r25, 0x09	; 9
    937e:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    9382:	89 2b       	or	r24, r25
    9384:	09 f4       	brne	.+2      	; 0x9388 <WebRequest+0x1d6>
    9386:	71 cf       	rjmp	.-286    	; 0x926a <WebRequest+0xb8>
    9388:	60 e2       	ldi	r22, 0x20	; 32
    938a:	70 e0       	ldi	r23, 0x00	; 0
    938c:	8d e8       	ldi	r24, 0x8D	; 141
    938e:	99 e0       	ldi	r25, 0x09	; 9
    9390:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    9394:	00 97       	sbiw	r24, 0x00	; 0
    9396:	09 f4       	brne	.+2      	; 0x939a <WebRequest+0x1e8>
    9398:	68 cf       	rjmp	.-304    	; 0x926a <WebRequest+0xb8>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    939a:	dc 01       	movw	r26, r24
    939c:	1c 92       	st	X, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    939e:	60 e7       	ldi	r22, 0x70	; 112
    93a0:	79 e3       	ldi	r23, 0x39	; 57
    93a2:	8e e8       	ldi	r24, 0x8E	; 142
    93a4:	99 e0       	ldi	r25, 0x09	; 9
    93a6:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    93aa:	89 2b       	or	r24, r25
    93ac:	09 f4       	brne	.+2      	; 0x93b0 <WebRequest+0x1fe>
    93ae:	eb c0       	rjmp	.+470    	; 0x9586 <WebRequest+0x3d4>
			url = strchr(url,'?');
    93b0:	6f e3       	ldi	r22, 0x3F	; 63
    93b2:	70 e0       	ldi	r23, 0x00	; 0
    93b4:	8d e8       	ldi	r24, 0x8D	; 141
    93b6:	99 e0       	ldi	r25, 0x09	; 9
    93b8:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    93bc:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    93be:	80 91 7e 09 	lds	r24, 0x097E
    93c2:	88 23       	and	r24, r24
    93c4:	09 f4       	brne	.+2      	; 0x93c8 <WebRequest+0x216>
    93c6:	bd c0       	rjmp	.+378    	; 0x9542 <WebRequest+0x390>
    93c8:	01 15       	cp	r16, r1
    93ca:	11 05       	cpc	r17, r1
    93cc:	09 f4       	brne	.+2      	; 0x93d0 <WebRequest+0x21e>
    93ce:	b9 c0       	rjmp	.+370    	; 0x9542 <WebRequest+0x390>
    93d0:	48 e0       	ldi	r20, 0x08	; 8
    93d2:	50 e0       	ldi	r21, 0x00	; 0
    93d4:	6a e3       	ldi	r22, 0x3A	; 58
    93d6:	7c e4       	ldi	r23, 0x4C	; 76
    93d8:	c8 01       	movw	r24, r16
    93da:	0e 94 f4 6b 	call	0xd7e8	; 0xd7e8 <strncmp_P>
    93de:	89 2b       	or	r24, r25
    93e0:	09 f0       	breq	.+2      	; 0x93e4 <WebRequest+0x232>
    93e2:	af c0       	rjmp	.+350    	; 0x9542 <WebRequest+0x390>
    93e4:	40 e1       	ldi	r20, 0x10	; 16
    93e6:	50 e0       	ldi	r21, 0x00	; 0
    93e8:	69 e2       	ldi	r22, 0x29	; 41
    93ea:	76 e0       	ldi	r23, 0x06	; 6
    93ec:	c8 01       	movw	r24, r16
    93ee:	08 96       	adiw	r24, 0x08	; 8
    93f0:	0e 94 40 6c 	call	0xd880	; 0xd880 <strncmp>
    93f4:	89 2b       	or	r24, r25
    93f6:	09 f0       	breq	.+2      	; 0x93fa <WebRequest+0x248>
    93f8:	a4 c0       	rjmp	.+328    	; 0x9542 <WebRequest+0x390>
    93fa:	61 01       	movw	r12, r2
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    93fc:	86 e5       	ldi	r24, 0x56	; 86
    93fe:	90 e0       	ldi	r25, 0x00	; 0
    9400:	0e 94 61 73 	call	0xe6c2	; 0xe6c2 <__eerd_dword_m128>
    9404:	ab 01       	movw	r20, r22
    9406:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    9408:	80 91 68 09 	lds	r24, 0x0968
    940c:	0e 94 0d 2c 	call	0x581a	; 0x581a <StartTimer32>
			
			*url = '\0';
    9410:	f8 01       	movw	r30, r16
    9412:	11 92       	st	Z+, r1
    9414:	cf 01       	movw	r24, r30
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    9416:	66 e2       	ldi	r22, 0x26	; 38
    9418:	70 e0       	ldi	r23, 0x00	; 0
    941a:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    941e:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    9420:	00 97       	sbiw	r24, 0x00	; 0
    9422:	09 f4       	brne	.+2      	; 0x9426 <WebRequest+0x274>
    9424:	77 c0       	rjmp	.+238    	; 0x9514 <WebRequest+0x362>
    9426:	68 eb       	ldi	r22, 0xB8	; 184
    9428:	26 2e       	mov	r2, r22
    942a:	6b e4       	ldi	r22, 0x4B	; 75
    942c:	36 2e       	mov	r3, r22
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    942e:	6d e3       	ldi	r22, 0x3D	; 61
    9430:	70 e0       	ldi	r23, 0x00	; 0
    9432:	c8 01       	movw	r24, r16
    9434:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    9438:	5c 01       	movw	r10, r24
					if(p==NULL) return ptrPage;
    943a:	00 97       	sbiw	r24, 0x00	; 0
    943c:	09 f4       	brne	.+2      	; 0x9440 <WebRequest+0x28e>
    943e:	a6 c0       	rjmp	.+332    	; 0x958c <WebRequest+0x3da>
					nextvar=strchr(url+1,'&');
    9440:	28 01       	movw	r4, r16
    9442:	ff ef       	ldi	r31, 0xFF	; 255
    9444:	4f 1a       	sub	r4, r31
    9446:	5f 0a       	sbc	r5, r31
    9448:	66 e2       	ldi	r22, 0x26	; 38
    944a:	70 e0       	ldi	r23, 0x00	; 0
    944c:	c2 01       	movw	r24, r4
    944e:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    9452:	8c 01       	movw	r16, r24
					varfield = p + 1;
    9454:	75 01       	movw	r14, r10
    9456:	2f ef       	ldi	r18, 0xFF	; 255
    9458:	e2 1a       	sub	r14, r18
    945a:	f2 0a       	sbc	r15, r18
					*p = '\0';
    945c:	d5 01       	movw	r26, r10
    945e:	1c 92       	st	X, r1
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9460:	69 84       	ldd	r6, Y+9	; 0x09
    9462:	7a 84       	ldd	r7, Y+10	; 0x0a
    9464:	30 e0       	ldi	r19, 0x00	; 0
    9466:	29 81       	ldd	r18, Y+1	; 0x01
    9468:	32 17       	cp	r19, r18
    946a:	09 f4       	brne	.+2      	; 0x946e <WebRequest+0x2bc>
    946c:	4e c0       	rjmp	.+156    	; 0x950a <WebRequest+0x358>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    946e:	f3 01       	movw	r30, r6
    9470:	85 90       	lpm	r8, Z+
    9472:	94 90       	lpm	r9, Z
    9474:	64 01       	movw	r12, r8
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9476:	20 e0       	ldi	r18, 0x00	; 0
    9478:	f4 01       	movw	r30, r8
    947a:	34 96       	adiw	r30, 0x04	; 4
    947c:	fc 83       	std	Y+4, r31	; 0x04
    947e:	eb 83       	std	Y+3, r30	; 0x03
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    9480:	c4 01       	movw	r24, r8
    9482:	06 96       	adiw	r24, 0x06	; 6
    9484:	9e 83       	std	Y+6, r25	; 0x06
    9486:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9488:	eb 81       	ldd	r30, Y+3	; 0x03
    948a:	fc 81       	ldd	r31, Y+4	; 0x04
    948c:	85 91       	lpm	r24, Z+
    948e:	94 91       	lpm	r25, Z
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9490:	a2 2e       	mov	r10, r18
    9492:	b1 2c       	mov	r11, r1
    9494:	96 95       	lsr	r25
    9496:	87 95       	ror	r24
    9498:	96 95       	lsr	r25
    949a:	87 95       	ror	r24
    949c:	a8 16       	cp	r10, r24
    949e:	b9 06       	cpc	r11, r25
    94a0:	78 f5       	brcc	.+94     	; 0x9500 <WebRequest+0x34e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    94a2:	ed 81       	ldd	r30, Y+5	; 0x05
    94a4:	fe 81       	ldd	r31, Y+6	; 0x06
    94a6:	85 91       	lpm	r24, Z+
    94a8:	94 91       	lpm	r25, Z
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    94aa:	00 97       	sbiw	r24, 0x00	; 0
    94ac:	39 f1       	breq	.+78     	; 0x94fc <WebRequest+0x34a>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    94ae:	aa 0c       	add	r10, r10
    94b0:	bb 1c       	adc	r11, r11
    94b2:	aa 0c       	add	r10, r10
    94b4:	bb 1c       	adc	r11, r11
    94b6:	a8 0e       	add	r10, r24
    94b8:	b9 1e       	adc	r11, r25
    94ba:	f5 01       	movw	r30, r10
    94bc:	65 91       	lpm	r22, Z+
    94be:	74 91       	lpm	r23, Z
    94c0:	c2 01       	movw	r24, r4
    94c2:	28 87       	std	Y+8, r18	; 0x08
    94c4:	3f 83       	std	Y+7, r19	; 0x07
    94c6:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    94ca:	28 85       	ldd	r18, Y+8	; 0x08
    94cc:	3f 81       	ldd	r19, Y+7	; 0x07
    94ce:	89 2b       	or	r24, r25
    94d0:	a9 f4       	brne	.+42     	; 0x94fc <WebRequest+0x34a>
    94d2:	c7 01       	movw	r24, r14
    94d4:	7c 01       	movw	r14, r24
    94d6:	01 96       	adiw	r24, 0x01	; 1
									while(*varfield=='+') varfield++;	// ignore leading '+'
    94d8:	d7 01       	movw	r26, r14
    94da:	4c 91       	ld	r20, X
    94dc:	4b 32       	cpi	r20, 0x2B	; 43
    94de:	d1 f3       	breq	.-12     	; 0x94d4 <WebRequest+0x322>
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    94e0:	b2 e0       	ldi	r27, 0x02	; 2
    94e2:	ab 0e       	add	r10, r27
    94e4:	b1 1c       	adc	r11, r1
    94e6:	f5 01       	movw	r30, r10
    94e8:	85 91       	lpm	r24, Z+
    94ea:	94 91       	lpm	r25, Z
    94ec:	b7 01       	movw	r22, r14
    94ee:	28 87       	std	Y+8, r18	; 0x08
    94f0:	3f 83       	std	Y+7, r19	; 0x07
    94f2:	0e 94 e1 43 	call	0x87c2	; 0x87c2 <WebBuf2Field>
									ptrPageVar = ptrPage;	//  -    ptrPage
    94f6:	14 01       	movw	r2, r8
    94f8:	3f 81       	ldd	r19, Y+7	; 0x07
    94fa:	28 85       	ldd	r18, Y+8	; 0x08
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    94fc:	2f 5f       	subi	r18, 0xFF	; 255
    94fe:	c4 cf       	rjmp	.-120    	; 0x9488 <WebRequest+0x2d6>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9500:	3f 5f       	subi	r19, 0xFF	; 255
    9502:	e2 e0       	ldi	r30, 0x02	; 2
    9504:	6e 0e       	add	r6, r30
    9506:	71 1c       	adc	r7, r1
    9508:	ae cf       	rjmp	.-164    	; 0x9466 <WebRequest+0x2b4>
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    950a:	01 15       	cp	r16, r1
    950c:	11 05       	cpc	r17, r1
    950e:	09 f0       	breq	.+2      	; 0x9512 <WebRequest+0x360>
    9510:	8e cf       	rjmp	.-228    	; 0x942e <WebRequest+0x27c>
    9512:	3e c0       	rjmp	.+124    	; 0x9590 <WebRequest+0x3de>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    9514:	6a e1       	ldi	r22, 0x1A	; 26
    9516:	73 e0       	ldi	r23, 0x03	; 3
    9518:	8d e8       	ldi	r24, 0x8D	; 141
    951a:	99 e0       	ldi	r25, 0x09	; 9
    951c:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    9520:	89 2b       	or	r24, r25
    9522:	09 f4       	brne	.+2      	; 0x9526 <WebRequest+0x374>
    9524:	35 c0       	rjmp	.+106    	; 0x9590 <WebRequest+0x3de>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    9526:	6e e0       	ldi	r22, 0x0E	; 14
    9528:	73 e0       	ldi	r23, 0x03	; 3
    952a:	8e e8       	ldi	r24, 0x8E	; 142
    952c:	99 e0       	ldi	r25, 0x09	; 9
    952e:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    9532:	89 2b       	or	r24, r25
    9534:	21 f0       	breq	.+8      	; 0x953e <WebRequest+0x38c>
    9536:	e9 84       	ldd	r14, Y+9	; 0x09
    9538:	fa 84       	ldd	r15, Y+10	; 0x0a
    953a:	10 e0       	ldi	r17, 0x00	; 0
    953c:	15 c0       	rjmp	.+42     	; 0x9568 <WebRequest+0x3b6>
				WebSession = 0;
    953e:	10 92 7e 09 	sts	0x097E, r1
				return &Web_login;
    9542:	81 e9       	ldi	r24, 0x91	; 145
    9544:	98 e4       	ldi	r25, 0x48	; 72
    9546:	28 c0       	rjmp	.+80     	; 0x9598 <WebRequest+0x3e6>
    9548:	f7 01       	movw	r30, r14
    954a:	c5 90       	lpm	r12, Z+
    954c:	d4 90       	lpm	r13, Z
    954e:	f6 01       	movw	r30, r12
    9550:	65 91       	lpm	r22, Z+
    9552:	74 91       	lpm	r23, Z
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    9554:	8e e8       	ldi	r24, 0x8E	; 142
    9556:	99 e0       	ldi	r25, 0x09	; 9
    9558:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    955c:	a2 e0       	ldi	r26, 0x02	; 2
    955e:	ea 0e       	add	r14, r26
    9560:	f1 1c       	adc	r15, r1
    9562:	89 2b       	or	r24, r25
    9564:	29 f0       	breq	.+10     	; 0x9570 <WebRequest+0x3be>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    9566:	1f 5f       	subi	r17, 0xFF	; 255
    9568:	29 81       	ldd	r18, Y+1	; 0x01
    956a:	12 13       	cpse	r17, r18
    956c:	ed cf       	rjmp	.-38     	; 0x9548 <WebRequest+0x396>
    956e:	08 c0       	rjmp	.+16     	; 0x9580 <WebRequest+0x3ce>
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9570:	f6 01       	movw	r30, r12
    9572:	3c 96       	adiw	r30, 0x0c	; 12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9574:	e4 91       	lpm	r30, Z
    9576:	80 91 6c 0a 	lds	r24, 0x0A6C
    957a:	8e 17       	cp	r24, r30
    957c:	58 f0       	brcs	.+22     	; 0x9594 <WebRequest+0x3e2>
    957e:	06 c0       	rjmp	.+12     	; 0x958c <WebRequest+0x3da>
					return ptrPage;				
				}
			}
			
			//  URL
			return &Web_error_page;
    9580:	88 eb       	ldi	r24, 0xB8	; 184
    9582:	9b e4       	ldi	r25, 0x4B	; 75
    9584:	09 c0       	rjmp	.+18     	; 0x9598 <WebRequest+0x3e6>
			#endif

			*p = '\0';

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9586:	85 ee       	ldi	r24, 0xE5	; 229
    9588:	93 e3       	ldi	r25, 0x33	; 51
    958a:	06 c0       	rjmp	.+12     	; 0x9598 <WebRequest+0x3e6>
    958c:	c6 01       	movw	r24, r12
    958e:	04 c0       	rjmp	.+8      	; 0x9598 <WebRequest+0x3e6>
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
				return ptrPage;			
    9590:	c1 01       	movw	r24, r2
    9592:	02 c0       	rjmp	.+4      	; 0x9598 <WebRequest+0x3e6>
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9594:	8c ea       	ldi	r24, 0xAC	; 172
    9596:	92 e3       	ldi	r25, 0x32	; 50
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    9598:	2a 96       	adiw	r28, 0x0a	; 10
    959a:	0f b6       	in	r0, 0x3f	; 63
    959c:	f8 94       	cli
    959e:	de bf       	out	0x3e, r29	; 62
    95a0:	0f be       	out	0x3f, r0	; 63
    95a2:	cd bf       	out	0x3d, r28	; 61
    95a4:	df 91       	pop	r29
    95a6:	cf 91       	pop	r28
    95a8:	1f 91       	pop	r17
    95aa:	0f 91       	pop	r16
    95ac:	ff 90       	pop	r15
    95ae:	ef 90       	pop	r14
    95b0:	df 90       	pop	r13
    95b2:	cf 90       	pop	r12
    95b4:	bf 90       	pop	r11
    95b6:	af 90       	pop	r10
    95b8:	9f 90       	pop	r9
    95ba:	8f 90       	pop	r8
    95bc:	7f 90       	pop	r7
    95be:	6f 90       	pop	r6
    95c0:	5f 90       	pop	r5
    95c2:	4f 90       	pop	r4
    95c4:	3f 90       	pop	r3
    95c6:	2f 90       	pop	r2
    95c8:	08 95       	ret

000095ca <EM_InitFIFO>:
void EMeter_NoLink(void);
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){cli();
    95ca:	f8 94       	cli
	EM_RX_FIFO_Begin = 255;
    95cc:	8f ef       	ldi	r24, 0xFF	; 255
    95ce:	80 93 70 09 	sts	0x0970, r24
	EM_RX_FIFO_End = 255;
    95d2:	80 93 38 0d 	sts	0x0D38, r24
	EMeter_RxCharN = 0;
    95d6:	10 92 3f 0d 	sts	0x0D3F, r1
    95da:	10 92 3e 0d 	sts	0x0D3E, r1
	sei();
    95de:	78 94       	sei
    95e0:	08 95       	ret

000095e2 <EM_SetUARTParam>:
		EM_UART_BitQt = 3;		
	}
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
    95e2:	29 2f       	mov	r18, r25
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    95e4:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    95e8:	80 93 6b 0a 	sts	0x0A6B, r24

	switch(EM_UART_Rate){
    95ec:	90 e0       	ldi	r25, 0x00	; 0
    95ee:	89 30       	cpi	r24, 0x09	; 9
    95f0:	91 05       	cpc	r25, r1
    95f2:	38 f5       	brcc	.+78     	; 0x9642 <EM_SetUARTParam+0x60>
    95f4:	fc 01       	movw	r30, r24
    95f6:	eb 55       	subi	r30, 0x5B	; 91
    95f8:	ff 4f       	sbci	r31, 0xFF	; 255
    95fa:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    95fe:	83 e0       	ldi	r24, 0x03	; 3
    9600:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    9604:	82 e4       	ldi	r24, 0x42	; 66
    9606:	20 c0       	rjmp	.+64     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    9608:	81 e0       	ldi	r24, 0x01	; 1
    960a:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    960e:	80 ea       	ldi	r24, 0xA0	; 160
    9610:	1b c0       	rjmp	.+54     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    9612:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    9616:	8f ec       	ldi	r24, 0xCF	; 207
    9618:	17 c0       	rjmp	.+46     	; 0x9648 <EM_SetUARTParam+0x66>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    961a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    961e:	84 e4       	ldi	r24, 0x44	; 68
    9620:	13 c0       	rjmp	.+38     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    9622:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    9626:	83 e3       	ldi	r24, 0x33	; 51
    9628:	0f c0       	rjmp	.+30     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    962a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    962e:	82 e2       	ldi	r24, 0x22	; 34
    9630:	0b c0       	rjmp	.+22     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    9632:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    9636:	89 e1       	ldi	r24, 0x19	; 25
    9638:	07 c0       	rjmp	.+14     	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    963a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    963e:	80 e1       	ldi	r24, 0x10	; 16
    9640:	03 c0       	rjmp	.+6      	; 0x9648 <EM_SetUARTParam+0x66>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    9642:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    9646:	87 e6       	ldi	r24, 0x67	; 103
    9648:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    964c:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    9650:	82 2f       	mov	r24, r18
    9652:	83 70       	andi	r24, 0x03	; 3
    9654:	80 93 0c 06 	sts	0x060C, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    9658:	82 30       	cpi	r24, 0x02	; 2
    965a:	41 f0       	breq	.+16     	; 0x966c <EM_SetUARTParam+0x8a>
    965c:	83 30       	cpi	r24, 0x03	; 3
    965e:	51 f0       	breq	.+20     	; 0x9674 <EM_SetUARTParam+0x92>
    9660:	81 30       	cpi	r24, 0x01	; 1
    9662:	41 f4       	brne	.+16     	; 0x9674 <EM_SetUARTParam+0x92>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9664:	80 91 9d 00 	lds	r24, 0x009D
    9668:	80 62       	ori	r24, 0x20	; 32
    966a:	06 c0       	rjmp	.+12     	; 0x9678 <EM_SetUARTParam+0x96>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    966c:	80 91 9d 00 	lds	r24, 0x009D
    9670:	80 63       	ori	r24, 0x30	; 48
    9672:	02 c0       	rjmp	.+4      	; 0x9678 <EM_SetUARTParam+0x96>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9674:	80 91 9d 00 	lds	r24, 0x009D
    9678:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    967c:	22 fb       	bst	r18, 2
    967e:	88 27       	eor	r24, r24
    9680:	80 f9       	bld	r24, 0
    9682:	80 93 42 09 	sts	0x0942, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    9686:	81 30       	cpi	r24, 0x01	; 1
    9688:	19 f0       	breq	.+6      	; 0x9690 <EM_SetUARTParam+0xae>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    968a:	80 91 9d 00 	lds	r24, 0x009D
    968e:	03 c0       	rjmp	.+6      	; 0x9696 <EM_SetUARTParam+0xb4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    9690:	80 91 9d 00 	lds	r24, 0x009D
    9694:	88 60       	ori	r24, 0x08	; 8
    9696:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    969a:	92 2f       	mov	r25, r18
    969c:	96 95       	lsr	r25
    969e:	96 95       	lsr	r25
    96a0:	96 95       	lsr	r25
    96a2:	93 70       	andi	r25, 0x03	; 3
    96a4:	90 93 72 0a 	sts	0x0A72, r25
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96a8:	80 91 9d 00 	lds	r24, 0x009D
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    96ac:	92 30       	cpi	r25, 0x02	; 2
    96ae:	31 f0       	breq	.+12     	; 0x96bc <EM_SetUARTParam+0xda>
    96b0:	93 30       	cpi	r25, 0x03	; 3
    96b2:	31 f0       	breq	.+12     	; 0x96c0 <EM_SetUARTParam+0xde>
    96b4:	91 30       	cpi	r25, 0x01	; 1
    96b6:	29 f4       	brne	.+10     	; 0x96c2 <EM_SetUARTParam+0xe0>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96b8:	82 60       	ori	r24, 0x02	; 2
    96ba:	03 c0       	rjmp	.+6      	; 0x96c2 <EM_SetUARTParam+0xe0>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96bc:	84 60       	ori	r24, 0x04	; 4
    96be:	01 c0       	rjmp	.+2      	; 0x96c2 <EM_SetUARTParam+0xe0>
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96c0:	86 60       	ori	r24, 0x06	; 6
    96c2:	80 93 9d 00 	sts	0x009D, r24
    96c6:	08 95       	ret

000096c8 <ApplyUARTParam>:
	}
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
    96c8:	80 91 6b 0a 	lds	r24, 0x0A6B
    96cc:	60 91 0c 06 	lds	r22, 0x060C
    96d0:	70 e0       	ldi	r23, 0x00	; 0
    96d2:	76 2f       	mov	r23, r22
    96d4:	66 27       	eor	r22, r22
    96d6:	68 0f       	add	r22, r24
    96d8:	71 1d       	adc	r23, r1
    96da:	80 91 42 09 	lds	r24, 0x0942
    96de:	90 e0       	ldi	r25, 0x00	; 0
    96e0:	98 2f       	mov	r25, r24
    96e2:	88 27       	eor	r24, r24
    96e4:	99 0f       	add	r25, r25
    96e6:	99 0f       	add	r25, r25
    96e8:	68 0f       	add	r22, r24
    96ea:	79 1f       	adc	r23, r25
    96ec:	80 91 72 0a 	lds	r24, 0x0A72
    96f0:	90 e0       	ldi	r25, 0x00	; 0
    96f2:	98 2f       	mov	r25, r24
    96f4:	88 27       	eor	r24, r24
    96f6:	99 0f       	add	r25, r25
    96f8:	99 0f       	add	r25, r25
    96fa:	99 0f       	add	r25, r25
    96fc:	68 0f       	add	r22, r24
    96fe:	79 1f       	adc	r23, r25
	eww(&EM_UART_Param, Temp16);
    9700:	87 e2       	ldi	r24, 0x27	; 39
    9702:	90 e0       	ldi	r25, 0x00	; 0
    9704:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    9708:	80 91 75 0a 	lds	r24, 0x0A75
    970c:	81 11       	cpse	r24, r1
    970e:	06 c0       	rjmp	.+12     	; 0x971c <ApplyUARTParam+0x54>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9710:	87 e2       	ldi	r24, 0x27	; 39
    9712:	90 e0       	ldi	r25, 0x00	; 0
    9714:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    9718:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    971c:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <Modbus_ReadHoldReg>

00009720 <ChangeUARTParam>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9720:	89 e2       	ldi	r24, 0x29	; 41
    9722:	90 e0       	ldi	r25, 0x00	; 0
    9724:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9728:	81 30       	cpi	r24, 0x01	; 1
    972a:	51 f4       	brne	.+20     	; 0x9740 <ChangeUARTParam+0x20>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    972c:	93 e0       	ldi	r25, 0x03	; 3
    972e:	90 93 6b 0a 	sts	0x0A6B, r25
		EM_UART_Parity = 1;
    9732:	80 93 0c 06 	sts	0x060C, r24
		EM_UART_StopBits = 0;
    9736:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 2;
    973a:	82 e0       	ldi	r24, 0x02	; 2
    973c:	80 93 72 0a 	sts	0x0A72, r24
    9740:	89 e2       	ldi	r24, 0x29	; 41
    9742:	90 e0       	ldi	r25, 0x00	; 0
    9744:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    9748:	82 50       	subi	r24, 0x02	; 2
    974a:	83 30       	cpi	r24, 0x03	; 3
    974c:	48 f4       	brcc	.+18     	; 0x9760 <ChangeUARTParam+0x40>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    974e:	83 e0       	ldi	r24, 0x03	; 3
    9750:	80 93 6b 0a 	sts	0x0A6B, r24
		EM_UART_Parity = 0;
    9754:	10 92 0c 06 	sts	0x060C, r1
		EM_UART_StopBits = 0;
    9758:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 3;		
    975c:	80 93 72 0a 	sts	0x0A72, r24
	}
	ApplyUARTParam();
    9760:	0c 94 64 4b 	jmp	0x96c8	; 0x96c8 <ApplyUARTParam>

00009764 <EMeter_ReInit>:
	}
}
void EMeter_ReInit(void){

	//RS485
	MB_PLC_Init();
    9764:	0e 94 ad 2e 	call	0x5d5a	; 0x5d5a <MB_PLC_Init>
	
	#ifdef CTS
		CTS_Config();
    9768:	0e 94 d6 2e 	call	0x5dac	; 0x5dac <CTS_Config>
		CTS_OFF();
    976c:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <CTS_OFF>
	#endif
	#ifdef RTS
		RTS_Config();
    9770:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <RTS_Config>
	#endif

	EM_InitFIFO();
    9774:	0e 94 e5 4a 	call	0x95ca	; 0x95ca <EM_InitFIFO>

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9778:	88 e9       	ldi	r24, 0x98	; 152
    977a:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    977e:	80 e4       	ldi	r24, 0x40	; 64
    9780:	80 93 9b 00 	sts	0x009B, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9784:	87 e2       	ldi	r24, 0x27	; 39
    9786:	90 e0       	ldi	r25, 0x00	; 0
    9788:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    978c:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <EM_SetUARTParam>

	EM_HalfBufferStart= EMeter_RxStr;//----    
    9790:	8c e3       	ldi	r24, 0x3C	; 60
    9792:	97 e0       	ldi	r25, 0x07	; 7
    9794:	90 93 88 09 	sts	0x0988, r25
    9798:	80 93 87 09 	sts	0x0987, r24
	EMeter_RxStr_Offset = EMeter_RxStr;
    979c:	90 93 08 06 	sts	0x0608, r25
    97a0:	80 93 07 06 	sts	0x0607, r24
	EM_BufferReadEnable=0;//----- 
    97a4:	10 92 50 09 	sts	0x0950, r1
	EMeter_RxCharN=0;
    97a8:	10 92 3f 0d 	sts	0x0D3F, r1
    97ac:	10 92 3e 0d 	sts	0x0D3E, r1
    97b0:	08 95       	ret

000097b2 <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    97b2:	80 91 76 0a 	lds	r24, 0x0A76
    97b6:	88 23       	and	r24, r24
    97b8:	31 f0       	breq	.+12     	; 0x97c6 <GSM_CloseTransparent+0x14>
		cli();		
    97ba:	f8 94       	cli
		Transparent = 0;
    97bc:	10 92 76 0a 	sts	0x0A76, r1
		EMeter_ReInit();
    97c0:	0e 94 b2 4b 	call	0x9764	; 0x9764 <EMeter_ReInit>
		sei();		
    97c4:	78 94       	sei
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    97c6:	6f ef       	ldi	r22, 0xFF	; 255
    97c8:	7f ef       	ldi	r23, 0xFF	; 255
    97ca:	80 91 59 02 	lds	r24, 0x0259
    97ce:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>

000097d2 <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    97d2:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    97d6:	91 e0       	ldi	r25, 0x01	; 1
    97d8:	98 0f       	add	r25, r24
    97da:	90 93 0e 01 	sts	0x010E, r25

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    97de:	80 93 38 0c 	sts	0x0C38, r24
	EMeter_ReInit();
    97e2:	0e 94 b2 4b 	call	0x9764	; 0x9764 <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    97e6:	8a e0       	ldi	r24, 0x0A	; 10
    97e8:	90 e0       	ldi	r25, 0x00	; 0
    97ea:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	if(erb(&AutoSend)){
    97ee:	88 23       	and	r24, r24
    97f0:	49 f0       	breq	.+18     	; 0x9804 <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    97f2:	68 ee       	ldi	r22, 0xE8	; 232
    97f4:	73 e0       	ldi	r23, 0x03	; 3
    97f6:	80 91 38 0c 	lds	r24, 0x0C38
    97fa:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
		EM_Mode = 0;
    97fe:	10 92 71 0a 	sts	0x0A71, r1
    9802:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    9804:	8f ef       	ldi	r24, 0xFF	; 255
    9806:	80 93 71 0a 	sts	0x0A71, r24
    980a:	08 95       	ret

0000980c <USART_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    980c:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    9810:	91 e0       	ldi	r25, 0x01	; 1
    9812:	98 0f       	add	r25, r24
    9814:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
    9818:	80 93 4c 09 	sts	0x094C, r24

	MB_Init();
    981c:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <MB_Init>
	EMeter_Init();
    9820:	0e 94 e9 4b 	call	0x97d2	; 0x97d2 <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
    9824:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
    9826:	d8 9a       	sbi	0x1b, 0	; 27
    9828:	85 e3       	ldi	r24, 0x35	; 53
    982a:	8a 95       	dec	r24
    982c:	f1 f7       	brne	.-4      	; 0x982a <USART_Init+0x1e>
    982e:	00 00       	nop
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
    9830:	c8 99       	sbic	0x19, 0	; 25
    9832:	08 c0       	rjmp	.+16     	; 0x9844 <USART_Init+0x38>
		MB_Init();
    9834:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <MB_Init>
		UART_Soft = 1;
    9838:	81 e0       	ldi	r24, 0x01	; 1
    983a:	80 93 75 0a 	sts	0x0A75, r24
		ModbusMode = 1;
    983e:	80 93 e0 03 	sts	0x03E0, r24
    9842:	06 c0       	rjmp	.+12     	; 0x9850 <USART_Init+0x44>
	}
	else{
		EMeter_ReInit();
    9844:	0e 94 b2 4b 	call	0x9764	; 0x9764 <EMeter_ReInit>
		UART_Soft = 0;
    9848:	10 92 75 0a 	sts	0x0A75, r1
		ModbusMode = 0;
    984c:	10 92 e0 03 	sts	0x03E0, r1
	}
	
	GSM_Init();
    9850:	0c 94 e4 3a 	jmp	0x75c8	; 0x75c8 <GSM_Init>

00009854 <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    9854:	80 91 76 0a 	lds	r24, 0x0A76
    9858:	88 23       	and	r24, r24
    985a:	a9 f1       	breq	.+106    	; 0x98c6 <EMeter_RX+0x72>
					StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    985c:	60 91 0b 01 	lds	r22, 0x010B
    9860:	70 91 0c 01 	lds	r23, 0x010C
    9864:	80 91 40 0d 	lds	r24, 0x0D40
    9868:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    986c:	60 91 09 01 	lds	r22, 0x0109
    9870:	70 91 0a 01 	lds	r23, 0x010A
    9874:	80 91 0b 06 	lds	r24, 0x060B
    9878:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					EMeterIsLink=1;
    987c:	81 e0       	ldi	r24, 0x01	; 1
    987e:	80 93 5d 09 	sts	0x095D, r24
		char Char = UDR_EMETER;
    9882:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    9886:	80 91 70 09 	lds	r24, 0x0970
    988a:	8f 5f       	subi	r24, 0xFF	; 255
    988c:	80 93 70 09 	sts	0x0970, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    9890:	80 91 70 09 	lds	r24, 0x0970
    9894:	8f 3f       	cpi	r24, 0xFF	; 255
    9896:	11 f4       	brne	.+4      	; 0x989c <EMeter_RX+0x48>
    9898:	10 92 70 09 	sts	0x0970, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    989c:	e0 91 70 09 	lds	r30, 0x0970
    98a0:	f0 e0       	ldi	r31, 0x00	; 0
    98a2:	e7 50       	subi	r30, 0x07	; 7
    98a4:	fc 4f       	sbci	r31, 0xFC	; 252
    98a6:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    98a8:	90 91 70 09 	lds	r25, 0x0970
    98ac:	80 91 38 0d 	lds	r24, 0x0D38
    98b0:	98 13       	cpse	r25, r24
    98b2:	06 c0       	rjmp	.+12     	; 0x98c0 <EMeter_RX+0x6c>
			EM_RX_FIFOOverFlow = 1;
    98b4:	81 e0       	ldi	r24, 0x01	; 1
    98b6:	80 93 24 0b 	sts	0x0B24, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    98ba:	8f ef       	ldi	r24, 0xFF	; 255
    98bc:	80 93 6e 0a 	sts	0x0A6E, r24
			
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    98c0:	88 eb       	ldi	r24, 0xB8	; 184
    98c2:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    98c4:	5e 9a       	sbi	0x0b, 6	; 11
    98c6:	08 95       	ret

000098c8 <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    98c8:	1f 92       	push	r1
    98ca:	0f 92       	push	r0
    98cc:	0f b6       	in	r0, 0x3f	; 63
    98ce:	0f 92       	push	r0
    98d0:	11 24       	eor	r1, r1
    98d2:	0b b6       	in	r0, 0x3b	; 59
    98d4:	0f 92       	push	r0
    98d6:	2f 93       	push	r18
    98d8:	3f 93       	push	r19
    98da:	4f 93       	push	r20
    98dc:	5f 93       	push	r21
    98de:	6f 93       	push	r22
    98e0:	7f 93       	push	r23
    98e2:	8f 93       	push	r24
    98e4:	9f 93       	push	r25
    98e6:	af 93       	push	r26
    98e8:	bf 93       	push	r27
    98ea:	ef 93       	push	r30
    98ec:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    98ee:	80 91 e0 03 	lds	r24, 0x03E0
    98f2:	88 23       	and	r24, r24
    98f4:	29 f0       	breq	.+10     	; 0x9900 <__vector_30+0x38>
    98f6:	8c e9       	ldi	r24, 0x9C	; 156
    98f8:	90 e0       	ldi	r25, 0x00	; 0
    98fa:	0e 94 05 30 	call	0x600a	; 0x600a <Modbus_RX>
    98fe:	02 c0       	rjmp	.+4      	; 0x9904 <__vector_30+0x3c>
	else EMeter_RX();
    9900:	0e 94 2a 4c 	call	0x9854	; 0x9854 <EMeter_RX>
	COMM_LED = 1;
    9904:	81 e0       	ldi	r24, 0x01	; 1
    9906:	80 93 10 06 	sts	0x0610, r24
}	
    990a:	ff 91       	pop	r31
    990c:	ef 91       	pop	r30
    990e:	bf 91       	pop	r27
    9910:	af 91       	pop	r26
    9912:	9f 91       	pop	r25
    9914:	8f 91       	pop	r24
    9916:	7f 91       	pop	r23
    9918:	6f 91       	pop	r22
    991a:	5f 91       	pop	r21
    991c:	4f 91       	pop	r20
    991e:	3f 91       	pop	r19
    9920:	2f 91       	pop	r18
    9922:	0f 90       	pop	r0
    9924:	0b be       	out	0x3b, r0	; 59
    9926:	0f 90       	pop	r0
    9928:	0f be       	out	0x3f, r0	; 63
    992a:	0f 90       	pop	r0
    992c:	1f 90       	pop	r1
    992e:	18 95       	reti

00009930 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    9930:	80 91 76 0a 	lds	r24, 0x0A76
    9934:	88 23       	and	r24, r24
    9936:	21 f0       	breq	.+8      	; 0x9940 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9938:	88 e9       	ldi	r24, 0x98	; 152
    993a:	80 93 9a 00 	sts	0x009A, r24
    993e:	05 c0       	rjmp	.+10     	; 0x994a <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9940:	88 e9       	ldi	r24, 0x98	; 152
    9942:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    9946:	10 92 59 09 	sts	0x0959, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    994a:	94 98       	cbi	0x12, 4	; 18
    994c:	08 95       	ret

0000994e <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    994e:	1f 92       	push	r1
    9950:	0f 92       	push	r0
    9952:	0f b6       	in	r0, 0x3f	; 63
    9954:	0f 92       	push	r0
    9956:	11 24       	eor	r1, r1
    9958:	0b b6       	in	r0, 0x3b	; 59
    995a:	0f 92       	push	r0
    995c:	2f 93       	push	r18
    995e:	3f 93       	push	r19
    9960:	4f 93       	push	r20
    9962:	5f 93       	push	r21
    9964:	6f 93       	push	r22
    9966:	7f 93       	push	r23
    9968:	8f 93       	push	r24
    996a:	9f 93       	push	r25
    996c:	af 93       	push	r26
    996e:	bf 93       	push	r27
    9970:	ef 93       	push	r30
    9972:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    9974:	80 91 e0 03 	lds	r24, 0x03E0
    9978:	88 23       	and	r24, r24
    997a:	29 f0       	breq	.+10     	; 0x9986 <__vector_32+0x38>
    997c:	8c e9       	ldi	r24, 0x9C	; 156
    997e:	90 e0       	ldi	r25, 0x00	; 0
    9980:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <Modbus_TX>
    9984:	02 c0       	rjmp	.+4      	; 0x998a <__vector_32+0x3c>
	else EMeter_TX();
    9986:	0e 94 98 4c 	call	0x9930	; 0x9930 <EMeter_TX>
	COMM_LED = 1;
    998a:	81 e0       	ldi	r24, 0x01	; 1
    998c:	80 93 10 06 	sts	0x0610, r24
}
    9990:	ff 91       	pop	r31
    9992:	ef 91       	pop	r30
    9994:	bf 91       	pop	r27
    9996:	af 91       	pop	r26
    9998:	9f 91       	pop	r25
    999a:	8f 91       	pop	r24
    999c:	7f 91       	pop	r23
    999e:	6f 91       	pop	r22
    99a0:	5f 91       	pop	r21
    99a2:	4f 91       	pop	r20
    99a4:	3f 91       	pop	r19
    99a6:	2f 91       	pop	r18
    99a8:	0f 90       	pop	r0
    99aa:	0b be       	out	0x3b, r0	; 59
    99ac:	0f 90       	pop	r0
    99ae:	0f be       	out	0x3f, r0	; 63
    99b0:	0f 90       	pop	r0
    99b2:	1f 90       	pop	r1
    99b4:	18 95       	reti

000099b6 <EMeter_Link>:

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    99b6:	81 e0       	ldi	r24, 0x01	; 1
    99b8:	90 91 05 01 	lds	r25, 0x0105
    99bc:	91 11       	cpse	r25, r1
    99be:	80 e0       	ldi	r24, 0x00	; 0
	else return 1;
}
    99c0:	08 95       	ret

000099c2 <IsEMReady>:
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    99c2:	81 e0       	ldi	r24, 0x01	; 1
    99c4:	90 91 71 0a 	lds	r25, 0x0A71
    99c8:	9f 3f       	cpi	r25, 0xFF	; 255
    99ca:	09 f0       	breq	.+2      	; 0x99ce <IsEMReady+0xc>
    99cc:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    99ce:	08 95       	ret

000099d0 <EMRead>:
    99d0:	89 e2       	ldi	r24, 0x29	; 41
    99d2:	90 e0       	ldi	r25, 0x00	; 0
    99d4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    99d8:	84 30       	cpi	r24, 0x04	; 4
    99da:	11 f0       	breq	.+4      	; 0x99e0 <EMRead+0x10>
    99dc:	10 92 71 0a 	sts	0x0A71, r1
    99e0:	08 95       	ret

000099e2 <GPRS_AppInit>:

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    99e2:	0e 94 90 2a 	call	0x5520	; 0x5520 <Timer16Alloc>
    99e6:	80 93 0f 06 	sts	0x060F, r24
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    99ea:	0e 94 90 2a 	call	0x5520	; 0x5520 <Timer16Alloc>
    99ee:	80 93 4e 09 	sts	0x094E, r24
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    99f2:	0e 94 90 2a 	call	0x5520	; 0x5520 <Timer16Alloc>
    99f6:	80 93 0c 0b 	sts	0x0B0C, r24
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    99fa:	6f ef       	ldi	r22, 0xFF	; 255
    99fc:	7f ef       	ldi	r23, 0xFF	; 255
    99fe:	80 91 4e 09 	lds	r24, 0x094E
    9a02:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    9a06:	80 91 11 01 	lds	r24, 0x0111
    9a0a:	88 32       	cpi	r24, 0x28	; 40
    9a0c:	28 f0       	brcs	.+10     	; 0x9a18 <GPRS_AppInit+0x36>
    9a0e:	80 91 69 09 	lds	r24, 0x0969
    9a12:	81 60       	ori	r24, 0x01	; 1
    9a14:	80 93 69 09 	sts	0x0969, r24
    9a18:	08 95       	ret

00009a1a <GPRS_AddHeader>:
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    9a1a:	0f 93       	push	r16
    9a1c:	1f 93       	push	r17
    9a1e:	cf 93       	push	r28
    9a20:	df 93       	push	r29
    9a22:	00 d0       	rcall	.+0      	; 0x9a24 <GPRS_AddHeader+0xa>
    9a24:	1f 92       	push	r1
    9a26:	cd b7       	in	r28, 0x3d	; 61
    9a28:	de b7       	in	r29, 0x3e	; 62
    9a2a:	8c 01       	movw	r16, r24

	Buf[0] = 5;	
    9a2c:	85 e0       	ldi	r24, 0x05	; 5
    9a2e:	f8 01       	movw	r30, r16
    9a30:	80 83       	st	Z, r24
	Buf[1] = 1;	
    9a32:	81 e0       	ldi	r24, 0x01	; 1
    9a34:	81 83       	std	Z+1, r24	; 0x01
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a36:	8c e0       	ldi	r24, 0x0C	; 12
    9a38:	91 e0       	ldi	r25, 0x01	; 1
    9a3a:	2b 83       	std	Y+3, r18	; 0x03
    9a3c:	4a 83       	std	Y+2, r20	; 0x02
    9a3e:	69 83       	std	Y+1, r22	; 0x01
    9a40:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    9a44:	f8 01       	movw	r30, r16
    9a46:	92 83       	std	Z+2, r25	; 0x02
    9a48:	8c e0       	ldi	r24, 0x0C	; 12
    9a4a:	91 e0       	ldi	r25, 0x01	; 1
    9a4c:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    9a50:	f8 01       	movw	r30, r16
    9a52:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    9a54:	69 81       	ldd	r22, Y+1	; 0x01
    9a56:	64 83       	std	Z+4, r22	; 0x04
	Buf[5] = Size;	// -       
    9a58:	2b 81       	ldd	r18, Y+3	; 0x03
    9a5a:	25 83       	std	Z+5, r18	; 0x05
	Buf[6] = Func;		
    9a5c:	4a 81       	ldd	r20, Y+2	; 0x02
    9a5e:	46 83       	std	Z+6, r20	; 0x06
}
    9a60:	0f 90       	pop	r0
    9a62:	0f 90       	pop	r0
    9a64:	0f 90       	pop	r0
    9a66:	df 91       	pop	r29
    9a68:	cf 91       	pop	r28
    9a6a:	1f 91       	pop	r17
    9a6c:	0f 91       	pop	r16
    9a6e:	08 95       	ret

00009a70 <GPRS_CurDataSend>:

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    9a70:	cf 92       	push	r12
    9a72:	df 92       	push	r13
    9a74:	ef 92       	push	r14
    9a76:	ff 92       	push	r15
    9a78:	0f 93       	push	r16
    9a7a:	1f 93       	push	r17
    9a7c:	cf 93       	push	r28
    9a7e:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    9a80:	86 e0       	ldi	r24, 0x06	; 6
    9a82:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    9a86:	81 e0       	ldi	r24, 0x01	; 1
    9a88:	80 93 3a 0b 	sts	0x0B3A, r24
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9a8c:	90 91 7a 09 	lds	r25, 0x097A
    9a90:	90 93 3b 0b 	sts	0x0B3B, r25
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    9a94:	90 91 79 09 	lds	r25, 0x0979
    9a98:	90 93 3c 0b 	sts	0x0B3C, r25
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    9a9c:	90 91 78 09 	lds	r25, 0x0978
    9aa0:	90 93 3d 0b 	sts	0x0B3D, r25
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    9aa4:	90 91 77 09 	lds	r25, 0x0977
    9aa8:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    9aac:	90 91 76 09 	lds	r25, 0x0976
    9ab0:	90 93 3f 0b 	sts	0x0B3F, r25
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    9ab4:	90 91 75 09 	lds	r25, 0x0975
    9ab8:	90 93 40 0b 	sts	0x0B40, r25
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    9abc:	90 91 74 09 	lds	r25, 0x0974
    9ac0:	90 93 41 0b 	sts	0x0B41, r25
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9ac4:	90 91 73 09 	lds	r25, 0x0973
    9ac8:	90 93 42 0b 	sts	0x0B42, r25

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    9acc:	80 93 43 0b 	sts	0x0B43, r24
	GPRS_Data_Out[11] = SW_VERSION;		//   
    9ad0:	94 e0       	ldi	r25, 0x04	; 4
    9ad2:	90 93 44 0b 	sts	0x0B44, r25
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    9ad6:	80 93 45 0b 	sts	0x0B45, r24

	GPRS_Data_Out[13] = 60;			// -       
    9ada:	8c e3       	ldi	r24, 0x3C	; 60
    9adc:	80 93 46 0b 	sts	0x0B46, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    9ae0:	80 91 1c 0b 	lds	r24, 0x0B1C
    9ae4:	80 93 47 0b 	sts	0x0B47, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    9ae8:	80 91 1d 0b 	lds	r24, 0x0B1D
    9aec:	80 93 48 0b 	sts	0x0B48, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    9af0:	80 91 1e 0b 	lds	r24, 0x0B1E
    9af4:	80 93 49 0b 	sts	0x0B49, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    9af8:	80 91 1f 0b 	lds	r24, 0x0B1F
    9afc:	80 93 4a 0b 	sts	0x0B4A, r24

	if(EMeter_Link()){
    9b00:	0e 94 db 4c 	call	0x99b6	; 0x99b6 <EMeter_Link>
    9b04:	88 23       	and	r24, r24
    9b06:	f1 f0       	breq	.+60     	; 0x9b44 <GPRS_CurDataSend+0xd4>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b08:	89 e2       	ldi	r24, 0x29	; 41
    9b0a:	90 e0       	ldi	r25, 0x00	; 0
    9b0c:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9b10:	81 30       	cpi	r24, 0x01	; 1
    9b12:	a9 f4       	brne	.+42     	; 0x9b3e <GPRS_CurDataSend+0xce>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    9b14:	82 e7       	ldi	r24, 0x72	; 114
    9b16:	98 e0       	ldi	r25, 0x08	; 8
    9b18:	9f 93       	push	r25
    9b1a:	8f 93       	push	r24
    9b1c:	8e ee       	ldi	r24, 0xEE	; 238
    9b1e:	92 e0       	ldi	r25, 0x02	; 2
    9b20:	9f 93       	push	r25
    9b22:	8f 93       	push	r24
    9b24:	8b e4       	ldi	r24, 0x4B	; 75
    9b26:	9b e0       	ldi	r25, 0x0B	; 11
    9b28:	9f 93       	push	r25
    9b2a:	8f 93       	push	r24
    9b2c:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
    9b30:	0f 90       	pop	r0
    9b32:	0f 90       	pop	r0
    9b34:	0f 90       	pop	r0
    9b36:	0f 90       	pop	r0
    9b38:	0f 90       	pop	r0
    9b3a:	0f 90       	pop	r0
    9b3c:	11 c0       	rjmp	.+34     	; 0x9b60 <GPRS_CurDataSend+0xf0>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    9b3e:	8e ed       	ldi	r24, 0xDE	; 222
    9b40:	92 e0       	ldi	r25, 0x02	; 2
    9b42:	02 c0       	rjmp	.+4      	; 0x9b48 <GPRS_CurDataSend+0xd8>
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    9b44:	8e ec       	ldi	r24, 0xCE	; 206
    9b46:	92 e0       	ldi	r25, 0x02	; 2
    9b48:	9f 93       	push	r25
    9b4a:	8f 93       	push	r24
    9b4c:	8b e4       	ldi	r24, 0x4B	; 75
    9b4e:	9b e0       	ldi	r25, 0x0B	; 11
    9b50:	9f 93       	push	r25
    9b52:	8f 93       	push	r24
    9b54:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
    9b58:	0f 90       	pop	r0
    9b5a:	0f 90       	pop	r0
    9b5c:	0f 90       	pop	r0
    9b5e:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    9b60:	10 92 5b 0b 	sts	0x0B5B, r1
    9b64:	10 92 5a 0b 	sts	0x0B5A, r1
	if(!EMeter_Link()){
    9b68:	0e 94 db 4c 	call	0x99b6	; 0x99b6 <EMeter_Link>
    9b6c:	e0 90 41 0d 	lds	r14, 0x0D41
    9b70:	f0 90 42 0d 	lds	r15, 0x0D42
    9b74:	00 91 e4 03 	lds	r16, 0x03E4
    9b78:	10 91 e5 03 	lds	r17, 0x03E5
    9b7c:	c0 91 73 0a 	lds	r28, 0x0A73
    9b80:	d0 91 74 0a 	lds	r29, 0x0A74
    9b84:	81 11       	cpse	r24, r1
    9b86:	03 c0       	rjmp	.+6      	; 0x9b8e <GPRS_CurDataSend+0x11e>
		ptr[0] |= (1<<0);
    9b88:	81 e0       	ldi	r24, 0x01	; 1
    9b8a:	90 e0       	ldi	r25, 0x00	; 0
    9b8c:	ac c0       	rjmp	.+344    	; 0x9ce6 <GPRS_CurDataSend+0x276>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    9b8e:	e1 14       	cp	r14, r1
    9b90:	f1 04       	cpc	r15, r1
    9b92:	31 f4       	brne	.+12     	; 0x9ba0 <GPRS_CurDataSend+0x130>
    9b94:	80 e2       	ldi	r24, 0x20	; 32
    9b96:	90 e0       	ldi	r25, 0x00	; 0
    9b98:	90 93 5b 0b 	sts	0x0B5B, r25
    9b9c:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Ub==0) ptr[0] |= (1<<6);
    9ba0:	01 15       	cp	r16, r1
    9ba2:	11 05       	cpc	r17, r1
    9ba4:	49 f4       	brne	.+18     	; 0x9bb8 <GPRS_CurDataSend+0x148>
    9ba6:	80 91 5a 0b 	lds	r24, 0x0B5A
    9baa:	90 91 5b 0b 	lds	r25, 0x0B5B
    9bae:	80 64       	ori	r24, 0x40	; 64
    9bb0:	90 93 5b 0b 	sts	0x0B5B, r25
    9bb4:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Uc==0) ptr[0] |= (1<<7);
    9bb8:	20 97       	sbiw	r28, 0x00	; 0
    9bba:	49 f4       	brne	.+18     	; 0x9bce <GPRS_CurDataSend+0x15e>
    9bbc:	80 91 5a 0b 	lds	r24, 0x0B5A
    9bc0:	90 91 5b 0b 	lds	r25, 0x0B5B
    9bc4:	80 68       	ori	r24, 0x80	; 128
    9bc6:	90 93 5b 0b 	sts	0x0B5B, r25
    9bca:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    9bce:	40 91 5f 09 	lds	r20, 0x095F
    9bd2:	50 91 60 09 	lds	r21, 0x0960
    9bd6:	60 91 61 09 	lds	r22, 0x0961
    9bda:	70 91 62 09 	lds	r23, 0x0962
    9bde:	80 91 08 0b 	lds	r24, 0x0B08
    9be2:	90 91 09 0b 	lds	r25, 0x0B09
    9be6:	a0 91 0a 0b 	lds	r26, 0x0B0A
    9bea:	b0 91 0b 0b 	lds	r27, 0x0B0B
    9bee:	48 17       	cp	r20, r24
    9bf0:	59 07       	cpc	r21, r25
    9bf2:	6a 07       	cpc	r22, r26
    9bf4:	7b 07       	cpc	r23, r27
    9bf6:	59 f4       	brne	.+22     	; 0x9c0e <GPRS_CurDataSend+0x19e>
    9bf8:	20 91 3f 09 	lds	r18, 0x093F
    9bfc:	30 91 40 09 	lds	r19, 0x0940
    9c00:	80 91 f5 09 	lds	r24, 0x09F5
    9c04:	90 91 f6 09 	lds	r25, 0x09F6
    9c08:	28 17       	cp	r18, r24
    9c0a:	39 07       	cpc	r19, r25
    9c0c:	49 f0       	breq	.+18     	; 0x9c20 <GPRS_CurDataSend+0x1b0>
    9c0e:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c12:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c16:	91 60       	ori	r25, 0x01	; 1
    9c18:	90 93 5b 0b 	sts	0x0B5B, r25
    9c1c:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    9c20:	40 91 20 0b 	lds	r20, 0x0B20
    9c24:	50 91 21 0b 	lds	r21, 0x0B21
    9c28:	60 91 22 0b 	lds	r22, 0x0B22
    9c2c:	70 91 23 0b 	lds	r23, 0x0B23
    9c30:	80 91 ee 09 	lds	r24, 0x09EE
    9c34:	90 91 ef 09 	lds	r25, 0x09EF
    9c38:	a0 91 f0 09 	lds	r26, 0x09F0
    9c3c:	b0 91 f1 09 	lds	r27, 0x09F1
    9c40:	48 17       	cp	r20, r24
    9c42:	59 07       	cpc	r21, r25
    9c44:	6a 07       	cpc	r22, r26
    9c46:	7b 07       	cpc	r23, r27
    9c48:	59 f4       	brne	.+22     	; 0x9c60 <GPRS_CurDataSend+0x1f0>
    9c4a:	20 91 1a 06 	lds	r18, 0x061A
    9c4e:	30 91 1b 06 	lds	r19, 0x061B
    9c52:	80 91 f4 03 	lds	r24, 0x03F4
    9c56:	90 91 f5 03 	lds	r25, 0x03F5
    9c5a:	28 17       	cp	r18, r24
    9c5c:	39 07       	cpc	r19, r25
    9c5e:	49 f0       	breq	.+18     	; 0x9c72 <GPRS_CurDataSend+0x202>
    9c60:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c64:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c68:	92 60       	ori	r25, 0x02	; 2
    9c6a:	90 93 5b 0b 	sts	0x0B5B, r25
    9c6e:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    9c72:	40 91 eb 03 	lds	r20, 0x03EB
    9c76:	50 91 ec 03 	lds	r21, 0x03EC
    9c7a:	60 91 ed 03 	lds	r22, 0x03ED
    9c7e:	70 91 ee 03 	lds	r23, 0x03EE
    9c82:	80 91 16 06 	lds	r24, 0x0616
    9c86:	90 91 17 06 	lds	r25, 0x0617
    9c8a:	a0 91 18 06 	lds	r26, 0x0618
    9c8e:	b0 91 19 06 	lds	r27, 0x0619
    9c92:	48 17       	cp	r20, r24
    9c94:	59 07       	cpc	r21, r25
    9c96:	6a 07       	cpc	r22, r26
    9c98:	7b 07       	cpc	r23, r27
    9c9a:	59 f4       	brne	.+22     	; 0x9cb2 <GPRS_CurDataSend+0x242>
    9c9c:	20 91 1a 0b 	lds	r18, 0x0B1A
    9ca0:	30 91 1b 0b 	lds	r19, 0x0B1B
    9ca4:	80 91 43 0d 	lds	r24, 0x0D43
    9ca8:	90 91 44 0d 	lds	r25, 0x0D44
    9cac:	28 17       	cp	r18, r24
    9cae:	39 07       	cpc	r19, r25
    9cb0:	49 f0       	breq	.+18     	; 0x9cc4 <GPRS_CurDataSend+0x254>
    9cb2:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cb6:	90 91 5b 0b 	lds	r25, 0x0B5B
    9cba:	94 60       	ori	r25, 0x04	; 4
    9cbc:	90 93 5b 0b 	sts	0x0B5B, r25
    9cc0:	80 93 5a 0b 	sts	0x0B5A, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    9cc4:	80 91 53 09 	lds	r24, 0x0953
    9cc8:	90 91 54 09 	lds	r25, 0x0954
    9ccc:	a0 91 55 09 	lds	r26, 0x0955
    9cd0:	b0 91 56 09 	lds	r27, 0x0956
    9cd4:	89 2b       	or	r24, r25
    9cd6:	8a 2b       	or	r24, r26
    9cd8:	8b 2b       	or	r24, r27
    9cda:	49 f0       	breq	.+18     	; 0x9cee <GPRS_CurDataSend+0x27e>
    9cdc:	80 91 5a 0b 	lds	r24, 0x0B5A
    9ce0:	90 91 5b 0b 	lds	r25, 0x0B5B
    9ce4:	98 60       	ori	r25, 0x08	; 8
    9ce6:	90 93 5b 0b 	sts	0x0B5B, r25
    9cea:	80 93 5a 0b 	sts	0x0B5A, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    9cee:	80 e0       	ldi	r24, 0x00	; 0
    9cf0:	0e 94 b7 3b 	call	0x776e	; 0x776e <DI_Status>
    9cf4:	81 11       	cpse	r24, r1
    9cf6:	09 c0       	rjmp	.+18     	; 0x9d0a <GPRS_CurDataSend+0x29a>
    9cf8:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cfc:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d00:	82 60       	ori	r24, 0x02	; 2
    9d02:	90 93 5b 0b 	sts	0x0B5B, r25
    9d06:	80 93 5a 0b 	sts	0x0B5A, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    9d0a:	81 e0       	ldi	r24, 0x01	; 1
    9d0c:	0e 94 b7 3b 	call	0x776e	; 0x776e <DI_Status>
    9d10:	81 11       	cpse	r24, r1
    9d12:	09 c0       	rjmp	.+18     	; 0x9d26 <GPRS_CurDataSend+0x2b6>
    9d14:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d18:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d1c:	84 60       	ori	r24, 0x04	; 4
    9d1e:	90 93 5b 0b 	sts	0x0B5B, r25
    9d22:	80 93 5a 0b 	sts	0x0B5A, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    9d26:	c0 90 f2 05 	lds	r12, 0x05F2
    9d2a:	d0 90 f3 05 	lds	r13, 0x05F3
    9d2e:	c6 01       	movw	r24, r12
    9d30:	90 58       	subi	r25, 0x80	; 128
    9d32:	02 97       	sbiw	r24, 0x02	; 2
    9d34:	00 f1       	brcs	.+64     	; 0x9d76 <GPRS_CurDataSend+0x306>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9d36:	8d e0       	ldi	r24, 0x0D	; 13
    9d38:	90 e0       	ldi	r25, 0x00	; 0
    9d3a:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    9d3e:	c8 16       	cp	r12, r24
    9d40:	d9 06       	cpc	r13, r25
    9d42:	4c f0       	brlt	.+18     	; 0x9d56 <GPRS_CurDataSend+0x2e6>
    9d44:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d48:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d4c:	88 60       	ori	r24, 0x08	; 8
    9d4e:	90 93 5b 0b 	sts	0x0B5B, r25
    9d52:	80 93 5a 0b 	sts	0x0B5A, r24
    9d56:	8b e0       	ldi	r24, 0x0B	; 11
    9d58:	90 e0       	ldi	r25, 0x00	; 0
    9d5a:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    9d5e:	8c 15       	cp	r24, r12
    9d60:	9d 05       	cpc	r25, r13
    9d62:	4c f0       	brlt	.+18     	; 0x9d76 <GPRS_CurDataSend+0x306>
    9d64:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d68:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d6c:	80 61       	ori	r24, 0x10	; 16
    9d6e:	90 93 5b 0b 	sts	0x0B5B, r25
    9d72:	80 93 5a 0b 	sts	0x0B5A, r24
	}

	ptr[1] = Temperature[0];
    9d76:	d0 92 5d 0b 	sts	0x0B5D, r13
    9d7a:	c0 92 5c 0b 	sts	0x0B5C, r12

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    9d7e:	80 91 46 02 	lds	r24, 0x0246
    9d82:	90 91 47 02 	lds	r25, 0x0247
    9d86:	a0 91 48 02 	lds	r26, 0x0248
    9d8a:	b0 91 49 02 	lds	r27, 0x0249
    9d8e:	80 93 5e 0b 	sts	0x0B5E, r24
    9d92:	90 93 5f 0b 	sts	0x0B5F, r25
    9d96:	a0 93 60 0b 	sts	0x0B60, r26
    9d9a:	b0 93 61 0b 	sts	0x0B61, r27
	pi4[1] = E_Meter_RAM.Am;
    9d9e:	80 91 4a 02 	lds	r24, 0x024A
    9da2:	90 91 4b 02 	lds	r25, 0x024B
    9da6:	a0 91 4c 02 	lds	r26, 0x024C
    9daa:	b0 91 4d 02 	lds	r27, 0x024D
    9dae:	80 93 62 0b 	sts	0x0B62, r24
    9db2:	90 93 63 0b 	sts	0x0B63, r25
    9db6:	a0 93 64 0b 	sts	0x0B64, r26
    9dba:	b0 93 65 0b 	sts	0x0B65, r27
	pi4[2] = E_Meter_RAM.Rp;
    9dbe:	80 91 4e 02 	lds	r24, 0x024E
    9dc2:	90 91 4f 02 	lds	r25, 0x024F
    9dc6:	a0 91 50 02 	lds	r26, 0x0250
    9dca:	b0 91 51 02 	lds	r27, 0x0251
    9dce:	80 93 66 0b 	sts	0x0B66, r24
    9dd2:	90 93 67 0b 	sts	0x0B67, r25
    9dd6:	a0 93 68 0b 	sts	0x0B68, r26
    9dda:	b0 93 69 0b 	sts	0x0B69, r27
	pi4[3] = E_Meter_RAM.Rm;
    9dde:	80 91 52 02 	lds	r24, 0x0252
    9de2:	90 91 53 02 	lds	r25, 0x0253
    9de6:	a0 91 54 02 	lds	r26, 0x0254
    9dea:	b0 91 55 02 	lds	r27, 0x0255
    9dee:	80 93 6a 0b 	sts	0x0B6A, r24
    9df2:	90 93 6b 0b 	sts	0x0B6B, r25
    9df6:	a0 93 6c 0b 	sts	0x0B6C, r26
    9dfa:	b0 93 6d 0b 	sts	0x0B6D, r27

	GPRS_Data_Out[53] = EM_Year;
    9dfe:	80 91 86 09 	lds	r24, 0x0986
    9e02:	80 93 6e 0b 	sts	0x0B6E, r24
	GPRS_Data_Out[54] = EM_Month;
    9e06:	80 91 ed 09 	lds	r24, 0x09ED
    9e0a:	80 93 6f 0b 	sts	0x0B6F, r24
	GPRS_Data_Out[55] = EM_Day;
    9e0e:	80 91 e2 03 	lds	r24, 0x03E2
    9e12:	80 93 70 0b 	sts	0x0B70, r24
	GPRS_Data_Out[56] = EM_Hour;
    9e16:	80 91 6e 09 	lds	r24, 0x096E
    9e1a:	80 93 71 0b 	sts	0x0B71, r24
	GPRS_Data_Out[57] = EM_Min;
    9e1e:	80 91 4d 09 	lds	r24, 0x094D
    9e22:	80 93 72 0b 	sts	0x0B72, r24
	GPRS_Data_Out[58] = EM_Sec;
    9e26:	80 91 0e 06 	lds	r24, 0x060E
    9e2a:	80 93 73 0b 	sts	0x0B73, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
	ptr[0] = EM_PowerActive;
    9e2e:	80 91 6f 0a 	lds	r24, 0x0A6F
    9e32:	90 91 70 0a 	lds	r25, 0x0A70
    9e36:	90 93 75 0b 	sts	0x0B75, r25
    9e3a:	80 93 74 0b 	sts	0x0B74, r24
	ptr[1] = Ua;
    9e3e:	f0 92 77 0b 	sts	0x0B77, r15
    9e42:	e0 92 76 0b 	sts	0x0B76, r14
	ptr[2] = Ub;
    9e46:	10 93 79 0b 	sts	0x0B79, r17
    9e4a:	00 93 78 0b 	sts	0x0B78, r16
	ptr[3] = Uc;
    9e4e:	d0 93 7b 0b 	sts	0x0B7B, r29
    9e52:	c0 93 7a 0b 	sts	0x0B7A, r28
	ptr[4] = Ia;
    9e56:	80 91 f2 03 	lds	r24, 0x03F2
    9e5a:	90 91 f3 03 	lds	r25, 0x03F3
    9e5e:	90 93 7d 0b 	sts	0x0B7D, r25
    9e62:	80 93 7c 0b 	sts	0x0B7C, r24
	ptr[5] = Ib;
    9e66:	80 91 47 09 	lds	r24, 0x0947
    9e6a:	90 91 48 09 	lds	r25, 0x0948
    9e6e:	90 93 7f 0b 	sts	0x0B7F, r25
    9e72:	80 93 7e 0b 	sts	0x0B7E, r24
	ptr[6] = Ic;
    9e76:	80 91 81 09 	lds	r24, 0x0981
    9e7a:	90 91 82 09 	lds	r25, 0x0982
    9e7e:	90 93 81 0b 	sts	0x0B81, r25
    9e82:	80 93 80 0b 	sts	0x0B80, r24

	GPRS_Data_Out[73] = GSM_RSSI;
    9e86:	80 91 25 06 	lds	r24, 0x0625
    9e8a:	80 93 82 0b 	sts	0x0B82, r24

	GPRS_FlgSz_Out = 74;	//    .     
    9e8e:	8a e4       	ldi	r24, 0x4A	; 74
    9e90:	80 93 43 09 	sts	0x0943, r24
}
    9e94:	df 91       	pop	r29
    9e96:	cf 91       	pop	r28
    9e98:	1f 91       	pop	r17
    9e9a:	0f 91       	pop	r16
    9e9c:	ff 90       	pop	r15
    9e9e:	ef 90       	pop	r14
    9ea0:	df 90       	pop	r13
    9ea2:	cf 90       	pop	r12
    9ea4:	08 95       	ret

00009ea6 <GPRS_SendData>:

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    9ea6:	cf 93       	push	r28
    9ea8:	df 93       	push	r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9eaa:	8a e0       	ldi	r24, 0x0A	; 10
    9eac:	90 e0       	ldi	r25, 0x00	; 0
    9eae:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    9eb2:	88 23       	and	r24, r24
    9eb4:	09 f4       	brne	.+2      	; 0x9eb8 <GPRS_SendData+0x12>
    9eb6:	59 c0       	rjmp	.+178    	; 0x9f6a <GPRS_SendData+0xc4>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9eb8:	88 e0       	ldi	r24, 0x08	; 8
    9eba:	90 e0       	ldi	r25, 0x00	; 0
    9ebc:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    9ec0:	cc 97       	sbiw	r24, 0x3c	; 60
    9ec2:	08 f4       	brcc	.+2      	; 0x9ec6 <GPRS_SendData+0x20>
    9ec4:	52 c0       	rjmp	.+164    	; 0x9f6a <GPRS_SendData+0xc4>
		if(Timer1s != Timer1sOld){
    9ec6:	80 91 0e 0b 	lds	r24, 0x0B0E
    9eca:	90 91 80 09 	lds	r25, 0x0980
    9ece:	89 17       	cp	r24, r25
    9ed0:	91 f0       	breq	.+36     	; 0x9ef6 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    9ed2:	80 93 80 09 	sts	0x0980, r24
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    9ed6:	c0 91 18 0b 	lds	r28, 0x0B18
    9eda:	d0 91 19 0b 	lds	r29, 0x0B19
    9ede:	88 e0       	ldi	r24, 0x08	; 8
    9ee0:	90 e0       	ldi	r25, 0x00	; 0
    9ee2:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    9ee6:	c8 17       	cp	r28, r24
    9ee8:	d9 07       	cpc	r29, r25
    9eea:	28 f4       	brcc	.+10     	; 0x9ef6 <GPRS_SendData+0x50>
    9eec:	21 96       	adiw	r28, 0x01	; 1
    9eee:	d0 93 19 0b 	sts	0x0B19, r29
    9ef2:	c0 93 18 0b 	sts	0x0B18, r28
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    9ef6:	c0 91 18 0b 	lds	r28, 0x0B18
    9efa:	d0 91 19 0b 	lds	r29, 0x0B19
    9efe:	88 e0       	ldi	r24, 0x08	; 8
    9f00:	90 e0       	ldi	r25, 0x00	; 0
    9f02:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    9f06:	4e 97       	sbiw	r24, 0x1e	; 30
    9f08:	c8 17       	cp	r28, r24
    9f0a:	d9 07       	cpc	r29, r25
    9f0c:	29 f4       	brne	.+10     	; 0x9f18 <GPRS_SendData+0x72>
			if(IsEMReady()) EMRead();			
    9f0e:	0e 94 e1 4c 	call	0x99c2	; 0x99c2 <IsEMReady>
    9f12:	81 11       	cpse	r24, r1
    9f14:	0e 94 e8 4c 	call	0x99d0	; 0x99d0 <EMRead>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    9f18:	c0 91 18 0b 	lds	r28, 0x0B18
    9f1c:	d0 91 19 0b 	lds	r29, 0x0B19
    9f20:	88 e0       	ldi	r24, 0x08	; 8
    9f22:	90 e0       	ldi	r25, 0x00	; 0
    9f24:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    9f28:	0f 97       	sbiw	r24, 0x0f	; 15
    9f2a:	c8 17       	cp	r28, r24
    9f2c:	d9 07       	cpc	r29, r25
    9f2e:	49 f4       	brne	.+18     	; 0x9f42 <GPRS_SendData+0x9c>
			if(!EMeter_Link()){
    9f30:	0e 94 db 4c 	call	0x99b6	; 0x99b6 <EMeter_Link>
    9f34:	81 11       	cpse	r24, r1
    9f36:	05 c0       	rjmp	.+10     	; 0x9f42 <GPRS_SendData+0x9c>
				if(IsEMReady()) EMRead();
    9f38:	0e 94 e1 4c 	call	0x99c2	; 0x99c2 <IsEMReady>
    9f3c:	81 11       	cpse	r24, r1
    9f3e:	0e 94 e8 4c 	call	0x99d0	; 0x99d0 <EMRead>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    9f42:	c0 91 18 0b 	lds	r28, 0x0B18
    9f46:	d0 91 19 0b 	lds	r29, 0x0B19
    9f4a:	88 e0       	ldi	r24, 0x08	; 8
    9f4c:	90 e0       	ldi	r25, 0x00	; 0
    9f4e:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    9f52:	c8 17       	cp	r28, r24
    9f54:	d9 07       	cpc	r29, r25
    9f56:	48 f0       	brcs	.+18     	; 0x9f6a <GPRS_SendData+0xc4>
			GPRS_DataTimer = 0;
    9f58:	10 92 19 0b 	sts	0x0B19, r1
    9f5c:	10 92 18 0b 	sts	0x0B18, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    9f60:	80 91 5c 09 	lds	r24, 0x095C
    9f64:	81 60       	ori	r24, 0x01	; 1
    9f66:	80 93 5c 09 	sts	0x095C, r24
		}
	}
}
    9f6a:	df 91       	pop	r29
    9f6c:	cf 91       	pop	r28
    9f6e:	08 95       	ret

00009f70 <GPRS_NewMsg>:

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    9f70:	90 91 69 09 	lds	r25, 0x0969
    9f74:	90 fd       	sbrc	r25, 0
    9f76:	5a c0       	rjmp	.+180    	; 0xa02c <GPRS_NewMsg+0xbc>
		GPRS_CrashID++;
    9f78:	90 91 04 01 	lds	r25, 0x0104
    9f7c:	9f 5f       	subi	r25, 0xFF	; 255
    9f7e:	90 93 04 01 	sts	0x0104, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    9f82:	26 e0       	ldi	r18, 0x06	; 6
    9f84:	20 93 07 0a 	sts	0x0A07, r18
		GPRS_CrashData[1] = 1;	
    9f88:	21 e0       	ldi	r18, 0x01	; 1
    9f8a:	20 93 08 0a 	sts	0x0A08, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9f8e:	30 91 7a 09 	lds	r19, 0x097A
    9f92:	30 93 09 0a 	sts	0x0A09, r19
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    9f96:	30 91 79 09 	lds	r19, 0x0979
    9f9a:	30 93 0a 0a 	sts	0x0A0A, r19
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    9f9e:	30 91 78 09 	lds	r19, 0x0978
    9fa2:	30 93 0b 0a 	sts	0x0A0B, r19
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    9fa6:	30 91 77 09 	lds	r19, 0x0977
    9faa:	30 93 0c 0a 	sts	0x0A0C, r19
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    9fae:	30 91 76 09 	lds	r19, 0x0976
    9fb2:	30 93 0d 0a 	sts	0x0A0D, r19
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    9fb6:	30 91 75 09 	lds	r19, 0x0975
    9fba:	30 93 0e 0a 	sts	0x0A0E, r19
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    9fbe:	30 91 74 09 	lds	r19, 0x0974
    9fc2:	30 93 0f 0a 	sts	0x0A0F, r19
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9fc6:	30 91 73 09 	lds	r19, 0x0973
    9fca:	30 93 10 0a 	sts	0x0A10, r19

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    9fce:	32 e0       	ldi	r19, 0x02	; 2
    9fd0:	30 93 11 0a 	sts	0x0A11, r19
		GPRS_CrashData[11] = SW_VERSION;		//   
    9fd4:	34 e0       	ldi	r19, 0x04	; 4
    9fd6:	30 93 12 0a 	sts	0x0A12, r19
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    9fda:	20 93 13 0a 	sts	0x0A13, r18
		
		GPRS_CrashData[14] = Type;
    9fde:	80 93 15 0a 	sts	0x0A15, r24
		GPRS_CrashData[15] = 1;			//    
    9fe2:	20 93 16 0a 	sts	0x0A16, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    9fe6:	90 93 17 0a 	sts	0x0A17, r25

		GPRS_CrashData[17] = 0;
    9fea:	10 92 18 0a 	sts	0x0A18, r1
		GPRS_CrashData[18] = 0;
    9fee:	10 92 19 0a 	sts	0x0A19, r1
		GPRS_CrashData[19] = 0;
    9ff2:	10 92 1a 0a 	sts	0x0A1A, r1
		GPRS_CrashData[20] = 0;
    9ff6:	10 92 1b 0a 	sts	0x0A1B, r1
		GPRS_CrashData[21] = 0;
    9ffa:	10 92 1c 0a 	sts	0x0A1C, r1
		GPRS_CrashData[22] = 0;
    9ffe:	10 92 1d 0a 	sts	0x0A1D, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    a002:	42 e3       	ldi	r20, 0x32	; 50
    a004:	50 e0       	ldi	r21, 0x00	; 0
    a006:	8e e1       	ldi	r24, 0x1E	; 30
    a008:	9a e0       	ldi	r25, 0x0A	; 10
    a00a:	0e 94 d7 6b 	call	0xd7ae	; 0xd7ae <strlcpy_P>
    a00e:	87 5f       	subi	r24, 0xF7	; 247
    a010:	80 93 14 0a 	sts	0x0A14, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
    a014:	80 91 5c 09 	lds	r24, 0x095C
    a018:	8f 7d       	andi	r24, 0xDF	; 223
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    a01a:	80 64       	ori	r24, 0x40	; 64
    a01c:	80 93 5c 09 	sts	0x095C, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    a020:	60 ee       	ldi	r22, 0xE0	; 224
    a022:	7e e2       	ldi	r23, 0x2E	; 46
    a024:	80 91 0f 06 	lds	r24, 0x060F
    a028:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>
    a02c:	08 95       	ret

0000a02e <GPRS_SendNewCrash>:
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    a02e:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a030:	c0 91 14 0a 	lds	r28, 0x0A14
    a034:	c2 5f       	subi	r28, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a036:	4c 2f       	mov	r20, r28
    a038:	50 e0       	ldi	r21, 0x00	; 0
    a03a:	67 e0       	ldi	r22, 0x07	; 7
    a03c:	7a e0       	ldi	r23, 0x0A	; 10
    a03e:	89 e3       	ldi	r24, 0x39	; 57
    a040:	9b e0       	ldi	r25, 0x0B	; 11
    a042:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a046:	c0 93 43 09 	sts	0x0943, r28
}
    a04a:	cf 91       	pop	r28
    a04c:	08 95       	ret

0000a04e <GPRS_SendRepCrash>:
// --      
void GPRS_SendRepCrash(void){
    a04e:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a050:	c0 91 14 0a 	lds	r28, 0x0A14
    a054:	c2 5f       	subi	r28, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    a056:	82 e0       	ldi	r24, 0x02	; 2
    a058:	80 93 16 0a 	sts	0x0A16, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a05c:	4c 2f       	mov	r20, r28
    a05e:	50 e0       	ldi	r21, 0x00	; 0
    a060:	67 e0       	ldi	r22, 0x07	; 7
    a062:	7a e0       	ldi	r23, 0x0A	; 10
    a064:	89 e3       	ldi	r24, 0x39	; 57
    a066:	9b e0       	ldi	r25, 0x0B	; 11
    a068:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a06c:	c0 93 43 09 	sts	0x0943, r28
}
    a070:	cf 91       	pop	r28
    a072:	08 95       	ret

0000a074 <GPRS_Check_PSW>:

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    a074:	0f 93       	push	r16
    a076:	1f 93       	push	r17
    a078:	cf 93       	push	r28
    a07a:	df 93       	push	r29
    a07c:	8c 01       	movw	r16, r24
    a07e:	c0 e0       	ldi	r28, 0x00	; 0
    a080:	d0 e0       	ldi	r29, 0x00	; 0
    a082:	ce 01       	movw	r24, r28
    a084:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a088:	08 17       	cp	r16, r24
    a08a:	19 07       	cpc	r17, r25
    a08c:	59 f0       	breq	.+22     	; 0xa0a4 <GPRS_Check_PSW+0x30>
    a08e:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    a090:	80 e0       	ldi	r24, 0x00	; 0
    a092:	c8 30       	cpi	r28, 0x08	; 8
    a094:	d8 07       	cpc	r29, r24
    a096:	a9 f7       	brne	.-22     	; 0xa082 <GPRS_Check_PSW+0xe>
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
    a098:	81 e0       	ldi	r24, 0x01	; 1
    a09a:	0c 3f       	cpi	r16, 0xFC	; 252
    a09c:	18 45       	sbci	r17, 0x58	; 88
    a09e:	19 f0       	breq	.+6      	; 0xa0a6 <GPRS_Check_PSW+0x32>
    a0a0:	80 e0       	ldi	r24, 0x00	; 0
    a0a2:	01 c0       	rjmp	.+2      	; 0xa0a6 <GPRS_Check_PSW+0x32>
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a0a4:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(Pass == 22780) return 1;
	return 0;
}
    a0a6:	df 91       	pop	r29
    a0a8:	cf 91       	pop	r28
    a0aa:	1f 91       	pop	r17
    a0ac:	0f 91       	pop	r16
    a0ae:	08 95       	ret

0000a0b0 <GPRS_Get_Session_ID>:
	}
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
    a0b0:	cf 93       	push	r28
    a0b2:	df 93       	push	r29
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    a0b4:	80 91 69 09 	lds	r24, 0x0969
    a0b8:	83 ff       	sbrs	r24, 3
    a0ba:	05 c0       	rjmp	.+10     	; 0xa0c6 <GPRS_Get_Session_ID+0x16>
    a0bc:	10 92 11 0b 	sts	0x0B11, r1
    a0c0:	10 92 10 0b 	sts	0x0B10, r1
    a0c4:	12 c0       	rjmp	.+36     	; 0xa0ea <GPRS_Get_Session_ID+0x3a>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    a0c6:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    a0ca:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint16_t Time = Timer16[TimerN];
    a0ce:	ec 2f       	mov	r30, r28
    a0d0:	f0 e0       	ldi	r31, 0x00	; 0
    a0d2:	ee 0f       	add	r30, r30
    a0d4:	ff 1f       	adc	r31, r31
    a0d6:	ea 5d       	subi	r30, 0xDA	; 218
    a0d8:	fc 4f       	sbci	r31, 0xFC	; 252
    a0da:	c0 81       	ld	r28, Z
    a0dc:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    a0de:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
    a0e2:	d0 93 11 0b 	sts	0x0B11, r29
    a0e6:	c0 93 10 0b 	sts	0x0B10, r28
	GPRS_Data_Out[0] = 5;	//    
    a0ea:	85 e0       	ldi	r24, 0x05	; 5
    a0ec:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a0f0:	81 e0       	ldi	r24, 0x01	; 1
    a0f2:	80 93 3a 0b 	sts	0x0B3A, r24
    a0f6:	8c e0       	ldi	r24, 0x0C	; 12
    a0f8:	91 e0       	ldi	r25, 0x01	; 1
    a0fa:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a0fe:	90 93 3b 0b 	sts	0x0B3B, r25
    a102:	8c e0       	ldi	r24, 0x0C	; 12
    a104:	91 e0       	ldi	r25, 0x01	; 1
    a106:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a10a:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 4;
    a10e:	84 e0       	ldi	r24, 0x04	; 4
    a110:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    a114:	80 91 10 0b 	lds	r24, 0x0B10
    a118:	90 91 11 0b 	lds	r25, 0x0B11
    a11c:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    a120:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_FlgSz_Out = 7;					//    .     	
    a124:	87 e0       	ldi	r24, 0x07	; 7
    a126:	80 93 43 09 	sts	0x0943, r24
}
    a12a:	df 91       	pop	r29
    a12c:	cf 91       	pop	r28
    a12e:	08 95       	ret

0000a130 <GPRS_RemoteDisplayControl>:

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    a130:	6f e0       	ldi	r22, 0x0F	; 15
    a132:	80 e0       	ldi	r24, 0x00	; 0
    a134:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    a138:	80 91 69 09 	lds	r24, 0x0969
    a13c:	84 60       	ori	r24, 0x04	; 4
    a13e:	80 93 69 09 	sts	0x0969, r24
    a142:	08 95       	ret

0000a144 <GPRS_SendDisplay>:
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
	GPRS_Data_Out[0] = 5;	//    
    a144:	85 e0       	ldi	r24, 0x05	; 5
    a146:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a14a:	81 e0       	ldi	r24, 0x01	; 1
    a14c:	80 93 3a 0b 	sts	0x0B3A, r24
    a150:	8c e0       	ldi	r24, 0x0C	; 12
    a152:	91 e0       	ldi	r25, 0x01	; 1
    a154:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a158:	90 93 3b 0b 	sts	0x0B3B, r25
    a15c:	8c e0       	ldi	r24, 0x0C	; 12
    a15e:	91 e0       	ldi	r25, 0x01	; 1
    a160:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a164:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 3;
    a168:	83 e0       	ldi	r24, 0x03	; 3
    a16a:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = 34;
    a16e:	82 e2       	ldi	r24, 0x22	; 34
    a170:	80 93 3e 0b 	sts	0x0B3E, r24
	GPRS_Data_Out[6] = 10;
    a174:	8a e0       	ldi	r24, 0x0A	; 10
    a176:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    a17a:	80 93 40 0b 	sts	0x0B40, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    a17e:	88 e2       	ldi	r24, 0x28	; 40
    a180:	80 93 43 09 	sts	0x0943, r24
    a184:	08 95       	ret

0000a186 <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    a186:	cf 93       	push	r28
    a188:	c8 2f       	mov	r28, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    a18a:	48 2f       	mov	r20, r24
    a18c:	50 e0       	ldi	r21, 0x00	; 0
    a18e:	6d e3       	ldi	r22, 0x3D	; 61
    a190:	76 e0       	ldi	r23, 0x06	; 6
    a192:	89 e3       	ldi	r24, 0x39	; 57
    a194:	9b e0       	ldi	r25, 0x0B	; 11
    a196:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    a19a:	c0 93 43 09 	sts	0x0943, r28
}
    a19e:	cf 91       	pop	r28
    a1a0:	08 95       	ret

0000a1a2 <GPRS_ReadParamReply>:
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    a1a2:	1f 93       	push	r17
    a1a4:	cf 93       	push	r28
    a1a6:	df 93       	push	r29
    a1a8:	00 d0       	rcall	.+0      	; 0xa1aa <GPRS_ReadParamReply+0x8>
    a1aa:	cd b7       	in	r28, 0x3d	; 61
    a1ac:	de b7       	in	r29, 0x3e	; 62
    a1ae:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a1b0:	85 e0       	ldi	r24, 0x05	; 5
    a1b2:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a1b6:	81 e0       	ldi	r24, 0x01	; 1
    a1b8:	80 93 3e 06 	sts	0x063E, r24
    a1bc:	8c e0       	ldi	r24, 0x0C	; 12
    a1be:	91 e0       	ldi	r25, 0x01	; 1
    a1c0:	4a 83       	std	Y+2, r20	; 0x02
    a1c2:	69 83       	std	Y+1, r22	; 0x01
    a1c4:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a1c8:	90 93 3f 06 	sts	0x063F, r25
    a1cc:	8c e0       	ldi	r24, 0x0C	; 12
    a1ce:	91 e0       	ldi	r25, 0x01	; 1
    a1d0:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a1d4:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a1d8:	83 e0       	ldi	r24, 0x03	; 3
    a1da:	80 93 41 06 	sts	0x0641, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    a1de:	4a 81       	ldd	r20, Y+2	; 0x02
    a1e0:	4d 5f       	subi	r20, 0xFD	; 253
    a1e2:	40 93 42 06 	sts	0x0642, r20
	GPRS_ChangeData[6] = 7;
    a1e6:	87 e0       	ldi	r24, 0x07	; 7
    a1e8:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a1ec:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;
    a1f0:	69 81       	ldd	r22, Y+1	; 0x01
    a1f2:	60 93 45 06 	sts	0x0645, r22
}
    a1f6:	0f 90       	pop	r0
    a1f8:	0f 90       	pop	r0
    a1fa:	df 91       	pop	r29
    a1fc:	cf 91       	pop	r28
    a1fe:	1f 91       	pop	r17
    a200:	08 95       	ret

0000a202 <GPRS_WriteParamReply>:
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    a202:	1f 93       	push	r17
    a204:	cf 93       	push	r28
    a206:	df 93       	push	r29
    a208:	1f 92       	push	r1
    a20a:	cd b7       	in	r28, 0x3d	; 61
    a20c:	de b7       	in	r29, 0x3e	; 62
    a20e:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a210:	85 e0       	ldi	r24, 0x05	; 5
    a212:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a216:	81 e0       	ldi	r24, 0x01	; 1
    a218:	80 93 3e 06 	sts	0x063E, r24
    a21c:	8c e0       	ldi	r24, 0x0C	; 12
    a21e:	91 e0       	ldi	r25, 0x01	; 1
    a220:	69 83       	std	Y+1, r22	; 0x01
    a222:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a226:	90 93 3f 06 	sts	0x063F, r25
    a22a:	8c e0       	ldi	r24, 0x0C	; 12
    a22c:	91 e0       	ldi	r25, 0x01	; 1
    a22e:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a232:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a236:	93 e0       	ldi	r25, 0x03	; 3
    a238:	90 93 41 06 	sts	0x0641, r25
	GPRS_ChangeData[5] = 3;	// -       
    a23c:	90 93 42 06 	sts	0x0642, r25
	GPRS_ChangeData[6] = 8;
    a240:	88 e0       	ldi	r24, 0x08	; 8
    a242:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a246:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;	
    a24a:	69 81       	ldd	r22, Y+1	; 0x01
    a24c:	60 93 45 06 	sts	0x0645, r22
}
    a250:	0f 90       	pop	r0
    a252:	df 91       	pop	r29
    a254:	cf 91       	pop	r28
    a256:	1f 91       	pop	r17
    a258:	08 95       	ret

0000a25a <GPRS_Param>:

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    a25a:	cf 92       	push	r12
    a25c:	ef 92       	push	r14
    a25e:	0f 93       	push	r16
    a260:	1f 93       	push	r17
    a262:	cf 93       	push	r28
    a264:	df 93       	push	r29
    a266:	d8 2f       	mov	r29, r24
    a268:	16 2f       	mov	r17, r22
    a26a:	ca 01       	movw	r24, r20
    a26c:	c2 2f       	mov	r28, r18
	if(Cmd==READ_PARAM ){
    a26e:	01 3c       	cpi	r16, 0xC1	; 193
    a270:	b9 f4       	brne	.+46     	; 0xa2a0 <GPRS_Param+0x46>
		if(MemCopy){
    a272:	ee 20       	and	r14, r14
    a274:	61 f0       	breq	.+24     	; 0xa28e <GPRS_Param+0x34>
    a276:	42 2f       	mov	r20, r18
    a278:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    a27a:	bc 01       	movw	r22, r24
    a27c:	86 e4       	ldi	r24, 0x46	; 70
    a27e:	96 e0       	ldi	r25, 0x06	; 6
    a280:	cc 20       	and	r12, r12
    a282:	19 f0       	breq	.+6      	; 0xa28a <GPRS_Param+0x30>
    a284:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
    a288:	02 c0       	rjmp	.+4      	; 0xa28e <GPRS_Param+0x34>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a28a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    a28e:	4c 2f       	mov	r20, r28
    a290:	61 2f       	mov	r22, r17
    a292:	8d 2f       	mov	r24, r29
    a294:	0e 94 d1 50 	call	0xa1a2	; 0xa1a2 <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    a298:	c7 5f       	subi	r28, 0xF7	; 247
    a29a:	c0 93 11 06 	sts	0x0611, r28
    a29e:	19 c0       	rjmp	.+50     	; 0xa2d2 <GPRS_Param+0x78>
	}
	if(Cmd==WRITE_PARAM){
    a2a0:	0c 34       	cpi	r16, 0x4C	; 76
    a2a2:	b9 f4       	brne	.+46     	; 0xa2d2 <GPRS_Param+0x78>
		if(MemCopy){
    a2a4:	ee 20       	and	r14, r14
    a2a6:	71 f0       	breq	.+28     	; 0xa2c4 <GPRS_Param+0x6a>
    a2a8:	42 2f       	mov	r20, r18
    a2aa:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    a2ac:	cc 20       	and	r12, r12
    a2ae:	29 f0       	breq	.+10     	; 0xa2ba <GPRS_Param+0x60>
    a2b0:	68 e4       	ldi	r22, 0x48	; 72
    a2b2:	78 e0       	ldi	r23, 0x08	; 8
    a2b4:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
    a2b8:	05 c0       	rjmp	.+10     	; 0xa2c4 <GPRS_Param+0x6a>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    a2ba:	bc 01       	movw	r22, r24
    a2bc:	88 e4       	ldi	r24, 0x48	; 72
    a2be:	98 e0       	ldi	r25, 0x08	; 8
    a2c0:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    a2c4:	61 2f       	mov	r22, r17
    a2c6:	8d 2f       	mov	r24, r29
    a2c8:	0e 94 01 51 	call	0xa202	; 0xa202 <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    a2cc:	89 e0       	ldi	r24, 0x09	; 9
    a2ce:	80 93 11 06 	sts	0x0611, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a2d2:	80 91 5c 09 	lds	r24, 0x095C
    a2d6:	88 60       	ori	r24, 0x08	; 8
    a2d8:	80 93 5c 09 	sts	0x095C, r24
}
    a2dc:	df 91       	pop	r29
    a2de:	cf 91       	pop	r28
    a2e0:	1f 91       	pop	r17
    a2e2:	0f 91       	pop	r16
    a2e4:	ef 90       	pop	r14
    a2e6:	cf 90       	pop	r12
    a2e8:	08 95       	ret

0000a2ea <GPRS_CriticalCMD_Process>:

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    a2ea:	80 91 e3 03 	lds	r24, 0x03E3
    a2ee:	88 23       	and	r24, r24
    a2f0:	f9 f0       	breq	.+62     	; 0xa330 <GPRS_CriticalCMD_Process+0x46>
    a2f2:	80 91 0c 0b 	lds	r24, 0x0B0C
    a2f6:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    a2fa:	88 23       	and	r24, r24
    a2fc:	c9 f0       	breq	.+50     	; 0xa330 <GPRS_CriticalCMD_Process+0x46>
		switch(GPRS_CriticalCMD){
    a2fe:	80 91 e3 03 	lds	r24, 0x03E3
    a302:	82 30       	cpi	r24, 0x02	; 2
    a304:	69 f0       	breq	.+26     	; 0xa320 <GPRS_CriticalCMD_Process+0x36>
    a306:	20 f4       	brcc	.+8      	; 0xa310 <GPRS_CriticalCMD_Process+0x26>
    a308:	81 30       	cpi	r24, 0x01	; 1
    a30a:	81 f4       	brne	.+32     	; 0xa32c <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    a30c:	f8 94       	cli
    a30e:	07 c0       	rjmp	.+14     	; 0xa31e <GPRS_CriticalCMD_Process+0x34>
    a310:	83 30       	cpi	r24, 0x03	; 3
    a312:	51 f0       	breq	.+20     	; 0xa328 <GPRS_CriticalCMD_Process+0x3e>
    a314:	84 30       	cpi	r24, 0x04	; 4
    a316:	51 f4       	brne	.+20     	; 0xa32c <GPRS_CriticalCMD_Process+0x42>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
			case GPRS_UPDATER:		Start_Updater(); break;
    a318:	0e 94 f9 28 	call	0x51f2	; 0x51f2 <Start_Updater>
    a31c:	07 c0       	rjmp	.+14     	; 0xa32c <GPRS_CriticalCMD_Process+0x42>
    a31e:	ff cf       	rjmp	.-2      	; 0xa31e <GPRS_CriticalCMD_Process+0x34>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    a320:	8a e5       	ldi	r24, 0x5A	; 90
    a322:	80 93 27 06 	sts	0x0627, r24
    a326:	02 c0       	rjmp	.+4      	; 0xa32c <GPRS_CriticalCMD_Process+0x42>
void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
		switch(GPRS_CriticalCMD){
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    a328:	0e 94 c6 29 	call	0x538c	; 0x538c <Start_Bootloader>
			case GPRS_UPDATER:		Start_Updater(); break;
		}
		GPRS_CriticalCMD = 0;
    a32c:	10 92 e3 03 	sts	0x03E3, r1
    a330:	08 95       	ret

0000a332 <GPRS_Param00>:
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    a332:	cf 92       	push	r12
    a334:	ef 92       	push	r14
    a336:	0f 93       	push	r16
    a338:	cf 93       	push	r28
    a33a:	c8 2f       	mov	r28, r24
    a33c:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    a33e:	84 30       	cpi	r24, 0x04	; 4
    a340:	59 f1       	breq	.+86     	; 0xa398 <GPRS_Param00+0x66>
    a342:	28 f4       	brcc	.+10     	; 0xa34e <GPRS_Param00+0x1c>
    a344:	81 30       	cpi	r24, 0x01	; 1
    a346:	49 f0       	breq	.+18     	; 0xa35a <GPRS_Param00+0x28>
    a348:	82 30       	cpi	r24, 0x02	; 2
    a34a:	81 f0       	breq	.+32     	; 0xa36c <GPRS_Param00+0x3a>
    a34c:	4f c0       	rjmp	.+158    	; 0xa3ec <GPRS_Param00+0xba>
    a34e:	86 30       	cpi	r24, 0x06	; 6
    a350:	99 f1       	breq	.+102    	; 0xa3b8 <GPRS_Param00+0x86>
    a352:	50 f1       	brcs	.+84     	; 0xa3a8 <GPRS_Param00+0x76>
    a354:	87 30       	cpi	r24, 0x07	; 7
    a356:	c1 f1       	breq	.+112    	; 0xa3c8 <GPRS_Param00+0x96>
    a358:	49 c0       	rjmp	.+146    	; 0xa3ec <GPRS_Param00+0xba>
		case 1:	if(Cmd==READ_PARAM){
    a35a:	61 3c       	cpi	r22, 0xC1	; 193
    a35c:	09 f0       	breq	.+2      	; 0xa360 <GPRS_Param00+0x2e>
    a35e:	46 c0       	rjmp	.+140    	; 0xa3ec <GPRS_Param00+0xba>
					GPRS_ChangeData[9] = SW_VERSION;
    a360:	84 e0       	ldi	r24, 0x04	; 4
    a362:	80 93 46 06 	sts	0x0646, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    a366:	c0 93 47 06 	sts	0x0647, r28
    a36a:	3e c0       	rjmp	.+124    	; 0xa3e8 <GPRS_Param00+0xb6>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    a36c:	61 3c       	cpi	r22, 0xC1	; 193
    a36e:	49 f4       	brne	.+18     	; 0xa382 <GPRS_Param00+0x50>
    a370:	42 e0       	ldi	r20, 0x02	; 2
    a372:	50 e0       	ldi	r21, 0x00	; 0
    a374:	6c e0       	ldi	r22, 0x0C	; 12
    a376:	71 e0       	ldi	r23, 0x01	; 1
    a378:	86 e4       	ldi	r24, 0x46	; 70
    a37a:	96 e0       	ldi	r25, 0x06	; 6
    a37c:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a380:	33 c0       	rjmp	.+102    	; 0xa3e8 <GPRS_Param00+0xb6>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    a382:	6c 34       	cpi	r22, 0x4C	; 76
    a384:	89 f5       	brne	.+98     	; 0xa3e8 <GPRS_Param00+0xb6>
    a386:	42 e0       	ldi	r20, 0x02	; 2
    a388:	50 e0       	ldi	r21, 0x00	; 0
    a38a:	6c e0       	ldi	r22, 0x0C	; 12
    a38c:	71 e0       	ldi	r23, 0x01	; 1
    a38e:	88 e4       	ldi	r24, 0x48	; 72
    a390:	98 e0       	ldi	r25, 0x08	; 8
    a392:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
    a396:	28 c0       	rjmp	.+80     	; 0xa3e8 <GPRS_Param00+0xb6>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    a398:	6c 34       	cpi	r22, 0x4C	; 76
    a39a:	41 f5       	brne	.+80     	; 0xa3ec <GPRS_Param00+0xba>
    a39c:	80 91 48 08 	lds	r24, 0x0848
    a3a0:	88 23       	and	r24, r24
    a3a2:	21 f1       	breq	.+72     	; 0xa3ec <GPRS_Param00+0xba>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    a3a4:	81 e0       	ldi	r24, 0x01	; 1
    a3a6:	17 c0       	rjmp	.+46     	; 0xa3d6 <GPRS_Param00+0xa4>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3a8:	6c 34       	cpi	r22, 0x4C	; 76
    a3aa:	01 f5       	brne	.+64     	; 0xa3ec <GPRS_Param00+0xba>
    a3ac:	80 91 48 08 	lds	r24, 0x0848
    a3b0:	88 23       	and	r24, r24
    a3b2:	e1 f0       	breq	.+56     	; 0xa3ec <GPRS_Param00+0xba>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    a3b4:	82 e0       	ldi	r24, 0x02	; 2
    a3b6:	0f c0       	rjmp	.+30     	; 0xa3d6 <GPRS_Param00+0xa4>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3b8:	6c 34       	cpi	r22, 0x4C	; 76
    a3ba:	c1 f4       	brne	.+48     	; 0xa3ec <GPRS_Param00+0xba>
    a3bc:	80 91 48 08 	lds	r24, 0x0848
    a3c0:	88 23       	and	r24, r24
    a3c2:	a1 f0       	breq	.+40     	; 0xa3ec <GPRS_Param00+0xba>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    a3c4:	83 e0       	ldi	r24, 0x03	; 3
    a3c6:	07 c0       	rjmp	.+14     	; 0xa3d6 <GPRS_Param00+0xa4>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3c8:	6c 34       	cpi	r22, 0x4C	; 76
    a3ca:	81 f4       	brne	.+32     	; 0xa3ec <GPRS_Param00+0xba>
    a3cc:	80 91 48 08 	lds	r24, 0x0848
    a3d0:	88 23       	and	r24, r24
    a3d2:	61 f0       	breq	.+24     	; 0xa3ec <GPRS_Param00+0xba>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    a3d4:	84 e0       	ldi	r24, 0x04	; 4
    a3d6:	80 93 e3 03 	sts	0x03E3, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    a3da:	60 e9       	ldi	r22, 0x90	; 144
    a3dc:	71 e0       	ldi	r23, 0x01	; 1
    a3de:	80 91 0c 0b 	lds	r24, 0x0B0C
    a3e2:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    a3e6:	02 c0       	rjmp	.+4      	; 0xa3ec <GPRS_Param00+0xba>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
				param_size = sizeof(Vega_SN);
    a3e8:	22 e0       	ldi	r18, 0x02	; 2
    a3ea:	01 c0       	rjmp	.+2      	; 0xa3ee <GPRS_Param00+0xbc>
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
	uint8_t param_size = 0;
    a3ec:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a3ee:	c1 2c       	mov	r12, r1
    a3f0:	e1 2c       	mov	r14, r1
    a3f2:	40 e0       	ldi	r20, 0x00	; 0
    a3f4:	50 e0       	ldi	r21, 0x00	; 0
    a3f6:	6c 2f       	mov	r22, r28
    a3f8:	80 e0       	ldi	r24, 0x00	; 0
    a3fa:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a3fe:	cf 91       	pop	r28
    a400:	0f 91       	pop	r16
    a402:	ef 90       	pop	r14
    a404:	cf 90       	pop	r12
    a406:	08 95       	ret

0000a408 <GPRS_Param01>:
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a408:	cf 92       	push	r12
    a40a:	ef 92       	push	r14
    a40c:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a40e:	c1 2c       	mov	r12, r1
    a410:	e1 2c       	mov	r14, r1
    a412:	06 2f       	mov	r16, r22
    a414:	20 e0       	ldi	r18, 0x00	; 0
    a416:	40 e0       	ldi	r20, 0x00	; 0
    a418:	50 e0       	ldi	r21, 0x00	; 0
    a41a:	68 2f       	mov	r22, r24
    a41c:	81 e0       	ldi	r24, 0x01	; 1
    a41e:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a422:	0f 91       	pop	r16
    a424:	ef 90       	pop	r14
    a426:	cf 90       	pop	r12
    a428:	08 95       	ret

0000a42a <GPRS_Param02>:
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a42a:	cf 92       	push	r12
    a42c:	ef 92       	push	r14
    a42e:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    a430:	c1 2c       	mov	r12, r1
    a432:	e1 2c       	mov	r14, r1
    a434:	06 2f       	mov	r16, r22
    a436:	21 e0       	ldi	r18, 0x01	; 1
    a438:	40 e0       	ldi	r20, 0x00	; 0
    a43a:	50 e0       	ldi	r21, 0x00	; 0
    a43c:	68 2f       	mov	r22, r24
    a43e:	82 e0       	ldi	r24, 0x02	; 2
    a440:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a444:	0f 91       	pop	r16
    a446:	ef 90       	pop	r14
    a448:	cf 90       	pop	r12
    a44a:	08 95       	ret

0000a44c <GPRS_Param03>:
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a44c:	cf 92       	push	r12
    a44e:	ef 92       	push	r14
    a450:	0f 93       	push	r16
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a452:	c1 2c       	mov	r12, r1
    a454:	ee 24       	eor	r14, r14
    a456:	e3 94       	inc	r14
    a458:	06 2f       	mov	r16, r22
    a45a:	20 e0       	ldi	r18, 0x00	; 0
    a45c:	40 e0       	ldi	r20, 0x00	; 0
    a45e:	50 e0       	ldi	r21, 0x00	; 0
    a460:	68 2f       	mov	r22, r24
    a462:	83 e0       	ldi	r24, 0x03	; 3
    a464:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a468:	0f 91       	pop	r16
    a46a:	ef 90       	pop	r14
    a46c:	cf 90       	pop	r12
    a46e:	08 95       	ret

0000a470 <GPRS_Param04>:

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a470:	cf 92       	push	r12
    a472:	ef 92       	push	r14
    a474:	0f 93       	push	r16
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a476:	c1 2c       	mov	r12, r1
    a478:	ee 24       	eor	r14, r14
    a47a:	e3 94       	inc	r14
    a47c:	06 2f       	mov	r16, r22
    a47e:	20 e0       	ldi	r18, 0x00	; 0
    a480:	40 e0       	ldi	r20, 0x00	; 0
    a482:	50 e0       	ldi	r21, 0x00	; 0
    a484:	68 2f       	mov	r22, r24
    a486:	84 e0       	ldi	r24, 0x04	; 4
    a488:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a48c:	0f 91       	pop	r16
    a48e:	ef 90       	pop	r14
    a490:	cf 90       	pop	r12
    a492:	08 95       	ret

0000a494 <GPRS_Param05>:

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a494:	cf 92       	push	r12
    a496:	ef 92       	push	r14
    a498:	0f 93       	push	r16
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a49a:	c1 2c       	mov	r12, r1
    a49c:	ee 24       	eor	r14, r14
    a49e:	e3 94       	inc	r14
    a4a0:	06 2f       	mov	r16, r22
    a4a2:	20 e0       	ldi	r18, 0x00	; 0
    a4a4:	40 e0       	ldi	r20, 0x00	; 0
    a4a6:	50 e0       	ldi	r21, 0x00	; 0
    a4a8:	68 2f       	mov	r22, r24
    a4aa:	85 e0       	ldi	r24, 0x05	; 5
    a4ac:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a4b0:	0f 91       	pop	r16
    a4b2:	ef 90       	pop	r14
    a4b4:	cf 90       	pop	r12
    a4b6:	08 95       	ret

0000a4b8 <GPRS_Param06>:

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4b8:	cf 92       	push	r12
    a4ba:	ef 92       	push	r14
    a4bc:	0f 93       	push	r16
    a4be:	2f ef       	ldi	r18, 0xFF	; 255
    a4c0:	28 0f       	add	r18, r24
    a4c2:	27 30       	cpi	r18, 0x07	; 7
    a4c4:	68 f4       	brcc	.+26     	; 0xa4e0 <GPRS_Param06+0x28>
    a4c6:	30 e0       	ldi	r19, 0x00	; 0
    a4c8:	f9 01       	movw	r30, r18
    a4ca:	ee 0f       	add	r30, r30
    a4cc:	ff 1f       	adc	r31, r31
    a4ce:	e4 51       	subi	r30, 0x14	; 20
    a4d0:	fe 4f       	sbci	r31, 0xFE	; 254
    a4d2:	40 81       	ld	r20, Z
    a4d4:	51 81       	ldd	r21, Z+1	; 0x01
    a4d6:	f9 01       	movw	r30, r18
    a4d8:	eb 51       	subi	r30, 0x1B	; 27
    a4da:	fe 4f       	sbci	r31, 0xFE	; 254
    a4dc:	20 81       	ld	r18, Z
    a4de:	03 c0       	rjmp	.+6      	; 0xa4e6 <GPRS_Param06+0x2e>
    a4e0:	20 e0       	ldi	r18, 0x00	; 0
    a4e2:	40 e0       	ldi	r20, 0x00	; 0
    a4e4:	50 e0       	ldi	r21, 0x00	; 0
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a4e6:	c1 2c       	mov	r12, r1
    a4e8:	ee 24       	eor	r14, r14
    a4ea:	e3 94       	inc	r14
    a4ec:	06 2f       	mov	r16, r22
    a4ee:	68 2f       	mov	r22, r24
    a4f0:	86 e0       	ldi	r24, 0x06	; 6
    a4f2:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a4f6:	0f 91       	pop	r16
    a4f8:	ef 90       	pop	r14
    a4fa:	cf 90       	pop	r12
    a4fc:	08 95       	ret

0000a4fe <GPRS_Param07>:
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4fe:	cf 92       	push	r12
    a500:	ef 92       	push	r14
    a502:	0f 93       	push	r16
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a504:	c1 2c       	mov	r12, r1
    a506:	ee 24       	eor	r14, r14
    a508:	e3 94       	inc	r14
    a50a:	06 2f       	mov	r16, r22
    a50c:	20 e0       	ldi	r18, 0x00	; 0
    a50e:	40 e0       	ldi	r20, 0x00	; 0
    a510:	50 e0       	ldi	r21, 0x00	; 0
    a512:	68 2f       	mov	r22, r24
    a514:	87 e0       	ldi	r24, 0x07	; 7
    a516:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a51a:	0f 91       	pop	r16
    a51c:	ef 90       	pop	r14
    a51e:	cf 90       	pop	r12
    a520:	08 95       	ret

0000a522 <GPRS_Param08>:

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a522:	cf 92       	push	r12
    a524:	ef 92       	push	r14
    a526:	0f 93       	push	r16
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    a528:	c1 2c       	mov	r12, r1
    a52a:	ee 24       	eor	r14, r14
    a52c:	e3 94       	inc	r14
    a52e:	06 2f       	mov	r16, r22
    a530:	20 e0       	ldi	r18, 0x00	; 0
    a532:	40 e0       	ldi	r20, 0x00	; 0
    a534:	50 e0       	ldi	r21, 0x00	; 0
    a536:	68 2f       	mov	r22, r24
    a538:	88 e0       	ldi	r24, 0x08	; 8
    a53a:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a53e:	0f 91       	pop	r16
    a540:	ef 90       	pop	r14
    a542:	cf 90       	pop	r12
    a544:	08 95       	ret

0000a546 <GPRS_Param09>:

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a546:	cf 92       	push	r12
    a548:	ef 92       	push	r14
    a54a:	0f 93       	push	r16
    a54c:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a54e:	48 2f       	mov	r20, r24
    a550:	50 e0       	ldi	r21, 0x00	; 0
    a552:	fa 01       	movw	r30, r20
    a554:	31 97       	sbiw	r30, 0x01	; 1
    a556:	e6 31       	cpi	r30, 0x16	; 22
    a558:	f1 05       	cpc	r31, r1
    a55a:	08 f0       	brcs	.+2      	; 0xa55e <GPRS_Param09+0x18>
    a55c:	78 c0       	rjmp	.+240    	; 0xa64e <GPRS_Param09+0x108>
    a55e:	e2 55       	subi	r30, 0x52	; 82
    a560:	ff 4f       	sbci	r31, 0xFF	; 255
    a562:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
    a566:	23 e1       	ldi	r18, 0x13	; 19
    a568:	44 e5       	ldi	r20, 0x54	; 84
    a56a:	51 e0       	ldi	r21, 0x01	; 1
    a56c:	7b c0       	rjmp	.+246    	; 0xa664 <GPRS_Param09+0x11e>
void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:
			if(Cmd==READ_PARAM){
    a56e:	61 3c       	cpi	r22, 0xC1	; 193
    a570:	91 f4       	brne	.+36     	; 0xa596 <GPRS_Param09+0x50>
    a572:	4f e0       	ldi	r20, 0x0F	; 15
    a574:	50 e0       	ldi	r21, 0x00	; 0
    a576:	6c e7       	ldi	r22, 0x7C	; 124
    a578:	71 e0       	ldi	r23, 0x01	; 1
    a57a:	86 e4       	ldi	r24, 0x46	; 70
    a57c:	96 e0       	ldi	r25, 0x06	; 6
    a57e:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a582:	4f e0       	ldi	r20, 0x0F	; 15
    a584:	50 e0       	ldi	r21, 0x00	; 0
    a586:	6a e9       	ldi	r22, 0x9A	; 154
    a588:	71 e0       	ldi	r23, 0x01	; 1
    a58a:	85 e5       	ldi	r24, 0x55	; 85
    a58c:	96 e0       	ldi	r25, 0x06	; 6
    a58e:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
    a592:	2e e1       	ldi	r18, 0x1E	; 30
    a594:	5f c0       	rjmp	.+190    	; 0xa654 <GPRS_Param09+0x10e>
			}
			if(Cmd==WRITE_PARAM){
    a596:	6c 34       	cpi	r22, 0x4C	; 76
    a598:	09 f0       	breq	.+2      	; 0xa59c <GPRS_Param09+0x56>
    a59a:	6f c0       	rjmp	.+222    	; 0xa67a <GPRS_Param09+0x134>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    a59c:	4f e0       	ldi	r20, 0x0F	; 15
    a59e:	50 e0       	ldi	r21, 0x00	; 0
    a5a0:	6c e7       	ldi	r22, 0x7C	; 124
    a5a2:	71 e0       	ldi	r23, 0x01	; 1
    a5a4:	88 e4       	ldi	r24, 0x48	; 72
    a5a6:	98 e0       	ldi	r25, 0x08	; 8
    a5a8:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    a5ac:	4f e0       	ldi	r20, 0x0F	; 15
    a5ae:	50 e0       	ldi	r21, 0x00	; 0
    a5b0:	6e e3       	ldi	r22, 0x3E	; 62
    a5b2:	73 e0       	ldi	r23, 0x03	; 3
    a5b4:	87 e5       	ldi	r24, 0x57	; 87
    a5b6:	98 e0       	ldi	r25, 0x08	; 8
    a5b8:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
    a5bc:	5e c0       	rjmp	.+188    	; 0xa67a <GPRS_Param09+0x134>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    a5be:	24 e0       	ldi	r18, 0x04	; 4
    a5c0:	46 e4       	ldi	r20, 0x46	; 70
    a5c2:	51 e0       	ldi	r21, 0x01	; 1
    a5c4:	4f c0       	rjmp	.+158    	; 0xa664 <GPRS_Param09+0x11e>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    a5c6:	24 e0       	ldi	r18, 0x04	; 4
    a5c8:	4a e4       	ldi	r20, 0x4A	; 74
    a5ca:	51 e0       	ldi	r21, 0x01	; 1
    a5cc:	4b c0       	rjmp	.+150    	; 0xa664 <GPRS_Param09+0x11e>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    a5ce:	24 e0       	ldi	r18, 0x04	; 4
    a5d0:	4e e4       	ldi	r20, 0x4E	; 78
    a5d2:	51 e0       	ldi	r21, 0x01	; 1
    a5d4:	47 c0       	rjmp	.+142    	; 0xa664 <GPRS_Param09+0x11e>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    a5d6:	22 e0       	ldi	r18, 0x02	; 2
    a5d8:	4a e2       	ldi	r20, 0x2A	; 42
    a5da:	51 e0       	ldi	r21, 0x01	; 1
    a5dc:	43 c0       	rjmp	.+134    	; 0xa664 <GPRS_Param09+0x11e>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    a5de:	22 e0       	ldi	r18, 0x02	; 2
    a5e0:	4c e2       	ldi	r20, 0x2C	; 44
    a5e2:	51 e0       	ldi	r21, 0x01	; 1
    a5e4:	3f c0       	rjmp	.+126    	; 0xa664 <GPRS_Param09+0x11e>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    a5e6:	22 e0       	ldi	r18, 0x02	; 2
    a5e8:	4e e2       	ldi	r20, 0x2E	; 46
    a5ea:	51 e0       	ldi	r21, 0x01	; 1
    a5ec:	3b c0       	rjmp	.+118    	; 0xa664 <GPRS_Param09+0x11e>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    a5ee:	22 e0       	ldi	r18, 0x02	; 2
    a5f0:	40 e3       	ldi	r20, 0x30	; 48
    a5f2:	51 e0       	ldi	r21, 0x01	; 1
    a5f4:	37 c0       	rjmp	.+110    	; 0xa664 <GPRS_Param09+0x11e>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    a5f6:	24 e0       	ldi	r18, 0x04	; 4
    a5f8:	40 e1       	ldi	r20, 0x10	; 16
    a5fa:	51 e0       	ldi	r21, 0x01	; 1
    a5fc:	33 c0       	rjmp	.+102    	; 0xa664 <GPRS_Param09+0x11e>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    a5fe:	24 e0       	ldi	r18, 0x04	; 4
    a600:	44 e1       	ldi	r20, 0x14	; 20
    a602:	51 e0       	ldi	r21, 0x01	; 1
    a604:	2f c0       	rjmp	.+94     	; 0xa664 <GPRS_Param09+0x11e>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    a606:	24 e0       	ldi	r18, 0x04	; 4
    a608:	48 e1       	ldi	r20, 0x18	; 24
    a60a:	51 e0       	ldi	r21, 0x01	; 1
    a60c:	2b c0       	rjmp	.+86     	; 0xa664 <GPRS_Param09+0x11e>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    a60e:	24 e0       	ldi	r18, 0x04	; 4
    a610:	4c e1       	ldi	r20, 0x1C	; 28
    a612:	51 e0       	ldi	r21, 0x01	; 1
    a614:	27 c0       	rjmp	.+78     	; 0xa664 <GPRS_Param09+0x11e>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    a616:	22 e0       	ldi	r18, 0x02	; 2
    a618:	40 e2       	ldi	r20, 0x20	; 32
    a61a:	51 e0       	ldi	r21, 0x01	; 1
    a61c:	23 c0       	rjmp	.+70     	; 0xa664 <GPRS_Param09+0x11e>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    a61e:	22 e0       	ldi	r18, 0x02	; 2
    a620:	4e e0       	ldi	r20, 0x0E	; 14
    a622:	51 e0       	ldi	r21, 0x01	; 1
    a624:	1f c0       	rjmp	.+62     	; 0xa664 <GPRS_Param09+0x11e>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    a626:	21 e0       	ldi	r18, 0x01	; 1
    a628:	40 e6       	ldi	r20, 0x60	; 96
    a62a:	50 e0       	ldi	r21, 0x00	; 0
    a62c:	1b c0       	rjmp	.+54     	; 0xa664 <GPRS_Param09+0x11e>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    a62e:	2c e0       	ldi	r18, 0x0C	; 12
    a630:	43 ee       	ldi	r20, 0xE3	; 227
    a632:	50 e0       	ldi	r21, 0x00	; 0
    a634:	17 c0       	rjmp	.+46     	; 0xa664 <GPRS_Param09+0x11e>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    a636:	2c e0       	ldi	r18, 0x0C	; 12
    a638:	40 ef       	ldi	r20, 0xF0	; 240
    a63a:	50 e0       	ldi	r21, 0x00	; 0
    a63c:	13 c0       	rjmp	.+38     	; 0xa664 <GPRS_Param09+0x11e>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    a63e:	2c e0       	ldi	r18, 0x0C	; 12
    a640:	4d ef       	ldi	r20, 0xFD	; 253
    a642:	50 e0       	ldi	r21, 0x00	; 0
    a644:	0f c0       	rjmp	.+30     	; 0xa664 <GPRS_Param09+0x11e>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;
    a646:	22 e0       	ldi	r18, 0x02	; 2
    a648:	48 e0       	ldi	r20, 0x08	; 8
    a64a:	50 e0       	ldi	r21, 0x00	; 0
    a64c:	0b c0       	rjmp	.+22     	; 0xa664 <GPRS_Param09+0x11e>
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a64e:	20 e0       	ldi	r18, 0x00	; 0
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a650:	81 30       	cpi	r24, 0x01	; 1
    a652:	31 f4       	brne	.+12     	; 0xa660 <GPRS_Param09+0x11a>
    a654:	c1 2c       	mov	r12, r1
    a656:	e1 2c       	mov	r14, r1
    a658:	40 e0       	ldi	r20, 0x00	; 0
    a65a:	50 e0       	ldi	r21, 0x00	; 0
    a65c:	61 e0       	ldi	r22, 0x01	; 1
    a65e:	06 c0       	rjmp	.+12     	; 0xa66c <GPRS_Param09+0x126>
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a660:	40 e0       	ldi	r20, 0x00	; 0
    a662:	50 e0       	ldi	r21, 0x00	; 0

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a664:	c1 2c       	mov	r12, r1
    a666:	ee 24       	eor	r14, r14
    a668:	e3 94       	inc	r14
    a66a:	68 2f       	mov	r22, r24
    a66c:	89 e0       	ldi	r24, 0x09	; 9
    a66e:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a672:	0f 91       	pop	r16
    a674:	ef 90       	pop	r14
    a676:	cf 90       	pop	r12
    a678:	08 95       	ret
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a67a:	20 e0       	ldi	r18, 0x00	; 0
    a67c:	eb cf       	rjmp	.-42     	; 0xa654 <GPRS_Param09+0x10e>
			if(Cmd==WRITE_PARAM){
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
    a67e:	23 e1       	ldi	r18, 0x13	; 19
    a680:	48 e6       	ldi	r20, 0x68	; 104
    a682:	51 e0       	ldi	r21, 0x01	; 1
    a684:	ef cf       	rjmp	.-34     	; 0xa664 <GPRS_Param09+0x11e>
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    a686:	24 e0       	ldi	r18, 0x04	; 4
    a688:	42 e4       	ldi	r20, 0x42	; 66
    a68a:	51 e0       	ldi	r21, 0x01	; 1
    a68c:	eb cf       	rjmp	.-42     	; 0xa664 <GPRS_Param09+0x11e>

0000a68e <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a68e:	cf 92       	push	r12
    a690:	ef 92       	push	r14
    a692:	0f 93       	push	r16
    a694:	ef ef       	ldi	r30, 0xFF	; 255
    a696:	e8 0f       	add	r30, r24
    a698:	e5 30       	cpi	r30, 0x05	; 5
    a69a:	48 f4       	brcc	.+18     	; 0xa6ae <GPRS_Param10+0x20>
    a69c:	f0 e0       	ldi	r31, 0x00	; 0
    a69e:	ee 0f       	add	r30, r30
    a6a0:	ff 1f       	adc	r31, r31
    a6a2:	e5 52       	subi	r30, 0x25	; 37
    a6a4:	fe 4f       	sbci	r31, 0xFE	; 254
    a6a6:	40 81       	ld	r20, Z
    a6a8:	51 81       	ldd	r21, Z+1	; 0x01
    a6aa:	22 e0       	ldi	r18, 0x02	; 2
    a6ac:	03 c0       	rjmp	.+6      	; 0xa6b4 <GPRS_Param10+0x26>
    a6ae:	20 e0       	ldi	r18, 0x00	; 0
    a6b0:	40 e0       	ldi	r20, 0x00	; 0
    a6b2:	50 e0       	ldi	r21, 0x00	; 0
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6b4:	c1 2c       	mov	r12, r1
    a6b6:	ee 24       	eor	r14, r14
    a6b8:	e3 94       	inc	r14
    a6ba:	06 2f       	mov	r16, r22
    a6bc:	68 2f       	mov	r22, r24
    a6be:	8a e0       	ldi	r24, 0x0A	; 10
    a6c0:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
}
    a6c4:	0f 91       	pop	r16
    a6c6:	ef 90       	pop	r14
    a6c8:	cf 90       	pop	r12
    a6ca:	08 95       	ret

0000a6cc <GPRS_Param11>:
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a6cc:	cf 92       	push	r12
    a6ce:	ef 92       	push	r14
    a6d0:	0f 93       	push	r16
    a6d2:	cf 93       	push	r28
    a6d4:	c8 2f       	mov	r28, r24
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a6d6:	81 30       	cpi	r24, 0x01	; 1
    a6d8:	21 f4       	brne	.+8      	; 0xa6e2 <GPRS_Param11+0x16>
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
    a6da:	21 e0       	ldi	r18, 0x01	; 1
    a6dc:	49 e2       	ldi	r20, 0x29	; 41
    a6de:	50 e0       	ldi	r21, 0x00	; 0
    a6e0:	03 c0       	rjmp	.+6      	; 0xa6e8 <GPRS_Param11+0x1c>
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a6e2:	20 e0       	ldi	r18, 0x00	; 0
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a6e4:	40 e0       	ldi	r20, 0x00	; 0
    a6e6:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6e8:	c1 2c       	mov	r12, r1
    a6ea:	ee 24       	eor	r14, r14
    a6ec:	e3 94       	inc	r14
    a6ee:	06 2f       	mov	r16, r22
    a6f0:	6c 2f       	mov	r22, r28
    a6f2:	8b e0       	ldi	r24, 0x0B	; 11
    a6f4:	0e 94 2d 51 	call	0xa25a	; 0xa25a <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a6f8:	c1 30       	cpi	r28, 0x01	; 1
    a6fa:	31 f4       	brne	.+12     	; 0xa708 <GPRS_Param11+0x3c>
#endif
}
    a6fc:	cf 91       	pop	r28
    a6fe:	0f 91       	pop	r16
    a700:	ef 90       	pop	r14
    a702:	cf 90       	pop	r12
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a704:	0c 94 b2 4b 	jmp	0x9764	; 0x9764 <EMeter_ReInit>
#endif
}
    a708:	cf 91       	pop	r28
    a70a:	0f 91       	pop	r16
    a70c:	ef 90       	pop	r14
    a70e:	cf 90       	pop	r12
    a710:	08 95       	ret

0000a712 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
    a712:	0f 93       	push	r16
    a714:	1f 93       	push	r17
    a716:	08 2f       	mov	r16, r24
    a718:	86 2f       	mov	r24, r22
    a71a:	64 2f       	mov	r22, r20
	switch(ParamID_Hi){
    a71c:	10 e0       	ldi	r17, 0x00	; 0
    a71e:	0c 30       	cpi	r16, 0x0C	; 12
    a720:	11 05       	cpc	r17, r1
    a722:	a8 f5       	brcc	.+106    	; 0xa78e <GPRS_Parameter+0x7c>
    a724:	f8 01       	movw	r30, r16
    a726:	ec 53       	subi	r30, 0x3C	; 60
    a728:	ff 4f       	sbci	r31, 0xFF	; 255
    a72a:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a72e:	1f 91       	pop	r17
    a730:	0f 91       	pop	r16
#endif
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    a732:	0c 94 99 51 	jmp	0xa332	; 0xa332 <GPRS_Param00>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a736:	1f 91       	pop	r17
    a738:	0f 91       	pop	r16
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    a73a:	0c 94 04 52 	jmp	0xa408	; 0xa408 <GPRS_Param01>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a73e:	1f 91       	pop	r17
    a740:	0f 91       	pop	r16

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    a742:	0c 94 15 52 	jmp	0xa42a	; 0xa42a <GPRS_Param02>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a746:	1f 91       	pop	r17
    a748:	0f 91       	pop	r16
void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    a74a:	0c 94 26 52 	jmp	0xa44c	; 0xa44c <GPRS_Param03>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a74e:	1f 91       	pop	r17
    a750:	0f 91       	pop	r16
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    a752:	0c 94 38 52 	jmp	0xa470	; 0xa470 <GPRS_Param04>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a756:	1f 91       	pop	r17
    a758:	0f 91       	pop	r16
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    a75a:	0c 94 4a 52 	jmp	0xa494	; 0xa494 <GPRS_Param05>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a75e:	1f 91       	pop	r17
    a760:	0f 91       	pop	r16
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    a762:	0c 94 5c 52 	jmp	0xa4b8	; 0xa4b8 <GPRS_Param06>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a766:	1f 91       	pop	r17
    a768:	0f 91       	pop	r16
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    a76a:	0c 94 7f 52 	jmp	0xa4fe	; 0xa4fe <GPRS_Param07>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a76e:	1f 91       	pop	r17
    a770:	0f 91       	pop	r16
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    a772:	0c 94 91 52 	jmp	0xa522	; 0xa522 <GPRS_Param08>
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a776:	1f 91       	pop	r17
    a778:	0f 91       	pop	r16
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    a77a:	0c 94 a3 52 	jmp	0xa546	; 0xa546 <GPRS_Param09>
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a77e:	1f 91       	pop	r17
    a780:	0f 91       	pop	r16
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    a782:	0c 94 47 53 	jmp	0xa68e	; 0xa68e <GPRS_Param10>
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a786:	1f 91       	pop	r17
    a788:	0f 91       	pop	r16
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    a78a:	0c 94 66 53 	jmp	0xa6cc	; 0xa6cc <GPRS_Param11>
	}
}
    a78e:	1f 91       	pop	r17
    a790:	0f 91       	pop	r16
    a792:	08 95       	ret

0000a794 <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    a794:	cf 93       	push	r28
    a796:	c8 2f       	mov	r28, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    a798:	82 30       	cpi	r24, 0x02	; 2
    a79a:	09 f0       	breq	.+2      	; 0xa79e <ReadParamBlock+0xa>
    a79c:	80 c0       	rjmp	.+256    	; 0xa89e <ReadParamBlock+0x10a>
    a79e:	4f e0       	ldi	r20, 0x0F	; 15
    a7a0:	50 e0       	ldi	r21, 0x00	; 0
    a7a2:	6c e7       	ldi	r22, 0x7C	; 124
    a7a4:	71 e0       	ldi	r23, 0x01	; 1
    a7a6:	85 e4       	ldi	r24, 0x45	; 69
    a7a8:	96 e0       	ldi	r25, 0x06	; 6
    a7aa:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7ae:	4f e0       	ldi	r20, 0x0F	; 15
    a7b0:	50 e0       	ldi	r21, 0x00	; 0
    a7b2:	6e e3       	ldi	r22, 0x3E	; 62
    a7b4:	73 e0       	ldi	r23, 0x03	; 3
    a7b6:	84 e5       	ldi	r24, 0x54	; 84
    a7b8:	96 e0       	ldi	r25, 0x06	; 6
    a7ba:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7be:	43 e1       	ldi	r20, 0x13	; 19
    a7c0:	50 e0       	ldi	r21, 0x00	; 0
    a7c2:	68 e6       	ldi	r22, 0x68	; 104
    a7c4:	71 e0       	ldi	r23, 0x01	; 1
    a7c6:	83 e6       	ldi	r24, 0x63	; 99
    a7c8:	96 e0       	ldi	r25, 0x06	; 6
    a7ca:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7ce:	44 e1       	ldi	r20, 0x14	; 20
    a7d0:	50 e0       	ldi	r21, 0x00	; 0
    a7d2:	64 e5       	ldi	r22, 0x54	; 84
    a7d4:	71 e0       	ldi	r23, 0x01	; 1
    a7d6:	86 e7       	ldi	r24, 0x76	; 118
    a7d8:	96 e0       	ldi	r25, 0x06	; 6
    a7da:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7de:	40 e1       	ldi	r20, 0x10	; 16
    a7e0:	50 e0       	ldi	r21, 0x00	; 0
    a7e2:	62 e4       	ldi	r22, 0x42	; 66
    a7e4:	71 e0       	ldi	r23, 0x01	; 1
    a7e6:	89 e8       	ldi	r24, 0x89	; 137
    a7e8:	96 e0       	ldi	r25, 0x06	; 6
    a7ea:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7ee:	48 e0       	ldi	r20, 0x08	; 8
    a7f0:	50 e0       	ldi	r21, 0x00	; 0
    a7f2:	6a e2       	ldi	r22, 0x2A	; 42
    a7f4:	71 e0       	ldi	r23, 0x01	; 1
    a7f6:	89 e9       	ldi	r24, 0x99	; 153
    a7f8:	96 e0       	ldi	r25, 0x06	; 6
    a7fa:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a7fe:	40 e1       	ldi	r20, 0x10	; 16
    a800:	50 e0       	ldi	r21, 0x00	; 0
    a802:	60 e1       	ldi	r22, 0x10	; 16
    a804:	71 e0       	ldi	r23, 0x01	; 1
    a806:	81 ea       	ldi	r24, 0xA1	; 161
    a808:	96 e0       	ldi	r25, 0x06	; 6
    a80a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a80e:	42 e0       	ldi	r20, 0x02	; 2
    a810:	50 e0       	ldi	r21, 0x00	; 0
    a812:	60 e2       	ldi	r22, 0x20	; 32
    a814:	71 e0       	ldi	r23, 0x01	; 1
    a816:	81 eb       	ldi	r24, 0xB1	; 177
    a818:	96 e0       	ldi	r25, 0x06	; 6
    a81a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a81e:	42 e0       	ldi	r20, 0x02	; 2
    a820:	50 e0       	ldi	r21, 0x00	; 0
    a822:	6e e0       	ldi	r22, 0x0E	; 14
    a824:	71 e0       	ldi	r23, 0x01	; 1
    a826:	83 eb       	ldi	r24, 0xB3	; 179
    a828:	96 e0       	ldi	r25, 0x06	; 6
    a82a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a82e:	41 e0       	ldi	r20, 0x01	; 1
    a830:	50 e0       	ldi	r21, 0x00	; 0
    a832:	60 e6       	ldi	r22, 0x60	; 96
    a834:	70 e0       	ldi	r23, 0x00	; 0
    a836:	85 eb       	ldi	r24, 0xB5	; 181
    a838:	96 e0       	ldi	r25, 0x06	; 6
    a83a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a83e:	4c e0       	ldi	r20, 0x0C	; 12
    a840:	50 e0       	ldi	r21, 0x00	; 0
    a842:	63 ee       	ldi	r22, 0xE3	; 227
    a844:	70 e0       	ldi	r23, 0x00	; 0
    a846:	86 eb       	ldi	r24, 0xB6	; 182
    a848:	96 e0       	ldi	r25, 0x06	; 6
    a84a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a84e:	4c e0       	ldi	r20, 0x0C	; 12
    a850:	50 e0       	ldi	r21, 0x00	; 0
    a852:	60 ef       	ldi	r22, 0xF0	; 240
    a854:	70 e0       	ldi	r23, 0x00	; 0
    a856:	82 ec       	ldi	r24, 0xC2	; 194
    a858:	96 e0       	ldi	r25, 0x06	; 6
    a85a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a85e:	4c e0       	ldi	r20, 0x0C	; 12
    a860:	50 e0       	ldi	r21, 0x00	; 0
    a862:	6d ef       	ldi	r22, 0xFD	; 253
    a864:	70 e0       	ldi	r23, 0x00	; 0
    a866:	8e ec       	ldi	r24, 0xCE	; 206
    a868:	96 e0       	ldi	r25, 0x06	; 6
    a86a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
    a86e:	42 e0       	ldi	r20, 0x02	; 2
    a870:	50 e0       	ldi	r21, 0x00	; 0
    a872:	68 e0       	ldi	r22, 0x08	; 8
    a874:	70 e0       	ldi	r23, 0x00	; 0
    a876:	8a ed       	ldi	r24, 0xDA	; 218
    a878:	96 e0       	ldi	r25, 0x06	; 6
    a87a:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    a87e:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a882:	29 e9       	ldi	r18, 0x99	; 153
    a884:	41 e1       	ldi	r20, 0x11	; 17
    a886:	63 e0       	ldi	r22, 0x03	; 3
    a888:	8d e3       	ldi	r24, 0x3D	; 61
    a88a:	96 e0       	ldi	r25, 0x06	; 6
    a88c:	0e 94 0d 4d 	call	0x9a1a	; 0x9a1a <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a890:	80 91 5c 09 	lds	r24, 0x095C
    a894:	88 60       	ori	r24, 0x08	; 8
    a896:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a89a:	8f e9       	ldi	r24, 0x9F	; 159
    a89c:	17 c0       	rjmp	.+46     	; 0xa8cc <ReadParamBlock+0x138>
	}

	if(Block == 3){
    a89e:	83 30       	cpi	r24, 0x03	; 3
    a8a0:	c1 f4       	brne	.+48     	; 0xa8d2 <ReadParamBlock+0x13e>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a8a2:	89 e2       	ldi	r24, 0x29	; 41
    a8a4:	90 e0       	ldi	r25, 0x00	; 0
    a8a6:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    a8aa:	80 93 45 06 	sts	0x0645, r24

		GPRS_ChangeData[7] = Block;
    a8ae:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a8b2:	23 e0       	ldi	r18, 0x03	; 3
    a8b4:	41 e1       	ldi	r20, 0x11	; 17
    a8b6:	63 e0       	ldi	r22, 0x03	; 3
    a8b8:	8d e3       	ldi	r24, 0x3D	; 61
    a8ba:	96 e0       	ldi	r25, 0x06	; 6
    a8bc:	0e 94 0d 4d 	call	0x9a1a	; 0x9a1a <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a8c0:	80 91 5c 09 	lds	r24, 0x095C
    a8c4:	88 60       	ori	r24, 0x08	; 8
    a8c6:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a8ca:	89 e0       	ldi	r24, 0x09	; 9
    a8cc:	80 93 11 06 	sts	0x0611, r24
    a8d0:	01 c0       	rjmp	.+2      	; 0xa8d4 <ReadParamBlock+0x140>

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){

	uint8_t blocksize=8;
    a8d2:	88 e0       	ldi	r24, 0x08	; 8
		GPRS_ChangeReplySize = blocksize;
	}

	return blocksize;
	
}
    a8d4:	cf 91       	pop	r28
    a8d6:	08 95       	ret

0000a8d8 <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){
    a8d8:	cf 93       	push	r28

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    a8da:	c0 91 5e 09 	lds	r28, 0x095E
    a8de:	cc 23       	and	r28, r28
    a8e0:	09 f4       	brne	.+2      	; 0xa8e4 <GPRS_ReciveData+0xc>
    a8e2:	8a c0       	rjmp	.+276    	; 0xa9f8 <GPRS_ReciveData+0x120>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    a8e4:	80 91 3d 08 	lds	r24, 0x083D
    a8e8:	85 30       	cpi	r24, 0x05	; 5
    a8ea:	09 f0       	breq	.+2      	; 0xa8ee <GPRS_ReciveData+0x16>
    a8ec:	85 c0       	rjmp	.+266    	; 0xa9f8 <GPRS_ReciveData+0x120>
    a8ee:	80 91 3e 08 	lds	r24, 0x083E
    a8f2:	81 30       	cpi	r24, 0x01	; 1
    a8f4:	09 f0       	breq	.+2      	; 0xa8f8 <GPRS_ReciveData+0x20>
    a8f6:	80 c0       	rjmp	.+256    	; 0xa9f8 <GPRS_ReciveData+0x120>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
    a8f8:	80 91 3f 08 	lds	r24, 0x083F
    a8fc:	90 e0       	ldi	r25, 0x00	; 0
    a8fe:	98 2f       	mov	r25, r24
    a900:	88 27       	eor	r24, r24
    a902:	20 91 40 08 	lds	r18, 0x0840
		if(GPRS_Check_PSW(Psw) == 0){
    a906:	82 0f       	add	r24, r18
    a908:	91 1d       	adc	r25, r1
    a90a:	0e 94 3a 50 	call	0xa074	; 0xa074 <GPRS_Check_PSW>
    a90e:	81 11       	cpse	r24, r1
    a910:	06 c0       	rjmp	.+12     	; 0xa91e <GPRS_ReciveData+0x46>
			GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a912:	80 91 69 09 	lds	r24, 0x0969
    a916:	88 60       	ori	r24, 0x08	; 8
    a918:	80 93 69 09 	sts	0x0969, r24
    a91c:	1b c0       	rjmp	.+54     	; 0xa954 <GPRS_ReciveData+0x7c>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    a91e:	80 91 41 08 	lds	r24, 0x0841
    a922:	84 30       	cpi	r24, 0x04	; 4
    a924:	d9 f4       	brne	.+54     	; 0xa95c <GPRS_ReciveData+0x84>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a926:	8c e0       	ldi	r24, 0x0C	; 12
    a928:	91 e0       	ldi	r25, 0x01	; 1
    a92a:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    a92e:	20 91 42 08 	lds	r18, 0x0842
    a932:	30 e0       	ldi	r19, 0x00	; 0
    a934:	32 2f       	mov	r19, r18
    a936:	22 27       	eor	r18, r18
    a938:	40 91 43 08 	lds	r20, 0x0843
    a93c:	24 0f       	add	r18, r20
    a93e:	31 1d       	adc	r19, r1
    a940:	40 91 69 09 	lds	r20, 0x0969
    a944:	82 17       	cp	r24, r18
    a946:	93 07       	cpc	r25, r19
    a948:	11 f4       	brne	.+4      	; 0xa94e <GPRS_ReciveData+0x76>
    a94a:	47 7f       	andi	r20, 0xF7	; 247
    a94c:	01 c0       	rjmp	.+2      	; 0xa950 <GPRS_ReciveData+0x78>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a94e:	48 60       	ori	r20, 0x08	; 8
    a950:	40 93 69 09 	sts	0x0969, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    a954:	80 91 5c 09 	lds	r24, 0x095C
    a958:	80 61       	ori	r24, 0x10	; 16
    a95a:	2e c0       	rjmp	.+92     	; 0xa9b8 <GPRS_ReciveData+0xe0>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    a95c:	83 30       	cpi	r24, 0x03	; 3
    a95e:	09 f0       	breq	.+2      	; 0xa962 <GPRS_ReciveData+0x8a>
    a960:	4b c0       	rjmp	.+150    	; 0xa9f8 <GPRS_ReciveData+0x120>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    a962:	20 91 10 0b 	lds	r18, 0x0B10
    a966:	30 91 11 0b 	lds	r19, 0x0B11
    a96a:	21 15       	cp	r18, r1
    a96c:	31 05       	cpc	r19, r1
    a96e:	89 f2       	breq	.-94     	; 0xa912 <GPRS_ReciveData+0x3a>
    a970:	80 91 42 08 	lds	r24, 0x0842
    a974:	90 e0       	ldi	r25, 0x00	; 0
    a976:	98 2f       	mov	r25, r24
    a978:	88 27       	eor	r24, r24
    a97a:	40 91 43 08 	lds	r20, 0x0843
    a97e:	84 0f       	add	r24, r20
    a980:	91 1d       	adc	r25, r1
    a982:	28 17       	cp	r18, r24
    a984:	39 07       	cpc	r19, r25
    a986:	29 f6       	brne	.-118    	; 0xa912 <GPRS_ReciveData+0x3a>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    a988:	90 91 44 08 	lds	r25, 0x0844
			
			switch(GPRS_Data_In[8]){
    a98c:	80 91 45 08 	lds	r24, 0x0845
    a990:	88 30       	cpi	r24, 0x08	; 8
    a992:	d9 f0       	breq	.+54     	; 0xa9ca <GPRS_ReciveData+0xf2>
    a994:	28 f4       	brcc	.+10     	; 0xa9a0 <GPRS_ReciveData+0xc8>
    a996:	81 30       	cpi	r24, 0x01	; 1
    a998:	41 f0       	breq	.+16     	; 0xa9aa <GPRS_ReciveData+0xd2>
    a99a:	87 30       	cpi	r24, 0x07	; 7
    a99c:	81 f0       	breq	.+32     	; 0xa9be <GPRS_ReciveData+0xe6>
    a99e:	2c c0       	rjmp	.+88     	; 0xa9f8 <GPRS_ReciveData+0x120>
    a9a0:	8a 30       	cpi	r24, 0x0A	; 10
    a9a2:	d9 f0       	breq	.+54     	; 0xa9da <GPRS_ReciveData+0x102>
    a9a4:	81 31       	cpi	r24, 0x11	; 17
    a9a6:	01 f1       	breq	.+64     	; 0xa9e8 <GPRS_ReciveData+0x110>
    a9a8:	27 c0       	rjmp	.+78     	; 0xa9f8 <GPRS_ReciveData+0x120>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    a9aa:	91 30       	cpi	r25, 0x01	; 1
    a9ac:	29 f5       	brne	.+74     	; 0xa9f8 <GPRS_ReciveData+0x120>
    a9ae:	c9 30       	cpi	r28, 0x09	; 9
    a9b0:	19 f5       	brne	.+70     	; 0xa9f8 <GPRS_ReciveData+0x120>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    a9b2:	80 91 5c 09 	lds	r24, 0x095C
    a9b6:	82 60       	ori	r24, 0x02	; 2
    a9b8:	80 93 5c 09 	sts	0x095C, r24
    a9bc:	1d c0       	rjmp	.+58     	; 0xa9f8 <GPRS_ReciveData+0x120>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    a9be:	93 30       	cpi	r25, 0x03	; 3
    a9c0:	d9 f4       	brne	.+54     	; 0xa9f8 <GPRS_ReciveData+0x120>
    a9c2:	cb 30       	cpi	r28, 0x0B	; 11
    a9c4:	c9 f4       	brne	.+50     	; 0xa9f8 <GPRS_ReciveData+0x120>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    a9c6:	41 ec       	ldi	r20, 0xC1	; 193
    a9c8:	01 c0       	rjmp	.+2      	; 0xa9cc <GPRS_ReciveData+0xf4>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    a9ca:	4c e4       	ldi	r20, 0x4C	; 76
    a9cc:	60 91 47 08 	lds	r22, 0x0847
    a9d0:	80 91 46 08 	lds	r24, 0x0846
    a9d4:	0e 94 89 53 	call	0xa712	; 0xa712 <GPRS_Parameter>
				break;
    a9d8:	0f c0       	rjmp	.+30     	; 0xa9f8 <GPRS_ReciveData+0x120>
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    a9da:	92 30       	cpi	r25, 0x02	; 2
    a9dc:	69 f4       	brne	.+26     	; 0xa9f8 <GPRS_ReciveData+0x120>
    a9de:	ca 30       	cpi	r28, 0x0A	; 10
    a9e0:	59 f4       	brne	.+22     	; 0xa9f8 <GPRS_ReciveData+0x120>
					GPRS_RemoteDisplayControl();
    a9e2:	0e 94 98 50 	call	0xa130	; 0xa130 <GPRS_RemoteDisplayControl>
    a9e6:	08 c0       	rjmp	.+16     	; 0xa9f8 <GPRS_ReciveData+0x120>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    a9e8:	92 30       	cpi	r25, 0x02	; 2
    a9ea:	31 f4       	brne	.+12     	; 0xa9f8 <GPRS_ReciveData+0x120>
    a9ec:	ca 30       	cpi	r28, 0x0A	; 10
    a9ee:	21 f4       	brne	.+8      	; 0xa9f8 <GPRS_ReciveData+0x120>
					ReadParamBlock	(GPRS_Data_In[9]);
    a9f0:	80 91 46 08 	lds	r24, 0x0846
    a9f4:	0e 94 ca 53 	call	0xa794	; 0xa794 <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
    a9f8:	10 92 5e 09 	sts	0x095E, r1
	}//   
	else GPRS_FlgSz_In = 0;
}
    a9fc:	cf 91       	pop	r28
    a9fe:	08 95       	ret

0000aa00 <GPRS_Arbitr>:
// -----                  
void GPRS_Arbitr(void){
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    aa00:	80 91 5c 09 	lds	r24, 0x095C
    aa04:	86 ff       	sbrs	r24, 6
    aa06:	06 c0       	rjmp	.+12     	; 0xaa14 <GPRS_Arbitr+0x14>
		GPRS_SendNewCrash();
    aa08:	0e 94 17 50 	call	0xa02e	; 0xa02e <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    aa0c:	80 91 5c 09 	lds	r24, 0x095C
    aa10:	8f 7b       	andi	r24, 0xBF	; 191
    aa12:	3d c0       	rjmp	.+122    	; 0xaa8e <GPRS_Arbitr+0x8e>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    aa14:	85 ff       	sbrs	r24, 5
    aa16:	0d c0       	rjmp	.+26     	; 0xaa32 <GPRS_Arbitr+0x32>
		GPRS_SendRepCrash();
    aa18:	0e 94 27 50 	call	0xa04e	; 0xa04e <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    aa1c:	80 91 5c 09 	lds	r24, 0x095C
    aa20:	8f 7d       	andi	r24, 0xDF	; 223
    aa22:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aa26:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0b11111110;	//   IP1
    aa2a:	8e ef       	ldi	r24, 0xFE	; 254
    aa2c:	80 93 6f 08 	sts	0x086F, r24
    aa30:	34 c0       	rjmp	.+104    	; 0xaa9a <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    aa32:	84 ff       	sbrs	r24, 4
    aa34:	06 c0       	rjmp	.+12     	; 0xaa42 <GPRS_Arbitr+0x42>
		GPRS_Get_Session_ID();
    aa36:	0e 94 58 50 	call	0xa0b0	; 0xa0b0 <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    aa3a:	80 91 5c 09 	lds	r24, 0x095C
    aa3e:	8f 7e       	andi	r24, 0xEF	; 239
    aa40:	19 c0       	rjmp	.+50     	; 0xaa74 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    aa42:	83 ff       	sbrs	r24, 3
    aa44:	08 c0       	rjmp	.+16     	; 0xaa56 <GPRS_Arbitr+0x56>
		GPRS_SendChange(GPRS_ChangeReplySize);
    aa46:	80 91 11 06 	lds	r24, 0x0611
    aa4a:	0e 94 c3 50 	call	0xa186	; 0xa186 <GPRS_SendChange>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    aa4e:	80 91 5c 09 	lds	r24, 0x095C
    aa52:	87 7f       	andi	r24, 0xF7	; 247
    aa54:	0f c0       	rjmp	.+30     	; 0xaa74 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    aa56:	82 ff       	sbrs	r24, 2
    aa58:	06 c0       	rjmp	.+12     	; 0xaa66 <GPRS_Arbitr+0x66>
		GPRS_SendDisplay();
    aa5a:	0e 94 a2 50 	call	0xa144	; 0xa144 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    aa5e:	80 91 5c 09 	lds	r24, 0x095C
    aa62:	8b 7f       	andi	r24, 0xFB	; 251
    aa64:	07 c0       	rjmp	.+14     	; 0xaa74 <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    aa66:	81 ff       	sbrs	r24, 1
    aa68:	0b c0       	rjmp	.+22     	; 0xaa80 <GPRS_Arbitr+0x80>
		GPRS_CurDataSend();
    aa6a:	0e 94 38 4d 	call	0x9a70	; 0x9a70 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    aa6e:	80 91 5c 09 	lds	r24, 0x095C
    aa72:	8d 7f       	andi	r24, 0xFD	; 253
    aa74:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = TCP;
    aa78:	81 e0       	ldi	r24, 0x01	; 1
    aa7a:	80 93 7c 09 	sts	0x097C, r24
    aa7e:	0d c0       	rjmp	.+26     	; 0xaa9a <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    aa80:	80 ff       	sbrs	r24, 0
    aa82:	0f c0       	rjmp	.+30     	; 0xaaa2 <GPRS_Arbitr+0xa2>
		GPRS_CurDataSend();
    aa84:	0e 94 38 4d 	call	0x9a70	; 0x9a70 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    aa88:	80 91 5c 09 	lds	r24, 0x095C
    aa8c:	8e 7f       	andi	r24, 0xFE	; 254
    aa8e:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aa92:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0;	//   IP
    aa96:	10 92 6f 08 	sts	0x086F, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    aa9a:	80 91 43 09 	lds	r24, 0x0943
    aa9e:	80 93 7b 09 	sts	0x097B, r24
    aaa2:	08 95       	ret

0000aaa4 <GPRS_App>:
		return;
	}
}
// -----   ApplCycle
void GPRS_App(void){
    aaa4:	cf 93       	push	r28
    aaa6:	df 93       	push	r29

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    aaa8:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aaac:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint16_t Time = Timer16[TimerN];
    aab0:	ec 2f       	mov	r30, r28
    aab2:	f0 e0       	ldi	r31, 0x00	; 0
    aab4:	ee 0f       	add	r30, r30
    aab6:	ff 1f       	adc	r31, r31
    aab8:	ea 5d       	subi	r30, 0xDA	; 218
    aaba:	fc 4f       	sbci	r31, 0xFC	; 252
    aabc:	c0 81       	ld	r28, Z
    aabe:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    aac0:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
    aac4:	c8 3c       	cpi	r28, 0xC8	; 200
    aac6:	d1 05       	cpc	r29, r1
    aac8:	30 f4       	brcc	.+12     	; 0xaad6 <GPRS_App+0x32>
    aaca:	6f ef       	ldi	r22, 0xFF	; 255
    aacc:	7f ef       	ldi	r23, 0xFF	; 255
    aace:	80 91 4e 09 	lds	r24, 0x094E
    aad2:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    aad6:	80 91 07 01 	lds	r24, 0x0107
    aada:	8f 3f       	cpi	r24, 0xFF	; 255
    aadc:	31 f4       	brne	.+12     	; 0xaaea <GPRS_App+0x46>
		GPRS_Session_ID = 0;
    aade:	10 92 11 0b 	sts	0x0B11, r1
    aae2:	10 92 10 0b 	sts	0x0B10, r1
		GPRS_LoginLevel = 0;
    aae6:	10 92 d5 08 	sts	0x08D5, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    aaea:	c0 91 0f 06 	lds	r28, 0x060F

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aaee:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint16_t Time = Timer16[TimerN];
    aaf2:	ec 2f       	mov	r30, r28
    aaf4:	f0 e0       	ldi	r31, 0x00	; 0
    aaf6:	ee 0f       	add	r30, r30
    aaf8:	ff 1f       	adc	r31, r31
    aafa:	ea 5d       	subi	r30, 0xDA	; 218
    aafc:	fc 4f       	sbci	r31, 0xFC	; 252
    aafe:	c0 81       	ld	r28, Z
    ab00:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    ab02:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
    ab06:	d0 93 00 06 	sts	0x0600, r29
    ab0a:	c0 93 ff 05 	sts	0x05FF, r28

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    ab0e:	80 91 69 09 	lds	r24, 0x0969
    ab12:	80 fd       	sbrc	r24, 0
    ab14:	1b c0       	rjmp	.+54     	; 0xab4c <GPRS_App+0xa8>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    ab16:	0e 94 6c 54 	call	0xa8d8	; 0xa8d8 <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    ab1a:	80 e0       	ldi	r24, 0x00	; 0
    ab1c:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    ab20:	88 23       	and	r24, r24
    ab22:	61 f0       	breq	.+24     	; 0xab3c <GPRS_App+0x98>
    ab24:	90 91 69 09 	lds	r25, 0x0969
    ab28:	92 ff       	sbrs	r25, 2
    ab2a:	08 c0       	rjmp	.+16     	; 0xab3c <GPRS_App+0x98>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    ab2c:	80 91 5c 09 	lds	r24, 0x095C
    ab30:	84 60       	ori	r24, 0x04	; 4
    ab32:	80 93 5c 09 	sts	0x095C, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    ab36:	9b 7f       	andi	r25, 0xFB	; 251
    ab38:	90 93 69 09 	sts	0x0969, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    ab3c:	0e 94 53 4f 	call	0x9ea6	; 0x9ea6 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    ab40:	80 91 43 09 	lds	r24, 0x0943
    ab44:	81 11       	cpse	r24, r1
    ab46:	02 c0       	rjmp	.+4      	; 0xab4c <GPRS_App+0xa8>
    ab48:	0e 94 00 55 	call	0xaa00	; 0xaa00 <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
}
    ab4c:	df 91       	pop	r29
    ab4e:	cf 91       	pop	r28
		GPRS_SendData();
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
	}

	GPRS_CriticalCMD_Process();
    ab50:	0c 94 75 51 	jmp	0xa2ea	; 0xa2ea <GPRS_CriticalCMD_Process>

0000ab54 <GSMApply>:
}

void 
GSMApply(void){//=====================================================   GSM

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    ab54:	4e e1       	ldi	r20, 0x1E	; 30
    ab56:	50 e0       	ldi	r21, 0x00	; 0
    ab58:	6c e7       	ldi	r22, 0x7C	; 124
    ab5a:	71 e0       	ldi	r23, 0x01	; 1
    ab5c:	8e e7       	ldi	r24, 0x7E	; 126
    ab5e:	98 e0       	ldi	r25, 0x08	; 8
    ab60:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
	wdt_reset();
    ab64:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    ab66:	44 e1       	ldi	r20, 0x14	; 20
    ab68:	50 e0       	ldi	r21, 0x00	; 0
    ab6a:	68 e6       	ldi	r22, 0x68	; 104
    ab6c:	71 e0       	ldi	r23, 0x01	; 1
    ab6e:	8c e9       	ldi	r24, 0x9C	; 156
    ab70:	98 e0       	ldi	r25, 0x08	; 8
    ab72:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
	wdt_reset();
    ab76:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    ab78:	44 e1       	ldi	r20, 0x14	; 20
    ab7a:	50 e0       	ldi	r21, 0x00	; 0
    ab7c:	64 e5       	ldi	r22, 0x54	; 84
    ab7e:	71 e0       	ldi	r23, 0x01	; 1
    ab80:	80 eb       	ldi	r24, 0xB0	; 176
    ab82:	98 e0       	ldi	r25, 0x08	; 8
    ab84:	0e 94 d5 29 	call	0x53aa	; 0x53aa <ewbl>
	wdt_reset();
    ab88:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    ab8a:	60 91 c4 08 	lds	r22, 0x08C4
    ab8e:	70 91 c5 08 	lds	r23, 0x08C5
    ab92:	80 e2       	ldi	r24, 0x20	; 32
    ab94:	91 e0       	ldi	r25, 0x01	; 1
    ab96:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    ab9a:	60 91 c6 08 	lds	r22, 0x08C6
    ab9e:	70 91 c7 08 	lds	r23, 0x08C7
    aba2:	8e e0       	ldi	r24, 0x0E	; 14
    aba4:	91 e0       	ldi	r25, 0x01	; 1
    aba6:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>

	ewb(&TCP_ServerIP->IP1, MBHoldReg1[38]);
    abaa:	60 91 c8 08 	lds	r22, 0x08C8
    abae:	82 e3       	ldi	r24, 0x32	; 50
    abb0:	91 e0       	ldi	r25, 0x01	; 1
    abb2:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
	ewb(&TCP_ServerIP->IP2, MBHoldReg1[39]);
    abb6:	60 91 ca 08 	lds	r22, 0x08CA
    abba:	83 e3       	ldi	r24, 0x33	; 51
    abbc:	91 e0       	ldi	r25, 0x01	; 1
    abbe:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
	ewb(&TCP_ServerIP->IP3, MBHoldReg1[40]);
    abc2:	60 91 cc 08 	lds	r22, 0x08CC
    abc6:	84 e3       	ldi	r24, 0x34	; 52
    abc8:	91 e0       	ldi	r25, 0x01	; 1
    abca:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
	ewb(&TCP_ServerIP->IP4, MBHoldReg1[41]);
    abce:	60 91 ce 08 	lds	r22, 0x08CE
    abd2:	85 e3       	ldi	r24, 0x35	; 53
    abd4:	91 e0       	ldi	r25, 0x01	; 1
    abd6:	0e 94 c2 29 	call	0x5384	; 0x5384 <ewb>
	eww(&TCP_ServerPort[0], MBHoldReg1[42]);
    abda:	60 91 d0 08 	lds	r22, 0x08D0
    abde:	70 91 d1 08 	lds	r23, 0x08D1
    abe2:	82 e2       	ldi	r24, 0x22	; 34
    abe4:	91 e0       	ldi	r25, 0x01	; 1
    abe6:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>
	eww(&SerialNum, MBHoldReg1[43]);
    abea:	60 91 d2 08 	lds	r22, 0x08D2
    abee:	70 91 d3 08 	lds	r23, 0x08D3
    abf2:	82 e5       	ldi	r24, 0x52	; 82
    abf4:	91 e0       	ldi	r25, 0x01	; 1
    abf6:	0c 94 cd 29 	jmp	0x539a	; 0x539a <eww>

0000abfa <Modbus_App>:
	MBHoldReg1[43] = erw(&SerialNum);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    abfa:	cf 93       	push	r28
    abfc:	df 93       	push	r29

	IntOff();
    abfe:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	MBInput1[0] = DigInput.State[0];
    ac02:	80 91 d6 08 	lds	r24, 0x08D6
    ac06:	80 93 f6 03 	sts	0x03F6, r24

	MBInReg1[0]  = (SW_VERSION << 8) + 	SW_SUBVERSION;
    ac0a:	81 e0       	ldi	r24, 0x01	; 1
    ac0c:	94 e0       	ldi	r25, 0x04	; 4
    ac0e:	90 93 79 0a 	sts	0x0A79, r25
    ac12:	80 93 78 0a 	sts	0x0A78, r24
	MBInReg1[1]  = MemFail;
    ac16:	80 91 77 0a 	lds	r24, 0x0A77
    ac1a:	90 e0       	ldi	r25, 0x00	; 0
    ac1c:	90 93 7b 0a 	sts	0x0A7B, r25
    ac20:	80 93 7a 0a 	sts	0x0A7A, r24
	MBInReg1[2]  = (uint16_t)(LiveTime & 0x0000FFFF);
    ac24:	80 91 63 09 	lds	r24, 0x0963
    ac28:	90 91 64 09 	lds	r25, 0x0964
    ac2c:	a0 91 65 09 	lds	r26, 0x0965
    ac30:	b0 91 66 09 	lds	r27, 0x0966
    ac34:	90 93 7d 0a 	sts	0x0A7D, r25
    ac38:	80 93 7c 0a 	sts	0x0A7C, r24
	MBInReg1[3]  = (uint16_t)(LiveTime>>16);
    ac3c:	80 91 63 09 	lds	r24, 0x0963
    ac40:	90 91 64 09 	lds	r25, 0x0964
    ac44:	a0 91 65 09 	lds	r26, 0x0965
    ac48:	b0 91 66 09 	lds	r27, 0x0966
    ac4c:	b0 93 7f 0a 	sts	0x0A7F, r27
    ac50:	a0 93 7e 0a 	sts	0x0A7E, r26
	MBInReg1[4]  = (uint16_t)Temperature[0];	
    ac54:	80 91 f2 05 	lds	r24, 0x05F2
    ac58:	90 91 f3 05 	lds	r25, 0x05F3
    ac5c:	90 93 81 0a 	sts	0x0A81, r25
    ac60:	80 93 80 0a 	sts	0x0A80, r24
	MBInReg1[5]  = (uint16_t)GSM_State;
    ac64:	80 91 27 06 	lds	r24, 0x0627
    ac68:	90 e0       	ldi	r25, 0x00	; 0
    ac6a:	90 93 83 0a 	sts	0x0A83, r25
    ac6e:	80 93 82 0a 	sts	0x0A82, r24
	MBInReg1[6]  = GSM_MyIP.IP1;
    ac72:	80 91 1c 0b 	lds	r24, 0x0B1C
    ac76:	90 e0       	ldi	r25, 0x00	; 0
    ac78:	90 93 85 0a 	sts	0x0A85, r25
    ac7c:	80 93 84 0a 	sts	0x0A84, r24
	MBInReg1[7]  = GSM_MyIP.IP2;
    ac80:	80 91 1d 0b 	lds	r24, 0x0B1D
    ac84:	90 e0       	ldi	r25, 0x00	; 0
    ac86:	90 93 87 0a 	sts	0x0A87, r25
    ac8a:	80 93 86 0a 	sts	0x0A86, r24
	MBInReg1[8]  = GSM_MyIP.IP3;
    ac8e:	80 91 1e 0b 	lds	r24, 0x0B1E
    ac92:	90 e0       	ldi	r25, 0x00	; 0
    ac94:	90 93 89 0a 	sts	0x0A89, r25
    ac98:	80 93 88 0a 	sts	0x0A88, r24
	MBInReg1[9]  = GSM_MyIP.IP4;
    ac9c:	80 91 1f 0b 	lds	r24, 0x0B1F
    aca0:	90 e0       	ldi	r25, 0x00	; 0
    aca2:	90 93 8b 0a 	sts	0x0A8B, r25
    aca6:	80 93 8a 0a 	sts	0x0A8A, r24
	MBInReg1[10] = GSM_ClientIP.IP1;
    acaa:	80 91 3a 0d 	lds	r24, 0x0D3A
    acae:	90 e0       	ldi	r25, 0x00	; 0
    acb0:	90 93 8d 0a 	sts	0x0A8D, r25
    acb4:	80 93 8c 0a 	sts	0x0A8C, r24
	MBInReg1[11] = GSM_ClientIP.IP2;
    acb8:	80 91 3b 0d 	lds	r24, 0x0D3B
    acbc:	90 e0       	ldi	r25, 0x00	; 0
    acbe:	90 93 8f 0a 	sts	0x0A8F, r25
    acc2:	80 93 8e 0a 	sts	0x0A8E, r24
	MBInReg1[12] = GSM_ClientIP.IP3;
    acc6:	80 91 3c 0d 	lds	r24, 0x0D3C
    acca:	90 e0       	ldi	r25, 0x00	; 0
    accc:	90 93 91 0a 	sts	0x0A91, r25
    acd0:	80 93 90 0a 	sts	0x0A90, r24
	MBInReg1[13] = GSM_ClientIP.IP4;
    acd4:	80 91 3d 0d 	lds	r24, 0x0D3D
    acd8:	90 e0       	ldi	r25, 0x00	; 0
    acda:	90 93 93 0a 	sts	0x0A93, r25
    acde:	80 93 92 0a 	sts	0x0A92, r24
	MBInReg1[14] = GSM_RX_FIFOMax;
    ace2:	80 91 0d 0b 	lds	r24, 0x0B0D
    ace6:	90 e0       	ldi	r25, 0x00	; 0
    ace8:	90 93 95 0a 	sts	0x0A95, r25
    acec:	80 93 94 0a 	sts	0x0A94, r24
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    acf0:	80 91 7f 09 	lds	r24, 0x097F
    acf4:	90 e0       	ldi	r25, 0x00	; 0
    acf6:	90 93 97 0a 	sts	0x0A97, r25
    acfa:	80 93 96 0a 	sts	0x0A96, r24
	MBInReg1[16] = EM_RX_FIFOMax;
    acfe:	80 91 6e 0a 	lds	r24, 0x0A6E
    ad02:	90 e0       	ldi	r25, 0x00	; 0
    ad04:	90 93 99 0a 	sts	0x0A99, r25
    ad08:	80 93 98 0a 	sts	0x0A98, r24
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    ad0c:	80 91 73 09 	lds	r24, 0x0973
    ad10:	80 93 9a 0a 	sts	0x0A9A, r24
    ad14:	80 91 74 09 	lds	r24, 0x0974
    ad18:	80 93 9b 0a 	sts	0x0A9B, r24
    ad1c:	80 91 75 09 	lds	r24, 0x0975
    ad20:	80 93 9c 0a 	sts	0x0A9C, r24
    ad24:	80 91 76 09 	lds	r24, 0x0976
    ad28:	80 93 9d 0a 	sts	0x0A9D, r24
    ad2c:	80 91 77 09 	lds	r24, 0x0977
    ad30:	80 93 9e 0a 	sts	0x0A9E, r24
    ad34:	80 91 78 09 	lds	r24, 0x0978
    ad38:	80 93 9f 0a 	sts	0x0A9F, r24
    ad3c:	80 91 79 09 	lds	r24, 0x0979
    ad40:	80 93 a0 0a 	sts	0x0AA0, r24
    ad44:	80 91 7a 09 	lds	r24, 0x097A
    ad48:	80 93 a1 0a 	sts	0x0AA1, r24
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    ad4c:	80 91 5b 09 	lds	r24, 0x095B
    ad50:	90 e0       	ldi	r25, 0x00	; 0
    ad52:	90 93 a3 0a 	sts	0x0AA3, r25
    ad56:	80 93 a2 0a 	sts	0x0AA2, r24
	MBInReg1[22] = (uint16_t)Web_POST;
    ad5a:	80 91 6d 09 	lds	r24, 0x096D
    ad5e:	90 e0       	ldi	r25, 0x00	; 0
    ad60:	90 93 a5 0a 	sts	0x0AA5, r25
    ad64:	80 93 a4 0a 	sts	0x0AA4, r24
	MBInReg1[23] = (uint16_t)AppProtocol;
    ad68:	80 91 f4 09 	lds	r24, 0x09F4
    ad6c:	90 e0       	ldi	r25, 0x00	; 0
    ad6e:	90 93 a7 0a 	sts	0x0AA7, r25
    ad72:	80 93 a6 0a 	sts	0x0AA6, r24
	MBInReg1[24] = (uint16_t)WebSession;
    ad76:	80 91 7e 09 	lds	r24, 0x097E
    ad7a:	90 e0       	ldi	r25, 0x00	; 0
    ad7c:	90 93 a9 0a 	sts	0x0AA9, r25
    ad80:	80 93 a8 0a 	sts	0x0AA8, r24
	MBInReg1[25] = (uint16_t)WebMode;
    ad84:	80 91 06 01 	lds	r24, 0x0106
    ad88:	90 e0       	ldi	r25, 0x00	; 0
    ad8a:	90 93 ab 0a 	sts	0x0AAB, r25
    ad8e:	80 93 aa 0a 	sts	0x0AAA, r24
	MBInReg1[26] = (uint16_t)WebStrLen;
    ad92:	80 91 70 08 	lds	r24, 0x0870
    ad96:	90 e0       	ldi	r25, 0x00	; 0
    ad98:	90 93 ad 0a 	sts	0x0AAD, r25
    ad9c:	80 93 ac 0a 	sts	0x0AAC, r24

	IntOn();
    ada0:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    ada4:	80 91 df 03 	lds	r24, 0x03DF
    ada8:	80 ff       	sbrs	r24, 0
    adaa:	10 c0       	rjmp	.+32     	; 0xadcc <Modbus_App+0x1d2>
		GSMApply();						//  MB RAM  EEPROM
    adac:	0e 94 aa 55 	call	0xab54	; 0xab54 <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    adb0:	0e 94 1d 2a 	call	0x543a	; 0x543a <Modbus_ReadHoldReg>
    adb4:	8a e5       	ldi	r24, 0x5A	; 90
    adb6:	80 93 27 06 	sts	0x0627, r24
		ResetGSMState();				// 
		IntOff();
    adba:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    adbe:	80 91 df 03 	lds	r24, 0x03DF
    adc2:	8e 7f       	andi	r24, 0xFE	; 254
    adc4:	80 93 df 03 	sts	0x03DF, r24
		IntOn();
    adc8:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
	}
	
	IntOff();
    adcc:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    add0:	c0 91 7c 08 	lds	r28, 0x087C
    add4:	d0 91 7d 08 	lds	r29, 0x087D
    add8:	87 e2       	ldi	r24, 0x27	; 39
    adda:	90 e0       	ldi	r25, 0x00	; 0
    addc:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    ade0:	c8 17       	cp	r28, r24
    ade2:	d9 07       	cpc	r29, r25
    ade4:	29 f0       	breq	.+10     	; 0xadf0 <Modbus_App+0x1f6>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    ade6:	be 01       	movw	r22, r28
    ade8:	87 e2       	ldi	r24, 0x27	; 39
    adea:	90 e0       	ldi	r25, 0x00	; 0
    adec:	0e 94 cd 29 	call	0x539a	; 0x539a <eww>
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    adf0:	df 91       	pop	r29
    adf2:	cf 91       	pop	r28
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
		eww(&EM_UART_Param, MBHoldReg1[0]);
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
    adf4:	0c 94 15 2a 	jmp	0x542a	; 0x542a <IntOn>

0000adf8 <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    adf8:	81 e0       	ldi	r24, 0x01	; 1
    adfa:	80 93 f2 09 	sts	0x09F2, r24
	ModbusMode = 0;
    adfe:	10 92 e0 03 	sts	0x03E0, r1
	EM_InitFIFO();
    ae02:	0e 94 e5 4a 	call	0x95ca	; 0x95ca <EM_InitFIFO>
	cli();
    ae06:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    ae08:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    ae0a:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ae0e:	88 e0       	ldi	r24, 0x08	; 8
    ae10:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    ae14:	85 e0       	ldi	r24, 0x05	; 5
    ae16:	99 e1       	ldi	r25, 0x19	; 25
    ae18:	0e 94 f1 4a 	call	0x95e2	; 0x95e2 <EM_SetUARTParam>
	sei();	
    ae1c:	78 94       	sei
    ae1e:	08 95       	ret

0000ae20 <StopDebug>:
}

void StopDebug(void){
	GSM_DebugMode = 0;
    ae20:	10 92 f2 09 	sts	0x09F2, r1
	ModbusMode = 1;
    ae24:	81 e0       	ldi	r24, 0x01	; 1
    ae26:	80 93 e0 03 	sts	0x03E0, r24
	cli();
    ae2a:	f8 94       	cli
	MB_Init();
    ae2c:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <MB_Init>
	sei();
    ae30:	78 94       	sei
    ae32:	08 95       	ret

0000ae34 <SendDebug>:
}

//  ISR
void SendDebug(uint8_t Char){
	//---FIFO
	EM_RX_FIFO_Begin++;
    ae34:	90 91 70 09 	lds	r25, 0x0970
    ae38:	9f 5f       	subi	r25, 0xFF	; 255
    ae3a:	90 93 70 09 	sts	0x0970, r25
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    ae3e:	90 91 70 09 	lds	r25, 0x0970
    ae42:	9f 3f       	cpi	r25, 0xFF	; 255
    ae44:	11 f4       	brne	.+4      	; 0xae4a <SendDebug+0x16>
    ae46:	10 92 70 09 	sts	0x0970, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    ae4a:	e0 91 70 09 	lds	r30, 0x0970
    ae4e:	f0 e0       	ldi	r31, 0x00	; 0
    ae50:	e7 50       	subi	r30, 0x07	; 7
    ae52:	fc 4f       	sbci	r31, 0xFC	; 252
    ae54:	80 83       	st	Z, r24
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    ae56:	90 91 70 09 	lds	r25, 0x0970
    ae5a:	80 91 38 0d 	lds	r24, 0x0D38
    ae5e:	98 13       	cpse	r25, r24
    ae60:	06 c0       	rjmp	.+12     	; 0xae6e <SendDebug+0x3a>
		EM_RX_FIFOOverFlow = 1;
    ae62:	81 e0       	ldi	r24, 0x01	; 1
    ae64:	80 93 24 0b 	sts	0x0B24, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    ae68:	8f ef       	ldi	r24, 0xFF	; 255
    ae6a:	80 93 6e 0a 	sts	0x0A6E, r24
    ae6e:	08 95       	ret

0000ae70 <GSM_RX>:

}
// ~~~~~~~~~
void
GSM_RX(void)
{
    ae70:	cf 93       	push	r28
	char Char = UDR_GSM;
    ae72:	cc b1       	in	r28, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    ae74:	90 91 7b 08 	lds	r25, 0x087B
    ae78:	9f 5f       	subi	r25, 0xFF	; 255
    ae7a:	90 93 7b 08 	sts	0x087B, r25
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    ae7e:	80 91 7b 08 	lds	r24, 0x087B
    ae82:	8a 3f       	cpi	r24, 0xFA	; 250
    ae84:	10 f0       	brcs	.+4      	; 0xae8a <GSM_RX+0x1a>
    ae86:	10 92 7b 08 	sts	0x087B, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    ae8a:	e0 91 7b 08 	lds	r30, 0x087B
    ae8e:	f0 e0       	ldi	r31, 0x00	; 0
    ae90:	e8 50       	subi	r30, 0x08	; 8
    ae92:	fb 4f       	sbci	r31, 0xFB	; 251
    ae94:	c0 83       	st	Z, r28
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    ae96:	90 91 7b 08 	lds	r25, 0x087B
    ae9a:	80 91 05 06 	lds	r24, 0x0605
    ae9e:	98 13       	cpse	r25, r24
    aea0:	06 c0       	rjmp	.+12     	; 0xaeae <GSM_RX+0x3e>
		GSM_RX_FIFOOverFlow = 1;
    aea2:	81 e0       	ldi	r24, 0x01	; 1
    aea4:	80 93 6d 0a 	sts	0x0A6D, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    aea8:	8a ef       	ldi	r24, 0xFA	; 250
    aeaa:	80 93 0d 0b 	sts	0x0B0D, r24
	}

	//---In Transparent Mode
	if(Transparent){
    aeae:	80 91 76 0a 	lds	r24, 0x0A76
    aeb2:	88 23       	and	r24, r24
    aeb4:	e1 f0       	breq	.+56     	; 0xaeee <GSM_RX+0x7e>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    aeb6:	88 eb       	ldi	r24, 0xB8	; 184
    aeb8:	80 93 9a 00 	sts	0x009A, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    aebc:	90 91 9b 00 	lds	r25, 0x009B
    aec0:	90 64       	ori	r25, 0x40	; 64
    aec2:	90 93 9b 00 	sts	0x009B, r25

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    aec6:	90 91 7b 08 	lds	r25, 0x087B
    aeca:	80 91 f8 0a 	lds	r24, 0x0AF8
    aece:	98 13       	cpse	r25, r24
    aed0:	06 c0       	rjmp	.+12     	; 0xaede <GSM_RX+0x6e>
			GSM_RX_FIFOOverFlow_Transp = 1;
    aed2:	81 e0       	ldi	r24, 0x01	; 1
    aed4:	80 93 4a 0e 	sts	0x0E4A, r24
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    aed8:	8a ef       	ldi	r24, 0xFA	; 250
    aeda:	80 93 7f 09 	sts	0x097F, r24
		}
		StartTimer16(TCP_CONNECT_check_timer, Connection_check_period );
    aede:	60 91 0b 01 	lds	r22, 0x010B
    aee2:	70 91 0c 01 	lds	r23, 0x010C
    aee6:	80 91 40 0d 	lds	r24, 0x0D40
    aeea:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    aeee:	80 91 f2 09 	lds	r24, 0x09F2
    aef2:	88 23       	and	r24, r24
    aef4:	31 f0       	breq	.+12     	; 0xaf02 <GSM_RX+0x92>
		SendDebug(Char);
    aef6:	8c 2f       	mov	r24, r28
    aef8:	0e 94 1a 57 	call	0xae34	; 0xae34 <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    aefc:	88 e2       	ldi	r24, 0x28	; 40
    aefe:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
	}

}
    af02:	cf 91       	pop	r28
    af04:	08 95       	ret

0000af06 <__vector_18>:
}
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    af06:	1f 92       	push	r1
    af08:	0f 92       	push	r0
    af0a:	0f b6       	in	r0, 0x3f	; 63
    af0c:	0f 92       	push	r0
    af0e:	11 24       	eor	r1, r1
    af10:	0b b6       	in	r0, 0x3b	; 59
    af12:	0f 92       	push	r0
    af14:	2f 93       	push	r18
    af16:	3f 93       	push	r19
    af18:	4f 93       	push	r20
    af1a:	5f 93       	push	r21
    af1c:	6f 93       	push	r22
    af1e:	7f 93       	push	r23
    af20:	8f 93       	push	r24
    af22:	9f 93       	push	r25
    af24:	af 93       	push	r26
    af26:	bf 93       	push	r27
    af28:	ef 93       	push	r30
    af2a:	ff 93       	push	r31
	GSM_RX();
    af2c:	0e 94 38 57 	call	0xae70	; 0xae70 <GSM_RX>
	GSM_LED = 1;
    af30:	81 e0       	ldi	r24, 0x01	; 1
    af32:	80 93 0a 06 	sts	0x060A, r24
}
    af36:	ff 91       	pop	r31
    af38:	ef 91       	pop	r30
    af3a:	bf 91       	pop	r27
    af3c:	af 91       	pop	r26
    af3e:	9f 91       	pop	r25
    af40:	8f 91       	pop	r24
    af42:	7f 91       	pop	r23
    af44:	6f 91       	pop	r22
    af46:	5f 91       	pop	r21
    af48:	4f 91       	pop	r20
    af4a:	3f 91       	pop	r19
    af4c:	2f 91       	pop	r18
    af4e:	0f 90       	pop	r0
    af50:	0b be       	out	0x3b, r0	; 59
    af52:	0f 90       	pop	r0
    af54:	0f be       	out	0x3f, r0	; 63
    af56:	0f 90       	pop	r0
    af58:	1f 90       	pop	r1
    af5a:	18 95       	reti

0000af5c <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    af5c:	80 91 39 0c 	lds	r24, 0x0C39
    af60:	8c b9       	out	0x0c, r24	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    af62:	80 91 f2 09 	lds	r24, 0x09F2
    af66:	88 23       	and	r24, r24
    af68:	49 f0       	breq	.+18     	; 0xaf7c <GSM_SendFirstChar+0x20>
		SendDebug(GSM_TxStr[0]);
    af6a:	80 91 39 0c 	lds	r24, 0x0C39
    af6e:	0e 94 1a 57 	call	0xae34	; 0xae34 <SendDebug>
		cli();
    af72:	f8 94       	cli
    af74:	88 e2       	ldi	r24, 0x28	; 40
    af76:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    af7a:	78 94       	sei
	}

	GSM_TxCharN = 1;
    af7c:	81 e0       	ldi	r24, 0x01	; 1
    af7e:	80 93 46 0d 	sts	0x0D46, r24
	cli();
    af82:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    af84:	80 91 08 01 	lds	r24, 0x0108
    af88:	8e 7f       	andi	r24, 0xFE	; 254
    af8a:	80 93 08 01 	sts	0x0108, r24
	sei();
    af8e:	78 94       	sei
	cli();
    af90:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    af92:	88 eb       	ldi	r24, 0xB8	; 184
    af94:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    af96:	78 94       	sei
    af98:	08 95       	ret

0000af9a <GSM_SendCR>:
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    af9a:	cf 93       	push	r28
    af9c:	df 93       	push	r29
    af9e:	ec 01       	movw	r28, r24


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    afa0:	0e 94 eb 6b 	call	0xd7d6	; 0xd7d6 <__strlen_P>
	GSMTxSz = strlen_P(Str_P);
    afa4:	80 93 57 09 	sts	0x0957, r24
	sprintf_P(GSM_TxStr, Str_P);
    afa8:	df 93       	push	r29
    afaa:	cf 93       	push	r28
    afac:	89 e3       	ldi	r24, 0x39	; 57
    afae:	9c e0       	ldi	r25, 0x0C	; 12
    afb0:	9f 93       	push	r25
    afb2:	8f 93       	push	r24
    afb4:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    afb8:	80 91 57 09 	lds	r24, 0x0957
    afbc:	90 e0       	ldi	r25, 0x00	; 0
    afbe:	69 ec       	ldi	r22, 0xC9	; 201
    afc0:	71 e0       	ldi	r23, 0x01	; 1
    afc2:	87 5c       	subi	r24, 0xC7	; 199
    afc4:	93 4f       	sbci	r25, 0xF3	; 243
    afc6:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
	GSMTxSz++;
    afca:	80 91 57 09 	lds	r24, 0x0957
    afce:	8f 5f       	subi	r24, 0xFF	; 255
    afd0:	80 93 57 09 	sts	0x0957, r24
	GSM_SendFirstChar();
    afd4:	0f 90       	pop	r0
    afd6:	0f 90       	pop	r0
    afd8:	0f 90       	pop	r0
    afda:	0f 90       	pop	r0
}
    afdc:	df 91       	pop	r29
    afde:	cf 91       	pop	r28
void GSM_SendCR(prog_char *Str_P){
	GSMTxSz = strlen_P(Str_P);
	sprintf_P(GSM_TxStr, Str_P);
	sprintf(GSM_TxStr + GSMTxSz, "\r");
	GSMTxSz++;
	GSM_SendFirstChar();
    afe0:	0c 94 ae 57 	jmp	0xaf5c	; 0xaf5c <GSM_SendFirstChar>

0000afe4 <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    afe4:	cf 93       	push	r28
    afe6:	df 93       	push	r29
    afe8:	00 d0       	rcall	.+0      	; 0xafea <GSM_Execute_Command+0x6>
    afea:	cd b7       	in	r28, 0x3d	; 61
    afec:	de b7       	in	r29, 0x3e	; 62
	if(GSM_Flag & (1<<flg_TxCStr)){
    afee:	20 91 08 01 	lds	r18, 0x0108
    aff2:	20 ff       	sbrs	r18, 0
    aff4:	0e c0       	rjmp	.+28     	; 0xb012 <GSM_Execute_Command+0x2e>
		GSM_SendCR(Str_P);
    aff6:	69 83       	std	Y+1, r22	; 0x01
    aff8:	7a 83       	std	Y+2, r23	; 0x02
    affa:	0e 94 cd 57 	call	0xaf9a	; 0xaf9a <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    affe:	69 81       	ldd	r22, Y+1	; 0x01
    b000:	7a 81       	ldd	r23, Y+2	; 0x02
    b002:	80 91 5a 02 	lds	r24, 0x025A
	}
}
    b006:	0f 90       	pop	r0
    b008:	0f 90       	pop	r0
    b00a:	df 91       	pop	r29
    b00c:	cf 91       	pop	r28
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
	if(GSM_Flag & (1<<flg_TxCStr)){
		GSM_SendCR(Str_P);
		StartTimer16(TD_GSM, Timeout);
    b00e:	0c 94 cc 2a 	jmp	0x5598	; 0x5598 <StartTimer16>
	}
}
    b012:	0f 90       	pop	r0
    b014:	0f 90       	pop	r0
    b016:	df 91       	pop	r29
    b018:	cf 91       	pop	r28
    b01a:	08 95       	ret

0000b01c <GSM_AddHeaderSendData>:
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b01c:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b020:	40 91 57 09 	lds	r20, 0x0957
    b024:	50 e0       	ldi	r21, 0x00	; 0
    b026:	bc 01       	movw	r22, r24
    b028:	89 e3       	ldi	r24, 0x39	; 57
    b02a:	9c e0       	ldi	r25, 0x0C	; 12
    b02c:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
	GSM_SendFirstChar();
    b030:	0c 94 ae 57 	jmp	0xaf5c	; 0xaf5c <GSM_SendFirstChar>

0000b034 <GSM_SendData>:
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b034:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b038:	40 91 57 09 	lds	r20, 0x0957
    b03c:	50 e0       	ldi	r21, 0x00	; 0
    b03e:	bc 01       	movw	r22, r24
    b040:	89 e3       	ldi	r24, 0x39	; 57
    b042:	9c e0       	ldi	r25, 0x0C	; 12
    b044:	0e 94 1c 6c 	call	0xd838	; 0xd838 <memcpy>
	GSM_SendFirstChar();
    b048:	0c 94 ae 57 	jmp	0xaf5c	; 0xaf5c <GSM_SendFirstChar>

0000b04c <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    b04c:	9f 92       	push	r9
    b04e:	af 92       	push	r10
    b050:	bf 92       	push	r11
    b052:	cf 92       	push	r12
    b054:	df 92       	push	r13
    b056:	ef 92       	push	r14
    b058:	ff 92       	push	r15
    b05a:	0f 93       	push	r16
    b05c:	1f 93       	push	r17
    b05e:	cf 93       	push	r28
    b060:	df 93       	push	r29
    b062:	cd b7       	in	r28, 0x3d	; 61
    b064:	de b7       	in	r29, 0x3e	; 62
    b066:	2e 97       	sbiw	r28, 0x0e	; 14
    b068:	0f b6       	in	r0, 0x3f	; 63
    b06a:	f8 94       	cli
    b06c:	de bf       	out	0x3e, r29	; 62
    b06e:	0f be       	out	0x3f, r0	; 63
    b070:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    b072:	80 91 7d 09 	lds	r24, 0x097D
    b076:	88 23       	and	r24, r24
    b078:	31 f0       	breq	.+12     	; 0xb086 <GSM_Cycle+0x3a>
    b07a:	82 30       	cpi	r24, 0x02	; 2
    b07c:	11 f4       	brne	.+4      	; 0xb082 <GSM_Cycle+0x36>
    b07e:	0c 94 db 63 	jmp	0xc7b6	; 0xc7b6 <GSM_Cycle+0x176a>
    b082:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    b086:	80 91 27 06 	lds	r24, 0x0627
    b08a:	90 e0       	ldi	r25, 0x00	; 0
    b08c:	8b 36       	cpi	r24, 0x6B	; 107
    b08e:	91 05       	cpc	r25, r1
    b090:	10 f0       	brcs	.+4      	; 0xb096 <GSM_Cycle+0x4a>
    b092:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b096:	fc 01       	movw	r30, r24
    b098:	e0 53       	subi	r30, 0x30	; 48
    b09a:	ff 4f       	sbci	r31, 0xFF	; 255
    b09c:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>

		case GSM_PowerOn:
		    Transparent_Application_state = INIT;
    b0a0:	10 92 52 09 	sts	0x0952, r1
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    b0a4:	60 ed       	ldi	r22, 0xD0	; 208
    b0a6:	77 e0       	ldi	r23, 0x07	; 7
    b0a8:	80 91 5a 02 	lds	r24, 0x025A
    b0ac:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    b0b0:	40 e0       	ldi	r20, 0x00	; 0
    b0b2:	56 ed       	ldi	r21, 0xD6	; 214
    b0b4:	63 e8       	ldi	r22, 0x83	; 131
    b0b6:	70 e0       	ldi	r23, 0x00	; 0
    b0b8:	80 91 57 02 	lds	r24, 0x0257
    b0bc:	0e 94 0d 2c 	call	0x581a	; 0x581a <StartTimer32>
			//StartTimer32(TD_GSM_Reset, 10UL*6000);	//    24 
			GSM_PWRCNTRL_ON();
    b0c0:	0e 94 d2 2e 	call	0x5da4	; 0x5da4 <GSM_PWRCNTRL_ON>
			InitFIFO();
    b0c4:	0e 94 ff 39 	call	0x73fe	; 0x73fe <InitFIFO>
			EM_InitFIFO();
    b0c8:	0e 94 e5 4a 	call	0x95ca	; 0x95ca <EM_InitFIFO>
			GSM_Modem = NOT_RECOGNIZED;
    b0cc:	10 92 71 08 	sts	0x0871, r1
			GSM_State = GSM_WAIT_RDY;
    b0d0:	81 e0       	ldi	r24, 0x01	; 1
    b0d2:	80 93 27 06 	sts	0x0627, r24
    b0d6:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    b0da:	6a e5       	ldi	r22, 0x5A	; 90
    b0dc:	8a e6       	ldi	r24, 0x6A	; 106
    b0de:	9f e4       	ldi	r25, 0x4F	; 79
    b0e0:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b0e4:	88 23       	and	r24, r24
    b0e6:	11 f4       	brne	.+4      	; 0xb0ec <GSM_Cycle+0xa0>
    b0e8:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b0ec:	80 91 27 06 	lds	r24, 0x0627
    b0f0:	8f 5f       	subi	r24, 0xFF	; 255
    b0f2:	80 93 27 06 	sts	0x0627, r24
    b0f6:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    b0fa:	68 e8       	ldi	r22, 0x88	; 136
    b0fc:	73 e1       	ldi	r23, 0x13	; 19
    b0fe:	83 e7       	ldi	r24, 0x73	; 115
    b100:	9e e4       	ldi	r25, 0x4E	; 78
    b102:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b106:	80 91 27 06 	lds	r24, 0x0627
    b10a:	8f 5f       	subi	r24, 0xFF	; 255
    b10c:	80 93 27 06 	sts	0x0627, r24
    b110:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b114:	80 91 5a 02 	lds	r24, 0x025A
    b118:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    b11c:	88 23       	and	r24, r24
    b11e:	19 f0       	breq	.+6      	; 0xb126 <GSM_Cycle+0xda>
    b120:	8a e5       	ldi	r24, 0x5A	; 90
    b122:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b126:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    b12a:	88 23       	and	r24, r24
    b12c:	e9 f0       	breq	.+58     	; 0xb168 <GSM_Cycle+0x11c>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    b12e:	6c e7       	ldi	r22, 0x7C	; 124
    b130:	7f e4       	ldi	r23, 0x4F	; 79
    b132:	89 e8       	ldi	r24, 0x89	; 137
    b134:	99 e0       	ldi	r25, 0x09	; 9
    b136:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    b13a:	89 2b       	or	r24, r25
    b13c:	19 f4       	brne	.+6      	; 0xb144 <GSM_Cycle+0xf8>
    b13e:	81 e0       	ldi	r24, 0x01	; 1
    b140:	80 93 71 08 	sts	0x0871, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    b144:	6e e6       	ldi	r22, 0x6E	; 110
    b146:	7f e4       	ldi	r23, 0x4F	; 79
    b148:	89 e8       	ldi	r24, 0x89	; 137
    b14a:	99 e0       	ldi	r25, 0x09	; 9
    b14c:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    b150:	89 2b       	or	r24, r25
    b152:	19 f4       	brne	.+6      	; 0xb15a <GSM_Cycle+0x10e>
    b154:	82 e0       	ldi	r24, 0x02	; 2
    b156:	80 93 71 08 	sts	0x0871, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    b15a:	80 91 71 08 	lds	r24, 0x0871
    b15e:	88 23       	and	r24, r24
    b160:	19 f0       	breq	.+6      	; 0xb168 <GSM_Cycle+0x11c>
    b162:	86 e0       	ldi	r24, 0x06	; 6
    b164:	80 93 27 06 	sts	0x0627, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    b168:	6a e5       	ldi	r22, 0x5A	; 90
    b16a:	8f e5       	ldi	r24, 0x5F	; 95
    b16c:	9f e4       	ldi	r25, 0x4F	; 79
    b16e:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b172:	88 23       	and	r24, r24
    b174:	11 f4       	brne	.+4      	; 0xb17a <GSM_Cycle+0x12e>
    b176:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    b17a:	80 91 71 08 	lds	r24, 0x0871
    b17e:	82 30       	cpi	r24, 0x02	; 2
    b180:	29 f4       	brne	.+10     	; 0xb18c <GSM_Cycle+0x140>
    b182:	87 e0       	ldi	r24, 0x07	; 7
    b184:	80 93 27 06 	sts	0x0627, r24
    b188:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				else GSM_State = GSM_SEND_E0;
    b18c:	88 e0       	ldi	r24, 0x08	; 8
    b18e:	80 93 27 06 	sts	0x0627, r24
    b192:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    b196:	6a e5       	ldi	r22, 0x5A	; 90
    b198:	85 e5       	ldi	r24, 0x55	; 85
    b19a:	9f e4       	ldi	r25, 0x4F	; 79
    b19c:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b1a0:	88 23       	and	r24, r24
    b1a2:	11 f4       	brne	.+4      	; 0xb1a8 <GSM_Cycle+0x15c>
    b1a4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b1a8:	80 91 27 06 	lds	r24, 0x0627
    b1ac:	8f 5f       	subi	r24, 0xFF	; 255
    b1ae:	80 93 27 06 	sts	0x0627, r24
    b1b2:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    b1b6:	64 e6       	ldi	r22, 0x64	; 100
    b1b8:	70 e0       	ldi	r23, 0x00	; 0
    b1ba:	8b e7       	ldi	r24, 0x7B	; 123
    b1bc:	9e e4       	ldi	r25, 0x4E	; 78
    b1be:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b1c2:	80 91 27 06 	lds	r24, 0x0627
    b1c6:	8f 5f       	subi	r24, 0xFF	; 255
    b1c8:	80 93 27 06 	sts	0x0627, r24
    b1cc:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b1d0:	6a e5       	ldi	r22, 0x5A	; 90
    b1d2:	82 e1       	ldi	r24, 0x12	; 18
    b1d4:	9f e4       	ldi	r25, 0x4F	; 79
    b1d6:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b1da:	88 23       	and	r24, r24
    b1dc:	11 f4       	brne	.+4      	; 0xb1e2 <GSM_Cycle+0x196>
    b1de:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b1e2:	80 91 27 06 	lds	r24, 0x0627
    b1e6:	8f 5f       	subi	r24, 0xFF	; 255
    b1e8:	80 93 27 06 	sts	0x0627, r24
    b1ec:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    b1f0:	64 e6       	ldi	r22, 0x64	; 100
    b1f2:	70 e0       	ldi	r23, 0x00	; 0
    b1f4:	89 e6       	ldi	r24, 0x69	; 105
    b1f6:	9e e4       	ldi	r25, 0x4E	; 78
    b1f8:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b1fc:	80 91 27 06 	lds	r24, 0x0627
    b200:	8f 5f       	subi	r24, 0xFF	; 255
    b202:	80 93 27 06 	sts	0x0627, r24
    b206:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CMGF;
    b20a:	6a e5       	ldi	r22, 0x5A	; 90
    b20c:	82 e1       	ldi	r24, 0x12	; 18
    b20e:	9f e4       	ldi	r25, 0x4F	; 79
    b210:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b214:	88 23       	and	r24, r24
    b216:	11 f4       	brne	.+4      	; 0xb21c <GSM_Cycle+0x1d0>
    b218:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b21c:	8f e0       	ldi	r24, 0x0F	; 15
    b21e:	80 93 27 06 	sts	0x0627, r24
    b222:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    b226:	64 e6       	ldi	r22, 0x64	; 100
    b228:	70 e0       	ldi	r23, 0x00	; 0
    b22a:	8f e5       	ldi	r24, 0x5F	; 95
    b22c:	9e e4       	ldi	r25, 0x4E	; 78
    b22e:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b232:	80 91 27 06 	lds	r24, 0x0627
    b236:	8f 5f       	subi	r24, 0xFF	; 255
    b238:	80 93 27 06 	sts	0x0627, r24
    b23c:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b240:	6a e5       	ldi	r22, 0x5A	; 90
    b242:	82 e1       	ldi	r24, 0x12	; 18
    b244:	9f e4       	ldi	r25, 0x4F	; 79
    b246:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b24a:	88 23       	and	r24, r24
    b24c:	11 f4       	brne	.+4      	; 0xb252 <GSM_Cycle+0x206>
    b24e:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b252:	80 91 27 06 	lds	r24, 0x0627
    b256:	8f 5f       	subi	r24, 0xFF	; 255
    b258:	80 93 27 06 	sts	0x0627, r24
    b25c:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    b260:	64 e6       	ldi	r22, 0x64	; 100
    b262:	70 e0       	ldi	r23, 0x00	; 0
    b264:	8c e4       	ldi	r24, 0x4C	; 76
    b266:	9e e4       	ldi	r25, 0x4E	; 78
    b268:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b26c:	80 91 27 06 	lds	r24, 0x0627
    b270:	8f 5f       	subi	r24, 0xFF	; 255
    b272:	80 93 27 06 	sts	0x0627, r24
    b276:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b27a:	6a e5       	ldi	r22, 0x5A	; 90
    b27c:	82 e1       	ldi	r24, 0x12	; 18
    b27e:	9f e4       	ldi	r25, 0x4F	; 79
    b280:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b284:	88 23       	and	r24, r24
    b286:	11 f4       	brne	.+4      	; 0xb28c <GSM_Cycle+0x240>
    b288:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b28c:	80 91 27 06 	lds	r24, 0x0627
    b290:	8f 5f       	subi	r24, 0xFF	; 255
    b292:	80 93 27 06 	sts	0x0627, r24
    b296:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    b29a:	64 e6       	ldi	r22, 0x64	; 100
    b29c:	70 e0       	ldi	r23, 0x00	; 0
    b29e:	88 e2       	ldi	r24, 0x28	; 40
    b2a0:	9e e4       	ldi	r25, 0x4E	; 78
    b2a2:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
			GSM_State++; 
    b2a6:	80 91 27 06 	lds	r24, 0x0627
    b2aa:	8f 5f       	subi	r24, 0xFF	; 255
    b2ac:	80 93 27 06 	sts	0x0627, r24
    b2b0:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b2b4:	6a e5       	ldi	r22, 0x5A	; 90
    b2b6:	82 e1       	ldi	r24, 0x12	; 18
    b2b8:	9f e4       	ldi	r25, 0x4F	; 79
    b2ba:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b2be:	88 23       	and	r24, r24
    b2c0:	11 f4       	brne	.+4      	; 0xb2c6 <GSM_Cycle+0x27a>
    b2c2:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;*/
				GSM_State++;
    b2c6:	80 91 27 06 	lds	r24, 0x0627
    b2ca:	8f 5f       	subi	r24, 0xFF	; 255
    b2cc:	80 93 27 06 	sts	0x0627, r24
    b2d0:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SEND_CIPMODE:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    b2d4:	64 e6       	ldi	r22, 0x64	; 100
    b2d6:	70 e0       	ldi	r23, 0x00	; 0
    b2d8:	84 e3       	ldi	r24, 0x34	; 52
    b2da:	9e e4       	ldi	r25, 0x4E	; 78
    b2dc:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
			GSM_State++;
    b2e0:	80 91 27 06 	lds	r24, 0x0627
    b2e4:	8f 5f       	subi	r24, 0xFF	; 255
    b2e6:	80 93 27 06 	sts	0x0627, r24
    b2ea:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b2ee:	6a e5       	ldi	r22, 0x5A	; 90
    b2f0:	82 e1       	ldi	r24, 0x12	; 18
    b2f2:	9f e4       	ldi	r25, 0x4F	; 79
    b2f4:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b2f8:	88 23       	and	r24, r24
    b2fa:	11 f4       	brne	.+4      	; 0xb300 <GSM_Cycle+0x2b4>
    b2fc:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				GSM_State++;
    b300:	80 91 27 06 	lds	r24, 0x0627
    b304:	8f 5f       	subi	r24, 0xFF	; 255
    b306:	80 93 27 06 	sts	0x0627, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    b30a:	68 ee       	ldi	r22, 0xE8	; 232
    b30c:	73 e0       	ldi	r23, 0x03	; 3
    b30e:	80 91 5a 02 	lds	r24, 0x025A
    b312:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    b316:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 100*GSM_DEBUG_DELAY); GSM_State++;
    b31a:	64 e6       	ldi	r22, 0x64	; 100
    b31c:	70 e0       	ldi	r23, 0x00	; 0
    b31e:	84 e1       	ldi	r24, 0x14	; 20
    b320:	9e e4       	ldi	r25, 0x4E	; 78
    b322:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b326:	80 91 27 06 	lds	r24, 0x0627
    b32a:	8f 5f       	subi	r24, 0xFF	; 255
    b32c:	80 93 27 06 	sts	0x0627, r24
    b330:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b334:	6a e5       	ldi	r22, 0x5A	; 90
    b336:	82 e1       	ldi	r24, 0x12	; 18
    b338:	9f e4       	ldi	r25, 0x4F	; 79
    b33a:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b33e:	88 23       	and	r24, r24
    b340:	11 f4       	brne	.+4      	; 0xb346 <GSM_Cycle+0x2fa>
    b342:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b346:	80 91 27 06 	lds	r24, 0x0627
    b34a:	8f 5f       	subi	r24, 0xFF	; 255
    b34c:	80 93 27 06 	sts	0x0627, r24
    b350:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    b354:	10 92 e6 03 	sts	0x03E6, r1
			GSM_State++;
    b358:	80 91 27 06 	lds	r24, 0x0627
    b35c:	8f 5f       	subi	r24, 0xFF	; 255
    b35e:	80 93 27 06 	sts	0x0627, r24
    b362:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    b366:	64 ef       	ldi	r22, 0xF4	; 244
    b368:	71 e0       	ldi	r23, 0x01	; 1
    b36a:	89 e0       	ldi	r24, 0x09	; 9
    b36c:	9e e4       	ldi	r25, 0x4E	; 78
    b36e:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b372:	80 91 e6 03 	lds	r24, 0x03E6
    b376:	8f 5f       	subi	r24, 0xFF	; 255
    b378:	80 93 e6 03 	sts	0x03E6, r24
    b37c:	80 91 27 06 	lds	r24, 0x0627
    b380:	8f 5f       	subi	r24, 0xFF	; 255
    b382:	80 93 27 06 	sts	0x0627, r24
    b386:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    b38a:	80 91 e6 03 	lds	r24, 0x03E6
    b38e:	85 31       	cpi	r24, 0x15	; 21
    b390:	18 f0       	brcs	.+6      	; 0xb398 <GSM_Cycle+0x34c>
    b392:	8a e5       	ldi	r24, 0x5A	; 90
    b394:	80 93 27 06 	sts	0x0627, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    b398:	6a e1       	ldi	r22, 0x1A	; 26
    b39a:	82 e1       	ldi	r24, 0x12	; 18
    b39c:	9f e4       	ldi	r25, 0x4F	; 79
    b39e:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b3a2:	88 23       	and	r24, r24
    b3a4:	11 f4       	brne	.+4      	; 0xb3aa <GSM_Cycle+0x35e>
    b3a6:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b3aa:	80 91 27 06 	lds	r24, 0x0627
    b3ae:	8f 5f       	subi	r24, 0xFF	; 255
    b3b0:	80 93 27 06 	sts	0x0627, r24
    b3b4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    b3b8:	80 91 08 01 	lds	r24, 0x0108
    b3bc:	80 ff       	sbrs	r24, 0
    b3be:	6d c0       	rjmp	.+218    	; 0xb49a <GSM_Cycle+0x44e>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    b3c0:	8a ef       	ldi	r24, 0xFA	; 250
    b3c2:	9d e4       	ldi	r25, 0x4D	; 77
    b3c4:	9f 93       	push	r25
    b3c6:	8f 93       	push	r24
    b3c8:	89 e3       	ldi	r24, 0x39	; 57
    b3ca:	9c e0       	ldi	r25, 0x0C	; 12
    b3cc:	9f 93       	push	r25
    b3ce:	8f 93       	push	r24
    b3d0:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
    b3d4:	8e e0       	ldi	r24, 0x0E	; 14
    b3d6:	80 93 57 09 	sts	0x0957, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    b3da:	10 91 57 09 	lds	r17, 0x0957
    b3de:	80 91 57 09 	lds	r24, 0x0957
    b3e2:	90 e0       	ldi	r25, 0x00	; 0
    b3e4:	6c e7       	ldi	r22, 0x7C	; 124
    b3e6:	71 e0       	ldi	r23, 0x01	; 1
    b3e8:	87 5c       	subi	r24, 0xC7	; 199
    b3ea:	93 4f       	sbci	r25, 0xF3	; 243
    b3ec:	0e 94 c2 3a 	call	0x7584	; 0x7584 <strcpy_EE>
    b3f0:	81 0f       	add	r24, r17
    b3f2:	80 93 57 09 	sts	0x0957, r24
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    b3f6:	80 91 57 09 	lds	r24, 0x0957
    b3fa:	90 e0       	ldi	r25, 0x00	; 0
    b3fc:	63 eb       	ldi	r22, 0xB3	; 179
    b3fe:	71 e0       	ldi	r23, 0x01	; 1
    b400:	87 5c       	subi	r24, 0xC7	; 199
    b402:	93 4f       	sbci	r25, 0xF3	; 243
    b404:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
    b408:	80 91 57 09 	lds	r24, 0x0957
    b40c:	8d 5f       	subi	r24, 0xFD	; 253
    b40e:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    b412:	10 91 57 09 	lds	r17, 0x0957
    b416:	80 91 57 09 	lds	r24, 0x0957
    b41a:	90 e0       	ldi	r25, 0x00	; 0
    b41c:	68 e6       	ldi	r22, 0x68	; 104
    b41e:	71 e0       	ldi	r23, 0x01	; 1
    b420:	87 5c       	subi	r24, 0xC7	; 199
    b422:	93 4f       	sbci	r25, 0xF3	; 243
    b424:	0e 94 c2 3a 	call	0x7584	; 0x7584 <strcpy_EE>
    b428:	81 0f       	add	r24, r17
    b42a:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    b42e:	80 91 57 09 	lds	r24, 0x0957
    b432:	90 e0       	ldi	r25, 0x00	; 0
    b434:	63 eb       	ldi	r22, 0xB3	; 179
    b436:	71 e0       	ldi	r23, 0x01	; 1
    b438:	87 5c       	subi	r24, 0xC7	; 199
    b43a:	93 4f       	sbci	r25, 0xF3	; 243
    b43c:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
    b440:	80 91 57 09 	lds	r24, 0x0957
    b444:	8d 5f       	subi	r24, 0xFD	; 253
    b446:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    b44a:	10 91 57 09 	lds	r17, 0x0957
    b44e:	80 91 57 09 	lds	r24, 0x0957
    b452:	90 e0       	ldi	r25, 0x00	; 0
    b454:	64 e5       	ldi	r22, 0x54	; 84
    b456:	71 e0       	ldi	r23, 0x01	; 1
    b458:	87 5c       	subi	r24, 0xC7	; 199
    b45a:	93 4f       	sbci	r25, 0xF3	; 243
    b45c:	0e 94 c2 3a 	call	0x7584	; 0x7584 <strcpy_EE>
    b460:	81 0f       	add	r24, r17
    b462:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    b466:	80 91 57 09 	lds	r24, 0x0957
    b46a:	90 e0       	ldi	r25, 0x00	; 0
    b46c:	68 ec       	ldi	r22, 0xC8	; 200
    b46e:	71 e0       	ldi	r23, 0x01	; 1
    b470:	87 5c       	subi	r24, 0xC7	; 199
    b472:	93 4f       	sbci	r25, 0xF3	; 243
    b474:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
    b478:	80 91 57 09 	lds	r24, 0x0957
    b47c:	8e 5f       	subi	r24, 0xFE	; 254
    b47e:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b482:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    b486:	6c e2       	ldi	r22, 0x2C	; 44
    b488:	71 e0       	ldi	r23, 0x01	; 1
    b48a:	80 91 5a 02 	lds	r24, 0x025A
    b48e:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    b492:	0f 90       	pop	r0
    b494:	0f 90       	pop	r0
    b496:	0f 90       	pop	r0
    b498:	0f 90       	pop	r0
			}
			GSM_State++;
    b49a:	80 91 27 06 	lds	r24, 0x0627
    b49e:	8f 5f       	subi	r24, 0xFF	; 255
    b4a0:	80 93 27 06 	sts	0x0627, r24
    b4a4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b4a8:	6a e5       	ldi	r22, 0x5A	; 90
    b4aa:	82 e1       	ldi	r24, 0x12	; 18
    b4ac:	9f e4       	ldi	r25, 0x4F	; 79
    b4ae:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b4b2:	88 23       	and	r24, r24
    b4b4:	11 f4       	brne	.+4      	; 0xb4ba <GSM_Cycle+0x46e>
    b4b6:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b4ba:	80 91 27 06 	lds	r24, 0x0627
    b4be:	8f 5f       	subi	r24, 0xFF	; 255
    b4c0:	80 93 27 06 	sts	0x0627, r24
    b4c4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    b4c8:	6c e2       	ldi	r22, 0x2C	; 44
    b4ca:	71 e0       	ldi	r23, 0x01	; 1
    b4cc:	82 ef       	ldi	r24, 0xF2	; 242
    b4ce:	9d e4       	ldi	r25, 0x4D	; 77
    b4d0:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b4d4:	80 91 27 06 	lds	r24, 0x0627
    b4d8:	8f 5f       	subi	r24, 0xFF	; 255
    b4da:	80 93 27 06 	sts	0x0627, r24
    b4de:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b4e2:	6a e5       	ldi	r22, 0x5A	; 90
    b4e4:	82 e1       	ldi	r24, 0x12	; 18
    b4e6:	9f e4       	ldi	r25, 0x4F	; 79
    b4e8:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b4ec:	88 23       	and	r24, r24
    b4ee:	11 f4       	brne	.+4      	; 0xb4f4 <GSM_Cycle+0x4a8>
    b4f0:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b4f4:	80 91 27 06 	lds	r24, 0x0627
    b4f8:	8f 5f       	subi	r24, 0xFF	; 255
    b4fa:	80 93 27 06 	sts	0x0627, r24
    b4fe:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    b502:	60 ee       	ldi	r22, 0xE0	; 224
    b504:	7e e2       	ldi	r23, 0x2E	; 46
    b506:	89 ee       	ldi	r24, 0xE9	; 233
    b508:	9d e4       	ldi	r25, 0x4D	; 77
    b50a:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b50e:	80 91 27 06 	lds	r24, 0x0627
    b512:	8f 5f       	subi	r24, 0xFF	; 255
    b514:	80 93 27 06 	sts	0x0627, r24
    b518:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b51c:	6a e5       	ldi	r22, 0x5A	; 90
    b51e:	82 e1       	ldi	r24, 0x12	; 18
    b520:	9f e4       	ldi	r25, 0x4F	; 79
    b522:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b526:	88 23       	and	r24, r24
    b528:	11 f4       	brne	.+4      	; 0xb52e <GSM_Cycle+0x4e2>
    b52a:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b52e:	80 91 27 06 	lds	r24, 0x0627
    b532:	8f 5f       	subi	r24, 0xFF	; 255
    b534:	80 93 27 06 	sts	0x0627, r24
    b538:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    b53c:	68 ee       	ldi	r22, 0xE8	; 232
    b53e:	73 e0       	ldi	r23, 0x03	; 3
    b540:	80 ee       	ldi	r24, 0xE0	; 224
    b542:	9d e4       	ldi	r25, 0x4D	; 77
    b544:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b548:	80 91 27 06 	lds	r24, 0x0627
    b54c:	8f 5f       	subi	r24, 0xFF	; 255
    b54e:	80 93 27 06 	sts	0x0627, r24
    b552:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b556:	80 91 5a 02 	lds	r24, 0x025A
    b55a:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    b55e:	88 23       	and	r24, r24
    b560:	19 f0       	breq	.+6      	; 0xb568 <GSM_Cycle+0x51c>
    b562:	8a e5       	ldi	r24, 0x5A	; 90
    b564:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b568:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    b56c:	88 23       	and	r24, r24
    b56e:	11 f4       	brne	.+4      	; 0xb574 <GSM_Cycle+0x528>
    b570:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    b574:	10 92 1c 0b 	sts	0x0B1C, r1
	IP->IP2 = IP2;
    b578:	10 92 1d 0b 	sts	0x0B1D, r1
	IP->IP3 = IP3;
    b57c:	10 92 1e 0b 	sts	0x0B1E, r1
	IP->IP4 = IP4;
    b580:	10 92 1f 0b 	sts	0x0B1F, r1
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b584:	40 e0       	ldi	r20, 0x00	; 0
    b586:	a9 e8       	ldi	r26, 0x89	; 137
    b588:	b9 e0       	ldi	r27, 0x09	; 9
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b58a:	50 e2       	ldi	r21, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b58c:	89 e8       	ldi	r24, 0x89	; 137
    b58e:	99 e0       	ldi	r25, 0x09	; 9
    b590:	fd 01       	movw	r30, r26
    b592:	01 90       	ld	r0, Z+
    b594:	00 20       	and	r0, r0
    b596:	e9 f7       	brne	.-6      	; 0xb592 <GSM_Cycle+0x546>
    b598:	31 97       	sbiw	r30, 0x01	; 1
    b59a:	e9 58       	subi	r30, 0x89	; 137
    b59c:	f9 40       	sbci	r31, 0x09	; 9
    b59e:	24 2f       	mov	r18, r20
    b5a0:	30 e0       	ldi	r19, 0x00	; 0
    b5a2:	2e 17       	cp	r18, r30
    b5a4:	3f 07       	cpc	r19, r31
    b5a6:	58 f4       	brcc	.+22     	; 0xb5be <GSM_Cycle+0x572>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b5a8:	f9 01       	movw	r30, r18
    b5aa:	e7 57       	subi	r30, 0x77	; 119
    b5ac:	f6 4f       	sbci	r31, 0xF6	; 246
    b5ae:	80 81       	ld	r24, Z
    b5b0:	90 e0       	ldi	r25, 0x00	; 0
    b5b2:	c0 97       	sbiw	r24, 0x30	; 48
    b5b4:	0a 97       	sbiw	r24, 0x0a	; 10
    b5b6:	08 f0       	brcs	.+2      	; 0xb5ba <GSM_Cycle+0x56e>
    b5b8:	50 83       	st	Z, r21
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b5ba:	4f 5f       	subi	r20, 0xFF	; 255
    b5bc:	e7 cf       	rjmp	.-50     	; 0xb58c <GSM_Cycle+0x540>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    b5be:	2f e1       	ldi	r18, 0x1F	; 31
    b5c0:	3b e0       	ldi	r19, 0x0B	; 11
    b5c2:	3f 93       	push	r19
    b5c4:	2f 93       	push	r18
    b5c6:	2e e1       	ldi	r18, 0x1E	; 30
    b5c8:	3b e0       	ldi	r19, 0x0B	; 11
    b5ca:	3f 93       	push	r19
    b5cc:	2f 93       	push	r18
    b5ce:	2d e1       	ldi	r18, 0x1D	; 29
    b5d0:	3b e0       	ldi	r19, 0x0B	; 11
    b5d2:	3f 93       	push	r19
    b5d4:	2f 93       	push	r18
    b5d6:	2c e1       	ldi	r18, 0x1C	; 28
    b5d8:	3b e0       	ldi	r19, 0x0B	; 11
    b5da:	3f 93       	push	r19
    b5dc:	2f 93       	push	r18
    b5de:	2a e6       	ldi	r18, 0x6A	; 106
    b5e0:	33 e0       	ldi	r19, 0x03	; 3
    b5e2:	3f 93       	push	r19
    b5e4:	2f 93       	push	r18
    b5e6:	9f 93       	push	r25
    b5e8:	8f 93       	push	r24
    b5ea:	0e 94 ce 6c 	call	0xd99c	; 0xd99c <sscanf_P>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
    b5ee:	00 e0       	ldi	r16, 0x00	; 0
    b5f0:	20 e0       	ldi	r18, 0x00	; 0
    b5f2:	40 e0       	ldi	r20, 0x00	; 0
    b5f4:	60 e0       	ldi	r22, 0x00	; 0
    b5f6:	8c e1       	ldi	r24, 0x1C	; 28
    b5f8:	9b e0       	ldi	r25, 0x0B	; 11
    b5fa:	0e 94 be 39 	call	0x737c	; 0x737c <IP_compare_Const>
    b5fe:	0f b6       	in	r0, 0x3f	; 63
    b600:	f8 94       	cli
    b602:	de bf       	out	0x3e, r29	; 62
    b604:	0f be       	out	0x3f, r0	; 63
    b606:	cd bf       	out	0x3d, r28	; 61
    b608:	81 11       	cpse	r24, r1
    b60a:	03 c0       	rjmp	.+6      	; 0xb612 <GSM_Cycle+0x5c6>
				/*	if(GSM_MultiCon) GSM_State++;
					else GSM_State = GSM_SEND_CIPSERVER;*/
					GSM_State=GSM_SEND_CIPSTART_TCP;
    b60c:	84 e2       	ldi	r24, 0x24	; 36
    b60e:	80 93 27 06 	sts	0x0627, r24
				}
				TempNum=0;	//
    b612:	10 92 e7 03 	sts	0x03E7, r1
    b616:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    b61a:	80 91 08 01 	lds	r24, 0x0108
    b61e:	80 fd       	sbrc	r24, 0
    b620:	02 c0       	rjmp	.+4      	; 0xb626 <GSM_Cycle+0x5da>
    b622:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				GSMTxSz = strlen_P(AT_CIPSTART_TCP);
    b626:	82 e1       	ldi	r24, 0x12	; 18
    b628:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSTART_TCP);
    b62c:	88 eb       	ldi	r24, 0xB8	; 184
    b62e:	9d e4       	ldi	r25, 0x4D	; 77
    b630:	9f 93       	push	r25
    b632:	8f 93       	push	r24
    b634:	09 e3       	ldi	r16, 0x39	; 57
    b636:	1c e0       	ldi	r17, 0x0C	; 12
    b638:	1f 93       	push	r17
    b63a:	0f 93       	push	r16
    b63c:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
    b640:	82 e2       	ldi	r24, 0x22	; 34
    b642:	91 e0       	ldi	r25, 0x01	; 1
    b644:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    b648:	c8 2e       	mov	r12, r24
    b64a:	b9 2e       	mov	r11, r25
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b64c:	85 e3       	ldi	r24, 0x35	; 53
    b64e:	91 e0       	ldi	r25, 0x01	; 1
    b650:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b654:	d8 2e       	mov	r13, r24
    b656:	84 e3       	ldi	r24, 0x34	; 52
    b658:	91 e0       	ldi	r25, 0x01	; 1
    b65a:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b65e:	e8 2e       	mov	r14, r24
    b660:	83 e3       	ldi	r24, 0x33	; 51
    b662:	91 e0       	ldi	r25, 0x01	; 1
    b664:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b668:	f8 2e       	mov	r15, r24
    b66a:	82 e3       	ldi	r24, 0x32	; 50
    b66c:	91 e0       	ldi	r25, 0x01	; 1
    b66e:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
				
				sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2),
    b672:	90 91 57 09 	lds	r25, 0x0957
    b676:	bf 92       	push	r11
    b678:	cf 92       	push	r12
    b67a:	1f 92       	push	r1
    b67c:	df 92       	push	r13
    b67e:	1f 92       	push	r1
    b680:	ef 92       	push	r14
    b682:	1f 92       	push	r1
    b684:	ff 92       	push	r15
    b686:	1f 92       	push	r1
    b688:	8f 93       	push	r24
    b68a:	27 eb       	ldi	r18, 0xB7	; 183
    b68c:	31 e0       	ldi	r19, 0x01	; 1
    b68e:	3f 93       	push	r19
    b690:	2f 93       	push	r18
    b692:	89 2f       	mov	r24, r25
    b694:	90 e0       	ldi	r25, 0x00	; 0
    b696:	87 5c       	subi	r24, 0xC7	; 199
    b698:	93 4f       	sbci	r25, 0xF3	; 243
    b69a:	9f 93       	push	r25
    b69c:	8f 93       	push	r24
    b69e:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
				(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
				GSMTxSz = strlen(GSM_TxStr);
    b6a2:	f8 01       	movw	r30, r16
    b6a4:	01 90       	ld	r0, Z+
    b6a6:	00 20       	and	r0, r0
    b6a8:	e9 f7       	brne	.-6      	; 0xb6a4 <GSM_Cycle+0x658>
    b6aa:	31 97       	sbiw	r30, 0x01	; 1
    b6ac:	e9 53       	subi	r30, 0x39	; 57
    b6ae:	fc 40       	sbci	r31, 0x0C	; 12
    b6b0:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    b6b4:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    b6b8:	68 ee       	ldi	r22, 0xE8	; 232
    b6ba:	73 e0       	ldi	r23, 0x03	; 3
    b6bc:	80 91 5a 02 	lds	r24, 0x025A
    b6c0:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State=GSM_WAIT_CIPSTART_TCP_OK;
    b6c4:	85 e2       	ldi	r24, 0x25	; 37
    b6c6:	80 93 27 06 	sts	0x0627, r24
    b6ca:	0f b6       	in	r0, 0x3f	; 63
    b6cc:	f8 94       	cli
    b6ce:	de bf       	out	0x3e, r29	; 62
    b6d0:	0f be       	out	0x3f, r0	; 63
    b6d2:	cd bf       	out	0x3d, r28	; 61
    b6d4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}		
			break;
		case GSM_WAIT_CIPSTART_TCP_OK:
	
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_WAIT_CIPSTART_TCP_CONNECT;
    b6d8:	6a e5       	ldi	r22, 0x5A	; 90
    b6da:	82 e1       	ldi	r24, 0x12	; 18
    b6dc:	9f e4       	ldi	r25, 0x4F	; 79
    b6de:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b6e2:	88 23       	and	r24, r24
    b6e4:	11 f4       	brne	.+4      	; 0xb6ea <GSM_Cycle+0x69e>
    b6e6:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b6ea:	86 e2       	ldi	r24, 0x26	; 38
    b6ec:	80 93 27 06 	sts	0x0627, r24
    b6f0:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			if(GetStringFromFIFO()){
			SetDigOut(2);*/
			/*	char RightAnswer[sizeof(RESP_CONNECT)];
				strcpy_P(RightAnswer, RESP_CONNECT);*/
				//RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b6f4:	6a e5       	ldi	r22, 0x5A	; 90
    b6f6:	8a e0       	ldi	r24, 0x0A	; 10
    b6f8:	9f e4       	ldi	r25, 0x4F	; 79
    b6fa:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b6fe:	88 23       	and	r24, r24
    b700:	11 f4       	brne	.+4      	; 0xb706 <GSM_Cycle+0x6ba>
    b702:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				/*	if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
					else GSM_State = GSM_SEND_CIPSTART;*/
					GSM_State = GSM_SEND_IDENTIFICATION;
    b706:	87 e2       	ldi	r24, 0x27	; 39
    b708:	80 93 27 06 	sts	0x0627, r24
    b70c:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				}
		//	}
			break;
		case GSM_SEND_IDENTIFICATION:
			if(GSM_Flag & (1<<flg_TxCStr)){
    b710:	80 91 08 01 	lds	r24, 0x0108
    b714:	80 fd       	sbrc	r24, 0
    b716:	02 c0       	rjmp	.+4      	; 0xb71c <GSM_Cycle+0x6d0>
    b718:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b71c:	82 e5       	ldi	r24, 0x52	; 82
    b71e:	91 e0       	ldi	r25, 0x01	; 1
    b720:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
				GSMTxSz = sprintf(GSM_TxStr, "Modem=%u",(unsigned int)erw(&SerialNum));
    b724:	9f 93       	push	r25
    b726:	8f 93       	push	r24
    b728:	8b ec       	ldi	r24, 0xCB	; 203
    b72a:	91 e0       	ldi	r25, 0x01	; 1
    b72c:	9f 93       	push	r25
    b72e:	8f 93       	push	r24
    b730:	89 e3       	ldi	r24, 0x39	; 57
    b732:	9c e0       	ldi	r25, 0x0C	; 12
    b734:	9f 93       	push	r25
    b736:	8f 93       	push	r24
    b738:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    b73c:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b740:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b744:	64 ef       	ldi	r22, 0xF4	; 244
    b746:	71 e0       	ldi	r23, 0x01	; 1
    b748:	80 91 5a 02 	lds	r24, 0x025A
    b74c:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State++;
    b750:	80 91 27 06 	lds	r24, 0x0627
    b754:	8f 5f       	subi	r24, 0xFF	; 255
    b756:	80 93 27 06 	sts	0x0627, r24
    b75a:	0f 90       	pop	r0
    b75c:	0f 90       	pop	r0
    b75e:	0f 90       	pop	r0
    b760:	0f 90       	pop	r0
    b762:	0f 90       	pop	r0
    b764:	0f 90       	pop	r0
    b766:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_WAIT_IDENTIFICATION_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1))
    b76a:	6a e5       	ldi	r22, 0x5A	; 90
    b76c:	82 e1       	ldi	r24, 0x12	; 18
    b76e:	9f e4       	ldi	r25, 0x4F	; 79
    b770:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b774:	88 23       	and	r24, r24
    b776:	11 f4       	brne	.+4      	; 0xb77c <GSM_Cycle+0x730>
    b778:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			{
				EM_InitFIFO(); 
    b77c:	0e 94 e5 4a 	call	0x95ca	; 0x95ca <EM_InitFIFO>
				InitFIFO();
    b780:	0e 94 ff 39 	call	0x73fe	; 0x73fe <InitFIFO>
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b784:	80 91 05 06 	lds	r24, 0x0605
    b788:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State=GSM_ProtocolMode;
    b78c:	81 e6       	ldi	r24, 0x61	; 97
    b78e:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b792:	60 91 0b 01 	lds	r22, 0x010B
    b796:	70 91 0c 01 	lds	r23, 0x010C
    b79a:	80 91 40 0d 	lds	r24, 0x0D40
    b79e:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b7a2:	60 91 09 01 	lds	r22, 0x0109
    b7a6:	70 91 0a 01 	lds	r23, 0x010A
    b7aa:	80 91 0b 06 	lds	r24, 0x060B
    b7ae:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    b7b2:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SEND_CIPSTATUS:
			GSM_Execute_Command(AT_CIPSTATUS, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_STATE_CONNECT_OK;			
    b7b6:	64 ef       	ldi	r22, 0xF4	; 244
    b7b8:	71 e0       	ldi	r23, 0x01	; 1
    b7ba:	8c e8       	ldi	r24, 0x8C	; 140
    b7bc:	9d e4       	ldi	r25, 0x4D	; 77
    b7be:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b7c2:	8a e2       	ldi	r24, 0x2A	; 42
    b7c4:	80 93 27 06 	sts	0x0627, r24
    b7c8:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_STATE_CONNECT_OK:
			if(GSM_Wait_Response_P(RESP_STATE_CONNECT_OK, GSM_ReStart1)){
    b7cc:	6a e5       	ldi	r22, 0x5A	; 90
    b7ce:	88 e9       	ldi	r24, 0x98	; 152
    b7d0:	9e e4       	ldi	r25, 0x4E	; 78
    b7d2:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b7d6:	88 23       	and	r24, r24
    b7d8:	11 f4       	brne	.+4      	; 0xb7de <GSM_Cycle+0x792>
    b7da:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				GSM_State = GSM_SEND_ATO;
    b7de:	8b e2       	ldi	r24, 0x2B	; 43
    b7e0:	80 93 27 06 	sts	0x0627, r24
    b7e4:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SEND_ATO:
			GSM_Execute_Command(AT_ATO, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_ATO_CONNECT;
    b7e8:	64 ef       	ldi	r22, 0xF4	; 244
    b7ea:	71 e0       	ldi	r23, 0x01	; 1
    b7ec:	88 e8       	ldi	r24, 0x88	; 136
    b7ee:	9d e4       	ldi	r25, 0x4D	; 77
    b7f0:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    b7f4:	8c e2       	ldi	r24, 0x2C	; 44
    b7f6:	80 93 27 06 	sts	0x0627, r24
    b7fa:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_ATO_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b7fe:	6a e5       	ldi	r22, 0x5A	; 90
    b800:	8a e0       	ldi	r24, 0x0A	; 10
    b802:	9f e4       	ldi	r25, 0x4F	; 79
    b804:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b808:	88 23       	and	r24, r24
    b80a:	11 f4       	brne	.+4      	; 0xb810 <GSM_Cycle+0x7c4>
    b80c:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
				switch(Transparent_Application_state){
    b810:	80 91 52 09 	lds	r24, 0x0952
    b814:	82 30       	cpi	r24, 0x02	; 2
    b816:	49 f0       	breq	.+18     	; 0xb82a <GSM_Cycle+0x7de>
    b818:	83 30       	cpi	r24, 0x03	; 3
    b81a:	b9 f4       	brne	.+46     	; 0xb84a <GSM_Cycle+0x7fe>
					case CHECK_CONNECTION_STATE:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b81c:	60 91 0b 01 	lds	r22, 0x010B
    b820:	70 91 0c 01 	lds	r23, 0x010C
    b824:	80 91 40 0d 	lds	r24, 0x0D40
    b828:	0e c0       	rjmp	.+28     	; 0xb846 <GSM_Cycle+0x7fa>
						break;
					case RECONNECT:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b82a:	60 91 0b 01 	lds	r22, 0x010B
    b82e:	70 91 0c 01 	lds	r23, 0x010C
    b832:	80 91 40 0d 	lds	r24, 0x0D40
    b836:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
						StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b83a:	60 91 09 01 	lds	r22, 0x0109
    b83e:	70 91 0a 01 	lds	r23, 0x010A
    b842:	80 91 0b 06 	lds	r24, 0x060B
    b846:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
						break;
					default:break;
				}
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b84a:	80 91 05 06 	lds	r24, 0x0605
    b84e:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State = GSM_ProtocolMode;
    b852:	81 e6       	ldi	r24, 0x61	; 97
    b854:	80 93 27 06 	sts	0x0627, r24
    b858:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    b85c:	10 91 e7 03 	lds	r17, 0x03E7
    b860:	e4 e0       	ldi	r30, 0x04	; 4
    b862:	1e 9f       	mul	r17, r30
    b864:	c0 01       	movw	r24, r0
    b866:	11 24       	eor	r1, r1
    b868:	00 e0       	ldi	r16, 0x00	; 0
    b86a:	20 e0       	ldi	r18, 0x00	; 0
    b86c:	40 e0       	ldi	r20, 0x00	; 0
    b86e:	60 e0       	ldi	r22, 0x00	; 0
    b870:	8e 5b       	subi	r24, 0xBE	; 190
    b872:	9e 4f       	sbci	r25, 0xFE	; 254
    b874:	0e 94 cf 39 	call	0x739e	; 0x739e <IP_E_compare_Const>
    b878:	88 23       	and	r24, r24
    b87a:	61 f0       	breq	.+24     	; 0xb894 <GSM_Cycle+0x848>
				TempNum++;
    b87c:	1f 5f       	subi	r17, 0xFF	; 255
    b87e:	10 93 e7 03 	sts	0x03E7, r17
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    b882:	14 30       	cpi	r17, 0x04	; 4
    b884:	10 f4       	brcc	.+4      	; 0xb88a <GSM_Cycle+0x83e>
    b886:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
    b88a:	83 e3       	ldi	r24, 0x33	; 51
    b88c:	80 93 27 06 	sts	0x0627, r24
    b890:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    b894:	80 91 08 01 	lds	r24, 0x0108
    b898:	80 fd       	sbrc	r24, 0
    b89a:	02 c0       	rjmp	.+4      	; 0xb8a0 <GSM_Cycle+0x854>
    b89c:	0c 94 61 64 	jmp	0xc8c2	; 0xc8c2 <GSM_Cycle+0x1876>
					GSMTxSz = strlen_P(AT_CIPSTART);
    b8a0:	84 e1       	ldi	r24, 0x14	; 20
    b8a2:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    b8a6:	8b ec       	ldi	r24, 0xCB	; 203
    b8a8:	9d e4       	ldi	r25, 0x4D	; 77
    b8aa:	9f 93       	push	r25
    b8ac:	8f 93       	push	r24
    b8ae:	89 e3       	ldi	r24, 0x39	; 57
    b8b0:	e8 2e       	mov	r14, r24
    b8b2:	8c e0       	ldi	r24, 0x0C	; 12
    b8b4:	f8 2e       	mov	r15, r24
    b8b6:	ff 92       	push	r15
    b8b8:	ef 92       	push	r14
    b8ba:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    b8be:	00 91 e7 03 	lds	r16, 0x03E7
    b8c2:	80 e3       	ldi	r24, 0x30	; 48
    b8c4:	80 0f       	add	r24, r16
    b8c6:	80 93 45 0c 	sts	0x0C45, r24
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
    b8ca:	10 e0       	ldi	r17, 0x00	; 0
    b8cc:	c8 01       	movw	r24, r16
    b8ce:	88 0f       	add	r24, r24
    b8d0:	99 1f       	adc	r25, r25
    b8d2:	86 5d       	subi	r24, 0xD6	; 214
    b8d4:	9e 4f       	sbci	r25, 0xFE	; 254
    b8d6:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
    b8da:	a8 2e       	mov	r10, r24
    b8dc:	99 2e       	mov	r9, r25
    b8de:	00 0f       	add	r16, r16
    b8e0:	11 1f       	adc	r17, r17
    b8e2:	00 0f       	add	r16, r16
    b8e4:	11 1f       	adc	r17, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b8e6:	c8 01       	movw	r24, r16
    b8e8:	8b 5b       	subi	r24, 0xBB	; 187
    b8ea:	9e 4f       	sbci	r25, 0xFE	; 254
    b8ec:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b8f0:	b8 2e       	mov	r11, r24
    b8f2:	c8 01       	movw	r24, r16
    b8f4:	8c 5b       	subi	r24, 0xBC	; 188
    b8f6:	9e 4f       	sbci	r25, 0xFE	; 254
    b8f8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b8fc:	c8 2e       	mov	r12, r24
    b8fe:	c8 01       	movw	r24, r16
    b900:	8d 5b       	subi	r24, 0xBD	; 189
    b902:	9e 4f       	sbci	r25, 0xFE	; 254
    b904:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    b908:	d8 2e       	mov	r13, r24
    b90a:	c8 01       	movw	r24, r16
    b90c:	8e 5b       	subi	r24, 0xBE	; 190
    b90e:	9e 4f       	sbci	r25, 0xFE	; 254
    b910:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
					GSMTxSz = strlen_P(AT_CIPSTART);
					sprintf_P(GSM_TxStr, AT_CIPSTART);
					GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    b914:	90 91 57 09 	lds	r25, 0x0957
    b918:	9f 92       	push	r9
    b91a:	af 92       	push	r10
    b91c:	1f 92       	push	r1
    b91e:	bf 92       	push	r11
    b920:	1f 92       	push	r1
    b922:	cf 92       	push	r12
    b924:	1f 92       	push	r1
    b926:	df 92       	push	r13
    b928:	1f 92       	push	r1
    b92a:	8f 93       	push	r24
    b92c:	27 eb       	ldi	r18, 0xB7	; 183
    b92e:	31 e0       	ldi	r19, 0x01	; 1
    b930:	3f 93       	push	r19
    b932:	2f 93       	push	r18
    b934:	89 2f       	mov	r24, r25
    b936:	90 e0       	ldi	r25, 0x00	; 0
    b938:	87 5c       	subi	r24, 0xC7	; 199
    b93a:	93 4f       	sbci	r25, 0xF3	; 243
    b93c:	9f 93       	push	r25
    b93e:	8f 93       	push	r24
    b940:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    b944:	f7 01       	movw	r30, r14
    b946:	01 90       	ld	r0, Z+
    b948:	00 20       	and	r0, r0
    b94a:	e9 f7       	brne	.-6      	; 0xb946 <GSM_Cycle+0x8fa>
    b94c:	31 97       	sbiw	r30, 0x01	; 1
    b94e:	e9 53       	subi	r30, 0x39	; 57
    b950:	fc 40       	sbci	r31, 0x0C	; 12
    b952:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    b956:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b95a:	64 ef       	ldi	r22, 0xF4	; 244
    b95c:	71 e0       	ldi	r23, 0x01	; 1
    b95e:	80 91 5a 02 	lds	r24, 0x025A
    b962:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					GSM_State++;
    b966:	80 91 27 06 	lds	r24, 0x0627
    b96a:	8f 5f       	subi	r24, 0xFF	; 255
    b96c:	80 93 27 06 	sts	0x0627, r24
    b970:	0f b6       	in	r0, 0x3f	; 63
    b972:	f8 94       	cli
    b974:	de bf       	out	0x3e, r29	; 62
    b976:	0f be       	out	0x3f, r0	; 63
    b978:	cd bf       	out	0x3d, r28	; 61
    b97a:	a3 c7       	rjmp	.+3910   	; 0xc8c2 <GSM_Cycle+0x1876>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b97c:	6a e5       	ldi	r22, 0x5A	; 90
    b97e:	82 e1       	ldi	r24, 0x12	; 18
    b980:	9f e4       	ldi	r25, 0x4F	; 79
    b982:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    b986:	88 23       	and	r24, r24
    b988:	09 f4       	brne	.+2      	; 0xb98c <GSM_Cycle+0x940>
    b98a:	9b c7       	rjmp	.+3894   	; 0xc8c2 <GSM_Cycle+0x1876>
    b98c:	80 91 27 06 	lds	r24, 0x0627
    b990:	8f 5f       	subi	r24, 0xFF	; 255
    b992:	80 93 27 06 	sts	0x0627, r24
    b996:	95 c7       	rjmp	.+3882   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b998:	80 91 5a 02 	lds	r24, 0x025A
    b99c:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    b9a0:	88 23       	and	r24, r24
    b9a2:	19 f0       	breq	.+6      	; 0xb9aa <GSM_Cycle+0x95e>
    b9a4:	8a e5       	ldi	r24, 0x5A	; 90
    b9a6:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b9aa:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    b9ae:	88 23       	and	r24, r24
    b9b0:	09 f4       	brne	.+2      	; 0xb9b4 <GSM_Cycle+0x968>
    b9b2:	87 c7       	rjmp	.+3854   	; 0xc8c2 <GSM_Cycle+0x1876>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    b9b4:	6c ef       	ldi	r22, 0xFC	; 252
    b9b6:	7e e4       	ldi	r23, 0x4E	; 78
    b9b8:	ce 01       	movw	r24, r28
    b9ba:	01 96       	adiw	r24, 0x01	; 1
    b9bc:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    b9c0:	10 91 e7 03 	lds	r17, 0x03E7
    b9c4:	80 e3       	ldi	r24, 0x30	; 48
    b9c6:	81 0f       	add	r24, r17
    b9c8:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    b9ca:	6a e5       	ldi	r22, 0x5A	; 90
    b9cc:	ce 01       	movw	r24, r28
    b9ce:	01 96       	adiw	r24, 0x01	; 1
    b9d0:	0e 94 19 3b 	call	0x7632	; 0x7632 <GSM_Wait_Response>
    b9d4:	88 23       	and	r24, r24
    b9d6:	09 f4       	brne	.+2      	; 0xb9da <GSM_Cycle+0x98e>
    b9d8:	74 c7       	rjmp	.+3816   	; 0xc8c2 <GSM_Cycle+0x1876>
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    b9da:	1f 5f       	subi	r17, 0xFF	; 255
    b9dc:	10 93 e7 03 	sts	0x03E7, r17
    b9e0:	14 30       	cpi	r17, 0x04	; 4
    b9e2:	20 f0       	brcs	.+8      	; 0xb9ec <GSM_Cycle+0x9a0>
    b9e4:	83 e3       	ldi	r24, 0x33	; 51
    b9e6:	80 93 27 06 	sts	0x0627, r24
    b9ea:	6b c7       	rjmp	.+3798   	; 0xc8c2 <GSM_Cycle+0x1876>
					else GSM_State = GSM_SEND_CIPSTART;
    b9ec:	8d e2       	ldi	r24, 0x2D	; 45
    b9ee:	80 93 27 06 	sts	0x0627, r24
    b9f2:	67 c7       	rjmp	.+3790   	; 0xc8c2 <GSM_Cycle+0x1876>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    b9f4:	80 91 08 01 	lds	r24, 0x0108
    b9f8:	80 ff       	sbrs	r24, 0
    b9fa:	63 c7       	rjmp	.+3782   	; 0xc8c2 <GSM_Cycle+0x1876>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    b9fc:	8f e0       	ldi	r24, 0x0F	; 15
    b9fe:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    ba02:	88 ea       	ldi	r24, 0xA8	; 168
    ba04:	9d e4       	ldi	r25, 0x4D	; 77
    ba06:	9f 93       	push	r25
    ba08:	8f 93       	push	r24
    ba0a:	09 e3       	ldi	r16, 0x39	; 57
    ba0c:	1c e0       	ldi	r17, 0x0C	; 12
    ba0e:	1f 93       	push	r17
    ba10:	0f 93       	push	r16
    ba12:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    ba16:	80 e2       	ldi	r24, 0x20	; 32
    ba18:	91 e0       	ldi	r25, 0x01	; 1
    ba1a:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    ba1e:	40 91 57 09 	lds	r20, 0x0957
    ba22:	9f 93       	push	r25
    ba24:	8f 93       	push	r24
    ba26:	27 ed       	ldi	r18, 0xD7	; 215
    ba28:	31 e0       	ldi	r19, 0x01	; 1
    ba2a:	3f 93       	push	r19
    ba2c:	2f 93       	push	r18
    ba2e:	84 2f       	mov	r24, r20
    ba30:	90 e0       	ldi	r25, 0x00	; 0
    ba32:	87 5c       	subi	r24, 0xC7	; 199
    ba34:	93 4f       	sbci	r25, 0xF3	; 243
    ba36:	9f 93       	push	r25
    ba38:	8f 93       	push	r24
    ba3a:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    ba3e:	f8 01       	movw	r30, r16
    ba40:	01 90       	ld	r0, Z+
    ba42:	00 20       	and	r0, r0
    ba44:	e9 f7       	brne	.-6      	; 0xba40 <GSM_Cycle+0x9f4>
    ba46:	31 97       	sbiw	r30, 0x01	; 1
    ba48:	e9 53       	subi	r30, 0x39	; 57
    ba4a:	fc 40       	sbci	r31, 0x0C	; 12
    ba4c:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    ba50:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    ba54:	64 ef       	ldi	r22, 0xF4	; 244
    ba56:	71 e0       	ldi	r23, 0x01	; 1
    ba58:	80 91 5a 02 	lds	r24, 0x025A
    ba5c:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State++;
    ba60:	80 91 27 06 	lds	r24, 0x0627
    ba64:	8f 5f       	subi	r24, 0xFF	; 255
    ba66:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    ba6a:	6f ef       	ldi	r22, 0xFF	; 255
    ba6c:	7f ef       	ldi	r23, 0xFF	; 255
    ba6e:	80 91 59 02 	lds	r24, 0x0259
    ba72:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    ba76:	0f b6       	in	r0, 0x3f	; 63
    ba78:	f8 94       	cli
    ba7a:	de bf       	out	0x3e, r29	; 62
    ba7c:	0f be       	out	0x3f, r0	; 63
    ba7e:	cd bf       	out	0x3d, r28	; 61
    ba80:	20 c7       	rjmp	.+3648   	; 0xc8c2 <GSM_Cycle+0x1876>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    ba82:	6a e5       	ldi	r22, 0x5A	; 90
    ba84:	82 e1       	ldi	r24, 0x12	; 18
    ba86:	9f e4       	ldi	r25, 0x4F	; 79
    ba88:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    ba8c:	88 23       	and	r24, r24
    ba8e:	09 f4       	brne	.+2      	; 0xba92 <GSM_Cycle+0xa46>
    ba90:	18 c7       	rjmp	.+3632   	; 0xc8c2 <GSM_Cycle+0x1876>
    ba92:	80 91 27 06 	lds	r24, 0x0627
    ba96:	8f 5f       	subi	r24, 0xFF	; 255
    ba98:	80 93 27 06 	sts	0x0627, r24
    ba9c:	12 c7       	rjmp	.+3620   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    ba9e:	6a e5       	ldi	r22, 0x5A	; 90
    baa0:	82 ef       	ldi	r24, 0xF2	; 242
    baa2:	9e e4       	ldi	r25, 0x4E	; 78
    baa4:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    baa8:	88 23       	and	r24, r24
    baaa:	09 f4       	brne	.+2      	; 0xbaae <GSM_Cycle+0xa62>
    baac:	0a c7       	rjmp	.+3604   	; 0xc8c2 <GSM_Cycle+0x1876>
    baae:	83 e3       	ldi	r24, 0x33	; 51
    bab0:	80 93 27 06 	sts	0x0627, r24
    bab4:	06 c7       	rjmp	.+3596   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    bab6:	80 91 7e 09 	lds	r24, 0x097E
    baba:	81 11       	cpse	r24, r1
    babc:	3c c0       	rjmp	.+120    	; 0xbb36 <GSM_Cycle+0xaea>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    babe:	80 91 43 09 	lds	r24, 0x0943
    bac2:	88 23       	and	r24, r24
    bac4:	41 f1       	breq	.+80     	; 0xbb16 <GSM_Cycle+0xaca>
					if(GSM_MultiCon == 1){
    bac6:	80 91 4b 0e 	lds	r24, 0x0E4B
    baca:	81 30       	cpi	r24, 0x01	; 1
    bacc:	e9 f4       	brne	.+58     	; 0xbb08 <GSM_Cycle+0xabc>
						if(GPRS_Protocol_Out == UDP){
    bace:	80 91 7c 09 	lds	r24, 0x097C
    bad2:	81 11       	cpse	r24, r1
    bad4:	09 c0       	rjmp	.+18     	; 0xbae8 <GSM_Cycle+0xa9c>
							TempNum = 0;
    bad6:	10 92 e7 03 	sts	0x03E7, r1
							GSM_State = GSM_SEND_CIPSEND;
    bada:	85 e3       	ldi	r24, 0x35	; 53
    badc:	80 93 27 06 	sts	0x0627, r24
							ResetTimer16(TD_GSM);
    bae0:	80 91 5a 02 	lds	r24, 0x025A
    bae4:	0e 94 b9 2c 	call	0x5972	; 0x5972 <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    bae8:	80 91 7c 09 	lds	r24, 0x097C
    baec:	81 30       	cpi	r24, 0x01	; 1
    baee:	09 f0       	breq	.+2      	; 0xbaf2 <GSM_Cycle+0xaa6>
    baf0:	e8 c6       	rjmp	.+3536   	; 0xc8c2 <GSM_Cycle+0x1876>
							if(GSM_ActiveConnection == NO_CONNECTION){
    baf2:	80 91 07 01 	lds	r24, 0x0107
    baf6:	8f 3f       	cpi	r24, 0xFF	; 255
    baf8:	19 f4       	brne	.+6      	; 0xbb00 <GSM_Cycle+0xab4>
								GPRS_FlgSz_Out = 0;
    bafa:	10 92 43 09 	sts	0x0943, r1
    bafe:	e1 c6       	rjmp	.+3522   	; 0xc8c2 <GSM_Cycle+0x1876>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    bb00:	85 e3       	ldi	r24, 0x35	; 53
    bb02:	80 93 27 06 	sts	0x0627, r24
    bb06:	dd c6       	rjmp	.+3514   	; 0xc8c2 <GSM_Cycle+0x1876>
						}
					}
					else{
						GSM_MultiCon = 1;
    bb08:	81 e0       	ldi	r24, 0x01	; 1
    bb0a:	80 93 4b 0e 	sts	0x0E4B, r24
						GSM_State = GSM_CIPSHUT;
    bb0e:	82 e5       	ldi	r24, 0x52	; 82
    bb10:	80 93 27 06 	sts	0x0627, r24
    bb14:	d6 c6       	rjmp	.+3500   	; 0xc8c2 <GSM_Cycle+0x1876>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    bb16:	80 91 67 09 	lds	r24, 0x0967
    bb1a:	88 23       	and	r24, r24
    bb1c:	61 f0       	breq	.+24     	; 0xbb36 <GSM_Cycle+0xaea>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bb1e:	80 e6       	ldi	r24, 0x60	; 96
    bb20:	90 e0       	ldi	r25, 0x00	; 0
    bb22:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    bb26:	88 23       	and	r24, r24
    bb28:	31 f0       	breq	.+12     	; 0xbb36 <GSM_Cycle+0xaea>
					GSM_State = GSM_SEND_CMGS;
    bb2a:	8a e3       	ldi	r24, 0x3A	; 58
    bb2c:	80 93 27 06 	sts	0x0627, r24
					TempNum = 0;
    bb30:	10 92 e7 03 	sts	0x03E7, r1
    bb34:	c6 c6       	rjmp	.+3468   	; 0xc8c2 <GSM_Cycle+0x1876>
					break;
				}
			}

			if(GetStringFromFIFO()){
    bb36:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    bb3a:	88 23       	and	r24, r24
    bb3c:	31 f0       	breq	.+12     	; 0xbb4a <GSM_Cycle+0xafe>
				GSM_State = GSM_AnalyzeURC;
    bb3e:	84 e3       	ldi	r24, 0x34	; 52
    bb40:	80 93 27 06 	sts	0x0627, r24
				TempNum = 0;
    bb44:	10 92 e7 03 	sts	0x03E7, r1
    bb48:	bc c6       	rjmp	.+3448   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			if(!IsWebSession()){
    bb4a:	80 91 7e 09 	lds	r24, 0x097E
    bb4e:	81 11       	cpse	r24, r1
    bb50:	b8 c6       	rjmp	.+3440   	; 0xc8c2 <GSM_Cycle+0x1876>
				if(Timer16Stopp(TD_TCP_Connect) ){
    bb52:	80 91 59 02 	lds	r24, 0x0259
    bb56:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    bb5a:	88 23       	and	r24, r24
    bb5c:	21 f0       	breq	.+8      	; 0xbb66 <GSM_Cycle+0xb1a>
					GSM_State = GSM_CIPSHUT;
    bb5e:	82 e5       	ldi	r24, 0x52	; 82
    bb60:	80 93 27 06 	sts	0x0627, r24
    bb64:	ae c6       	rjmp	.+3420   	; 0xc8c2 <GSM_Cycle+0x1876>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    bb66:	80 91 58 02 	lds	r24, 0x0258
    bb6a:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    bb6e:	88 23       	and	r24, r24
    bb70:	21 f0       	breq	.+8      	; 0xbb7a <GSM_Cycle+0xb2e>
					GSM_State = GSM_SEND_CSQ;
    bb72:	8f e5       	ldi	r24, 0x5F	; 95
    bb74:	80 93 27 06 	sts	0x0627, r24
    bb78:	a4 c6       	rjmp	.+3400   	; 0xc8c2 <GSM_Cycle+0x1876>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    bb7a:	80 91 57 02 	lds	r24, 0x0257
    bb7e:	0e 94 8e 2c 	call	0x591c	; 0x591c <Timer32Stopp>
    bb82:	88 23       	and	r24, r24
    bb84:	09 f4       	brne	.+2      	; 0xbb88 <GSM_Cycle+0xb3c>
    bb86:	9d c6       	rjmp	.+3386   	; 0xc8c2 <GSM_Cycle+0x1876>
					GSM_State = GSM_ReStart1;
    bb88:	8a e5       	ldi	r24, 0x5A	; 90
    bb8a:	80 93 27 06 	sts	0x0627, r24
    bb8e:	99 c6       	rjmp	.+3378   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    bb90:	6b e4       	ldi	r22, 0x4B	; 75
    bb92:	7f e4       	ldi	r23, 0x4F	; 79
    bb94:	89 e8       	ldi	r24, 0x89	; 137
    bb96:	99 e0       	ldi	r25, 0x09	; 9
    bb98:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bb9c:	89 2b       	or	r24, r25
    bb9e:	21 f0       	breq	.+8      	; 0xbba8 <GSM_Cycle+0xb5c>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    bba0:	8e e3       	ldi	r24, 0x3E	; 62
    bba2:	80 93 27 06 	sts	0x0627, r24
    bba6:	8d c6       	rjmp	.+3354   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    bba8:	63 e4       	ldi	r22, 0x43	; 67
    bbaa:	7f e4       	ldi	r23, 0x4F	; 79
    bbac:	89 e8       	ldi	r24, 0x89	; 137
    bbae:	99 e0       	ldi	r25, 0x09	; 9
    bbb0:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bbb4:	89 2b       	or	r24, r25
    bbb6:	61 f0       	breq	.+24     	; 0xbbd0 <GSM_Cycle+0xb84>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    bbb8:	68 ee       	ldi	r22, 0xE8	; 232
    bbba:	73 e0       	ldi	r23, 0x03	; 3
    bbbc:	80 91 59 02 	lds	r24, 0x0259
    bbc0:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_CSD = 0;
    bbc4:	10 92 4b 09 	sts	0x094B, r1
				GSM_State = GSM_ProtocolMode;
    bbc8:	81 e6       	ldi	r24, 0x61	; 97
    bbca:	80 93 27 06 	sts	0x0627, r24
    bbce:	79 c6       	rjmp	.+3314   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    bbd0:	60 e2       	ldi	r22, 0x20	; 32
    bbd2:	7f e4       	ldi	r23, 0x4F	; 79
    bbd4:	89 e8       	ldi	r24, 0x89	; 137
    bbd6:	99 e0       	ldi	r25, 0x09	; 9
    bbd8:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bbdc:	89 2b       	or	r24, r25
    bbde:	51 f0       	breq	.+20     	; 0xbbf4 <GSM_Cycle+0xba8>
				StartTimer16(TD_GSM, 150);
    bbe0:	66 e9       	ldi	r22, 0x96	; 150
    bbe2:	70 e0       	ldi	r23, 0x00	; 0
    bbe4:	80 91 5a 02 	lds	r24, 0x025A
    bbe8:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    bbec:	86 e6       	ldi	r24, 0x66	; 102
    bbee:	80 93 27 06 	sts	0x0627, r24
    bbf2:	67 c6       	rjmp	.+3278   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    bbf4:	60 e3       	ldi	r22, 0x30	; 48
    bbf6:	7f e4       	ldi	r23, 0x4F	; 79
    bbf8:	89 e8       	ldi	r24, 0x89	; 137
    bbfa:	99 e0       	ldi	r25, 0x09	; 9
    bbfc:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bc00:	89 2b       	or	r24, r25
    bc02:	49 f1       	breq	.+82     	; 0xbc56 <GSM_Cycle+0xc0a>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    bc04:	87 ee       	ldi	r24, 0xE7	; 231
    bc06:	93 e0       	ldi	r25, 0x03	; 3
    bc08:	9f 93       	push	r25
    bc0a:	8f 93       	push	r24
    bc0c:	8d e5       	ldi	r24, 0x5D	; 93
    bc0e:	93 e0       	ldi	r25, 0x03	; 3
    bc10:	9f 93       	push	r25
    bc12:	8f 93       	push	r24
    bc14:	89 e8       	ldi	r24, 0x89	; 137
    bc16:	99 e0       	ldi	r25, 0x09	; 9
    bc18:	9f 93       	push	r25
    bc1a:	8f 93       	push	r24
    bc1c:	0e 94 ce 6c 	call	0xd99c	; 0xd99c <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    bc20:	0f 90       	pop	r0
    bc22:	0f 90       	pop	r0
    bc24:	0f 90       	pop	r0
    bc26:	0f 90       	pop	r0
    bc28:	0f 90       	pop	r0
    bc2a:	0f 90       	pop	r0
    bc2c:	90 91 07 01 	lds	r25, 0x0107
    bc30:	80 91 e7 03 	lds	r24, 0x03E7
    bc34:	98 13       	cpse	r25, r24
    bc36:	0b c0       	rjmp	.+22     	; 0xbc4e <GSM_Cycle+0xc02>
					GSM_ActiveConnection = NO_CONNECTION;
    bc38:	8f ef       	ldi	r24, 0xFF	; 255
    bc3a:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    bc3e:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    bc42:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    bc46:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    bc4a:	10 92 3d 0d 	sts	0x0D3D, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    bc4e:	83 e3       	ldi	r24, 0x33	; 51
    bc50:	80 93 27 06 	sts	0x0627, r24
    bc54:	36 c6       	rjmp	.+3180   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    bc56:	65 e2       	ldi	r22, 0x25	; 37
    bc58:	7f e4       	ldi	r23, 0x4F	; 79
    bc5a:	89 e8       	ldi	r24, 0x89	; 137
    bc5c:	99 e0       	ldi	r25, 0x09	; 9
    bc5e:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bc62:	89 2b       	or	r24, r25
    bc64:	21 f0       	breq	.+8      	; 0xbc6e <GSM_Cycle+0xc22>
				GSM_State = GSM_SEND_E0;
    bc66:	88 e0       	ldi	r24, 0x08	; 8
    bc68:	80 93 27 06 	sts	0x0627, r24
    bc6c:	2a c6       	rjmp	.+3156   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    bc6e:	69 e3       	ldi	r22, 0x39	; 57
    bc70:	7f e4       	ldi	r23, 0x4F	; 79
    bc72:	89 e8       	ldi	r24, 0x89	; 137
    bc74:	99 e0       	ldi	r25, 0x09	; 9
    bc76:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bc7a:	89 2b       	or	r24, r25
    bc7c:	41 f0       	breq	.+16     	; 0xbc8e <GSM_Cycle+0xc42>
    bc7e:	80 91 5e 09 	lds	r24, 0x095E
    bc82:	81 11       	cpse	r24, r1
    bc84:	04 c0       	rjmp	.+8      	; 0xbc8e <GSM_Cycle+0xc42>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    bc86:	81 e4       	ldi	r24, 0x41	; 65
    bc88:	80 93 27 06 	sts	0x0627, r24
    bc8c:	1a c6       	rjmp	.+3124   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    bc8e:	6f eb       	ldi	r22, 0xBF	; 191
    bc90:	7e e4       	ldi	r23, 0x4E	; 78
    bc92:	89 e8       	ldi	r24, 0x89	; 137
    bc94:	99 e0       	ldi	r25, 0x09	; 9
    bc96:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    bc9a:	89 2b       	or	r24, r25
    bc9c:	21 f0       	breq	.+8      	; 0xbca6 <GSM_Cycle+0xc5a>
				GSM_State = GSM_WAIT_CSQ;
    bc9e:	80 e6       	ldi	r24, 0x60	; 96
    bca0:	80 93 27 06 	sts	0x0627, r24
    bca4:	0e c6       	rjmp	.+3100   	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    bca6:	83 e3       	ldi	r24, 0x33	; 51
    bca8:	80 93 27 06 	sts	0x0627, r24
    bcac:	0a c6       	rjmp	.+3092   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    bcae:	80 91 7c 09 	lds	r24, 0x097C
    bcb2:	81 11       	cpse	r24, r1
    bcb4:	74 c0       	rjmp	.+232    	; 0xbd9e <GSM_Cycle+0xd52>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    bcb6:	10 91 e7 03 	lds	r17, 0x03E7
    bcba:	e4 e0       	ldi	r30, 0x04	; 4
    bcbc:	1e 9f       	mul	r17, r30
    bcbe:	c0 01       	movw	r24, r0
    bcc0:	11 24       	eor	r1, r1
    bcc2:	00 e0       	ldi	r16, 0x00	; 0
    bcc4:	20 e0       	ldi	r18, 0x00	; 0
    bcc6:	40 e0       	ldi	r20, 0x00	; 0
    bcc8:	60 e0       	ldi	r22, 0x00	; 0
    bcca:	8e 5b       	subi	r24, 0xBE	; 190
    bccc:	9e 4f       	sbci	r25, 0xFE	; 254
    bcce:	0e 94 cf 39 	call	0x739e	; 0x739e <IP_E_compare_Const>
    bcd2:	81 11       	cpse	r24, r1
    bcd4:	0b c0       	rjmp	.+22     	; 0xbcec <GSM_Cycle+0xca0>
    bcd6:	80 91 6f 08 	lds	r24, 0x086F
    bcda:	90 e0       	ldi	r25, 0x00	; 0
    bcdc:	01 2e       	mov	r0, r17
    bcde:	02 c0       	rjmp	.+4      	; 0xbce4 <GSM_Cycle+0xc98>
    bce0:	95 95       	asr	r25
    bce2:	87 95       	ror	r24
    bce4:	0a 94       	dec	r0
    bce6:	e2 f7       	brpl	.-8      	; 0xbce0 <GSM_Cycle+0xc94>
    bce8:	80 ff       	sbrs	r24, 0
    bcea:	12 c0       	rjmp	.+36     	; 0xbd10 <GSM_Cycle+0xcc4>
					TempNum++;
    bcec:	1f 5f       	subi	r17, 0xFF	; 255
    bcee:	10 93 e7 03 	sts	0x03E7, r17
					if(TempNum>3){
    bcf2:	14 30       	cpi	r17, 0x04	; 4
    bcf4:	08 f4       	brcc	.+2      	; 0xbcf8 <GSM_Cycle+0xcac>
    bcf6:	53 c0       	rjmp	.+166    	; 0xbd9e <GSM_Cycle+0xd52>
						StartTimer16(TD_GSM,150);
    bcf8:	66 e9       	ldi	r22, 0x96	; 150
    bcfa:	70 e0       	ldi	r23, 0x00	; 0
    bcfc:	80 91 5a 02 	lds	r24, 0x025A
    bd00:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    bd04:	89 e3       	ldi	r24, 0x39	; 57
    bd06:	80 93 27 06 	sts	0x0627, r24
						GPRS_FlgSz_Out = 0;
    bd0a:	10 92 43 09 	sts	0x0943, r1
    bd0e:	47 c0       	rjmp	.+142    	; 0xbd9e <GSM_Cycle+0xd52>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    bd10:	80 91 08 01 	lds	r24, 0x0108
    bd14:	80 ff       	sbrs	r24, 0
    bd16:	43 c0       	rjmp	.+134    	; 0xbd9e <GSM_Cycle+0xd52>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    bd18:	80 91 5a 02 	lds	r24, 0x025A
    bd1c:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    bd20:	88 23       	and	r24, r24
    bd22:	e9 f1       	breq	.+122    	; 0xbd9e <GSM_Cycle+0xd52>
							GSMTxSz = strlen_P(AT_CIPSEND);
    bd24:	8b e0       	ldi	r24, 0x0B	; 11
    bd26:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    bd2a:	8c e7       	ldi	r24, 0x7C	; 124
    bd2c:	9d e4       	ldi	r25, 0x4D	; 77
    bd2e:	9f 93       	push	r25
    bd30:	8f 93       	push	r24
    bd32:	09 e3       	ldi	r16, 0x39	; 57
    bd34:	1c e0       	ldi	r17, 0x0C	; 12
    bd36:	1f 93       	push	r17
    bd38:	0f 93       	push	r16
    bd3a:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    bd3e:	80 91 57 09 	lds	r24, 0x0957
    bd42:	90 91 43 09 	lds	r25, 0x0943
    bd46:	1f 92       	push	r1
    bd48:	9f 93       	push	r25
    bd4a:	90 91 e7 03 	lds	r25, 0x03E7
    bd4e:	1f 92       	push	r1
    bd50:	9f 93       	push	r25
    bd52:	24 ed       	ldi	r18, 0xD4	; 212
    bd54:	31 e0       	ldi	r19, 0x01	; 1
    bd56:	3f 93       	push	r19
    bd58:	2f 93       	push	r18
    bd5a:	90 e0       	ldi	r25, 0x00	; 0
    bd5c:	87 5c       	subi	r24, 0xC7	; 199
    bd5e:	93 4f       	sbci	r25, 0xF3	; 243
    bd60:	9f 93       	push	r25
    bd62:	8f 93       	push	r24
    bd64:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    bd68:	f8 01       	movw	r30, r16
    bd6a:	01 90       	ld	r0, Z+
    bd6c:	00 20       	and	r0, r0
    bd6e:	e9 f7       	brne	.-6      	; 0xbd6a <GSM_Cycle+0xd1e>
    bd70:	31 97       	sbiw	r30, 0x01	; 1
    bd72:	e9 53       	subi	r30, 0x39	; 57
    bd74:	fc 40       	sbci	r31, 0x0C	; 12
    bd76:	e0 93 57 09 	sts	0x0957, r30
							GSM_SendFirstChar();
    bd7a:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bd7e:	64 ef       	ldi	r22, 0xF4	; 244
    bd80:	71 e0       	ldi	r23, 0x01	; 1
    bd82:	80 91 5a 02 	lds	r24, 0x025A
    bd86:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
							GSM_State++;
    bd8a:	80 91 27 06 	lds	r24, 0x0627
    bd8e:	8f 5f       	subi	r24, 0xFF	; 255
    bd90:	80 93 27 06 	sts	0x0627, r24
    bd94:	0f b6       	in	r0, 0x3f	; 63
    bd96:	f8 94       	cli
    bd98:	de bf       	out	0x3e, r29	; 62
    bd9a:	0f be       	out	0x3f, r0	; 63
    bd9c:	cd bf       	out	0x3d, r28	; 61
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    bd9e:	80 91 7c 09 	lds	r24, 0x097C
    bda2:	81 30       	cpi	r24, 0x01	; 1
    bda4:	09 f0       	breq	.+2      	; 0xbda8 <GSM_Cycle+0xd5c>
    bda6:	8d c5       	rjmp	.+2842   	; 0xc8c2 <GSM_Cycle+0x1876>
				if(GSM_Flag & (1<<flg_TxCStr)){
    bda8:	80 91 08 01 	lds	r24, 0x0108
    bdac:	80 ff       	sbrs	r24, 0
    bdae:	89 c5       	rjmp	.+2834   	; 0xc8c2 <GSM_Cycle+0x1876>
					GSMTxSz = strlen_P(AT_CIPSEND);
    bdb0:	8b e0       	ldi	r24, 0x0B	; 11
    bdb2:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    bdb6:	8c e7       	ldi	r24, 0x7C	; 124
    bdb8:	9d e4       	ldi	r25, 0x4D	; 77
    bdba:	9f 93       	push	r25
    bdbc:	8f 93       	push	r24
    bdbe:	09 e3       	ldi	r16, 0x39	; 57
    bdc0:	1c e0       	ldi	r17, 0x0C	; 12
    bdc2:	1f 93       	push	r17
    bdc4:	0f 93       	push	r16
    bdc6:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    bdca:	80 91 57 09 	lds	r24, 0x0957
    bdce:	90 91 43 09 	lds	r25, 0x0943
    bdd2:	1f 92       	push	r1
    bdd4:	9f 93       	push	r25
    bdd6:	90 91 07 01 	lds	r25, 0x0107
    bdda:	1f 92       	push	r1
    bddc:	9f 93       	push	r25
    bdde:	24 ed       	ldi	r18, 0xD4	; 212
    bde0:	31 e0       	ldi	r19, 0x01	; 1
    bde2:	3f 93       	push	r19
    bde4:	2f 93       	push	r18
    bde6:	90 e0       	ldi	r25, 0x00	; 0
    bde8:	87 5c       	subi	r24, 0xC7	; 199
    bdea:	93 4f       	sbci	r25, 0xF3	; 243
    bdec:	9f 93       	push	r25
    bdee:	8f 93       	push	r24
    bdf0:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    bdf4:	f8 01       	movw	r30, r16
    bdf6:	01 90       	ld	r0, Z+
    bdf8:	00 20       	and	r0, r0
    bdfa:	e9 f7       	brne	.-6      	; 0xbdf6 <GSM_Cycle+0xdaa>
    bdfc:	31 97       	sbiw	r30, 0x01	; 1
    bdfe:	e9 53       	subi	r30, 0x39	; 57
    be00:	fc 40       	sbci	r31, 0x0C	; 12
    be02:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    be06:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    be0a:	64 ef       	ldi	r22, 0xF4	; 244
    be0c:	71 e0       	ldi	r23, 0x01	; 1
    be0e:	80 91 5a 02 	lds	r24, 0x025A
    be12:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					GSM_State++;
    be16:	80 91 27 06 	lds	r24, 0x0627
    be1a:	8f 5f       	subi	r24, 0xFF	; 255
    be1c:	80 93 27 06 	sts	0x0627, r24
    be20:	0f b6       	in	r0, 0x3f	; 63
    be22:	f8 94       	cli
    be24:	de bf       	out	0x3e, r29	; 62
    be26:	0f be       	out	0x3f, r0	; 63
    be28:	cd bf       	out	0x3d, r28	; 61
    be2a:	4b c5       	rjmp	.+2710   	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    be2c:	63 e3       	ldi	r22, 0x33	; 51
    be2e:	8e e3       	ldi	r24, 0x3E	; 62
    be30:	0e 94 4d 3b 	call	0x769a	; 0x769a <GSM_Wait_Char>
    be34:	88 23       	and	r24, r24
    be36:	29 f0       	breq	.+10     	; 0xbe42 <GSM_Cycle+0xdf6>
    be38:	80 91 27 06 	lds	r24, 0x0627
    be3c:	8f 5f       	subi	r24, 0xFF	; 255
    be3e:	80 93 27 06 	sts	0x0627, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    be42:	80 91 27 06 	lds	r24, 0x0627
    be46:	83 33       	cpi	r24, 0x33	; 51
    be48:	09 f0       	breq	.+2      	; 0xbe4c <GSM_Cycle+0xe00>
    be4a:	3b c5       	rjmp	.+2678   	; 0xc8c2 <GSM_Cycle+0x1876>
    be4c:	10 92 43 09 	sts	0x0943, r1
    be50:	38 c5       	rjmp	.+2672   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    be52:	60 91 43 09 	lds	r22, 0x0943
    be56:	89 e3       	ldi	r24, 0x39	; 57
    be58:	9b e0       	ldi	r25, 0x0B	; 11
    be5a:	0e 94 0e 58 	call	0xb01c	; 0xb01c <GSM_AddHeaderSendData>
			GSM_State++;
    be5e:	80 91 27 06 	lds	r24, 0x0627
    be62:	8f 5f       	subi	r24, 0xFF	; 255
    be64:	80 93 27 06 	sts	0x0627, r24
    be68:	2c c5       	rjmp	.+2648   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    be6a:	80 91 5a 02 	lds	r24, 0x025A
    be6e:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    be72:	88 23       	and	r24, r24
    be74:	29 f0       	breq	.+10     	; 0xbe80 <GSM_Cycle+0xe34>
				GSM_State = GSM_ServerIdle;
    be76:	83 e3       	ldi	r24, 0x33	; 51
    be78:	80 93 27 06 	sts	0x0627, r24
				GPRS_FlgSz_Out = 0;
    be7c:	10 92 43 09 	sts	0x0943, r1
			}

			if(GetStringFromFIFO()){
    be80:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    be84:	88 23       	and	r24, r24
    be86:	09 f4       	brne	.+2      	; 0xbe8a <GSM_Cycle+0xe3e>
    be88:	1c c5       	rjmp	.+2616   	; 0xc8c2 <GSM_Cycle+0x1876>
				if(GPRS_Protocol_Out == UDP){
    be8a:	80 91 7c 09 	lds	r24, 0x097C
    be8e:	81 11       	cpse	r24, r1
    be90:	27 c0       	rjmp	.+78     	; 0xbee0 <GSM_Cycle+0xe94>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    be92:	6a ed       	ldi	r22, 0xDA	; 218
    be94:	7e e4       	ldi	r23, 0x4E	; 78
    be96:	ce 01       	movw	r24, r28
    be98:	01 96       	adiw	r24, 0x01	; 1
    be9a:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    be9e:	80 91 e7 03 	lds	r24, 0x03E7
    bea2:	80 5d       	subi	r24, 0xD0	; 208
    bea4:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bea6:	6a e5       	ldi	r22, 0x5A	; 90
    bea8:	ce 01       	movw	r24, r28
    beaa:	01 96       	adiw	r24, 0x01	; 1
    beac:	0e 94 19 3b 	call	0x7632	; 0x7632 <GSM_Wait_Response>
    beb0:	88 23       	and	r24, r24
    beb2:	b1 f0       	breq	.+44     	; 0xbee0 <GSM_Cycle+0xe94>
						StartTimer16(TD_GSM,500);//min~ 2 sec
    beb4:	64 ef       	ldi	r22, 0xF4	; 244
    beb6:	71 e0       	ldi	r23, 0x01	; 1
    beb8:	80 91 5a 02 	lds	r24, 0x025A
    bebc:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
						if(++TempNum>3){
    bec0:	80 91 e7 03 	lds	r24, 0x03E7
    bec4:	8f 5f       	subi	r24, 0xFF	; 255
    bec6:	80 93 e7 03 	sts	0x03E7, r24
    beca:	84 30       	cpi	r24, 0x04	; 4
    becc:	30 f0       	brcs	.+12     	; 0xbeda <GSM_Cycle+0xe8e>
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    bece:	89 e3       	ldi	r24, 0x39	; 57
    bed0:	80 93 27 06 	sts	0x0627, r24
							GPRS_FlgSz_Out = 0;
    bed4:	10 92 43 09 	sts	0x0943, r1
    bed8:	03 c0       	rjmp	.+6      	; 0xbee0 <GSM_Cycle+0xe94>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    beda:	85 e3       	ldi	r24, 0x35	; 53
    bedc:	80 93 27 06 	sts	0x0627, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    bee0:	80 91 7c 09 	lds	r24, 0x097C
    bee4:	81 30       	cpi	r24, 0x01	; 1
    bee6:	09 f0       	breq	.+2      	; 0xbeea <GSM_Cycle+0xe9e>
    bee8:	ec c4       	rjmp	.+2520   	; 0xc8c2 <GSM_Cycle+0x1876>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    beea:	6a ed       	ldi	r22, 0xDA	; 218
    beec:	7e e4       	ldi	r23, 0x4E	; 78
    beee:	ce 01       	movw	r24, r28
    bef0:	01 96       	adiw	r24, 0x01	; 1
    bef2:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    bef6:	80 91 07 01 	lds	r24, 0x0107
    befa:	80 5d       	subi	r24, 0xD0	; 208
    befc:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    befe:	6a e5       	ldi	r22, 0x5A	; 90
    bf00:	ce 01       	movw	r24, r28
    bf02:	01 96       	adiw	r24, 0x01	; 1
    bf04:	0e 94 19 3b 	call	0x7632	; 0x7632 <GSM_Wait_Response>
    bf08:	88 23       	and	r24, r24
    bf0a:	09 f4       	brne	.+2      	; 0xbf0e <GSM_Cycle+0xec2>
    bf0c:	da c4       	rjmp	.+2484   	; 0xc8c2 <GSM_Cycle+0x1876>
						GPRS_FlgSz_Out = 0;
    bf0e:	10 92 43 09 	sts	0x0943, r1
    bf12:	d7 c4       	rjmp	.+2478   	; 0xc8c2 <GSM_Cycle+0x1876>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    bf14:	80 91 5a 02 	lds	r24, 0x025A
    bf18:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    bf1c:	88 23       	and	r24, r24
    bf1e:	09 f4       	brne	.+2      	; 0xbf22 <GSM_Cycle+0xed6>
    bf20:	d0 c4       	rjmp	.+2464   	; 0xc8c2 <GSM_Cycle+0x1876>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    bf22:	10 92 4b 0e 	sts	0x0E4B, r1
				if(sendsWithoutReconnect<3)
    bf26:	80 91 5b 02 	lds	r24, 0x025B
    bf2a:	83 30       	cpi	r24, 0x03	; 3
    bf2c:	10 f4       	brcc	.+4      	; 0xbf32 <GSM_Cycle+0xee6>
				{
					GSM_State = GSM_CIPSHUT;
    bf2e:	82 e5       	ldi	r24, 0x52	; 82
    bf30:	03 c0       	rjmp	.+6      	; 0xbf38 <GSM_Cycle+0xeec>
				}
				else{
					sendsWithoutReconnect=0;
    bf32:	10 92 5b 02 	sts	0x025B, r1
					GSM_State = GSM_CIPSHUT_;
    bf36:	84 e5       	ldi	r24, 0x54	; 84
    bf38:	80 93 27 06 	sts	0x0627, r24
				}
				sendsWithoutReconnect++;
    bf3c:	80 91 5b 02 	lds	r24, 0x025B
    bf40:	8f 5f       	subi	r24, 0xFF	; 255
    bf42:	80 93 5b 02 	sts	0x025B, r24
    bf46:	bd c4       	rjmp	.+2426   	; 0xc8c2 <GSM_Cycle+0x1876>

			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bf48:	68 ee       	ldi	r22, 0xE8	; 232
    bf4a:	73 e0       	ldi	r23, 0x03	; 3
    bf4c:	83 e5       	ldi	r24, 0x53	; 83
    bf4e:	9d e4       	ldi	r25, 0x4D	; 77
    bf50:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    bf54:	80 91 27 06 	lds	r24, 0x0627
    bf58:	8f 5f       	subi	r24, 0xFF	; 255
    bf5a:	80 93 27 06 	sts	0x0627, r24
    bf5e:	b1 c4       	rjmp	.+2402   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    bf60:	6a e5       	ldi	r22, 0x5A	; 90
    bf62:	87 eb       	ldi	r24, 0xB7	; 183
    bf64:	9e e4       	ldi	r25, 0x4E	; 78
    bf66:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    bf6a:	88 23       	and	r24, r24
    bf6c:	09 f4       	brne	.+2      	; 0xbf70 <GSM_Cycle+0xf24>
    bf6e:	a9 c4       	rjmp	.+2386   	; 0xc8c2 <GSM_Cycle+0x1876>
    bf70:	83 e1       	ldi	r24, 0x13	; 19
    bf72:	80 93 27 06 	sts	0x0627, r24
    bf76:	a5 c4       	rjmp	.+2378   	; 0xc8c2 <GSM_Cycle+0x1876>
		//------------------------


				//------------------------  GPRS
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bf78:	68 ee       	ldi	r22, 0xE8	; 232
    bf7a:	73 e0       	ldi	r23, 0x03	; 3
    bf7c:	83 e5       	ldi	r24, 0x53	; 83
    bf7e:	9d e4       	ldi	r25, 0x4D	; 77
    bf80:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    bf84:	80 91 27 06 	lds	r24, 0x0627
    bf88:	8f 5f       	subi	r24, 0xFF	; 255
    bf8a:	80 93 27 06 	sts	0x0627, r24
    bf8e:	99 c4       	rjmp	.+2354   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    bf90:	6a e5       	ldi	r22, 0x5A	; 90
    bf92:	87 eb       	ldi	r24, 0xB7	; 183
    bf94:	9e e4       	ldi	r25, 0x4E	; 78
    bf96:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    bf9a:	88 23       	and	r24, r24
    bf9c:	09 f4       	brne	.+2      	; 0xbfa0 <GSM_Cycle+0xf54>
    bf9e:	91 c4       	rjmp	.+2338   	; 0xc8c2 <GSM_Cycle+0x1876>
    bfa0:	80 91 27 06 	lds	r24, 0x0627
    bfa4:	8f 5f       	subi	r24, 0xFF	; 255
    bfa6:	80 93 27 06 	sts	0x0627, r24
    bfaa:	8b c4       	rjmp	.+2326   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    bfac:	68 ee       	ldi	r22, 0xE8	; 232
    bfae:	73 e0       	ldi	r23, 0x03	; 3
    bfb0:	88 e4       	ldi	r24, 0x48	; 72
    bfb2:	9d e4       	ldi	r25, 0x4D	; 77
    bfb4:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    bfb8:	80 91 27 06 	lds	r24, 0x0627
    bfbc:	8f 5f       	subi	r24, 0xFF	; 255
    bfbe:	80 93 27 06 	sts	0x0627, r24
    bfc2:	7f c4       	rjmp	.+2302   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    bfc4:	6a e5       	ldi	r22, 0x5A	; 90
    bfc6:	82 e1       	ldi	r24, 0x12	; 18
    bfc8:	9f e4       	ldi	r25, 0x4F	; 79
    bfca:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    bfce:	88 23       	and	r24, r24
    bfd0:	09 f4       	brne	.+2      	; 0xbfd4 <GSM_Cycle+0xf88>
    bfd2:	77 c4       	rjmp	.+2286   	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_GSM, 1000);
    bfd4:	68 ee       	ldi	r22, 0xE8	; 232
    bfd6:	73 e0       	ldi	r23, 0x03	; 3
    bfd8:	80 91 5a 02 	lds	r24, 0x025A
    bfdc:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			 	GSM_State = GSM_SEND_CIPMUX;
    bfe0:	83 e1       	ldi	r24, 0x13	; 19
    bfe2:	80 93 27 06 	sts	0x0627, r24
    bfe6:	6d c4       	rjmp	.+2266   	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    bfe8:	80 91 08 01 	lds	r24, 0x0108
    bfec:	80 ff       	sbrs	r24, 0
    bfee:	69 c4       	rjmp	.+2258   	; 0xc8c2 <GSM_Cycle+0x1876>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
    bff0:	60 91 e7 03 	lds	r22, 0x03E7
    bff4:	9d e0       	ldi	r25, 0x0D	; 13
    bff6:	69 9f       	mul	r22, r25
    bff8:	b0 01       	movw	r22, r0
    bffa:	11 24       	eor	r1, r1
    bffc:	6d 51       	subi	r22, 0x1D	; 29
    bffe:	7f 4f       	sbci	r23, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c000:	4d e0       	ldi	r20, 0x0D	; 13
    c002:	50 e0       	ldi	r21, 0x00	; 0
    c004:	89 e3       	ldi	r24, 0x39	; 57
    c006:	9c e0       	ldi	r25, 0x0C	; 12
    c008:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
				GSMTxSz = strlen(GSM_TxStr);
    c00c:	e9 e3       	ldi	r30, 0x39	; 57
    c00e:	fc e0       	ldi	r31, 0x0C	; 12
    c010:	01 90       	ld	r0, Z+
    c012:	00 20       	and	r0, r0
    c014:	e9 f7       	brne	.-6      	; 0xc010 <GSM_Cycle+0xfc4>
    c016:	31 97       	sbiw	r30, 0x01	; 1
    c018:	e9 53       	subi	r30, 0x39	; 57
    c01a:	fc 40       	sbci	r31, 0x0C	; 12
    c01c:	e0 93 57 09 	sts	0x0957, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c020:	80 e0       	ldi	r24, 0x00	; 0
		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
    c022:	90 e0       	ldi	r25, 0x00	; 0
				for(uint8_t i=0; i<GSMTxSz; i++)
    c024:	20 91 57 09 	lds	r18, 0x0957
    c028:	82 17       	cp	r24, r18
    c02a:	50 f4       	brcc	.+20     	; 0xc040 <GSM_Cycle+0xff4>
					if(GSM_TxStr[i] != '0') j++;
    c02c:	e8 2f       	mov	r30, r24
    c02e:	f0 e0       	ldi	r31, 0x00	; 0
    c030:	e7 5c       	subi	r30, 0xC7	; 199
    c032:	f3 4f       	sbci	r31, 0xF3	; 243
    c034:	20 81       	ld	r18, Z
    c036:	20 33       	cpi	r18, 0x30	; 48
    c038:	09 f0       	breq	.+2      	; 0xc03c <GSM_Cycle+0xff0>
    c03a:	9f 5f       	subi	r25, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c03c:	8f 5f       	subi	r24, 0xFF	; 255
    c03e:	f2 cf       	rjmp	.-28     	; 0xc024 <GSM_Cycle+0xfd8>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c040:	99 23       	and	r25, r25
    c042:	09 f4       	brne	.+2      	; 0xc046 <GSM_Cycle+0xffa>
    c044:	4b c0       	rjmp	.+150    	; 0xc0dc <GSM_Cycle+0x1090>
					GSMTxSz = strlen_P(AT_CMGS);
    c046:	8a e0       	ldi	r24, 0x0A	; 10
    c048:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    c04c:	81 e4       	ldi	r24, 0x41	; 65
    c04e:	9e e4       	ldi	r25, 0x4E	; 78
    c050:	9f 93       	push	r25
    c052:	8f 93       	push	r24
    c054:	09 e3       	ldi	r16, 0x39	; 57
    c056:	1c e0       	ldi	r17, 0x0C	; 12
    c058:	1f 93       	push	r17
    c05a:	0f 93       	push	r16
    c05c:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    c060:	60 91 e7 03 	lds	r22, 0x03E7
    c064:	80 91 57 09 	lds	r24, 0x0957
    c068:	ed e0       	ldi	r30, 0x0D	; 13
    c06a:	6e 9f       	mul	r22, r30
    c06c:	b0 01       	movw	r22, r0
    c06e:	11 24       	eor	r1, r1
    c070:	6d 51       	subi	r22, 0x1D	; 29
    c072:	7f 4f       	sbci	r23, 0xFF	; 255
    c074:	90 e0       	ldi	r25, 0x00	; 0
    c076:	4d e0       	ldi	r20, 0x0D	; 13
    c078:	50 e0       	ldi	r21, 0x00	; 0
    c07a:	87 5c       	subi	r24, 0xC7	; 199
    c07c:	93 4f       	sbci	r25, 0xF3	; 243
    c07e:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    c082:	d8 01       	movw	r26, r16
    c084:	0d 90       	ld	r0, X+
    c086:	00 20       	and	r0, r0
    c088:	e9 f7       	brne	.-6      	; 0xc084 <GSM_Cycle+0x1038>
    c08a:	11 97       	sbiw	r26, 0x01	; 1
    c08c:	a9 53       	subi	r26, 0x39	; 57
    c08e:	bc 40       	sbci	r27, 0x0C	; 12
    c090:	a0 93 57 09 	sts	0x0957, r26
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    c094:	80 91 57 09 	lds	r24, 0x0957
    c098:	90 e0       	ldi	r25, 0x00	; 0
    c09a:	68 ec       	ldi	r22, 0xC8	; 200
    c09c:	71 e0       	ldi	r23, 0x01	; 1
    c09e:	87 5c       	subi	r24, 0xC7	; 199
    c0a0:	93 4f       	sbci	r25, 0xF3	; 243
    c0a2:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    c0a6:	f8 01       	movw	r30, r16
    c0a8:	01 90       	ld	r0, Z+
    c0aa:	00 20       	and	r0, r0
    c0ac:	e9 f7       	brne	.-6      	; 0xc0a8 <GSM_Cycle+0x105c>
    c0ae:	31 97       	sbiw	r30, 0x01	; 1
    c0b0:	e9 53       	subi	r30, 0x39	; 57
    c0b2:	fc 40       	sbci	r31, 0x0C	; 12
    c0b4:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    c0b8:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c0bc:	64 ef       	ldi	r22, 0xF4	; 244
    c0be:	71 e0       	ldi	r23, 0x01	; 1
    c0c0:	80 91 5a 02 	lds	r24, 0x025A
    c0c4:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					GSM_State++;
    c0c8:	80 91 27 06 	lds	r24, 0x0627
    c0cc:	8f 5f       	subi	r24, 0xFF	; 255
    c0ce:	80 93 27 06 	sts	0x0627, r24
    c0d2:	0f 90       	pop	r0
    c0d4:	0f 90       	pop	r0
    c0d6:	0f 90       	pop	r0
    c0d8:	0f 90       	pop	r0
    c0da:	f3 c3       	rjmp	.+2022   	; 0xc8c2 <GSM_Cycle+0x1876>
				}
				else{
					TempNum++;
    c0dc:	80 91 e7 03 	lds	r24, 0x03E7
    c0e0:	8f 5f       	subi	r24, 0xFF	; 255
    c0e2:	80 93 e7 03 	sts	0x03E7, r24
					if(TempNum>=MaxTelephDirSz){
    c0e6:	83 30       	cpi	r24, 0x03	; 3
    c0e8:	08 f4       	brcc	.+2      	; 0xc0ec <GSM_Cycle+0x10a0>
    c0ea:	eb c3       	rjmp	.+2006   	; 0xc8c2 <GSM_Cycle+0x1876>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    c0ec:	83 e3       	ldi	r24, 0x33	; 51
    c0ee:	80 93 27 06 	sts	0x0627, r24
						SMS_FlgSz_Out = 0;
    c0f2:	10 92 67 09 	sts	0x0967, r1
    c0f6:	e5 c3       	rjmp	.+1994   	; 0xc8c2 <GSM_Cycle+0x1876>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c0f8:	6a e5       	ldi	r22, 0x5A	; 90
    c0fa:	8e e3       	ldi	r24, 0x3E	; 62
    c0fc:	0e 94 4d 3b 	call	0x769a	; 0x769a <GSM_Wait_Char>
    c100:	88 23       	and	r24, r24
    c102:	09 f4       	brne	.+2      	; 0xc106 <GSM_Cycle+0x10ba>
    c104:	de c3       	rjmp	.+1980   	; 0xc8c2 <GSM_Cycle+0x1876>
    c106:	80 91 27 06 	lds	r24, 0x0627
    c10a:	8f 5f       	subi	r24, 0xFF	; 255
    c10c:	80 93 27 06 	sts	0x0627, r24
    c110:	d8 c3       	rjmp	.+1968   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c112:	60 91 67 09 	lds	r22, 0x0967
    c116:	e6 2f       	mov	r30, r22
    c118:	f0 e0       	ldi	r31, 0x00	; 0
    c11a:	e6 52       	subi	r30, 0x26	; 38
    c11c:	f7 4f       	sbci	r31, 0xF7	; 247
    c11e:	8a e1       	ldi	r24, 0x1A	; 26
    c120:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c122:	6f 5f       	subi	r22, 0xFF	; 255
    c124:	8a ed       	ldi	r24, 0xDA	; 218
    c126:	98 e0       	ldi	r25, 0x08	; 8
    c128:	0e 94 1a 58 	call	0xb034	; 0xb034 <GSM_SendData>
			GSM_State++;
    c12c:	80 91 27 06 	lds	r24, 0x0627
    c130:	8f 5f       	subi	r24, 0xFF	; 255
    c132:	80 93 27 06 	sts	0x0627, r24
    c136:	c5 c3       	rjmp	.+1930   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c138:	6a e5       	ldi	r22, 0x5A	; 90
    c13a:	82 e1       	ldi	r24, 0x12	; 18
    c13c:	9f e4       	ldi	r25, 0x4F	; 79
    c13e:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c142:	88 23       	and	r24, r24
    c144:	09 f4       	brne	.+2      	; 0xc148 <GSM_Cycle+0x10fc>
    c146:	bd c3       	rjmp	.+1914   	; 0xc8c2 <GSM_Cycle+0x1876>
				if(++TempNum>=MaxTelephDirSz){
    c148:	80 91 e7 03 	lds	r24, 0x03E7
    c14c:	8f 5f       	subi	r24, 0xFF	; 255
    c14e:	80 93 e7 03 	sts	0x03E7, r24
    c152:	83 30       	cpi	r24, 0x03	; 3
    c154:	30 f0       	brcs	.+12     	; 0xc162 <GSM_Cycle+0x1116>
					GSM_State = GSM_ServerIdle;
    c156:	83 e3       	ldi	r24, 0x33	; 51
    c158:	80 93 27 06 	sts	0x0627, r24
					SMS_FlgSz_Out = 0;
    c15c:	10 92 67 09 	sts	0x0967, r1
    c160:	b0 c3       	rjmp	.+1888   	; 0xc8c2 <GSM_Cycle+0x1876>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    c162:	8a e3       	ldi	r24, 0x3A	; 58
    c164:	80 93 27 06 	sts	0x0627, r24
    c168:	ac c3       	rjmp	.+1880   	; 0xc8c2 <GSM_Cycle+0x1876>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    c16a:	8d e3       	ldi	r24, 0x3D	; 61
    c16c:	9d e0       	ldi	r25, 0x0D	; 13
    c16e:	9f 93       	push	r25
    c170:	8f 93       	push	r24
    c172:	8c e3       	ldi	r24, 0x3C	; 60
    c174:	9d e0       	ldi	r25, 0x0D	; 13
    c176:	9f 93       	push	r25
    c178:	8f 93       	push	r24
    c17a:	8b e3       	ldi	r24, 0x3B	; 59
    c17c:	9d e0       	ldi	r25, 0x0D	; 13
    c17e:	9f 93       	push	r25
    c180:	8f 93       	push	r24
    c182:	8a e3       	ldi	r24, 0x3A	; 58
    c184:	9d e0       	ldi	r25, 0x0D	; 13
    c186:	9f 93       	push	r25
    c188:	8f 93       	push	r24
    c18a:	8f e3       	ldi	r24, 0x3F	; 63
    c18c:	93 e0       	ldi	r25, 0x03	; 3
    c18e:	9f 93       	push	r25
    c190:	8f 93       	push	r24
    c192:	89 e8       	ldi	r24, 0x89	; 137
    c194:	99 e0       	ldi	r25, 0x09	; 9
    c196:	9f 93       	push	r25
    c198:	8f 93       	push	r24
    c19a:	0e 94 ce 6c 	call	0xd99c	; 0xd99c <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    c19e:	10 92 e7 03 	sts	0x03E7, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c1a2:	10 91 3d 0d 	lds	r17, 0x0D3D
    c1a6:	d0 90 3c 0d 	lds	r13, 0x0D3C
    c1aa:	c0 90 3b 0d 	lds	r12, 0x0D3B
    c1ae:	b0 90 3a 0d 	lds	r11, 0x0D3A
    c1b2:	00 e1       	ldi	r16, 0x10	; 16
    c1b4:	e0 2e       	mov	r14, r16
    c1b6:	01 e0       	ldi	r16, 0x01	; 1
    c1b8:	f0 2e       	mov	r15, r16
    c1ba:	0f b6       	in	r0, 0x3f	; 63
    c1bc:	f8 94       	cli
    c1be:	de bf       	out	0x3e, r29	; 62
    c1c0:	0f be       	out	0x3f, r0	; 63
    c1c2:	cd bf       	out	0x3d, r28	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    c1c4:	0f ef       	ldi	r16, 0xFF	; 255
    c1c6:	2f ef       	ldi	r18, 0xFF	; 255
    c1c8:	4f ef       	ldi	r20, 0xFF	; 255
    c1ca:	6f ef       	ldi	r22, 0xFF	; 255
    c1cc:	c7 01       	movw	r24, r14
    c1ce:	0e 94 cf 39 	call	0x739e	; 0x739e <IP_E_compare_Const>
    c1d2:	88 23       	and	r24, r24
    c1d4:	21 f0       	breq	.+8      	; 0xc1de <GSM_Cycle+0x1192>
					TempNum = 1;
    c1d6:	81 e0       	ldi	r24, 0x01	; 1
    c1d8:	80 93 e7 03 	sts	0x03E7, r24
    c1dc:	1a c0       	rjmp	.+52     	; 0xc212 <GSM_Cycle+0x11c6>
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    c1de:	00 e0       	ldi	r16, 0x00	; 0
    c1e0:	20 e0       	ldi	r18, 0x00	; 0
    c1e2:	40 e0       	ldi	r20, 0x00	; 0
    c1e4:	60 e0       	ldi	r22, 0x00	; 0
    c1e6:	c7 01       	movw	r24, r14
    c1e8:	0e 94 cf 39 	call	0x739e	; 0x739e <IP_E_compare_Const>
    c1ec:	81 11       	cpse	r24, r1
    c1ee:	09 c0       	rjmp	.+18     	; 0xc202 <GSM_Cycle+0x11b6>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c1f0:	01 2f       	mov	r16, r17
    c1f2:	2d 2d       	mov	r18, r13
    c1f4:	4c 2d       	mov	r20, r12
    c1f6:	6b 2d       	mov	r22, r11
    c1f8:	c7 01       	movw	r24, r14
    c1fa:	0e 94 cf 39 	call	0x739e	; 0x739e <IP_E_compare_Const>
    c1fe:	81 11       	cpse	r24, r1
    c200:	ea cf       	rjmp	.-44     	; 0xc1d6 <GSM_Cycle+0x118a>
    c202:	34 e0       	ldi	r19, 0x04	; 4
    c204:	e3 0e       	add	r14, r19
    c206:	f1 1c       	adc	r15, r1
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    c208:	80 e2       	ldi	r24, 0x20	; 32
    c20a:	e8 16       	cp	r14, r24
    c20c:	81 e0       	ldi	r24, 0x01	; 1
    c20e:	f8 06       	cpc	r15, r24
    c210:	c9 f6       	brne	.-78     	; 0xc1c4 <GSM_Cycle+0x1178>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    c212:	80 91 e7 03 	lds	r24, 0x03E7
    c216:	88 23       	and	r24, r24
    c218:	89 f0       	breq	.+34     	; 0xc23c <GSM_Cycle+0x11f0>
				GSM_State = GSM_ServerIdle;
    c21a:	83 e3       	ldi	r24, 0x33	; 51
    c21c:	80 93 27 06 	sts	0x0627, r24
				GSM_ActiveConnection = GSM_Temp;
    c220:	80 91 e6 03 	lds	r24, 0x03E6
    c224:	80 93 07 01 	sts	0x0107, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c228:	8e e0       	ldi	r24, 0x0E	; 14
    c22a:	91 e0       	ldi	r25, 0x01	; 1
    c22c:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c230:	bc 01       	movw	r22, r24
    c232:	80 91 59 02 	lds	r24, 0x0259
    c236:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
    c23a:	43 c3       	rjmp	.+1670   	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    c23c:	8f e3       	ldi	r24, 0x3F	; 63
    c23e:	80 93 27 06 	sts	0x0627, r24
    c242:	3f c3       	rjmp	.+1662   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    c244:	80 91 08 01 	lds	r24, 0x0108
    c248:	80 ff       	sbrs	r24, 0
    c24a:	3b c3       	rjmp	.+1654   	; 0xc8c2 <GSM_Cycle+0x1876>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    c24c:	8f e0       	ldi	r24, 0x0F	; 15
    c24e:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    c252:	8c e6       	ldi	r24, 0x6C	; 108
    c254:	9d e4       	ldi	r25, 0x4D	; 77
    c256:	9f 93       	push	r25
    c258:	8f 93       	push	r24
    c25a:	89 e3       	ldi	r24, 0x39	; 57
    c25c:	9c e0       	ldi	r25, 0x0C	; 12
    c25e:	9f 93       	push	r25
    c260:	8f 93       	push	r24
    c262:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    c266:	80 91 57 09 	lds	r24, 0x0957
    c26a:	90 e0       	ldi	r25, 0x00	; 0
    c26c:	69 ec       	ldi	r22, 0xC9	; 201
    c26e:	71 e0       	ldi	r23, 0x01	; 1
    c270:	87 5c       	subi	r24, 0xC7	; 199
    c272:	93 4f       	sbci	r25, 0xF3	; 243
    c274:	0e 94 39 6c 	call	0xd872	; 0xd872 <strcpy>
				GSMTxSz++;
    c278:	80 91 57 09 	lds	r24, 0x0957
    c27c:	8f 5f       	subi	r24, 0xFF	; 255
    c27e:	80 93 57 09 	sts	0x0957, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    c282:	80 91 e6 03 	lds	r24, 0x03E6
    c286:	80 5d       	subi	r24, 0xD0	; 208
    c288:	80 93 45 0c 	sts	0x0C45, r24
				GSM_SendFirstChar();
    c28c:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c290:	64 ef       	ldi	r22, 0xF4	; 244
    c292:	71 e0       	ldi	r23, 0x01	; 1
    c294:	80 91 5a 02 	lds	r24, 0x025A
    c298:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State++;
    c29c:	80 91 27 06 	lds	r24, 0x0627
    c2a0:	8f 5f       	subi	r24, 0xFF	; 255
    c2a2:	80 93 27 06 	sts	0x0627, r24
    c2a6:	0f 90       	pop	r0
    c2a8:	0f 90       	pop	r0
    c2aa:	0f 90       	pop	r0
    c2ac:	0f 90       	pop	r0
    c2ae:	09 c3       	rjmp	.+1554   	; 0xc8c2 <GSM_Cycle+0x1876>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c2b0:	80 91 5a 02 	lds	r24, 0x025A
    c2b4:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c2b8:	88 23       	and	r24, r24
    c2ba:	19 f0       	breq	.+6      	; 0xc2c2 <GSM_Cycle+0x1276>
    c2bc:	8a e5       	ldi	r24, 0x5A	; 90
    c2be:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    c2c2:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    c2c6:	88 23       	and	r24, r24
    c2c8:	09 f4       	brne	.+2      	; 0xc2cc <GSM_Cycle+0x1280>
    c2ca:	fb c2       	rjmp	.+1526   	; 0xc8c2 <GSM_Cycle+0x1876>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    c2cc:	65 ec       	ldi	r22, 0xC5	; 197
    c2ce:	7e e4       	ldi	r23, 0x4E	; 78
    c2d0:	ce 01       	movw	r24, r28
    c2d2:	01 96       	adiw	r24, 0x01	; 1
    c2d4:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    c2d8:	80 91 e6 03 	lds	r24, 0x03E6
    c2dc:	80 5d       	subi	r24, 0xD0	; 208
    c2de:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c2e0:	6a e5       	ldi	r22, 0x5A	; 90
    c2e2:	ce 01       	movw	r24, r28
    c2e4:	01 96       	adiw	r24, 0x01	; 1
    c2e6:	0e 94 19 3b 	call	0x7632	; 0x7632 <GSM_Wait_Response>
    c2ea:	88 23       	and	r24, r24
    c2ec:	09 f4       	brne	.+2      	; 0xc2f0 <GSM_Cycle+0x12a4>
    c2ee:	e9 c2       	rjmp	.+1490   	; 0xc8c2 <GSM_Cycle+0x1876>
					GSM_State = GSM_ServerIdle;
    c2f0:	83 e3       	ldi	r24, 0x33	; 51
    c2f2:	80 93 27 06 	sts	0x0627, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    c2f6:	80 91 07 01 	lds	r24, 0x0107
    c2fa:	8f 3f       	cpi	r24, 0xFF	; 255
    c2fc:	09 f4       	brne	.+2      	; 0xc300 <GSM_Cycle+0x12b4>
    c2fe:	e1 c2       	rjmp	.+1474   	; 0xc8c2 <GSM_Cycle+0x1876>
    c300:	80 91 59 02 	lds	r24, 0x0259
    c304:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c308:	88 23       	and	r24, r24
    c30a:	09 f4       	brne	.+2      	; 0xc30e <GSM_Cycle+0x12c2>
    c30c:	da c2       	rjmp	.+1460   	; 0xc8c2 <GSM_Cycle+0x1876>
						GSM_ActiveConnection = NO_CONNECTION;
    c30e:	8f ef       	ldi	r24, 0xFF	; 255
    c310:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c314:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c318:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c31c:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c320:	10 92 3d 0d 	sts	0x0D3D, r1
    c324:	ce c2       	rjmp	.+1436   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    c326:	86 ee       	ldi	r24, 0xE6	; 230
    c328:	93 e0       	ldi	r25, 0x03	; 3
    c32a:	9f 93       	push	r25
    c32c:	8f 93       	push	r24
    c32e:	ce 01       	movw	r24, r28
    c330:	01 96       	adiw	r24, 0x01	; 1
    c332:	9f 93       	push	r25
    c334:	8f 93       	push	r24
    c336:	8c e2       	ldi	r24, 0x2C	; 44
    c338:	93 e0       	ldi	r25, 0x03	; 3
    c33a:	9f 93       	push	r25
    c33c:	8f 93       	push	r24
    c33e:	89 e8       	ldi	r24, 0x89	; 137
    c340:	99 e0       	ldi	r25, 0x09	; 9
    c342:	9f 93       	push	r25
    c344:	8f 93       	push	r24
    c346:	0e 94 ce 6c 	call	0xd99c	; 0xd99c <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    c34a:	0f b6       	in	r0, 0x3f	; 63
    c34c:	f8 94       	cli
    c34e:	de bf       	out	0x3e, r29	; 62
    c350:	0f be       	out	0x3f, r0	; 63
    c352:	cd bf       	out	0x3d, r28	; 61
    c354:	99 81       	ldd	r25, Y+1	; 0x01
    c356:	80 91 07 01 	lds	r24, 0x0107
    c35a:	98 13       	cpse	r25, r24
    c35c:	0c c0       	rjmp	.+24     	; 0xc376 <GSM_Cycle+0x132a>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c35e:	64 ef       	ldi	r22, 0xF4	; 244
    c360:	71 e0       	ldi	r23, 0x01	; 1
    c362:	80 91 5a 02 	lds	r24, 0x025A
    c366:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					GSM_State++;
    c36a:	80 91 27 06 	lds	r24, 0x0627
    c36e:	8f 5f       	subi	r24, 0xFF	; 255
    c370:	80 93 27 06 	sts	0x0627, r24
    c374:	a6 c2       	rjmp	.+1356   	; 0xc8c2 <GSM_Cycle+0x1876>
					break;
				}
				GSM_State = GSM_ServerIdle;
    c376:	83 e3       	ldi	r24, 0x33	; 51
    c378:	80 93 27 06 	sts	0x0627, r24
    c37c:	a2 c2       	rjmp	.+1348   	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    c37e:	80 91 5a 02 	lds	r24, 0x025A
    c382:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c386:	88 23       	and	r24, r24
    c388:	19 f0       	breq	.+6      	; 0xc390 <GSM_Cycle+0x1344>
    c38a:	8a e5       	ldi	r24, 0x5A	; 90
    c38c:	80 93 27 06 	sts	0x0627, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    c390:	80 91 e6 03 	lds	r24, 0x03E6
    c394:	80 93 5e 09 	sts	0x095E, r24

			GSM_State = GSM_ServerIdle;
    c398:	83 e3       	ldi	r24, 0x33	; 51
    c39a:	80 93 27 06 	sts	0x0627, r24
    c39e:	91 c2       	rjmp	.+1314   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c3a0:	60 e7       	ldi	r22, 0x70	; 112
    c3a2:	77 e1       	ldi	r23, 0x17	; 23
    c3a4:	8e e5       	ldi	r24, 0x5E	; 94
    c3a6:	9d e4       	ldi	r25, 0x4D	; 77
    c3a8:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c3ac:	80 91 27 06 	lds	r24, 0x0627
    c3b0:	8f 5f       	subi	r24, 0xFF	; 255
    c3b2:	80 93 27 06 	sts	0x0627, r24
    c3b6:	85 c2       	rjmp	.+1290   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c3b8:	80 91 5a 02 	lds	r24, 0x025A
    c3bc:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c3c0:	88 23       	and	r24, r24
    c3c2:	19 f0       	breq	.+6      	; 0xc3ca <GSM_Cycle+0x137e>
    c3c4:	8a e5       	ldi	r24, 0x5A	; 90
    c3c6:	80 93 27 06 	sts	0x0627, r24
			//  
			if(GetStringFromFIFO()){
    c3ca:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    c3ce:	88 23       	and	r24, r24
    c3d0:	09 f4       	brne	.+2      	; 0xc3d4 <GSM_Cycle+0x1388>
    c3d2:	77 c2       	rjmp	.+1262   	; 0xc8c2 <GSM_Cycle+0x1876>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
    c3d4:	61 ed       	ldi	r22, 0xD1	; 209
    c3d6:	7e e4       	ldi	r23, 0x4E	; 78
    c3d8:	89 e8       	ldi	r24, 0x89	; 137
    c3da:	99 e0       	ldi	r25, 0x09	; 9
    c3dc:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    c3e0:	89 2b       	or	r24, r25
    c3e2:	49 f0       	breq	.+18     	; 0xc3f6 <GSM_Cycle+0x13aa>
    c3e4:	62 e3       	ldi	r22, 0x32	; 50
    c3e6:	7f e4       	ldi	r23, 0x4F	; 79
    c3e8:	89 e8       	ldi	r24, 0x89	; 137
    c3ea:	99 e0       	ldi	r25, 0x09	; 9
    c3ec:	0e 94 c7 6b 	call	0xd78e	; 0xd78e <strcmp_P>
    c3f0:	89 2b       	or	r24, r25
    c3f2:	09 f0       	breq	.+2      	; 0xc3f6 <GSM_Cycle+0x13aa>
    c3f4:	66 c2       	rjmp	.+1228   	; 0xc8c2 <GSM_Cycle+0x1876>
					GSM_State = GSM_ServerIdle;
    c3f6:	83 e3       	ldi	r24, 0x33	; 51
    c3f8:	80 93 27 06 	sts	0x0627, r24
					GPRS_FlgSz_Out = 0;						
    c3fc:	10 92 43 09 	sts	0x0943, r1
    c400:	60 c2       	rjmp	.+1216   	; 0xc8c2 <GSM_Cycle+0x1876>
		//------------------------

		/*NEW COMMIT*/
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
    c402:	0e 94 ce 2e 	call	0x5d9c	; 0x5d9c <GSM_PWRCNTRL_OFF>
			StartTimer16(TD_GSM,1000);
    c406:	68 ee       	ldi	r22, 0xE8	; 232
    c408:	73 e0       	ldi	r23, 0x03	; 3
    c40a:	80 91 5a 02 	lds	r24, 0x025A
    c40e:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			RxBufOverFlow = 0;
    c412:	10 92 39 0d 	sts	0x0D39, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
    c416:	10 92 67 09 	sts	0x0967, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c41a:	8f ef       	ldi	r24, 0xFF	; 255
    c41c:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c420:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c424:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c428:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c42c:	10 92 3d 0d 	sts	0x0D3D, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c430:	80 91 08 01 	lds	r24, 0x0108
    c434:	81 60       	ori	r24, 0x01	; 1
    c436:	80 93 08 01 	sts	0x0108, r24
			GSM_State++;
    c43a:	80 91 27 06 	lds	r24, 0x0627
    c43e:	8f 5f       	subi	r24, 0xFF	; 255
    c440:	80 93 27 06 	sts	0x0627, r24
    c444:	3e c2       	rjmp	.+1148   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c446:	80 91 5a 02 	lds	r24, 0x025A
    c44a:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c44e:	88 23       	and	r24, r24
    c450:	09 f4       	brne	.+2      	; 0xc454 <GSM_Cycle+0x1408>
    c452:	37 c2       	rjmp	.+1134   	; 0xc8c2 <GSM_Cycle+0x1876>
				GSM_State = GSM_PowerOn;
    c454:	10 92 27 06 	sts	0x0627, r1
    c458:	34 c2       	rjmp	.+1128   	; 0xc8c2 <GSM_Cycle+0x1876>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
    c45a:	64 ef       	ldi	r22, 0xF4	; 244
    c45c:	71 e0       	ldi	r23, 0x01	; 1
    c45e:	89 e9       	ldi	r24, 0x99	; 153
    c460:	9d e4       	ldi	r25, 0x4D	; 77
    c462:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c466:	80 91 27 06 	lds	r24, 0x0627
    c46a:	8f 5f       	subi	r24, 0xFF	; 255
    c46c:	80 93 27 06 	sts	0x0627, r24
    c470:	28 c2       	rjmp	.+1104   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c472:	6a e5       	ldi	r22, 0x5A	; 90
    c474:	82 e1       	ldi	r24, 0x12	; 18
    c476:	9f e4       	ldi	r25, 0x4F	; 79
    c478:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c47c:	88 23       	and	r24, r24
    c47e:	09 f4       	brne	.+2      	; 0xc482 <GSM_Cycle+0x1436>
    c480:	20 c2       	rjmp	.+1088   	; 0xc8c2 <GSM_Cycle+0x1876>
    c482:	80 91 27 06 	lds	r24, 0x0627
    c486:	8f 5f       	subi	r24, 0xFF	; 255
    c488:	80 93 27 06 	sts	0x0627, r24
    c48c:	1a c2       	rjmp	.+1076   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
    c48e:	6a e5       	ldi	r22, 0x5A	; 90
    c490:	85 ee       	ldi	r24, 0xE5	; 229
    c492:	9e e4       	ldi	r25, 0x4E	; 78
    c494:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c498:	88 23       	and	r24, r24
    c49a:	09 f4       	brne	.+2      	; 0xc49e <GSM_Cycle+0x1452>
    c49c:	12 c2       	rjmp	.+1060   	; 0xc8c2 <GSM_Cycle+0x1876>
    c49e:	80 e3       	ldi	r24, 0x30	; 48
    c4a0:	80 93 27 06 	sts	0x0627, r24
    c4a4:	0e c2       	rjmp	.+1052   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c4a6:	64 ef       	ldi	r22, 0xF4	; 244
    c4a8:	71 e0       	ldi	r23, 0x01	; 1
    c4aa:	81 e4       	ldi	r24, 0x41	; 65
    c4ac:	9d e4       	ldi	r25, 0x4D	; 77
    c4ae:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
    c4b2:	60 e7       	ldi	r22, 0x70	; 112
    c4b4:	77 e1       	ldi	r23, 0x17	; 23
    c4b6:	80 91 58 02 	lds	r24, 0x0258
    c4ba:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			GSM_State = GSM_ServerIdle;
    c4be:	83 e3       	ldi	r24, 0x33	; 51
    c4c0:	80 93 27 06 	sts	0x0627, r24
    c4c4:	fe c1       	rjmp	.+1020   	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
    c4c6:	8f ef       	ldi	r24, 0xFF	; 255
    c4c8:	80 93 25 06 	sts	0x0625, r24
    c4cc:	80 93 6c 09 	sts	0x096C, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    c4d0:	8c e6       	ldi	r24, 0x6C	; 108
    c4d2:	99 e0       	ldi	r25, 0x09	; 9
    c4d4:	9f 93       	push	r25
    c4d6:	8f 93       	push	r24
    c4d8:	85 e2       	ldi	r24, 0x25	; 37
    c4da:	96 e0       	ldi	r25, 0x06	; 6
    c4dc:	9f 93       	push	r25
    c4de:	8f 93       	push	r24
    c4e0:	8c e1       	ldi	r24, 0x1C	; 28
    c4e2:	93 e0       	ldi	r25, 0x03	; 3
    c4e4:	9f 93       	push	r25
    c4e6:	8f 93       	push	r24
    c4e8:	89 e8       	ldi	r24, 0x89	; 137
    c4ea:	99 e0       	ldi	r25, 0x09	; 9
    c4ec:	9f 93       	push	r25
    c4ee:	8f 93       	push	r24
    c4f0:	0e 94 ce 6c 	call	0xd99c	; 0xd99c <sscanf_P>
			GSM_State = GSM_ServerIdle;
    c4f4:	83 e3       	ldi	r24, 0x33	; 51
    c4f6:	80 93 27 06 	sts	0x0627, r24
    c4fa:	0f b6       	in	r0, 0x3f	; 63
    c4fc:	f8 94       	cli
    c4fe:	de bf       	out	0x3e, r29	; 62
    c500:	0f be       	out	0x3f, r0	; 63
    c502:	cd bf       	out	0x3d, r28	; 61
    c504:	de c1       	rjmp	.+956    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			Transparent_Application_state = WAIT_REQUEST;
    c506:	81 e0       	ldi	r24, 0x01	; 1
    c508:	80 93 52 09 	sts	0x0952, r24
			if(!UART_Soft){
    c50c:	80 91 75 0a 	lds	r24, 0x0A75
    c510:	81 11       	cpse	r24, r1
    c512:	05 c0       	rjmp	.+10     	; 0xc51e <GSM_Cycle+0x14d2>
				cli();
    c514:	f8 94       	cli
				Transparent = 1;
    c516:	81 e0       	ldi	r24, 0x01	; 1
    c518:	80 93 76 0a 	sts	0x0A76, r24
    c51c:	03 c0       	rjmp	.+6      	; 0xc524 <GSM_Cycle+0x14d8>
				sei();
				}
				else{
				cli();
    c51e:	f8 94       	cli
				Transparent = 0;
    c520:	10 92 76 0a 	sts	0x0A76, r1
				sei();
    c524:	78 94       	sei
				GSM_State = GSM_Swtch2CommandMode;
				Transparent_Application_state = RECONNECT;
				Transparent = 0;
				break;
			}*/
			if(Timer16Stopp(TCP_CONNECT_check_timer)){
    c526:	80 91 40 0d 	lds	r24, 0x0D40
    c52a:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c52e:	88 23       	and	r24, r24
    c530:	59 f0       	breq	.+22     	; 0xc548 <GSM_Cycle+0x14fc>
				GSM_State = GSM_Swtch2CommandMode;
    c532:	83 e6       	ldi	r24, 0x63	; 99
    c534:	80 93 27 06 	sts	0x0627, r24
				Transparent_Application_state = CHECK_CONNECTION_STATE;
    c538:	83 e0       	ldi	r24, 0x03	; 3
    c53a:	80 93 52 09 	sts	0x0952, r24
				cli();
    c53e:	f8 94       	cli
				Transparent = 0;
    c540:	10 92 76 0a 	sts	0x0A76, r1
				sei();
    c544:	78 94       	sei
    c546:	bd c1       	rjmp	.+890    	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}
			if(Timer32Stopp(TD_GSM_Reset)){
    c548:	80 91 57 02 	lds	r24, 0x0257
    c54c:	0e 94 8e 2c 	call	0x591c	; 0x591c <Timer32Stopp>
    c550:	88 23       	and	r24, r24
    c552:	09 f4       	brne	.+2      	; 0xc556 <GSM_Cycle+0x150a>
    c554:	b6 c1       	rjmp	.+876    	; 0xc8c2 <GSM_Cycle+0x1876>
				cli();
    c556:	f8 94       	cli
				Transparent = 0;
    c558:	10 92 76 0a 	sts	0x0A76, r1
				sei();
    c55c:	78 94       	sei
				GSM_State = GSM_ReStart1;
    c55e:	8a e5       	ldi	r24, 0x5A	; 90
    c560:	80 93 27 06 	sts	0x0627, r24
    c564:	ae c1       	rjmp	.+860    	; 0xc8c2 <GSM_Cycle+0x1876>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c566:	90 91 7b 08 	lds	r25, 0x087B
    c56a:	80 91 05 06 	lds	r24, 0x0605
    c56e:	98 17       	cp	r25, r24
    c570:	49 f0       	breq	.+18     	; 0xc584 <GSM_Cycle+0x1538>
    c572:	8e e0       	ldi	r24, 0x0E	; 14
    c574:	91 e0       	ldi	r25, 0x01	; 1
    c576:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c57a:	bc 01       	movw	r22, r24
    c57c:	80 91 59 02 	lds	r24, 0x0259
    c580:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
    c584:	80 91 f4 09 	lds	r24, 0x09F4
    c588:	81 30       	cpi	r24, 0x01	; 1
    c58a:	71 f1       	breq	.+92     	; 0xc5e8 <GSM_Cycle+0x159c>
				if(GetStringFromFIFO()){							
    c58c:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    c590:	88 23       	and	r24, r24
    c592:	51 f1       	breq	.+84     	; 0xc5e8 <GSM_Cycle+0x159c>
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c594:	62 e3       	ldi	r22, 0x32	; 50
    c596:	7f e4       	ldi	r23, 0x4F	; 79
    c598:	89 e8       	ldi	r24, 0x89	; 137
    c59a:	99 e0       	ldi	r25, 0x09	; 9
    c59c:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    c5a0:	89 2b       	or	r24, r25
    c5a2:	31 f0       	breq	.+12     	; 0xc5b0 <GSM_Cycle+0x1564>
						GSM_State = GSM_ServerIdle;
    c5a4:	83 e3       	ldi	r24, 0x33	; 51
    c5a6:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c5aa:	0e 94 d9 4b 	call	0x97b2	; 0x97b2 <GSM_CloseTransparent>
    c5ae:	89 c1       	rjmp	.+786    	; 0xc8c2 <GSM_Cycle+0x1876>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
    c5b0:	65 e1       	ldi	r22, 0x15	; 21
    c5b2:	7f e4       	ldi	r23, 0x4F	; 79
    c5b4:	89 e8       	ldi	r24, 0x89	; 137
    c5b6:	99 e0       	ldi	r25, 0x09	; 9
    c5b8:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    c5bc:	89 2b       	or	r24, r25
    c5be:	31 f0       	breq	.+12     	; 0xc5cc <GSM_Cycle+0x1580>
						GSM_State = GSM_ServerIdle;
    c5c0:	83 e3       	ldi	r24, 0x33	; 51
    c5c2:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c5c6:	0e 94 d9 4b 	call	0x97b2	; 0x97b2 <GSM_CloseTransparent>
    c5ca:	7b c1       	rjmp	.+758    	; 0xc8c2 <GSM_Cycle+0x1876>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    c5cc:	65 e2       	ldi	r22, 0x25	; 37
    c5ce:	7f e4       	ldi	r23, 0x4F	; 79
    c5d0:	89 e8       	ldi	r24, 0x89	; 137
    c5d2:	99 e0       	ldi	r25, 0x09	; 9
    c5d4:	0e 94 02 6c 	call	0xd804	; 0xd804 <strstr_P>
    c5d8:	89 2b       	or	r24, r25
    c5da:	31 f0       	breq	.+12     	; 0xc5e8 <GSM_Cycle+0x159c>
						GSM_State = GSM_SEND_E0;
    c5dc:	88 e0       	ldi	r24, 0x08	; 8
    c5de:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c5e2:	0e 94 d9 4b 	call	0x97b2	; 0x97b2 <GSM_CloseTransparent>
    c5e6:	6d c1       	rjmp	.+730    	; 0xc8c2 <GSM_Cycle+0x1876>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    c5e8:	80 91 59 02 	lds	r24, 0x0259
    c5ec:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c5f0:	88 23       	and	r24, r24
    c5f2:	09 f4       	brne	.+2      	; 0xc5f6 <GSM_Cycle+0x15aa>
    c5f4:	66 c1       	rjmp	.+716    	; 0xc8c2 <GSM_Cycle+0x1876>
				GSM_State = GSM_Swtch2CommandMode;
    c5f6:	83 e6       	ldi	r24, 0x63	; 99
    c5f8:	80 93 27 06 	sts	0x0627, r24
				GSM_CloseTransparent();
    c5fc:	0e 94 d9 4b 	call	0x97b2	; 0x97b2 <GSM_CloseTransparent>
    c600:	60 c1       	rjmp	.+704    	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}
			break;
		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
    c602:	6e e6       	ldi	r22, 0x6E	; 110
    c604:	70 e0       	ldi	r23, 0x00	; 0
    c606:	80 91 5a 02 	lds	r24, 0x025A
    c60a:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			//WebClose();
			GSM_State++;
    c60e:	80 91 27 06 	lds	r24, 0x0627
    c612:	8f 5f       	subi	r24, 0xFF	; 255
    c614:	80 93 27 06 	sts	0x0627, r24
    c618:	54 c1       	rjmp	.+680    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c61a:	80 91 5a 02 	lds	r24, 0x025A
    c61e:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c622:	88 23       	and	r24, r24
    c624:	09 f4       	brne	.+2      	; 0xc628 <GSM_Cycle+0x15dc>
    c626:	4d c1       	rjmp	.+666    	; 0xc8c2 <GSM_Cycle+0x1876>
						if(GSM_Flag & (1<<flg_TxCStr)){
    c628:	80 91 08 01 	lds	r24, 0x0108
    c62c:	80 ff       	sbrs	r24, 0
    c62e:	49 c1       	rjmp	.+658    	; 0xc8c2 <GSM_Cycle+0x1876>
							GSMTxSz = strlen_P(ESC_SEQ);
    c630:	83 e0       	ldi	r24, 0x03	; 3
    c632:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, ESC_SEQ);
    c636:	84 e9       	ldi	r24, 0x94	; 148
    c638:	9e e4       	ldi	r25, 0x4E	; 78
    c63a:	9f 93       	push	r25
    c63c:	8f 93       	push	r24
    c63e:	89 e3       	ldi	r24, 0x39	; 57
    c640:	9c e0       	ldi	r25, 0x0C	; 12
    c642:	9f 93       	push	r25
    c644:	8f 93       	push	r24
    c646:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
							GSM_SendFirstChar();
    c64a:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c64e:	64 ef       	ldi	r22, 0xF4	; 244
    c650:	71 e0       	ldi	r23, 0x01	; 1
    c652:	80 91 5a 02 	lds	r24, 0x025A
    c656:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
							GSM_State++;
    c65a:	80 91 27 06 	lds	r24, 0x0627
    c65e:	8f 5f       	subi	r24, 0xFF	; 255
    c660:	80 93 27 06 	sts	0x0627, r24
    c664:	0f 90       	pop	r0
    c666:	0f 90       	pop	r0
    c668:	0f 90       	pop	r0
    c66a:	0f 90       	pop	r0
    c66c:	2a c1       	rjmp	.+596    	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;*/
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c66e:	6a e5       	ldi	r22, 0x5A	; 90
    c670:	82 e1       	ldi	r24, 0x12	; 18
    c672:	9f e4       	ldi	r25, 0x4F	; 79
    c674:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c678:	88 23       	and	r24, r24
    c67a:	09 f4       	brne	.+2      	; 0xc67e <GSM_Cycle+0x1632>
    c67c:	22 c1       	rjmp	.+580    	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    c67e:	6f ef       	ldi	r22, 0xFF	; 255
    c680:	7f ef       	ldi	r23, 0xFF	; 255
    c682:	80 91 59 02 	lds	r24, 0x0259
    c686:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				/*if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
				else GSM_State = GSM_SEND_CIPCLOSE;*/
				switch(Transparent_Application_state){
    c68a:	80 91 52 09 	lds	r24, 0x0952
    c68e:	82 30       	cpi	r24, 0x02	; 2
    c690:	41 f0       	breq	.+16     	; 0xc6a2 <GSM_Cycle+0x1656>
    c692:	83 30       	cpi	r24, 0x03	; 3
    c694:	51 f4       	brne	.+20     	; 0xc6aa <GSM_Cycle+0x165e>
					case CHECK_CONNECTION_STATE:
						GSM_State = GSM_SEND_CIPSTATUS;
    c696:	89 e2       	ldi	r24, 0x29	; 41
    c698:	80 93 27 06 	sts	0x0627, r24
						InitFIFO();
    c69c:	0e 94 ff 39 	call	0x73fe	; 0x73fe <InitFIFO>
    c6a0:	10 c1       	rjmp	.+544    	; 0xc8c2 <GSM_Cycle+0x1876>
						break;
					case RECONNECT:
						GSM_State = GSM_CIPSHUT_;
    c6a2:	84 e5       	ldi	r24, 0x54	; 84
    c6a4:	80 93 27 06 	sts	0x0627, r24
    c6a8:	0c c1       	rjmp	.+536    	; 0xc8c2 <GSM_Cycle+0x1876>
						break;
					default:GSM_State = GSM_ReStart1;
    c6aa:	8a e5       	ldi	r24, 0x5A	; 90
    c6ac:	80 93 27 06 	sts	0x0627, r24
    c6b0:	08 c1       	rjmp	.+528    	; 0xc8c2 <GSM_Cycle+0x1876>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
    c6b2:	80 91 5a 02 	lds	r24, 0x025A
    c6b6:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c6ba:	88 23       	and	r24, r24
    c6bc:	19 f0       	breq	.+6      	; 0xc6c4 <GSM_Cycle+0x1678>
    c6be:	89 e6       	ldi	r24, 0x69	; 105
    c6c0:	80 93 27 06 	sts	0x0627, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c6c4:	8f e5       	ldi	r24, 0x5F	; 95
    c6c6:	90 e0       	ldi	r25, 0x00	; 0
    c6c8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
    c6cc:	81 11       	cpse	r24, r1
    c6ce:	04 c0       	rjmp	.+8      	; 0xc6d8 <GSM_Cycle+0x168c>
				GSM_State = GSM_SEND_ATA;
    c6d0:	87 e6       	ldi	r24, 0x67	; 103
    c6d2:	80 93 27 06 	sts	0x0627, r24
    c6d6:	f5 c0       	rjmp	.+490    	; 0xc8c2 <GSM_Cycle+0x1876>
				break;
			}
			if(GetStringFromFIFO() > 25){
    c6d8:	0e 94 66 3a 	call	0x74cc	; 0x74cc <GetStringFromFIFO>
    c6dc:	8a 31       	cpi	r24, 0x1A	; 26
    c6de:	08 f4       	brcc	.+2      	; 0xc6e2 <GSM_Cycle+0x1696>
    c6e0:	f0 c0       	rjmp	.+480    	; 0xc8c2 <GSM_Cycle+0x1876>
				char *qoute_open = strchr(GSM_RxStr,'"');
    c6e2:	62 e2       	ldi	r22, 0x22	; 34
    c6e4:	70 e0       	ldi	r23, 0x00	; 0
    c6e6:	89 e8       	ldi	r24, 0x89	; 137
    c6e8:	99 e0       	ldi	r25, 0x09	; 9
    c6ea:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
    c6ee:	7c 01       	movw	r14, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
    c6f0:	62 e2       	ldi	r22, 0x22	; 34
    c6f2:	70 e0       	ldi	r23, 0x00	; 0
    c6f4:	01 96       	adiw	r24, 0x01	; 1
    c6f6:	0e 94 25 6c 	call	0xd84a	; 0xd84a <strchr>
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
    c6fa:	e1 14       	cp	r14, r1
    c6fc:	f1 04       	cpc	r15, r1
    c6fe:	11 f0       	breq	.+4      	; 0xc704 <GSM_Cycle+0x16b8>
    c700:	00 97       	sbiw	r24, 0x00	; 0
    c702:	21 f4       	brne	.+8      	; 0xc70c <GSM_Cycle+0x16c0>
					GSM_State = GSM_SEND_ATH;
    c704:	89 e6       	ldi	r24, 0x69	; 105
    c706:	80 93 27 06 	sts	0x0627, r24
    c70a:	db c0       	rjmp	.+438    	; 0xc8c2 <GSM_Cycle+0x1876>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
    c70c:	fc 01       	movw	r30, r24
    c70e:	10 82       	st	Z, r1
    c710:	01 e6       	ldi	r16, 0x61	; 97
    c712:	10 e0       	ldi	r17, 0x00	; 0
				for(uint8_t i = 0; i<10; i++){
					if(strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i])) GSM_State = GSM_SEND_ATH;
    c714:	f2 e0       	ldi	r31, 0x02	; 2
    c716:	ef 0e       	add	r14, r31
    c718:	f1 1c       	adc	r15, r1
    c71a:	b9 e6       	ldi	r27, 0x69	; 105
    c71c:	db 2e       	mov	r13, r27
    c71e:	b8 01       	movw	r22, r16
    c720:	c7 01       	movw	r24, r14
    c722:	0e 94 71 47 	call	0x8ee2	; 0x8ee2 <strcmp_E>
    c726:	88 23       	and	r24, r24
    c728:	49 f0       	breq	.+18     	; 0xc73c <GSM_Cycle+0x16f0>
    c72a:	d0 92 27 06 	sts	0x0627, r13
    c72e:	03 5f       	subi	r16, 0xF3	; 243
    c730:	1f 4f       	sbci	r17, 0xFF	; 255
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
    c732:	20 e0       	ldi	r18, 0x00	; 0
    c734:	03 3e       	cpi	r16, 0xE3	; 227
    c736:	12 07       	cpc	r17, r18
    c738:	91 f7       	brne	.-28     	; 0xc71e <GSM_Cycle+0x16d2>
    c73a:	c3 c0       	rjmp	.+390    	; 0xc8c2 <GSM_Cycle+0x1876>
					if(strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i])) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
    c73c:	87 e6       	ldi	r24, 0x67	; 103
    c73e:	80 93 27 06 	sts	0x0627, r24
    c742:	bf c0       	rjmp	.+382    	; 0xc8c2 <GSM_Cycle+0x1876>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c744:	60 e7       	ldi	r22, 0x70	; 112
    c746:	77 e1       	ldi	r23, 0x17	; 23
    c748:	8d e3       	ldi	r24, 0x3D	; 61
    c74a:	9d e4       	ldi	r25, 0x4D	; 77
    c74c:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c750:	80 91 27 06 	lds	r24, 0x0627
    c754:	8f 5f       	subi	r24, 0xFF	; 255
    c756:	80 93 27 06 	sts	0x0627, r24
    c75a:	b3 c0       	rjmp	.+358    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
    c75c:	69 e6       	ldi	r22, 0x69	; 105
    c75e:	8a ea       	ldi	r24, 0xAA	; 170
    c760:	9e e4       	ldi	r25, 0x4E	; 78
    c762:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c766:	88 23       	and	r24, r24
    c768:	09 f4       	brne	.+2      	; 0xc76c <GSM_Cycle+0x1720>
    c76a:	ab c0       	rjmp	.+342    	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_TCP_Connect, 500);	//   
    c76c:	64 ef       	ldi	r22, 0xF4	; 244
    c76e:	71 e0       	ldi	r23, 0x01	; 1
    c770:	80 91 59 02 	lds	r24, 0x0259
    c774:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_CSD = 1;
    c778:	81 e0       	ldi	r24, 0x01	; 1
    c77a:	80 93 4b 09 	sts	0x094B, r24
				GSM_State = GSM_ProtocolMode;
    c77e:	81 e6       	ldi	r24, 0x61	; 97
    c780:	80 93 27 06 	sts	0x0627, r24
    c784:	9e c0       	rjmp	.+316    	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
    c786:	6c e2       	ldi	r22, 0x2C	; 44
    c788:	71 e0       	ldi	r23, 0x01	; 1
    c78a:	89 e3       	ldi	r24, 0x39	; 57
    c78c:	9d e4       	ldi	r25, 0x4D	; 77
    c78e:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c792:	80 91 27 06 	lds	r24, 0x0627
    c796:	8f 5f       	subi	r24, 0xFF	; 255
    c798:	80 93 27 06 	sts	0x0627, r24
    c79c:	92 c0       	rjmp	.+292    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    c79e:	6a e5       	ldi	r22, 0x5A	; 90
    c7a0:	82 e1       	ldi	r24, 0x12	; 18
    c7a2:	9f e4       	ldi	r25, 0x4F	; 79
    c7a4:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c7a8:	88 23       	and	r24, r24
    c7aa:	09 f4       	brne	.+2      	; 0xc7ae <GSM_Cycle+0x1762>
    c7ac:	8a c0       	rjmp	.+276    	; 0xc8c2 <GSM_Cycle+0x1876>
    c7ae:	83 e3       	ldi	r24, 0x33	; 51
    c7b0:	80 93 27 06 	sts	0x0627, r24
    c7b4:	86 c0       	rjmp	.+268    	; 0xc8c2 <GSM_Cycle+0x1876>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c7b6:	80 91 27 06 	lds	r24, 0x0627
    c7ba:	90 e0       	ldi	r25, 0x00	; 0
    c7bc:	89 30       	cpi	r24, 0x09	; 9
    c7be:	91 05       	cpc	r25, r1
    c7c0:	08 f0       	brcs	.+2      	; 0xc7c4 <GSM_Cycle+0x1778>
    c7c2:	7d c0       	rjmp	.+250    	; 0xc8be <GSM_Cycle+0x1872>
    c7c4:	fc 01       	movw	r30, r24
    c7c6:	e5 5c       	subi	r30, 0xC5	; 197
    c7c8:	fe 4f       	sbci	r31, 0xFE	; 254
    c7ca:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c7ce:	68 ec       	ldi	r22, 0xC8	; 200
    c7d0:	70 e0       	ldi	r23, 0x00	; 0
    c7d2:	80 91 5a 02 	lds	r24, 0x025A
    c7d6:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
			GSM_PWRCNTRL_ON();
    c7da:	0e 94 d2 2e 	call	0x5da4	; 0x5da4 <GSM_PWRCNTRL_ON>
			GSM_State++;
    c7de:	80 91 27 06 	lds	r24, 0x0627
    c7e2:	8f 5f       	subi	r24, 0xFF	; 255
    c7e4:	80 93 27 06 	sts	0x0627, r24
    c7e8:	6c c0       	rjmp	.+216    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    c7ea:	80 91 5a 02 	lds	r24, 0x025A
    c7ee:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c7f2:	88 23       	and	r24, r24
    c7f4:	31 f0       	breq	.+12     	; 0xc802 <GSM_Cycle+0x17b6>
    c7f6:	64 e6       	ldi	r22, 0x64	; 100
    c7f8:	70 e0       	ldi	r23, 0x00	; 0
    c7fa:	81 e9       	ldi	r24, 0x91	; 145
    c7fc:	9e e4       	ldi	r25, 0x4E	; 78
    c7fe:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c802:	80 91 27 06 	lds	r24, 0x0627
    c806:	8f 5f       	subi	r24, 0xFF	; 255
    c808:	80 93 27 06 	sts	0x0627, r24
    c80c:	5a c0       	rjmp	.+180    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    c80e:	61 e0       	ldi	r22, 0x01	; 1
    c810:	82 e1       	ldi	r24, 0x12	; 18
    c812:	9f e4       	ldi	r25, 0x4F	; 79
    c814:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c818:	88 23       	and	r24, r24
    c81a:	09 f4       	brne	.+2      	; 0xc81e <GSM_Cycle+0x17d2>
    c81c:	52 c0       	rjmp	.+164    	; 0xc8c2 <GSM_Cycle+0x1876>
    c81e:	80 91 27 06 	lds	r24, 0x0627
    c822:	8f 5f       	subi	r24, 0xFF	; 255
    c824:	80 93 27 06 	sts	0x0627, r24
    c828:	4c c0       	rjmp	.+152    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c82a:	64 e6       	ldi	r22, 0x64	; 100
    c82c:	70 e0       	ldi	r23, 0x00	; 0
    c82e:	85 e8       	ldi	r24, 0x85	; 133
    c830:	9e e4       	ldi	r25, 0x4E	; 78
    c832:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c836:	80 91 27 06 	lds	r24, 0x0627
    c83a:	8f 5f       	subi	r24, 0xFF	; 255
    c83c:	80 93 27 06 	sts	0x0627, r24
    c840:	40 c0       	rjmp	.+128    	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c842:	61 e0       	ldi	r22, 0x01	; 1
    c844:	82 e1       	ldi	r24, 0x12	; 18
    c846:	9f e4       	ldi	r25, 0x4F	; 79
    c848:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c84c:	88 23       	and	r24, r24
    c84e:	c9 f1       	breq	.+114    	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_GSM,200);
    c850:	68 ec       	ldi	r22, 0xC8	; 200
    c852:	70 e0       	ldi	r23, 0x00	; 0
    c854:	80 91 5a 02 	lds	r24, 0x025A
    c858:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State++;
    c85c:	80 91 27 06 	lds	r24, 0x0627
    c860:	8f 5f       	subi	r24, 0xFF	; 255
    c862:	80 93 27 06 	sts	0x0627, r24
    c866:	2d c0       	rjmp	.+90     	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c868:	64 e6       	ldi	r22, 0x64	; 100
    c86a:	70 e0       	ldi	r23, 0x00	; 0
    c86c:	80 e8       	ldi	r24, 0x80	; 128
    c86e:	9e e4       	ldi	r25, 0x4E	; 78
    c870:	0e 94 f2 57 	call	0xafe4	; 0xafe4 <GSM_Execute_Command>
    c874:	80 91 27 06 	lds	r24, 0x0627
    c878:	8f 5f       	subi	r24, 0xFF	; 255
    c87a:	80 93 27 06 	sts	0x0627, r24
    c87e:	21 c0       	rjmp	.+66     	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c880:	61 e0       	ldi	r22, 0x01	; 1
    c882:	82 e1       	ldi	r24, 0x12	; 18
    c884:	9f e4       	ldi	r25, 0x4F	; 79
    c886:	0e 94 24 3b 	call	0x7648	; 0x7648 <GSM_Wait_Response_P>
    c88a:	88 23       	and	r24, r24
    c88c:	d1 f0       	breq	.+52     	; 0xc8c2 <GSM_Cycle+0x1876>
				StartTimer16(TD_GSM,200);
    c88e:	68 ec       	ldi	r22, 0xC8	; 200
    c890:	70 e0       	ldi	r23, 0x00	; 0
    c892:	80 91 5a 02 	lds	r24, 0x025A
    c896:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				GSM_State++;
    c89a:	80 91 27 06 	lds	r24, 0x0627
    c89e:	8f 5f       	subi	r24, 0xFF	; 255
    c8a0:	80 93 27 06 	sts	0x0627, r24
    c8a4:	0e c0       	rjmp	.+28     	; 0xc8c2 <GSM_Cycle+0x1876>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    c8a6:	80 91 5a 02 	lds	r24, 0x025A
    c8aa:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    c8ae:	88 23       	and	r24, r24
    c8b0:	41 f0       	breq	.+16     	; 0xc8c2 <GSM_Cycle+0x1876>
    c8b2:	80 91 27 06 	lds	r24, 0x0627
    c8b6:	8f 5f       	subi	r24, 0xFF	; 255
    c8b8:	80 93 27 06 	sts	0x0627, r24
    c8bc:	02 c0       	rjmp	.+4      	; 0xc8c2 <GSM_Cycle+0x1876>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c8be:	10 92 27 06 	sts	0x0627, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
    c8c2:	80 91 27 06 	lds	r24, 0x0627
    c8c6:	8a 35       	cpi	r24, 0x5A	; 90
    c8c8:	41 f0       	breq	.+16     	; 0xc8da <GSM_Cycle+0x188e>
    c8ca:	80 91 27 06 	lds	r24, 0x0627
    c8ce:	8b 35       	cpi	r24, 0x5B	; 91
    c8d0:	21 f0       	breq	.+8      	; 0xc8da <GSM_Cycle+0x188e>
    c8d2:	80 91 27 06 	lds	r24, 0x0627
    c8d6:	80 93 5b 09 	sts	0x095B, r24
}
    c8da:	2e 96       	adiw	r28, 0x0e	; 14
    c8dc:	0f b6       	in	r0, 0x3f	; 63
    c8de:	f8 94       	cli
    c8e0:	de bf       	out	0x3e, r29	; 62
    c8e2:	0f be       	out	0x3f, r0	; 63
    c8e4:	cd bf       	out	0x3d, r28	; 61
    c8e6:	df 91       	pop	r29
    c8e8:	cf 91       	pop	r28
    c8ea:	1f 91       	pop	r17
    c8ec:	0f 91       	pop	r16
    c8ee:	ff 90       	pop	r15
    c8f0:	ef 90       	pop	r14
    c8f2:	df 90       	pop	r13
    c8f4:	cf 90       	pop	r12
    c8f6:	bf 90       	pop	r11
    c8f8:	af 90       	pop	r10
    c8fa:	9f 90       	pop	r9
    c8fc:	08 95       	ret

0000c8fe <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
    c8fe:	80 91 75 0a 	lds	r24, 0x0A75
    c902:	88 23       	and	r24, r24
    c904:	b9 f0       	breq	.+46     	; 0xc934 <USART_Cycle+0x36>

		if(ModbusMode) MB_Cycle();
    c906:	80 91 e0 03 	lds	r24, 0x03E0
    c90a:	81 11       	cpse	r24, r1
    c90c:	0e 94 9c 39 	call	0x7338	; 0x7338 <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
    c910:	c8 9b       	sbis	0x19, 0	; 25
    c912:	22 c0       	rjmp	.+68     	; 0xc958 <USART_Cycle+0x5a>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
    c914:	80 91 4c 09 	lds	r24, 0x094C
    c918:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    c91c:	88 23       	and	r24, r24
    c91e:	09 f1       	breq	.+66     	; 0xc962 <USART_Cycle+0x64>
				cli();
    c920:	f8 94       	cli
				EMeter_ReInit();
    c922:	0e 94 b2 4b 	call	0x9764	; 0x9764 <EMeter_ReInit>
				UART_Soft = 0;
    c926:	10 92 75 0a 	sts	0x0A75, r1
				ModbusMode = 0;				
    c92a:	10 92 e0 03 	sts	0x03E0, r1
				GSM_DebugMode = 0;	
    c92e:	10 92 f2 09 	sts	0x09F2, r1
    c932:	10 c0       	rjmp	.+32     	; 0xc954 <USART_Cycle+0x56>
			}
		}
	}
	else{
	//	EMeter_Cycle();
		if(!(PINA & (1<<PA0))){
    c934:	c8 99       	sbic	0x19, 0	; 25
    c936:	10 c0       	rjmp	.+32     	; 0xc958 <USART_Cycle+0x5a>
			if(Timer8Stopp(TD_UART_Soft)){
    c938:	80 91 4c 09 	lds	r24, 0x094C
    c93c:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    c940:	88 23       	and	r24, r24
    c942:	79 f0       	breq	.+30     	; 0xc962 <USART_Cycle+0x64>
				//if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
				cli();
    c944:	f8 94       	cli
				MB_Init();
    c946:	0e 94 96 35 	call	0x6b2c	; 0x6b2c <MB_Init>
				UART_Soft = 1;
    c94a:	81 e0       	ldi	r24, 0x01	; 1
    c94c:	80 93 75 0a 	sts	0x0A75, r24
				ModbusMode = 1;
    c950:	80 93 e0 03 	sts	0x03E0, r24
				sei();
    c954:	78 94       	sei
    c956:	05 c0       	rjmp	.+10     	; 0xc962 <USART_Cycle+0x64>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
    c958:	6a e0       	ldi	r22, 0x0A	; 10
    c95a:	80 91 4c 09 	lds	r24, 0x094C
    c95e:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
    c962:	0c 94 26 58 	jmp	0xb04c	; 0xb04c <GSM_Cycle>

0000c966 <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    c966:	2f 92       	push	r2
    c968:	3f 92       	push	r3
    c96a:	4f 92       	push	r4
    c96c:	5f 92       	push	r5
    c96e:	6f 92       	push	r6
    c970:	7f 92       	push	r7
    c972:	8f 92       	push	r8
    c974:	9f 92       	push	r9
    c976:	af 92       	push	r10
    c978:	bf 92       	push	r11
    c97a:	cf 92       	push	r12
    c97c:	df 92       	push	r13
    c97e:	ef 92       	push	r14
    c980:	ff 92       	push	r15
    c982:	0f 93       	push	r16
    c984:	1f 93       	push	r17
    c986:	cf 93       	push	r28
    c988:	df 93       	push	r29
    c98a:	cd b7       	in	r28, 0x3d	; 61
    c98c:	de b7       	in	r29, 0x3e	; 62
    c98e:	2c 97       	sbiw	r28, 0x0c	; 12
    c990:	0f b6       	in	r0, 0x3f	; 63
    c992:	f8 94       	cli
    c994:	de bf       	out	0x3e, r29	; 62
    c996:	0f be       	out	0x3f, r0	; 63
    c998:	cd bf       	out	0x3d, r28	; 61
    c99a:	8c 01       	movw	r16, r24
    c99c:	b6 2e       	mov	r11, r22
	}
	else{
		StartTimeoutWaitRequest = 0;
	}

}
    c99e:	2d b6       	in	r2, 0x3d	; 61
    c9a0:	3e b6       	in	r3, 0x3e	; 62
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	//static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    c9a2:	f0 90 1c 06 	lds	r15, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    c9a6:	0e 94 0d 2a 	call	0x541a	; 0x541a <IntOff>
	uint32_t Time = Timer32[TimerN];
    c9aa:	24 e0       	ldi	r18, 0x04	; 4
    c9ac:	f2 9e       	mul	r15, r18
    c9ae:	f0 01       	movw	r30, r0
    c9b0:	11 24       	eor	r1, r1
    c9b2:	ea 57       	subi	r30, 0x7A	; 122
    c9b4:	fd 4f       	sbci	r31, 0xFD	; 253
    c9b6:	c0 80       	ld	r12, Z
    c9b8:	d1 80       	ldd	r13, Z+1	; 0x01
    c9ba:	e2 80       	ldd	r14, Z+2	; 0x02
    c9bc:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    c9be:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOn>
    c9c2:	38 ec       	ldi	r19, 0xC8	; 200
    c9c4:	c3 16       	cp	r12, r19
    c9c6:	d1 04       	cpc	r13, r1
    c9c8:	e1 04       	cpc	r14, r1
    c9ca:	f1 04       	cpc	r15, r1
    c9cc:	38 f4       	brcc	.+14     	; 0xc9dc <WebServer+0x76>
    c9ce:	4f ef       	ldi	r20, 0xFF	; 255
    c9d0:	5f ef       	ldi	r21, 0xFF	; 255
    c9d2:	ba 01       	movw	r22, r20
    c9d4:	80 91 1c 06 	lds	r24, 0x061C
    c9d8:	0e 94 0d 2c 	call	0x581a	; 0x581a <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    c9dc:	80 91 68 09 	lds	r24, 0x0968
    c9e0:	0e 94 8e 2c 	call	0x591c	; 0x591c <Timer32Stopp>
    c9e4:	81 11       	cpse	r24, r1
    c9e6:	10 92 7e 09 	sts	0x097E, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    c9ea:	80 91 27 06 	lds	r24, 0x0627
    c9ee:	82 36       	cpi	r24, 0x62	; 98
    c9f0:	09 f0       	breq	.+2      	; 0xc9f4 <WebServer+0x8e>
    c9f2:	e1 c3       	rjmp	.+1986   	; 0xd1b6 <WebServer+0x850>
    c9f4:	80 91 f4 09 	lds	r24, 0x09F4
    c9f8:	81 30       	cpi	r24, 0x01	; 1
    c9fa:	09 f0       	breq	.+2      	; 0xc9fe <WebServer+0x98>
    c9fc:	dc c3       	rjmp	.+1976   	; 0xd1b6 <WebServer+0x850>
		
		// 
		if(WebMode == 254){
    c9fe:	80 91 06 01 	lds	r24, 0x0106
    ca02:	8e 3f       	cpi	r24, 0xFE	; 254
    ca04:	71 f5       	brne	.+92     	; 0xca62 <WebServer+0xfc>
			ptrPage = WebRequest(ptrSite, SiteSize);
    ca06:	6b 2d       	mov	r22, r11
    ca08:	c8 01       	movw	r24, r16
    ca0a:	0e 94 d9 48 	call	0x91b2	; 0x91b2 <WebRequest>
    ca0e:	90 93 40 02 	sts	0x0240, r25
    ca12:	80 93 3f 02 	sts	0x023F, r24
			if(ptrPage != NULL){
    ca16:	89 2b       	or	r24, r25
    ca18:	41 f0       	breq	.+16     	; 0xca2a <WebServer+0xc4>
				WebMode = 255;
    ca1a:	8f ef       	ldi	r24, 0xFF	; 255
    ca1c:	80 93 06 01 	sts	0x0106, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    ca20:	64 e1       	ldi	r22, 0x14	; 20
    ca22:	80 91 44 09 	lds	r24, 0x0944
    ca26:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    ca2a:	80 91 3e 02 	lds	r24, 0x023E
    ca2e:	88 23       	and	r24, r24
    ca30:	79 f0       	breq	.+30     	; 0xca50 <WebServer+0xea>
				if(Timer16Stopp(TD_WaitReqTimout)){
    ca32:	80 91 6a 09 	lds	r24, 0x096A
    ca36:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    ca3a:	88 23       	and	r24, r24
    ca3c:	91 f0       	breq	.+36     	; 0xca62 <WebServer+0xfc>
					GSM_State = GSM_Swtch2CommandMode;
    ca3e:	83 e6       	ldi	r24, 0x63	; 99
    ca40:	80 93 27 06 	sts	0x0627, r24
					Web_POST = 0;
    ca44:	10 92 6d 09 	sts	0x096D, r1
					WebMode = 254;
    ca48:	8e ef       	ldi	r24, 0xFE	; 254
    ca4a:	80 93 06 01 	sts	0x0106, r24
					return;				
    ca4e:	b5 c3       	rjmp	.+1898   	; 0xd1ba <WebServer+0x854>
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    ca50:	68 ee       	ldi	r22, 0xE8	; 232
    ca52:	73 e0       	ldi	r23, 0x03	; 3
    ca54:	80 91 6a 09 	lds	r24, 0x096A
    ca58:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				StartTimeoutWaitRequest = 1;
    ca5c:	81 e0       	ldi	r24, 0x01	; 1
    ca5e:	80 93 3e 02 	sts	0x023E, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    ca62:	80 91 08 01 	lds	r24, 0x0108
    ca66:	80 ff       	sbrs	r24, 0
    ca68:	a8 c3       	rjmp	.+1872   	; 0xd1ba <WebServer+0x854>
    ca6a:	80 91 4f 09 	lds	r24, 0x094F
    ca6e:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    ca72:	88 23       	and	r24, r24
    ca74:	09 f4       	brne	.+2      	; 0xca78 <WebServer+0x112>
    ca76:	a1 c3       	rjmp	.+1858   	; 0xd1ba <WebServer+0x854>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    ca78:	80 91 06 01 	lds	r24, 0x0106
    ca7c:	8f 3f       	cpi	r24, 0xFF	; 255
    ca7e:	39 f4       	brne	.+14     	; 0xca8e <WebServer+0x128>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    ca80:	80 91 44 09 	lds	r24, 0x0944
    ca84:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    ca88:	81 11       	cpse	r24, r1
					WebMode = 0;
    ca8a:	10 92 06 01 	sts	0x0106, r1
				}
			}

			// 
			if(WebMode == 2){
    ca8e:	80 91 06 01 	lds	r24, 0x0106
    ca92:	82 30       	cpi	r24, 0x02	; 2
    ca94:	59 f4       	brne	.+22     	; 0xcaac <WebServer+0x146>
				GSM_State = GSM_Swtch2CommandMode;
    ca96:	83 e6       	ldi	r24, 0x63	; 99
    ca98:	80 93 27 06 	sts	0x0627, r24
				WebMode = 254;
    ca9c:	8e ef       	ldi	r24, 0xFE	; 254
    ca9e:	80 93 06 01 	sts	0x0106, r24
				Web_Login_Code = 0;
    caa2:	10 92 09 06 	sts	0x0609, r1
				Web_POST = 0;
    caa6:	10 92 6d 09 	sts	0x096D, r1
				return;
    caaa:	87 c3       	rjmp	.+1806   	; 0xd1ba <WebServer+0x854>
			}
			
			//   
			if(WebMode == 0){
    caac:	81 11       	cpse	r24, r1
    caae:	df c0       	rjmp	.+446    	; 0xcc6e <WebServer+0x308>
				//Not Found
				if(ptrPage == &Web_error_page){
    cab0:	80 91 3f 02 	lds	r24, 0x023F
    cab4:	90 91 40 02 	lds	r25, 0x0240
    cab8:	88 5b       	subi	r24, 0xB8	; 184
    caba:	9b 44       	sbci	r25, 0x4B	; 75
    cabc:	b9 f4       	brne	.+46     	; 0xcaec <WebServer+0x186>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    cabe:	44 e7       	ldi	r20, 0x74	; 116
    cac0:	50 e0       	ldi	r21, 0x00	; 0
    cac2:	65 ec       	ldi	r22, 0xC5	; 197
    cac4:	7b e4       	ldi	r23, 0x4B	; 75
    cac6:	89 e3       	ldi	r24, 0x39	; 57
    cac8:	9c e0       	ldi	r25, 0x0C	; 12
    caca:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    cace:	84 e7       	ldi	r24, 0x74	; 116
    cad0:	80 93 57 09 	sts	0x0957, r24
					GSM_SendFirstChar();
    cad4:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    cad8:	68 ec       	ldi	r22, 0xC8	; 200
    cada:	70 e0       	ldi	r23, 0x00	; 0
    cadc:	80 91 4f 09 	lds	r24, 0x094F
    cae0:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
					WebMode = 2;
    cae4:	82 e0       	ldi	r24, 0x02	; 2
    cae6:	80 93 06 01 	sts	0x0106, r24
    caea:	c1 c0       	rjmp	.+386    	; 0xcc6e <WebServer+0x308>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    caec:	41 e1       	ldi	r20, 0x11	; 17
    caee:	50 e0       	ldi	r21, 0x00	; 0
    caf0:	61 ee       	ldi	r22, 0xE1	; 225
    caf2:	7c e4       	ldi	r23, 0x4C	; 76
    caf4:	89 e3       	ldi	r24, 0x39	; 57
    caf6:	9c e0       	ldi	r25, 0x0C	; 12
    caf8:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    cafc:	4e e0       	ldi	r20, 0x0E	; 14
    cafe:	50 e0       	ldi	r21, 0x00	; 0
    cb00:	62 ed       	ldi	r22, 0xD2	; 210
    cb02:	7c e4       	ldi	r23, 0x4C	; 76
    cb04:	8a e4       	ldi	r24, 0x4A	; 74
    cb06:	9c e0       	ldi	r25, 0x0C	; 12
    cb08:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cb0c:	e0 91 3f 02 	lds	r30, 0x023F
    cb10:	f0 91 40 02 	lds	r31, 0x0240
    cb14:	85 91       	lpm	r24, Z+
    cb16:	94 91       	lpm	r25, Z
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    cb18:	6e e2       	ldi	r22, 0x2E	; 46
    cb1a:	70 e0       	ldi	r23, 0x00	; 0
    cb1c:	0e 94 bc 6b 	call	0xd778	; 0xd778 <strchr_P>
					if(ext_point_ptr){ 
    cb20:	00 97       	sbiw	r24, 0x00	; 0
    cb22:	09 f4       	brne	.+2      	; 0xcb26 <WebServer+0x1c0>
    cb24:	89 c0       	rjmp	.+274    	; 0xcc38 <WebServer+0x2d2>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    cb26:	7c 01       	movw	r14, r24
    cb28:	5f ef       	ldi	r21, 0xFF	; 255
    cb2a:	e5 1a       	sub	r14, r21
    cb2c:	f5 0a       	sbc	r15, r21
    cb2e:	b7 01       	movw	r22, r14
    cb30:	81 e9       	ldi	r24, 0x91	; 145
    cb32:	9c e4       	ldi	r25, 0x4C	; 76
    cb34:	0e 94 53 47 	call	0x8ea6	; 0x8ea6 <strcmp_PP>
    cb38:	81 11       	cpse	r24, r1
    cb3a:	0b c0       	rjmp	.+22     	; 0xcb52 <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    cb3c:	41 e2       	ldi	r20, 0x21	; 33
    cb3e:	50 e0       	ldi	r21, 0x00	; 0
    cb40:	6d e9       	ldi	r22, 0x9D	; 157
    cb42:	7c e4       	ldi	r23, 0x4C	; 76
    cb44:	88 e5       	ldi	r24, 0x58	; 88
    cb46:	9c e0       	ldi	r25, 0x0C	; 12
    cb48:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
							i += sizeof(html_cp1251_str)-1;
    cb4c:	00 e4       	ldi	r16, 0x40	; 64
    cb4e:	10 e0       	ldi	r17, 0x00	; 0
    cb50:	67 c0       	rjmp	.+206    	; 0xcc20 <WebServer+0x2ba>
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    cb52:	46 e0       	ldi	r20, 0x06	; 6
    cb54:	50 e0       	ldi	r21, 0x00	; 0
    cb56:	66 e9       	ldi	r22, 0x96	; 150
    cb58:	7c e4       	ldi	r23, 0x4C	; 76
    cb5a:	88 e5       	ldi	r24, 0x58	; 88
    cb5c:	9c e0       	ldi	r25, 0x0C	; 12
    cb5e:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    cb62:	b7 01       	movw	r22, r14
    cb64:	8d e8       	ldi	r24, 0x8D	; 141
    cb66:	9c e4       	ldi	r25, 0x4C	; 76
    cb68:	0e 94 53 47 	call	0x8ea6	; 0x8ea6 <strcmp_PP>
    cb6c:	81 11       	cpse	r24, r1
    cb6e:	0b c0       	rjmp	.+22     	; 0xcb86 <WebServer+0x220>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    cb70:	43 e0       	ldi	r20, 0x03	; 3
    cb72:	50 e0       	ldi	r21, 0x00	; 0
    cb74:	6d e8       	ldi	r22, 0x8D	; 141
    cb76:	7c e4       	ldi	r23, 0x4C	; 76
    cb78:	8e e5       	ldi	r24, 0x5E	; 94
    cb7a:	9c e0       	ldi	r25, 0x0C	; 12
    cb7c:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
								i += sizeof(ico_str)-1;
    cb80:	08 e2       	ldi	r16, 0x28	; 40
    cb82:	10 e0       	ldi	r17, 0x00	; 0
    cb84:	02 c0       	rjmp	.+4      	; 0xcb8a <WebServer+0x224>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
							i += sizeof(image_str)-1;
    cb86:	05 e2       	ldi	r16, 0x25	; 37
    cb88:	10 e0       	ldi	r17, 0x00	; 0
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    cb8a:	b7 01       	movw	r22, r14
    cb8c:	89 e8       	ldi	r24, 0x89	; 137
    cb8e:	9c e4       	ldi	r25, 0x4C	; 76
    cb90:	0e 94 53 47 	call	0x8ea6	; 0x8ea6 <strcmp_PP>
    cb94:	81 11       	cpse	r24, r1
    cb96:	0b c0       	rjmp	.+22     	; 0xcbae <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    cb98:	43 e0       	ldi	r20, 0x03	; 3
    cb9a:	50 e0       	ldi	r21, 0x00	; 0
    cb9c:	69 e8       	ldi	r22, 0x89	; 137
    cb9e:	7c e4       	ldi	r23, 0x4C	; 76
    cba0:	c8 01       	movw	r24, r16
    cba2:	87 5c       	subi	r24, 0xC7	; 199
    cba4:	93 4f       	sbci	r25, 0xF3	; 243
    cba6:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
								i += sizeof(gif_str)-1;								
    cbaa:	0d 5f       	subi	r16, 0xFD	; 253
    cbac:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    cbae:	b7 01       	movw	r22, r14
    cbb0:	84 e8       	ldi	r24, 0x84	; 132
    cbb2:	9c e4       	ldi	r25, 0x4C	; 76
    cbb4:	0e 94 53 47 	call	0x8ea6	; 0x8ea6 <strcmp_PP>
    cbb8:	81 11       	cpse	r24, r1
    cbba:	0b c0       	rjmp	.+22     	; 0xcbd2 <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    cbbc:	44 e0       	ldi	r20, 0x04	; 4
    cbbe:	50 e0       	ldi	r21, 0x00	; 0
    cbc0:	64 e8       	ldi	r22, 0x84	; 132
    cbc2:	7c e4       	ldi	r23, 0x4C	; 76
    cbc4:	c8 01       	movw	r24, r16
    cbc6:	87 5c       	subi	r24, 0xC7	; 199
    cbc8:	93 4f       	sbci	r25, 0xF3	; 243
    cbca:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    cbce:	0c 5f       	subi	r16, 0xFC	; 252
    cbd0:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    cbd2:	42 e1       	ldi	r20, 0x12	; 18
    cbd4:	50 e0       	ldi	r21, 0x00	; 0
    cbd6:	6f eb       	ldi	r22, 0xBF	; 191
    cbd8:	7c e4       	ldi	r23, 0x4C	; 76
    cbda:	c8 01       	movw	r24, r16
    cbdc:	87 5c       	subi	r24, 0xC7	; 199
    cbde:	93 4f       	sbci	r25, 0xF3	; 243
    cbe0:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
							i += sizeof(Content_Length)-1;
    cbe4:	0e 5e       	subi	r16, 0xEE	; 238
    cbe6:	1f 4f       	sbci	r17, 0xFF	; 255
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    cbe8:	e0 91 3f 02 	lds	r30, 0x023F
    cbec:	f0 91 40 02 	lds	r31, 0x0240
    cbf0:	38 96       	adiw	r30, 0x08	; 8

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cbf2:	85 91       	lpm	r24, Z+
    cbf4:	94 91       	lpm	r25, Z
    cbf6:	9f 93       	push	r25
    cbf8:	8f 93       	push	r24
    cbfa:	89 e0       	ldi	r24, 0x09	; 9
    cbfc:	93 e0       	ldi	r25, 0x03	; 3
    cbfe:	9f 93       	push	r25
    cc00:	8f 93       	push	r24
    cc02:	c8 01       	movw	r24, r16
    cc04:	87 5c       	subi	r24, 0xC7	; 199
    cc06:	93 4f       	sbci	r25, 0xF3	; 243
    cc08:	9f 93       	push	r25
    cc0a:	8f 93       	push	r24
    cc0c:	0e 94 7d 6c 	call	0xd8fa	; 0xd8fa <sprintf_P>
    cc10:	08 0f       	add	r16, r24
    cc12:	19 1f       	adc	r17, r25
    cc14:	0f 90       	pop	r0
    cc16:	0f 90       	pop	r0
    cc18:	0f 90       	pop	r0
    cc1a:	0f 90       	pop	r0
    cc1c:	0f 90       	pop	r0
    cc1e:	0f 90       	pop	r0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    cc20:	45 e1       	ldi	r20, 0x15	; 21
    cc22:	50 e0       	ldi	r21, 0x00	; 0
    cc24:	6e e6       	ldi	r22, 0x6E	; 110
    cc26:	7c e4       	ldi	r23, 0x4C	; 76
    cc28:	c8 01       	movw	r24, r16
    cc2a:	87 5c       	subi	r24, 0xC7	; 199
    cc2c:	93 4f       	sbci	r25, 0xF3	; 243
    cc2e:	0e 94 b3 6b 	call	0xd766	; 0xd766 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    cc32:	0b 5e       	subi	r16, 0xEB	; 235
    cc34:	1f 4f       	sbci	r17, 0xFF	; 255
    cc36:	02 c0       	rjmp	.+4      	; 0xcc3c <WebServer+0x2d6>
					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
					i += sizeof(Content_Type)-1;
    cc38:	0f e1       	ldi	r16, 0x1F	; 31
    cc3a:	10 e0       	ldi	r17, 0x00	; 0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
						i += sizeof(Connection_Close)-1;

					}
					WebDataCnt = 0;
    cc3c:	10 92 f1 03 	sts	0x03F1, r1
    cc40:	10 92 f0 03 	sts	0x03F0, r1
					WebInputHiddenCnt = 0;
    cc44:	10 92 e9 03 	sts	0x03E9, r1
					WebHrefHiddenCnt = 0;
    cc48:	10 92 28 06 	sts	0x0628, r1
					WebImgSrcHiddenCnt = 0;
    cc4c:	10 92 e8 03 	sts	0x03E8, r1
					ptrIF = prp(&ptrPage->IF_List);
    cc50:	e0 91 3f 02 	lds	r30, 0x023F
    cc54:	f0 91 40 02 	lds	r31, 0x0240
    cc58:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cc5a:	85 91       	lpm	r24, Z+
    cc5c:	94 91       	lpm	r25, Z
    cc5e:	90 93 3d 02 	sts	0x023D, r25
    cc62:	80 93 3c 02 	sts	0x023C, r24
					WebMode = 1;
    cc66:	81 e0       	ldi	r24, 0x01	; 1
    cc68:	80 93 06 01 	sts	0x0106, r24
    cc6c:	02 c0       	rjmp	.+4      	; 0xcc72 <WebServer+0x30c>


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){

			uint16_t i=0;
    cc6e:	00 e0       	ldi	r16, 0x00	; 0
    cc70:	10 e0       	ldi	r17, 0x00	; 0
					WebMode = 1;
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    cc72:	80 91 06 01 	lds	r24, 0x0106
    cc76:	81 30       	cpi	r24, 0x01	; 1
    cc78:	09 f0       	breq	.+2      	; 0xcc7c <WebServer+0x316>
    cc7a:	9f c2       	rjmp	.+1342   	; 0xd1ba <WebServer+0x854>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    cc7c:	bb 24       	eor	r11, r11
    cc7e:	b3 94       	inc	r11
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    cc80:	0f 3f       	cpi	r16, 0xFF	; 255
    cc82:	11 05       	cpc	r17, r1
    cc84:	08 f0       	brcs	.+2      	; 0xcc88 <WebServer+0x322>
    cc86:	b0 c0       	rjmp	.+352    	; 0xcde8 <WebServer+0x482>
					char ch;
					if(WebImgSrcHiddenCnt){
    cc88:	80 91 e8 03 	lds	r24, 0x03E8
    cc8c:	c0 90 3f 02 	lds	r12, 0x023F
    cc90:	d0 90 40 02 	lds	r13, 0x0240
    cc94:	88 23       	and	r24, r24
    cc96:	a1 f0       	breq	.+40     	; 0xccc0 <WebServer+0x35a>
    cc98:	e8 2f       	mov	r30, r24
    cc9a:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    cc9c:	89 30       	cpi	r24, 0x09	; 9
    cc9e:	20 f0       	brcs	.+8      	; 0xcca8 <WebServer+0x342>
    cca0:	e0 5e       	subi	r30, 0xE0	; 224
    cca2:	f9 4f       	sbci	r31, 0xF9	; 249
    cca4:	a0 80       	ld	r10, Z
    cca6:	03 c0       	rjmp	.+6      	; 0xccae <WebServer+0x348>
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
    cca8:	e7 5c       	subi	r30, 0xC7	; 199
    ccaa:	f3 4b       	sbci	r31, 0xB3	; 179

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ccac:	a4 90       	lpm	r10, Z
						WebImgSrcHiddenCnt++ ;
    ccae:	8f 5f       	subi	r24, 0xFF	; 255
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    ccb0:	89 31       	cpi	r24, 0x19	; 25
    ccb2:	18 f4       	brcc	.+6      	; 0xccba <WebServer+0x354>
					char ch;
					if(WebImgSrcHiddenCnt){
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    ccb4:	80 93 e8 03 	sts	0x03E8, r24
    ccb8:	46 c0       	rjmp	.+140    	; 0xcd46 <WebServer+0x3e0>
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    ccba:	10 92 e8 03 	sts	0x03E8, r1
    ccbe:	43 c0       	rjmp	.+134    	; 0xcd46 <WebServer+0x3e0>
					}
					else{
						if(WebHrefHiddenCnt){
    ccc0:	80 91 28 06 	lds	r24, 0x0628
    ccc4:	88 23       	and	r24, r24
    ccc6:	a1 f0       	breq	.+40     	; 0xccf0 <WebServer+0x38a>
    ccc8:	e8 2f       	mov	r30, r24
    ccca:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    cccc:	89 30       	cpi	r24, 0x09	; 9
    ccce:	20 f0       	brcs	.+8      	; 0xccd8 <WebServer+0x372>
    ccd0:	e0 5e       	subi	r30, 0xE0	; 224
    ccd2:	f9 4f       	sbci	r31, 0xF9	; 249
    ccd4:	a0 80       	ld	r10, Z
    ccd6:	03 c0       	rjmp	.+6      	; 0xccde <WebServer+0x378>
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
    ccd8:	e7 5c       	subi	r30, 0xC7	; 199
    ccda:	f3 4b       	sbci	r31, 0xB3	; 179
    ccdc:	a4 90       	lpm	r10, Z
							WebHrefHiddenCnt++ ;
    ccde:	8f 5f       	subi	r24, 0xFF	; 255
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    cce0:	89 31       	cpi	r24, 0x19	; 25
    cce2:	18 f4       	brcc	.+6      	; 0xccea <WebServer+0x384>
					else{
						if(WebHrefHiddenCnt){
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    cce4:	80 93 28 06 	sts	0x0628, r24
    cce8:	2e c0       	rjmp	.+92     	; 0xcd46 <WebServer+0x3e0>
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    ccea:	10 92 28 06 	sts	0x0628, r1
    ccee:	2b c0       	rjmp	.+86     	; 0xcd46 <WebServer+0x3e0>
						}
						else{
							if(WebInputHiddenCnt){
    ccf0:	80 91 e9 03 	lds	r24, 0x03E9
    ccf4:	88 23       	and	r24, r24
    ccf6:	a1 f0       	breq	.+40     	; 0xcd20 <WebServer+0x3ba>
    ccf8:	e8 2f       	mov	r30, r24
    ccfa:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    ccfc:	8b 32       	cpi	r24, 0x2B	; 43
    ccfe:	20 f0       	brcs	.+8      	; 0xcd08 <WebServer+0x3a2>
    cd00:	e2 50       	subi	r30, 0x02	; 2
    cd02:	fa 4f       	sbci	r31, 0xFA	; 250
    cd04:	a0 80       	ld	r10, Z
    cd06:	03 c0       	rjmp	.+6      	; 0xcd0e <WebServer+0x3a8>
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
    cd08:	ee 5b       	subi	r30, 0xBE	; 190
    cd0a:	f3 4b       	sbci	r31, 0xB3	; 179
    cd0c:	a4 90       	lpm	r10, Z
								WebInputHiddenCnt++ ;
    cd0e:	8f 5f       	subi	r24, 0xFF	; 255
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    cd10:	8e 33       	cpi	r24, 0x3E	; 62
    cd12:	18 f4       	brcc	.+6      	; 0xcd1a <WebServer+0x3b4>
						else{
							if(WebInputHiddenCnt){
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    cd14:	80 93 e9 03 	sts	0x03E9, r24
    cd18:	16 c0       	rjmp	.+44     	; 0xcd46 <WebServer+0x3e0>
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    cd1a:	10 92 e9 03 	sts	0x03E9, r1
    cd1e:	13 c0       	rjmp	.+38     	; 0xcd46 <WebServer+0x3e0>
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    cd20:	f6 01       	movw	r30, r12
    cd22:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cd24:	25 91       	lpm	r18, Z+
    cd26:	34 91       	lpm	r19, Z
    cd28:	80 91 f0 03 	lds	r24, 0x03F0
    cd2c:	90 91 f1 03 	lds	r25, 0x03F1
    cd30:	ac 01       	movw	r20, r24
    cd32:	4f 5f       	subi	r20, 0xFF	; 255
    cd34:	5f 4f       	sbci	r21, 0xFF	; 255
    cd36:	50 93 f1 03 	sts	0x03F1, r21
    cd3a:	40 93 f0 03 	sts	0x03F0, r20
    cd3e:	f9 01       	movw	r30, r18
    cd40:	e8 0f       	add	r30, r24
    cd42:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cd44:	a4 90       	lpm	r10, Z
							}
						}
					}

					GSM_TxStr[i++] = ch;
    cd46:	78 01       	movw	r14, r16
    cd48:	8f ef       	ldi	r24, 0xFF	; 255
    cd4a:	e8 1a       	sub	r14, r24
    cd4c:	f8 0a       	sbc	r15, r24
    cd4e:	d8 01       	movw	r26, r16
    cd50:	a7 5c       	subi	r26, 0xC7	; 199
    cd52:	b3 4f       	sbci	r27, 0xF3	; 243
    cd54:	ac 92       	st	X, r10
					if(ptrPage != &Web_login){	//  login.html   !
    cd56:	91 e9       	ldi	r25, 0x91	; 145
    cd58:	c9 16       	cp	r12, r25
    cd5a:	98 e4       	ldi	r25, 0x48	; 72
    cd5c:	d9 06       	cpc	r13, r25
    cd5e:	59 f1       	breq	.+86     	; 0xcdb6 <WebServer+0x450>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    cd60:	8a 2d       	mov	r24, r10
    cd62:	0e 94 95 47 	call	0x8f2a	; 0x8f2a <SeekTagFORM>
    cd66:	81 11       	cpse	r24, r1
    cd68:	b0 92 e9 03 	sts	0x03E9, r11
						if(SeekTagA_HREF(ch)){ 
    cd6c:	8a 2d       	mov	r24, r10
    cd6e:	0e 94 d1 47 	call	0x8fa2	; 0x8fa2 <SeekTagA_HREF>
    cd72:	88 23       	and	r24, r24
    cd74:	69 f0       	breq	.+26     	; 0xcd90 <WebServer+0x42a>
							WebHrefHiddenCnt = 1;
    cd76:	b0 92 28 06 	sts	0x0628, r11
							i--;
							WebDataCnt--;
    cd7a:	20 91 f0 03 	lds	r18, 0x03F0
    cd7e:	30 91 f1 03 	lds	r19, 0x03F1
    cd82:	21 50       	subi	r18, 0x01	; 1
    cd84:	31 09       	sbc	r19, r1
    cd86:	30 93 f1 03 	sts	0x03F1, r19
    cd8a:	20 93 f0 03 	sts	0x03F0, r18
    cd8e:	78 01       	movw	r14, r16
						}
						if(SeekTagIMG_SRC(ch)){ 
    cd90:	8a 2d       	mov	r24, r10
    cd92:	0e 94 0d 48 	call	0x901a	; 0x901a <SeekTagIMG_SRC>
    cd96:	88 23       	and	r24, r24
    cd98:	71 f0       	breq	.+28     	; 0xcdb6 <WebServer+0x450>
							WebImgSrcHiddenCnt = 1;
    cd9a:	b0 92 e8 03 	sts	0x03E8, r11
							i--;
    cd9e:	e1 e0       	ldi	r30, 0x01	; 1
    cda0:	ee 1a       	sub	r14, r30
    cda2:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    cda4:	80 91 f0 03 	lds	r24, 0x03F0
    cda8:	90 91 f1 03 	lds	r25, 0x03F1
    cdac:	01 97       	sbiw	r24, 0x01	; 1
    cdae:	90 93 f1 03 	sts	0x03F1, r25
    cdb2:	80 93 f0 03 	sts	0x03F0, r24
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    cdb6:	f8 e0       	ldi	r31, 0x08	; 8
    cdb8:	cf 0e       	add	r12, r31
    cdba:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cdbc:	f6 01       	movw	r30, r12
    cdbe:	85 91       	lpm	r24, Z+
    cdc0:	94 91       	lpm	r25, Z
    cdc2:	20 91 f0 03 	lds	r18, 0x03F0
    cdc6:	30 91 f1 03 	lds	r19, 0x03F1
    cdca:	28 17       	cp	r18, r24
    cdcc:	39 07       	cpc	r19, r25
    cdce:	10 f4       	brcc	.+4      	; 0xcdd4 <WebServer+0x46e>
    cdd0:	87 01       	movw	r16, r14
    cdd2:	56 cf       	rjmp	.-340    	; 0xcc80 <WebServer+0x31a>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    cdd4:	68 ec       	ldi	r22, 0xC8	; 200
    cdd6:	70 e0       	ldi	r23, 0x00	; 0
    cdd8:	80 91 4f 09 	lds	r24, 0x094F
    cddc:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
						WebMode = 2;
    cde0:	82 e0       	ldi	r24, 0x02	; 2
    cde2:	80 93 06 01 	sts	0x0106, r24
						break;
    cde6:	87 01       	movw	r16, r14
					}
				}
				//
				if(ptrIF != NULL){
    cde8:	c0 90 3c 02 	lds	r12, 0x023C
    cdec:	d0 90 3d 02 	lds	r13, 0x023D
    cdf0:	c1 14       	cp	r12, r1
    cdf2:	d1 04       	cpc	r13, r1
    cdf4:	09 f4       	brne	.+2      	; 0xcdf8 <WebServer+0x492>
    cdf6:	be c1       	rjmp	.+892    	; 0xd174 <WebServer+0x80e>
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    cdf8:	e0 91 3f 02 	lds	r30, 0x023F
    cdfc:	f0 91 40 02 	lds	r31, 0x0240
    ce00:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce02:	25 91       	lpm	r18, Z+
    ce04:	34 91       	lpm	r19, Z
    ce06:	80 91 f0 03 	lds	r24, 0x03F0
    ce0a:	90 91 f1 03 	lds	r25, 0x03F1
    ce0e:	f9 01       	movw	r30, r18
    ce10:	e8 0f       	add	r30, r24
    ce12:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ce14:	24 91       	lpm	r18, Z
    ce16:	2b 37       	cpi	r18, 0x7B	; 123
    ce18:	a1 f4       	brne	.+40     	; 0xce42 <WebServer+0x4dc>
    ce1a:	80 1b       	sub	r24, r16
    ce1c:	91 0b       	sbc	r25, r17
    ce1e:	ac 01       	movw	r20, r24
    ce20:	40 0f       	add	r20, r16
    ce22:	51 1f       	adc	r21, r17
						while(GSM_TxStr[i-1] == '{'){
    ce24:	98 01       	movw	r18, r16
    ce26:	21 50       	subi	r18, 0x01	; 1
    ce28:	31 09       	sbc	r19, r1
    ce2a:	f9 01       	movw	r30, r18
    ce2c:	e7 5c       	subi	r30, 0xC7	; 199
    ce2e:	f3 4f       	sbci	r31, 0xF3	; 243
    ce30:	60 81       	ld	r22, Z
    ce32:	6b 37       	cpi	r22, 0x7B	; 123
    ce34:	11 f4       	brne	.+4      	; 0xce3a <WebServer+0x4d4>
							WebDataCnt--;
							i--;
    ce36:	89 01       	movw	r16, r18
    ce38:	f2 cf       	rjmp	.-28     	; 0xce1e <WebServer+0x4b8>
    ce3a:	50 93 f1 03 	sts	0x03F1, r21
    ce3e:	40 93 f0 03 	sts	0x03F0, r20
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    ce42:	0b 87       	std	Y+11, r16	; 0x0b
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    ce44:	61 2c       	mov	r6, r1
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    ce46:	aa 24       	eor	r10, r10
    ce48:	a3 94       	inc	r10
    ce4a:	b1 2c       	mov	r11, r1
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    ce4c:	5b e3       	ldi	r21, 0x3B	; 59
    ce4e:	45 2e       	mov	r4, r21
    ce50:	51 e0       	ldi	r21, 0x01	; 1
    ce52:	55 2e       	mov	r5, r21
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    ce54:	4b 85       	ldd	r20, Y+11	; 0x0b
    ce56:	64 16       	cp	r6, r20
    ce58:	08 f0       	brcs	.+2      	; 0xce5c <WebServer+0x4f6>
    ce5a:	88 c1       	rjmp	.+784    	; 0xd16c <WebServer+0x806>
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    ce5c:	e6 2c       	mov	r14, r6
    ce5e:	f1 2c       	mov	r15, r1
    ce60:	97 01       	movw	r18, r14
    ce62:	27 5c       	subi	r18, 0xC7	; 199
    ce64:	33 4f       	sbci	r19, 0xF3	; 243
    ce66:	79 01       	movw	r14, r18
    ce68:	3a 83       	std	Y+2, r19	; 0x02
    ce6a:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
    ce6c:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    ce6e:	f9 01       	movw	r30, r18
    ce70:	70 80       	ld	r7, Z
    ce72:	fb e7       	ldi	r31, 0x7B	; 123
    ce74:	7f 12       	cpse	r7, r31
    ce76:	6f c1       	rjmp	.+734    	; 0xd156 <WebServer+0x7f0>
    ce78:	80 e0       	ldi	r24, 0x00	; 0
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    ce7a:	8f 5f       	subi	r24, 0xFF	; 255
    ce7c:	48 2f       	mov	r20, r24
    ce7e:	50 e0       	ldi	r21, 0x00	; 0
    ce80:	f7 01       	movw	r30, r14
    ce82:	e4 0f       	add	r30, r20
    ce84:	f5 1f       	adc	r31, r21
    ce86:	70 80       	ld	r7, Z
    ce88:	2b e7       	ldi	r18, 0x7B	; 123
    ce8a:	72 16       	cp	r7, r18
    ce8c:	b1 f3       	breq	.-20     	; 0xce7a <WebServer+0x514>
    ce8e:	8c 83       	std	Y+4, r24	; 0x04
			Param.Prec = prb(&IF->Prec);
    ce90:	f6 01       	movw	r30, r12
    ce92:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ce94:	e4 91       	lpm	r30, Z
    ce96:	eb 83       	std	Y+3, r30	; 0x03
			Param.Txt = prp(&IF->EnumList);
    ce98:	f6 01       	movw	r30, r12
    ce9a:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce9c:	85 90       	lpm	r8, Z+
    ce9e:	94 90       	lpm	r9, Z
    cea0:	9e 82       	std	Y+6, r9	; 0x06
    cea2:	8d 82       	std	Y+5, r8	; 0x05
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    cea4:	f6 01       	movw	r30, r12
    cea6:	31 96       	adiw	r30, 0x01	; 1
    cea8:	a5 91       	lpm	r26, Z+
    ceaa:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    ceac:	f6 01       	movw	r30, r12
    ceae:	64 91       	lpm	r22, Z
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    ceb0:	70 e0       	ldi	r23, 0x00	; 0
    ceb2:	63 32       	cpi	r22, 0x23	; 35
    ceb4:	71 05       	cpc	r23, r1
    ceb6:	08 f0       	brcs	.+2      	; 0xceba <WebServer+0x554>
    ceb8:	4b c1       	rjmp	.+662    	; 0xd150 <WebServer+0x7ea>
    ceba:	fb 01       	movw	r30, r22
    cebc:	ec 5b       	subi	r30, 0xBC	; 188
    cebe:	fe 4f       	sbci	r31, 0xFE	; 254
    cec0:	0c 94 0e 75 	jmp	0xea1c	; 0xea1c <__tablejump2__>
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    cec4:	8c 91       	ld	r24, X
    cec6:	03 c0       	rjmp	.+6      	; 0xcece <WebServer+0x568>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    cec8:	cd 01       	movw	r24, r26
    ceca:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    cece:	ae 01       	movw	r20, r28
    ced0:	4f 5f       	subi	r20, 0xFF	; 255
    ced2:	5f 4f       	sbci	r21, 0xFF	; 255
    ced4:	62 e6       	ldi	r22, 0x62	; 98
    ced6:	90 e0       	ldi	r25, 0x00	; 0
    ced8:	0e 94 9b 3e 	call	0x7d36	; 0x7d36 <PutVal>
    cedc:	39 c1       	rjmp	.+626    	; 0xd150 <WebServer+0x7ea>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    cede:	8c 91       	ld	r24, X
    cee0:	03 c0       	rjmp	.+6      	; 0xcee8 <WebServer+0x582>
    cee2:	cd 01       	movw	r24, r26
    cee4:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    cee8:	ae 01       	movw	r20, r28
    ceea:	4f 5f       	subi	r20, 0xFF	; 255
    ceec:	5f 4f       	sbci	r21, 0xFF	; 255
    ceee:	62 e6       	ldi	r22, 0x62	; 98
    cef0:	99 27       	eor	r25, r25
    cef2:	87 fd       	sbrc	r24, 7
    cef4:	90 95       	com	r25
    cef6:	0e 94 16 3f 	call	0x7e2c	; 0x7e2c <Put_sVal>
    cefa:	2a c1       	rjmp	.+596    	; 0xd150 <WebServer+0x7ea>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    cefc:	8c 91       	ld	r24, X
    cefe:	03 c0       	rjmp	.+6      	; 0xcf06 <WebServer+0x5a0>
    cf00:	cd 01       	movw	r24, r26
    cf02:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    cf06:	ae 01       	movw	r20, r28
    cf08:	4f 5f       	subi	r20, 0xFF	; 255
    cf0a:	5f 4f       	sbci	r21, 0xFF	; 255
    cf0c:	62 e6       	ldi	r22, 0x62	; 98
    cf0e:	90 e0       	ldi	r25, 0x00	; 0
    cf10:	0e 94 c0 3f 	call	0x7f80	; 0x7f80 <Put_zVal>
    cf14:	1d c1       	rjmp	.+570    	; 0xd150 <WebServer+0x7ea>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    cf16:	6c 91       	ld	r22, X
    cf18:	70 e0       	ldi	r23, 0x00	; 0
    cf1a:	80 e0       	ldi	r24, 0x00	; 0
    cf1c:	90 e0       	ldi	r25, 0x00	; 0
    cf1e:	9e 01       	movw	r18, r28
    cf20:	2f 5f       	subi	r18, 0xFF	; 255
    cf22:	3f 4f       	sbci	r19, 0xFF	; 255
    cf24:	42 e6       	ldi	r20, 0x62	; 98
    cf26:	08 c0       	rjmp	.+16     	; 0xcf38 <WebServer+0x5d2>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    cf28:	6d 91       	ld	r22, X+
    cf2a:	7c 91       	ld	r23, X
    cf2c:	80 e0       	ldi	r24, 0x00	; 0
    cf2e:	90 e0       	ldi	r25, 0x00	; 0
    cf30:	9e 01       	movw	r18, r28
    cf32:	2f 5f       	subi	r18, 0xFF	; 255
    cf34:	3f 4f       	sbci	r19, 0xFF	; 255
    cf36:	47 e7       	ldi	r20, 0x77	; 119
    cf38:	0e 94 3b 40 	call	0x8076	; 0x8076 <Put_zVal_h>
    cf3c:	09 c1       	rjmp	.+530    	; 0xd150 <WebServer+0x7ea>
    cf3e:	13 96       	adiw	r26, 0x03	; 3
    cf40:	8c 91       	ld	r24, X
    cf42:	13 97       	sbiw	r26, 0x03	; 3
    cf44:	8f 93       	push	r24
    cf46:	12 96       	adiw	r26, 0x02	; 2
    cf48:	8c 91       	ld	r24, X
    cf4a:	12 97       	sbiw	r26, 0x02	; 2
    cf4c:	8f 93       	push	r24
    cf4e:	11 96       	adiw	r26, 0x01	; 1
    cf50:	8c 91       	ld	r24, X
    cf52:	11 97       	sbiw	r26, 0x01	; 1
    cf54:	8f 93       	push	r24
    cf56:	8c 91       	ld	r24, X
    cf58:	8f 93       	push	r24
    cf5a:	5f 92       	push	r5
    cf5c:	4f 92       	push	r4
    cf5e:	ff 92       	push	r15
    cf60:	ef 92       	push	r14
    cf62:	0e 94 4e 6c 	call	0xd89c	; 0xd89c <sprintf>
    cf66:	2d b7       	in	r18, 0x3d	; 61
    cf68:	3e b7       	in	r19, 0x3e	; 62
    cf6a:	28 5f       	subi	r18, 0xF8	; 248
    cf6c:	3f 4f       	sbci	r19, 0xFF	; 255
    cf6e:	0f b6       	in	r0, 0x3f	; 63
    cf70:	f8 94       	cli
    cf72:	3e bf       	out	0x3e, r19	; 62
    cf74:	0f be       	out	0x3f, r0	; 63
    cf76:	2d bf       	out	0x3d, r18	; 61
    cf78:	eb c0       	rjmp	.+470    	; 0xd150 <WebServer+0x7ea>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    cf7a:	ae 01       	movw	r20, r28
    cf7c:	4f 5f       	subi	r20, 0xFF	; 255
    cf7e:	5f 4f       	sbci	r21, 0xFF	; 255
    cf80:	67 e7       	ldi	r22, 0x77	; 119
    cf82:	8d 91       	ld	r24, X+
    cf84:	9c 91       	ld	r25, X
    cf86:	a8 cf       	rjmp	.-176    	; 0xced8 <WebServer+0x572>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    cf88:	cd 01       	movw	r24, r26
    cf8a:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    cf8e:	ae 01       	movw	r20, r28
    cf90:	4f 5f       	subi	r20, 0xFF	; 255
    cf92:	5f 4f       	sbci	r21, 0xFF	; 255
    cf94:	67 e7       	ldi	r22, 0x77	; 119
    cf96:	a0 cf       	rjmp	.-192    	; 0xced8 <WebServer+0x572>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    cf98:	ae 01       	movw	r20, r28
    cf9a:	4f 5f       	subi	r20, 0xFF	; 255
    cf9c:	5f 4f       	sbci	r21, 0xFF	; 255
    cf9e:	67 e7       	ldi	r22, 0x77	; 119
    cfa0:	8d 91       	ld	r24, X+
    cfa2:	9c 91       	ld	r25, X
    cfa4:	a8 cf       	rjmp	.-176    	; 0xcef6 <WebServer+0x590>
    cfa6:	cd 01       	movw	r24, r26
    cfa8:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    cfac:	ae 01       	movw	r20, r28
    cfae:	4f 5f       	subi	r20, 0xFF	; 255
    cfb0:	5f 4f       	sbci	r21, 0xFF	; 255
    cfb2:	67 e7       	ldi	r22, 0x77	; 119
    cfb4:	a0 cf       	rjmp	.-192    	; 0xcef6 <WebServer+0x590>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    cfb6:	ae 01       	movw	r20, r28
    cfb8:	4f 5f       	subi	r20, 0xFF	; 255
    cfba:	5f 4f       	sbci	r21, 0xFF	; 255
    cfbc:	67 e7       	ldi	r22, 0x77	; 119
    cfbe:	8d 91       	ld	r24, X+
    cfc0:	9c 91       	ld	r25, X
    cfc2:	a6 cf       	rjmp	.-180    	; 0xcf10 <WebServer+0x5aa>
    cfc4:	cd 01       	movw	r24, r26
    cfc6:	0e 94 67 73 	call	0xe6ce	; 0xe6ce <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    cfca:	ae 01       	movw	r20, r28
    cfcc:	4f 5f       	subi	r20, 0xFF	; 255
    cfce:	5f 4f       	sbci	r21, 0xFF	; 255
    cfd0:	67 e7       	ldi	r22, 0x77	; 119
    cfd2:	9e cf       	rjmp	.-196    	; 0xcf10 <WebServer+0x5aa>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    cfd4:	6d 91       	ld	r22, X+
    cfd6:	7d 91       	ld	r23, X+
    cfd8:	8d 91       	ld	r24, X+
    cfda:	9c 91       	ld	r25, X
    cfdc:	03 c0       	rjmp	.+6      	; 0xcfe4 <WebServer+0x67e>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    cfde:	cd 01       	movw	r24, r26
    cfe0:	0e 94 61 73 	call	0xe6c2	; 0xe6c2 <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    cfe4:	ae 01       	movw	r20, r28
    cfe6:	4f 5f       	subi	r20, 0xFF	; 255
    cfe8:	5f 4f       	sbci	r21, 0xFF	; 255
    cfea:	0e 94 71 40 	call	0x80e2	; 0x80e2 <PutDVal>
    cfee:	b0 c0       	rjmp	.+352    	; 0xd150 <WebServer+0x7ea>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    cff0:	6d 91       	ld	r22, X+
    cff2:	7d 91       	ld	r23, X+
    cff4:	8d 91       	ld	r24, X+
    cff6:	9c 91       	ld	r25, X
    cff8:	03 c0       	rjmp	.+6      	; 0xd000 <WebServer+0x69a>
    cffa:	cd 01       	movw	r24, r26
    cffc:	0e 94 61 73 	call	0xe6c2	; 0xe6c2 <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    d000:	ae 01       	movw	r20, r28
    d002:	4f 5f       	subi	r20, 0xFF	; 255
    d004:	5f 4f       	sbci	r21, 0xFF	; 255
    d006:	0e 94 04 41 	call	0x8208	; 0x8208 <Put_sDVal>
    d00a:	a2 c0       	rjmp	.+324    	; 0xd150 <WebServer+0x7ea>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    d00c:	6d 91       	ld	r22, X+
    d00e:	7d 91       	ld	r23, X+
    d010:	8d 91       	ld	r24, X+
    d012:	9c 91       	ld	r25, X
    d014:	03 c0       	rjmp	.+6      	; 0xd01c <WebServer+0x6b6>
    d016:	cd 01       	movw	r24, r26
    d018:	0e 94 61 73 	call	0xe6c2	; 0xe6c2 <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    d01c:	ae 01       	movw	r20, r28
    d01e:	4f 5f       	subi	r20, 0xFF	; 255
    d020:	5f 4f       	sbci	r21, 0xFF	; 255
    d022:	0e 94 fc 41 	call	0x83f8	; 0x83f8 <Put_zDVal>
    d026:	94 c0       	rjmp	.+296    	; 0xd150 <WebServer+0x7ea>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    d028:	6d 91       	ld	r22, X+
    d02a:	7d 91       	ld	r23, X+
    d02c:	8d 91       	ld	r24, X+
    d02e:	9c 91       	ld	r25, X
    d030:	0b c0       	rjmp	.+22     	; 0xd048 <WebServer+0x6e2>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d032:	44 e0       	ldi	r20, 0x04	; 4
    d034:	50 e0       	ldi	r21, 0x00	; 0
    d036:	bd 01       	movw	r22, r26
    d038:	ce 01       	movw	r24, r28
    d03a:	07 96       	adiw	r24, 0x07	; 7
    d03c:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    d040:	6f 81       	ldd	r22, Y+7	; 0x07
    d042:	78 85       	ldd	r23, Y+8	; 0x08
    d044:	89 85       	ldd	r24, Y+9	; 0x09
    d046:	9a 85       	ldd	r25, Y+10	; 0x0a
    d048:	ae 01       	movw	r20, r28
    d04a:	4f 5f       	subi	r20, 0xFF	; 255
    d04c:	5f 4f       	sbci	r21, 0xFF	; 255
    d04e:	0e 94 8f 42 	call	0x851e	; 0x851e <Put_FFVal>
    d052:	7e c0       	rjmp	.+252    	; 0xd150 <WebServer+0x7ea>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    d054:	6d 91       	ld	r22, X+
    d056:	7d 91       	ld	r23, X+
    d058:	8d 91       	ld	r24, X+
    d05a:	9c 91       	ld	r25, X
    d05c:	0b c0       	rjmp	.+22     	; 0xd074 <WebServer+0x70e>
    d05e:	44 e0       	ldi	r20, 0x04	; 4
    d060:	50 e0       	ldi	r21, 0x00	; 0
    d062:	bd 01       	movw	r22, r26
    d064:	ce 01       	movw	r24, r28
    d066:	07 96       	adiw	r24, 0x07	; 7
    d068:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    d06c:	6f 81       	ldd	r22, Y+7	; 0x07
    d06e:	78 85       	ldd	r23, Y+8	; 0x08
    d070:	89 85       	ldd	r24, Y+9	; 0x09
    d072:	9a 85       	ldd	r25, Y+10	; 0x0a
    d074:	ae 01       	movw	r20, r28
    d076:	4f 5f       	subi	r20, 0xFF	; 255
    d078:	5f 4f       	sbci	r21, 0xFF	; 255
    d07a:	0e 94 cd 42 	call	0x859a	; 0x859a <Put_GFVal>
    d07e:	68 c0       	rjmp	.+208    	; 0xd150 <WebServer+0x7ea>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    d080:	8c 91       	ld	r24, X
    d082:	03 c0       	rjmp	.+6      	; 0xd08a <WebServer+0x724>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d084:	cd 01       	movw	r24, r26
    d086:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    d08a:	88 0e       	add	r8, r24
    d08c:	91 1c       	adc	r9, r1
    d08e:	88 0e       	add	r8, r24
    d090:	91 1c       	adc	r9, r1
    d092:	9e 82       	std	Y+6, r9	; 0x06
    d094:	8d 82       	std	Y+5, r8	; 0x05
		PutEnum(Param);
    d096:	ce 01       	movw	r24, r28
    d098:	01 96       	adiw	r24, 0x01	; 1
    d09a:	0e 94 75 3e 	call	0x7cea	; 0x7cea <PutEnum>
    d09e:	58 c0       	rjmp	.+176    	; 0xd150 <WebServer+0x7ea>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d0a0:	2b 81       	ldd	r18, Y+3	; 0x03
    d0a2:	82 2f       	mov	r24, r18
    d0a4:	86 95       	lsr	r24
    d0a6:	86 95       	lsr	r24
    d0a8:	86 95       	lsr	r24
    d0aa:	a8 0f       	add	r26, r24
    d0ac:	b1 1d       	adc	r27, r1
    d0ae:	8c 91       	ld	r24, X
    d0b0:	90 e0       	ldi	r25, 0x00	; 0
    d0b2:	0e c0       	rjmp	.+28     	; 0xd0d0 <WebServer+0x76a>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d0b4:	2b 81       	ldd	r18, Y+3	; 0x03
    d0b6:	82 2f       	mov	r24, r18
    d0b8:	86 95       	lsr	r24
    d0ba:	86 95       	lsr	r24
    d0bc:	86 95       	lsr	r24
    d0be:	fd 01       	movw	r30, r26
    d0c0:	e8 0f       	add	r30, r24
    d0c2:	f1 1d       	adc	r31, r1
    d0c4:	cf 01       	movw	r24, r30
    d0c6:	2c 87       	std	Y+12, r18	; 0x0c
    d0c8:	0e 94 59 73 	call	0xe6b2	; 0xe6b2 <__eerd_byte_m128>
    d0cc:	90 e0       	ldi	r25, 0x00	; 0
    d0ce:	2c 85       	ldd	r18, Y+12	; 0x0c
    d0d0:	27 70       	andi	r18, 0x07	; 7
    d0d2:	a5 01       	movw	r20, r10
    d0d4:	02 c0       	rjmp	.+4      	; 0xd0da <WebServer+0x774>
    d0d6:	44 0f       	add	r20, r20
    d0d8:	55 1f       	adc	r21, r21
    d0da:	2a 95       	dec	r18
    d0dc:	e2 f7       	brpl	.-8      	; 0xd0d6 <WebServer+0x770>
    d0de:	84 23       	and	r24, r20
    d0e0:	95 23       	and	r25, r21
    d0e2:	89 2b       	or	r24, r25
    d0e4:	19 f0       	breq	.+6      	; 0xd0ec <WebServer+0x786>
    d0e6:	e2 e0       	ldi	r30, 0x02	; 2
    d0e8:	f0 e0       	ldi	r31, 0x00	; 0
    d0ea:	02 c0       	rjmp	.+4      	; 0xd0f0 <WebServer+0x78a>
    d0ec:	e0 e0       	ldi	r30, 0x00	; 0
    d0ee:	f0 e0       	ldi	r31, 0x00	; 0
    d0f0:	e8 0d       	add	r30, r8
    d0f2:	f9 1d       	adc	r31, r9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d0f4:	65 91       	lpm	r22, Z+
    d0f6:	74 91       	lpm	r23, Z
    d0f8:	c7 01       	movw	r24, r14
    d0fa:	0e 94 d0 6b 	call	0xd7a0	; 0xd7a0 <strcpy_P>
    d0fe:	28 c0       	rjmp	.+80     	; 0xd150 <WebServer+0x7ea>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    d100:	be 01       	movw	r22, r28
    d102:	6f 5f       	subi	r22, 0xFF	; 255
    d104:	7f 4f       	sbci	r23, 0xFF	; 255
    d106:	cd 01       	movw	r24, r26
    d108:	0e 94 20 43 	call	0x8640	; 0x8640 <Put_TextValAlignLeft>
    d10c:	21 c0       	rjmp	.+66     	; 0xd150 <WebServer+0x7ea>
    d10e:	8d b6       	in	r8, 0x3d	; 61
    d110:	9e b6       	in	r9, 0x3e	; 62
		break;
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    d112:	ca 01       	movw	r24, r20
    d114:	01 96       	adiw	r24, 0x01	; 1
    d116:	ed b7       	in	r30, 0x3d	; 61
    d118:	fe b7       	in	r31, 0x3e	; 62
    d11a:	e8 1b       	sub	r30, r24
    d11c:	f9 0b       	sbc	r31, r25
    d11e:	0f b6       	in	r0, 0x3f	; 63
    d120:	f8 94       	cli
    d122:	fe bf       	out	0x3e, r31	; 62
    d124:	0f be       	out	0x3f, r0	; 63
    d126:	ed bf       	out	0x3d, r30	; 61
    d128:	2d b7       	in	r18, 0x3d	; 61
    d12a:	3e b7       	in	r19, 0x3e	; 62
    d12c:	2f 5f       	subi	r18, 0xFF	; 255
    d12e:	3f 4f       	sbci	r19, 0xFF	; 255
    d130:	79 01       	movw	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d132:	bd 01       	movw	r22, r26
    d134:	c9 01       	movw	r24, r18
    d136:	0e 94 49 73 	call	0xe692	; 0xe692 <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    d13a:	be 01       	movw	r22, r28
    d13c:	6f 5f       	subi	r22, 0xFF	; 255
    d13e:	7f 4f       	sbci	r23, 0xFF	; 255
    d140:	c7 01       	movw	r24, r14
    d142:	0e 94 20 43 	call	0x8640	; 0x8640 <Put_TextValAlignLeft>
    d146:	0f b6       	in	r0, 0x3f	; 63
    d148:	f8 94       	cli
    d14a:	9e be       	out	0x3e, r9	; 62
    d14c:	0f be       	out	0x3f, r0	; 63
    d14e:	8d be       	out	0x3d, r8	; 61
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    d150:	36 e0       	ldi	r19, 0x06	; 6
    d152:	c3 0e       	add	r12, r19
    d154:	d1 1c       	adc	r13, r1
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    d156:	8c 81       	ldd	r24, Y+4	; 0x04
    d158:	86 0d       	add	r24, r6
    d15a:	e8 2f       	mov	r30, r24
    d15c:	f0 e0       	ldi	r31, 0x00	; 0
    d15e:	e7 5c       	subi	r30, 0xC7	; 199
    d160:	f3 4f       	sbci	r31, 0xF3	; 243
    d162:	70 82       	st	Z, r7
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    d164:	66 24       	eor	r6, r6
    d166:	63 94       	inc	r6
    d168:	68 0e       	add	r6, r24
    d16a:	74 ce       	rjmp	.-792    	; 0xce54 <WebServer+0x4ee>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    d16c:	d0 92 3d 02 	sts	0x023D, r13
    d170:	c0 92 3c 02 	sts	0x023C, r12
				}
				GSMTxSz = i;
    d174:	00 93 57 09 	sts	0x0957, r16
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d178:	20 91 57 09 	lds	r18, 0x0957
    d17c:	80 91 3a 02 	lds	r24, 0x023A
    d180:	90 91 3b 02 	lds	r25, 0x023B
    d184:	82 0f       	add	r24, r18
    d186:	91 1d       	adc	r25, r1
				if(PacketByteCount >= MaxPacketSz){
    d188:	81 15       	cp	r24, r1
    d18a:	54 e0       	ldi	r21, 0x04	; 4
    d18c:	95 07       	cpc	r25, r21
    d18e:	28 f4       	brcc	.+10     	; 0xd19a <WebServer+0x834>
					}
					ptrIF = PutWebLine(ptrIF, i);
				}
				GSMTxSz = i;
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d190:	90 93 3b 02 	sts	0x023B, r25
    d194:	80 93 3a 02 	sts	0x023A, r24
    d198:	0b c0       	rjmp	.+22     	; 0xd1b0 <WebServer+0x84a>
				if(PacketByteCount >= MaxPacketSz){
					PacketByteCount -= MaxPacketSz;
    d19a:	94 50       	subi	r25, 0x04	; 4
    d19c:	90 93 3b 02 	sts	0x023B, r25
    d1a0:	80 93 3a 02 	sts	0x023A, r24
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    d1a4:	68 ec       	ldi	r22, 0xC8	; 200
    d1a6:	70 e0       	ldi	r23, 0x00	; 0
    d1a8:	80 91 4f 09 	lds	r24, 0x094F
    d1ac:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
				}
				GSM_SendFirstChar();
    d1b0:	0e 94 ae 57 	call	0xaf5c	; 0xaf5c <GSM_SendFirstChar>
    d1b4:	02 c0       	rjmp	.+4      	; 0xd1ba <WebServer+0x854>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    d1b6:	10 92 3e 02 	sts	0x023E, r1
	}

}
    d1ba:	0f b6       	in	r0, 0x3f	; 63
    d1bc:	f8 94       	cli
    d1be:	3e be       	out	0x3e, r3	; 62
    d1c0:	0f be       	out	0x3f, r0	; 63
    d1c2:	2d be       	out	0x3d, r2	; 61
    d1c4:	2c 96       	adiw	r28, 0x0c	; 12
    d1c6:	0f b6       	in	r0, 0x3f	; 63
    d1c8:	f8 94       	cli
    d1ca:	de bf       	out	0x3e, r29	; 62
    d1cc:	0f be       	out	0x3f, r0	; 63
    d1ce:	cd bf       	out	0x3d, r28	; 61
    d1d0:	df 91       	pop	r29
    d1d2:	cf 91       	pop	r28
    d1d4:	1f 91       	pop	r17
    d1d6:	0f 91       	pop	r16
    d1d8:	ff 90       	pop	r15
    d1da:	ef 90       	pop	r14
    d1dc:	df 90       	pop	r13
    d1de:	cf 90       	pop	r12
    d1e0:	bf 90       	pop	r11
    d1e2:	af 90       	pop	r10
    d1e4:	9f 90       	pop	r9
    d1e6:	8f 90       	pop	r8
    d1e8:	7f 90       	pop	r7
    d1ea:	6f 90       	pop	r6
    d1ec:	5f 90       	pop	r5
    d1ee:	4f 90       	pop	r4
    d1f0:	3f 90       	pop	r3
    d1f2:	2f 90       	pop	r2
    d1f4:	08 95       	ret

0000d1f6 <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    d1f6:	80 91 76 0a 	lds	r24, 0x0A76
    d1fa:	88 23       	and	r24, r24
    d1fc:	09 f4       	brne	.+2      	; 0xd200 <GSM_DRE+0xa>
    d1fe:	55 c0       	rjmp	.+170    	; 0xd2aa <GSM_DRE+0xb4>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d200:	90 91 70 09 	lds	r25, 0x0970
    d204:	80 91 38 0d 	lds	r24, 0x0D38
    d208:	98 17       	cp	r25, r24
    d20a:	a1 f0       	breq	.+40     	; 0xd234 <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    d20c:	80 91 38 0d 	lds	r24, 0x0D38
    d210:	8f 5f       	subi	r24, 0xFF	; 255
    d212:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d216:	80 91 38 0d 	lds	r24, 0x0D38
    d21a:	8f 3f       	cpi	r24, 0xFF	; 255
    d21c:	11 f4       	brne	.+4      	; 0xd222 <GSM_DRE+0x2c>
    d21e:	10 92 38 0d 	sts	0x0D38, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    d222:	e0 91 38 0d 	lds	r30, 0x0D38
    d226:	f0 e0       	ldi	r31, 0x00	; 0
    d228:	e7 50       	subi	r30, 0x07	; 7
    d22a:	fc 4f       	sbci	r31, 0xFC	; 252
    d22c:	80 81       	ld	r24, Z
    d22e:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    d230:	5e 9a       	sbi	0x0b, 6	; 11
    d232:	02 c0       	rjmp	.+4      	; 0xd238 <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d234:	88 ed       	ldi	r24, 0xD8	; 216
    d236:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    d238:	90 91 70 09 	lds	r25, 0x0970
    d23c:	80 91 38 0d 	lds	r24, 0x0D38
    d240:	89 17       	cp	r24, r25
    d242:	a0 f4       	brcc	.+40     	; 0xd26c <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    d244:	20 91 6e 0a 	lds	r18, 0x0A6E
    d248:	80 91 70 09 	lds	r24, 0x0970
    d24c:	40 91 38 0d 	lds	r20, 0x0D38
    d250:	30 e0       	ldi	r19, 0x00	; 0
    d252:	90 e0       	ldi	r25, 0x00	; 0
    d254:	84 1b       	sub	r24, r20
    d256:	91 09       	sbc	r25, r1
    d258:	28 17       	cp	r18, r24
    d25a:	39 07       	cpc	r19, r25
    d25c:	3c f4       	brge	.+14     	; 0xd26c <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    d25e:	80 91 70 09 	lds	r24, 0x0970
    d262:	90 91 38 0d 	lds	r25, 0x0D38
    d266:	89 1b       	sub	r24, r25
    d268:	80 93 6e 0a 	sts	0x0A6E, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    d26c:	90 91 38 0d 	lds	r25, 0x0D38
    d270:	80 91 70 09 	lds	r24, 0x0970
    d274:	89 17       	cp	r24, r25
    d276:	e8 f5       	brcc	.+122    	; 0xd2f2 <GSM_DRE+0xfc>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    d278:	20 91 6e 0a 	lds	r18, 0x0A6E
    d27c:	50 91 38 0d 	lds	r21, 0x0D38
    d280:	40 91 70 09 	lds	r20, 0x0970
    d284:	30 e0       	ldi	r19, 0x00	; 0
    d286:	8f ef       	ldi	r24, 0xFF	; 255
    d288:	90 e0       	ldi	r25, 0x00	; 0
    d28a:	85 1b       	sub	r24, r21
    d28c:	91 09       	sbc	r25, r1
    d28e:	84 0f       	add	r24, r20
    d290:	91 1d       	adc	r25, r1
    d292:	28 17       	cp	r18, r24
    d294:	39 07       	cpc	r19, r25
    d296:	6c f5       	brge	.+90     	; 0xd2f2 <GSM_DRE+0xfc>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    d298:	80 91 70 09 	lds	r24, 0x0970
    d29c:	90 91 38 0d 	lds	r25, 0x0D38
    d2a0:	81 50       	subi	r24, 0x01	; 1
    d2a2:	89 1b       	sub	r24, r25
    d2a4:	80 93 6e 0a 	sts	0x0A6E, r24
    d2a8:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    d2aa:	90 91 46 0d 	lds	r25, 0x0D46
    d2ae:	80 91 57 09 	lds	r24, 0x0957
    d2b2:	98 17       	cp	r25, r24
    d2b4:	e0 f4       	brcc	.+56     	; 0xd2ee <GSM_DRE+0xf8>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    d2b6:	e0 91 46 0d 	lds	r30, 0x0D46
    d2ba:	f0 e0       	ldi	r31, 0x00	; 0
    d2bc:	e7 5c       	subi	r30, 0xC7	; 199
    d2be:	f3 4f       	sbci	r31, 0xF3	; 243
    d2c0:	80 81       	ld	r24, Z
    d2c2:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    d2c4:	80 91 f2 09 	lds	r24, 0x09F2
    d2c8:	88 23       	and	r24, r24
    d2ca:	59 f0       	breq	.+22     	; 0xd2e2 <GSM_DRE+0xec>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    d2cc:	e0 91 46 0d 	lds	r30, 0x0D46
    d2d0:	f0 e0       	ldi	r31, 0x00	; 0
    d2d2:	e7 5c       	subi	r30, 0xC7	; 199
    d2d4:	f3 4f       	sbci	r31, 0xF3	; 243
    d2d6:	80 81       	ld	r24, Z
    d2d8:	0e 94 1a 57 	call	0xae34	; 0xae34 <SendDebug>
    d2dc:	88 e2       	ldi	r24, 0x28	; 40
    d2de:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    d2e2:	80 91 46 0d 	lds	r24, 0x0D46
    d2e6:	8f 5f       	subi	r24, 0xFF	; 255
    d2e8:	80 93 46 0d 	sts	0x0D46, r24
    d2ec:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d2ee:	88 ed       	ldi	r24, 0xD8	; 216
    d2f0:	8a b9       	out	0x0a, r24	; 10
    d2f2:	08 95       	ret

0000d2f4 <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    d2f4:	1f 92       	push	r1
    d2f6:	0f 92       	push	r0
    d2f8:	0f b6       	in	r0, 0x3f	; 63
    d2fa:	0f 92       	push	r0
    d2fc:	11 24       	eor	r1, r1
    d2fe:	0b b6       	in	r0, 0x3b	; 59
    d300:	0f 92       	push	r0
    d302:	2f 93       	push	r18
    d304:	3f 93       	push	r19
    d306:	4f 93       	push	r20
    d308:	5f 93       	push	r21
    d30a:	6f 93       	push	r22
    d30c:	7f 93       	push	r23
    d30e:	8f 93       	push	r24
    d310:	9f 93       	push	r25
    d312:	af 93       	push	r26
    d314:	bf 93       	push	r27
    d316:	ef 93       	push	r30
    d318:	ff 93       	push	r31
	GSM_DRE();
    d31a:	0e 94 fb 68 	call	0xd1f6	; 0xd1f6 <GSM_DRE>
	GSM_LED = 1;
    d31e:	81 e0       	ldi	r24, 0x01	; 1
    d320:	80 93 0a 06 	sts	0x060A, r24
}
    d324:	ff 91       	pop	r31
    d326:	ef 91       	pop	r30
    d328:	bf 91       	pop	r27
    d32a:	af 91       	pop	r26
    d32c:	9f 91       	pop	r25
    d32e:	8f 91       	pop	r24
    d330:	7f 91       	pop	r23
    d332:	6f 91       	pop	r22
    d334:	5f 91       	pop	r21
    d336:	4f 91       	pop	r20
    d338:	3f 91       	pop	r19
    d33a:	2f 91       	pop	r18
    d33c:	0f 90       	pop	r0
    d33e:	0b be       	out	0x3b, r0	; 59
    d340:	0f 90       	pop	r0
    d342:	0f be       	out	0x3f, r0	; 63
    d344:	0f 90       	pop	r0
    d346:	1f 90       	pop	r1
    d348:	18 95       	reti

0000d34a <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d34a:	90 91 70 09 	lds	r25, 0x0970
    d34e:	80 91 38 0d 	lds	r24, 0x0D38
    d352:	98 17       	cp	r25, r24
    d354:	a1 f0       	breq	.+40     	; 0xd37e <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    d356:	80 91 38 0d 	lds	r24, 0x0D38
    d35a:	8f 5f       	subi	r24, 0xFF	; 255
    d35c:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d360:	80 91 38 0d 	lds	r24, 0x0D38
    d364:	8f 3f       	cpi	r24, 0xFF	; 255
    d366:	11 f4       	brne	.+4      	; 0xd36c <Debug_DRE+0x22>
    d368:	10 92 38 0d 	sts	0x0D38, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    d36c:	e0 91 38 0d 	lds	r30, 0x0D38
    d370:	f0 e0       	ldi	r31, 0x00	; 0
    d372:	e7 50       	subi	r30, 0x07	; 7
    d374:	fc 4f       	sbci	r31, 0xFC	; 252
    d376:	80 81       	ld	r24, Z
    d378:	80 93 9c 00 	sts	0x009C, r24
    d37c:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    d37e:	88 e0       	ldi	r24, 0x08	; 8
    d380:	80 93 9a 00 	sts	0x009A, r24
    d384:	08 95       	ret

0000d386 <EMeter_DRE>:
	}*/
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    d386:	80 91 f2 09 	lds	r24, 0x09F2
    d38a:	81 11       	cpse	r24, r1
    d38c:	0c 94 a5 69 	jmp	0xd34a	; 0xd34a <Debug_DRE>
	else{
		if(Transparent){
    d390:	80 91 76 0a 	lds	r24, 0x0A76
    d394:	88 23       	and	r24, r24
    d396:	09 f4       	brne	.+2      	; 0xd39a <EMeter_DRE+0x14>
    d398:	5e c0       	rjmp	.+188    	; 0xd456 <EMeter_DRE+0xd0>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    d39a:	90 91 7b 08 	lds	r25, 0x087B
    d39e:	80 91 f8 0a 	lds	r24, 0x0AF8
    d3a2:	98 17       	cp	r25, r24
    d3a4:	d1 f0       	breq	.+52     	; 0xd3da <EMeter_DRE+0x54>
		GSM_RX_FIFO_End_Transp++;
    d3a6:	80 91 f8 0a 	lds	r24, 0x0AF8
    d3aa:	8f 5f       	subi	r24, 0xFF	; 255
    d3ac:	80 93 f8 0a 	sts	0x0AF8, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    d3b0:	80 91 f8 0a 	lds	r24, 0x0AF8
    d3b4:	8a 3f       	cpi	r24, 0xFA	; 250
    d3b6:	10 f0       	brcs	.+4      	; 0xd3bc <EMeter_DRE+0x36>
    d3b8:	10 92 f8 0a 	sts	0x0AF8, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    d3bc:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    d3be:	e0 91 f8 0a 	lds	r30, 0x0AF8
    d3c2:	f0 e0       	ldi	r31, 0x00	; 0
    d3c4:	e8 50       	subi	r30, 0x08	; 8
    d3c6:	fb 4f       	sbci	r31, 0xFB	; 251
    d3c8:	80 81       	ld	r24, Z
    d3ca:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    d3ce:	80 91 9b 00 	lds	r24, 0x009B
    d3d2:	80 64       	ori	r24, 0x40	; 64
    d3d4:	80 93 9b 00 	sts	0x009B, r24
    d3d8:	03 c0       	rjmp	.+6      	; 0xd3e0 <EMeter_DRE+0x5a>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d3da:	88 ed       	ldi	r24, 0xD8	; 216
    d3dc:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    d3e0:	90 91 7b 08 	lds	r25, 0x087B
    d3e4:	80 91 f8 0a 	lds	r24, 0x0AF8
    d3e8:	89 17       	cp	r24, r25
    d3ea:	a0 f4       	brcc	.+40     	; 0xd414 <EMeter_DRE+0x8e>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    d3ec:	20 91 7f 09 	lds	r18, 0x097F
    d3f0:	80 91 7b 08 	lds	r24, 0x087B
    d3f4:	40 91 f8 0a 	lds	r20, 0x0AF8
    d3f8:	30 e0       	ldi	r19, 0x00	; 0
    d3fa:	90 e0       	ldi	r25, 0x00	; 0
    d3fc:	84 1b       	sub	r24, r20
    d3fe:	91 09       	sbc	r25, r1
    d400:	28 17       	cp	r18, r24
    d402:	39 07       	cpc	r19, r25
    d404:	3c f4       	brge	.+14     	; 0xd414 <EMeter_DRE+0x8e>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    d406:	80 91 7b 08 	lds	r24, 0x087B
    d40a:	90 91 f8 0a 	lds	r25, 0x0AF8
    d40e:	89 1b       	sub	r24, r25
    d410:	80 93 7f 09 	sts	0x097F, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    d414:	90 91 f8 0a 	lds	r25, 0x0AF8
    d418:	80 91 7b 08 	lds	r24, 0x087B
    d41c:	89 17       	cp	r24, r25
    d41e:	c0 f4       	brcc	.+48     	; 0xd450 <EMeter_DRE+0xca>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    d420:	20 91 7f 09 	lds	r18, 0x097F
    d424:	50 91 f8 0a 	lds	r21, 0x0AF8
    d428:	40 91 7b 08 	lds	r20, 0x087B
    d42c:	30 e0       	ldi	r19, 0x00	; 0
    d42e:	8a ef       	ldi	r24, 0xFA	; 250
    d430:	90 e0       	ldi	r25, 0x00	; 0
    d432:	85 1b       	sub	r24, r21
    d434:	91 09       	sbc	r25, r1
    d436:	84 0f       	add	r24, r20
    d438:	91 1d       	adc	r25, r1
    d43a:	28 17       	cp	r18, r24
    d43c:	39 07       	cpc	r19, r25
    d43e:	44 f4       	brge	.+16     	; 0xd450 <EMeter_DRE+0xca>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    d440:	80 91 7b 08 	lds	r24, 0x087B
    d444:	90 91 f8 0a 	lds	r25, 0x0AF8
    d448:	86 50       	subi	r24, 0x06	; 6
    d44a:	89 1b       	sub	r24, r25
    d44c:	80 93 7f 09 	sts	0x097F, r24
			GetByteFromGSM_FIFO_Transp();
			EMeterIsLink=0;
    d450:	10 92 5d 09 	sts	0x095D, r1
    d454:	08 95       	ret
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    d456:	90 91 51 09 	lds	r25, 0x0951
    d45a:	80 91 47 0d 	lds	r24, 0x0D47
    d45e:	98 17       	cp	r25, r24
    d460:	70 f4       	brcc	.+28     	; 0xd47e <EMeter_DRE+0xf8>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    d462:	e0 91 51 09 	lds	r30, 0x0951
    d466:	f0 e0       	ldi	r31, 0x00	; 0
    d468:	e7 50       	subi	r30, 0x07	; 7
    d46a:	f5 4f       	sbci	r31, 0xF5	; 245
    d46c:	80 81       	ld	r24, Z
    d46e:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    d472:	80 91 51 09 	lds	r24, 0x0951
    d476:	8f 5f       	subi	r24, 0xFF	; 255
    d478:	80 93 51 09 	sts	0x0951, r24
    d47c:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d47e:	88 ed       	ldi	r24, 0xD8	; 216
    d480:	80 93 9a 00 	sts	0x009A, r24
    d484:	08 95       	ret

0000d486 <__vector_31>:
}

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    d486:	1f 92       	push	r1
    d488:	0f 92       	push	r0
    d48a:	0f b6       	in	r0, 0x3f	; 63
    d48c:	0f 92       	push	r0
    d48e:	11 24       	eor	r1, r1
    d490:	0b b6       	in	r0, 0x3b	; 59
    d492:	0f 92       	push	r0
    d494:	2f 93       	push	r18
    d496:	3f 93       	push	r19
    d498:	4f 93       	push	r20
    d49a:	5f 93       	push	r21
    d49c:	6f 93       	push	r22
    d49e:	7f 93       	push	r23
    d4a0:	8f 93       	push	r24
    d4a2:	9f 93       	push	r25
    d4a4:	af 93       	push	r26
    d4a6:	bf 93       	push	r27
    d4a8:	ef 93       	push	r30
    d4aa:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    d4ac:	80 91 e0 03 	lds	r24, 0x03E0
    d4b0:	88 23       	and	r24, r24
    d4b2:	29 f0       	breq	.+10     	; 0xd4be <__vector_31+0x38>
    d4b4:	8c e9       	ldi	r24, 0x9C	; 156
    d4b6:	90 e0       	ldi	r25, 0x00	; 0
    d4b8:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <Modbus_TX>
    d4bc:	02 c0       	rjmp	.+4      	; 0xd4c2 <__vector_31+0x3c>
	else EMeter_DRE();
    d4be:	0e 94 c3 69 	call	0xd386	; 0xd386 <EMeter_DRE>
	COMM_LED = 1;
    d4c2:	81 e0       	ldi	r24, 0x01	; 1
    d4c4:	80 93 10 06 	sts	0x0610, r24
}
    d4c8:	ff 91       	pop	r31
    d4ca:	ef 91       	pop	r30
    d4cc:	bf 91       	pop	r27
    d4ce:	af 91       	pop	r26
    d4d0:	9f 91       	pop	r25
    d4d2:	8f 91       	pop	r24
    d4d4:	7f 91       	pop	r23
    d4d6:	6f 91       	pop	r22
    d4d8:	5f 91       	pop	r21
    d4da:	4f 91       	pop	r20
    d4dc:	3f 91       	pop	r19
    d4de:	2f 91       	pop	r18
    d4e0:	0f 90       	pop	r0
    d4e2:	0b be       	out	0x3b, r0	; 59
    d4e4:	0f 90       	pop	r0
    d4e6:	0f be       	out	0x3f, r0	; 63
    d4e8:	0f 90       	pop	r0
    d4ea:	1f 90       	pop	r1
    d4ec:	18 95       	reti

0000d4ee <ToggleLED>:

//#include "web.h"
#include "web_vem_levels.h"

void ToggleLED(uint8_t DO){
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    d4ee:	40 91 63 09 	lds	r20, 0x0963
    d4f2:	50 91 64 09 	lds	r21, 0x0964
    d4f6:	60 91 65 09 	lds	r22, 0x0965
    d4fa:	70 91 66 09 	lds	r23, 0x0966
    d4fe:	42 fd       	sbrc	r20, 2
    d500:	0c 94 26 3c 	jmp	0x784c	; 0x784c <ResDigOut>
	else SetDigOut(DO);
    d504:	0c 94 14 3c 	jmp	0x7828	; 0x7828 <SetDigOut>

0000d508 <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    d508:	0e 94 1d 2a 	call	0x543a	; 0x543a <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    d50c:	0e 94 f1 4c 	call	0x99e2	; 0x99e2 <GPRS_AppInit>
	#endif

	WebInit();
    d510:	0c 94 71 43 	jmp	0x86e2	; 0x86e2 <WebInit>

0000d514 <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
    d514:	69 e0       	ldi	r22, 0x09	; 9
    d516:	8e e7       	ldi	r24, 0x7E	; 126
    d518:	95 e0       	ldi	r25, 0x05	; 5
    d51a:	0e 94 b3 64 	call	0xc966	; 0xc966 <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
    d51e:	0e 94 52 55 	call	0xaaa4	; 0xaaa4 <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
    d522:	0e 94 fd 55 	call	0xabfa	; 0xabfa <Modbus_App>
		}
	*/	


	// GSM_DebugMode
	if(UART_Soft){
    d526:	80 91 75 0a 	lds	r24, 0x0A75
    d52a:	88 23       	and	r24, r24
    d52c:	09 f1       	breq	.+66     	; 0xd570 <ApplCycle+0x5c>
		if(GSM_DebugMode){
    d52e:	80 91 f2 09 	lds	r24, 0x09F2
    d532:	88 23       	and	r24, r24
    d534:	81 f0       	breq	.+32     	; 0xd556 <ApplCycle+0x42>
			if( DI_State(DI_BL) ){
    d536:	83 e0       	ldi	r24, 0x03	; 3
    d538:	0e 94 a5 3b 	call	0x774a	; 0x774a <DI_State>
    d53c:	88 23       	and	r24, r24
    d53e:	41 f0       	breq	.+16     	; 0xd550 <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
    d540:	81 e0       	ldi	r24, 0x01	; 1
    d542:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    d546:	88 23       	and	r24, r24
    d548:	51 f1       	breq	.+84     	; 0xd59e <ApplCycle+0x8a>
					StopDebug();
    d54a:	0e 94 10 57 	call	0xae20	; 0xae20 <StopDebug>
    d54e:	22 c0       	rjmp	.+68     	; 0xd594 <ApplCycle+0x80>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
    d550:	62 e3       	ldi	r22, 0x32	; 50
    d552:	70 e0       	ldi	r23, 0x00	; 0
    d554:	21 c0       	rjmp	.+66     	; 0xd598 <ApplCycle+0x84>
		}
		else{
			if( DI_State(DI_BL) ){
    d556:	83 e0       	ldi	r24, 0x03	; 3
    d558:	0e 94 a5 3b 	call	0x774a	; 0x774a <DI_State>
    d55c:	88 23       	and	r24, r24
    d55e:	69 f0       	breq	.+26     	; 0xd57a <ApplCycle+0x66>
				if(Timer16Stopp(TD_GotoDebug)){
    d560:	81 e0       	ldi	r24, 0x01	; 1
    d562:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    d566:	88 23       	and	r24, r24
    d568:	d1 f0       	breq	.+52     	; 0xd59e <ApplCycle+0x8a>
					StartDebug();
    d56a:	0e 94 fc 56 	call	0xadf8	; 0xadf8 <StartDebug>
    d56e:	12 c0       	rjmp	.+36     	; 0xd594 <ApplCycle+0x80>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
    d570:	83 e0       	ldi	r24, 0x03	; 3
    d572:	0e 94 a5 3b 	call	0x774a	; 0x774a <DI_State>
    d576:	81 11       	cpse	r24, r1
    d578:	03 c0       	rjmp	.+6      	; 0xd580 <ApplCycle+0x6c>
				if(Timer16Stopp(TD_GotoDebug)){
					StartDebug();
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,100);
    d57a:	64 e6       	ldi	r22, 0x64	; 100
    d57c:	70 e0       	ldi	r23, 0x00	; 0
    d57e:	0c c0       	rjmp	.+24     	; 0xd598 <ApplCycle+0x84>
		}
	}
	else{
		if( DI_State(DI_BL) ){
			if(Timer16Stopp(TD_GotoDebug)){
    d580:	81 e0       	ldi	r24, 0x01	; 1
    d582:	0e 94 67 2c 	call	0x58ce	; 0x58ce <Timer16Stopp>
    d586:	88 23       	and	r24, r24
    d588:	51 f0       	breq	.+20     	; 0xd59e <ApplCycle+0x8a>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
    d58a:	64 ef       	ldi	r22, 0xF4	; 244
    d58c:	7c e4       	ldi	r23, 0x4C	; 76
    d58e:	82 e0       	ldi	r24, 0x02	; 2
    d590:	0e 94 b8 4f 	call	0x9f70	; 0x9f70 <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
    d594:	64 ef       	ldi	r22, 0xF4	; 244
    d596:	71 e0       	ldi	r23, 0x01	; 1
    d598:	81 e0       	ldi	r24, 0x01	; 1
    d59a:	0e 94 cc 2a 	call	0x5598	; 0x5598 <StartTimer16>
		}
	}
	else ResDigOut(DO_BL);*/

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
    d59e:	80 91 0a 06 	lds	r24, 0x060A
    d5a2:	81 30       	cpi	r24, 0x01	; 1
    d5a4:	39 f4       	brne	.+14     	; 0xd5b4 <ApplCycle+0xa0>
		StartTimer8(TD_GSM_LED,5);
    d5a6:	65 e0       	ldi	r22, 0x05	; 5
    d5a8:	83 e0       	ldi	r24, 0x03	; 3
    d5aa:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
		GSM_LED = 2;
    d5ae:	82 e0       	ldi	r24, 0x02	; 2
    d5b0:	80 93 0a 06 	sts	0x060A, r24
	}
	if(GSM_LED ==2){
    d5b4:	80 91 0a 06 	lds	r24, 0x060A
    d5b8:	82 30       	cpi	r24, 0x02	; 2
    d5ba:	31 f4       	brne	.+12     	; 0xd5c8 <ApplCycle+0xb4>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
    d5bc:	83 e0       	ldi	r24, 0x03	; 3
    d5be:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    d5c2:	81 11       	cpse	r24, r1
    d5c4:	10 92 0a 06 	sts	0x060A, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ProtocolMode){
    d5c8:	80 91 27 06 	lds	r24, 0x0627
    d5cc:	81 36       	cpi	r24, 0x61	; 97
    d5ce:	81 f4       	brne	.+32     	; 0xd5f0 <ApplCycle+0xdc>
		if(GSM_LED||UART_Soft) ToggleLED(DO_GSM);
    d5d0:	80 91 0a 06 	lds	r24, 0x060A
    d5d4:	81 11       	cpse	r24, r1
    d5d6:	04 c0       	rjmp	.+8      	; 0xd5e0 <ApplCycle+0xcc>
    d5d8:	80 91 75 0a 	lds	r24, 0x0A75
    d5dc:	88 23       	and	r24, r24
    d5de:	21 f0       	breq	.+8      	; 0xd5e8 <ApplCycle+0xd4>
    d5e0:	80 e0       	ldi	r24, 0x00	; 0
    d5e2:	0e 94 77 6a 	call	0xd4ee	; 0xd4ee <ToggleLED>
    d5e6:	0a c0       	rjmp	.+20     	; 0xd5fc <ApplCycle+0xe8>
		else SetDigOut(DO_GSM);
    d5e8:	80 e0       	ldi	r24, 0x00	; 0
    d5ea:	0e 94 14 3c 	call	0x7828	; 0x7828 <SetDigOut>
    d5ee:	06 c0       	rjmp	.+12     	; 0xd5fc <ApplCycle+0xe8>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
    d5f0:	80 91 0a 06 	lds	r24, 0x060A
    d5f4:	81 11       	cpse	r24, r1
    d5f6:	f4 cf       	rjmp	.-24     	; 0xd5e0 <ApplCycle+0xcc>
		else ResDigOut(DO_GSM);
    d5f8:	0e 94 26 3c 	call	0x784c	; 0x784c <ResDigOut>
	}


	//----   COMM_LED  /  UART1
	if(COMM_LED == 1){
    d5fc:	80 91 10 06 	lds	r24, 0x0610
    d600:	81 30       	cpi	r24, 0x01	; 1
    d602:	39 f4       	brne	.+14     	; 0xd612 <ApplCycle+0xfe>
		StartTimer8(TD_COMM_LED,5);
    d604:	65 e0       	ldi	r22, 0x05	; 5
    d606:	82 e0       	ldi	r24, 0x02	; 2
    d608:	0e 94 9e 2a 	call	0x553c	; 0x553c <StartTimer8>
		COMM_LED = 2;
    d60c:	82 e0       	ldi	r24, 0x02	; 2
    d60e:	80 93 10 06 	sts	0x0610, r24
	}
	if(COMM_LED ==2){
    d612:	80 91 10 06 	lds	r24, 0x0610
    d616:	82 30       	cpi	r24, 0x02	; 2
    d618:	29 f4       	brne	.+10     	; 0xd624 <ApplCycle+0x110>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
    d61a:	0e 94 4c 2c 	call	0x5898	; 0x5898 <Timer8Stopp>
    d61e:	81 11       	cpse	r24, r1
    d620:	10 92 10 06 	sts	0x0610, r1
	}
	//   COMM_LED 
	//if(EMeter_Link()){
	if(EMeterIsLink){
    d624:	80 91 5d 09 	lds	r24, 0x095D
    d628:	88 23       	and	r24, r24
    d62a:	51 f0       	breq	.+20     	; 0xd640 <ApplCycle+0x12c>
		if(COMM_LED) ToggleLED(DO_RS);
    d62c:	80 91 10 06 	lds	r24, 0x0610
    d630:	88 23       	and	r24, r24
    d632:	19 f0       	breq	.+6      	; 0xd63a <ApplCycle+0x126>
    d634:	81 e0       	ldi	r24, 0x01	; 1
    d636:	0c 94 77 6a 	jmp	0xd4ee	; 0xd4ee <ToggleLED>
		else SetDigOut(DO_RS);
    d63a:	81 e0       	ldi	r24, 0x01	; 1
    d63c:	0c 94 14 3c 	jmp	0x7828	; 0x7828 <SetDigOut>
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
    d640:	80 91 10 06 	lds	r24, 0x0610
    d644:	81 11       	cpse	r24, r1
    d646:	f6 cf       	rjmp	.-20     	; 0xd634 <ApplCycle+0x120>
		else ResDigOut(DO_RS);
    d648:	81 e0       	ldi	r24, 0x01	; 1
    d64a:	0c 94 26 3c 	jmp	0x784c	; 0x784c <ResDigOut>

0000d64e <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimersInc();
    d64e:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <TimersInc>
	TimeInit();
    d652:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <TimeInit>
	MemCheckInit();
    d656:	0e 94 f3 29 	call	0x53e6	; 0x53e6 <MemCheckInit>

// ~~~~~~~~~~
void
DI_Init(void)
{
	DI_Init_Hard();
    d65a:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <DI_Init_Hard>
	LED_Init();
	DigitInit();
    d65e:	0e 94 6c 3c 	call	0x78d8	; 0x78d8 <DO_Init>
	OneWire_Init();
    d662:	0e 94 11 3d 	call	0x7a22	; 0x7a22 <OneWire_Init>
	USART_Init();
    d666:	0e 94 06 4c 	call	0x980c	; 0x980c <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    d66a:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {TimersInc();
    d66c:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <TimersInc>
		wdt_reset();
    d670:	a8 95       	wdr
		DigitIn();
    d672:	0e 94 c9 3b 	call	0x7792	; 0x7792 <DigitIn>
		DS18B20();
    d676:	0e 94 4c 3e 	call	0x7c98	; 0x7c98 <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
    d67a:	80 91 56 02 	lds	r24, 0x0256
    d67e:	87 30       	cpi	r24, 0x07	; 7
    d680:	a9 f7       	brne	.-22     	; 0xd66c <main+0x1e>

//	MemCheckMsg();

	ApplInit();
    d682:	0e 94 84 6a 	call	0xd508	; 0xd508 <ApplInit>
	
	ScanCycleInit();
    d686:	0e 94 26 2d 	call	0x5a4c	; 0x5a4c <ScanCycleInit>

	for(;;) {TimersInc();
    d68a:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <TimersInc>
		sei();
    d68e:	78 94       	sei

		TimeCycle();
    d690:	0e 94 78 2e 	call	0x5cf0	; 0x5cf0 <TimeCycle>
		DigitIn();
    d694:	0e 94 c9 3b 	call	0x7792	; 0x7792 <DigitIn>
		DS18B20();
    d698:	0e 94 4c 3e 	call	0x7c98	; 0x7c98 <DS18B20>
		USART_Cycle();
    d69c:	0e 94 7f 64 	call	0xc8fe	; 0xc8fe <USART_Cycle>

		ApplCycle();
    d6a0:	0e 94 8a 6a 	call	0xd514	; 0xd514 <ApplCycle>

		DigitOut();
    d6a4:	0e 94 39 3c 	call	0x7872	; 0x7872 <DigitOut>
    d6a8:	f0 cf       	rjmp	.-32     	; 0xd68a <main+0x3c>

0000d6aa <do_random>:
    d6aa:	8f 92       	push	r8
    d6ac:	9f 92       	push	r9
    d6ae:	af 92       	push	r10
    d6b0:	bf 92       	push	r11
    d6b2:	cf 92       	push	r12
    d6b4:	df 92       	push	r13
    d6b6:	ef 92       	push	r14
    d6b8:	ff 92       	push	r15
    d6ba:	cf 93       	push	r28
    d6bc:	df 93       	push	r29
    d6be:	ec 01       	movw	r28, r24
    d6c0:	68 81       	ld	r22, Y
    d6c2:	79 81       	ldd	r23, Y+1	; 0x01
    d6c4:	8a 81       	ldd	r24, Y+2	; 0x02
    d6c6:	9b 81       	ldd	r25, Y+3	; 0x03
    d6c8:	61 15       	cp	r22, r1
    d6ca:	71 05       	cpc	r23, r1
    d6cc:	81 05       	cpc	r24, r1
    d6ce:	91 05       	cpc	r25, r1
    d6d0:	21 f4       	brne	.+8      	; 0xd6da <do_random+0x30>
    d6d2:	64 e2       	ldi	r22, 0x24	; 36
    d6d4:	79 ed       	ldi	r23, 0xD9	; 217
    d6d6:	8b e5       	ldi	r24, 0x5B	; 91
    d6d8:	97 e0       	ldi	r25, 0x07	; 7
    d6da:	2d e1       	ldi	r18, 0x1D	; 29
    d6dc:	33 ef       	ldi	r19, 0xF3	; 243
    d6de:	41 e0       	ldi	r20, 0x01	; 1
    d6e0:	50 e0       	ldi	r21, 0x00	; 0
    d6e2:	0e 94 ef 74 	call	0xe9de	; 0xe9de <__divmodsi4>
    d6e6:	49 01       	movw	r8, r18
    d6e8:	5a 01       	movw	r10, r20
    d6ea:	9b 01       	movw	r18, r22
    d6ec:	ac 01       	movw	r20, r24
    d6ee:	a7 ea       	ldi	r26, 0xA7	; 167
    d6f0:	b1 e4       	ldi	r27, 0x41	; 65
    d6f2:	0e 94 14 75 	call	0xea28	; 0xea28 <__muluhisi3>
    d6f6:	6b 01       	movw	r12, r22
    d6f8:	7c 01       	movw	r14, r24
    d6fa:	ac ee       	ldi	r26, 0xEC	; 236
    d6fc:	b4 ef       	ldi	r27, 0xF4	; 244
    d6fe:	a5 01       	movw	r20, r10
    d700:	94 01       	movw	r18, r8
    d702:	0e 94 22 75 	call	0xea44	; 0xea44 <__mulohisi3>
    d706:	c6 0e       	add	r12, r22
    d708:	d7 1e       	adc	r13, r23
    d70a:	e8 1e       	adc	r14, r24
    d70c:	f9 1e       	adc	r15, r25
    d70e:	f7 fe       	sbrs	r15, 7
    d710:	06 c0       	rjmp	.+12     	; 0xd71e <do_random+0x74>
    d712:	81 e0       	ldi	r24, 0x01	; 1
    d714:	c8 1a       	sub	r12, r24
    d716:	d1 08       	sbc	r13, r1
    d718:	e1 08       	sbc	r14, r1
    d71a:	80 e8       	ldi	r24, 0x80	; 128
    d71c:	f8 0a       	sbc	r15, r24
    d71e:	c8 82       	st	Y, r12
    d720:	d9 82       	std	Y+1, r13	; 0x01
    d722:	ea 82       	std	Y+2, r14	; 0x02
    d724:	fb 82       	std	Y+3, r15	; 0x03
    d726:	c7 01       	movw	r24, r14
    d728:	b6 01       	movw	r22, r12
    d72a:	9f 77       	andi	r25, 0x7F	; 127
    d72c:	df 91       	pop	r29
    d72e:	cf 91       	pop	r28
    d730:	ff 90       	pop	r15
    d732:	ef 90       	pop	r14
    d734:	df 90       	pop	r13
    d736:	cf 90       	pop	r12
    d738:	bf 90       	pop	r11
    d73a:	af 90       	pop	r10
    d73c:	9f 90       	pop	r9
    d73e:	8f 90       	pop	r8
    d740:	08 95       	ret

0000d742 <random_r>:
    d742:	0c 94 55 6b 	jmp	0xd6aa	; 0xd6aa <do_random>

0000d746 <random>:
    d746:	80 e0       	ldi	r24, 0x00	; 0
    d748:	91 e0       	ldi	r25, 0x01	; 1
    d74a:	0c 94 55 6b 	jmp	0xd6aa	; 0xd6aa <do_random>

0000d74e <srandom>:
    d74e:	60 93 00 01 	sts	0x0100, r22
    d752:	70 93 01 01 	sts	0x0101, r23
    d756:	80 93 02 01 	sts	0x0102, r24
    d75a:	90 93 03 01 	sts	0x0103, r25
    d75e:	08 95       	ret

0000d760 <exit>:
    d760:	f8 94       	cli
    d762:	0c 94 36 75 	jmp	0xea6c	; 0xea6c <_exit>

0000d766 <memcpy_P>:
    d766:	fb 01       	movw	r30, r22
    d768:	dc 01       	movw	r26, r24
    d76a:	02 c0       	rjmp	.+4      	; 0xd770 <memcpy_P+0xa>
    d76c:	05 90       	lpm	r0, Z+
    d76e:	0d 92       	st	X+, r0
    d770:	41 50       	subi	r20, 0x01	; 1
    d772:	50 40       	sbci	r21, 0x00	; 0
    d774:	d8 f7       	brcc	.-10     	; 0xd76c <memcpy_P+0x6>
    d776:	08 95       	ret

0000d778 <strchr_P>:
    d778:	fc 01       	movw	r30, r24
    d77a:	05 90       	lpm	r0, Z+
    d77c:	06 16       	cp	r0, r22
    d77e:	21 f0       	breq	.+8      	; 0xd788 <strchr_P+0x10>
    d780:	00 20       	and	r0, r0
    d782:	d9 f7       	brne	.-10     	; 0xd77a <strchr_P+0x2>
    d784:	c0 01       	movw	r24, r0
    d786:	08 95       	ret
    d788:	31 97       	sbiw	r30, 0x01	; 1
    d78a:	cf 01       	movw	r24, r30
    d78c:	08 95       	ret

0000d78e <strcmp_P>:
    d78e:	fb 01       	movw	r30, r22
    d790:	dc 01       	movw	r26, r24
    d792:	8d 91       	ld	r24, X+
    d794:	05 90       	lpm	r0, Z+
    d796:	80 19       	sub	r24, r0
    d798:	01 10       	cpse	r0, r1
    d79a:	d9 f3       	breq	.-10     	; 0xd792 <strcmp_P+0x4>
    d79c:	99 0b       	sbc	r25, r25
    d79e:	08 95       	ret

0000d7a0 <strcpy_P>:
    d7a0:	fb 01       	movw	r30, r22
    d7a2:	dc 01       	movw	r26, r24
    d7a4:	05 90       	lpm	r0, Z+
    d7a6:	0d 92       	st	X+, r0
    d7a8:	00 20       	and	r0, r0
    d7aa:	e1 f7       	brne	.-8      	; 0xd7a4 <strcpy_P+0x4>
    d7ac:	08 95       	ret

0000d7ae <strlcpy_P>:
    d7ae:	dc 01       	movw	r26, r24
    d7b0:	fb 01       	movw	r30, r22
    d7b2:	41 50       	subi	r20, 0x01	; 1
    d7b4:	50 40       	sbci	r21, 0x00	; 0
    d7b6:	58 f0       	brcs	.+22     	; 0xd7ce <strlcpy_P+0x20>
    d7b8:	49 f0       	breq	.+18     	; 0xd7cc <strlcpy_P+0x1e>
    d7ba:	05 90       	lpm	r0, Z+
    d7bc:	0d 92       	st	X+, r0
    d7be:	00 20       	and	r0, r0
    d7c0:	c1 f7       	brne	.-16     	; 0xd7b2 <strlcpy_P+0x4>
    d7c2:	e6 1b       	sub	r30, r22
    d7c4:	f7 0b       	sbc	r31, r23
    d7c6:	31 97       	sbiw	r30, 0x01	; 1
    d7c8:	cf 01       	movw	r24, r30
    d7ca:	08 95       	ret
    d7cc:	1c 92       	st	X, r1
    d7ce:	05 90       	lpm	r0, Z+
    d7d0:	00 20       	and	r0, r0
    d7d2:	e9 f7       	brne	.-6      	; 0xd7ce <strlcpy_P+0x20>
    d7d4:	f6 cf       	rjmp	.-20     	; 0xd7c2 <strlcpy_P+0x14>

0000d7d6 <__strlen_P>:
    d7d6:	fc 01       	movw	r30, r24
    d7d8:	05 90       	lpm	r0, Z+
    d7da:	00 20       	and	r0, r0
    d7dc:	e9 f7       	brne	.-6      	; 0xd7d8 <__strlen_P+0x2>
    d7de:	80 95       	com	r24
    d7e0:	90 95       	com	r25
    d7e2:	8e 0f       	add	r24, r30
    d7e4:	9f 1f       	adc	r25, r31
    d7e6:	08 95       	ret

0000d7e8 <strncmp_P>:
    d7e8:	fb 01       	movw	r30, r22
    d7ea:	dc 01       	movw	r26, r24
    d7ec:	41 50       	subi	r20, 0x01	; 1
    d7ee:	50 40       	sbci	r21, 0x00	; 0
    d7f0:	30 f0       	brcs	.+12     	; 0xd7fe <strncmp_P+0x16>
    d7f2:	8d 91       	ld	r24, X+
    d7f4:	05 90       	lpm	r0, Z+
    d7f6:	80 19       	sub	r24, r0
    d7f8:	19 f4       	brne	.+6      	; 0xd800 <strncmp_P+0x18>
    d7fa:	00 20       	and	r0, r0
    d7fc:	b9 f7       	brne	.-18     	; 0xd7ec <strncmp_P+0x4>
    d7fe:	88 1b       	sub	r24, r24
    d800:	99 0b       	sbc	r25, r25
    d802:	08 95       	ret

0000d804 <strstr_P>:
    d804:	fb 01       	movw	r30, r22
    d806:	55 91       	lpm	r21, Z+
    d808:	55 23       	and	r21, r21
    d80a:	a9 f0       	breq	.+42     	; 0xd836 <strstr_P+0x32>
    d80c:	bf 01       	movw	r22, r30
    d80e:	dc 01       	movw	r26, r24
    d810:	4d 91       	ld	r20, X+
    d812:	45 17       	cp	r20, r21
    d814:	41 11       	cpse	r20, r1
    d816:	e1 f7       	brne	.-8      	; 0xd810 <strstr_P+0xc>
    d818:	59 f4       	brne	.+22     	; 0xd830 <strstr_P+0x2c>
    d81a:	cd 01       	movw	r24, r26
    d81c:	05 90       	lpm	r0, Z+
    d81e:	00 20       	and	r0, r0
    d820:	49 f0       	breq	.+18     	; 0xd834 <strstr_P+0x30>
    d822:	4d 91       	ld	r20, X+
    d824:	40 15       	cp	r20, r0
    d826:	41 11       	cpse	r20, r1
    d828:	c9 f3       	breq	.-14     	; 0xd81c <strstr_P+0x18>
    d82a:	fb 01       	movw	r30, r22
    d82c:	41 11       	cpse	r20, r1
    d82e:	ef cf       	rjmp	.-34     	; 0xd80e <strstr_P+0xa>
    d830:	81 e0       	ldi	r24, 0x01	; 1
    d832:	90 e0       	ldi	r25, 0x00	; 0
    d834:	01 97       	sbiw	r24, 0x01	; 1
    d836:	08 95       	ret

0000d838 <memcpy>:
    d838:	fb 01       	movw	r30, r22
    d83a:	dc 01       	movw	r26, r24
    d83c:	02 c0       	rjmp	.+4      	; 0xd842 <memcpy+0xa>
    d83e:	01 90       	ld	r0, Z+
    d840:	0d 92       	st	X+, r0
    d842:	41 50       	subi	r20, 0x01	; 1
    d844:	50 40       	sbci	r21, 0x00	; 0
    d846:	d8 f7       	brcc	.-10     	; 0xd83e <memcpy+0x6>
    d848:	08 95       	ret

0000d84a <strchr>:
    d84a:	fc 01       	movw	r30, r24
    d84c:	81 91       	ld	r24, Z+
    d84e:	86 17       	cp	r24, r22
    d850:	21 f0       	breq	.+8      	; 0xd85a <strchr+0x10>
    d852:	88 23       	and	r24, r24
    d854:	d9 f7       	brne	.-10     	; 0xd84c <strchr+0x2>
    d856:	99 27       	eor	r25, r25
    d858:	08 95       	ret
    d85a:	31 97       	sbiw	r30, 0x01	; 1
    d85c:	cf 01       	movw	r24, r30
    d85e:	08 95       	ret

0000d860 <strcmp>:
    d860:	fb 01       	movw	r30, r22
    d862:	dc 01       	movw	r26, r24
    d864:	8d 91       	ld	r24, X+
    d866:	01 90       	ld	r0, Z+
    d868:	80 19       	sub	r24, r0
    d86a:	01 10       	cpse	r0, r1
    d86c:	d9 f3       	breq	.-10     	; 0xd864 <strcmp+0x4>
    d86e:	99 0b       	sbc	r25, r25
    d870:	08 95       	ret

0000d872 <strcpy>:
    d872:	fb 01       	movw	r30, r22
    d874:	dc 01       	movw	r26, r24
    d876:	01 90       	ld	r0, Z+
    d878:	0d 92       	st	X+, r0
    d87a:	00 20       	and	r0, r0
    d87c:	e1 f7       	brne	.-8      	; 0xd876 <strcpy+0x4>
    d87e:	08 95       	ret

0000d880 <strncmp>:
    d880:	fb 01       	movw	r30, r22
    d882:	dc 01       	movw	r26, r24
    d884:	41 50       	subi	r20, 0x01	; 1
    d886:	50 40       	sbci	r21, 0x00	; 0
    d888:	30 f0       	brcs	.+12     	; 0xd896 <strncmp+0x16>
    d88a:	8d 91       	ld	r24, X+
    d88c:	01 90       	ld	r0, Z+
    d88e:	80 19       	sub	r24, r0
    d890:	19 f4       	brne	.+6      	; 0xd898 <strncmp+0x18>
    d892:	00 20       	and	r0, r0
    d894:	b9 f7       	brne	.-18     	; 0xd884 <strncmp+0x4>
    d896:	88 1b       	sub	r24, r24
    d898:	99 0b       	sbc	r25, r25
    d89a:	08 95       	ret

0000d89c <sprintf>:
    d89c:	0f 93       	push	r16
    d89e:	1f 93       	push	r17
    d8a0:	cf 93       	push	r28
    d8a2:	df 93       	push	r29
    d8a4:	cd b7       	in	r28, 0x3d	; 61
    d8a6:	de b7       	in	r29, 0x3e	; 62
    d8a8:	2e 97       	sbiw	r28, 0x0e	; 14
    d8aa:	0f b6       	in	r0, 0x3f	; 63
    d8ac:	f8 94       	cli
    d8ae:	de bf       	out	0x3e, r29	; 62
    d8b0:	0f be       	out	0x3f, r0	; 63
    d8b2:	cd bf       	out	0x3d, r28	; 61
    d8b4:	0d 89       	ldd	r16, Y+21	; 0x15
    d8b6:	1e 89       	ldd	r17, Y+22	; 0x16
    d8b8:	86 e0       	ldi	r24, 0x06	; 6
    d8ba:	8c 83       	std	Y+4, r24	; 0x04
    d8bc:	1a 83       	std	Y+2, r17	; 0x02
    d8be:	09 83       	std	Y+1, r16	; 0x01
    d8c0:	8f ef       	ldi	r24, 0xFF	; 255
    d8c2:	9f e7       	ldi	r25, 0x7F	; 127
    d8c4:	9e 83       	std	Y+6, r25	; 0x06
    d8c6:	8d 83       	std	Y+5, r24	; 0x05
    d8c8:	ae 01       	movw	r20, r28
    d8ca:	47 5e       	subi	r20, 0xE7	; 231
    d8cc:	5f 4f       	sbci	r21, 0xFF	; 255
    d8ce:	6f 89       	ldd	r22, Y+23	; 0x17
    d8d0:	78 8d       	ldd	r23, Y+24	; 0x18
    d8d2:	ce 01       	movw	r24, r28
    d8d4:	01 96       	adiw	r24, 0x01	; 1
    d8d6:	0e 94 7a 6e 	call	0xdcf4	; 0xdcf4 <vfprintf>
    d8da:	ef 81       	ldd	r30, Y+7	; 0x07
    d8dc:	f8 85       	ldd	r31, Y+8	; 0x08
    d8de:	e0 0f       	add	r30, r16
    d8e0:	f1 1f       	adc	r31, r17
    d8e2:	10 82       	st	Z, r1
    d8e4:	2e 96       	adiw	r28, 0x0e	; 14
    d8e6:	0f b6       	in	r0, 0x3f	; 63
    d8e8:	f8 94       	cli
    d8ea:	de bf       	out	0x3e, r29	; 62
    d8ec:	0f be       	out	0x3f, r0	; 63
    d8ee:	cd bf       	out	0x3d, r28	; 61
    d8f0:	df 91       	pop	r29
    d8f2:	cf 91       	pop	r28
    d8f4:	1f 91       	pop	r17
    d8f6:	0f 91       	pop	r16
    d8f8:	08 95       	ret

0000d8fa <sprintf_P>:
    d8fa:	0f 93       	push	r16
    d8fc:	1f 93       	push	r17
    d8fe:	cf 93       	push	r28
    d900:	df 93       	push	r29
    d902:	cd b7       	in	r28, 0x3d	; 61
    d904:	de b7       	in	r29, 0x3e	; 62
    d906:	2e 97       	sbiw	r28, 0x0e	; 14
    d908:	0f b6       	in	r0, 0x3f	; 63
    d90a:	f8 94       	cli
    d90c:	de bf       	out	0x3e, r29	; 62
    d90e:	0f be       	out	0x3f, r0	; 63
    d910:	cd bf       	out	0x3d, r28	; 61
    d912:	0d 89       	ldd	r16, Y+21	; 0x15
    d914:	1e 89       	ldd	r17, Y+22	; 0x16
    d916:	8e e0       	ldi	r24, 0x0E	; 14
    d918:	8c 83       	std	Y+4, r24	; 0x04
    d91a:	1a 83       	std	Y+2, r17	; 0x02
    d91c:	09 83       	std	Y+1, r16	; 0x01
    d91e:	8f ef       	ldi	r24, 0xFF	; 255
    d920:	9f e7       	ldi	r25, 0x7F	; 127
    d922:	9e 83       	std	Y+6, r25	; 0x06
    d924:	8d 83       	std	Y+5, r24	; 0x05
    d926:	ae 01       	movw	r20, r28
    d928:	47 5e       	subi	r20, 0xE7	; 231
    d92a:	5f 4f       	sbci	r21, 0xFF	; 255
    d92c:	6f 89       	ldd	r22, Y+23	; 0x17
    d92e:	78 8d       	ldd	r23, Y+24	; 0x18
    d930:	ce 01       	movw	r24, r28
    d932:	01 96       	adiw	r24, 0x01	; 1
    d934:	0e 94 7a 6e 	call	0xdcf4	; 0xdcf4 <vfprintf>
    d938:	ef 81       	ldd	r30, Y+7	; 0x07
    d93a:	f8 85       	ldd	r31, Y+8	; 0x08
    d93c:	e0 0f       	add	r30, r16
    d93e:	f1 1f       	adc	r31, r17
    d940:	10 82       	st	Z, r1
    d942:	2e 96       	adiw	r28, 0x0e	; 14
    d944:	0f b6       	in	r0, 0x3f	; 63
    d946:	f8 94       	cli
    d948:	de bf       	out	0x3e, r29	; 62
    d94a:	0f be       	out	0x3f, r0	; 63
    d94c:	cd bf       	out	0x3d, r28	; 61
    d94e:	df 91       	pop	r29
    d950:	cf 91       	pop	r28
    d952:	1f 91       	pop	r17
    d954:	0f 91       	pop	r16
    d956:	08 95       	ret

0000d958 <sscanf>:
    d958:	cf 93       	push	r28
    d95a:	df 93       	push	r29
    d95c:	cd b7       	in	r28, 0x3d	; 61
    d95e:	de b7       	in	r29, 0x3e	; 62
    d960:	2e 97       	sbiw	r28, 0x0e	; 14
    d962:	0f b6       	in	r0, 0x3f	; 63
    d964:	f8 94       	cli
    d966:	de bf       	out	0x3e, r29	; 62
    d968:	0f be       	out	0x3f, r0	; 63
    d96a:	cd bf       	out	0x3d, r28	; 61
    d96c:	85 e0       	ldi	r24, 0x05	; 5
    d96e:	8c 83       	std	Y+4, r24	; 0x04
    d970:	8b 89       	ldd	r24, Y+19	; 0x13
    d972:	9c 89       	ldd	r25, Y+20	; 0x14
    d974:	9a 83       	std	Y+2, r25	; 0x02
    d976:	89 83       	std	Y+1, r24	; 0x01
    d978:	ae 01       	movw	r20, r28
    d97a:	49 5e       	subi	r20, 0xE9	; 233
    d97c:	5f 4f       	sbci	r21, 0xFF	; 255
    d97e:	6d 89       	ldd	r22, Y+21	; 0x15
    d980:	7e 89       	ldd	r23, Y+22	; 0x16
    d982:	ce 01       	movw	r24, r28
    d984:	01 96       	adiw	r24, 0x01	; 1
    d986:	0e 94 12 72 	call	0xe424	; 0xe424 <vfscanf>
    d98a:	2e 96       	adiw	r28, 0x0e	; 14
    d98c:	0f b6       	in	r0, 0x3f	; 63
    d98e:	f8 94       	cli
    d990:	de bf       	out	0x3e, r29	; 62
    d992:	0f be       	out	0x3f, r0	; 63
    d994:	cd bf       	out	0x3d, r28	; 61
    d996:	df 91       	pop	r29
    d998:	cf 91       	pop	r28
    d99a:	08 95       	ret

0000d99c <sscanf_P>:
    d99c:	cf 93       	push	r28
    d99e:	df 93       	push	r29
    d9a0:	cd b7       	in	r28, 0x3d	; 61
    d9a2:	de b7       	in	r29, 0x3e	; 62
    d9a4:	2e 97       	sbiw	r28, 0x0e	; 14
    d9a6:	0f b6       	in	r0, 0x3f	; 63
    d9a8:	f8 94       	cli
    d9aa:	de bf       	out	0x3e, r29	; 62
    d9ac:	0f be       	out	0x3f, r0	; 63
    d9ae:	cd bf       	out	0x3d, r28	; 61
    d9b0:	8d e0       	ldi	r24, 0x0D	; 13
    d9b2:	8c 83       	std	Y+4, r24	; 0x04
    d9b4:	8b 89       	ldd	r24, Y+19	; 0x13
    d9b6:	9c 89       	ldd	r25, Y+20	; 0x14
    d9b8:	9a 83       	std	Y+2, r25	; 0x02
    d9ba:	89 83       	std	Y+1, r24	; 0x01
    d9bc:	ae 01       	movw	r20, r28
    d9be:	49 5e       	subi	r20, 0xE9	; 233
    d9c0:	5f 4f       	sbci	r21, 0xFF	; 255
    d9c2:	6d 89       	ldd	r22, Y+21	; 0x15
    d9c4:	7e 89       	ldd	r23, Y+22	; 0x16
    d9c6:	ce 01       	movw	r24, r28
    d9c8:	01 96       	adiw	r24, 0x01	; 1
    d9ca:	0e 94 12 72 	call	0xe424	; 0xe424 <vfscanf>
    d9ce:	2e 96       	adiw	r28, 0x0e	; 14
    d9d0:	0f b6       	in	r0, 0x3f	; 63
    d9d2:	f8 94       	cli
    d9d4:	de bf       	out	0x3e, r29	; 62
    d9d6:	0f be       	out	0x3f, r0	; 63
    d9d8:	cd bf       	out	0x3d, r28	; 61
    d9da:	df 91       	pop	r29
    d9dc:	cf 91       	pop	r28
    d9de:	08 95       	ret

0000d9e0 <__divsf3>:
    d9e0:	0c d0       	rcall	.+24     	; 0xd9fa <__divsf3x>
    d9e2:	eb c0       	rjmp	.+470    	; 0xdbba <__fp_round>
    d9e4:	e3 d0       	rcall	.+454    	; 0xdbac <__fp_pscB>
    d9e6:	40 f0       	brcs	.+16     	; 0xd9f8 <__divsf3+0x18>
    d9e8:	da d0       	rcall	.+436    	; 0xdb9e <__fp_pscA>
    d9ea:	30 f0       	brcs	.+12     	; 0xd9f8 <__divsf3+0x18>
    d9ec:	21 f4       	brne	.+8      	; 0xd9f6 <__divsf3+0x16>
    d9ee:	5f 3f       	cpi	r21, 0xFF	; 255
    d9f0:	19 f0       	breq	.+6      	; 0xd9f8 <__divsf3+0x18>
    d9f2:	cc c0       	rjmp	.+408    	; 0xdb8c <__fp_inf>
    d9f4:	51 11       	cpse	r21, r1
    d9f6:	15 c1       	rjmp	.+554    	; 0xdc22 <__fp_szero>
    d9f8:	cf c0       	rjmp	.+414    	; 0xdb98 <__fp_nan>

0000d9fa <__divsf3x>:
    d9fa:	f0 d0       	rcall	.+480    	; 0xdbdc <__fp_split3>
    d9fc:	98 f3       	brcs	.-26     	; 0xd9e4 <__divsf3+0x4>

0000d9fe <__divsf3_pse>:
    d9fe:	99 23       	and	r25, r25
    da00:	c9 f3       	breq	.-14     	; 0xd9f4 <__divsf3+0x14>
    da02:	55 23       	and	r21, r21
    da04:	b1 f3       	breq	.-20     	; 0xd9f2 <__divsf3+0x12>
    da06:	95 1b       	sub	r25, r21
    da08:	55 0b       	sbc	r21, r21
    da0a:	bb 27       	eor	r27, r27
    da0c:	aa 27       	eor	r26, r26
    da0e:	62 17       	cp	r22, r18
    da10:	73 07       	cpc	r23, r19
    da12:	84 07       	cpc	r24, r20
    da14:	38 f0       	brcs	.+14     	; 0xda24 <__divsf3_pse+0x26>
    da16:	9f 5f       	subi	r25, 0xFF	; 255
    da18:	5f 4f       	sbci	r21, 0xFF	; 255
    da1a:	22 0f       	add	r18, r18
    da1c:	33 1f       	adc	r19, r19
    da1e:	44 1f       	adc	r20, r20
    da20:	aa 1f       	adc	r26, r26
    da22:	a9 f3       	breq	.-22     	; 0xda0e <__divsf3_pse+0x10>
    da24:	33 d0       	rcall	.+102    	; 0xda8c <__divsf3_pse+0x8e>
    da26:	0e 2e       	mov	r0, r30
    da28:	3a f0       	brmi	.+14     	; 0xda38 <__divsf3_pse+0x3a>
    da2a:	e0 e8       	ldi	r30, 0x80	; 128
    da2c:	30 d0       	rcall	.+96     	; 0xda8e <__divsf3_pse+0x90>
    da2e:	91 50       	subi	r25, 0x01	; 1
    da30:	50 40       	sbci	r21, 0x00	; 0
    da32:	e6 95       	lsr	r30
    da34:	00 1c       	adc	r0, r0
    da36:	ca f7       	brpl	.-14     	; 0xda2a <__divsf3_pse+0x2c>
    da38:	29 d0       	rcall	.+82     	; 0xda8c <__divsf3_pse+0x8e>
    da3a:	fe 2f       	mov	r31, r30
    da3c:	27 d0       	rcall	.+78     	; 0xda8c <__divsf3_pse+0x8e>
    da3e:	66 0f       	add	r22, r22
    da40:	77 1f       	adc	r23, r23
    da42:	88 1f       	adc	r24, r24
    da44:	bb 1f       	adc	r27, r27
    da46:	26 17       	cp	r18, r22
    da48:	37 07       	cpc	r19, r23
    da4a:	48 07       	cpc	r20, r24
    da4c:	ab 07       	cpc	r26, r27
    da4e:	b0 e8       	ldi	r27, 0x80	; 128
    da50:	09 f0       	breq	.+2      	; 0xda54 <__divsf3_pse+0x56>
    da52:	bb 0b       	sbc	r27, r27
    da54:	80 2d       	mov	r24, r0
    da56:	bf 01       	movw	r22, r30
    da58:	ff 27       	eor	r31, r31
    da5a:	93 58       	subi	r25, 0x83	; 131
    da5c:	5f 4f       	sbci	r21, 0xFF	; 255
    da5e:	2a f0       	brmi	.+10     	; 0xda6a <__divsf3_pse+0x6c>
    da60:	9e 3f       	cpi	r25, 0xFE	; 254
    da62:	51 05       	cpc	r21, r1
    da64:	68 f0       	brcs	.+26     	; 0xda80 <__divsf3_pse+0x82>
    da66:	92 c0       	rjmp	.+292    	; 0xdb8c <__fp_inf>
    da68:	dc c0       	rjmp	.+440    	; 0xdc22 <__fp_szero>
    da6a:	5f 3f       	cpi	r21, 0xFF	; 255
    da6c:	ec f3       	brlt	.-6      	; 0xda68 <__divsf3_pse+0x6a>
    da6e:	98 3e       	cpi	r25, 0xE8	; 232
    da70:	dc f3       	brlt	.-10     	; 0xda68 <__divsf3_pse+0x6a>
    da72:	86 95       	lsr	r24
    da74:	77 95       	ror	r23
    da76:	67 95       	ror	r22
    da78:	b7 95       	ror	r27
    da7a:	f7 95       	ror	r31
    da7c:	9f 5f       	subi	r25, 0xFF	; 255
    da7e:	c9 f7       	brne	.-14     	; 0xda72 <__divsf3_pse+0x74>
    da80:	88 0f       	add	r24, r24
    da82:	91 1d       	adc	r25, r1
    da84:	96 95       	lsr	r25
    da86:	87 95       	ror	r24
    da88:	97 f9       	bld	r25, 7
    da8a:	08 95       	ret
    da8c:	e1 e0       	ldi	r30, 0x01	; 1
    da8e:	66 0f       	add	r22, r22
    da90:	77 1f       	adc	r23, r23
    da92:	88 1f       	adc	r24, r24
    da94:	bb 1f       	adc	r27, r27
    da96:	62 17       	cp	r22, r18
    da98:	73 07       	cpc	r23, r19
    da9a:	84 07       	cpc	r24, r20
    da9c:	ba 07       	cpc	r27, r26
    da9e:	20 f0       	brcs	.+8      	; 0xdaa8 <__divsf3_pse+0xaa>
    daa0:	62 1b       	sub	r22, r18
    daa2:	73 0b       	sbc	r23, r19
    daa4:	84 0b       	sbc	r24, r20
    daa6:	ba 0b       	sbc	r27, r26
    daa8:	ee 1f       	adc	r30, r30
    daaa:	88 f7       	brcc	.-30     	; 0xda8e <__divsf3_pse+0x90>
    daac:	e0 95       	com	r30
    daae:	08 95       	ret

0000dab0 <__fixsfsi>:
    dab0:	04 d0       	rcall	.+8      	; 0xdaba <__fixunssfsi>
    dab2:	68 94       	set
    dab4:	b1 11       	cpse	r27, r1
    dab6:	b5 c0       	rjmp	.+362    	; 0xdc22 <__fp_szero>
    dab8:	08 95       	ret

0000daba <__fixunssfsi>:
    daba:	98 d0       	rcall	.+304    	; 0xdbec <__fp_splitA>
    dabc:	88 f0       	brcs	.+34     	; 0xdae0 <__fixunssfsi+0x26>
    dabe:	9f 57       	subi	r25, 0x7F	; 127
    dac0:	90 f0       	brcs	.+36     	; 0xdae6 <__fixunssfsi+0x2c>
    dac2:	b9 2f       	mov	r27, r25
    dac4:	99 27       	eor	r25, r25
    dac6:	b7 51       	subi	r27, 0x17	; 23
    dac8:	a0 f0       	brcs	.+40     	; 0xdaf2 <__fixunssfsi+0x38>
    daca:	d1 f0       	breq	.+52     	; 0xdb00 <__fixunssfsi+0x46>
    dacc:	66 0f       	add	r22, r22
    dace:	77 1f       	adc	r23, r23
    dad0:	88 1f       	adc	r24, r24
    dad2:	99 1f       	adc	r25, r25
    dad4:	1a f0       	brmi	.+6      	; 0xdadc <__fixunssfsi+0x22>
    dad6:	ba 95       	dec	r27
    dad8:	c9 f7       	brne	.-14     	; 0xdacc <__fixunssfsi+0x12>
    dada:	12 c0       	rjmp	.+36     	; 0xdb00 <__fixunssfsi+0x46>
    dadc:	b1 30       	cpi	r27, 0x01	; 1
    dade:	81 f0       	breq	.+32     	; 0xdb00 <__fixunssfsi+0x46>
    dae0:	9f d0       	rcall	.+318    	; 0xdc20 <__fp_zero>
    dae2:	b1 e0       	ldi	r27, 0x01	; 1
    dae4:	08 95       	ret
    dae6:	9c c0       	rjmp	.+312    	; 0xdc20 <__fp_zero>
    dae8:	67 2f       	mov	r22, r23
    daea:	78 2f       	mov	r23, r24
    daec:	88 27       	eor	r24, r24
    daee:	b8 5f       	subi	r27, 0xF8	; 248
    daf0:	39 f0       	breq	.+14     	; 0xdb00 <__fixunssfsi+0x46>
    daf2:	b9 3f       	cpi	r27, 0xF9	; 249
    daf4:	cc f3       	brlt	.-14     	; 0xdae8 <__fixunssfsi+0x2e>
    daf6:	86 95       	lsr	r24
    daf8:	77 95       	ror	r23
    dafa:	67 95       	ror	r22
    dafc:	b3 95       	inc	r27
    dafe:	d9 f7       	brne	.-10     	; 0xdaf6 <__fixunssfsi+0x3c>
    db00:	3e f4       	brtc	.+14     	; 0xdb10 <__fixunssfsi+0x56>
    db02:	90 95       	com	r25
    db04:	80 95       	com	r24
    db06:	70 95       	com	r23
    db08:	61 95       	neg	r22
    db0a:	7f 4f       	sbci	r23, 0xFF	; 255
    db0c:	8f 4f       	sbci	r24, 0xFF	; 255
    db0e:	9f 4f       	sbci	r25, 0xFF	; 255
    db10:	08 95       	ret

0000db12 <__floatunsisf>:
    db12:	e8 94       	clt
    db14:	09 c0       	rjmp	.+18     	; 0xdb28 <__floatsisf+0x12>

0000db16 <__floatsisf>:
    db16:	97 fb       	bst	r25, 7
    db18:	3e f4       	brtc	.+14     	; 0xdb28 <__floatsisf+0x12>
    db1a:	90 95       	com	r25
    db1c:	80 95       	com	r24
    db1e:	70 95       	com	r23
    db20:	61 95       	neg	r22
    db22:	7f 4f       	sbci	r23, 0xFF	; 255
    db24:	8f 4f       	sbci	r24, 0xFF	; 255
    db26:	9f 4f       	sbci	r25, 0xFF	; 255
    db28:	99 23       	and	r25, r25
    db2a:	a9 f0       	breq	.+42     	; 0xdb56 <__floatsisf+0x40>
    db2c:	f9 2f       	mov	r31, r25
    db2e:	96 e9       	ldi	r25, 0x96	; 150
    db30:	bb 27       	eor	r27, r27
    db32:	93 95       	inc	r25
    db34:	f6 95       	lsr	r31
    db36:	87 95       	ror	r24
    db38:	77 95       	ror	r23
    db3a:	67 95       	ror	r22
    db3c:	b7 95       	ror	r27
    db3e:	f1 11       	cpse	r31, r1
    db40:	f8 cf       	rjmp	.-16     	; 0xdb32 <__floatsisf+0x1c>
    db42:	fa f4       	brpl	.+62     	; 0xdb82 <__floatsisf+0x6c>
    db44:	bb 0f       	add	r27, r27
    db46:	11 f4       	brne	.+4      	; 0xdb4c <__floatsisf+0x36>
    db48:	60 ff       	sbrs	r22, 0
    db4a:	1b c0       	rjmp	.+54     	; 0xdb82 <__floatsisf+0x6c>
    db4c:	6f 5f       	subi	r22, 0xFF	; 255
    db4e:	7f 4f       	sbci	r23, 0xFF	; 255
    db50:	8f 4f       	sbci	r24, 0xFF	; 255
    db52:	9f 4f       	sbci	r25, 0xFF	; 255
    db54:	16 c0       	rjmp	.+44     	; 0xdb82 <__floatsisf+0x6c>
    db56:	88 23       	and	r24, r24
    db58:	11 f0       	breq	.+4      	; 0xdb5e <__floatsisf+0x48>
    db5a:	96 e9       	ldi	r25, 0x96	; 150
    db5c:	11 c0       	rjmp	.+34     	; 0xdb80 <__floatsisf+0x6a>
    db5e:	77 23       	and	r23, r23
    db60:	21 f0       	breq	.+8      	; 0xdb6a <__floatsisf+0x54>
    db62:	9e e8       	ldi	r25, 0x8E	; 142
    db64:	87 2f       	mov	r24, r23
    db66:	76 2f       	mov	r23, r22
    db68:	05 c0       	rjmp	.+10     	; 0xdb74 <__floatsisf+0x5e>
    db6a:	66 23       	and	r22, r22
    db6c:	71 f0       	breq	.+28     	; 0xdb8a <__floatsisf+0x74>
    db6e:	96 e8       	ldi	r25, 0x86	; 134
    db70:	86 2f       	mov	r24, r22
    db72:	70 e0       	ldi	r23, 0x00	; 0
    db74:	60 e0       	ldi	r22, 0x00	; 0
    db76:	2a f0       	brmi	.+10     	; 0xdb82 <__floatsisf+0x6c>
    db78:	9a 95       	dec	r25
    db7a:	66 0f       	add	r22, r22
    db7c:	77 1f       	adc	r23, r23
    db7e:	88 1f       	adc	r24, r24
    db80:	da f7       	brpl	.-10     	; 0xdb78 <__floatsisf+0x62>
    db82:	88 0f       	add	r24, r24
    db84:	96 95       	lsr	r25
    db86:	87 95       	ror	r24
    db88:	97 f9       	bld	r25, 7
    db8a:	08 95       	ret

0000db8c <__fp_inf>:
    db8c:	97 f9       	bld	r25, 7
    db8e:	9f 67       	ori	r25, 0x7F	; 127
    db90:	80 e8       	ldi	r24, 0x80	; 128
    db92:	70 e0       	ldi	r23, 0x00	; 0
    db94:	60 e0       	ldi	r22, 0x00	; 0
    db96:	08 95       	ret

0000db98 <__fp_nan>:
    db98:	9f ef       	ldi	r25, 0xFF	; 255
    db9a:	80 ec       	ldi	r24, 0xC0	; 192
    db9c:	08 95       	ret

0000db9e <__fp_pscA>:
    db9e:	00 24       	eor	r0, r0
    dba0:	0a 94       	dec	r0
    dba2:	16 16       	cp	r1, r22
    dba4:	17 06       	cpc	r1, r23
    dba6:	18 06       	cpc	r1, r24
    dba8:	09 06       	cpc	r0, r25
    dbaa:	08 95       	ret

0000dbac <__fp_pscB>:
    dbac:	00 24       	eor	r0, r0
    dbae:	0a 94       	dec	r0
    dbb0:	12 16       	cp	r1, r18
    dbb2:	13 06       	cpc	r1, r19
    dbb4:	14 06       	cpc	r1, r20
    dbb6:	05 06       	cpc	r0, r21
    dbb8:	08 95       	ret

0000dbba <__fp_round>:
    dbba:	09 2e       	mov	r0, r25
    dbbc:	03 94       	inc	r0
    dbbe:	00 0c       	add	r0, r0
    dbc0:	11 f4       	brne	.+4      	; 0xdbc6 <__fp_round+0xc>
    dbc2:	88 23       	and	r24, r24
    dbc4:	52 f0       	brmi	.+20     	; 0xdbda <__fp_round+0x20>
    dbc6:	bb 0f       	add	r27, r27
    dbc8:	40 f4       	brcc	.+16     	; 0xdbda <__fp_round+0x20>
    dbca:	bf 2b       	or	r27, r31
    dbcc:	11 f4       	brne	.+4      	; 0xdbd2 <__fp_round+0x18>
    dbce:	60 ff       	sbrs	r22, 0
    dbd0:	04 c0       	rjmp	.+8      	; 0xdbda <__fp_round+0x20>
    dbd2:	6f 5f       	subi	r22, 0xFF	; 255
    dbd4:	7f 4f       	sbci	r23, 0xFF	; 255
    dbd6:	8f 4f       	sbci	r24, 0xFF	; 255
    dbd8:	9f 4f       	sbci	r25, 0xFF	; 255
    dbda:	08 95       	ret

0000dbdc <__fp_split3>:
    dbdc:	57 fd       	sbrc	r21, 7
    dbde:	90 58       	subi	r25, 0x80	; 128
    dbe0:	44 0f       	add	r20, r20
    dbe2:	55 1f       	adc	r21, r21
    dbe4:	59 f0       	breq	.+22     	; 0xdbfc <__fp_splitA+0x10>
    dbe6:	5f 3f       	cpi	r21, 0xFF	; 255
    dbe8:	71 f0       	breq	.+28     	; 0xdc06 <__fp_splitA+0x1a>
    dbea:	47 95       	ror	r20

0000dbec <__fp_splitA>:
    dbec:	88 0f       	add	r24, r24
    dbee:	97 fb       	bst	r25, 7
    dbf0:	99 1f       	adc	r25, r25
    dbf2:	61 f0       	breq	.+24     	; 0xdc0c <__fp_splitA+0x20>
    dbf4:	9f 3f       	cpi	r25, 0xFF	; 255
    dbf6:	79 f0       	breq	.+30     	; 0xdc16 <__fp_splitA+0x2a>
    dbf8:	87 95       	ror	r24
    dbfa:	08 95       	ret
    dbfc:	12 16       	cp	r1, r18
    dbfe:	13 06       	cpc	r1, r19
    dc00:	14 06       	cpc	r1, r20
    dc02:	55 1f       	adc	r21, r21
    dc04:	f2 cf       	rjmp	.-28     	; 0xdbea <__fp_split3+0xe>
    dc06:	46 95       	lsr	r20
    dc08:	f1 df       	rcall	.-30     	; 0xdbec <__fp_splitA>
    dc0a:	08 c0       	rjmp	.+16     	; 0xdc1c <__fp_splitA+0x30>
    dc0c:	16 16       	cp	r1, r22
    dc0e:	17 06       	cpc	r1, r23
    dc10:	18 06       	cpc	r1, r24
    dc12:	99 1f       	adc	r25, r25
    dc14:	f1 cf       	rjmp	.-30     	; 0xdbf8 <__fp_splitA+0xc>
    dc16:	86 95       	lsr	r24
    dc18:	71 05       	cpc	r23, r1
    dc1a:	61 05       	cpc	r22, r1
    dc1c:	08 94       	sec
    dc1e:	08 95       	ret

0000dc20 <__fp_zero>:
    dc20:	e8 94       	clt

0000dc22 <__fp_szero>:
    dc22:	bb 27       	eor	r27, r27
    dc24:	66 27       	eor	r22, r22
    dc26:	77 27       	eor	r23, r23
    dc28:	cb 01       	movw	r24, r22
    dc2a:	97 f9       	bld	r25, 7
    dc2c:	08 95       	ret

0000dc2e <__mulsf3>:
    dc2e:	0b d0       	rcall	.+22     	; 0xdc46 <__mulsf3x>
    dc30:	c4 cf       	rjmp	.-120    	; 0xdbba <__fp_round>
    dc32:	b5 df       	rcall	.-150    	; 0xdb9e <__fp_pscA>
    dc34:	28 f0       	brcs	.+10     	; 0xdc40 <__mulsf3+0x12>
    dc36:	ba df       	rcall	.-140    	; 0xdbac <__fp_pscB>
    dc38:	18 f0       	brcs	.+6      	; 0xdc40 <__mulsf3+0x12>
    dc3a:	95 23       	and	r25, r21
    dc3c:	09 f0       	breq	.+2      	; 0xdc40 <__mulsf3+0x12>
    dc3e:	a6 cf       	rjmp	.-180    	; 0xdb8c <__fp_inf>
    dc40:	ab cf       	rjmp	.-170    	; 0xdb98 <__fp_nan>
    dc42:	11 24       	eor	r1, r1
    dc44:	ee cf       	rjmp	.-36     	; 0xdc22 <__fp_szero>

0000dc46 <__mulsf3x>:
    dc46:	ca df       	rcall	.-108    	; 0xdbdc <__fp_split3>
    dc48:	a0 f3       	brcs	.-24     	; 0xdc32 <__mulsf3+0x4>

0000dc4a <__mulsf3_pse>:
    dc4a:	95 9f       	mul	r25, r21
    dc4c:	d1 f3       	breq	.-12     	; 0xdc42 <__mulsf3+0x14>
    dc4e:	95 0f       	add	r25, r21
    dc50:	50 e0       	ldi	r21, 0x00	; 0
    dc52:	55 1f       	adc	r21, r21
    dc54:	62 9f       	mul	r22, r18
    dc56:	f0 01       	movw	r30, r0
    dc58:	72 9f       	mul	r23, r18
    dc5a:	bb 27       	eor	r27, r27
    dc5c:	f0 0d       	add	r31, r0
    dc5e:	b1 1d       	adc	r27, r1
    dc60:	63 9f       	mul	r22, r19
    dc62:	aa 27       	eor	r26, r26
    dc64:	f0 0d       	add	r31, r0
    dc66:	b1 1d       	adc	r27, r1
    dc68:	aa 1f       	adc	r26, r26
    dc6a:	64 9f       	mul	r22, r20
    dc6c:	66 27       	eor	r22, r22
    dc6e:	b0 0d       	add	r27, r0
    dc70:	a1 1d       	adc	r26, r1
    dc72:	66 1f       	adc	r22, r22
    dc74:	82 9f       	mul	r24, r18
    dc76:	22 27       	eor	r18, r18
    dc78:	b0 0d       	add	r27, r0
    dc7a:	a1 1d       	adc	r26, r1
    dc7c:	62 1f       	adc	r22, r18
    dc7e:	73 9f       	mul	r23, r19
    dc80:	b0 0d       	add	r27, r0
    dc82:	a1 1d       	adc	r26, r1
    dc84:	62 1f       	adc	r22, r18
    dc86:	83 9f       	mul	r24, r19
    dc88:	a0 0d       	add	r26, r0
    dc8a:	61 1d       	adc	r22, r1
    dc8c:	22 1f       	adc	r18, r18
    dc8e:	74 9f       	mul	r23, r20
    dc90:	33 27       	eor	r19, r19
    dc92:	a0 0d       	add	r26, r0
    dc94:	61 1d       	adc	r22, r1
    dc96:	23 1f       	adc	r18, r19
    dc98:	84 9f       	mul	r24, r20
    dc9a:	60 0d       	add	r22, r0
    dc9c:	21 1d       	adc	r18, r1
    dc9e:	82 2f       	mov	r24, r18
    dca0:	76 2f       	mov	r23, r22
    dca2:	6a 2f       	mov	r22, r26
    dca4:	11 24       	eor	r1, r1
    dca6:	9f 57       	subi	r25, 0x7F	; 127
    dca8:	50 40       	sbci	r21, 0x00	; 0
    dcaa:	8a f0       	brmi	.+34     	; 0xdcce <__mulsf3_pse+0x84>
    dcac:	e1 f0       	breq	.+56     	; 0xdce6 <__mulsf3_pse+0x9c>
    dcae:	88 23       	and	r24, r24
    dcb0:	4a f0       	brmi	.+18     	; 0xdcc4 <__mulsf3_pse+0x7a>
    dcb2:	ee 0f       	add	r30, r30
    dcb4:	ff 1f       	adc	r31, r31
    dcb6:	bb 1f       	adc	r27, r27
    dcb8:	66 1f       	adc	r22, r22
    dcba:	77 1f       	adc	r23, r23
    dcbc:	88 1f       	adc	r24, r24
    dcbe:	91 50       	subi	r25, 0x01	; 1
    dcc0:	50 40       	sbci	r21, 0x00	; 0
    dcc2:	a9 f7       	brne	.-22     	; 0xdcae <__mulsf3_pse+0x64>
    dcc4:	9e 3f       	cpi	r25, 0xFE	; 254
    dcc6:	51 05       	cpc	r21, r1
    dcc8:	70 f0       	brcs	.+28     	; 0xdce6 <__mulsf3_pse+0x9c>
    dcca:	60 cf       	rjmp	.-320    	; 0xdb8c <__fp_inf>
    dccc:	aa cf       	rjmp	.-172    	; 0xdc22 <__fp_szero>
    dcce:	5f 3f       	cpi	r21, 0xFF	; 255
    dcd0:	ec f3       	brlt	.-6      	; 0xdccc <__mulsf3_pse+0x82>
    dcd2:	98 3e       	cpi	r25, 0xE8	; 232
    dcd4:	dc f3       	brlt	.-10     	; 0xdccc <__mulsf3_pse+0x82>
    dcd6:	86 95       	lsr	r24
    dcd8:	77 95       	ror	r23
    dcda:	67 95       	ror	r22
    dcdc:	b7 95       	ror	r27
    dcde:	f7 95       	ror	r31
    dce0:	e7 95       	ror	r30
    dce2:	9f 5f       	subi	r25, 0xFF	; 255
    dce4:	c1 f7       	brne	.-16     	; 0xdcd6 <__mulsf3_pse+0x8c>
    dce6:	fe 2b       	or	r31, r30
    dce8:	88 0f       	add	r24, r24
    dcea:	91 1d       	adc	r25, r1
    dcec:	96 95       	lsr	r25
    dcee:	87 95       	ror	r24
    dcf0:	97 f9       	bld	r25, 7
    dcf2:	08 95       	ret

0000dcf4 <vfprintf>:
    dcf4:	2f 92       	push	r2
    dcf6:	3f 92       	push	r3
    dcf8:	4f 92       	push	r4
    dcfa:	5f 92       	push	r5
    dcfc:	6f 92       	push	r6
    dcfe:	7f 92       	push	r7
    dd00:	8f 92       	push	r8
    dd02:	9f 92       	push	r9
    dd04:	af 92       	push	r10
    dd06:	bf 92       	push	r11
    dd08:	cf 92       	push	r12
    dd0a:	df 92       	push	r13
    dd0c:	ef 92       	push	r14
    dd0e:	ff 92       	push	r15
    dd10:	0f 93       	push	r16
    dd12:	1f 93       	push	r17
    dd14:	cf 93       	push	r28
    dd16:	df 93       	push	r29
    dd18:	cd b7       	in	r28, 0x3d	; 61
    dd1a:	de b7       	in	r29, 0x3e	; 62
    dd1c:	2c 97       	sbiw	r28, 0x0c	; 12
    dd1e:	0f b6       	in	r0, 0x3f	; 63
    dd20:	f8 94       	cli
    dd22:	de bf       	out	0x3e, r29	; 62
    dd24:	0f be       	out	0x3f, r0	; 63
    dd26:	cd bf       	out	0x3d, r28	; 61
    dd28:	7c 01       	movw	r14, r24
    dd2a:	6b 01       	movw	r12, r22
    dd2c:	8a 01       	movw	r16, r20
    dd2e:	fc 01       	movw	r30, r24
    dd30:	17 82       	std	Z+7, r1	; 0x07
    dd32:	16 82       	std	Z+6, r1	; 0x06
    dd34:	83 81       	ldd	r24, Z+3	; 0x03
    dd36:	81 ff       	sbrs	r24, 1
    dd38:	bd c1       	rjmp	.+890    	; 0xe0b4 <vfprintf+0x3c0>
    dd3a:	ce 01       	movw	r24, r28
    dd3c:	01 96       	adiw	r24, 0x01	; 1
    dd3e:	4c 01       	movw	r8, r24
    dd40:	f7 01       	movw	r30, r14
    dd42:	93 81       	ldd	r25, Z+3	; 0x03
    dd44:	f6 01       	movw	r30, r12
    dd46:	93 fd       	sbrc	r25, 3
    dd48:	85 91       	lpm	r24, Z+
    dd4a:	93 ff       	sbrs	r25, 3
    dd4c:	81 91       	ld	r24, Z+
    dd4e:	6f 01       	movw	r12, r30
    dd50:	88 23       	and	r24, r24
    dd52:	09 f4       	brne	.+2      	; 0xdd56 <vfprintf+0x62>
    dd54:	ab c1       	rjmp	.+854    	; 0xe0ac <vfprintf+0x3b8>
    dd56:	85 32       	cpi	r24, 0x25	; 37
    dd58:	39 f4       	brne	.+14     	; 0xdd68 <vfprintf+0x74>
    dd5a:	93 fd       	sbrc	r25, 3
    dd5c:	85 91       	lpm	r24, Z+
    dd5e:	93 ff       	sbrs	r25, 3
    dd60:	81 91       	ld	r24, Z+
    dd62:	6f 01       	movw	r12, r30
    dd64:	85 32       	cpi	r24, 0x25	; 37
    dd66:	29 f4       	brne	.+10     	; 0xdd72 <vfprintf+0x7e>
    dd68:	b7 01       	movw	r22, r14
    dd6a:	90 e0       	ldi	r25, 0x00	; 0
    dd6c:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    dd70:	e7 cf       	rjmp	.-50     	; 0xdd40 <vfprintf+0x4c>
    dd72:	51 2c       	mov	r5, r1
    dd74:	31 2c       	mov	r3, r1
    dd76:	20 e0       	ldi	r18, 0x00	; 0
    dd78:	20 32       	cpi	r18, 0x20	; 32
    dd7a:	a0 f4       	brcc	.+40     	; 0xdda4 <vfprintf+0xb0>
    dd7c:	8b 32       	cpi	r24, 0x2B	; 43
    dd7e:	69 f0       	breq	.+26     	; 0xdd9a <vfprintf+0xa6>
    dd80:	30 f4       	brcc	.+12     	; 0xdd8e <vfprintf+0x9a>
    dd82:	80 32       	cpi	r24, 0x20	; 32
    dd84:	59 f0       	breq	.+22     	; 0xdd9c <vfprintf+0xa8>
    dd86:	83 32       	cpi	r24, 0x23	; 35
    dd88:	69 f4       	brne	.+26     	; 0xdda4 <vfprintf+0xb0>
    dd8a:	20 61       	ori	r18, 0x10	; 16
    dd8c:	2c c0       	rjmp	.+88     	; 0xdde6 <vfprintf+0xf2>
    dd8e:	8d 32       	cpi	r24, 0x2D	; 45
    dd90:	39 f0       	breq	.+14     	; 0xdda0 <vfprintf+0xac>
    dd92:	80 33       	cpi	r24, 0x30	; 48
    dd94:	39 f4       	brne	.+14     	; 0xdda4 <vfprintf+0xb0>
    dd96:	21 60       	ori	r18, 0x01	; 1
    dd98:	26 c0       	rjmp	.+76     	; 0xdde6 <vfprintf+0xf2>
    dd9a:	22 60       	ori	r18, 0x02	; 2
    dd9c:	24 60       	ori	r18, 0x04	; 4
    dd9e:	23 c0       	rjmp	.+70     	; 0xdde6 <vfprintf+0xf2>
    dda0:	28 60       	ori	r18, 0x08	; 8
    dda2:	21 c0       	rjmp	.+66     	; 0xdde6 <vfprintf+0xf2>
    dda4:	27 fd       	sbrc	r18, 7
    dda6:	27 c0       	rjmp	.+78     	; 0xddf6 <vfprintf+0x102>
    dda8:	30 ed       	ldi	r19, 0xD0	; 208
    ddaa:	38 0f       	add	r19, r24
    ddac:	3a 30       	cpi	r19, 0x0A	; 10
    ddae:	78 f4       	brcc	.+30     	; 0xddce <vfprintf+0xda>
    ddb0:	26 ff       	sbrs	r18, 6
    ddb2:	06 c0       	rjmp	.+12     	; 0xddc0 <vfprintf+0xcc>
    ddb4:	fa e0       	ldi	r31, 0x0A	; 10
    ddb6:	5f 9e       	mul	r5, r31
    ddb8:	30 0d       	add	r19, r0
    ddba:	11 24       	eor	r1, r1
    ddbc:	53 2e       	mov	r5, r19
    ddbe:	13 c0       	rjmp	.+38     	; 0xdde6 <vfprintf+0xf2>
    ddc0:	8a e0       	ldi	r24, 0x0A	; 10
    ddc2:	38 9e       	mul	r3, r24
    ddc4:	30 0d       	add	r19, r0
    ddc6:	11 24       	eor	r1, r1
    ddc8:	33 2e       	mov	r3, r19
    ddca:	20 62       	ori	r18, 0x20	; 32
    ddcc:	0c c0       	rjmp	.+24     	; 0xdde6 <vfprintf+0xf2>
    ddce:	8e 32       	cpi	r24, 0x2E	; 46
    ddd0:	21 f4       	brne	.+8      	; 0xddda <vfprintf+0xe6>
    ddd2:	26 fd       	sbrc	r18, 6
    ddd4:	6b c1       	rjmp	.+726    	; 0xe0ac <vfprintf+0x3b8>
    ddd6:	20 64       	ori	r18, 0x40	; 64
    ddd8:	06 c0       	rjmp	.+12     	; 0xdde6 <vfprintf+0xf2>
    ddda:	8c 36       	cpi	r24, 0x6C	; 108
    dddc:	11 f4       	brne	.+4      	; 0xdde2 <vfprintf+0xee>
    ddde:	20 68       	ori	r18, 0x80	; 128
    dde0:	02 c0       	rjmp	.+4      	; 0xdde6 <vfprintf+0xf2>
    dde2:	88 36       	cpi	r24, 0x68	; 104
    dde4:	41 f4       	brne	.+16     	; 0xddf6 <vfprintf+0x102>
    dde6:	f6 01       	movw	r30, r12
    dde8:	93 fd       	sbrc	r25, 3
    ddea:	85 91       	lpm	r24, Z+
    ddec:	93 ff       	sbrs	r25, 3
    ddee:	81 91       	ld	r24, Z+
    ddf0:	6f 01       	movw	r12, r30
    ddf2:	81 11       	cpse	r24, r1
    ddf4:	c1 cf       	rjmp	.-126    	; 0xdd78 <vfprintf+0x84>
    ddf6:	98 2f       	mov	r25, r24
    ddf8:	9f 7d       	andi	r25, 0xDF	; 223
    ddfa:	95 54       	subi	r25, 0x45	; 69
    ddfc:	93 30       	cpi	r25, 0x03	; 3
    ddfe:	28 f4       	brcc	.+10     	; 0xde0a <vfprintf+0x116>
    de00:	0c 5f       	subi	r16, 0xFC	; 252
    de02:	1f 4f       	sbci	r17, 0xFF	; 255
    de04:	ff e3       	ldi	r31, 0x3F	; 63
    de06:	f9 83       	std	Y+1, r31	; 0x01
    de08:	0d c0       	rjmp	.+26     	; 0xde24 <vfprintf+0x130>
    de0a:	83 36       	cpi	r24, 0x63	; 99
    de0c:	31 f0       	breq	.+12     	; 0xde1a <vfprintf+0x126>
    de0e:	83 37       	cpi	r24, 0x73	; 115
    de10:	71 f0       	breq	.+28     	; 0xde2e <vfprintf+0x13a>
    de12:	83 35       	cpi	r24, 0x53	; 83
    de14:	09 f0       	breq	.+2      	; 0xde18 <vfprintf+0x124>
    de16:	5b c0       	rjmp	.+182    	; 0xdece <vfprintf+0x1da>
    de18:	22 c0       	rjmp	.+68     	; 0xde5e <vfprintf+0x16a>
    de1a:	f8 01       	movw	r30, r16
    de1c:	80 81       	ld	r24, Z
    de1e:	89 83       	std	Y+1, r24	; 0x01
    de20:	0e 5f       	subi	r16, 0xFE	; 254
    de22:	1f 4f       	sbci	r17, 0xFF	; 255
    de24:	44 24       	eor	r4, r4
    de26:	43 94       	inc	r4
    de28:	51 2c       	mov	r5, r1
    de2a:	54 01       	movw	r10, r8
    de2c:	15 c0       	rjmp	.+42     	; 0xde58 <vfprintf+0x164>
    de2e:	38 01       	movw	r6, r16
    de30:	f2 e0       	ldi	r31, 0x02	; 2
    de32:	6f 0e       	add	r6, r31
    de34:	71 1c       	adc	r7, r1
    de36:	f8 01       	movw	r30, r16
    de38:	a0 80       	ld	r10, Z
    de3a:	b1 80       	ldd	r11, Z+1	; 0x01
    de3c:	26 ff       	sbrs	r18, 6
    de3e:	03 c0       	rjmp	.+6      	; 0xde46 <vfprintf+0x152>
    de40:	65 2d       	mov	r22, r5
    de42:	70 e0       	ldi	r23, 0x00	; 0
    de44:	02 c0       	rjmp	.+4      	; 0xde4a <vfprintf+0x156>
    de46:	6f ef       	ldi	r22, 0xFF	; 255
    de48:	7f ef       	ldi	r23, 0xFF	; 255
    de4a:	c5 01       	movw	r24, r10
    de4c:	2c 87       	std	Y+12, r18	; 0x0c
    de4e:	0e 94 a4 73 	call	0xe748	; 0xe748 <strnlen>
    de52:	2c 01       	movw	r4, r24
    de54:	83 01       	movw	r16, r6
    de56:	2c 85       	ldd	r18, Y+12	; 0x0c
    de58:	2f 77       	andi	r18, 0x7F	; 127
    de5a:	22 2e       	mov	r2, r18
    de5c:	17 c0       	rjmp	.+46     	; 0xde8c <vfprintf+0x198>
    de5e:	38 01       	movw	r6, r16
    de60:	f2 e0       	ldi	r31, 0x02	; 2
    de62:	6f 0e       	add	r6, r31
    de64:	71 1c       	adc	r7, r1
    de66:	f8 01       	movw	r30, r16
    de68:	a0 80       	ld	r10, Z
    de6a:	b1 80       	ldd	r11, Z+1	; 0x01
    de6c:	26 ff       	sbrs	r18, 6
    de6e:	03 c0       	rjmp	.+6      	; 0xde76 <vfprintf+0x182>
    de70:	65 2d       	mov	r22, r5
    de72:	70 e0       	ldi	r23, 0x00	; 0
    de74:	02 c0       	rjmp	.+4      	; 0xde7a <vfprintf+0x186>
    de76:	6f ef       	ldi	r22, 0xFF	; 255
    de78:	7f ef       	ldi	r23, 0xFF	; 255
    de7a:	c5 01       	movw	r24, r10
    de7c:	2c 87       	std	Y+12, r18	; 0x0c
    de7e:	0e 94 99 73 	call	0xe732	; 0xe732 <strnlen_P>
    de82:	2c 01       	movw	r4, r24
    de84:	2c 85       	ldd	r18, Y+12	; 0x0c
    de86:	20 68       	ori	r18, 0x80	; 128
    de88:	22 2e       	mov	r2, r18
    de8a:	83 01       	movw	r16, r6
    de8c:	23 fc       	sbrc	r2, 3
    de8e:	1b c0       	rjmp	.+54     	; 0xdec6 <vfprintf+0x1d2>
    de90:	83 2d       	mov	r24, r3
    de92:	90 e0       	ldi	r25, 0x00	; 0
    de94:	48 16       	cp	r4, r24
    de96:	59 06       	cpc	r5, r25
    de98:	b0 f4       	brcc	.+44     	; 0xdec6 <vfprintf+0x1d2>
    de9a:	b7 01       	movw	r22, r14
    de9c:	80 e2       	ldi	r24, 0x20	; 32
    de9e:	90 e0       	ldi	r25, 0x00	; 0
    dea0:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    dea4:	3a 94       	dec	r3
    dea6:	f4 cf       	rjmp	.-24     	; 0xde90 <vfprintf+0x19c>
    dea8:	f5 01       	movw	r30, r10
    deaa:	27 fc       	sbrc	r2, 7
    deac:	85 91       	lpm	r24, Z+
    deae:	27 fe       	sbrs	r2, 7
    deb0:	81 91       	ld	r24, Z+
    deb2:	5f 01       	movw	r10, r30
    deb4:	b7 01       	movw	r22, r14
    deb6:	90 e0       	ldi	r25, 0x00	; 0
    deb8:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    debc:	31 10       	cpse	r3, r1
    debe:	3a 94       	dec	r3
    dec0:	f1 e0       	ldi	r31, 0x01	; 1
    dec2:	4f 1a       	sub	r4, r31
    dec4:	51 08       	sbc	r5, r1
    dec6:	41 14       	cp	r4, r1
    dec8:	51 04       	cpc	r5, r1
    deca:	71 f7       	brne	.-36     	; 0xdea8 <vfprintf+0x1b4>
    decc:	e5 c0       	rjmp	.+458    	; 0xe098 <vfprintf+0x3a4>
    dece:	84 36       	cpi	r24, 0x64	; 100
    ded0:	11 f0       	breq	.+4      	; 0xded6 <vfprintf+0x1e2>
    ded2:	89 36       	cpi	r24, 0x69	; 105
    ded4:	39 f5       	brne	.+78     	; 0xdf24 <vfprintf+0x230>
    ded6:	f8 01       	movw	r30, r16
    ded8:	27 ff       	sbrs	r18, 7
    deda:	07 c0       	rjmp	.+14     	; 0xdeea <vfprintf+0x1f6>
    dedc:	60 81       	ld	r22, Z
    dede:	71 81       	ldd	r23, Z+1	; 0x01
    dee0:	82 81       	ldd	r24, Z+2	; 0x02
    dee2:	93 81       	ldd	r25, Z+3	; 0x03
    dee4:	0c 5f       	subi	r16, 0xFC	; 252
    dee6:	1f 4f       	sbci	r17, 0xFF	; 255
    dee8:	08 c0       	rjmp	.+16     	; 0xdefa <vfprintf+0x206>
    deea:	60 81       	ld	r22, Z
    deec:	71 81       	ldd	r23, Z+1	; 0x01
    deee:	88 27       	eor	r24, r24
    def0:	77 fd       	sbrc	r23, 7
    def2:	80 95       	com	r24
    def4:	98 2f       	mov	r25, r24
    def6:	0e 5f       	subi	r16, 0xFE	; 254
    def8:	1f 4f       	sbci	r17, 0xFF	; 255
    defa:	2f 76       	andi	r18, 0x6F	; 111
    defc:	b2 2e       	mov	r11, r18
    defe:	97 ff       	sbrs	r25, 7
    df00:	09 c0       	rjmp	.+18     	; 0xdf14 <vfprintf+0x220>
    df02:	90 95       	com	r25
    df04:	80 95       	com	r24
    df06:	70 95       	com	r23
    df08:	61 95       	neg	r22
    df0a:	7f 4f       	sbci	r23, 0xFF	; 255
    df0c:	8f 4f       	sbci	r24, 0xFF	; 255
    df0e:	9f 4f       	sbci	r25, 0xFF	; 255
    df10:	20 68       	ori	r18, 0x80	; 128
    df12:	b2 2e       	mov	r11, r18
    df14:	2a e0       	ldi	r18, 0x0A	; 10
    df16:	30 e0       	ldi	r19, 0x00	; 0
    df18:	a4 01       	movw	r20, r8
    df1a:	0e 94 38 74 	call	0xe870	; 0xe870 <__ultoa_invert>
    df1e:	a8 2e       	mov	r10, r24
    df20:	a8 18       	sub	r10, r8
    df22:	44 c0       	rjmp	.+136    	; 0xdfac <vfprintf+0x2b8>
    df24:	85 37       	cpi	r24, 0x75	; 117
    df26:	29 f4       	brne	.+10     	; 0xdf32 <vfprintf+0x23e>
    df28:	2f 7e       	andi	r18, 0xEF	; 239
    df2a:	b2 2e       	mov	r11, r18
    df2c:	2a e0       	ldi	r18, 0x0A	; 10
    df2e:	30 e0       	ldi	r19, 0x00	; 0
    df30:	25 c0       	rjmp	.+74     	; 0xdf7c <vfprintf+0x288>
    df32:	f2 2f       	mov	r31, r18
    df34:	f9 7f       	andi	r31, 0xF9	; 249
    df36:	bf 2e       	mov	r11, r31
    df38:	8f 36       	cpi	r24, 0x6F	; 111
    df3a:	c1 f0       	breq	.+48     	; 0xdf6c <vfprintf+0x278>
    df3c:	18 f4       	brcc	.+6      	; 0xdf44 <vfprintf+0x250>
    df3e:	88 35       	cpi	r24, 0x58	; 88
    df40:	79 f0       	breq	.+30     	; 0xdf60 <vfprintf+0x26c>
    df42:	b4 c0       	rjmp	.+360    	; 0xe0ac <vfprintf+0x3b8>
    df44:	80 37       	cpi	r24, 0x70	; 112
    df46:	19 f0       	breq	.+6      	; 0xdf4e <vfprintf+0x25a>
    df48:	88 37       	cpi	r24, 0x78	; 120
    df4a:	21 f0       	breq	.+8      	; 0xdf54 <vfprintf+0x260>
    df4c:	af c0       	rjmp	.+350    	; 0xe0ac <vfprintf+0x3b8>
    df4e:	2f 2f       	mov	r18, r31
    df50:	20 61       	ori	r18, 0x10	; 16
    df52:	b2 2e       	mov	r11, r18
    df54:	b4 fe       	sbrs	r11, 4
    df56:	0d c0       	rjmp	.+26     	; 0xdf72 <vfprintf+0x27e>
    df58:	8b 2d       	mov	r24, r11
    df5a:	84 60       	ori	r24, 0x04	; 4
    df5c:	b8 2e       	mov	r11, r24
    df5e:	09 c0       	rjmp	.+18     	; 0xdf72 <vfprintf+0x27e>
    df60:	24 ff       	sbrs	r18, 4
    df62:	0a c0       	rjmp	.+20     	; 0xdf78 <vfprintf+0x284>
    df64:	9f 2f       	mov	r25, r31
    df66:	96 60       	ori	r25, 0x06	; 6
    df68:	b9 2e       	mov	r11, r25
    df6a:	06 c0       	rjmp	.+12     	; 0xdf78 <vfprintf+0x284>
    df6c:	28 e0       	ldi	r18, 0x08	; 8
    df6e:	30 e0       	ldi	r19, 0x00	; 0
    df70:	05 c0       	rjmp	.+10     	; 0xdf7c <vfprintf+0x288>
    df72:	20 e1       	ldi	r18, 0x10	; 16
    df74:	30 e0       	ldi	r19, 0x00	; 0
    df76:	02 c0       	rjmp	.+4      	; 0xdf7c <vfprintf+0x288>
    df78:	20 e1       	ldi	r18, 0x10	; 16
    df7a:	32 e0       	ldi	r19, 0x02	; 2
    df7c:	f8 01       	movw	r30, r16
    df7e:	b7 fe       	sbrs	r11, 7
    df80:	07 c0       	rjmp	.+14     	; 0xdf90 <vfprintf+0x29c>
    df82:	60 81       	ld	r22, Z
    df84:	71 81       	ldd	r23, Z+1	; 0x01
    df86:	82 81       	ldd	r24, Z+2	; 0x02
    df88:	93 81       	ldd	r25, Z+3	; 0x03
    df8a:	0c 5f       	subi	r16, 0xFC	; 252
    df8c:	1f 4f       	sbci	r17, 0xFF	; 255
    df8e:	06 c0       	rjmp	.+12     	; 0xdf9c <vfprintf+0x2a8>
    df90:	60 81       	ld	r22, Z
    df92:	71 81       	ldd	r23, Z+1	; 0x01
    df94:	80 e0       	ldi	r24, 0x00	; 0
    df96:	90 e0       	ldi	r25, 0x00	; 0
    df98:	0e 5f       	subi	r16, 0xFE	; 254
    df9a:	1f 4f       	sbci	r17, 0xFF	; 255
    df9c:	a4 01       	movw	r20, r8
    df9e:	0e 94 38 74 	call	0xe870	; 0xe870 <__ultoa_invert>
    dfa2:	a8 2e       	mov	r10, r24
    dfa4:	a8 18       	sub	r10, r8
    dfa6:	fb 2d       	mov	r31, r11
    dfa8:	ff 77       	andi	r31, 0x7F	; 127
    dfaa:	bf 2e       	mov	r11, r31
    dfac:	b6 fe       	sbrs	r11, 6
    dfae:	0b c0       	rjmp	.+22     	; 0xdfc6 <vfprintf+0x2d2>
    dfb0:	2b 2d       	mov	r18, r11
    dfb2:	2e 7f       	andi	r18, 0xFE	; 254
    dfb4:	a5 14       	cp	r10, r5
    dfb6:	50 f4       	brcc	.+20     	; 0xdfcc <vfprintf+0x2d8>
    dfb8:	b4 fe       	sbrs	r11, 4
    dfba:	0a c0       	rjmp	.+20     	; 0xdfd0 <vfprintf+0x2dc>
    dfbc:	b2 fc       	sbrc	r11, 2
    dfbe:	08 c0       	rjmp	.+16     	; 0xdfd0 <vfprintf+0x2dc>
    dfc0:	2b 2d       	mov	r18, r11
    dfc2:	2e 7e       	andi	r18, 0xEE	; 238
    dfc4:	05 c0       	rjmp	.+10     	; 0xdfd0 <vfprintf+0x2dc>
    dfc6:	7a 2c       	mov	r7, r10
    dfc8:	2b 2d       	mov	r18, r11
    dfca:	03 c0       	rjmp	.+6      	; 0xdfd2 <vfprintf+0x2de>
    dfcc:	7a 2c       	mov	r7, r10
    dfce:	01 c0       	rjmp	.+2      	; 0xdfd2 <vfprintf+0x2de>
    dfd0:	75 2c       	mov	r7, r5
    dfd2:	24 ff       	sbrs	r18, 4
    dfd4:	0d c0       	rjmp	.+26     	; 0xdff0 <vfprintf+0x2fc>
    dfd6:	fe 01       	movw	r30, r28
    dfd8:	ea 0d       	add	r30, r10
    dfda:	f1 1d       	adc	r31, r1
    dfdc:	80 81       	ld	r24, Z
    dfde:	80 33       	cpi	r24, 0x30	; 48
    dfe0:	11 f4       	brne	.+4      	; 0xdfe6 <vfprintf+0x2f2>
    dfe2:	29 7e       	andi	r18, 0xE9	; 233
    dfe4:	09 c0       	rjmp	.+18     	; 0xdff8 <vfprintf+0x304>
    dfe6:	22 ff       	sbrs	r18, 2
    dfe8:	06 c0       	rjmp	.+12     	; 0xdff6 <vfprintf+0x302>
    dfea:	73 94       	inc	r7
    dfec:	73 94       	inc	r7
    dfee:	04 c0       	rjmp	.+8      	; 0xdff8 <vfprintf+0x304>
    dff0:	82 2f       	mov	r24, r18
    dff2:	86 78       	andi	r24, 0x86	; 134
    dff4:	09 f0       	breq	.+2      	; 0xdff8 <vfprintf+0x304>
    dff6:	73 94       	inc	r7
    dff8:	23 fd       	sbrc	r18, 3
    dffa:	13 c0       	rjmp	.+38     	; 0xe022 <vfprintf+0x32e>
    dffc:	20 ff       	sbrs	r18, 0
    dffe:	06 c0       	rjmp	.+12     	; 0xe00c <vfprintf+0x318>
    e000:	5a 2c       	mov	r5, r10
    e002:	73 14       	cp	r7, r3
    e004:	18 f4       	brcc	.+6      	; 0xe00c <vfprintf+0x318>
    e006:	53 0c       	add	r5, r3
    e008:	57 18       	sub	r5, r7
    e00a:	73 2c       	mov	r7, r3
    e00c:	73 14       	cp	r7, r3
    e00e:	68 f4       	brcc	.+26     	; 0xe02a <vfprintf+0x336>
    e010:	b7 01       	movw	r22, r14
    e012:	80 e2       	ldi	r24, 0x20	; 32
    e014:	90 e0       	ldi	r25, 0x00	; 0
    e016:	2c 87       	std	Y+12, r18	; 0x0c
    e018:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e01c:	73 94       	inc	r7
    e01e:	2c 85       	ldd	r18, Y+12	; 0x0c
    e020:	f5 cf       	rjmp	.-22     	; 0xe00c <vfprintf+0x318>
    e022:	73 14       	cp	r7, r3
    e024:	10 f4       	brcc	.+4      	; 0xe02a <vfprintf+0x336>
    e026:	37 18       	sub	r3, r7
    e028:	01 c0       	rjmp	.+2      	; 0xe02c <vfprintf+0x338>
    e02a:	31 2c       	mov	r3, r1
    e02c:	24 ff       	sbrs	r18, 4
    e02e:	12 c0       	rjmp	.+36     	; 0xe054 <vfprintf+0x360>
    e030:	b7 01       	movw	r22, r14
    e032:	80 e3       	ldi	r24, 0x30	; 48
    e034:	90 e0       	ldi	r25, 0x00	; 0
    e036:	2c 87       	std	Y+12, r18	; 0x0c
    e038:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e03c:	2c 85       	ldd	r18, Y+12	; 0x0c
    e03e:	22 ff       	sbrs	r18, 2
    e040:	17 c0       	rjmp	.+46     	; 0xe070 <vfprintf+0x37c>
    e042:	21 ff       	sbrs	r18, 1
    e044:	03 c0       	rjmp	.+6      	; 0xe04c <vfprintf+0x358>
    e046:	88 e5       	ldi	r24, 0x58	; 88
    e048:	90 e0       	ldi	r25, 0x00	; 0
    e04a:	02 c0       	rjmp	.+4      	; 0xe050 <vfprintf+0x35c>
    e04c:	88 e7       	ldi	r24, 0x78	; 120
    e04e:	90 e0       	ldi	r25, 0x00	; 0
    e050:	b7 01       	movw	r22, r14
    e052:	0c c0       	rjmp	.+24     	; 0xe06c <vfprintf+0x378>
    e054:	82 2f       	mov	r24, r18
    e056:	86 78       	andi	r24, 0x86	; 134
    e058:	59 f0       	breq	.+22     	; 0xe070 <vfprintf+0x37c>
    e05a:	21 fd       	sbrc	r18, 1
    e05c:	02 c0       	rjmp	.+4      	; 0xe062 <vfprintf+0x36e>
    e05e:	80 e2       	ldi	r24, 0x20	; 32
    e060:	01 c0       	rjmp	.+2      	; 0xe064 <vfprintf+0x370>
    e062:	8b e2       	ldi	r24, 0x2B	; 43
    e064:	27 fd       	sbrc	r18, 7
    e066:	8d e2       	ldi	r24, 0x2D	; 45
    e068:	b7 01       	movw	r22, r14
    e06a:	90 e0       	ldi	r25, 0x00	; 0
    e06c:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e070:	a5 14       	cp	r10, r5
    e072:	38 f4       	brcc	.+14     	; 0xe082 <vfprintf+0x38e>
    e074:	b7 01       	movw	r22, r14
    e076:	80 e3       	ldi	r24, 0x30	; 48
    e078:	90 e0       	ldi	r25, 0x00	; 0
    e07a:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e07e:	5a 94       	dec	r5
    e080:	f7 cf       	rjmp	.-18     	; 0xe070 <vfprintf+0x37c>
    e082:	aa 94       	dec	r10
    e084:	f4 01       	movw	r30, r8
    e086:	ea 0d       	add	r30, r10
    e088:	f1 1d       	adc	r31, r1
    e08a:	80 81       	ld	r24, Z
    e08c:	b7 01       	movw	r22, r14
    e08e:	90 e0       	ldi	r25, 0x00	; 0
    e090:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e094:	a1 10       	cpse	r10, r1
    e096:	f5 cf       	rjmp	.-22     	; 0xe082 <vfprintf+0x38e>
    e098:	33 20       	and	r3, r3
    e09a:	09 f4       	brne	.+2      	; 0xe09e <vfprintf+0x3aa>
    e09c:	51 ce       	rjmp	.-862    	; 0xdd40 <vfprintf+0x4c>
    e09e:	b7 01       	movw	r22, r14
    e0a0:	80 e2       	ldi	r24, 0x20	; 32
    e0a2:	90 e0       	ldi	r25, 0x00	; 0
    e0a4:	0e 94 ed 73 	call	0xe7da	; 0xe7da <fputc>
    e0a8:	3a 94       	dec	r3
    e0aa:	f6 cf       	rjmp	.-20     	; 0xe098 <vfprintf+0x3a4>
    e0ac:	f7 01       	movw	r30, r14
    e0ae:	86 81       	ldd	r24, Z+6	; 0x06
    e0b0:	97 81       	ldd	r25, Z+7	; 0x07
    e0b2:	02 c0       	rjmp	.+4      	; 0xe0b8 <vfprintf+0x3c4>
    e0b4:	8f ef       	ldi	r24, 0xFF	; 255
    e0b6:	9f ef       	ldi	r25, 0xFF	; 255
    e0b8:	2c 96       	adiw	r28, 0x0c	; 12
    e0ba:	0f b6       	in	r0, 0x3f	; 63
    e0bc:	f8 94       	cli
    e0be:	de bf       	out	0x3e, r29	; 62
    e0c0:	0f be       	out	0x3f, r0	; 63
    e0c2:	cd bf       	out	0x3d, r28	; 61
    e0c4:	df 91       	pop	r29
    e0c6:	cf 91       	pop	r28
    e0c8:	1f 91       	pop	r17
    e0ca:	0f 91       	pop	r16
    e0cc:	ff 90       	pop	r15
    e0ce:	ef 90       	pop	r14
    e0d0:	df 90       	pop	r13
    e0d2:	cf 90       	pop	r12
    e0d4:	bf 90       	pop	r11
    e0d6:	af 90       	pop	r10
    e0d8:	9f 90       	pop	r9
    e0da:	8f 90       	pop	r8
    e0dc:	7f 90       	pop	r7
    e0de:	6f 90       	pop	r6
    e0e0:	5f 90       	pop	r5
    e0e2:	4f 90       	pop	r4
    e0e4:	3f 90       	pop	r3
    e0e6:	2f 90       	pop	r2
    e0e8:	08 95       	ret

0000e0ea <putval>:
    e0ea:	20 fd       	sbrc	r18, 0
    e0ec:	09 c0       	rjmp	.+18     	; 0xe100 <putval+0x16>
    e0ee:	fc 01       	movw	r30, r24
    e0f0:	23 fd       	sbrc	r18, 3
    e0f2:	05 c0       	rjmp	.+10     	; 0xe0fe <putval+0x14>
    e0f4:	22 ff       	sbrs	r18, 2
    e0f6:	02 c0       	rjmp	.+4      	; 0xe0fc <putval+0x12>
    e0f8:	73 83       	std	Z+3, r23	; 0x03
    e0fa:	62 83       	std	Z+2, r22	; 0x02
    e0fc:	51 83       	std	Z+1, r21	; 0x01
    e0fe:	40 83       	st	Z, r20
    e100:	08 95       	ret

0000e102 <mulacc>:
    e102:	44 fd       	sbrc	r20, 4
    e104:	10 c0       	rjmp	.+32     	; 0xe126 <mulacc+0x24>
    e106:	46 fd       	sbrc	r20, 6
    e108:	10 c0       	rjmp	.+32     	; 0xe12a <mulacc+0x28>
    e10a:	db 01       	movw	r26, r22
    e10c:	fc 01       	movw	r30, r24
    e10e:	aa 0f       	add	r26, r26
    e110:	bb 1f       	adc	r27, r27
    e112:	ee 1f       	adc	r30, r30
    e114:	ff 1f       	adc	r31, r31
    e116:	10 94       	com	r1
    e118:	d1 f7       	brne	.-12     	; 0xe10e <mulacc+0xc>
    e11a:	6a 0f       	add	r22, r26
    e11c:	7b 1f       	adc	r23, r27
    e11e:	8e 1f       	adc	r24, r30
    e120:	9f 1f       	adc	r25, r31
    e122:	31 e0       	ldi	r19, 0x01	; 1
    e124:	03 c0       	rjmp	.+6      	; 0xe12c <mulacc+0x2a>
    e126:	33 e0       	ldi	r19, 0x03	; 3
    e128:	01 c0       	rjmp	.+2      	; 0xe12c <mulacc+0x2a>
    e12a:	34 e0       	ldi	r19, 0x04	; 4
    e12c:	66 0f       	add	r22, r22
    e12e:	77 1f       	adc	r23, r23
    e130:	88 1f       	adc	r24, r24
    e132:	99 1f       	adc	r25, r25
    e134:	31 50       	subi	r19, 0x01	; 1
    e136:	d1 f7       	brne	.-12     	; 0xe12c <mulacc+0x2a>
    e138:	62 0f       	add	r22, r18
    e13a:	71 1d       	adc	r23, r1
    e13c:	81 1d       	adc	r24, r1
    e13e:	91 1d       	adc	r25, r1
    e140:	08 95       	ret

0000e142 <skip_spaces>:
    e142:	0f 93       	push	r16
    e144:	1f 93       	push	r17
    e146:	cf 93       	push	r28
    e148:	df 93       	push	r29
    e14a:	8c 01       	movw	r16, r24
    e14c:	c8 01       	movw	r24, r16
    e14e:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e152:	ec 01       	movw	r28, r24
    e154:	97 fd       	sbrc	r25, 7
    e156:	08 c0       	rjmp	.+16     	; 0xe168 <skip_spaces+0x26>
    e158:	0e 94 91 73 	call	0xe722	; 0xe722 <isspace>
    e15c:	89 2b       	or	r24, r25
    e15e:	b1 f7       	brne	.-20     	; 0xe14c <skip_spaces+0xa>
    e160:	b8 01       	movw	r22, r16
    e162:	ce 01       	movw	r24, r28
    e164:	0e 94 1f 74 	call	0xe83e	; 0xe83e <ungetc>
    e168:	ce 01       	movw	r24, r28
    e16a:	df 91       	pop	r29
    e16c:	cf 91       	pop	r28
    e16e:	1f 91       	pop	r17
    e170:	0f 91       	pop	r16
    e172:	08 95       	ret

0000e174 <conv_int>:
    e174:	8f 92       	push	r8
    e176:	9f 92       	push	r9
    e178:	af 92       	push	r10
    e17a:	cf 92       	push	r12
    e17c:	df 92       	push	r13
    e17e:	ef 92       	push	r14
    e180:	ff 92       	push	r15
    e182:	0f 93       	push	r16
    e184:	1f 93       	push	r17
    e186:	cf 93       	push	r28
    e188:	df 93       	push	r29
    e18a:	ec 01       	movw	r28, r24
    e18c:	a6 2e       	mov	r10, r22
    e18e:	4a 01       	movw	r8, r20
    e190:	02 2f       	mov	r16, r18
    e192:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e196:	ac 01       	movw	r20, r24
    e198:	55 27       	eor	r21, r21
    e19a:	4b 32       	cpi	r20, 0x2B	; 43
    e19c:	51 05       	cpc	r21, r1
    e19e:	21 f0       	breq	.+8      	; 0xe1a8 <conv_int+0x34>
    e1a0:	4d 32       	cpi	r20, 0x2D	; 45
    e1a2:	51 05       	cpc	r21, r1
    e1a4:	51 f4       	brne	.+20     	; 0xe1ba <conv_int+0x46>
    e1a6:	00 68       	ori	r16, 0x80	; 128
    e1a8:	aa 94       	dec	r10
    e1aa:	11 f4       	brne	.+4      	; 0xe1b0 <conv_int+0x3c>
    e1ac:	80 e0       	ldi	r24, 0x00	; 0
    e1ae:	67 c0       	rjmp	.+206    	; 0xe27e <conv_int+0x10a>
    e1b0:	ce 01       	movw	r24, r28
    e1b2:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e1b6:	97 fd       	sbrc	r25, 7
    e1b8:	f9 cf       	rjmp	.-14     	; 0xe1ac <conv_int+0x38>
    e1ba:	10 2f       	mov	r17, r16
    e1bc:	1d 7f       	andi	r17, 0xFD	; 253
    e1be:	30 2f       	mov	r19, r16
    e1c0:	30 73       	andi	r19, 0x30	; 48
    e1c2:	01 f5       	brne	.+64     	; 0xe204 <conv_int+0x90>
    e1c4:	80 33       	cpi	r24, 0x30	; 48
    e1c6:	f1 f4       	brne	.+60     	; 0xe204 <conv_int+0x90>
    e1c8:	ff 24       	eor	r15, r15
    e1ca:	fa 94       	dec	r15
    e1cc:	fa 0c       	add	r15, r10
    e1ce:	09 f4       	brne	.+2      	; 0xe1d2 <conv_int+0x5e>
    e1d0:	42 c0       	rjmp	.+132    	; 0xe256 <conv_int+0xe2>
    e1d2:	ce 01       	movw	r24, r28
    e1d4:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e1d8:	97 fd       	sbrc	r25, 7
    e1da:	3d c0       	rjmp	.+122    	; 0xe256 <conv_int+0xe2>
    e1dc:	38 2f       	mov	r19, r24
    e1de:	3f 7d       	andi	r19, 0xDF	; 223
    e1e0:	38 35       	cpi	r19, 0x58	; 88
    e1e2:	51 f4       	brne	.+20     	; 0xe1f8 <conv_int+0x84>
    e1e4:	12 64       	ori	r17, 0x42	; 66
    e1e6:	aa 94       	dec	r10
    e1e8:	aa 94       	dec	r10
    e1ea:	a9 f1       	breq	.+106    	; 0xe256 <conv_int+0xe2>
    e1ec:	ce 01       	movw	r24, r28
    e1ee:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e1f2:	97 ff       	sbrs	r25, 7
    e1f4:	07 c0       	rjmp	.+14     	; 0xe204 <conv_int+0x90>
    e1f6:	2f c0       	rjmp	.+94     	; 0xe256 <conv_int+0xe2>
    e1f8:	06 ff       	sbrs	r16, 6
    e1fa:	02 c0       	rjmp	.+4      	; 0xe200 <conv_int+0x8c>
    e1fc:	12 60       	ori	r17, 0x02	; 2
    e1fe:	01 c0       	rjmp	.+2      	; 0xe202 <conv_int+0x8e>
    e200:	12 61       	ori	r17, 0x12	; 18
    e202:	af 2c       	mov	r10, r15
    e204:	c1 2c       	mov	r12, r1
    e206:	d1 2c       	mov	r13, r1
    e208:	76 01       	movw	r14, r12
    e20a:	20 ed       	ldi	r18, 0xD0	; 208
    e20c:	28 0f       	add	r18, r24
    e20e:	28 30       	cpi	r18, 0x08	; 8
    e210:	80 f0       	brcs	.+32     	; 0xe232 <conv_int+0xbe>
    e212:	14 ff       	sbrs	r17, 4
    e214:	04 c0       	rjmp	.+8      	; 0xe21e <conv_int+0xaa>
    e216:	be 01       	movw	r22, r28
    e218:	0e 94 1f 74 	call	0xe83e	; 0xe83e <ungetc>
    e21c:	19 c0       	rjmp	.+50     	; 0xe250 <conv_int+0xdc>
    e21e:	2a 30       	cpi	r18, 0x0A	; 10
    e220:	40 f0       	brcs	.+16     	; 0xe232 <conv_int+0xbe>
    e222:	16 ff       	sbrs	r17, 6
    e224:	f8 cf       	rjmp	.-16     	; 0xe216 <conv_int+0xa2>
    e226:	2f 7d       	andi	r18, 0xDF	; 223
    e228:	3f ee       	ldi	r19, 0xEF	; 239
    e22a:	32 0f       	add	r19, r18
    e22c:	36 30       	cpi	r19, 0x06	; 6
    e22e:	98 f7       	brcc	.-26     	; 0xe216 <conv_int+0xa2>
    e230:	27 50       	subi	r18, 0x07	; 7
    e232:	41 2f       	mov	r20, r17
    e234:	c7 01       	movw	r24, r14
    e236:	b6 01       	movw	r22, r12
    e238:	0e 94 81 70 	call	0xe102	; 0xe102 <mulacc>
    e23c:	6b 01       	movw	r12, r22
    e23e:	7c 01       	movw	r14, r24
    e240:	12 60       	ori	r17, 0x02	; 2
    e242:	aa 94       	dec	r10
    e244:	59 f0       	breq	.+22     	; 0xe25c <conv_int+0xe8>
    e246:	ce 01       	movw	r24, r28
    e248:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e24c:	97 ff       	sbrs	r25, 7
    e24e:	dd cf       	rjmp	.-70     	; 0xe20a <conv_int+0x96>
    e250:	11 fd       	sbrc	r17, 1
    e252:	04 c0       	rjmp	.+8      	; 0xe25c <conv_int+0xe8>
    e254:	ab cf       	rjmp	.-170    	; 0xe1ac <conv_int+0x38>
    e256:	c1 2c       	mov	r12, r1
    e258:	d1 2c       	mov	r13, r1
    e25a:	76 01       	movw	r14, r12
    e25c:	17 ff       	sbrs	r17, 7
    e25e:	08 c0       	rjmp	.+16     	; 0xe270 <conv_int+0xfc>
    e260:	f0 94       	com	r15
    e262:	e0 94       	com	r14
    e264:	d0 94       	com	r13
    e266:	c0 94       	com	r12
    e268:	c1 1c       	adc	r12, r1
    e26a:	d1 1c       	adc	r13, r1
    e26c:	e1 1c       	adc	r14, r1
    e26e:	f1 1c       	adc	r15, r1
    e270:	21 2f       	mov	r18, r17
    e272:	b7 01       	movw	r22, r14
    e274:	a6 01       	movw	r20, r12
    e276:	c4 01       	movw	r24, r8
    e278:	0e 94 75 70 	call	0xe0ea	; 0xe0ea <putval>
    e27c:	81 e0       	ldi	r24, 0x01	; 1
    e27e:	df 91       	pop	r29
    e280:	cf 91       	pop	r28
    e282:	1f 91       	pop	r17
    e284:	0f 91       	pop	r16
    e286:	ff 90       	pop	r15
    e288:	ef 90       	pop	r14
    e28a:	df 90       	pop	r13
    e28c:	cf 90       	pop	r12
    e28e:	af 90       	pop	r10
    e290:	9f 90       	pop	r9
    e292:	8f 90       	pop	r8
    e294:	08 95       	ret

0000e296 <conv_brk>:
    e296:	7f 92       	push	r7
    e298:	8f 92       	push	r8
    e29a:	9f 92       	push	r9
    e29c:	af 92       	push	r10
    e29e:	bf 92       	push	r11
    e2a0:	cf 92       	push	r12
    e2a2:	df 92       	push	r13
    e2a4:	ef 92       	push	r14
    e2a6:	ff 92       	push	r15
    e2a8:	0f 93       	push	r16
    e2aa:	1f 93       	push	r17
    e2ac:	cf 93       	push	r28
    e2ae:	df 93       	push	r29
    e2b0:	cd b7       	in	r28, 0x3d	; 61
    e2b2:	de b7       	in	r29, 0x3e	; 62
    e2b4:	a1 97       	sbiw	r28, 0x21	; 33
    e2b6:	0f b6       	in	r0, 0x3f	; 63
    e2b8:	f8 94       	cli
    e2ba:	de bf       	out	0x3e, r29	; 62
    e2bc:	0f be       	out	0x3f, r0	; 63
    e2be:	cd bf       	out	0x3d, r28	; 61
    e2c0:	5c 01       	movw	r10, r24
    e2c2:	7a 01       	movw	r14, r20
    e2c4:	8e 01       	movw	r16, r28
    e2c6:	0f 5f       	subi	r16, 0xFF	; 255
    e2c8:	1f 4f       	sbci	r17, 0xFF	; 255
    e2ca:	68 01       	movw	r12, r16
    e2cc:	80 e2       	ldi	r24, 0x20	; 32
    e2ce:	d8 01       	movw	r26, r16
    e2d0:	1d 92       	st	X+, r1
    e2d2:	8a 95       	dec	r24
    e2d4:	e9 f7       	brne	.-6      	; 0xe2d0 <conv_brk+0x3a>
    e2d6:	f5 01       	movw	r30, r10
    e2d8:	73 80       	ldd	r7, Z+3	; 0x03
    e2da:	40 e0       	ldi	r20, 0x00	; 0
    e2dc:	50 e0       	ldi	r21, 0x00	; 0
    e2de:	81 2c       	mov	r8, r1
    e2e0:	b0 e0       	ldi	r27, 0x00	; 0
    e2e2:	91 2c       	mov	r9, r1
    e2e4:	81 e0       	ldi	r24, 0x01	; 1
    e2e6:	90 e0       	ldi	r25, 0x00	; 0
    e2e8:	f9 01       	movw	r30, r18
    e2ea:	73 fc       	sbrc	r7, 3
    e2ec:	a5 91       	lpm	r26, Z+
    e2ee:	73 fe       	sbrs	r7, 3
    e2f0:	a1 91       	ld	r26, Z+
    e2f2:	8f 01       	movw	r16, r30
    e2f4:	7a 2f       	mov	r23, r26
    e2f6:	9f 01       	movw	r18, r30
    e2f8:	a1 11       	cpse	r26, r1
    e2fa:	03 c0       	rjmp	.+6      	; 0xe302 <conv_brk+0x6c>
    e2fc:	80 e0       	ldi	r24, 0x00	; 0
    e2fe:	90 e0       	ldi	r25, 0x00	; 0
    e300:	7d c0       	rjmp	.+250    	; 0xe3fc <conv_brk+0x166>
    e302:	ae 35       	cpi	r26, 0x5E	; 94
    e304:	19 f4       	brne	.+6      	; 0xe30c <conv_brk+0x76>
    e306:	41 15       	cp	r20, r1
    e308:	51 05       	cpc	r21, r1
    e30a:	59 f1       	breq	.+86     	; 0xe362 <conv_brk+0xcc>
    e30c:	e9 2d       	mov	r30, r9
    e30e:	f0 e0       	ldi	r31, 0x00	; 0
    e310:	e4 17       	cp	r30, r20
    e312:	f5 07       	cpc	r31, r21
    e314:	3c f4       	brge	.+14     	; 0xe324 <conv_brk+0x8e>
    e316:	ad 35       	cpi	r26, 0x5D	; 93
    e318:	69 f1       	breq	.+90     	; 0xe374 <conv_brk+0xde>
    e31a:	ad 32       	cpi	r26, 0x2D	; 45
    e31c:	19 f4       	brne	.+6      	; 0xe324 <conv_brk+0x8e>
    e31e:	bb 23       	and	r27, r27
    e320:	19 f1       	breq	.+70     	; 0xe368 <conv_brk+0xd2>
    e322:	03 c0       	rjmp	.+6      	; 0xe32a <conv_brk+0x94>
    e324:	b1 11       	cpse	r27, r1
    e326:	01 c0       	rjmp	.+2      	; 0xe32a <conv_brk+0x94>
    e328:	8a 2e       	mov	r8, r26
    e32a:	e7 2f       	mov	r30, r23
    e32c:	e6 95       	lsr	r30
    e32e:	e6 95       	lsr	r30
    e330:	e6 95       	lsr	r30
    e332:	86 01       	movw	r16, r12
    e334:	0e 0f       	add	r16, r30
    e336:	11 1d       	adc	r17, r1
    e338:	f8 01       	movw	r30, r16
    e33a:	a7 2f       	mov	r26, r23
    e33c:	a7 70       	andi	r26, 0x07	; 7
    e33e:	8c 01       	movw	r16, r24
    e340:	02 c0       	rjmp	.+4      	; 0xe346 <conv_brk+0xb0>
    e342:	00 0f       	add	r16, r16
    e344:	11 1f       	adc	r17, r17
    e346:	aa 95       	dec	r26
    e348:	e2 f7       	brpl	.-8      	; 0xe342 <conv_brk+0xac>
    e34a:	d8 01       	movw	r26, r16
    e34c:	b0 81       	ld	r27, Z
    e34e:	ba 2b       	or	r27, r26
    e350:	b0 83       	st	Z, r27
    e352:	78 15       	cp	r23, r8
    e354:	59 f0       	breq	.+22     	; 0xe36c <conv_brk+0xd6>
    e356:	78 15       	cp	r23, r8
    e358:	10 f4       	brcc	.+4      	; 0xe35e <conv_brk+0xc8>
    e35a:	7f 5f       	subi	r23, 0xFF	; 255
    e35c:	e6 cf       	rjmp	.-52     	; 0xe32a <conv_brk+0x94>
    e35e:	71 50       	subi	r23, 0x01	; 1
    e360:	e4 cf       	rjmp	.-56     	; 0xe32a <conv_brk+0x94>
    e362:	99 24       	eor	r9, r9
    e364:	93 94       	inc	r9
    e366:	03 c0       	rjmp	.+6      	; 0xe36e <conv_brk+0xd8>
    e368:	b1 e0       	ldi	r27, 0x01	; 1
    e36a:	01 c0       	rjmp	.+2      	; 0xe36e <conv_brk+0xd8>
    e36c:	b0 e0       	ldi	r27, 0x00	; 0
    e36e:	4f 5f       	subi	r20, 0xFF	; 255
    e370:	5f 4f       	sbci	r21, 0xFF	; 255
    e372:	ba cf       	rjmp	.-140    	; 0xe2e8 <conv_brk+0x52>
    e374:	bb 23       	and	r27, r27
    e376:	19 f0       	breq	.+6      	; 0xe37e <conv_brk+0xe8>
    e378:	8e 81       	ldd	r24, Y+6	; 0x06
    e37a:	80 62       	ori	r24, 0x20	; 32
    e37c:	8e 83       	std	Y+6, r24	; 0x06
    e37e:	91 10       	cpse	r9, r1
    e380:	03 c0       	rjmp	.+6      	; 0xe388 <conv_brk+0xf2>
    e382:	99 24       	eor	r9, r9
    e384:	93 94       	inc	r9
    e386:	15 c0       	rjmp	.+42     	; 0xe3b2 <conv_brk+0x11c>
    e388:	f6 01       	movw	r30, r12
    e38a:	ce 01       	movw	r24, r28
    e38c:	81 96       	adiw	r24, 0x21	; 33
    e38e:	20 81       	ld	r18, Z
    e390:	20 95       	com	r18
    e392:	21 93       	st	Z+, r18
    e394:	e8 17       	cp	r30, r24
    e396:	f9 07       	cpc	r31, r25
    e398:	d1 f7       	brne	.-12     	; 0xe38e <conv_brk+0xf8>
    e39a:	f3 cf       	rjmp	.-26     	; 0xe382 <conv_brk+0xec>
    e39c:	e1 14       	cp	r14, r1
    e39e:	f1 04       	cpc	r15, r1
    e3a0:	29 f0       	breq	.+10     	; 0xe3ac <conv_brk+0x116>
    e3a2:	d7 01       	movw	r26, r14
    e3a4:	8c 93       	st	X, r24
    e3a6:	f7 01       	movw	r30, r14
    e3a8:	31 96       	adiw	r30, 0x01	; 1
    e3aa:	7f 01       	movw	r14, r30
    e3ac:	61 50       	subi	r22, 0x01	; 1
    e3ae:	01 f1       	breq	.+64     	; 0xe3f0 <conv_brk+0x15a>
    e3b0:	91 2c       	mov	r9, r1
    e3b2:	c5 01       	movw	r24, r10
    e3b4:	69 a3       	std	Y+33, r22	; 0x21
    e3b6:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e3ba:	69 a1       	ldd	r22, Y+33	; 0x21
    e3bc:	97 fd       	sbrc	r25, 7
    e3be:	16 c0       	rjmp	.+44     	; 0xe3ec <conv_brk+0x156>
    e3c0:	28 2f       	mov	r18, r24
    e3c2:	26 95       	lsr	r18
    e3c4:	26 95       	lsr	r18
    e3c6:	26 95       	lsr	r18
    e3c8:	f6 01       	movw	r30, r12
    e3ca:	e2 0f       	add	r30, r18
    e3cc:	f1 1d       	adc	r31, r1
    e3ce:	20 81       	ld	r18, Z
    e3d0:	30 e0       	ldi	r19, 0x00	; 0
    e3d2:	ac 01       	movw	r20, r24
    e3d4:	47 70       	andi	r20, 0x07	; 7
    e3d6:	55 27       	eor	r21, r21
    e3d8:	02 c0       	rjmp	.+4      	; 0xe3de <conv_brk+0x148>
    e3da:	35 95       	asr	r19
    e3dc:	27 95       	ror	r18
    e3de:	4a 95       	dec	r20
    e3e0:	e2 f7       	brpl	.-8      	; 0xe3da <conv_brk+0x144>
    e3e2:	20 fd       	sbrc	r18, 0
    e3e4:	db cf       	rjmp	.-74     	; 0xe39c <conv_brk+0x106>
    e3e6:	b5 01       	movw	r22, r10
    e3e8:	0e 94 1f 74 	call	0xe83e	; 0xe83e <ungetc>
    e3ec:	91 10       	cpse	r9, r1
    e3ee:	86 cf       	rjmp	.-244    	; 0xe2fc <conv_brk+0x66>
    e3f0:	e1 14       	cp	r14, r1
    e3f2:	f1 04       	cpc	r15, r1
    e3f4:	11 f0       	breq	.+4      	; 0xe3fa <conv_brk+0x164>
    e3f6:	d7 01       	movw	r26, r14
    e3f8:	1c 92       	st	X, r1
    e3fa:	c8 01       	movw	r24, r16
    e3fc:	a1 96       	adiw	r28, 0x21	; 33
    e3fe:	0f b6       	in	r0, 0x3f	; 63
    e400:	f8 94       	cli
    e402:	de bf       	out	0x3e, r29	; 62
    e404:	0f be       	out	0x3f, r0	; 63
    e406:	cd bf       	out	0x3d, r28	; 61
    e408:	df 91       	pop	r29
    e40a:	cf 91       	pop	r28
    e40c:	1f 91       	pop	r17
    e40e:	0f 91       	pop	r16
    e410:	ff 90       	pop	r15
    e412:	ef 90       	pop	r14
    e414:	df 90       	pop	r13
    e416:	cf 90       	pop	r12
    e418:	bf 90       	pop	r11
    e41a:	af 90       	pop	r10
    e41c:	9f 90       	pop	r9
    e41e:	8f 90       	pop	r8
    e420:	7f 90       	pop	r7
    e422:	08 95       	ret

0000e424 <vfscanf>:
    e424:	4f 92       	push	r4
    e426:	5f 92       	push	r5
    e428:	7f 92       	push	r7
    e42a:	8f 92       	push	r8
    e42c:	9f 92       	push	r9
    e42e:	af 92       	push	r10
    e430:	bf 92       	push	r11
    e432:	cf 92       	push	r12
    e434:	df 92       	push	r13
    e436:	ef 92       	push	r14
    e438:	ff 92       	push	r15
    e43a:	0f 93       	push	r16
    e43c:	1f 93       	push	r17
    e43e:	cf 93       	push	r28
    e440:	df 93       	push	r29
    e442:	1f 92       	push	r1
    e444:	cd b7       	in	r28, 0x3d	; 61
    e446:	de b7       	in	r29, 0x3e	; 62
    e448:	8c 01       	movw	r16, r24
    e44a:	2b 01       	movw	r4, r22
    e44c:	7a 01       	movw	r14, r20
    e44e:	fc 01       	movw	r30, r24
    e450:	17 82       	std	Z+7, r1	; 0x07
    e452:	16 82       	std	Z+6, r1	; 0x06
    e454:	a1 2c       	mov	r10, r1
    e456:	f8 01       	movw	r30, r16
    e458:	d3 80       	ldd	r13, Z+3	; 0x03
    e45a:	f2 01       	movw	r30, r4
    e45c:	d3 fc       	sbrc	r13, 3
    e45e:	85 91       	lpm	r24, Z+
    e460:	d3 fe       	sbrs	r13, 3
    e462:	81 91       	ld	r24, Z+
    e464:	38 2f       	mov	r19, r24
    e466:	2f 01       	movw	r4, r30
    e468:	88 23       	and	r24, r24
    e46a:	09 f4       	brne	.+2      	; 0xe46e <vfscanf+0x4a>
    e46c:	fc c0       	rjmp	.+504    	; 0xe666 <vfscanf+0x242>
    e46e:	90 e0       	ldi	r25, 0x00	; 0
    e470:	39 83       	std	Y+1, r19	; 0x01
    e472:	0e 94 91 73 	call	0xe722	; 0xe722 <isspace>
    e476:	39 81       	ldd	r19, Y+1	; 0x01
    e478:	89 2b       	or	r24, r25
    e47a:	21 f0       	breq	.+8      	; 0xe484 <vfscanf+0x60>
    e47c:	c8 01       	movw	r24, r16
    e47e:	0e 94 a1 70 	call	0xe142	; 0xe142 <skip_spaces>
    e482:	e9 cf       	rjmp	.-46     	; 0xe456 <vfscanf+0x32>
    e484:	35 32       	cpi	r19, 0x25	; 37
    e486:	41 f4       	brne	.+16     	; 0xe498 <vfscanf+0x74>
    e488:	f2 01       	movw	r30, r4
    e48a:	d3 fc       	sbrc	r13, 3
    e48c:	35 91       	lpm	r19, Z+
    e48e:	d3 fe       	sbrs	r13, 3
    e490:	31 91       	ld	r19, Z+
    e492:	2f 01       	movw	r4, r30
    e494:	35 32       	cpi	r19, 0x25	; 37
    e496:	69 f4       	brne	.+26     	; 0xe4b2 <vfscanf+0x8e>
    e498:	c8 01       	movw	r24, r16
    e49a:	39 83       	std	Y+1, r19	; 0x01
    e49c:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e4a0:	39 81       	ldd	r19, Y+1	; 0x01
    e4a2:	97 fd       	sbrc	r25, 7
    e4a4:	de c0       	rjmp	.+444    	; 0xe662 <vfscanf+0x23e>
    e4a6:	38 17       	cp	r19, r24
    e4a8:	b1 f2       	breq	.-84     	; 0xe456 <vfscanf+0x32>
    e4aa:	b8 01       	movw	r22, r16
    e4ac:	0e 94 1f 74 	call	0xe83e	; 0xe83e <ungetc>
    e4b0:	da c0       	rjmp	.+436    	; 0xe666 <vfscanf+0x242>
    e4b2:	3a 32       	cpi	r19, 0x2A	; 42
    e4b4:	41 f4       	brne	.+16     	; 0xe4c6 <vfscanf+0xa2>
    e4b6:	d3 fc       	sbrc	r13, 3
    e4b8:	35 91       	lpm	r19, Z+
    e4ba:	d3 fe       	sbrs	r13, 3
    e4bc:	31 91       	ld	r19, Z+
    e4be:	2f 01       	movw	r4, r30
    e4c0:	bb 24       	eor	r11, r11
    e4c2:	b3 94       	inc	r11
    e4c4:	01 c0       	rjmp	.+2      	; 0xe4c8 <vfscanf+0xa4>
    e4c6:	b1 2c       	mov	r11, r1
    e4c8:	71 2c       	mov	r7, r1
    e4ca:	20 ed       	ldi	r18, 0xD0	; 208
    e4cc:	23 0f       	add	r18, r19
    e4ce:	2a 30       	cpi	r18, 0x0A	; 10
    e4d0:	90 f4       	brcc	.+36     	; 0xe4f6 <vfscanf+0xd2>
    e4d2:	fb 2d       	mov	r31, r11
    e4d4:	f2 60       	ori	r31, 0x02	; 2
    e4d6:	bf 2e       	mov	r11, r31
    e4d8:	67 2d       	mov	r22, r7
    e4da:	70 e0       	ldi	r23, 0x00	; 0
    e4dc:	80 e0       	ldi	r24, 0x00	; 0
    e4de:	90 e0       	ldi	r25, 0x00	; 0
    e4e0:	40 e2       	ldi	r20, 0x20	; 32
    e4e2:	0e 94 81 70 	call	0xe102	; 0xe102 <mulacc>
    e4e6:	76 2e       	mov	r7, r22
    e4e8:	f2 01       	movw	r30, r4
    e4ea:	d3 fc       	sbrc	r13, 3
    e4ec:	35 91       	lpm	r19, Z+
    e4ee:	d3 fe       	sbrs	r13, 3
    e4f0:	31 91       	ld	r19, Z+
    e4f2:	2f 01       	movw	r4, r30
    e4f4:	ea cf       	rjmp	.-44     	; 0xe4ca <vfscanf+0xa6>
    e4f6:	b1 fe       	sbrs	r11, 1
    e4f8:	03 c0       	rjmp	.+6      	; 0xe500 <vfscanf+0xdc>
    e4fa:	71 10       	cpse	r7, r1
    e4fc:	03 c0       	rjmp	.+6      	; 0xe504 <vfscanf+0xe0>
    e4fe:	b3 c0       	rjmp	.+358    	; 0xe666 <vfscanf+0x242>
    e500:	77 24       	eor	r7, r7
    e502:	7a 94       	dec	r7
    e504:	38 36       	cpi	r19, 0x68	; 104
    e506:	19 f0       	breq	.+6      	; 0xe50e <vfscanf+0xea>
    e508:	3c 36       	cpi	r19, 0x6C	; 108
    e50a:	61 f0       	breq	.+24     	; 0xe524 <vfscanf+0x100>
    e50c:	14 c0       	rjmp	.+40     	; 0xe536 <vfscanf+0x112>
    e50e:	f2 01       	movw	r30, r4
    e510:	d3 fc       	sbrc	r13, 3
    e512:	35 91       	lpm	r19, Z+
    e514:	d3 fe       	sbrs	r13, 3
    e516:	31 91       	ld	r19, Z+
    e518:	2f 01       	movw	r4, r30
    e51a:	38 36       	cpi	r19, 0x68	; 104
    e51c:	61 f4       	brne	.+24     	; 0xe536 <vfscanf+0x112>
    e51e:	fb 2d       	mov	r31, r11
    e520:	f8 60       	ori	r31, 0x08	; 8
    e522:	bf 2e       	mov	r11, r31
    e524:	8b 2d       	mov	r24, r11
    e526:	84 60       	ori	r24, 0x04	; 4
    e528:	b8 2e       	mov	r11, r24
    e52a:	f2 01       	movw	r30, r4
    e52c:	d3 fc       	sbrc	r13, 3
    e52e:	35 91       	lpm	r19, Z+
    e530:	d3 fe       	sbrs	r13, 3
    e532:	31 91       	ld	r19, Z+
    e534:	2f 01       	movw	r4, r30
    e536:	33 23       	and	r19, r19
    e538:	09 f4       	brne	.+2      	; 0xe53c <vfscanf+0x118>
    e53a:	95 c0       	rjmp	.+298    	; 0xe666 <vfscanf+0x242>
    e53c:	63 2f       	mov	r22, r19
    e53e:	70 e0       	ldi	r23, 0x00	; 0
    e540:	87 ed       	ldi	r24, 0xD7	; 215
    e542:	9f e4       	ldi	r25, 0x4F	; 79
    e544:	39 83       	std	Y+1, r19	; 0x01
    e546:	0e 94 bc 6b 	call	0xd778	; 0xd778 <strchr_P>
    e54a:	39 81       	ldd	r19, Y+1	; 0x01
    e54c:	89 2b       	or	r24, r25
    e54e:	09 f4       	brne	.+2      	; 0xe552 <vfscanf+0x12e>
    e550:	8a c0       	rjmp	.+276    	; 0xe666 <vfscanf+0x242>
    e552:	b0 fc       	sbrc	r11, 0
    e554:	07 c0       	rjmp	.+14     	; 0xe564 <vfscanf+0x140>
    e556:	f7 01       	movw	r30, r14
    e558:	c0 80       	ld	r12, Z
    e55a:	d1 80       	ldd	r13, Z+1	; 0x01
    e55c:	c7 01       	movw	r24, r14
    e55e:	02 96       	adiw	r24, 0x02	; 2
    e560:	7c 01       	movw	r14, r24
    e562:	02 c0       	rjmp	.+4      	; 0xe568 <vfscanf+0x144>
    e564:	c1 2c       	mov	r12, r1
    e566:	d1 2c       	mov	r13, r1
    e568:	3e 36       	cpi	r19, 0x6E	; 110
    e56a:	51 f4       	brne	.+20     	; 0xe580 <vfscanf+0x15c>
    e56c:	f8 01       	movw	r30, r16
    e56e:	46 81       	ldd	r20, Z+6	; 0x06
    e570:	57 81       	ldd	r21, Z+7	; 0x07
    e572:	60 e0       	ldi	r22, 0x00	; 0
    e574:	70 e0       	ldi	r23, 0x00	; 0
    e576:	2b 2d       	mov	r18, r11
    e578:	c6 01       	movw	r24, r12
    e57a:	0e 94 75 70 	call	0xe0ea	; 0xe0ea <putval>
    e57e:	6b cf       	rjmp	.-298    	; 0xe456 <vfscanf+0x32>
    e580:	33 36       	cpi	r19, 0x63	; 99
    e582:	a1 f4       	brne	.+40     	; 0xe5ac <vfscanf+0x188>
    e584:	b1 fc       	sbrc	r11, 1
    e586:	02 c0       	rjmp	.+4      	; 0xe58c <vfscanf+0x168>
    e588:	77 24       	eor	r7, r7
    e58a:	73 94       	inc	r7
    e58c:	c8 01       	movw	r24, r16
    e58e:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e592:	97 fd       	sbrc	r25, 7
    e594:	66 c0       	rjmp	.+204    	; 0xe662 <vfscanf+0x23e>
    e596:	c1 14       	cp	r12, r1
    e598:	d1 04       	cpc	r13, r1
    e59a:	29 f0       	breq	.+10     	; 0xe5a6 <vfscanf+0x182>
    e59c:	f6 01       	movw	r30, r12
    e59e:	80 83       	st	Z, r24
    e5a0:	c6 01       	movw	r24, r12
    e5a2:	01 96       	adiw	r24, 0x01	; 1
    e5a4:	6c 01       	movw	r12, r24
    e5a6:	7a 94       	dec	r7
    e5a8:	89 f7       	brne	.-30     	; 0xe58c <vfscanf+0x168>
    e5aa:	57 c0       	rjmp	.+174    	; 0xe65a <vfscanf+0x236>
    e5ac:	3b 35       	cpi	r19, 0x5B	; 91
    e5ae:	59 f4       	brne	.+22     	; 0xe5c6 <vfscanf+0x1a2>
    e5b0:	92 01       	movw	r18, r4
    e5b2:	a6 01       	movw	r20, r12
    e5b4:	67 2d       	mov	r22, r7
    e5b6:	c8 01       	movw	r24, r16
    e5b8:	0e 94 4b 71 	call	0xe296	; 0xe296 <conv_brk>
    e5bc:	2c 01       	movw	r4, r24
    e5be:	00 97       	sbiw	r24, 0x00	; 0
    e5c0:	09 f0       	breq	.+2      	; 0xe5c4 <vfscanf+0x1a0>
    e5c2:	4b c0       	rjmp	.+150    	; 0xe65a <vfscanf+0x236>
    e5c4:	45 c0       	rjmp	.+138    	; 0xe650 <vfscanf+0x22c>
    e5c6:	c8 01       	movw	r24, r16
    e5c8:	39 83       	std	Y+1, r19	; 0x01
    e5ca:	0e 94 a1 70 	call	0xe142	; 0xe142 <skip_spaces>
    e5ce:	39 81       	ldd	r19, Y+1	; 0x01
    e5d0:	97 fd       	sbrc	r25, 7
    e5d2:	47 c0       	rjmp	.+142    	; 0xe662 <vfscanf+0x23e>
    e5d4:	3f 36       	cpi	r19, 0x6F	; 111
    e5d6:	69 f1       	breq	.+90     	; 0xe632 <vfscanf+0x20e>
    e5d8:	28 f4       	brcc	.+10     	; 0xe5e4 <vfscanf+0x1c0>
    e5da:	34 36       	cpi	r19, 0x64	; 100
    e5dc:	31 f1       	breq	.+76     	; 0xe62a <vfscanf+0x206>
    e5de:	39 36       	cpi	r19, 0x69	; 105
    e5e0:	79 f1       	breq	.+94     	; 0xe640 <vfscanf+0x21c>
    e5e2:	2b c0       	rjmp	.+86     	; 0xe63a <vfscanf+0x216>
    e5e4:	33 37       	cpi	r19, 0x73	; 115
    e5e6:	69 f0       	breq	.+26     	; 0xe602 <vfscanf+0x1de>
    e5e8:	35 37       	cpi	r19, 0x75	; 117
    e5ea:	f9 f0       	breq	.+62     	; 0xe62a <vfscanf+0x206>
    e5ec:	26 c0       	rjmp	.+76     	; 0xe63a <vfscanf+0x216>
    e5ee:	c1 14       	cp	r12, r1
    e5f0:	d1 04       	cpc	r13, r1
    e5f2:	29 f0       	breq	.+10     	; 0xe5fe <vfscanf+0x1da>
    e5f4:	f6 01       	movw	r30, r12
    e5f6:	80 82       	st	Z, r8
    e5f8:	c6 01       	movw	r24, r12
    e5fa:	01 96       	adiw	r24, 0x01	; 1
    e5fc:	6c 01       	movw	r12, r24
    e5fe:	7a 94       	dec	r7
    e600:	71 f0       	breq	.+28     	; 0xe61e <vfscanf+0x1fa>
    e602:	c8 01       	movw	r24, r16
    e604:	0e 94 af 73 	call	0xe75e	; 0xe75e <fgetc>
    e608:	4c 01       	movw	r8, r24
    e60a:	97 fd       	sbrc	r25, 7
    e60c:	08 c0       	rjmp	.+16     	; 0xe61e <vfscanf+0x1fa>
    e60e:	0e 94 91 73 	call	0xe722	; 0xe722 <isspace>
    e612:	89 2b       	or	r24, r25
    e614:	61 f3       	breq	.-40     	; 0xe5ee <vfscanf+0x1ca>
    e616:	b8 01       	movw	r22, r16
    e618:	c4 01       	movw	r24, r8
    e61a:	0e 94 1f 74 	call	0xe83e	; 0xe83e <ungetc>
    e61e:	c1 14       	cp	r12, r1
    e620:	d1 04       	cpc	r13, r1
    e622:	d9 f0       	breq	.+54     	; 0xe65a <vfscanf+0x236>
    e624:	f6 01       	movw	r30, r12
    e626:	10 82       	st	Z, r1
    e628:	18 c0       	rjmp	.+48     	; 0xe65a <vfscanf+0x236>
    e62a:	fb 2d       	mov	r31, r11
    e62c:	f0 62       	ori	r31, 0x20	; 32
    e62e:	bf 2e       	mov	r11, r31
    e630:	07 c0       	rjmp	.+14     	; 0xe640 <vfscanf+0x21c>
    e632:	8b 2d       	mov	r24, r11
    e634:	80 61       	ori	r24, 0x10	; 16
    e636:	b8 2e       	mov	r11, r24
    e638:	03 c0       	rjmp	.+6      	; 0xe640 <vfscanf+0x21c>
    e63a:	9b 2d       	mov	r25, r11
    e63c:	90 64       	ori	r25, 0x40	; 64
    e63e:	b9 2e       	mov	r11, r25
    e640:	2b 2d       	mov	r18, r11
    e642:	a6 01       	movw	r20, r12
    e644:	67 2d       	mov	r22, r7
    e646:	c8 01       	movw	r24, r16
    e648:	0e 94 ba 70 	call	0xe174	; 0xe174 <conv_int>
    e64c:	81 11       	cpse	r24, r1
    e64e:	05 c0       	rjmp	.+10     	; 0xe65a <vfscanf+0x236>
    e650:	f8 01       	movw	r30, r16
    e652:	83 81       	ldd	r24, Z+3	; 0x03
    e654:	80 73       	andi	r24, 0x30	; 48
    e656:	29 f4       	brne	.+10     	; 0xe662 <vfscanf+0x23e>
    e658:	06 c0       	rjmp	.+12     	; 0xe666 <vfscanf+0x242>
    e65a:	b0 fc       	sbrc	r11, 0
    e65c:	fc ce       	rjmp	.-520    	; 0xe456 <vfscanf+0x32>
    e65e:	a3 94       	inc	r10
    e660:	fa ce       	rjmp	.-524    	; 0xe456 <vfscanf+0x32>
    e662:	aa 20       	and	r10, r10
    e664:	19 f0       	breq	.+6      	; 0xe66c <vfscanf+0x248>
    e666:	8a 2d       	mov	r24, r10
    e668:	90 e0       	ldi	r25, 0x00	; 0
    e66a:	02 c0       	rjmp	.+4      	; 0xe670 <vfscanf+0x24c>
    e66c:	8f ef       	ldi	r24, 0xFF	; 255
    e66e:	9f ef       	ldi	r25, 0xFF	; 255
    e670:	0f 90       	pop	r0
    e672:	df 91       	pop	r29
    e674:	cf 91       	pop	r28
    e676:	1f 91       	pop	r17
    e678:	0f 91       	pop	r16
    e67a:	ff 90       	pop	r15
    e67c:	ef 90       	pop	r14
    e67e:	df 90       	pop	r13
    e680:	cf 90       	pop	r12
    e682:	bf 90       	pop	r11
    e684:	af 90       	pop	r10
    e686:	9f 90       	pop	r9
    e688:	8f 90       	pop	r8
    e68a:	7f 90       	pop	r7
    e68c:	5f 90       	pop	r5
    e68e:	4f 90       	pop	r4
    e690:	08 95       	ret

0000e692 <__eerd_block_m128>:
    e692:	dc 01       	movw	r26, r24
    e694:	cb 01       	movw	r24, r22

0000e696 <__eerd_blraw_m128>:
    e696:	fc 01       	movw	r30, r24
    e698:	e1 99       	sbic	0x1c, 1	; 28
    e69a:	fe cf       	rjmp	.-4      	; 0xe698 <__eerd_blraw_m128+0x2>
    e69c:	06 c0       	rjmp	.+12     	; 0xe6aa <__eerd_blraw_m128+0x14>
    e69e:	ff bb       	out	0x1f, r31	; 31
    e6a0:	ee bb       	out	0x1e, r30	; 30
    e6a2:	e0 9a       	sbi	0x1c, 0	; 28
    e6a4:	31 96       	adiw	r30, 0x01	; 1
    e6a6:	0d b2       	in	r0, 0x1d	; 29
    e6a8:	0d 92       	st	X+, r0
    e6aa:	41 50       	subi	r20, 0x01	; 1
    e6ac:	50 40       	sbci	r21, 0x00	; 0
    e6ae:	b8 f7       	brcc	.-18     	; 0xe69e <__eerd_blraw_m128+0x8>
    e6b0:	08 95       	ret

0000e6b2 <__eerd_byte_m128>:
    e6b2:	e1 99       	sbic	0x1c, 1	; 28
    e6b4:	fe cf       	rjmp	.-4      	; 0xe6b2 <__eerd_byte_m128>
    e6b6:	9f bb       	out	0x1f, r25	; 31
    e6b8:	8e bb       	out	0x1e, r24	; 30
    e6ba:	e0 9a       	sbi	0x1c, 0	; 28
    e6bc:	99 27       	eor	r25, r25
    e6be:	8d b3       	in	r24, 0x1d	; 29
    e6c0:	08 95       	ret

0000e6c2 <__eerd_dword_m128>:
    e6c2:	a6 e1       	ldi	r26, 0x16	; 22
    e6c4:	b0 e0       	ldi	r27, 0x00	; 0
    e6c6:	44 e0       	ldi	r20, 0x04	; 4
    e6c8:	50 e0       	ldi	r21, 0x00	; 0
    e6ca:	0c 94 4b 73 	jmp	0xe696	; 0xe696 <__eerd_blraw_m128>

0000e6ce <__eerd_word_m128>:
    e6ce:	a8 e1       	ldi	r26, 0x18	; 24
    e6d0:	b0 e0       	ldi	r27, 0x00	; 0
    e6d2:	42 e0       	ldi	r20, 0x02	; 2
    e6d4:	50 e0       	ldi	r21, 0x00	; 0
    e6d6:	0c 94 4b 73 	jmp	0xe696	; 0xe696 <__eerd_blraw_m128>

0000e6da <__eewr_block_m128>:
    e6da:	dc 01       	movw	r26, r24
    e6dc:	cb 01       	movw	r24, r22
    e6de:	03 c0       	rjmp	.+6      	; 0xe6e6 <__eewr_block_m128+0xc>
    e6e0:	2d 91       	ld	r18, X+
    e6e2:	0e 94 78 73 	call	0xe6f0	; 0xe6f0 <__eewr_r18_m128>
    e6e6:	41 50       	subi	r20, 0x01	; 1
    e6e8:	50 40       	sbci	r21, 0x00	; 0
    e6ea:	d0 f7       	brcc	.-12     	; 0xe6e0 <__eewr_block_m128+0x6>
    e6ec:	08 95       	ret

0000e6ee <__eewr_byte_m128>:
    e6ee:	26 2f       	mov	r18, r22

0000e6f0 <__eewr_r18_m128>:
    e6f0:	e1 99       	sbic	0x1c, 1	; 28
    e6f2:	fe cf       	rjmp	.-4      	; 0xe6f0 <__eewr_r18_m128>
    e6f4:	9f bb       	out	0x1f, r25	; 31
    e6f6:	8e bb       	out	0x1e, r24	; 30
    e6f8:	2d bb       	out	0x1d, r18	; 29
    e6fa:	0f b6       	in	r0, 0x3f	; 63
    e6fc:	f8 94       	cli
    e6fe:	e2 9a       	sbi	0x1c, 2	; 28
    e700:	e1 9a       	sbi	0x1c, 1	; 28
    e702:	0f be       	out	0x3f, r0	; 63
    e704:	01 96       	adiw	r24, 0x01	; 1
    e706:	08 95       	ret

0000e708 <__eewr_dword_m128>:
    e708:	24 2f       	mov	r18, r20
    e70a:	0e 94 78 73 	call	0xe6f0	; 0xe6f0 <__eewr_r18_m128>
    e70e:	25 2f       	mov	r18, r21
    e710:	0e 94 78 73 	call	0xe6f0	; 0xe6f0 <__eewr_r18_m128>
    e714:	0c 94 8c 73 	jmp	0xe718	; 0xe718 <__eewr_word_m128>

0000e718 <__eewr_word_m128>:
    e718:	0e 94 77 73 	call	0xe6ee	; 0xe6ee <__eewr_byte_m128>
    e71c:	27 2f       	mov	r18, r23
    e71e:	0c 94 78 73 	jmp	0xe6f0	; 0xe6f0 <__eewr_r18_m128>

0000e722 <isspace>:
    e722:	91 11       	cpse	r25, r1
    e724:	03 c1       	rjmp	.+518    	; 0xe92c <__ctype_isfalse>
    e726:	80 32       	cpi	r24, 0x20	; 32
    e728:	19 f0       	breq	.+6      	; 0xe730 <isspace+0xe>
    e72a:	89 50       	subi	r24, 0x09	; 9
    e72c:	85 50       	subi	r24, 0x05	; 5
    e72e:	d0 f7       	brcc	.-12     	; 0xe724 <isspace+0x2>
    e730:	08 95       	ret

0000e732 <strnlen_P>:
    e732:	fc 01       	movw	r30, r24
    e734:	05 90       	lpm	r0, Z+
    e736:	61 50       	subi	r22, 0x01	; 1
    e738:	70 40       	sbci	r23, 0x00	; 0
    e73a:	01 10       	cpse	r0, r1
    e73c:	d8 f7       	brcc	.-10     	; 0xe734 <strnlen_P+0x2>
    e73e:	80 95       	com	r24
    e740:	90 95       	com	r25
    e742:	8e 0f       	add	r24, r30
    e744:	9f 1f       	adc	r25, r31
    e746:	08 95       	ret

0000e748 <strnlen>:
    e748:	fc 01       	movw	r30, r24
    e74a:	61 50       	subi	r22, 0x01	; 1
    e74c:	70 40       	sbci	r23, 0x00	; 0
    e74e:	01 90       	ld	r0, Z+
    e750:	01 10       	cpse	r0, r1
    e752:	d8 f7       	brcc	.-10     	; 0xe74a <strnlen+0x2>
    e754:	80 95       	com	r24
    e756:	90 95       	com	r25
    e758:	8e 0f       	add	r24, r30
    e75a:	9f 1f       	adc	r25, r31
    e75c:	08 95       	ret

0000e75e <fgetc>:
    e75e:	cf 93       	push	r28
    e760:	df 93       	push	r29
    e762:	ec 01       	movw	r28, r24
    e764:	2b 81       	ldd	r18, Y+3	; 0x03
    e766:	20 ff       	sbrs	r18, 0
    e768:	33 c0       	rjmp	.+102    	; 0xe7d0 <fgetc+0x72>
    e76a:	26 ff       	sbrs	r18, 6
    e76c:	0a c0       	rjmp	.+20     	; 0xe782 <fgetc+0x24>
    e76e:	2f 7b       	andi	r18, 0xBF	; 191
    e770:	2b 83       	std	Y+3, r18	; 0x03
    e772:	8e 81       	ldd	r24, Y+6	; 0x06
    e774:	9f 81       	ldd	r25, Y+7	; 0x07
    e776:	01 96       	adiw	r24, 0x01	; 1
    e778:	9f 83       	std	Y+7, r25	; 0x07
    e77a:	8e 83       	std	Y+6, r24	; 0x06
    e77c:	8a 81       	ldd	r24, Y+2	; 0x02
    e77e:	90 e0       	ldi	r25, 0x00	; 0
    e780:	29 c0       	rjmp	.+82     	; 0xe7d4 <fgetc+0x76>
    e782:	22 ff       	sbrs	r18, 2
    e784:	0f c0       	rjmp	.+30     	; 0xe7a4 <fgetc+0x46>
    e786:	e8 81       	ld	r30, Y
    e788:	f9 81       	ldd	r31, Y+1	; 0x01
    e78a:	80 81       	ld	r24, Z
    e78c:	99 27       	eor	r25, r25
    e78e:	87 fd       	sbrc	r24, 7
    e790:	90 95       	com	r25
    e792:	00 97       	sbiw	r24, 0x00	; 0
    e794:	19 f4       	brne	.+6      	; 0xe79c <fgetc+0x3e>
    e796:	20 62       	ori	r18, 0x20	; 32
    e798:	2b 83       	std	Y+3, r18	; 0x03
    e79a:	1a c0       	rjmp	.+52     	; 0xe7d0 <fgetc+0x72>
    e79c:	31 96       	adiw	r30, 0x01	; 1
    e79e:	f9 83       	std	Y+1, r31	; 0x01
    e7a0:	e8 83       	st	Y, r30
    e7a2:	0e c0       	rjmp	.+28     	; 0xe7c0 <fgetc+0x62>
    e7a4:	ea 85       	ldd	r30, Y+10	; 0x0a
    e7a6:	fb 85       	ldd	r31, Y+11	; 0x0b
    e7a8:	09 95       	icall
    e7aa:	97 ff       	sbrs	r25, 7
    e7ac:	09 c0       	rjmp	.+18     	; 0xe7c0 <fgetc+0x62>
    e7ae:	2b 81       	ldd	r18, Y+3	; 0x03
    e7b0:	01 96       	adiw	r24, 0x01	; 1
    e7b2:	11 f4       	brne	.+4      	; 0xe7b8 <fgetc+0x5a>
    e7b4:	80 e1       	ldi	r24, 0x10	; 16
    e7b6:	01 c0       	rjmp	.+2      	; 0xe7ba <fgetc+0x5c>
    e7b8:	80 e2       	ldi	r24, 0x20	; 32
    e7ba:	82 2b       	or	r24, r18
    e7bc:	8b 83       	std	Y+3, r24	; 0x03
    e7be:	08 c0       	rjmp	.+16     	; 0xe7d0 <fgetc+0x72>
    e7c0:	2e 81       	ldd	r18, Y+6	; 0x06
    e7c2:	3f 81       	ldd	r19, Y+7	; 0x07
    e7c4:	2f 5f       	subi	r18, 0xFF	; 255
    e7c6:	3f 4f       	sbci	r19, 0xFF	; 255
    e7c8:	3f 83       	std	Y+7, r19	; 0x07
    e7ca:	2e 83       	std	Y+6, r18	; 0x06
    e7cc:	99 27       	eor	r25, r25
    e7ce:	02 c0       	rjmp	.+4      	; 0xe7d4 <fgetc+0x76>
    e7d0:	8f ef       	ldi	r24, 0xFF	; 255
    e7d2:	9f ef       	ldi	r25, 0xFF	; 255
    e7d4:	df 91       	pop	r29
    e7d6:	cf 91       	pop	r28
    e7d8:	08 95       	ret

0000e7da <fputc>:
    e7da:	0f 93       	push	r16
    e7dc:	1f 93       	push	r17
    e7de:	cf 93       	push	r28
    e7e0:	df 93       	push	r29
    e7e2:	18 2f       	mov	r17, r24
    e7e4:	09 2f       	mov	r16, r25
    e7e6:	eb 01       	movw	r28, r22
    e7e8:	8b 81       	ldd	r24, Y+3	; 0x03
    e7ea:	81 fd       	sbrc	r24, 1
    e7ec:	03 c0       	rjmp	.+6      	; 0xe7f4 <fputc+0x1a>
    e7ee:	8f ef       	ldi	r24, 0xFF	; 255
    e7f0:	9f ef       	ldi	r25, 0xFF	; 255
    e7f2:	20 c0       	rjmp	.+64     	; 0xe834 <fputc+0x5a>
    e7f4:	82 ff       	sbrs	r24, 2
    e7f6:	10 c0       	rjmp	.+32     	; 0xe818 <fputc+0x3e>
    e7f8:	4e 81       	ldd	r20, Y+6	; 0x06
    e7fa:	5f 81       	ldd	r21, Y+7	; 0x07
    e7fc:	2c 81       	ldd	r18, Y+4	; 0x04
    e7fe:	3d 81       	ldd	r19, Y+5	; 0x05
    e800:	42 17       	cp	r20, r18
    e802:	53 07       	cpc	r21, r19
    e804:	7c f4       	brge	.+30     	; 0xe824 <fputc+0x4a>
    e806:	e8 81       	ld	r30, Y
    e808:	f9 81       	ldd	r31, Y+1	; 0x01
    e80a:	9f 01       	movw	r18, r30
    e80c:	2f 5f       	subi	r18, 0xFF	; 255
    e80e:	3f 4f       	sbci	r19, 0xFF	; 255
    e810:	39 83       	std	Y+1, r19	; 0x01
    e812:	28 83       	st	Y, r18
    e814:	10 83       	st	Z, r17
    e816:	06 c0       	rjmp	.+12     	; 0xe824 <fputc+0x4a>
    e818:	e8 85       	ldd	r30, Y+8	; 0x08
    e81a:	f9 85       	ldd	r31, Y+9	; 0x09
    e81c:	81 2f       	mov	r24, r17
    e81e:	09 95       	icall
    e820:	89 2b       	or	r24, r25
    e822:	29 f7       	brne	.-54     	; 0xe7ee <fputc+0x14>
    e824:	2e 81       	ldd	r18, Y+6	; 0x06
    e826:	3f 81       	ldd	r19, Y+7	; 0x07
    e828:	2f 5f       	subi	r18, 0xFF	; 255
    e82a:	3f 4f       	sbci	r19, 0xFF	; 255
    e82c:	3f 83       	std	Y+7, r19	; 0x07
    e82e:	2e 83       	std	Y+6, r18	; 0x06
    e830:	81 2f       	mov	r24, r17
    e832:	90 2f       	mov	r25, r16
    e834:	df 91       	pop	r29
    e836:	cf 91       	pop	r28
    e838:	1f 91       	pop	r17
    e83a:	0f 91       	pop	r16
    e83c:	08 95       	ret

0000e83e <ungetc>:
    e83e:	fb 01       	movw	r30, r22
    e840:	23 81       	ldd	r18, Z+3	; 0x03
    e842:	20 ff       	sbrs	r18, 0
    e844:	12 c0       	rjmp	.+36     	; 0xe86a <ungetc+0x2c>
    e846:	26 fd       	sbrc	r18, 6
    e848:	10 c0       	rjmp	.+32     	; 0xe86a <ungetc+0x2c>
    e84a:	8f 3f       	cpi	r24, 0xFF	; 255
    e84c:	3f ef       	ldi	r19, 0xFF	; 255
    e84e:	93 07       	cpc	r25, r19
    e850:	61 f0       	breq	.+24     	; 0xe86a <ungetc+0x2c>
    e852:	82 83       	std	Z+2, r24	; 0x02
    e854:	2f 7d       	andi	r18, 0xDF	; 223
    e856:	20 64       	ori	r18, 0x40	; 64
    e858:	23 83       	std	Z+3, r18	; 0x03
    e85a:	26 81       	ldd	r18, Z+6	; 0x06
    e85c:	37 81       	ldd	r19, Z+7	; 0x07
    e85e:	21 50       	subi	r18, 0x01	; 1
    e860:	31 09       	sbc	r19, r1
    e862:	37 83       	std	Z+7, r19	; 0x07
    e864:	26 83       	std	Z+6, r18	; 0x06
    e866:	99 27       	eor	r25, r25
    e868:	08 95       	ret
    e86a:	8f ef       	ldi	r24, 0xFF	; 255
    e86c:	9f ef       	ldi	r25, 0xFF	; 255
    e86e:	08 95       	ret

0000e870 <__ultoa_invert>:
    e870:	fa 01       	movw	r30, r20
    e872:	aa 27       	eor	r26, r26
    e874:	28 30       	cpi	r18, 0x08	; 8
    e876:	51 f1       	breq	.+84     	; 0xe8cc <__ultoa_invert+0x5c>
    e878:	20 31       	cpi	r18, 0x10	; 16
    e87a:	81 f1       	breq	.+96     	; 0xe8dc <__ultoa_invert+0x6c>
    e87c:	e8 94       	clt
    e87e:	6f 93       	push	r22
    e880:	6e 7f       	andi	r22, 0xFE	; 254
    e882:	6e 5f       	subi	r22, 0xFE	; 254
    e884:	7f 4f       	sbci	r23, 0xFF	; 255
    e886:	8f 4f       	sbci	r24, 0xFF	; 255
    e888:	9f 4f       	sbci	r25, 0xFF	; 255
    e88a:	af 4f       	sbci	r26, 0xFF	; 255
    e88c:	b1 e0       	ldi	r27, 0x01	; 1
    e88e:	3e d0       	rcall	.+124    	; 0xe90c <__ultoa_invert+0x9c>
    e890:	b4 e0       	ldi	r27, 0x04	; 4
    e892:	3c d0       	rcall	.+120    	; 0xe90c <__ultoa_invert+0x9c>
    e894:	67 0f       	add	r22, r23
    e896:	78 1f       	adc	r23, r24
    e898:	89 1f       	adc	r24, r25
    e89a:	9a 1f       	adc	r25, r26
    e89c:	a1 1d       	adc	r26, r1
    e89e:	68 0f       	add	r22, r24
    e8a0:	79 1f       	adc	r23, r25
    e8a2:	8a 1f       	adc	r24, r26
    e8a4:	91 1d       	adc	r25, r1
    e8a6:	a1 1d       	adc	r26, r1
    e8a8:	6a 0f       	add	r22, r26
    e8aa:	71 1d       	adc	r23, r1
    e8ac:	81 1d       	adc	r24, r1
    e8ae:	91 1d       	adc	r25, r1
    e8b0:	a1 1d       	adc	r26, r1
    e8b2:	20 d0       	rcall	.+64     	; 0xe8f4 <__ultoa_invert+0x84>
    e8b4:	09 f4       	brne	.+2      	; 0xe8b8 <__ultoa_invert+0x48>
    e8b6:	68 94       	set
    e8b8:	3f 91       	pop	r19
    e8ba:	2a e0       	ldi	r18, 0x0A	; 10
    e8bc:	26 9f       	mul	r18, r22
    e8be:	11 24       	eor	r1, r1
    e8c0:	30 19       	sub	r19, r0
    e8c2:	30 5d       	subi	r19, 0xD0	; 208
    e8c4:	31 93       	st	Z+, r19
    e8c6:	de f6       	brtc	.-74     	; 0xe87e <__ultoa_invert+0xe>
    e8c8:	cf 01       	movw	r24, r30
    e8ca:	08 95       	ret
    e8cc:	46 2f       	mov	r20, r22
    e8ce:	47 70       	andi	r20, 0x07	; 7
    e8d0:	40 5d       	subi	r20, 0xD0	; 208
    e8d2:	41 93       	st	Z+, r20
    e8d4:	b3 e0       	ldi	r27, 0x03	; 3
    e8d6:	0f d0       	rcall	.+30     	; 0xe8f6 <__ultoa_invert+0x86>
    e8d8:	c9 f7       	brne	.-14     	; 0xe8cc <__ultoa_invert+0x5c>
    e8da:	f6 cf       	rjmp	.-20     	; 0xe8c8 <__ultoa_invert+0x58>
    e8dc:	46 2f       	mov	r20, r22
    e8de:	4f 70       	andi	r20, 0x0F	; 15
    e8e0:	40 5d       	subi	r20, 0xD0	; 208
    e8e2:	4a 33       	cpi	r20, 0x3A	; 58
    e8e4:	18 f0       	brcs	.+6      	; 0xe8ec <__ultoa_invert+0x7c>
    e8e6:	49 5d       	subi	r20, 0xD9	; 217
    e8e8:	31 fd       	sbrc	r19, 1
    e8ea:	40 52       	subi	r20, 0x20	; 32
    e8ec:	41 93       	st	Z+, r20
    e8ee:	02 d0       	rcall	.+4      	; 0xe8f4 <__ultoa_invert+0x84>
    e8f0:	a9 f7       	brne	.-22     	; 0xe8dc <__ultoa_invert+0x6c>
    e8f2:	ea cf       	rjmp	.-44     	; 0xe8c8 <__ultoa_invert+0x58>
    e8f4:	b4 e0       	ldi	r27, 0x04	; 4
    e8f6:	a6 95       	lsr	r26
    e8f8:	97 95       	ror	r25
    e8fa:	87 95       	ror	r24
    e8fc:	77 95       	ror	r23
    e8fe:	67 95       	ror	r22
    e900:	ba 95       	dec	r27
    e902:	c9 f7       	brne	.-14     	; 0xe8f6 <__ultoa_invert+0x86>
    e904:	00 97       	sbiw	r24, 0x00	; 0
    e906:	61 05       	cpc	r22, r1
    e908:	71 05       	cpc	r23, r1
    e90a:	08 95       	ret
    e90c:	9b 01       	movw	r18, r22
    e90e:	ac 01       	movw	r20, r24
    e910:	0a 2e       	mov	r0, r26
    e912:	06 94       	lsr	r0
    e914:	57 95       	ror	r21
    e916:	47 95       	ror	r20
    e918:	37 95       	ror	r19
    e91a:	27 95       	ror	r18
    e91c:	ba 95       	dec	r27
    e91e:	c9 f7       	brne	.-14     	; 0xe912 <__ultoa_invert+0xa2>
    e920:	62 0f       	add	r22, r18
    e922:	73 1f       	adc	r23, r19
    e924:	84 1f       	adc	r24, r20
    e926:	95 1f       	adc	r25, r21
    e928:	a0 1d       	adc	r26, r0
    e92a:	08 95       	ret

0000e92c <__ctype_isfalse>:
    e92c:	99 27       	eor	r25, r25
    e92e:	88 27       	eor	r24, r24

0000e930 <__ctype_istrue>:
    e930:	08 95       	ret

0000e932 <__udivmodqi4>:
    e932:	99 1b       	sub	r25, r25
    e934:	79 e0       	ldi	r23, 0x09	; 9
    e936:	04 c0       	rjmp	.+8      	; 0xe940 <__udivmodqi4_ep>

0000e938 <__udivmodqi4_loop>:
    e938:	99 1f       	adc	r25, r25
    e93a:	96 17       	cp	r25, r22
    e93c:	08 f0       	brcs	.+2      	; 0xe940 <__udivmodqi4_ep>
    e93e:	96 1b       	sub	r25, r22

0000e940 <__udivmodqi4_ep>:
    e940:	88 1f       	adc	r24, r24
    e942:	7a 95       	dec	r23
    e944:	c9 f7       	brne	.-14     	; 0xe938 <__udivmodqi4_loop>
    e946:	80 95       	com	r24
    e948:	08 95       	ret

0000e94a <__udivmodhi4>:
    e94a:	aa 1b       	sub	r26, r26
    e94c:	bb 1b       	sub	r27, r27
    e94e:	51 e1       	ldi	r21, 0x11	; 17
    e950:	07 c0       	rjmp	.+14     	; 0xe960 <__udivmodhi4_ep>

0000e952 <__udivmodhi4_loop>:
    e952:	aa 1f       	adc	r26, r26
    e954:	bb 1f       	adc	r27, r27
    e956:	a6 17       	cp	r26, r22
    e958:	b7 07       	cpc	r27, r23
    e95a:	10 f0       	brcs	.+4      	; 0xe960 <__udivmodhi4_ep>
    e95c:	a6 1b       	sub	r26, r22
    e95e:	b7 0b       	sbc	r27, r23

0000e960 <__udivmodhi4_ep>:
    e960:	88 1f       	adc	r24, r24
    e962:	99 1f       	adc	r25, r25
    e964:	5a 95       	dec	r21
    e966:	a9 f7       	brne	.-22     	; 0xe952 <__udivmodhi4_loop>
    e968:	80 95       	com	r24
    e96a:	90 95       	com	r25
    e96c:	bc 01       	movw	r22, r24
    e96e:	cd 01       	movw	r24, r26
    e970:	08 95       	ret

0000e972 <__divmodhi4>:
    e972:	97 fb       	bst	r25, 7
    e974:	07 2e       	mov	r0, r23
    e976:	16 f4       	brtc	.+4      	; 0xe97c <__divmodhi4+0xa>
    e978:	00 94       	com	r0
    e97a:	07 d0       	rcall	.+14     	; 0xe98a <__divmodhi4_neg1>
    e97c:	77 fd       	sbrc	r23, 7
    e97e:	09 d0       	rcall	.+18     	; 0xe992 <__divmodhi4_neg2>
    e980:	0e 94 a5 74 	call	0xe94a	; 0xe94a <__udivmodhi4>
    e984:	07 fc       	sbrc	r0, 7
    e986:	05 d0       	rcall	.+10     	; 0xe992 <__divmodhi4_neg2>
    e988:	3e f4       	brtc	.+14     	; 0xe998 <__divmodhi4_exit>

0000e98a <__divmodhi4_neg1>:
    e98a:	90 95       	com	r25
    e98c:	81 95       	neg	r24
    e98e:	9f 4f       	sbci	r25, 0xFF	; 255
    e990:	08 95       	ret

0000e992 <__divmodhi4_neg2>:
    e992:	70 95       	com	r23
    e994:	61 95       	neg	r22
    e996:	7f 4f       	sbci	r23, 0xFF	; 255

0000e998 <__divmodhi4_exit>:
    e998:	08 95       	ret

0000e99a <__udivmodsi4>:
    e99a:	a1 e2       	ldi	r26, 0x21	; 33
    e99c:	1a 2e       	mov	r1, r26
    e99e:	aa 1b       	sub	r26, r26
    e9a0:	bb 1b       	sub	r27, r27
    e9a2:	fd 01       	movw	r30, r26
    e9a4:	0d c0       	rjmp	.+26     	; 0xe9c0 <__udivmodsi4_ep>

0000e9a6 <__udivmodsi4_loop>:
    e9a6:	aa 1f       	adc	r26, r26
    e9a8:	bb 1f       	adc	r27, r27
    e9aa:	ee 1f       	adc	r30, r30
    e9ac:	ff 1f       	adc	r31, r31
    e9ae:	a2 17       	cp	r26, r18
    e9b0:	b3 07       	cpc	r27, r19
    e9b2:	e4 07       	cpc	r30, r20
    e9b4:	f5 07       	cpc	r31, r21
    e9b6:	20 f0       	brcs	.+8      	; 0xe9c0 <__udivmodsi4_ep>
    e9b8:	a2 1b       	sub	r26, r18
    e9ba:	b3 0b       	sbc	r27, r19
    e9bc:	e4 0b       	sbc	r30, r20
    e9be:	f5 0b       	sbc	r31, r21

0000e9c0 <__udivmodsi4_ep>:
    e9c0:	66 1f       	adc	r22, r22
    e9c2:	77 1f       	adc	r23, r23
    e9c4:	88 1f       	adc	r24, r24
    e9c6:	99 1f       	adc	r25, r25
    e9c8:	1a 94       	dec	r1
    e9ca:	69 f7       	brne	.-38     	; 0xe9a6 <__udivmodsi4_loop>
    e9cc:	60 95       	com	r22
    e9ce:	70 95       	com	r23
    e9d0:	80 95       	com	r24
    e9d2:	90 95       	com	r25
    e9d4:	9b 01       	movw	r18, r22
    e9d6:	ac 01       	movw	r20, r24
    e9d8:	bd 01       	movw	r22, r26
    e9da:	cf 01       	movw	r24, r30
    e9dc:	08 95       	ret

0000e9de <__divmodsi4>:
    e9de:	05 2e       	mov	r0, r21
    e9e0:	97 fb       	bst	r25, 7
    e9e2:	1e f4       	brtc	.+6      	; 0xe9ea <__divmodsi4+0xc>
    e9e4:	00 94       	com	r0
    e9e6:	0e 94 06 75 	call	0xea0c	; 0xea0c <__negsi2>
    e9ea:	57 fd       	sbrc	r21, 7
    e9ec:	07 d0       	rcall	.+14     	; 0xe9fc <__divmodsi4_neg2>
    e9ee:	0e 94 cd 74 	call	0xe99a	; 0xe99a <__udivmodsi4>
    e9f2:	07 fc       	sbrc	r0, 7
    e9f4:	03 d0       	rcall	.+6      	; 0xe9fc <__divmodsi4_neg2>
    e9f6:	4e f4       	brtc	.+18     	; 0xea0a <__divmodsi4_exit>
    e9f8:	0c 94 06 75 	jmp	0xea0c	; 0xea0c <__negsi2>

0000e9fc <__divmodsi4_neg2>:
    e9fc:	50 95       	com	r21
    e9fe:	40 95       	com	r20
    ea00:	30 95       	com	r19
    ea02:	21 95       	neg	r18
    ea04:	3f 4f       	sbci	r19, 0xFF	; 255
    ea06:	4f 4f       	sbci	r20, 0xFF	; 255
    ea08:	5f 4f       	sbci	r21, 0xFF	; 255

0000ea0a <__divmodsi4_exit>:
    ea0a:	08 95       	ret

0000ea0c <__negsi2>:
    ea0c:	90 95       	com	r25
    ea0e:	80 95       	com	r24
    ea10:	70 95       	com	r23
    ea12:	61 95       	neg	r22
    ea14:	7f 4f       	sbci	r23, 0xFF	; 255
    ea16:	8f 4f       	sbci	r24, 0xFF	; 255
    ea18:	9f 4f       	sbci	r25, 0xFF	; 255
    ea1a:	08 95       	ret

0000ea1c <__tablejump2__>:
    ea1c:	ee 0f       	add	r30, r30
    ea1e:	ff 1f       	adc	r31, r31

0000ea20 <__tablejump__>:
    ea20:	05 90       	lpm	r0, Z+
    ea22:	f4 91       	lpm	r31, Z
    ea24:	e0 2d       	mov	r30, r0
    ea26:	09 94       	ijmp

0000ea28 <__muluhisi3>:
    ea28:	0e 94 27 75 	call	0xea4e	; 0xea4e <__umulhisi3>
    ea2c:	a5 9f       	mul	r26, r21
    ea2e:	90 0d       	add	r25, r0
    ea30:	b4 9f       	mul	r27, r20
    ea32:	90 0d       	add	r25, r0
    ea34:	a4 9f       	mul	r26, r20
    ea36:	80 0d       	add	r24, r0
    ea38:	91 1d       	adc	r25, r1
    ea3a:	11 24       	eor	r1, r1
    ea3c:	08 95       	ret

0000ea3e <__mulshisi3>:
    ea3e:	b7 ff       	sbrs	r27, 7
    ea40:	0c 94 14 75 	jmp	0xea28	; 0xea28 <__muluhisi3>

0000ea44 <__mulohisi3>:
    ea44:	0e 94 14 75 	call	0xea28	; 0xea28 <__muluhisi3>
    ea48:	82 1b       	sub	r24, r18
    ea4a:	93 0b       	sbc	r25, r19
    ea4c:	08 95       	ret

0000ea4e <__umulhisi3>:
    ea4e:	a2 9f       	mul	r26, r18
    ea50:	b0 01       	movw	r22, r0
    ea52:	b3 9f       	mul	r27, r19
    ea54:	c0 01       	movw	r24, r0
    ea56:	a3 9f       	mul	r26, r19
    ea58:	70 0d       	add	r23, r0
    ea5a:	81 1d       	adc	r24, r1
    ea5c:	11 24       	eor	r1, r1
    ea5e:	91 1d       	adc	r25, r1
    ea60:	b2 9f       	mul	r27, r18
    ea62:	70 0d       	add	r23, r0
    ea64:	81 1d       	adc	r24, r1
    ea66:	11 24       	eor	r1, r1
    ea68:	91 1d       	adc	r25, r1
    ea6a:	08 95       	ret

0000ea6c <_exit>:
    ea6c:	f8 94       	cli

0000ea6e <__stop_program>:
    ea6e:	ff cf       	rjmp	.-2      	; 0xea6e <__stop_program>
