
vem_ke.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000013a  00800100  0000ec76  0000ed2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000ec76  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c12  0080023a  0080023a  0000ee64  2**0
                  ALLOC
  3 .eeprom       000001ae  00810000  00810000  0000ee64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      0000005c  00000000  00000000  0000f012  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000009d8  00000000  00000000  0000f06e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00014c7b  00000000  00000000  0000fa46  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009d8  00000000  00000000  000246c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e8d  00000000  00000000  00025099  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000024e0  00000000  00000000  00028f28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00004251  00000000  00000000  0002b408  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000100fe  00000000  00000000  0002f659  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000d28  00000000  00000000  0003f757  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 fa 27 	jmp	0x4ff4	; 0x4ff4 <__ctors_end>
       4:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
       8:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
       c:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      10:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      14:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      18:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      1c:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      20:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      24:	0c 94 15 2f 	jmp	0x5e2a	; 0x5e2a <__vector_9>
      28:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      2c:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      30:	0c 94 39 2d 	jmp	0x5a72	; 0x5a72 <__vector_12>
      34:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      38:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      3c:	0c 94 e5 2e 	jmp	0x5dca	; 0x5dca <__vector_15>
      40:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      44:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      48:	0c 94 8e 57 	jmp	0xaf1c	; 0xaf1c <__vector_18>
      4c:	0c 94 1b 6a 	jmp	0xd436	; 0xd436 <__vector_19>
      50:	0c 94 82 3b 	jmp	0x7704	; 0x7704 <__vector_20>
      54:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      58:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      5c:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      60:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      64:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      68:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      6c:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      70:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      74:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      78:	0c 94 6c 4c 	jmp	0x98d8	; 0x98d8 <__vector_30>
      7c:	0c 94 e4 6a 	jmp	0xd5c8	; 0xd5c8 <__vector_31>
      80:	0c 94 af 4c 	jmp	0x995e	; 0x995e <__vector_32>
      84:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      88:	0c 94 19 28 	jmp	0x5032	; 0x5032 <__bad_interrupt>
      8c:	d8 32       	cpi	r29, 0x28	; 40
      8e:	d8 32       	cpi	r29, 0x28	; 40
      90:	64 33       	cpi	r22, 0x34	; 52
      92:	64 33       	cpi	r22, 0x34	; 52
      94:	c0 34       	cpi	r28, 0x40	; 64
      96:	bf 33       	cpi	r27, 0x3F	; 63
      98:	c0 34       	cpi	r28, 0x40	; 64
      9a:	c0 34       	cpi	r28, 0x40	; 64
      9c:	c0 34       	cpi	r28, 0x40	; 64
      9e:	c0 34       	cpi	r28, 0x40	; 64
      a0:	c0 34       	cpi	r28, 0x40	; 64
      a2:	c0 34       	cpi	r28, 0x40	; 64
      a4:	c0 34       	cpi	r28, 0x40	; 64
      a6:	c0 34       	cpi	r28, 0x40	; 64
      a8:	ee 33       	cpi	r30, 0x3E	; 62
      aa:	67 34       	cpi	r22, 0x47	; 71
      ac:	5d 36       	cpi	r21, 0x6D	; 109
      ae:	5d 36       	cpi	r21, 0x6D	; 109
      b0:	f3 36       	cpi	r31, 0x63	; 99
      b2:	f3 36       	cpi	r31, 0x63	; 99
      b4:	04 38       	cpi	r16, 0x84	; 132
      b6:	5f 37       	cpi	r21, 0x7F	; 127
      b8:	04 38       	cpi	r16, 0x84	; 132
      ba:	04 38       	cpi	r16, 0x84	; 132
      bc:	04 38       	cpi	r16, 0x84	; 132
      be:	04 38       	cpi	r16, 0x84	; 132
      c0:	04 38       	cpi	r16, 0x84	; 132
      c2:	04 38       	cpi	r16, 0x84	; 132
      c4:	04 38       	cpi	r16, 0x84	; 132
      c6:	04 38       	cpi	r16, 0x84	; 132
      c8:	b2 37       	cpi	r27, 0x72	; 114
      ca:	b2 37       	cpi	r27, 0x72	; 114
      cc:	46 44       	sbci	r20, 0x46	; 70
      ce:	71 44       	sbci	r23, 0x41	; 65
      d0:	a5 44       	sbci	r26, 0x45	; 69
      d2:	db 44       	sbci	r29, 0x4B	; 75
      d4:	46 44       	sbci	r20, 0x46	; 70
      d6:	71 44       	sbci	r23, 0x41	; 65
      d8:	31 47       	sbci	r19, 0x71	; 113
      da:	fd 44       	sbci	r31, 0x4D	; 77
      dc:	26 45       	sbci	r18, 0x56	; 86
      de:	58 45       	sbci	r21, 0x58	; 88
      e0:	91 45       	sbci	r25, 0x51	; 81
      e2:	fd 44       	sbci	r31, 0x4D	; 77
      e4:	26 45       	sbci	r18, 0x56	; 86
      e6:	bb 45       	sbci	r27, 0x5B	; 91
      e8:	bb 45       	sbci	r27, 0x5B	; 91
      ea:	31 47       	sbci	r19, 0x71	; 113
      ec:	bf 45       	sbci	r27, 0x5F	; 95
      ee:	ca 45       	sbci	r28, 0x5A	; 90
      f0:	d5 45       	sbci	r29, 0x55	; 85
      f2:	09 46       	sbci	r16, 0x69	; 105
      f4:	bf 45       	sbci	r27, 0x5F	; 95
      f6:	ca 45       	sbci	r28, 0x5A	; 90
      f8:	31 47       	sbci	r19, 0x71	; 113
      fa:	31 47       	sbci	r19, 0x71	; 113
      fc:	31 47       	sbci	r19, 0x71	; 113
      fe:	39 46       	sbci	r19, 0x69	; 105
     100:	55 46       	sbci	r21, 0x65	; 101
     102:	39 46       	sbci	r19, 0x69	; 105
     104:	55 46       	sbci	r21, 0x65	; 101
     106:	73 46       	sbci	r23, 0x63	; 99
     108:	76 46       	sbci	r23, 0x66	; 102
     10a:	7d 46       	sbci	r23, 0x6D	; 109
     10c:	9f 46       	sbci	r25, 0x6F	; 111
     10e:	c3 46       	sbci	r28, 0x63	; 99
     110:	f8 46       	sbci	r31, 0x68	; 104
     112:	a8 47       	sbci	r26, 0x78	; 120
     114:	ac 47       	sbci	r26, 0x7C	; 124
     116:	b1 47       	sbci	r27, 0x71	; 113
     118:	b6 47       	sbci	r27, 0x76	; 118
     11a:	bb 47       	sbci	r27, 0x7B	; 123
     11c:	c0 47       	sbci	r28, 0x70	; 112
     11e:	c4 47       	sbci	r28, 0x74	; 116
     120:	c8 47       	sbci	r28, 0x78	; 120
     122:	ce 47       	sbci	r28, 0x7E	; 126
     124:	e4 47       	sbci	r30, 0x74	; 116
     126:	e8 47       	sbci	r30, 0x78	; 120
     128:	ed 47       	sbci	r30, 0x7D	; 125
     12a:	f1 47       	sbci	r31, 0x71	; 113
     12c:	f6 47       	sbci	r31, 0x76	; 118
     12e:	fb 47       	sbci	r31, 0x7B	; 123
     130:	00 48       	sbci	r16, 0x80	; 128
     132:	05 48       	sbci	r16, 0x85	; 133
     134:	0b 48       	sbci	r16, 0x8B	; 139
     136:	20 48       	sbci	r18, 0x80	; 128
     138:	24 48       	sbci	r18, 0x84	; 132
     13a:	29 48       	sbci	r18, 0x89	; 137
     13c:	2e 48       	sbci	r18, 0x8E	; 142
     13e:	33 48       	sbci	r19, 0x83	; 131
     140:	37 48       	sbci	r19, 0x87	; 135
     142:	3c 48       	sbci	r19, 0x8C	; 140
     144:	41 48       	sbci	r20, 0x81	; 129
     146:	46 48       	sbci	r20, 0x86	; 134
     148:	4c 48       	sbci	r20, 0x8C	; 140
     14a:	07 4b       	sbci	r16, 0xB7	; 183
     14c:	0c 4b       	sbci	r16, 0xBC	; 188
     14e:	11 4b       	sbci	r17, 0xB1	; 177
     150:	29 4b       	sbci	r18, 0xB9	; 185
     152:	15 4b       	sbci	r17, 0xB5	; 181
     154:	19 4b       	sbci	r17, 0xB9	; 185
     156:	1d 4b       	sbci	r17, 0xBD	; 189
     158:	21 4b       	sbci	r18, 0xB1	; 177
     15a:	25 4b       	sbci	r18, 0xB5	; 181
     15c:	c2 52       	subi	r28, 0x22	; 34
     15e:	4a 53       	subi	r20, 0x3A	; 58
     160:	be 52       	subi	r27, 0x2E	; 46
     162:	4e 53       	subi	r20, 0x3E	; 62
     164:	ea 52       	subi	r30, 0x2A	; 42
     166:	ee 52       	subi	r30, 0x2E	; 46
     168:	f2 52       	subi	r31, 0x22	; 34
     16a:	f6 52       	subi	r31, 0x26	; 38
     16c:	fa 52       	subi	r31, 0x2A	; 42
     16e:	fe 52       	subi	r31, 0x2E	; 46
     170:	02 53       	subi	r16, 0x32	; 50
     172:	06 53       	subi	r16, 0x36	; 54
     174:	0a 53       	subi	r16, 0x3A	; 58
     176:	0e 53       	subi	r16, 0x3E	; 62
     178:	12 53       	subi	r17, 0x32	; 50
     17a:	16 53       	subi	r17, 0x36	; 54
     17c:	1a 53       	subi	r17, 0x3A	; 58
     17e:	1e 53       	subi	r17, 0x3E	; 62
     180:	22 53       	subi	r18, 0x32	; 50
     182:	26 53       	subi	r18, 0x36	; 54
     184:	2a 53       	subi	r18, 0x3A	; 58
     186:	2e 53       	subi	r18, 0x3E	; 62
     188:	a2 53       	subi	r26, 0x32	; 50
     18a:	a6 53       	subi	r26, 0x36	; 54
     18c:	aa 53       	subi	r26, 0x3A	; 58
     18e:	ae 53       	subi	r26, 0x3E	; 62
     190:	b2 53       	subi	r27, 0x32	; 50
     192:	b6 53       	subi	r27, 0x36	; 54
     194:	ba 53       	subi	r27, 0x3A	; 58
     196:	be 53       	subi	r27, 0x3E	; 62
     198:	c2 53       	subi	r28, 0x32	; 50
     19a:	c6 53       	subi	r28, 0x36	; 54
     19c:	ca 53       	subi	r28, 0x3A	; 58
     19e:	ce 53       	subi	r28, 0x3E	; 62
     1a0:	62 58       	subi	r22, 0x82	; 130
     1a2:	7d 58       	subi	r23, 0x8D	; 141
     1a4:	8d 58       	subi	r24, 0x8D	; 141
     1a6:	9a 58       	subi	r25, 0x8A	; 138
     1a8:	fb 64       	ori	r31, 0x4B	; 75
     1aa:	fb 64       	ori	r31, 0x4B	; 75
     1ac:	c4 58       	subi	r28, 0x84	; 132
     1ae:	db 58       	subi	r29, 0x8B	; 139
     1b0:	eb 58       	subi	r30, 0x8B	; 139
     1b2:	f8 58       	subi	r31, 0x88	; 136
     1b4:	08 59       	subi	r16, 0x98	; 152
     1b6:	15 59       	subi	r17, 0x95	; 149
     1b8:	25 59       	subi	r18, 0x95	; 149
     1ba:	34 59       	subi	r19, 0x94	; 148
     1bc:	b1 59       	subi	r27, 0x91	; 145
     1be:	c1 59       	subi	r28, 0x91	; 145
     1c0:	ce 59       	subi	r28, 0x9E	; 158
     1c2:	de 59       	subi	r29, 0x9E	; 158
     1c4:	eb 59       	subi	r30, 0x9B	; 155
     1c6:	fb 59       	subi	r31, 0x9B	; 155
     1c8:	08 5a       	subi	r16, 0xA8	; 168
     1ca:	18 5a       	subi	r17, 0xA8	; 168
     1cc:	25 5a       	subi	r18, 0xA5	; 165
     1ce:	3b 5a       	subi	r19, 0xAB	; 171
     1d0:	48 5a       	subi	r20, 0xA8	; 168
     1d2:	58 5a       	subi	r21, 0xA8	; 168
     1d4:	61 5a       	subi	r22, 0xA1	; 161
     1d6:	73 5a       	subi	r23, 0xA3	; 163
     1d8:	8a 5a       	subi	r24, 0xAA	; 170
     1da:	02 5b       	subi	r16, 0xB2	; 178
     1dc:	12 5b       	subi	r17, 0xB2	; 178
     1de:	1f 5b       	subi	r17, 0xBF	; 191
     1e0:	2f 5b       	subi	r18, 0xBF	; 191
     1e2:	3c 5b       	subi	r19, 0xBC	; 188
     1e4:	4c 5b       	subi	r20, 0xBC	; 188
     1e6:	59 5b       	subi	r21, 0xB9	; 185
     1e8:	bb 5b       	subi	r27, 0xBB	; 187
     1ea:	1a 5c       	subi	r17, 0xCA	; 202
     1ec:	28 5c       	subi	r18, 0xC8	; 200
     1ee:	36 5c       	subi	r19, 0xC6	; 198
     1f0:	63 5c       	subi	r22, 0xC3	; 195
     1f2:	89 5c       	subi	r24, 0xC9	; 201
     1f4:	94 5c       	subi	r25, 0xC4	; 196
     1f6:	a2 5c       	subi	r26, 0xC2	; 194
     1f8:	ad 5c       	subi	r26, 0xCD	; 205
     1fa:	dc 5c       	subi	r29, 0xCC	; 204
     1fc:	6c 5d       	subi	r22, 0xDC	; 220
     1fe:	7a 5d       	subi	r23, 0xDA	; 218
     200:	a8 5d       	subi	r26, 0xD8	; 216
     202:	ef 5d       	subi	r30, 0xDF	; 223
     204:	fd 5d       	subi	r31, 0xDD	; 221
     206:	09 5e       	subi	r16, 0xE9	; 233
     208:	76 5e       	subi	r23, 0xE6	; 230
     20a:	05 5f       	subi	r16, 0xF5	; 245
     20c:	c4 5f       	subi	r28, 0xF4	; 244
     20e:	d7 5f       	subi	r29, 0xF7	; 247
     210:	e3 5f       	subi	r30, 0xF3	; 243
     212:	38 60       	ori	r19, 0x08	; 8
     214:	a2 60       	ori	r26, 0x02	; 2
     216:	2a 61       	ori	r18, 0x1A	; 26
     218:	37 61       	ori	r19, 0x17	; 23
     21a:	4a 61       	ori	r20, 0x1A	; 26
     21c:	63 61       	ori	r22, 0x13	; 19
     21e:	d0 61       	ori	r29, 0x10	; 16
     220:	06 62       	ori	r16, 0x26	; 38
     222:	41 62       	ori	r20, 0x21	; 33
     224:	6d 62       	ori	r22, 0x2D	; 45
     226:	7e 62       	ori	r23, 0x2E	; 46
     228:	8a 62       	ori	r24, 0x2A	; 42
     22a:	fb 64       	ori	r31, 0x4B	; 75
     22c:	fb 64       	ori	r31, 0x4B	; 75
     22e:	fb 64       	ori	r31, 0x4B	; 75
     230:	fb 64       	ori	r31, 0x4B	; 75
     232:	fb 64       	ori	r31, 0x4B	; 75
     234:	fb 64       	ori	r31, 0x4B	; 75
     236:	fb 64       	ori	r31, 0x4B	; 75
     238:	fb 64       	ori	r31, 0x4B	; 75
     23a:	fb 64       	ori	r31, 0x4B	; 75
     23c:	fb 64       	ori	r31, 0x4B	; 75
     23e:	fb 64       	ori	r31, 0x4B	; 75
     240:	fb 64       	ori	r31, 0x4B	; 75
     242:	fb 64       	ori	r31, 0x4B	; 75
     244:	52 60       	ori	r21, 0x02	; 2
     246:	5e 60       	ori	r21, 0x0E	; 14
     248:	6a 60       	ori	r22, 0x0A	; 10
     24a:	76 60       	ori	r23, 0x06	; 6
     24c:	84 60       	ori	r24, 0x04	; 4
     24e:	90 60       	ori	r25, 0x00	; 0
     250:	fb 64       	ori	r31, 0x4B	; 75
     252:	fb 64       	ori	r31, 0x4B	; 75
     254:	af 62       	ori	r26, 0x2F	; 47
     256:	d1 62       	ori	r29, 0x21	; 33
     258:	db 62       	ori	r29, 0x2B	; 43
     25a:	e7 62       	ori	r30, 0x27	; 39
     25c:	f5 62       	ori	r31, 0x25	; 37
     25e:	01 63       	ori	r16, 0x31	; 49
     260:	11 63       	ori	r17, 0x31	; 49
     262:	31 63       	ori	r19, 0x31	; 49
     264:	4d 63       	ori	r20, 0x3D	; 61
     266:	9b 63       	ori	r25, 0x3B	; 59
     268:	a7 63       	ori	r26, 0x37	; 55
     26a:	d1 63       	ori	r29, 0x31	; 49
     26c:	f3 63       	ori	r31, 0x33	; 51
     26e:	3c 64       	ori	r19, 0x4C	; 76
     270:	48 64       	ori	r20, 0x48	; 72
     272:	5d 64       	ori	r21, 0x4D	; 77
     274:	69 64       	ori	r22, 0x49	; 73
     276:	81 64       	ori	r24, 0x41	; 65
     278:	8f 64       	ori	r24, 0x4F	; 79
     27a:	a1 64       	ori	r26, 0x41	; 65
     27c:	af 64       	ori	r26, 0x4F	; 79
     27e:	bb 64       	ori	r27, 0x4B	; 75
     280:	ce 64       	ori	r28, 0x4E	; 78
     282:	da 64       	ori	r29, 0x4A	; 74
     284:	ed 64       	ori	r30, 0x4D	; 77
     286:	fb 64       	ori	r31, 0x4B	; 75
     288:	03 68       	ori	r16, 0x83	; 131
     28a:	05 68       	ori	r16, 0x85	; 133
     28c:	10 68       	ori	r17, 0x80	; 128
     28e:	12 68       	ori	r17, 0x82	; 130
     290:	1f 68       	ori	r17, 0x8F	; 143
     292:	21 68       	ori	r18, 0x81	; 129
     294:	2c 68       	ori	r18, 0x8C	; 140
     296:	5e 68       	ori	r21, 0x8E	; 142
     298:	65 68       	ori	r22, 0x85	; 133
     29a:	6d 68       	ori	r22, 0x8D	; 141
     29c:	74 68       	ori	r23, 0x84	; 132
     29e:	7c 68       	ori	r23, 0x8C	; 140
     2a0:	83 68       	ori	r24, 0x83	; 131
     2a2:	5e 68       	ori	r21, 0x8E	; 142
     2a4:	7c 68       	ori	r23, 0x8C	; 140
     2a6:	35 68       	ori	r19, 0x85	; 133
     2a8:	8b 68       	ori	r24, 0x8B	; 139
     2aa:	90 68       	ori	r25, 0x80	; 128
     2ac:	99 68       	ori	r25, 0x89	; 137
     2ae:	9e 68       	ori	r25, 0x8E	; 142
     2b0:	a7 68       	ori	r26, 0x87	; 135
     2b2:	ac 68       	ori	r26, 0x8C	; 140
     2b4:	8b 68       	ori	r24, 0x8B	; 139
     2b6:	a7 68       	ori	r26, 0x87	; 135
     2b8:	40 68       	ori	r20, 0x80	; 128
     2ba:	b5 68       	ori	r27, 0x85	; 133
     2bc:	ba 68       	ori	r27, 0x8A	; 138
     2be:	cb 68       	ori	r28, 0x8B	; 139
     2c0:	d0 68       	ori	r29, 0x80	; 128
     2c2:	e1 68       	ori	r30, 0x81	; 129
     2c4:	e3 68       	ori	r30, 0x83	; 131
     2c6:	f1 68       	ori	r31, 0x81	; 129
     2c8:	fb 68       	ori	r31, 0x8B	; 139
     2ca:	21 69       	ori	r18, 0x91	; 145
     2cc:	28 69       	ori	r18, 0x98	; 152

000002ce <__trampolines_end>:
     2ce:	ed e5       	ldi	r30, 0x5D	; 93
     2d0:	f2 20       	and	r15, r2
     2d2:	f1 e2       	ldi	r31, 0x21	; 33
     2d4:	ff e7       	ldi	r31, 0x7F	; 127
     2d6:	e8 20       	and	r14, r8
     2d8:	f1 20       	and	r15, r1
     2da:	dd d1       	rcall	.+954    	; 0x696 <system_page+0x4c>
     2dc:	20 00       	.word	0x0020	; ????

000002de <__c.5170>:
     2de:	e5 f1 f2 fc 20 f1 e2 ff e7 fc 20 f1 20 dd d1 00     .... ..... . ...

000002ee <__c.5168>:
     2ee:	4c 26 47 20 20 b9 20 25 38 73 00                    L&G  . %8s.

000002f9 <__c.4714>:
     2f9:	25 30 38 6c 78 27 3e 0d 0a 00                       %08lx'>...

00000303 <__c.4712>:
     303:	25 30 38 6c 78 00                                   %08lx.

00000309 <__c.4695>:
     309:	25 75 0d 0a 00                                      %u...

0000030e <__c.4596>:
     30e:	6c 6f 67 6f 75 74 2e 68 74 6d 6c 00                 logout.html.

0000031a <__c.4594>:
     31a:	2f 00                                               /.

0000031c <__c.3750>:
     31c:	2b 43 53 51 3a 20 25 68 68 75 2c 25 68 68 75 00     +CSQ: %hhu,%hhu.

0000032c <__c.3738>:
     32c:	2b 52 45 43 45 49 56 45 2c 25 68 68 75 2c 25 68     +RECEIVE,%hhu,%h
     33c:	68 75 00                                            hu.

0000033f <__c.3727>:
     33f:	52 45 4d 4f 54 45 20 49 50 3a 25 68 68 75 2e 25     REMOTE IP:%hhu.%
     34f:	68 68 75 2e 25 68 68 75 2e 25 68 68 75 00           hhu.%hhu.%hhu.

0000035d <__c.3702>:
     35d:	25 68 68 75 2c 20 43 4c 4f 53 45 44 00              %hhu, CLOSED.

0000036a <__c.3678>:
     36a:	25 68 68 75 20 25 68 68 75 20 25 68 68 75 20 25     %hhu %hhu %hhu %
     37a:	68 68 75 00                                         hhu.

0000037e <__c.3650>:
     37e:	25 75 00                                            %u.

00000381 <__c.3648>:
     381:	25 6c 75 64 00                                      %lud.

00000386 <aCRCLo.1930>:
     386:	00 c0 c1 01 c3 03 02 c2 c6 06 07 c7 05 c5 c4 04     ................
     396:	cc 0c 0d cd 0f cf ce 0e 0a ca cb 0b c9 09 08 c8     ................
     3a6:	d8 18 19 d9 1b db da 1a 1e de df 1f dd 1d 1c dc     ................
     3b6:	14 d4 d5 15 d7 17 16 d6 d2 12 13 d3 11 d1 d0 10     ................
     3c6:	f0 30 31 f1 33 f3 f2 32 36 f6 f7 37 f5 35 34 f4     .01.3..26..7.54.
     3d6:	3c fc fd 3d ff 3f 3e fe fa 3a 3b fb 39 f9 f8 38     <..=.?>..:;.9..8
     3e6:	28 e8 e9 29 eb 2b 2a ea ee 2e 2f ef 2d ed ec 2c     (..).+*.../.-..,
     3f6:	e4 24 25 e5 27 e7 e6 26 22 e2 e3 23 e1 21 20 e0     .$%.'..&"..#.! .
     406:	a0 60 61 a1 63 a3 a2 62 66 a6 a7 67 a5 65 64 a4     .`a.c..bf..g.ed.
     416:	6c ac ad 6d af 6f 6e ae aa 6a 6b ab 69 a9 a8 68     l..m.on..jk.i..h
     426:	78 b8 b9 79 bb 7b 7a ba be 7e 7f bf 7d bd bc 7c     x..y.{z..~..}..|
     436:	b4 74 75 b5 77 b7 b6 76 72 b2 b3 73 b1 71 70 b0     .tu.w..vr..s.qp.
     446:	50 90 91 51 93 53 52 92 96 56 57 97 55 95 94 54     P..Q.SR..VW.U..T
     456:	9c 5c 5d 9d 5f 9f 9e 5e 5a 9a 9b 5b 99 59 58 98     .\]._..^Z..[.YX.
     466:	88 48 49 89 4b 8b 8a 4a 4e 8e 8f 4f 8d 4d 4c 8c     .HI.K..JN..O.ML.
     476:	44 84 85 45 87 47 46 86 82 42 43 83 41 81 80 40     D..E.GF..BC.A..@

00000486 <aCRCHi.1929>:
     486:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     496:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4a6:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4b6:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4c6:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     4d6:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4e6:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     4f6:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     506:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     516:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     526:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     536:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     546:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@
     556:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     566:	01 c0 80 41 00 c1 81 40 00 c1 81 40 01 c0 80 41     ...A...@...@...A
     576:	00 c1 81 40 01 c0 80 41 01 c0 80 41 00 c1 81 40     ...@...A...A...@

00000586 <WebSite>:
     586:	5b 45 99 48 ed 33 84 39 d8 1c e4 16 92 0c 98 05     [E.H.3.9........
     596:	b4 32                                               .2

00000598 <Web_system>:
     598:	86 0c 44 0c 18 00 a5 05 fa 05 4a 06 04              ..D.......J..

000005a5 <system_OField>:
     5a5:	44 06 34 06 2d 06 1d 06 12 06 02 06 f8 05 e8 05     D.4.-...........
     5b5:	e2 05 d2 05 cd 05 bd 05                             ........

000005bd <Web_Tlow>:
     5bd:	0a 0b 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005cd <var_Tlow>:
     5cd:	54 6c 6f 77 00                                      Tlow.

000005d2 <Web_Thigh>:
     5d2:	0a 0d 00 18 fc ff ff dc 05 00 00 00 00 00 00 01     ................

000005e2 <var_Thigh>:
     5e2:	54 68 69 67 68 00                                   Thigh.

000005e8 <Web_BLupgrade>:
     5e8:	00 1f 06 00 00 00 00 ff 00 00 00 01 29 00 00 00     ............)...

000005f8 <var_BLupgrade>:
     5f8:	42 4c 75 70 67 72 61 64 65 00                       BLupgrade.

00000602 <Web_Bootloader>:
     602:	00 1f 06 00 00 00 00 ff 00 00 00 ce 29 00 00 00     ............)...

00000612 <var_Bootloader>:
     612:	42 6f 6f 74 6c 6f 61 64 65 72 00                    Bootloader.

0000061d <Web_Reboot>:
     61d:	00 1f 06 00 00 00 00 ff 00 00 00 fb 28 00 00 00     ............(...

0000062d <var_Reboot>:
     62d:	52 65 62 6f 6f 74 00                                Reboot.

00000634 <Web_Title>:
     634:	22 0f 00 00 00 00 00 02 00 00 00 00 00 00 00 15     "...............

00000644 <var_Title>:
     644:	54 69 74 6c 65 00                                   Title.

0000064a <system_page>:
     64a:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     65a:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     66a:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     67a:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     68a:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     69a:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     6aa:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     6ba:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     6ca:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     6da:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     6ea:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     6fa:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     70a:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     71a:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     72a:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     73a:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     74a:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     75a:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     76a:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     77a:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     78a:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     79a:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     7aa:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     7ba:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     7ca:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     7da:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     7ea:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     7fa:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     80a:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     81a:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     82a:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     83a:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
     84a:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
     85a:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
     86a:	cd e0 e7 e2 e0 ed e8 e5 20 ee e1 fa e5 ea f2 e0     ........ .......
     87a:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     88a:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 69 74     'text' name='Tit
     89a:	6c 65 27 20 73 69 7a 65 3d 27 34 30 27 20 76 61     le' size='40' va
     8aa:	6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     lue='{{{{{{{{{{{
     8ba:	7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69     {{{{{{{{{'>...<i
     8ca:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     8da:	74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a     t' value='OK'>..
     8ea:	3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a     </form>..</BR>..
     8fa:	0d 0a cd e0 f0 e0 e1 ee f2 ea e0 20 3a 7b 7b 7b     ........... :{{{
     90a:	7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a 3c 46     {{{{{{{{ .....<F
     91a:	4f 52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     ORM action='/' m
     92a:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c     ethod='GET'>...<
     93a:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
     94a:	69 74 27 20 6e 61 6d 65 3d 27 52 65 62 6f 6f 74     it' name='Reboot
     95a:	27 20 76 61 6c 75 65 3d 27 52 65 62 6f 6f 74 27     ' value='Reboot'
     96a:	3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a c2 e5 f0 f1     >..</FORM>......
     97a:	e8 ff 20 cf ce 3a 20 33 2e 30 37 0d 0a 3c 46 4f     .. ..: 3.07..<FO
     98a:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
     99a:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
     9aa:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
     9ba:	74 27 20 6e 61 6d 65 3d 27 42 6f 6f 74 6c 6f 61     t' name='Bootloa
     9ca:	64 65 72 27 20 76 61 6c 75 65 3d 27 42 6f 6f 74     der' value='Boot
     9da:	6c 6f 61 64 65 72 27 20 63 6f 6c 6f 72 3d 27 52     loader' color='R
     9ea:	45 44 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     ED'>..</FORM>..<
     9fa:	2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63 74 69     /BR>..<FORM acti
     a0a:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
     a1a:	45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ET'>...<input ty
     a2a:	70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61 6d 65     pe='submit' name
     a3a:	3d 27 42 4c 75 70 67 72 61 64 65 27 20 76 61 6c     ='BLupgrade' val
     a4a:	75 65 3d 27 42 4c 75 70 67 72 61 64 65 27 3e 0d     ue='BLupgrade'>.
     a5a:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
     a6a:	0a 3c 48 32 3e d2 e5 ec ef e5 f0 e0 f2 f3 f0 e0     .<H2>...........
     a7a:	3c 2f 48 32 3e 0d 0a d2 e5 ec ef e5 f0 e0 f2 f3     </H2>...........
     a8a:	f0 e0 3a 7b 7b 7b 7b 7b 7b 7b 26 23 31 37 36 43     ..:{{{{{{{&#176C
     a9a:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
     aaa:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
     aba:	47 45 54 27 3e 0d 0a 09 d2 e2 fb f1 ee ea e0 ff     GET'>...........
     aca:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     ada:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 68 69     'text' name='Thi
     aea:	67 68 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c     gh' size='5' val
     afa:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31     ue='{{{{{{{'>&#1
     b0a:	37 36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     76C...<input typ
     b1a:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
     b2a:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
     b3a:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
     b4a:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
     b5a:	27 47 45 54 27 3e 0d 0a 09 d2 ed e8 e7 ea e0 ff     'GET'>..........
     b6a:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
     b7a:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 54 6c 6f     'text' name='Tlo
     b8a:	77 27 20 73 69 7a 65 3d 27 35 27 20 76 61 6c 75     w' size='5' valu
     b9a:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 27 3e 26 23 31 37     e='{{{{{{{'>&#17
     baa:	36 43 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     6C...<input type
     bba:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
     bca:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
     bda:	3c 2f 42 52 3e 0d 0a c1 f3 f4 e5 f0 20 47 53 4d     </BR>....... GSM
     bea:	2d 3e 45 4d 3a 20 7b 7b 7b 2f 28 6d 61 78 20 32     ->EM: {{{/(max 2
     bfa:	35 30 29 e1 e0 e9 f2 3c 2f 42 52 3e 0d 0a c1 f3     50)....</BR>....
     c0a:	f4 e5 f0 20 45 4d 2d 3e 47 53 4d 3a 20 7b 7b 7b     ... EM->GSM: {{{
     c1a:	2f 28 6d 61 78 20 32 35 30 29 e1 e0 e9 f2 3c 2f     /(max 250)....</
     c2a:	42 52 3e 0d 0a 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     BR>....</BODY>..
     c3a:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00000c44 <system_IField>:
     c44:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
     c54:	00 00 14 12 06 00 00 00 22 0f 00 00 00 15 10 63     ........"......c
     c64:	09 00 00 02 09 f2 05 00 00 01 0a 0d 00 00 00 01     ................
     c74:	0a 0b 00 00 00 01 00 7f 09 00 00 00 00 6e 0a 00     .............n..
	...

00000c86 <name_system>:
     c86:	73 79 73 74 65 6d 2e 68 74 6d 6c 00                 system.html.

00000c92 <Web_csd>:
     c92:	db 16 7b 16 2c 00 9f 0c c7 08 b4 0d 02              ..{.,........

00000c9f <csd_OField>:
     c9f:	ad 0d 9d 0d 98 0d 88 0d 83 0d 73 0d 6e 0d 5e 0d     ..........s.n.^.
     caf:	59 0d 49 0d 44 0d 34 0d 2f 0d 1f 0d 1a 0d 0a 0d     Y.I.D.4./.......
     cbf:	05 0d f5 0c f0 0c e0 0c db 0c cb 0c                 ............

00000ccb <Web_CSD_Number9>:
     ccb:	22 d6 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cdb <var_CSD_Number9>:
     cdb:	43 53 44 39 00                                      CSD9.

00000ce0 <Web_CSD_Number8>:
     ce0:	22 c9 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000cf0 <var_CSD_Number8>:
     cf0:	43 53 44 38 00                                      CSD8.

00000cf5 <Web_CSD_Number7>:
     cf5:	22 bc 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d05 <var_CSD_Number7>:
     d05:	43 53 44 37 00                                      CSD7.

00000d0a <Web_CSD_Number6>:
     d0a:	22 af 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d1a <var_CSD_Number6>:
     d1a:	43 53 44 36 00                                      CSD6.

00000d1f <Web_CSD_Number5>:
     d1f:	22 a2 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d2f <var_CSD_Number5>:
     d2f:	43 53 44 35 00                                      CSD5.

00000d34 <Web_CSD_Number4>:
     d34:	22 95 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d44 <var_CSD_Number4>:
     d44:	43 53 44 34 00                                      CSD4.

00000d49 <Web_CSD_Number3>:
     d49:	22 88 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00000d59 <var_CSD_Number3>:
     d59:	43 53 44 33 00                                      CSD3.

00000d5e <Web_CSD_Number2>:
     d5e:	22 7b 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "{..............

00000d6e <var_CSD_Number2>:
     d6e:	43 53 44 32 00                                      CSD2.

00000d73 <Web_CSD_Number1>:
     d73:	22 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "n..............

00000d83 <var_CSD_Number1>:
     d83:	43 53 44 31 00                                      CSD1.

00000d88 <Web_CSD_Number0>:
     d88:	22 61 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "a..............

00000d98 <var_CSD_Number0>:
     d98:	43 53 44 30 00                                      CSD0.

00000d9d <Web_CLIP>:
     d9d:	01 5f 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ._..............

00000dad <var_CLIP>:
     dad:	43 4c 49 50 4f 6e 00                                CLIPOn.

00000db4 <csd_page>:
     db4:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
     dc4:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
     dd4:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
     de4:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
     df4:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
     e04:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
     e14:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
     e24:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
     e34:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
     e44:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
     e54:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
     e64:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
     e74:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
     e84:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
     e94:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
     ea4:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
     eb4:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
     ec4:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
     ed4:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
     ee4:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
     ef4:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
     f04:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
     f14:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
     f24:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
     f34:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
     f44:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
     f54:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
     f64:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
     f74:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
     f84:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
     f94:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
     fa4:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 66 6f     .</a>..<HR>..<fo
     fb4:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
     fc4:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 cf f0     thod='GET'>.....
     fd4:	ee e2 e5 f0 ea e0 20 ed ee ec e5 f0 e0 3a 0d 0a     ...... ......:..
     fe4:	09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d 22 43     .<SELECT NAME="C
     ff4:	4c 49 50 4f 6e 22 3e 20 0d 0a 09 3c 4f 50 54 49     LIPOn"> ...<OPTI
    1004:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    1014:	7b 7b 7b 3e cd e5 f2 20 0d 0a 09 3c 4f 50 54 49     {{{>... ...<OPTI
    1024:	4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b     ON VALUE=1 {{{{{
    1034:	7b 7b 7b 3e c4 e0 0d 0a 09 3c 2f 53 45 4c 45 43     {{{>.....</SELEC
    1044:	54 3e 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     T> ...<input typ
    1054:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    1064:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    1074:	0a 3c 68 33 3e d0 e0 e7 f0 e5 f8 b8 ed ed fb e5     .<h3>...........
    1084:	20 ed ee ec e5 f0 e0 3c 2f 68 33 3e 3c 2f 42 52      ......</h3></BR
    1094:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    10a4:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    10b4:	3e 0d 0a 09 b9 31 3a 20 0d 0a 09 3c 69 6e 70 75     >....1: ...<inpu
    10c4:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    10d4:	6d 65 3d 27 43 53 44 30 27 20 73 69 7a 65 3d 27     me='CSD0' size='
    10e4:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    10f4:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1104:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1114:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1124:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1134:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1144:	47 45 54 27 3e 0d 0a 09 b9 32 3a 20 0d 0a 09 3c     GET'>....2: ...<
    1154:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1164:	27 20 6e 61 6d 65 3d 27 43 53 44 31 27 20 73 69     ' name='CSD1' si
    1174:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    1184:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    1194:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    11a4:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    11b4:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    11c4:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    11d4:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 33 3a 20     od='GET'>....3: 
    11e4:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    11f4:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 32     text' name='CSD2
    1204:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1214:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1224:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1234:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1244:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    1254:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    1264:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    1274:	b9 34 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .4: ...<input ty
    1284:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    1294:	43 53 44 33 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD3' size='12' 
    12a4:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    12b4:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    12c4:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    12d4:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    12e4:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    12f4:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1304:	3e 0d 0a 09 b9 35 3a 20 0d 0a 09 3c 69 6e 70 75     >....5: ...<inpu
    1314:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1324:	6d 65 3d 27 43 53 44 34 27 20 73 69 7a 65 3d 27     me='CSD4' size='
    1334:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1344:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1354:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1364:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1374:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    1384:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1394:	47 45 54 27 3e 0d 0a 09 b9 36 3a 20 0d 0a 09 3c     GET'>....6: ...<
    13a4:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    13b4:	27 20 6e 61 6d 65 3d 27 43 53 44 35 27 20 73 69     ' name='CSD5' si
    13c4:	7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27 7b     ze='12' value='{
    13d4:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09     {{{{{{{{{{{'>...
    13e4:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    13f4:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    1404:	0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d     ..</form>..<form
    1414:	20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68      action='/' meth
    1424:	6f 64 3d 27 47 45 54 27 3e 0d 0a 09 b9 37 3a 20     od='GET'>....7: 
    1434:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    1444:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 53 44 36     text' name='CSD6
    1454:	27 20 73 69 7a 65 3d 27 31 32 27 20 76 61 6c 75     ' size='12' valu
    1464:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27     e='{{{{{{{{{{{{'
    1474:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    1484:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    1494:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    14a4:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    14b4:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    14c4:	b9 38 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79     .8: ...<input ty
    14d4:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    14e4:	43 53 44 37 27 20 73 69 7a 65 3d 27 31 32 27 20     CSD7' size='12' 
    14f4:	76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b     value='{{{{{{{{{
    1504:	7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{{'>...<input t
    1514:	79 70 65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c     ype='submit' val
    1524:	75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d     ue='OK'>..</form
    1534:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    1544:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    1554:	3e 0d 0a 09 b9 39 3a 20 0d 0a 09 3c 69 6e 70 75     >....9: ...<inpu
    1564:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    1574:	6d 65 3d 27 43 53 44 38 27 20 73 69 7a 65 3d 27     me='CSD8' size='
    1584:	31 32 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     12' value='{{{{{
    1594:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    15a4:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    15b4:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    15c4:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    15d4:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    15e4:	47 45 54 27 3e 0d 0a 09 b9 31 30 3a 20 0d 0a 09     GET'>....10: ...
    15f4:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    1604:	74 27 20 6e 61 6d 65 3d 27 43 53 44 39 27 20 73     t' name='CSD9' s
    1614:	69 7a 65 3d 27 31 32 27 20 76 61 6c 75 65 3d 27     ize='12' value='
    1624:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a     {{{{{{{{{{{{'>..
    1634:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75     .<input type='su
    1644:	62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27     bmit' value='OK'
    1654:	3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52     >..</form>..</BR
    1664:	3e 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48     >.. </BODY>..</H
    1674:	54 4d 4c 3e 0d 0a 00                                TML>...

0000167b <csd_IField>:
    167b:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    168b:	00 00 14 12 06 00 00 00 1e 5f 00 39 45 00 1e 5f     ........._.9E.._
    169b:	00 35 45 00 22 61 00 00 00 0d 22 6e 00 00 00 0d     .5E."a...."n....
    16ab:	22 7b 00 00 00 0d 22 88 00 00 00 0d 22 95 00 00     "{...."....."...
    16bb:	00 0d 22 a2 00 00 00 0d 22 af 00 00 00 0d 22 bc     ..".....".....".
    16cb:	00 00 00 0d 22 c9 00 00 00 0d 22 d6 00 00 00 0d     ....".....".....

000016db <name_csd>:
    16db:	63 73 64 2e 68 74 6d 6c 00                          csd.html.

000016e4 <Web_gsm>:
    16e4:	cf 1c 9f 1c 1c 00 f1 16 cf 04 d0 17 04              .............

000016f1 <gsm_OField>:
    16f1:	c7 17 b7 17 a4 17 94 17 87 17 77 17 71 17 61 17     ..........w.q.a.
    1701:	55 17 45 17 39 17 29 17 1d 17 0d 17                 U.E.9.).....

0000170d <Web_SMS_Number3>:
    170d:	22 fd 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

0000171d <var_SMS_Number3>:
    171d:	53 4d 53 5f 4e 75 6d 62 65 72 33 00                 SMS_Number3.

00001729 <Web_SMS_Number2>:
    1729:	22 f0 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001739 <var_SMS_Number2>:
    1739:	53 4d 53 5f 4e 75 6d 62 65 72 32 00                 SMS_Number2.

00001745 <Web_SMS_Number1>:
    1745:	22 e3 00 00 00 00 00 00 00 00 00 00 00 00 00 0d     "...............

00001755 <var_SMS_Number1>:
    1755:	53 4d 53 5f 4e 75 6d 62 65 72 31 00                 SMS_Number1.

00001761 <Web_SMS>:
    1761:	01 60 00 00 00 00 00 01 00 00 00 00 00 00 00 00     .`..............

00001771 <var_SMS>:
    1771:	53 4d 53 4f 6e 00                                   SMSOn.

00001777 <Web_GPRS_apn_psw>:
    1777:	22 54 01 00 00 00 00 02 00 00 00 25 2a 00 00 14     "T.........%*...

00001787 <var_GPRS_apn_psw>:
    1787:	47 50 52 53 5f 61 70 6e 5f 70 73 77 00              GPRS_apn_psw.

00001794 <Web_GPRS_apn_user_name>:
    1794:	22 68 01 00 00 00 00 02 00 00 00 25 2a 00 00 14     "h.........%*...

000017a4 <var_GPRS_apn_user_name>:
    17a4:	47 50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61     GPRS_apn_user_na
    17b4:	6d 65 00                                            me.

000017b7 <Web_GPRS_apn1>:
    17b7:	22 7c 01 00 00 00 00 02 00 00 00 25 2a 00 00 1e     "|.........%*...

000017c7 <var_GPRS_apn1>:
    17c7:	47 50 52 53 5f 61 70 6e 00                          GPRS_apn.

000017d0 <gsm_page>:
    17d0:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    17e0:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    17f0:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    1800:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    1810:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    1820:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    1830:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    1840:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    1850:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    1860:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    1870:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    1880:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    1890:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    18a0:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    18b0:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    18c0:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    18d0:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    18e0:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    18f0:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    1900:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    1910:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    1920:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    1930:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    1940:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    1950:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    1960:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    1970:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    1980:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    1990:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    19a0:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    19b0:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    19c0:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a d3 f0 ee     .</a>..<HR>.....
    19d0:	e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0 20 7b 7b 20     .... ....... {{ 
    19e0:	28 30 2d 33 31 29 3c 2f 42 52 3e 0d 0a 3c 68 33     (0-31)</BR>..<h3
    19f0:	3e 47 50 52 53 3c 2f 68 33 3e 3c 2f 42 52 3e 0d     >GPRS</h3></BR>.
    1a00:	0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f     .<form action='/
    1a10:	27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d     ' method='GET'>.
    1a20:	0a 09 41 50 4e 20 6e 61 6d 65 3a 20 0d 0a 09 3c     ..APN name: ...<
    1a30:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    1a40:	27 20 6e 61 6d 65 3d 27 47 50 52 53 5f 61 70 6e     ' name='GPRS_apn
    1a50:	27 20 73 69 7a 65 3d 27 32 39 27 20 76 61 6c 75     ' size='29' valu
    1a60:	65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     e='{{{{{{{{{{{{{
    1a70:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    1a80:	27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     '>...<input type
    1a90:	3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d     ='submit' value=
    1aa0:	27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a     'OK'>..</form>..
    1ab0:	3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </BR>..<form act
    1ac0:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    1ad0:	47 45 54 27 3e 0d 0a 09 55 73 65 72 20 6e 61 6d     GET'>...User nam
    1ae0:	65 3a 20 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     e: ...<input typ
    1af0:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 47     e='text' name='G
    1b00:	50 52 53 5f 61 70 6e 5f 75 73 65 72 5f 6e 61 6d     PRS_apn_user_nam
    1b10:	65 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     e' size='19' val
    1b20:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1b30:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1b40:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1b50:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1b60:	66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66     form>..</BR>..<f
    1b70:	6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d     orm action='/' m
    1b80:	65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 50     ethod='GET'>...P
    1b90:	61 73 73 77 6f 72 64 3a 20 0d 0a 09 3c 69 6e 70     assword: ...<inp
    1ba0:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    1bb0:	61 6d 65 3d 27 47 50 52 53 5f 61 70 6e 5f 70 73     ame='GPRS_apn_ps
    1bc0:	77 27 20 73 69 7a 65 3d 27 31 39 27 20 76 61 6c     w' size='19' val
    1bd0:	75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     ue='{{{{{{{{{{{{
    1be0:	7b 7b 7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70     {{{{{{{'>...<inp
    1bf0:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    1c00:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    1c10:	66 6f 72 6d 0d 0a 3c 2f 42 52 3e 0d 0a 3c 46 4f     form..</BR>..<FO
    1c20:	52 4d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     RM action='/' me
    1c30:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 3c 69     thod='GET'>...<i
    1c40:	6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69     nput type='submi
    1c50:	74 27 20 6e 61 6d 65 3d 27 52 65 73 65 74 47 53     t' name='ResetGS
    1c60:	4d 27 20 76 61 6c 75 65 3d 27 52 65 73 65 74 47     M' value='ResetG
    1c70:	53 4d 27 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c     SM'>..</FORM>..<
    1c80:	2f 42 52 3e 3c 2f 42 52 3e 0d 0a 20 3c 2f 42 4f     /BR></BR>.. </BO
    1c90:	44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00        DY>..</HTML>...

00001c9f <gsm_IField>:
    1c9f:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    1caf:	00 00 14 12 06 00 00 00 00 25 06 00 00 00 22 7c     .........%...."|
    1cbf:	01 00 00 1e 22 68 01 00 00 14 22 54 01 00 00 14     ...."h...."T....

00001ccf <name_gsm>:
    1ccf:	67 73 6d 2e 68 74 6d 6c 00                          gsm.html.

00001cd8 <Web_network>:
    1cd8:	a7 32 a5 31 a0 00 e5 1c 4a 10 5b 21 04              .2.1....J.[!.

00001ce5 <network_OField>:
    1ce5:	4c 21 3c 21 28 21 18 21 06 21 f6 20 95 1d 85 1d     L!<!(!.!.!. ....
    1cf5:	ed 20 dd 20 d4 20 c4 20 bb 20 ab 20 a2 20 92 20     . . . . . . . . 
    1d05:	89 20 79 20 70 20 60 20 57 20 47 20 3e 20 2e 20     . y p ` W G > . 
    1d15:	25 20 15 20 0c 20 fc 1f f3 1f e3 1f da 1f ca 1f     % . . ..........
    1d25:	c1 1f b1 1f a8 1f 98 1f 8f 1f 7f 1f 76 1f 66 1f     ............v.f.
    1d35:	60 1f 50 1f 4a 1f 3a 1f 34 1f 24 1f 1e 1f 0e 1f     `.P.J.:.4.$.....
    1d45:	08 1f f8 1e f2 1e e2 1e dc 1e cc 1e c6 1e b6 1e     ................
    1d55:	b0 1e a0 1e 9a 1e 8a 1e 84 1e 74 1e 6e 1e 5e 1e     ..........t.n.^.
    1d65:	58 1e 48 1e 42 1e 32 1e 2c 1e 1c 1e 16 1e 06 1e     X.H.B.2.,.......
    1d75:	fc 1d ec 1d e2 1d d2 1d c8 1d b8 1d ae 1d 9e 1d     ................

00001d85 <Web_ResetGSM>:
    1d85:	00 1f 06 00 00 00 00 ff 00 00 00 fd 28 00 00 00     ............(...

00001d95 <var_ResetGSM>:
    1d95:	52 65 73 65 74 47 53 4d 00                          ResetGSM.

00001d9e <Web_UDP3_Port>:
    1d9e:	08 30 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .0..............

00001dae <var_UDP3_Port>:
    1dae:	55 44 50 33 5f 50 6f 72 74 00                       UDP3_Port.

00001db8 <Web_UDP2_Port>:
    1db8:	08 2e 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     ................

00001dc8 <var_UDP2_Port>:
    1dc8:	55 44 50 32 5f 50 6f 72 74 00                       UDP2_Port.

00001dd2 <Web_UDP1_Port>:
    1dd2:	08 2c 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .,..............

00001de2 <var_UDP1_Port>:
    1de2:	55 44 50 31 5f 50 6f 72 74 00                       UDP1_Port.

00001dec <Web_UDP0_Port>:
    1dec:	08 2a 01 00 00 00 00 ff ff 00 00 00 00 00 00 00     .*..............

00001dfc <var_UDP0_Port>:
    1dfc:	55 44 50 30 5f 50 6f 72 74 00                       UDP0_Port.

00001e06 <Web_UDP3_IP4>:
    1e06:	01 51 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .Q..............

00001e16 <var_UDP3_IP4>:
    1e16:	55 44 50 33 34 00                                   UDP34.

00001e1c <Web_UDP3_IP3>:
    1e1c:	01 50 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .P..............

00001e2c <var_UDP3_IP3>:
    1e2c:	55 44 50 33 33 00                                   UDP33.

00001e32 <Web_UDP3_IP2>:
    1e32:	01 4f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .O..............

00001e42 <var_UDP3_IP2>:
    1e42:	55 44 50 33 32 00                                   UDP32.

00001e48 <Web_UDP3_IP1>:
    1e48:	01 4e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .N..............

00001e58 <var_UDP3_IP1>:
    1e58:	55 44 50 33 31 00                                   UDP31.

00001e5e <Web_UDP2_IP4>:
    1e5e:	01 4d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .M..............

00001e6e <var_UDP2_IP4>:
    1e6e:	55 44 50 32 34 00                                   UDP24.

00001e74 <Web_UDP2_IP3>:
    1e74:	01 4c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .L..............

00001e84 <var_UDP2_IP3>:
    1e84:	55 44 50 32 33 00                                   UDP23.

00001e8a <Web_UDP2_IP2>:
    1e8a:	01 4b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .K..............

00001e9a <var_UDP2_IP2>:
    1e9a:	55 44 50 32 32 00                                   UDP22.

00001ea0 <Web_UDP2_IP1>:
    1ea0:	01 4a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .J..............

00001eb0 <var_UDP2_IP1>:
    1eb0:	55 44 50 32 31 00                                   UDP21.

00001eb6 <Web_UDP1_IP4>:
    1eb6:	01 49 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .I..............

00001ec6 <var_UDP1_IP4>:
    1ec6:	55 44 50 31 34 00                                   UDP14.

00001ecc <Web_UDP1_IP3>:
    1ecc:	01 48 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .H..............

00001edc <var_UDP1_IP3>:
    1edc:	55 44 50 31 33 00                                   UDP13.

00001ee2 <Web_UDP1_IP2>:
    1ee2:	01 47 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .G..............

00001ef2 <var_UDP1_IP2>:
    1ef2:	55 44 50 31 32 00                                   UDP12.

00001ef8 <Web_UDP1_IP1>:
    1ef8:	01 46 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .F..............

00001f08 <var_UDP1_IP1>:
    1f08:	55 44 50 31 31 00                                   UDP11.

00001f0e <Web_UDP0_IP4>:
    1f0e:	01 45 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .E..............

00001f1e <var_UDP0_IP4>:
    1f1e:	55 44 50 30 34 00                                   UDP04.

00001f24 <Web_UDP0_IP3>:
    1f24:	01 44 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .D..............

00001f34 <var_UDP0_IP3>:
    1f34:	55 44 50 30 33 00                                   UDP03.

00001f3a <Web_UDP0_IP2>:
    1f3a:	01 43 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .C..............

00001f4a <var_UDP0_IP2>:
    1f4a:	55 44 50 30 32 00                                   UDP02.

00001f50 <Web_UDP0_IP1>:
    1f50:	01 42 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     .B..............

00001f60 <var_UDP0_IP1>:
    1f60:	55 44 50 30 31 00                                   UDP01.

00001f66 <Web_Cli3_IP4>:
    1f66:	01 1f 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f76 <var_Cli3_IP4>:
    1f76:	43 6c 69 33 5f 49 50 34 00                          Cli3_IP4.

00001f7f <Web_Cli3_IP3>:
    1f7f:	01 1e 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001f8f <var_Cli3_IP3>:
    1f8f:	43 6c 69 33 5f 49 50 33 00                          Cli3_IP3.

00001f98 <Web_Cli3_IP2>:
    1f98:	01 1d 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fa8 <var_Cli3_IP2>:
    1fa8:	43 6c 69 33 5f 49 50 32 00                          Cli3_IP2.

00001fb1 <Web_Cli3_IP1>:
    1fb1:	01 1c 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fc1 <var_Cli3_IP1>:
    1fc1:	43 6c 69 33 5f 49 50 31 00                          Cli3_IP1.

00001fca <Web_Cli2_IP4>:
    1fca:	01 1b 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001fda <var_Cli2_IP4>:
    1fda:	43 6c 69 32 5f 49 50 34 00                          Cli2_IP4.

00001fe3 <Web_Cli2_IP3>:
    1fe3:	01 1a 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00001ff3 <var_Cli2_IP3>:
    1ff3:	43 6c 69 32 5f 49 50 33 00                          Cli2_IP3.

00001ffc <Web_Cli2_IP2>:
    1ffc:	01 19 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000200c <var_Cli2_IP2>:
    200c:	43 6c 69 32 5f 49 50 32 00                          Cli2_IP2.

00002015 <Web_Cli2_IP1>:
    2015:	01 18 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002025 <var_Cli2_IP1>:
    2025:	43 6c 69 32 5f 49 50 31 00                          Cli2_IP1.

0000202e <Web_Cli1_IP4>:
    202e:	01 17 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

0000203e <var_Cli1_IP4>:
    203e:	43 6c 69 31 5f 49 50 34 00                          Cli1_IP4.

00002047 <Web_Cli1_IP3>:
    2047:	01 16 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002057 <var_Cli1_IP3>:
    2057:	43 6c 69 31 5f 49 50 33 00                          Cli1_IP3.

00002060 <Web_Cli1_IP2>:
    2060:	01 15 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002070 <var_Cli1_IP2>:
    2070:	43 6c 69 31 5f 49 50 32 00                          Cli1_IP2.

00002079 <Web_Cli1_IP1>:
    2079:	01 14 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

00002089 <var_Cli1_IP1>:
    2089:	43 6c 69 31 5f 49 50 31 00                          Cli1_IP1.

00002092 <Web_Cli0_IP4>:
    2092:	01 13 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020a2 <var_Cli0_IP4>:
    20a2:	43 6c 69 30 5f 49 50 34 00                          Cli0_IP4.

000020ab <Web_Cli0_IP3>:
    20ab:	01 12 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020bb <var_Cli0_IP3>:
    20bb:	43 6c 69 30 5f 49 50 33 00                          Cli0_IP3.

000020c4 <Web_Cli0_IP2>:
    20c4:	01 11 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020d4 <var_Cli0_IP2>:
    20d4:	43 6c 69 30 5f 49 50 32 00                          Cli0_IP2.

000020dd <Web_Cli0_IP1>:
    20dd:	01 10 01 00 00 00 00 ff 00 00 00 00 00 00 00 00     ................

000020ed <var_Cli0_IP1>:
    20ed:	43 6c 69 30 5f 49 50 31 00                          Cli0_IP1.

000020f6 <Web_WebMaxSessionTime>:
    20f6:	11 56 00 00 00 00 00 ff c9 9a 3b 00 00 00 00 02     .V........;.....

00002106 <var_WebMaxSessionTime>:
    2106:	57 65 62 4d 61 78 53 65 73 73 69 6f 6e 54 69 6d     WebMaxSessionTim
    2116:	65 00                                               e.

00002118 <Web_TCP_CONNECT_timeout>:
    2118:	08 0e 01 00 00 00 00 ff ff 00 00 25 2a 00 00 02     ...........%*...

00002128 <var_TCP_CONNECT_timeout>:
    2128:	54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74 69 6d 65     TCP_CONNECT_time
    2138:	6f 75 74 00                                         out.

0000213c <Web_TCP_ListenPort>:
    213c:	08 20 01 00 00 00 00 ff ff 00 00 25 2a 00 00 00     . .........%*...

0000214c <var_TCP_ListenPort>:
    214c:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 00        TCP_ListenPort.

0000215b <network_page>:
    215b:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    216b:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    217b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    218b:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    219b:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    21ab:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    21bb:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    21cb:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    21db:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    21eb:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    21fb:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    220b:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    221b:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    222b:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    223b:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    224b:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    225b:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    226b:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    227b:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    228b:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    229b:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    22ab:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    22bb:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    22cb:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    22db:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    22eb:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    22fb:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    230b:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    231b:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    232b:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    233b:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    234b:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 0d 0a 3c     .</a>..<HR>....<
    235b:	68 33 3e 54 43 50 2f 49 50 20 53 65 72 76 65 72     h3>TCP/IP Server
    236b:	3c 2f 68 33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     </h3>..<form act
    237b:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    238b:	47 45 54 27 3e 0d 0a 09 4c 69 73 74 65 6e 20 70     GET'>...Listen p
    239b:	6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     ort:...<input ty
    23ab:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    23bb:	54 43 50 5f 4c 69 73 74 65 6e 50 6f 72 74 27 20     TCP_ListenPort' 
    23cb:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    23db:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    23eb:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    23fb:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    240b:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    241b:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    242b:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 54 43 50     hod='GET'>...TCP
    243b:	2f 49 50 20 63 6f 6e 6e 65 63 74 69 6f 6e 20 74     /IP connection t
    244b:	69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70 75 74     imeout:...<input
    245b:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    246b:	65 3d 27 54 43 50 5f 43 4f 4e 4e 45 43 54 5f 74     e='TCP_CONNECT_t
    247b:	69 6d 65 6f 75 74 27 20 73 69 7a 65 3d 27 37 27     imeout' size='7'
    248b:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 27 3e      value='{{{{{{'>
    249b:	73 65 63 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     sec...<input typ
    24ab:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    24bb:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    24cb:	0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63     .</BR>..<form ac
    24db:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    24eb:	27 47 45 54 27 3e 0d 0a 09 53 65 73 73 69 6f 6e     'GET'>...Session
    24fb:	20 74 69 6d 65 6f 75 74 3a 0d 0a 09 3c 69 6e 70      timeout:...<inp
    250b:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    251b:	61 6d 65 3d 27 57 65 62 4d 61 78 53 65 73 73 69     ame='WebMaxSessi
    252b:	6f 6e 54 69 6d 65 27 20 73 69 7a 65 3d 27 37 27     onTime' size='7'
    253b:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 7b 7b 7b      value='{{{{{{{{
    254b:	7b 7b 27 3e 73 65 63 0d 0a 09 3c 69 6e 70 75 74     {{'>sec...<input
    255b:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    256b:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    257b:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 68     rm>..</BR>....<h
    258b:	33 3e 49 50 20 46 69 72 65 77 61 6c 6c 3c 2f 68     3>IP Firewall</h
    259b:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    25ab:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    25bb:	27 3e 0d 0a 09 49 50 31 3a 0d 0a 09 3c 69 6e 70     '>...IP1:...<inp
    25cb:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    25db:	61 6d 65 3d 27 43 6c 69 30 5f 49 50 31 27 20 73     ame='Cli0_IP1' s
    25eb:	69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b     ize='3' value='{
    25fb:	7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74     {{'>....<input t
    260b:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    261b:	27 43 6c 69 30 5f 49 50 32 27 20 73 69 7a 65 3d     'Cli0_IP2' size=
    262b:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    263b:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    264b:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69     'text' name='Cli
    265b:	30 5f 49 50 33 27 20 73 69 7a 65 3d 27 33 27 20     0_IP3' size='3' 
    266b:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    267b:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    268b:	74 27 20 6e 61 6d 65 3d 27 43 6c 69 30 5f 49 50     t' name='Cli0_IP
    269b:	34 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     4' size='3' valu
    26ab:	65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75     e='{{{'>...<inpu
    26bb:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    26cb:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    26db:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f     orm>..</BR>..<fo
    26eb:	72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65     rm action='/' me
    26fb:	74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09 49 50     thod='GET'>...IP
    270b:	32 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     2:...<input type
    271b:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c     ='text' name='Cl
    272b:	69 31 5f 49 50 31 27 20 73 69 7a 65 3d 27 33 27     i1_IP1' size='3'
    273b:	20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a      value='{{{'>...
    274b:	09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65     .<input type='te
    275b:	78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 31 5f 49     xt' name='Cli1_I
    276b:	50 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     P2' size='3' val
    277b:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    278b:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    279b:	6e 61 6d 65 3d 27 43 6c 69 31 5f 49 50 33 27 20     name='Cli1_IP3' 
    27ab:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    27bb:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    27cb:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    27db:	3d 27 43 6c 69 31 5f 49 50 34 27 20 73 69 7a 65     ='Cli1_IP4' size
    27eb:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    27fb:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    280b:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    281b:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    282b:	2f 42 52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69     /BR>..<form acti
    283b:	6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47     on='/' method='G
    284b:	45 54 27 3e 0d 0a 09 49 50 33 3a 0d 0a 09 3c 69     ET'>...IP3:...<i
    285b:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    286b:	20 6e 61 6d 65 3d 27 43 6c 69 32 5f 49 50 31 27      name='Cli2_IP1'
    287b:	20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d      size='3' value=
    288b:	27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74     '{{{'>....<input
    289b:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    28ab:	65 3d 27 43 6c 69 32 5f 49 50 32 27 20 73 69 7a     e='Cli2_IP2' siz
    28bb:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    28cb:	27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     '>....<input typ
    28db:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 43     e='text' name='C
    28eb:	6c 69 32 5f 49 50 33 27 20 73 69 7a 65 3d 27 33     li2_IP3' size='3
    28fb:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d     ' value='{{{'>..
    290b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    291b:	65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 32 5f     ext' name='Cli2_
    292b:	49 50 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     IP4' size='3' va
    293b:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e     lue='{{{'>...<in
    294b:	70 75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74     put type='submit
    295b:	27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c     ' value='OK'>..<
    296b:	2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c     /form>..</BR>..<
    297b:	66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20     form action='/' 
    298b:	6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a 09     method='GET'>...
    299b:	49 50 34 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79     IP4:...<input ty
    29ab:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    29bb:	43 6c 69 33 5f 49 50 31 27 20 73 69 7a 65 3d 27     Cli3_IP1' size='
    29cb:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    29db:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    29eb:	74 65 78 74 27 20 6e 61 6d 65 3d 27 43 6c 69 33     text' name='Cli3
    29fb:	5f 49 50 32 27 20 73 69 7a 65 3d 27 33 27 20 76     _IP2' size='3' v
    2a0b:	61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c     alue='{{{'>....<
    2a1b:	69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74     input type='text
    2a2b:	27 20 6e 61 6d 65 3d 27 43 6c 69 33 5f 49 50 33     ' name='Cli3_IP3
    2a3b:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2a4b:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2a5b:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2a6b:	6d 65 3d 27 43 6c 69 33 5f 49 50 34 27 20 73 69     me='Cli3_IP4' si
    2a7b:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2a8b:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2a9b:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2aab:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2abb:	0a 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61 63     .</BR>..<FORM ac
    2acb:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    2adb:	27 47 45 54 27 3e 0d 0a 09 3c 69 6e 70 75 74 20     'GET'>...<input 
    2aeb:	74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 6e 61     type='submit' na
    2afb:	6d 65 3d 27 52 65 73 65 74 47 53 4d 27 20 76 61     me='ResetGSM' va
    2b0b:	6c 75 65 3d 27 52 65 73 65 74 47 53 4d 27 3e 0d     lue='ResetGSM'>.
    2b1b:	0a 3c 2f 46 4f 52 4d 3e 0d 0a 3c 2f 42 52 3e 0d     .</FORM>..</BR>.
    2b2b:	0a 0d 0a 0d 0a 3c 68 33 3e ce f2 f1 fb eb ea e0     .....<h3>.......
    2b3b:	20 f2 e5 ea f3 f9 e8 f5 20 e4 e0 ed ed fb f5 3a      ....... ......:
    2b4b:	3c 2f 68 33 3e 0d 0a 3c 2f 42 52 3e 0d 0a 0d 0a     </h3>..</BR>....
    2b5b:	3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d 27 2f 27     <form action='/'
    2b6b:	20 6d 65 74 68 6f 64 3d 27 47 45 54 27 3e 0d 0a      method='GET'>..
    2b7b:	55 44 50 20 53 65 72 76 65 72 31 20 49 50 3a 0d     UDP Server1 IP:.
    2b8b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    2b9b:	65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 30 31     ext' name='UDP01
    2bab:	27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65     ' size='3' value
    2bbb:	3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75     ='{{{'>....<inpu
    2bcb:	74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61     t type='text' na
    2bdb:	6d 65 3d 27 55 44 50 30 32 27 20 73 69 7a 65 3d     me='UDP02' size=
    2beb:	27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e     '3' value='{{{'>
    2bfb:	2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     ....<input type=
    2c0b:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    2c1b:	30 33 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c     03' size='3' val
    2c2b:	75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e     ue='{{{'>....<in
    2c3b:	70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20     put type='text' 
    2c4b:	6e 61 6d 65 3d 27 55 44 50 30 34 27 20 73 69 7a     name='UDP04' siz
    2c5b:	65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b     e='3' value='{{{
    2c6b:	27 3e 0d 0a 50 6f 72 74 3a 0d 0a 09 3c 69 6e 70     '>..Port:...<inp
    2c7b:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2c8b:	61 6d 65 3d 27 55 44 50 30 5f 50 6f 72 74 27 20     ame='UDP0_Port' 
    2c9b:	73 69 7a 65 3d 27 35 27 20 76 61 6c 75 65 3d 27     size='5' value='
    2cab:	7b 7b 7b 7b 7b 27 3e 0d 0a 09 3c 69 6e 70 75 74     {{{{{'>...<input
    2cbb:	20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20 76      type='submit' v
    2ccb:	61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f     alue='OK'>..</fo
    2cdb:	72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 66 6f 72     rm>..</BR>..<for
    2ceb:	6d 20 61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74     m action='/' met
    2cfb:	68 6f 64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20     hod='GET'>..UDP 
    2d0b:	53 65 72 76 65 72 32 20 49 50 3a 0d 0a 09 3c 69     Server2 IP:...<i
    2d1b:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2d2b:	20 6e 61 6d 65 3d 27 55 44 50 31 31 27 20 73 69      name='UDP11' si
    2d3b:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2d4b:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2d5b:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2d6b:	55 44 50 31 32 27 20 73 69 7a 65 3d 27 33 27 20     UDP12' size='3' 
    2d7b:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09     value='{{{'>....
    2d8b:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65 78     <input type='tex
    2d9b:	74 27 20 6e 61 6d 65 3d 27 55 44 50 31 33 27 20     t' name='UDP13' 
    2dab:	73 69 7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27     size='3' value='
    2dbb:	7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20     {{{'>....<input 
    2dcb:	74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65     type='text' name
    2ddb:	3d 27 55 44 50 31 34 27 20 73 69 7a 65 3d 27 33     ='UDP14' size='3
    2deb:	27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a     ' value='{{{'>..
    2dfb:	50 6f 72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74     Port:...<input t
    2e0b:	79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d     ype='text' name=
    2e1b:	27 55 44 50 31 5f 50 6f 72 74 27 20 73 69 7a 65     'UDP1_Port' size
    2e2b:	3d 27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b     ='5' value='{{{{
    2e3b:	7b 27 3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     {'>...<input typ
    2e4b:	65 3d 27 73 75 62 6d 69 74 27 20 76 61 6c 75 65     e='submit' value
    2e5b:	3d 27 4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d     ='OK'>..</form>.
    2e6b:	0a 3c 2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20     .</BR>....<form 
    2e7b:	61 63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f     action='/' metho
    2e8b:	64 3d 27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65     d='GET'>..UDP Se
    2e9b:	72 76 65 72 33 20 49 50 3a 0d 0a 09 3c 69 6e 70     rver3 IP:...<inp
    2eab:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    2ebb:	61 6d 65 3d 27 55 44 50 32 31 27 20 73 69 7a 65     ame='UDP21' size
    2ecb:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    2edb:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    2eeb:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    2efb:	50 32 32 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P22' size='3' va
    2f0b:	6c 75 65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69     lue='{{{'>....<i
    2f1b:	6e 70 75 74 20 74 79 70 65 3d 27 74 65 78 74 27     nput type='text'
    2f2b:	20 6e 61 6d 65 3d 27 55 44 50 32 33 27 20 73 69      name='UDP23' si
    2f3b:	7a 65 3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b     ze='3' value='{{
    2f4b:	7b 27 3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79     {'>....<input ty
    2f5b:	70 65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27     pe='text' name='
    2f6b:	55 44 50 32 34 27 20 73 69 7a 65 3d 27 33 27 20     UDP24' size='3' 
    2f7b:	76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f     value='{{{'>..Po
    2f8b:	72 74 3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70     rt:...<input typ
    2f9b:	65 3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55     e='text' name='U
    2fab:	44 50 32 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27     DP2_Port' size='
    2fbb:	35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27     5' value='{{{{{'
    2fcb:	3e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     >...<input type=
    2fdb:	27 73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27     'submit' value='
    2feb:	4f 4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c     OK'>..</form>..<
    2ffb:	2f 42 52 3e 0d 0a 0d 0a 3c 66 6f 72 6d 20 61 63     /BR>....<form ac
    300b:	74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d     tion='/' method=
    301b:	27 47 45 54 27 3e 0d 0a 55 44 50 20 53 65 72 76     'GET'>..UDP Serv
    302b:	65 72 34 20 49 50 3a 0d 0a 09 3c 69 6e 70 75 74     er4 IP:...<input
    303b:	20 74 79 70 65 3d 27 74 65 78 74 27 20 6e 61 6d      type='text' nam
    304b:	65 3d 27 55 44 50 33 31 27 20 73 69 7a 65 3d 27     e='UDP31' size='
    305b:	33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27 3e 2e     3' value='{{{'>.
    306b:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    307b:	74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50 33     text' name='UDP3
    308b:	32 27 20 73 69 7a 65 3d 27 33 27 20 76 61 6c 75     2' size='3' valu
    309b:	65 3d 27 7b 7b 7b 27 3e 2e 0d 0a 09 3c 69 6e 70     e='{{{'>....<inp
    30ab:	75 74 20 74 79 70 65 3d 27 74 65 78 74 27 20 6e     ut type='text' n
    30bb:	61 6d 65 3d 27 55 44 50 33 33 27 20 73 69 7a 65     ame='UDP33' size
    30cb:	3d 27 33 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 27     ='3' value='{{{'
    30db:	3e 2e 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65     >....<input type
    30eb:	3d 27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44     ='text' name='UD
    30fb:	50 33 34 27 20 73 69 7a 65 3d 27 33 27 20 76 61     P34' size='3' va
    310b:	6c 75 65 3d 27 7b 7b 7b 27 3e 0d 0a 50 6f 72 74     lue='{{{'>..Port
    311b:	3a 0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d     :...<input type=
    312b:	27 74 65 78 74 27 20 6e 61 6d 65 3d 27 55 44 50     'text' name='UDP
    313b:	33 5f 50 6f 72 74 27 20 73 69 7a 65 3d 27 35 27     3_Port' size='5'
    314b:	20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b 27 3e 0d      value='{{{{{'>.
    315b:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73     ..<input type='s
    316b:	75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b     ubmit' value='OK
    317b:	27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42     '>..</form>..</B
    318b:	52 3e 0d 0a 0d 0a 20 3c 2f 42 4f 44 59 3e 0d 0a     R>.... </BODY>..
    319b:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

000031a5 <network_IField>:
    31a5:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    31b5:	00 00 14 12 06 00 00 00 08 20 01 00 00 00 08 0e     ......... ......
    31c5:	01 00 00 02 11 56 00 00 00 02 01 10 01 00 00 00     .....V..........
    31d5:	01 11 01 00 00 00 01 12 01 00 00 00 01 13 01 00     ................
    31e5:	00 00 01 14 01 00 00 00 01 15 01 00 00 00 01 16     ................
    31f5:	01 00 00 00 01 17 01 00 00 00 01 18 01 00 00 00     ................
    3205:	01 19 01 00 00 00 01 1a 01 00 00 00 01 1b 01 00     ................
    3215:	00 00 01 1c 01 00 00 00 01 1d 01 00 00 00 01 1e     ................
    3225:	01 00 00 00 01 1f 01 00 00 00 01 42 01 00 00 00     ...........B....
    3235:	01 43 01 00 00 00 01 44 01 00 00 00 01 45 01 00     .C.....D.....E..
    3245:	00 00 08 2a 01 00 00 00 01 46 01 00 00 00 01 47     ...*.....F.....G
    3255:	01 00 00 00 01 48 01 00 00 00 01 49 01 00 00 00     .....H.....I....
    3265:	08 2c 01 00 00 00 01 4a 01 00 00 00 01 4b 01 00     .,.....J.....K..
    3275:	00 00 01 4c 01 00 00 00 01 4d 01 00 00 00 08 2e     ...L.....M......
    3285:	01 00 00 00 01 4e 01 00 00 00 01 4f 01 00 00 00     .....N.....O....
    3295:	01 50 01 00 00 00 01 51 01 00 00 00 08 30 01 00     .P.....Q.....0..
	...

000032a7 <name_network>:
    32a7:	6e 65 74 77 6f 72 6b 2e 68 74 6d 6c 00              network.html.

000032b4 <Web_name_access_error>:
    32b4:	db 33 00 00 00 00 00 00 1a 01 c1 32 00              .3.........2.

000032c1 <name_access_error_page>:
    32c1:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    32d1:	3c 54 49 54 4c 45 3e ce f8 e8 e1 ea e0 20 e4 ee     <TITLE>...... ..
    32e1:	f1 f2 f3 ef e0 3c 2f 54 49 54 4c 45 3e 0d 0a 3c     .....</TITLE>..<
    32f1:	6d 65 74 61 20 68 74 74 70 2d 65 71 75 69 76 3d     meta http-equiv=
    3301:	22 43 6f 6e 74 65 6e 74 2d 54 79 70 65 22 20 63     "Content-Type" c
    3311:	6f 6e 74 65 6e 74 3d 22 74 65 78 74 2f 68 74 6d     ontent="text/htm
    3321:	6c 3b 20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f     l; charset=windo
    3331:	77 73 2d 31 32 35 31 22 3e 0d 0a 3c 2f 48 45 41     ws-1251">..</HEA
    3341:	44 3e 0d 0a 3c 63 65 6e 74 65 72 3e 0d 0a 3c 68     D>..<center>..<h
    3351:	65 61 64 3e 0d 0a 3c 68 33 3e c2 e0 f8 20 f3 f0     ead>..<h3>... ..
    3361:	ee e2 e5 ed fc 20 e4 ee f1 f2 f3 ef e0 20 ed e5     ..... ....... ..
    3371:	20 ef ee e7 e2 ee eb ff e5 f2 20 ef f0 ee f1 ec      ......... .....
    3381:	e0 f2 f0 e8 e2 e0 f2 fc 20 fd f2 f3 20 f1 f2 f0     ........ ... ...
    3391:	e0 ed e8 f6 f3 3c 2f 68 33 3e 0d 0a 3c 61 20 68     .....</h3>..<a h
    33a1:	72 65 66 3d 22 69 6e 64 65 78 2e 68 74 6d 6c 22     ref="index.html"
    33b1:	3e cd e0 e7 e0 e4 20 ed e0 20 e3 eb e0 e2 ed f3     >..... .. ......
    33c1:	fe 20 f1 f2 f0 e0 ed e8 f6 f3 3c 2f 61 3e 0d 0a     . ........</a>..
    33d1:	3c 2f 68 74 6d 6c 3e 0d 0a 00                       </html>...

000033db <name_access_error>:
    33db:	61 63 63 65 73 73 5f 65 72 72 6f 72 2e 68 74 6d     access_error.htm
    33eb:	6c 00                                               l.

000033ed <Web_favicon>:
    33ed:	78 39 00 00 00 00 00 00 7e 05 fa 33 00              x9......~..3.

000033fa <favicon>:
    33fa:	00 00 01 00 01 00 10 10 00 00 01 00 08 00 68 05     ..............h.
    340a:	00 00 16 00 00 00 28 00 00 00 10 00 00 00 20 00     ......(....... .
    341a:	00 00 01 00 08 00 00 00 00 00 00 01 00 00 00 00     ................
    342a:	00 00 00 00 00 00 00 01 00 00 00 00 00 00 27 1f     ..............'.
    343a:	ed 00 a4 a1 f8 00 59 53 f1 00 75 70 f4 00 2d 25     ......YS..up..-%
    344a:	ee 00 c7 c5 fa 00 39 32 ef 00 f0 ef fe 00 8b 87     ......92........
    345a:	f5 00 a7 a4 f8 00 3c 35 ef 00 ff ff ff 00 c3 c1     ......<5........
    346a:	fa 00 33 2b ee 00 68 62 f3 00 f6 f5 fe 00 ad aa     ..3+..hb........
    347a:	f8 00 b9 b7 f9 00 2c 24 ee 00 29 21 ed 00 3b 34     ......,$..)!..;4
    348a:	ef 00 c2 c0 fa 00 25 1d ed 00 db da fc 00 32 2a     ......%.......2*
    349a:	ee 00 e8 e7 fd 00 93 8f f6 00 80 7b f5 00 2b 23     ...........{..+#
    34aa:	ee 00 e1 e0 fd 00 7c 78 f4 00 34 2d ee 00 a2 9f     ......|x..4-....
    34ba:	f7 00 d7 d6 fc 00 9b 98 f7 00 24 1c ed 00 b8 b5     ..........$.....
    34ca:	f9 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    3836:	00 00 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3846:	0b 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3856:	0a 0b 0b 23 23 23 23 1c 1e 09 01 0e 16 23 23 23     ...####......###
    3866:	18 0b 0b 23 23 23 0d 21 0b 0b 0b 0b 24 16 23 23     ...###.!....$.##
    3876:	18 0b 0b 23 23 23 20 0b 0b 0b 0b 0b 0b 03 23 23     ...### .......##
    3886:	18 0b 0b 23 23 16 07 0b 0b 0b 0b 0b 0b 0c 23 23     ...##.........##
    3896:	18 0b 0b 23 23 18 0b 0b 0b 0b 0b 0b 0b 1d 23 23     ...##.........##
    38a6:	18 0b 0b 23 23 04 0b 0b 0b 0b 0b 0b 0b 17 23 23     ...##.........##
    38b6:	18 0b 0b 23 23 23 19 0b 0b 0b 0b 0b 0b 11 23 23     ...###........##
    38c6:	18 0b 0b 23 23 23 10 0b 0b 0b 0b 0b 0b 1b 23 23     ...###........##
    38d6:	18 0b 0b 23 23 23 02 0b 0b 0b 0b 0b 0f 1f 23 23     ...###........##
    38e6:	18 0b 0b 23 23 23 23 15 0b 0b 0b 0b 1a 23 23 23     ...####......###
    38f6:	18 0b 0b 23 23 23 23 14 19 0b 0b 05 13 23 23 23     ...####......###
    3906:	18 0b 0b 23 23 23 23 23 06 22 08 12 23 23 23 23     ...#####."..####
    3916:	18 0b 0b 00 23 23 23 23 23 23 23 23 23 23 23 23     ....############
    3926:	0a 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b 0b     ................
    3936:	0b 0b 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00003978 <name_favicon>:
    3978:	66 61 76 69 63 6f 6e 2e 69 63 6f 00                 favicon.ico.

00003984 <Web_emeter>:
    3984:	4f 45 5b 43 1c 00 91 39 00 09 5b 3a 02              OE[C...9..[:.

00003991 <emeter_OField>:
    3991:	50 3a 40 3a 3b 3a 2b 3a 25 3a 15 3a 0e 3a fe 39     P:@:;:+:%:.:.:.9
    39a1:	f5 39 e5 39 bd 39 ad 39 dc 39 cc 39                 .9.9.9.9.9.9

000039ad <Web_CurrDataPeriod>:
    39ad:	08 08 00 3c 00 00 00 ff ff 00 00 00 00 00 00 00     ...<............

000039bd <var_CurrDataPeriod>:
    39bd:	43 75 72 72 44 61 74 61 50 65 72 69 6f 64 00        CurrDataPeriod.

000039cc <Web_AutoSend>:
    39cc:	01 0a 00 00 00 00 00 01 00 00 00 00 00 00 00 00     ................

000039dc <var_AutoSend>:
    39dc:	41 75 74 6f 53 65 6e 64 00                          AutoSend.

000039e5 <Web_EM_UART_StopBits>:
    39e5:	00 42 09 00 00 00 00 01 00 00 00 6c 4b 00 00 00     .B.........lK...

000039f5 <var_EM_UART_StopBits>:
    39f5:	53 74 6f 70 42 69 74 73 00                          StopBits.

000039fe <Web_EM_UART_Parity>:
    39fe:	00 0c 06 00 00 00 00 02 00 00 00 00 00 00 00 00     ................

00003a0e <var_EM_UART_Parity>:
    3a0e:	50 61 72 69 74 79 00                                Parity.

00003a15 <Web_EM_UART_BitQt>:
    3a15:	00 72 0a 00 00 00 00 03 00 00 00 00 00 00 00 00     .r..............

00003a25 <var_EM_UART_BitQt>:
    3a25:	42 69 74 51 74 00                                   BitQt.

00003a2b <Web_EM_UART_Rate>:
    3a2b:	00 6b 0a 00 00 00 00 08 00 00 00 00 00 00 00 00     .k..............

00003a3b <var_EM_UART_Rate>:
    3a3b:	52 61 74 65 00                                      Rate.

00003a40 <Web_EMeterType>:
    3a40:	01 29 00 00 00 00 00 04 00 00 00 98 4b 00 00 00     .)..........K...

00003a50 <var_EMeterType>:
    3a50:	45 4d 65 74 65 72 54 79 70 65 00                    EMeterType.

00003a5b <emeter_page>:
    3a5b:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    3a6b:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    3a7b:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    3a8b:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    3a9b:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    3aab:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    3abb:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    3acb:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    3adb:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    3aeb:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    3afb:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    3b0b:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    3b1b:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    3b2b:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    3b3b:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    3b4b:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    3b5b:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    3b6b:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    3b7b:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    3b8b:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    3b9b:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    3bab:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    3bbb:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    3bcb:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    3bdb:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    3beb:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    3bfb:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    3c0b:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    3c1b:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    3c2b:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    3c3b:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    3c4b:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    3c5b:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    3c6b:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    3c7b:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    3c8b:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    3c9b:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    3cab:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    3cbb:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    3ccb:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 2f 42     {{{{ ....*...</B
    3cdb:	52 3e 0d 0a 3c 68 33 3e d2 e8 ef 20 fd eb e5 ea     R>..<h3>... ....
    3ceb:	f2 f0 ee f1 f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33     ...........:</h3
    3cfb:	3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e 3d     >..<form action=
    3d0b:	27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54 27     '/' method='GET'
    3d1b:	3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45     >...<SELECT NAME
    3d2b:	3d 22 45 4d 65 74 65 72 54 79 70 65 22 3e 20 0d     ="EMeterType"> .
    3d3b:	0a 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    3d4b:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    3d5b:	3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20     <OPTION VALUE=1 
    3d6b:	7b 7b 7b 7b 7b 7b 7b 7b 3e 4c 61 6e 64 69 73 26     {{{{{{{{>Landis&
    3d7b:	47 79 72 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     Gyr..<OPTION VAL
    3d8b:	55 45 3d 32 20 7b 7b 7b 7b 7b 7b 7b 7b 3e dd cb     UE=2 {{{{{{{{>..
    3d9b:	c2 c8 cd 0d 0a 3c 4f 50 54 49 4f 4e 20 56 41 4c     .....<OPTION VAL
    3dab:	55 45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e cc e5     UE=3 {{{{{{{{>..
    3dbb:	f0 ea f3 f0 e8 e9 32 33 30 0d 0a 3c 4f 50 54 49     ......230..<OPTI
    3dcb:	4f 4e 20 56 41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b     ON VALUE=4 {{{{{
    3ddb:	7b 7b 7b 3e dd cb c2 c8 cd 20 ec ee e4 e5 ec 0d     {{{>..... ......
    3deb:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c     ..</SELECT> ...<
    3dfb:	69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62 6d     input type='subm
    3e0b:	69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d     it' value='OK'>.
    3e1b:	0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d     .</form>..</BR>.
    3e2b:	0a 0d 0a 3c 68 33 3e cf e0 f0 e0 ec e5 f2 f0 fb     ...<h3>.........
    3e3b:	20 52 53 32 33 32 2f 52 53 34 38 35 3a 3c 2f 68      RS232/RS485:</h
    3e4b:	33 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     3>..<form action
    3e5b:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    3e6b:	27 3e 0d 0a 0d 0a 09 d1 ea ee f0 ee f1 f2 fc 3a     '>.............:
    3e7b:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    3e8b:	22 52 61 74 65 22 3e 20 0d 0a 09 3c 4f 50 54 49     "Rate"> ...<OPTI
    3e9b:	4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b     ON VALUE=0 {{{{{
    3eab:	7b 7b 7b 3e 31 32 30 30 62 70 73 0d 0a 09 3c 4f     {{{>1200bps...<O
    3ebb:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b     PTION VALUE=1 {{
    3ecb:	7b 7b 7b 7b 7b 7b 3e 32 34 30 30 62 70 73 0d 0a     {{{{{{>2400bps..
    3edb:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 32     .<OPTION VALUE=2
    3eeb:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 34 38 30 30 62 70      {{{{{{{{>4800bp
    3efb:	73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55     s...<OPTION VALU
    3f0b:	45 3d 33 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 39 36 30     E=3 {{{{{{{{>960
    3f1b:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3f2b:	41 4c 55 45 3d 34 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=4 {{{{{{{{>
    3f3b:	31 34 34 30 30 62 70 73 0d 0a 09 3c 4f 50 54 49     14400bps...<OPTI
    3f4b:	4f 4e 20 56 41 4c 55 45 3d 35 20 7b 7b 7b 7b 7b     ON VALUE=5 {{{{{
    3f5b:	7b 7b 7b 3e 31 39 32 30 30 62 70 73 0d 0a 09 3c     {{{>19200bps...<
    3f6b:	4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 36 20 7b     OPTION VALUE=6 {
    3f7b:	7b 7b 7b 7b 7b 7b 7b 3e 32 38 38 30 30 62 70 73     {{{{{{{>28800bps
    3f8b:	0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45     ...<OPTION VALUE
    3f9b:	3d 37 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 33 38 34 30     =7 {{{{{{{{>3840
    3fab:	30 62 70 73 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     0bps...<OPTION V
    3fbb:	41 4c 55 45 3d 38 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=8 {{{{{{{{>
    3fcb:	35 37 36 30 30 62 70 73 0d 0a 09 3c 2f 53 45 4c     57600bps...</SEL
    3fdb:	45 43 54 3e 0d 0a 0d 0a 09 ca ee eb e8 f7 e5 f1     ECT>............
    3feb:	f2 e2 ee 20 e1 e8 f2 3a 0d 0a 09 3c 53 45 4c 45     ... ...:...<SELE
    3ffb:	43 54 20 4e 41 4d 45 3d 22 42 69 74 51 74 22 3e     CT NAME="BitQt">
    400b:	20 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55      ...<OPTION VALU
    401b:	45 3d 30 20 7b 7b 7b 7b 7b 7b 7b 7b 3e 35 0d 0a     E=0 {{{{{{{{>5..
    402b:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    403b:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e 36 0d 0a 09 3c 4f      {{{{{{{{>6...<O
    404b:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    405b:	7b 7b 7b 7b 7b 7b 3e 37 0d 0a 09 3c 4f 50 54 49     {{{{{{>7...<OPTI
    406b:	4f 4e 20 56 41 4c 55 45 3d 33 20 7b 7b 7b 7b 7b     ON VALUE=3 {{{{{
    407b:	7b 7b 7b 3e 38 0d 0a 09 3c 2f 53 45 4c 45 43 54     {{{>8...</SELECT
    408b:	3e 20 0d 0a 0d 0a 09 d7 b8 f2 ed ee f1 f2 fc 3a     > .............:
    409b:	0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d 45 3d     ...<SELECT NAME=
    40ab:	22 50 61 72 69 74 79 22 3e 20 0d 0a 09 3c 4f 50     "Parity"> ...<OP
    40bb:	54 49 4f 4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b     TION VALUE=0 {{{
    40cb:	7b 7b 7b 7b 7b 3e ed e5 f2 0d 0a 09 3c 4f 50 54     {{{{{>......<OPT
    40db:	49 4f 4e 20 56 41 4c 55 45 3d 31 20 7b 7b 7b 7b     ION VALUE=1 {{{{
    40eb:	7b 7b 7b 7b 3e f7 e5 f2 ed fb e9 0d 0a 09 3c 4f     {{{{>.........<O
    40fb:	50 54 49 4f 4e 20 56 41 4c 55 45 3d 32 20 7b 7b     PTION VALUE=2 {{
    410b:	7b 7b 7b 7b 7b 7b 3e ed e5 f7 b8 f2 ed fb e9 0d     {{{{{{>.........
    411b:	0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a 0d 0a     ..</SELECT> ....
    412b:	09 d1 f2 ee ef 2d e1 e8 f2 fb 3a 0d 0a 09 3c 53     .....-....:...<S
    413b:	45 4c 45 43 54 20 4e 41 4d 45 3d 22 53 74 6f 70     ELECT NAME="Stop
    414b:	42 69 74 73 22 3e 20 0d 0a 09 3c 4f 50 54 49 4f     Bits"> ...<OPTIO
    415b:	4e 20 56 41 4c 55 45 3d 30 20 7b 7b 7b 7b 7b 7b     N VALUE=0 {{{{{{
    416b:	7b 7b 3e 31 0d 0a 09 3c 4f 50 54 49 4f 4e 20 56     {{>1...<OPTION V
    417b:	41 4c 55 45 3d 31 20 7b 7b 7b 7b 7b 7b 7b 7b 3e     ALUE=1 {{{{{{{{>
    418b:	32 0d 0a 09 3c 2f 53 45 4c 45 43 54 3e 20 0d 0a     2...</SELECT> ..
    419b:	0d 0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27     ...<input type='
    41ab:	73 75 62 6d 69 74 27 20 76 61 6c 75 65 3d 27 4f     submit' value='O
    41bb:	4b 27 3e 0d 0a 3c 2f 66 6f 72 6d 3e 0d 0a 3c 2f     K'>..</form>..</
    41cb:	42 52 3e 0d 0a 3c 68 33 3e ce ef f0 ee f1 20 f1     BR>..<h3>..... .
    41db:	f7 b8 f2 f7 e8 ea e0 3a 3c 2f 68 33 3e 3c 2f 42     .......:</h3></B
    41eb:	52 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74 69 6f 6e     R>..<form action
    41fb:	3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27 47 45 54     ='/' method='GET
    420b:	27 3e 0d 0a 09 3c 53 45 4c 45 43 54 20 4e 41 4d     '>...<SELECT NAM
    421b:	45 3d 22 41 75 74 6f 53 65 6e 64 22 3e 20 0d 0a     E="AutoSend"> ..
    422b:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 30     .<OPTION VALUE=0
    423b:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e cd e5 f2 20 0d 0a      {{{{{{{{>... ..
    424b:	09 3c 4f 50 54 49 4f 4e 20 56 41 4c 55 45 3d 31     .<OPTION VALUE=1
    425b:	20 7b 7b 7b 7b 7b 7b 7b 7b 3e c4 e0 0d 0a 09 3c      {{{{{{{{>.....<
    426b:	2f 53 45 4c 45 43 54 3e 20 0d 0a 09 3c 69 6e 70     /SELECT> ...<inp
    427b:	75 74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27     ut type='submit'
    428b:	20 76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f      value='OK'>..</
    429b:	66 6f 72 6d 3e 0d 0a 3c 66 6f 72 6d 20 61 63 74     form>..<form act
    42ab:	69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64 3d 27     ion='/' method='
    42bb:	47 45 54 27 3e 0d 0a 20 cf e5 f0 e8 ee e4 3a 0d     GET'>.. ......:.
    42cb:	0a 09 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74     ..<input type='t
    42db:	65 78 74 27 20 6e 61 6d 65 3d 27 43 75 72 72 44     ext' name='CurrD
    42eb:	61 74 61 50 65 72 69 6f 64 27 20 73 69 7a 65 3d     ataPeriod' size=
    42fb:	27 35 27 20 76 61 6c 75 65 3d 27 7b 7b 7b 7b 7b     '5' value='{{{{{
    430b:	27 3e 0d 0a 09 f1 e5 ea 0d 0a 09 3c 69 6e 70 75     '>.........<inpu
    431b:	74 20 74 79 70 65 3d 27 73 75 62 6d 69 74 27 20     t type='submit' 
    432b:	76 61 6c 75 65 3d 27 4f 4b 27 3e 0d 0a 3c 2f 66     value='OK'>..</f
    433b:	6f 72 6d 3e 0d 0a 3c 2f 42 52 3e 0d 0a 3c 2f 42     orm>..</BR>..</B
    434b:	4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e 0d 0a 00     ODY>..</HTML>...

0000435b <emeter_IField>:
    435b:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    436b:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    437b:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    438b:	1e 29 00 2b 45 00 1e 29 00 21 45 00 1e 29 00 17     .).+E..).!E..)..
    439b:	45 00 1e 29 00 0d 45 00 1e 29 00 03 45 00 1d 6b     E..)..E..)..E..k
    43ab:	0a f1 44 00 1d 6b 0a df 44 00 1d 6b 0a cd 44 00     ..D..k..D..k..D.
    43bb:	1d 6b 0a bb 44 00 1d 6b 0a a9 44 00 1d 6b 0a 97     .k..D..k..D..k..
    43cb:	44 00 1d 6b 0a 85 44 00 1d 6b 0a 73 44 00 1d 6b     D..k..D..k.sD..k
    43db:	0a 61 44 00 1d 72 0a 59 44 00 1d 72 0a 51 44 00     .aD..r.YD..r.QD.
    43eb:	1d 72 0a 49 44 00 1d 72 0a 41 44 00 1d 0c 06 3b     .r.ID..r.AD....;
    43fb:	44 00 1d 0c 06 35 44 00 1d 0c 06 2f 44 00 1d 42     D....5D..../D..B
    440b:	09 2b 44 00 1d 42 09 27 44 00 1e 0a 00 39 45 00     .+D..B.'D....9E.
    441b:	1e 0a 00 35 45 00 08 08 00 00 00 00                 ...5E.......

00004427 <STB_2_List>:
    4427:	46 45 3d 45                                         FE=E

0000442b <STB_1_List>:
    442b:	3d 45 46 45                                         =EFE

0000442f <PAR_O_List>:
    442f:	46 45 46 45 3d 45                                   FEFE=E

00004435 <PAR_E_List>:
    4435:	46 45 3d 45 46 45                                   FE=EFE

0000443b <PAR_N_List>:
    443b:	3d 45 46 45 46 45                                   =EFEFE

00004441 <BIT8_List>:
    4441:	46 45 46 45 46 45 3d 45                             FEFEFE=E

00004449 <BIT7_List>:
    4449:	46 45 46 45 3d 45 46 45                             FEFE=EFE

00004451 <BIT6_List>:
    4451:	46 45 3d 45 46 45 46 45                             FE=EFEFE

00004459 <BIT5_List>:
    4459:	3d 45 46 45 46 45 46 45                             =EFEFEFE

00004461 <BR57600_List>:
    4461:	46 45 46 45 46 45 46 45 46 45 46 45 46 45 46 45     FEFEFEFEFEFEFEFE
    4471:	3d 45                                               =E

00004473 <BR34800_List>:
    4473:	46 45 46 45 46 45 46 45 46 45 46 45 46 45 3d 45     FEFEFEFEFEFEFE=E
    4483:	46 45                                               FE

00004485 <BR28800_List>:
    4485:	46 45 46 45 46 45 46 45 46 45 46 45 3d 45 46 45     FEFEFEFEFEFE=EFE
    4495:	46 45                                               FE

00004497 <BR19200_List>:
    4497:	46 45 46 45 46 45 46 45 46 45 3d 45 46 45 46 45     FEFEFEFEFE=EFEFE
    44a7:	46 45                                               FE

000044a9 <BR14400_List>:
    44a9:	46 45 46 45 46 45 46 45 3d 45 46 45 46 45 46 45     FEFEFEFE=EFEFEFE
    44b9:	46 45                                               FE

000044bb <BR9600_List>:
    44bb:	46 45 46 45 46 45 3d 45 46 45 46 45 46 45 46 45     FEFEFE=EFEFEFEFE
    44cb:	46 45                                               FE

000044cd <BR4800_List>:
    44cd:	46 45 46 45 3d 45 46 45 46 45 46 45 46 45 46 45     FEFE=EFEFEFEFEFE
    44dd:	46 45                                               FE

000044df <BR2400_List>:
    44df:	46 45 3d 45 46 45 46 45 46 45 46 45 46 45 46 45     FE=EFEFEFEFEFEFE
    44ef:	46 45                                               FE

000044f1 <BR1200_List>:
    44f1:	3d 45 46 45 46 45 46 45 46 45 46 45 46 45 46 45     =EFEFEFEFEFEFEFE
    4501:	46 45                                               FE

00004503 <ELVIN_MODEM_List>:
    4503:	46 45 46 45 46 45 46 45 3d 45                       FEFEFEFE=E

0000450d <MERCURY_230_List>:
    450d:	46 45 46 45 46 45 3d 45 46 45                       FEFEFE=EFE

00004517 <ELVIN_List>:
    4517:	46 45 46 45 3d 45 46 45 46 45                       FEFE=EFEFE

00004521 <LANDIS_GYR_ZMR110_List>:
    4521:	46 45 3d 45 46 45 46 45 46 45                       FE=EFEFEFE

0000452b <EM_NONE_List>:
    452b:	3d 45 46 45 46 45 46 45 46 45                       =EFEFEFEFE

00004535 <ON_List>:
    4535:	46 45 3d 45                                         FE=E

00004539 <OFF_List>:
    4539:	3d 45 46 45                                         =EFE

0000453d <Selected_Str>:
    453d:	73 65 6c 65 63 74 65 64 00                          selected.

00004546 <Space_Str>:
    4546:	20 20 20 20 20 20 20 20 00                                  .

0000454f <name_emeter>:
    454f:	65 6d 65 74 65 72 2e 68 74 6d 6c 00                 emeter.html.

0000455b <Web_index>:
    455b:	8e 48 52 48 00 00 00 00 ea 02 68 45 00              .HRH......hE.

00004568 <index_page>:
    4568:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    4578:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    4588:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    4598:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    45a8:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    45b8:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    45c8:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    45d8:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    45e8:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 3e     .</HEAD>..<BODY>
    45f8:	0d 0a 0d 0a 3c 48 32 3e 45 4d 52 65 61 64 65 72     ....<H2>EMReader
    4608:	2e 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     . {{{{{{{{{{{{{{
    4618:	7b 7b 7b 7b 7b 7b 3c 2f 48 32 3e 0d 0a 49 44 3a     {{{{{{</H2>..ID:
    4628:	20 7b 7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 20      {{{{ {{{{{{{{{ 
    4638:	09 53 57 3a 20 33 2e 30 37 3c 2f 42 52 3e 0d 0a     .SW: 3.07</BR>..
    4648:	3c 48 52 3e 0d 0a 3c 61 20 68 72 65 66 3d 22 69     <HR>..<a href="i
    4658:	6e 64 65 78 2e 68 74 6d 6c 22 3e c3 eb e0 e2 ed     ndex.html">.....
    4668:	e0 ff 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68 72     ..</a> | ..<a hr
    4678:	65 66 3d 22 65 6d 65 74 65 72 2e 68 74 6d 6c 22     ef="emeter.html"
    4688:	3e cd e0 f1 f2 f0 ee e9 ea e8 20 f1 f7 e5 f2 f7     >......... .....
    4698:	e8 ea e0 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20 68     ...</a> | ..<a h
    46a8:	72 65 66 3d 22 6e 65 74 77 6f 72 6b 2e 68 74 6d     ref="network.htm
    46b8:	6c 22 3e d1 e5 f2 e5 e2 fb e5 20 ed e0 f1 f2 f0     l">....... .....
    46c8:	ee e9 ea e8 3c 2f 61 3e 20 7c 20 0d 0a 3c 61 20     ....</a> | ..<a 
    46d8:	68 72 65 66 3d 22 67 73 6d 2e 68 74 6d 6c 22 3e     href="gsm.html">
    46e8:	47 53 4d 2f 47 50 52 53 3c 2f 61 3e 20 7c 20 0d     GSM/GPRS</a> | .
    46f8:	0a 3c 61 20 68 72 65 66 3d 22 63 73 64 2e 68 74     .<a href="csd.ht
    4708:	6d 6c 22 3e 43 53 44 3c 2f 61 3e 20 7c 20 0d 0a     ml">CSD</a> | ..
    4718:	3c 61 20 68 72 65 66 3d 22 73 79 73 74 65 6d 2e     <a href="system.
    4728:	68 74 6d 6c 22 3e d1 e8 f1 f2 e5 ec e0 3c 2f 61     html">.......</a
    4738:	3e 20 7c 20 0d 0a 3c 61 20 68 72 65 66 3d 22 6c     > | ..<a href="l
    4748:	6f 67 6f 75 74 2e 68 74 6d 6c 22 3e c2 fb f5 ee     ogout.html">....
    4758:	e4 3c 2f 61 3e 0d 0a 3c 48 52 3e 0d 0a 3c 68 33     .</a>..<HR>..<h3
    4768:	3e d1 f7 b8 f2 f7 e8 ea e8 20 fd eb e5 ea f2 f0     >........ ......
    4778:	ee fd ed e5 f0 e3 e8 e8 3a 3c 2f 68 33 3e 0d 0a     ........:</h3>..
    4788:	41 2b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea     A+ {{{{{{{{{{{ .
    4798:	c2 f2 2a f7 20 7c 20 41 2d 20 7b 7b 7b 7b 7b 7b     ..*. | A- {{{{{{
    47a8:	7b 7b 7b 7b 7b 20 ea c2 f2 2a f7 20 7c 20 52 2b     {{{{{ ...*. | R+
    47b8:	20 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 ea c2 c0      {{{{{{{{{{{ ...
    47c8:	f0 2a f7 20 7c 20 52 2d 20 7b 7b 7b 7b 7b 7b 7b     .*. | R- {{{{{{{
    47d8:	7b 7b 7b 7b 20 ea c2 c0 f0 2a f7 0d 0a 3c 68 33     {{{{ ....*...<h3
    47e8:	3e d3 f0 ee e2 e5 ed fc 20 f1 e8 e3 ed e0 eb e0     >....... .......
    47f8:	3a 3c 2f 68 33 3e 0d 0a 20 7b 7b 20 28 30 2d 33     :</h3>.. {{ (0-3
    4808:	31 29 3c 2f 42 52 3e 0d 0a 3c 68 33 3e cd e0 f0     1)</BR>..<h3>...
    4818:	e0 e1 ee f2 ea e0 20 3a 3c 2f 68 33 3e 0d 0a 7b     ...... :</h3>..{
    4828:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 20 f1 e5 ea 0d 0a     {{{{{{{{{{ .....
    4838:	3c 2f 42 52 3e 0d 0a 3c 2f 42 4f 44 59 3e 0d 0a     </BR>..</BODY>..
    4848:	3c 2f 48 54 4d 4c 3e 0d 0a 00                       </HTML>...

00004852 <index_IField>:
    4852:	22 0f 00 00 00 15 22 0f 00 00 00 15 07 27 0b 00     "....."......'..
    4862:	00 00 14 12 06 00 00 00 10 46 02 00 00 03 10 4a     .........F.....J
    4872:	02 00 00 03 10 4e 02 00 00 03 10 52 02 00 00 03     .....N.....R....
    4882:	00 25 06 00 00 00 10 63 09 00 00 02                 .%.....c....

0000488e <name_index>:
    488e:	69 6e 64 65 78 2e 68 74 6d 6c 00                    index.html.

00004899 <Web_login>:
    4899:	a8 4b c0 4a 08 00 a6 48 e3 01 dd 48 00              .K.J...H...H.

000048a6 <vars_loginOField>:
    48a6:	d7 48 c7 48 be 48 ae 48                             .H.H.H.H

000048ae <Web_PasswOF>:
    48ae:	21 f4 05 00 00 00 00 02 00 00 00 05 29 00 00 0b     !...........)...

000048be <vars_Passw>:
    48be:	70 61 73 73 77 6f 72 64 00                          password.

000048c7 <Web_LoginOF>:
    48c7:	21 f7 09 00 00 00 00 02 00 00 00 00 00 00 00 10     !...............

000048d7 <vars_Login>:
    48d7:	6c 6f 67 69 6e 00                                   login.

000048dd <login_page>:
    48dd:	3c 48 54 4d 4c 3e 0d 0a 3c 48 45 41 44 3e 0d 0a     <HTML>..<HEAD>..
    48ed:	3c 54 49 54 4c 45 3e 7b 7b 7b 7b 7b 7b 7b 7b 7b     <TITLE>{{{{{{{{{
    48fd:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 54 49 54     {{{{{{{{{{{</TIT
    490d:	4c 45 3e 0d 0a 3c 6d 65 74 61 20 68 74 74 70 2d     LE>..<meta http-
    491d:	65 71 75 69 76 3d 22 43 6f 6e 74 65 6e 74 2d 54     equiv="Content-T
    492d:	79 70 65 22 20 63 6f 6e 74 65 6e 74 3d 22 74 65     ype" content="te
    493d:	78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73 65 74     xt/html; charset
    494d:	3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 22 3e 0d     =windows-1251">.
    495d:	0a 3c 2f 48 45 41 44 3e 0d 0a 3c 42 4f 44 59 20     .</HEAD>..<BODY 
    496d:	41 4c 49 47 4e 3d 43 45 4e 54 45 52 3e 0d 0a 7b     ALIGN=CENTER>..{
    497d:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    498d:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    499d:	7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b 7b     {{{{{{{{{{{{{{{{
    49ad:	3c 2f 42 52 3e 3c 2f 42 52 3e 0d 0a 49 44 20 7b     </BR></BR>..ID {
    49bd:	7b 7b 7b 20 7b 7b 7b 7b 7b 7b 7b 7b 7b 3c 2f 42     {{{ {{{{{{{{{</B
    49cd:	52 3e 3c 2f 42 52 3e 0d 0a 3c 46 4f 52 4d 20 61     R></BR>..<FORM a
    49dd:	63 74 69 6f 6e 3d 27 2f 27 20 6d 65 74 68 6f 64     ction='/' method
    49ed:	3d 27 50 4f 53 54 27 3e 0d 0a 09 4c 6f 67 69 6e     ='POST'>...Login
    49fd:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 74 65      <input type='te
    4a0d:	78 74 27 20 6e 61 6d 65 3d 27 6c 6f 67 69 6e 27     xt' name='login'
    4a1d:	20 73 69 7a 65 3d 27 31 35 27 3e 3c 2f 42 52 3e      size='15'></BR>
    4a2d:	3c 2f 42 52 3e 0d 0a 09 50 61 73 73 77 6f 72 64     </BR>...Password
    4a3d:	20 3c 69 6e 70 75 74 20 74 79 70 65 3d 27 70 61      <input type='pa
    4a4d:	73 73 77 6f 72 64 27 20 6e 61 6d 65 3d 27 70 61     ssword' name='pa
    4a5d:	73 73 77 6f 72 64 27 20 73 69 7a 65 3d 27 31 30     ssword' size='10
    4a6d:	27 3e 3c 2f 42 52 3e 3c 2f 42 52 3e 09 0d 0a 09     '></BR></BR>....
    4a7d:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 73 75 62     <input type='sub
    4a8d:	6d 69 74 27 20 76 61 6c 75 65 3d 27 4f 4b 27 3e     mit' value='OK'>
    4a9d:	3c 2f 42 52 3e 0d 0a 3c 2f 46 4f 52 4d 3e 0d 0a     </BR>..</FORM>..
    4aad:	3c 2f 42 4f 44 59 3e 0d 0a 3c 2f 48 54 4d 4c 3e     </BODY>..</HTML>
    4abd:	0d 0a 00                                            ...

00004ac0 <login_InField>:
    4ac0:	22 0f 00 00 00 15 1d 09 06 d8 4a 00 07 27 0b 00     ".........J..'..
    4ad0:	00 00 14 12 06 00 00 00                             ........

00004ad8 <Web_LoginMsg_List>:
    4ad8:	76 4b 44 4b 12 4b e0 4a                             vKDK.K.J

00004ae0 <Login_PSW_Str>:
    4ae0:	50 61 73 73 77 6f 72 64 20 69 73 20 6e 6f 74 20     Password is not 
    4af0:	76 61 6c 69 64 21 20 20 20 20 20 20 20 20 20 20     valid!          
    4b00:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b10:	20 00                                                .

00004b12 <Login_Login_Str>:
    4b12:	4c 6f 67 69 6e 20 69 73 20 6e 6f 74 20 76 61 6c     Login is not val
    4b22:	69 64 21 20 20 20 20 20 20 20 20 20 20 20 20 20     id!             
    4b32:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
    4b42:	20 00                                                .

00004b44 <Login_Busy_Str>:
    4b44:	45 4d 52 65 61 64 65 72 20 69 73 20 62 75 73 79     EMReader is busy
    4b54:	20 6e 6f 77 2e 20 41 6e 6f 74 68 65 72 20 75 73      now. Another us
    4b64:	65 72 20 73 74 61 72 74 20 73 65 73 73 69 6f 6e     er start session
    4b74:	2e 00                                               ..

00004b76 <Login_Welcome_Str>:
    4b76:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 4d 52 65 61     Welcome to EMRea
    4b86:	64 65 72 21 20 50 6c 65 61 73 65 20 6c 6f 67 20     der! Please log 
    4b96:	69 6e 21 20 20 20 20 20 20 20 20 20 20 20 20 20     in!             
    4ba6:	20 00                                                .

00004ba8 <name_login>:
    4ba8:	6c 6f 67 69 6e 2e 68 74 6d 6c 00                    login.html.

00004bb3 <METHOD_POST>:
    4bb3:	50 4f 53 54 20 2f 00                                POST /.

00004bba <METHOD_GET>:
    4bba:	47 45 54 20 2f 00                                   GET /.

00004bc0 <Web_error_page>:
	...
    4bc8:	75 00 cd 4b 00                                      u..K.

00004bcd <error_page>:
    4bcd:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
    4bdd:	20 46 6f 75 6e 64 0d 0a 43 6f 6e 74 65 6e 74 2d      Found..Content-
    4bed:	54 79 70 65 3a 20 74 65 78 74 2f 68 74 6d 6c 3b     Type: text/html;
    4bfd:	20 63 68 61 72 73 65 74 3d 77 69 6e 64 6f 77 73      charset=windows
    4c0d:	2d 31 32 35 31 0d 0a 43 6f 6e 6e 65 63 74 69 6f     -1251..Connectio
    4c1d:	6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a 3c 68 31 3e     n: close....<h1>
    4c2d:	34 30 34 20 2d 20 4e 6f 74 20 46 6f 75 6e 64 3c     404 - Not Found<
    4c3d:	2f 68 31 3e 00                                      /h1>.

00004c42 <SESSID_pstr>:
    4c42:	3f 53 45 53 53 49 44 3d 00                          ?SESSID=.

00004c4b <inputSESSID_Str>:
    4c4b:	3c 69 6e 70 75 74 20 74 79 70 65 3d 27 68 69 64     <input type='hid
    4c5b:	64 65 6e 27 20 6e 61 6d 65 3d 27 53 45 53 53 49     den' name='SESSI
    4c6b:	44 27 20 76 61 6c 75 65 3d 27 00                    D' value='.

00004c76 <Connection_Close>:
    4c76:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
    4c86:	65 0d 0a 0d 0a 00                                   e.....

00004c8c <jpeg_str>:
    4c8c:	6a 70 65 67 00                                      jpeg.

00004c91 <gif_str>:
    4c91:	67 69 66 00                                         gif.

00004c95 <ico_str>:
    4c95:	69 63 6f 00                                         ico.

00004c99 <html_str>:
    4c99:	68 74 6d 6c 00                                      html.

00004c9e <image_str>:
    4c9e:	69 6d 61 67 65 2f 00                                image/.

00004ca5 <html_cp1251_str>:
    4ca5:	74 65 78 74 2f 68 74 6d 6c 3b 20 63 68 61 72 73     text/html; chars
    4cb5:	65 74 3d 77 69 6e 64 6f 77 73 2d 31 32 35 31 0d     et=windows-1251.
    4cc5:	0a 00                                               ..

00004cc7 <Content_Length>:
    4cc7:	0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68     ..Content-Length
    4cd7:	3a 20 00                                            : .

00004cda <Content_Type>:
    4cda:	43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 00        Content-Type: .

00004ce9 <HTTP_200_OK>:
    4ce9:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
    4cf9:	0a 00                                               ..

00004cfb <MsgErr41>:
    4cfb:	29                                                  )

00004cfc <TestMsg_str>:
    4cfc:	f2 e5 f1 f2 ee e2 ee e5 20 f1 ee ee e1 f9 e5 ed     ........ .......
    4d0c:	e8 e5 00                                            ...

00004d0f <MB_Master_List>:
    4d0f:	00 00 00                                            ...

00004d12 <DO_M>:
    4d12:	61 00 62 00 02 61 00 62 00 01 61 00 62 00 04        a.b..a.b..a.b..

00004d21 <DI_M>:
    4d21:	34 00 35 00 33 00 02 01 34 00 35 00 33 00 01 01     4.5.3...4.5.3...
    4d31:	3a 00 3b 00 39 00 01 00 3a 00 3b 00 39 00 02 00     :.;.9...:.;.9...

00004d41 <AT_ATH>:
    4d41:	41 54 48 00                                         ATH.

00004d45 <AT_ATA>:
    4d45:	41 54 41 00                                         ATA.

00004d49 <AT_CSQ>:
    4d49:	41 54 2b 43 53 51 00                                AT+CSQ.

00004d50 <AT_CGATT_0>:
    4d50:	41 54 2b 43 47 41 54 54 3d 30 00                    AT+CGATT=0.

00004d5b <AT_CIPSHUT>:
    4d5b:	41 54 2b 43 49 50 53 48 55 54 00                    AT+CIPSHUT.

00004d66 <AT_CIPCLOSE>:
    4d66:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 31 00           AT+CIPCLOSE=1.

00004d74 <AT_CIPCLOSE_1>:
    4d74:	41 54 2b 43 49 50 43 4c 4f 53 45 3d 78 2c 31 00     AT+CIPCLOSE=x,1.

00004d84 <AT_CIPSEND>:
    4d84:	41 54 2b 43 49 50 53 45 4e 44 3d 00                 AT+CIPSEND=.

00004d90 <AT_ATO>:
    4d90:	41 54 4f 00                                         ATO.

00004d94 <AT_CIPSTATUS>:
    4d94:	41 54 2b 43 49 50 53 54 41 54 55 53 00              AT+CIPSTATUS.

00004da1 <AT_SERVERCLOSE>:
    4da1:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 30 00        AT+CIPSERVER=0.

00004db0 <AT_CIPSERVER>:
    4db0:	41 54 2b 43 49 50 53 45 52 56 45 52 3d 31 2c 00     AT+CIPSERVER=1,.

00004dc0 <AT_CIPSTART_TCP>:
    4dc0:	41 54 2b 43 49 50 53 54 41 52 54 3d 22 54 43 50     AT+CIPSTART="TCP
    4dd0:	22 2c 00                                            ",.

00004dd3 <AT_CIPSTART>:
    4dd3:	41 54 2b 43 49 50 53 54 41 52 54 3d 30 2c 22 55     AT+CIPSTART=0,"U
    4de3:	44 50 22 2c 00                                      DP",.

00004de8 <AT_CIFSR>:
    4de8:	41 54 2b 43 49 46 53 52 00                          AT+CIFSR.

00004df1 <AT_CIICR>:
    4df1:	41 54 2b 43 49 49 43 52 00                          AT+CIICR.

00004dfa <AT_CSTT>:
    4dfa:	41 54 2b 43 53 54 54 00                             AT+CSTT.

00004e02 <AT_CIPCSGP>:
    4e02:	41 54 2b 43 49 50 43 53 47 50 3d 31 2c 22 00        AT+CIPCSGP=1,".

00004e11 <AT_CGATT>:
    4e11:	41 54 2b 43 47 41 54 54 3d 31 00                    AT+CGATT=1.

00004e1c <AT_CIPTKA>:
    4e1c:	41 54 2b 43 49 50 54 4b 41 3d 31 2c 33 30 2c 33     AT+CIPTKA=1,30,3
    4e2c:	30 2c 31 00                                         0,1.

00004e30 <AT_CIPMUX_0>:
    4e30:	41 54 2b 43 49 50 4d 55 58 3d 30 00                 AT+CIPMUX=0.

00004e3c <AT_CIPMODE_1>:
    4e3c:	41 54 2b 43 49 50 4d 4f 44 45 3d 31 00              AT+CIPMODE=1.

00004e49 <AT_CMGS>:
    4e49:	41 54 2b 43 4d 47 53 3d 22 2b 00                    AT+CMGS="+.

00004e54 <AT_CSMP>:
    4e54:	41 54 2b 43 53 4d 50 3d 31 37 2c 31 36 37 2c 30     AT+CSMP=17,167,0
    4e64:	2c 30 00                                            ,0.

00004e67 <AT_CMGF>:
    4e67:	41 54 2b 43 4d 47 46 3d 31 00                       AT+CMGF=1.

00004e71 <AT_CCID>:
    4e71:	41 54 2b 43 43 49 44 00                             AT+CCID.

00004e79 <AT_CLIP>:
    4e79:	41 54 2b 43 4c 49 50 3d 31 00                       AT+CLIP=1.

00004e83 <AT_CGMM>:
    4e83:	41 54 2b 43 47 4d 4d 00                             AT+CGMM.

00004e8b <AT_E0>:
    4e8b:	41 54 45 30 00                                      ATE0.

00004e90 <AT_W>:
    4e90:	41 54 26 57 00                                      AT&W.

00004e95 <AT_IPR9600>:
    4e95:	41 54 2b 49 50 52 3d 39 36 30 30 00                 AT+IPR=9600.

00004ea1 <AT_AT>:
    4ea1:	41 54 00                                            AT.

00004ea4 <ESC_SEQ>:
    4ea4:	2b 2b 2b 00                                         +++.

00004ea8 <RESP_STATE_CONNECT_OK>:
    4ea8:	53 54 41 54 45 3a 20 43 4f 4e 4e 45 43 54 20 4f     STATE: CONNECT O
    4eb8:	4b 00                                               K.

00004eba <RESP_CONNECT_9600>:
    4eba:	43 4f 4e 4e 45 43 54 20 39 36 30 30 00              CONNECT 9600.

00004ec7 <RESP_SHUT_OK>:
    4ec7:	53 48 55 54 20 4f 4b 00                             SHUT OK.

00004ecf <RESP_CSQ>:
    4ecf:	2b 43 53 51 3a 00                                   +CSQ:.

00004ed5 <RESP_CLOSE_OK_FAST>:
    4ed5:	78 2c 20 43 4c 4f 53 45 20 4f 4b 00                 x, CLOSE OK.

00004ee1 <RESP_CLOSE_OK>:
    4ee1:	43 4c 4f 53 45 20 4f 4b 00                          CLOSE OK.

00004eea <RESP_SEND_OK>:
    4eea:	78 2c 20 53 45 4e 44 20 4f 4b 00                    x, SEND OK.

00004ef5 <RESP_SERVER_CLOSE>:
    4ef5:	53 45 52 56 45 52 20 43 4c 4f 53 45 00              SERVER CLOSE.

00004f02 <RESP_SERVER_OK>:
    4f02:	53 45 52 56 45 52 20 4f 4b 00                       SERVER OK.

00004f0c <RESP_CONNECT_OK>:
    4f0c:	78 2c 20 43 4f 4e 4e 45 43 54 20 4f 4b 00           x, CONNECT OK.

00004f1a <RESP_CONNECT>:
    4f1a:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f22 <RESP_OK>:
    4f22:	4f 4b 00                                            OK.

00004f25 <URC_NO_CARRIER>:
    4f25:	4e 4f 20 43 41 52 52 49 45 52 00                    NO CARRIER.

00004f30 <URC_RING>:
    4f30:	52 49 4e 47 00                                      RING.

00004f35 <URC_PDPDEACT>:
    4f35:	2b 50 44 50 20 44 45 41 43 54 00                    +PDP DEACT.

00004f40 <URC_CLOSED>:
    4f40:	2c 20 43 4c 4f 53 45 44 00                          , CLOSED.

00004f49 <URC_RECEIVE>:
    4f49:	2b 52 45 43 45 49 56 45 2c 00                       +RECEIVE,.

00004f53 <URC_CONNECT>:
    4f53:	43 4f 4e 4e 45 43 54 00                             CONNECT.

00004f5b <URC_REMOTE_IP>:
    4f5b:	52 45 4d 4f 54 45 20 49 50 00                       REMOTE IP.

00004f65 <URC_SMS_READY>:
    4f65:	53 4d 53 20 52 65 61 64 79 00                       SMS Ready.

00004f6f <URC_CALL_READY>:
    4f6f:	43 61 6c 6c 20 52 65 61 64 79 00                    Call Ready.

00004f7a <URC_RDY>:
    4f7a:	52 44 59 00                                         RDY.

00004f7e <GSM_SIMCOM_SIM800>:
    4f7e:	53 49 4d 43 4f 4d 5f 53 49 4d 38 30 30 00           SIMCOM_SIM800.

00004f8c <GSM_SIMCOM_SIM900R>:
    4f8c:	53 49 4d 43 4f 4d 5f 53 49 4d 39 30 30 52 00        SIMCOM_SIM900R.

00004f9b <MB_Timer>:
    4f9b:	52 00 51 00 30 28 44 00 43 00 36 28                 R.Q.0(D.C.6(

00004fa7 <MB_Port>:
    4fa7:	9c 00 9b 00 9a 00 9d 00 98 00 99 00 28 28 2d 28     ............((-(
    4fb7:	2e 28 2f 28                                         .(/(

00004fbb <BR_Tbl>:
    4fbb:	42 03 ff a0 01 fb cf 00 7d 67 00 3f 44 00 2a 33     B.......}g.?D.*3
    4fcb:	00 1f 22 00 1b 19 00 1b 10 00 1b                    .."........

00004fd6 <Modbus_Map>:
    4fd6:	df 03 08 00 f6 03 08 00 7c 08 2c 00 78 0a 1e 00     ........|.,.x...

00004fe6 <MB_Role>:
	...

00004fe7 <__c.2299>:
    4fe7:	63 64 69 6e 6f 70 73 75 78 58 5b 00 00              cdinopsuxX[..

00004ff4 <__ctors_end>:
    4ff4:	11 24       	eor	r1, r1
    4ff6:	1f be       	out	0x3f, r1	; 63
    4ff8:	cf ef       	ldi	r28, 0xFF	; 255
    4ffa:	d0 e1       	ldi	r29, 0x10	; 16
    4ffc:	de bf       	out	0x3e, r29	; 62
    4ffe:	cd bf       	out	0x3d, r28	; 61

00005000 <__do_copy_data>:
    5000:	12 e0       	ldi	r17, 0x02	; 2
    5002:	a0 e0       	ldi	r26, 0x00	; 0
    5004:	b1 e0       	ldi	r27, 0x01	; 1
    5006:	e6 e7       	ldi	r30, 0x76	; 118
    5008:	fc ee       	ldi	r31, 0xEC	; 236
    500a:	00 e0       	ldi	r16, 0x00	; 0
    500c:	0b bf       	out	0x3b, r16	; 59
    500e:	02 c0       	rjmp	.+4      	; 0x5014 <__do_copy_data+0x14>
    5010:	07 90       	elpm	r0, Z+
    5012:	0d 92       	st	X+, r0
    5014:	aa 33       	cpi	r26, 0x3A	; 58
    5016:	b1 07       	cpc	r27, r17
    5018:	d9 f7       	brne	.-10     	; 0x5010 <__do_copy_data+0x10>

0000501a <__do_clear_bss>:
    501a:	2e e0       	ldi	r18, 0x0E	; 14
    501c:	aa e3       	ldi	r26, 0x3A	; 58
    501e:	b2 e0       	ldi	r27, 0x02	; 2
    5020:	01 c0       	rjmp	.+2      	; 0x5024 <.do_clear_bss_start>

00005022 <.do_clear_bss_loop>:
    5022:	1d 92       	st	X+, r1

00005024 <.do_clear_bss_start>:
    5024:	ac 34       	cpi	r26, 0x4C	; 76
    5026:	b2 07       	cpc	r27, r18
    5028:	e1 f7       	brne	.-8      	; 0x5022 <.do_clear_bss_loop>
    502a:	0e 94 c8 6b 	call	0xd790	; 0xd790 <main>
    502e:	0c 94 51 6c 	jmp	0xd8a2	; 0xd8a2 <exit>

00005032 <__bad_interrupt>:
    5032:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00005036 <rrb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
rrb(const uint8_t *addr)
{
	return *addr;
}
    5036:	fc 01       	movw	r30, r24
    5038:	80 81       	ld	r24, Z
    503a:	08 95       	ret

0000503c <prb>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    503c:	fc 01       	movw	r30, r24
    503e:	84 91       	lpm	r24, Z
}
    5040:	08 95       	ret

00005042 <prb_f>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#if FLASHEND>0xFFFF
uint8_t
prb_f(const prog_uint8_t *addr)
{
	return pgm_read_byte_far((uint16_t)addr+0x10000);
    5042:	a0 e0       	ldi	r26, 0x00	; 0
    5044:	b0 e0       	ldi	r27, 0x00	; 0
    5046:	11 96       	adiw	r26, 0x01	; 1
}
    5048:	ab bf       	out	0x3b, r26	; 59
    504a:	fc 01       	movw	r30, r24
    504c:	87 91       	elpm	r24, Z+
    504e:	08 95       	ret

00005050 <RS485_1>:
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
}

void RS485_0(void) {}
void RS485_1(void) {PORTD ^=(1<<PD4);}
    5050:	82 b3       	in	r24, 0x12	; 18
    5052:	90 e1       	ldi	r25, 0x10	; 16
    5054:	89 27       	eor	r24, r25
    5056:	82 bb       	out	0x12, r24	; 18
    5058:	08 95       	ret

0000505a <MB_LED1>:

void MB_LED0(void) {}
void MB_LED1(void) {}
    505a:	08 95       	ret

0000505c <MB_LED_Err_On_1>:

void MB_LED_Err_On_0(void)	{}
void MB_LED_Err_Off_0(void)	{}
void MB_LED_Err_On_1(void)	{}
    505c:	08 95       	ret

0000505e <MB_LED_Err_Off_1>:
void MB_LED_Err_Off_1(void)	{}
    505e:	08 95       	ret

00005060 <StartTimer0>:
StartTimer0(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR0  = ((((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#elif defined (__AVR_ATmega128__)
		TCCR0  =   ((1<<WGM01) &~(1<<WGM00)  &~(1<<COM01)  &~(1<<COM00)) |(1<<CS02)   |(1<<CS01)  |(1<<CS00);
    5060:	8f e0       	ldi	r24, 0x0F	; 15
    5062:	83 bf       	out	0x33, r24	; 51
	#elif defined (__AVR_ATmega1280__)  || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR0A =    (1<<WGM01) &~(1<<WGM00)  &~(1<<COM0A1) &~(1<<COM0A0) &~(1<<COM0B1) &~(1<<COM0B0);
		TCCR0B = ((~(1<<WGM02)                                           |(1<<CS02)) &~(1<<CS01)) |(1<<CS00);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE0);
    5064:	87 b7       	in	r24, 0x37	; 55
    5066:	82 60       	ori	r24, 0x02	; 2
    5068:	87 bf       	out	0x37, r24	; 55
    506a:	08 95       	ret

0000506c <StartTimer2>:
StartTimer2(void)
{
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
		TCCR2  =   ((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#elif defined (__AVR_ATmega128__)
		TCCR2  = ((((1<<WGM21) &~(1<<WGM20)  &~(1<<COM21)  &~(1<<COM20)) |(1<<CS22)) &~(1<<CS21)) |(1<<CS20);
    506c:	8d e0       	ldi	r24, 0x0D	; 13
    506e:	85 bd       	out	0x25, r24	; 37
	#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR2A =    (1<<WGM21) &~(1<<WGM20)  &~(1<<COM2A1) &~(1<<COM2A0) &~(1<<COM2B1) &~(1<<COM2B0);
		TCCR2B =   ~(1<<WGM22)                                           |(1<<CS22)   |(1<<CS21)  |(1<<CS20);
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE2);
    5070:	87 b7       	in	r24, 0x37	; 55
    5072:	80 68       	ori	r24, 0x80	; 128
    5074:	87 bf       	out	0x37, r24	; 55
    5076:	08 95       	ret

00005078 <MB_Timer_ISR>:
	#if defined (__AVR_ATxmega128A1__)
		tc->INTCTRLA = (tc->INTCTRLA &~TC1_OVFINTLVL_gm) |TC_OVFINTLVL_OFF_gc;
		tc->CTRLA = TC_CLKSEL_OFF_gc;
	#endif
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Timer[MB_N]tc_f)!=tc; MB_N++);
    5078:	60 e0       	ldi	r22, 0x00	; 0
    507a:	76 e0       	ldi	r23, 0x06	; 6
    507c:	26 2f       	mov	r18, r22
    507e:	30 e0       	ldi	r19, 0x00	; 0
    5080:	72 9f       	mul	r23, r18
    5082:	f0 01       	movw	r30, r0
    5084:	73 9f       	mul	r23, r19
    5086:	f0 0d       	add	r31, r0
    5088:	11 24       	eor	r1, r1
    508a:	e5 56       	subi	r30, 0x65	; 101
    508c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    508e:	45 91       	lpm	r20, Z+
    5090:	54 91       	lpm	r21, Z
    5092:	e6 2f       	mov	r30, r22
    5094:	f0 e0       	ldi	r31, 0x00	; 0
    5096:	84 17       	cp	r24, r20
    5098:	95 07       	cpc	r25, r21
    509a:	11 f0       	breq	.+4      	; 0x50a0 <MB_Timer_ISR+0x28>
    509c:	6f 5f       	subi	r22, 0xFF	; 255
    509e:	ee cf       	rjmp	.-36     	; 0x507c <MB_Timer_ISR+0x4>

	
	switch (prb(MB_Role+MB_N)){
    50a0:	ea 51       	subi	r30, 0x1A	; 26
    50a2:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    50a4:	e4 91       	lpm	r30, Z
    50a6:	ee 23       	and	r30, r30
    50a8:	19 f0       	breq	.+6      	; 0x50b0 <MB_Timer_ISR+0x38>
    50aa:	e1 30       	cpi	r30, 0x01	; 1
    50ac:	f9 f0       	breq	.+62     	; 0x50ec <MB_Timer_ISR+0x74>
    50ae:	08 95       	ret
	case Role_Slave:
		if(MB_Frame[MB_N][0]==MB_NativeAddr[MB_N]){	// Slave     -   MB_TimerFlag
    50b0:	f2 2f       	mov	r31, r18
    50b2:	ee 27       	eor	r30, r30
    50b4:	e8 5b       	subi	r30, 0xB8	; 184
    50b6:	f2 4f       	sbci	r31, 0xF2	; 242
    50b8:	90 81       	ld	r25, Z
    50ba:	f9 01       	movw	r30, r18
    50bc:	e8 50       	subi	r30, 0x08	; 8
    50be:	fc 4f       	sbci	r31, 0xFC	; 252
    50c0:	80 81       	ld	r24, Z
    50c2:	98 17       	cp	r25, r24
    50c4:	99 f0       	breq	.+38     	; 0x50ec <MB_Timer_ISR+0x74>
			MB_TimerFlag |= (1<<MB_N);
		}
		else{
			MB_State[MB_N] = MB_Idle;
    50c6:	f9 01       	movw	r30, r18
    50c8:	ef 51       	subi	r30, 0x1F	; 31
    50ca:	fc 4f       	sbci	r31, 0xFC	; 252
    50cc:	81 e0       	ldi	r24, 0x01	; 1
    50ce:	80 83       	st	Z, r24
			MB_CPT[MB_N][0]++;
    50d0:	f9 01       	movw	r30, r18
    50d2:	84 e0       	ldi	r24, 0x04	; 4
    50d4:	ee 0f       	add	r30, r30
    50d6:	ff 1f       	adc	r31, r31
    50d8:	8a 95       	dec	r24
    50da:	e1 f7       	brne	.-8      	; 0x50d4 <MB_Timer_ISR+0x5c>
    50dc:	e7 5d       	subi	r30, 0xD7	; 215
    50de:	f4 4f       	sbci	r31, 0xF4	; 244
    50e0:	80 81       	ld	r24, Z
    50e2:	91 81       	ldd	r25, Z+1	; 0x01
    50e4:	01 96       	adiw	r24, 0x01	; 1
    50e6:	91 83       	std	Z+1, r25	; 0x01
    50e8:	80 83       	st	Z, r24
    50ea:	08 95       	ret
		}
		break;
	case Role_Master:
		MB_TimerFlag |= (1<<MB_N);
    50ec:	30 91 13 0b 	lds	r19, 0x0B13
    50f0:	81 e0       	ldi	r24, 0x01	; 1
    50f2:	90 e0       	ldi	r25, 0x00	; 0
    50f4:	02 2e       	mov	r0, r18
    50f6:	01 c0       	rjmp	.+2      	; 0x50fa <MB_Timer_ISR+0x82>
    50f8:	88 0f       	add	r24, r24
    50fa:	0a 94       	dec	r0
    50fc:	ea f7       	brpl	.-6      	; 0x50f8 <MB_Timer_ISR+0x80>
    50fe:	38 2b       	or	r19, r24
    5100:	30 93 13 0b 	sts	0x0B13, r19
    5104:	08 95       	ret

00005106 <MBRecept>:
		#endif
		MB_Err &=(1<<MB_N);
		return;
	}
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		Buf = USART_Reg(MB_N, ucsra);
    5106:	28 2f       	mov	r18, r24
    5108:	30 e0       	ldi	r19, 0x00	; 0
    510a:	94 e1       	ldi	r25, 0x14	; 20
    510c:	89 9f       	mul	r24, r25
    510e:	f0 01       	movw	r30, r0
    5110:	11 24       	eor	r1, r1
    5112:	e7 55       	subi	r30, 0x57	; 87
    5114:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5116:	a5 91       	lpm	r26, Z+
    5118:	b4 91       	lpm	r27, Z
    511a:	9c 91       	ld	r25, X
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = USART_Reg(MB_N, udr);
    511c:	f9 01       	movw	r30, r18
    511e:	e7 52       	subi	r30, 0x27	; 39
    5120:	f7 4f       	sbci	r31, 0xF7	; 247
    5122:	40 81       	ld	r20, Z
    5124:	51 e0       	ldi	r21, 0x01	; 1
    5126:	54 0f       	add	r21, r20
    5128:	50 83       	st	Z, r21
    512a:	54 e1       	ldi	r21, 0x14	; 20
    512c:	52 9f       	mul	r21, r18
    512e:	f0 01       	movw	r30, r0
    5130:	53 9f       	mul	r21, r19
    5132:	f0 0d       	add	r31, r0
    5134:	11 24       	eor	r1, r1
    5136:	e9 55       	subi	r30, 0x59	; 89
    5138:	f0 4b       	sbci	r31, 0xB0	; 176
    513a:	a5 91       	lpm	r26, Z+
    513c:	b4 91       	lpm	r27, Z
    513e:	5c 91       	ld	r21, X
    5140:	f2 2f       	mov	r31, r18
    5142:	ee 27       	eor	r30, r30
    5144:	e4 0f       	add	r30, r20
    5146:	f1 1d       	adc	r31, r1
    5148:	e8 5b       	subi	r30, 0xB8	; 184
    514a:	f2 4f       	sbci	r31, 0xF2	; 242
    514c:	50 83       	st	Z, r21
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		Buf = usart->STATUS;
		MB_Frame[MB_N][MB_Frame_Sz[MB_N]++] = usart->DATA;
	#endif
	if (Buf &(1<<3))
    514e:	93 ff       	sbrs	r25, 3
    5150:	0e c0       	rjmp	.+28     	; 0x516e <MBRecept+0x68>
		MB_CPT[MB_N][7]++;
    5152:	f9 01       	movw	r30, r18
    5154:	24 e0       	ldi	r18, 0x04	; 4
    5156:	ee 0f       	add	r30, r30
    5158:	ff 1f       	adc	r31, r31
    515a:	2a 95       	dec	r18
    515c:	e1 f7       	brne	.-8      	; 0x5156 <MBRecept+0x50>
    515e:	e7 5d       	subi	r30, 0xD7	; 215
    5160:	f4 4f       	sbci	r31, 0xF4	; 244
    5162:	26 85       	ldd	r18, Z+14	; 0x0e
    5164:	37 85       	ldd	r19, Z+15	; 0x0f
    5166:	2f 5f       	subi	r18, 0xFF	; 255
    5168:	3f 4f       	sbci	r19, 0xFF	; 255
    516a:	37 87       	std	Z+15, r19	; 0x0f
    516c:	26 87       	std	Z+14, r18	; 0x0e
	if (Buf &((1<<4) |(1<<3) |(1<<2)))
    516e:	9c 71       	andi	r25, 0x1C	; 28
    5170:	59 f0       	breq	.+22     	; 0x5188 <MBRecept+0x82>
		MB_Err |=(1<<MB_N);
    5172:	21 e0       	ldi	r18, 0x01	; 1
    5174:	30 e0       	ldi	r19, 0x00	; 0
    5176:	01 c0       	rjmp	.+2      	; 0x517a <MBRecept+0x74>
    5178:	22 0f       	add	r18, r18
    517a:	8a 95       	dec	r24
    517c:	ea f7       	brpl	.-6      	; 0x5178 <MBRecept+0x72>
    517e:	80 91 6b 02 	lds	r24, 0x026B
    5182:	82 2b       	or	r24, r18
    5184:	80 93 6b 02 	sts	0x026B, r24
    5188:	08 95       	ret

0000518a <GetSlave>:

// ~~~~~~~~~~~~~~~~~~~
static MB_Slave*
GetSlave(uint8_t MB_N)
{
	return (MB_Slave*)prp(&(MB_Master_List+MB_N)->SlaveList)+CurrSlave[MB_N];
    518a:	43 e0       	ldi	r20, 0x03	; 3
    518c:	84 9f       	mul	r24, r20
    518e:	f0 01       	movw	r30, r0
    5190:	11 24       	eor	r1, r1
    5192:	e1 5f       	subi	r30, 0xF1	; 241
    5194:	f2 4b       	sbci	r31, 0xB2	; 178
    5196:	25 91       	lpm	r18, Z+
    5198:	34 91       	lpm	r19, Z
    519a:	e8 2f       	mov	r30, r24
    519c:	f0 e0       	ldi	r31, 0x00	; 0
    519e:	ea 5f       	subi	r30, 0xFA	; 250
    51a0:	f9 4f       	sbci	r31, 0xF9	; 249
    51a2:	80 81       	ld	r24, Z
}
    51a4:	a9 01       	movw	r20, r18
    51a6:	64 e0       	ldi	r22, 0x04	; 4
    51a8:	86 9f       	mul	r24, r22
    51aa:	40 0d       	add	r20, r0
    51ac:	51 1d       	adc	r21, r1
    51ae:	11 24       	eor	r1, r1
    51b0:	ca 01       	movw	r24, r20
    51b2:	08 95       	ret

000051b4 <DI_Init_Hard>:
static T_DI_M DI_M[] PROGMEM = DI_Map_Own;

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
    51b4:	81 e2       	ldi	r24, 0x21	; 33
    51b6:	9d e4       	ldi	r25, 0x4D	; 77
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
		cli();
    51b8:	f8 94       	cli
    51ba:	fc 01       	movw	r30, r24
    51bc:	a5 91       	lpm	r26, Z+
    51be:	b4 91       	lpm	r27, Z
    51c0:	ac 01       	movw	r20, r24
    51c2:	4a 5f       	subi	r20, 0xFA	; 250
    51c4:	5f 4f       	sbci	r21, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51c6:	fa 01       	movw	r30, r20
    51c8:	34 91       	lpm	r19, Z
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
    51ca:	30 95       	com	r19
    51cc:	2c 91       	ld	r18, X
    51ce:	23 23       	and	r18, r19
    51d0:	2c 93       	st	X, r18
    51d2:	9c 01       	movw	r18, r24
    51d4:	2e 5f       	subi	r18, 0xFE	; 254
    51d6:	3f 4f       	sbci	r19, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    51d8:	f9 01       	movw	r30, r18
    51da:	a5 91       	lpm	r26, Z+
    51dc:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    51de:	fa 01       	movw	r30, r20
    51e0:	44 91       	lpm	r20, Z
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
    51e2:	2c 91       	ld	r18, X
    51e4:	24 2b       	or	r18, r20
    51e6:	2c 93       	st	X, r18
		sei();
    51e8:	78 94       	sei
    51ea:	08 96       	adiw	r24, 0x08	; 8

// ~~~~~~~~~~~~~~~
static void
DI_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    51ec:	fd e4       	ldi	r31, 0x4D	; 77
    51ee:	81 34       	cpi	r24, 0x41	; 65
    51f0:	9f 07       	cpc	r25, r31
    51f2:	11 f7       	brne	.-60     	; 0x51b8 <DI_Init_Hard+0x4>
		cli();
		*(uint8_t*)prp(&DI_M[D_N].DDR) &=~prb(&DI_M[D_N].P);
		*(uint8_t*)prp(&DI_M[D_N].PORT) |=prb(&DI_M[D_N].P);
		sei();
	}
}
    51f4:	08 95       	ret

000051f6 <Reboot>:
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    51f6:	f8 94       	cli
    51f8:	ff cf       	rjmp	.-2      	; 0x51f8 <Reboot+0x2>

000051fa <ResetGSMState>:
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    51fa:	8a e5       	ldi	r24, 0x5A	; 90
    51fc:	80 93 27 06 	sts	0x0627, r24
    5200:	08 95       	ret

00005202 <Start_Updater>:
	cli();
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
	while(1){}		//reset
}
void Start_Updater(void){
	cli();
    5202:	f8 94       	cli
	(*((void(*)(void))ADDR_UPDATER))();			//jump
    5204:	e0 e0       	ldi	r30, 0x00	; 0
    5206:	ff ef       	ldi	r31, 0xFF	; 255
    5208:	09 94       	ijmp

0000520a <Web_Login_Request>:
	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}

void Web_Login_Request(void){
	Web_LoginAttempt = 1;	//  
    520a:	81 e0       	ldi	r24, 0x01	; 1
    520c:	80 93 3a 08 	sts	0x083A, r24
    5210:	08 95       	ret

00005212 <erb>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5212:	0c 94 fa 73 	jmp	0xe7f4	; 0xe7f4 <__eerd_byte_m128>

00005216 <GetReg>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
    5216:	0f 93       	push	r16
    5218:	1f 93       	push	r17
    521a:	cf 93       	push	r28
    521c:	df 93       	push	r29
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    521e:	c8 2f       	mov	r28, r24
    5220:	d0 e0       	ldi	r29, 0x00	; 0
    5222:	fe 01       	movw	r30, r28
    5224:	ee 5d       	subi	r30, 0xDE	; 222
    5226:	f9 4f       	sbci	r31, 0xF9	; 249
    5228:	90 81       	ld	r25, Z
    522a:	92 30       	cpi	r25, 0x02	; 2
    522c:	09 f1       	breq	.+66     	; 0x5270 <GetReg+0x5a>
    522e:	fe 01       	movw	r30, r28
    5230:	a4 e0       	ldi	r26, 0x04	; 4
    5232:	ee 0f       	add	r30, r30
    5234:	ff 1f       	adc	r31, r31
    5236:	aa 95       	dec	r26
    5238:	e1 f7       	brne	.-8      	; 0x5232 <GetReg+0x1c>
    523a:	e2 52       	subi	r30, 0x22	; 34
    523c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    523e:	05 91       	lpm	r16, Z+
    5240:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    5242:	0e 94 c5 28 	call	0x518a	; 0x518a <GetSlave>
    5246:	01 96       	adiw	r24, 0x01	; 1
    5248:	fc 01       	movw	r30, r24
    524a:	85 91       	lpm	r24, Z+
    524c:	94 91       	lpm	r25, Z
    524e:	c3 5f       	subi	r28, 0xF3	; 243
    5250:	d9 4f       	sbci	r29, 0xF9	; 249
    5252:	28 81       	ld	r18, Y
    5254:	fc 01       	movw	r30, r24
    5256:	37 e0       	ldi	r19, 0x07	; 7
    5258:	23 9f       	mul	r18, r19
    525a:	e0 0d       	add	r30, r0
    525c:	f1 1d       	adc	r31, r1
    525e:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~
static uint16_t*
GetReg(uint8_t MB_N)
{
	return MB_SingleState[MB_N]!=MB_SingleExec?(uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&GetQuery(MB_N)->AllocAddr):MB_SingleQuery[MB_N].Buf;
    5260:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    5262:	85 91       	lpm	r24, Z+
    5264:	94 91       	lpm	r25, Z
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	80 0f       	add	r24, r16
    526c:	91 1f       	adc	r25, r17
    526e:	09 c0       	rjmp	.+18     	; 0x5282 <GetReg+0x6c>
    5270:	73 e0       	ldi	r23, 0x03	; 3
    5272:	cc 0f       	add	r28, r28
    5274:	dd 1f       	adc	r29, r29
    5276:	7a 95       	dec	r23
    5278:	e1 f7       	brne	.-8      	; 0x5272 <GetReg+0x5c>
    527a:	cd 59       	subi	r28, 0x9D	; 157
    527c:	dd 4f       	sbci	r29, 0xFD	; 253
    527e:	8e 81       	ldd	r24, Y+6	; 0x06
    5280:	9f 81       	ldd	r25, Y+7	; 0x07
}
    5282:	df 91       	pop	r29
    5284:	cf 91       	pop	r28
    5286:	1f 91       	pop	r17
    5288:	0f 91       	pop	r16
    528a:	08 95       	ret

0000528c <prd>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
prd(const prog_uint32_t *addr)
{
	return pgm_read_dword(addr);
    528c:	fc 01       	movw	r30, r24
    528e:	65 91       	lpm	r22, Z+
    5290:	75 91       	lpm	r23, Z+
    5292:	85 91       	lpm	r24, Z+
    5294:	94 91       	lpm	r25, Z
}
    5296:	08 95       	ret

00005298 <CRC_Seed>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC_Seed(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz, uint16_t Seed)
{
    5298:	8f 92       	push	r8
    529a:	9f 92       	push	r9
    529c:	af 92       	push	r10
    529e:	bf 92       	push	r11
    52a0:	cf 92       	push	r12
    52a2:	df 92       	push	r13
    52a4:	ef 92       	push	r14
    52a6:	ff 92       	push	r15
    52a8:	0f 93       	push	r16
    52aa:	1f 93       	push	r17
    52ac:	cf 93       	push	r28
    52ae:	df 93       	push	r29
    52b0:	00 d0       	rcall	.+0      	; 0x52b2 <CRC_Seed+0x1a>
    52b2:	00 d0       	rcall	.+0      	; 0x52b4 <CRC_Seed+0x1c>
    52b4:	cd b7       	in	r28, 0x3d	; 61
    52b6:	de b7       	in	r29, 0x3e	; 62
    52b8:	4c 01       	movw	r8, r24
    52ba:	5b 01       	movw	r10, r22
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52bc:	c1 2c       	mov	r12, r1
    52be:	d1 2c       	mov	r13, r1
    52c0:	76 01       	movw	r14, r12
    52c2:	c2 16       	cp	r12, r18
    52c4:	d3 06       	cpc	r13, r19
    52c6:	e4 06       	cpc	r14, r20
    52c8:	f5 06       	cpc	r15, r21
    52ca:	f9 f0       	breq	.+62     	; 0x530a <CRC_Seed+0x72>
    52cc:	c5 01       	movw	r24, r10
    52ce:	8c 0d       	add	r24, r12
    52d0:	9d 1d       	adc	r25, r13
		uint8_t j = CRCLo^GetByte(Block+i);
    52d2:	29 83       	std	Y+1, r18	; 0x01
    52d4:	3a 83       	std	Y+2, r19	; 0x02
    52d6:	4b 83       	std	Y+3, r20	; 0x03
    52d8:	5c 83       	std	Y+4, r21	; 0x04
    52da:	f4 01       	movw	r30, r8
    52dc:	09 95       	icall
    52de:	80 27       	eor	r24, r16
		CRCLo = CRCHi^prb(aCRCHi+j);
    52e0:	68 2f       	mov	r22, r24
    52e2:	70 e0       	ldi	r23, 0x00	; 0
    52e4:	fb 01       	movw	r30, r22
    52e6:	ea 57       	subi	r30, 0x7A	; 122
    52e8:	fb 4f       	sbci	r31, 0xFB	; 251

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52ea:	04 91       	lpm	r16, Z
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
    52ec:	01 27       	eor	r16, r17
		CRCHi = prb(aCRCLo+j);
    52ee:	fb 01       	movw	r30, r22
    52f0:	ea 57       	subi	r30, 0x7A	; 122
    52f2:	fc 4f       	sbci	r31, 0xFC	; 252

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    52f4:	14 91       	lpm	r17, Z
		0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98,
		0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
		0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 0x40
	};
	uint8_t CRCHi=Seed>>8, CRCLo=Seed;
	for (uint32_t i=0; i<Sz; i++) {
    52f6:	ff ef       	ldi	r31, 0xFF	; 255
    52f8:	cf 1a       	sub	r12, r31
    52fa:	df 0a       	sbc	r13, r31
    52fc:	ef 0a       	sbc	r14, r31
    52fe:	ff 0a       	sbc	r15, r31
    5300:	5c 81       	ldd	r21, Y+4	; 0x04
    5302:	4b 81       	ldd	r20, Y+3	; 0x03
    5304:	3a 81       	ldd	r19, Y+2	; 0x02
    5306:	29 81       	ldd	r18, Y+1	; 0x01
    5308:	dc cf       	rjmp	.-72     	; 0x52c2 <CRC_Seed+0x2a>
		uint8_t j = CRCLo^GetByte(Block+i);
		CRCLo = CRCHi^prb(aCRCHi+j);
		CRCHi = prb(aCRCLo+j);
	}
	return CRCHi<<8|CRCLo;
    530a:	80 2f       	mov	r24, r16
    530c:	90 e0       	ldi	r25, 0x00	; 0
}
    530e:	91 2b       	or	r25, r17
    5310:	0f 90       	pop	r0
    5312:	0f 90       	pop	r0
    5314:	0f 90       	pop	r0
    5316:	0f 90       	pop	r0
    5318:	df 91       	pop	r29
    531a:	cf 91       	pop	r28
    531c:	1f 91       	pop	r17
    531e:	0f 91       	pop	r16
    5320:	ff 90       	pop	r15
    5322:	ef 90       	pop	r14
    5324:	df 90       	pop	r13
    5326:	cf 90       	pop	r12
    5328:	bf 90       	pop	r11
    532a:	af 90       	pop	r10
    532c:	9f 90       	pop	r9
    532e:	8f 90       	pop	r8
    5330:	08 95       	ret

00005332 <CRC>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
CRC(uint8_t (*GetByte)(const uint8_t*), const uint8_t *Block, uint32_t Sz)
{
    5332:	0f 93       	push	r16
    5334:	1f 93       	push	r17
	return CRC_Seed(GetByte, Block, Sz, 0xFFFF);
    5336:	0f ef       	ldi	r16, 0xFF	; 255
    5338:	1f ef       	ldi	r17, 0xFF	; 255
    533a:	0e 94 4c 29 	call	0x5298	; 0x5298 <CRC_Seed>
}
    533e:	1f 91       	pop	r17
    5340:	0f 91       	pop	r16
    5342:	08 95       	ret

00005344 <CRC_EEPROM_calc>:
}

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
    5344:	0f 93       	push	r16
    5346:	1f 93       	push	r17
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
    5348:	29 ea       	ldi	r18, 0xA9	; 169
    534a:	31 e0       	ldi	r19, 0x01	; 1
// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
    534c:	40 e0       	ldi	r20, 0x00	; 0
    534e:	50 e0       	ldi	r21, 0x00	; 0
    5350:	60 e0       	ldi	r22, 0x00	; 0
    5352:	70 e0       	ldi	r23, 0x00	; 0
    5354:	89 e0       	ldi	r24, 0x09	; 9
    5356:	99 e2       	ldi	r25, 0x29	; 41
    5358:	0e 94 99 29 	call	0x5332	; 0x5332 <CRC>
    535c:	2b ef       	ldi	r18, 0xFB	; 251
    535e:	3f e0       	ldi	r19, 0x0F	; 15
    5360:	29 5a       	subi	r18, 0xA9	; 169
    5362:	31 40       	sbci	r19, 0x01	; 1
    5364:	40 e0       	ldi	r20, 0x00	; 0
    5366:	50 e0       	ldi	r21, 0x00	; 0

// ~~~~~~~~~~~~~~~~~~
static uint16_t
CRC_EEPROM_calc(void)
{
	return
    5368:	8c 01       	movw	r16, r24
    536a:	6e ea       	ldi	r22, 0xAE	; 174
    536c:	71 e0       	ldi	r23, 0x01	; 1
    536e:	89 e0       	ldi	r24, 0x09	; 9
    5370:	99 e2       	ldi	r25, 0x29	; 41
    5372:	0e 94 4c 29 	call	0x5298	; 0x5298 <CRC_Seed>
		CRC_Seed(erb, (uint8_t*)&MemCheck_stor+sizeof(MemCheck_stor), E2END-((uint16_t)&MemCheck_stor-1)-sizeof(MemCheck_stor),
			CRC(erb, NULL, (uint16_t)&MemCheck_stor));
}
    5376:	1f 91       	pop	r17
    5378:	0f 91       	pop	r16
    537a:	08 95       	ret

0000537c <CRC_EEPROM_upd>:
// ~~~~~~~~~~~~~~~~~
// Duration: 48 ms
static void
CRC_EEPROM_upd(void)
{
	if (!(MemFail &(1<<MemFail_EEPROM)))
    537c:	80 91 77 0a 	lds	r24, 0x0A77
    5380:	81 fd       	sbrc	r24, 1
    5382:	07 c0       	rjmp	.+14     	; 0x5392 <CRC_EEPROM_upd+0x16>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5384:	0e 94 a2 29 	call	0x5344	; 0x5344 <CRC_EEPROM_calc>
    5388:	bc 01       	movw	r22, r24
    538a:	8b ea       	ldi	r24, 0xAB	; 171
    538c:	91 e0       	ldi	r25, 0x01	; 1
    538e:	0c 94 2d 74 	jmp	0xe85a	; 0xe85a <__eewr_word_m128>
    5392:	08 95       	ret

00005394 <ewb>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewb(uint8_t *addr, uint8_t val)
{
	//IntOff();
	eeprom_write_byte(addr, val);
    5394:	0e 94 18 74 	call	0xe830	; 0xe830 <__eewr_byte_m128>
	CRC_EEPROM_upd();
    5398:	0c 94 be 29 	jmp	0x537c	; 0x537c <CRC_EEPROM_upd>

0000539c <Start_Bootloader>:
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
}
void Start_Bootloader(void){
	cli();
    539c:	f8 94       	cli
	ewb((uint8_t*)E2END, 0xFF);	//  Application program
    539e:	6f ef       	ldi	r22, 0xFF	; 255
    53a0:	8f ef       	ldi	r24, 0xFF	; 255
    53a2:	9f e0       	ldi	r25, 0x0F	; 15
    53a4:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
    53a8:	ff cf       	rjmp	.-2      	; 0x53a8 <Start_Bootloader+0xc>

000053aa <eww>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
eww(uint16_t *addr, uint16_t val)
{
	//IntOff();
	eeprom_write_word(addr, val);
    53aa:	0e 94 2d 74 	call	0xe85a	; 0xe85a <__eewr_word_m128>
	CRC_EEPROM_upd();
    53ae:	0c 94 be 29 	jmp	0x537c	; 0x537c <CRC_EEPROM_upd>

000053b2 <ewd>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewd(uint32_t *addr, uint32_t val)
{
	//IntOff();
	eeprom_write_dword(addr, val);
    53b2:	0e 94 25 74 	call	0xe84a	; 0xe84a <__eewr_dword_m128>
	CRC_EEPROM_upd();
    53b6:	0c 94 be 29 	jmp	0x537c	; 0x537c <CRC_EEPROM_upd>

000053ba <ewbl>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ewbl(const void *src, void *dst, size_t n)
{
	//IntOff();
	eeprom_write_block(src, dst, n);
    53ba:	0e 94 0e 74 	call	0xe81c	; 0xe81c <__eewr_block_m128>
	CRC_EEPROM_upd();
    53be:	0c 94 be 29 	jmp	0x537c	; 0x537c <CRC_EEPROM_upd>

000053c2 <CRC_Flash_calc>:
}

// ~~~~~~~~~~~~~~~~~
static uint16_t
CRC_Flash_calc(void)
{
    53c2:	0f 93       	push	r16
    53c4:	1f 93       	push	r17
	#if FLASHEND<0xFFFF
		return CRC(prb, NULL, (uint32_t)FLASHEND+1);
	#else
		return CRC_Seed(prb_f, NULL, FLASHEND-0xFFFF, CRC(prb, NULL, 0x10000));
    53c6:	20 e0       	ldi	r18, 0x00	; 0
    53c8:	30 e0       	ldi	r19, 0x00	; 0
    53ca:	41 e0       	ldi	r20, 0x01	; 1
    53cc:	50 e0       	ldi	r21, 0x00	; 0
    53ce:	60 e0       	ldi	r22, 0x00	; 0
    53d0:	70 e0       	ldi	r23, 0x00	; 0
    53d2:	8e e1       	ldi	r24, 0x1E	; 30
    53d4:	98 e2       	ldi	r25, 0x28	; 40
    53d6:	0e 94 99 29 	call	0x5332	; 0x5332 <CRC>
    53da:	8c 01       	movw	r16, r24
    53dc:	20 e0       	ldi	r18, 0x00	; 0
    53de:	30 e0       	ldi	r19, 0x00	; 0
    53e0:	41 e0       	ldi	r20, 0x01	; 1
    53e2:	50 e0       	ldi	r21, 0x00	; 0
    53e4:	60 e0       	ldi	r22, 0x00	; 0
    53e6:	70 e0       	ldi	r23, 0x00	; 0
    53e8:	81 e2       	ldi	r24, 0x21	; 33
    53ea:	98 e2       	ldi	r25, 0x28	; 40
    53ec:	0e 94 4c 29 	call	0x5298	; 0x5298 <CRC_Seed>
	#endif
}
    53f0:	1f 91       	pop	r17
    53f2:	0f 91       	pop	r16
    53f4:	08 95       	ret

000053f6 <MemCheckInit>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    53f6:	8d ea       	ldi	r24, 0xAD	; 173
    53f8:	91 e0       	ldi	r25, 0x01	; 1
    53fa:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
// ~~~~~~~~~~~~~~~
void
MemCheckInit(void)
{
//	TD_Mem = Timer32SysAlloc(1);
	if (!erb(&MemCheck_stor.ReprogFlg)) {
    53fe:	81 11       	cpse	r24, r1
    5400:	13 c0       	rjmp	.+38     	; 0x5428 <MemCheckInit+0x32>
		eeprom_write_word(&MemCheck_stor.CRC_Flash_stor, CRC_Flash_calc());
    5402:	0e 94 e1 29 	call	0x53c2	; 0x53c2 <CRC_Flash_calc>
    5406:	bc 01       	movw	r22, r24
    5408:	89 ea       	ldi	r24, 0xA9	; 169
    540a:	91 e0       	ldi	r25, 0x01	; 1
    540c:	0e 94 2d 74 	call	0xe85a	; 0xe85a <__eewr_word_m128>
		eeprom_write_word(&MemCheck_stor.CRC_EEPROM_stor, CRC_EEPROM_calc());
    5410:	0e 94 a2 29 	call	0x5344	; 0x5344 <CRC_EEPROM_calc>
    5414:	bc 01       	movw	r22, r24
    5416:	8b ea       	ldi	r24, 0xAB	; 171
    5418:	91 e0       	ldi	r25, 0x01	; 1
    541a:	0e 94 2d 74 	call	0xe85a	; 0xe85a <__eewr_word_m128>
		eeprom_write_byte(&MemCheck_stor.ReprogFlg, 1);
    541e:	61 e0       	ldi	r22, 0x01	; 1
    5420:	8d ea       	ldi	r24, 0xAD	; 173
    5422:	91 e0       	ldi	r25, 0x01	; 1
    5424:	0c 94 18 74 	jmp	0xe830	; 0xe830 <__eewr_byte_m128>
    5428:	08 95       	ret

0000542a <IntOff>:

// ~~~~~~~~~
uint8_t
IntOff(void)
{
	interru_enub_flg = SREG &(1<<7);
    542a:	8f b7       	in	r24, 0x3f	; 63
    542c:	80 78       	andi	r24, 0x80	; 128
    542e:	80 93 de 03 	sts	0x03DE, r24
	cli();
    5432:	f8 94       	cli
	return interru_enub_flg;
}
    5434:	80 91 de 03 	lds	r24, 0x03DE
    5438:	08 95       	ret

0000543a <IntOn>:

// ~~~~~~~~
uint8_t
IntOn(void)
{
	if (interru_enub_flg)
    543a:	80 91 de 03 	lds	r24, 0x03DE
    543e:	88 23       	and	r24, r24
    5440:	09 f0       	breq	.+2      	; 0x5444 <IntOn+0xa>
		sei();
    5442:	78 94       	sei
	return interru_enub_flg;
}
    5444:	80 91 de 03 	lds	r24, 0x03DE
    5448:	08 95       	ret

0000544a <Modbus_ReadHoldReg>:
	eww(&SerialNum, MBHoldReg1[43]);
	
}

void Modbus_ReadHoldReg(void){
	IntOff();
    544a:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    544e:	87 e2       	ldi	r24, 0x27	; 39
    5450:	90 e0       	ldi	r25, 0x00	; 0
    5452:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	MBHoldReg1[0] = erw(&EM_UART_Param);
    5456:	90 93 7d 08 	sts	0x087D, r25
    545a:	80 93 7c 08 	sts	0x087C, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    545e:	4e e1       	ldi	r20, 0x1E	; 30
    5460:	50 e0       	ldi	r21, 0x00	; 0
    5462:	6c e7       	ldi	r22, 0x7C	; 124
    5464:	71 e0       	ldi	r23, 0x01	; 1
    5466:	8e e7       	ldi	r24, 0x7E	; 126
    5468:	98 e0       	ldi	r25, 0x08	; 8
    546a:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    546e:	44 e1       	ldi	r20, 0x14	; 20
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	68 e6       	ldi	r22, 0x68	; 104
    5474:	71 e0       	ldi	r23, 0x01	; 1
    5476:	8c e9       	ldi	r24, 0x9C	; 156
    5478:	98 e0       	ldi	r25, 0x08	; 8
    547a:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    547e:	44 e1       	ldi	r20, 0x14	; 20
    5480:	50 e0       	ldi	r21, 0x00	; 0
    5482:	64 e5       	ldi	r22, 0x54	; 84
    5484:	71 e0       	ldi	r23, 0x01	; 1
    5486:	80 eb       	ldi	r24, 0xB0	; 176
    5488:	98 e0       	ldi	r25, 0x08	; 8
    548a:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    548e:	80 e2       	ldi	r24, 0x20	; 32
    5490:	91 e0       	ldi	r25, 0x01	; 1
    5492:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	erbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
	erbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
	erbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
	MBHoldReg1[36] = erw(&TCP_ListenPort);
    5496:	90 93 c5 08 	sts	0x08C5, r25
    549a:	80 93 c4 08 	sts	0x08C4, r24
    549e:	8e e0       	ldi	r24, 0x0E	; 14
    54a0:	91 e0       	ldi	r25, 0x01	; 1
    54a2:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	MBHoldReg1[37] = erw(&TCP_CONNECT_timeout);
    54a6:	90 93 c7 08 	sts	0x08C7, r25
    54aa:	80 93 c6 08 	sts	0x08C6, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    54ae:	82 e3       	ldi	r24, 0x32	; 50
    54b0:	91 e0       	ldi	r25, 0x01	; 1
    54b2:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MBHoldReg1[38] = erb(&TCP_ServerIP->IP1);
    54b6:	90 e0       	ldi	r25, 0x00	; 0
    54b8:	90 93 c9 08 	sts	0x08C9, r25
    54bc:	80 93 c8 08 	sts	0x08C8, r24
    54c0:	83 e3       	ldi	r24, 0x33	; 51
    54c2:	91 e0       	ldi	r25, 0x01	; 1
    54c4:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MBHoldReg1[39] = erb(&TCP_ServerIP->IP2);
    54c8:	90 e0       	ldi	r25, 0x00	; 0
    54ca:	90 93 cb 08 	sts	0x08CB, r25
    54ce:	80 93 ca 08 	sts	0x08CA, r24
    54d2:	84 e3       	ldi	r24, 0x34	; 52
    54d4:	91 e0       	ldi	r25, 0x01	; 1
    54d6:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MBHoldReg1[40] = erb(&TCP_ServerIP->IP3);
    54da:	90 e0       	ldi	r25, 0x00	; 0
    54dc:	90 93 cd 08 	sts	0x08CD, r25
    54e0:	80 93 cc 08 	sts	0x08CC, r24
    54e4:	85 e3       	ldi	r24, 0x35	; 53
    54e6:	91 e0       	ldi	r25, 0x01	; 1
    54e8:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MBHoldReg1[41] = erb(&TCP_ServerIP->IP4);
    54ec:	90 e0       	ldi	r25, 0x00	; 0
    54ee:	90 93 cf 08 	sts	0x08CF, r25
    54f2:	80 93 ce 08 	sts	0x08CE, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    54f6:	82 e2       	ldi	r24, 0x22	; 34
    54f8:	91 e0       	ldi	r25, 0x01	; 1
    54fa:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	MBHoldReg1[42] = erw(&TCP_ServerPort[0]);
    54fe:	90 93 d1 08 	sts	0x08D1, r25
    5502:	80 93 d0 08 	sts	0x08D0, r24
    5506:	82 e5       	ldi	r24, 0x52	; 82
    5508:	91 e0       	ldi	r25, 0x01	; 1
    550a:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	MBHoldReg1[43] = erw(&SerialNum);
    550e:	90 93 d3 08 	sts	0x08D3, r25
    5512:	80 93 d2 08 	sts	0x08D2, r24
	IntOn();
    5516:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

0000551a <WdtOn>:

// ~~~~~~~~
void
WdtOn(void)
{
	wdt_reset();
    551a:	a8 95       	wdr
	wdt_enable(WDTO_2S);
    551c:	2f e0       	ldi	r18, 0x0F	; 15
    551e:	88 e1       	ldi	r24, 0x18	; 24
    5520:	90 e0       	ldi	r25, 0x00	; 0
    5522:	0f b6       	in	r0, 0x3f	; 63
    5524:	f8 94       	cli
    5526:	a8 95       	wdr
    5528:	81 bd       	out	0x21, r24	; 33
    552a:	0f be       	out	0x3f, r0	; 63
    552c:	21 bd       	out	0x21, r18	; 33
    552e:	08 95       	ret

00005530 <Timer16Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer16Alloc(void)
{
	uint8_t N = VacantTimer16;
    5530:	80 91 11 01 	lds	r24, 0x0111
	VacantTimer16++;
    5534:	91 e0       	ldi	r25, 0x01	; 1
    5536:	98 0f       	add	r25, r24
    5538:	90 93 11 01 	sts	0x0111, r25
	return N;
}
    553c:	08 95       	ret

0000553e <Timer32Alloc>:

// ~~~~~~~~~~~~~~~
uint8_t
Timer32Alloc(void)
{
	uint8_t N = VacantTimer32;
    553e:	80 91 10 01 	lds	r24, 0x0110
	VacantTimer32++;
    5542:	91 e0       	ldi	r25, 0x01	; 1
    5544:	98 0f       	add	r25, r24
    5546:	90 93 10 01 	sts	0x0110, r25
	return N;
}
    554a:	08 95       	ret

0000554c <StartTimer8>:
}


void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
    554c:	1f 93       	push	r17
    554e:	cf 93       	push	r28
    5550:	df 93       	push	r29
    5552:	1f 92       	push	r1
    5554:	cd b7       	in	r28, 0x3d	; 61
    5556:	de b7       	in	r29, 0x3e	; 62
    5558:	18 2f       	mov	r17, r24
	IntOff();
    555a:	69 83       	std	Y+1, r22	; 0x01
    555c:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	if ((Timer8[TimerN]=Timeout)>0)
    5560:	e1 2f       	mov	r30, r17
    5562:	f0 e0       	ldi	r31, 0x00	; 0
    5564:	ea 55       	subi	r30, 0x5A	; 90
    5566:	fc 4f       	sbci	r31, 0xFC	; 252
    5568:	69 81       	ldd	r22, Y+1	; 0x01
    556a:	60 83       	st	Z, r22
    556c:	e1 2f       	mov	r30, r17
    556e:	e6 95       	lsr	r30
    5570:	e6 95       	lsr	r30
    5572:	e6 95       	lsr	r30
    5574:	17 70       	andi	r17, 0x07	; 7
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5576:	f0 e0       	ldi	r31, 0x00	; 0
    5578:	e3 58       	subi	r30, 0x83	; 131
    557a:	fd 4f       	sbci	r31, 0xFD	; 253
    557c:	80 81       	ld	r24, Z
    557e:	21 e0       	ldi	r18, 0x01	; 1
    5580:	30 e0       	ldi	r19, 0x00	; 0
    5582:	01 2e       	mov	r0, r17
    5584:	01 c0       	rjmp	.+2      	; 0x5588 <StartTimer8+0x3c>
    5586:	22 0f       	add	r18, r18
    5588:	0a 94       	dec	r0
    558a:	ea f7       	brpl	.-6      	; 0x5586 <StartTimer8+0x3a>

void
StartTimer8(uint8_t TimerN, uint8_t Timeout)
{
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
    558c:	66 23       	and	r22, r22
    558e:	21 f0       	breq	.+8      	; 0x5598 <StartTimer8+0x4c>
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
    5590:	20 95       	com	r18
    5592:	28 23       	and	r18, r24
    5594:	20 83       	st	Z, r18
    5596:	02 c0       	rjmp	.+4      	; 0x559c <StartTimer8+0x50>
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
    5598:	82 2b       	or	r24, r18
    559a:	80 83       	st	Z, r24
	IntOn();
}
    559c:	0f 90       	pop	r0
    559e:	df 91       	pop	r29
    55a0:	cf 91       	pop	r28
    55a2:	1f 91       	pop	r17
	IntOff();
	if ((Timer8[TimerN]=Timeout)>0)
		Timer8Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer8Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    55a4:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

000055a8 <StartTimer16>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
    55a8:	1f 93       	push	r17
    55aa:	cf 93       	push	r28
    55ac:	df 93       	push	r29
    55ae:	18 2f       	mov	r17, r24
    55b0:	eb 01       	movw	r28, r22
	IntOff();
    55b2:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	if ((Timer16[TimerN]=Timeout)>0)
    55b6:	e1 2f       	mov	r30, r17
    55b8:	f0 e0       	ldi	r31, 0x00	; 0
    55ba:	ee 0f       	add	r30, r30
    55bc:	ff 1f       	adc	r31, r31
    55be:	ea 5d       	subi	r30, 0xDA	; 218
    55c0:	fc 4f       	sbci	r31, 0xFC	; 252
    55c2:	d1 83       	std	Z+1, r29	; 0x01
    55c4:	c0 83       	st	Z, r28
    55c6:	e1 2f       	mov	r30, r17
    55c8:	e6 95       	lsr	r30
    55ca:	e6 95       	lsr	r30
    55cc:	e6 95       	lsr	r30
    55ce:	17 70       	andi	r17, 0x07	; 7
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55d0:	f0 e0       	ldi	r31, 0x00	; 0
    55d2:	ec 58       	subi	r30, 0x8C	; 140
    55d4:	fd 4f       	sbci	r31, 0xFD	; 253
    55d6:	80 81       	ld	r24, Z
    55d8:	21 e0       	ldi	r18, 0x01	; 1
    55da:	30 e0       	ldi	r19, 0x00	; 0
    55dc:	01 2e       	mov	r0, r17
    55de:	01 c0       	rjmp	.+2      	; 0x55e2 <StartTimer16+0x3a>
    55e0:	22 0f       	add	r18, r18
    55e2:	0a 94       	dec	r0
    55e4:	ea f7       	brpl	.-6      	; 0x55e0 <StartTimer16+0x38>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer16(uint8_t TimerN, uint16_t Timeout)
{
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
    55e6:	cd 2b       	or	r28, r29
    55e8:	21 f0       	breq	.+8      	; 0x55f2 <StartTimer16+0x4a>
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
    55ea:	20 95       	com	r18
    55ec:	28 23       	and	r18, r24
    55ee:	20 83       	st	Z, r18
    55f0:	02 c0       	rjmp	.+4      	; 0x55f6 <StartTimer16+0x4e>
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
    55f2:	82 2b       	or	r24, r18
    55f4:	80 83       	st	Z, r24
	IntOn();
}
    55f6:	df 91       	pop	r29
    55f8:	cf 91       	pop	r28
    55fa:	1f 91       	pop	r17
	IntOff();
	if ((Timer16[TimerN]=Timeout)>0)
		Timer16Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer16Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    55fc:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

00005600 <SlavesOn>:

// ~~~~~~~~~~~~~~~~~~~
static void
SlavesOn(uint8_t MB_N)
{
	SlaveSkip[MB_N] = 0;
    5600:	28 2f       	mov	r18, r24
    5602:	30 e0       	ldi	r19, 0x00	; 0
    5604:	f9 01       	movw	r30, r18
    5606:	ee 0f       	add	r30, r30
    5608:	ff 1f       	adc	r31, r31
    560a:	ee 0f       	add	r30, r30
    560c:	ff 1f       	adc	r31, r31
    560e:	e3 5a       	subi	r30, 0xA3	; 163
    5610:	fd 4f       	sbci	r31, 0xFD	; 253
    5612:	10 82       	st	Z, r1
    5614:	11 82       	std	Z+1, r1	; 0x01
    5616:	12 82       	std	Z+2, r1	; 0x02
    5618:	13 82       	std	Z+3, r1	; 0x03
	StartTimer16(TD_MB_SlaveOff+MB_N, 100*MB_M_TimeOff[MB_N]);
    561a:	f9 01       	movw	r30, r18
    561c:	e6 51       	subi	r30, 0x16	; 22
    561e:	fc 4f       	sbci	r31, 0xFC	; 252
    5620:	60 81       	ld	r22, Z
    5622:	94 e6       	ldi	r25, 0x64	; 100
    5624:	69 9f       	mul	r22, r25
    5626:	b0 01       	movw	r22, r0
    5628:	11 24       	eor	r1, r1
    562a:	90 91 5c 02 	lds	r25, 0x025C
    562e:	9f 5f       	subi	r25, 0xFF	; 255
    5630:	89 0f       	add	r24, r25
    5632:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>

00005636 <NextSlave>:
}

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
    5636:	4f 92       	push	r4
    5638:	5f 92       	push	r5
    563a:	6f 92       	push	r6
    563c:	7f 92       	push	r7
    563e:	8f 92       	push	r8
    5640:	9f 92       	push	r9
    5642:	af 92       	push	r10
    5644:	bf 92       	push	r11
    5646:	cf 92       	push	r12
    5648:	df 92       	push	r13
    564a:	ef 92       	push	r14
    564c:	ff 92       	push	r15
    564e:	0f 93       	push	r16
    5650:	1f 93       	push	r17
    5652:	cf 93       	push	r28
    5654:	df 93       	push	r29
    5656:	98 2e       	mov	r9, r24
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
    5658:	83 e0       	ldi	r24, 0x03	; 3
    565a:	98 9e       	mul	r9, r24
    565c:	f0 01       	movw	r30, r0
    565e:	11 24       	eor	r1, r1
    5660:	ef 5e       	subi	r30, 0xEF	; 239
    5662:	f2 4b       	sbci	r31, 0xB2	; 178

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5664:	74 90       	lpm	r7, Z
// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
	uint8_t i = 0;
    5666:	81 2c       	mov	r8, r1

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
NextSlave(uint8_t MB_N)
{
	uint8_t Over = 0;
    5668:	61 2c       	mov	r6, r1
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    566a:	09 2d       	mov	r16, r9
    566c:	10 e0       	ldi	r17, 0x00	; 0
    566e:	e8 01       	movw	r28, r16
    5670:	ca 5f       	subi	r28, 0xFA	; 250
    5672:	d9 4f       	sbci	r29, 0xF9	; 249
			CurrSlave[MB_N] = 0;
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    5674:	98 01       	movw	r18, r16
    5676:	22 0f       	add	r18, r18
    5678:	33 1f       	adc	r19, r19
    567a:	f9 01       	movw	r30, r18
    567c:	e7 5b       	subi	r30, 0xB7	; 183
    567e:	f6 4f       	sbci	r31, 0xF6	; 246
    5680:	5f 01       	movw	r10, r30
    5682:	c9 01       	movw	r24, r18
    5684:	85 5c       	subi	r24, 0xC5	; 197
    5686:	97 4f       	sbci	r25, 0xF7	; 247
    5688:	6c 01       	movw	r12, r24
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    568a:	78 01       	movw	r14, r16
    568c:	ee 0c       	add	r14, r14
    568e:	ff 1c       	adc	r15, r15
    5690:	ee 0c       	add	r14, r14
    5692:	ff 1c       	adc	r15, r15
    5694:	f7 01       	movw	r30, r14
    5696:	e3 5a       	subi	r30, 0xA3	; 163
    5698:	fd 4f       	sbci	r31, 0xFD	; 253
    569a:	7f 01       	movw	r14, r30
{
	uint8_t Over = 0;
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
    569c:	98 81       	ld	r25, Y
    569e:	9f 5f       	subi	r25, 0xFF	; 255
    56a0:	98 83       	st	Y, r25
    56a2:	97 11       	cpse	r25, r7
    56a4:	27 c0       	rjmp	.+78     	; 0x56f4 <NextSlave+0xbe>
			CurrSlave[MB_N] = 0;
    56a6:	18 82       	st	Y, r1
			Over = 1;

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
    56a8:	60 90 5c 02 	lds	r6, 0x025C
    56ac:	63 94       	inc	r6
    56ae:	63 94       	inc	r6
    56b0:	69 0c       	add	r6, r9

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    56b2:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint16_t Time = Timer16[TimerN];
    56b6:	a6 2d       	mov	r26, r6
    56b8:	b0 e0       	ldi	r27, 0x00	; 0
    56ba:	aa 0f       	add	r26, r26
    56bc:	bb 1f       	adc	r27, r27
    56be:	aa 5d       	subi	r26, 0xDA	; 218
    56c0:	bc 4f       	sbci	r27, 0xFC	; 252
    56c2:	4d 90       	ld	r4, X+
    56c4:	5c 90       	ld	r5, X
	IntOn();
    56c6:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
    56ca:	92 01       	movw	r18, r4
    56cc:	20 95       	com	r18
    56ce:	30 95       	com	r19
    56d0:	f5 01       	movw	r30, r10
    56d2:	31 83       	std	Z+1, r19	; 0x01
    56d4:	20 83       	st	Z, r18
    56d6:	f6 01       	movw	r30, r12
    56d8:	40 81       	ld	r20, Z
    56da:	51 81       	ldd	r21, Z+1	; 0x01
    56dc:	42 17       	cp	r20, r18
    56de:	53 07       	cpc	r21, r19
    56e0:	10 f4       	brcc	.+4      	; 0x56e6 <NextSlave+0xb0>
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
    56e2:	31 83       	std	Z+1, r19	; 0x01
    56e4:	20 83       	st	Z, r18
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    56e6:	6f ef       	ldi	r22, 0xFF	; 255
    56e8:	7f ef       	ldi	r23, 0xFF	; 255
    56ea:	86 2d       	mov	r24, r6
    56ec:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
	uint8_t i = 0;
	uint8_t SlaveQt = prb(&(MB_Master_List+MB_N)->SlaveQt);
	do
		if (++CurrSlave[MB_N]==SlaveQt) {
			CurrSlave[MB_N] = 0;
			Over = 1;
    56f0:	66 24       	eor	r6, r6
    56f2:	63 94       	inc	r6

			if ((MB_Master_Cycle[MB_N]=0xFFFF-GetTimer16(TD_MB_Cycle+MB_N))>MB_Master_MaxCycle[MB_N])
				MB_Master_MaxCycle[MB_N] = MB_Master_Cycle[MB_N];
			StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		}
	while (SlaveSkip[MB_N] &((uint32_t)1<<CurrSlave[MB_N]) && ++i<SlaveQt);
    56f4:	f7 01       	movw	r30, r14
    56f6:	40 81       	ld	r20, Z
    56f8:	51 81       	ldd	r21, Z+1	; 0x01
    56fa:	62 81       	ldd	r22, Z+2	; 0x02
    56fc:	73 81       	ldd	r23, Z+3	; 0x03
    56fe:	08 80       	ld	r0, Y
    5700:	04 c0       	rjmp	.+8      	; 0x570a <NextSlave+0xd4>
    5702:	76 95       	lsr	r23
    5704:	67 95       	ror	r22
    5706:	57 95       	ror	r21
    5708:	47 95       	ror	r20
    570a:	0a 94       	dec	r0
    570c:	d2 f7       	brpl	.-12     	; 0x5702 <NextSlave+0xcc>
    570e:	40 ff       	sbrs	r20, 0
    5710:	03 c0       	rjmp	.+6      	; 0x5718 <NextSlave+0xe2>
    5712:	83 94       	inc	r8
    5714:	87 14       	cp	r8, r7
    5716:	10 f2       	brcs	.-124    	; 0x569c <NextSlave+0x66>
	if (i==SlaveQt) {
    5718:	87 10       	cpse	r8, r7
    571a:	09 c0       	rjmp	.+18     	; 0x572e <NextSlave+0xf8>
		SlavesOn(MB_N);
    571c:	89 2d       	mov	r24, r9
    571e:	0e 94 00 2b 	call	0x5600	; 0x5600 <SlavesOn>
		if (++CurrSlave[MB_N]==SlaveQt)
    5722:	98 81       	ld	r25, Y
    5724:	9f 5f       	subi	r25, 0xFF	; 255
    5726:	98 83       	st	Y, r25
    5728:	98 11       	cpse	r25, r8
    572a:	01 c0       	rjmp	.+2      	; 0x572e <NextSlave+0xf8>
			CurrSlave[MB_N] = 0;
    572c:	18 82       	st	Y, r1
	}
	CurrQuery[MB_N] = 0;
    572e:	f8 01       	movw	r30, r16
    5730:	e3 5f       	subi	r30, 0xF3	; 243
    5732:	f9 4f       	sbci	r31, 0xF9	; 249
    5734:	10 82       	st	Z, r1
	return Over;
}
    5736:	86 2d       	mov	r24, r6
    5738:	df 91       	pop	r29
    573a:	cf 91       	pop	r28
    573c:	1f 91       	pop	r17
    573e:	0f 91       	pop	r16
    5740:	ff 90       	pop	r15
    5742:	ef 90       	pop	r14
    5744:	df 90       	pop	r13
    5746:	cf 90       	pop	r12
    5748:	bf 90       	pop	r11
    574a:	af 90       	pop	r10
    574c:	9f 90       	pop	r9
    574e:	8f 90       	pop	r8
    5750:	7f 90       	pop	r7
    5752:	6f 90       	pop	r6
    5754:	5f 90       	pop	r5
    5756:	4f 90       	pop	r4
    5758:	08 95       	ret

0000575a <FailSlave>:

// ~~~~~~~~~~~~~~~~~~~~
static uint8_t
FailSlave(uint8_t MB_N)
{
    575a:	0f 93       	push	r16
    575c:	1f 93       	push	r17
    575e:	cf 93       	push	r28
    5760:	df 93       	push	r29
	uint8_t Over = 0;
	if (MB_SingleState[MB_N]==MB_SingleExec)
    5762:	28 2f       	mov	r18, r24
    5764:	30 e0       	ldi	r19, 0x00	; 0
    5766:	f9 01       	movw	r30, r18
    5768:	ee 5d       	subi	r30, 0xDE	; 222
    576a:	f9 4f       	sbci	r31, 0xF9	; 249
    576c:	90 81       	ld	r25, Z
    576e:	92 30       	cpi	r25, 0x02	; 2
    5770:	11 f4       	brne	.+4      	; 0x5776 <FailSlave+0x1c>
		MB_SingleState[MB_N] = MB_SingleIdle;
    5772:	10 82       	st	Z, r1
    5774:	54 c0       	rjmp	.+168    	; 0x581e <FailSlave+0xc4>
	else{
		MB_CPT[MB_N][4]++;	// -    
    5776:	f9 01       	movw	r30, r18
    5778:	d4 e0       	ldi	r29, 0x04	; 4
    577a:	ee 0f       	add	r30, r30
    577c:	ff 1f       	adc	r31, r31
    577e:	da 95       	dec	r29
    5780:	e1 f7       	brne	.-8      	; 0x577a <FailSlave+0x20>
    5782:	e7 5d       	subi	r30, 0xD7	; 215
    5784:	f4 4f       	sbci	r31, 0xF4	; 244
    5786:	40 85       	ldd	r20, Z+8	; 0x08
    5788:	51 85       	ldd	r21, Z+9	; 0x09
    578a:	4f 5f       	subi	r20, 0xFF	; 255
    578c:	5f 4f       	sbci	r21, 0xFF	; 255
    578e:	51 87       	std	Z+9, r21	; 0x09
    5790:	40 87       	std	Z+8, r20	; 0x08
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
    5792:	f9 01       	movw	r30, r18
    5794:	ef 59       	subi	r30, 0x9F	; 159
    5796:	fd 4f       	sbci	r31, 0xFD	; 253
    5798:	90 81       	ld	r25, Z
    579a:	9f 5f       	subi	r25, 0xFF	; 255
    579c:	90 83       	st	Z, r25
    579e:	d9 01       	movw	r26, r18
    57a0:	ac 52       	subi	r26, 0x2C	; 44
    57a2:	b7 4f       	sbci	r27, 0xF7	; 247
    57a4:	4c 91       	ld	r20, X
    57a6:	94 13       	cpse	r25, r20
    57a8:	3a c0       	rjmp	.+116    	; 0x581e <FailSlave+0xc4>
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
    57aa:	d9 01       	movw	r26, r18
    57ac:	aa 5f       	subi	r26, 0xFA	; 250
    57ae:	b9 4f       	sbci	r27, 0xF9	; 249
    57b0:	41 e0       	ldi	r20, 0x01	; 1
    57b2:	50 e0       	ldi	r21, 0x00	; 0
    57b4:	60 e0       	ldi	r22, 0x00	; 0
    57b6:	70 e0       	ldi	r23, 0x00	; 0
    57b8:	0c 90       	ld	r0, X
    57ba:	04 c0       	rjmp	.+8      	; 0x57c4 <FailSlave+0x6a>
    57bc:	44 0f       	add	r20, r20
    57be:	55 1f       	adc	r21, r21
    57c0:	66 1f       	adc	r22, r22
    57c2:	77 1f       	adc	r23, r23
    57c4:	0a 94       	dec	r0
    57c6:	d2 f7       	brpl	.-12     	; 0x57bc <FailSlave+0x62>
			SlaveOff[MB_N] |=S_N;
    57c8:	d9 01       	movw	r26, r18
    57ca:	aa 0f       	add	r26, r26
    57cc:	bb 1f       	adc	r27, r27
    57ce:	aa 0f       	add	r26, r26
    57d0:	bb 1f       	adc	r27, r27
    57d2:	ed 01       	movw	r28, r26
    57d4:	cc 5e       	subi	r28, 0xEC	; 236
    57d6:	d4 4f       	sbci	r29, 0xF4	; 244
    57d8:	08 81       	ld	r16, Y
    57da:	19 81       	ldd	r17, Y+1	; 0x01
    57dc:	2a 81       	ldd	r18, Y+2	; 0x02
    57de:	3b 81       	ldd	r19, Y+3	; 0x03
    57e0:	04 2b       	or	r16, r20
    57e2:	15 2b       	or	r17, r21
    57e4:	26 2b       	or	r18, r22
    57e6:	37 2b       	or	r19, r23
    57e8:	08 83       	st	Y, r16
    57ea:	19 83       	std	Y+1, r17	; 0x01
    57ec:	2a 83       	std	Y+2, r18	; 0x02
    57ee:	3b 83       	std	Y+3, r19	; 0x03
			SlaveSkip[MB_N] |=S_N;
    57f0:	a3 5a       	subi	r26, 0xA3	; 163
    57f2:	bd 4f       	sbci	r27, 0xFD	; 253
    57f4:	0d 91       	ld	r16, X+
    57f6:	1d 91       	ld	r17, X+
    57f8:	2d 91       	ld	r18, X+
    57fa:	3c 91       	ld	r19, X
    57fc:	13 97       	sbiw	r26, 0x03	; 3
    57fe:	04 2b       	or	r16, r20
    5800:	15 2b       	or	r17, r21
    5802:	26 2b       	or	r18, r22
    5804:	37 2b       	or	r19, r23
    5806:	0d 93       	st	X+, r16
    5808:	1d 93       	st	X+, r17
    580a:	2d 93       	st	X+, r18
    580c:	3c 93       	st	X, r19
    580e:	13 97       	sbiw	r26, 0x03	; 3
			Try[MB_N] = 0;
    5810:	10 82       	st	Z, r1
			Over = NextSlave(MB_N);
		}
	}
	return Over;
}
    5812:	df 91       	pop	r29
    5814:	cf 91       	pop	r28
    5816:	1f 91       	pop	r17
    5818:	0f 91       	pop	r16
		if (++Try[MB_N]==MB_M_Try[MB_N]) {
			uint32_t S_N = (uint32_t)1<<CurrSlave[MB_N];
			SlaveOff[MB_N] |=S_N;
			SlaveSkip[MB_N] |=S_N;
			Try[MB_N] = 0;
			Over = NextSlave(MB_N);
    581a:	0c 94 1b 2b 	jmp	0x5636	; 0x5636 <NextSlave>
		}
	}
	return Over;
}
    581e:	80 e0       	ldi	r24, 0x00	; 0
    5820:	df 91       	pop	r29
    5822:	cf 91       	pop	r28
    5824:	1f 91       	pop	r17
    5826:	0f 91       	pop	r16
    5828:	08 95       	ret

0000582a <StartTimer32>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
    582a:	1f 93       	push	r17
    582c:	cf 93       	push	r28
    582e:	df 93       	push	r29
    5830:	00 d0       	rcall	.+0      	; 0x5832 <StartTimer32+0x8>
    5832:	00 d0       	rcall	.+0      	; 0x5834 <StartTimer32+0xa>
    5834:	cd b7       	in	r28, 0x3d	; 61
    5836:	de b7       	in	r29, 0x3e	; 62
    5838:	18 2f       	mov	r17, r24
	IntOff();
    583a:	49 83       	std	Y+1, r20	; 0x01
    583c:	5a 83       	std	Y+2, r21	; 0x02
    583e:	6b 83       	std	Y+3, r22	; 0x03
    5840:	7c 83       	std	Y+4, r23	; 0x04
    5842:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	if ((Timer32[TimerN]=Timeout)>0)
    5846:	84 e0       	ldi	r24, 0x04	; 4
    5848:	18 9f       	mul	r17, r24
    584a:	f0 01       	movw	r30, r0
    584c:	11 24       	eor	r1, r1
    584e:	ea 57       	subi	r30, 0x7A	; 122
    5850:	fd 4f       	sbci	r31, 0xFD	; 253
    5852:	49 81       	ldd	r20, Y+1	; 0x01
    5854:	5a 81       	ldd	r21, Y+2	; 0x02
    5856:	6b 81       	ldd	r22, Y+3	; 0x03
    5858:	7c 81       	ldd	r23, Y+4	; 0x04
    585a:	40 83       	st	Z, r20
    585c:	51 83       	std	Z+1, r21	; 0x01
    585e:	62 83       	std	Z+2, r22	; 0x02
    5860:	73 83       	std	Z+3, r23	; 0x03
    5862:	e1 2f       	mov	r30, r17
    5864:	e6 95       	lsr	r30
    5866:	e6 95       	lsr	r30
    5868:	e6 95       	lsr	r30
    586a:	17 70       	andi	r17, 0x07	; 7
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    586c:	f0 e0       	ldi	r31, 0x00	; 0
    586e:	e2 59       	subi	r30, 0x92	; 146
    5870:	fd 4f       	sbci	r31, 0xFD	; 253
    5872:	80 81       	ld	r24, Z
    5874:	21 e0       	ldi	r18, 0x01	; 1
    5876:	30 e0       	ldi	r19, 0x00	; 0
    5878:	01 2e       	mov	r0, r17
    587a:	01 c0       	rjmp	.+2      	; 0x587e <StartTimer32+0x54>
    587c:	22 0f       	add	r18, r18
    587e:	0a 94       	dec	r0
    5880:	ea f7       	brpl	.-6      	; 0x587c <StartTimer32+0x52>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
StartTimer32(uint8_t TimerN, uint32_t Timeout)
{
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
    5882:	45 2b       	or	r20, r21
    5884:	46 2b       	or	r20, r22
    5886:	47 2b       	or	r20, r23
    5888:	21 f0       	breq	.+8      	; 0x5892 <StartTimer32+0x68>
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
    588a:	20 95       	com	r18
    588c:	28 23       	and	r18, r24
    588e:	20 83       	st	Z, r18
    5890:	02 c0       	rjmp	.+4      	; 0x5896 <StartTimer32+0x6c>
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
    5892:	82 2b       	or	r24, r18
    5894:	80 83       	st	Z, r24
	IntOn();
}
    5896:	0f 90       	pop	r0
    5898:	0f 90       	pop	r0
    589a:	0f 90       	pop	r0
    589c:	0f 90       	pop	r0
    589e:	df 91       	pop	r29
    58a0:	cf 91       	pop	r28
    58a2:	1f 91       	pop	r17
	IntOff();
	if ((Timer32[TimerN]=Timeout)>0)
		Timer32Flg[TimerN/8] &=~(1<<TimerN%8);
	else
		Timer32Flg[TimerN/8] |=(1<<TimerN%8);
	IntOn();
    58a4:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

000058a8 <Timer8Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer8Stopp(uint8_t TimerN)
{
	return (Timer8Flg[TimerN/8] &(1<<TimerN%8)) && Timer8[TimerN]==0;
    58a8:	a8 2f       	mov	r26, r24
    58aa:	a6 95       	lsr	r26
    58ac:	a6 95       	lsr	r26
    58ae:	a6 95       	lsr	r26
    58b0:	b0 e0       	ldi	r27, 0x00	; 0
    58b2:	a3 58       	subi	r26, 0x83	; 131
    58b4:	bd 4f       	sbci	r27, 0xFD	; 253
    58b6:	2c 91       	ld	r18, X
    58b8:	30 e0       	ldi	r19, 0x00	; 0
    58ba:	98 2f       	mov	r25, r24
    58bc:	97 70       	andi	r25, 0x07	; 7
    58be:	02 c0       	rjmp	.+4      	; 0x58c4 <Timer8Stopp+0x1c>
    58c0:	35 95       	asr	r19
    58c2:	27 95       	ror	r18
    58c4:	9a 95       	dec	r25
    58c6:	e2 f7       	brpl	.-8      	; 0x58c0 <Timer8Stopp+0x18>
    58c8:	20 ff       	sbrs	r18, 0
    58ca:	07 c0       	rjmp	.+14     	; 0x58da <Timer8Stopp+0x32>
    58cc:	e8 2f       	mov	r30, r24
    58ce:	f0 e0       	ldi	r31, 0x00	; 0
    58d0:	ea 55       	subi	r30, 0x5A	; 90
    58d2:	fc 4f       	sbci	r31, 0xFC	; 252
    58d4:	90 81       	ld	r25, Z
    58d6:	81 e0       	ldi	r24, 0x01	; 1
    58d8:	91 11       	cpse	r25, r1
    58da:	80 e0       	ldi	r24, 0x00	; 0
}
    58dc:	08 95       	ret

000058de <Timer16Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16Stopp(uint8_t TimerN)
{
    58de:	cf 93       	push	r28
    58e0:	c8 2f       	mov	r28, r24
	IntOff();
    58e2:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint8_t T_S = (Timer16Flg[TimerN/8] &(1<<TimerN%8)) && Timer16[TimerN]==0;
    58e6:	ac 2f       	mov	r26, r28
    58e8:	a6 95       	lsr	r26
    58ea:	a6 95       	lsr	r26
    58ec:	a6 95       	lsr	r26
    58ee:	b0 e0       	ldi	r27, 0x00	; 0
    58f0:	ac 58       	subi	r26, 0x8C	; 140
    58f2:	bd 4f       	sbci	r27, 0xFD	; 253
    58f4:	2c 91       	ld	r18, X
    58f6:	30 e0       	ldi	r19, 0x00	; 0
    58f8:	8c 2f       	mov	r24, r28
    58fa:	87 70       	andi	r24, 0x07	; 7
    58fc:	02 c0       	rjmp	.+4      	; 0x5902 <Timer16Stopp+0x24>
    58fe:	35 95       	asr	r19
    5900:	27 95       	ror	r18
    5902:	8a 95       	dec	r24
    5904:	e2 f7       	brpl	.-8      	; 0x58fe <Timer16Stopp+0x20>
    5906:	20 ff       	sbrs	r18, 0
    5908:	0b c0       	rjmp	.+22     	; 0x5920 <Timer16Stopp+0x42>
    590a:	ec 2f       	mov	r30, r28
    590c:	f0 e0       	ldi	r31, 0x00	; 0
    590e:	ee 0f       	add	r30, r30
    5910:	ff 1f       	adc	r31, r31
    5912:	ea 5d       	subi	r30, 0xDA	; 218
    5914:	fc 4f       	sbci	r31, 0xFC	; 252
    5916:	20 81       	ld	r18, Z
    5918:	31 81       	ldd	r19, Z+1	; 0x01
    591a:	c1 e0       	ldi	r28, 0x01	; 1
    591c:	23 2b       	or	r18, r19
    591e:	09 f0       	breq	.+2      	; 0x5922 <Timer16Stopp+0x44>
    5920:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5922:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
	return T_S;
}
    5926:	8c 2f       	mov	r24, r28
    5928:	cf 91       	pop	r28
    592a:	08 95       	ret

0000592c <Timer32Stopp>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32Stopp(uint8_t TimerN)
{
    592c:	cf 93       	push	r28
    592e:	c8 2f       	mov	r28, r24
	IntOff();
    5930:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint8_t T_S = (Timer32Flg[TimerN/8] &(1<<TimerN%8)) && Timer32[TimerN]==0;
    5934:	ac 2f       	mov	r26, r28
    5936:	a6 95       	lsr	r26
    5938:	a6 95       	lsr	r26
    593a:	a6 95       	lsr	r26
    593c:	b0 e0       	ldi	r27, 0x00	; 0
    593e:	a2 59       	subi	r26, 0x92	; 146
    5940:	bd 4f       	sbci	r27, 0xFD	; 253
    5942:	2c 91       	ld	r18, X
    5944:	30 e0       	ldi	r19, 0x00	; 0
    5946:	8c 2f       	mov	r24, r28
    5948:	87 70       	andi	r24, 0x07	; 7
    594a:	02 c0       	rjmp	.+4      	; 0x5950 <Timer32Stopp+0x24>
    594c:	35 95       	asr	r19
    594e:	27 95       	ror	r18
    5950:	8a 95       	dec	r24
    5952:	e2 f7       	brpl	.-8      	; 0x594c <Timer32Stopp+0x20>
    5954:	20 ff       	sbrs	r18, 0
    5956:	0f c0       	rjmp	.+30     	; 0x5976 <Timer32Stopp+0x4a>
    5958:	84 e0       	ldi	r24, 0x04	; 4
    595a:	c8 9f       	mul	r28, r24
    595c:	f0 01       	movw	r30, r0
    595e:	11 24       	eor	r1, r1
    5960:	ea 57       	subi	r30, 0x7A	; 122
    5962:	fd 4f       	sbci	r31, 0xFD	; 253
    5964:	40 81       	ld	r20, Z
    5966:	51 81       	ldd	r21, Z+1	; 0x01
    5968:	62 81       	ldd	r22, Z+2	; 0x02
    596a:	73 81       	ldd	r23, Z+3	; 0x03
    596c:	c1 e0       	ldi	r28, 0x01	; 1
    596e:	45 2b       	or	r20, r21
    5970:	46 2b       	or	r20, r22
    5972:	47 2b       	or	r20, r23
    5974:	09 f0       	breq	.+2      	; 0x5978 <Timer32Stopp+0x4c>
    5976:	c0 e0       	ldi	r28, 0x00	; 0
	IntOn();
    5978:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
	return T_S;
}
    597c:	8c 2f       	mov	r24, r28
    597e:	cf 91       	pop	r28
    5980:	08 95       	ret

00005982 <ResetTimer16>:
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~
void
ResetTimer16(uint8_t TimerN)
{
    5982:	cf 93       	push	r28
    5984:	c8 2f       	mov	r28, r24
	IntOff();
    5986:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
    598a:	ac 2f       	mov	r26, r28
    598c:	a6 95       	lsr	r26
    598e:	a6 95       	lsr	r26
    5990:	a6 95       	lsr	r26
    5992:	b0 e0       	ldi	r27, 0x00	; 0
    5994:	ac 58       	subi	r26, 0x8C	; 140
    5996:	bd 4f       	sbci	r27, 0xFD	; 253
    5998:	8c 91       	ld	r24, X
    599a:	9c 2f       	mov	r25, r28
    599c:	97 70       	andi	r25, 0x07	; 7
    599e:	21 e0       	ldi	r18, 0x01	; 1
    59a0:	30 e0       	ldi	r19, 0x00	; 0
    59a2:	01 c0       	rjmp	.+2      	; 0x59a6 <ResetTimer16+0x24>
    59a4:	22 0f       	add	r18, r18
    59a6:	9a 95       	dec	r25
    59a8:	ea f7       	brpl	.-6      	; 0x59a4 <ResetTimer16+0x22>
    59aa:	82 2b       	or	r24, r18
    59ac:	8c 93       	st	X, r24
	Timer16[TimerN] = 0;
    59ae:	ec 2f       	mov	r30, r28
    59b0:	f0 e0       	ldi	r31, 0x00	; 0
    59b2:	ee 0f       	add	r30, r30
    59b4:	ff 1f       	adc	r31, r31
    59b6:	ea 5d       	subi	r30, 0xDA	; 218
    59b8:	fc 4f       	sbci	r31, 0xFC	; 252
    59ba:	11 82       	std	Z+1, r1	; 0x01
    59bc:	10 82       	st	Z, r1
	IntOn();
}
    59be:	cf 91       	pop	r28
ResetTimer16(uint8_t TimerN)
{
	IntOff();
	Timer16Flg[TimerN/8] |=1<<TimerN%8;
	Timer16[TimerN] = 0;
	IntOn();
    59c0:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

000059c4 <OnTimeSave>:

// ~~~~~~~~~~~~~
void
OnTimeSave(void)
{
	ewb(&Timer1min_EE, Timer1min);
    59c4:	60 91 23 06 	lds	r22, 0x0623
    59c8:	85 ea       	ldi	r24, 0xA5	; 165
    59ca:	91 e0       	ldi	r25, 0x01	; 1
    59cc:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
	eww(&Timer1hour_EE, Timer1hour);
    59d0:	60 91 48 0e 	lds	r22, 0x0E48
    59d4:	70 91 49 0e 	lds	r23, 0x0E49
    59d8:	83 ea       	ldi	r24, 0xA3	; 163
    59da:	91 e0       	ldi	r25, 0x01	; 1
    59dc:	0c 94 d5 29 	jmp	0x53aa	; 0x53aa <eww>

000059e0 <TimeInit>:
		CCP = CCP_IOREG_gc; CLK.CTRL = CLK_SCLKSEL_PLL_gc;
		CCP = CCP_IOREG_gc; CLK.LOCK = CLK_LOCK_bm;
	#endif

	// WDT
	WdtOn();
    59e0:	0e 94 8d 2a 	call	0x551a	; 0x551a <WdtOn>

	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		TCCR1A = 0;
    59e4:	1f bc       	out	0x2f, r1	; 47
		TCCR1B = (((~(1<<WGM13) |(1<<WGM12)) &~(1<<CS12)) |(1<<CS11)) &~(1<<CS10);
    59e6:	8a ee       	ldi	r24, 0xEA	; 234
    59e8:	8e bd       	out	0x2e, r24	; 46
		OCR1A = 20000;
    59ea:	80 e2       	ldi	r24, 0x20	; 32
    59ec:	9e e4       	ldi	r25, 0x4E	; 78
    59ee:	9b bd       	out	0x2b, r25	; 43
    59f0:	8a bd       	out	0x2a, r24	; 42
		TCC0.CTRLB = TC_WGMODE_NORMAL_gc &~TC0_CCBEN_bm &~TC0_CCAEN_bm;
		TCC0.CTRLD = TC_EVACT_OFF_gc;
		TCC0.CTRLE = ~TC0_BYTEM_bm;
	#endif
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__)
		TIMSK |=(1<<OCIE1A);
    59f2:	87 b7       	in	r24, 0x37	; 55
    59f4:	80 61       	ori	r24, 0x10	; 16
    59f6:	87 bf       	out	0x37, r24	; 55
    59f8:	80 e0       	ldi	r24, 0x00	; 0
    59fa:	90 e0       	ldi	r25, 0x00	; 0
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
    59fc:	2f ef       	ldi	r18, 0xFF	; 255
    59fe:	fc 01       	movw	r30, r24
    5a00:	e3 58       	subi	r30, 0x83	; 131
    5a02:	fd 4f       	sbci	r31, 0xFD	; 253
    5a04:	20 83       	st	Z, r18
    5a06:	01 96       	adiw	r24, 0x01	; 1
		TCC0.INTCTRLB = 0;
	#endif

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
    5a08:	87 30       	cpi	r24, 0x07	; 7
    5a0a:	91 05       	cpc	r25, r1
    5a0c:	c1 f7       	brne	.-16     	; 0x59fe <TimeInit+0x1e>
    5a0e:	80 e0       	ldi	r24, 0x00	; 0
    5a10:	90 e0       	ldi	r25, 0x00	; 0
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
		Timer16Flg[i] = 0xFF;
    5a12:	3f ef       	ldi	r19, 0xFF	; 255
    5a14:	fc 01       	movw	r30, r24
    5a16:	ec 58       	subi	r30, 0x8C	; 140
    5a18:	fd 4f       	sbci	r31, 0xFD	; 253
    5a1a:	2f ef       	ldi	r18, 0xFF	; 255
    5a1c:	30 83       	st	Z, r19
    5a1e:	01 96       	adiw	r24, 0x01	; 1

	// Program timers (10 ms)
	uint8_t i;
	for (i=0; i<sizeof(Timer8Flg); i++)
		Timer8Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer16Flg); i++)
    5a20:	89 30       	cpi	r24, 0x09	; 9
    5a22:	91 05       	cpc	r25, r1
    5a24:	b9 f7       	brne	.-18     	; 0x5a14 <TimeInit+0x34>
		Timer16Flg[i] = 0xFF;
	for (i=0; i<sizeof(Timer32Flg); i++)
		Timer32Flg[i] = 0xFF;
    5a26:	20 93 6e 02 	sts	0x026E, r18
    5a2a:	20 93 6f 02 	sts	0x026F, r18
    5a2e:	20 93 70 02 	sts	0x0270, r18
    5a32:	20 93 71 02 	sts	0x0271, r18
    5a36:	20 93 72 02 	sts	0x0272, r18
    5a3a:	20 93 73 02 	sts	0x0273, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5a3e:	85 ea       	ldi	r24, 0xA5	; 165
    5a40:	91 e0       	ldi	r25, 0x01	; 1
    5a42:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>

	// 1 s
	Timer1min = erb(&Timer1min_EE);
    5a46:	80 93 23 06 	sts	0x0623, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    5a4a:	83 ea       	ldi	r24, 0xA3	; 163
    5a4c:	91 e0       	ldi	r25, 0x01	; 1
    5a4e:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	Timer1hour = erw(&Timer1hour_EE);
    5a52:	90 93 49 0e 	sts	0x0E49, r25
    5a56:	80 93 48 0e 	sts	0x0E48, r24
    5a5a:	08 95       	ret

00005a5c <ScanCycleInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    5a5c:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    5a60:	91 e0       	ldi	r25, 0x01	; 1
    5a62:	98 0f       	add	r25, r24
    5a64:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~~~~
void
ScanCycleInit(void)
{
	TD_Scan = Timer8SysAlloc(1);
    5a68:	80 93 6d 02 	sts	0x026D, r24
	StartTimer8(TD_Scan, 0xFF);
    5a6c:	6f ef       	ldi	r22, 0xFF	; 255
    5a6e:	0c 94 a6 2a 	jmp	0x554c	; 0x554c <StartTimer8>

00005a72 <__vector_12>:
#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
	ISR(TIMER1_COMPA_vect)
#elif defined (__AVR_ATxmega128A1__)
	ISR(TCC0_OVF_vect)
#endif
{
    5a72:	1f 92       	push	r1
    5a74:	0f 92       	push	r0
    5a76:	0f b6       	in	r0, 0x3f	; 63
    5a78:	0f 92       	push	r0
    5a7a:	11 24       	eor	r1, r1
    5a7c:	0b b6       	in	r0, 0x3b	; 59
    5a7e:	0f 92       	push	r0
    5a80:	2f 93       	push	r18
    5a82:	3f 93       	push	r19
    5a84:	4f 93       	push	r20
    5a86:	5f 93       	push	r21
    5a88:	6f 93       	push	r22
    5a8a:	8f 93       	push	r24
    5a8c:	9f 93       	push	r25
    5a8e:	ef 93       	push	r30
    5a90:	ff 93       	push	r31
	TickCounter++;
    5a92:	80 91 6c 02 	lds	r24, 0x026C
    5a96:	8f 5f       	subi	r24, 0xFF	; 255
    5a98:	80 93 6c 02 	sts	0x026C, r24
    5a9c:	80 e0       	ldi	r24, 0x00	; 0
    5a9e:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5aa0:	41 e0       	ldi	r20, 0x01	; 1
    5aa2:	50 e0       	ldi	r21, 0x00	; 0
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
			if (!(Timer8_ISR_Flg[i/8] &(1<<i%8)) && --Timer8_ISR[i]==0)
    5aa4:	20 91 84 02 	lds	r18, 0x0284
    5aa8:	30 e0       	ldi	r19, 0x00	; 0
    5aaa:	08 2e       	mov	r0, r24
    5aac:	02 c0       	rjmp	.+4      	; 0x5ab2 <__vector_12+0x40>
    5aae:	35 95       	asr	r19
    5ab0:	27 95       	ror	r18
    5ab2:	0a 94       	dec	r0
    5ab4:	e2 f7       	brpl	.-8      	; 0x5aae <__vector_12+0x3c>
    5ab6:	20 fd       	sbrc	r18, 0
    5ab8:	13 c0       	rjmp	.+38     	; 0x5ae0 <__vector_12+0x6e>
    5aba:	fc 01       	movw	r30, r24
    5abc:	ea 52       	subi	r30, 0x2A	; 42
    5abe:	fc 4f       	sbci	r31, 0xFC	; 252
    5ac0:	20 81       	ld	r18, Z
    5ac2:	21 50       	subi	r18, 0x01	; 1
    5ac4:	20 83       	st	Z, r18
    5ac6:	21 11       	cpse	r18, r1
    5ac8:	0b c0       	rjmp	.+22     	; 0x5ae0 <__vector_12+0x6e>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);
    5aca:	60 91 84 02 	lds	r22, 0x0284
    5ace:	9a 01       	movw	r18, r20
    5ad0:	08 2e       	mov	r0, r24
    5ad2:	01 c0       	rjmp	.+2      	; 0x5ad6 <__vector_12+0x64>
    5ad4:	22 0f       	add	r18, r18
    5ad6:	0a 94       	dec	r0
    5ad8:	ea f7       	brpl	.-6      	; 0x5ad4 <__vector_12+0x62>
    5ada:	62 2b       	or	r22, r18
    5adc:	60 93 84 02 	sts	0x0284, r22
    5ae0:	01 96       	adiw	r24, 0x01	; 1
	ISR(TCC0_OVF_vect)
#endif
{
	TickCounter++;
	uint8_t i;
	for (i=0; i<Timer8_ISR_TotNumber; i++)
    5ae2:	88 30       	cpi	r24, 0x08	; 8
    5ae4:	91 05       	cpc	r25, r1
    5ae6:	f1 f6       	brne	.-68     	; 0x5aa4 <__vector_12+0x32>
				Timer8_ISR_Flg[i/8] |=(1<<i%8);

	#ifdef HIGH_SPEED_COUNTER
		HSC_Process();
	#endif
}
    5ae8:	ff 91       	pop	r31
    5aea:	ef 91       	pop	r30
    5aec:	9f 91       	pop	r25
    5aee:	8f 91       	pop	r24
    5af0:	6f 91       	pop	r22
    5af2:	5f 91       	pop	r21
    5af4:	4f 91       	pop	r20
    5af6:	3f 91       	pop	r19
    5af8:	2f 91       	pop	r18
    5afa:	0f 90       	pop	r0
    5afc:	0b be       	out	0x3b, r0	; 59
    5afe:	0f 90       	pop	r0
    5b00:	0f be       	out	0x3f, r0	; 63
    5b02:	0f 90       	pop	r0
    5b04:	1f 90       	pop	r1
    5b06:	18 95       	reti

00005b08 <TimersInc>:
void 
TimersInc(void)
{
    5b08:	ef 92       	push	r14
    5b0a:	ff 92       	push	r15
    5b0c:	0f 93       	push	r16
    5b0e:	1f 93       	push	r17
    5b10:	cf 93       	push	r28
    5b12:	df 93       	push	r29
	uint8_t i, TickCounterVar;	
	cli();
    5b14:	f8 94       	cli
	TickCounterVar = TickCounter;
    5b16:	00 91 6c 02 	lds	r16, 0x026C
	TickCounter = 0;
    5b1a:	10 92 6c 02 	sts	0x026C, r1
	sei();
    5b1e:	78 94       	sei
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b20:	10 e0       	ldi	r17, 0x00	; 0
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
    5b22:	ee 24       	eor	r14, r14
    5b24:	e3 94       	inc	r14
    5b26:	f1 2c       	mov	r15, r1
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5b28:	10 17       	cp	r17, r16
    5b2a:	09 f4       	brne	.+2      	; 0x5b2e <TimersInc+0x26>
    5b2c:	e2 c0       	rjmp	.+452    	; 0x5cf2 <TimersInc+0x1ea>
		LiveTime++;
    5b2e:	80 91 63 09 	lds	r24, 0x0963
    5b32:	90 91 64 09 	lds	r25, 0x0964
    5b36:	a0 91 65 09 	lds	r26, 0x0965
    5b3a:	b0 91 66 09 	lds	r27, 0x0966
    5b3e:	01 96       	adiw	r24, 0x01	; 1
    5b40:	a1 1d       	adc	r26, r1
    5b42:	b1 1d       	adc	r27, r1
    5b44:	80 93 63 09 	sts	0x0963, r24
    5b48:	90 93 64 09 	sts	0x0964, r25
    5b4c:	a0 93 65 09 	sts	0x0965, r26
    5b50:	b0 93 66 09 	sts	0x0966, r27
    5b54:	80 e0       	ldi	r24, 0x00	; 0
    5b56:	90 e0       	ldi	r25, 0x00	; 0
	 	for (i=0; i<Timer8TotNumber; i++){
			cli();
    5b58:	f8 94       	cli
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
    5b5a:	e8 2f       	mov	r30, r24
    5b5c:	e6 95       	lsr	r30
    5b5e:	e6 95       	lsr	r30
    5b60:	e6 95       	lsr	r30
    5b62:	f0 e0       	ldi	r31, 0x00	; 0
    5b64:	e3 58       	subi	r30, 0x83	; 131
    5b66:	fd 4f       	sbci	r31, 0xFD	; 253
    5b68:	20 81       	ld	r18, Z
    5b6a:	58 2f       	mov	r21, r24
    5b6c:	57 70       	andi	r21, 0x07	; 7
    5b6e:	30 e0       	ldi	r19, 0x00	; 0
    5b70:	05 2e       	mov	r0, r21
    5b72:	02 c0       	rjmp	.+4      	; 0x5b78 <TimersInc+0x70>
    5b74:	35 95       	asr	r19
    5b76:	27 95       	ror	r18
    5b78:	0a 94       	dec	r0
    5b7a:	e2 f7       	brpl	.-8      	; 0x5b74 <TimersInc+0x6c>
    5b7c:	20 fd       	sbrc	r18, 0
    5b7e:	11 c0       	rjmp	.+34     	; 0x5ba2 <TimersInc+0x9a>
    5b80:	dc 01       	movw	r26, r24
    5b82:	aa 55       	subi	r26, 0x5A	; 90
    5b84:	bc 4f       	sbci	r27, 0xFC	; 252
    5b86:	3c 91       	ld	r19, X
    5b88:	31 50       	subi	r19, 0x01	; 1
    5b8a:	3c 93       	st	X, r19
    5b8c:	31 11       	cpse	r19, r1
    5b8e:	09 c0       	rjmp	.+18     	; 0x5ba2 <TimersInc+0x9a>
				Timer8Flg[i/8] |=(1<<i%8);
    5b90:	40 81       	ld	r20, Z
    5b92:	97 01       	movw	r18, r14
    5b94:	05 2e       	mov	r0, r21
    5b96:	01 c0       	rjmp	.+2      	; 0x5b9a <TimersInc+0x92>
    5b98:	22 0f       	add	r18, r18
    5b9a:	0a 94       	dec	r0
    5b9c:	ea f7       	brpl	.-6      	; 0x5b98 <TimersInc+0x90>
    5b9e:	42 2b       	or	r20, r18
    5ba0:	40 83       	st	Z, r20
			sei();
    5ba2:	78 94       	sei
    5ba4:	01 96       	adiw	r24, 0x01	; 1
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
		LiveTime++;
	 	for (i=0; i<Timer8TotNumber; i++){
    5ba6:	80 33       	cpi	r24, 0x30	; 48
    5ba8:	91 05       	cpc	r25, r1
    5baa:	b1 f6       	brne	.-84     	; 0x5b58 <TimersInc+0x50>
    5bac:	80 e0       	ldi	r24, 0x00	; 0
    5bae:	90 e0       	ldi	r25, 0x00	; 0
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
			cli();
    5bb0:	f8 94       	cli
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
    5bb2:	e8 2f       	mov	r30, r24
    5bb4:	e6 95       	lsr	r30
    5bb6:	e6 95       	lsr	r30
    5bb8:	e6 95       	lsr	r30
    5bba:	f0 e0       	ldi	r31, 0x00	; 0
    5bbc:	ec 58       	subi	r30, 0x8C	; 140
    5bbe:	fd 4f       	sbci	r31, 0xFD	; 253
    5bc0:	20 81       	ld	r18, Z
    5bc2:	58 2f       	mov	r21, r24
    5bc4:	57 70       	andi	r21, 0x07	; 7
    5bc6:	30 e0       	ldi	r19, 0x00	; 0
    5bc8:	05 2e       	mov	r0, r21
    5bca:	02 c0       	rjmp	.+4      	; 0x5bd0 <TimersInc+0xc8>
    5bcc:	35 95       	asr	r19
    5bce:	27 95       	ror	r18
    5bd0:	0a 94       	dec	r0
    5bd2:	e2 f7       	brpl	.-8      	; 0x5bcc <TimersInc+0xc4>
    5bd4:	20 fd       	sbrc	r18, 0
    5bd6:	18 c0       	rjmp	.+48     	; 0x5c08 <TimersInc+0x100>
    5bd8:	dc 01       	movw	r26, r24
    5bda:	aa 0f       	add	r26, r26
    5bdc:	bb 1f       	adc	r27, r27
    5bde:	aa 5d       	subi	r26, 0xDA	; 218
    5be0:	bc 4f       	sbci	r27, 0xFC	; 252
    5be2:	2d 91       	ld	r18, X+
    5be4:	3c 91       	ld	r19, X
    5be6:	11 97       	sbiw	r26, 0x01	; 1
    5be8:	21 50       	subi	r18, 0x01	; 1
    5bea:	31 09       	sbc	r19, r1
    5bec:	11 96       	adiw	r26, 0x01	; 1
    5bee:	3c 93       	st	X, r19
    5bf0:	2e 93       	st	-X, r18
    5bf2:	23 2b       	or	r18, r19
    5bf4:	49 f4       	brne	.+18     	; 0x5c08 <TimersInc+0x100>
				Timer16Flg[i/8] |=(1<<i%8);
    5bf6:	40 81       	ld	r20, Z
    5bf8:	97 01       	movw	r18, r14
    5bfa:	05 2e       	mov	r0, r21
    5bfc:	01 c0       	rjmp	.+2      	; 0x5c00 <TimersInc+0xf8>
    5bfe:	22 0f       	add	r18, r18
    5c00:	0a 94       	dec	r0
    5c02:	ea f7       	brpl	.-6      	; 0x5bfe <TimersInc+0xf6>
    5c04:	42 2b       	or	r20, r18
    5c06:	40 83       	st	Z, r20
			sei();
    5c08:	78 94       	sei
    5c0a:	01 96       	adiw	r24, 0x01	; 1
			cli();
			if (!(Timer8Flg[i/8] &(1<<i%8)) && --Timer8[i]==0)
				Timer8Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer16TotNumber; i++){
    5c0c:	80 34       	cpi	r24, 0x40	; 64
    5c0e:	91 05       	cpc	r25, r1
    5c10:	79 f6       	brne	.-98     	; 0x5bb0 <TimersInc+0xa8>
    5c12:	20 e0       	ldi	r18, 0x00	; 0
    5c14:	30 e0       	ldi	r19, 0x00	; 0
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
			cli();
    5c16:	f8 94       	cli
			if (!(Timer32Flg[i/8] &(1<<i%8)) && --Timer32[i]==0)
    5c18:	e2 2f       	mov	r30, r18
    5c1a:	e6 95       	lsr	r30
    5c1c:	e6 95       	lsr	r30
    5c1e:	e6 95       	lsr	r30
    5c20:	f0 e0       	ldi	r31, 0x00	; 0
    5c22:	e2 59       	subi	r30, 0x92	; 146
    5c24:	fd 4f       	sbci	r31, 0xFD	; 253
    5c26:	80 81       	ld	r24, Z
    5c28:	62 2f       	mov	r22, r18
    5c2a:	67 70       	andi	r22, 0x07	; 7
    5c2c:	90 e0       	ldi	r25, 0x00	; 0
    5c2e:	06 2e       	mov	r0, r22
    5c30:	02 c0       	rjmp	.+4      	; 0x5c36 <TimersInc+0x12e>
    5c32:	95 95       	asr	r25
    5c34:	87 95       	ror	r24
    5c36:	0a 94       	dec	r0
    5c38:	e2 f7       	brpl	.-8      	; 0x5c32 <TimersInc+0x12a>
    5c3a:	80 fd       	sbrc	r24, 0
    5c3c:	20 c0       	rjmp	.+64     	; 0x5c7e <TimersInc+0x176>
    5c3e:	a9 01       	movw	r20, r18
    5c40:	44 0f       	add	r20, r20
    5c42:	55 1f       	adc	r21, r21
    5c44:	44 0f       	add	r20, r20
    5c46:	55 1f       	adc	r21, r21
    5c48:	4a 57       	subi	r20, 0x7A	; 122
    5c4a:	5d 4f       	sbci	r21, 0xFD	; 253
    5c4c:	ea 01       	movw	r28, r20
    5c4e:	88 81       	ld	r24, Y
    5c50:	99 81       	ldd	r25, Y+1	; 0x01
    5c52:	aa 81       	ldd	r26, Y+2	; 0x02
    5c54:	bb 81       	ldd	r27, Y+3	; 0x03
    5c56:	01 97       	sbiw	r24, 0x01	; 1
    5c58:	a1 09       	sbc	r26, r1
    5c5a:	b1 09       	sbc	r27, r1
    5c5c:	88 83       	st	Y, r24
    5c5e:	99 83       	std	Y+1, r25	; 0x01
    5c60:	aa 83       	std	Y+2, r26	; 0x02
    5c62:	bb 83       	std	Y+3, r27	; 0x03
    5c64:	89 2b       	or	r24, r25
    5c66:	8a 2b       	or	r24, r26
    5c68:	8b 2b       	or	r24, r27
    5c6a:	49 f4       	brne	.+18     	; 0x5c7e <TimersInc+0x176>
				Timer32Flg[i/8] |=(1<<i%8);	
    5c6c:	40 81       	ld	r20, Z
    5c6e:	c7 01       	movw	r24, r14
    5c70:	06 2e       	mov	r0, r22
    5c72:	01 c0       	rjmp	.+2      	; 0x5c76 <TimersInc+0x16e>
    5c74:	88 0f       	add	r24, r24
    5c76:	0a 94       	dec	r0
    5c78:	ea f7       	brpl	.-6      	; 0x5c74 <TimersInc+0x16c>
    5c7a:	48 2b       	or	r20, r24
    5c7c:	40 83       	st	Z, r20
			sei();
    5c7e:	78 94       	sei
    5c80:	2f 5f       	subi	r18, 0xFF	; 255
    5c82:	3f 4f       	sbci	r19, 0xFF	; 255
			cli();
			if (!(Timer16Flg[i/8] &(1<<i%8)) && --Timer16[i]==0)
				Timer16Flg[i/8] |=(1<<i%8);
			sei();
		}
		for (i=0; i<Timer32TotNumber; i++){
    5c84:	28 32       	cpi	r18, 0x28	; 40
    5c86:	31 05       	cpc	r19, r1
    5c88:	31 f6       	brne	.-116    	; 0x5c16 <TimersInc+0x10e>
			sei();
		}

		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		static uint8_t Timer10ms;
		if (++Timer10ms==100) {
    5c8a:	80 91 45 02 	lds	r24, 0x0245
    5c8e:	8f 5f       	subi	r24, 0xFF	; 255
    5c90:	80 93 45 02 	sts	0x0245, r24
    5c94:	84 36       	cpi	r24, 0x64	; 100
    5c96:	59 f5       	brne	.+86     	; 0x5cee <TimersInc+0x1e6>
			Timer10ms = 0;
    5c98:	10 92 45 02 	sts	0x0245, r1
			ScanPerSec = ScanCount;
    5c9c:	80 91 45 09 	lds	r24, 0x0945
    5ca0:	90 91 46 09 	lds	r25, 0x0946
    5ca4:	90 93 72 09 	sts	0x0972, r25
    5ca8:	80 93 71 09 	sts	0x0971, r24
 			ScanCount = 0;
    5cac:	10 92 46 09 	sts	0x0946, r1
    5cb0:	10 92 45 09 	sts	0x0945, r1

// ~~~~~~~~~~~~~~~
inline static void
RT(void)
{
	if (++Timer1s==60) {
    5cb4:	80 91 0e 0b 	lds	r24, 0x0B0E
    5cb8:	8f 5f       	subi	r24, 0xFF	; 255
    5cba:	80 93 0e 0b 	sts	0x0B0E, r24
    5cbe:	8c 33       	cpi	r24, 0x3C	; 60
    5cc0:	b1 f4       	brne	.+44     	; 0x5cee <TimersInc+0x1e6>
		Timer1s = 0;
    5cc2:	10 92 0e 0b 	sts	0x0B0E, r1
		if (++Timer1min==60) {
    5cc6:	80 91 23 06 	lds	r24, 0x0623
    5cca:	8f 5f       	subi	r24, 0xFF	; 255
    5ccc:	80 93 23 06 	sts	0x0623, r24
    5cd0:	8c 33       	cpi	r24, 0x3C	; 60
    5cd2:	69 f4       	brne	.+26     	; 0x5cee <TimersInc+0x1e6>
			Timer1min = 0;
    5cd4:	10 92 23 06 	sts	0x0623, r1
			++Timer1hour;
    5cd8:	80 91 48 0e 	lds	r24, 0x0E48
    5cdc:	90 91 49 0e 	lds	r25, 0x0E49
    5ce0:	01 96       	adiw	r24, 0x01	; 1
    5ce2:	90 93 49 0e 	sts	0x0E49, r25
    5ce6:	80 93 48 0e 	sts	0x0E48, r24
			OnTimeSave();
    5cea:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <OnTimeSave>
	uint8_t i, TickCounterVar;	
	cli();
	TickCounterVar = TickCounter;
	TickCounter = 0;
	sei();
	for(uint8_t j=0;j<TickCounterVar;j++){
    5cee:	1f 5f       	subi	r17, 0xFF	; 255
    5cf0:	1b cf       	rjmp	.-458    	; 0x5b28 <TimersInc+0x20>
 			ScanCount = 0;
			RT();
		}
		#endif
	}
}
    5cf2:	df 91       	pop	r29
    5cf4:	cf 91       	pop	r28
    5cf6:	1f 91       	pop	r17
    5cf8:	0f 91       	pop	r16
    5cfa:	ff 90       	pop	r15
    5cfc:	ef 90       	pop	r14
    5cfe:	08 95       	ret

00005d00 <TimeCycle>:
// ~~~~~~~~~~~~
void
TimeCycle(void)
{
	// WDT
	wdt_reset();
    5d00:	a8 95       	wdr

	// Scan cycle
	ScanCount++;
    5d02:	80 91 45 09 	lds	r24, 0x0945
    5d06:	90 91 46 09 	lds	r25, 0x0946
    5d0a:	01 96       	adiw	r24, 0x01	; 1
    5d0c:	90 93 46 09 	sts	0x0946, r25
    5d10:	80 93 45 09 	sts	0x0945, r24
	if ((ScanCycle=0xFF-Timer8[TD_Scan])>MaxScanCycle)
    5d14:	80 91 6d 02 	lds	r24, 0x026D
    5d18:	e8 2f       	mov	r30, r24
    5d1a:	f0 e0       	ldi	r31, 0x00	; 0
    5d1c:	ea 55       	subi	r30, 0x5A	; 90
    5d1e:	fc 4f       	sbci	r31, 0xFC	; 252
    5d20:	90 81       	ld	r25, Z
    5d22:	90 95       	com	r25
    5d24:	90 93 3e 09 	sts	0x093E, r25
    5d28:	20 91 24 06 	lds	r18, 0x0624
    5d2c:	29 17       	cp	r18, r25
    5d2e:	10 f4       	brcc	.+4      	; 0x5d34 <TimeCycle+0x34>
		MaxScanCycle = ScanCycle;
    5d30:	90 93 24 06 	sts	0x0624, r25
	StartTimer8(TD_Scan, 0xFF);
    5d34:	6f ef       	ldi	r22, 0xFF	; 255
    5d36:	0c 94 a6 2a 	jmp	0x554c	; 0x554c <StartTimer8>

00005d3a <Delay_us>:
{
	/*uint8_t i;
	for(i=Delay/Delay_us_Max; i; i--)
		_delay_us(Delay_us_Max);*/
	//_delay_us(Delay%Delay_us_Max);
	Delay *= .8;	// By trial
    5d3a:	bc 01       	movw	r22, r24
    5d3c:	80 e0       	ldi	r24, 0x00	; 0
    5d3e:	90 e0       	ldi	r25, 0x00	; 0
    5d40:	0e 94 2a 6e 	call	0xdc54	; 0xdc54 <__floatunsisf>
    5d44:	2d ec       	ldi	r18, 0xCD	; 205
    5d46:	3c ec       	ldi	r19, 0xCC	; 204
    5d48:	4c e4       	ldi	r20, 0x4C	; 76
    5d4a:	5f e3       	ldi	r21, 0x3F	; 63
    5d4c:	0e 94 b8 6e 	call	0xdd70	; 0xdd70 <__mulsf3>
    5d50:	0e 94 fe 6d 	call	0xdbfc	; 0xdbfc <__fixunssfsi>
	while (Delay--)
    5d54:	61 15       	cp	r22, r1
    5d56:	71 05       	cpc	r23, r1
    5d58:	39 f0       	breq	.+14     	; 0x5d68 <Delay_us+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5d5a:	85 e0       	ldi	r24, 0x05	; 5
    5d5c:	8a 95       	dec	r24
    5d5e:	f1 f7       	brne	.-4      	; 0x5d5c <Delay_us+0x22>
    5d60:	00 00       	nop
    5d62:	61 50       	subi	r22, 0x01	; 1
    5d64:	71 09       	sbc	r23, r1
    5d66:	f6 cf       	rjmp	.-20     	; 0x5d54 <Delay_us+0x1a>
		_delay_us(1);
}
    5d68:	08 95       	ret

00005d6a <MB_PLC_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void MB_PLC_Init(void)
{
	// RS485
	DDRD |=(1<<PD4); PORTD &=~(1<<PD4);
    5d6a:	8c 9a       	sbi	0x11, 4	; 17
    5d6c:	94 98       	cbi	0x12, 4	; 18
    5d6e:	08 95       	ret

00005d70 <OW_MasterPullLowBus>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define TerReg 1

//~~~~~~~~~~~~~
void OW_MasterPullLowBus(uint8_t CH){
	switch(CH){
    5d70:	81 11       	cpse	r24, r1
    5d72:	0a c0       	rjmp	.+20     	; 0x5d88 <OW_MasterPullLowBus+0x18>
//		case 0: DDRF |= (1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG |= (1<<PG0);
    5d74:	80 91 64 00 	lds	r24, 0x0064
    5d78:	81 60       	ori	r24, 0x01	; 1
    5d7a:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d7e:	80 91 65 00 	lds	r24, 0x0065
    5d82:	8e 7f       	andi	r24, 0xFE	; 254
    5d84:	80 93 65 00 	sts	0x0065, r24
    5d88:	08 95       	ret

00005d8a <OW_MasterReleaseBus>:
				break;
	}
}
//~~~~~~~~~~~~~
void OW_MasterReleaseBus(uint8_t CH){
	switch(CH){
    5d8a:	81 11       	cpse	r24, r1
    5d8c:	0a c0       	rjmp	.+20     	; 0x5da2 <OW_MasterReleaseBus+0x18>
//		case 0: DDRF &= ~(1<<PF2);
//				PORTF &= ~(1<<PF2);
		case 0: DDRG &= ~(1<<PG0);
    5d8e:	80 91 64 00 	lds	r24, 0x0064
    5d92:	8e 7f       	andi	r24, 0xFE	; 254
    5d94:	80 93 64 00 	sts	0x0064, r24
				PORTG &= ~(1<<PG0);
    5d98:	80 91 65 00 	lds	r24, 0x0065
    5d9c:	8e 7f       	andi	r24, 0xFE	; 254
    5d9e:	80 93 65 00 	sts	0x0065, r24
    5da2:	08 95       	ret

00005da4 <GSM_PWRCNTRL_Config>:
// ~~~~~~~~~~~~~~~

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Add hardware turn on, 
void GSM_PWRCNTRL_Config(void){
	cli();
    5da4:	f8 94       	cli
	//DDRD|=(1<<PD6);
	DDRE|=(1<<PE7);
    5da6:	17 9a       	sbi	0x02, 7	; 2
	sei();
    5da8:	78 94       	sei
    5daa:	08 95       	ret

00005dac <GSM_PWRCNTRL_OFF>:
}
void GSM_PWRCNTRL_OFF(void){
	cli();
    5dac:	f8 94       	cli
	//PORTD &= ~(1<<PD6);
	PORTE &= ~(1<<PE7);
    5dae:	1f 98       	cbi	0x03, 7	; 3
	sei();
    5db0:	78 94       	sei
    5db2:	08 95       	ret

00005db4 <GSM_PWRCNTRL_ON>:
}
void GSM_PWRCNTRL_ON(void){
	cli();
    5db4:	f8 94       	cli
	//PORTD|=(1<<PD6);
	PORTE|=(1<<PE7);
    5db6:	1f 9a       	sbi	0x03, 7	; 3
	sei();
    5db8:	78 94       	sei
    5dba:	08 95       	ret

00005dbc <CTS_Config>:
// For electrometer.h

#define CTS

void CTS_Config(void){
	DDRD|=(1<<PD5);
    5dbc:	8d 9a       	sbi	0x11, 5	; 17
    5dbe:	08 95       	ret

00005dc0 <CTS_OFF>:
}
void CTS_OFF(void){
	PORTD &= ~(1<<PD5);
    5dc0:	95 98       	cbi	0x12, 5	; 18
    5dc2:	08 95       	ret

00005dc4 <RTS_Config>:

//----
#define RTS

void RTS_Config(void){
	DDRD &= ~(1<<PD6);
    5dc4:	8e 98       	cbi	0x11, 6	; 17
	PORTD |= (1<<PD6);	//pull'up
    5dc6:	96 9a       	sbi	0x12, 6	; 18
    5dc8:	08 95       	ret

00005dca <__vector_15>:
}
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#elif defined (__AVR_ATmega128__)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ISR(TIMER0_COMP_vect)
{
    5dca:	1f 92       	push	r1
    5dcc:	0f 92       	push	r0
    5dce:	0f b6       	in	r0, 0x3f	; 63
    5dd0:	0f 92       	push	r0
    5dd2:	11 24       	eor	r1, r1
    5dd4:	0b b6       	in	r0, 0x3b	; 59
    5dd6:	0f 92       	push	r0
    5dd8:	2f 93       	push	r18
    5dda:	3f 93       	push	r19
    5ddc:	4f 93       	push	r20
    5dde:	5f 93       	push	r21
    5de0:	6f 93       	push	r22
    5de2:	7f 93       	push	r23
    5de4:	8f 93       	push	r24
    5de6:	9f 93       	push	r25
    5de8:	af 93       	push	r26
    5dea:	bf 93       	push	r27
    5dec:	ef 93       	push	r30
    5dee:	ff 93       	push	r31
	TCCR0 &=~(1<<CS02) &~(1<<CS01) &~(1<<CS00);
    5df0:	83 b7       	in	r24, 0x33	; 51
    5df2:	88 7f       	andi	r24, 0xF8	; 248
    5df4:	83 bf       	out	0x33, r24	; 51
	TIMSK &=~(1<<OCIE0);
    5df6:	87 b7       	in	r24, 0x37	; 55
    5df8:	8d 7f       	andi	r24, 0xFD	; 253
    5dfa:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT0);
    5dfc:	82 e5       	ldi	r24, 0x52	; 82
    5dfe:	90 e0       	ldi	r25, 0x00	; 0
    5e00:	0e 94 3c 28 	call	0x5078	; 0x5078 <MB_Timer_ISR>
}
    5e04:	ff 91       	pop	r31
    5e06:	ef 91       	pop	r30
    5e08:	bf 91       	pop	r27
    5e0a:	af 91       	pop	r26
    5e0c:	9f 91       	pop	r25
    5e0e:	8f 91       	pop	r24
    5e10:	7f 91       	pop	r23
    5e12:	6f 91       	pop	r22
    5e14:	5f 91       	pop	r21
    5e16:	4f 91       	pop	r20
    5e18:	3f 91       	pop	r19
    5e1a:	2f 91       	pop	r18
    5e1c:	0f 90       	pop	r0
    5e1e:	0b be       	out	0x3b, r0	; 59
    5e20:	0f 90       	pop	r0
    5e22:	0f be       	out	0x3f, r0	; 63
    5e24:	0f 90       	pop	r0
    5e26:	1f 90       	pop	r1
    5e28:	18 95       	reti

00005e2a <__vector_9>:

// ~~~~~~~~~~~~~~~~~~
ISR(TIMER2_COMP_vect)
{
    5e2a:	1f 92       	push	r1
    5e2c:	0f 92       	push	r0
    5e2e:	0f b6       	in	r0, 0x3f	; 63
    5e30:	0f 92       	push	r0
    5e32:	11 24       	eor	r1, r1
    5e34:	0b b6       	in	r0, 0x3b	; 59
    5e36:	0f 92       	push	r0
    5e38:	2f 93       	push	r18
    5e3a:	3f 93       	push	r19
    5e3c:	4f 93       	push	r20
    5e3e:	5f 93       	push	r21
    5e40:	6f 93       	push	r22
    5e42:	7f 93       	push	r23
    5e44:	8f 93       	push	r24
    5e46:	9f 93       	push	r25
    5e48:	af 93       	push	r26
    5e4a:	bf 93       	push	r27
    5e4c:	ef 93       	push	r30
    5e4e:	ff 93       	push	r31
	TCCR2 &=~(1<<CS22) &~(1<<CS21) &~(1<<CS20);
    5e50:	85 b5       	in	r24, 0x25	; 37
    5e52:	88 7f       	andi	r24, 0xF8	; 248
    5e54:	85 bd       	out	0x25, r24	; 37
	TIMSK &=~(1<<OCIE2);
    5e56:	87 b7       	in	r24, 0x37	; 55
    5e58:	8f 77       	andi	r24, 0x7F	; 127
    5e5a:	87 bf       	out	0x37, r24	; 55
	MB_Timer_ISR(&TCNT2);
    5e5c:	84 e4       	ldi	r24, 0x44	; 68
    5e5e:	90 e0       	ldi	r25, 0x00	; 0
    5e60:	0e 94 3c 28 	call	0x5078	; 0x5078 <MB_Timer_ISR>
}
    5e64:	ff 91       	pop	r31
    5e66:	ef 91       	pop	r30
    5e68:	bf 91       	pop	r27
    5e6a:	af 91       	pop	r26
    5e6c:	9f 91       	pop	r25
    5e6e:	8f 91       	pop	r24
    5e70:	7f 91       	pop	r23
    5e72:	6f 91       	pop	r22
    5e74:	5f 91       	pop	r21
    5e76:	4f 91       	pop	r20
    5e78:	3f 91       	pop	r19
    5e7a:	2f 91       	pop	r18
    5e7c:	0f 90       	pop	r0
    5e7e:	0b be       	out	0x3b, r0	; 59
    5e80:	0f 90       	pop	r0
    5e82:	0f be       	out	0x3f, r0	; 63
    5e84:	0f 90       	pop	r0
    5e86:	1f 90       	pop	r1
    5e88:	18 95       	reti

00005e8a <SetParity>:
// ~~~

// ~~~~~~~~~~~~~~~~~~~~
void
SetParity(uint8_t MB_N)
{
    5e8a:	ff 92       	push	r15
    5e8c:	0f 93       	push	r16
    5e8e:	1f 93       	push	r17
    5e90:	cf 93       	push	r28
    5e92:	df 93       	push	r29
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
    5e94:	08 2f       	mov	r16, r24
    5e96:	10 e0       	ldi	r17, 0x00	; 0
    5e98:	e8 01       	movw	r28, r16
    5e9a:	cc 0f       	add	r28, r28
    5e9c:	dd 1f       	adc	r29, r29
    5e9e:	c0 0f       	add	r28, r16
    5ea0:	d1 1f       	adc	r29, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5ea2:	ce 01       	movw	r24, r28
    5ea4:	81 56       	subi	r24, 0x61	; 97
    5ea6:	9e 4f       	sbci	r25, 0xFE	; 254
    5ea8:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    5eac:	f8 2e       	mov	r15, r24
    5eae:	c0 56       	subi	r28, 0x60	; 96
    5eb0:	de 4f       	sbci	r29, 0xFE	; 254
    5eb2:	ce 01       	movw	r24, r28
    5eb4:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
    5eb8:	f1 10       	cpse	r15, r1
    5eba:	04 c0       	rjmp	.+8      	; 0x5ec4 <SetParity+0x3a>
			ucsrc &=~(1<<5) &~(1<<4);
			switch (S_B) {
    5ebc:	81 30       	cpi	r24, 0x01	; 1
    5ebe:	39 f4       	brne	.+14     	; 0x5ece <SetParity+0x44>
			case 1:
				ucsrc &=~(1<<3);
    5ec0:	96 e8       	ldi	r25, 0x86	; 134
    5ec2:	08 c0       	rjmp	.+16     	; 0x5ed4 <SetParity+0x4a>
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
			switch (Parity) {
    5ec4:	91 e0       	ldi	r25, 0x01	; 1
    5ec6:	f9 12       	cpse	r15, r25
    5ec8:	04 c0       	rjmp	.+8      	; 0x5ed2 <SetParity+0x48>
			case EvenParity:
				ucsrc = (ucsrc |(1<<5)) &~(1<<4);
    5eca:	96 ea       	ldi	r25, 0xA6	; 166
    5ecc:	03 c0       	rjmp	.+6      	; 0x5ed4 <SetParity+0x4a>
{
	uint8_t Parity = erb(&MB_Param[MB_N].Parity), S_B = erb(&MB_Param[MB_N].StopBits);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		uint8_t ucsrc = (~(1<<6) |(1<<2) |(1<<1)) &~(1<<0);
		if (Parity==NoParity) {
			ucsrc &=~(1<<5) &~(1<<4);
    5ece:	9e e8       	ldi	r25, 0x8E	; 142
    5ed0:	01 c0       	rjmp	.+2      	; 0x5ed4 <SetParity+0x4a>
				ucsrc  |=(1<<3);
				break;
			}
		}
		else {
			ucsrc &=~(1<<3);
    5ed2:	96 eb       	ldi	r25, 0xB6	; 182
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__)
			ucsrc  |=(1<<7);
		#elif defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			ucsrc &=~(1<<7);
		#endif
		USART_Reg(MB_N, ucsrc) = ucsrc;
    5ed4:	24 e1       	ldi	r18, 0x14	; 20
    5ed6:	20 9f       	mul	r18, r16
    5ed8:	f0 01       	movw	r30, r0
    5eda:	21 9f       	mul	r18, r17
    5edc:	f0 0d       	add	r31, r0
    5ede:	11 24       	eor	r1, r1
    5ee0:	e3 55       	subi	r30, 0x53	; 83
    5ee2:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5ee4:	a5 91       	lpm	r26, Z+
    5ee6:	b4 91       	lpm	r27, Z
    5ee8:	9c 93       	st	X, r25
				usart->CTRLC |=USART_PMODE_ODD_gc;
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
    5eea:	ff 20       	and	r15, r15
    5eec:	59 f0       	breq	.+22     	; 0x5f04 <SetParity+0x7a>
    5eee:	81 30       	cpi	r24, 0x01	; 1
    5ef0:	49 f0       	breq	.+18     	; 0x5f04 <SetParity+0x7a>
		ewb(&MB_Param[MB_N].StopBits, 1);
    5ef2:	61 e0       	ldi	r22, 0x01	; 1
    5ef4:	ce 01       	movw	r24, r28
}
    5ef6:	df 91       	pop	r29
    5ef8:	cf 91       	pop	r28
    5efa:	1f 91       	pop	r17
    5efc:	0f 91       	pop	r16
    5efe:	ff 90       	pop	r15
				break;
			}
		}
	#endif
	if (Parity!=NoParity && S_B!=1)
		ewb(&MB_Param[MB_N].StopBits, 1);
    5f00:	0c 94 ca 29 	jmp	0x5394	; 0x5394 <ewb>
}
    5f04:	df 91       	pop	r29
    5f06:	cf 91       	pop	r28
    5f08:	1f 91       	pop	r17
    5f0a:	0f 91       	pop	r16
    5f0c:	ff 90       	pop	r15
    5f0e:	08 95       	ret

00005f10 <SetBAUD>:

// ~~~~~~~~~~~~~~~~~~
void
SetBAUD(uint8_t MB_N)
{
    5f10:	cf 93       	push	r28
    5f12:	df 93       	push	r29
	BR_Val *ptrBR_Val = BR_Tbl + (MB_BitRate_RAM[MB_N] = erb(&MB_Param[MB_N].BitRate));
    5f14:	c8 2f       	mov	r28, r24
    5f16:	d0 e0       	ldi	r29, 0x00	; 0
    5f18:	ce 01       	movw	r24, r28
    5f1a:	88 0f       	add	r24, r24
    5f1c:	99 1f       	adc	r25, r25
    5f1e:	8c 0f       	add	r24, r28
    5f20:	9d 1f       	adc	r25, r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    5f22:	8f 55       	subi	r24, 0x5F	; 95
    5f24:	9e 4f       	sbci	r25, 0xFE	; 254
    5f26:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    5f2a:	fe 01       	movw	r30, r28
    5f2c:	e1 59       	subi	r30, 0x91	; 145
    5f2e:	f6 4f       	sbci	r31, 0xF6	; 246
    5f30:	80 83       	st	Z, r24
    5f32:	23 e0       	ldi	r18, 0x03	; 3
    5f34:	82 9f       	mul	r24, r18
    5f36:	c0 01       	movw	r24, r0
    5f38:	11 24       	eor	r1, r1
    5f3a:	85 54       	subi	r24, 0x45	; 69
    5f3c:	90 4b       	sbci	r25, 0xB0	; 176
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ubrrl) = prb((uint8_t*)&ptrBR_Val->UBRR);
    5f3e:	24 e1       	ldi	r18, 0x14	; 20
    5f40:	2c 9f       	mul	r18, r28
    5f42:	f0 01       	movw	r30, r0
    5f44:	2d 9f       	mul	r18, r29
    5f46:	f0 0d       	add	r31, r0
    5f48:	11 24       	eor	r1, r1
    5f4a:	ef 54       	subi	r30, 0x4F	; 79
    5f4c:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f4e:	a5 91       	lpm	r26, Z+
    5f50:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f52:	fc 01       	movw	r30, r24
    5f54:	24 91       	lpm	r18, Z
    5f56:	2c 93       	st	X, r18
		USART_Reg(MB_N, ubrrh) = prb((uint8_t*)&ptrBR_Val->UBRR+1);
    5f58:	24 e1       	ldi	r18, 0x14	; 20
    5f5a:	2c 9f       	mul	r18, r28
    5f5c:	f0 01       	movw	r30, r0
    5f5e:	2d 9f       	mul	r18, r29
    5f60:	f0 0d       	add	r31, r0
    5f62:	11 24       	eor	r1, r1
    5f64:	e1 55       	subi	r30, 0x51	; 81
    5f66:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f68:	a5 91       	lpm	r26, Z+
    5f6a:	b4 91       	lpm	r27, Z
    5f6c:	fc 01       	movw	r30, r24
    5f6e:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f70:	e4 91       	lpm	r30, Z
    5f72:	ec 93       	st	X, r30

		*(uint8_t*)prp(&MB_Timer[MB_N].OCR) = prb(&ptrBR_Val->Time35);
    5f74:	26 e0       	ldi	r18, 0x06	; 6
    5f76:	2c 9f       	mul	r18, r28
    5f78:	f0 01       	movw	r30, r0
    5f7a:	2d 9f       	mul	r18, r29
    5f7c:	f0 0d       	add	r31, r0
    5f7e:	11 24       	eor	r1, r1
    5f80:	e3 56       	subi	r30, 0x63	; 99
    5f82:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5f84:	a5 91       	lpm	r26, Z+
    5f86:	b4 91       	lpm	r27, Z
    5f88:	fc 01       	movw	r30, r24
    5f8a:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    5f8c:	84 91       	lpm	r24, Z
    5f8e:	8c 93       	st	X, r24
		usart->BAUDCTRLA = prb((uint8_t*)&ptrBR_Val->UBRR);
		usart->BAUDCTRLB = prb((uint8_t*)&ptrBR_Val->UBRR+1) + USART_BSCALE0_bm;

		((TC1_t*)prp(MB_Timer+MB_N))->PER = prw(&ptrBR_Val->Time35);
	#endif
}
    5f90:	df 91       	pop	r29
    5f92:	cf 91       	pop	r28
    5f94:	08 95       	ret

00005f96 <MB_Transm>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_Transm(uint8_t MB_N)
{
    5f96:	cf 93       	push	r28
    5f98:	df 93       	push	r29
	MB_State[MB_N] = MB_Trans;
    5f9a:	c8 2f       	mov	r28, r24
    5f9c:	d0 e0       	ldi	r29, 0x00	; 0
    5f9e:	fe 01       	movw	r30, r28
    5fa0:	ef 51       	subi	r30, 0x1F	; 31
    5fa2:	fc 4f       	sbci	r31, 0xFC	; 252
    5fa4:	83 e0       	ldi	r24, 0x03	; 3
    5fa6:	80 83       	st	Z, r24
	USART_Func(MB_N, RS485);
    5fa8:	84 e1       	ldi	r24, 0x14	; 20
    5faa:	8c 9f       	mul	r24, r28
    5fac:	f0 01       	movw	r30, r0
    5fae:	8d 9f       	mul	r24, r29
    5fb0:	f0 0d       	add	r31, r0
    5fb2:	11 24       	eor	r1, r1
    5fb4:	ed 54       	subi	r30, 0x4D	; 77
    5fb6:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    5fb8:	85 91       	lpm	r24, Z+
    5fba:	94 91       	lpm	r25, Z
    5fbc:	fc 01       	movw	r30, r24
    5fbe:	09 95       	icall
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		//USART_Reg(MB_N, ucsrb) |=(1<<6);
		USART_Reg(MB_N, udr) = MB_Frame[MB_N][0];
    5fc0:	84 e1       	ldi	r24, 0x14	; 20
    5fc2:	8c 9f       	mul	r24, r28
    5fc4:	f0 01       	movw	r30, r0
    5fc6:	8d 9f       	mul	r24, r29
    5fc8:	f0 0d       	add	r31, r0
    5fca:	11 24       	eor	r1, r1
    5fcc:	e9 55       	subi	r30, 0x59	; 89
    5fce:	f0 4b       	sbci	r31, 0xB0	; 176
    5fd0:	a5 91       	lpm	r26, Z+
    5fd2:	b4 91       	lpm	r27, Z
    5fd4:	fc 2f       	mov	r31, r28
    5fd6:	ee 27       	eor	r30, r30
    5fd8:	e8 5b       	subi	r30, 0xB8	; 184
    5fda:	f2 4f       	sbci	r31, 0xF2	; 242
    5fdc:	80 81       	ld	r24, Z
    5fde:	8c 93       	st	X, r24

		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    5fe0:	84 e1       	ldi	r24, 0x14	; 20
    5fe2:	8c 9f       	mul	r24, r28
    5fe4:	f0 01       	movw	r30, r0
    5fe6:	8d 9f       	mul	r24, r29
    5fe8:	f0 0d       	add	r31, r0
    5fea:	11 24       	eor	r1, r1
    5fec:	e7 55       	subi	r30, 0x57	; 87
    5fee:	f0 4b       	sbci	r31, 0xB0	; 176
    5ff0:	a5 91       	lpm	r26, Z+
    5ff2:	b4 91       	lpm	r27, Z
    5ff4:	8c 91       	ld	r24, X
    5ff6:	80 64       	ori	r24, 0x40	; 64
    5ff8:	8c 93       	st	X, r24
		USART_Reg(MB_N, ucsrb) |=(1<<5);
    5ffa:	84 e1       	ldi	r24, 0x14	; 20
    5ffc:	8c 9f       	mul	r24, r28
    5ffe:	f0 01       	movw	r30, r0
    6000:	8d 9f       	mul	r24, r29
    6002:	f0 0d       	add	r31, r0
    6004:	11 24       	eor	r1, r1
    6006:	e5 55       	subi	r30, 0x55	; 85
    6008:	f0 4b       	sbci	r31, 0xB0	; 176
    600a:	a5 91       	lpm	r26, Z+
    600c:	b4 91       	lpm	r27, Z
    600e:	8c 91       	ld	r24, X
    6010:	80 62       	ori	r24, 0x20	; 32
    6012:	8c 93       	st	X, r24
	#elif defined (__AVR_ATxmega128A1__)
		USART_t *usart = prp(&MB_Port[MB_N].usart);
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_HI_gc;
		usart->DATA = MB_Frame[MB_N][0];
	#endif
}
    6014:	df 91       	pop	r29
    6016:	cf 91       	pop	r28
    6018:	08 95       	ret

0000601a <Modbus_RX>:

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
    601a:	cf 93       	push	r28
    601c:	df 93       	push	r29
    601e:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    6020:	80 e0       	ldi	r24, 0x00	; 0
    6022:	94 e1       	ldi	r25, 0x14	; 20
    6024:	c8 2f       	mov	r28, r24
    6026:	d0 e0       	ldi	r29, 0x00	; 0
    6028:	9c 9f       	mul	r25, r28
    602a:	f0 01       	movw	r30, r0
    602c:	9d 9f       	mul	r25, r29
    602e:	f0 0d       	add	r31, r0
    6030:	11 24       	eor	r1, r1
    6032:	e9 55       	subi	r30, 0x59	; 89
    6034:	f0 4b       	sbci	r31, 0xB0	; 176
    6036:	25 91       	lpm	r18, Z+
    6038:	34 91       	lpm	r19, Z
    603a:	a2 17       	cp	r26, r18
    603c:	b3 07       	cpc	r27, r19
    603e:	11 f0       	breq	.+4      	; 0x6044 <Modbus_RX+0x2a>
    6040:	8f 5f       	subi	r24, 0xFF	; 255
    6042:	f0 cf       	rjmp	.-32     	; 0x6024 <Modbus_RX+0xa>
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    6044:	fe 01       	movw	r30, r28
    6046:	ef 51       	subi	r30, 0x1F	; 31
    6048:	fc 4f       	sbci	r31, 0xFC	; 252
    604a:	90 81       	ld	r25, Z
    604c:	92 30       	cpi	r25, 0x02	; 2
    604e:	a1 f1       	breq	.+104    	; 0x60b8 <Modbus_RX+0x9e>
    6050:	40 f5       	brcc	.+80     	; 0x60a2 <Modbus_RX+0x88>
    6052:	99 23       	and	r25, r25
    6054:	51 f1       	breq	.+84     	; 0x60aa <Modbus_RX+0x90>
    6056:	91 30       	cpi	r25, 0x01	; 1
    6058:	09 f0       	breq	.+2      	; 0x605c <Modbus_RX+0x42>
    605a:	3b c0       	rjmp	.+118    	; 0x60d2 <Modbus_RX+0xb8>
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
		MB_ClearTimer(MB_N);
		break;
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
    605c:	92 e0       	ldi	r25, 0x02	; 2
    605e:	90 83       	st	Z, r25
		MB_Err &=~(1<<MB_N);
    6060:	21 e0       	ldi	r18, 0x01	; 1
    6062:	30 e0       	ldi	r19, 0x00	; 0
    6064:	08 2e       	mov	r0, r24
    6066:	01 c0       	rjmp	.+2      	; 0x606a <Modbus_RX+0x50>
    6068:	22 0f       	add	r18, r18
    606a:	0a 94       	dec	r0
    606c:	ea f7       	brpl	.-6      	; 0x6068 <Modbus_RX+0x4e>
    606e:	20 95       	com	r18
    6070:	90 91 6b 02 	lds	r25, 0x026B
    6074:	92 23       	and	r25, r18
    6076:	90 93 6b 02 	sts	0x026B, r25
		MB_Frame_Sz[MB_N] = 0;
    607a:	fe 01       	movw	r30, r28
    607c:	e7 52       	subi	r30, 0x27	; 39
    607e:	f7 4f       	sbci	r31, 0xF7	; 247
    6080:	10 82       	st	Z, r1
		MBRecept(MB_N);
    6082:	0e 94 83 28 	call	0x5106	; 0x5106 <MBRecept>
		MB_StartTimer(MB_N);
    6086:	86 e0       	ldi	r24, 0x06	; 6
    6088:	8c 9f       	mul	r24, r28
    608a:	f0 01       	movw	r30, r0
    608c:	8d 9f       	mul	r24, r29
    608e:	f0 0d       	add	r31, r0
    6090:	11 24       	eor	r1, r1
    6092:	e1 56       	subi	r30, 0x61	; 97
    6094:	f0 4b       	sbci	r31, 0xB0	; 176
    6096:	85 91       	lpm	r24, Z+
    6098:	94 91       	lpm	r25, Z
    609a:	fc 01       	movw	r30, r24
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    609c:	df 91       	pop	r29
    609e:	cf 91       	pop	r28
	case MB_Idle: 
		MB_State[MB_N] = MB_Recept;
		MB_Err &=~(1<<MB_N);
		MB_Frame_Sz[MB_N] = 0;
		MBRecept(MB_N);
		MB_StartTimer(MB_N);
    60a0:	09 94       	ijmp
// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
    60a2:	96 30       	cpi	r25, 0x06	; 6
    60a4:	b0 f4       	brcc	.+44     	; 0x60d2 <Modbus_RX+0xb8>
		MBRecept(MB_N);
		MB_ClearTimer(MB_N);
		break;
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
    60a6:	8c 91       	ld	r24, X
		break;
    60a8:	14 c0       	rjmp	.+40     	; 0x60d2 <Modbus_RX+0xb8>
Modbus_RX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	switch (MB_State[MB_N]) {
	case MB_Initi:
		MB_Frame[MB_N][0] = usart_data(usart);
    60aa:	8c 91       	ld	r24, X
    60ac:	fc 2f       	mov	r31, r28
    60ae:	ee 27       	eor	r30, r30
    60b0:	e8 5b       	subi	r30, 0xB8	; 184
    60b2:	f2 4f       	sbci	r31, 0xF2	; 242
    60b4:	80 83       	st	Z, r24
    60b6:	02 c0       	rjmp	.+4      	; 0x60bc <Modbus_RX+0xa2>
		MB_StartTimer(MB_N);
		break;
	case MB_Recept:
		/*if(TCNT2>=prb(&(BR_Tbl+MB_BitRate_RAM[MB_N])->Time15))
			MB_Err &=(1<<MB_N);*/
		MBRecept(MB_N);
    60b8:	0e 94 83 28 	call	0x5106	; 0x5106 <MBRecept>
		MB_ClearTimer(MB_N);
    60bc:	86 e0       	ldi	r24, 0x06	; 6
    60be:	8c 9f       	mul	r24, r28
    60c0:	f0 01       	movw	r30, r0
    60c2:	8d 9f       	mul	r24, r29
    60c4:	f0 0d       	add	r31, r0
    60c6:	11 24       	eor	r1, r1
    60c8:	e5 56       	subi	r30, 0x65	; 101
    60ca:	f0 4b       	sbci	r31, 0xB0	; 176
    60cc:	a5 91       	lpm	r26, Z+
    60ce:	b4 91       	lpm	r27, Z
    60d0:	1c 92       	st	X, r1
	case MB_Trans: case MB_Proc: 
	case MB_NoReply: // MB_NoReply    MB_Recept ..  MB_M_Cycle   MB_Trans
		usart_data(usart);
		break;
	}
}
    60d2:	df 91       	pop	r29
    60d4:	cf 91       	pop	r28
    60d6:	08 95       	ret

000060d8 <CommErr>:
}

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
    60d8:	0f 93       	push	r16
    60da:	1f 93       	push	r17
    60dc:	cf 93       	push	r28
    60de:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    60e0:	c8 2f       	mov	r28, r24
    60e2:	d0 e0       	ldi	r29, 0x00	; 0
    60e4:	fe 01       	movw	r30, r28
    60e6:	e7 52       	subi	r30, 0x27	; 39
    60e8:	f7 4f       	sbci	r31, 0xF7	; 247
    60ea:	90 81       	ld	r25, Z
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    60ec:	20 91 6b 02 	lds	r18, 0x026B
    60f0:	30 e0       	ldi	r19, 0x00	; 0
    60f2:	02 c0       	rjmp	.+4      	; 0x60f8 <CommErr+0x20>
    60f4:	35 95       	asr	r19
    60f6:	27 95       	ror	r18
    60f8:	8a 95       	dec	r24
    60fa:	e2 f7       	brpl	.-8      	; 0x60f4 <CommErr+0x1c>
    60fc:	20 fd       	sbrc	r18, 0
    60fe:	1b c0       	rjmp	.+54     	; 0x6136 <CommErr+0x5e>
    6100:	93 30       	cpi	r25, 0x03	; 3
    6102:	c8 f0       	brcs	.+50     	; 0x6136 <CommErr+0x5e>

// ~~~~~~~~~~~~~~~~~~
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    6104:	2e ef       	ldi	r18, 0xFE	; 254
    6106:	29 0f       	add	r18, r25
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
    6108:	7c 2f       	mov	r23, r28
    610a:	66 27       	eor	r22, r22
    610c:	68 5b       	subi	r22, 0xB8	; 184
    610e:	72 4f       	sbci	r23, 0xF2	; 242
    6110:	fb 01       	movw	r30, r22
    6112:	e2 0f       	add	r30, r18
    6114:	f1 1d       	adc	r31, r1
    6116:	00 81       	ld	r16, Z
    6118:	11 81       	ldd	r17, Z+1	; 0x01
    611a:	30 e0       	ldi	r19, 0x00	; 0
    611c:	40 e0       	ldi	r20, 0x00	; 0
    611e:	50 e0       	ldi	r21, 0x00	; 0
    6120:	8b e1       	ldi	r24, 0x1B	; 27
    6122:	98 e2       	ldi	r25, 0x28	; 40
    6124:	0e 94 99 29 	call	0x5332	; 0x5332 <CRC>
    6128:	21 e0       	ldi	r18, 0x01	; 1
    612a:	08 17       	cp	r16, r24
    612c:	19 07       	cpc	r17, r25
    612e:	09 f4       	brne	.+2      	; 0x6132 <CommErr+0x5a>
    6130:	20 e0       	ldi	r18, 0x00	; 0
    6132:	12 2f       	mov	r17, r18
    6134:	01 c0       	rjmp	.+2      	; 0x6138 <CommErr+0x60>
    6136:	11 e0       	ldi	r17, 0x01	; 1
    6138:	fe 01       	movw	r30, r28
    613a:	54 e0       	ldi	r21, 0x04	; 4
    613c:	ee 0f       	add	r30, r30
    613e:	ff 1f       	adc	r31, r31
    6140:	5a 95       	dec	r21
    6142:	e1 f7       	brne	.-8      	; 0x613c <CommErr+0x64>
	if (Err) {
		MB_CPT[MB_N][1]++;
    6144:	e7 5d       	subi	r30, 0xD7	; 215
    6146:	f4 4f       	sbci	r31, 0xF4	; 244
uint8_t
CommErr(uint8_t MB_N)
{
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
	uint8_t Err = MB_Err &(1<<MB_N) || MB_Frame_Sz[MB_N]<3 || *(uint16_t*)(MB_Frame[MB_N]+Sz)!=CRC(rrb, MB_Frame[MB_N], Sz);
	if (Err) {
    6148:	11 23       	and	r17, r17
    614a:	79 f0       	breq	.+30     	; 0x616a <CommErr+0x92>
		MB_CPT[MB_N][1]++;
    614c:	22 81       	ldd	r18, Z+2	; 0x02
    614e:	33 81       	ldd	r19, Z+3	; 0x03
    6150:	2f 5f       	subi	r18, 0xFF	; 255
    6152:	3f 4f       	sbci	r19, 0xFF	; 255
    6154:	33 83       	std	Z+3, r19	; 0x03
    6156:	22 83       	std	Z+2, r18	; 0x02
		USART_Func(MB_N, LED_Err_On);
    6158:	84 e1       	ldi	r24, 0x14	; 20
    615a:	8c 9f       	mul	r24, r28
    615c:	f0 01       	movw	r30, r0
    615e:	8d 9f       	mul	r24, r29
    6160:	f0 0d       	add	r31, r0
    6162:	11 24       	eor	r1, r1
    6164:	e9 54       	subi	r30, 0x49	; 73
    6166:	f0 4b       	sbci	r31, 0xB0	; 176
    6168:	0e c0       	rjmp	.+28     	; 0x6186 <CommErr+0xae>
	}
	else {
		MB_CPT[MB_N][0]++;
    616a:	20 81       	ld	r18, Z
    616c:	31 81       	ldd	r19, Z+1	; 0x01
    616e:	2f 5f       	subi	r18, 0xFF	; 255
    6170:	3f 4f       	sbci	r19, 0xFF	; 255
    6172:	31 83       	std	Z+1, r19	; 0x01
    6174:	20 83       	st	Z, r18
		USART_Func(MB_N, LED_Err_Off);
    6176:	84 e1       	ldi	r24, 0x14	; 20
    6178:	8c 9f       	mul	r24, r28
    617a:	f0 01       	movw	r30, r0
    617c:	8d 9f       	mul	r24, r29
    617e:	f0 0d       	add	r31, r0
    6180:	11 24       	eor	r1, r1
    6182:	e7 54       	subi	r30, 0x47	; 71
    6184:	f0 4b       	sbci	r31, 0xB0	; 176
    6186:	25 91       	lpm	r18, Z+
    6188:	34 91       	lpm	r19, Z
    618a:	f9 01       	movw	r30, r18
    618c:	09 95       	icall
	}
	return Err;
}
    618e:	81 2f       	mov	r24, r17
    6190:	df 91       	pop	r29
    6192:	cf 91       	pop	r28
    6194:	1f 91       	pop	r17
    6196:	0f 91       	pop	r16
    6198:	08 95       	ret

0000619a <SetCRC_MB>:

// ~~~~~~~~~~~~~~~~~~~~
void
SetCRC_MB(uint8_t MB_N)
{
    619a:	cf 93       	push	r28
    619c:	df 93       	push	r29
	uint8_t Sz = MB_Frame_Sz[MB_N]-2;
    619e:	68 2f       	mov	r22, r24
    61a0:	70 e0       	ldi	r23, 0x00	; 0
    61a2:	fb 01       	movw	r30, r22
    61a4:	e7 52       	subi	r30, 0x27	; 39
    61a6:	f7 4f       	sbci	r31, 0xF7	; 247
    61a8:	20 81       	ld	r18, Z
    61aa:	22 50       	subi	r18, 0x02	; 2
	*(uint16_t*)(MB_Frame[MB_N]+Sz) = CRC(rrb, MB_Frame[MB_N], Sz);
    61ac:	76 2f       	mov	r23, r22
    61ae:	66 27       	eor	r22, r22
    61b0:	68 5b       	subi	r22, 0xB8	; 184
    61b2:	72 4f       	sbci	r23, 0xF2	; 242
    61b4:	eb 01       	movw	r28, r22
    61b6:	c2 0f       	add	r28, r18
    61b8:	d1 1d       	adc	r29, r1
    61ba:	30 e0       	ldi	r19, 0x00	; 0
    61bc:	40 e0       	ldi	r20, 0x00	; 0
    61be:	50 e0       	ldi	r21, 0x00	; 0
    61c0:	8b e1       	ldi	r24, 0x1B	; 27
    61c2:	98 e2       	ldi	r25, 0x28	; 40
    61c4:	0e 94 99 29 	call	0x5332	; 0x5332 <CRC>
    61c8:	99 83       	std	Y+1, r25	; 0x01
    61ca:	88 83       	st	Y, r24
}
    61cc:	df 91       	pop	r29
    61ce:	cf 91       	pop	r28
    61d0:	08 95       	ret

000061d2 <FormData>:
}

// ~~~~~~~~~~~~~~~~~~~
static void
FormData(uint8_t MB_N)
{
    61d2:	bf 92       	push	r11
    61d4:	cf 92       	push	r12
    61d6:	df 92       	push	r13
    61d8:	ef 92       	push	r14
    61da:	ff 92       	push	r15
    61dc:	0f 93       	push	r16
    61de:	1f 93       	push	r17
    61e0:	cf 93       	push	r28
    61e2:	df 93       	push	r29
    61e4:	b8 2e       	mov	r11, r24
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    61e6:	c8 2f       	mov	r28, r24
    61e8:	d0 e0       	ldi	r29, 0x00	; 0
    61ea:	dc 2e       	mov	r13, r28
    61ec:	cc 24       	eor	r12, r12
    61ee:	86 01       	movw	r16, r12
    61f0:	08 5b       	subi	r16, 0xB8	; 184
    61f2:	12 4f       	sbci	r17, 0xF2	; 242
    61f4:	f8 01       	movw	r30, r16
    61f6:	81 81       	ldd	r24, Z+1	; 0x01
    61f8:	86 30       	cpi	r24, 0x06	; 6
    61fa:	f1 f0       	breq	.+60     	; 0x6238 <FormData+0x66>
    61fc:	48 f4       	brcc	.+18     	; 0x6210 <FormData+0x3e>
    61fe:	81 50       	subi	r24, 0x01	; 1
    6200:	84 30       	cpi	r24, 0x04	; 4
    6202:	08 f0       	brcs	.+2      	; 0x6206 <FormData+0x34>
    6204:	c9 c0       	rjmp	.+402    	; 0x6398 <FormData+0x1c6>
	case 1: case 2: case 3: case 4:
		MB_Frame_Sz[MB_N] = 8;
    6206:	c7 52       	subi	r28, 0x27	; 39
    6208:	d7 4f       	sbci	r29, 0xF7	; 247
    620a:	88 e0       	ldi	r24, 0x08	; 8
    620c:	88 83       	st	Y, r24
		break;
    620e:	c4 c0       	rjmp	.+392    	; 0x6398 <FormData+0x1c6>
static void
FormData(uint8_t MB_N)
{
	uint16_t Qt;
	uint16_t *Reg;
	switch (MB_Frame[MB_N][1]) {
    6210:	8f 30       	cpi	r24, 0x0F	; 15
    6212:	11 f1       	breq	.+68     	; 0x6258 <FormData+0x86>
    6214:	80 31       	cpi	r24, 0x10	; 16
    6216:	09 f0       	breq	.+2      	; 0x621a <FormData+0x48>
    6218:	bf c0       	rjmp	.+382    	; 0x6398 <FormData+0x1c6>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
    621a:	f8 01       	movw	r30, r16
    621c:	85 81       	ldd	r24, Z+5	; 0x05
    621e:	88 0f       	add	r24, r24
    6220:	86 83       	std	Z+6, r24	; 0x06
    6222:	c7 52       	subi	r28, 0x27	; 39
    6224:	d7 4f       	sbci	r29, 0xF7	; 247
    6226:	87 5f       	subi	r24, 0xF7	; 247
    6228:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    622a:	8b 2d       	mov	r24, r11
    622c:	0e 94 0b 29 	call	0x5216	; 0x5216 <GetReg>
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6230:	20 e0       	ldi	r18, 0x00	; 0
    6232:	e8 01       	movw	r28, r16
    6234:	25 96       	adiw	r28, 0x05	; 5
    6236:	9a c0       	rjmp	.+308    	; 0x636c <FormData+0x19a>
		MB_Frame_Sz[MB_N] = 8;
		MB_Frame[MB_N][5] = 0;
		break;
	*/
	case 6:
		MB_Frame_Sz[MB_N] = 8;
    6238:	c7 52       	subi	r28, 0x27	; 39
    623a:	d7 4f       	sbci	r29, 0xF7	; 247
    623c:	88 e0       	ldi	r24, 0x08	; 8
    623e:	88 83       	st	Y, r24
		Reg = GetReg(MB_N);
    6240:	8b 2d       	mov	r24, r11
    6242:	0e 94 0b 29 	call	0x5216	; 0x5216 <GetReg>
		MB_Frame[MB_N][4] = *Reg>>8;
    6246:	fc 01       	movw	r30, r24
    6248:	21 81       	ldd	r18, Z+1	; 0x01
    624a:	f8 01       	movw	r30, r16
    624c:	24 83       	std	Z+4, r18	; 0x04
		MB_Frame[MB_N][5] = *Reg;
    624e:	fc 01       	movw	r30, r24
    6250:	80 81       	ld	r24, Z
    6252:	f8 01       	movw	r30, r16
    6254:	85 83       	std	Z+5, r24	; 0x05
		break;
    6256:	a0 c0       	rjmp	.+320    	; 0x6398 <FormData+0x1c6>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6258:	f8 01       	movw	r30, r16
    625a:	e4 80       	ldd	r14, Z+4	; 0x04
    625c:	f1 2c       	mov	r15, r1
    625e:	fe 2c       	mov	r15, r14
    6260:	ee 24       	eor	r14, r14
    6262:	85 81       	ldd	r24, Z+5	; 0x05
    6264:	e8 2a       	or	r14, r24
	case 0x0F:
		Qt = MB_FrameReg(MB_N, 4);
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = Qt/8 + (Qt%8>0)) + 9;
    6266:	c7 01       	movw	r24, r14
    6268:	13 e0       	ldi	r17, 0x03	; 3
    626a:	96 95       	lsr	r25
    626c:	87 95       	ror	r24
    626e:	1a 95       	dec	r17
    6270:	e1 f7       	brne	.-8      	; 0x626a <FormData+0x98>
    6272:	97 01       	movw	r18, r14
    6274:	27 70       	andi	r18, 0x07	; 7
    6276:	33 27       	eor	r19, r19
    6278:	41 e0       	ldi	r20, 0x01	; 1
    627a:	23 2b       	or	r18, r19
    627c:	09 f4       	brne	.+2      	; 0x6280 <FormData+0xae>
    627e:	40 e0       	ldi	r20, 0x00	; 0
    6280:	24 2f       	mov	r18, r20
    6282:	28 0f       	add	r18, r24
    6284:	f6 01       	movw	r30, r12
    6286:	e8 5b       	subi	r30, 0xB8	; 184
    6288:	f2 4f       	sbci	r31, 0xF2	; 242
    628a:	26 83       	std	Z+6, r18	; 0x06
    628c:	de 01       	movw	r26, r28
    628e:	a7 52       	subi	r26, 0x27	; 39
    6290:	b7 4f       	sbci	r27, 0xF7	; 247
    6292:	27 5f       	subi	r18, 0xF7	; 247
    6294:	2c 93       	st	X, r18
		MB_Frame[MB_N][7+Qt/8] = 0;
    6296:	e8 0f       	add	r30, r24
    6298:	f9 1f       	adc	r31, r25
    629a:	17 82       	std	Z+7, r1	; 0x07
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
    629c:	fe 01       	movw	r30, r28
    629e:	ee 5d       	subi	r30, 0xDE	; 222
    62a0:	f9 4f       	sbci	r31, 0xF9	; 249
    62a2:	80 81       	ld	r24, Z
    62a4:	82 30       	cpi	r24, 0x02	; 2
    62a6:	f9 f0       	breq	.+62     	; 0x62e6 <FormData+0x114>
			Discr = prp(&Modbus_Map[MB_N].Coil);
    62a8:	fe 01       	movw	r30, r28
    62aa:	a4 e0       	ldi	r26, 0x04	; 4
    62ac:	ee 0f       	add	r30, r30
    62ae:	ff 1f       	adc	r31, r31
    62b0:	aa 95       	dec	r26
    62b2:	e1 f7       	brne	.-8      	; 0x62ac <FormData+0xda>
    62b4:	ea 52       	subi	r30, 0x2A	; 42
    62b6:	f0 4b       	sbci	r31, 0xB0	; 176
    62b8:	05 91       	lpm	r16, Z+
    62ba:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~
static MB_Query*
GetQuery(uint8_t MB_N)
{
	return (MB_Query*)prp(&GetSlave(MB_N)->QueryList)+CurrQuery[MB_N];
    62bc:	8b 2d       	mov	r24, r11
    62be:	0e 94 c5 28 	call	0x518a	; 0x518a <GetSlave>
    62c2:	01 96       	adiw	r24, 0x01	; 1
    62c4:	fc 01       	movw	r30, r24
    62c6:	85 91       	lpm	r24, Z+
    62c8:	94 91       	lpm	r25, Z
    62ca:	c3 5f       	subi	r28, 0xF3	; 243
    62cc:	d9 4f       	sbci	r29, 0xF9	; 249
    62ce:	28 81       	ld	r18, Y
    62d0:	fc 01       	movw	r30, r24
    62d2:	37 e0       	ldi	r19, 0x07	; 7
    62d4:	23 9f       	mul	r18, r19
    62d6:	e0 0d       	add	r30, r0
    62d8:	f1 1d       	adc	r31, r1
    62da:	11 24       	eor	r1, r1
		MB_Frame[MB_N][7+Qt/8] = 0;
		uint8_t *Discr;
		uint8_t Pin;
		if (MB_SingleState[MB_N]!=MB_SingleExec) {
			Discr = prp(&Modbus_Map[MB_N].Coil);
			Pin = prw(&GetQuery(MB_N)->AllocAddr);
    62dc:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    62de:	85 91       	lpm	r24, Z+
    62e0:	94 91       	lpm	r25, Z
    62e2:	78 2f       	mov	r23, r24
    62e4:	0a c0       	rjmp	.+20     	; 0x62fa <FormData+0x128>
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
    62e6:	f3 e0       	ldi	r31, 0x03	; 3
    62e8:	cc 0f       	add	r28, r28
    62ea:	dd 1f       	adc	r29, r29
    62ec:	fa 95       	dec	r31
    62ee:	e1 f7       	brne	.-8      	; 0x62e8 <FormData+0x116>
    62f0:	cd 59       	subi	r28, 0x9D	; 157
    62f2:	dd 4f       	sbci	r29, 0xFD	; 253
    62f4:	0e 81       	ldd	r16, Y+6	; 0x06
    62f6:	1f 81       	ldd	r17, Y+7	; 0x07
			Pin = 0;
    62f8:	70 e0       	ldi	r23, 0x00	; 0
		}
		for (uint8_t i=0; i<Qt; i++) {
    62fa:	60 e0       	ldi	r22, 0x00	; 0
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    62fc:	41 e0       	ldi	r20, 0x01	; 1
    62fe:	50 e0       	ldi	r21, 0x00	; 0
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6300:	26 2f       	mov	r18, r22
    6302:	30 e0       	ldi	r19, 0x00	; 0
    6304:	2e 15       	cp	r18, r14
    6306:	3f 05       	cpc	r19, r15
    6308:	08 f0       	brcs	.+2      	; 0x630c <FormData+0x13a>
    630a:	46 c0       	rjmp	.+140    	; 0x6398 <FormData+0x1c6>
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
    630c:	e6 2f       	mov	r30, r22
    630e:	e6 95       	lsr	r30
    6310:	e6 95       	lsr	r30
    6312:	e6 95       	lsr	r30
    6314:	e9 5f       	subi	r30, 0xF9	; 249
    6316:	86 2f       	mov	r24, r22
    6318:	87 70       	andi	r24, 0x07	; 7
    631a:	9a 01       	movw	r18, r20
    631c:	02 c0       	rjmp	.+4      	; 0x6322 <FormData+0x150>
    631e:	22 0f       	add	r18, r18
    6320:	33 1f       	adc	r19, r19
    6322:	8a 95       	dec	r24
    6324:	e2 f7       	brpl	.-8      	; 0x631e <FormData+0x14c>
    6326:	c9 01       	movw	r24, r18
			if (Discr[j/8] &(1<<j%8))
    6328:	f6 2f       	mov	r31, r22
    632a:	f7 0f       	add	r31, r23
    632c:	2f 2f       	mov	r18, r31
    632e:	26 95       	lsr	r18
    6330:	26 95       	lsr	r18
    6332:	26 95       	lsr	r18
    6334:	d8 01       	movw	r26, r16
    6336:	a2 0f       	add	r26, r18
    6338:	b1 1d       	adc	r27, r1
    633a:	2c 91       	ld	r18, X
    633c:	30 e0       	ldi	r19, 0x00	; 0
    633e:	f7 70       	andi	r31, 0x07	; 7
    6340:	02 c0       	rjmp	.+4      	; 0x6346 <FormData+0x174>
    6342:	35 95       	asr	r19
    6344:	27 95       	ror	r18
    6346:	fa 95       	dec	r31
    6348:	e2 f7       	brpl	.-8      	; 0x6342 <FormData+0x170>
    634a:	f0 e0       	ldi	r31, 0x00	; 0
				MB_Frame[MB_N][Byte] |=Bit;
    634c:	ec 0d       	add	r30, r12
    634e:	fd 1d       	adc	r31, r13
    6350:	e8 5b       	subi	r30, 0xB8	; 184
    6352:	f2 4f       	sbci	r31, 0xF2	; 242
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
			uint8_t j = Pin+i;
			uint8_t Byte=7+i/8, Bit=1<<i%8;
			if (Discr[j/8] &(1<<j%8))
    6354:	20 ff       	sbrs	r18, 0
    6356:	04 c0       	rjmp	.+8      	; 0x6360 <FormData+0x18e>
				MB_Frame[MB_N][Byte] |=Bit;
    6358:	90 81       	ld	r25, Z
    635a:	98 2b       	or	r25, r24
    635c:	90 83       	st	Z, r25
    635e:	04 c0       	rjmp	.+8      	; 0x6368 <FormData+0x196>
			else
				MB_Frame[MB_N][Byte] &=~Bit;
    6360:	80 95       	com	r24
    6362:	90 81       	ld	r25, Z
    6364:	89 23       	and	r24, r25
    6366:	80 83       	st	Z, r24
		}
		else {
			Discr = MB_SingleQuery[MB_N].Buf;
			Pin = 0;
		}
		for (uint8_t i=0; i<Qt; i++) {
    6368:	6f 5f       	subi	r22, 0xFF	; 255
    636a:	ca cf       	rjmp	.-108    	; 0x6300 <FormData+0x12e>
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    636c:	38 81       	ld	r19, Y
    636e:	23 17       	cp	r18, r19
    6370:	98 f4       	brcc	.+38     	; 0x6398 <FormData+0x1c6>
			uint8_t j = i*2;
    6372:	32 2f       	mov	r19, r18
    6374:	33 0f       	add	r19, r19
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
    6376:	fc 01       	movw	r30, r24
    6378:	e2 0f       	add	r30, r18
    637a:	f1 1d       	adc	r31, r1
    637c:	e2 0f       	add	r30, r18
    637e:	f1 1d       	adc	r31, r1
    6380:	d8 01       	movw	r26, r16
    6382:	a3 0f       	add	r26, r19
    6384:	b1 1d       	adc	r27, r1
    6386:	31 81       	ldd	r19, Z+1	; 0x01
    6388:	17 96       	adiw	r26, 0x07	; 7
    638a:	3c 93       	st	X, r19
    638c:	17 97       	sbiw	r26, 0x07	; 7
			MB_Frame[MB_N][8+j] = Reg[i];
    638e:	30 81       	ld	r19, Z
    6390:	18 96       	adiw	r26, 0x08	; 8
    6392:	3c 93       	st	X, r19
		}
		break;
	case 0x10:
		MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][6] = MB_Frame[MB_N][5]*2) + 9;
		Reg = GetReg(MB_N);
		for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6394:	2f 5f       	subi	r18, 0xFF	; 255
    6396:	ea cf       	rjmp	.-44     	; 0x636c <FormData+0x19a>
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    6398:	8b 2d       	mov	r24, r11
}
    639a:	df 91       	pop	r29
    639c:	cf 91       	pop	r28
    639e:	1f 91       	pop	r17
    63a0:	0f 91       	pop	r16
    63a2:	ff 90       	pop	r15
    63a4:	ef 90       	pop	r14
    63a6:	df 90       	pop	r13
    63a8:	cf 90       	pop	r12
    63aa:	bf 90       	pop	r11
			MB_Frame[MB_N][7+j] = Reg[i]>>8;
			MB_Frame[MB_N][8+j] = Reg[i];
		}
		break;
	}
	SetCRC_MB(MB_N);
    63ac:	0c 94 cd 30 	jmp	0x619a	; 0x619a <SetCRC_MB>

000063b0 <FormQuery>:
}

// ~~~~~~~~~~~~~~~~~~~~
static void
FormQuery(uint8_t MB_N)
{
    63b0:	cf 93       	push	r28
    63b2:	c8 2f       	mov	r28, r24
	MB_Slave *Slave = GetSlave(MB_N);
    63b4:	0e 94 c5 28 	call	0x518a	; 0x518a <GetSlave>
    63b8:	bc 01       	movw	r22, r24
	MB_Query *Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    63ba:	fc 01       	movw	r30, r24
    63bc:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    63be:	45 91       	lpm	r20, Z+
    63c0:	54 91       	lpm	r21, Z
    63c2:	2c 2f       	mov	r18, r28
    63c4:	30 e0       	ldi	r19, 0x00	; 0
    63c6:	f9 01       	movw	r30, r18
    63c8:	e3 5f       	subi	r30, 0xF3	; 243
    63ca:	f9 4f       	sbci	r31, 0xF9	; 249
    63cc:	80 81       	ld	r24, Z
    63ce:	97 e0       	ldi	r25, 0x07	; 7
    63d0:	89 9f       	mul	r24, r25
    63d2:	40 0d       	add	r20, r0
    63d4:	51 1d       	adc	r21, r1
    63d6:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    63d8:	fb 01       	movw	r30, r22
    63da:	64 91       	lpm	r22, Z

	MB_Frame[MB_N][0] = prb(&Slave->Addr);
    63dc:	b2 2f       	mov	r27, r18
    63de:	aa 27       	eor	r26, r26
    63e0:	a8 5b       	subi	r26, 0xB8	; 184
    63e2:	b2 4f       	sbci	r27, 0xF2	; 242
    63e4:	6c 93       	st	X, r22
    63e6:	fa 01       	movw	r30, r20
    63e8:	84 91       	lpm	r24, Z
	MB_Frame[MB_N][1] = prb(&Query->Func);
    63ea:	f2 2f       	mov	r31, r18
    63ec:	ee 27       	eor	r30, r30
    63ee:	e8 5b       	subi	r30, 0xB8	; 184
    63f0:	f2 4f       	sbci	r31, 0xF2	; 242
    63f2:	81 83       	std	Z+1, r24	; 0x01
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
    63f4:	fa 01       	movw	r30, r20
    63f6:	32 96       	adiw	r30, 0x02	; 2
    63f8:	e4 91       	lpm	r30, Z
    63fa:	b2 2f       	mov	r27, r18
    63fc:	aa 27       	eor	r26, r26
    63fe:	a8 5b       	subi	r26, 0xB8	; 184
    6400:	b2 4f       	sbci	r27, 0xF2	; 242
    6402:	12 96       	adiw	r26, 0x02	; 2
    6404:	ec 93       	st	X, r30
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
    6406:	fa 01       	movw	r30, r20
    6408:	31 96       	adiw	r30, 0x01	; 1
    640a:	e4 91       	lpm	r30, Z
    640c:	b2 2f       	mov	r27, r18
    640e:	aa 27       	eor	r26, r26
    6410:	a8 5b       	subi	r26, 0xB8	; 184
    6412:	b2 4f       	sbci	r27, 0xF2	; 242
    6414:	13 96       	adiw	r26, 0x03	; 3
    6416:	ec 93       	st	X, r30
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
    6418:	fa 01       	movw	r30, r20
    641a:	34 96       	adiw	r30, 0x04	; 4
    641c:	e4 91       	lpm	r30, Z
    641e:	b2 2f       	mov	r27, r18
    6420:	aa 27       	eor	r26, r26
    6422:	a8 5b       	subi	r26, 0xB8	; 184
    6424:	b2 4f       	sbci	r27, 0xF2	; 242
    6426:	14 96       	adiw	r26, 0x04	; 4
    6428:	ec 93       	st	X, r30
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);
    642a:	fa 01       	movw	r30, r20
    642c:	33 96       	adiw	r30, 0x03	; 3
    642e:	44 91       	lpm	r20, Z
    6430:	b2 2f       	mov	r27, r18
    6432:	aa 27       	eor	r26, r26
    6434:	a8 5b       	subi	r26, 0xB8	; 184
    6436:	b2 4f       	sbci	r27, 0xF2	; 242
    6438:	15 96       	adiw	r26, 0x05	; 5
    643a:	4c 93       	st	X, r20

	FormData(MB_N);
    643c:	8c 2f       	mov	r24, r28
}
    643e:	cf 91       	pop	r28
	MB_Frame[MB_N][2] = prb((uint8_t*)&Query->StartAddr+1);
	MB_Frame[MB_N][3] = prb((uint8_t*)&Query->StartAddr);
	MB_Frame[MB_N][4] = prb((uint8_t*)&Query->Qt+1);
	MB_Frame[MB_N][5] = prb((uint8_t*)&Query->Qt);

	FormData(MB_N);
    6440:	0c 94 e9 30 	jmp	0x61d2	; 0x61d2 <FormData>

00006444 <FormSingle>:

// ~~~~~~~~~~~~~~~~~~~~~
static void
FormSingle(uint8_t MB_N)
{
	MB_Frame[MB_N][0] = MB_SingleQuery[MB_N].Addr;
    6444:	28 2f       	mov	r18, r24
    6446:	30 e0       	ldi	r19, 0x00	; 0
    6448:	f2 2f       	mov	r31, r18
    644a:	ee 27       	eor	r30, r30
    644c:	e8 5b       	subi	r30, 0xB8	; 184
    644e:	f2 4f       	sbci	r31, 0xF2	; 242
    6450:	d9 01       	movw	r26, r18
    6452:	93 e0       	ldi	r25, 0x03	; 3
    6454:	aa 0f       	add	r26, r26
    6456:	bb 1f       	adc	r27, r27
    6458:	9a 95       	dec	r25
    645a:	e1 f7       	brne	.-8      	; 0x6454 <FormSingle+0x10>
    645c:	ad 59       	subi	r26, 0x9D	; 157
    645e:	bd 4f       	sbci	r27, 0xFD	; 253
    6460:	9c 91       	ld	r25, X
    6462:	90 83       	st	Z, r25
	MB_Frame[MB_N][1] = MB_SingleQuery[MB_N].Func;
    6464:	11 96       	adiw	r26, 0x01	; 1
    6466:	9c 91       	ld	r25, X
    6468:	11 97       	sbiw	r26, 0x01	; 1
    646a:	91 83       	std	Z+1, r25	; 0x01
	MB_Frame[MB_N][2] = MB_SingleQuery[MB_N].StartAddr>>8;
    646c:	12 96       	adiw	r26, 0x02	; 2
    646e:	9c 91       	ld	r25, X
    6470:	12 97       	sbiw	r26, 0x02	; 2
    6472:	13 96       	adiw	r26, 0x03	; 3
    6474:	4c 91       	ld	r20, X
    6476:	13 97       	sbiw	r26, 0x03	; 3
    6478:	42 83       	std	Z+2, r20	; 0x02
	MB_Frame[MB_N][3] = MB_SingleQuery[MB_N].StartAddr;
    647a:	93 83       	std	Z+3, r25	; 0x03
	MB_Frame[MB_N][4] = MB_SingleQuery[MB_N].Qt>>8;
    647c:	14 96       	adiw	r26, 0x04	; 4
    647e:	9c 91       	ld	r25, X
    6480:	14 97       	sbiw	r26, 0x04	; 4
    6482:	15 96       	adiw	r26, 0x05	; 5
    6484:	4c 91       	ld	r20, X
    6486:	44 83       	std	Z+4, r20	; 0x04
	MB_Frame[MB_N][5] = MB_SingleQuery[MB_N].Qt;
    6488:	95 83       	std	Z+5, r25	; 0x05
	
	MB_SingleState[MB_N] = MB_SingleExec;
    648a:	f9 01       	movw	r30, r18
    648c:	ee 5d       	subi	r30, 0xDE	; 222
    648e:	f9 4f       	sbci	r31, 0xF9	; 249
    6490:	92 e0       	ldi	r25, 0x02	; 2
    6492:	90 83       	st	Z, r25
	FormData(MB_N);
    6494:	0c 94 e9 30 	jmp	0x61d2	; 0x61d2 <FormData>

00006498 <MB_FrameReg>:
    6498:	e8 2f       	mov	r30, r24
    649a:	f0 e0       	ldi	r31, 0x00	; 0
    649c:	70 e0       	ldi	r23, 0x00	; 0
    649e:	fe 2f       	mov	r31, r30
    64a0:	ee 27       	eor	r30, r30
    64a2:	df 01       	movw	r26, r30
    64a4:	a8 5b       	subi	r26, 0xB8	; 184
    64a6:	b2 4f       	sbci	r27, 0xF2	; 242
    64a8:	a6 0f       	add	r26, r22
    64aa:	b7 1f       	adc	r27, r23
    64ac:	11 96       	adiw	r26, 0x01	; 1
    64ae:	8c 91       	ld	r24, X
    64b0:	e6 0f       	add	r30, r22
    64b2:	f7 1f       	adc	r31, r23
    64b4:	e8 5b       	subi	r30, 0xB8	; 184
    64b6:	f2 4f       	sbci	r31, 0xF2	; 242
    64b8:	20 81       	ld	r18, Z
    64ba:	90 e0       	ldi	r25, 0x00	; 0
}
    64bc:	92 2b       	or	r25, r18
    64be:	08 95       	ret

000064c0 <MB_S_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_S_Timer_ISR(uint8_t MB_N)
{
    64c0:	2f 92       	push	r2
    64c2:	3f 92       	push	r3
    64c4:	4f 92       	push	r4
    64c6:	5f 92       	push	r5
    64c8:	6f 92       	push	r6
    64ca:	7f 92       	push	r7
    64cc:	8f 92       	push	r8
    64ce:	9f 92       	push	r9
    64d0:	af 92       	push	r10
    64d2:	bf 92       	push	r11
    64d4:	cf 92       	push	r12
    64d6:	df 92       	push	r13
    64d8:	ef 92       	push	r14
    64da:	ff 92       	push	r15
    64dc:	0f 93       	push	r16
    64de:	1f 93       	push	r17
    64e0:	cf 93       	push	r28
    64e2:	df 93       	push	r29
    64e4:	00 d0       	rcall	.+0      	; 0x64e6 <MB_S_Timer_ISR+0x26>
    64e6:	00 d0       	rcall	.+0      	; 0x64e8 <MB_S_Timer_ISR+0x28>
    64e8:	1f 92       	push	r1
    64ea:	cd b7       	in	r28, 0x3d	; 61
    64ec:	de b7       	in	r29, 0x3e	; 62
    64ee:	78 2e       	mov	r7, r24
	switch (MB_State[MB_N]) {
    64f0:	c8 2e       	mov	r12, r24
    64f2:	d1 2c       	mov	r13, r1
    64f4:	96 01       	movw	r18, r12
    64f6:	2f 51       	subi	r18, 0x1F	; 31
    64f8:	3c 4f       	sbci	r19, 0xFC	; 252
    64fa:	59 01       	movw	r10, r18
    64fc:	d9 01       	movw	r26, r18
    64fe:	8c 91       	ld	r24, X
    6500:	88 23       	and	r24, r24
    6502:	59 f0       	breq	.+22     	; 0x651a <MB_S_Timer_ISR+0x5a>
    6504:	82 30       	cpi	r24, 0x02	; 2
    6506:	09 f0       	breq	.+2      	; 0x650a <MB_S_Timer_ISR+0x4a>
    6508:	aa c2       	rjmp	.+1364   	; 0x6a5e <MB_S_Timer_ISR+0x59e>
	case MB_Initi:
		MB_State[MB_N] = MB_Idle;
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    650a:	84 e0       	ldi	r24, 0x04	; 4
    650c:	d9 01       	movw	r26, r18
    650e:	8c 93       	st	X, r24

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_S_CtrlProc(uint8_t MB_N)
{
	if (CommErr(MB_N)) {
    6510:	87 2d       	mov	r24, r7
    6512:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <CommErr>
    6516:	88 23       	and	r24, r24
    6518:	21 f0       	breq	.+8      	; 0x6522 <MB_S_Timer_ISR+0x62>
		MB_State[MB_N] = MB_Idle;
    651a:	81 e0       	ldi	r24, 0x01	; 1
    651c:	f5 01       	movw	r30, r10
    651e:	80 83       	st	Z, r24
    6520:	9e c2       	rjmp	.+1340   	; 0x6a5e <MB_S_Timer_ISR+0x59e>
		return;
	}
	if (MB_Frame[MB_N][0]!=0 && MB_Frame[MB_N][0]!=MB_NativeAddr[MB_N]) {
    6522:	3c 2d       	mov	r19, r12
    6524:	22 27       	eor	r18, r18
    6526:	3d 83       	std	Y+5, r19	; 0x05
    6528:	2c 83       	std	Y+4, r18	; 0x04
    652a:	f9 01       	movw	r30, r18
    652c:	e8 5b       	subi	r30, 0xB8	; 184
    652e:	f2 4f       	sbci	r31, 0xF2	; 242
    6530:	80 81       	ld	r24, Z
    6532:	88 23       	and	r24, r24
    6534:	51 f0       	breq	.+20     	; 0x654a <MB_S_Timer_ISR+0x8a>
    6536:	f6 01       	movw	r30, r12
    6538:	e8 50       	subi	r30, 0x08	; 8
    653a:	fc 4f       	sbci	r31, 0xFC	; 252
    653c:	90 81       	ld	r25, Z
    653e:	89 17       	cp	r24, r25
    6540:	21 f0       	breq	.+8      	; 0x654a <MB_S_Timer_ISR+0x8a>
		MB_State[MB_N] = MB_Idle;
    6542:	81 e0       	ldi	r24, 0x01	; 1
    6544:	d5 01       	movw	r26, r10
    6546:	8c 93       	st	X, r24
    6548:	8a c2       	rjmp	.+1300   	; 0x6a5e <MB_S_Timer_ISR+0x59e>
		return;
	}
	USART_Func(MB_N, LED);
    654a:	84 e1       	ldi	r24, 0x14	; 20
    654c:	8c 9d       	mul	r24, r12
    654e:	40 01       	movw	r8, r0
    6550:	8d 9d       	mul	r24, r13
    6552:	90 0c       	add	r9, r0
    6554:	11 24       	eor	r1, r1
    6556:	f4 01       	movw	r30, r8
    6558:	eb 54       	subi	r30, 0x4B	; 75
    655a:	f0 4b       	sbci	r31, 0xB0	; 176
    655c:	4f 01       	movw	r8, r30

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    655e:	25 91       	lpm	r18, Z+
    6560:	34 91       	lpm	r19, Z
    6562:	f9 01       	movw	r30, r18
    6564:	09 95       	icall
	MB_CPT[MB_N][3]++;
    6566:	86 01       	movw	r16, r12
    6568:	e4 e0       	ldi	r30, 0x04	; 4
    656a:	00 0f       	add	r16, r16
    656c:	11 1f       	adc	r17, r17
    656e:	ea 95       	dec	r30
    6570:	e1 f7       	brne	.-8      	; 0x656a <MB_S_Timer_ISR+0xaa>
    6572:	f8 01       	movw	r30, r16
    6574:	e7 5d       	subi	r30, 0xD7	; 215
    6576:	f4 4f       	sbci	r31, 0xF4	; 244
    6578:	86 81       	ldd	r24, Z+6	; 0x06
    657a:	97 81       	ldd	r25, Z+7	; 0x07
    657c:	01 96       	adiw	r24, 0x01	; 1
    657e:	97 83       	std	Z+7, r25	; 0x07
    6580:	86 83       	std	Z+6, r24	; 0x06

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6582:	ec 81       	ldd	r30, Y+4	; 0x04
    6584:	fd 81       	ldd	r31, Y+5	; 0x05
    6586:	e8 5b       	subi	r30, 0xB8	; 184
    6588:	f2 4f       	sbci	r31, 0xF2	; 242
    658a:	e2 80       	ldd	r14, Z+2	; 0x02
    658c:	f1 2c       	mov	r15, r1
    658e:	fe 2c       	mov	r15, r14
    6590:	ee 24       	eor	r14, r14
    6592:	83 81       	ldd	r24, Z+3	; 0x03
    6594:	e8 2a       	or	r14, r24
inline static uint8_t
Process(uint8_t MB_N)
{
	uint8_t Err;
	uint16_t StartAddr = MB_FrameReg(MB_N, 2);
	switch (MB_Frame[MB_N][1]) {
    6596:	61 81       	ldd	r22, Z+1	; 0x01
    6598:	86 2f       	mov	r24, r22
    659a:	90 e0       	ldi	r25, 0x00	; 0
    659c:	fc 01       	movw	r30, r24
    659e:	31 97       	sbiw	r30, 0x01	; 1
    65a0:	e0 31       	cpi	r30, 0x10	; 16
    65a2:	f1 05       	cpc	r31, r1
    65a4:	08 f0       	brcs	.+2      	; 0x65a8 <MB_S_Timer_ISR+0xe8>
    65a6:	ec c1       	rjmp	.+984    	; 0x6980 <MB_S_Timer_ISR+0x4c0>
    65a8:	ea 5b       	subi	r30, 0xBA	; 186
    65aa:	ff 4f       	sbci	r31, 0xFF	; 255
    65ac:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
*/
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadDiscr(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    65b0:	ec 81       	ldd	r30, Y+4	; 0x04
    65b2:	fd 81       	ldd	r31, Y+5	; 0x05
    65b4:	e8 5b       	subi	r30, 0xB8	; 184
    65b6:	f2 4f       	sbci	r31, 0xF2	; 242
    65b8:	80 81       	ld	r24, Z
    65ba:	88 23       	and	r24, r24
    65bc:	09 f4       	brne	.+2      	; 0x65c0 <MB_S_Timer_ISR+0x100>
    65be:	dd c0       	rjmp	.+442    	; 0x677a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    65c0:	d6 01       	movw	r26, r12
    65c2:	a7 52       	subi	r26, 0x27	; 39
    65c4:	b7 4f       	sbci	r27, 0xF7	; 247
    65c6:	8c 91       	ld	r24, X
    65c8:	88 30       	cpi	r24, 0x08	; 8
    65ca:	09 f0       	breq	.+2      	; 0x65ce <MB_S_Timer_ISR+0x10e>
    65cc:	8c c0       	rjmp	.+280    	; 0x66e6 <MB_S_Timer_ISR+0x226>
    65ce:	24 81       	ldd	r18, Z+4	; 0x04
    65d0:	30 e0       	ldi	r19, 0x00	; 0
    65d2:	32 2f       	mov	r19, r18
    65d4:	22 27       	eor	r18, r18
    65d6:	85 81       	ldd	r24, Z+5	; 0x05
    65d8:	28 2b       	or	r18, r24
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65da:	a9 01       	movw	r20, r18
    65dc:	4e 0d       	add	r20, r14
    65de:	5f 1d       	adc	r21, r15
    65e0:	f8 01       	movw	r30, r16
    65e2:	61 30       	cpi	r22, 0x01	; 1
    65e4:	61 f4       	brne	.+24     	; 0x65fe <MB_S_Timer_ISR+0x13e>
    65e6:	e8 52       	subi	r30, 0x28	; 40
    65e8:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    65ea:	85 91       	lpm	r24, Z+
    65ec:	94 91       	lpm	r25, Z
    65ee:	84 17       	cp	r24, r20
    65f0:	95 07       	cpc	r25, r21
    65f2:	08 f4       	brcc	.+2      	; 0x65f6 <MB_S_Timer_ISR+0x136>
    65f4:	96 c1       	rjmp	.+812    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    65f6:	f8 01       	movw	r30, r16
    65f8:	ea 52       	subi	r30, 0x2A	; 42
    65fa:	f0 4b       	sbci	r31, 0xB0	; 176
    65fc:	0b c0       	rjmp	.+22     	; 0x6614 <MB_S_Timer_ISR+0x154>
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
    65fe:	e4 52       	subi	r30, 0x24	; 36
    6600:	f0 4b       	sbci	r31, 0xB0	; 176
    6602:	85 91       	lpm	r24, Z+
    6604:	94 91       	lpm	r25, Z
    6606:	84 17       	cp	r24, r20
    6608:	95 07       	cpc	r25, r21
    660a:	08 f4       	brcc	.+2      	; 0x660e <MB_S_Timer_ISR+0x14e>
    660c:	8a c1       	rjmp	.+788    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    660e:	f8 01       	movw	r30, r16
    6610:	e6 52       	subi	r30, 0x26	; 38
    6612:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6614:	65 91       	lpm	r22, Z+
    6616:	74 91       	lpm	r23, Z
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
    6618:	e1 e0       	ldi	r30, 0x01	; 1
    661a:	a9 01       	movw	r20, r18
    661c:	47 70       	andi	r20, 0x07	; 7
    661e:	55 27       	eor	r21, r21
    6620:	45 2b       	or	r20, r21
    6622:	09 f4       	brne	.+2      	; 0x6626 <MB_S_Timer_ISR+0x166>
    6624:	e0 e0       	ldi	r30, 0x00	; 0
    6626:	c9 01       	movw	r24, r18
    6628:	43 e0       	ldi	r20, 0x03	; 3
    662a:	96 95       	lsr	r25
    662c:	87 95       	ror	r24
    662e:	4a 95       	dec	r20
    6630:	e1 f7       	brne	.-8      	; 0x662a <MB_S_Timer_ISR+0x16a>
    6632:	8e 0f       	add	r24, r30
    6634:	ec 81       	ldd	r30, Y+4	; 0x04
    6636:	fd 81       	ldd	r31, Y+5	; 0x05
    6638:	e8 5b       	subi	r30, 0xB8	; 184
    663a:	f2 4f       	sbci	r31, 0xF2	; 242
    663c:	82 83       	std	Z+2, r24	; 0x02
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
    663e:	8b 5f       	subi	r24, 0xFB	; 251
    6640:	8c 93       	st	X, r24
	for (uint8_t i=0; i<Qt; i++) {
    6642:	a0 e0       	ldi	r26, 0x00	; 0
		uint16_t j = StartAddr+i;
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    6644:	22 24       	eor	r2, r2
    6646:	23 94       	inc	r2
    6648:	31 2c       	mov	r3, r1
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    664a:	4a 2f       	mov	r20, r26
    664c:	50 e0       	ldi	r21, 0x00	; 0
    664e:	42 17       	cp	r20, r18
    6650:	53 07       	cpc	r21, r19
    6652:	08 f0       	brcs	.+2      	; 0x6656 <MB_S_Timer_ISR+0x196>
    6654:	93 c1       	rjmp	.+806    	; 0x697c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    6656:	4e 0d       	add	r20, r14
    6658:	5f 1d       	adc	r21, r15
		uint8_t Byte=3+i/8, Bit=1<<i%8;
    665a:	ba 2f       	mov	r27, r26
    665c:	b6 95       	lsr	r27
    665e:	b6 95       	lsr	r27
    6660:	b6 95       	lsr	r27
    6662:	bd 5f       	subi	r27, 0xFD	; 253
    6664:	8a 2f       	mov	r24, r26
    6666:	87 70       	andi	r24, 0x07	; 7
    6668:	21 01       	movw	r4, r2
    666a:	01 c0       	rjmp	.+2      	; 0x666e <MB_S_Timer_ISR+0x1ae>
    666c:	44 0c       	add	r4, r4
    666e:	8a 95       	dec	r24
    6670:	ea f7       	brpl	.-6      	; 0x666c <MB_S_Timer_ISR+0x1ac>
		if (Discr[j/8] &(1<<j%8))
    6672:	fa 01       	movw	r30, r20
    6674:	83 e0       	ldi	r24, 0x03	; 3
    6676:	f6 95       	lsr	r31
    6678:	e7 95       	ror	r30
    667a:	8a 95       	dec	r24
    667c:	e1 f7       	brne	.-8      	; 0x6676 <MB_S_Timer_ISR+0x1b6>
    667e:	e6 0f       	add	r30, r22
    6680:	f7 1f       	adc	r31, r23
    6682:	80 81       	ld	r24, Z
    6684:	90 e0       	ldi	r25, 0x00	; 0
    6686:	47 70       	andi	r20, 0x07	; 7
    6688:	55 27       	eor	r21, r21
    668a:	02 c0       	rjmp	.+4      	; 0x6690 <MB_S_Timer_ISR+0x1d0>
    668c:	95 95       	asr	r25
    668e:	87 95       	ror	r24
    6690:	4a 95       	dec	r20
    6692:	e2 f7       	brpl	.-8      	; 0x668c <MB_S_Timer_ISR+0x1cc>
    6694:	eb 2f       	mov	r30, r27
    6696:	f0 e0       	ldi	r31, 0x00	; 0
    6698:	80 ff       	sbrs	r24, 0
    669a:	0a c0       	rjmp	.+20     	; 0x66b0 <MB_S_Timer_ISR+0x1f0>
			MB_Frame[MB_N][Byte] |=Bit;
    669c:	8c 81       	ldd	r24, Y+4	; 0x04
    669e:	9d 81       	ldd	r25, Y+5	; 0x05
    66a0:	e8 0f       	add	r30, r24
    66a2:	f9 1f       	adc	r31, r25
    66a4:	e8 5b       	subi	r30, 0xB8	; 184
    66a6:	f2 4f       	sbci	r31, 0xF2	; 242
    66a8:	80 81       	ld	r24, Z
    66aa:	84 29       	or	r24, r4
    66ac:	80 83       	st	Z, r24
    66ae:	0a c0       	rjmp	.+20     	; 0x66c4 <MB_S_Timer_ISR+0x204>
		else
			MB_Frame[MB_N][Byte] &=~Bit;
    66b0:	8c 81       	ldd	r24, Y+4	; 0x04
    66b2:	9d 81       	ldd	r25, Y+5	; 0x05
    66b4:	e8 0f       	add	r30, r24
    66b6:	f9 1f       	adc	r31, r25
    66b8:	e8 5b       	subi	r30, 0xB8	; 184
    66ba:	f2 4f       	sbci	r31, 0xF2	; 242
    66bc:	40 94       	com	r4
    66be:	80 81       	ld	r24, Z
    66c0:	48 22       	and	r4, r24
    66c2:	40 82       	st	Z, r4
	if (StartAddr+Qt>(MB_Frame[MB_N][1]==1?prw(&Modbus_Map[MB_N].Coil_Qt):prw(&Modbus_Map[MB_N].Input_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
	MB_Frame[MB_N][2] = Qt/8+(Qt%8>0);
	MB_Frame_Sz[MB_N] = MB_Frame[MB_N][2]+5;
	for (uint8_t i=0; i<Qt; i++) {
    66c4:	af 5f       	subi	r26, 0xFF	; 255
    66c6:	c1 cf       	rjmp	.-126    	; 0x664a <MB_S_Timer_ISR+0x18a>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
    66c8:	ec 81       	ldd	r30, Y+4	; 0x04
    66ca:	fd 81       	ldd	r31, Y+5	; 0x05
    66cc:	e8 5b       	subi	r30, 0xB8	; 184
    66ce:	f2 4f       	sbci	r31, 0xF2	; 242
    66d0:	80 81       	ld	r24, Z
    66d2:	88 23       	and	r24, r24
    66d4:	09 f4       	brne	.+2      	; 0x66d8 <MB_S_Timer_ISR+0x218>
    66d6:	51 c0       	rjmp	.+162    	; 0x677a <MB_S_Timer_ISR+0x2ba>
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
    66d8:	96 01       	movw	r18, r12
    66da:	27 52       	subi	r18, 0x27	; 39
    66dc:	37 4f       	sbci	r19, 0xF7	; 247
    66de:	d9 01       	movw	r26, r18
    66e0:	8c 91       	ld	r24, X
    66e2:	88 30       	cpi	r24, 0x08	; 8
    66e4:	11 f0       	breq	.+4      	; 0x66ea <MB_S_Timer_ISR+0x22a>
		return MB_Frame[MB_N][2]=IllegData;
    66e6:	83 e0       	ldi	r24, 0x03	; 3
    66e8:	0f c1       	rjmp	.+542    	; 0x6908 <MB_S_Timer_ISR+0x448>
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    66ea:	75 81       	ldd	r23, Z+5	; 0x05
    66ec:	c7 01       	movw	r24, r14
    66ee:	87 0f       	add	r24, r23
    66f0:	91 1d       	adc	r25, r1
    66f2:	f8 01       	movw	r30, r16
    66f4:	63 30       	cpi	r22, 0x03	; 3
    66f6:	61 f4       	brne	.+24     	; 0x6710 <MB_S_Timer_ISR+0x250>
    66f8:	e0 52       	subi	r30, 0x20	; 32
    66fa:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    66fc:	45 91       	lpm	r20, Z+
    66fe:	54 91       	lpm	r21, Z
    6700:	48 17       	cp	r20, r24
    6702:	59 07       	cpc	r21, r25
    6704:	08 f4       	brcc	.+2      	; 0x6708 <MB_S_Timer_ISR+0x248>
    6706:	0d c1       	rjmp	.+538    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6708:	f8 01       	movw	r30, r16
    670a:	e2 52       	subi	r30, 0x22	; 34
    670c:	f0 4b       	sbci	r31, 0xB0	; 176
    670e:	0b c0       	rjmp	.+22     	; 0x6726 <MB_S_Timer_ISR+0x266>
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
    6710:	ec 51       	subi	r30, 0x1C	; 28
    6712:	f0 4b       	sbci	r31, 0xB0	; 176
    6714:	45 91       	lpm	r20, Z+
    6716:	54 91       	lpm	r21, Z
    6718:	48 17       	cp	r20, r24
    671a:	59 07       	cpc	r21, r25
    671c:	08 f4       	brcc	.+2      	; 0x6720 <MB_S_Timer_ISR+0x260>
    671e:	01 c1       	rjmp	.+514    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6720:	f8 01       	movw	r30, r16
    6722:	ee 51       	subi	r30, 0x1E	; 30
    6724:	f0 4b       	sbci	r31, 0xB0	; 176
    6726:	85 91       	lpm	r24, Z+
    6728:	94 91       	lpm	r25, Z
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
    672a:	77 0f       	add	r23, r23
    672c:	ac 81       	ldd	r26, Y+4	; 0x04
    672e:	bd 81       	ldd	r27, Y+5	; 0x05
    6730:	a8 5b       	subi	r26, 0xB8	; 184
    6732:	b2 4f       	sbci	r27, 0xF2	; 242
    6734:	12 96       	adiw	r26, 0x02	; 2
    6736:	7c 93       	st	X, r23
    6738:	12 97       	sbiw	r26, 0x02	; 2
    673a:	7b 5f       	subi	r23, 0xFB	; 251
    673c:	f9 01       	movw	r30, r18
    673e:	70 83       	st	Z, r23
	uint8_t Qt = MB_Frame[MB_N][5];
    6740:	15 96       	adiw	r26, 0x05	; 5
    6742:	5c 91       	ld	r21, X
    6744:	15 97       	sbiw	r26, 0x05	; 5
		return 0xFF;
	if (MB_Frame_Sz[MB_N]!=8)
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
    6746:	f7 01       	movw	r30, r14
    6748:	ee 0f       	add	r30, r30
    674a:	ff 1f       	adc	r31, r31
    674c:	e8 0f       	add	r30, r24
    674e:	f9 1f       	adc	r31, r25
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6750:	40 e0       	ldi	r20, 0x00	; 0
		uint8_t j = i*2;
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    6752:	cd 01       	movw	r24, r26
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6754:	45 17       	cp	r20, r21
    6756:	09 f4       	brne	.+2      	; 0x675a <MB_S_Timer_ISR+0x29a>
    6758:	11 c1       	rjmp	.+546    	; 0x697c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
    675a:	64 2f       	mov	r22, r20
    675c:	66 0f       	add	r22, r22
		MB_Frame[MB_N][3+j] = Reg[i]>>8;
    675e:	7c 01       	movw	r14, r24
    6760:	e6 0e       	add	r14, r22
    6762:	f1 1c       	adc	r15, r1
    6764:	61 81       	ldd	r22, Z+1	; 0x01
    6766:	d7 01       	movw	r26, r14
    6768:	13 96       	adiw	r26, 0x03	; 3
    676a:	6c 93       	st	X, r22
		MB_Frame[MB_N][4+j] = Reg[i];
    676c:	20 81       	ld	r18, Z
    676e:	32 96       	adiw	r30, 0x02	; 2
    6770:	d7 01       	movw	r26, r14
    6772:	14 96       	adiw	r26, 0x04	; 4
    6774:	2c 93       	st	X, r18
	if (StartAddr+MB_Frame[MB_N][5]>(MB_Frame[MB_N][1]==3?prw(&Modbus_Map[MB_N].HoldReg_Qt):prw(&Modbus_Map[MB_N].InReg_Qt)))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint16_t *Reg = (uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg)) + StartAddr;
	MB_Frame_Sz[MB_N] = (MB_Frame[MB_N][2] = MB_Frame[MB_N][5]*2) + 5;
	uint8_t Qt = MB_Frame[MB_N][5];
	for (uint8_t i=0; i<Qt; i++) {
    6776:	4f 5f       	subi	r20, 0xFF	; 255
    6778:	ed cf       	rjmp	.-38     	; 0x6754 <MB_S_Timer_ISR+0x294>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_ReadReg(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame[MB_N][0]==0)
		return 0xFF;
    677a:	9f ef       	ldi	r25, 0xFF	; 255
    677c:	08 c1       	rjmp	.+528    	; 0x698e <MB_S_Timer_ISR+0x4ce>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_PresetSingle(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=8)
    677e:	d6 01       	movw	r26, r12
    6780:	a7 52       	subi	r26, 0x27	; 39
    6782:	b7 4f       	sbci	r27, 0xF7	; 247
    6784:	8c 91       	ld	r24, X
    6786:	88 30       	cpi	r24, 0x08	; 8
    6788:	09 f0       	breq	.+2      	; 0x678c <MB_S_Timer_ISR+0x2cc>
    678a:	b9 c0       	rjmp	.+370    	; 0x68fe <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+1>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    678c:	f8 01       	movw	r30, r16
    678e:	e0 52       	subi	r30, 0x20	; 32
    6790:	f0 4b       	sbci	r31, 0xB0	; 176
    6792:	85 91       	lpm	r24, Z+
    6794:	94 91       	lpm	r25, Z
    6796:	97 01       	movw	r18, r14
    6798:	2f 5f       	subi	r18, 0xFF	; 255
    679a:	3f 4f       	sbci	r19, 0xFF	; 255
    679c:	82 17       	cp	r24, r18
    679e:	93 07       	cpc	r25, r19
    67a0:	08 f4       	brcc	.+2      	; 0x67a4 <MB_S_Timer_ISR+0x2e4>
    67a2:	bf c0       	rjmp	.+382    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
    67a4:	88 e0       	ldi	r24, 0x08	; 8
    67a6:	8c 93       	st	X, r24
	*((uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+StartAddr) = MB_FrameReg(MB_N, 4);
    67a8:	f8 01       	movw	r30, r16
    67aa:	e2 52       	subi	r30, 0x22	; 34
    67ac:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    67ae:	85 91       	lpm	r24, Z+
    67b0:	94 91       	lpm	r25, Z
    67b2:	f7 01       	movw	r30, r14
    67b4:	ee 0f       	add	r30, r30
    67b6:	ff 1f       	adc	r31, r31
    67b8:	e8 0f       	add	r30, r24
    67ba:	f9 1f       	adc	r31, r25
    67bc:	ac 81       	ldd	r26, Y+4	; 0x04
    67be:	bd 81       	ldd	r27, Y+5	; 0x05
    67c0:	a8 5b       	subi	r26, 0xB8	; 184
    67c2:	b2 4f       	sbci	r27, 0xF2	; 242
    67c4:	14 96       	adiw	r26, 0x04	; 4
    67c6:	8c 91       	ld	r24, X
    67c8:	14 97       	sbiw	r26, 0x04	; 4
    67ca:	90 e0       	ldi	r25, 0x00	; 0
    67cc:	98 2f       	mov	r25, r24
    67ce:	88 27       	eor	r24, r24
    67d0:	15 96       	adiw	r26, 0x05	; 5
    67d2:	2c 91       	ld	r18, X
    67d4:	82 2b       	or	r24, r18
    67d6:	91 83       	std	Z+1, r25	; 0x01
    67d8:	80 83       	st	Z, r24
    67da:	d0 c0       	rjmp	.+416    	; 0x697c <MB_S_Timer_ISR+0x4bc>
    67dc:	ec 81       	ldd	r30, Y+4	; 0x04
    67de:	fd 81       	ldd	r31, Y+5	; 0x05
    67e0:	e8 5b       	subi	r30, 0xB8	; 184
    67e2:	f2 4f       	sbci	r31, 0xF2	; 242
    67e4:	64 80       	ldd	r6, Z+4	; 0x04
    67e6:	85 81       	ldd	r24, Z+5	; 0x05
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Force(uint8_t MB_N, uint16_t StartAddr)
{
	uint16_t Qt = MB_FrameReg(MB_N, 4);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || Qt/8+(Qt%8>0)!=MB_Frame[MB_N][6])
    67e8:	66 81       	ldd	r22, Z+6	; 0x06
    67ea:	d6 01       	movw	r26, r12
    67ec:	a7 52       	subi	r26, 0x27	; 39
    67ee:	b7 4f       	sbci	r27, 0xF7	; 247
    67f0:	4c 91       	ld	r20, X
    67f2:	50 e0       	ldi	r21, 0x00	; 0
    67f4:	70 e0       	ldi	r23, 0x00	; 0
    67f6:	9b 01       	movw	r18, r22
    67f8:	27 5f       	subi	r18, 0xF7	; 247
    67fa:	3f 4f       	sbci	r19, 0xFF	; 255
    67fc:	42 17       	cp	r20, r18
    67fe:	53 07       	cpc	r21, r19
    6800:	09 f0       	breq	.+2      	; 0x6804 <MB_S_Timer_ISR+0x344>
    6802:	7d c0       	rjmp	.+250    	; 0x68fe <MB_S_Timer_ISR+0x43e>
    6804:	90 e0       	ldi	r25, 0x00	; 0
    6806:	96 29       	or	r25, r6
    6808:	9c 01       	movw	r18, r24
    680a:	27 70       	andi	r18, 0x07	; 7
    680c:	33 27       	eor	r19, r19
    680e:	41 e0       	ldi	r20, 0x01	; 1
    6810:	50 e0       	ldi	r21, 0x00	; 0
    6812:	23 2b       	or	r18, r19
    6814:	11 f4       	brne	.+4      	; 0x681a <MB_S_Timer_ISR+0x35a>
    6816:	40 e0       	ldi	r20, 0x00	; 0
    6818:	50 e0       	ldi	r21, 0x00	; 0
    681a:	9c 01       	movw	r18, r24
    681c:	e3 e0       	ldi	r30, 0x03	; 3
    681e:	36 95       	lsr	r19
    6820:	27 95       	ror	r18
    6822:	ea 95       	dec	r30
    6824:	e1 f7       	brne	.-8      	; 0x681e <MB_S_Timer_ISR+0x35e>
    6826:	24 0f       	add	r18, r20
    6828:	35 1f       	adc	r19, r21
    682a:	26 17       	cp	r18, r22
    682c:	37 07       	cpc	r19, r23
    682e:	09 f0       	breq	.+2      	; 0x6832 <MB_S_Timer_ISR+0x372>
    6830:	66 c0       	rjmp	.+204    	; 0x68fe <MB_S_Timer_ISR+0x43e>
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
    6832:	f8 01       	movw	r30, r16
    6834:	e8 52       	subi	r30, 0x28	; 40
    6836:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6838:	25 91       	lpm	r18, Z+
    683a:	34 91       	lpm	r19, Z
    683c:	ac 01       	movw	r20, r24
    683e:	4e 0d       	add	r20, r14
    6840:	5f 1d       	adc	r21, r15
    6842:	24 17       	cp	r18, r20
    6844:	35 07       	cpc	r19, r21
    6846:	08 f4       	brcc	.+2      	; 0x684a <MB_S_Timer_ISR+0x38a>
    6848:	6c c0       	rjmp	.+216    	; 0x6922 <MB_S_Timer_ISR+0x462>
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
    684a:	f8 01       	movw	r30, r16
    684c:	ea 52       	subi	r30, 0x2A	; 42
    684e:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6850:	25 90       	lpm	r2, Z+
    6852:	34 90       	lpm	r3, Z
	MB_Frame_Sz[MB_N] = 8;
    6854:	28 e0       	ldi	r18, 0x08	; 8
    6856:	2c 93       	st	X, r18
	for (uint8_t i=0; i<Qt; i++) {
    6858:	51 2c       	mov	r5, r1
		uint16_t j = StartAddr+i;
		uint16_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    685a:	6c 81       	ldd	r22, Y+4	; 0x04
    685c:	7d 81       	ldd	r23, Y+5	; 0x05
    685e:	68 5b       	subi	r22, 0xB8	; 184
    6860:	72 4f       	sbci	r23, 0xF2	; 242
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    6862:	45 2d       	mov	r20, r5
    6864:	50 e0       	ldi	r21, 0x00	; 0
    6866:	48 17       	cp	r20, r24
    6868:	59 07       	cpc	r21, r25
    686a:	08 f0       	brcs	.+2      	; 0x686e <MB_S_Timer_ISR+0x3ae>
    686c:	87 c0       	rjmp	.+270    	; 0x697c <MB_S_Timer_ISR+0x4bc>
		uint16_t j = StartAddr+i;
    686e:	4e 0d       	add	r20, r14
    6870:	5f 1d       	adc	r21, r15
		uint16_t Byte=j/8, Bit=1<<j%8;
    6872:	fa 01       	movw	r30, r20
    6874:	a3 e0       	ldi	r26, 0x03	; 3
    6876:	f6 95       	lsr	r31
    6878:	e7 95       	ror	r30
    687a:	aa 95       	dec	r26
    687c:	e1 f7       	brne	.-8      	; 0x6876 <MB_S_Timer_ISR+0x3b6>
    687e:	47 70       	andi	r20, 0x07	; 7
    6880:	55 27       	eor	r21, r21
    6882:	21 e0       	ldi	r18, 0x01	; 1
    6884:	30 e0       	ldi	r19, 0x00	; 0
    6886:	02 c0       	rjmp	.+4      	; 0x688c <MB_S_Timer_ISR+0x3cc>
    6888:	22 0f       	add	r18, r18
    688a:	33 1f       	adc	r19, r19
    688c:	4a 95       	dec	r20
    688e:	e2 f7       	brpl	.-8      	; 0x6888 <MB_S_Timer_ISR+0x3c8>
    6890:	a9 01       	movw	r20, r18
		if (MB_Frame[MB_N][7+i/8] &(1<<i%8))
    6892:	25 2d       	mov	r18, r5
    6894:	26 95       	lsr	r18
    6896:	26 95       	lsr	r18
    6898:	26 95       	lsr	r18
    689a:	db 01       	movw	r26, r22
    689c:	a2 0f       	add	r26, r18
    689e:	b1 1d       	adc	r27, r1
    68a0:	17 96       	adiw	r26, 0x07	; 7
    68a2:	2c 91       	ld	r18, X
    68a4:	30 e0       	ldi	r19, 0x00	; 0
    68a6:	a5 2d       	mov	r26, r5
    68a8:	a7 70       	andi	r26, 0x07	; 7
    68aa:	02 c0       	rjmp	.+4      	; 0x68b0 <MB_S_Timer_ISR+0x3f0>
    68ac:	35 95       	asr	r19
    68ae:	27 95       	ror	r18
    68b0:	aa 95       	dec	r26
    68b2:	e2 f7       	brpl	.-8      	; 0x68ac <MB_S_Timer_ISR+0x3ec>
    68b4:	e2 0d       	add	r30, r2
    68b6:	f3 1d       	adc	r31, r3
    68b8:	20 ff       	sbrs	r18, 0
    68ba:	03 c0       	rjmp	.+6      	; 0x68c2 <MB_S_Timer_ISR+0x402>
			Coil[Byte] |=Bit;
    68bc:	20 81       	ld	r18, Z
    68be:	24 2b       	or	r18, r20
    68c0:	03 c0       	rjmp	.+6      	; 0x68c8 <MB_S_Timer_ISR+0x408>
		else
			Coil[Byte] &=~Bit;
    68c2:	40 95       	com	r20
    68c4:	20 81       	ld	r18, Z
    68c6:	24 23       	and	r18, r20
    68c8:	20 83       	st	Z, r18
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+Qt > prw(&Modbus_Map[MB_N].Coil_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	uint8_t *Coil = prp(&Modbus_Map[MB_N].Coil);
	MB_Frame_Sz[MB_N] = 8;
	for (uint8_t i=0; i<Qt; i++) {
    68ca:	53 94       	inc	r5
    68cc:	ca cf       	rjmp	.-108    	; 0x6862 <MB_S_Timer_ISR+0x3a2>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_S_Preset(uint8_t MB_N, uint16_t StartAddr)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][6]+9 || MB_Frame[MB_N][5]*2!=MB_Frame[MB_N][6])
    68ce:	ec 81       	ldd	r30, Y+4	; 0x04
    68d0:	fd 81       	ldd	r31, Y+5	; 0x05
    68d2:	e8 5b       	subi	r30, 0xB8	; 184
    68d4:	f2 4f       	sbci	r31, 0xF2	; 242
    68d6:	46 81       	ldd	r20, Z+6	; 0x06
    68d8:	50 e0       	ldi	r21, 0x00	; 0
    68da:	d6 01       	movw	r26, r12
    68dc:	a7 52       	subi	r26, 0x27	; 39
    68de:	b7 4f       	sbci	r27, 0xF7	; 247
    68e0:	2c 91       	ld	r18, X
    68e2:	30 e0       	ldi	r19, 0x00	; 0
    68e4:	ca 01       	movw	r24, r20
    68e6:	09 96       	adiw	r24, 0x09	; 9
    68e8:	28 17       	cp	r18, r24
    68ea:	39 07       	cpc	r19, r25
    68ec:	41 f4       	brne	.+16     	; 0x68fe <MB_S_Timer_ISR+0x43e>
    68ee:	85 81       	ldd	r24, Z+5	; 0x05
    68f0:	90 e0       	ldi	r25, 0x00	; 0
    68f2:	9c 01       	movw	r18, r24
    68f4:	22 0f       	add	r18, r18
    68f6:	33 1f       	adc	r19, r19
    68f8:	24 17       	cp	r18, r20
    68fa:	35 07       	cpc	r19, r21
    68fc:	41 f0       	breq	.+16     	; 0x690e <MB_S_Timer_ISR+0x44e>
		return MB_Frame[MB_N][2]=IllegData;
    68fe:	83 e0       	ldi	r24, 0x03	; 3
    6900:	ec 81       	ldd	r30, Y+4	; 0x04
    6902:	fd 81       	ldd	r31, Y+5	; 0x05
    6904:	e8 5b       	subi	r30, 0xB8	; 184
    6906:	f2 4f       	sbci	r31, 0xF2	; 242
    6908:	82 83       	std	Z+2, r24	; 0x02
    690a:	93 e0       	ldi	r25, 0x03	; 3
    690c:	40 c0       	rjmp	.+128    	; 0x698e <MB_S_Timer_ISR+0x4ce>
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
    690e:	f8 01       	movw	r30, r16
    6910:	e0 52       	subi	r30, 0x20	; 32
    6912:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6914:	25 91       	lpm	r18, Z+
    6916:	34 91       	lpm	r19, Z
    6918:	8e 0d       	add	r24, r14
    691a:	9f 1d       	adc	r25, r15
    691c:	28 17       	cp	r18, r24
    691e:	39 07       	cpc	r19, r25
    6920:	40 f4       	brcc	.+16     	; 0x6932 <MB_S_Timer_ISR+0x472>
		return MB_Frame[MB_N][2]=IllegAddr;
    6922:	82 e0       	ldi	r24, 0x02	; 2
    6924:	ec 81       	ldd	r30, Y+4	; 0x04
    6926:	fd 81       	ldd	r31, Y+5	; 0x05
    6928:	e8 5b       	subi	r30, 0xB8	; 184
    692a:	f2 4f       	sbci	r31, 0xF2	; 242
    692c:	82 83       	std	Z+2, r24	; 0x02
    692e:	92 e0       	ldi	r25, 0x02	; 2
    6930:	2e c0       	rjmp	.+92     	; 0x698e <MB_S_Timer_ISR+0x4ce>
	MB_Frame_Sz[MB_N] = 8;
    6932:	88 e0       	ldi	r24, 0x08	; 8
    6934:	8c 93       	st	X, r24
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
    6936:	f8 01       	movw	r30, r16
    6938:	e2 52       	subi	r30, 0x22	; 34
    693a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    693c:	25 90       	lpm	r2, Z+
    693e:	34 90       	lpm	r3, Z
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6940:	61 2c       	mov	r6, r1
    6942:	2c 81       	ldd	r18, Y+4	; 0x04
    6944:	3d 81       	ldd	r19, Y+5	; 0x05
    6946:	23 5b       	subi	r18, 0xB3	; 179
    6948:	32 4f       	sbci	r19, 0xF2	; 242
    694a:	3a 83       	std	Y+2, r19	; 0x02
    694c:	29 83       	std	Y+1, r18	; 0x01
    694e:	e9 81       	ldd	r30, Y+1	; 0x01
    6950:	fa 81       	ldd	r31, Y+2	; 0x02
    6952:	80 81       	ld	r24, Z
    6954:	68 16       	cp	r6, r24
    6956:	90 f4       	brcc	.+36     	; 0x697c <MB_S_Timer_ISR+0x4bc>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
    6958:	27 01       	movw	r4, r14
    695a:	46 0c       	add	r4, r6
    695c:	51 1c       	adc	r5, r1
    695e:	44 0c       	add	r4, r4
    6960:	55 1c       	adc	r5, r5
    6962:	42 0c       	add	r4, r2
    6964:	53 1c       	adc	r5, r3
    6966:	66 2d       	mov	r22, r6
    6968:	66 0f       	add	r22, r22
    696a:	69 5f       	subi	r22, 0xF9	; 249
    696c:	87 2d       	mov	r24, r7
    696e:	0e 94 4c 32 	call	0x6498	; 0x6498 <MB_FrameReg>
    6972:	d2 01       	movw	r26, r4
    6974:	8d 93       	st	X+, r24
    6976:	9c 93       	st	X, r25
		return MB_Frame[MB_N][2]=IllegData;
	if (StartAddr+MB_Frame[MB_N][5]>prw(&Modbus_Map[MB_N].HoldReg_Qt))
		return MB_Frame[MB_N][2]=IllegAddr;
	MB_Frame_Sz[MB_N] = 8;
	uint16_t *HoldReg = prp(&Modbus_Map[MB_N].HoldReg);
	for (uint8_t i=0; i<MB_Frame[MB_N][5]; i++) {
    6978:	63 94       	inc	r6
    697a:	e9 cf       	rjmp	.-46     	; 0x694e <MB_S_Timer_ISR+0x48e>
		uint8_t j = i*2;
		HoldReg[StartAddr+i] = MB_FrameReg(MB_N, 7+j);
	}
	return 0;
    697c:	90 e0       	ldi	r25, 0x00	; 0
    697e:	07 c0       	rjmp	.+14     	; 0x698e <MB_S_Timer_ISR+0x4ce>
		break;
	case 0x10:
		Err = MB_S_Preset(MB_N, StartAddr);
		break;
	default:
		Err = MB_Frame[MB_N][2] = IllegFunc;
    6980:	81 e0       	ldi	r24, 0x01	; 1
    6982:	ec 81       	ldd	r30, Y+4	; 0x04
    6984:	fd 81       	ldd	r31, Y+5	; 0x05
    6986:	e8 5b       	subi	r30, 0xB8	; 184
    6988:	f2 4f       	sbci	r31, 0xF2	; 242
    698a:	82 83       	std	Z+2, r24	; 0x02
    698c:	91 e0       	ldi	r25, 0x01	; 1
		break;
	}
	if (MB_Frame[MB_N][0]) {
    698e:	ec 81       	ldd	r30, Y+4	; 0x04
    6990:	fd 81       	ldd	r31, Y+5	; 0x05
    6992:	e8 5b       	subi	r30, 0xB8	; 184
    6994:	f2 4f       	sbci	r31, 0xF2	; 242
    6996:	80 81       	ld	r24, Z
    6998:	88 23       	and	r24, r24
    699a:	79 f0       	breq	.+30     	; 0x69ba <MB_S_Timer_ISR+0x4fa>
		if (Err) {
    699c:	99 23       	and	r25, r25
    699e:	41 f0       	breq	.+16     	; 0x69b0 <MB_S_Timer_ISR+0x4f0>
			MB_Frame[MB_N][1] |=(1<<7);
    69a0:	81 81       	ldd	r24, Z+1	; 0x01
    69a2:	80 68       	ori	r24, 0x80	; 128
    69a4:	81 83       	std	Z+1, r24	; 0x01
			MB_Frame_Sz[MB_N] = 5;
    69a6:	f6 01       	movw	r30, r12
    69a8:	e7 52       	subi	r30, 0x27	; 39
    69aa:	f7 4f       	sbci	r31, 0xF7	; 247
    69ac:	85 e0       	ldi	r24, 0x05	; 5
    69ae:	80 83       	st	Z, r24
		}
		SetCRC_MB(MB_N);
    69b0:	87 2d       	mov	r24, r7
    69b2:	9b 83       	std	Y+3, r25	; 0x03
    69b4:	0e 94 cd 30 	call	0x619a	; 0x619a <SetCRC_MB>
    69b8:	9b 81       	ldd	r25, Y+3	; 0x03
		MB_State[MB_N] = MB_Idle;
		return;
	}
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
    69ba:	99 23       	and	r25, r25
    69bc:	41 f0       	breq	.+16     	; 0x69ce <MB_S_Timer_ISR+0x50e>
		MB_CPT[MB_N][2]++;
    69be:	f8 01       	movw	r30, r16
    69c0:	e7 5d       	subi	r30, 0xD7	; 215
    69c2:	f4 4f       	sbci	r31, 0xF4	; 244
    69c4:	84 81       	ldd	r24, Z+4	; 0x04
    69c6:	95 81       	ldd	r25, Z+5	; 0x05
    69c8:	01 96       	adiw	r24, 0x01	; 1
    69ca:	95 83       	std	Z+5, r25	; 0x05
    69cc:	84 83       	std	Z+4, r24	; 0x04
	if (MB_Frame[MB_N][0])
    69ce:	ec 81       	ldd	r30, Y+4	; 0x04
    69d0:	fd 81       	ldd	r31, Y+5	; 0x05
    69d2:	e8 5b       	subi	r30, 0xB8	; 184
    69d4:	f2 4f       	sbci	r31, 0xF2	; 242
    69d6:	80 81       	ld	r24, Z
    69d8:	88 23       	and	r24, r24
    69da:	d1 f0       	breq	.+52     	; 0x6a10 <MB_S_Timer_ISR+0x550>
		MB_Transm(MB_N);
    69dc:	87 2d       	mov	r24, r7
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    69de:	0f 90       	pop	r0
    69e0:	0f 90       	pop	r0
    69e2:	0f 90       	pop	r0
    69e4:	0f 90       	pop	r0
    69e6:	0f 90       	pop	r0
    69e8:	df 91       	pop	r29
    69ea:	cf 91       	pop	r28
    69ec:	1f 91       	pop	r17
    69ee:	0f 91       	pop	r16
    69f0:	ff 90       	pop	r15
    69f2:	ef 90       	pop	r14
    69f4:	df 90       	pop	r13
    69f6:	cf 90       	pop	r12
    69f8:	bf 90       	pop	r11
    69fa:	af 90       	pop	r10
    69fc:	9f 90       	pop	r9
    69fe:	8f 90       	pop	r8
    6a00:	7f 90       	pop	r7
    6a02:	6f 90       	pop	r6
    6a04:	5f 90       	pop	r5
    6a06:	4f 90       	pop	r4
    6a08:	3f 90       	pop	r3
    6a0a:	2f 90       	pop	r2
	USART_Func(MB_N, LED);
	MB_CPT[MB_N][3]++;
	if (Process(MB_N))
		MB_CPT[MB_N][2]++;
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
    6a0c:	0c 94 cb 2f 	jmp	0x5f96	; 0x5f96 <MB_Transm>
	else {
		MB_CPT[MB_N][4]++;
    6a10:	f8 01       	movw	r30, r16
    6a12:	e7 5d       	subi	r30, 0xD7	; 215
    6a14:	f4 4f       	sbci	r31, 0xF4	; 244
    6a16:	80 85       	ldd	r24, Z+8	; 0x08
    6a18:	91 85       	ldd	r25, Z+9	; 0x09
    6a1a:	01 96       	adiw	r24, 0x01	; 1
    6a1c:	91 87       	std	Z+9, r25	; 0x09
    6a1e:	80 87       	std	Z+8, r24	; 0x08
		MB_State[MB_N] = MB_Idle;
    6a20:	81 e0       	ldi	r24, 0x01	; 1
    6a22:	d5 01       	movw	r26, r10
    6a24:	8c 93       	st	X, r24
    6a26:	f4 01       	movw	r30, r8
    6a28:	85 91       	lpm	r24, Z+
    6a2a:	94 91       	lpm	r25, Z
		USART_Func(MB_N, LED);
    6a2c:	fc 01       	movw	r30, r24
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a2e:	0f 90       	pop	r0
    6a30:	0f 90       	pop	r0
    6a32:	0f 90       	pop	r0
    6a34:	0f 90       	pop	r0
    6a36:	0f 90       	pop	r0
    6a38:	df 91       	pop	r29
    6a3a:	cf 91       	pop	r28
    6a3c:	1f 91       	pop	r17
    6a3e:	0f 91       	pop	r16
    6a40:	ff 90       	pop	r15
    6a42:	ef 90       	pop	r14
    6a44:	df 90       	pop	r13
    6a46:	cf 90       	pop	r12
    6a48:	bf 90       	pop	r11
    6a4a:	af 90       	pop	r10
    6a4c:	9f 90       	pop	r9
    6a4e:	8f 90       	pop	r8
    6a50:	7f 90       	pop	r7
    6a52:	6f 90       	pop	r6
    6a54:	5f 90       	pop	r5
    6a56:	4f 90       	pop	r4
    6a58:	3f 90       	pop	r3
    6a5a:	2f 90       	pop	r2
	if (MB_Frame[MB_N][0])
		MB_Transm(MB_N);
	else {
		MB_CPT[MB_N][4]++;
		MB_State[MB_N] = MB_Idle;
		USART_Func(MB_N, LED);
    6a5c:	09 94       	ijmp
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_S_CtrlProc(MB_N);
		break;
	}
}
    6a5e:	0f 90       	pop	r0
    6a60:	0f 90       	pop	r0
    6a62:	0f 90       	pop	r0
    6a64:	0f 90       	pop	r0
    6a66:	0f 90       	pop	r0
    6a68:	df 91       	pop	r29
    6a6a:	cf 91       	pop	r28
    6a6c:	1f 91       	pop	r17
    6a6e:	0f 91       	pop	r16
    6a70:	ff 90       	pop	r15
    6a72:	ef 90       	pop	r14
    6a74:	df 90       	pop	r13
    6a76:	cf 90       	pop	r12
    6a78:	bf 90       	pop	r11
    6a7a:	af 90       	pop	r10
    6a7c:	9f 90       	pop	r9
    6a7e:	8f 90       	pop	r8
    6a80:	7f 90       	pop	r7
    6a82:	6f 90       	pop	r6
    6a84:	5f 90       	pop	r5
    6a86:	4f 90       	pop	r4
    6a88:	3f 90       	pop	r3
    6a8a:	2f 90       	pop	r2
    6a8c:	08 95       	ret

00006a8e <MB_S_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_S_Tx(uint8_t MB_N)
{
	USART_Func(MB_N, LED);
    6a8e:	24 e1       	ldi	r18, 0x14	; 20
    6a90:	82 9f       	mul	r24, r18
    6a92:	c0 01       	movw	r24, r0
    6a94:	11 24       	eor	r1, r1
    6a96:	8b 54       	subi	r24, 0x4B	; 75
    6a98:	90 4b       	sbci	r25, 0xB0	; 176
    6a9a:	fc 01       	movw	r30, r24
    6a9c:	85 91       	lpm	r24, Z+
    6a9e:	94 91       	lpm	r25, Z
    6aa0:	fc 01       	movw	r30, r24
    6aa2:	09 94       	ijmp

00006aa4 <MB_S_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_S_Init(uint8_t MB_N)
{
    6aa4:	cf 93       	push	r28
    6aa6:	df 93       	push	r29
	#ifndef MB_ADDR_DIP_SW
		MB_NativeAddr[MB_N] = erb(MB_NativeAddr_EE+MB_N);
    6aa8:	c8 2f       	mov	r28, r24
    6aaa:	d0 e0       	ldi	r29, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6aac:	ce 01       	movw	r24, r28
    6aae:	8e 55       	subi	r24, 0x5E	; 94
    6ab0:	9e 4f       	sbci	r25, 0xFE	; 254
    6ab2:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    6ab6:	c8 50       	subi	r28, 0x08	; 8
    6ab8:	dc 4f       	sbci	r29, 0xFC	; 252
    6aba:	88 83       	st	Y, r24
	#endif
}
    6abc:	df 91       	pop	r29
    6abe:	cf 91       	pop	r28
    6ac0:	08 95       	ret

00006ac2 <MB_M_Init>:
}

// ~~~~~~~~~~~~~~~~~~~~
void
MB_M_Init(uint8_t MB_N)
{
    6ac2:	0f 93       	push	r16
    6ac4:	1f 93       	push	r17
    6ac6:	cf 93       	push	r28
    6ac8:	df 93       	push	r29
	MB_M_Period[MB_N]		= erw(&MB_M_Param_EE[MB_N].Period);
    6aca:	c8 2f       	mov	r28, r24
    6acc:	d0 e0       	ldi	r29, 0x00	; 0
    6ace:	95 e0       	ldi	r25, 0x05	; 5
    6ad0:	89 9f       	mul	r24, r25
    6ad2:	80 01       	movw	r16, r0
    6ad4:	11 24       	eor	r1, r1
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    6ad6:	c8 01       	movw	r24, r16
    6ad8:	86 56       	subi	r24, 0x66	; 102
    6ada:	9e 4f       	sbci	r25, 0xFE	; 254
    6adc:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    6ae0:	fe 01       	movw	r30, r28
    6ae2:	ee 0f       	add	r30, r30
    6ae4:	ff 1f       	adc	r31, r31
    6ae6:	e0 5e       	subi	r30, 0xE0	; 224
    6ae8:	f9 4f       	sbci	r31, 0xF9	; 249
    6aea:	91 83       	std	Z+1, r25	; 0x01
    6aec:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    6aee:	c8 01       	movw	r24, r16
    6af0:	84 56       	subi	r24, 0x64	; 100
    6af2:	9e 4f       	sbci	r25, 0xFE	; 254
    6af4:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MB_M_Timeout[MB_N]	= erb(&MB_M_Param_EE[MB_N].Timeout);
    6af8:	fe 01       	movw	r30, r28
    6afa:	ee 5e       	subi	r30, 0xEE	; 238
    6afc:	f4 4f       	sbci	r31, 0xF4	; 244
    6afe:	80 83       	st	Z, r24
    6b00:	c8 01       	movw	r24, r16
    6b02:	83 56       	subi	r24, 0x63	; 99
    6b04:	9e 4f       	sbci	r25, 0xFE	; 254
    6b06:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MB_M_Try[MB_N]			= erb(&MB_M_Param_EE[MB_N].Try);
    6b0a:	fe 01       	movw	r30, r28
    6b0c:	ec 52       	subi	r30, 0x2C	; 44
    6b0e:	f7 4f       	sbci	r31, 0xF7	; 247
    6b10:	80 83       	st	Z, r24
    6b12:	c8 01       	movw	r24, r16
    6b14:	82 56       	subi	r24, 0x62	; 98
    6b16:	9e 4f       	sbci	r25, 0xFE	; 254
    6b18:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	MB_M_TimeOff[MB_N]	= erb(&MB_M_Param_EE[MB_N].TimeOff);
    6b1c:	c6 51       	subi	r28, 0x16	; 22
    6b1e:	dc 4f       	sbci	r29, 0xFC	; 252
    6b20:	88 83       	st	Y, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    6b22:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    6b26:	93 e0       	ldi	r25, 0x03	; 3
    6b28:	98 0f       	add	r25, r24
    6b2a:	90 93 0e 01 	sts	0x010E, r25

	TD_MB = Timer16SysAlloc(Modbus_Qt*3);
    6b2e:	80 93 5c 02 	sts	0x025C, r24
}
    6b32:	df 91       	pop	r29
    6b34:	cf 91       	pop	r28
    6b36:	1f 91       	pop	r17
    6b38:	0f 91       	pop	r16
    6b3a:	08 95       	ret

00006b3c <MB_Init>:

// ~~~~~~~~~~
void
MB_Init(void)
{
	MB_PLC_Init();
    6b3c:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <MB_PLC_Init>
		PORTE.DIR |=(1<<3);
	#endif
	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++) {
		void MB_S_Init(uint8_t);
		void MB_M_Init(uint8_t);
		MB_State[MB_N] = MB_Initi;
    6b40:	10 92 e1 03 	sts	0x03E1, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b44:	e9 ea       	ldi	r30, 0xA9	; 169
    6b46:	ff e4       	ldi	r31, 0x4F	; 79
    6b48:	a5 91       	lpm	r26, Z+
    6b4a:	b4 91       	lpm	r27, Z
		#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
			USART_Reg(MB_N, ucsra) = ~(1<<1) &~(1<<0);
    6b4c:	8c ef       	ldi	r24, 0xFC	; 252
    6b4e:	8c 93       	st	X, r24
    6b50:	eb ea       	ldi	r30, 0xAB	; 171
    6b52:	ff e4       	ldi	r31, 0x4F	; 79
    6b54:	a5 91       	lpm	r26, Z+
    6b56:	b4 91       	lpm	r27, Z
			USART_Reg(MB_N, ucsrb) = (((1<<7) &~(1<<6) &~(1<<5)) |(1<<4) |(1<<3)) &~(1<<2);
    6b58:	88 e9       	ldi	r24, 0x98	; 152
    6b5a:	8c 93       	st	X, r24
			tc->CTRLD = TC_EVACT_OFF_gc;
			//tc->CTRLE = TC1_BYTEM_bm;
			tc->INTCTRLA |=TC_ERRINTLVL_OFF_gc;
			tc->INTCTRLB = 0;
		#endif
		SetParity(MB_N);
    6b5c:	80 e0       	ldi	r24, 0x00	; 0
    6b5e:	0e 94 45 2f 	call	0x5e8a	; 0x5e8a <SetParity>
		SetBAUD(MB_N);
    6b62:	80 e0       	ldi	r24, 0x00	; 0
    6b64:	0e 94 88 2f 	call	0x5f10	; 0x5f10 <SetBAUD>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6b68:	e6 ee       	ldi	r30, 0xE6	; 230
    6b6a:	ff e4       	ldi	r31, 0x4F	; 79
    6b6c:	e4 91       	lpm	r30, Z
		switch (prb(MB_Role+MB_N)) {
    6b6e:	ee 23       	and	r30, r30
    6b70:	31 f0       	breq	.+12     	; 0x6b7e <MB_Init+0x42>
    6b72:	e1 30       	cpi	r30, 0x01	; 1
    6b74:	39 f4       	brne	.+14     	; 0x6b84 <MB_Init+0x48>
		case Role_Slave:
			MB_S_Init(MB_N);
			break;
		case Role_Master:
			MB_M_Init(MB_N);
    6b76:	80 e0       	ldi	r24, 0x00	; 0
    6b78:	0e 94 61 35 	call	0x6ac2	; 0x6ac2 <MB_M_Init>
			break;
    6b7c:	03 c0       	rjmp	.+6      	; 0x6b84 <MB_Init+0x48>
		#endif
		SetParity(MB_N);
		SetBAUD(MB_N);
		switch (prb(MB_Role+MB_N)) {
		case Role_Slave:
			MB_S_Init(MB_N);
    6b7e:	80 e0       	ldi	r24, 0x00	; 0
    6b80:	0e 94 52 35 	call	0x6aa4	; 0x6aa4 <MB_S_Init>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6b84:	ef e9       	ldi	r30, 0x9F	; 159
    6b86:	ff e4       	ldi	r31, 0x4F	; 79
    6b88:	25 91       	lpm	r18, Z+
    6b8a:	34 91       	lpm	r19, Z
			break;
		case Role_Master:
			MB_M_Init(MB_N);
			break;
		}
		MB_StartTimer(MB_N);
    6b8c:	f9 01       	movw	r30, r18
    6b8e:	09 94       	ijmp

00006b90 <MB_M_Timer_ISR>:
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Timer_ISR(uint8_t MB_N)
{
    6b90:	4f 92       	push	r4
    6b92:	5f 92       	push	r5
    6b94:	7f 92       	push	r7
    6b96:	8f 92       	push	r8
    6b98:	9f 92       	push	r9
    6b9a:	af 92       	push	r10
    6b9c:	bf 92       	push	r11
    6b9e:	cf 92       	push	r12
    6ba0:	df 92       	push	r13
    6ba2:	ef 92       	push	r14
    6ba4:	ff 92       	push	r15
    6ba6:	0f 93       	push	r16
    6ba8:	1f 93       	push	r17
    6baa:	cf 93       	push	r28
    6bac:	df 93       	push	r29
    6bae:	d8 2e       	mov	r13, r24
	switch (MB_State[MB_N]) {
    6bb0:	c8 2f       	mov	r28, r24
    6bb2:	d0 e0       	ldi	r29, 0x00	; 0
    6bb4:	fe 01       	movw	r30, r28
    6bb6:	ef 51       	subi	r30, 0x1F	; 31
    6bb8:	fc 4f       	sbci	r31, 0xFC	; 252
    6bba:	80 81       	ld	r24, Z
    6bbc:	88 23       	and	r24, r24
    6bbe:	19 f0       	breq	.+6      	; 0x6bc6 <MB_M_Timer_ISR+0x36>
    6bc0:	82 30       	cpi	r24, 0x02	; 2
    6bc2:	f1 f0       	breq	.+60     	; 0x6c00 <MB_M_Timer_ISR+0x70>
    6bc4:	85 c2       	rjmp	.+1290   	; 0x70d0 <MB_M_Timer_ISR+0x540>
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
    6bc6:	80 91 5c 02 	lds	r24, 0x025C
    6bca:	8e 5f       	subi	r24, 0xFE	; 254
    6bcc:	6f ef       	ldi	r22, 0xFF	; 255
    6bce:	7f ef       	ldi	r23, 0xFF	; 255
    6bd0:	8d 0d       	add	r24, r13
    6bd2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
		FormQuery(MB_N);
    6bd6:	8d 2d       	mov	r24, r13
    6bd8:	0e 94 d8 31 	call	0x63b0	; 0x63b0 <FormQuery>
		MB_Transm(MB_N);
    6bdc:	8d 2d       	mov	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    6bde:	df 91       	pop	r29
    6be0:	cf 91       	pop	r28
    6be2:	1f 91       	pop	r17
    6be4:	0f 91       	pop	r16
    6be6:	ff 90       	pop	r15
    6be8:	ef 90       	pop	r14
    6bea:	df 90       	pop	r13
    6bec:	cf 90       	pop	r12
    6bee:	bf 90       	pop	r11
    6bf0:	af 90       	pop	r10
    6bf2:	9f 90       	pop	r9
    6bf4:	8f 90       	pop	r8
    6bf6:	7f 90       	pop	r7
    6bf8:	5f 90       	pop	r5
    6bfa:	4f 90       	pop	r4
{
	switch (MB_State[MB_N]) {
	case MB_Initi:
		StartTimer16(TD_MB_Cycle+MB_N, 0xFFFF);
		FormQuery(MB_N);
		MB_Transm(MB_N);
    6bfc:	0c 94 cb 2f 	jmp	0x5f96	; 0x5f96 <MB_Transm>
		break;
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
    6c00:	84 e0       	ldi	r24, 0x04	; 4
    6c02:	80 83       	st	Z, r24
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
    6c04:	9e 01       	movw	r18, r28
    6c06:	2e 5d       	subi	r18, 0xDE	; 222
    6c08:	39 4f       	sbci	r19, 0xF9	; 249
    6c0a:	79 01       	movw	r14, r18
    6c0c:	f9 01       	movw	r30, r18
    6c0e:	90 81       	ld	r25, Z
    6c10:	81 e0       	ldi	r24, 0x01	; 1
    6c12:	92 30       	cpi	r25, 0x02	; 2
    6c14:	09 f0       	breq	.+2      	; 0x6c18 <MB_M_Timer_ISR+0x88>
    6c16:	80 e0       	ldi	r24, 0x00	; 0
    6c18:	80 93 62 02 	sts	0x0262, r24
	if (CommErr(MB_N))
    6c1c:	8d 2d       	mov	r24, r13
    6c1e:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <CommErr>
    6c22:	81 11       	cpse	r24, r1
    6c24:	ed c1       	rjmp	.+986    	; 0x7000 <MB_M_Timer_ISR+0x470>
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
    6c26:	84 e1       	ldi	r24, 0x14	; 20
    6c28:	8c 9f       	mul	r24, r28
    6c2a:	f0 01       	movw	r30, r0
    6c2c:	8d 9f       	mul	r24, r29
    6c2e:	f0 0d       	add	r31, r0
    6c30:	11 24       	eor	r1, r1
    6c32:	eb 54       	subi	r30, 0x4B	; 75
    6c34:	f0 4b       	sbci	r31, 0xB0	; 176
    6c36:	85 91       	lpm	r24, Z+
    6c38:	94 91       	lpm	r25, Z
    6c3a:	fc 01       	movw	r30, r24
    6c3c:	09 95       	icall
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
		uint8_t Addr, Func;
		if (LastProcSingle) {
    6c3e:	80 91 62 02 	lds	r24, 0x0262
    6c42:	88 23       	and	r24, r24
    6c44:	79 f0       	breq	.+30     	; 0x6c64 <MB_M_Timer_ISR+0xd4>
			Addr = MB_SingleQuery[MB_N].Addr;
    6c46:	fe 01       	movw	r30, r28
    6c48:	63 e0       	ldi	r22, 0x03	; 3
    6c4a:	ee 0f       	add	r30, r30
    6c4c:	ff 1f       	adc	r31, r31
    6c4e:	6a 95       	dec	r22
    6c50:	e1 f7       	brne	.-8      	; 0x6c4a <MB_M_Timer_ISR+0xba>
    6c52:	ed 59       	subi	r30, 0x9D	; 157
    6c54:	fd 4f       	sbci	r31, 0xFD	; 253
    6c56:	20 81       	ld	r18, Z
			Func = MB_SingleQuery[MB_N].Func;
    6c58:	41 81       	ldd	r20, Z+1	; 0x01
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
		MB_Query *Query = NULL;
    6c5a:	80 e0       	ldi	r24, 0x00	; 0
    6c5c:	90 e0       	ldi	r25, 0x00	; 0
	LastProcSingle = MB_SingleState[MB_N]==MB_SingleExec;
	if (CommErr(MB_N))
		Over = FailSlave(MB_N);
	else {
		USART_Func(MB_N, LED);
		MB_Slave *Slave = NULL;
    6c5e:	00 e0       	ldi	r16, 0x00	; 0
    6c60:	10 e0       	ldi	r17, 0x00	; 0
    6c62:	15 c0       	rjmp	.+42     	; 0x6c8e <MB_M_Timer_ISR+0xfe>
		if (LastProcSingle) {
			Addr = MB_SingleQuery[MB_N].Addr;
			Func = MB_SingleQuery[MB_N].Func;
		}
		else {
			Slave = GetSlave(MB_N);
    6c64:	8d 2d       	mov	r24, r13
    6c66:	0e 94 c5 28 	call	0x518a	; 0x518a <GetSlave>
    6c6a:	8c 01       	movw	r16, r24
			Query = (MB_Query*)prp(&Slave->QueryList)+CurrQuery[MB_N];
    6c6c:	fc 01       	movw	r30, r24
    6c6e:	31 96       	adiw	r30, 0x01	; 1
    6c70:	85 91       	lpm	r24, Z+
    6c72:	94 91       	lpm	r25, Z
    6c74:	fe 01       	movw	r30, r28
    6c76:	e3 5f       	subi	r30, 0xF3	; 243
    6c78:	f9 4f       	sbci	r31, 0xF9	; 249
    6c7a:	20 81       	ld	r18, Z
    6c7c:	f7 e0       	ldi	r31, 0x07	; 7
    6c7e:	2f 9f       	mul	r18, r31
    6c80:	80 0d       	add	r24, r0
    6c82:	91 1d       	adc	r25, r1
    6c84:	11 24       	eor	r1, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    6c86:	f8 01       	movw	r30, r16
    6c88:	24 91       	lpm	r18, Z
    6c8a:	fc 01       	movw	r30, r24
    6c8c:	44 91       	lpm	r20, Z
			Addr = prb(&Slave->Addr);
			Func = prb(&Query->Func);
		}
		if (MB_Frame[MB_N][0]!=Addr || MB_Frame[MB_N][1]!=Func)
    6c8e:	bc 2f       	mov	r27, r28
    6c90:	aa 27       	eor	r26, r26
    6c92:	fd 01       	movw	r30, r26
    6c94:	e8 5b       	subi	r30, 0xB8	; 184
    6c96:	f2 4f       	sbci	r31, 0xF2	; 242
    6c98:	30 81       	ld	r19, Z
    6c9a:	32 13       	cpse	r19, r18
    6c9c:	b1 c1       	rjmp	.+866    	; 0x7000 <MB_M_Timer_ISR+0x470>
    6c9e:	c1 80       	ldd	r12, Z+1	; 0x01
    6ca0:	c4 12       	cpse	r12, r20
    6ca2:	ae c1       	rjmp	.+860    	; 0x7000 <MB_M_Timer_ISR+0x470>
			Over = FailSlave(MB_N);
		else {
			uint8_t Err = 0;
			switch (Func) {
    6ca4:	50 e0       	ldi	r21, 0x00	; 0
    6ca6:	fa 01       	movw	r30, r20
    6ca8:	31 97       	sbiw	r30, 0x01	; 1
    6caa:	e0 31       	cpi	r30, 0x10	; 16
    6cac:	f1 05       	cpc	r31, r1
    6cae:	08 f0       	brcs	.+2      	; 0x6cb2 <MB_M_Timer_ISR+0x122>
    6cb0:	ab c1       	rjmp	.+854    	; 0x7008 <MB_M_Timer_ISR+0x478>
    6cb2:	ea 5a       	subi	r30, 0xAA	; 170
    6cb4:	ff 4f       	sbci	r31, 0xFF	; 255
    6cb6:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadDiscr(uint8_t MB_N, MB_Query *Query)
{
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
    6cba:	20 91 62 02 	lds	r18, 0x0262
    6cbe:	22 23       	and	r18, r18
    6cc0:	51 f0       	breq	.+20     	; 0x6cd6 <MB_M_Timer_ISR+0x146>
    6cc2:	fe 01       	movw	r30, r28
    6cc4:	43 e0       	ldi	r20, 0x03	; 3
    6cc6:	ee 0f       	add	r30, r30
    6cc8:	ff 1f       	adc	r31, r31
    6cca:	4a 95       	dec	r20
    6ccc:	e1 f7       	brne	.-8      	; 0x6cc6 <MB_M_Timer_ISR+0x136>
    6cce:	ed 59       	subi	r30, 0x9D	; 157
    6cd0:	fd 4f       	sbci	r31, 0xFD	; 253
    6cd2:	64 81       	ldd	r22, Z+4	; 0x04
    6cd4:	03 c0       	rjmp	.+6      	; 0x6cdc <MB_M_Timer_ISR+0x14c>
    6cd6:	fc 01       	movw	r30, r24
    6cd8:	33 96       	adiw	r30, 0x03	; 3
    6cda:	64 91       	lpm	r22, Z
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
    6cdc:	fd 01       	movw	r30, r26
    6cde:	e8 5b       	subi	r30, 0xB8	; 184
    6ce0:	f2 4f       	sbci	r31, 0xF2	; 242
    6ce2:	22 81       	ldd	r18, Z+2	; 0x02
    6ce4:	30 e0       	ldi	r19, 0x00	; 0
    6ce6:	fe 01       	movw	r30, r28
    6ce8:	e7 52       	subi	r30, 0x27	; 39
    6cea:	f7 4f       	sbci	r31, 0xF7	; 247
    6cec:	e0 81       	ld	r30, Z
    6cee:	f0 e0       	ldi	r31, 0x00	; 0
    6cf0:	a9 01       	movw	r20, r18
    6cf2:	4b 5f       	subi	r20, 0xFB	; 251
    6cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    6cf6:	e4 17       	cp	r30, r20
    6cf8:	f5 07       	cpc	r31, r21
    6cfa:	09 f0       	breq	.+2      	; 0x6cfe <MB_M_Timer_ISR+0x16e>
    6cfc:	74 c1       	rjmp	.+744    	; 0x6fe6 <MB_M_Timer_ISR+0x456>
    6cfe:	e6 2f       	mov	r30, r22
    6d00:	e6 95       	lsr	r30
    6d02:	e6 95       	lsr	r30
    6d04:	e6 95       	lsr	r30
    6d06:	f0 e0       	ldi	r31, 0x00	; 0
    6d08:	41 e0       	ldi	r20, 0x01	; 1
    6d0a:	50 e0       	ldi	r21, 0x00	; 0
    6d0c:	76 2f       	mov	r23, r22
    6d0e:	77 70       	andi	r23, 0x07	; 7
    6d10:	11 f4       	brne	.+4      	; 0x6d16 <MB_M_Timer_ISR+0x186>
    6d12:	40 e0       	ldi	r20, 0x00	; 0
    6d14:	50 e0       	ldi	r21, 0x00	; 0
    6d16:	4e 0f       	add	r20, r30
    6d18:	5f 1f       	adc	r21, r31
    6d1a:	42 17       	cp	r20, r18
    6d1c:	53 07       	cpc	r21, r19
    6d1e:	09 f0       	breq	.+2      	; 0x6d22 <MB_M_Timer_ISR+0x192>
    6d20:	62 c1       	rjmp	.+708    	; 0x6fe6 <MB_M_Timer_ISR+0x456>
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d22:	20 91 62 02 	lds	r18, 0x0262
		Discr = MB_SingleQuery[MB_N].Buf;
    6d26:	fe 01       	movw	r30, r28
	uint8_t Qt = LastProcSingle ? MB_SingleQuery[MB_N].Qt : prb((uint8_t*)&Query->Qt);
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || Qt/8+((Qt%8)>0)!=MB_Frame[MB_N][2])
		return 1;
	uint8_t *Discr;
	uint8_t Pin;
	if (LastProcSingle) {
    6d28:	22 23       	and	r18, r18
    6d2a:	59 f0       	breq	.+22     	; 0x6d42 <MB_M_Timer_ISR+0x1b2>
		Discr = MB_SingleQuery[MB_N].Buf;
    6d2c:	33 e0       	ldi	r19, 0x03	; 3
    6d2e:	ee 0f       	add	r30, r30
    6d30:	ff 1f       	adc	r31, r31
    6d32:	3a 95       	dec	r19
    6d34:	e1 f7       	brne	.-8      	; 0x6d2e <MB_M_Timer_ISR+0x19e>
    6d36:	ed 59       	subi	r30, 0x9D	; 157
    6d38:	fd 4f       	sbci	r31, 0xFD	; 253
    6d3a:	46 81       	ldd	r20, Z+6	; 0x06
    6d3c:	57 81       	ldd	r21, Z+7	; 0x07
		Pin = 0;
    6d3e:	c1 2c       	mov	r12, r1
    6d40:	14 c0       	rjmp	.+40     	; 0x6d6a <MB_M_Timer_ISR+0x1da>
    6d42:	24 e0       	ldi	r18, 0x04	; 4
    6d44:	ee 0f       	add	r30, r30
    6d46:	ff 1f       	adc	r31, r31
    6d48:	2a 95       	dec	r18
    6d4a:	e1 f7       	brne	.-8      	; 0x6d44 <MB_M_Timer_ISR+0x1b4>
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
    6d4c:	21 e0       	ldi	r18, 0x01	; 1
    6d4e:	c2 12       	cpse	r12, r18
    6d50:	03 c0       	rjmp	.+6      	; 0x6d58 <MB_M_Timer_ISR+0x1c8>
    6d52:	ea 52       	subi	r30, 0x2A	; 42
    6d54:	f0 4b       	sbci	r31, 0xB0	; 176
    6d56:	02 c0       	rjmp	.+4      	; 0x6d5c <MB_M_Timer_ISR+0x1cc>
    6d58:	e6 52       	subi	r30, 0x26	; 38
    6d5a:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6d5c:	45 91       	lpm	r20, Z+
    6d5e:	54 91       	lpm	r21, Z
		Pin = prw(&Query->AllocAddr);
    6d60:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6d62:	fc 01       	movw	r30, r24
    6d64:	85 91       	lpm	r24, Z+
    6d66:	94 91       	lpm	r25, Z
    6d68:	c8 2e       	mov	r12, r24
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d6a:	20 e0       	ldi	r18, 0x00	; 0
    6d6c:	30 e0       	ldi	r19, 0x00	; 0
    6d6e:	86 2e       	mov	r8, r22
    6d70:	91 2c       	mov	r9, r1
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d72:	aa 24       	eor	r10, r10
    6d74:	a3 94       	inc	r10
    6d76:	b1 2c       	mov	r11, r1
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d78:	a8 5b       	subi	r26, 0xB8	; 184
    6d7a:	b2 4f       	sbci	r27, 0xF2	; 242
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6d7c:	28 15       	cp	r18, r8
    6d7e:	39 05       	cpc	r19, r9
    6d80:	08 f0       	brcs	.+2      	; 0x6d84 <MB_M_Timer_ISR+0x1f4>
    6d82:	42 c1       	rjmp	.+644    	; 0x7008 <MB_M_Timer_ISR+0x478>
    6d84:	ec 2d       	mov	r30, r12
    6d86:	e2 0f       	add	r30, r18
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
    6d88:	7e 2e       	mov	r7, r30
    6d8a:	76 94       	lsr	r7
    6d8c:	76 94       	lsr	r7
    6d8e:	76 94       	lsr	r7
    6d90:	e7 70       	andi	r30, 0x07	; 7
    6d92:	25 01       	movw	r4, r10
    6d94:	01 c0       	rjmp	.+2      	; 0x6d98 <MB_M_Timer_ISR+0x208>
    6d96:	44 0c       	add	r4, r4
    6d98:	ea 95       	dec	r30
    6d9a:	ea f7       	brpl	.-6      	; 0x6d96 <MB_M_Timer_ISR+0x206>
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6d9c:	c9 01       	movw	r24, r18
    6d9e:	63 e0       	ldi	r22, 0x03	; 3
    6da0:	96 95       	lsr	r25
    6da2:	87 95       	ror	r24
    6da4:	6a 95       	dec	r22
    6da6:	e1 f7       	brne	.-8      	; 0x6da0 <MB_M_Timer_ISR+0x210>
    6da8:	8a 0f       	add	r24, r26
    6daa:	9b 1f       	adc	r25, r27
    6dac:	fc 01       	movw	r30, r24
    6dae:	63 81       	ldd	r22, Z+3	; 0x03
    6db0:	70 e0       	ldi	r23, 0x00	; 0
    6db2:	c9 01       	movw	r24, r18
    6db4:	87 70       	andi	r24, 0x07	; 7
    6db6:	99 27       	eor	r25, r25
    6db8:	02 c0       	rjmp	.+4      	; 0x6dbe <MB_M_Timer_ISR+0x22e>
    6dba:	75 95       	asr	r23
    6dbc:	67 95       	ror	r22
    6dbe:	8a 95       	dec	r24
    6dc0:	e2 f7       	brpl	.-8      	; 0x6dba <MB_M_Timer_ISR+0x22a>
    6dc2:	87 2d       	mov	r24, r7
    6dc4:	90 e0       	ldi	r25, 0x00	; 0
			Discr[Byte] |=Bit;
    6dc6:	84 0f       	add	r24, r20
    6dc8:	95 1f       	adc	r25, r21
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
		uint8_t j = Pin+i;
		uint8_t Byte=j/8, Bit=1<<j%8;
		if (MB_Frame[MB_N][3+i/8] &(1<<i%8))
    6dca:	60 ff       	sbrs	r22, 0
    6dcc:	04 c0       	rjmp	.+8      	; 0x6dd6 <MB_M_Timer_ISR+0x246>
			Discr[Byte] |=Bit;
    6dce:	fc 01       	movw	r30, r24
    6dd0:	60 81       	ld	r22, Z
    6dd2:	64 29       	or	r22, r4
    6dd4:	04 c0       	rjmp	.+8      	; 0x6dde <MB_M_Timer_ISR+0x24e>
		else
			Discr[Byte] &=~Bit;
    6dd6:	40 94       	com	r4
    6dd8:	fc 01       	movw	r30, r24
    6dda:	60 81       	ld	r22, Z
    6ddc:	64 21       	and	r22, r4
    6dde:	60 83       	st	Z, r22
	}
	else {
		Discr = MB_Frame[MB_N][1]==1 ? prp(&Modbus_Map[MB_N].Coil) : prp(&Modbus_Map[MB_N].Input);
		Pin = prw(&Query->AllocAddr);
	}
	for (uint16_t i=0; i<Qt; i++) {
    6de0:	2f 5f       	subi	r18, 0xFF	; 255
    6de2:	3f 4f       	sbci	r19, 0xFF	; 255
    6de4:	cb cf       	rjmp	.-106    	; 0x6d7c <MB_M_Timer_ISR+0x1ec>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_ReadReg(uint8_t MB_N, MB_Query *Query)
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
    6de6:	a8 5b       	subi	r26, 0xB8	; 184
    6de8:	b2 4f       	sbci	r27, 0xF2	; 242
    6dea:	12 96       	adiw	r26, 0x02	; 2
    6dec:	4c 91       	ld	r20, X
    6dee:	fe 01       	movw	r30, r28
    6df0:	e7 52       	subi	r30, 0x27	; 39
    6df2:	f7 4f       	sbci	r31, 0xF7	; 247
    6df4:	e0 81       	ld	r30, Z
    6df6:	f0 e0       	ldi	r31, 0x00	; 0
    6df8:	64 2f       	mov	r22, r20
    6dfa:	70 e0       	ldi	r23, 0x00	; 0
    6dfc:	9b 01       	movw	r18, r22
    6dfe:	2b 5f       	subi	r18, 0xFB	; 251
    6e00:	3f 4f       	sbci	r19, 0xFF	; 255
    6e02:	e2 17       	cp	r30, r18
    6e04:	f3 07       	cpc	r31, r19
    6e06:	09 f0       	breq	.+2      	; 0x6e0a <MB_M_Timer_ISR+0x27a>
    6e08:	ee c0       	rjmp	.+476    	; 0x6fe6 <MB_M_Timer_ISR+0x456>
    6e0a:	20 91 62 02 	lds	r18, 0x0262
    6e0e:	22 23       	and	r18, r18
    6e10:	59 f0       	breq	.+22     	; 0x6e28 <MB_M_Timer_ISR+0x298>
    6e12:	fe 01       	movw	r30, r28
    6e14:	a3 e0       	ldi	r26, 0x03	; 3
    6e16:	ee 0f       	add	r30, r30
    6e18:	ff 1f       	adc	r31, r31
    6e1a:	aa 95       	dec	r26
    6e1c:	e1 f7       	brne	.-8      	; 0x6e16 <MB_M_Timer_ISR+0x286>
    6e1e:	ed 59       	subi	r30, 0x9D	; 157
    6e20:	fd 4f       	sbci	r31, 0xFD	; 253
    6e22:	24 81       	ldd	r18, Z+4	; 0x04
    6e24:	35 81       	ldd	r19, Z+5	; 0x05
    6e26:	04 c0       	rjmp	.+8      	; 0x6e30 <MB_M_Timer_ISR+0x2a0>
    6e28:	fc 01       	movw	r30, r24
    6e2a:	33 96       	adiw	r30, 0x03	; 3
    6e2c:	25 91       	lpm	r18, Z+
    6e2e:	34 91       	lpm	r19, Z
    6e30:	22 0f       	add	r18, r18
    6e32:	33 1f       	adc	r19, r19
    6e34:	26 17       	cp	r18, r22
    6e36:	37 07       	cpc	r19, r23
    6e38:	09 f0       	breq	.+2      	; 0x6e3c <MB_M_Timer_ISR+0x2ac>
    6e3a:	d5 c0       	rjmp	.+426    	; 0x6fe6 <MB_M_Timer_ISR+0x456>
		return 1;
	uint16_t *Reg = LastProcSingle ?
    6e3c:	20 91 62 02 	lds	r18, 0x0262
		MB_SingleQuery[MB_N].Buf
	:
    6e40:	fe 01       	movw	r30, r28
    6e42:	22 23       	and	r18, r18
    6e44:	51 f0       	breq	.+20     	; 0x6e5a <MB_M_Timer_ISR+0x2ca>
    6e46:	33 e0       	ldi	r19, 0x03	; 3
    6e48:	ee 0f       	add	r30, r30
    6e4a:	ff 1f       	adc	r31, r31
    6e4c:	3a 95       	dec	r19
    6e4e:	e1 f7       	brne	.-8      	; 0x6e48 <MB_M_Timer_ISR+0x2b8>
    6e50:	ed 59       	subi	r30, 0x9D	; 157
    6e52:	fd 4f       	sbci	r31, 0xFD	; 253
    6e54:	a6 80       	ldd	r10, Z+6	; 0x06
    6e56:	b7 80       	ldd	r11, Z+7	; 0x07
    6e58:	17 c0       	rjmp	.+46     	; 0x6e88 <MB_M_Timer_ISR+0x2f8>
    6e5a:	24 e0       	ldi	r18, 0x04	; 4
    6e5c:	ee 0f       	add	r30, r30
    6e5e:	ff 1f       	adc	r31, r31
    6e60:	2a 95       	dec	r18
    6e62:	e1 f7       	brne	.-8      	; 0x6e5c <MB_M_Timer_ISR+0x2cc>
    6e64:	23 e0       	ldi	r18, 0x03	; 3
    6e66:	c2 12       	cpse	r12, r18
    6e68:	03 c0       	rjmp	.+6      	; 0x6e70 <MB_M_Timer_ISR+0x2e0>
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e6a:	e2 52       	subi	r30, 0x22	; 34
    6e6c:	f0 4b       	sbci	r31, 0xB0	; 176
    6e6e:	02 c0       	rjmp	.+4      	; 0x6e74 <MB_M_Timer_ISR+0x2e4>
    6e70:	ee 51       	subi	r30, 0x1E	; 30
    6e72:	f0 4b       	sbci	r31, 0xB0	; 176
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e74:	25 91       	lpm	r18, Z+
    6e76:	34 91       	lpm	r19, Z
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
    6e78:	05 96       	adiw	r24, 0x05	; 5
    6e7a:	fc 01       	movw	r30, r24
    6e7c:	a5 90       	lpm	r10, Z+
    6e7e:	b4 90       	lpm	r11, Z
    6e80:	aa 0c       	add	r10, r10
    6e82:	bb 1c       	adc	r11, r11
{
	if (MB_Frame_Sz[MB_N]!=MB_Frame[MB_N][2]+5 || (LastProcSingle?MB_SingleQuery[MB_N].Qt:prw(&Query->Qt))*2!=MB_Frame[MB_N][2])
		return 1;
	uint16_t *Reg = LastProcSingle ?
		MB_SingleQuery[MB_N].Buf
	:
    6e84:	a2 0e       	add	r10, r18
    6e86:	b3 1e       	adc	r11, r19
		(uint16_t*)(MB_Frame[MB_N][1]==3?prp(&Modbus_Map[MB_N].HoldReg):prp(&Modbus_Map[MB_N].InReg))+prw(&Query->AllocAddr);
	for (int8_t j=MB_Frame[MB_N][2]/2-1; j>=0; j--) {
    6e88:	46 95       	lsr	r20
    6e8a:	cc 24       	eor	r12, r12
    6e8c:	ca 94       	dec	r12
    6e8e:	c4 0e       	add	r12, r20
    6e90:	74 2e       	mov	r7, r20
    6e92:	77 0c       	add	r7, r7
    6e94:	7a 94       	dec	r7
    6e96:	7a 94       	dec	r7
    6e98:	ff ef       	ldi	r31, 0xFF	; 255
    6e9a:	cf 16       	cp	r12, r31
    6e9c:	09 f4       	brne	.+2      	; 0x6ea0 <MB_M_Timer_ISR+0x310>
    6e9e:	b4 c0       	rjmp	.+360    	; 0x7008 <MB_M_Timer_ISR+0x478>
		int8_t i = j*2;
		Reg[j] = MB_FrameReg(MB_N, 3+i);
    6ea0:	8c 2c       	mov	r8, r12
    6ea2:	88 0c       	add	r8, r8
    6ea4:	99 08       	sbc	r9, r9
    6ea6:	8a 0c       	add	r8, r10
    6ea8:	9b 1c       	adc	r9, r11
    6eaa:	63 e0       	ldi	r22, 0x03	; 3
    6eac:	67 0d       	add	r22, r7
    6eae:	8d 2d       	mov	r24, r13
    6eb0:	0e 94 4c 32 	call	0x6498	; 0x6498 <MB_FrameReg>
    6eb4:	f4 01       	movw	r30, r8
    6eb6:	91 83       	std	Z+1, r25	; 0x01
    6eb8:	80 83       	st	Z, r24
    6eba:	ca 94       	dec	r12
    6ebc:	eb cf       	rjmp	.-42     	; 0x6e94 <MB_M_Timer_ISR+0x304>
inline static uint8_t
MB_M_PresetSingle(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr;
	uint16_t *Reg;
	if (LastProcSingle) {
    6ebe:	20 91 62 02 	lds	r18, 0x0262
    6ec2:	22 23       	and	r18, r18
    6ec4:	69 f0       	breq	.+26     	; 0x6ee0 <MB_M_Timer_ISR+0x350>
		StartAddr = MB_SingleQuery[MB_N].StartAddr;
    6ec6:	fe 01       	movw	r30, r28
    6ec8:	83 e0       	ldi	r24, 0x03	; 3
    6eca:	ee 0f       	add	r30, r30
    6ecc:	ff 1f       	adc	r31, r31
    6ece:	8a 95       	dec	r24
    6ed0:	e1 f7       	brne	.-8      	; 0x6eca <MB_M_Timer_ISR+0x33a>
    6ed2:	ed 59       	subi	r30, 0x9D	; 157
    6ed4:	fd 4f       	sbci	r31, 0xFD	; 253
    6ed6:	22 81       	ldd	r18, Z+2	; 0x02
    6ed8:	33 81       	ldd	r19, Z+3	; 0x03
		Reg = MB_SingleQuery[MB_N].Buf;
    6eda:	66 81       	ldd	r22, Z+6	; 0x06
    6edc:	77 81       	ldd	r23, Z+7	; 0x07
    6ede:	17 c0       	rjmp	.+46     	; 0x6f0e <MB_M_Timer_ISR+0x37e>
	}
	else {
		StartAddr = prw(&Query->StartAddr);
    6ee0:	fc 01       	movw	r30, r24
    6ee2:	31 96       	adiw	r30, 0x01	; 1
    6ee4:	25 91       	lpm	r18, Z+
    6ee6:	34 91       	lpm	r19, Z
		Reg = (uint16_t*)prp(&Modbus_Map[MB_N].HoldReg)+prw(&Query->AllocAddr);
    6ee8:	fe 01       	movw	r30, r28
    6eea:	54 e0       	ldi	r21, 0x04	; 4
    6eec:	ee 0f       	add	r30, r30
    6eee:	ff 1f       	adc	r31, r31
    6ef0:	5a 95       	dec	r21
    6ef2:	e1 f7       	brne	.-8      	; 0x6eec <MB_M_Timer_ISR+0x35c>
    6ef4:	e2 52       	subi	r30, 0x22	; 34
    6ef6:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    6ef8:	45 91       	lpm	r20, Z+
    6efa:	54 91       	lpm	r21, Z
    6efc:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    6efe:	fc 01       	movw	r30, r24
    6f00:	85 91       	lpm	r24, Z+
    6f02:	94 91       	lpm	r25, Z
    6f04:	bc 01       	movw	r22, r24
    6f06:	66 0f       	add	r22, r22
    6f08:	77 1f       	adc	r23, r23
    6f0a:	64 0f       	add	r22, r20
    6f0c:	75 1f       	adc	r23, r21
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=*Reg;
    6f0e:	ce 01       	movw	r24, r28
    6f10:	87 52       	subi	r24, 0x27	; 39
    6f12:	97 4f       	sbci	r25, 0xF7	; 247
    6f14:	fc 01       	movw	r30, r24
    6f16:	80 81       	ld	r24, Z
    6f18:	88 30       	cpi	r24, 0x08	; 8
    6f1a:	09 f0       	breq	.+2      	; 0x6f1e <MB_M_Timer_ISR+0x38e>
    6f1c:	61 c0       	rjmp	.+194    	; 0x6fe0 <MB_M_Timer_ISR+0x450>

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
MB_FrameReg(uint8_t MB_N, uint8_t i)
{
	return MB_Frame[MB_N][i]<<8 | MB_Frame[MB_N][i+1];
    6f1e:	a8 5b       	subi	r26, 0xB8	; 184
    6f20:	b2 4f       	sbci	r27, 0xF2	; 242
    6f22:	12 96       	adiw	r26, 0x02	; 2
    6f24:	8c 91       	ld	r24, X
    6f26:	12 97       	sbiw	r26, 0x02	; 2
    6f28:	90 e0       	ldi	r25, 0x00	; 0
    6f2a:	98 2f       	mov	r25, r24
    6f2c:	88 27       	eor	r24, r24
    6f2e:	13 96       	adiw	r26, 0x03	; 3
    6f30:	4c 91       	ld	r20, X
    6f32:	13 97       	sbiw	r26, 0x03	; 3
    6f34:	84 2b       	or	r24, r20
    6f36:	82 17       	cp	r24, r18
    6f38:	93 07       	cpc	r25, r19
    6f3a:	09 f0       	breq	.+2      	; 0x6f3e <MB_M_Timer_ISR+0x3ae>
    6f3c:	51 c0       	rjmp	.+162    	; 0x6fe0 <MB_M_Timer_ISR+0x450>
    6f3e:	14 96       	adiw	r26, 0x04	; 4
    6f40:	8c 91       	ld	r24, X
    6f42:	14 97       	sbiw	r26, 0x04	; 4
    6f44:	90 e0       	ldi	r25, 0x00	; 0
    6f46:	98 2f       	mov	r25, r24
    6f48:	88 27       	eor	r24, r24
    6f4a:	15 96       	adiw	r26, 0x05	; 5
    6f4c:	2c 91       	ld	r18, X
    6f4e:	82 2b       	or	r24, r18
    6f50:	41 e0       	ldi	r20, 0x01	; 1
    6f52:	fb 01       	movw	r30, r22
    6f54:	20 81       	ld	r18, Z
    6f56:	31 81       	ldd	r19, Z+1	; 0x01
    6f58:	82 17       	cp	r24, r18
    6f5a:	93 07       	cpc	r25, r19
    6f5c:	09 f4       	brne	.+2      	; 0x6f60 <MB_M_Timer_ISR+0x3d0>
    6f5e:	40 e0       	ldi	r20, 0x00	; 0
    6f60:	84 2f       	mov	r24, r20
    6f62:	3f c0       	rjmp	.+126    	; 0x6fe2 <MB_M_Timer_ISR+0x452>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
inline static uint8_t
MB_M_Force(uint8_t MB_N, MB_Query *Query)
{
	uint16_t StartAddr, Qt;
	if (LastProcSingle) {
    6f64:	20 91 62 02 	lds	r18, 0x0262
    6f68:	22 23       	and	r18, r18
    6f6a:	69 f0       	breq	.+26     	; 0x6f86 <MB_M_Timer_ISR+0x3f6>
		StartAddr	= MB_SingleQuery[MB_N].StartAddr;
    6f6c:	fe 01       	movw	r30, r28
    6f6e:	83 e0       	ldi	r24, 0x03	; 3
    6f70:	ee 0f       	add	r30, r30
    6f72:	ff 1f       	adc	r31, r31
    6f74:	8a 95       	dec	r24
    6f76:	e1 f7       	brne	.-8      	; 0x6f70 <MB_M_Timer_ISR+0x3e0>
    6f78:	ed 59       	subi	r30, 0x9D	; 157
    6f7a:	fd 4f       	sbci	r31, 0xFD	; 253
    6f7c:	22 81       	ldd	r18, Z+2	; 0x02
    6f7e:	33 81       	ldd	r19, Z+3	; 0x03
		Qt				= MB_SingleQuery[MB_N].Qt;
    6f80:	44 81       	ldd	r20, Z+4	; 0x04
    6f82:	55 81       	ldd	r21, Z+5	; 0x05
    6f84:	08 c0       	rjmp	.+16     	; 0x6f96 <MB_M_Timer_ISR+0x406>
	}
	else {
		StartAddr	= prw(&Query->StartAddr);
    6f86:	fc 01       	movw	r30, r24
    6f88:	31 96       	adiw	r30, 0x01	; 1
    6f8a:	25 91       	lpm	r18, Z+
    6f8c:	34 91       	lpm	r19, Z
		Qt				= prw(&Query->Qt);
    6f8e:	03 96       	adiw	r24, 0x03	; 3
    6f90:	fc 01       	movw	r30, r24
    6f92:	45 91       	lpm	r20, Z+
    6f94:	54 91       	lpm	r21, Z
	}
	return MB_Frame_Sz[MB_N]!=8 || MB_FrameReg(MB_N, 2)!=StartAddr || MB_FrameReg(MB_N, 4)!=Qt;
    6f96:	fe 01       	movw	r30, r28
    6f98:	e7 52       	subi	r30, 0x27	; 39
    6f9a:	f7 4f       	sbci	r31, 0xF7	; 247
    6f9c:	80 81       	ld	r24, Z
    6f9e:	88 30       	cpi	r24, 0x08	; 8
    6fa0:	f9 f4       	brne	.+62     	; 0x6fe0 <MB_M_Timer_ISR+0x450>
    6fa2:	a8 5b       	subi	r26, 0xB8	; 184
    6fa4:	b2 4f       	sbci	r27, 0xF2	; 242
    6fa6:	12 96       	adiw	r26, 0x02	; 2
    6fa8:	8c 91       	ld	r24, X
    6faa:	12 97       	sbiw	r26, 0x02	; 2
    6fac:	90 e0       	ldi	r25, 0x00	; 0
    6fae:	98 2f       	mov	r25, r24
    6fb0:	88 27       	eor	r24, r24
    6fb2:	13 96       	adiw	r26, 0x03	; 3
    6fb4:	6c 91       	ld	r22, X
    6fb6:	13 97       	sbiw	r26, 0x03	; 3
    6fb8:	86 2b       	or	r24, r22
    6fba:	82 17       	cp	r24, r18
    6fbc:	93 07       	cpc	r25, r19
    6fbe:	81 f4       	brne	.+32     	; 0x6fe0 <MB_M_Timer_ISR+0x450>
    6fc0:	14 96       	adiw	r26, 0x04	; 4
    6fc2:	8c 91       	ld	r24, X
    6fc4:	14 97       	sbiw	r26, 0x04	; 4
    6fc6:	90 e0       	ldi	r25, 0x00	; 0
    6fc8:	98 2f       	mov	r25, r24
    6fca:	88 27       	eor	r24, r24
    6fcc:	15 96       	adiw	r26, 0x05	; 5
    6fce:	2c 91       	ld	r18, X
    6fd0:	82 2b       	or	r24, r18
    6fd2:	21 e0       	ldi	r18, 0x01	; 1
    6fd4:	84 17       	cp	r24, r20
    6fd6:	95 07       	cpc	r25, r21
    6fd8:	09 f4       	brne	.+2      	; 0x6fdc <MB_M_Timer_ISR+0x44c>
    6fda:	20 e0       	ldi	r18, 0x00	; 0
    6fdc:	82 2f       	mov	r24, r18
    6fde:	01 c0       	rjmp	.+2      	; 0x6fe2 <MB_M_Timer_ISR+0x452>
    6fe0:	81 e0       	ldi	r24, 0x01	; 1
				break;
			case 0x0F: case 0x10:
				Err = MB_M_Force(MB_N, Query);
				break;
			}
			if (Err) {
    6fe2:	88 23       	and	r24, r24
    6fe4:	89 f0       	breq	.+34     	; 0x7008 <MB_M_Timer_ISR+0x478>
				MB_CPT[MB_N][2]++;
    6fe6:	fe 01       	movw	r30, r28
    6fe8:	54 e0       	ldi	r21, 0x04	; 4
    6fea:	ee 0f       	add	r30, r30
    6fec:	ff 1f       	adc	r31, r31
    6fee:	5a 95       	dec	r21
    6ff0:	e1 f7       	brne	.-8      	; 0x6fea <MB_M_Timer_ISR+0x45a>
    6ff2:	e7 5d       	subi	r30, 0xD7	; 215
    6ff4:	f4 4f       	sbci	r31, 0xF4	; 244
    6ff6:	84 81       	ldd	r24, Z+4	; 0x04
    6ff8:	95 81       	ldd	r25, Z+5	; 0x05
    6ffa:	01 96       	adiw	r24, 0x01	; 1
    6ffc:	95 83       	std	Z+5, r25	; 0x05
    6ffe:	84 83       	std	Z+4, r24	; 0x04
				Over = FailSlave(MB_N);
    7000:	8d 2d       	mov	r24, r13
    7002:	0e 94 ad 2b 	call	0x575a	; 0x575a <FailSlave>
    7006:	45 c0       	rjmp	.+138    	; 0x7092 <MB_M_Timer_ISR+0x502>
			}
			else if (LastProcSingle)
    7008:	80 91 62 02 	lds	r24, 0x0262
    700c:	88 23       	and	r24, r24
    700e:	19 f0       	breq	.+6      	; 0x7016 <MB_M_Timer_ISR+0x486>
				MB_SingleState[MB_N] = MB_SingleIdle;
    7010:	f7 01       	movw	r30, r14
    7012:	10 82       	st	Z, r1
    7014:	47 c0       	rjmp	.+142    	; 0x70a4 <MB_M_Timer_ISR+0x514>
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
    7016:	7e 01       	movw	r14, r28
    7018:	ee 0c       	add	r14, r14
    701a:	ff 1c       	adc	r15, r15
    701c:	ee 0c       	add	r14, r14
    701e:	ff 1c       	adc	r15, r15
    7020:	97 01       	movw	r18, r14
    7022:	2c 5e       	subi	r18, 0xEC	; 236
    7024:	34 4f       	sbci	r19, 0xF4	; 244
    7026:	79 01       	movw	r14, r18
    7028:	81 e0       	ldi	r24, 0x01	; 1
    702a:	90 e0       	ldi	r25, 0x00	; 0
    702c:	a0 e0       	ldi	r26, 0x00	; 0
    702e:	b0 e0       	ldi	r27, 0x00	; 0
    7030:	9e 01       	movw	r18, r28
    7032:	2a 5f       	subi	r18, 0xFA	; 250
    7034:	39 4f       	sbci	r19, 0xF9	; 249
    7036:	f9 01       	movw	r30, r18
    7038:	00 80       	ld	r0, Z
    703a:	04 c0       	rjmp	.+8      	; 0x7044 <MB_M_Timer_ISR+0x4b4>
    703c:	88 0f       	add	r24, r24
    703e:	99 1f       	adc	r25, r25
    7040:	aa 1f       	adc	r26, r26
    7042:	bb 1f       	adc	r27, r27
    7044:	0a 94       	dec	r0
    7046:	d2 f7       	brpl	.-12     	; 0x703c <MB_M_Timer_ISR+0x4ac>
    7048:	80 95       	com	r24
    704a:	90 95       	com	r25
    704c:	a0 95       	com	r26
    704e:	b0 95       	com	r27
    7050:	f7 01       	movw	r30, r14
    7052:	40 81       	ld	r20, Z
    7054:	51 81       	ldd	r21, Z+1	; 0x01
    7056:	62 81       	ldd	r22, Z+2	; 0x02
    7058:	73 81       	ldd	r23, Z+3	; 0x03
    705a:	84 23       	and	r24, r20
    705c:	95 23       	and	r25, r21
    705e:	a6 23       	and	r26, r22
    7060:	b7 23       	and	r27, r23
    7062:	80 83       	st	Z, r24
    7064:	91 83       	std	Z+1, r25	; 0x01
    7066:	a2 83       	std	Z+2, r26	; 0x02
    7068:	b3 83       	std	Z+3, r27	; 0x03
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
    706a:	fe 01       	movw	r30, r28
    706c:	e3 5f       	subi	r30, 0xF3	; 243
    706e:	f9 4f       	sbci	r31, 0xF9	; 249
    7070:	80 81       	ld	r24, Z
    7072:	8f 5f       	subi	r24, 0xFF	; 255
    7074:	80 83       	st	Z, r24
    7076:	f8 01       	movw	r30, r16
    7078:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    707a:	04 91       	lpm	r16, Z
    707c:	80 13       	cpse	r24, r16
    707e:	04 c0       	rjmp	.+8      	; 0x7088 <MB_M_Timer_ISR+0x4f8>
					Over = NextSlave(MB_N);
    7080:	8d 2d       	mov	r24, r13
    7082:	0e 94 1b 2b 	call	0x5636	; 0x5636 <NextSlave>
    7086:	01 c0       	rjmp	.+2      	; 0x708a <MB_M_Timer_ISR+0x4fa>

// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void
MB_M_CtrlProc(uint8_t MB_N)
{
	uint8_t Over = 0;
    7088:	80 e0       	ldi	r24, 0x00	; 0
				MB_SingleState[MB_N] = MB_SingleIdle;
			else {
				SlaveOff[MB_N] &=~((uint32_t)1<<CurrSlave[MB_N]);
				if (++CurrQuery[MB_N]==prb(&Slave->QueryQt))
					Over = NextSlave(MB_N);
				Try[MB_N] = 0;
    708a:	fe 01       	movw	r30, r28
    708c:	ef 59       	subi	r30, 0x9F	; 159
    708e:	fd 4f       	sbci	r31, 0xFD	; 253
    7090:	10 82       	st	Z, r1
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    7092:	88 23       	and	r24, r24
    7094:	39 f0       	breq	.+14     	; 0x70a4 <MB_M_Timer_ISR+0x514>
    7096:	cc 0f       	add	r28, r28
    7098:	dd 1f       	adc	r29, r29
    709a:	c0 5e       	subi	r28, 0xE0	; 224
    709c:	d9 4f       	sbci	r29, 0xF9	; 249
    709e:	68 81       	ld	r22, Y
    70a0:	79 81       	ldd	r23, Y+1	; 0x01
    70a2:	02 c0       	rjmp	.+4      	; 0x70a8 <MB_M_Timer_ISR+0x518>
    70a4:	65 e0       	ldi	r22, 0x05	; 5
    70a6:	70 e0       	ldi	r23, 0x00	; 0
    70a8:	80 91 5c 02 	lds	r24, 0x025C
    70ac:	8d 0d       	add	r24, r13
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    70ae:	df 91       	pop	r29
    70b0:	cf 91       	pop	r28
    70b2:	1f 91       	pop	r17
    70b4:	0f 91       	pop	r16
    70b6:	ff 90       	pop	r15
    70b8:	ef 90       	pop	r14
    70ba:	df 90       	pop	r13
    70bc:	cf 90       	pop	r12
    70be:	bf 90       	pop	r11
    70c0:	af 90       	pop	r10
    70c2:	9f 90       	pop	r9
    70c4:	8f 90       	pop	r8
    70c6:	7f 90       	pop	r7
    70c8:	5f 90       	pop	r5
    70ca:	4f 90       	pop	r4
			}
		}
		/*if (Over)
			USART_Func(MB_N, LED);*/
	}
	StartTimer16(TD_MB_Idle+MB_N, Over?MB_M_Period[MB_N]:MB_M_Pause_Min);
    70cc:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>
	case MB_Recept:
		MB_State[MB_N] = MB_Proc;
		MB_M_CtrlProc(MB_N);
		break;
	}
}
    70d0:	df 91       	pop	r29
    70d2:	cf 91       	pop	r28
    70d4:	1f 91       	pop	r17
    70d6:	0f 91       	pop	r16
    70d8:	ff 90       	pop	r15
    70da:	ef 90       	pop	r14
    70dc:	df 90       	pop	r13
    70de:	cf 90       	pop	r12
    70e0:	bf 90       	pop	r11
    70e2:	af 90       	pop	r10
    70e4:	9f 90       	pop	r9
    70e6:	8f 90       	pop	r8
    70e8:	7f 90       	pop	r7
    70ea:	5f 90       	pop	r5
    70ec:	4f 90       	pop	r4
    70ee:	08 95       	ret

000070f0 <MB_M_Tx>:

// ~~~~~~~~~~~~~~~~~~
void
MB_M_Tx(uint8_t MB_N)
{
	StartTimer16(TD_MB_Idle+MB_N, MB_M_Timeout[MB_N]);
    70f0:	e8 2f       	mov	r30, r24
    70f2:	f0 e0       	ldi	r31, 0x00	; 0
    70f4:	ee 5e       	subi	r30, 0xEE	; 238
    70f6:	f4 4f       	sbci	r31, 0xF4	; 244
    70f8:	60 81       	ld	r22, Z
    70fa:	70 e0       	ldi	r23, 0x00	; 0
    70fc:	90 91 5c 02 	lds	r25, 0x025C
    7100:	89 0f       	add	r24, r25
    7102:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>

00007106 <Modbus_TX>:
}

// ~~~~~~~~~~~~~~~~~~~~~~
void
Modbus_TX(usart_t *usart)
{
    7106:	bf 92       	push	r11
    7108:	cf 92       	push	r12
    710a:	df 92       	push	r13
    710c:	ef 92       	push	r14
    710e:	ff 92       	push	r15
    7110:	0f 93       	push	r16
    7112:	1f 93       	push	r17
    7114:	cf 93       	push	r28
    7116:	df 93       	push	r29
    7118:	1f 92       	push	r1
    711a:	cd b7       	in	r28, 0x3d	; 61
    711c:	de b7       	in	r29, 0x3e	; 62
    711e:	dc 01       	movw	r26, r24
// ~~~~~~~~~~~~~~~~~~~~~~
static uint8_t
MB_Port_N(usart_t *usart)
{
	uint8_t MB_N;
	for (MB_N=0; prp(&MB_Port[MB_N].usart_field)!=usart; MB_N++);
    7120:	80 e0       	ldi	r24, 0x00	; 0
    7122:	94 e1       	ldi	r25, 0x14	; 20
    7124:	c8 2e       	mov	r12, r24
    7126:	d1 2c       	mov	r13, r1
    7128:	9c 9d       	mul	r25, r12
    712a:	f0 01       	movw	r30, r0
    712c:	9d 9d       	mul	r25, r13
    712e:	f0 0d       	add	r31, r0
    7130:	11 24       	eor	r1, r1
    7132:	e9 55       	subi	r30, 0x59	; 89
    7134:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7136:	25 91       	lpm	r18, Z+
    7138:	34 91       	lpm	r19, Z
    713a:	e8 2e       	mov	r14, r24
    713c:	f1 2c       	mov	r15, r1
    713e:	a2 17       	cp	r26, r18
    7140:	b3 07       	cpc	r27, r19
    7142:	11 f0       	breq	.+4      	; 0x7148 <Modbus_TX+0x42>
    7144:	8f 5f       	subi	r24, 0xFF	; 255
    7146:	ee cf       	rjmp	.-36     	; 0x7124 <Modbus_TX+0x1e>
void
Modbus_TX(usart_t *usart)
{
	uint8_t MB_N = MB_Port_N(usart);
	static uint8_t Count[Modbus_Qt];
	if (Count[MB_N] == MB_Frame_Sz[MB_N]-2){
    7148:	86 01       	movw	r16, r12
    714a:	0c 5b       	subi	r16, 0xBC	; 188
    714c:	1d 4f       	sbci	r17, 0xFD	; 253
    714e:	f8 01       	movw	r30, r16
    7150:	90 81       	ld	r25, Z
    7152:	69 2f       	mov	r22, r25
    7154:	70 e0       	ldi	r23, 0x00	; 0
    7156:	a6 01       	movw	r20, r12
    7158:	47 52       	subi	r20, 0x27	; 39
    715a:	57 4f       	sbci	r21, 0xF7	; 247
    715c:	fa 01       	movw	r30, r20
    715e:	20 81       	ld	r18, Z
    7160:	30 e0       	ldi	r19, 0x00	; 0
    7162:	22 50       	subi	r18, 0x02	; 2
    7164:	31 09       	sbc	r19, r1
    7166:	62 17       	cp	r22, r18
    7168:	73 07       	cpc	r23, r19
    716a:	39 f5       	brne	.+78     	; 0x71ba <Modbus_TX+0xb4>
		USART_Reg(MB_N, ucsrb) &=~(1<<5);
    716c:	64 e1       	ldi	r22, 0x14	; 20
    716e:	6c 9d       	mul	r22, r12
    7170:	90 01       	movw	r18, r0
    7172:	6d 9d       	mul	r22, r13
    7174:	30 0d       	add	r19, r0
    7176:	11 24       	eor	r1, r1
    7178:	25 55       	subi	r18, 0x55	; 85
    717a:	30 4b       	sbci	r19, 0xB0	; 176
    717c:	f9 01       	movw	r30, r18
    717e:	65 91       	lpm	r22, Z+
    7180:	74 91       	lpm	r23, Z
    7182:	fb 01       	movw	r30, r22
    7184:	b0 80       	ld	r11, Z
    7186:	fb 2d       	mov	r31, r11
    7188:	ff 7d       	andi	r31, 0xDF	; 223
    718a:	bf 2e       	mov	r11, r31
    718c:	fb 01       	movw	r30, r22
    718e:	b0 82       	st	Z, r11
    7190:	f9 01       	movw	r30, r18
    7192:	25 91       	lpm	r18, Z+
    7194:	34 91       	lpm	r19, Z
		USART_Reg(MB_N, ucsrb) |=(1<<6);
    7196:	f9 01       	movw	r30, r18
    7198:	60 81       	ld	r22, Z
    719a:	60 64       	ori	r22, 0x40	; 64
    719c:	60 83       	st	Z, r22
		USART_Reg(MB_N, ucsra) |=(1<<6);	//Clear TxC pending interrupt		
    719e:	24 e1       	ldi	r18, 0x14	; 20
    71a0:	2c 9d       	mul	r18, r12
    71a2:	f0 01       	movw	r30, r0
    71a4:	2d 9d       	mul	r18, r13
    71a6:	f0 0d       	add	r31, r0
    71a8:	11 24       	eor	r1, r1
    71aa:	e7 55       	subi	r30, 0x57	; 87
    71ac:	f0 4b       	sbci	r31, 0xB0	; 176
    71ae:	25 91       	lpm	r18, Z+
    71b0:	34 91       	lpm	r19, Z
    71b2:	f9 01       	movw	r30, r18
    71b4:	60 81       	ld	r22, Z
    71b6:	60 64       	ori	r22, 0x40	; 64
    71b8:	60 83       	st	Z, r22
	}
	if (++Count[MB_N]<MB_Frame_Sz[MB_N]) {
    71ba:	9f 5f       	subi	r25, 0xFF	; 255
    71bc:	f8 01       	movw	r30, r16
    71be:	90 83       	st	Z, r25
    71c0:	fa 01       	movw	r30, r20
    71c2:	20 81       	ld	r18, Z
    71c4:	92 17       	cp	r25, r18
    71c6:	48 f4       	brcc	.+18     	; 0x71da <Modbus_TX+0xd4>
		usart_data(usart) = MB_Frame[MB_N][Count[MB_N]];
    71c8:	fc 2d       	mov	r31, r12
    71ca:	ee 27       	eor	r30, r30
    71cc:	e9 0f       	add	r30, r25
    71ce:	f1 1d       	adc	r31, r1
    71d0:	e8 5b       	subi	r30, 0xB8	; 184
    71d2:	f2 4f       	sbci	r31, 0xF2	; 242
    71d4:	80 81       	ld	r24, Z
    71d6:	8c 93       	st	X, r24
		return;
    71d8:	43 c0       	rjmp	.+134    	; 0x7260 <Modbus_TX+0x15a>
	}

	void MB_S_Tx(uint8_t);
	void MB_M_Tx(uint8_t);
	#if defined (__AVR_ATmega16__) || defined (__AVR_ATmega32__) || defined (__AVR_ATmega128__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__) || defined (__AVR_ATmega2561__)
		USART_Reg(MB_N, ucsrb) &=~((1<<6)|(1<<5)); 	// .  USART Data Register Empty Interrupt
    71da:	94 e1       	ldi	r25, 0x14	; 20
    71dc:	9c 9d       	mul	r25, r12
    71de:	f0 01       	movw	r30, r0
    71e0:	9d 9d       	mul	r25, r13
    71e2:	f0 0d       	add	r31, r0
    71e4:	11 24       	eor	r1, r1
    71e6:	e5 55       	subi	r30, 0x55	; 85
    71e8:	f0 4b       	sbci	r31, 0xB0	; 176
    71ea:	a5 91       	lpm	r26, Z+
    71ec:	b4 91       	lpm	r27, Z
    71ee:	9c 91       	ld	r25, X
    71f0:	9f 79       	andi	r25, 0x9F	; 159
    71f2:	9c 93       	st	X, r25
	#elif defined (__AVR_ATxmega128A1__)
		usart->CTRLA = (usart->CTRLA &~USART_TXCINTLVL_gm) |USART_TXCINTLVL_OFF_gc;
	#endif
	USART_Func(MB_N, RS485);
    71f4:	94 e1       	ldi	r25, 0x14	; 20
    71f6:	9c 9d       	mul	r25, r12
    71f8:	90 01       	movw	r18, r0
    71fa:	9d 9d       	mul	r25, r13
    71fc:	30 0d       	add	r19, r0
    71fe:	11 24       	eor	r1, r1
    7200:	2d 54       	subi	r18, 0x4D	; 77
    7202:	30 4b       	sbci	r19, 0xB0	; 176
    7204:	f9 01       	movw	r30, r18
    7206:	45 91       	lpm	r20, Z+
    7208:	54 91       	lpm	r21, Z
    720a:	89 83       	std	Y+1, r24	; 0x01
    720c:	fa 01       	movw	r30, r20
    720e:	09 95       	icall
	Count[MB_N] = 0;
    7210:	d8 01       	movw	r26, r16
    7212:	1c 92       	st	X, r1
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
    7214:	f6 01       	movw	r30, r12
    7216:	ef 51       	subi	r30, 0x1F	; 31
    7218:	fc 4f       	sbci	r31, 0xFC	; 252
    721a:	91 e0       	ldi	r25, 0x01	; 1
    721c:	90 83       	st	Z, r25
	switch (prb(MB_Role+MB_N)) {
    721e:	f7 01       	movw	r30, r14
    7220:	ea 51       	subi	r30, 0x1A	; 26
    7222:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7224:	e4 91       	lpm	r30, Z
    7226:	89 81       	ldd	r24, Y+1	; 0x01
    7228:	ee 23       	and	r30, r30
    722a:	71 f0       	breq	.+28     	; 0x7248 <Modbus_TX+0x142>
    722c:	e1 30       	cpi	r30, 0x01	; 1
    722e:	c1 f4       	brne	.+48     	; 0x7260 <Modbus_TX+0x15a>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7230:	0f 90       	pop	r0
    7232:	df 91       	pop	r29
    7234:	cf 91       	pop	r28
    7236:	1f 91       	pop	r17
    7238:	0f 91       	pop	r16
    723a:	ff 90       	pop	r15
    723c:	ef 90       	pop	r14
    723e:	df 90       	pop	r13
    7240:	cf 90       	pop	r12
    7242:	bf 90       	pop	r11
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
    7244:	0c 94 78 38 	jmp	0x70f0	; 0x70f0 <MB_M_Tx>
		break;
	}
}
    7248:	0f 90       	pop	r0
    724a:	df 91       	pop	r29
    724c:	cf 91       	pop	r28
    724e:	1f 91       	pop	r17
    7250:	0f 91       	pop	r16
    7252:	ff 90       	pop	r15
    7254:	ef 90       	pop	r14
    7256:	df 90       	pop	r13
    7258:	cf 90       	pop	r12
    725a:	bf 90       	pop	r11
	Count[MB_N] = 0;
	//StartTime3_5();
	MB_State[MB_N] = MB_Idle;
	switch (prb(MB_Role+MB_N)) {
	case Role_Slave:
		MB_S_Tx(MB_N);
    725c:	0c 94 47 35 	jmp	0x6a8e	; 0x6a8e <MB_S_Tx>
		break;
	case Role_Master:
		MB_M_Tx(MB_N);
		break;
	}
}
    7260:	0f 90       	pop	r0
    7262:	df 91       	pop	r29
    7264:	cf 91       	pop	r28
    7266:	1f 91       	pop	r17
    7268:	0f 91       	pop	r16
    726a:	ff 90       	pop	r15
    726c:	ef 90       	pop	r14
    726e:	df 90       	pop	r13
    7270:	cf 90       	pop	r12
    7272:	bf 90       	pop	r11
    7274:	08 95       	ret

00007276 <MB_M_Cycle>:
}

// ~~~~~~~~~~~~~~~~~~~~~
void
MB_M_Cycle(uint8_t MB_N)
{
    7276:	1f 93       	push	r17
    7278:	cf 93       	push	r28
    727a:	df 93       	push	r29
    727c:	18 2f       	mov	r17, r24
	if (Timer16Stopp(TD_MB_SlaveOff+MB_N))
    727e:	c0 91 5c 02 	lds	r28, 0x025C
    7282:	c8 0f       	add	r28, r24
    7284:	81 e0       	ldi	r24, 0x01	; 1
    7286:	8c 0f       	add	r24, r28
    7288:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    728c:	88 23       	and	r24, r24
    728e:	19 f0       	breq	.+6      	; 0x7296 <MB_M_Cycle+0x20>
		SlavesOn(MB_N);
    7290:	81 2f       	mov	r24, r17
    7292:	0e 94 00 2b 	call	0x5600	; 0x5600 <SlavesOn>

	if (Timer16Stopp(TD_MB_Idle+MB_N)){
    7296:	8c 2f       	mov	r24, r28
    7298:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    729c:	88 23       	and	r24, r24
    729e:	09 f4       	brne	.+2      	; 0x72a2 <MB_M_Cycle+0x2c>
    72a0:	4f c0       	rjmp	.+158    	; 0x7340 <MB_M_Cycle+0xca>
		cli();
    72a2:	f8 94       	cli
		if(MB_State[MB_N] == MB_Idle) MB_State[MB_N] = MB_NoReply;
    72a4:	c1 2f       	mov	r28, r17
    72a6:	d0 e0       	ldi	r29, 0x00	; 0
    72a8:	fe 01       	movw	r30, r28
    72aa:	ef 51       	subi	r30, 0x1F	; 31
    72ac:	fc 4f       	sbci	r31, 0xFC	; 252
    72ae:	80 81       	ld	r24, Z
    72b0:	81 30       	cpi	r24, 0x01	; 1
    72b2:	11 f4       	brne	.+4      	; 0x72b8 <MB_M_Cycle+0x42>
    72b4:	85 e0       	ldi	r24, 0x05	; 5
    72b6:	80 83       	st	Z, r24
		sei();
    72b8:	78 94       	sei
	}
	else return;
	
	switch (MB_State[MB_N]) {
    72ba:	80 81       	ld	r24, Z
    72bc:	84 30       	cpi	r24, 0x04	; 4
    72be:	a1 f0       	breq	.+40     	; 0x72e8 <MB_M_Cycle+0x72>
    72c0:	85 30       	cpi	r24, 0x05	; 5
    72c2:	09 f0       	breq	.+2      	; 0x72c6 <MB_M_Cycle+0x50>
    72c4:	3d c0       	rjmp	.+122    	; 0x7340 <MB_M_Cycle+0xca>
	case MB_NoReply:
		FailSlave(MB_N);
    72c6:	81 2f       	mov	r24, r17
    72c8:	0e 94 ad 2b 	call	0x575a	; 0x575a <FailSlave>
		switch (MB_SingleState[MB_N]) {
    72cc:	fe 01       	movw	r30, r28
    72ce:	ee 5d       	subi	r30, 0xDE	; 222
    72d0:	f9 4f       	sbci	r31, 0xF9	; 249
    72d2:	80 81       	ld	r24, Z
    72d4:	88 23       	and	r24, r24
    72d6:	09 f1       	breq	.+66     	; 0x731a <MB_M_Cycle+0xa4>
    72d8:	81 30       	cpi	r24, 0x01	; 1
    72da:	31 f5       	brne	.+76     	; 0x7328 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (Try[MB_N]==0)
    72dc:	cf 59       	subi	r28, 0x9F	; 159
    72de:	dd 4f       	sbci	r29, 0xFD	; 253
    72e0:	88 81       	ld	r24, Y
    72e2:	81 11       	cpse	r24, r1
    72e4:	21 c0       	rjmp	.+66     	; 0x7328 <MB_M_Cycle+0xb2>
    72e6:	1d c0       	rjmp	.+58     	; 0x7322 <MB_M_Cycle+0xac>
		cli();
		MB_Transm(MB_N);
		sei();
		break;
	case MB_Proc:
		cli();
    72e8:	f8 94       	cli
		USART_Func(MB_N, LED);
    72ea:	84 e1       	ldi	r24, 0x14	; 20
    72ec:	8c 9f       	mul	r24, r28
    72ee:	f0 01       	movw	r30, r0
    72f0:	8d 9f       	mul	r24, r29
    72f2:	f0 0d       	add	r31, r0
    72f4:	11 24       	eor	r1, r1
    72f6:	eb 54       	subi	r30, 0x4B	; 75
    72f8:	f0 4b       	sbci	r31, 0xB0	; 176

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    72fa:	25 91       	lpm	r18, Z+
    72fc:	34 91       	lpm	r19, Z
    72fe:	f9 01       	movw	r30, r18
    7300:	09 95       	icall
		sei();
    7302:	78 94       	sei
		switch (MB_SingleState[MB_N]) {
    7304:	ce 5d       	subi	r28, 0xDE	; 222
    7306:	d9 4f       	sbci	r29, 0xF9	; 249
    7308:	88 81       	ld	r24, Y
    730a:	88 23       	and	r24, r24
    730c:	31 f0       	breq	.+12     	; 0x731a <MB_M_Cycle+0xa4>
    730e:	81 30       	cpi	r24, 0x01	; 1
    7310:	59 f4       	brne	.+22     	; 0x7328 <MB_M_Cycle+0xb2>
		case MB_SingleIdle:
			FormQuery(MB_N);
			break;
		case MB_SingleStart:
			if (LastProcSingle)
    7312:	80 91 62 02 	lds	r24, 0x0262
    7316:	88 23       	and	r24, r24
    7318:	21 f0       	breq	.+8      	; 0x7322 <MB_M_Cycle+0xac>
				FormQuery(MB_N);
    731a:	81 2f       	mov	r24, r17
    731c:	0e 94 d8 31 	call	0x63b0	; 0x63b0 <FormQuery>
    7320:	03 c0       	rjmp	.+6      	; 0x7328 <MB_M_Cycle+0xb2>
			else
				FormSingle(MB_N);
    7322:	81 2f       	mov	r24, r17
    7324:	0e 94 22 32 	call	0x6444	; 0x6444 <FormSingle>
			break;
		}
		StartTimer16(TD_MB_Idle+MB_N, 0xFFFF);	//     
    7328:	80 91 5c 02 	lds	r24, 0x025C
    732c:	6f ef       	ldi	r22, 0xFF	; 255
    732e:	7f ef       	ldi	r23, 0xFF	; 255
    7330:	81 0f       	add	r24, r17
    7332:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
		cli();
    7336:	f8 94       	cli
		MB_Transm(MB_N);
    7338:	81 2f       	mov	r24, r17
    733a:	0e 94 cb 2f 	call	0x5f96	; 0x5f96 <MB_Transm>
		sei();
    733e:	78 94       	sei
		break;
	}
}
    7340:	df 91       	pop	r29
    7342:	cf 91       	pop	r28
    7344:	1f 91       	pop	r17
    7346:	08 95       	ret

00007348 <MB_Cycle>:
{
	void MB_S_Timer_ISR(uint8_t);
	void MB_M_Timer_ISR(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++){
		if(MB_TimerFlag & (1<<MB_N)){
    7348:	80 91 13 0b 	lds	r24, 0x0B13
    734c:	80 ff       	sbrs	r24, 0
    734e:	15 c0       	rjmp	.+42     	; 0x737a <MB_Cycle+0x32>
			cli();
    7350:	f8 94       	cli
			MB_TimerFlag &= ~(1<<MB_N);
    7352:	80 91 13 0b 	lds	r24, 0x0B13
    7356:	8e 7f       	andi	r24, 0xFE	; 254
    7358:	80 93 13 0b 	sts	0x0B13, r24
			sei();
    735c:	78 94       	sei

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    735e:	e6 ee       	ldi	r30, 0xE6	; 230
    7360:	ff e4       	ldi	r31, 0x4F	; 79
    7362:	e4 91       	lpm	r30, Z
			switch (prb(MB_Role+MB_N)) {
    7364:	ee 23       	and	r30, r30
    7366:	31 f0       	breq	.+12     	; 0x7374 <MB_Cycle+0x2c>
    7368:	e1 30       	cpi	r30, 0x01	; 1
    736a:	39 f4       	brne	.+14     	; 0x737a <MB_Cycle+0x32>
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
				break;
			case Role_Master:
				MB_M_Timer_ISR(MB_N);
    736c:	80 e0       	ldi	r24, 0x00	; 0
    736e:	0e 94 c8 35 	call	0x6b90	; 0x6b90 <MB_M_Timer_ISR>
				break;
    7372:	03 c0       	rjmp	.+6      	; 0x737a <MB_Cycle+0x32>
			cli();
			MB_TimerFlag &= ~(1<<MB_N);
			sei();
			switch (prb(MB_Role+MB_N)) {
			case Role_Slave:
				MB_S_Timer_ISR(MB_N);
    7374:	80 e0       	ldi	r24, 0x00	; 0
    7376:	0e 94 60 32 	call	0x64c0	; 0x64c0 <MB_S_Timer_ISR>
    737a:	e6 ee       	ldi	r30, 0xE6	; 230
    737c:	ff e4       	ldi	r31, 0x4F	; 79
    737e:	e4 91       	lpm	r30, Z
	}

	void MB_M_Cycle(uint8_t);

	for (uint8_t MB_N=0; MB_N<Modbus_Qt; MB_N++)
		if (prb(MB_Role+MB_N)==Role_Master)
    7380:	e1 30       	cpi	r30, 0x01	; 1
    7382:	19 f4       	brne	.+6      	; 0x738a <MB_Cycle+0x42>
			MB_M_Cycle(MB_N);
    7384:	80 e0       	ldi	r24, 0x00	; 0
    7386:	0c 94 3b 39 	jmp	0x7276	; 0x7276 <MB_M_Cycle>
    738a:	08 95       	ret

0000738c <IP_compare_Const>:
	IP->IP1 = IP1;
	IP->IP2 = IP2;
	IP->IP3 = IP3;
	IP->IP4 = IP4;
}
uint8_t IP_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    738c:	0f 93       	push	r16
    738e:	fc 01       	movw	r30, r24
	if((IP->IP1 == IP1) && (IP->IP2 == IP2) && (IP->IP3 == IP3) && (IP->IP4 == IP4)) return 1;
    7390:	80 81       	ld	r24, Z
    7392:	86 13       	cpse	r24, r22
    7394:	09 c0       	rjmp	.+18     	; 0x73a8 <IP_compare_Const+0x1c>
    7396:	81 81       	ldd	r24, Z+1	; 0x01
    7398:	84 13       	cpse	r24, r20
    739a:	06 c0       	rjmp	.+12     	; 0x73a8 <IP_compare_Const+0x1c>
    739c:	82 81       	ldd	r24, Z+2	; 0x02
    739e:	82 13       	cpse	r24, r18
    73a0:	03 c0       	rjmp	.+6      	; 0x73a8 <IP_compare_Const+0x1c>
    73a2:	81 e0       	ldi	r24, 0x01	; 1
    73a4:	93 81       	ldd	r25, Z+3	; 0x03
    73a6:	90 13       	cpse	r25, r16
	else return 0;
    73a8:	80 e0       	ldi	r24, 0x00	; 0
}
    73aa:	0f 91       	pop	r16
    73ac:	08 95       	ret

000073ae <IP_E_compare_Const>:
uint8_t IP_E_compare_Const(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
    73ae:	cf 92       	push	r12
    73b0:	df 92       	push	r13
    73b2:	ff 92       	push	r15
    73b4:	0f 93       	push	r16
    73b6:	1f 93       	push	r17
    73b8:	cf 93       	push	r28
    73ba:	df 93       	push	r29
    73bc:	1f 92       	push	r1
    73be:	cd b7       	in	r28, 0x3d	; 61
    73c0:	de b7       	in	r29, 0x3e	; 62
    73c2:	6c 01       	movw	r12, r24
    73c4:	f4 2e       	mov	r15, r20
    73c6:	12 2f       	mov	r17, r18
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    73c8:	69 83       	std	Y+1, r22	; 0x01
    73ca:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	if((erb(&IP->IP1) == IP1) && (erb(&IP->IP2) == IP2) && (erb(&IP->IP3) == IP3) && (erb(&IP->IP4) == IP4)) return 1;
    73ce:	69 81       	ldd	r22, Y+1	; 0x01
    73d0:	86 13       	cpse	r24, r22
    73d2:	12 c0       	rjmp	.+36     	; 0x73f8 <IP_E_compare_Const+0x4a>
    73d4:	c6 01       	movw	r24, r12
    73d6:	01 96       	adiw	r24, 0x01	; 1
    73d8:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    73dc:	8f 11       	cpse	r24, r15
    73de:	0c c0       	rjmp	.+24     	; 0x73f8 <IP_E_compare_Const+0x4a>
    73e0:	c6 01       	movw	r24, r12
    73e2:	02 96       	adiw	r24, 0x02	; 2
    73e4:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    73e8:	81 13       	cpse	r24, r17
    73ea:	06 c0       	rjmp	.+12     	; 0x73f8 <IP_E_compare_Const+0x4a>
    73ec:	c6 01       	movw	r24, r12
    73ee:	03 96       	adiw	r24, 0x03	; 3
    73f0:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    73f4:	91 e0       	ldi	r25, 0x01	; 1
    73f6:	80 13       	cpse	r24, r16
	else return 0;
    73f8:	90 e0       	ldi	r25, 0x00	; 0
}
    73fa:	89 2f       	mov	r24, r25
    73fc:	0f 90       	pop	r0
    73fe:	df 91       	pop	r29
    7400:	cf 91       	pop	r28
    7402:	1f 91       	pop	r17
    7404:	0f 91       	pop	r16
    7406:	ff 90       	pop	r15
    7408:	df 90       	pop	r13
    740a:	cf 90       	pop	r12
    740c:	08 95       	ret

0000740e <InitFIFO>:
		}
	}
#endif
// ~~~~~~~~~~~
void InitFIFO(void){
	GSM_RX_FIFO_Begin = 255;
    740e:	8f ef       	ldi	r24, 0xFF	; 255
    7410:	80 93 7b 08 	sts	0x087B, r24
	GSM_RX_FIFO_End = 255;
    7414:	80 93 05 06 	sts	0x0605, r24
	GSM_RxCharN = 0;
    7418:	10 92 45 0d 	sts	0x0D45, r1
    741c:	08 95       	ret

0000741e <GetByteFromFIFO>:
//	GSM_RX_FIFOOverFlow = 0;
//	GSM_RX_FIFOMax = 0;
}
// ~~~~~~~~~~~
void GetByteFromFIFO(uint8_t *ReadBuf, uint8_t *Index, uint8_t ReadBuf_Sz){
    741e:	fb 01       	movw	r30, r22

	//Reset *Index if read buffer overflow
	if(*Index >= ReadBuf_Sz){
    7420:	20 81       	ld	r18, Z
    7422:	24 17       	cp	r18, r20
    7424:	08 f0       	brcs	.+2      	; 0x7428 <GetByteFromFIFO+0xa>
		*Index = 0;
    7426:	10 82       	st	Z, r1
		//TODO  
	}	

	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End){
    7428:	20 91 7b 08 	lds	r18, 0x087B
    742c:	a0 91 05 06 	lds	r26, 0x0605
    7430:	a2 17       	cp	r26, r18
    7432:	08 f5       	brcc	.+66     	; 0x7476 <GetByteFromFIFO+0x58>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))			
    7434:	af 3f       	cpi	r26, 0xFF	; 255
    7436:	81 f0       	breq	.+32     	; 0x7458 <GetByteFromFIFO+0x3a>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End))
    7438:	40 91 0d 0b 	lds	r20, 0x0B0D
    743c:	20 91 7b 08 	lds	r18, 0x087B
    7440:	50 e0       	ldi	r21, 0x00	; 0
    7442:	30 e0       	ldi	r19, 0x00	; 0
    7444:	2a 1b       	sub	r18, r26
    7446:	31 09       	sbc	r19, r1
    7448:	42 17       	cp	r20, r18
    744a:	53 07       	cpc	r21, r19
    744c:	2c f4       	brge	.+10     	; 0x7458 <GetByteFromFIFO+0x3a>
				GSM_RX_FIFOMax =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End;
    744e:	20 91 7b 08 	lds	r18, 0x087B
    7452:	2a 1b       	sub	r18, r26
    7454:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    7458:	af 5f       	subi	r26, 0xFF	; 255
    745a:	a0 93 05 06 	sts	0x0605, r26
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    745e:	b0 e0       	ldi	r27, 0x00	; 0
    7460:	a8 50       	subi	r26, 0x08	; 8
    7462:	bb 4f       	sbci	r27, 0xFB	; 251
    7464:	2c 91       	ld	r18, X
    7466:	30 81       	ld	r19, Z
    7468:	dc 01       	movw	r26, r24
    746a:	a3 0f       	add	r26, r19
    746c:	b1 1d       	adc	r27, r1
    746e:	2c 93       	st	X, r18
		*Index=*Index+1;
    7470:	20 81       	ld	r18, Z
    7472:	2f 5f       	subi	r18, 0xFF	; 255
    7474:	20 83       	st	Z, r18
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
    7476:	60 91 05 06 	lds	r22, 0x0605
    747a:	20 91 7b 08 	lds	r18, 0x087B
    747e:	26 17       	cp	r18, r22
    7480:	60 f5       	brcc	.+88     	; 0x74da <GetByteFromFIFO+0xbc>
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
    7482:	6f 3f       	cpi	r22, 0xFF	; 255
    7484:	a1 f0       	breq	.+40     	; 0x74ae <GetByteFromFIFO+0x90>
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
    7486:	40 91 0d 0b 	lds	r20, 0x0B0D
    748a:	70 91 7b 08 	lds	r23, 0x087B
    748e:	50 e0       	ldi	r21, 0x00	; 0
    7490:	2a ef       	ldi	r18, 0xFA	; 250
    7492:	30 e0       	ldi	r19, 0x00	; 0
    7494:	26 1b       	sub	r18, r22
    7496:	31 09       	sbc	r19, r1
    7498:	27 0f       	add	r18, r23
    749a:	31 1d       	adc	r19, r1
    749c:	42 17       	cp	r20, r18
    749e:	53 07       	cpc	r21, r19
    74a0:	34 f4       	brge	.+12     	; 0x74ae <GetByteFromFIFO+0x90>
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
    74a2:	20 91 7b 08 	lds	r18, 0x087B
    74a6:	26 50       	subi	r18, 0x06	; 6
    74a8:	26 1b       	sub	r18, r22
    74aa:	20 93 0d 0b 	sts	0x0B0D, r18
		GSM_RX_FIFO_End++;
    74ae:	6f 5f       	subi	r22, 0xFF	; 255
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    74b0:	6a 3f       	cpi	r22, 0xFA	; 250
    74b2:	18 f4       	brcc	.+6      	; 0x74ba <GetByteFromFIFO+0x9c>
	}
	if(GSM_RX_FIFO_End > GSM_RX_FIFO_Begin){
		if((GSM_RX_FIFO_End != 255)&&(GSM_RX_FIFO_End != 255))
			if(GSM_RX_FIFOMax < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin))
				GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End  + GSM_RX_FIFO_Begin;
		GSM_RX_FIFO_End++;
    74b4:	60 93 05 06 	sts	0x0605, r22
    74b8:	02 c0       	rjmp	.+4      	; 0x74be <GetByteFromFIFO+0xa0>
		if(GSM_RX_FIFO_End >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End = 0;
    74ba:	10 92 05 06 	sts	0x0605, r1
		ReadBuf[*Index] = GSM_RX_FIFO[GSM_RX_FIFO_End];
    74be:	a0 91 05 06 	lds	r26, 0x0605
    74c2:	b0 e0       	ldi	r27, 0x00	; 0
    74c4:	a8 50       	subi	r26, 0x08	; 8
    74c6:	bb 4f       	sbci	r27, 0xFB	; 251
    74c8:	2c 91       	ld	r18, X
    74ca:	30 81       	ld	r19, Z
    74cc:	dc 01       	movw	r26, r24
    74ce:	a3 0f       	add	r26, r19
    74d0:	b1 1d       	adc	r27, r1
    74d2:	2c 93       	st	X, r18
		*Index=*Index+1;
    74d4:	80 81       	ld	r24, Z
    74d6:	8f 5f       	subi	r24, 0xFF	; 255
    74d8:	80 83       	st	Z, r24
    74da:	08 95       	ret

000074dc <GetStringFromFIFO>:
//        
uint8_t GetStringFromFIFO(void){

	uint8_t StrLength = 0;

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    74dc:	90 91 7b 08 	lds	r25, 0x087B
    74e0:	80 91 05 06 	lds	r24, 0x0605
    74e4:	98 17       	cp	r25, r24
    74e6:	39 f1       	breq	.+78     	; 0x7536 <GetStringFromFIFO+0x5a>
		
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    74e8:	44 e6       	ldi	r20, 0x64	; 100
    74ea:	65 e4       	ldi	r22, 0x45	; 69
    74ec:	7d e0       	ldi	r23, 0x0D	; 13
    74ee:	89 e8       	ldi	r24, 0x89	; 137
    74f0:	99 e0       	ldi	r25, 0x09	; 9
    74f2:	0e 94 0f 3a 	call	0x741e	; 0x741e <GetByteFromFIFO>

		//   : xxxxxxxxxxxxxxxx<CR><LF>
		//	'\r' CR - carridge return 0x0D
		//	'\n' LF - line feed 0x0A
		//   xxxxxxxxxxxxxxxx<\0>
		if( (GSM_RxCharN >= 2) && (GSM_RxStr[GSM_RxCharN-2]== '\r') && (GSM_RxStr[GSM_RxCharN-1]== '\n') ){
    74f6:	80 91 45 0d 	lds	r24, 0x0D45
    74fa:	82 30       	cpi	r24, 0x02	; 2
    74fc:	78 f3       	brcs	.-34     	; 0x74dc <GetStringFromFIFO>
    74fe:	e0 91 45 0d 	lds	r30, 0x0D45
    7502:	f0 e0       	ldi	r31, 0x00	; 0
    7504:	e9 57       	subi	r30, 0x79	; 121
    7506:	f6 4f       	sbci	r31, 0xF6	; 246
    7508:	80 81       	ld	r24, Z
    750a:	8d 30       	cpi	r24, 0x0D	; 13
    750c:	39 f7       	brne	.-50     	; 0x74dc <GetStringFromFIFO>
    750e:	e0 91 45 0d 	lds	r30, 0x0D45
    7512:	f0 e0       	ldi	r31, 0x00	; 0
    7514:	e8 57       	subi	r30, 0x78	; 120
    7516:	f6 4f       	sbci	r31, 0xF6	; 246
    7518:	80 81       	ld	r24, Z
    751a:	8a 30       	cpi	r24, 0x0A	; 10
    751c:	f9 f6       	brne	.-66     	; 0x74dc <GetStringFromFIFO>
			GSM_RxStr[GSM_RxCharN-2] = '\0';
    751e:	e0 91 45 0d 	lds	r30, 0x0D45
    7522:	f0 e0       	ldi	r31, 0x00	; 0
    7524:	e9 57       	subi	r30, 0x79	; 121
    7526:	f6 4f       	sbci	r31, 0xF6	; 246
    7528:	10 82       	st	Z, r1
			StrLength = GSM_RxCharN-1;
    752a:	80 91 45 0d 	lds	r24, 0x0D45
			GSM_RxCharN = 0;
    752e:	10 92 45 0d 	sts	0x0D45, r1
    7532:	81 50       	subi	r24, 0x01	; 1
    7534:	08 95       	ret
			return StrLength;
		}

	}//while

	return StrLength;
    7536:	80 e0       	ldi	r24, 0x00	; 0
}
    7538:	08 95       	ret

0000753a <ForceEndStringFromFIFO>:
// ~~~~~~~~~~~
//    GSM_RxStr  <CR><LF>
uint8_t ForceEndStringFromFIFO(void){
	uint8_t StrLength;
	if(GSM_RxCharN > GSM_RXSTR_SIZE-1) GSM_RxCharN = GSM_RXSTR_SIZE-1;
    753a:	80 91 45 0d 	lds	r24, 0x0D45
    753e:	84 36       	cpi	r24, 0x64	; 100
    7540:	18 f0       	brcs	.+6      	; 0x7548 <ForceEndStringFromFIFO+0xe>
    7542:	83 e6       	ldi	r24, 0x63	; 99
    7544:	80 93 45 0d 	sts	0x0D45, r24
	StrLength = GSM_RxCharN;
    7548:	80 91 45 0d 	lds	r24, 0x0D45
	GSM_RxStr[GSM_RxCharN]='\0';
    754c:	e0 91 45 0d 	lds	r30, 0x0D45
    7550:	f0 e0       	ldi	r31, 0x00	; 0
    7552:	e7 57       	subi	r30, 0x77	; 119
    7554:	f6 4f       	sbci	r31, 0xF6	; 246
    7556:	10 82       	st	Z, r1
	GSM_RxCharN = 0;
    7558:	10 92 45 0d 	sts	0x0D45, r1
	return StrLength;
}
    755c:	08 95       	ret

0000755e <GetDataFromFIFO>:

// ~~~~~~~~~~~
uint8_t GetDataFromFIFO(const uint8_t Amount){
    755e:	cf 93       	push	r28
    7560:	c8 2f       	mov	r28, r24

	while(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){
    7562:	90 91 7b 08 	lds	r25, 0x087B
    7566:	80 91 05 06 	lds	r24, 0x0605
    756a:	98 17       	cp	r25, r24
    756c:	79 f0       	breq	.+30     	; 0x758c <GetDataFromFIFO+0x2e>
		GetByteFromFIFO((uint8_t *)GSM_RxStr, (uint8_t *)&GSM_RxCharN, GSM_RXSTR_SIZE);
    756e:	44 e6       	ldi	r20, 0x64	; 100
    7570:	65 e4       	ldi	r22, 0x45	; 69
    7572:	7d e0       	ldi	r23, 0x0D	; 13
    7574:	89 e8       	ldi	r24, 0x89	; 137
    7576:	99 e0       	ldi	r25, 0x09	; 9
    7578:	0e 94 0f 3a 	call	0x741e	; 0x741e <GetByteFromFIFO>
		if(GSM_RxCharN >= Amount){
    757c:	80 91 45 0d 	lds	r24, 0x0D45
    7580:	8c 17       	cp	r24, r28
    7582:	78 f3       	brcs	.-34     	; 0x7562 <GetDataFromFIFO+0x4>
			GSM_RxCharN = 0;
    7584:	10 92 45 0d 	sts	0x0D45, r1
			return Amount;
    7588:	8c 2f       	mov	r24, r28
    758a:	02 c0       	rjmp	.+4      	; 0x7590 <GetDataFromFIFO+0x32>
		}
	}//while
	return GSM_RxCharN;
    758c:	80 91 45 0d 	lds	r24, 0x0D45
}
    7590:	cf 91       	pop	r28
    7592:	08 95       	ret

00007594 <strcpy_EE>:
// ~~~~~~~~~~~
//    EEPROM   RAM     '\0'    EEPROM
uint8_t strcpy_EE(char* str_RAM, uint8_t* str_EE){
    7594:	df 92       	push	r13
    7596:	ef 92       	push	r14
    7598:	ff 92       	push	r15
    759a:	0f 93       	push	r16
    759c:	1f 93       	push	r17
    759e:	cf 93       	push	r28
    75a0:	df 93       	push	r29
    75a2:	8c 01       	movw	r16, r24
    75a4:	7b 01       	movw	r14, r22
	uint8_t i=0;
    75a6:	d1 2c       	mov	r13, r1
	while( (erb(&str_EE[i])!='\0') && (erb(&str_EE[i])!=' ') ){
    75a8:	cd 2d       	mov	r28, r13
    75aa:	d0 e0       	ldi	r29, 0x00	; 0
    75ac:	c7 01       	movw	r24, r14
    75ae:	8c 0f       	add	r24, r28
    75b0:	9d 1f       	adc	r25, r29
    75b2:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    75b6:	98 2f       	mov	r25, r24
    75b8:	9f 7d       	andi	r25, 0xDF	; 223
    75ba:	29 f0       	breq	.+10     	; 0x75c6 <strcpy_EE+0x32>
		str_RAM[i] = (char)erb(&str_EE[i]);
    75bc:	c0 0f       	add	r28, r16
    75be:	d1 1f       	adc	r29, r17
    75c0:	88 83       	st	Y, r24
		i++;
    75c2:	d3 94       	inc	r13
    75c4:	f1 cf       	rjmp	.-30     	; 0x75a8 <strcpy_EE+0x14>
	}
	return i;	
}
    75c6:	8d 2d       	mov	r24, r13
    75c8:	df 91       	pop	r29
    75ca:	cf 91       	pop	r28
    75cc:	1f 91       	pop	r17
    75ce:	0f 91       	pop	r16
    75d0:	ff 90       	pop	r15
    75d2:	ef 90       	pop	r14
    75d4:	df 90       	pop	r13
    75d6:	08 95       	ret

000075d8 <GSM_Init>:
}
// ~~~~~~~~~~~
void
GSM_Init(void)
{	
	InitFIFO();
    75d8:	0e 94 07 3a 	call	0x740e	; 0x740e <InitFIFO>
		USART_GSM.BAUDCTRLB = 0x00 + USART_BSCALE0_bm;
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		USART_GSM.CTRLB = (1<<USART_RXEN_bp) | (1<<USART_TXEN_bp) | (0<<USART_CLK2X_bp) | (0 << USART_MPCM_bp) | (0 << USART_TXB8_bp);
		USART_GSM.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABl_gc | (0<< USART_SBMODE_bp) | USART_CHSIZE_8BIT_gc;
	#else
		UCSR_GSM_A = ~(1<<U2X_GSM) &~(1<<MPCM_GSM);
    75dc:	8c ef       	ldi	r24, 0xFC	; 252
    75de:	8b b9       	out	0x0b, r24	; 11
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    75e0:	88 e9       	ldi	r24, 0x98	; 152
    75e2:	8a b9       	out	0x0a, r24	; 10
		#if defined (__AVR_ATmega2561__) || defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)			
			UCSR_GSM_C = (0<<UMSEL_GSM_1) | (0<<UMSEL_GSM_0) | (0<<UPM_GSM_1) | (0<<UPM_GSM_0) | (0<<USBS_GSM) | (1<<UCSZ_GSM_1) | (1<<UCSZ_GSM_0) | (0<<UCPOL_GSM);
		#else
			UCSR_GSM_C = ((~(1<<UMSEL_GSM) &~(1<<UPM_GSM_1) &~(1<<UPM_GSM_0) &~(1<<USBS_GSM)) |(1<<UCSZ_GSM_1) |(1<<UCSZ_GSM_0)) &~(1<<UCPOL_GSM);
    75e4:	86 e8       	ldi	r24, 0x86	; 134
    75e6:	80 93 95 00 	sts	0x0095, r24
		#endif
		UBRR_GSM_H = 0x00;
    75ea:	10 92 90 00 	sts	0x0090, r1
		UBRR_GSM_L = 0x67;	// 9600
    75ee:	87 e6       	ldi	r24, 0x67	; 103
    75f0:	89 b9       	out	0x09, r24	; 9
	#endif

	GSM_PWRCNTRL_Config();
    75f2:	0e 94 d2 2e 	call	0x5da4	; 0x5da4 <GSM_PWRCNTRL_Config>
	GSM_PWRCNTRL_ON();
    75f6:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GSM_PWRCNTRL_ON>

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    75fa:	80 91 0e 01 	lds	r24, 0x010E
	#ifdef GSM_HW_FLOW_CONTROL
		GSM_CTS_RTS_Config();
	#endif

	TD_GSM = Timer16SysAlloc(1);
    75fe:	80 93 5a 02 	sts	0x025A, r24
	VacantTimer16Sys += n;
    7602:	91 e0       	ldi	r25, 0x01	; 1
    7604:	98 0f       	add	r25, r24
	TD_TCP_Connect = Timer16SysAlloc(1);
    7606:	90 93 59 02 	sts	0x0259, r25
    760a:	92 e0       	ldi	r25, 0x02	; 2
    760c:	98 0f       	add	r25, r24
	TD_RSSI = Timer16SysAlloc(1);
    760e:	90 93 58 02 	sts	0x0258, r25

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer32SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer32Sys;
    7612:	90 91 0d 01 	lds	r25, 0x010D
	VacantTimer32Sys += n;
    7616:	21 e0       	ldi	r18, 0x01	; 1
    7618:	29 0f       	add	r18, r25
    761a:	20 93 0d 01 	sts	0x010D, r18
	TD_GSM_Reset = Timer32SysAlloc(1);
    761e:	90 93 57 02 	sts	0x0257, r25
// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
	VacantTimer16Sys += n;
    7622:	93 e0       	ldi	r25, 0x03	; 3
    7624:	98 0f       	add	r25, r24
	TCP_CONNECT_check_timer = Timer16SysAlloc(1);
    7626:	90 93 40 0d 	sts	0x0D40, r25
    762a:	95 e0       	ldi	r25, 0x05	; 5
    762c:	98 0f       	add	r25, r24
    762e:	90 93 0e 01 	sts	0x010E, r25
    7632:	8c 5f       	subi	r24, 0xFC	; 252
	GPRS_RECONNECT_timer = Timer16SysAlloc(1);
    7634:	80 93 0b 06 	sts	0x060B, r24
/*	for (uint8_t i=0; i<4; i++)
		GPRS_ServerAddr[i] = erb(GPRS_ServerAddr_EE+i);
*/
	GSM_Control = GSM_CNTL_AUTO;
    7638:	10 92 7d 09 	sts	0x097D, r1
	GSM_State = GSM_PowerOn;
    763c:	10 92 27 06 	sts	0x0627, r1
    7640:	08 95       	ret

00007642 <GSM_Wait_Response>:
uint8_t GSM_Wait_Response(char *Str, uint8_t RestoreCMD){
//	if(Timer16Stopp(TD_GSM) && RestoreCMD){
//		GSM_State = RestoreCMD;
//		return 0;
//	}
	if(strcmp(GSM_RxStr, Str))return 0;
    7642:	bc 01       	movw	r22, r24
    7644:	89 e8       	ldi	r24, 0x89	; 137
    7646:	99 e0       	ldi	r25, 0x09	; 9
    7648:	0e 94 d1 6c 	call	0xd9a2	; 0xd9a2 <strcmp>
    764c:	21 e0       	ldi	r18, 0x01	; 1
    764e:	89 2b       	or	r24, r25
    7650:	09 f0       	breq	.+2      	; 0x7654 <GSM_Wait_Response+0x12>
    7652:	20 e0       	ldi	r18, 0x00	; 0
	else return 1;
}
    7654:	82 2f       	mov	r24, r18
    7656:	08 95       	ret

00007658 <GSM_Wait_Response_P>:
// ~~~~~~~~~
uint8_t GSM_Wait_Response_P(prog_char *Str_P, uint8_t RestoreCMD){
    7658:	0f 93       	push	r16
    765a:	1f 93       	push	r17
    765c:	cf 93       	push	r28
    765e:	df 93       	push	r29
    7660:	1f 92       	push	r1
    7662:	cd b7       	in	r28, 0x3d	; 61
    7664:	de b7       	in	r29, 0x3e	; 62
    7666:	8c 01       	movw	r16, r24
	
	if(Timer16Stopp(TD_GSM) && RestoreCMD){
    7668:	80 91 5a 02 	lds	r24, 0x025A
    766c:	69 83       	std	Y+1, r22	; 0x01
    766e:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    7672:	69 81       	ldd	r22, Y+1	; 0x01
    7674:	88 23       	and	r24, r24
    7676:	29 f0       	breq	.+10     	; 0x7682 <GSM_Wait_Response_P+0x2a>
    7678:	66 23       	and	r22, r22
    767a:	19 f0       	breq	.+6      	; 0x7682 <GSM_Wait_Response_P+0x2a>
		GSM_State = RestoreCMD;
    767c:	60 93 27 06 	sts	0x0627, r22
    7680:	0c c0       	rjmp	.+24     	; 0x769a <GSM_Wait_Response_P+0x42>
		return 0;
	}
	//  
	if(GetStringFromFIFO()){
    7682:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    7686:	88 23       	and	r24, r24
    7688:	41 f0       	breq	.+16     	; 0x769a <GSM_Wait_Response_P+0x42>
		if(strcmp_P(GSM_RxStr, Str_P)) return 0;
    768a:	b8 01       	movw	r22, r16
    768c:	89 e8       	ldi	r24, 0x89	; 137
    768e:	99 e0       	ldi	r25, 0x09	; 9
    7690:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    7694:	21 e0       	ldi	r18, 0x01	; 1
    7696:	89 2b       	or	r24, r25
    7698:	09 f0       	breq	.+2      	; 0x769c <GSM_Wait_Response_P+0x44>
		else return 1;
	}
	else return 0;
    769a:	20 e0       	ldi	r18, 0x00	; 0
}
    769c:	82 2f       	mov	r24, r18
    769e:	0f 90       	pop	r0
    76a0:	df 91       	pop	r29
    76a2:	cf 91       	pop	r28
    76a4:	1f 91       	pop	r17
    76a6:	0f 91       	pop	r16
    76a8:	08 95       	ret

000076aa <GSM_Wait_Char>:
// ~~~~~~~~~
uint8_t GSM_Wait_Char(char Char, uint8_t RestoreCMD){
    76aa:	1f 93       	push	r17
    76ac:	cf 93       	push	r28
    76ae:	df 93       	push	r29
    76b0:	1f 92       	push	r1
    76b2:	cd b7       	in	r28, 0x3d	; 61
    76b4:	de b7       	in	r29, 0x3e	; 62
    76b6:	18 2f       	mov	r17, r24
	if(Timer16Stopp(TD_GSM)){
    76b8:	80 91 5a 02 	lds	r24, 0x025A
    76bc:	69 83       	std	Y+1, r22	; 0x01
    76be:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    76c2:	69 81       	ldd	r22, Y+1	; 0x01
    76c4:	88 23       	and	r24, r24
    76c6:	19 f0       	breq	.+6      	; 0x76ce <GSM_Wait_Char+0x24>
		GSM_State = RestoreCMD;
    76c8:	60 93 27 06 	sts	0x0627, r22
    76cc:	09 c0       	rjmp	.+18     	; 0x76e0 <GSM_Wait_Char+0x36>
		return 0;
	}
	//   
	if(GetDataFromFIFO(1)){
    76ce:	81 e0       	ldi	r24, 0x01	; 1
    76d0:	0e 94 af 3a 	call	0x755e	; 0x755e <GetDataFromFIFO>
    76d4:	88 23       	and	r24, r24
    76d6:	21 f0       	breq	.+8      	; 0x76e0 <GSM_Wait_Char+0x36>
		if(GSM_RxStr[0] == Char)	return 1;
    76d8:	81 e0       	ldi	r24, 0x01	; 1
    76da:	90 91 89 09 	lds	r25, 0x0989
    76de:	91 13       	cpse	r25, r17
		else return 0;
	}
	else return 0;
    76e0:	80 e0       	ldi	r24, 0x00	; 0
}
    76e2:	0f 90       	pop	r0
    76e4:	df 91       	pop	r29
    76e6:	cf 91       	pop	r28
    76e8:	1f 91       	pop	r17
    76ea:	08 95       	ret

000076ec <GSM_TX>:
}
// ~~~~~~~~~
void
GSM_TX(void)
{
	if(Transparent){
    76ec:	80 91 76 0a 	lds	r24, 0x0A76
    76f0:	81 11       	cpse	r24, r1
    76f2:	05 c0       	rjmp	.+10     	; 0x76fe <GSM_TX+0x12>
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
	}
	else{	
		GSM_Flag |=(1<<flg_TxCStr);
    76f4:	80 91 08 01 	lds	r24, 0x0108
    76f8:	81 60       	ori	r24, 0x01	; 1
    76fa:	80 93 08 01 	sts	0x0108, r24
		#if defined (__AVR_ATxmega128A1__)
			USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc;
		#else
			UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    76fe:	88 e9       	ldi	r24, 0x98	; 152
    7700:	8a b9       	out	0x0a, r24	; 10
    7702:	08 95       	ret

00007704 <__vector_20>:

ISR(USART0_UDRE_vect){
	GSM_DRE();
	GSM_LED = 1;
}
ISR(USART0_TX_vect){
    7704:	1f 92       	push	r1
    7706:	0f 92       	push	r0
    7708:	0f b6       	in	r0, 0x3f	; 63
    770a:	0f 92       	push	r0
    770c:	11 24       	eor	r1, r1
    770e:	0b b6       	in	r0, 0x3b	; 59
    7710:	0f 92       	push	r0
    7712:	2f 93       	push	r18
    7714:	3f 93       	push	r19
    7716:	4f 93       	push	r20
    7718:	5f 93       	push	r21
    771a:	6f 93       	push	r22
    771c:	7f 93       	push	r23
    771e:	8f 93       	push	r24
    7720:	9f 93       	push	r25
    7722:	af 93       	push	r26
    7724:	bf 93       	push	r27
    7726:	ef 93       	push	r30
    7728:	ff 93       	push	r31
	GSM_TX();
    772a:	0e 94 76 3b 	call	0x76ec	; 0x76ec <GSM_TX>
	GSM_LED = 1;
    772e:	81 e0       	ldi	r24, 0x01	; 1
    7730:	80 93 0a 06 	sts	0x060A, r24
}
    7734:	ff 91       	pop	r31
    7736:	ef 91       	pop	r30
    7738:	bf 91       	pop	r27
    773a:	af 91       	pop	r26
    773c:	9f 91       	pop	r25
    773e:	8f 91       	pop	r24
    7740:	7f 91       	pop	r23
    7742:	6f 91       	pop	r22
    7744:	5f 91       	pop	r21
    7746:	4f 91       	pop	r20
    7748:	3f 91       	pop	r19
    774a:	2f 91       	pop	r18
    774c:	0f 90       	pop	r0
    774e:	0b be       	out	0x3b, r0	; 59
    7750:	0f 90       	pop	r0
    7752:	0f be       	out	0x3f, r0	; 63
    7754:	0f 90       	pop	r0
    7756:	1f 90       	pop	r1
    7758:	18 95       	reti

0000775a <DI_State>:

// ~~~~~~~~~~~~~~~~~~
uint8_t
DI_State(uint8_t D_N)
{
	return (DigInput.State[D_N/8] &(1<<D_N%8)) != 0;
    775a:	e8 2f       	mov	r30, r24
    775c:	e6 95       	lsr	r30
    775e:	e6 95       	lsr	r30
    7760:	e6 95       	lsr	r30
    7762:	f0 e0       	ldi	r31, 0x00	; 0
    7764:	ea 52       	subi	r30, 0x2A	; 42
    7766:	f7 4f       	sbci	r31, 0xF7	; 247
    7768:	20 81       	ld	r18, Z
    776a:	30 e0       	ldi	r19, 0x00	; 0
    776c:	87 70       	andi	r24, 0x07	; 7
    776e:	02 c0       	rjmp	.+4      	; 0x7774 <DI_State+0x1a>
    7770:	35 95       	asr	r19
    7772:	27 95       	ror	r18
    7774:	8a 95       	dec	r24
    7776:	e2 f7       	brpl	.-8      	; 0x7770 <DI_State+0x16>
}
    7778:	82 2f       	mov	r24, r18
    777a:	81 70       	andi	r24, 0x01	; 1
    777c:	08 95       	ret

0000777e <DI_Status>:

// ~~~~~~~~~~~~~~~~~~~
uint8_t
DI_Status(uint8_t D_N)
{
	return (DigInput.Status[D_N/8] &(1<<D_N%8)) != 0;
    777e:	e8 2f       	mov	r30, r24
    7780:	e6 95       	lsr	r30
    7782:	e6 95       	lsr	r30
    7784:	e6 95       	lsr	r30
    7786:	f0 e0       	ldi	r31, 0x00	; 0
    7788:	e8 52       	subi	r30, 0x28	; 40
    778a:	f7 4f       	sbci	r31, 0xF7	; 247
    778c:	20 81       	ld	r18, Z
    778e:	30 e0       	ldi	r19, 0x00	; 0
    7790:	87 70       	andi	r24, 0x07	; 7
    7792:	02 c0       	rjmp	.+4      	; 0x7798 <DI_Status+0x1a>
    7794:	35 95       	asr	r19
    7796:	27 95       	ror	r18
    7798:	8a 95       	dec	r24
    779a:	e2 f7       	brpl	.-8      	; 0x7794 <DI_Status+0x16>
}
    779c:	82 2f       	mov	r24, r18
    779e:	81 70       	andi	r24, 0x01	; 1
    77a0:	08 95       	ret

000077a2 <DigitIn>:
}

// ~~~~~~~~~~
void
DigitIn(void)
{
    77a2:	ff 92       	push	r15
    77a4:	0f 93       	push	r16
    77a6:	1f 93       	push	r17
    77a8:	cf 93       	push	r28
    77aa:	df 93       	push	r29
	memcpy(DigInput.StateOld, DigInput.State, DI_Reg+DI_Reg_Ext);
    77ac:	c0 91 d6 08 	lds	r28, 0x08D6
    77b0:	c0 93 d7 08 	sts	0x08D7, r28
    77b4:	8e e5       	ldi	r24, 0x5E	; 94
    77b6:	90 e0       	ldi	r25, 0x00	; 0
    77b8:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	for (uint8_t i=0; i<DI_Reg; i++)
		DigInput.Status[i] = DigInput.State[i]^erb(DI_Invers+i);
    77bc:	8c 27       	eor	r24, r28
    77be:	80 93 d8 08 	sts	0x08D8, r24
    77c2:	85 e2       	ldi	r24, 0x25	; 37
    77c4:	9d e4       	ldi	r25, 0x4D	; 77
    77c6:	20 e0       	ldi	r18, 0x00	; 0
    77c8:	30 e0       	ldi	r19, 0x00	; 0
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
			uint8_t Byte=D_N/8, Bit=1<<D_N%8;
    77ca:	c1 e0       	ldi	r28, 0x01	; 1
    77cc:	d0 e0       	ldi	r29, 0x00	; 0
    77ce:	ae 01       	movw	r20, r28
    77d0:	02 2e       	mov	r0, r18
    77d2:	01 c0       	rjmp	.+2      	; 0x77d6 <DigitIn+0x34>
    77d4:	44 0f       	add	r20, r20
    77d6:	0a 94       	dec	r0
    77d8:	ea f7       	brpl	.-6      	; 0x77d4 <DigitIn+0x32>
    77da:	fc 01       	movw	r30, r24
    77dc:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77de:	e4 91       	lpm	r30, Z
    77e0:	dc 01       	movw	r26, r24
    77e2:	12 96       	adiw	r26, 0x02	; 2
    77e4:	f0 90 d6 08 	lds	r15, 0x08D6
			if(prb(&DI_M[D_N].Inversion)){
    77e8:	ee 23       	and	r30, r30
    77ea:	51 f0       	breq	.+20     	; 0x7800 <DigitIn+0x5e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    77ec:	fc 01       	movw	r30, r24
    77ee:	05 91       	lpm	r16, Z+
    77f0:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    77f2:	fd 01       	movw	r30, r26
    77f4:	a4 91       	lpm	r26, Z
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    77f6:	f8 01       	movw	r30, r16
    77f8:	60 81       	ld	r22, Z
    77fa:	a6 23       	and	r26, r22
    77fc:	51 f0       	breq	.+20     	; 0x7812 <DigitIn+0x70>
    77fe:	0c c0       	rjmp	.+24     	; 0x7818 <DigitIn+0x76>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7800:	fc 01       	movw	r30, r24
    7802:	05 91       	lpm	r16, Z+
    7804:	14 91       	lpm	r17, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    7806:	fd 01       	movw	r30, r26
    7808:	a4 91       	lpm	r26, Z
					DigInput.State[Byte] |=Bit;
				else
					DigInput.State[Byte] &=~Bit;
			}
			else{
				if (*(uint8_t*)prp(&DI_M[D_N].PIN) & prb(&DI_M[D_N].P))
    780a:	f8 01       	movw	r30, r16
    780c:	60 81       	ld	r22, Z
    780e:	a6 23       	and	r26, r22
    7810:	19 f0       	breq	.+6      	; 0x7818 <DigitIn+0x76>
					DigInput.State[Byte] &=~Bit;
    7812:	40 95       	com	r20
    7814:	4f 21       	and	r20, r15
    7816:	01 c0       	rjmp	.+2      	; 0x781a <DigitIn+0x78>
				else
					DigInput.State[Byte]  |=Bit;
    7818:	4f 29       	or	r20, r15
    781a:	40 93 d6 08 	sts	0x08D6, r20
    781e:	2f 5f       	subi	r18, 0xFF	; 255
    7820:	3f 4f       	sbci	r19, 0xFF	; 255
    7822:	08 96       	adiw	r24, 0x08	; 8
	void DigitIn_Hard(void);
#else
	static void
	DigitIn_Hard(void)
	{
		for (uint8_t D_N=0; D_N<sizeof(DI_M)/sizeof(T_DI_M); D_N++) {
    7824:	24 30       	cpi	r18, 0x04	; 4
    7826:	31 05       	cpc	r19, r1
    7828:	09 f0       	breq	.+2      	; 0x782c <DigitIn+0x8a>
    782a:	d1 cf       	rjmp	.-94     	; 0x77ce <DigitIn+0x2c>
			DigInput.State[j]		= (DigInput_Ext)[i];
			DigInput.Status[j]	= (DigInput_Ext)[i+DI_Reg_Ext];
			IntOn();
		}
	#endif
}
    782c:	df 91       	pop	r29
    782e:	cf 91       	pop	r28
    7830:	1f 91       	pop	r17
    7832:	0f 91       	pop	r16
    7834:	ff 90       	pop	r15
    7836:	08 95       	ret

00007838 <SetDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
SetDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] |=(1<<D_N%8);
    7838:	e8 2f       	mov	r30, r24
    783a:	e6 95       	lsr	r30
    783c:	e6 95       	lsr	r30
    783e:	e6 95       	lsr	r30
    7840:	f0 e0       	ldi	r31, 0x00	; 0
    7842:	eb 57       	subi	r30, 0x7B	; 123
    7844:	f6 4f       	sbci	r31, 0xF6	; 246
    7846:	87 70       	andi	r24, 0x07	; 7
    7848:	21 e0       	ldi	r18, 0x01	; 1
    784a:	30 e0       	ldi	r19, 0x00	; 0
    784c:	01 c0       	rjmp	.+2      	; 0x7850 <SetDigOut+0x18>
    784e:	22 0f       	add	r18, r18
    7850:	8a 95       	dec	r24
    7852:	ea f7       	brpl	.-6      	; 0x784e <SetDigOut+0x16>
    7854:	80 81       	ld	r24, Z
    7856:	82 2b       	or	r24, r18
    7858:	80 83       	st	Z, r24
    785a:	08 95       	ret

0000785c <ResDigOut>:

// ~~~~~~~~~~~~~~~~~~~
void
ResDigOut(uint8_t D_N)
{
	DigOutput.Buf[D_N/8] &=~(1<<D_N%8);
    785c:	e8 2f       	mov	r30, r24
    785e:	e6 95       	lsr	r30
    7860:	e6 95       	lsr	r30
    7862:	e6 95       	lsr	r30
    7864:	f0 e0       	ldi	r31, 0x00	; 0
    7866:	eb 57       	subi	r30, 0x7B	; 123
    7868:	f6 4f       	sbci	r31, 0xF6	; 246
    786a:	87 70       	andi	r24, 0x07	; 7
    786c:	21 e0       	ldi	r18, 0x01	; 1
    786e:	30 e0       	ldi	r19, 0x00	; 0
    7870:	01 c0       	rjmp	.+2      	; 0x7874 <ResDigOut+0x18>
    7872:	22 0f       	add	r18, r18
    7874:	8a 95       	dec	r24
    7876:	ea f7       	brpl	.-6      	; 0x7872 <ResDigOut+0x16>
    7878:	20 95       	com	r18
    787a:	80 81       	ld	r24, Z
    787c:	28 23       	and	r18, r24
    787e:	20 83       	st	Z, r18
    7880:	08 95       	ret

00007882 <DigitOut>:

// ~~~~~~~~~~~
void
DigitOut(void)
{
	memcpy(DigOutput.StateOld, DigOutput.State, DO_Reg+DO_Reg_Ext);
    7882:	80 91 83 09 	lds	r24, 0x0983
    7886:	80 93 84 09 	sts	0x0984, r24
	memcpy(DigOutput.State, DigOutput.Buf, DO_Reg);
    788a:	80 91 85 09 	lds	r24, 0x0985
    788e:	80 93 83 09 	sts	0x0983, r24
    7892:	84 e1       	ldi	r24, 0x14	; 20
    7894:	9d e4       	ldi	r25, 0x4D	; 77
    7896:	20 e0       	ldi	r18, 0x00	; 0
    7898:	30 e0       	ldi	r19, 0x00	; 0
// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    789a:	f8 94       	cli
		if (DigOutput.State[D_N/8] &(1<<D_N%8))
    789c:	40 91 83 09 	lds	r20, 0x0983
    78a0:	50 e0       	ldi	r21, 0x00	; 0
    78a2:	02 2e       	mov	r0, r18
    78a4:	02 c0       	rjmp	.+4      	; 0x78aa <DigitOut+0x28>
    78a6:	55 95       	asr	r21
    78a8:	47 95       	ror	r20
    78aa:	0a 94       	dec	r0
    78ac:	e2 f7       	brpl	.-8      	; 0x78a6 <DigitOut+0x24>
    78ae:	bc 01       	movw	r22, r24
    78b0:	6e 5f       	subi	r22, 0xFE	; 254
    78b2:	7f 4f       	sbci	r23, 0xFF	; 255

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78b4:	fc 01       	movw	r30, r24
    78b6:	40 ff       	sbrs	r20, 0
    78b8:	07 c0       	rjmp	.+14     	; 0x78c8 <DigitOut+0x46>
    78ba:	a5 91       	lpm	r26, Z+
    78bc:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78be:	fb 01       	movw	r30, r22
    78c0:	64 91       	lpm	r22, Z
			*(uint8_t*)prp(&DO_M[D_N].PORT)  |= prb(&DO_M[D_N].P);
    78c2:	4c 91       	ld	r20, X
    78c4:	46 2b       	or	r20, r22
    78c6:	07 c0       	rjmp	.+14     	; 0x78d6 <DigitOut+0x54>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78c8:	a5 91       	lpm	r26, Z+
    78ca:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78cc:	fb 01       	movw	r30, r22
    78ce:	64 91       	lpm	r22, Z
		else
			*(uint8_t*)prp(&DO_M[D_N].PORT) &= ~prb(&DO_M[D_N].P);
    78d0:	60 95       	com	r22
    78d2:	4c 91       	ld	r20, X
    78d4:	46 23       	and	r20, r22
    78d6:	4c 93       	st	X, r20
		sei();
    78d8:	78 94       	sei
    78da:	2f 5f       	subi	r18, 0xFF	; 255
    78dc:	3f 4f       	sbci	r19, 0xFF	; 255
    78de:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~~
static void
DigitOut_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    78e0:	23 30       	cpi	r18, 0x03	; 3
    78e2:	31 05       	cpc	r19, r1
    78e4:	d1 f6       	brne	.-76     	; 0x789a <DigitOut+0x18>
				DigOutput.State[j] = (DigOutput_Ext)[i];
			(DigOutput_Ext)[i+DO_Reg_Ext] = DigOutput.Buf[j];
			IntOn();
		}
	#endif
}
    78e6:	08 95       	ret

000078e8 <DO_Init>:

// ~~~~~~~~~~
void
DO_Init(void)
{
    78e8:	82 e1       	ldi	r24, 0x12	; 18
    78ea:	9d e4       	ldi	r25, 0x4D	; 77
// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
		cli();
    78ec:	f8 94       	cli

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    78ee:	fc 01       	movw	r30, r24
    78f0:	a5 91       	lpm	r26, Z+
    78f2:	b4 91       	lpm	r27, Z
    78f4:	fc 01       	movw	r30, r24
    78f6:	34 96       	adiw	r30, 0x04	; 4

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    78f8:	e4 91       	lpm	r30, Z
		*(uint8_t*)prp(&DO_M[D_N].DDR) |= prb(&DO_M[D_N].P);
    78fa:	2c 91       	ld	r18, X
    78fc:	2e 2b       	or	r18, r30
    78fe:	2c 93       	st	X, r18
		sei();
    7900:	78 94       	sei
    7902:	05 96       	adiw	r24, 0x05	; 5

// ~~~~~~~~~~~~~~~
static void
DO_Init_Hard(void)
{
	for (uint8_t D_N=0; D_N<sizeof(DO_M)/sizeof(T_DO_M); D_N++) {
    7904:	2d e4       	ldi	r18, 0x4D	; 77
    7906:	81 32       	cpi	r24, 0x21	; 33
    7908:	92 07       	cpc	r25, r18
    790a:	81 f7       	brne	.-32     	; 0x78ec <DO_Init+0x4>
// ~~~~~~~~~~
void
DO_Init(void)
{
	DO_Init_Hard();
	DigitOut();		// Clear all
    790c:	0c 94 41 3c 	jmp	0x7882	; 0x7882 <DigitOut>

00007910 <Pow10>:
#include <string.h>

// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
    7910:	28 2f       	mov	r18, r24
	uint16_t Pow = 1;
    7912:	81 e0       	ldi	r24, 0x01	; 1
    7914:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
		Pow *= 10;
    7916:	3a e0       	ldi	r19, 0x0A	; 10
// ~~~~~~~~~~~~~~~
uint16_t
Pow10(uint8_t Exp)
{
	uint16_t Pow = 1;
	while(Exp--)
    7918:	21 50       	subi	r18, 0x01	; 1
    791a:	38 f0       	brcs	.+14     	; 0x792a <Pow10+0x1a>
		Pow *= 10;
    791c:	ac 01       	movw	r20, r24
    791e:	34 9f       	mul	r19, r20
    7920:	c0 01       	movw	r24, r0
    7922:	35 9f       	mul	r19, r21
    7924:	90 0d       	add	r25, r0
    7926:	11 24       	eor	r1, r1
    7928:	f7 cf       	rjmp	.-18     	; 0x7918 <Pow10+0x8>
	return Pow;
}
    792a:	08 95       	ret

0000792c <PowL10>:
// ~~~~~~~~~~~~~~~
uint32_t
PowL10(uint8_t Exp)
{
    792c:	e8 2f       	mov	r30, r24
	uint32_t Pow = 1;
    792e:	61 e0       	ldi	r22, 0x01	; 1
    7930:	70 e0       	ldi	r23, 0x00	; 0
    7932:	80 e0       	ldi	r24, 0x00	; 0
    7934:	90 e0       	ldi	r25, 0x00	; 0
	while(Exp--)
    7936:	e1 50       	subi	r30, 0x01	; 1
    7938:	38 f0       	brcs	.+14     	; 0x7948 <PowL10+0x1c>
		Pow *= 10;
    793a:	aa e0       	ldi	r26, 0x0A	; 10
    793c:	b0 e0       	ldi	r27, 0x00	; 0
    793e:	9b 01       	movw	r18, r22
    7940:	ac 01       	movw	r20, r24
    7942:	0e 94 b5 75 	call	0xeb6a	; 0xeb6a <__muluhisi3>
    7946:	f7 cf       	rjmp	.-18     	; 0x7936 <PowL10+0xa>
	return Pow;
}
    7948:	08 95       	ret

0000794a <OW_MasterTx_Command>:
uint8_t TD_DS18B20Read;

enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
    794a:	ff 92       	push	r15
    794c:	0f 93       	push	r16
    794e:	1f 93       	push	r17
    7950:	cf 93       	push	r28
    7952:	df 93       	push	r29
    7954:	f8 2e       	mov	r15, r24
    7956:	c0 e0       	ldi	r28, 0x00	; 0
    7958:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		if(Command & (1<<i)){
    795a:	06 2f       	mov	r16, r22
    795c:	10 e0       	ldi	r17, 0x00	; 0

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
		cli();
    795e:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    7960:	8f 2d       	mov	r24, r15
    7962:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <OW_MasterPullLowBus>
    7966:	8a e1       	ldi	r24, 0x1A	; 26
    7968:	8a 95       	dec	r24
    796a:	f1 f7       	brne	.-4      	; 0x7968 <OW_MasterTx_Command+0x1e>
    796c:	00 c0       	rjmp	.+0      	; 0x796e <OW_MasterTx_Command+0x24>
		_delay_us(5);
		if(Command & (1<<i)){
    796e:	98 01       	movw	r18, r16
    7970:	0c 2e       	mov	r0, r28
    7972:	02 c0       	rjmp	.+4      	; 0x7978 <OW_MasterTx_Command+0x2e>
    7974:	35 95       	asr	r19
    7976:	27 95       	ror	r18
    7978:	0a 94       	dec	r0
    797a:	e2 f7       	brpl	.-8      	; 0x7974 <OW_MasterTx_Command+0x2a>
    797c:	20 ff       	sbrs	r18, 0
    797e:	0a c0       	rjmp	.+20     	; 0x7994 <OW_MasterTx_Command+0x4a>
			OW_MasterReleaseBus(CH);
    7980:	8f 2d       	mov	r24, r15
    7982:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>
    7986:	83 e5       	ldi	r24, 0x53	; 83
    7988:	91 e0       	ldi	r25, 0x01	; 1
    798a:	01 97       	sbiw	r24, 0x01	; 1
    798c:	f1 f7       	brne	.-4      	; 0x798a <OW_MasterTx_Command+0x40>
    798e:	00 c0       	rjmp	.+0      	; 0x7990 <OW_MasterTx_Command+0x46>
    7990:	00 00       	nop
    7992:	07 c0       	rjmp	.+14     	; 0x79a2 <OW_MasterTx_Command+0x58>
			_delay_us(85);
		}
		else{
			Delay_us(85);
    7994:	85 e5       	ldi	r24, 0x55	; 85
    7996:	90 e0       	ldi	r25, 0x00	; 0
    7998:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>
			OW_MasterReleaseBus(CH);
    799c:	8f 2d       	mov	r24, r15
    799e:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>
		}
		sei();
    79a2:	78 94       	sei
    79a4:	9a e1       	ldi	r25, 0x1A	; 26
    79a6:	9a 95       	dec	r25
    79a8:	f1 f7       	brne	.-4      	; 0x79a6 <OW_MasterTx_Command+0x5c>
    79aa:	00 c0       	rjmp	.+0      	; 0x79ac <OW_MasterTx_Command+0x62>
    79ac:	21 96       	adiw	r28, 0x01	; 1
enum{OW_NO_CODE, OW_OK, OW_NO_PRESENCE_PULSE};

//~~~~~~~~~~~~~
void OW_MasterTx_Command(const uint8_t CH, const uint8_t Command){
	uint8_t i ;
	for(i=0; i<8; i++){
    79ae:	c8 30       	cpi	r28, 0x08	; 8
    79b0:	d1 05       	cpc	r29, r1
    79b2:	a9 f6       	brne	.-86     	; 0x795e <OW_MasterTx_Command+0x14>
			OW_MasterReleaseBus(CH);
		}
		sei();
		_delay_us(5);	//recovery time minimum 1us
	}
}
    79b4:	df 91       	pop	r29
    79b6:	cf 91       	pop	r28
    79b8:	1f 91       	pop	r17
    79ba:	0f 91       	pop	r16
    79bc:	ff 90       	pop	r15
    79be:	08 95       	ret

000079c0 <OW_MasterRx_Data>:
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
    79c0:	ef 92       	push	r14
    79c2:	ff 92       	push	r15
    79c4:	0f 93       	push	r16
    79c6:	1f 93       	push	r17
    79c8:	cf 93       	push	r28
    79ca:	df 93       	push	r29
    79cc:	e8 2e       	mov	r14, r24
    79ce:	c0 e0       	ldi	r28, 0x00	; 0
    79d0:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t i;
	uint8_t Data = 0;
    79d2:	f1 2c       	mov	r15, r1
		cli();
		OW_MasterPullLowBus(CH);
		_delay_us(5);
		OW_MasterReleaseBus(CH);
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79d4:	01 e0       	ldi	r16, 0x01	; 1
    79d6:	10 e0       	ldi	r17, 0x00	; 0
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
		cli();
    79d8:	f8 94       	cli
		OW_MasterPullLowBus(CH);
    79da:	8e 2d       	mov	r24, r14
    79dc:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <OW_MasterPullLowBus>
    79e0:	8a e1       	ldi	r24, 0x1A	; 26
    79e2:	8a 95       	dec	r24
    79e4:	f1 f7       	brne	.-4      	; 0x79e2 <OW_MasterRx_Data+0x22>
    79e6:	00 c0       	rjmp	.+0      	; 0x79e8 <OW_MasterRx_Data+0x28>
		_delay_us(5);
		OW_MasterReleaseBus(CH);
    79e8:	8e 2d       	mov	r24, r14
    79ea:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>
    79ee:	9a e1       	ldi	r25, 0x1A	; 26
    79f0:	9a 95       	dec	r25
    79f2:	f1 f7       	brne	.-4      	; 0x79f0 <OW_MasterRx_Data+0x30>
    79f4:	00 c0       	rjmp	.+0      	; 0x79f6 <OW_MasterRx_Data+0x36>
}
//~~~~~~~~~~~~~
uint8_t OW_MasterReadBus(uint8_t CH){
	switch(CH){
		//default: return (PINF & (1<<PF2));
		default: return (PING & (1<<PG0));
    79f6:	80 91 63 00 	lds	r24, 0x0063
		_delay_us(5);
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
    79fa:	80 ff       	sbrs	r24, 0
    79fc:	07 c0       	rjmp	.+14     	; 0x7a0c <OW_MasterRx_Data+0x4c>
    79fe:	98 01       	movw	r18, r16
    7a00:	0c 2e       	mov	r0, r28
    7a02:	01 c0       	rjmp	.+2      	; 0x7a06 <OW_MasterRx_Data+0x46>
    7a04:	22 0f       	add	r18, r18
    7a06:	0a 94       	dec	r0
    7a08:	ea f7       	brpl	.-6      	; 0x7a04 <OW_MasterRx_Data+0x44>
    7a0a:	f2 2a       	or	r15, r18
		sei();
    7a0c:	78 94       	sei
    7a0e:	8f ee       	ldi	r24, 0xEF	; 239
    7a10:	90 e0       	ldi	r25, 0x00	; 0
    7a12:	01 97       	sbiw	r24, 0x01	; 1
    7a14:	f1 f7       	brne	.-4      	; 0x7a12 <OW_MasterRx_Data+0x52>
    7a16:	00 c0       	rjmp	.+0      	; 0x7a18 <OW_MasterRx_Data+0x58>
    7a18:	00 00       	nop
    7a1a:	21 96       	adiw	r28, 0x01	; 1
}
//~~~~~~~~~~~~~
uint8_t OW_MasterRx_Data(const uint8_t CH){
	uint8_t i;
	uint8_t Data = 0;
	for(i=0; i<8; i++){
    7a1c:	c8 30       	cpi	r28, 0x08	; 8
    7a1e:	d1 05       	cpc	r29, r1
    7a20:	d9 f6       	brne	.-74     	; 0x79d8 <OW_MasterRx_Data+0x18>
		if(OW_MasterReadBus(CH)) Data |= (1<<i);
		sei();
		_delay_us(60);
	}
	return Data;
}
    7a22:	8f 2d       	mov	r24, r15
    7a24:	df 91       	pop	r29
    7a26:	cf 91       	pop	r28
    7a28:	1f 91       	pop	r17
    7a2a:	0f 91       	pop	r16
    7a2c:	ff 90       	pop	r15
    7a2e:	ef 90       	pop	r14
    7a30:	08 95       	ret

00007a32 <OneWire_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    7a32:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    7a36:	91 e0       	ldi	r25, 0x01	; 1
    7a38:	98 0f       	add	r25, r24
    7a3a:	90 93 0f 01 	sts	0x010F, r25


//~~~~~~~~~~~~~
void OneWire_Init(void){
	TD_DS18B20Read = Timer8SysAlloc(1);
    7a3e:	80 93 6b 09 	sts	0x096B, r24
	uint8_t i;
	for(i=0; i<TerReg; i++) DS18B20_Error[i] = 10;
    7a42:	8a e0       	ldi	r24, 0x0A	; 10
    7a44:	80 93 f7 03 	sts	0x03F7, r24
    7a48:	08 95       	ret

00007a4a <OneWireStartADC>:
	#ifdef RH_CHANNNEL
		StartTimer8(TD_DS18B20Read, 200);
	#endif
}
// ~~~~~~~~~~~~~
void OneWireStartADC(const uint8_t CH){
    7a4a:	ff 92       	push	r15
    7a4c:	0f 93       	push	r16
    7a4e:	1f 93       	push	r17
    7a50:	cf 93       	push	r28
    7a52:	df 93       	push	r29
    7a54:	f8 2e       	mov	r15, r24
	#ifdef RH_CHANNNEL
		if(CH == RH_CHANNNEL) return;
	#endif

	if(erb(&ThermType[CH]) == ThermOff){
    7a56:	08 2f       	mov	r16, r24
    7a58:	10 e0       	ldi	r17, 0x00	; 0
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    7a5a:	c8 01       	movw	r24, r16
    7a5c:	83 5a       	subi	r24, 0xA3	; 163
    7a5e:	9f 4f       	sbci	r25, 0xFF	; 255
    7a60:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    7a64:	e8 01       	movw	r28, r16
    7a66:	cd 50       	subi	r28, 0x0D	; 13
    7a68:	d6 4f       	sbci	r29, 0xF6	; 246
    7a6a:	81 11       	cpse	r24, r1
    7a6c:	0c c0       	rjmp	.+24     	; 0x7a86 <OneWireStartADC+0x3c>
		Temperature[CH] = Therm_Off_Mark;
    7a6e:	f8 01       	movw	r30, r16
    7a70:	ee 0f       	add	r30, r30
    7a72:	ff 1f       	adc	r31, r31
    7a74:	ee 50       	subi	r30, 0x0E	; 14
    7a76:	fa 4f       	sbci	r31, 0xFA	; 250
    7a78:	80 e0       	ldi	r24, 0x00	; 0
    7a7a:	90 e8       	ldi	r25, 0x80	; 128
    7a7c:	91 83       	std	Z+1, r25	; 0x01
    7a7e:	80 83       	st	Z, r24
		DS18B20_Status[CH] = DS18B20_ERROR;
    7a80:	82 e0       	ldi	r24, 0x02	; 2
    7a82:	88 83       	st	Y, r24
		return;
    7a84:	37 c0       	rjmp	.+110    	; 0x7af4 <OneWireStartADC+0xaa>
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7a86:	f8 94       	cli
    7a88:	8f 2d       	mov	r24, r15
    7a8a:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <OW_MasterPullLowBus>
    7a8e:	78 94       	sei
	Delay_us(580);	
    7a90:	84 e4       	ldi	r24, 0x44	; 68
    7a92:	92 e0       	ldi	r25, 0x02	; 2
    7a94:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7a98:	f8 94       	cli
    7a9a:	8f 2d       	mov	r24, r15
    7a9c:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>
    7aa0:	87 e1       	ldi	r24, 0x17	; 23
    7aa2:	91 e0       	ldi	r25, 0x01	; 1
    7aa4:	01 97       	sbiw	r24, 0x01	; 1
    7aa6:	f1 f7       	brne	.-4      	; 0x7aa4 <OneWireStartADC+0x5a>
    7aa8:	00 c0       	rjmp	.+0      	; 0x7aaa <OneWireStartADC+0x60>
    7aaa:	00 00       	nop
    7aac:	80 91 63 00 	lds	r24, 0x0063
	
	//MASTER RX presence pulse480s minimum
	_delay_us(70);	//SLAVE waits
	if(OW_MasterReadBus(CH)==0)	DS18B20_Status[CH] = DS18B20_OK;
    7ab0:	80 fd       	sbrc	r24, 0
    7ab2:	03 c0       	rjmp	.+6      	; 0x7aba <OneWireStartADC+0x70>
    7ab4:	81 e0       	ldi	r24, 0x01	; 1
    7ab6:	88 83       	st	Y, r24
    7ab8:	08 c0       	rjmp	.+16     	; 0x7aca <OneWireStartADC+0x80>
	else{ 
		DS18B20_Status[CH] = DS18B20_ERROR;
    7aba:	82 e0       	ldi	r24, 0x02	; 2
    7abc:	88 83       	st	Y, r24
		DS18B20_Error[CH]++;
    7abe:	f8 01       	movw	r30, r16
    7ac0:	e9 50       	subi	r30, 0x09	; 9
    7ac2:	fc 4f       	sbci	r31, 0xFC	; 252
    7ac4:	80 81       	ld	r24, Z
    7ac6:	8f 5f       	subi	r24, 0xFF	; 255
    7ac8:	80 83       	st	Z, r24
	}
	sei();
    7aca:	78 94       	sei
	
	Delay_us(510);
    7acc:	8e ef       	ldi	r24, 0xFE	; 254
    7ace:	91 e0       	ldi	r25, 0x01	; 1
    7ad0:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7ad4:	88 81       	ld	r24, Y
    7ad6:	82 30       	cpi	r24, 0x02	; 2
    7ad8:	69 f0       	breq	.+26     	; 0x7af4 <OneWireStartADC+0xaa>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7ada:	6c ec       	ldi	r22, 0xCC	; 204
    7adc:	8f 2d       	mov	r24, r15
    7ade:	0e 94 a5 3c 	call	0x794a	; 0x794a <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7ae2:	64 e4       	ldi	r22, 0x44	; 68
    7ae4:	8f 2d       	mov	r24, r15
	}
}
    7ae6:	df 91       	pop	r29
    7ae8:	cf 91       	pop	r28
    7aea:	1f 91       	pop	r17
    7aec:	0f 91       	pop	r16
    7aee:	ff 90       	pop	r15
	
	Delay_us(510);

	if(DS18B20_Status[CH] != DS18B20_ERROR){
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
		OW_MasterTx_Command(CH,0x44);	// CONVERT T Command
    7af0:	0c 94 a5 3c 	jmp	0x794a	; 0x794a <OW_MasterTx_Command>
	}
}
    7af4:	df 91       	pop	r29
    7af6:	cf 91       	pop	r28
    7af8:	1f 91       	pop	r17
    7afa:	0f 91       	pop	r16
    7afc:	ff 90       	pop	r15
    7afe:	08 95       	ret

00007b00 <OneWireReadTemp>:
// ~~~~~~~~~~~~~
void OneWireReadTemp(const uint8_t CH){
    7b00:	8f 92       	push	r8
    7b02:	9f 92       	push	r9
    7b04:	af 92       	push	r10
    7b06:	bf 92       	push	r11
    7b08:	cf 92       	push	r12
    7b0a:	df 92       	push	r13
    7b0c:	ef 92       	push	r14
    7b0e:	ff 92       	push	r15
    7b10:	1f 93       	push	r17
    7b12:	cf 93       	push	r28
    7b14:	df 93       	push	r29
    7b16:	18 2f       	mov	r17, r24
			Read_DHT22(CH);
			return;
		}
	#endif
	
	if(erb(&ThermType[CH]) == ThermOff){
    7b18:	c8 2f       	mov	r28, r24
    7b1a:	d0 e0       	ldi	r29, 0x00	; 0
    7b1c:	ce 01       	movw	r24, r28
    7b1e:	83 5a       	subi	r24, 0xA3	; 163
    7b20:	9f 4f       	sbci	r25, 0xFF	; 255
    7b22:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    7b26:	9e 01       	movw	r18, r28
    7b28:	2d 50       	subi	r18, 0x0D	; 13
    7b2a:	36 4f       	sbci	r19, 0xF6	; 246
    7b2c:	79 01       	movw	r14, r18
    7b2e:	fe 01       	movw	r30, r28
    7b30:	e9 50       	subi	r30, 0x09	; 9
    7b32:	fc 4f       	sbci	r31, 0xFC	; 252
    7b34:	81 11       	cpse	r24, r1
    7b36:	0c c0       	rjmp	.+24     	; 0x7b50 <OneWireReadTemp+0x50>
		Temperature[CH] = Therm_Off_Mark;
    7b38:	cc 0f       	add	r28, r28
    7b3a:	dd 1f       	adc	r29, r29
    7b3c:	ce 50       	subi	r28, 0x0E	; 14
    7b3e:	da 4f       	sbci	r29, 0xFA	; 250
    7b40:	80 e0       	ldi	r24, 0x00	; 0
    7b42:	90 e8       	ldi	r25, 0x80	; 128
    7b44:	99 83       	std	Y+1, r25	; 0x01
    7b46:	88 83       	st	Y, r24
		DS18B20_Status[CH] = DS18B20_INIT;
    7b48:	d7 01       	movw	r26, r14
    7b4a:	1c 92       	st	X, r1
		DS18B20_Error[CH]=0;
    7b4c:	10 82       	st	Z, r1
		return;
    7b4e:	a0 c0       	rjmp	.+320    	; 0x7c90 <OneWireReadTemp+0x190>
	}
		
	if(DS18B20_Status[CH] == DS18B20_ERROR){
    7b50:	d9 01       	movw	r26, r18
    7b52:	8c 91       	ld	r24, X
    7b54:	82 30       	cpi	r24, 0x02	; 2
    7b56:	79 f4       	brne	.+30     	; 0x7b76 <OneWireReadTemp+0x76>
		if(DS18B20_Error[CH] > 9) Temperature[CH] = ADC_Off_Mark;
    7b58:	80 81       	ld	r24, Z
    7b5a:	8a 30       	cpi	r24, 0x0A	; 10
    7b5c:	48 f0       	brcs	.+18     	; 0x7b70 <OneWireReadTemp+0x70>
    7b5e:	cc 0f       	add	r28, r28
    7b60:	dd 1f       	adc	r29, r29
    7b62:	ce 50       	subi	r28, 0x0E	; 14
    7b64:	da 4f       	sbci	r29, 0xFA	; 250
    7b66:	81 e0       	ldi	r24, 0x01	; 1
    7b68:	90 e8       	ldi	r25, 0x80	; 128
    7b6a:	99 83       	std	Y+1, r25	; 0x01
    7b6c:	88 83       	st	Y, r24
    7b6e:	90 c0       	rjmp	.+288    	; 0x7c90 <OneWireReadTemp+0x190>
		else DS18B20_Error[CH]++;
    7b70:	8f 5f       	subi	r24, 0xFF	; 255
    7b72:	80 83       	st	Z, r24
    7b74:	8d c0       	rjmp	.+282    	; 0x7c90 <OneWireReadTemp+0x190>
		return;
	}
	else{
		DS18B20_Error[CH]=0;
    7b76:	10 82       	st	Z, r1
	}

	//MASTER TX RESET PULSE 480s minimum
	cli(); OW_MasterPullLowBus(CH); sei();
    7b78:	f8 94       	cli
    7b7a:	81 2f       	mov	r24, r17
    7b7c:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <OW_MasterPullLowBus>
    7b80:	78 94       	sei
	Delay_us(580);
    7b82:	84 e4       	ldi	r24, 0x44	; 68
    7b84:	92 e0       	ldi	r25, 0x02	; 2
    7b86:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>
	cli(); OW_MasterReleaseBus(CH); 
    7b8a:	f8 94       	cli
    7b8c:	81 2f       	mov	r24, r17
    7b8e:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>

	//MASTER RX presence pulse 480s minimum
	Delay_us(70);	//SLAVE waits
    7b92:	86 e4       	ldi	r24, 0x46	; 70
    7b94:	90 e0       	ldi	r25, 0x00	; 0
    7b96:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>
    7b9a:	80 91 63 00 	lds	r24, 0x0063
	if(OW_MasterReadBus(CH)!=0) DS18B20_Status[CH] = DS18B20_ERROR;
    7b9e:	80 ff       	sbrs	r24, 0
    7ba0:	03 c0       	rjmp	.+6      	; 0x7ba8 <OneWireReadTemp+0xa8>
    7ba2:	82 e0       	ldi	r24, 0x02	; 2
    7ba4:	f7 01       	movw	r30, r14
    7ba6:	80 83       	st	Z, r24
	sei();
    7ba8:	78 94       	sei
	Delay_us(510);
    7baa:	8e ef       	ldi	r24, 0xFE	; 254
    7bac:	91 e0       	ldi	r25, 0x01	; 1
    7bae:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>

	if(DS18B20_Status[CH] != DS18B20_ERROR){
    7bb2:	d7 01       	movw	r26, r14
    7bb4:	8c 91       	ld	r24, X
    7bb6:	82 30       	cpi	r24, 0x02	; 2
    7bb8:	09 f4       	brne	.+2      	; 0x7bbc <OneWireReadTemp+0xbc>
    7bba:	6a c0       	rjmp	.+212    	; 0x7c90 <OneWireReadTemp+0x190>
		OW_MasterTx_Command(CH,0xCC);	// SKIP ROM Command
    7bbc:	6c ec       	ldi	r22, 0xCC	; 204
    7bbe:	81 2f       	mov	r24, r17
    7bc0:	0e 94 a5 3c 	call	0x794a	; 0x794a <OW_MasterTx_Command>
		OW_MasterTx_Command(CH,0xBE);	// READ SCRATCHPAD
    7bc4:	6e eb       	ldi	r22, 0xBE	; 190
    7bc6:	81 2f       	mov	r24, r17
    7bc8:	0e 94 a5 3c 	call	0x794a	; 0x794a <OW_MasterTx_Command>
		int16_t Tres;
		Tres = (int16_t)OW_MasterRx_Data(CH);
    7bcc:	81 2f       	mov	r24, r17
    7bce:	0e 94 e0 3c 	call	0x79c0	; 0x79c0 <OW_MasterRx_Data>
    7bd2:	e8 2e       	mov	r14, r24
    7bd4:	f1 2c       	mov	r15, r1
		Tres |= ((int16_t)OW_MasterRx_Data(CH)<<8);
    7bd6:	81 2f       	mov	r24, r17
    7bd8:	0e 94 e0 3c 	call	0x79c0	; 0x79c0 <OW_MasterRx_Data>
    7bdc:	f8 2a       	or	r15, r24
		Tres = (Tres*10)/16;
    7bde:	8a e0       	ldi	r24, 0x0A	; 10
    7be0:	8e 9d       	mul	r24, r14
    7be2:	b0 01       	movw	r22, r0
    7be4:	8f 9d       	mul	r24, r15
    7be6:	70 0d       	add	r23, r0
    7be8:	11 24       	eor	r1, r1
    7bea:	77 ff       	sbrs	r23, 7
    7bec:	02 c0       	rjmp	.+4      	; 0x7bf2 <OneWireReadTemp+0xf2>
    7bee:	61 5f       	subi	r22, 0xF1	; 241
    7bf0:	7f 4f       	sbci	r23, 0xFF	; 255
    7bf2:	4b 01       	movw	r8, r22
    7bf4:	94 e0       	ldi	r25, 0x04	; 4
    7bf6:	95 94       	asr	r9
    7bf8:	87 94       	ror	r8
    7bfa:	9a 95       	dec	r25
    7bfc:	e1 f7       	brne	.-8      	; 0x7bf6 <OneWireReadTemp+0xf6>
		if(Tres != 850)	//DS18B20 power up value = 85.0C
    7bfe:	b2 e5       	ldi	r27, 0x52	; 82
    7c00:	8b 16       	cp	r8, r27
    7c02:	b3 e0       	ldi	r27, 0x03	; 3
    7c04:	9b 06       	cpc	r9, r27
    7c06:	b1 f1       	breq	.+108    	; 0x7c74 <OneWireReadTemp+0x174>
			Temperature[CH] = (Tres+(int8_t)erb(&ThermCorr[CH].D))*(erw(&ThermCorr[CH].A)/1000.0);
    7c08:	7e 01       	movw	r14, r28
    7c0a:	ee 0c       	add	r14, r14
    7c0c:	ff 1c       	adc	r15, r15
    7c0e:	ce 0d       	add	r28, r14
    7c10:	df 1d       	adc	r29, r15
    7c12:	ce 01       	movw	r24, r28
    7c14:	86 5a       	subi	r24, 0xA6	; 166
    7c16:	9f 4f       	sbci	r25, 0xFF	; 255
    7c18:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    7c1c:	d8 2e       	mov	r13, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    7c1e:	ce 01       	movw	r24, r28
    7c20:	85 5a       	subi	r24, 0xA5	; 165
    7c22:	9f 4f       	sbci	r25, 0xFF	; 255
    7c24:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    7c28:	5c 01       	movw	r10, r24
    7c2a:	e7 01       	movw	r28, r14
    7c2c:	ce 50       	subi	r28, 0x0E	; 14
    7c2e:	da 4f       	sbci	r29, 0xFA	; 250
    7c30:	b4 01       	movw	r22, r8
    7c32:	6d 0d       	add	r22, r13
    7c34:	71 1d       	adc	r23, r1
    7c36:	d7 fc       	sbrc	r13, 7
    7c38:	7a 95       	dec	r23
    7c3a:	88 27       	eor	r24, r24
    7c3c:	77 fd       	sbrc	r23, 7
    7c3e:	80 95       	com	r24
    7c40:	98 2f       	mov	r25, r24
    7c42:	0e 94 2c 6e 	call	0xdc58	; 0xdc58 <__floatsisf>
    7c46:	6b 01       	movw	r12, r22
    7c48:	7c 01       	movw	r14, r24
    7c4a:	b5 01       	movw	r22, r10
    7c4c:	80 e0       	ldi	r24, 0x00	; 0
    7c4e:	90 e0       	ldi	r25, 0x00	; 0
    7c50:	0e 94 2a 6e 	call	0xdc54	; 0xdc54 <__floatunsisf>
    7c54:	20 e0       	ldi	r18, 0x00	; 0
    7c56:	30 e0       	ldi	r19, 0x00	; 0
    7c58:	4a e7       	ldi	r20, 0x7A	; 122
    7c5a:	54 e4       	ldi	r21, 0x44	; 68
    7c5c:	0e 94 91 6d 	call	0xdb22	; 0xdb22 <__divsf3>
    7c60:	9b 01       	movw	r18, r22
    7c62:	ac 01       	movw	r20, r24
    7c64:	c7 01       	movw	r24, r14
    7c66:	b6 01       	movw	r22, r12
    7c68:	0e 94 b8 6e 	call	0xdd70	; 0xdd70 <__mulsf3>
    7c6c:	0e 94 f9 6d 	call	0xdbf2	; 0xdbf2 <__fixsfsi>
    7c70:	79 83       	std	Y+1, r23	; 0x01
    7c72:	68 83       	st	Y, r22

		//MASTER TX RESET PULSE 480s minimum
		cli(); OW_MasterPullLowBus(CH); sei();
    7c74:	f8 94       	cli
    7c76:	81 2f       	mov	r24, r17
    7c78:	0e 94 b8 2e 	call	0x5d70	; 0x5d70 <OW_MasterPullLowBus>
    7c7c:	78 94       	sei
		Delay_us(580);	
    7c7e:	84 e4       	ldi	r24, 0x44	; 68
    7c80:	92 e0       	ldi	r25, 0x02	; 2
    7c82:	0e 94 9d 2e 	call	0x5d3a	; 0x5d3a <Delay_us>
		cli(); OW_MasterReleaseBus(CH); sei();
    7c86:	f8 94       	cli
    7c88:	81 2f       	mov	r24, r17
    7c8a:	0e 94 c5 2e 	call	0x5d8a	; 0x5d8a <OW_MasterReleaseBus>
    7c8e:	78 94       	sei

		//if( OW_Temperature[CH]>300 || OW_Temperature[CH]<150 ) DS18B20_Error[CH]++;
	}
}
    7c90:	df 91       	pop	r29
    7c92:	cf 91       	pop	r28
    7c94:	1f 91       	pop	r17
    7c96:	ff 90       	pop	r15
    7c98:	ef 90       	pop	r14
    7c9a:	df 90       	pop	r13
    7c9c:	cf 90       	pop	r12
    7c9e:	bf 90       	pop	r11
    7ca0:	af 90       	pop	r10
    7ca2:	9f 90       	pop	r9
    7ca4:	8f 90       	pop	r8
    7ca6:	08 95       	ret

00007ca8 <DS18B20>:
// ~~~~~~~~~~~~~
#if TerReg == 1
	void DS18B20(void){
		if(Timer8Stopp(TD_DS18B20Read)){
    7ca8:	80 91 6b 09 	lds	r24, 0x096B
    7cac:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    7cb0:	88 23       	and	r24, r24
    7cb2:	11 f1       	breq	.+68     	; 0x7cf8 <DS18B20+0x50>
			if(DS18B20_Mode >= DS18B20_END_CYCLE) DS18B20_Mode = DS18B20_START_ADC1;
    7cb4:	80 91 56 02 	lds	r24, 0x0256
    7cb8:	87 30       	cpi	r24, 0x07	; 7
    7cba:	18 f0       	brcs	.+6      	; 0x7cc2 <DS18B20+0x1a>
    7cbc:	81 e0       	ldi	r24, 0x01	; 1
    7cbe:	80 93 56 02 	sts	0x0256, r24
		
			switch(DS18B20_Mode){
    7cc2:	80 91 56 02 	lds	r24, 0x0256
    7cc6:	81 30       	cpi	r24, 0x01	; 1
    7cc8:	39 f0       	breq	.+14     	; 0x7cd8 <DS18B20+0x30>
    7cca:	84 30       	cpi	r24, 0x04	; 4
    7ccc:	81 f4       	brne	.+32     	; 0x7cee <DS18B20+0x46>
				StartTimer8(TD_DS18B20Read, 100);
				DS18B20_Mode = DS18B20_START_ADC3;
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
    7cce:	80 e0       	ldi	r24, 0x00	; 0
    7cd0:	0e 94 80 3d 	call	0x7b00	; 0x7b00 <OneWireReadTemp>
				DS18B20_Mode = DS18B20_READ_T3;
    7cd4:	86 e0       	ldi	r24, 0x06	; 6
    7cd6:	09 c0       	rjmp	.+18     	; 0x7cea <DS18B20+0x42>
			switch(DS18B20_Mode){
			case DS18B20_INITIAL:
				break;

			case DS18B20_START_ADC1:
				OneWireStartADC(0);	// 2.9
    7cd8:	80 e0       	ldi	r24, 0x00	; 0
    7cda:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OneWireStartADC>
				StartTimer8(TD_DS18B20Read, 100);
    7cde:	64 e6       	ldi	r22, 0x64	; 100
    7ce0:	80 91 6b 09 	lds	r24, 0x096B
    7ce4:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
				DS18B20_Mode = DS18B20_START_ADC3;
    7ce8:	83 e0       	ldi	r24, 0x03	; 3
				break;

			case DS18B20_READ_T1:
				OneWireReadTemp(0);	// 4.6
				DS18B20_Mode = DS18B20_READ_T3;
    7cea:	80 93 56 02 	sts	0x0256, r24
				break;
			}
			DS18B20_Mode++;
    7cee:	80 91 56 02 	lds	r24, 0x0256
    7cf2:	8f 5f       	subi	r24, 0xFF	; 255
    7cf4:	80 93 56 02 	sts	0x0256, r24
    7cf8:	08 95       	ret

00007cfa <PutEnum>:
		Func();
}
// ~~~~~~~~~~~~~~~~~~~~
void
PutEnum(T_Param *Param)
{
    7cfa:	cf 93       	push	r28
    7cfc:	df 93       	push	r29
    7cfe:	ec 01       	movw	r28, r24

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    7d00:	ec 81       	ldd	r30, Y+4	; 0x04
    7d02:	fd 81       	ldd	r31, Y+5	; 0x05
    7d04:	65 91       	lpm	r22, Z+
    7d06:	74 91       	lpm	r23, Z
	strcpy_P(Param->Pos, prp(Param->Txt));
    7d08:	88 81       	ld	r24, Y
    7d0a:	99 81       	ldd	r25, Y+1	; 0x01
    7d0c:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
	for(uint8_t i=strlen(Param->Pos); i<Param->Size; *(Param->Pos+i++)=' ');
    7d10:	a8 81       	ld	r26, Y
    7d12:	b9 81       	ldd	r27, Y+1	; 0x01
    7d14:	fd 01       	movw	r30, r26
    7d16:	01 90       	ld	r0, Z+
    7d18:	00 20       	and	r0, r0
    7d1a:	e9 f7       	brne	.-6      	; 0x7d16 <PutEnum+0x1c>
    7d1c:	31 97       	sbiw	r30, 0x01	; 1
    7d1e:	4e 2f       	mov	r20, r30
    7d20:	4a 1b       	sub	r20, r26
    7d22:	80 e0       	ldi	r24, 0x00	; 0
    7d24:	90 e0       	ldi	r25, 0x00	; 0
    7d26:	50 e2       	ldi	r21, 0x20	; 32
    7d28:	24 2f       	mov	r18, r20
    7d2a:	28 0f       	add	r18, r24
    7d2c:	01 96       	adiw	r24, 0x01	; 1
    7d2e:	3b 81       	ldd	r19, Y+3	; 0x03
    7d30:	23 17       	cp	r18, r19
    7d32:	30 f4       	brcc	.+12     	; 0x7d40 <PutEnum+0x46>
    7d34:	e8 81       	ld	r30, Y
    7d36:	f9 81       	ldd	r31, Y+1	; 0x01
    7d38:	e2 0f       	add	r30, r18
    7d3a:	f1 1d       	adc	r31, r1
    7d3c:	50 83       	st	Z, r21
    7d3e:	f4 cf       	rjmp	.-24     	; 0x7d28 <PutEnum+0x2e>
}
    7d40:	df 91       	pop	r29
    7d42:	cf 91       	pop	r28
    7d44:	08 95       	ret

00007d46 <PutVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutVal(uint16_t Val, char Type, T_Param *Param)
{
    7d46:	cf 92       	push	r12
    7d48:	df 92       	push	r13
    7d4a:	ef 92       	push	r14
    7d4c:	ff 92       	push	r15
    7d4e:	0f 93       	push	r16
    7d50:	1f 93       	push	r17
    7d52:	cf 93       	push	r28
    7d54:	df 93       	push	r29
    7d56:	cd b7       	in	r28, 0x3d	; 61
    7d58:	de b7       	in	r29, 0x3e	; 62
    7d5a:	29 97       	sbiw	r28, 0x09	; 9
    7d5c:	0f b6       	in	r0, 0x3f	; 63
    7d5e:	f8 94       	cli
    7d60:	de bf       	out	0x3e, r29	; 62
    7d62:	0f be       	out	0x3f, r0	; 63
    7d64:	cd bf       	out	0x3d, r28	; 61
    7d66:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7d68:	67 37       	cpi	r22, 0x77	; 119
    7d6a:	19 f4       	brne	.+6      	; 0x7d72 <PutVal+0x2c>
    7d6c:	8f ef       	ldi	r24, 0xFF	; 255
    7d6e:	9f ef       	ldi	r25, 0xFF	; 255
    7d70:	02 c0       	rjmp	.+4      	; 0x7d76 <PutVal+0x30>
    7d72:	8f ef       	ldi	r24, 0xFF	; 255
    7d74:	90 e0       	ldi	r25, 0x00	; 0
    7d76:	8e 19       	sub	r24, r14
    7d78:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7d7a:	fa 01       	movw	r30, r20
    7d7c:	24 81       	ldd	r18, Z+4	; 0x04
    7d7e:	35 81       	ldd	r19, Z+5	; 0x05
    7d80:	21 15       	cp	r18, r1
    7d82:	31 05       	cpc	r19, r1
    7d84:	69 f0       	breq	.+26     	; 0x7da0 <PutVal+0x5a>
    7d86:	82 30       	cpi	r24, 0x02	; 2
    7d88:	91 05       	cpc	r25, r1
    7d8a:	50 f4       	brcc	.+20     	; 0x7da0 <PutVal+0x5a>
		Param->Txt += Idx;
    7d8c:	88 0f       	add	r24, r24
    7d8e:	99 1f       	adc	r25, r25
    7d90:	82 0f       	add	r24, r18
    7d92:	93 1f       	adc	r25, r19
    7d94:	95 83       	std	Z+5, r25	; 0x05
    7d96:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7d98:	ca 01       	movw	r24, r20
    7d9a:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
    7d9e:	3f c0       	rjmp	.+126    	; 0x7e1e <PutVal+0xd8>
		return;
	}
	char Format[] = "% u.%. u";
    7da0:	89 e0       	ldi	r24, 0x09	; 9
    7da2:	e3 e1       	ldi	r30, 0x13	; 19
    7da4:	f1 e0       	ldi	r31, 0x01	; 1
    7da6:	8e 01       	movw	r16, r28
    7da8:	0f 5f       	subi	r16, 0xFF	; 255
    7daa:	1f 4f       	sbci	r17, 0xFF	; 255
    7dac:	d8 01       	movw	r26, r16
    7dae:	01 90       	ld	r0, Z+
    7db0:	0d 92       	st	X+, r0
    7db2:	8a 95       	dec	r24
    7db4:	e1 f7       	brne	.-8      	; 0x7dae <PutVal+0x68>
	Format[1] = '0'+Param->Size;
    7db6:	fa 01       	movw	r30, r20
    7db8:	93 81       	ldd	r25, Z+3	; 0x03
    7dba:	90 5d       	subi	r25, 0xD0	; 208
    7dbc:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    7dbe:	82 81       	ldd	r24, Z+2	; 0x02
    7dc0:	c1 80       	ldd	r12, Z+1	; 0x01
    7dc2:	d0 80       	ld	r13, Z
    7dc4:	88 23       	and	r24, r24
    7dc6:	e1 f0       	breq	.+56     	; 0x7e00 <PutVal+0xba>
		Format[1] -= Param->Prec+1;
    7dc8:	98 1b       	sub	r25, r24
    7dca:	91 50       	subi	r25, 0x01	; 1
    7dcc:	9a 83       	std	Y+2, r25	; 0x02
		Format[6] = '0'+Param->Prec;
    7dce:	90 e3       	ldi	r25, 0x30	; 48
    7dd0:	98 0f       	add	r25, r24
    7dd2:	9f 83       	std	Y+7, r25	; 0x07
		uint16_t Div=Pow10(Param->Prec);
    7dd4:	0e 94 88 3c 	call	0x7910	; 0x7910 <Pow10>
    7dd8:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    7dda:	c7 01       	movw	r24, r14
    7ddc:	0e 94 46 75 	call	0xea8c	; 0xea8c <__udivmodhi4>
    7de0:	9f 93       	push	r25
    7de2:	8f 93       	push	r24
    7de4:	7f 93       	push	r23
    7de6:	6f 93       	push	r22
    7de8:	1f 93       	push	r17
    7dea:	0f 93       	push	r16
    7dec:	cf 92       	push	r12
    7dee:	df 92       	push	r13
    7df0:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    7df4:	0f b6       	in	r0, 0x3f	; 63
    7df6:	f8 94       	cli
    7df8:	de bf       	out	0x3e, r29	; 62
    7dfa:	0f be       	out	0x3f, r0	; 63
    7dfc:	cd bf       	out	0x3d, r28	; 61
    7dfe:	0f c0       	rjmp	.+30     	; 0x7e1e <PutVal+0xd8>
	}
	else {
		Format[3] = '\0';
    7e00:	1c 82       	std	Y+4, r1	; 0x04
		sprintf(Param->Pos, Format, Val);
    7e02:	ff 92       	push	r15
    7e04:	ef 92       	push	r14
    7e06:	1f 93       	push	r17
    7e08:	0f 93       	push	r16
    7e0a:	cf 92       	push	r12
    7e0c:	df 92       	push	r13
    7e0e:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    7e12:	0f 90       	pop	r0
    7e14:	0f 90       	pop	r0
    7e16:	0f 90       	pop	r0
    7e18:	0f 90       	pop	r0
    7e1a:	0f 90       	pop	r0
    7e1c:	0f 90       	pop	r0
	}
}
    7e1e:	29 96       	adiw	r28, 0x09	; 9
    7e20:	0f b6       	in	r0, 0x3f	; 63
    7e22:	f8 94       	cli
    7e24:	de bf       	out	0x3e, r29	; 62
    7e26:	0f be       	out	0x3f, r0	; 63
    7e28:	cd bf       	out	0x3d, r28	; 61
    7e2a:	df 91       	pop	r29
    7e2c:	cf 91       	pop	r28
    7e2e:	1f 91       	pop	r17
    7e30:	0f 91       	pop	r16
    7e32:	ff 90       	pop	r15
    7e34:	ef 90       	pop	r14
    7e36:	df 90       	pop	r13
    7e38:	cf 90       	pop	r12
    7e3a:	08 95       	ret

00007e3c <Put_sVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sVal(int16_t Val, char Type, T_Param *Param)
{
    7e3c:	af 92       	push	r10
    7e3e:	bf 92       	push	r11
    7e40:	cf 92       	push	r12
    7e42:	df 92       	push	r13
    7e44:	ef 92       	push	r14
    7e46:	ff 92       	push	r15
    7e48:	0f 93       	push	r16
    7e4a:	1f 93       	push	r17
    7e4c:	cf 93       	push	r28
    7e4e:	df 93       	push	r29
    7e50:	cd b7       	in	r28, 0x3d	; 61
    7e52:	de b7       	in	r29, 0x3e	; 62
    7e54:	2a 97       	sbiw	r28, 0x0a	; 10
    7e56:	0f b6       	in	r0, 0x3f	; 63
    7e58:	f8 94       	cli
    7e5a:	de bf       	out	0x3e, r29	; 62
    7e5c:	0f be       	out	0x3f, r0	; 63
    7e5e:	cd bf       	out	0x3d, r28	; 61
    7e60:	7c 01       	movw	r14, r24
    7e62:	8a 01       	movw	r16, r20
	uint16_t Idx = (Type=='w'?0x8000:0x80)+Val;
    7e64:	67 37       	cpi	r22, 0x77	; 119
    7e66:	19 f4       	brne	.+6      	; 0x7e6e <Put_sVal+0x32>
    7e68:	80 e0       	ldi	r24, 0x00	; 0
    7e6a:	90 e8       	ldi	r25, 0x80	; 128
    7e6c:	02 c0       	rjmp	.+4      	; 0x7e72 <Put_sVal+0x36>
    7e6e:	80 e8       	ldi	r24, 0x80	; 128
    7e70:	90 e0       	ldi	r25, 0x00	; 0
    7e72:	8e 0d       	add	r24, r14
    7e74:	9f 1d       	adc	r25, r15
	if(Param->Txt && Idx<2) {
    7e76:	d8 01       	movw	r26, r16
    7e78:	14 96       	adiw	r26, 0x04	; 4
    7e7a:	2d 91       	ld	r18, X+
    7e7c:	3c 91       	ld	r19, X
    7e7e:	15 97       	sbiw	r26, 0x05	; 5
    7e80:	21 15       	cp	r18, r1
    7e82:	31 05       	cpc	r19, r1
    7e84:	79 f0       	breq	.+30     	; 0x7ea4 <Put_sVal+0x68>
    7e86:	82 30       	cpi	r24, 0x02	; 2
    7e88:	91 05       	cpc	r25, r1
    7e8a:	60 f4       	brcc	.+24     	; 0x7ea4 <Put_sVal+0x68>
		Param->Txt += Idx;
    7e8c:	88 0f       	add	r24, r24
    7e8e:	99 1f       	adc	r25, r25
    7e90:	82 0f       	add	r24, r18
    7e92:	93 1f       	adc	r25, r19
    7e94:	15 96       	adiw	r26, 0x05	; 5
    7e96:	9c 93       	st	X, r25
    7e98:	8e 93       	st	-X, r24
    7e9a:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    7e9c:	c8 01       	movw	r24, r16
    7e9e:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
    7ea2:	65 c0       	rjmp	.+202    	; 0x7f6e <Put_sVal+0x132>
		return;
	}
	char Format[] = "%+ d.%. u";
    7ea4:	8a e0       	ldi	r24, 0x0A	; 10
    7ea6:	ec e1       	ldi	r30, 0x1C	; 28
    7ea8:	f1 e0       	ldi	r31, 0x01	; 1
    7eaa:	9e 01       	movw	r18, r28
    7eac:	2f 5f       	subi	r18, 0xFF	; 255
    7eae:	3f 4f       	sbci	r19, 0xFF	; 255
    7eb0:	69 01       	movw	r12, r18
    7eb2:	d9 01       	movw	r26, r18
    7eb4:	01 90       	ld	r0, Z+
    7eb6:	0d 92       	st	X+, r0
    7eb8:	8a 95       	dec	r24
    7eba:	e1 f7       	brne	.-8      	; 0x7eb4 <Put_sVal+0x78>
	if(Val==0)
    7ebc:	e1 14       	cp	r14, r1
    7ebe:	f1 04       	cpc	r15, r1
    7ec0:	11 f4       	brne	.+4      	; 0x7ec6 <Put_sVal+0x8a>
		Format[1] = ' ';
    7ec2:	80 e2       	ldi	r24, 0x20	; 32
    7ec4:	8a 83       	std	Y+2, r24	; 0x02
	Format[2] = '0'+Param->Size;
    7ec6:	d8 01       	movw	r26, r16
    7ec8:	13 96       	adiw	r26, 0x03	; 3
    7eca:	9c 91       	ld	r25, X
    7ecc:	13 97       	sbiw	r26, 0x03	; 3
    7ece:	90 5d       	subi	r25, 0xD0	; 208
    7ed0:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    7ed2:	12 96       	adiw	r26, 0x02	; 2
    7ed4:	8c 91       	ld	r24, X
    7ed6:	12 97       	sbiw	r26, 0x02	; 2
    7ed8:	11 96       	adiw	r26, 0x01	; 1
    7eda:	ac 90       	ld	r10, X
    7edc:	11 97       	sbiw	r26, 0x01	; 1
    7ede:	bc 90       	ld	r11, X
    7ee0:	88 23       	and	r24, r24
    7ee2:	b1 f1       	breq	.+108    	; 0x7f50 <Put_sVal+0x114>
		Format[2] -= Param->Prec+1;
    7ee4:	98 1b       	sub	r25, r24
    7ee6:	91 50       	subi	r25, 0x01	; 1
    7ee8:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    7eea:	90 e3       	ldi	r25, 0x30	; 48
    7eec:	98 0f       	add	r25, r24
    7eee:	98 87       	std	Y+8, r25	; 0x08
		int16_t Div=Pow10(Param->Prec);
    7ef0:	0e 94 88 3c 	call	0x7910	; 0x7910 <Pow10>
    7ef4:	9c 01       	movw	r18, r24
		sprintf(Param->Pos, Format, Val/Div, (uint16_t)abs(Val)%Div);
    7ef6:	c7 01       	movw	r24, r14
    7ef8:	f7 fe       	sbrs	r15, 7
    7efa:	04 c0       	rjmp	.+8      	; 0x7f04 <Put_sVal+0xc8>
    7efc:	88 27       	eor	r24, r24
    7efe:	99 27       	eor	r25, r25
    7f00:	8e 19       	sub	r24, r14
    7f02:	9f 09       	sbc	r25, r15
    7f04:	b9 01       	movw	r22, r18
    7f06:	0e 94 46 75 	call	0xea8c	; 0xea8c <__udivmodhi4>
    7f0a:	9f 93       	push	r25
    7f0c:	8f 93       	push	r24
    7f0e:	c7 01       	movw	r24, r14
    7f10:	b9 01       	movw	r22, r18
    7f12:	0e 94 5a 75 	call	0xeab4	; 0xeab4 <__divmodhi4>
    7f16:	7f 93       	push	r23
    7f18:	6f 93       	push	r22
    7f1a:	df 92       	push	r13
    7f1c:	cf 92       	push	r12
    7f1e:	af 92       	push	r10
    7f20:	bf 92       	push	r11
    7f22:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
		if(Val<0) {
    7f26:	0f b6       	in	r0, 0x3f	; 63
    7f28:	f8 94       	cli
    7f2a:	de bf       	out	0x3e, r29	; 62
    7f2c:	0f be       	out	0x3f, r0	; 63
    7f2e:	cd bf       	out	0x3d, r28	; 61
    7f30:	f7 fe       	sbrs	r15, 7
    7f32:	1d c0       	rjmp	.+58     	; 0x7f6e <Put_sVal+0x132>
			while(*Param->Pos==' ')
    7f34:	d8 01       	movw	r26, r16
    7f36:	ed 91       	ld	r30, X+
    7f38:	fc 91       	ld	r31, X
    7f3a:	80 81       	ld	r24, Z
    7f3c:	80 32       	cpi	r24, 0x20	; 32
    7f3e:	29 f4       	brne	.+10     	; 0x7f4a <Put_sVal+0x10e>
				Param->Pos++;
    7f40:	31 96       	adiw	r30, 0x01	; 1
    7f42:	d8 01       	movw	r26, r16
    7f44:	ed 93       	st	X+, r30
    7f46:	fc 93       	st	X, r31
    7f48:	f5 cf       	rjmp	.-22     	; 0x7f34 <Put_sVal+0xf8>
			*Param->Pos = '-';
    7f4a:	8d e2       	ldi	r24, 0x2D	; 45
    7f4c:	80 83       	st	Z, r24
    7f4e:	0f c0       	rjmp	.+30     	; 0x7f6e <Put_sVal+0x132>
		}
	}
	else {
		Format[4] = '\0';
    7f50:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    7f52:	ff 92       	push	r15
    7f54:	ef 92       	push	r14
    7f56:	df 92       	push	r13
    7f58:	cf 92       	push	r12
    7f5a:	af 92       	push	r10
    7f5c:	bf 92       	push	r11
    7f5e:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    7f62:	0f 90       	pop	r0
    7f64:	0f 90       	pop	r0
    7f66:	0f 90       	pop	r0
    7f68:	0f 90       	pop	r0
    7f6a:	0f 90       	pop	r0
    7f6c:	0f 90       	pop	r0
	}
}
    7f6e:	2a 96       	adiw	r28, 0x0a	; 10
    7f70:	0f b6       	in	r0, 0x3f	; 63
    7f72:	f8 94       	cli
    7f74:	de bf       	out	0x3e, r29	; 62
    7f76:	0f be       	out	0x3f, r0	; 63
    7f78:	cd bf       	out	0x3d, r28	; 61
    7f7a:	df 91       	pop	r29
    7f7c:	cf 91       	pop	r28
    7f7e:	1f 91       	pop	r17
    7f80:	0f 91       	pop	r16
    7f82:	ff 90       	pop	r15
    7f84:	ef 90       	pop	r14
    7f86:	df 90       	pop	r13
    7f88:	cf 90       	pop	r12
    7f8a:	bf 90       	pop	r11
    7f8c:	af 90       	pop	r10
    7f8e:	08 95       	ret

00007f90 <Put_zVal>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal(uint16_t Val, char Type, T_Param *Param)
{
    7f90:	cf 92       	push	r12
    7f92:	df 92       	push	r13
    7f94:	ef 92       	push	r14
    7f96:	ff 92       	push	r15
    7f98:	0f 93       	push	r16
    7f9a:	1f 93       	push	r17
    7f9c:	cf 93       	push	r28
    7f9e:	df 93       	push	r29
    7fa0:	cd b7       	in	r28, 0x3d	; 61
    7fa2:	de b7       	in	r29, 0x3e	; 62
    7fa4:	2a 97       	sbiw	r28, 0x0a	; 10
    7fa6:	0f b6       	in	r0, 0x3f	; 63
    7fa8:	f8 94       	cli
    7faa:	de bf       	out	0x3e, r29	; 62
    7fac:	0f be       	out	0x3f, r0	; 63
    7fae:	cd bf       	out	0x3d, r28	; 61
    7fb0:	7c 01       	movw	r14, r24
	uint16_t Idx = (Type=='w'?0xFFFF:0xFF)-Val;
    7fb2:	67 37       	cpi	r22, 0x77	; 119
    7fb4:	19 f4       	brne	.+6      	; 0x7fbc <Put_zVal+0x2c>
    7fb6:	8f ef       	ldi	r24, 0xFF	; 255
    7fb8:	9f ef       	ldi	r25, 0xFF	; 255
    7fba:	02 c0       	rjmp	.+4      	; 0x7fc0 <Put_zVal+0x30>
    7fbc:	8f ef       	ldi	r24, 0xFF	; 255
    7fbe:	90 e0       	ldi	r25, 0x00	; 0
    7fc0:	8e 19       	sub	r24, r14
    7fc2:	9f 09       	sbc	r25, r15
	if(Param->Txt && Idx<2) {
    7fc4:	fa 01       	movw	r30, r20
    7fc6:	24 81       	ldd	r18, Z+4	; 0x04
    7fc8:	35 81       	ldd	r19, Z+5	; 0x05
    7fca:	21 15       	cp	r18, r1
    7fcc:	31 05       	cpc	r19, r1
    7fce:	69 f0       	breq	.+26     	; 0x7fea <Put_zVal+0x5a>
    7fd0:	82 30       	cpi	r24, 0x02	; 2
    7fd2:	91 05       	cpc	r25, r1
    7fd4:	50 f4       	brcc	.+20     	; 0x7fea <Put_zVal+0x5a>
		Param->Txt += Idx;
    7fd6:	88 0f       	add	r24, r24
    7fd8:	99 1f       	adc	r25, r25
    7fda:	82 0f       	add	r24, r18
    7fdc:	93 1f       	adc	r25, r19
    7fde:	95 83       	std	Z+5, r25	; 0x05
    7fe0:	84 83       	std	Z+4, r24	; 0x04
		PutEnum(Param);
    7fe2:	ca 01       	movw	r24, r20
    7fe4:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
    7fe8:	3f c0       	rjmp	.+126    	; 0x8068 <Put_zVal+0xd8>
		return;
	}
	char Format[] = "%0 u.%. u";
    7fea:	8a e0       	ldi	r24, 0x0A	; 10
    7fec:	e6 e2       	ldi	r30, 0x26	; 38
    7fee:	f1 e0       	ldi	r31, 0x01	; 1
    7ff0:	8e 01       	movw	r16, r28
    7ff2:	0f 5f       	subi	r16, 0xFF	; 255
    7ff4:	1f 4f       	sbci	r17, 0xFF	; 255
    7ff6:	d8 01       	movw	r26, r16
    7ff8:	01 90       	ld	r0, Z+
    7ffa:	0d 92       	st	X+, r0
    7ffc:	8a 95       	dec	r24
    7ffe:	e1 f7       	brne	.-8      	; 0x7ff8 <Put_zVal+0x68>
	Format[2] = '0'+Param->Size;
    8000:	fa 01       	movw	r30, r20
    8002:	93 81       	ldd	r25, Z+3	; 0x03
    8004:	90 5d       	subi	r25, 0xD0	; 208
    8006:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    8008:	82 81       	ldd	r24, Z+2	; 0x02
    800a:	c1 80       	ldd	r12, Z+1	; 0x01
    800c:	d0 80       	ld	r13, Z
    800e:	88 23       	and	r24, r24
    8010:	e1 f0       	breq	.+56     	; 0x804a <Put_zVal+0xba>
		Format[2] -= Param->Prec+1;
    8012:	98 1b       	sub	r25, r24
    8014:	91 50       	subi	r25, 0x01	; 1
    8016:	9b 83       	std	Y+3, r25	; 0x03
		Format[7] = '0'+Param->Prec;
    8018:	90 e3       	ldi	r25, 0x30	; 48
    801a:	98 0f       	add	r25, r24
    801c:	98 87       	std	Y+8, r25	; 0x08
		uint16_t Div=Pow10(Param->Prec);
    801e:	0e 94 88 3c 	call	0x7910	; 0x7910 <Pow10>
    8022:	bc 01       	movw	r22, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    8024:	c7 01       	movw	r24, r14
    8026:	0e 94 46 75 	call	0xea8c	; 0xea8c <__udivmodhi4>
    802a:	9f 93       	push	r25
    802c:	8f 93       	push	r24
    802e:	7f 93       	push	r23
    8030:	6f 93       	push	r22
    8032:	1f 93       	push	r17
    8034:	0f 93       	push	r16
    8036:	cf 92       	push	r12
    8038:	df 92       	push	r13
    803a:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    803e:	0f b6       	in	r0, 0x3f	; 63
    8040:	f8 94       	cli
    8042:	de bf       	out	0x3e, r29	; 62
    8044:	0f be       	out	0x3f, r0	; 63
    8046:	cd bf       	out	0x3d, r28	; 61
    8048:	0f c0       	rjmp	.+30     	; 0x8068 <Put_zVal+0xd8>
	}
	else {
		Format[4] = '\0';
    804a:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    804c:	ff 92       	push	r15
    804e:	ef 92       	push	r14
    8050:	1f 93       	push	r17
    8052:	0f 93       	push	r16
    8054:	cf 92       	push	r12
    8056:	df 92       	push	r13
    8058:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    805c:	0f 90       	pop	r0
    805e:	0f 90       	pop	r0
    8060:	0f 90       	pop	r0
    8062:	0f 90       	pop	r0
    8064:	0f 90       	pop	r0
    8066:	0f 90       	pop	r0
	}
}
    8068:	2a 96       	adiw	r28, 0x0a	; 10
    806a:	0f b6       	in	r0, 0x3f	; 63
    806c:	f8 94       	cli
    806e:	de bf       	out	0x3e, r29	; 62
    8070:	0f be       	out	0x3f, r0	; 63
    8072:	cd bf       	out	0x3d, r28	; 61
    8074:	df 91       	pop	r29
    8076:	cf 91       	pop	r28
    8078:	1f 91       	pop	r17
    807a:	0f 91       	pop	r16
    807c:	ff 90       	pop	r15
    807e:	ef 90       	pop	r14
    8080:	df 90       	pop	r13
    8082:	cf 90       	pop	r12
    8084:	08 95       	ret

00008086 <Put_zVal_h>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
    8086:	f9 01       	movw	r30, r18
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
    8088:	42 36       	cpi	r20, 0x62	; 98
    808a:	29 f4       	brne	.+10     	; 0x8096 <Put_zVal_h+0x10>
    808c:	1f 92       	push	r1
    808e:	6f 93       	push	r22
    8090:	80 e3       	ldi	r24, 0x30	; 48
    8092:	91 e0       	ldi	r25, 0x01	; 1
    8094:	06 c0       	rjmp	.+12     	; 0x80a2 <Put_zVal_h+0x1c>
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
    8096:	47 37       	cpi	r20, 0x77	; 119
    8098:	99 f4       	brne	.+38     	; 0x80c0 <Put_zVal_h+0x3a>
    809a:	7f 93       	push	r23
    809c:	6f 93       	push	r22
    809e:	86 e3       	ldi	r24, 0x36	; 54
    80a0:	91 e0       	ldi	r25, 0x01	; 1
    80a2:	9f 93       	push	r25
    80a4:	8f 93       	push	r24
    80a6:	81 81       	ldd	r24, Z+1	; 0x01
    80a8:	8f 93       	push	r24
    80aa:	80 81       	ld	r24, Z
    80ac:	8f 93       	push	r24
    80ae:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    80b2:	0f 90       	pop	r0
    80b4:	0f 90       	pop	r0
    80b6:	0f 90       	pop	r0
    80b8:	0f 90       	pop	r0
    80ba:	0f 90       	pop	r0
    80bc:	0f 90       	pop	r0
    80be:	08 95       	ret
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    80c0:	4c 36       	cpi	r20, 0x6C	; 108
    80c2:	b1 f4       	brne	.+44     	; 0x80f0 <Put_zVal_h+0x6a>
    80c4:	9f 93       	push	r25
    80c6:	8f 93       	push	r24
    80c8:	7f 93       	push	r23
    80ca:	6f 93       	push	r22
    80cc:	8b e3       	ldi	r24, 0x3B	; 59
    80ce:	91 e0       	ldi	r25, 0x01	; 1
    80d0:	9f 93       	push	r25
    80d2:	8f 93       	push	r24
    80d4:	81 81       	ldd	r24, Z+1	; 0x01
    80d6:	8f 93       	push	r24
    80d8:	80 81       	ld	r24, Z
    80da:	8f 93       	push	r24
    80dc:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    80e0:	8d b7       	in	r24, 0x3d	; 61
    80e2:	9e b7       	in	r25, 0x3e	; 62
    80e4:	08 96       	adiw	r24, 0x08	; 8
    80e6:	0f b6       	in	r0, 0x3f	; 63
    80e8:	f8 94       	cli
    80ea:	9e bf       	out	0x3e, r25	; 62
    80ec:	0f be       	out	0x3f, r0	; 63
    80ee:	8d bf       	out	0x3d, r24	; 61
    80f0:	08 95       	ret

000080f2 <PutDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// PutDVal - print unsigned Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
PutDVal(uint32_t Val, T_Param *Param)
{
    80f2:	af 92       	push	r10
    80f4:	bf 92       	push	r11
    80f6:	cf 92       	push	r12
    80f8:	df 92       	push	r13
    80fa:	ef 92       	push	r14
    80fc:	ff 92       	push	r15
    80fe:	0f 93       	push	r16
    8100:	1f 93       	push	r17
    8102:	cf 93       	push	r28
    8104:	df 93       	push	r29
    8106:	cd b7       	in	r28, 0x3d	; 61
    8108:	de b7       	in	r29, 0x3e	; 62
    810a:	2b 97       	sbiw	r28, 0x0b	; 11
    810c:	0f b6       	in	r0, 0x3f	; 63
    810e:	f8 94       	cli
    8110:	de bf       	out	0x3e, r29	; 62
    8112:	0f be       	out	0x3f, r0	; 63
    8114:	cd bf       	out	0x3d, r28	; 61
    8116:	6b 01       	movw	r12, r22
    8118:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    811a:	8b 01       	movw	r16, r22
    811c:	9c 01       	movw	r18, r24
    811e:	00 95       	com	r16
    8120:	10 95       	com	r17
    8122:	20 95       	com	r18
    8124:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    8126:	fa 01       	movw	r30, r20
    8128:	84 81       	ldd	r24, Z+4	; 0x04
    812a:	95 81       	ldd	r25, Z+5	; 0x05
    812c:	00 97       	sbiw	r24, 0x00	; 0
    812e:	79 f0       	breq	.+30     	; 0x814e <PutDVal+0x5c>
    8130:	02 30       	cpi	r16, 0x02	; 2
    8132:	11 05       	cpc	r17, r1
    8134:	21 05       	cpc	r18, r1
    8136:	31 05       	cpc	r19, r1
    8138:	50 f4       	brcc	.+20     	; 0x814e <PutDVal+0x5c>
		Param->Txt += Idx;
    813a:	00 0f       	add	r16, r16
    813c:	11 1f       	adc	r17, r17
    813e:	08 0f       	add	r16, r24
    8140:	19 1f       	adc	r17, r25
    8142:	15 83       	std	Z+5, r17	; 0x05
    8144:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    8146:	ca 01       	movw	r24, r20
    8148:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
		return;
    814c:	54 c0       	rjmp	.+168    	; 0x81f6 <PutDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    814e:	fa 01       	movw	r30, r20
    8150:	93 81       	ldd	r25, Z+3	; 0x03
    8152:	9a 30       	cpi	r25, 0x0A	; 10
    8154:	81 f4       	brne	.+32     	; 0x8176 <PutDVal+0x84>
    8156:	82 81       	ldd	r24, Z+2	; 0x02
    8158:	81 11       	cpse	r24, r1
    815a:	0d c0       	rjmp	.+26     	; 0x8176 <PutDVal+0x84>
		sprintf(Param->Pos, "%10lu", Val);
    815c:	ff 92       	push	r15
    815e:	ef 92       	push	r14
    8160:	df 92       	push	r13
    8162:	cf 92       	push	r12
    8164:	81 e4       	ldi	r24, 0x41	; 65
    8166:	91 e0       	ldi	r25, 0x01	; 1
    8168:	9f 93       	push	r25
    816a:	8f 93       	push	r24
    816c:	81 81       	ldd	r24, Z+1	; 0x01
    816e:	8f 93       	push	r24
    8170:	80 81       	ld	r24, Z
    8172:	8f 93       	push	r24
    8174:	39 c0       	rjmp	.+114    	; 0x81e8 <PutDVal+0xf6>
		return;
	}
	char Format[] = "% lu.%. lu";
    8176:	8b e0       	ldi	r24, 0x0B	; 11
    8178:	e7 e4       	ldi	r30, 0x47	; 71
    817a:	f1 e0       	ldi	r31, 0x01	; 1
    817c:	8e 01       	movw	r16, r28
    817e:	0f 5f       	subi	r16, 0xFF	; 255
    8180:	1f 4f       	sbci	r17, 0xFF	; 255
    8182:	d8 01       	movw	r26, r16
    8184:	01 90       	ld	r0, Z+
    8186:	0d 92       	st	X+, r0
    8188:	8a 95       	dec	r24
    818a:	e1 f7       	brne	.-8      	; 0x8184 <PutDVal+0x92>
	Format[1] = '0'+Param->Size;
    818c:	90 5d       	subi	r25, 0xD0	; 208
    818e:	9a 83       	std	Y+2, r25	; 0x02
	if(Param->Prec) {
    8190:	fa 01       	movw	r30, r20
    8192:	82 81       	ldd	r24, Z+2	; 0x02
    8194:	a1 80       	ldd	r10, Z+1	; 0x01
    8196:	b0 80       	ld	r11, Z
    8198:	88 23       	and	r24, r24
    819a:	e9 f0       	breq	.+58     	; 0x81d6 <PutDVal+0xe4>
		Format[1] -= Param->Prec+1;
    819c:	98 1b       	sub	r25, r24
    819e:	91 50       	subi	r25, 0x01	; 1
    81a0:	9a 83       	std	Y+2, r25	; 0x02
		Format[7] = '0'+Param->Prec;
    81a2:	90 e3       	ldi	r25, 0x30	; 48
    81a4:	98 0f       	add	r25, r24
    81a6:	98 87       	std	Y+8, r25	; 0x08
		uint32_t Div=PowL10(Param->Prec);
    81a8:	0e 94 96 3c 	call	0x792c	; 0x792c <PowL10>
    81ac:	9b 01       	movw	r18, r22
    81ae:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    81b0:	c7 01       	movw	r24, r14
    81b2:	b6 01       	movw	r22, r12
    81b4:	0e 94 6e 75 	call	0xeadc	; 0xeadc <__udivmodsi4>
    81b8:	9f 93       	push	r25
    81ba:	8f 93       	push	r24
    81bc:	7f 93       	push	r23
    81be:	6f 93       	push	r22
    81c0:	5f 93       	push	r21
    81c2:	4f 93       	push	r20
    81c4:	3f 93       	push	r19
    81c6:	2f 93       	push	r18
    81c8:	1f 93       	push	r17
    81ca:	0f 93       	push	r16
    81cc:	af 92       	push	r10
    81ce:	bf 92       	push	r11
    81d0:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    81d4:	0b c0       	rjmp	.+22     	; 0x81ec <PutDVal+0xfa>
	}
	else {
		Format[4] = '\0';
    81d6:	1d 82       	std	Y+5, r1	; 0x05
		sprintf(Param->Pos, Format, Val);
    81d8:	ff 92       	push	r15
    81da:	ef 92       	push	r14
    81dc:	df 92       	push	r13
    81de:	cf 92       	push	r12
    81e0:	1f 93       	push	r17
    81e2:	0f 93       	push	r16
    81e4:	af 92       	push	r10
    81e6:	bf 92       	push	r11
    81e8:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    81ec:	0f b6       	in	r0, 0x3f	; 63
    81ee:	f8 94       	cli
    81f0:	de bf       	out	0x3e, r29	; 62
    81f2:	0f be       	out	0x3f, r0	; 63
    81f4:	cd bf       	out	0x3d, r28	; 61
	}
}
    81f6:	2b 96       	adiw	r28, 0x0b	; 11
    81f8:	0f b6       	in	r0, 0x3f	; 63
    81fa:	f8 94       	cli
    81fc:	de bf       	out	0x3e, r29	; 62
    81fe:	0f be       	out	0x3f, r0	; 63
    8200:	cd bf       	out	0x3d, r28	; 61
    8202:	df 91       	pop	r29
    8204:	cf 91       	pop	r28
    8206:	1f 91       	pop	r17
    8208:	0f 91       	pop	r16
    820a:	ff 90       	pop	r15
    820c:	ef 90       	pop	r14
    820e:	df 90       	pop	r13
    8210:	cf 90       	pop	r12
    8212:	bf 90       	pop	r11
    8214:	af 90       	pop	r10
    8216:	08 95       	ret

00008218 <Put_sDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_sDVal - print signed Longint in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
Put_sDVal(int32_t Val, T_Param *Param)
{
    8218:	af 92       	push	r10
    821a:	bf 92       	push	r11
    821c:	cf 92       	push	r12
    821e:	df 92       	push	r13
    8220:	ef 92       	push	r14
    8222:	ff 92       	push	r15
    8224:	0f 93       	push	r16
    8226:	1f 93       	push	r17
    8228:	cf 93       	push	r28
    822a:	df 93       	push	r29
    822c:	cd b7       	in	r28, 0x3d	; 61
    822e:	de b7       	in	r29, 0x3e	; 62
    8230:	27 97       	sbiw	r28, 0x07	; 7
    8232:	0f b6       	in	r0, 0x3f	; 63
    8234:	f8 94       	cli
    8236:	de bf       	out	0x3e, r29	; 62
    8238:	0f be       	out	0x3f, r0	; 63
    823a:	cd bf       	out	0x3d, r28	; 61
    823c:	6b 01       	movw	r12, r22
    823e:	7c 01       	movw	r14, r24
    8240:	5a 01       	movw	r10, r20
	uint32_t Idx = 0x80000000+Val;
    8242:	8b 01       	movw	r16, r22
    8244:	9c 01       	movw	r18, r24
    8246:	30 58       	subi	r19, 0x80	; 128
	if(Param->Txt && Idx<2) {
    8248:	da 01       	movw	r26, r20
    824a:	14 96       	adiw	r26, 0x04	; 4
    824c:	8d 91       	ld	r24, X+
    824e:	9c 91       	ld	r25, X
    8250:	15 97       	sbiw	r26, 0x05	; 5
    8252:	00 97       	sbiw	r24, 0x00	; 0
    8254:	89 f0       	breq	.+34     	; 0x8278 <Put_sDVal+0x60>
    8256:	02 30       	cpi	r16, 0x02	; 2
    8258:	11 05       	cpc	r17, r1
    825a:	21 05       	cpc	r18, r1
    825c:	31 05       	cpc	r19, r1
    825e:	60 f4       	brcc	.+24     	; 0x8278 <Put_sDVal+0x60>
		Param->Txt += Idx;
    8260:	00 0f       	add	r16, r16
    8262:	11 1f       	adc	r17, r17
    8264:	08 0f       	add	r16, r24
    8266:	19 1f       	adc	r17, r25
    8268:	15 96       	adiw	r26, 0x05	; 5
    826a:	1c 93       	st	X, r17
    826c:	0e 93       	st	-X, r16
    826e:	14 97       	sbiw	r26, 0x04	; 4
		PutEnum(Param);
    8270:	ca 01       	movw	r24, r20
    8272:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
		return;
    8276:	b7 c0       	rjmp	.+366    	; 0x83e6 <Put_sDVal+0x1ce>
	}
	// standart specificator to print Longint in string
	if(Param->Size>9){
    8278:	f5 01       	movw	r30, r10
    827a:	83 81       	ldd	r24, Z+3	; 0x03
    827c:	9e 01       	movw	r18, r28
    827e:	2f 5f       	subi	r18, 0xFF	; 255
    8280:	3f 4f       	sbci	r19, 0xFF	; 255
    8282:	8a 30       	cpi	r24, 0x0A	; 10
    8284:	70 f0       	brcs	.+28     	; 0x82a2 <Put_sDVal+0x8a>
		char Format[] = "%+1 ld";
    8286:	97 e0       	ldi	r25, 0x07	; 7
    8288:	e2 e5       	ldi	r30, 0x52	; 82
    828a:	f1 e0       	ldi	r31, 0x01	; 1
    828c:	d9 01       	movw	r26, r18
    828e:	01 90       	ld	r0, Z+
    8290:	0d 92       	st	X+, r0
    8292:	9a 95       	dec	r25
    8294:	e1 f7       	brne	.-8      	; 0x828e <Put_sDVal+0x76>
		Format[3] = '0'+Param->Size%10;
    8296:	6a e0       	ldi	r22, 0x0A	; 10
    8298:	0e 94 3a 75 	call	0xea74	; 0xea74 <__udivmodqi4>
    829c:	90 5d       	subi	r25, 0xD0	; 208
    829e:	9c 83       	std	Y+4, r25	; 0x04
    82a0:	0a c0       	rjmp	.+20     	; 0x82b6 <Put_sDVal+0x9e>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+ ld";
    82a2:	96 e0       	ldi	r25, 0x06	; 6
    82a4:	e9 e5       	ldi	r30, 0x59	; 89
    82a6:	f1 e0       	ldi	r31, 0x01	; 1
    82a8:	d9 01       	movw	r26, r18
    82aa:	01 90       	ld	r0, Z+
    82ac:	0d 92       	st	X+, r0
    82ae:	9a 95       	dec	r25
    82b0:	e1 f7       	brne	.-8      	; 0x82aa <Put_sDVal+0x92>
		Format[2] = '0'+Param->Size;
    82b2:	80 5d       	subi	r24, 0xD0	; 208
    82b4:	8b 83       	std	Y+3, r24	; 0x03
		sprintf(Param->Pos, Format, Val);
    82b6:	ff 92       	push	r15
    82b8:	ef 92       	push	r14
    82ba:	df 92       	push	r13
    82bc:	cf 92       	push	r12
    82be:	3f 93       	push	r19
    82c0:	2f 93       	push	r18
    82c2:	d5 01       	movw	r26, r10
    82c4:	11 96       	adiw	r26, 0x01	; 1
    82c6:	8c 91       	ld	r24, X
    82c8:	11 97       	sbiw	r26, 0x01	; 1
    82ca:	8f 93       	push	r24
    82cc:	8c 91       	ld	r24, X
    82ce:	8f 93       	push	r24
    82d0:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    82d4:	0f b6       	in	r0, 0x3f	; 63
    82d6:	f8 94       	cli
    82d8:	de bf       	out	0x3e, r29	; 62
    82da:	0f be       	out	0x3f, r0	; 63
    82dc:	cd bf       	out	0x3d, r28	; 61
	}
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';
    82de:	c1 14       	cp	r12, r1
    82e0:	d1 04       	cpc	r13, r1
    82e2:	e1 04       	cpc	r14, r1
    82e4:	f1 04       	cpc	r15, r1
    82e6:	59 f4       	brne	.+22     	; 0x82fe <Put_sDVal+0xe6>
    82e8:	d5 01       	movw	r26, r10
    82ea:	13 96       	adiw	r26, 0x03	; 3
    82ec:	8c 91       	ld	r24, X
    82ee:	13 97       	sbiw	r26, 0x03	; 3
    82f0:	ed 91       	ld	r30, X+
    82f2:	fc 91       	ld	r31, X
    82f4:	e8 0f       	add	r30, r24
    82f6:	f1 1d       	adc	r31, r1
    82f8:	32 97       	sbiw	r30, 0x02	; 2
    82fa:	80 e2       	ldi	r24, 0x20	; 32
    82fc:	80 83       	st	Z, r24

	if(Param->Prec){
    82fe:	f5 01       	movw	r30, r10
    8300:	82 81       	ldd	r24, Z+2	; 0x02
    8302:	88 23       	and	r24, r24
    8304:	09 f4       	brne	.+2      	; 0x8308 <Put_sDVal+0xf0>
    8306:	6f c0       	rjmp	.+222    	; 0x83e6 <Put_sDVal+0x1ce>
    8308:	60 e0       	ldi	r22, 0x00	; 0
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    830a:	d5 01       	movw	r26, r10
    830c:	13 96       	adiw	r26, 0x03	; 3
    830e:	8c 91       	ld	r24, X
    8310:	13 97       	sbiw	r26, 0x03	; 3
    8312:	90 e0       	ldi	r25, 0x00	; 0
    8314:	12 96       	adiw	r26, 0x02	; 2
    8316:	2c 91       	ld	r18, X
    8318:	12 97       	sbiw	r26, 0x02	; 2
    831a:	82 1b       	sub	r24, r18
    831c:	91 09       	sbc	r25, r1
    831e:	46 2f       	mov	r20, r22
    8320:	50 e0       	ldi	r21, 0x00	; 0
    8322:	2d 91       	ld	r18, X+
    8324:	3c 91       	ld	r19, X
    8326:	11 97       	sbiw	r26, 0x01	; 1
			Param->Pos[i] = Param->Pos[i+1];
    8328:	f9 01       	movw	r30, r18
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    832a:	48 17       	cp	r20, r24
    832c:	59 07       	cpc	r21, r25
    832e:	34 f4       	brge	.+12     	; 0x833c <Put_sDVal+0x124>
			Param->Pos[i] = Param->Pos[i+1];
    8330:	e4 0f       	add	r30, r20
    8332:	f5 1f       	adc	r31, r21
    8334:	81 81       	ldd	r24, Z+1	; 0x01
    8336:	80 83       	st	Z, r24
	//Delete sign if zero
	if(!Val)Param->Pos[Param->Size-2] = ' ';

	if(Param->Prec){
		//Insert decimal point
		for(uint8_t i=0; i< Param->Size - Param->Prec; i++){
    8338:	6f 5f       	subi	r22, 0xFF	; 255
    833a:	e7 cf       	rjmp	.-50     	; 0x830a <Put_sDVal+0xf2>
			Param->Pos[i] = Param->Pos[i+1];
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
    833c:	e8 0f       	add	r30, r24
    833e:	f9 1f       	adc	r31, r25
    8340:	31 97       	sbiw	r30, 0x01	; 1
    8342:	2e e2       	ldi	r18, 0x2E	; 46
    8344:	20 83       	st	Z, r18
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
    8346:	13 96       	adiw	r26, 0x03	; 3
    8348:	2c 91       	ld	r18, X
    834a:	13 97       	sbiw	r26, 0x03	; 3
    834c:	82 2f       	mov	r24, r18
    834e:	90 e0       	ldi	r25, 0x00	; 0
    8350:	12 96       	adiw	r26, 0x02	; 2
    8352:	3c 91       	ld	r19, X
    8354:	12 97       	sbiw	r26, 0x02	; 2
    8356:	83 1b       	sub	r24, r19
    8358:	91 09       	sbc	r25, r1
    835a:	ed 91       	ld	r30, X+
    835c:	fc 91       	ld	r31, X
    835e:	e8 0f       	add	r30, r24
    8360:	f9 1f       	adc	r31, r25
    8362:	32 97       	sbiw	r30, 0x02	; 2
    8364:	80 81       	ld	r24, Z
		if(c ==' ' || c =='+' || c =='-'){
    8366:	80 32       	cpi	r24, 0x20	; 32
    8368:	21 f0       	breq	.+8      	; 0x8372 <Put_sDVal+0x15a>
    836a:	8b 32       	cpi	r24, 0x2B	; 43
    836c:	11 f0       	breq	.+4      	; 0x8372 <Put_sDVal+0x15a>
    836e:	8d 32       	cpi	r24, 0x2D	; 45
    8370:	d1 f5       	brne	.+116    	; 0x83e6 <Put_sDVal+0x1ce>
			for(uint8_t i=Param->Size-1; i>1; i--){
    8372:	21 50       	subi	r18, 0x01	; 1
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    8374:	40 e3       	ldi	r20, 0x30	; 48
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    8376:	22 30       	cpi	r18, 0x02	; 2
    8378:	b0 f1       	brcs	.+108    	; 0x83e6 <Put_sDVal+0x1ce>
				if(Param->Pos[i] == ' '|| Param->Pos[i] == '+' || Param->Pos[i] == '-' ) Param->Pos[i]='0';
    837a:	82 2f       	mov	r24, r18
    837c:	90 e0       	ldi	r25, 0x00	; 0
    837e:	d5 01       	movw	r26, r10
    8380:	ed 91       	ld	r30, X+
    8382:	fc 91       	ld	r31, X
    8384:	e8 0f       	add	r30, r24
    8386:	f9 1f       	adc	r31, r25
    8388:	30 81       	ld	r19, Z
    838a:	30 32       	cpi	r19, 0x20	; 32
    838c:	21 f0       	breq	.+8      	; 0x8396 <Put_sDVal+0x17e>
    838e:	3b 32       	cpi	r19, 0x2B	; 43
    8390:	11 f0       	breq	.+4      	; 0x8396 <Put_sDVal+0x17e>
    8392:	3d 32       	cpi	r19, 0x2D	; 45
    8394:	09 f4       	brne	.+2      	; 0x8398 <Put_sDVal+0x180>
    8396:	40 83       	st	Z, r20
				if(Param->Pos[i] == '.'){
    8398:	d5 01       	movw	r26, r10
    839a:	ed 91       	ld	r30, X+
    839c:	fc 91       	ld	r31, X
    839e:	11 97       	sbiw	r26, 0x01	; 1
    83a0:	e8 0f       	add	r30, r24
    83a2:	f9 1f       	adc	r31, r25
    83a4:	30 81       	ld	r19, Z
    83a6:	3e 32       	cpi	r19, 0x2E	; 46
    83a8:	e1 f4       	brne	.+56     	; 0x83e2 <Put_sDVal+0x1ca>
					Param->Pos[i-1]='0';
    83aa:	31 97       	sbiw	r30, 0x01	; 1
    83ac:	20 e3       	ldi	r18, 0x30	; 48
    83ae:	20 83       	st	Z, r18
					if(Val>0)Param->Pos[i-2]='+';
    83b0:	1c 14       	cp	r1, r12
    83b2:	1d 04       	cpc	r1, r13
    83b4:	1e 04       	cpc	r1, r14
    83b6:	1f 04       	cpc	r1, r15
    83b8:	3c f4       	brge	.+14     	; 0x83c8 <Put_sDVal+0x1b0>
    83ba:	ed 91       	ld	r30, X+
    83bc:	fc 91       	ld	r31, X
    83be:	e8 0f       	add	r30, r24
    83c0:	f9 1f       	adc	r31, r25
    83c2:	32 97       	sbiw	r30, 0x02	; 2
    83c4:	8b e2       	ldi	r24, 0x2B	; 43
    83c6:	0b c0       	rjmp	.+22     	; 0x83de <Put_sDVal+0x1c6>
					if(Val<0)Param->Pos[i-2]='-';
    83c8:	cd 28       	or	r12, r13
    83ca:	ce 28       	or	r12, r14
    83cc:	cf 28       	or	r12, r15
    83ce:	59 f0       	breq	.+22     	; 0x83e6 <Put_sDVal+0x1ce>
    83d0:	d5 01       	movw	r26, r10
    83d2:	ed 91       	ld	r30, X+
    83d4:	fc 91       	ld	r31, X
    83d6:	e8 0f       	add	r30, r24
    83d8:	f9 1f       	adc	r31, r25
    83da:	32 97       	sbiw	r30, 0x02	; 2
    83dc:	8d e2       	ldi	r24, 0x2D	; 45
    83de:	80 83       	st	Z, r24
    83e0:	02 c0       	rjmp	.+4      	; 0x83e6 <Put_sDVal+0x1ce>
		}
		Param->Pos[Param->Size - Param->Prec-1] = '.';
		//Fill zeros and shift sign for correct view
		char c = Param->Pos[Param->Size - Param->Prec-2];
		if(c ==' ' || c =='+' || c =='-'){
			for(uint8_t i=Param->Size-1; i>1; i--){
    83e2:	21 50       	subi	r18, 0x01	; 1
    83e4:	c8 cf       	rjmp	.-112    	; 0x8376 <Put_sDVal+0x15e>
				}
			}
		}
	}

}
    83e6:	27 96       	adiw	r28, 0x07	; 7
    83e8:	0f b6       	in	r0, 0x3f	; 63
    83ea:	f8 94       	cli
    83ec:	de bf       	out	0x3e, r29	; 62
    83ee:	0f be       	out	0x3f, r0	; 63
    83f0:	cd bf       	out	0x3d, r28	; 61
    83f2:	df 91       	pop	r29
    83f4:	cf 91       	pop	r28
    83f6:	1f 91       	pop	r17
    83f8:	0f 91       	pop	r16
    83fa:	ff 90       	pop	r15
    83fc:	ef 90       	pop	r14
    83fe:	df 90       	pop	r13
    8400:	cf 90       	pop	r12
    8402:	bf 90       	pop	r11
    8404:	af 90       	pop	r10
    8406:	08 95       	ret

00008408 <Put_zDVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_zDVal - print unsigned Longint with leading zeroes in Buffer 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void 
Put_zDVal(uint32_t Val, T_Param *Param)
{
    8408:	af 92       	push	r10
    840a:	bf 92       	push	r11
    840c:	cf 92       	push	r12
    840e:	df 92       	push	r13
    8410:	ef 92       	push	r14
    8412:	ff 92       	push	r15
    8414:	0f 93       	push	r16
    8416:	1f 93       	push	r17
    8418:	cf 93       	push	r28
    841a:	df 93       	push	r29
    841c:	cd b7       	in	r28, 0x3d	; 61
    841e:	de b7       	in	r29, 0x3e	; 62
    8420:	2c 97       	sbiw	r28, 0x0c	; 12
    8422:	0f b6       	in	r0, 0x3f	; 63
    8424:	f8 94       	cli
    8426:	de bf       	out	0x3e, r29	; 62
    8428:	0f be       	out	0x3f, r0	; 63
    842a:	cd bf       	out	0x3d, r28	; 61
    842c:	6b 01       	movw	r12, r22
    842e:	7c 01       	movw	r14, r24
	uint32_t Idx = 0xFFFFFFFF-Val;
    8430:	8b 01       	movw	r16, r22
    8432:	9c 01       	movw	r18, r24
    8434:	00 95       	com	r16
    8436:	10 95       	com	r17
    8438:	20 95       	com	r18
    843a:	30 95       	com	r19
	if(Param->Txt && Idx<2) {
    843c:	fa 01       	movw	r30, r20
    843e:	84 81       	ldd	r24, Z+4	; 0x04
    8440:	95 81       	ldd	r25, Z+5	; 0x05
    8442:	00 97       	sbiw	r24, 0x00	; 0
    8444:	79 f0       	breq	.+30     	; 0x8464 <Put_zDVal+0x5c>
    8446:	02 30       	cpi	r16, 0x02	; 2
    8448:	11 05       	cpc	r17, r1
    844a:	21 05       	cpc	r18, r1
    844c:	31 05       	cpc	r19, r1
    844e:	50 f4       	brcc	.+20     	; 0x8464 <Put_zDVal+0x5c>
		Param->Txt += Idx;
    8450:	00 0f       	add	r16, r16
    8452:	11 1f       	adc	r17, r17
    8454:	08 0f       	add	r16, r24
    8456:	19 1f       	adc	r17, r25
    8458:	15 83       	std	Z+5, r17	; 0x05
    845a:	04 83       	std	Z+4, r16	; 0x04
		PutEnum(Param);
    845c:	ca 01       	movw	r24, r20
    845e:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
		return;
    8462:	54 c0       	rjmp	.+168    	; 0x850c <Put_zDVal+0x104>
	}

	if(Param->Size==10 && Param->Prec==0){
    8464:	fa 01       	movw	r30, r20
    8466:	93 81       	ldd	r25, Z+3	; 0x03
    8468:	9a 30       	cpi	r25, 0x0A	; 10
    846a:	81 f4       	brne	.+32     	; 0x848c <Put_zDVal+0x84>
    846c:	82 81       	ldd	r24, Z+2	; 0x02
    846e:	81 11       	cpse	r24, r1
    8470:	0d c0       	rjmp	.+26     	; 0x848c <Put_zDVal+0x84>
		sprintf(Param->Pos, "%010lu", Val);
    8472:	ff 92       	push	r15
    8474:	ef 92       	push	r14
    8476:	df 92       	push	r13
    8478:	cf 92       	push	r12
    847a:	8f e5       	ldi	r24, 0x5F	; 95
    847c:	91 e0       	ldi	r25, 0x01	; 1
    847e:	9f 93       	push	r25
    8480:	8f 93       	push	r24
    8482:	81 81       	ldd	r24, Z+1	; 0x01
    8484:	8f 93       	push	r24
    8486:	80 81       	ld	r24, Z
    8488:	8f 93       	push	r24
    848a:	39 c0       	rjmp	.+114    	; 0x84fe <Put_zDVal+0xf6>
		return;
	}
	char Format[] = "%0 lu.%. lu";
    848c:	8c e0       	ldi	r24, 0x0C	; 12
    848e:	e6 e6       	ldi	r30, 0x66	; 102
    8490:	f1 e0       	ldi	r31, 0x01	; 1
    8492:	8e 01       	movw	r16, r28
    8494:	0f 5f       	subi	r16, 0xFF	; 255
    8496:	1f 4f       	sbci	r17, 0xFF	; 255
    8498:	d8 01       	movw	r26, r16
    849a:	01 90       	ld	r0, Z+
    849c:	0d 92       	st	X+, r0
    849e:	8a 95       	dec	r24
    84a0:	e1 f7       	brne	.-8      	; 0x849a <Put_zDVal+0x92>
	Format[2] = '0'+Param->Size;
    84a2:	90 5d       	subi	r25, 0xD0	; 208
    84a4:	9b 83       	std	Y+3, r25	; 0x03
	if(Param->Prec) {
    84a6:	fa 01       	movw	r30, r20
    84a8:	82 81       	ldd	r24, Z+2	; 0x02
    84aa:	a1 80       	ldd	r10, Z+1	; 0x01
    84ac:	b0 80       	ld	r11, Z
    84ae:	88 23       	and	r24, r24
    84b0:	e9 f0       	breq	.+58     	; 0x84ec <Put_zDVal+0xe4>
		Format[2] -= Param->Prec+1;
    84b2:	98 1b       	sub	r25, r24
    84b4:	91 50       	subi	r25, 0x01	; 1
    84b6:	9b 83       	std	Y+3, r25	; 0x03
		Format[8] = '0'+Param->Prec;
    84b8:	90 e3       	ldi	r25, 0x30	; 48
    84ba:	98 0f       	add	r25, r24
    84bc:	99 87       	std	Y+9, r25	; 0x09
		uint32_t Div=PowL10(Param->Prec);
    84be:	0e 94 96 3c 	call	0x792c	; 0x792c <PowL10>
    84c2:	9b 01       	movw	r18, r22
    84c4:	ac 01       	movw	r20, r24
		sprintf(Param->Pos, Format, Val/Div, Val%Div);
    84c6:	c7 01       	movw	r24, r14
    84c8:	b6 01       	movw	r22, r12
    84ca:	0e 94 6e 75 	call	0xeadc	; 0xeadc <__udivmodsi4>
    84ce:	9f 93       	push	r25
    84d0:	8f 93       	push	r24
    84d2:	7f 93       	push	r23
    84d4:	6f 93       	push	r22
    84d6:	5f 93       	push	r21
    84d8:	4f 93       	push	r20
    84da:	3f 93       	push	r19
    84dc:	2f 93       	push	r18
    84de:	1f 93       	push	r17
    84e0:	0f 93       	push	r16
    84e2:	af 92       	push	r10
    84e4:	bf 92       	push	r11
    84e6:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    84ea:	0b c0       	rjmp	.+22     	; 0x8502 <Put_zDVal+0xfa>
	}
	else {
		Format[5] = '\0';
    84ec:	1e 82       	std	Y+6, r1	; 0x06
		sprintf(Param->Pos, Format, Val);
    84ee:	ff 92       	push	r15
    84f0:	ef 92       	push	r14
    84f2:	df 92       	push	r13
    84f4:	cf 92       	push	r12
    84f6:	1f 93       	push	r17
    84f8:	0f 93       	push	r16
    84fa:	af 92       	push	r10
    84fc:	bf 92       	push	r11
    84fe:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    8502:	0f b6       	in	r0, 0x3f	; 63
    8504:	f8 94       	cli
    8506:	de bf       	out	0x3e, r29	; 62
    8508:	0f be       	out	0x3f, r0	; 63
    850a:	cd bf       	out	0x3d, r28	; 61
	}
}
    850c:	2c 96       	adiw	r28, 0x0c	; 12
    850e:	0f b6       	in	r0, 0x3f	; 63
    8510:	f8 94       	cli
    8512:	de bf       	out	0x3e, r29	; 62
    8514:	0f be       	out	0x3f, r0	; 63
    8516:	cd bf       	out	0x3d, r28	; 61
    8518:	df 91       	pop	r29
    851a:	cf 91       	pop	r28
    851c:	1f 91       	pop	r17
    851e:	0f 91       	pop	r16
    8520:	ff 90       	pop	r15
    8522:	ef 90       	pop	r14
    8524:	df 90       	pop	r13
    8526:	cf 90       	pop	r12
    8528:	bf 90       	pop	r11
    852a:	af 90       	pop	r10
    852c:	08 95       	ret

0000852e <Put_FFVal>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_FVal -  The double argument is rounded and converted to decimal notation in the format "[-]ddd.ddd"
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_FFVal(float Val, T_Param *Param){
    852e:	1f 93       	push	r17
    8530:	cf 93       	push	r28
    8532:	df 93       	push	r29
    8534:	cd b7       	in	r28, 0x3d	; 61
    8536:	de b7       	in	r29, 0x3e	; 62
    8538:	27 97       	sbiw	r28, 0x07	; 7
    853a:	0f b6       	in	r0, 0x3f	; 63
    853c:	f8 94       	cli
    853e:	de bf       	out	0x3e, r29	; 62
    8540:	0f be       	out	0x3f, r0	; 63
    8542:	cd bf       	out	0x3d, r28	; 61
	char Format[] = "%+ . f";
    8544:	17 e0       	ldi	r17, 0x07	; 7
    8546:	e2 e7       	ldi	r30, 0x72	; 114
    8548:	f1 e0       	ldi	r31, 0x01	; 1
    854a:	9e 01       	movw	r18, r28
    854c:	2f 5f       	subi	r18, 0xFF	; 255
    854e:	3f 4f       	sbci	r19, 0xFF	; 255
    8550:	d9 01       	movw	r26, r18
    8552:	01 90       	ld	r0, Z+
    8554:	0d 92       	st	X+, r0
    8556:	1a 95       	dec	r17
    8558:	e1 f7       	brne	.-8      	; 0x8552 <Put_FFVal+0x24>
	Format[2] = '0'+Param->Size;
    855a:	da 01       	movw	r26, r20
    855c:	13 96       	adiw	r26, 0x03	; 3
    855e:	ec 91       	ld	r30, X
    8560:	13 97       	sbiw	r26, 0x03	; 3
    8562:	e0 5d       	subi	r30, 0xD0	; 208
    8564:	eb 83       	std	Y+3, r30	; 0x03
	Format[4] = '0'+Param->Prec;	
    8566:	12 96       	adiw	r26, 0x02	; 2
    8568:	ec 91       	ld	r30, X
    856a:	12 97       	sbiw	r26, 0x02	; 2
    856c:	e0 5d       	subi	r30, 0xD0	; 208
    856e:	ed 83       	std	Y+5, r30	; 0x05
	sprintf(Param->Pos, Format, Val);
    8570:	9f 93       	push	r25
    8572:	8f 93       	push	r24
    8574:	7f 93       	push	r23
    8576:	6f 93       	push	r22
    8578:	3f 93       	push	r19
    857a:	2f 93       	push	r18
    857c:	11 96       	adiw	r26, 0x01	; 1
    857e:	8c 91       	ld	r24, X
    8580:	11 97       	sbiw	r26, 0x01	; 1
    8582:	8f 93       	push	r24
    8584:	8c 91       	ld	r24, X
    8586:	8f 93       	push	r24
    8588:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    858c:	0f b6       	in	r0, 0x3f	; 63
    858e:	f8 94       	cli
    8590:	de bf       	out	0x3e, r29	; 62
    8592:	0f be       	out	0x3f, r0	; 63
    8594:	cd bf       	out	0x3d, r28	; 61
}
    8596:	27 96       	adiw	r28, 0x07	; 7
    8598:	0f b6       	in	r0, 0x3f	; 63
    859a:	f8 94       	cli
    859c:	de bf       	out	0x3e, r29	; 62
    859e:	0f be       	out	0x3f, r0	; 63
    85a0:	cd bf       	out	0x3d, r28	; 61
    85a2:	df 91       	pop	r29
    85a4:	cf 91       	pop	r28
    85a6:	1f 91       	pop	r17
    85a8:	08 95       	ret

000085aa <Put_GFVal>:
// Trailing zeros are removed from the fractional part of the result; 
// a decimal point appears only if it is followed by at least one digit.
// Max presicion - 8digits Why???
// Therefore Max Field size - 9
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_GFVal(float Val, T_Param *Param){
    85aa:	0f 93       	push	r16
    85ac:	1f 93       	push	r17
    85ae:	cf 93       	push	r28
    85b0:	df 93       	push	r29
    85b2:	cd b7       	in	r28, 0x3d	; 61
    85b4:	de b7       	in	r29, 0x3e	; 62
    85b6:	28 97       	sbiw	r28, 0x08	; 8
    85b8:	0f b6       	in	r0, 0x3f	; 63
    85ba:	f8 94       	cli
    85bc:	de bf       	out	0x3e, r29	; 62
    85be:	0f be       	out	0x3f, r0	; 63
    85c0:	cd bf       	out	0x3d, r28	; 61
	if(Param->Size < 10){
    85c2:	da 01       	movw	r26, r20
    85c4:	13 96       	adiw	r26, 0x03	; 3
    85c6:	1c 91       	ld	r17, X
    85c8:	9e 01       	movw	r18, r28
    85ca:	2f 5f       	subi	r18, 0xFF	; 255
    85cc:	3f 4f       	sbci	r19, 0xFF	; 255
    85ce:	1a 30       	cpi	r17, 0x0A	; 10
    85d0:	88 f4       	brcc	.+34     	; 0x85f4 <Put_GFVal+0x4a>
		char Format[] = "%+ . g";
    85d2:	07 e0       	ldi	r16, 0x07	; 7
    85d4:	e9 e7       	ldi	r30, 0x79	; 121
    85d6:	f1 e0       	ldi	r31, 0x01	; 1
    85d8:	d9 01       	movw	r26, r18
    85da:	01 90       	ld	r0, Z+
    85dc:	0d 92       	st	X+, r0
    85de:	0a 95       	dec	r16
    85e0:	e1 f7       	brne	.-8      	; 0x85da <Put_GFVal+0x30>
		Format[2] = '0'+Param->Size;
    85e2:	10 5d       	subi	r17, 0xD0	; 208
    85e4:	1b 83       	std	Y+3, r17	; 0x03
		Format[4] = '0'+Param->Prec;
    85e6:	da 01       	movw	r26, r20
    85e8:	12 96       	adiw	r26, 0x02	; 2
    85ea:	ec 91       	ld	r30, X
    85ec:	12 97       	sbiw	r26, 0x02	; 2
    85ee:	e0 5d       	subi	r30, 0xD0	; 208
    85f0:	ed 83       	std	Y+5, r30	; 0x05
    85f2:	10 c0       	rjmp	.+32     	; 0x8614 <Put_GFVal+0x6a>
		sprintf(Param->Pos, Format, Val);
	}
	else{
		char Format[] = "%+1 . g";
    85f4:	08 e0       	ldi	r16, 0x08	; 8
    85f6:	e0 e8       	ldi	r30, 0x80	; 128
    85f8:	f1 e0       	ldi	r31, 0x01	; 1
    85fa:	d9 01       	movw	r26, r18
    85fc:	01 90       	ld	r0, Z+
    85fe:	0d 92       	st	X+, r0
    8600:	0a 95       	dec	r16
    8602:	e1 f7       	brne	.-8      	; 0x85fc <Put_GFVal+0x52>
		Format[3] = '0'+Param->Size-10;	
    8604:	1a 5d       	subi	r17, 0xDA	; 218
    8606:	1c 83       	std	Y+4, r17	; 0x04
		Format[5] = '0'+Param->Prec;
    8608:	da 01       	movw	r26, r20
    860a:	12 96       	adiw	r26, 0x02	; 2
    860c:	ec 91       	ld	r30, X
    860e:	12 97       	sbiw	r26, 0x02	; 2
    8610:	e0 5d       	subi	r30, 0xD0	; 208
    8612:	ee 83       	std	Y+6, r30	; 0x06
		sprintf(Param->Pos, Format, Val);
    8614:	9f 93       	push	r25
    8616:	8f 93       	push	r24
    8618:	7f 93       	push	r23
    861a:	6f 93       	push	r22
    861c:	3f 93       	push	r19
    861e:	2f 93       	push	r18
    8620:	11 96       	adiw	r26, 0x01	; 1
    8622:	8c 91       	ld	r24, X
    8624:	11 97       	sbiw	r26, 0x01	; 1
    8626:	8f 93       	push	r24
    8628:	8c 91       	ld	r24, X
    862a:	8f 93       	push	r24
    862c:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    8630:	0f b6       	in	r0, 0x3f	; 63
    8632:	f8 94       	cli
    8634:	de bf       	out	0x3e, r29	; 62
    8636:	0f be       	out	0x3f, r0	; 63
    8638:	cd bf       	out	0x3d, r28	; 61
	}
}
    863a:	28 96       	adiw	r28, 0x08	; 8
    863c:	0f b6       	in	r0, 0x3f	; 63
    863e:	f8 94       	cli
    8640:	de bf       	out	0x3e, r29	; 62
    8642:	0f be       	out	0x3f, r0	; 63
    8644:	cd bf       	out	0x3d, r28	; 61
    8646:	df 91       	pop	r29
    8648:	cf 91       	pop	r28
    864a:	1f 91       	pop	r17
    864c:	0f 91       	pop	r16
    864e:	08 95       	ret

00008650 <Put_TextValAlignLeft>:
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Put_TextVal -  
// if, for example, Filed width =12 -> sprintf(Param->Pos,"%12.12s",Val)
// min and max width = Param->Size and align right
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void Put_TextValAlignLeft(char* Val, T_Param *Param){
    8650:	cf 92       	push	r12
    8652:	df 92       	push	r13
    8654:	ef 92       	push	r14
    8656:	ff 92       	push	r15
    8658:	0f 93       	push	r16
    865a:	1f 93       	push	r17
    865c:	cf 93       	push	r28
    865e:	df 93       	push	r29
    8660:	cd b7       	in	r28, 0x3d	; 61
    8662:	de b7       	in	r29, 0x3e	; 62
    8664:	29 97       	sbiw	r28, 0x09	; 9
    8666:	0f b6       	in	r0, 0x3f	; 63
    8668:	f8 94       	cli
    866a:	de bf       	out	0x3e, r29	; 62
    866c:	0f be       	out	0x3f, r0	; 63
    866e:	cd bf       	out	0x3d, r28	; 61
    8670:	d8 2e       	mov	r13, r24
    8672:	c9 2e       	mov	r12, r25
    8674:	7b 01       	movw	r14, r22
	char Format[9];
	//char Format[8] = "%10.10s";
	sprintf(Format,"%%-%u.%us", Param->Size, Param->Size);
    8676:	fb 01       	movw	r30, r22
    8678:	23 81       	ldd	r18, Z+3	; 0x03
    867a:	1f 92       	push	r1
    867c:	2f 93       	push	r18
    867e:	1f 92       	push	r1
    8680:	2f 93       	push	r18
    8682:	28 e8       	ldi	r18, 0x88	; 136
    8684:	31 e0       	ldi	r19, 0x01	; 1
    8686:	3f 93       	push	r19
    8688:	2f 93       	push	r18
    868a:	8e 01       	movw	r16, r28
    868c:	0f 5f       	subi	r16, 0xFF	; 255
    868e:	1f 4f       	sbci	r17, 0xFF	; 255
    8690:	1f 93       	push	r17
    8692:	0f 93       	push	r16
    8694:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
	sprintf(Param->Pos, Format, Val);
    8698:	cf 92       	push	r12
    869a:	df 92       	push	r13
    869c:	1f 93       	push	r17
    869e:	0f 93       	push	r16
    86a0:	f7 01       	movw	r30, r14
    86a2:	81 81       	ldd	r24, Z+1	; 0x01
    86a4:	8f 93       	push	r24
    86a6:	80 81       	ld	r24, Z
    86a8:	8f 93       	push	r24
    86aa:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    86ae:	0f b6       	in	r0, 0x3f	; 63
    86b0:	f8 94       	cli
    86b2:	de bf       	out	0x3e, r29	; 62
    86b4:	0f be       	out	0x3f, r0	; 63
    86b6:	cd bf       	out	0x3d, r28	; 61
}
    86b8:	29 96       	adiw	r28, 0x09	; 9
    86ba:	0f b6       	in	r0, 0x3f	; 63
    86bc:	f8 94       	cli
    86be:	de bf       	out	0x3e, r29	; 62
    86c0:	0f be       	out	0x3f, r0	; 63
    86c2:	cd bf       	out	0x3d, r28	; 61
    86c4:	df 91       	pop	r29
    86c6:	cf 91       	pop	r28
    86c8:	1f 91       	pop	r17
    86ca:	0f 91       	pop	r16
    86cc:	ff 90       	pop	r15
    86ce:	ef 90       	pop	r14
    86d0:	df 90       	pop	r13
    86d2:	cf 90       	pop	r12
    86d4:	08 95       	ret

000086d6 <HideMsg>:

// ~~~~~~~~~~
uint8_t
HideMsg(void)
{
	if (CurrMsg) {
    86d6:	80 91 25 0b 	lds	r24, 0x0B25
    86da:	90 91 26 0b 	lds	r25, 0x0B26
    86de:	89 2b       	or	r24, r25
    86e0:	31 f0       	breq	.+12     	; 0x86ee <HideMsg+0x18>
		//EventFunc(&CurrMsg->Exit);
		CurrMsg = NULL;
    86e2:	10 92 26 0b 	sts	0x0B26, r1
    86e6:	10 92 25 0b 	sts	0x0B25, r1
		return 1;
    86ea:	81 e0       	ldi	r24, 0x01	; 1
    86ec:	08 95       	ret
	}
	else
		return 0;
    86ee:	80 e0       	ldi	r24, 0x00	; 0
}
    86f0:	08 95       	ret

000086f2 <WebInit>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    86f2:	80 91 0f 01 	lds	r24, 0x010F
prog_char METHOD_POST[] = "POST /";

uint8_t Web_Login_Error(void);

void WebInit(void){
	TD_SetCRLFinPOST_RQ = Timer8SysAlloc(1);
    86f6:	80 93 41 09 	sts	0x0941, r24
	VacantTimer8Sys += n;
    86fa:	92 e0       	ldi	r25, 0x02	; 2
    86fc:	98 0f       	add	r25, r24
    86fe:	90 93 0f 01 	sts	0x010F, r25
    8702:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitLCDRefresh = Timer8SysAlloc(1);
    8704:	80 93 44 09 	sts	0x0944, r24

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    8708:	80 91 0e 01 	lds	r24, 0x010E
	TD_FlowDelay =  Timer16SysAlloc(1);
    870c:	80 93 4f 09 	sts	0x094F, r24
	VacantTimer16Sys += n;
    8710:	92 e0       	ldi	r25, 0x02	; 2
    8712:	98 0f       	add	r25, r24
    8714:	90 93 0e 01 	sts	0x010E, r25
    8718:	8f 5f       	subi	r24, 0xFF	; 255
	TD_WaitReqTimout =  Timer16SysAlloc(1);
    871a:	80 93 6a 09 	sts	0x096A, r24
	TD_WebSeedGenerator	= Timer32Alloc();		//     SessionID
    871e:	0e 94 9f 2a 	call	0x553e	; 0x553e <Timer32Alloc>
    8722:	80 93 1c 06 	sts	0x061C, r24
	TD_WebSessTimeout	= Timer32Alloc();
    8726:	0e 94 9f 2a 	call	0x553e	; 0x553e <Timer32Alloc>
    872a:	80 93 68 09 	sts	0x0968, r24
	if(Timer8AllocErr() || Timer16AllocErr() || Timer32AllocErr()) ShowMsg(&MsgErr41);
    872e:	80 91 12 01 	lds	r24, 0x0112
    8732:	88 31       	cpi	r24, 0x18	; 24
    8734:	40 f4       	brcc	.+16     	; 0x8746 <WebInit+0x54>
    8736:	80 91 11 01 	lds	r24, 0x0111
    873a:	88 32       	cpi	r24, 0x28	; 40
    873c:	20 f4       	brcc	.+8      	; 0x8746 <WebInit+0x54>
    873e:	80 91 10 01 	lds	r24, 0x0110
    8742:	80 32       	cpi	r24, 0x20	; 32
    8744:	40 f0       	brcs	.+16     	; 0x8756 <WebInit+0x64>

// ~~~~~~~~~~~~~~~~~~
void
ShowMsg(MsgPage *Msg)
{
	HideMsg();
    8746:	0e 94 6b 43 	call	0x86d6	; 0x86d6 <HideMsg>
	CurrMsg = Msg;
    874a:	8b ef       	ldi	r24, 0xFB	; 251
    874c:	9c e4       	ldi	r25, 0x4C	; 76
    874e:	90 93 26 0b 	sts	0x0B26, r25
    8752:	80 93 25 0b 	sts	0x0B25, r24
    8756:	08 95       	ret

00008758 <WebPresicionHanler>:
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8758:	0f 93       	push	r16
    875a:	1f 93       	push	r17
    875c:	cf 93       	push	r28
    875e:	df 93       	push	r29
    8760:	8b 01       	movw	r16, r22
	if(prb(&Field->Prec)){
    8762:	ec 01       	movw	r28, r24
    8764:	2f 96       	adiw	r28, 0x0f	; 15

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8766:	fe 01       	movw	r30, r28
    8768:	84 91       	lpm	r24, Z
    876a:	88 23       	and	r24, r24
    876c:	69 f1       	breq	.+90     	; 0x87c8 <WebPresicionHanler+0x70>
		char *p = strchr(BufStr,'.');	//seek for first decimal point
    876e:	6e e2       	ldi	r22, 0x2E	; 46
    8770:	70 e0       	ldi	r23, 0x00	; 0
    8772:	c8 01       	movw	r24, r16
    8774:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
		if(p==NULL){
    8778:	00 97       	sbiw	r24, 0x00	; 0
    877a:	29 f4       	brne	.+10     	; 0x8786 <WebPresicionHanler+0x2e>
			p = strchr(BufStr,' ');	//else seek for first space
    877c:	60 e2       	ldi	r22, 0x20	; 32
    877e:	70 e0       	ldi	r23, 0x00	; 0
    8780:	c8 01       	movw	r24, r16
    8782:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
		ew##ty3((ty2*)Var, Min);						\
	else																	\
		ew##ty3((ty2*)Var, (ty2)Buf)
// ~~~~~~~~~~~~~~~~~~~~~~~
//Change BufStr due to precision for correct sscanf reading BufStr
void WebPresicionHanler(OutField *Field, char *BufStr){
    8786:	dc 01       	movw	r26, r24
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
			if(*p == ' ') *p='0'; 
    8788:	40 e3       	ldi	r20, 0x30	; 48
    878a:	fe 01       	movw	r30, r28
    878c:	24 91       	lpm	r18, Z
    878e:	3a 2f       	mov	r19, r26
    8790:	38 1b       	sub	r19, r24
	if(prb(&Field->Prec)){
		char *p = strchr(BufStr,'.');	//seek for first decimal point
		if(p==NULL){
			p = strchr(BufStr,' ');	//else seek for first space
		}
	  	for(uint8_t i=0; i<prb(&Field->Prec); i++){
    8792:	32 17       	cp	r19, r18
    8794:	c8 f4       	brcc	.+50     	; 0x87c8 <WebPresicionHanler+0x70>
			if(*p == ' ') *p='0'; 
    8796:	2c 91       	ld	r18, X
    8798:	20 32       	cpi	r18, 0x20	; 32
    879a:	09 f4       	brne	.+2      	; 0x879e <WebPresicionHanler+0x46>
    879c:	4c 93       	st	X, r20
			if(*p == '.'){
    879e:	5c 91       	ld	r21, X
    87a0:	5e 32       	cpi	r21, 0x2E	; 46
    87a2:	81 f4       	brne	.+32     	; 0x87c4 <WebPresicionHanler+0x6c>
				if(isdigit(*(p+1))){
    87a4:	11 96       	adiw	r26, 0x01	; 1
    87a6:	6c 91       	ld	r22, X
    87a8:	11 97       	sbiw	r26, 0x01	; 1
    87aa:	26 2f       	mov	r18, r22
    87ac:	30 e0       	ldi	r19, 0x00	; 0
    87ae:	20 53       	subi	r18, 0x30	; 48
    87b0:	31 09       	sbc	r19, r1
    87b2:	2a 30       	cpi	r18, 0x0A	; 10
    87b4:	31 05       	cpc	r19, r1
    87b6:	28 f4       	brcc	.+10     	; 0x87c2 <WebPresicionHanler+0x6a>
					*p= *(p+1);
    87b8:	6c 93       	st	X, r22
					*(p+1) = '.';
    87ba:	11 96       	adiw	r26, 0x01	; 1
    87bc:	5c 93       	st	X, r21
    87be:	11 97       	sbiw	r26, 0x01	; 1
    87c0:	01 c0       	rjmp	.+2      	; 0x87c4 <WebPresicionHanler+0x6c>
				}
				else *p='0'; 
    87c2:	4c 93       	st	X, r20
			}
			p++;
    87c4:	11 96       	adiw	r26, 0x01	; 1
    87c6:	e1 cf       	rjmp	.-62     	; 0x878a <WebPresicionHanler+0x32>
		}
	}
	
}
    87c8:	df 91       	pop	r29
    87ca:	cf 91       	pop	r28
    87cc:	1f 91       	pop	r17
    87ce:	0f 91       	pop	r16
    87d0:	08 95       	ret

000087d2 <WebBuf2Field>:
// ~~~~~~~~~~~~~~~~~~~~~~~
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
    87d2:	2f 92       	push	r2
    87d4:	3f 92       	push	r3
    87d6:	4f 92       	push	r4
    87d8:	5f 92       	push	r5
    87da:	6f 92       	push	r6
    87dc:	7f 92       	push	r7
    87de:	8f 92       	push	r8
    87e0:	9f 92       	push	r9
    87e2:	af 92       	push	r10
    87e4:	bf 92       	push	r11
    87e6:	cf 92       	push	r12
    87e8:	df 92       	push	r13
    87ea:	ef 92       	push	r14
    87ec:	ff 92       	push	r15
    87ee:	0f 93       	push	r16
    87f0:	1f 93       	push	r17
    87f2:	cf 93       	push	r28
    87f4:	df 93       	push	r29
    87f6:	cd b7       	in	r28, 0x3d	; 61
    87f8:	de b7       	in	r29, 0x3e	; 62
    87fa:	2e 97       	sbiw	r28, 0x0e	; 14
    87fc:	0f b6       	in	r0, 0x3f	; 63
    87fe:	f8 94       	cli
    8800:	de bf       	out	0x3e, r29	; 62
    8802:	0f be       	out	0x3f, r0	; 63
    8804:	cd bf       	out	0x3d, r28	; 61
    8806:	6c 01       	movw	r12, r24
    8808:	8b 01       	movw	r16, r22
		}
		break;
	}

	EventFunc(&Field->Act);
}
    880a:	2d b7       	in	r18, 0x3d	; 61
    880c:	3e b7       	in	r19, 0x3e	; 62
    880e:	3e 87       	std	Y+14, r19	; 0x0e
    8810:	2d 87       	std	Y+13, r18	; 0x0d
//       
//     -
static void
WebBuf2Field(OutField *Field, char *BufStr)
{
	void *Var = prp(&Field->Var);
    8812:	fc 01       	movw	r30, r24
    8814:	31 96       	adiw	r30, 0x01	; 1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8816:	e5 90       	lpm	r14, Z+
    8818:	f4 90       	lpm	r15, Z
	uint8_t BitN=prb(&Field->Prec), Mask=1<<BitN%8, *BitVar=(uint8_t*)Var+BitN/8;
    881a:	1c 01       	movw	r2, r24
    881c:	3f e0       	ldi	r19, 0x0F	; 15
    881e:	23 0e       	add	r2, r19
    8820:	31 1c       	adc	r3, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8822:	f1 01       	movw	r30, r2
    8824:	84 91       	lpm	r24, Z
    8826:	98 2f       	mov	r25, r24
    8828:	97 70       	andi	r25, 0x07	; 7
    882a:	21 e0       	ldi	r18, 0x01	; 1
    882c:	30 e0       	ldi	r19, 0x00	; 0
    882e:	02 c0       	rjmp	.+4      	; 0x8834 <WebBuf2Field+0x62>
    8830:	22 0f       	add	r18, r18
    8832:	33 1f       	adc	r19, r19
    8834:	9a 95       	dec	r25
    8836:	e2 f7       	brpl	.-8      	; 0x8830 <WebBuf2Field+0x5e>
    8838:	3a 87       	std	Y+10, r19	; 0x0a
    883a:	29 87       	std	Y+9, r18	; 0x09
    883c:	86 95       	lsr	r24
    883e:	86 95       	lsr	r24
    8840:	86 95       	lsr	r24
    8842:	97 01       	movw	r18, r14
    8844:	28 0f       	add	r18, r24
    8846:	31 1d       	adc	r19, r1
    8848:	3c 87       	std	Y+12, r19	; 0x0c
    884a:	2b 87       	std	Y+11, r18	; 0x0b
	uint8_t EE_BitVar;
	uint32_t Min=prd(&Field->Min), Max=prd(&Field->Max);
    884c:	c6 01       	movw	r24, r12
    884e:	03 96       	adiw	r24, 0x03	; 3
    8850:	0e 94 46 29 	call	0x528c	; 0x528c <prd>
    8854:	2b 01       	movw	r4, r22
    8856:	3c 01       	movw	r6, r24
    8858:	c6 01       	movw	r24, r12
    885a:	07 96       	adiw	r24, 0x07	; 7
    885c:	0e 94 46 29 	call	0x528c	; 0x528c <prd>
    8860:	4b 01       	movw	r8, r22
    8862:	5c 01       	movw	r10, r24

	uint32_t Temp=0;
    8864:	1d 82       	std	Y+5, r1	; 0x05
    8866:	1e 82       	std	Y+6, r1	; 0x06
    8868:	1f 82       	std	Y+7, r1	; 0x07
    886a:	18 86       	std	Y+8, r1	; 0x08
	float fTemp=0;
    886c:	19 82       	std	Y+1, r1	; 0x01
    886e:	1a 82       	std	Y+2, r1	; 0x02
    8870:	1b 82       	std	Y+3, r1	; 0x03
    8872:	1c 82       	std	Y+4, r1	; 0x04
    8874:	f6 01       	movw	r30, r12
    8876:	84 91       	lpm	r24, Z


	switch(prb(&Field->Type)) {
    8878:	90 e0       	ldi	r25, 0x00	; 0
    887a:	83 32       	cpi	r24, 0x23	; 35
    887c:	91 05       	cpc	r25, r1
    887e:	08 f0       	brcs	.+2      	; 0x8882 <WebBuf2Field+0xb0>
    8880:	f0 c2       	rjmp	.+1504   	; 0x8e62 <WebBuf2Field+0x690>
    8882:	fc 01       	movw	r30, r24
    8884:	ea 59       	subi	r30, 0x9A	; 154
    8886:	ff 4f       	sbci	r31, 0xFF	; 255
    8888:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>



	case Byte: case z_Byte:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    888c:	b8 01       	movw	r22, r16
    888e:	c6 01       	movw	r24, r12
    8890:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);
    8894:	ce 01       	movw	r24, r28
    8896:	05 96       	adiw	r24, 0x05	; 5
    8898:	9f 93       	push	r25
    889a:	8f 93       	push	r24
    889c:	82 e9       	ldi	r24, 0x92	; 146
    889e:	91 e0       	ldi	r25, 0x01	; 1
    88a0:	9f 93       	push	r25
    88a2:	8f 93       	push	r24
    88a4:	1f 93       	push	r17
    88a6:	0f 93       	push	r16
    88a8:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		SetField(Temp, uint8_t);
    88ac:	8d 81       	ldd	r24, Y+5	; 0x05
    88ae:	9e 81       	ldd	r25, Y+6	; 0x06
    88b0:	af 81       	ldd	r26, Y+7	; 0x07
    88b2:	b8 85       	ldd	r27, Y+8	; 0x08
    88b4:	0f 90       	pop	r0
    88b6:	0f 90       	pop	r0
    88b8:	0f 90       	pop	r0
    88ba:	0f 90       	pop	r0
    88bc:	0f 90       	pop	r0
    88be:	0f 90       	pop	r0
    88c0:	b5 01       	movw	r22, r10
    88c2:	a4 01       	movw	r20, r8
    88c4:	55 27       	eor	r21, r21
    88c6:	66 27       	eor	r22, r22
    88c8:	77 27       	eor	r23, r23
    88ca:	48 17       	cp	r20, r24
    88cc:	59 07       	cpc	r21, r25
    88ce:	6a 07       	cpc	r22, r26
    88d0:	7b 07       	cpc	r23, r27
    88d2:	08 f4       	brcc	.+2      	; 0x88d6 <WebBuf2Field+0x104>
    88d4:	5f c0       	rjmp	.+190    	; 0x8994 <WebBuf2Field+0x1c2>
    88d6:	b3 01       	movw	r22, r6
    88d8:	a2 01       	movw	r20, r4
    88da:	55 27       	eor	r21, r21
    88dc:	66 27       	eor	r22, r22
    88de:	77 27       	eor	r23, r23
    88e0:	61 c0       	rjmp	.+194    	; 0x89a4 <WebBuf2Field+0x1d2>
		break;
	case EE_Byte: case z_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    88e2:	b8 01       	movw	r22, r16
    88e4:	c6 01       	movw	r24, r12
    88e6:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%hud", (unsigned short int*)&Temp) == 1){
    88ea:	ce 01       	movw	r24, r28
    88ec:	05 96       	adiw	r24, 0x05	; 5
    88ee:	9f 93       	push	r25
    88f0:	8f 93       	push	r24
    88f2:	82 e9       	ldi	r24, 0x92	; 146
    88f4:	91 e0       	ldi	r25, 0x01	; 1
    88f6:	9f 93       	push	r25
    88f8:	8f 93       	push	r24
    88fa:	1f 93       	push	r17
    88fc:	0f 93       	push	r16
    88fe:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    8902:	0f 90       	pop	r0
    8904:	0f 90       	pop	r0
    8906:	0f 90       	pop	r0
    8908:	0f 90       	pop	r0
    890a:	0f 90       	pop	r0
    890c:	0f 90       	pop	r0
    890e:	01 97       	sbiw	r24, 0x01	; 1
    8910:	09 f0       	breq	.+2      	; 0x8914 <WebBuf2Field+0x142>
    8912:	a7 c2       	rjmp	.+1358   	; 0x8e62 <WebBuf2Field+0x690>
			SetEEField(Temp, uint8_t, uint8_t, b);
    8914:	6d 81       	ldd	r22, Y+5	; 0x05
    8916:	7e 81       	ldd	r23, Y+6	; 0x06
    8918:	8f 81       	ldd	r24, Y+7	; 0x07
    891a:	98 85       	ldd	r25, Y+8	; 0x08
    891c:	95 01       	movw	r18, r10
    891e:	84 01       	movw	r16, r8
    8920:	11 27       	eor	r17, r17
    8922:	22 27       	eor	r18, r18
    8924:	33 27       	eor	r19, r19
    8926:	06 17       	cp	r16, r22
    8928:	17 07       	cpc	r17, r23
    892a:	28 07       	cpc	r18, r24
    892c:	39 07       	cpc	r19, r25
    892e:	08 f4       	brcc	.+2      	; 0x8932 <WebBuf2Field+0x160>
    8930:	5e c0       	rjmp	.+188    	; 0x89ee <WebBuf2Field+0x21c>
    8932:	93 01       	movw	r18, r6
    8934:	82 01       	movw	r16, r4
    8936:	11 27       	eor	r17, r17
    8938:	22 27       	eor	r18, r18
    893a:	33 27       	eor	r19, r19
    893c:	60 17       	cp	r22, r16
    893e:	71 07       	cpc	r23, r17
    8940:	82 07       	cpc	r24, r18
    8942:	93 07       	cpc	r25, r19
    8944:	08 f0       	brcs	.+2      	; 0x8948 <WebBuf2Field+0x176>
    8946:	d7 c1       	rjmp	.+942    	; 0x8cf6 <WebBuf2Field+0x524>
    8948:	d3 c1       	rjmp	.+934    	; 0x8cf0 <WebBuf2Field+0x51e>
		}		
		break;
	case s_Byte:
		WebPresicionHanler(Field, BufStr);
    894a:	b8 01       	movw	r22, r16
    894c:	c6 01       	movw	r24, r12
    894e:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%hd", (short int*)&Temp);
    8952:	ce 01       	movw	r24, r28
    8954:	05 96       	adiw	r24, 0x05	; 5
    8956:	9f 93       	push	r25
    8958:	8f 93       	push	r24
    895a:	87 e9       	ldi	r24, 0x97	; 151
    895c:	91 e0       	ldi	r25, 0x01	; 1
    895e:	9f 93       	push	r25
    8960:	8f 93       	push	r24
    8962:	1f 93       	push	r17
    8964:	0f 93       	push	r16
    8966:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		SetField(Temp, int8_t);
    896a:	8d 81       	ldd	r24, Y+5	; 0x05
    896c:	9e 81       	ldd	r25, Y+6	; 0x06
    896e:	af 81       	ldd	r26, Y+7	; 0x07
    8970:	b8 85       	ldd	r27, Y+8	; 0x08
    8972:	0f 90       	pop	r0
    8974:	0f 90       	pop	r0
    8976:	0f 90       	pop	r0
    8978:	0f 90       	pop	r0
    897a:	0f 90       	pop	r0
    897c:	0f 90       	pop	r0
    897e:	48 2d       	mov	r20, r8
    8980:	55 27       	eor	r21, r21
    8982:	47 fd       	sbrc	r20, 7
    8984:	50 95       	com	r21
    8986:	65 2f       	mov	r22, r21
    8988:	75 2f       	mov	r23, r21
    898a:	48 17       	cp	r20, r24
    898c:	59 07       	cpc	r21, r25
    898e:	6a 07       	cpc	r22, r26
    8990:	7b 07       	cpc	r23, r27
    8992:	10 f4       	brcc	.+4      	; 0x8998 <WebBuf2Field+0x1c6>
    8994:	f7 01       	movw	r30, r14
    8996:	cc c1       	rjmp	.+920    	; 0x8d30 <WebBuf2Field+0x55e>
    8998:	44 2d       	mov	r20, r4
    899a:	55 27       	eor	r21, r21
    899c:	47 fd       	sbrc	r20, 7
    899e:	50 95       	com	r21
    89a0:	65 2f       	mov	r22, r21
    89a2:	75 2f       	mov	r23, r21
    89a4:	f7 01       	movw	r30, r14
    89a6:	84 17       	cp	r24, r20
    89a8:	95 07       	cpc	r25, r21
    89aa:	a6 07       	cpc	r26, r22
    89ac:	b7 07       	cpc	r27, r23
    89ae:	08 f4       	brcc	.+2      	; 0x89b2 <WebBuf2Field+0x1e0>
    89b0:	9b c1       	rjmp	.+822    	; 0x8ce8 <WebBuf2Field+0x516>
    89b2:	80 83       	st	Z, r24
    89b4:	56 c2       	rjmp	.+1196   	; 0x8e62 <WebBuf2Field+0x690>
		break;
	case s_EE_Byte:
		WebPresicionHanler(Field, BufStr);
    89b6:	b8 01       	movw	r22, r16
    89b8:	c6 01       	movw	r24, r12
    89ba:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%hd", (short int*)&Temp) == 1){
    89be:	ce 01       	movw	r24, r28
    89c0:	05 96       	adiw	r24, 0x05	; 5
    89c2:	9f 93       	push	r25
    89c4:	8f 93       	push	r24
    89c6:	87 e9       	ldi	r24, 0x97	; 151
    89c8:	91 e0       	ldi	r25, 0x01	; 1
    89ca:	9f 93       	push	r25
    89cc:	8f 93       	push	r24
    89ce:	1f 93       	push	r17
    89d0:	0f 93       	push	r16
    89d2:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    89d6:	0f 90       	pop	r0
    89d8:	0f 90       	pop	r0
    89da:	0f 90       	pop	r0
    89dc:	0f 90       	pop	r0
    89de:	0f 90       	pop	r0
    89e0:	0f 90       	pop	r0
    89e2:	01 97       	sbiw	r24, 0x01	; 1
    89e4:	09 f0       	breq	.+2      	; 0x89e8 <WebBuf2Field+0x216>
    89e6:	3d c2       	rjmp	.+1146   	; 0x8e62 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int8_t, uint8_t, b);
    89e8:	6d 81       	ldd	r22, Y+5	; 0x05
    89ea:	86 16       	cp	r8, r22
    89ec:	14 f4       	brge	.+4      	; 0x89f2 <WebBuf2Field+0x220>
    89ee:	68 2d       	mov	r22, r8
    89f0:	82 c1       	rjmp	.+772    	; 0x8cf6 <WebBuf2Field+0x524>
    89f2:	64 15       	cp	r22, r4
    89f4:	0c f0       	brlt	.+2      	; 0x89f8 <WebBuf2Field+0x226>
    89f6:	7f c1       	rjmp	.+766    	; 0x8cf6 <WebBuf2Field+0x524>
    89f8:	7b c1       	rjmp	.+758    	; 0x8cf0 <WebBuf2Field+0x51e>
		}
		break;

	case Word: case z_Word:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    89fa:	b8 01       	movw	r22, r16
    89fc:	c6 01       	movw	r24, r12
    89fe:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		sscanf(BufStr,"%ud", (uint16_t*)&Temp);
    8a02:	ce 01       	movw	r24, r28
    8a04:	05 96       	adiw	r24, 0x05	; 5
    8a06:	9f 93       	push	r25
    8a08:	8f 93       	push	r24
    8a0a:	8b e9       	ldi	r24, 0x9B	; 155
    8a0c:	91 e0       	ldi	r25, 0x01	; 1
    8a0e:	9f 93       	push	r25
    8a10:	8f 93       	push	r24
    8a12:	1f 93       	push	r17
    8a14:	0f 93       	push	r16
    8a16:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		SetField(Temp, uint16_t);
    8a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    8a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    8a1e:	af 81       	ldd	r26, Y+7	; 0x07
    8a20:	b8 85       	ldd	r27, Y+8	; 0x08
    8a22:	0f 90       	pop	r0
    8a24:	0f 90       	pop	r0
    8a26:	0f 90       	pop	r0
    8a28:	0f 90       	pop	r0
    8a2a:	0f 90       	pop	r0
    8a2c:	0f 90       	pop	r0
    8a2e:	b5 01       	movw	r22, r10
    8a30:	a4 01       	movw	r20, r8
    8a32:	66 27       	eor	r22, r22
    8a34:	77 27       	eor	r23, r23
    8a36:	48 17       	cp	r20, r24
    8a38:	59 07       	cpc	r21, r25
    8a3a:	6a 07       	cpc	r22, r26
    8a3c:	7b 07       	cpc	r23, r27
    8a3e:	08 f4       	brcc	.+2      	; 0x8a42 <WebBuf2Field+0x270>
    8a40:	5b c0       	rjmp	.+182    	; 0x8af8 <WebBuf2Field+0x326>
    8a42:	b3 01       	movw	r22, r6
    8a44:	a2 01       	movw	r20, r4
    8a46:	66 27       	eor	r22, r22
    8a48:	77 27       	eor	r23, r23
    8a4a:	5f c0       	rjmp	.+190    	; 0x8b0a <WebBuf2Field+0x338>
		break;

	case EE_Word: case z_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8a4c:	b8 01       	movw	r22, r16
    8a4e:	c6 01       	movw	r24, r12
    8a50:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8a54:	ce 01       	movw	r24, r28
    8a56:	05 96       	adiw	r24, 0x05	; 5
    8a58:	9f 93       	push	r25
    8a5a:	8f 93       	push	r24
    8a5c:	8f e9       	ldi	r24, 0x9F	; 159
    8a5e:	91 e0       	ldi	r25, 0x01	; 1
    8a60:	9f 93       	push	r25
    8a62:	8f 93       	push	r24
    8a64:	1f 93       	push	r17
    8a66:	0f 93       	push	r16
    8a68:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    8a6c:	0f 90       	pop	r0
    8a6e:	0f 90       	pop	r0
    8a70:	0f 90       	pop	r0
    8a72:	0f 90       	pop	r0
    8a74:	0f 90       	pop	r0
    8a76:	0f 90       	pop	r0
    8a78:	01 97       	sbiw	r24, 0x01	; 1
    8a7a:	09 f0       	breq	.+2      	; 0x8a7e <WebBuf2Field+0x2ac>
    8a7c:	f2 c1       	rjmp	.+996    	; 0x8e62 <WebBuf2Field+0x690>
			SetEEField(Temp, uint16_t, uint16_t, w);
    8a7e:	6d 81       	ldd	r22, Y+5	; 0x05
    8a80:	7e 81       	ldd	r23, Y+6	; 0x06
    8a82:	8f 81       	ldd	r24, Y+7	; 0x07
    8a84:	98 85       	ldd	r25, Y+8	; 0x08
    8a86:	95 01       	movw	r18, r10
    8a88:	84 01       	movw	r16, r8
    8a8a:	22 27       	eor	r18, r18
    8a8c:	33 27       	eor	r19, r19
    8a8e:	06 17       	cp	r16, r22
    8a90:	17 07       	cpc	r17, r23
    8a92:	28 07       	cpc	r18, r24
    8a94:	39 07       	cpc	r19, r25
    8a96:	08 f4       	brcc	.+2      	; 0x8a9a <WebBuf2Field+0x2c8>
    8a98:	64 c0       	rjmp	.+200    	; 0x8b62 <WebBuf2Field+0x390>
    8a9a:	93 01       	movw	r18, r6
    8a9c:	82 01       	movw	r16, r4
    8a9e:	22 27       	eor	r18, r18
    8aa0:	33 27       	eor	r19, r19
    8aa2:	60 17       	cp	r22, r16
    8aa4:	71 07       	cpc	r23, r17
    8aa6:	82 07       	cpc	r24, r18
    8aa8:	93 07       	cpc	r25, r19
    8aaa:	08 f0       	brcs	.+2      	; 0x8aae <WebBuf2Field+0x2dc>
    8aac:	60 c0       	rjmp	.+192    	; 0x8b6e <WebBuf2Field+0x39c>
    8aae:	5e c0       	rjmp	.+188    	; 0x8b6c <WebBuf2Field+0x39a>
		}
		break;
	case s_Word:
		WebPresicionHanler(Field, BufStr);
    8ab0:	b8 01       	movw	r22, r16
    8ab2:	c6 01       	movw	r24, r12
    8ab4:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%d", (int16_t*)&Temp);
    8ab8:	ce 01       	movw	r24, r28
    8aba:	05 96       	adiw	r24, 0x05	; 5
    8abc:	9f 93       	push	r25
    8abe:	8f 93       	push	r24
    8ac0:	84 ea       	ldi	r24, 0xA4	; 164
    8ac2:	91 e0       	ldi	r25, 0x01	; 1
    8ac4:	9f 93       	push	r25
    8ac6:	8f 93       	push	r24
    8ac8:	1f 93       	push	r17
    8aca:	0f 93       	push	r16
    8acc:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		SetField(Temp, int16_t);
    8ad0:	8d 81       	ldd	r24, Y+5	; 0x05
    8ad2:	9e 81       	ldd	r25, Y+6	; 0x06
    8ad4:	af 81       	ldd	r26, Y+7	; 0x07
    8ad6:	b8 85       	ldd	r27, Y+8	; 0x08
    8ad8:	0f 90       	pop	r0
    8ada:	0f 90       	pop	r0
    8adc:	0f 90       	pop	r0
    8ade:	0f 90       	pop	r0
    8ae0:	0f 90       	pop	r0
    8ae2:	0f 90       	pop	r0
    8ae4:	a4 01       	movw	r20, r8
    8ae6:	66 27       	eor	r22, r22
    8ae8:	57 fd       	sbrc	r21, 7
    8aea:	60 95       	com	r22
    8aec:	76 2f       	mov	r23, r22
    8aee:	48 17       	cp	r20, r24
    8af0:	59 07       	cpc	r21, r25
    8af2:	6a 07       	cpc	r22, r26
    8af4:	7b 07       	cpc	r23, r27
    8af6:	20 f4       	brcc	.+8      	; 0x8b00 <WebBuf2Field+0x32e>
    8af8:	f7 01       	movw	r30, r14
    8afa:	91 82       	std	Z+1, r9	; 0x01
    8afc:	80 82       	st	Z, r8
    8afe:	b1 c1       	rjmp	.+866    	; 0x8e62 <WebBuf2Field+0x690>
    8b00:	a2 01       	movw	r20, r4
    8b02:	66 27       	eor	r22, r22
    8b04:	57 fd       	sbrc	r21, 7
    8b06:	60 95       	com	r22
    8b08:	76 2f       	mov	r23, r22
    8b0a:	f7 01       	movw	r30, r14
    8b0c:	84 17       	cp	r24, r20
    8b0e:	95 07       	cpc	r25, r21
    8b10:	a6 07       	cpc	r26, r22
    8b12:	b7 07       	cpc	r27, r23
    8b14:	18 f4       	brcc	.+6      	; 0x8b1c <WebBuf2Field+0x34a>
    8b16:	51 82       	std	Z+1, r5	; 0x01
    8b18:	40 82       	st	Z, r4
    8b1a:	a3 c1       	rjmp	.+838    	; 0x8e62 <WebBuf2Field+0x690>
    8b1c:	91 83       	std	Z+1, r25	; 0x01
    8b1e:	80 83       	st	Z, r24
    8b20:	a0 c1       	rjmp	.+832    	; 0x8e62 <WebBuf2Field+0x690>
		break;
	case s_EE_Word:
		WebPresicionHanler(Field, BufStr);
    8b22:	b8 01       	movw	r22, r16
    8b24:	c6 01       	movw	r24, r12
    8b26:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%d", (int16_t*)&Temp) == 1){
    8b2a:	ce 01       	movw	r24, r28
    8b2c:	05 96       	adiw	r24, 0x05	; 5
    8b2e:	9f 93       	push	r25
    8b30:	8f 93       	push	r24
    8b32:	84 ea       	ldi	r24, 0xA4	; 164
    8b34:	91 e0       	ldi	r25, 0x01	; 1
    8b36:	9f 93       	push	r25
    8b38:	8f 93       	push	r24
    8b3a:	1f 93       	push	r17
    8b3c:	0f 93       	push	r16
    8b3e:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    8b42:	0f 90       	pop	r0
    8b44:	0f 90       	pop	r0
    8b46:	0f 90       	pop	r0
    8b48:	0f 90       	pop	r0
    8b4a:	0f 90       	pop	r0
    8b4c:	0f 90       	pop	r0
    8b4e:	01 97       	sbiw	r24, 0x01	; 1
    8b50:	09 f0       	breq	.+2      	; 0x8b54 <WebBuf2Field+0x382>
    8b52:	87 c1       	rjmp	.+782    	; 0x8e62 <WebBuf2Field+0x690>
			WebSetEEField(Temp, int16_t, uint16_t, w);
    8b54:	6d 81       	ldd	r22, Y+5	; 0x05
    8b56:	7e 81       	ldd	r23, Y+6	; 0x06
    8b58:	8f 81       	ldd	r24, Y+7	; 0x07
    8b5a:	98 85       	ldd	r25, Y+8	; 0x08
    8b5c:	86 16       	cp	r8, r22
    8b5e:	97 06       	cpc	r9, r23
    8b60:	14 f4       	brge	.+4      	; 0x8b66 <WebBuf2Field+0x394>
    8b62:	b4 01       	movw	r22, r8
    8b64:	04 c0       	rjmp	.+8      	; 0x8b6e <WebBuf2Field+0x39c>
    8b66:	64 15       	cp	r22, r4
    8b68:	75 05       	cpc	r23, r5
    8b6a:	0c f4       	brge	.+2      	; 0x8b6e <WebBuf2Field+0x39c>
    8b6c:	b2 01       	movw	r22, r4
    8b6e:	c7 01       	movw	r24, r14
    8b70:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>
    8b74:	76 c1       	rjmp	.+748    	; 0x8e62 <WebBuf2Field+0x690>
			//ewb(Var, (uint16_t)Temp);
		}
		break;
	case c_Word: case zc_Word:
		*(uint16_t*)Var = F_Buf;
    8b76:	f7 01       	movw	r30, r14
    8b78:	11 82       	std	Z+1, r1	; 0x01
    8b7a:	10 82       	st	Z, r1
		break;
    8b7c:	72 c1       	rjmp	.+740    	; 0x8e62 <WebBuf2Field+0x690>



	case Longint: case z_Longint:
		//if(Limit_uByteVar(Temp)) sscanf(BufStr,"%ud", (unsigned short int*)&Temp);
		WebPresicionHanler(Field, BufStr);
    8b7e:	b8 01       	movw	r22, r16
    8b80:	c6 01       	movw	r24, r12
    8b82:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		sscanf(BufStr,"%lud", (uint32_t*)&Temp);
    8b86:	ce 01       	movw	r24, r28
    8b88:	05 96       	adiw	r24, 0x05	; 5
    8b8a:	9f 93       	push	r25
    8b8c:	8f 93       	push	r24
    8b8e:	8f e9       	ldi	r24, 0x9F	; 159
    8b90:	91 e0       	ldi	r25, 0x01	; 1
    8b92:	15 c0       	rjmp	.+42     	; 0x8bbe <WebBuf2Field+0x3ec>
		SetField(Temp, uint32_t);
		break;
	case EE_Longint: case z_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8b94:	b8 01       	movw	r22, r16
    8b96:	c6 01       	movw	r24, r12
    8b98:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%lud", (uint32_t*)&Temp) == 1){
    8b9c:	ce 01       	movw	r24, r28
    8b9e:	05 96       	adiw	r24, 0x05	; 5
    8ba0:	9f 93       	push	r25
    8ba2:	8f 93       	push	r24
    8ba4:	8f e9       	ldi	r24, 0x9F	; 159
    8ba6:	91 e0       	ldi	r25, 0x01	; 1
    8ba8:	3e c0       	rjmp	.+124    	; 0x8c26 <WebBuf2Field+0x454>
			SetEEField(Temp, uint32_t, uint32_t, d);
		}		
		break;
	case s_Longint:
		WebPresicionHanler(Field, BufStr);
    8baa:	b8 01       	movw	r22, r16
    8bac:	c6 01       	movw	r24, r12
    8bae:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		//if(Limit_sByteVar(Temp)) sscanf(BufStr,"%hd", (short int*)&Temp);
		sscanf(BufStr,"%ld", (int32_t*)&Temp);
    8bb2:	ce 01       	movw	r24, r28
    8bb4:	05 96       	adiw	r24, 0x05	; 5
    8bb6:	9f 93       	push	r25
    8bb8:	8f 93       	push	r24
    8bba:	87 ea       	ldi	r24, 0xA7	; 167
    8bbc:	91 e0       	ldi	r25, 0x01	; 1
    8bbe:	9f 93       	push	r25
    8bc0:	8f 93       	push	r24
    8bc2:	1f 93       	push	r17
    8bc4:	0f 93       	push	r16
    8bc6:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		SetField(Temp, int32_t);
    8bca:	8d 81       	ldd	r24, Y+5	; 0x05
    8bcc:	9e 81       	ldd	r25, Y+6	; 0x06
    8bce:	af 81       	ldd	r26, Y+7	; 0x07
    8bd0:	b8 85       	ldd	r27, Y+8	; 0x08
    8bd2:	0f 90       	pop	r0
    8bd4:	0f 90       	pop	r0
    8bd6:	0f 90       	pop	r0
    8bd8:	0f 90       	pop	r0
    8bda:	0f 90       	pop	r0
    8bdc:	0f 90       	pop	r0
    8bde:	f7 01       	movw	r30, r14
    8be0:	88 16       	cp	r8, r24
    8be2:	99 06       	cpc	r9, r25
    8be4:	aa 06       	cpc	r10, r26
    8be6:	bb 06       	cpc	r11, r27
    8be8:	28 f4       	brcc	.+10     	; 0x8bf4 <WebBuf2Field+0x422>
    8bea:	80 82       	st	Z, r8
    8bec:	91 82       	std	Z+1, r9	; 0x01
    8bee:	a2 82       	std	Z+2, r10	; 0x02
    8bf0:	b3 82       	std	Z+3, r11	; 0x03
    8bf2:	37 c1       	rjmp	.+622    	; 0x8e62 <WebBuf2Field+0x690>
    8bf4:	84 15       	cp	r24, r4
    8bf6:	95 05       	cpc	r25, r5
    8bf8:	a6 05       	cpc	r26, r6
    8bfa:	b7 05       	cpc	r27, r7
    8bfc:	28 f4       	brcc	.+10     	; 0x8c08 <WebBuf2Field+0x436>
    8bfe:	40 82       	st	Z, r4
    8c00:	51 82       	std	Z+1, r5	; 0x01
    8c02:	62 82       	std	Z+2, r6	; 0x02
    8c04:	73 82       	std	Z+3, r7	; 0x03
    8c06:	2d c1       	rjmp	.+602    	; 0x8e62 <WebBuf2Field+0x690>
    8c08:	80 83       	st	Z, r24
    8c0a:	91 83       	std	Z+1, r25	; 0x01
    8c0c:	a2 83       	std	Z+2, r26	; 0x02
    8c0e:	b3 83       	std	Z+3, r27	; 0x03
    8c10:	28 c1       	rjmp	.+592    	; 0x8e62 <WebBuf2Field+0x690>
		break;
	case s_EE_Longint:
		WebPresicionHanler(Field, BufStr);
    8c12:	b8 01       	movw	r22, r16
    8c14:	c6 01       	movw	r24, r12
    8c16:	0e 94 ac 43 	call	0x8758	; 0x8758 <WebPresicionHanler>
		if(sscanf(BufStr,"%ld", (int32_t*)&Temp) == 1){
    8c1a:	ce 01       	movw	r24, r28
    8c1c:	05 96       	adiw	r24, 0x05	; 5
    8c1e:	9f 93       	push	r25
    8c20:	8f 93       	push	r24
    8c22:	87 ea       	ldi	r24, 0xA7	; 167
    8c24:	91 e0       	ldi	r25, 0x01	; 1
    8c26:	9f 93       	push	r25
    8c28:	8f 93       	push	r24
    8c2a:	1f 93       	push	r17
    8c2c:	0f 93       	push	r16
    8c2e:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    8c32:	0f 90       	pop	r0
    8c34:	0f 90       	pop	r0
    8c36:	0f 90       	pop	r0
    8c38:	0f 90       	pop	r0
    8c3a:	0f 90       	pop	r0
    8c3c:	0f 90       	pop	r0
    8c3e:	01 97       	sbiw	r24, 0x01	; 1
    8c40:	09 f0       	breq	.+2      	; 0x8c44 <WebBuf2Field+0x472>
    8c42:	0f c1       	rjmp	.+542    	; 0x8e62 <WebBuf2Field+0x690>
			SetEEField(Temp, int32_t, uint32_t, d);
    8c44:	4d 81       	ldd	r20, Y+5	; 0x05
    8c46:	5e 81       	ldd	r21, Y+6	; 0x06
    8c48:	6f 81       	ldd	r22, Y+7	; 0x07
    8c4a:	78 85       	ldd	r23, Y+8	; 0x08
    8c4c:	84 16       	cp	r8, r20
    8c4e:	95 06       	cpc	r9, r21
    8c50:	a6 06       	cpc	r10, r22
    8c52:	b7 06       	cpc	r11, r23
    8c54:	18 f4       	brcc	.+6      	; 0x8c5c <WebBuf2Field+0x48a>
    8c56:	b5 01       	movw	r22, r10
    8c58:	a4 01       	movw	r20, r8
    8c5a:	07 c0       	rjmp	.+14     	; 0x8c6a <WebBuf2Field+0x498>
    8c5c:	44 15       	cp	r20, r4
    8c5e:	55 05       	cpc	r21, r5
    8c60:	66 05       	cpc	r22, r6
    8c62:	77 05       	cpc	r23, r7
    8c64:	10 f4       	brcc	.+4      	; 0x8c6a <WebBuf2Field+0x498>
    8c66:	b3 01       	movw	r22, r6
    8c68:	a2 01       	movw	r20, r4
    8c6a:	c7 01       	movw	r24, r14
    8c6c:	0e 94 d9 29 	call	0x53b2	; 0x53b2 <ewd>
    8c70:	f8 c0       	rjmp	.+496    	; 0x8e62 <WebBuf2Field+0x690>
		break;



	case FFloat: case GFloat:
		sscanf(BufStr,"%f", &fTemp);
    8c72:	ce 01       	movw	r24, r28
    8c74:	01 96       	adiw	r24, 0x01	; 1
    8c76:	9f 93       	push	r25
    8c78:	8f 93       	push	r24
    8c7a:	8b ea       	ldi	r24, 0xAB	; 171
    8c7c:	91 e0       	ldi	r25, 0x01	; 1
    8c7e:	9f 93       	push	r25
    8c80:	8f 93       	push	r24
    8c82:	1f 93       	push	r17
    8c84:	0f 93       	push	r16
    8c86:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		*(float*)Var = fTemp;
    8c8a:	89 81       	ldd	r24, Y+1	; 0x01
    8c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    8c8e:	ab 81       	ldd	r26, Y+3	; 0x03
    8c90:	bc 81       	ldd	r27, Y+4	; 0x04
    8c92:	f7 01       	movw	r30, r14
    8c94:	80 83       	st	Z, r24
    8c96:	91 83       	std	Z+1, r25	; 0x01
    8c98:	a2 83       	std	Z+2, r26	; 0x02
    8c9a:	b3 83       	std	Z+3, r27	; 0x03
		break;
    8c9c:	0f 90       	pop	r0
    8c9e:	0f 90       	pop	r0
    8ca0:	0f 90       	pop	r0
    8ca2:	0f 90       	pop	r0
    8ca4:	0f 90       	pop	r0
    8ca6:	0f 90       	pop	r0
    8ca8:	dc c0       	rjmp	.+440    	; 0x8e62 <WebBuf2Field+0x690>
	case EE_FFloat: case EE_GFloat:
		if(sscanf(BufStr,"%f", &fTemp) == 1){
    8caa:	9e 01       	movw	r18, r28
    8cac:	2f 5f       	subi	r18, 0xFF	; 255
    8cae:	3f 4f       	sbci	r19, 0xFF	; 255
    8cb0:	59 01       	movw	r10, r18
    8cb2:	bf 92       	push	r11
    8cb4:	2f 93       	push	r18
    8cb6:	8b ea       	ldi	r24, 0xAB	; 171
    8cb8:	91 e0       	ldi	r25, 0x01	; 1
    8cba:	9f 93       	push	r25
    8cbc:	8f 93       	push	r24
    8cbe:	1f 93       	push	r17
    8cc0:	0f 93       	push	r16
    8cc2:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
    8cc6:	0f 90       	pop	r0
    8cc8:	0f 90       	pop	r0
    8cca:	0f 90       	pop	r0
    8ccc:	0f 90       	pop	r0
    8cce:	0f 90       	pop	r0
    8cd0:	0f 90       	pop	r0
    8cd2:	01 97       	sbiw	r24, 0x01	; 1
    8cd4:	09 f0       	breq	.+2      	; 0x8cd8 <WebBuf2Field+0x506>
    8cd6:	c5 c0       	rjmp	.+394    	; 0x8e62 <WebBuf2Field+0x690>
			ewbl(&fTemp, (float*)Var, 4);
    8cd8:	44 e0       	ldi	r20, 0x04	; 4
    8cda:	50 e0       	ldi	r21, 0x00	; 0
    8cdc:	b7 01       	movw	r22, r14
    8cde:	c5 01       	movw	r24, r10
    8ce0:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
    8ce4:	be c0       	rjmp	.+380    	; 0x8e62 <WebBuf2Field+0x690>
		}
		break;


	case Enum:
		SetField(F_Buf, uint8_t);
    8ce6:	f7 01       	movw	r30, r14
    8ce8:	40 82       	st	Z, r4
    8cea:	bb c0       	rjmp	.+374    	; 0x8e62 <WebBuf2Field+0x690>
		break;
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
    8cec:	44 20       	and	r4, r4
    8cee:	11 f0       	breq	.+4      	; 0x8cf4 <WebBuf2Field+0x522>
    8cf0:	64 2d       	mov	r22, r4
    8cf2:	01 c0       	rjmp	.+2      	; 0x8cf6 <WebBuf2Field+0x524>
    8cf4:	60 e0       	ldi	r22, 0x00	; 0
    8cf6:	c7 01       	movw	r24, r14
    8cf8:	43 c0       	rjmp	.+134    	; 0x8d80 <WebBuf2Field+0x5ae>
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8cfa:	ce 01       	movw	r24, r28
    8cfc:	05 96       	adiw	r24, 0x05	; 5
    8cfe:	9f 93       	push	r25
    8d00:	8f 93       	push	r24
    8d02:	82 e9       	ldi	r24, 0x92	; 146
    8d04:	91 e0       	ldi	r25, 0x01	; 1
    8d06:	9f 93       	push	r25
    8d08:	8f 93       	push	r24
    8d0a:	1f 93       	push	r17
    8d0c:	0f 93       	push	r16
    8d0e:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
		if((unsigned short int)Temp)
    8d12:	0f 90       	pop	r0
    8d14:	0f 90       	pop	r0
    8d16:	0f 90       	pop	r0
    8d18:	0f 90       	pop	r0
    8d1a:	0f 90       	pop	r0
    8d1c:	0f 90       	pop	r0
    8d1e:	8d 81       	ldd	r24, Y+5	; 0x05
    8d20:	9e 81       	ldd	r25, Y+6	; 0x06
    8d22:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d24:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d26:	20 81       	ld	r18, Z
			*BitVar |=Mask;
    8d28:	89 84       	ldd	r8, Y+9	; 0x09
	case EE_Enum:
		SetEEField(F_Buf, uint8_t, uint8_t, b);
		break;
	case Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
		if((unsigned short int)Temp)
    8d2a:	89 2b       	or	r24, r25
    8d2c:	19 f0       	breq	.+6      	; 0x8d34 <WebBuf2Field+0x562>
			*BitVar |=Mask;
    8d2e:	82 2a       	or	r8, r18
    8d30:	80 82       	st	Z, r8
    8d32:	97 c0       	rjmp	.+302    	; 0x8e62 <WebBuf2Field+0x690>
		else
			*BitVar &=~Mask;
    8d34:	80 94       	com	r8
    8d36:	82 22       	and	r8, r18
    8d38:	eb 85       	ldd	r30, Y+11	; 0x0b
    8d3a:	fc 85       	ldd	r31, Y+12	; 0x0c
    8d3c:	f9 cf       	rjmp	.-14     	; 0x8d30 <WebBuf2Field+0x55e>
		break;
	case EE_Bit:
		sscanf(BufStr,"%hud", (unsigned short int*)&Temp);	// 0 -,  
    8d3e:	ce 01       	movw	r24, r28
    8d40:	05 96       	adiw	r24, 0x05	; 5
    8d42:	9f 93       	push	r25
    8d44:	8f 93       	push	r24
    8d46:	82 e9       	ldi	r24, 0x92	; 146
    8d48:	91 e0       	ldi	r25, 0x01	; 1
    8d4a:	9f 93       	push	r25
    8d4c:	8f 93       	push	r24
    8d4e:	1f 93       	push	r17
    8d50:	0f 93       	push	r16
    8d52:	0e 94 4d 6d 	call	0xda9a	; 0xda9a <sscanf>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8d56:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d58:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d5a:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		EE_BitVar=erb(BitVar);
		ewb(BitVar, (unsigned short int)Temp ? EE_BitVar |Mask : EE_BitVar &~Mask);
    8d5e:	0f 90       	pop	r0
    8d60:	0f 90       	pop	r0
    8d62:	0f 90       	pop	r0
    8d64:	0f 90       	pop	r0
    8d66:	0f 90       	pop	r0
    8d68:	0f 90       	pop	r0
    8d6a:	2d 81       	ldd	r18, Y+5	; 0x05
    8d6c:	3e 81       	ldd	r19, Y+6	; 0x06
    8d6e:	69 85       	ldd	r22, Y+9	; 0x09
    8d70:	23 2b       	or	r18, r19
    8d72:	11 f0       	breq	.+4      	; 0x8d78 <WebBuf2Field+0x5a6>
    8d74:	68 2b       	or	r22, r24
    8d76:	02 c0       	rjmp	.+4      	; 0x8d7c <WebBuf2Field+0x5aa>
    8d78:	60 95       	com	r22
    8d7a:	68 23       	and	r22, r24
    8d7c:	8b 85       	ldd	r24, Y+11	; 0x0b
    8d7e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8d80:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
		break;
    8d84:	6e c0       	rjmp	.+220    	; 0x8e62 <WebBuf2Field+0x690>
    8d86:	ad b6       	in	r10, 0x3d	; 61
    8d88:	be b6       	in	r11, 0x3e	; 62

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8d8a:	f1 01       	movw	r30, r2
    8d8c:	24 90       	lpm	r2, Z


	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8d8e:	31 2c       	mov	r3, r1
    8d90:	2d b7       	in	r18, 0x3d	; 61
    8d92:	3e b7       	in	r19, 0x3e	; 62
    8d94:	22 19       	sub	r18, r2
    8d96:	33 09       	sbc	r19, r3
    8d98:	0f b6       	in	r0, 0x3f	; 63
    8d9a:	f8 94       	cli
    8d9c:	3e bf       	out	0x3e, r19	; 62
    8d9e:	0f be       	out	0x3f, r0	; 63
    8da0:	2d bf       	out	0x3d, r18	; 61
    8da2:	6d b7       	in	r22, 0x3d	; 61
    8da4:	7e b7       	in	r23, 0x3e	; 62
    8da6:	6f 5f       	subi	r22, 0xFF	; 255
    8da8:	7f 4f       	sbci	r23, 0xFF	; 255
		uint8_t i=0;
    8daa:	90 e0       	ldi	r25, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dac:	31 e0       	ldi	r19, 0x01	; 1
    8dae:	23 1a       	sub	r2, r19
    8db0:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8db2:	20 e2       	ldi	r18, 0x20	; 32
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8db4:	49 2f       	mov	r20, r25
    8db6:	50 e0       	ldi	r21, 0x00	; 0
    8db8:	fb 01       	movw	r30, r22
    8dba:	e4 0f       	add	r30, r20
    8dbc:	f5 1f       	adc	r31, r21
    8dbe:	42 15       	cp	r20, r2
    8dc0:	53 05       	cpc	r21, r3
    8dc2:	3c f0       	brlt	.+14     	; 0x8dd2 <WebBuf2Field+0x600>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8dc4:	10 82       	st	Z, r1
		memcpy(Var, TempStr, i+1);
    8dc6:	4f 5f       	subi	r20, 0xFF	; 255
    8dc8:	5f 4f       	sbci	r21, 0xFF	; 255
    8dca:	c7 01       	movw	r24, r14
    8dcc:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
    8dd0:	33 c0       	rjmp	.+102    	; 0x8e38 <WebBuf2Field+0x666>
	case Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8dd2:	d8 01       	movw	r26, r16
    8dd4:	a4 0f       	add	r26, r20
    8dd6:	b5 1f       	adc	r27, r21
    8dd8:	8c 91       	ld	r24, X
    8dda:	80 32       	cpi	r24, 0x20	; 32
    8ddc:	99 f3       	breq	.-26     	; 0x8dc4 <WebBuf2Field+0x5f2>
    8dde:	86 32       	cpi	r24, 0x26	; 38
    8de0:	89 f3       	breq	.-30     	; 0x8dc4 <WebBuf2Field+0x5f2>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8de2:	8b 32       	cpi	r24, 0x2B	; 43
    8de4:	11 f4       	brne	.+4      	; 0x8dea <WebBuf2Field+0x618>
    8de6:	20 83       	st	Z, r18
    8de8:	01 c0       	rjmp	.+2      	; 0x8dec <WebBuf2Field+0x61a>
			else TempStr[i]=BufStr[i];
    8dea:	80 83       	st	Z, r24
			i++;
    8dec:	9f 5f       	subi	r25, 0xFF	; 255
    8dee:	e2 cf       	rjmp	.-60     	; 0x8db4 <WebBuf2Field+0x5e2>
    8df0:	ad b6       	in	r10, 0x3d	; 61
    8df2:	be b6       	in	r11, 0x3e	; 62
    8df4:	f1 01       	movw	r30, r2
    8df6:	24 90       	lpm	r2, Z

		break;
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
    8df8:	31 2c       	mov	r3, r1
    8dfa:	2d b7       	in	r18, 0x3d	; 61
    8dfc:	3e b7       	in	r19, 0x3e	; 62
    8dfe:	22 19       	sub	r18, r2
    8e00:	33 09       	sbc	r19, r3
    8e02:	0f b6       	in	r0, 0x3f	; 63
    8e04:	f8 94       	cli
    8e06:	3e bf       	out	0x3e, r19	; 62
    8e08:	0f be       	out	0x3f, r0	; 63
    8e0a:	2d bf       	out	0x3d, r18	; 61
    8e0c:	8d b7       	in	r24, 0x3d	; 61
    8e0e:	9e b7       	in	r25, 0x3e	; 62
    8e10:	01 96       	adiw	r24, 0x01	; 1
		uint8_t i=0;
    8e12:	30 e0       	ldi	r19, 0x00	; 0
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e14:	e1 e0       	ldi	r30, 0x01	; 1
    8e16:	2e 1a       	sub	r2, r30
    8e18:	31 08       	sbc	r3, r1
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e1a:	60 e2       	ldi	r22, 0x20	; 32
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e1c:	43 2f       	mov	r20, r19
    8e1e:	50 e0       	ldi	r21, 0x00	; 0
    8e20:	fc 01       	movw	r30, r24
    8e22:	e4 0f       	add	r30, r20
    8e24:	f5 1f       	adc	r31, r21
    8e26:	42 15       	cp	r20, r2
    8e28:	53 05       	cpc	r21, r3
    8e2a:	64 f0       	brlt	.+24     	; 0x8e44 <WebBuf2Field+0x672>
			if(BufStr[i] == '+') TempStr[i]=' ';
			else TempStr[i]=BufStr[i];
			i++;
		}
		TempStr[i] = '\0';
    8e2c:	10 82       	st	Z, r1
		ewbl(TempStr, Var, i+1);
    8e2e:	4f 5f       	subi	r20, 0xFF	; 255
    8e30:	5f 4f       	sbci	r21, 0xFF	; 255
    8e32:	b7 01       	movw	r22, r14
    8e34:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
    8e38:	0f b6       	in	r0, 0x3f	; 63
    8e3a:	f8 94       	cli
    8e3c:	be be       	out	0x3e, r11	; 62
    8e3e:	0f be       	out	0x3f, r0	; 63
    8e40:	ad be       	out	0x3d, r10	; 61
		}
		break;
    8e42:	0f c0       	rjmp	.+30     	; 0x8e62 <WebBuf2Field+0x690>
	case EE_Text:{
		//     prb(&Field->Prec)
		uint8_t Width = prb(&Field->Prec);
		char TempStr[Width];
		uint8_t i=0;
		while( (i<Width-1)&&(BufStr[i]!=' ')&&(BufStr[i]!='&') ){
    8e44:	d8 01       	movw	r26, r16
    8e46:	a4 0f       	add	r26, r20
    8e48:	b5 1f       	adc	r27, r21
    8e4a:	2c 91       	ld	r18, X
    8e4c:	20 32       	cpi	r18, 0x20	; 32
    8e4e:	71 f3       	breq	.-36     	; 0x8e2c <WebBuf2Field+0x65a>
    8e50:	26 32       	cpi	r18, 0x26	; 38
    8e52:	61 f3       	breq	.-40     	; 0x8e2c <WebBuf2Field+0x65a>
			if(BufStr[i] == '+') TempStr[i]=' ';
    8e54:	2b 32       	cpi	r18, 0x2B	; 43
    8e56:	11 f4       	brne	.+4      	; 0x8e5c <WebBuf2Field+0x68a>
    8e58:	60 83       	st	Z, r22
    8e5a:	01 c0       	rjmp	.+2      	; 0x8e5e <WebBuf2Field+0x68c>
			else TempStr[i]=BufStr[i];
    8e5c:	20 83       	st	Z, r18
			i++;
    8e5e:	3f 5f       	subi	r19, 0xFF	; 255
    8e60:	dd cf       	rjmp	.-70     	; 0x8e1c <WebBuf2Field+0x64a>
		ewbl(TempStr, Var, i+1);
		}
		break;
	}

	EventFunc(&Field->Act);
    8e62:	fb e0       	ldi	r31, 0x0B	; 11
    8e64:	cf 0e       	add	r12, r31
    8e66:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    8e68:	f6 01       	movw	r30, r12
    8e6a:	85 91       	lpm	r24, Z+
    8e6c:	94 91       	lpm	r25, Z
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static void
EventFunc(const MenuEvent *Event)
{
	MenuEvent Func = prp(Event);
	if (Func)
    8e6e:	00 97       	sbiw	r24, 0x00	; 0
    8e70:	11 f0       	breq	.+4      	; 0x8e76 <WebBuf2Field+0x6a4>
		Func();
    8e72:	fc 01       	movw	r30, r24
    8e74:	09 95       	icall
}
    8e76:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e78:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e7a:	0f b6       	in	r0, 0x3f	; 63
    8e7c:	f8 94       	cli
    8e7e:	3e bf       	out	0x3e, r19	; 62
    8e80:	0f be       	out	0x3f, r0	; 63
    8e82:	2d bf       	out	0x3d, r18	; 61
    8e84:	2e 96       	adiw	r28, 0x0e	; 14
    8e86:	0f b6       	in	r0, 0x3f	; 63
    8e88:	f8 94       	cli
    8e8a:	de bf       	out	0x3e, r29	; 62
    8e8c:	0f be       	out	0x3f, r0	; 63
    8e8e:	cd bf       	out	0x3d, r28	; 61
    8e90:	df 91       	pop	r29
    8e92:	cf 91       	pop	r28
    8e94:	1f 91       	pop	r17
    8e96:	0f 91       	pop	r16
    8e98:	ff 90       	pop	r15
    8e9a:	ef 90       	pop	r14
    8e9c:	df 90       	pop	r13
    8e9e:	cf 90       	pop	r12
    8ea0:	bf 90       	pop	r11
    8ea2:	af 90       	pop	r10
    8ea4:	9f 90       	pop	r9
    8ea6:	8f 90       	pop	r8
    8ea8:	7f 90       	pop	r7
    8eaa:	6f 90       	pop	r6
    8eac:	5f 90       	pop	r5
    8eae:	4f 90       	pop	r4
    8eb0:	3f 90       	pop	r3
    8eb2:	2f 90       	pop	r2
    8eb4:	08 95       	ret

00008eb6 <strcmp_PP>:

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    8eb6:	fc 01       	movw	r30, r24
    8eb8:	24 91       	lpm	r18, Z
// ~~~~~~~~~~~~~~~~~~
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
    8eba:	22 23       	and	r18, r18
    8ebc:	c1 f0       	breq	.+48     	; 0x8eee <strcmp_PP+0x38>
    8ebe:	fb 01       	movw	r30, r22
    8ec0:	24 91       	lpm	r18, Z
    8ec2:	22 23       	and	r18, r18
    8ec4:	a1 f0       	breq	.+40     	; 0x8eee <strcmp_PP+0x38>
    8ec6:	fc 01       	movw	r30, r24
    8ec8:	24 91       	lpm	r18, Z
    8eca:	fb 01       	movw	r30, r22
    8ecc:	34 91       	lpm	r19, Z
		if(prb(s1) > prb(s2)) return 1;
    8ece:	32 17       	cp	r19, r18
    8ed0:	50 f0       	brcs	.+20     	; 0x8ee6 <strcmp_PP+0x30>
    8ed2:	fc 01       	movw	r30, r24
    8ed4:	24 91       	lpm	r18, Z
    8ed6:	fb 01       	movw	r30, r22
    8ed8:	34 91       	lpm	r19, Z
		if(prb(s1) < prb(s2)) return -1;
    8eda:	23 17       	cp	r18, r19
    8edc:	30 f0       	brcs	.+12     	; 0x8eea <strcmp_PP+0x34>
		s1++;
    8ede:	01 96       	adiw	r24, 0x01	; 1
		s2++;
    8ee0:	6f 5f       	subi	r22, 0xFF	; 255
    8ee2:	7f 4f       	sbci	r23, 0xFF	; 255
    8ee4:	e8 cf       	rjmp	.-48     	; 0x8eb6 <strcmp_PP>
//    PROGMEM,    0
uint8_t strcmp_PP(const prog_char *S1, const prog_char *S2){
	prog_uint8_t* s1 = (prog_uint8_t*)S1;
	prog_uint8_t* s2 = (prog_uint8_t*)S2;
	while(prb(s1) && prb(s2)){
		if(prb(s1) > prb(s2)) return 1;
    8ee6:	81 e0       	ldi	r24, 0x01	; 1
    8ee8:	08 95       	ret
		if(prb(s1) < prb(s2)) return -1;
    8eea:	8f ef       	ldi	r24, 0xFF	; 255
    8eec:	08 95       	ret
		s1++;
		s2++;
	}
	return 0;	
    8eee:	80 e0       	ldi	r24, 0x00	; 0
}
    8ef0:	08 95       	ret

00008ef2 <strcmp_E>:
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
    8ef2:	ff 92       	push	r15
    8ef4:	0f 93       	push	r16
    8ef6:	1f 93       	push	r17
    8ef8:	cf 93       	push	r28
    8efa:	df 93       	push	r29
    8efc:	eb 01       	movw	r28, r22
    8efe:	8c 01       	movw	r16, r24
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8f00:	f8 01       	movw	r30, r16
    8f02:	f1 90       	ld	r15, Z+
    8f04:	8f 01       	movw	r16, r30
    8f06:	ff 20       	and	r15, r15
    8f08:	49 f0       	breq	.+18     	; 0x8f1c <strcmp_E+0x2a>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    8f0a:	ce 01       	movw	r24, r28
    8f0c:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8f10:	8f 15       	cp	r24, r15
    8f12:	50 f0       	brcs	.+20     	; 0x8f28 <strcmp_E+0x36>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8f14:	f8 16       	cp	r15, r24
    8f16:	50 f0       	brcs	.+20     	; 0x8f2c <strcmp_E+0x3a>
		str_RAM++;
		str_EE++;		
    8f18:	21 96       	adiw	r28, 0x01	; 1
    8f1a:	f2 cf       	rjmp	.-28     	; 0x8f00 <strcmp_E+0xe>
    8f1c:	ce 01       	movw	r24, r28
    8f1e:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	return 0;	
}
// ~~~~~~~~~~~
//    RAM    EEP,    0
uint8_t strcmp_E(char* str_RAM, char* str_EE){
	while(*str_RAM || erb((uint8_t*)str_EE)){
    8f22:	81 11       	cpse	r24, r1
    8f24:	f2 cf       	rjmp	.-28     	; 0x8f0a <strcmp_E+0x18>
    8f26:	03 c0       	rjmp	.+6      	; 0x8f2e <strcmp_E+0x3c>
		if(*str_RAM > erb((uint8_t*)str_EE)) return 1;
    8f28:	81 e0       	ldi	r24, 0x01	; 1
    8f2a:	01 c0       	rjmp	.+2      	; 0x8f2e <strcmp_E+0x3c>
		if(*str_RAM < erb((uint8_t*)str_EE)) return -1;
    8f2c:	8f ef       	ldi	r24, 0xFF	; 255
		str_RAM++;
		str_EE++;		
	}
	return 0;
}
    8f2e:	df 91       	pop	r29
    8f30:	cf 91       	pop	r28
    8f32:	1f 91       	pop	r17
    8f34:	0f 91       	pop	r16
    8f36:	ff 90       	pop	r15
    8f38:	08 95       	ret

00008f3a <SeekTagFORM>:
// ~~~~~~~~~~~
// 
// <form action='/' method='GET'>  :  
uint8_t SeekTagFORM(char ch){
	static uint8_t match;
	switch(match) {
    8f3a:	40 91 43 02 	lds	r20, 0x0243
    8f3e:	50 e0       	ldi	r21, 0x00	; 0
    8f40:	49 30       	cpi	r20, 0x09	; 9
    8f42:	51 05       	cpc	r21, r1
    8f44:	88 f5       	brcc	.+98     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f46:	fa 01       	movw	r30, r20
    8f48:	e7 57       	subi	r30, 0x77	; 119
    8f4a:	ff 4f       	sbci	r31, 0xFF	; 255
    8f4c:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8f50:	8c 33       	cpi	r24, 0x3C	; 60
    8f52:	61 f5       	brne	.+88     	; 0x8fac <SeekTagFORM+0x72>
    8f54:	81 e0       	ldi	r24, 0x01	; 1
    8f56:	1f c0       	rjmp	.+62     	; 0x8f96 <SeekTagFORM+0x5c>
			break;
		case 1:
			if(ch=='F' || ch=='f') match = 2;
    8f58:	8f 7d       	andi	r24, 0xDF	; 223
    8f5a:	86 34       	cpi	r24, 0x46	; 70
    8f5c:	29 f5       	brne	.+74     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f5e:	82 e0       	ldi	r24, 0x02	; 2
    8f60:	1a c0       	rjmp	.+52     	; 0x8f96 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 2:
			if(ch=='O' || ch=='o') match = 3;
    8f62:	8f 7d       	andi	r24, 0xDF	; 223
    8f64:	8f 34       	cpi	r24, 0x4F	; 79
    8f66:	01 f5       	brne	.+64     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f68:	83 e0       	ldi	r24, 0x03	; 3
    8f6a:	15 c0       	rjmp	.+42     	; 0x8f96 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 3:
			if(ch=='R' || ch=='r') match = 4;
    8f6c:	8f 7d       	andi	r24, 0xDF	; 223
    8f6e:	82 35       	cpi	r24, 0x52	; 82
    8f70:	d9 f4       	brne	.+54     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f72:	84 e0       	ldi	r24, 0x04	; 4
    8f74:	10 c0       	rjmp	.+32     	; 0x8f96 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 4:
			if(ch=='M' || ch=='m') match = 5;
    8f76:	8f 7d       	andi	r24, 0xDF	; 223
    8f78:	8d 34       	cpi	r24, 0x4D	; 77
    8f7a:	b1 f4       	brne	.+44     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f7c:	85 e0       	ldi	r24, 0x05	; 5
    8f7e:	0b c0       	rjmp	.+22     	; 0x8f96 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		case 5:
			if(ch==' ') match = 6;
    8f80:	80 32       	cpi	r24, 0x20	; 32
    8f82:	91 f4       	brne	.+36     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f84:	86 e0       	ldi	r24, 0x06	; 6
    8f86:	07 c0       	rjmp	.+14     	; 0x8f96 <SeekTagFORM+0x5c>
			else match = 0;
			break;
		//-----
		case 6:
			if(ch=='>') match = 7;
    8f88:	8e 33       	cpi	r24, 0x3E	; 62
    8f8a:	81 f4       	brne	.+32     	; 0x8fac <SeekTagFORM+0x72>
    8f8c:	87 e0       	ldi	r24, 0x07	; 7
    8f8e:	03 c0       	rjmp	.+6      	; 0x8f96 <SeekTagFORM+0x5c>
			break;
		case 7:
			if(ch=='\r') match = 8;
    8f90:	8d 30       	cpi	r24, 0x0D	; 13
    8f92:	51 f4       	brne	.+20     	; 0x8fa8 <SeekTagFORM+0x6e>
    8f94:	88 e0       	ldi	r24, 0x08	; 8
    8f96:	80 93 43 02 	sts	0x0243, r24
    8f9a:	08 c0       	rjmp	.+16     	; 0x8fac <SeekTagFORM+0x72>
			else match = 0;
			break;
		case 8:
			match = 0;
    8f9c:	10 92 43 02 	sts	0x0243, r1
			if(ch=='\n') return 1;
    8fa0:	91 e0       	ldi	r25, 0x01	; 1
    8fa2:	8a 30       	cpi	r24, 0x0A	; 10
    8fa4:	19 f4       	brne	.+6      	; 0x8fac <SeekTagFORM+0x72>
    8fa6:	03 c0       	rjmp	.+6      	; 0x8fae <SeekTagFORM+0x74>
			break;
		default:
			match = 0;
    8fa8:	10 92 43 02 	sts	0x0243, r1
	}
	return 0;
    8fac:	90 e0       	ldi	r25, 0x00	; 0

}
    8fae:	89 2f       	mov	r24, r25
    8fb0:	08 95       	ret

00008fb2 <SeekTagA_HREF>:
uint8_t SeekTagA_HREF(char ch){
	static uint8_t match;
	switch(match) {
    8fb2:	40 91 42 02 	lds	r20, 0x0242
    8fb6:	50 e0       	ldi	r21, 0x00	; 0
    8fb8:	49 30       	cpi	r20, 0x09	; 9
    8fba:	51 05       	cpc	r21, r1
    8fbc:	90 f5       	brcc	.+100    	; 0x9022 <SeekTagA_HREF+0x70>
    8fbe:	fa 01       	movw	r30, r20
    8fc0:	ee 56       	subi	r30, 0x6E	; 110
    8fc2:	ff 4f       	sbci	r31, 0xFF	; 255
    8fc4:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    8fc8:	8c 33       	cpi	r24, 0x3C	; 60
    8fca:	69 f5       	brne	.+90     	; 0x9026 <SeekTagA_HREF+0x74>
    8fcc:	81 e0       	ldi	r24, 0x01	; 1
    8fce:	20 c0       	rjmp	.+64     	; 0x9010 <SeekTagA_HREF+0x5e>
			break;
		case 1:
			if(ch=='A' || ch=='a') match = 2;
    8fd0:	8f 7d       	andi	r24, 0xDF	; 223
    8fd2:	81 34       	cpi	r24, 0x41	; 65
    8fd4:	31 f5       	brne	.+76     	; 0x9022 <SeekTagA_HREF+0x70>
    8fd6:	82 e0       	ldi	r24, 0x02	; 2
    8fd8:	1b c0       	rjmp	.+54     	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 2:
			if(ch==' ') match = 3;
    8fda:	80 32       	cpi	r24, 0x20	; 32
    8fdc:	11 f5       	brne	.+68     	; 0x9022 <SeekTagA_HREF+0x70>
    8fde:	83 e0       	ldi	r24, 0x03	; 3
    8fe0:	17 c0       	rjmp	.+46     	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 3:
			if(ch=='H' || ch=='h') match = 4;
    8fe2:	8f 7d       	andi	r24, 0xDF	; 223
    8fe4:	88 34       	cpi	r24, 0x48	; 72
    8fe6:	e9 f4       	brne	.+58     	; 0x9022 <SeekTagA_HREF+0x70>
    8fe8:	84 e0       	ldi	r24, 0x04	; 4
    8fea:	12 c0       	rjmp	.+36     	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 4:
			if(ch=='R' || ch=='r') match = 5;
    8fec:	8f 7d       	andi	r24, 0xDF	; 223
    8fee:	82 35       	cpi	r24, 0x52	; 82
    8ff0:	c1 f4       	brne	.+48     	; 0x9022 <SeekTagA_HREF+0x70>
    8ff2:	85 e0       	ldi	r24, 0x05	; 5
    8ff4:	0d c0       	rjmp	.+26     	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 5:
			if(ch=='E' || ch=='e') match = 6;
    8ff6:	8f 7d       	andi	r24, 0xDF	; 223
    8ff8:	85 34       	cpi	r24, 0x45	; 69
    8ffa:	99 f4       	brne	.+38     	; 0x9022 <SeekTagA_HREF+0x70>
    8ffc:	86 e0       	ldi	r24, 0x06	; 6
    8ffe:	08 c0       	rjmp	.+16     	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		case 6:
			if(ch=='F' || ch=='f') match = 7;
    9000:	8f 7d       	andi	r24, 0xDF	; 223
    9002:	86 34       	cpi	r24, 0x46	; 70
    9004:	71 f4       	brne	.+28     	; 0x9022 <SeekTagA_HREF+0x70>
    9006:	87 e0       	ldi	r24, 0x07	; 7
    9008:	03 c0       	rjmp	.+6      	; 0x9010 <SeekTagA_HREF+0x5e>
			else match = 0;
			break;
		//-----
		case 7:
			if(ch=='\"') match = 8;
    900a:	82 32       	cpi	r24, 0x22	; 34
    900c:	61 f4       	brne	.+24     	; 0x9026 <SeekTagA_HREF+0x74>
    900e:	88 e0       	ldi	r24, 0x08	; 8
    9010:	80 93 42 02 	sts	0x0242, r24
    9014:	08 c0       	rjmp	.+16     	; 0x9026 <SeekTagA_HREF+0x74>
			break;
		case 8:
			if(ch=='\"'){
    9016:	82 32       	cpi	r24, 0x22	; 34
    9018:	31 f4       	brne	.+12     	; 0x9026 <SeekTagA_HREF+0x74>
				match = 0;
    901a:	10 92 42 02 	sts	0x0242, r1
				return 1;
    901e:	81 e0       	ldi	r24, 0x01	; 1
    9020:	08 95       	ret
			}
			break;
		default:
			match = 0;
    9022:	10 92 42 02 	sts	0x0242, r1
	}
	return 0;
    9026:	80 e0       	ldi	r24, 0x00	; 0
}
    9028:	08 95       	ret

0000902a <SeekTagIMG_SRC>:
uint8_t SeekTagIMG_SRC(char ch){
	static uint8_t match;
	switch(match) {
    902a:	40 91 41 02 	lds	r20, 0x0241
    902e:	50 e0       	ldi	r21, 0x00	; 0
    9030:	4a 30       	cpi	r20, 0x0A	; 10
    9032:	51 05       	cpc	r21, r1
    9034:	b8 f5       	brcc	.+110    	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    9036:	fa 01       	movw	r30, r20
    9038:	e5 56       	subi	r30, 0x65	; 101
    903a:	ff 4f       	sbci	r31, 0xFF	; 255
    903c:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case 0:
			if(ch=='<') match = 1;
    9040:	8c 33       	cpi	r24, 0x3C	; 60
    9042:	91 f5       	brne	.+100    	; 0x90a8 <SeekTagIMG_SRC+0x7e>
    9044:	81 e0       	ldi	r24, 0x01	; 1
    9046:	25 c0       	rjmp	.+74     	; 0x9092 <SeekTagIMG_SRC+0x68>
			break;
		case 1:
			if(ch=='I' || ch=='i') match = 2;
    9048:	8f 7d       	andi	r24, 0xDF	; 223
    904a:	89 34       	cpi	r24, 0x49	; 73
    904c:	59 f5       	brne	.+86     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    904e:	82 e0       	ldi	r24, 0x02	; 2
    9050:	20 c0       	rjmp	.+64     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 2:
			if(ch=='M' || ch=='m') match = 3;
    9052:	8f 7d       	andi	r24, 0xDF	; 223
    9054:	8d 34       	cpi	r24, 0x4D	; 77
    9056:	31 f5       	brne	.+76     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    9058:	83 e0       	ldi	r24, 0x03	; 3
    905a:	1b c0       	rjmp	.+54     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 3:
			if(ch=='G' || ch=='g') match = 4;
    905c:	8f 7d       	andi	r24, 0xDF	; 223
    905e:	87 34       	cpi	r24, 0x47	; 71
    9060:	09 f5       	brne	.+66     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    9062:	84 e0       	ldi	r24, 0x04	; 4
    9064:	16 c0       	rjmp	.+44     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 4:
			if(ch==' ') match = 5;
    9066:	80 32       	cpi	r24, 0x20	; 32
    9068:	e9 f4       	brne	.+58     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    906a:	85 e0       	ldi	r24, 0x05	; 5
    906c:	12 c0       	rjmp	.+36     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 5:
			if(ch=='S' || ch=='s') match = 6;
    906e:	8f 7d       	andi	r24, 0xDF	; 223
    9070:	83 35       	cpi	r24, 0x53	; 83
    9072:	c1 f4       	brne	.+48     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    9074:	86 e0       	ldi	r24, 0x06	; 6
    9076:	0d c0       	rjmp	.+26     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 6:
			if(ch=='R' || ch=='r') match = 7;
    9078:	8f 7d       	andi	r24, 0xDF	; 223
    907a:	82 35       	cpi	r24, 0x52	; 82
    907c:	99 f4       	brne	.+38     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    907e:	87 e0       	ldi	r24, 0x07	; 7
    9080:	08 c0       	rjmp	.+16     	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		case 7:
			if(ch=='C' || ch=='c') match = 8;
    9082:	8f 7d       	andi	r24, 0xDF	; 223
    9084:	83 34       	cpi	r24, 0x43	; 67
    9086:	71 f4       	brne	.+28     	; 0x90a4 <SeekTagIMG_SRC+0x7a>
    9088:	88 e0       	ldi	r24, 0x08	; 8
    908a:	03 c0       	rjmp	.+6      	; 0x9092 <SeekTagIMG_SRC+0x68>
			else match = 0;
			break;
		//-----
		case 8:
			if(ch=='\"') match = 9;
    908c:	82 32       	cpi	r24, 0x22	; 34
    908e:	61 f4       	brne	.+24     	; 0x90a8 <SeekTagIMG_SRC+0x7e>
    9090:	89 e0       	ldi	r24, 0x09	; 9
    9092:	80 93 41 02 	sts	0x0241, r24
    9096:	08 c0       	rjmp	.+16     	; 0x90a8 <SeekTagIMG_SRC+0x7e>
			break;
		case 9:
			if(ch=='\"'){
    9098:	82 32       	cpi	r24, 0x22	; 34
    909a:	31 f4       	brne	.+12     	; 0x90a8 <SeekTagIMG_SRC+0x7e>
				match = 0;
    909c:	10 92 41 02 	sts	0x0241, r1
				return 1;
    90a0:	81 e0       	ldi	r24, 0x01	; 1
    90a2:	08 95       	ret
			}
			break;
		default:
			match = 0;
    90a4:	10 92 41 02 	sts	0x0241, r1
	}
	return 0;
    90a8:	80 e0       	ldi	r24, 0x00	; 0
}
    90aa:	08 95       	ret

000090ac <Web_Login_Error>:
		StartTimeoutWaitRequest = 0;
	}

}
//--Session
uint8_t Web_Login_Error(void){
    90ac:	cf 92       	push	r12
    90ae:	df 92       	push	r13
    90b0:	ef 92       	push	r14
    90b2:	ff 92       	push	r15
    90b4:	0f 93       	push	r16
    90b6:	1f 93       	push	r17
    90b8:	cf 93       	push	r28
    90ba:	df 93       	push	r29

	//   ?
	if(WebSession) return 1;
    90bc:	80 91 7e 09 	lds	r24, 0x097E
    90c0:	81 11       	cpse	r24, r1
    90c2:	73 c0       	rjmp	.+230    	; 0x91aa <Web_Login_Error+0xfe>
//	if(strcmp_E(Web_Passw_Str, Web_Passws) ) return 3;
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
    90c4:	10 92 6c 0a 	sts	0x0A6C, r1
    90c8:	0a ef       	ldi	r16, 0xFA	; 250
    90ca:	11 e0       	ldi	r17, 0x01	; 1
    90cc:	ca e2       	ldi	r28, 0x2A	; 42
    90ce:	d0 e0       	ldi	r29, 0x00	; 0
    90d0:	ff 24       	eor	r15, r15
    90d2:	f3 94       	inc	r15

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    90d4:	f8 01       	movw	r30, r16
    90d6:	65 91       	lpm	r22, Z+
    90d8:	74 91       	lpm	r23, Z
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
    90da:	87 ef       	ldi	r24, 0xF7	; 247
    90dc:	99 e0       	ldi	r25, 0x09	; 9
    90de:	0e 94 5b 47 	call	0x8eb6	; 0x8eb6 <strcmp_PP>
    90e2:	81 11       	cpse	r24, r1
    90e4:	09 c0       	rjmp	.+18     	; 0x90f8 <Web_Login_Error+0x4c>
    90e6:	be 01       	movw	r22, r28
    90e8:	84 ef       	ldi	r24, 0xF4	; 244
    90ea:	95 e0       	ldi	r25, 0x05	; 5
    90ec:	0e 94 79 47 	call	0x8ef2	; 0x8ef2 <strcmp_E>
    90f0:	81 11       	cpse	r24, r1
    90f2:	02 c0       	rjmp	.+4      	; 0x90f8 <Web_Login_Error+0x4c>
    90f4:	f0 92 6c 0a 	sts	0x0A6C, r15
    90f8:	f3 94       	inc	r15
    90fa:	00 5f       	subi	r16, 0xF0	; 240
    90fc:	1f 4f       	sbci	r17, 0xFF	; 255
    90fe:	2b 96       	adiw	r28, 0x0b	; 11
	
//prog_char Web_Logins[PASSWORDS_Qt][WebMaxLoginSz] EEMEM = LOGIN_Init;
//char Web_Passws[PASSWORDS_Qt][WebMaxPasswSz] EEMEM= PASSWORD_Init;
	
	AccessLevel = 0;
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
    9100:	85 e0       	ldi	r24, 0x05	; 5
    9102:	f8 12       	cpse	r15, r24
    9104:	e7 cf       	rjmp	.-50     	; 0x90d4 <Web_Login_Error+0x28>
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
    9106:	80 91 6c 0a 	lds	r24, 0x0A6C
    910a:	88 23       	and	r24, r24
    910c:	09 f4       	brne	.+2      	; 0x9110 <Web_Login_Error+0x64>
    910e:	4f c0       	rjmp	.+158    	; 0x91ae <Web_Login_Error+0x102>
	return 2;}


	WebSession = 1;
    9110:	81 e0       	ldi	r24, 0x01	; 1
    9112:	80 93 7e 09 	sts	0x097E, r24
	uint32_t Seed = GetTimer32(TD_WebSeedGenerator);
    9116:	c0 91 1c 06 	lds	r28, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    911a:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint32_t Time = Timer32[TimerN];
    911e:	94 e0       	ldi	r25, 0x04	; 4
    9120:	c9 9f       	mul	r28, r25
    9122:	f0 01       	movw	r30, r0
    9124:	11 24       	eor	r1, r1
    9126:	ea 57       	subi	r30, 0x7A	; 122
    9128:	fd 4f       	sbci	r31, 0xFD	; 253
    912a:	c0 80       	ld	r12, Z
    912c:	d1 80       	ldd	r13, Z+1	; 0x01
    912e:	e2 80       	ldd	r14, Z+2	; 0x02
    9130:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    9132:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
	srandom(Seed);
    9136:	c7 01       	movw	r24, r14
    9138:	b6 01       	movw	r22, r12
    913a:	0e 94 48 6c 	call	0xd890	; 0xd890 <srandom>
	random();// 
    913e:	0e 94 44 6c 	call	0xd888	; 0xd888 <random>
	Seed = random();
    9142:	0e 94 44 6c 	call	0xd888	; 0xd888 <random>
	sprintf_P(SESSID_Str,PSTR("%08lx"), Seed);
    9146:	9f 93       	push	r25
    9148:	8f 93       	push	r24
    914a:	7f 93       	push	r23
    914c:	6f 93       	push	r22
    914e:	83 e0       	ldi	r24, 0x03	; 3
    9150:	93 e0       	ldi	r25, 0x03	; 3
    9152:	9f 93       	push	r25
    9154:	8f 93       	push	r24
    9156:	89 e2       	ldi	r24, 0x29	; 41
    9158:	96 e0       	ldi	r25, 0x06	; 6
    915a:	9f 93       	push	r25
    915c:	8f 93       	push	r24
    915e:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
	Seed = random();
    9162:	0e 94 44 6c 	call	0xd888	; 0xd888 <random>
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);
    9166:	9f 93       	push	r25
    9168:	8f 93       	push	r24
    916a:	7f 93       	push	r23
    916c:	6f 93       	push	r22
    916e:	89 ef       	ldi	r24, 0xF9	; 249
    9170:	92 e0       	ldi	r25, 0x02	; 2
    9172:	9f 93       	push	r25
    9174:	8f 93       	push	r24
    9176:	81 e3       	ldi	r24, 0x31	; 49
    9178:	96 e0       	ldi	r25, 0x06	; 6
    917a:	9f 93       	push	r25
    917c:	8f 93       	push	r24
    917e:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    9182:	86 e5       	ldi	r24, 0x56	; 86
    9184:	90 e0       	ldi	r25, 0x00	; 0
    9186:	0e 94 02 74 	call	0xe804	; 0xe804 <__eerd_dword_m128>
    918a:	ab 01       	movw	r20, r22
    918c:	bc 01       	movw	r22, r24

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    918e:	80 91 68 09 	lds	r24, 0x0968
    9192:	0e 94 15 2c 	call	0x582a	; 0x582a <StartTimer32>
	return 0;
    9196:	8d b7       	in	r24, 0x3d	; 61
    9198:	9e b7       	in	r25, 0x3e	; 62
    919a:	40 96       	adiw	r24, 0x10	; 16
    919c:	0f b6       	in	r0, 0x3f	; 63
    919e:	f8 94       	cli
    91a0:	9e bf       	out	0x3e, r25	; 62
    91a2:	0f be       	out	0x3f, r0	; 63
    91a4:	8d bf       	out	0x3d, r24	; 61
    91a6:	80 e0       	ldi	r24, 0x00	; 0
    91a8:	03 c0       	rjmp	.+6      	; 0x91b0 <Web_Login_Error+0x104>
}
//--Session
uint8_t Web_Login_Error(void){

	//   ?
	if(WebSession) return 1;
    91aa:	81 e0       	ldi	r24, 0x01	; 1
    91ac:	01 c0       	rjmp	.+2      	; 0x91b0 <Web_Login_Error+0x104>
	for(uint8_t i = 0; i<PASSWORDS_Qt; i++){
		if(!strcmp_PP(Web_Login_Str, prp(Web_Logins[i]))&& !strcmp_E(Web_Passw_Str, Web_Passws[i])) AccessLevel = i+1;
	}

	if(AccessLevel == 0) {
	return 2;}
    91ae:	82 e0       	ldi	r24, 0x02	; 2
	Seed = random();
	sprintf_P(SESSID_Str+8,PSTR("%08lx'>\r\n"), Seed);

	StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
	return 0;
}
    91b0:	df 91       	pop	r29
    91b2:	cf 91       	pop	r28
    91b4:	1f 91       	pop	r17
    91b6:	0f 91       	pop	r16
    91b8:	ff 90       	pop	r15
    91ba:	ef 90       	pop	r14
    91bc:	df 90       	pop	r13
    91be:	cf 90       	pop	r12
    91c0:	08 95       	ret

000091c2 <WebRequest>:
}


	uint8_t WebStrLen;
// ~~~~~~~~~~~~~~~~~~
WebPage* WebRequest(WebPage **ptrSite, const uint8_t SiteSz){
    91c2:	2f 92       	push	r2
    91c4:	3f 92       	push	r3
    91c6:	4f 92       	push	r4
    91c8:	5f 92       	push	r5
    91ca:	6f 92       	push	r6
    91cc:	7f 92       	push	r7
    91ce:	8f 92       	push	r8
    91d0:	9f 92       	push	r9
    91d2:	af 92       	push	r10
    91d4:	bf 92       	push	r11
    91d6:	cf 92       	push	r12
    91d8:	df 92       	push	r13
    91da:	ef 92       	push	r14
    91dc:	ff 92       	push	r15
    91de:	0f 93       	push	r16
    91e0:	1f 93       	push	r17
    91e2:	cf 93       	push	r28
    91e4:	df 93       	push	r29
    91e6:	cd b7       	in	r28, 0x3d	; 61
    91e8:	de b7       	in	r29, 0x3e	; 62
    91ea:	2a 97       	sbiw	r28, 0x0a	; 10
    91ec:	0f b6       	in	r0, 0x3f	; 63
    91ee:	f8 94       	cli
    91f0:	de bf       	out	0x3e, r29	; 62
    91f2:	0f be       	out	0x3f, r0	; 63
    91f4:	cd bf       	out	0x3d, r28	; 61
    91f6:	9a 87       	std	Y+10, r25	; 0x0a
    91f8:	89 87       	std	Y+9, r24	; 0x09
    91fa:	69 83       	std	Y+1, r22	; 0x01
	
	
	WebStrLen = GetStringFromFIFO();
    91fc:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    9200:	80 93 70 08 	sts	0x0870, r24

	if(Web_POST==2){ 
    9204:	80 91 6d 09 	lds	r24, 0x096D
    9208:	82 30       	cpi	r24, 0x02	; 2
    920a:	a1 f4       	brne	.+40     	; 0x9234 <WebRequest+0x72>
		if(Timer8Stopp(TD_SetCRLFinPOST_RQ)){	//Chrome, Opera    
    920c:	80 91 41 09 	lds	r24, 0x0941
    9210:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    9214:	88 23       	and	r24, r24
    9216:	39 f0       	breq	.+14     	; 0x9226 <WebRequest+0x64>
			WebStrLen = ForceEndStringFromFIFO();
    9218:	0e 94 9d 3a 	call	0x753a	; 0x753a <ForceEndStringFromFIFO>
    921c:	80 93 70 08 	sts	0x0870, r24
			Web_POST=3;	
    9220:	83 e0       	ldi	r24, 0x03	; 3
    9222:	80 93 6d 09 	sts	0x096D, r24
		}
		if(WebStrLen) Web_POST=3;				//Explorer   
    9226:	80 91 70 08 	lds	r24, 0x0870
    922a:	88 23       	and	r24, r24
    922c:	19 f0       	breq	.+6      	; 0x9234 <WebRequest+0x72>
    922e:	83 e0       	ldi	r24, 0x03	; 3
    9230:	80 93 6d 09 	sts	0x096D, r24
	}

	//  
	if(WebStrLen){
    9234:	10 91 70 08 	lds	r17, 0x0870
    9238:	11 23       	and	r17, r17
    923a:	f9 f0       	breq	.+62     	; 0x927a <WebRequest+0xb8>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    923c:	e9 85       	ldd	r30, Y+9	; 0x09
    923e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9240:	25 90       	lpm	r2, Z+
    9242:	34 90       	lpm	r3, Z
		char *url, *p; 
		
		WebPage* ptrPage = prp(ptrSite);

		//----   POST -----------------------------------------------------------------------------------
		if( (strstr_P(GSM_RxStr, METHOD_POST) != NULL) ){	// 
    9244:	63 eb       	ldi	r22, 0xB3	; 179
    9246:	7b e4       	ldi	r23, 0x4B	; 75
    9248:	89 e8       	ldi	r24, 0x89	; 137
    924a:	99 e0       	ldi	r25, 0x09	; 9
    924c:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    9250:	89 2b       	or	r24, r25
    9252:	21 f0       	breq	.+8      	; 0x925c <WebRequest+0x9a>

			Web_POST = 1; 
    9254:	81 e0       	ldi	r24, 0x01	; 1
    9256:	80 93 6d 09 	sts	0x096D, r24
    925a:	0f c0       	rjmp	.+30     	; 0x927a <WebRequest+0xb8>
			return NULL;
		}
		if( (Web_POST==1) && (WebStrLen==1)){	//  ,    /0   
    925c:	80 91 6d 09 	lds	r24, 0x096D
    9260:	81 30       	cpi	r24, 0x01	; 1
    9262:	71 f4       	brne	.+28     	; 0x9280 <WebRequest+0xbe>
    9264:	11 30       	cpi	r17, 0x01	; 1
    9266:	09 f0       	breq	.+2      	; 0x926a <WebRequest+0xa8>
    9268:	8e c0       	rjmp	.+284    	; 0x9386 <WebRequest+0x1c4>
			Web_POST = 2;
    926a:	82 e0       	ldi	r24, 0x02	; 2
    926c:	80 93 6d 09 	sts	0x096D, r24
			StartTimer8(TD_SetCRLFinPOST_RQ,100);	//300 -  Opera , 600  -
    9270:	64 e6       	ldi	r22, 0x64	; 100
    9272:	80 91 41 09 	lds	r24, 0x0941
    9276:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
			return NULL;
    927a:	80 e0       	ldi	r24, 0x00	; 0
    927c:	90 e0       	ldi	r25, 0x00	; 0
    927e:	94 c1       	rjmp	.+808    	; 0x95a8 <WebRequest+0x3e6>
		}
		if(Web_POST==3){	//  
    9280:	83 30       	cpi	r24, 0x03	; 3
    9282:	09 f0       	breq	.+2      	; 0x9286 <WebRequest+0xc4>
    9284:	80 c0       	rjmp	.+256    	; 0x9386 <WebRequest+0x1c4>
			Web_POST = 0;
    9286:	10 92 6d 09 	sts	0x096D, r1
			url = GSM_RxStr;

			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
    928a:	f0 ec       	ldi	r31, 0xC0	; 192
    928c:	cf 2e       	mov	r12, r31
    928e:	fb e4       	ldi	r31, 0x4B	; 75
    9290:	df 2e       	mov	r13, r31
			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//For Debug
			#endif

			//URL 
			url = GSM_RxStr;
    9292:	a9 e8       	ldi	r26, 0x89	; 137
    9294:	ea 2e       	mov	r14, r26
    9296:	a9 e0       	ldi	r26, 0x09	; 9
    9298:	fa 2e       	mov	r15, r26
				varfield = p + 1;
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
    929a:	89 85       	ldd	r24, Y+9	; 0x09
    929c:	9a 85       	ldd	r25, Y+10	; 0x0a
    929e:	02 96       	adiw	r24, 0x02	; 2
    92a0:	9a 83       	std	Y+2, r25	; 0x02
    92a2:	89 83       	std	Y+1, r24	; 0x01
			//---    
			//:login=admin&password=secret
			char *nextvar, *varfield;
			WebPage* ptrPageVar = &Web_error_page;
			do{
				p=strchr(url,'=');
    92a4:	6d e3       	ldi	r22, 0x3D	; 61
    92a6:	70 e0       	ldi	r23, 0x00	; 0
    92a8:	c7 01       	movw	r24, r14
    92aa:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    92ae:	5c 01       	movw	r10, r24
				//if(p==NULL) return ptrPage;
				if(p==NULL) {
    92b0:	00 97       	sbiw	r24, 0x00	; 0
    92b2:	09 f4       	brne	.+2      	; 0x92b6 <WebRequest+0xf4>
    92b4:	4e c1       	rjmp	.+668    	; 0x9552 <WebRequest+0x390>
				return &Web_login;
				}
				nextvar=strchr(url+1,'&');
    92b6:	66 e2       	ldi	r22, 0x26	; 38
    92b8:	70 e0       	ldi	r23, 0x00	; 0
    92ba:	c7 01       	movw	r24, r14
    92bc:	01 96       	adiw	r24, 0x01	; 1
    92be:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    92c2:	4c 01       	movw	r8, r24
				varfield = p + 1;
    92c4:	85 01       	movw	r16, r10
    92c6:	0f 5f       	subi	r16, 0xFF	; 255
    92c8:	1f 4f       	sbci	r17, 0xFF	; 255
				*p = '\0';
    92ca:	d5 01       	movw	r26, r10
    92cc:	1c 92       	st	X, r1
    92ce:	e9 81       	ldd	r30, Y+1	; 0x01
    92d0:	fa 81       	ldd	r31, Y+2	; 0x02
    92d2:	65 90       	lpm	r6, Z+
    92d4:	74 90       	lpm	r7, Z
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92d6:	20 e0       	ldi	r18, 0x00	; 0
    92d8:	13 01       	movw	r2, r6
    92da:	b4 e0       	ldi	r27, 0x04	; 4
    92dc:	2b 0e       	add	r2, r27
    92de:	31 1c       	adc	r3, r1
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    92e0:	23 01       	movw	r4, r6
    92e2:	e6 e0       	ldi	r30, 0x06	; 6
    92e4:	4e 0e       	add	r4, r30
    92e6:	51 1c       	adc	r5, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    92e8:	f1 01       	movw	r30, r2
    92ea:	85 91       	lpm	r24, Z+
    92ec:	94 91       	lpm	r25, Z
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    92ee:	a2 2e       	mov	r10, r18
    92f0:	b1 2c       	mov	r11, r1
    92f2:	96 95       	lsr	r25
    92f4:	87 95       	ror	r24
    92f6:	96 95       	lsr	r25
    92f8:	87 95       	ror	r24
    92fa:	a8 16       	cp	r10, r24
    92fc:	b9 06       	cpc	r11, r25
    92fe:	50 f5       	brcc	.+84     	; 0x9354 <WebRequest+0x192>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    9300:	f2 01       	movw	r30, r4
    9302:	85 91       	lpm	r24, Z+
    9304:	94 91       	lpm	r25, Z
						WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
						if(ptrWOF != NULL){
    9306:	00 97       	sbiw	r24, 0x00	; 0
    9308:	19 f1       	breq	.+70     	; 0x9350 <WebRequest+0x18e>
							if(!strcmp_P(url, prp(&ptrWOF[j].Name))){
    930a:	aa 0c       	add	r10, r10
    930c:	bb 1c       	adc	r11, r11
    930e:	aa 0c       	add	r10, r10
    9310:	bb 1c       	adc	r11, r11
    9312:	a8 0e       	add	r10, r24
    9314:	b9 1e       	adc	r11, r25
    9316:	f5 01       	movw	r30, r10
    9318:	65 91       	lpm	r22, Z+
    931a:	74 91       	lpm	r23, Z
    931c:	c7 01       	movw	r24, r14
    931e:	28 87       	std	Y+8, r18	; 0x08
    9320:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    9324:	28 85       	ldd	r18, Y+8	; 0x08
    9326:	89 2b       	or	r24, r25
    9328:	99 f4       	brne	.+38     	; 0x9350 <WebRequest+0x18e>
    932a:	c8 01       	movw	r24, r16
    932c:	8c 01       	movw	r16, r24
    932e:	01 96       	adiw	r24, 0x01	; 1
								while(*varfield=='+') varfield++;	// ignore leading '+'
    9330:	d8 01       	movw	r26, r16
    9332:	3c 91       	ld	r19, X
    9334:	3b 32       	cpi	r19, 0x2B	; 43
    9336:	d1 f3       	breq	.-12     	; 0x932c <WebRequest+0x16a>
								WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield); 
    9338:	b2 e0       	ldi	r27, 0x02	; 2
    933a:	ab 0e       	add	r10, r27
    933c:	b1 1c       	adc	r11, r1
    933e:	f5 01       	movw	r30, r10
    9340:	85 91       	lpm	r24, Z+
    9342:	94 91       	lpm	r25, Z
    9344:	b8 01       	movw	r22, r16
    9346:	28 87       	std	Y+8, r18	; 0x08
    9348:	0e 94 e9 43 	call	0x87d2	; 0x87d2 <WebBuf2Field>
								ptrPageVar = ptrPage;	//  -    ptrPage
    934c:	63 01       	movw	r12, r6
    934e:	28 85       	ldd	r18, Y+8	; 0x08
				*p = '\0';
				//   
				//for(uint8_t i=0; i<SiteSz; i++){
					uint8_t i = 1; //     (login.html)
					ptrPage = (WebPage*)prp(&ptrSite[i]);
					for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9350:	2f 5f       	subi	r18, 0xFF	; 255
    9352:	ca cf       	rjmp	.-108    	; 0x92e8 <WebRequest+0x126>
								ptrPageVar = ptrPage;	//  -    ptrPage
							}
						}
					}
				//}
				url = nextvar+1;
    9354:	74 01       	movw	r14, r8
    9356:	ef ef       	ldi	r30, 0xFF	; 255
    9358:	ee 1a       	sub	r14, r30
    935a:	fe 0a       	sbc	r15, r30
			}while(nextvar);	//     
    935c:	89 28       	or	r8, r9
    935e:	09 f0       	breq	.+2      	; 0x9362 <WebRequest+0x1a0>
    9360:	a1 cf       	rjmp	.-190    	; 0x92a4 <WebRequest+0xe2>

			if(Web_LoginAttempt){				
    9362:	80 91 3a 08 	lds	r24, 0x083A
    9366:	88 23       	and	r24, r24
    9368:	09 f4       	brne	.+2      	; 0x936c <WebRequest+0x1aa>
    936a:	18 c1       	rjmp	.+560    	; 0x959c <WebRequest+0x3da>
				Web_LoginAttempt = 0;
    936c:	10 92 3a 08 	sts	0x083A, r1
				Web_Login_Code = Web_Login_Error();
    9370:	0e 94 56 48 	call	0x90ac	; 0x90ac <Web_Login_Error>
    9374:	80 93 09 06 	sts	0x0609, r24
				if(!Web_Login_Code){ return prp(ptrSite);}
    9378:	81 11       	cpse	r24, r1
    937a:	10 c1       	rjmp	.+544    	; 0x959c <WebRequest+0x3da>
    937c:	e9 85       	ldd	r30, Y+9	; 0x09
    937e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9380:	85 91       	lpm	r24, Z+
    9382:	94 91       	lpm	r25, Z
    9384:	11 c1       	rjmp	.+546    	; 0x95a8 <WebRequest+0x3e6>
		//----   GET -----------------------------------------------------------------------------------
		//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
		//:GET /system.html?SESSID=72fa12d3fc837bc0 HTTP/1.1
		
		url = GSM_RxStr+4;
		if( (strstr_P(GSM_RxStr, METHOD_GET) != NULL) && (p=strchr(url,' ')) ){
    9386:	6a eb       	ldi	r22, 0xBA	; 186
    9388:	7b e4       	ldi	r23, 0x4B	; 75
    938a:	89 e8       	ldi	r24, 0x89	; 137
    938c:	99 e0       	ldi	r25, 0x09	; 9
    938e:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    9392:	89 2b       	or	r24, r25
    9394:	09 f4       	brne	.+2      	; 0x9398 <WebRequest+0x1d6>
    9396:	71 cf       	rjmp	.-286    	; 0x927a <WebRequest+0xb8>
    9398:	60 e2       	ldi	r22, 0x20	; 32
    939a:	70 e0       	ldi	r23, 0x00	; 0
    939c:	8d e8       	ldi	r24, 0x8D	; 141
    939e:	99 e0       	ldi	r25, 0x09	; 9
    93a0:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    93a4:	00 97       	sbiw	r24, 0x00	; 0
    93a6:	09 f4       	brne	.+2      	; 0x93aa <WebRequest+0x1e8>
    93a8:	68 cf       	rjmp	.-304    	; 0x927a <WebRequest+0xb8>

			#ifdef WEB_DEBUG
				strncpy(StartStr, GSM_RxStr, sizeof(StartStr));	//ForDebug
			#endif

			*p = '\0';
    93aa:	dc 01       	movw	r26, r24
    93ac:	1c 92       	st	X, r1

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    93ae:	68 e7       	ldi	r22, 0x78	; 120
    93b0:	79 e3       	ldi	r23, 0x39	; 57
    93b2:	8e e8       	ldi	r24, 0x8E	; 142
    93b4:	99 e0       	ldi	r25, 0x09	; 9
    93b6:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    93ba:	89 2b       	or	r24, r25
    93bc:	09 f4       	brne	.+2      	; 0x93c0 <WebRequest+0x1fe>
    93be:	eb c0       	rjmp	.+470    	; 0x9596 <WebRequest+0x3d4>
			url = strchr(url,'?');
    93c0:	6f e3       	ldi	r22, 0x3F	; 63
    93c2:	70 e0       	ldi	r23, 0x00	; 0
    93c4:	8d e8       	ldi	r24, 0x8D	; 141
    93c6:	99 e0       	ldi	r25, 0x09	; 9
    93c8:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    93cc:	8c 01       	movw	r16, r24
			if( !WebSession || (url == NULL) || strncmp_P(url, SESSID_pstr, 8) || strncmp(url+8, SESSID_Str, 16) ) return &Web_login;
    93ce:	80 91 7e 09 	lds	r24, 0x097E
    93d2:	88 23       	and	r24, r24
    93d4:	09 f4       	brne	.+2      	; 0x93d8 <WebRequest+0x216>
    93d6:	bd c0       	rjmp	.+378    	; 0x9552 <WebRequest+0x390>
    93d8:	01 15       	cp	r16, r1
    93da:	11 05       	cpc	r17, r1
    93dc:	09 f4       	brne	.+2      	; 0x93e0 <WebRequest+0x21e>
    93de:	b9 c0       	rjmp	.+370    	; 0x9552 <WebRequest+0x390>
    93e0:	48 e0       	ldi	r20, 0x08	; 8
    93e2:	50 e0       	ldi	r21, 0x00	; 0
    93e4:	62 e4       	ldi	r22, 0x42	; 66
    93e6:	7c e4       	ldi	r23, 0x4C	; 76
    93e8:	c8 01       	movw	r24, r16
    93ea:	0e 94 95 6c 	call	0xd92a	; 0xd92a <strncmp_P>
    93ee:	89 2b       	or	r24, r25
    93f0:	09 f0       	breq	.+2      	; 0x93f4 <WebRequest+0x232>
    93f2:	af c0       	rjmp	.+350    	; 0x9552 <WebRequest+0x390>
    93f4:	40 e1       	ldi	r20, 0x10	; 16
    93f6:	50 e0       	ldi	r21, 0x00	; 0
    93f8:	69 e2       	ldi	r22, 0x29	; 41
    93fa:	76 e0       	ldi	r23, 0x06	; 6
    93fc:	c8 01       	movw	r24, r16
    93fe:	08 96       	adiw	r24, 0x08	; 8
    9400:	0e 94 e1 6c 	call	0xd9c2	; 0xd9c2 <strncmp>
    9404:	89 2b       	or	r24, r25
    9406:	09 f0       	breq	.+2      	; 0x940a <WebRequest+0x248>
    9408:	a4 c0       	rjmp	.+328    	; 0x9552 <WebRequest+0x390>
    940a:	61 01       	movw	r12, r2
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    940c:	86 e5       	ldi	r24, 0x56	; 86
    940e:	90 e0       	ldi	r25, 0x00	; 0
    9410:	0e 94 02 74 	call	0xe804	; 0xe804 <__eerd_dword_m128>
    9414:	ab 01       	movw	r20, r22
    9416:	bc 01       	movw	r22, r24

			StartTimer32(TD_WebSessTimeout, erd(&WebMaxSessionTime));
    9418:	80 91 68 09 	lds	r24, 0x0968
    941c:	0e 94 15 2c 	call	0x582a	; 0x582a <StartTimer32>
			
			*url = '\0';
    9420:	f8 01       	movw	r30, r16
    9422:	11 92       	st	Z+, r1
    9424:	cf 01       	movw	r24, r30
			
			//URL 

			//url = GSM_RxStr+5;
			url = strchr(url+1,'&');//     SESSID ?
    9426:	66 e2       	ldi	r22, 0x26	; 38
    9428:	70 e0       	ldi	r23, 0x00	; 0
    942a:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    942e:	8c 01       	movw	r16, r24

			//---    
			//:GET /?SESSID=72fa12d3fc837bc0&UDP0_IP1=12&UDP0_IP2=32&UDP0_IP3=43&UDP0_IP4=3&UDP0_Port=1234 HTTP/1.1
			if(url != NULL){
    9430:	00 97       	sbiw	r24, 0x00	; 0
    9432:	09 f4       	brne	.+2      	; 0x9436 <WebRequest+0x274>
    9434:	77 c0       	rjmp	.+238    	; 0x9524 <WebRequest+0x362>
    9436:	60 ec       	ldi	r22, 0xC0	; 192
    9438:	26 2e       	mov	r2, r22
    943a:	6b e4       	ldi	r22, 0x4B	; 75
    943c:	36 2e       	mov	r3, r22
				
				char *nextvar, *varfield;
				WebPage* ptrPageVar = &Web_error_page;
				do{
					p=strchr(url,'=');
    943e:	6d e3       	ldi	r22, 0x3D	; 61
    9440:	70 e0       	ldi	r23, 0x00	; 0
    9442:	c8 01       	movw	r24, r16
    9444:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    9448:	5c 01       	movw	r10, r24
					if(p==NULL) return ptrPage;
    944a:	00 97       	sbiw	r24, 0x00	; 0
    944c:	09 f4       	brne	.+2      	; 0x9450 <WebRequest+0x28e>
    944e:	a6 c0       	rjmp	.+332    	; 0x959c <WebRequest+0x3da>
					nextvar=strchr(url+1,'&');
    9450:	28 01       	movw	r4, r16
    9452:	ff ef       	ldi	r31, 0xFF	; 255
    9454:	4f 1a       	sub	r4, r31
    9456:	5f 0a       	sbc	r5, r31
    9458:	66 e2       	ldi	r22, 0x26	; 38
    945a:	70 e0       	ldi	r23, 0x00	; 0
    945c:	c2 01       	movw	r24, r4
    945e:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    9462:	8c 01       	movw	r16, r24
					varfield = p + 1;
    9464:	75 01       	movw	r14, r10
    9466:	2f ef       	ldi	r18, 0xFF	; 255
    9468:	e2 1a       	sub	r14, r18
    946a:	f2 0a       	sbc	r15, r18
					*p = '\0';
    946c:	d5 01       	movw	r26, r10
    946e:	1c 92       	st	X, r1
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9470:	69 84       	ldd	r6, Y+9	; 0x09
    9472:	7a 84       	ldd	r7, Y+10	; 0x0a
    9474:	30 e0       	ldi	r19, 0x00	; 0
    9476:	29 81       	ldd	r18, Y+1	; 0x01
    9478:	32 17       	cp	r19, r18
    947a:	09 f4       	brne	.+2      	; 0x947e <WebRequest+0x2bc>
    947c:	4e c0       	rjmp	.+156    	; 0x951a <WebRequest+0x358>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    947e:	f3 01       	movw	r30, r6
    9480:	85 90       	lpm	r8, Z+
    9482:	94 90       	lpm	r9, Z
    9484:	64 01       	movw	r12, r8
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    9486:	20 e0       	ldi	r18, 0x00	; 0
    9488:	f4 01       	movw	r30, r8
    948a:	34 96       	adiw	r30, 0x04	; 4
    948c:	fc 83       	std	Y+4, r31	; 0x04
    948e:	eb 83       	std	Y+3, r30	; 0x03
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
    9490:	c4 01       	movw	r24, r8
    9492:	06 96       	adiw	r24, 0x06	; 6
    9494:	9e 83       	std	Y+6, r25	; 0x06
    9496:	8d 83       	std	Y+5, r24	; 0x05

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    9498:	eb 81       	ldd	r30, Y+3	; 0x03
    949a:	fc 81       	ldd	r31, Y+4	; 0x04
    949c:	85 91       	lpm	r24, Z+
    949e:	94 91       	lpm	r25, Z
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    94a0:	a2 2e       	mov	r10, r18
    94a2:	b1 2c       	mov	r11, r1
    94a4:	96 95       	lsr	r25
    94a6:	87 95       	ror	r24
    94a8:	96 95       	lsr	r25
    94aa:	87 95       	ror	r24
    94ac:	a8 16       	cp	r10, r24
    94ae:	b9 06       	cpc	r11, r25
    94b0:	78 f5       	brcc	.+94     	; 0x9510 <WebRequest+0x34e>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    94b2:	ed 81       	ldd	r30, Y+5	; 0x05
    94b4:	fe 81       	ldd	r31, Y+6	; 0x06
    94b6:	85 91       	lpm	r24, Z+
    94b8:	94 91       	lpm	r25, Z
							WebOutField* ptrWOF= (WebOutField*)prp(&ptrPage->OF_List);
							if(ptrWOF != NULL){
    94ba:	00 97       	sbiw	r24, 0x00	; 0
    94bc:	39 f1       	breq	.+78     	; 0x950c <WebRequest+0x34a>
								if(!strcmp_P(url+1, prp(&ptrWOF[j].Name))){
    94be:	aa 0c       	add	r10, r10
    94c0:	bb 1c       	adc	r11, r11
    94c2:	aa 0c       	add	r10, r10
    94c4:	bb 1c       	adc	r11, r11
    94c6:	a8 0e       	add	r10, r24
    94c8:	b9 1e       	adc	r11, r25
    94ca:	f5 01       	movw	r30, r10
    94cc:	65 91       	lpm	r22, Z+
    94ce:	74 91       	lpm	r23, Z
    94d0:	c2 01       	movw	r24, r4
    94d2:	28 87       	std	Y+8, r18	; 0x08
    94d4:	3f 83       	std	Y+7, r19	; 0x07
    94d6:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    94da:	28 85       	ldd	r18, Y+8	; 0x08
    94dc:	3f 81       	ldd	r19, Y+7	; 0x07
    94de:	89 2b       	or	r24, r25
    94e0:	a9 f4       	brne	.+42     	; 0x950c <WebRequest+0x34a>
    94e2:	c7 01       	movw	r24, r14
    94e4:	7c 01       	movw	r14, r24
    94e6:	01 96       	adiw	r24, 0x01	; 1
									while(*varfield=='+') varfield++;	// ignore leading '+'
    94e8:	d7 01       	movw	r26, r14
    94ea:	4c 91       	ld	r20, X
    94ec:	4b 32       	cpi	r20, 0x2B	; 43
    94ee:	d1 f3       	breq	.-12     	; 0x94e4 <WebRequest+0x322>
									WebBuf2Field( (OutField*)prp(&ptrWOF[j].OField), varfield);
    94f0:	b2 e0       	ldi	r27, 0x02	; 2
    94f2:	ab 0e       	add	r10, r27
    94f4:	b1 1c       	adc	r11, r1
    94f6:	f5 01       	movw	r30, r10
    94f8:	85 91       	lpm	r24, Z+
    94fa:	94 91       	lpm	r25, Z
    94fc:	b7 01       	movw	r22, r14
    94fe:	28 87       	std	Y+8, r18	; 0x08
    9500:	3f 83       	std	Y+7, r19	; 0x07
    9502:	0e 94 e9 43 	call	0x87d2	; 0x87d2 <WebBuf2Field>
									ptrPageVar = ptrPage;	//  -    ptrPage
    9506:	14 01       	movw	r2, r8
    9508:	3f 81       	ldd	r19, Y+7	; 0x07
    950a:	28 85       	ldd	r18, Y+8	; 0x08
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
						ptrPage = (WebPage*)prp(&ptrSite[i]);
						for(uint8_t j=0; j<prw(&ptrPage->OFSz)/sizeof(WebOutField); j++){
    950c:	2f 5f       	subi	r18, 0xFF	; 255
    950e:	c4 cf       	rjmp	.-120    	; 0x9498 <WebRequest+0x2d6>
					if(p==NULL) return ptrPage;
					nextvar=strchr(url+1,'&');
					varfield = p + 1;
					*p = '\0';
					//   
					for(uint8_t i=0; i<SiteSz; i++){
    9510:	3f 5f       	subi	r19, 0xFF	; 255
    9512:	e2 e0       	ldi	r30, 0x02	; 2
    9514:	6e 0e       	add	r6, r30
    9516:	71 1c       	adc	r7, r1
    9518:	ae cf       	rjmp	.-164    	; 0x9476 <WebRequest+0x2b4>
								}
							}
						}
					}
					url = nextvar;
				}while(nextvar);	//     
    951a:	01 15       	cp	r16, r1
    951c:	11 05       	cpc	r17, r1
    951e:	09 f0       	breq	.+2      	; 0x9522 <WebRequest+0x360>
    9520:	8e cf       	rjmp	.-228    	; 0x943e <WebRequest+0x27c>
    9522:	3e c0       	rjmp	.+124    	; 0x95a0 <WebRequest+0x3de>
				return ptrPageVar;
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
    9524:	6a e1       	ldi	r22, 0x1A	; 26
    9526:	73 e0       	ldi	r23, 0x03	; 3
    9528:	8d e8       	ldi	r24, 0x8D	; 141
    952a:	99 e0       	ldi	r25, 0x09	; 9
    952c:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    9530:	89 2b       	or	r24, r25
    9532:	09 f4       	brne	.+2      	; 0x9536 <WebRequest+0x374>
    9534:	35 c0       	rjmp	.+106    	; 0x95a0 <WebRequest+0x3de>
				return ptrPage;			
			}
            if(!strcmp_P(url+1, PSTR("logout.html"))){
    9536:	6e e0       	ldi	r22, 0x0E	; 14
    9538:	73 e0       	ldi	r23, 0x03	; 3
    953a:	8e e8       	ldi	r24, 0x8E	; 142
    953c:	99 e0       	ldi	r25, 0x09	; 9
    953e:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    9542:	89 2b       	or	r24, r25
    9544:	21 f0       	breq	.+8      	; 0x954e <WebRequest+0x38c>
    9546:	e9 84       	ldd	r14, Y+9	; 0x09
    9548:	fa 84       	ldd	r15, Y+10	; 0x0a
    954a:	10 e0       	ldi	r17, 0x00	; 0
    954c:	15 c0       	rjmp	.+42     	; 0x9578 <WebRequest+0x3b6>
				WebSession = 0;
    954e:	10 92 7e 09 	sts	0x097E, r1
				return &Web_login;
    9552:	89 e9       	ldi	r24, 0x99	; 153
    9554:	98 e4       	ldi	r25, 0x48	; 72
    9556:	28 c0       	rjmp	.+80     	; 0x95a8 <WebRequest+0x3e6>
    9558:	f7 01       	movw	r30, r14
    955a:	c5 90       	lpm	r12, Z+
    955c:	d4 90       	lpm	r13, Z
    955e:	f6 01       	movw	r30, r12
    9560:	65 91       	lpm	r22, Z+
    9562:	74 91       	lpm	r23, Z
			
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
    9564:	8e e8       	ldi	r24, 0x8E	; 142
    9566:	99 e0       	ldi	r25, 0x09	; 9
    9568:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    956c:	a2 e0       	ldi	r26, 0x02	; 2
    956e:	ea 0e       	add	r14, r26
    9570:	f1 1c       	adc	r15, r1
    9572:	89 2b       	or	r24, r25
    9574:	29 f0       	breq	.+10     	; 0x9580 <WebRequest+0x3be>
				WebSession = 0;
				return &Web_login;
			}

			
			for(uint8_t i=0; i<SiteSz; i++){
    9576:	1f 5f       	subi	r17, 0xFF	; 255
    9578:	29 81       	ldd	r18, Y+1	; 0x01
    957a:	12 13       	cpse	r17, r18
    957c:	ed cf       	rjmp	.-38     	; 0x9558 <WebRequest+0x396>
    957e:	08 c0       	rjmp	.+16     	; 0x9590 <WebRequest+0x3ce>
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    9580:	f6 01       	movw	r30, r12
    9582:	3c 96       	adiw	r30, 0x0c	; 12

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    9584:	e4 91       	lpm	r30, Z
    9586:	80 91 6c 0a 	lds	r24, 0x0A6C
    958a:	8e 17       	cp	r24, r30
    958c:	58 f0       	brcs	.+22     	; 0x95a4 <WebRequest+0x3e2>
    958e:	06 c0       	rjmp	.+12     	; 0x959c <WebRequest+0x3da>
					return ptrPage;				
				}
			}
			
			//  URL
			return &Web_error_page;
    9590:	80 ec       	ldi	r24, 0xC0	; 192
    9592:	9b e4       	ldi	r25, 0x4B	; 75
    9594:	09 c0       	rjmp	.+18     	; 0x95a8 <WebRequest+0x3e6>
			#endif

			*p = '\0';

			//  ?SESSID=  ,  favicon.ico! 
			if(!strcmp_P(url+1, name_favicon)) return &Web_favicon;
    9596:	8d ee       	ldi	r24, 0xED	; 237
    9598:	93 e3       	ldi	r25, 0x33	; 51
    959a:	06 c0       	rjmp	.+12     	; 0x95a8 <WebRequest+0x3e6>
    959c:	c6 01       	movw	r24, r12
    959e:	04 c0       	rjmp	.+8      	; 0x95a8 <WebRequest+0x3e6>
			}//---

			//   ? -    
			url = GSM_RxStr+4;
            if(!strcmp_P(url, PSTR("/"))){
				return ptrPage;			
    95a0:	c1 01       	movw	r24, r2
    95a2:	02 c0       	rjmp	.+4      	; 0x95a8 <WebRequest+0x3e6>
			for(uint8_t i=0; i<SiteSz; i++){
				
				ptrPage = (WebPage*)prp(&ptrSite[i]);

				if(!strcmp_P(url+1, prp(&ptrPage->Name))){
					if(prb(&ptrPage->Level)>AccessLevel)ptrPage=&Web_name_access_error;
    95a4:	84 eb       	ldi	r24, 0xB4	; 180
    95a6:	92 e3       	ldi	r25, 0x32	; 50
			//  URL
			return &Web_error_page;
		}
	}
	return NULL;
}
    95a8:	2a 96       	adiw	r28, 0x0a	; 10
    95aa:	0f b6       	in	r0, 0x3f	; 63
    95ac:	f8 94       	cli
    95ae:	de bf       	out	0x3e, r29	; 62
    95b0:	0f be       	out	0x3f, r0	; 63
    95b2:	cd bf       	out	0x3d, r28	; 61
    95b4:	df 91       	pop	r29
    95b6:	cf 91       	pop	r28
    95b8:	1f 91       	pop	r17
    95ba:	0f 91       	pop	r16
    95bc:	ff 90       	pop	r15
    95be:	ef 90       	pop	r14
    95c0:	df 90       	pop	r13
    95c2:	cf 90       	pop	r12
    95c4:	bf 90       	pop	r11
    95c6:	af 90       	pop	r10
    95c8:	9f 90       	pop	r9
    95ca:	8f 90       	pop	r8
    95cc:	7f 90       	pop	r7
    95ce:	6f 90       	pop	r6
    95d0:	5f 90       	pop	r5
    95d2:	4f 90       	pop	r4
    95d4:	3f 90       	pop	r3
    95d6:	2f 90       	pop	r2
    95d8:	08 95       	ret

000095da <EM_InitFIFO>:
void EMeter_NoLink(void);
uint32_t EMeter_M230_Data_Convert(uint16_t Start);
uint32_t EMeter_ZMR110_Data_Convert(prog_char *Str_P);

// ~~~~~~~~~~~
void EM_InitFIFO(void){cli();
    95da:	f8 94       	cli
	EM_RX_FIFO_Begin = 255;
    95dc:	8f ef       	ldi	r24, 0xFF	; 255
    95de:	80 93 70 09 	sts	0x0970, r24
	EM_RX_FIFO_End = 255;
    95e2:	80 93 38 0d 	sts	0x0D38, r24
	EMeter_RxCharN = 0;
    95e6:	10 92 3f 0d 	sts	0x0D3F, r1
    95ea:	10 92 3e 0d 	sts	0x0D3E, r1
	sei();
    95ee:	78 94       	sei
    95f0:	08 95       	ret

000095f2 <EM_SetUARTParam>:
		EM_UART_BitQt = 3;		
	}
	ApplyUARTParam();
}
// ~~~~~~~~~~~
void EM_SetUARTParam(uint16_t Params){
    95f2:	29 2f       	mov	r18, r25
	
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);	
    95f4:	10 92 9b 00 	sts	0x009B, r1
	
	EM_UART_Rate = Params & 0x00FF;
    95f8:	80 93 6b 0a 	sts	0x0A6B, r24

	switch(EM_UART_Rate){
    95fc:	90 e0       	ldi	r25, 0x00	; 0
    95fe:	89 30       	cpi	r24, 0x09	; 9
    9600:	91 05       	cpc	r25, r1
    9602:	38 f5       	brcc	.+78     	; 0x9652 <EM_SetUARTParam+0x60>
    9604:	fc 01       	movw	r30, r24
    9606:	eb 55       	subi	r30, 0x5B	; 91
    9608:	ff 4f       	sbci	r31, 0xFF	; 255
    960a:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case 0:// 1200
			UBRR_EMETER_H = 0x03;
    960e:	83 e0       	ldi	r24, 0x03	; 3
    9610:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0x42;
    9614:	82 e4       	ldi	r24, 0x42	; 66
    9616:	20 c0       	rjmp	.+64     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 1:// 2400
			UBRR_EMETER_H = 0x01;
    9618:	81 e0       	ldi	r24, 0x01	; 1
    961a:	80 93 98 00 	sts	0x0098, r24
			UBRR_EMETER_L = 0xA0;
    961e:	80 ea       	ldi	r24, 0xA0	; 160
    9620:	1b c0       	rjmp	.+54     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 2:// 4800
			UBRR_EMETER_H = 0x00;
    9622:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0xCF;
    9626:	8f ec       	ldi	r24, 0xCF	; 207
    9628:	17 c0       	rjmp	.+46     	; 0x9658 <EM_SetUARTParam+0x66>
		case 3:// 9600
			UBRR_EMETER_H = 0x00;
			UBRR_EMETER_L = 0x67;
			break;
		case 4:// 14400
			UBRR_EMETER_H = 0x00;
    962a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x44;
    962e:	84 e4       	ldi	r24, 0x44	; 68
    9630:	13 c0       	rjmp	.+38     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 5:// 19200
			UBRR_EMETER_H = 0x00;
    9632:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x33;
    9636:	83 e3       	ldi	r24, 0x33	; 51
    9638:	0f c0       	rjmp	.+30     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 6:// 28800
			UBRR_EMETER_H = 0x00;
    963a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x22;
    963e:	82 e2       	ldi	r24, 0x22	; 34
    9640:	0b c0       	rjmp	.+22     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 7:// 38400
			UBRR_EMETER_H = 0x00;
    9642:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x19;
    9646:	89 e1       	ldi	r24, 0x19	; 25
    9648:	07 c0       	rjmp	.+14     	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		case 8:// 57600	
			UBRR_EMETER_H = 0x00;
    964a:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x10;
    964e:	80 e1       	ldi	r24, 0x10	; 16
    9650:	03 c0       	rjmp	.+6      	; 0x9658 <EM_SetUARTParam+0x66>
			break;
		default:
			UBRR_EMETER_H = 0x00;
    9652:	10 92 98 00 	sts	0x0098, r1
			UBRR_EMETER_L = 0x67;
    9656:	87 e6       	ldi	r24, 0x67	; 103
    9658:	80 93 99 00 	sts	0x0099, r24
			break;
	}

	UCSR_EMETER_C = (0<<UMSEL_EMETER) | (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0) | (0<<USBS_EMETER) | (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0) | (0<<UCPOL_EMETER);
    965c:	10 92 9d 00 	sts	0x009D, r1


	EM_UART_Parity = (Params >> 8) & 0b00000011;
    9660:	82 2f       	mov	r24, r18
    9662:	83 70       	andi	r24, 0x03	; 3
    9664:	80 93 0c 06 	sts	0x060C, r24

	//00=NoParity(), 01=EvenParity(), 10=OddParity()
	switch(EM_UART_Parity){
    9668:	82 30       	cpi	r24, 0x02	; 2
    966a:	41 f0       	breq	.+16     	; 0x967c <EM_SetUARTParam+0x8a>
    966c:	83 30       	cpi	r24, 0x03	; 3
    966e:	51 f0       	breq	.+20     	; 0x9684 <EM_SetUARTParam+0x92>
    9670:	81 30       	cpi	r24, 0x01	; 1
    9672:	41 f4       	brne	.+16     	; 0x9684 <EM_SetUARTParam+0x92>
		case 0://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
			break;
		case 1://Enabled, Even Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9674:	80 91 9d 00 	lds	r24, 0x009D
    9678:	80 62       	ori	r24, 0x20	; 32
    967a:	06 c0       	rjmp	.+12     	; 0x9688 <EM_SetUARTParam+0x96>
			break;
		case 2://Enabled, Odd Parity
			UCSR_EMETER_C |= (1<<UPM_EMETER_1) | (1<<UPM_EMETER_0);
    967c:	80 91 9d 00 	lds	r24, 0x009D
    9680:	80 63       	ori	r24, 0x30	; 48
    9682:	02 c0       	rjmp	.+4      	; 0x9688 <EM_SetUARTParam+0x96>
			break;
		case 3://Disabled
			UCSR_EMETER_C |= (0<<UPM_EMETER_1) | (0<<UPM_EMETER_0);
    9684:	80 91 9d 00 	lds	r24, 0x009D
    9688:	80 93 9d 00 	sts	0x009D, r24
			break;
	}


	EM_UART_StopBits = (Params >> 10) & 0b00000001;
    968c:	22 fb       	bst	r18, 2
    968e:	88 27       	eor	r24, r24
    9690:	80 f9       	bld	r24, 0
    9692:	80 93 42 09 	sts	0x0942, r24
	// 2 - -; 0=1, 1=2
	switch(EM_UART_StopBits){
    9696:	81 30       	cpi	r24, 0x01	; 1
    9698:	19 f0       	breq	.+6      	; 0x96a0 <EM_SetUARTParam+0xae>
		case 0://1-bit
			UCSR_EMETER_C |= (0<<USBS_EMETER);
    969a:	80 91 9d 00 	lds	r24, 0x009D
    969e:	03 c0       	rjmp	.+6      	; 0x96a6 <EM_SetUARTParam+0xb4>
			break;
		case 1://2-bits
			UCSR_EMETER_C |= (1<<USBS_EMETER);
    96a0:	80 91 9d 00 	lds	r24, 0x009D
    96a4:	88 60       	ori	r24, 0x08	; 8
    96a6:	80 93 9d 00 	sts	0x009D, r24
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
    96aa:	92 2f       	mov	r25, r18
    96ac:	96 95       	lsr	r25
    96ae:	96 95       	lsr	r25
    96b0:	96 95       	lsr	r25
    96b2:	93 70       	andi	r25, 0x03	; 3
    96b4:	90 93 72 0a 	sts	0x0A72, r25
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96b8:	80 91 9d 00 	lds	r24, 0x009D
			break;
	}
	
	EM_UART_BitQt = (Params >> 11) & 0b00000011;
	//:3-4:- : 00-5, 01-6, 10-7, 11- 8
	switch(EM_UART_BitQt){
    96bc:	92 30       	cpi	r25, 0x02	; 2
    96be:	31 f0       	breq	.+12     	; 0x96cc <EM_SetUARTParam+0xda>
    96c0:	93 30       	cpi	r25, 0x03	; 3
    96c2:	31 f0       	breq	.+12     	; 0x96d0 <EM_SetUARTParam+0xde>
    96c4:	91 30       	cpi	r25, 0x01	; 1
    96c6:	29 f4       	brne	.+10     	; 0x96d2 <EM_SetUARTParam+0xe0>
		case 0://5-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
			break;
		case 1://6-bit
			UCSR_EMETER_C |= (0<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96c8:	82 60       	ori	r24, 0x02	; 2
    96ca:	03 c0       	rjmp	.+6      	; 0x96d2 <EM_SetUARTParam+0xe0>
			break;
		case 2://7-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (0<<UCSZ_EMETER_0);
    96cc:	84 60       	ori	r24, 0x04	; 4
    96ce:	01 c0       	rjmp	.+2      	; 0x96d2 <EM_SetUARTParam+0xe0>
			break;
		case 3://8-bit
			UCSR_EMETER_C |= (1<<UCSZ_EMETER_1) | (1<<UCSZ_EMETER_0);
    96d0:	86 60       	ori	r24, 0x06	; 6
    96d2:	80 93 9d 00 	sts	0x009D, r24
    96d6:	08 95       	ret

000096d8 <ApplyUARTParam>:
	}
}
// ~~~~~~~~~~~
void ApplyUARTParam(void){
	
	uint16_t Temp16 = EM_UART_Rate + (EM_UART_Parity<<8) + (EM_UART_StopBits<<10) + (EM_UART_BitQt<<11);
    96d8:	80 91 6b 0a 	lds	r24, 0x0A6B
    96dc:	60 91 0c 06 	lds	r22, 0x060C
    96e0:	70 e0       	ldi	r23, 0x00	; 0
    96e2:	76 2f       	mov	r23, r22
    96e4:	66 27       	eor	r22, r22
    96e6:	68 0f       	add	r22, r24
    96e8:	71 1d       	adc	r23, r1
    96ea:	80 91 42 09 	lds	r24, 0x0942
    96ee:	90 e0       	ldi	r25, 0x00	; 0
    96f0:	98 2f       	mov	r25, r24
    96f2:	88 27       	eor	r24, r24
    96f4:	99 0f       	add	r25, r25
    96f6:	99 0f       	add	r25, r25
    96f8:	68 0f       	add	r22, r24
    96fa:	79 1f       	adc	r23, r25
    96fc:	80 91 72 0a 	lds	r24, 0x0A72
    9700:	90 e0       	ldi	r25, 0x00	; 0
    9702:	98 2f       	mov	r25, r24
    9704:	88 27       	eor	r24, r24
    9706:	99 0f       	add	r25, r25
    9708:	99 0f       	add	r25, r25
    970a:	99 0f       	add	r25, r25
    970c:	68 0f       	add	r22, r24
    970e:	79 1f       	adc	r23, r25
	eww(&EM_UART_Param, Temp16);
    9710:	87 e2       	ldi	r24, 0x27	; 39
    9712:	90 e0       	ldi	r25, 0x00	; 0
    9714:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>
	if(!UART_Soft){	//    -   GSM_DebugMode  Modbus
    9718:	80 91 75 0a 	lds	r24, 0x0A75
    971c:	81 11       	cpse	r24, r1
    971e:	06 c0       	rjmp	.+12     	; 0x972c <ApplyUARTParam+0x54>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9720:	87 e2       	ldi	r24, 0x27	; 39
    9722:	90 e0       	ldi	r25, 0x00	; 0
    9724:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		EM_SetUARTParam(erw(&EM_UART_Param));
    9728:	0e 94 f9 4a 	call	0x95f2	; 0x95f2 <EM_SetUARTParam>
	}
	Modbus_ReadHoldReg();
    972c:	0c 94 25 2a 	jmp	0x544a	; 0x544a <Modbus_ReadHoldReg>

00009730 <ChangeUARTParam>:
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9730:	89 e2       	ldi	r24, 0x29	; 41
    9732:	90 e0       	ldi	r25, 0x00	; 0
    9734:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
// ~~~~~~~~~~~
void ChangeUARTParam(void){
	if( erb(&EMeterType) == EM_NONE){
		
	}
	if(erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9738:	81 30       	cpi	r24, 0x01	; 1
    973a:	51 f4       	brne	.+20     	; 0x9750 <ChangeUARTParam+0x20>
		//    9600, 7, E,1
		EM_UART_Rate = 3;
    973c:	93 e0       	ldi	r25, 0x03	; 3
    973e:	90 93 6b 0a 	sts	0x0A6B, r25
		EM_UART_Parity = 1;
    9742:	80 93 0c 06 	sts	0x060C, r24
		EM_UART_StopBits = 0;
    9746:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 2;
    974a:	82 e0       	ldi	r24, 0x02	; 2
    974c:	80 93 72 0a 	sts	0x0A72, r24
    9750:	89 e2       	ldi	r24, 0x29	; 41
    9752:	90 e0       	ldi	r25, 0x00	; 0
    9754:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	}
	if( (erb(&EMeterType) == ELVIN) || (erb(&EMeterType) == MERCURY_230) || (erb(&EMeterType) == ELVIN_MODEM) ){
    9758:	82 50       	subi	r24, 0x02	; 2
    975a:	83 30       	cpi	r24, 0x03	; 3
    975c:	48 f4       	brcc	.+18     	; 0x9770 <ChangeUARTParam+0x40>
		//    9600, 8, N,1
		EM_UART_Rate = 3;
    975e:	83 e0       	ldi	r24, 0x03	; 3
    9760:	80 93 6b 0a 	sts	0x0A6B, r24
		EM_UART_Parity = 0;
    9764:	10 92 0c 06 	sts	0x060C, r1
		EM_UART_StopBits = 0;
    9768:	10 92 42 09 	sts	0x0942, r1
		EM_UART_BitQt = 3;		
    976c:	80 93 72 0a 	sts	0x0A72, r24
	}
	ApplyUARTParam();
    9770:	0c 94 6c 4b 	jmp	0x96d8	; 0x96d8 <ApplyUARTParam>

00009774 <EMeter_ReInit>:
	}
}
void EMeter_ReInit(void){

	//RS485
	MB_PLC_Init();
    9774:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <MB_PLC_Init>
	
	#ifdef CTS
		CTS_Config();
    9778:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <CTS_Config>
		CTS_OFF();
    977c:	0e 94 e0 2e 	call	0x5dc0	; 0x5dc0 <CTS_OFF>
	#endif
	#ifdef RTS
		RTS_Config();
    9780:	0e 94 e2 2e 	call	0x5dc4	; 0x5dc4 <RTS_Config>
	#endif

	EM_InitFIFO();
    9784:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_InitFIFO>

	UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9788:	88 e9       	ldi	r24, 0x98	; 152
    978a:	80 93 9a 00 	sts	0x009A, r24
	UCSR_EMETER_A = (1<<TXC_EMETER) | (0<<U2X_EMETER) | (0<<MPCM_EMETER); //Clear TXC_EMETER -  pending interrupt
    978e:	80 e4       	ldi	r24, 0x40	; 64
    9790:	80 93 9b 00 	sts	0x009B, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9794:	87 e2       	ldi	r24, 0x27	; 39
    9796:	90 e0       	ldi	r25, 0x00	; 0
    9798:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>

	EM_SetUARTParam(erw(&EM_UART_Param));
    979c:	0e 94 f9 4a 	call	0x95f2	; 0x95f2 <EM_SetUARTParam>

	EM_HalfBufferStart= EMeter_RxStr;//----    
    97a0:	8c e3       	ldi	r24, 0x3C	; 60
    97a2:	97 e0       	ldi	r25, 0x07	; 7
    97a4:	90 93 88 09 	sts	0x0988, r25
    97a8:	80 93 87 09 	sts	0x0987, r24
	EMeter_RxStr_Offset = EMeter_RxStr;
    97ac:	90 93 08 06 	sts	0x0608, r25
    97b0:	80 93 07 06 	sts	0x0607, r24
	EM_BufferReadEnable=0;//----- 
    97b4:	10 92 50 09 	sts	0x0950, r1
	EMeter_RxCharN=0;
    97b8:	10 92 3f 0d 	sts	0x0D3F, r1
    97bc:	10 92 3e 0d 	sts	0x0D3E, r1
    97c0:	08 95       	ret

000097c2 <GSM_CloseTransparent>:
	return i;	
}
// ~~~~~~~~~~~
void GSM_CloseTransparent(void)
{	
	if(Transparent){
    97c2:	80 91 76 0a 	lds	r24, 0x0A76
    97c6:	88 23       	and	r24, r24
    97c8:	31 f0       	breq	.+12     	; 0x97d6 <GSM_CloseTransparent+0x14>
		cli();		
    97ca:	f8 94       	cli
		Transparent = 0;
    97cc:	10 92 76 0a 	sts	0x0A76, r1
		EMeter_ReInit();
    97d0:	0e 94 ba 4b 	call	0x9774	; 0x9774 <EMeter_ReInit>
		sei();		
    97d4:	78 94       	sei
	}
	StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    97d6:	6f ef       	ldi	r22, 0xFF	; 255
    97d8:	7f ef       	ldi	r23, 0xFF	; 255
    97da:	80 91 59 02 	lds	r24, 0x0259
    97de:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>

000097e2 <EMeter_Init>:

// ~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
Timer16SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer16Sys;
    97e2:	80 91 0e 01 	lds	r24, 0x010E
	VacantTimer16Sys += n;
    97e6:	91 e0       	ldi	r25, 0x01	; 1
    97e8:	98 0f       	add	r25, r24
    97ea:	90 93 0e 01 	sts	0x010E, r25

}
// ~~~~~~~~~~~

void EMeter_Init(void){
	TD_EMeter = Timer16SysAlloc(1);
    97ee:	80 93 38 0c 	sts	0x0C38, r24
	EMeter_ReInit();
    97f2:	0e 94 ba 4b 	call	0x9774	; 0x9774 <EMeter_ReInit>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    97f6:	8a e0       	ldi	r24, 0x0A	; 10
    97f8:	90 e0       	ldi	r25, 0x00	; 0
    97fa:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	if(erb(&AutoSend)){
    97fe:	88 23       	and	r24, r24
    9800:	49 f0       	breq	.+18     	; 0x9814 <EMeter_Init+0x32>
		StartTimer16(TD_EMeter,1000);
    9802:	68 ee       	ldi	r22, 0xE8	; 232
    9804:	73 e0       	ldi	r23, 0x03	; 3
    9806:	80 91 38 0c 	lds	r24, 0x0C38
    980a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
		EM_Mode = 0;
    980e:	10 92 71 0a 	sts	0x0A71, r1
    9812:	08 95       	ret
	}
	else{
		EM_Mode = 255;
    9814:	8f ef       	ldi	r24, 0xFF	; 255
    9816:	80 93 71 0a 	sts	0x0A71, r24
    981a:	08 95       	ret

0000981c <USART_Init>:
}

uint8_t
Timer8SysAlloc(uint8_t n)
{
	uint8_t N = VacantTimer8Sys;
    981c:	80 91 0f 01 	lds	r24, 0x010F
	VacantTimer8Sys += n;
    9820:	91 e0       	ldi	r25, 0x01	; 1
    9822:	98 0f       	add	r25, r24
    9824:	90 93 0f 01 	sts	0x010F, r25

// ~~~~~~~~~~~~~
void
USART_Init(void)
{	
	TD_UART_Soft = Timer8SysAlloc(1);
    9828:	80 93 4c 09 	sts	0x094C, r24

	MB_Init();
    982c:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <MB_Init>
	EMeter_Init();
    9830:	0e 94 f1 4b 	call	0x97e2	; 0x97e2 <EMeter_Init>

	//set PORTA.0 input with pull'up
	DDRA &= ~(1<<PA0);
    9834:	d0 98       	cbi	0x1a, 0	; 26
	PORTA |= (1<<PA0);
    9836:	d8 9a       	sbi	0x1b, 0	; 27
    9838:	85 e3       	ldi	r24, 0x35	; 53
    983a:	8a 95       	dec	r24
    983c:	f1 f7       	brne	.-4      	; 0x983a <USART_Init+0x1e>
    983e:	00 00       	nop
	_delay_us(10);
	
	if(!(PINA & (1<<PA0))){
    9840:	c8 99       	sbic	0x19, 0	; 25
    9842:	08 c0       	rjmp	.+16     	; 0x9854 <USART_Init+0x38>
		MB_Init();
    9844:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <MB_Init>
		UART_Soft = 1;
    9848:	81 e0       	ldi	r24, 0x01	; 1
    984a:	80 93 75 0a 	sts	0x0A75, r24
		ModbusMode = 1;
    984e:	80 93 e0 03 	sts	0x03E0, r24
    9852:	06 c0       	rjmp	.+12     	; 0x9860 <USART_Init+0x44>
	}
	else{
		EMeter_ReInit();
    9854:	0e 94 ba 4b 	call	0x9774	; 0x9774 <EMeter_ReInit>
		UART_Soft = 0;
    9858:	10 92 75 0a 	sts	0x0A75, r1
		ModbusMode = 0;
    985c:	10 92 e0 03 	sts	0x03E0, r1
	}
	
	GSM_Init();
    9860:	0c 94 ec 3a 	jmp	0x75d8	; 0x75d8 <GSM_Init>

00009864 <EMeter_RX>:
}

// ~~~~~~~~~
void EMeter_RX(void){
	//----- Transparent
	if(Transparent){
    9864:	80 91 76 0a 	lds	r24, 0x0A76
    9868:	88 23       	and	r24, r24
    986a:	a9 f1       	breq	.+106    	; 0x98d6 <EMeter_RX+0x72>
					StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    986c:	60 91 0b 01 	lds	r22, 0x010B
    9870:	70 91 0c 01 	lds	r23, 0x010C
    9874:	80 91 40 0d 	lds	r24, 0x0D40
    9878:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    987c:	60 91 09 01 	lds	r22, 0x0109
    9880:	70 91 0a 01 	lds	r23, 0x010A
    9884:	80 91 0b 06 	lds	r24, 0x060B
    9888:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					EMeterIsLink=1;
    988c:	81 e0       	ldi	r24, 0x01	; 1
    988e:	80 93 5d 09 	sts	0x095D, r24
		char Char = UDR_EMETER;
    9892:	90 91 9c 00 	lds	r25, 0x009C

		//---FIFO
		EM_RX_FIFO_Begin++;
    9896:	80 91 70 09 	lds	r24, 0x0970
    989a:	8f 5f       	subi	r24, 0xFF	; 255
    989c:	80 93 70 09 	sts	0x0970, r24
		if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    98a0:	80 91 70 09 	lds	r24, 0x0970
    98a4:	8f 3f       	cpi	r24, 0xFF	; 255
    98a6:	11 f4       	brne	.+4      	; 0x98ac <EMeter_RX+0x48>
    98a8:	10 92 70 09 	sts	0x0970, r1
		EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    98ac:	e0 91 70 09 	lds	r30, 0x0970
    98b0:	f0 e0       	ldi	r31, 0x00	; 0
    98b2:	e7 50       	subi	r30, 0x07	; 7
    98b4:	fc 4f       	sbci	r31, 0xFC	; 252
    98b6:	90 83       	st	Z, r25
		if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    98b8:	90 91 70 09 	lds	r25, 0x0970
    98bc:	80 91 38 0d 	lds	r24, 0x0D38
    98c0:	98 13       	cpse	r25, r24
    98c2:	06 c0       	rjmp	.+12     	; 0x98d0 <EMeter_RX+0x6c>
			EM_RX_FIFOOverFlow = 1;
    98c4:	81 e0       	ldi	r24, 0x01	; 1
    98c6:	80 93 24 0b 	sts	0x0B24, r24
			EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    98ca:	8f ef       	ldi	r24, 0xFF	; 255
    98cc:	80 93 6e 0a 	sts	0x0A6E, r24
			
		}

		// enable DRE interrupt for UDR0
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    98d0:	88 eb       	ldi	r24, 0xB8	; 184
    98d2:	8a b9       	out	0x0a, r24	; 10
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    98d4:	5e 9a       	sbi	0x0b, 6	; 11
    98d6:	08 95       	ret

000098d8 <__vector_30>:
ISR(USART1_TX_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_TX();
	COMM_LED = 1;
}
ISR(USART1_RX_vect){
    98d8:	1f 92       	push	r1
    98da:	0f 92       	push	r0
    98dc:	0f b6       	in	r0, 0x3f	; 63
    98de:	0f 92       	push	r0
    98e0:	11 24       	eor	r1, r1
    98e2:	0b b6       	in	r0, 0x3b	; 59
    98e4:	0f 92       	push	r0
    98e6:	2f 93       	push	r18
    98e8:	3f 93       	push	r19
    98ea:	4f 93       	push	r20
    98ec:	5f 93       	push	r21
    98ee:	6f 93       	push	r22
    98f0:	7f 93       	push	r23
    98f2:	8f 93       	push	r24
    98f4:	9f 93       	push	r25
    98f6:	af 93       	push	r26
    98f8:	bf 93       	push	r27
    98fa:	ef 93       	push	r30
    98fc:	ff 93       	push	r31
	if(ModbusMode) Modbus_RX(&UDR1);
    98fe:	80 91 e0 03 	lds	r24, 0x03E0
    9902:	88 23       	and	r24, r24
    9904:	29 f0       	breq	.+10     	; 0x9910 <__vector_30+0x38>
    9906:	8c e9       	ldi	r24, 0x9C	; 156
    9908:	90 e0       	ldi	r25, 0x00	; 0
    990a:	0e 94 0d 30 	call	0x601a	; 0x601a <Modbus_RX>
    990e:	02 c0       	rjmp	.+4      	; 0x9914 <__vector_30+0x3c>
	else EMeter_RX();
    9910:	0e 94 32 4c 	call	0x9864	; 0x9864 <EMeter_RX>
	COMM_LED = 1;
    9914:	81 e0       	ldi	r24, 0x01	; 1
    9916:	80 93 10 06 	sts	0x0610, r24
}	
    991a:	ff 91       	pop	r31
    991c:	ef 91       	pop	r30
    991e:	bf 91       	pop	r27
    9920:	af 91       	pop	r26
    9922:	9f 91       	pop	r25
    9924:	8f 91       	pop	r24
    9926:	7f 91       	pop	r23
    9928:	6f 91       	pop	r22
    992a:	5f 91       	pop	r21
    992c:	4f 91       	pop	r20
    992e:	3f 91       	pop	r19
    9930:	2f 91       	pop	r18
    9932:	0f 90       	pop	r0
    9934:	0b be       	out	0x3b, r0	; 59
    9936:	0f 90       	pop	r0
    9938:	0f be       	out	0x3f, r0	; 63
    993a:	0f 90       	pop	r0
    993c:	1f 90       	pop	r1
    993e:	18 95       	reti

00009940 <EMeter_TX>:
		}
	}
}
// ~~~~~~~~~
void EMeter_TX(void){
	if(Transparent){
    9940:	80 91 76 0a 	lds	r24, 0x0A76
    9944:	88 23       	and	r24, r24
    9946:	21 f0       	breq	.+8      	; 0x9950 <EMeter_TX+0x10>
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9948:	88 e9       	ldi	r24, 0x98	; 152
    994a:	80 93 9a 00 	sts	0x009A, r24
    994e:	05 c0       	rjmp	.+10     	; 0x995a <EMeter_TX+0x1a>
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
	}
	else{
		UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    9950:	88 e9       	ldi	r24, 0x98	; 152
    9952:	80 93 9a 00 	sts	0x009A, r24
		EMeter_TxFlag = 0;
    9956:	10 92 59 09 	sts	0x0959, r1
		PORTD &= ~(1<<PD4);	//RS485 Tx_off
    995a:	94 98       	cbi	0x12, 4	; 18
    995c:	08 95       	ret

0000995e <__vector_32>:
ISR(USART1_UDRE_vect){
	if(ModbusMode) Modbus_TX(&UDR1);
	else EMeter_DRE();
	COMM_LED = 1;
}
ISR(USART1_TX_vect){
    995e:	1f 92       	push	r1
    9960:	0f 92       	push	r0
    9962:	0f b6       	in	r0, 0x3f	; 63
    9964:	0f 92       	push	r0
    9966:	11 24       	eor	r1, r1
    9968:	0b b6       	in	r0, 0x3b	; 59
    996a:	0f 92       	push	r0
    996c:	2f 93       	push	r18
    996e:	3f 93       	push	r19
    9970:	4f 93       	push	r20
    9972:	5f 93       	push	r21
    9974:	6f 93       	push	r22
    9976:	7f 93       	push	r23
    9978:	8f 93       	push	r24
    997a:	9f 93       	push	r25
    997c:	af 93       	push	r26
    997e:	bf 93       	push	r27
    9980:	ef 93       	push	r30
    9982:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    9984:	80 91 e0 03 	lds	r24, 0x03E0
    9988:	88 23       	and	r24, r24
    998a:	29 f0       	breq	.+10     	; 0x9996 <__vector_32+0x38>
    998c:	8c e9       	ldi	r24, 0x9C	; 156
    998e:	90 e0       	ldi	r25, 0x00	; 0
    9990:	0e 94 83 38 	call	0x7106	; 0x7106 <Modbus_TX>
    9994:	02 c0       	rjmp	.+4      	; 0x999a <__vector_32+0x3c>
	else EMeter_TX();
    9996:	0e 94 a0 4c 	call	0x9940	; 0x9940 <EMeter_TX>
	COMM_LED = 1;
    999a:	81 e0       	ldi	r24, 0x01	; 1
    999c:	80 93 10 06 	sts	0x0610, r24
}
    99a0:	ff 91       	pop	r31
    99a2:	ef 91       	pop	r30
    99a4:	bf 91       	pop	r27
    99a6:	af 91       	pop	r26
    99a8:	9f 91       	pop	r25
    99aa:	8f 91       	pop	r24
    99ac:	7f 91       	pop	r23
    99ae:	6f 91       	pop	r22
    99b0:	5f 91       	pop	r21
    99b2:	4f 91       	pop	r20
    99b4:	3f 91       	pop	r19
    99b6:	2f 91       	pop	r18
    99b8:	0f 90       	pop	r0
    99ba:	0b be       	out	0x3b, r0	; 59
    99bc:	0f 90       	pop	r0
    99be:	0f be       	out	0x3f, r0	; 63
    99c0:	0f 90       	pop	r0
    99c2:	1f 90       	pop	r1
    99c4:	18 95       	reti

000099c6 <EMeter_Link>:

}
// ~~~~~~~~~
uint8_t EMeter_Link(void){
//	if(EM_Retry>9) return 0;
	if(EM_Retry>=1) return 0;
    99c6:	81 e0       	ldi	r24, 0x01	; 1
    99c8:	90 91 05 01 	lds	r25, 0x0105
    99cc:	91 11       	cpse	r25, r1
    99ce:	80 e0       	ldi	r24, 0x00	; 0
	else return 1;
}
    99d0:	08 95       	ret

000099d2 <IsEMReady>:
		}
	}	
}
// ~~~~~~~~~
uint8_t IsEMReady(void){
	if(EM_Mode == 255) return 1;
    99d2:	81 e0       	ldi	r24, 0x01	; 1
    99d4:	90 91 71 0a 	lds	r25, 0x0A71
    99d8:	9f 3f       	cpi	r25, 0xFF	; 255
    99da:	09 f0       	breq	.+2      	; 0x99de <IsEMReady+0xc>
    99dc:	80 e0       	ldi	r24, 0x00	; 0
	else return 0;
}
    99de:	08 95       	ret

000099e0 <EMRead>:
    99e0:	89 e2       	ldi	r24, 0x29	; 41
    99e2:	90 e0       	ldi	r25, 0x00	; 0
    99e4:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>

// ~~~~~~~~~
void EMRead(void){
	if(erb(&EMeterType) != ELVIN_MODEM)	EM_Mode = 0;
    99e8:	84 30       	cpi	r24, 0x04	; 4
    99ea:	11 f0       	breq	.+4      	; 0x99f0 <EMRead+0x10>
    99ec:	10 92 71 0a 	sts	0x0A71, r1
    99f0:	08 95       	ret

000099f2 <GPRS_AppInit>:

uint16_t Password[PASSWORDS_Qt] EEMEM= PASSWORD_Init;

// -----
void GPRS_AppInit(void){
	GPRS_TD_CrashSendRetry		= Timer16Alloc();		//      
    99f2:	0e 94 98 2a 	call	0x5530	; 0x5530 <Timer16Alloc>
    99f6:	80 93 0f 06 	sts	0x060F, r24
	GPRS_TD_SessionIDGenerator	= Timer16Alloc();		//     SessionID
    99fa:	0e 94 98 2a 	call	0x5530	; 0x5530 <Timer16Alloc>
    99fe:	80 93 4e 09 	sts	0x094E, r24
	GPRS_TD_CriticalCMD			= Timer16Alloc();		//       
    9a02:	0e 94 98 2a 	call	0x5530	; 0x5530 <Timer16Alloc>
    9a06:	80 93 0c 0b 	sts	0x0B0C, r24
	StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    9a0a:	6f ef       	ldi	r22, 0xFF	; 255
    9a0c:	7f ef       	ldi	r23, 0xFF	; 255
    9a0e:	80 91 4e 09 	lds	r24, 0x094E
    9a12:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
	if(Timer16AllocErr()) GPRS_Flags |= (1<<GPRS_flg_Fail);
    9a16:	80 91 11 01 	lds	r24, 0x0111
    9a1a:	88 32       	cpi	r24, 0x28	; 40
    9a1c:	28 f0       	brcs	.+10     	; 0x9a28 <GPRS_AppInit+0x36>
    9a1e:	80 91 69 09 	lds	r24, 0x0969
    9a22:	81 60       	ori	r24, 0x01	; 1
    9a24:	80 93 69 09 	sts	0x0969, r24
    9a28:	08 95       	ret

00009a2a <GPRS_AddHeader>:
}
void GPRS_AddHeader(uint8_t* Buf, uint8_t Type, uint8_t Func, uint8_t Size){
    9a2a:	0f 93       	push	r16
    9a2c:	1f 93       	push	r17
    9a2e:	cf 93       	push	r28
    9a30:	df 93       	push	r29
    9a32:	00 d0       	rcall	.+0      	; 0x9a34 <GPRS_AddHeader+0xa>
    9a34:	1f 92       	push	r1
    9a36:	cd b7       	in	r28, 0x3d	; 61
    9a38:	de b7       	in	r29, 0x3e	; 62
    9a3a:	8c 01       	movw	r16, r24

	Buf[0] = 5;	
    9a3c:	85 e0       	ldi	r24, 0x05	; 5
    9a3e:	f8 01       	movw	r30, r16
    9a40:	80 83       	st	Z, r24
	Buf[1] = 1;	
    9a42:	81 e0       	ldi	r24, 0x01	; 1
    9a44:	81 83       	std	Z+1, r24	; 0x01
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9a46:	8c e0       	ldi	r24, 0x0C	; 12
    9a48:	91 e0       	ldi	r25, 0x01	; 1
    9a4a:	2b 83       	std	Y+3, r18	; 0x03
    9a4c:	4a 83       	std	Y+2, r20	; 0x02
    9a4e:	69 83       	std	Y+1, r22	; 0x01
    9a50:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	Buf[2] = erw(&Vega_SN)>>8;
    9a54:	f8 01       	movw	r30, r16
    9a56:	92 83       	std	Z+2, r25	; 0x02
    9a58:	8c e0       	ldi	r24, 0x0C	; 12
    9a5a:	91 e0       	ldi	r25, 0x01	; 1
    9a5c:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	Buf[3] = (uint8_t)erw(&Vega_SN);		
    9a60:	f8 01       	movw	r30, r16
    9a62:	83 83       	std	Z+3, r24	; 0x03
	Buf[4] = Type;
    9a64:	69 81       	ldd	r22, Y+1	; 0x01
    9a66:	64 83       	std	Z+4, r22	; 0x04
	Buf[5] = Size;	// -       
    9a68:	2b 81       	ldd	r18, Y+3	; 0x03
    9a6a:	25 83       	std	Z+5, r18	; 0x05
	Buf[6] = Func;		
    9a6c:	4a 81       	ldd	r20, Y+2	; 0x02
    9a6e:	46 83       	std	Z+6, r20	; 0x06
}
    9a70:	0f 90       	pop	r0
    9a72:	0f 90       	pop	r0
    9a74:	0f 90       	pop	r0
    9a76:	df 91       	pop	r29
    9a78:	cf 91       	pop	r28
    9a7a:	1f 91       	pop	r17
    9a7c:	0f 91       	pop	r16
    9a7e:	08 95       	ret

00009a80 <GPRS_CurDataSend>:

// -----               
void ModeStr(char *);
// ~~~~  GPRS_Data_Out[100]   
void GPRS_CurDataSend(void){
    9a80:	cf 92       	push	r12
    9a82:	df 92       	push	r13
    9a84:	ef 92       	push	r14
    9a86:	ff 92       	push	r15
    9a88:	0f 93       	push	r16
    9a8a:	1f 93       	push	r17
    9a8c:	cf 93       	push	r28
    9a8e:	df 93       	push	r29
	GPRS_Data_Out[0] = 6;	//    
    9a90:	86 e0       	ldi	r24, 0x06	; 6
    9a92:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    9a96:	81 e0       	ldi	r24, 0x01	; 1
    9a98:	80 93 3a 0b 	sts	0x0B3A, r24
	//---VegaID64
	GPRS_Data_Out[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9a9c:	90 91 7a 09 	lds	r25, 0x097A
    9aa0:	90 93 3b 0b 	sts	0x0B3B, r25
	GPRS_Data_Out[3] = *((uint8_t*)&ICCID+6);
    9aa4:	90 91 79 09 	lds	r25, 0x0979
    9aa8:	90 93 3c 0b 	sts	0x0B3C, r25
	GPRS_Data_Out[4] = *((uint8_t*)&ICCID+5);
    9aac:	90 91 78 09 	lds	r25, 0x0978
    9ab0:	90 93 3d 0b 	sts	0x0B3D, r25
	GPRS_Data_Out[5] = *((uint8_t*)&ICCID+4);
    9ab4:	90 91 77 09 	lds	r25, 0x0977
    9ab8:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = *((uint8_t*)&ICCID+3);
    9abc:	90 91 76 09 	lds	r25, 0x0976
    9ac0:	90 93 3f 0b 	sts	0x0B3F, r25
	GPRS_Data_Out[7] = *((uint8_t*)&ICCID+2);
    9ac4:	90 91 75 09 	lds	r25, 0x0975
    9ac8:	90 93 40 0b 	sts	0x0B40, r25
	GPRS_Data_Out[8] = *((uint8_t*)&ICCID+1);
    9acc:	90 91 74 09 	lds	r25, 0x0974
    9ad0:	90 93 41 0b 	sts	0x0B41, r25
	GPRS_Data_Out[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9ad4:	90 91 73 09 	lds	r25, 0x0973
    9ad8:	90 93 42 0b 	sts	0x0B42, r25

	GPRS_Data_Out[10] = GPRS_CURDATA;	//    
    9adc:	80 93 43 0b 	sts	0x0B43, r24
	GPRS_Data_Out[11] = SW_VERSION;		//   
    9ae0:	83 e0       	ldi	r24, 0x03	; 3
    9ae2:	80 93 44 0b 	sts	0x0B44, r24
	GPRS_Data_Out[12] = SW_SUBVERSION;	//   
    9ae6:	87 e0       	ldi	r24, 0x07	; 7
    9ae8:	80 93 45 0b 	sts	0x0B45, r24

	GPRS_Data_Out[13] = 60;			// -       
    9aec:	8c e3       	ldi	r24, 0x3C	; 60
    9aee:	80 93 46 0b 	sts	0x0B46, r24

	GPRS_Data_Out[14] = GSM_MyIP.IP1;			// -       
    9af2:	80 91 1c 0b 	lds	r24, 0x0B1C
    9af6:	80 93 47 0b 	sts	0x0B47, r24
	GPRS_Data_Out[15] = GSM_MyIP.IP2;			// -       
    9afa:	80 91 1d 0b 	lds	r24, 0x0B1D
    9afe:	80 93 48 0b 	sts	0x0B48, r24
	GPRS_Data_Out[16] = GSM_MyIP.IP3;			// -       
    9b02:	80 91 1e 0b 	lds	r24, 0x0B1E
    9b06:	80 93 49 0b 	sts	0x0B49, r24
	GPRS_Data_Out[17] = GSM_MyIP.IP4;			// -       
    9b0a:	80 91 1f 0b 	lds	r24, 0x0B1F
    9b0e:	80 93 4a 0b 	sts	0x0B4A, r24

	if(EMeter_Link()){
    9b12:	0e 94 e3 4c 	call	0x99c6	; 0x99c6 <EMeter_Link>
    9b16:	88 23       	and	r24, r24
    9b18:	f1 f0       	breq	.+60     	; 0x9b56 <GPRS_CurDataSend+0xd6>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9b1a:	89 e2       	ldi	r24, 0x29	; 41
    9b1c:	90 e0       	ldi	r25, 0x00	; 0
    9b1e:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		if( erb(&EMeterType) == LANDIS_GYR_ZMR110){
    9b22:	81 30       	cpi	r24, 0x01	; 1
    9b24:	a9 f4       	brne	.+42     	; 0x9b50 <GPRS_CurDataSend+0xd0>
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("L&G   %8s"), EM_ID_Str);	// 
    9b26:	82 e7       	ldi	r24, 0x72	; 114
    9b28:	98 e0       	ldi	r25, 0x08	; 8
    9b2a:	9f 93       	push	r25
    9b2c:	8f 93       	push	r24
    9b2e:	8e ee       	ldi	r24, 0xEE	; 238
    9b30:	92 e0       	ldi	r25, 0x02	; 2
    9b32:	9f 93       	push	r25
    9b34:	8f 93       	push	r24
    9b36:	8b e4       	ldi	r24, 0x4B	; 75
    9b38:	9b e0       	ldi	r25, 0x0B	; 11
    9b3a:	9f 93       	push	r25
    9b3c:	8f 93       	push	r24
    9b3e:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
    9b42:	0f 90       	pop	r0
    9b44:	0f 90       	pop	r0
    9b46:	0f 90       	pop	r0
    9b48:	0f 90       	pop	r0
    9b4a:	0f 90       	pop	r0
    9b4c:	0f 90       	pop	r0
    9b4e:	11 c0       	rjmp	.+34     	; 0x9b72 <GPRS_CurDataSend+0xf2>
		}
		else{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("   "));	// 
    9b50:	8e ed       	ldi	r24, 0xDE	; 222
    9b52:	92 e0       	ldi	r25, 0x02	; 2
    9b54:	02 c0       	rjmp	.+4      	; 0x9b5a <GPRS_CurDataSend+0xda>
		}
	}
	else 
	{
			sprintf_P((char*)GPRS_Data_Out+18,PSTR("    "));	// 
    9b56:	8e ec       	ldi	r24, 0xCE	; 206
    9b58:	92 e0       	ldi	r25, 0x02	; 2
    9b5a:	9f 93       	push	r25
    9b5c:	8f 93       	push	r24
    9b5e:	8b e4       	ldi	r24, 0x4B	; 75
    9b60:	9b e0       	ldi	r25, 0x0B	; 11
    9b62:	9f 93       	push	r25
    9b64:	8f 93       	push	r24
    9b66:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
    9b6a:	0f 90       	pop	r0
    9b6c:	0f 90       	pop	r0
    9b6e:	0f 90       	pop	r0
    9b70:	0f 90       	pop	r0
			
		
	}
	int16_t	*ptr = (int16_t*)&GPRS_Data_Out[33];	//   ..       GPRS_Data_Out
	//
	ptr[0] = 0;
    9b72:	10 92 5b 0b 	sts	0x0B5B, r1
    9b76:	10 92 5a 0b 	sts	0x0B5A, r1
	if(!EMeter_Link()){
    9b7a:	0e 94 e3 4c 	call	0x99c6	; 0x99c6 <EMeter_Link>
    9b7e:	e0 90 41 0d 	lds	r14, 0x0D41
    9b82:	f0 90 42 0d 	lds	r15, 0x0D42
    9b86:	00 91 e4 03 	lds	r16, 0x03E4
    9b8a:	10 91 e5 03 	lds	r17, 0x03E5
    9b8e:	c0 91 73 0a 	lds	r28, 0x0A73
    9b92:	d0 91 74 0a 	lds	r29, 0x0A74
    9b96:	81 11       	cpse	r24, r1
    9b98:	03 c0       	rjmp	.+6      	; 0x9ba0 <GPRS_CurDataSend+0x120>
		ptr[0] |= (1<<0);
    9b9a:	81 e0       	ldi	r24, 0x01	; 1
    9b9c:	90 e0       	ldi	r25, 0x00	; 0
    9b9e:	ac c0       	rjmp	.+344    	; 0x9cf8 <GPRS_CurDataSend+0x278>
	}
	else{
		if(Ua==0) ptr[0] |= (1<<5);
    9ba0:	e1 14       	cp	r14, r1
    9ba2:	f1 04       	cpc	r15, r1
    9ba4:	31 f4       	brne	.+12     	; 0x9bb2 <GPRS_CurDataSend+0x132>
    9ba6:	80 e2       	ldi	r24, 0x20	; 32
    9ba8:	90 e0       	ldi	r25, 0x00	; 0
    9baa:	90 93 5b 0b 	sts	0x0B5B, r25
    9bae:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Ub==0) ptr[0] |= (1<<6);
    9bb2:	01 15       	cp	r16, r1
    9bb4:	11 05       	cpc	r17, r1
    9bb6:	49 f4       	brne	.+18     	; 0x9bca <GPRS_CurDataSend+0x14a>
    9bb8:	80 91 5a 0b 	lds	r24, 0x0B5A
    9bbc:	90 91 5b 0b 	lds	r25, 0x0B5B
    9bc0:	80 64       	ori	r24, 0x40	; 64
    9bc2:	90 93 5b 0b 	sts	0x0B5B, r25
    9bc6:	80 93 5a 0b 	sts	0x0B5A, r24
		if(Uc==0) ptr[0] |= (1<<7);
    9bca:	20 97       	sbiw	r28, 0x00	; 0
    9bcc:	49 f4       	brne	.+18     	; 0x9be0 <GPRS_CurDataSend+0x160>
    9bce:	80 91 5a 0b 	lds	r24, 0x0B5A
    9bd2:	90 91 5b 0b 	lds	r25, 0x0B5B
    9bd6:	80 68       	ori	r24, 0x80	; 128
    9bd8:	90 93 5b 0b 	sts	0x0B5B, r25
    9bdc:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Magnit_Min_new != EM_Magnit_Min_prev) || (EM_Magnit_Cnt_new != EM_Magnit_Cnt_prev) ) ptr[0] |= (1<<8);
    9be0:	40 91 5f 09 	lds	r20, 0x095F
    9be4:	50 91 60 09 	lds	r21, 0x0960
    9be8:	60 91 61 09 	lds	r22, 0x0961
    9bec:	70 91 62 09 	lds	r23, 0x0962
    9bf0:	80 91 08 0b 	lds	r24, 0x0B08
    9bf4:	90 91 09 0b 	lds	r25, 0x0B09
    9bf8:	a0 91 0a 0b 	lds	r26, 0x0B0A
    9bfc:	b0 91 0b 0b 	lds	r27, 0x0B0B
    9c00:	48 17       	cp	r20, r24
    9c02:	59 07       	cpc	r21, r25
    9c04:	6a 07       	cpc	r22, r26
    9c06:	7b 07       	cpc	r23, r27
    9c08:	59 f4       	brne	.+22     	; 0x9c20 <GPRS_CurDataSend+0x1a0>
    9c0a:	20 91 3f 09 	lds	r18, 0x093F
    9c0e:	30 91 40 09 	lds	r19, 0x0940
    9c12:	80 91 f5 09 	lds	r24, 0x09F5
    9c16:	90 91 f6 09 	lds	r25, 0x09F6
    9c1a:	28 17       	cp	r18, r24
    9c1c:	39 07       	cpc	r19, r25
    9c1e:	49 f0       	breq	.+18     	; 0x9c32 <GPRS_CurDataSend+0x1b2>
    9c20:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c24:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c28:	91 60       	ori	r25, 0x01	; 1
    9c2a:	90 93 5b 0b 	sts	0x0B5B, r25
    9c2e:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Klemm_Min_new != EM_Klemm_Min_prev) || (EM_Klemm_Cnt_new != EM_Klemm_Cnt_prev) ) ptr[0] |= (1<<9);
    9c32:	40 91 20 0b 	lds	r20, 0x0B20
    9c36:	50 91 21 0b 	lds	r21, 0x0B21
    9c3a:	60 91 22 0b 	lds	r22, 0x0B22
    9c3e:	70 91 23 0b 	lds	r23, 0x0B23
    9c42:	80 91 ee 09 	lds	r24, 0x09EE
    9c46:	90 91 ef 09 	lds	r25, 0x09EF
    9c4a:	a0 91 f0 09 	lds	r26, 0x09F0
    9c4e:	b0 91 f1 09 	lds	r27, 0x09F1
    9c52:	48 17       	cp	r20, r24
    9c54:	59 07       	cpc	r21, r25
    9c56:	6a 07       	cpc	r22, r26
    9c58:	7b 07       	cpc	r23, r27
    9c5a:	59 f4       	brne	.+22     	; 0x9c72 <GPRS_CurDataSend+0x1f2>
    9c5c:	20 91 1a 06 	lds	r18, 0x061A
    9c60:	30 91 1b 06 	lds	r19, 0x061B
    9c64:	80 91 f4 03 	lds	r24, 0x03F4
    9c68:	90 91 f5 03 	lds	r25, 0x03F5
    9c6c:	28 17       	cp	r18, r24
    9c6e:	39 07       	cpc	r19, r25
    9c70:	49 f0       	breq	.+18     	; 0x9c84 <GPRS_CurDataSend+0x204>
    9c72:	80 91 5a 0b 	lds	r24, 0x0B5A
    9c76:	90 91 5b 0b 	lds	r25, 0x0B5B
    9c7a:	92 60       	ori	r25, 0x02	; 2
    9c7c:	90 93 5b 0b 	sts	0x0B5B, r25
    9c80:	80 93 5a 0b 	sts	0x0B5A, r24
		if( (EM_Korpus_Min_new != EM_Korpus_Min_prev) || (EM_Korpus_Cnt_new != EM_Korpus_Cnt_prev))  ptr[0] |= (1<<10);
    9c84:	40 91 eb 03 	lds	r20, 0x03EB
    9c88:	50 91 ec 03 	lds	r21, 0x03EC
    9c8c:	60 91 ed 03 	lds	r22, 0x03ED
    9c90:	70 91 ee 03 	lds	r23, 0x03EE
    9c94:	80 91 16 06 	lds	r24, 0x0616
    9c98:	90 91 17 06 	lds	r25, 0x0617
    9c9c:	a0 91 18 06 	lds	r26, 0x0618
    9ca0:	b0 91 19 06 	lds	r27, 0x0619
    9ca4:	48 17       	cp	r20, r24
    9ca6:	59 07       	cpc	r21, r25
    9ca8:	6a 07       	cpc	r22, r26
    9caa:	7b 07       	cpc	r23, r27
    9cac:	59 f4       	brne	.+22     	; 0x9cc4 <GPRS_CurDataSend+0x244>
    9cae:	20 91 1a 0b 	lds	r18, 0x0B1A
    9cb2:	30 91 1b 0b 	lds	r19, 0x0B1B
    9cb6:	80 91 43 0d 	lds	r24, 0x0D43
    9cba:	90 91 44 0d 	lds	r25, 0x0D44
    9cbe:	28 17       	cp	r18, r24
    9cc0:	39 07       	cpc	r19, r25
    9cc2:	49 f0       	breq	.+18     	; 0x9cd6 <GPRS_CurDataSend+0x256>
    9cc4:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cc8:	90 91 5b 0b 	lds	r25, 0x0B5B
    9ccc:	94 60       	ori	r25, 0x04	; 4
    9cce:	90 93 5b 0b 	sts	0x0B5B, r25
    9cd2:	80 93 5a 0b 	sts	0x0B5A, r24
		if(EM_FailCode) ptr[0] |= (1<<11);	//  
    9cd6:	80 91 53 09 	lds	r24, 0x0953
    9cda:	90 91 54 09 	lds	r25, 0x0954
    9cde:	a0 91 55 09 	lds	r26, 0x0955
    9ce2:	b0 91 56 09 	lds	r27, 0x0956
    9ce6:	89 2b       	or	r24, r25
    9ce8:	8a 2b       	or	r24, r26
    9cea:	8b 2b       	or	r24, r27
    9cec:	49 f0       	breq	.+18     	; 0x9d00 <GPRS_CurDataSend+0x280>
    9cee:	80 91 5a 0b 	lds	r24, 0x0B5A
    9cf2:	90 91 5b 0b 	lds	r25, 0x0B5B
    9cf6:	98 60       	ori	r25, 0x08	; 8
    9cf8:	90 93 5b 0b 	sts	0x0B5B, r25
    9cfc:	80 93 5a 0b 	sts	0x0B5A, r24
	
	}
	if(!DI_Status(0)) ptr[0] |= (1<<1);
    9d00:	80 e0       	ldi	r24, 0x00	; 0
    9d02:	0e 94 bf 3b 	call	0x777e	; 0x777e <DI_Status>
    9d06:	81 11       	cpse	r24, r1
    9d08:	09 c0       	rjmp	.+18     	; 0x9d1c <GPRS_CurDataSend+0x29c>
    9d0a:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d0e:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d12:	82 60       	ori	r24, 0x02	; 2
    9d14:	90 93 5b 0b 	sts	0x0B5B, r25
    9d18:	80 93 5a 0b 	sts	0x0B5A, r24
	if(!DI_Status(1)) ptr[0] |= (1<<2);
    9d1c:	81 e0       	ldi	r24, 0x01	; 1
    9d1e:	0e 94 bf 3b 	call	0x777e	; 0x777e <DI_Status>
    9d22:	81 11       	cpse	r24, r1
    9d24:	09 c0       	rjmp	.+18     	; 0x9d38 <GPRS_CurDataSend+0x2b8>
    9d26:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d2a:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d2e:	84 60       	ori	r24, 0x04	; 4
    9d30:	90 93 5b 0b 	sts	0x0B5B, r25
    9d34:	80 93 5a 0b 	sts	0x0B5A, r24
	if((Temperature[0] != Therm_Off_Mark) && (Temperature[0] != ADC_Off_Mark)){
    9d38:	c0 90 f2 05 	lds	r12, 0x05F2
    9d3c:	d0 90 f3 05 	lds	r13, 0x05F3
    9d40:	c6 01       	movw	r24, r12
    9d42:	90 58       	subi	r25, 0x80	; 128
    9d44:	02 97       	sbiw	r24, 0x02	; 2
    9d46:	00 f1       	brcs	.+64     	; 0x9d88 <GPRS_CurDataSend+0x308>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9d48:	8d e0       	ldi	r24, 0x0D	; 13
    9d4a:	90 e0       	ldi	r25, 0x00	; 0
    9d4c:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		if(Temperature[0] >= (int16_t)erw(&Thigh)) ptr[0] |= (1<<3);
    9d50:	c8 16       	cp	r12, r24
    9d52:	d9 06       	cpc	r13, r25
    9d54:	4c f0       	brlt	.+18     	; 0x9d68 <GPRS_CurDataSend+0x2e8>
    9d56:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d5a:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d5e:	88 60       	ori	r24, 0x08	; 8
    9d60:	90 93 5b 0b 	sts	0x0B5B, r25
    9d64:	80 93 5a 0b 	sts	0x0B5A, r24
    9d68:	8b e0       	ldi	r24, 0x0B	; 11
    9d6a:	90 e0       	ldi	r25, 0x00	; 0
    9d6c:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		if(Temperature[0] <= (int16_t)erw(&Tlow)) ptr[0] |= (1<<4);
    9d70:	8c 15       	cp	r24, r12
    9d72:	9d 05       	cpc	r25, r13
    9d74:	4c f0       	brlt	.+18     	; 0x9d88 <GPRS_CurDataSend+0x308>
    9d76:	80 91 5a 0b 	lds	r24, 0x0B5A
    9d7a:	90 91 5b 0b 	lds	r25, 0x0B5B
    9d7e:	80 61       	ori	r24, 0x10	; 16
    9d80:	90 93 5b 0b 	sts	0x0B5B, r25
    9d84:	80 93 5a 0b 	sts	0x0B5A, r24
	}

	ptr[1] = Temperature[0];
    9d88:	d0 92 5d 0b 	sts	0x0B5D, r13
    9d8c:	c0 92 5c 0b 	sts	0x0B5C, r12

	int32_t* pi4 = (int32_t*)&GPRS_Data_Out[37];
	pi4[0] = E_Meter_RAM.Ap;
    9d90:	80 91 46 02 	lds	r24, 0x0246
    9d94:	90 91 47 02 	lds	r25, 0x0247
    9d98:	a0 91 48 02 	lds	r26, 0x0248
    9d9c:	b0 91 49 02 	lds	r27, 0x0249
    9da0:	80 93 5e 0b 	sts	0x0B5E, r24
    9da4:	90 93 5f 0b 	sts	0x0B5F, r25
    9da8:	a0 93 60 0b 	sts	0x0B60, r26
    9dac:	b0 93 61 0b 	sts	0x0B61, r27
	pi4[1] = E_Meter_RAM.Am;
    9db0:	80 91 4a 02 	lds	r24, 0x024A
    9db4:	90 91 4b 02 	lds	r25, 0x024B
    9db8:	a0 91 4c 02 	lds	r26, 0x024C
    9dbc:	b0 91 4d 02 	lds	r27, 0x024D
    9dc0:	80 93 62 0b 	sts	0x0B62, r24
    9dc4:	90 93 63 0b 	sts	0x0B63, r25
    9dc8:	a0 93 64 0b 	sts	0x0B64, r26
    9dcc:	b0 93 65 0b 	sts	0x0B65, r27
	pi4[2] = E_Meter_RAM.Rp;
    9dd0:	80 91 4e 02 	lds	r24, 0x024E
    9dd4:	90 91 4f 02 	lds	r25, 0x024F
    9dd8:	a0 91 50 02 	lds	r26, 0x0250
    9ddc:	b0 91 51 02 	lds	r27, 0x0251
    9de0:	80 93 66 0b 	sts	0x0B66, r24
    9de4:	90 93 67 0b 	sts	0x0B67, r25
    9de8:	a0 93 68 0b 	sts	0x0B68, r26
    9dec:	b0 93 69 0b 	sts	0x0B69, r27
	pi4[3] = E_Meter_RAM.Rm;
    9df0:	80 91 52 02 	lds	r24, 0x0252
    9df4:	90 91 53 02 	lds	r25, 0x0253
    9df8:	a0 91 54 02 	lds	r26, 0x0254
    9dfc:	b0 91 55 02 	lds	r27, 0x0255
    9e00:	80 93 6a 0b 	sts	0x0B6A, r24
    9e04:	90 93 6b 0b 	sts	0x0B6B, r25
    9e08:	a0 93 6c 0b 	sts	0x0B6C, r26
    9e0c:	b0 93 6d 0b 	sts	0x0B6D, r27

	GPRS_Data_Out[53] = EM_Year;
    9e10:	80 91 86 09 	lds	r24, 0x0986
    9e14:	80 93 6e 0b 	sts	0x0B6E, r24
	GPRS_Data_Out[54] = EM_Month;
    9e18:	80 91 ed 09 	lds	r24, 0x09ED
    9e1c:	80 93 6f 0b 	sts	0x0B6F, r24
	GPRS_Data_Out[55] = EM_Day;
    9e20:	80 91 e2 03 	lds	r24, 0x03E2
    9e24:	80 93 70 0b 	sts	0x0B70, r24
	GPRS_Data_Out[56] = EM_Hour;
    9e28:	80 91 6e 09 	lds	r24, 0x096E
    9e2c:	80 93 71 0b 	sts	0x0B71, r24
	GPRS_Data_Out[57] = EM_Min;
    9e30:	80 91 4d 09 	lds	r24, 0x094D
    9e34:	80 93 72 0b 	sts	0x0B72, r24
	GPRS_Data_Out[58] = EM_Sec;
    9e38:	80 91 0e 06 	lds	r24, 0x060E
    9e3c:	80 93 73 0b 	sts	0x0B73, r24

	ptr = (int16_t*)&GPRS_Data_Out[59];
	ptr[0] = EM_PowerActive;
    9e40:	80 91 6f 0a 	lds	r24, 0x0A6F
    9e44:	90 91 70 0a 	lds	r25, 0x0A70
    9e48:	90 93 75 0b 	sts	0x0B75, r25
    9e4c:	80 93 74 0b 	sts	0x0B74, r24
	ptr[1] = Ua;
    9e50:	f0 92 77 0b 	sts	0x0B77, r15
    9e54:	e0 92 76 0b 	sts	0x0B76, r14
	ptr[2] = Ub;
    9e58:	10 93 79 0b 	sts	0x0B79, r17
    9e5c:	00 93 78 0b 	sts	0x0B78, r16
	ptr[3] = Uc;
    9e60:	d0 93 7b 0b 	sts	0x0B7B, r29
    9e64:	c0 93 7a 0b 	sts	0x0B7A, r28
	ptr[4] = Ia;
    9e68:	80 91 f2 03 	lds	r24, 0x03F2
    9e6c:	90 91 f3 03 	lds	r25, 0x03F3
    9e70:	90 93 7d 0b 	sts	0x0B7D, r25
    9e74:	80 93 7c 0b 	sts	0x0B7C, r24
	ptr[5] = Ib;
    9e78:	80 91 47 09 	lds	r24, 0x0947
    9e7c:	90 91 48 09 	lds	r25, 0x0948
    9e80:	90 93 7f 0b 	sts	0x0B7F, r25
    9e84:	80 93 7e 0b 	sts	0x0B7E, r24
	ptr[6] = Ic;
    9e88:	80 91 81 09 	lds	r24, 0x0981
    9e8c:	90 91 82 09 	lds	r25, 0x0982
    9e90:	90 93 81 0b 	sts	0x0B81, r25
    9e94:	80 93 80 0b 	sts	0x0B80, r24

	GPRS_Data_Out[73] = GSM_RSSI;
    9e98:	80 91 25 06 	lds	r24, 0x0625
    9e9c:	80 93 82 0b 	sts	0x0B82, r24

	GPRS_FlgSz_Out = 74;	//    .     
    9ea0:	8a e4       	ldi	r24, 0x4A	; 74
    9ea2:	80 93 43 09 	sts	0x0943, r24
}
    9ea6:	df 91       	pop	r29
    9ea8:	cf 91       	pop	r28
    9eaa:	1f 91       	pop	r17
    9eac:	0f 91       	pop	r16
    9eae:	ff 90       	pop	r15
    9eb0:	ef 90       	pop	r14
    9eb2:	df 90       	pop	r13
    9eb4:	cf 90       	pop	r12
    9eb6:	08 95       	ret

00009eb8 <GPRS_SendData>:

uint8_t Timer1sOld;
// ~~~~   
void GPRS_SendData(void){
    9eb8:	cf 93       	push	r28
    9eba:	df 93       	push	r29
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    9ebc:	8a e0       	ldi	r24, 0x0A	; 10
    9ebe:	90 e0       	ldi	r25, 0x00	; 0
    9ec0:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	//    5  
	if(erb(&AutoSend)  && (erw(&CurrDataPeriod) >= 60) ){	// CurrDataPeriod    60 -     !
    9ec4:	88 23       	and	r24, r24
    9ec6:	09 f4       	brne	.+2      	; 0x9eca <GPRS_SendData+0x12>
    9ec8:	59 c0       	rjmp	.+178    	; 0x9f7c <GPRS_SendData+0xc4>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    9eca:	88 e0       	ldi	r24, 0x08	; 8
    9ecc:	90 e0       	ldi	r25, 0x00	; 0
    9ece:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    9ed2:	cc 97       	sbiw	r24, 0x3c	; 60
    9ed4:	08 f4       	brcc	.+2      	; 0x9ed8 <GPRS_SendData+0x20>
    9ed6:	52 c0       	rjmp	.+164    	; 0x9f7c <GPRS_SendData+0xc4>
		if(Timer1s != Timer1sOld){
    9ed8:	80 91 0e 0b 	lds	r24, 0x0B0E
    9edc:	90 91 80 09 	lds	r25, 0x0980
    9ee0:	89 17       	cp	r24, r25
    9ee2:	91 f0       	breq	.+36     	; 0x9f08 <GPRS_SendData+0x50>
			Timer1sOld = Timer1s;
    9ee4:	80 93 80 09 	sts	0x0980, r24
			if(GPRS_DataTimer<erw(&CurrDataPeriod)) GPRS_DataTimer++;
    9ee8:	c0 91 18 0b 	lds	r28, 0x0B18
    9eec:	d0 91 19 0b 	lds	r29, 0x0B19
    9ef0:	88 e0       	ldi	r24, 0x08	; 8
    9ef2:	90 e0       	ldi	r25, 0x00	; 0
    9ef4:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    9ef8:	c8 17       	cp	r28, r24
    9efa:	d9 07       	cpc	r29, r25
    9efc:	28 f4       	brcc	.+10     	; 0x9f08 <GPRS_SendData+0x50>
    9efe:	21 96       	adiw	r28, 0x01	; 1
    9f00:	d0 93 19 0b 	sts	0x0B19, r29
    9f04:	c0 93 18 0b 	sts	0x0B18, r28
		}
		
		//   30    
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 30){
    9f08:	c0 91 18 0b 	lds	r28, 0x0B18
    9f0c:	d0 91 19 0b 	lds	r29, 0x0B19
    9f10:	88 e0       	ldi	r24, 0x08	; 8
    9f12:	90 e0       	ldi	r25, 0x00	; 0
    9f14:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    9f18:	4e 97       	sbiw	r24, 0x1e	; 30
    9f1a:	c8 17       	cp	r28, r24
    9f1c:	d9 07       	cpc	r29, r25
    9f1e:	29 f4       	brne	.+10     	; 0x9f2a <GPRS_SendData+0x72>
			if(IsEMReady()) EMRead();			
    9f20:	0e 94 e9 4c 	call	0x99d2	; 0x99d2 <IsEMReady>
    9f24:	81 11       	cpse	r24, r1
    9f26:	0e 94 f0 4c 	call	0x99e0	; 0x99e0 <EMRead>
		}

		//    15    ,      30
		if(GPRS_DataTimer == erw(&CurrDataPeriod) - 15){
    9f2a:	c0 91 18 0b 	lds	r28, 0x0B18
    9f2e:	d0 91 19 0b 	lds	r29, 0x0B19
    9f32:	88 e0       	ldi	r24, 0x08	; 8
    9f34:	90 e0       	ldi	r25, 0x00	; 0
    9f36:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    9f3a:	0f 97       	sbiw	r24, 0x0f	; 15
    9f3c:	c8 17       	cp	r28, r24
    9f3e:	d9 07       	cpc	r29, r25
    9f40:	49 f4       	brne	.+18     	; 0x9f54 <GPRS_SendData+0x9c>
			if(!EMeter_Link()){
    9f42:	0e 94 e3 4c 	call	0x99c6	; 0x99c6 <EMeter_Link>
    9f46:	81 11       	cpse	r24, r1
    9f48:	05 c0       	rjmp	.+10     	; 0x9f54 <GPRS_SendData+0x9c>
				if(IsEMReady()) EMRead();
    9f4a:	0e 94 e9 4c 	call	0x99d2	; 0x99d2 <IsEMReady>
    9f4e:	81 11       	cpse	r24, r1
    9f50:	0e 94 f0 4c 	call	0x99e0	; 0x99e0 <EMRead>
			}			
		}

		if(GPRS_DataTimer >= erw(&CurrDataPeriod)){
    9f54:	c0 91 18 0b 	lds	r28, 0x0B18
    9f58:	d0 91 19 0b 	lds	r29, 0x0B19
    9f5c:	88 e0       	ldi	r24, 0x08	; 8
    9f5e:	90 e0       	ldi	r25, 0x00	; 0
    9f60:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    9f64:	c8 17       	cp	r28, r24
    9f66:	d9 07       	cpc	r29, r25
    9f68:	48 f0       	brcs	.+18     	; 0x9f7c <GPRS_SendData+0xc4>
			GPRS_DataTimer = 0;
    9f6a:	10 92 19 0b 	sts	0x0B19, r1
    9f6e:	10 92 18 0b 	sts	0x0B18, r1
			GPRS_SendRQ |= (1 << GPRS_RQ_CurDataUDP);
    9f72:	80 91 5c 09 	lds	r24, 0x095C
    9f76:	81 60       	ori	r24, 0x01	; 1
    9f78:	80 93 5c 09 	sts	0x095C, r24
		}
	}
}
    9f7c:	df 91       	pop	r29
    9f7e:	cf 91       	pop	r28
    9f80:	08 95       	ret

00009f82 <GPRS_NewMsg>:

// -----      
void GPRS_NewMsg(uint8_t Type, prog_char* Msg_P){
	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    9f82:	90 91 69 09 	lds	r25, 0x0969
    9f86:	90 fd       	sbrc	r25, 0
    9f88:	5b c0       	rjmp	.+182    	; 0xa040 <GPRS_NewMsg+0xbe>
		GPRS_CrashID++;
    9f8a:	90 91 04 01 	lds	r25, 0x0104
    9f8e:	9f 5f       	subi	r25, 0xFF	; 255
    9f90:	90 93 04 01 	sts	0x0104, r25

		// --   GPRS_CrashData[]  
		GPRS_CrashData[0] = 6;	
    9f94:	26 e0       	ldi	r18, 0x06	; 6
    9f96:	20 93 07 0a 	sts	0x0A07, r18
		GPRS_CrashData[1] = 1;	
    9f9a:	21 e0       	ldi	r18, 0x01	; 1
    9f9c:	20 93 08 0a 	sts	0x0A08, r18
		//---VegaID64
		GPRS_CrashData[2] = *((uint8_t*)&ICCID+7);	//VegaID64_Hi
    9fa0:	30 91 7a 09 	lds	r19, 0x097A
    9fa4:	30 93 09 0a 	sts	0x0A09, r19
		GPRS_CrashData[3] = *((uint8_t*)&ICCID+6);
    9fa8:	30 91 79 09 	lds	r19, 0x0979
    9fac:	30 93 0a 0a 	sts	0x0A0A, r19
		GPRS_CrashData[4] = *((uint8_t*)&ICCID+5);
    9fb0:	30 91 78 09 	lds	r19, 0x0978
    9fb4:	30 93 0b 0a 	sts	0x0A0B, r19
		GPRS_CrashData[5] = *((uint8_t*)&ICCID+4);
    9fb8:	30 91 77 09 	lds	r19, 0x0977
    9fbc:	30 93 0c 0a 	sts	0x0A0C, r19
		GPRS_CrashData[6] = *((uint8_t*)&ICCID+3);
    9fc0:	30 91 76 09 	lds	r19, 0x0976
    9fc4:	30 93 0d 0a 	sts	0x0A0D, r19
		GPRS_CrashData[7] = *((uint8_t*)&ICCID+2);
    9fc8:	30 91 75 09 	lds	r19, 0x0975
    9fcc:	30 93 0e 0a 	sts	0x0A0E, r19
		GPRS_CrashData[8] = *((uint8_t*)&ICCID+1);
    9fd0:	30 91 74 09 	lds	r19, 0x0974
    9fd4:	30 93 0f 0a 	sts	0x0A0F, r19
		GPRS_CrashData[9] = *((uint8_t*)&ICCID+0);	//VegaID64_Lo
    9fd8:	30 91 73 09 	lds	r19, 0x0973
    9fdc:	30 93 10 0a 	sts	0x0A10, r19

		GPRS_CrashData[10] = GPRS_CRASH;	//    
    9fe0:	32 e0       	ldi	r19, 0x02	; 2
    9fe2:	30 93 11 0a 	sts	0x0A11, r19
		GPRS_CrashData[11] = SW_VERSION;		//   
    9fe6:	33 e0       	ldi	r19, 0x03	; 3
    9fe8:	30 93 12 0a 	sts	0x0A12, r19
		GPRS_CrashData[12] = SW_SUBVERSION;	//   			
    9fec:	37 e0       	ldi	r19, 0x07	; 7
    9fee:	30 93 13 0a 	sts	0x0A13, r19
		
		GPRS_CrashData[14] = Type;
    9ff2:	80 93 15 0a 	sts	0x0A15, r24
		GPRS_CrashData[15] = 1;			//    
    9ff6:	20 93 16 0a 	sts	0x0A16, r18
		GPRS_CrashData[16] = GPRS_CrashID;//  
    9ffa:	90 93 17 0a 	sts	0x0A17, r25

		GPRS_CrashData[17] = 0;
    9ffe:	10 92 18 0a 	sts	0x0A18, r1
		GPRS_CrashData[18] = 0;
    a002:	10 92 19 0a 	sts	0x0A19, r1
		GPRS_CrashData[19] = 0;
    a006:	10 92 1a 0a 	sts	0x0A1A, r1
		GPRS_CrashData[20] = 0;
    a00a:	10 92 1b 0a 	sts	0x0A1B, r1
		GPRS_CrashData[21] = 0;
    a00e:	10 92 1c 0a 	sts	0x0A1C, r1
		GPRS_CrashData[22] = 0;
    a012:	10 92 1d 0a 	sts	0x0A1D, r1

		GPRS_CrashData[13] = strlcpy_P((char*)GPRS_CrashData+23, Msg_P, 50) + 9;
    a016:	42 e3       	ldi	r20, 0x32	; 50
    a018:	50 e0       	ldi	r21, 0x00	; 0
    a01a:	8e e1       	ldi	r24, 0x1E	; 30
    a01c:	9a e0       	ldi	r25, 0x0A	; 10
    a01e:	0e 94 78 6c 	call	0xd8f0	; 0xd8f0 <strlcpy_P>
    a022:	87 5f       	subi	r24, 0xF7	; 247
    a024:	80 93 14 0a 	sts	0x0A14, r24

		//GPRS_Flags |= (1<<GPRS_flg_CrashNACK);	//    

		GPRS_SendRQ &=~(1<<GPRS_RQ_RepCrash);	//     
    a028:	80 91 5c 09 	lds	r24, 0x095C
    a02c:	8f 7d       	andi	r24, 0xDF	; 223
		GPRS_SendRQ |= (1<<GPRS_RQ_NewCrash);	//    
    a02e:	80 64       	ori	r24, 0x40	; 64
    a030:	80 93 5c 09 	sts	0x095C, r24

		StartTimer16(GPRS_TD_CrashSendRetry,12000);	//    2 
    a034:	60 ee       	ldi	r22, 0xE0	; 224
    a036:	7e e2       	ldi	r23, 0x2E	; 46
    a038:	80 91 0f 06 	lds	r24, 0x060F
    a03c:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>
    a040:	08 95       	ret

0000a042 <GPRS_SendNewCrash>:
	}
}
// --   CrashData[]  
void GPRS_SendNewCrash(void){
    a042:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a044:	c0 91 14 0a 	lds	r28, 0x0A14
    a048:	c2 5f       	subi	r28, 0xF2	; 242
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a04a:	4c 2f       	mov	r20, r28
    a04c:	50 e0       	ldi	r21, 0x00	; 0
    a04e:	67 e0       	ldi	r22, 0x07	; 7
    a050:	7a e0       	ldi	r23, 0x0A	; 10
    a052:	89 e3       	ldi	r24, 0x39	; 57
    a054:	9b e0       	ldi	r25, 0x0B	; 11
    a056:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a05a:	c0 93 43 09 	sts	0x0943, r28
}
    a05e:	cf 91       	pop	r28
    a060:	08 95       	ret

0000a062 <GPRS_SendRepCrash>:
// --      
void GPRS_SendRepCrash(void){
    a062:	cf 93       	push	r28
	uint8_t size = GPRS_CrashData[13]+14;
    a064:	c0 91 14 0a 	lds	r28, 0x0A14
    a068:	c2 5f       	subi	r28, 0xF2	; 242
	GPRS_CrashData[15] = 2;			//    
    a06a:	82 e0       	ldi	r24, 0x02	; 2
    a06c:	80 93 16 0a 	sts	0x0A16, r24
	memcpy(GPRS_Data_Out, GPRS_CrashData, size);
    a070:	4c 2f       	mov	r20, r28
    a072:	50 e0       	ldi	r21, 0x00	; 0
    a074:	67 e0       	ldi	r22, 0x07	; 7
    a076:	7a e0       	ldi	r23, 0x0A	; 10
    a078:	89 e3       	ldi	r24, 0x39	; 57
    a07a:	9b e0       	ldi	r25, 0x0B	; 11
    a07c:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
	GPRS_FlgSz_Out = size;	//    .     
    a080:	c0 93 43 09 	sts	0x0943, r28
}
    a084:	cf 91       	pop	r28
    a086:	08 95       	ret

0000a088 <GPRS_Check_PSW>:

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
    a088:	0f 93       	push	r16
    a08a:	1f 93       	push	r17
    a08c:	cf 93       	push	r28
    a08e:	df 93       	push	r29
    a090:	8c 01       	movw	r16, r24
    a092:	c0 e0       	ldi	r28, 0x00	; 0
    a094:	d0 e0       	ldi	r29, 0x00	; 0
    a096:	ce 01       	movw	r24, r28
    a098:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a09c:	08 17       	cp	r16, r24
    a09e:	19 07       	cpc	r17, r25
    a0a0:	59 f0       	breq	.+22     	; 0xa0b8 <GPRS_Check_PSW+0x30>
    a0a2:	22 96       	adiw	r28, 0x02	; 2
	GPRS_FlgSz_Out = size;	//    .     
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
    a0a4:	80 e0       	ldi	r24, 0x00	; 0
    a0a6:	c8 30       	cpi	r28, 0x08	; 8
    a0a8:	d8 07       	cpc	r29, r24
    a0aa:	a9 f7       	brne	.-22     	; 0xa096 <GPRS_Check_PSW+0xe>
		if(Pass == erw(&Password[i])) return 1;
	}
	if(Pass == 22780) return 1;
    a0ac:	81 e0       	ldi	r24, 0x01	; 1
    a0ae:	0c 3f       	cpi	r16, 0xFC	; 252
    a0b0:	18 45       	sbci	r17, 0x58	; 88
    a0b2:	19 f0       	breq	.+6      	; 0xa0ba <GPRS_Check_PSW+0x32>
    a0b4:	80 e0       	ldi	r24, 0x00	; 0
    a0b6:	01 c0       	rjmp	.+2      	; 0xa0ba <GPRS_Check_PSW+0x32>
}

// -----            S E S S I O N   I D 
uint8_t GPRS_Check_PSW(const uint16_t Pass){
	for(uint8_t i=0; i<PASSWORDS_Qt; i++){
		if(Pass == erw(&Password[i])) return 1;
    a0b8:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(Pass == 22780) return 1;
	return 0;
}
    a0ba:	df 91       	pop	r29
    a0bc:	cf 91       	pop	r28
    a0be:	1f 91       	pop	r17
    a0c0:	0f 91       	pop	r16
    a0c2:	08 95       	ret

0000a0c4 <GPRS_Get_Session_ID>:
	}
	if(Pass == 22780) return 1;
	return 0;
}

void GPRS_Get_Session_ID(void){
    a0c4:	cf 93       	push	r28
    a0c6:	df 93       	push	r29
	if(GPRS_Flags & (1<<GPRS_flg_NoAccess)) GPRS_Session_ID = 0;
    a0c8:	80 91 69 09 	lds	r24, 0x0969
    a0cc:	83 ff       	sbrs	r24, 3
    a0ce:	05 c0       	rjmp	.+10     	; 0xa0da <GPRS_Get_Session_ID+0x16>
    a0d0:	10 92 11 0b 	sts	0x0B11, r1
    a0d4:	10 92 10 0b 	sts	0x0B10, r1
    a0d8:	12 c0       	rjmp	.+36     	; 0xa0fe <GPRS_Get_Session_ID+0x3a>
	else GPRS_Session_ID	= GetTimer16(GPRS_TD_SessionIDGenerator);
    a0da:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    a0de:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint16_t Time = Timer16[TimerN];
    a0e2:	ec 2f       	mov	r30, r28
    a0e4:	f0 e0       	ldi	r31, 0x00	; 0
    a0e6:	ee 0f       	add	r30, r30
    a0e8:	ff 1f       	adc	r31, r31
    a0ea:	ea 5d       	subi	r30, 0xDA	; 218
    a0ec:	fc 4f       	sbci	r31, 0xFC	; 252
    a0ee:	c0 81       	ld	r28, Z
    a0f0:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    a0f2:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
    a0f6:	d0 93 11 0b 	sts	0x0B11, r29
    a0fa:	c0 93 10 0b 	sts	0x0B10, r28
	GPRS_Data_Out[0] = 5;	//    
    a0fe:	85 e0       	ldi	r24, 0x05	; 5
    a100:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a104:	81 e0       	ldi	r24, 0x01	; 1
    a106:	80 93 3a 0b 	sts	0x0B3A, r24
    a10a:	8c e0       	ldi	r24, 0x0C	; 12
    a10c:	91 e0       	ldi	r25, 0x01	; 1
    a10e:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a112:	90 93 3b 0b 	sts	0x0B3B, r25
    a116:	8c e0       	ldi	r24, 0x0C	; 12
    a118:	91 e0       	ldi	r25, 0x01	; 1
    a11a:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a11e:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 4;
    a122:	84 e0       	ldi	r24, 0x04	; 4
    a124:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = (uint8_t)(GPRS_Session_ID>>8);
    a128:	80 91 10 0b 	lds	r24, 0x0B10
    a12c:	90 91 11 0b 	lds	r25, 0x0B11
    a130:	90 93 3e 0b 	sts	0x0B3E, r25
	GPRS_Data_Out[6] = (uint8_t)(GPRS_Session_ID & 0x00FF);	
    a134:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_FlgSz_Out = 7;					//    .     	
    a138:	87 e0       	ldi	r24, 0x07	; 7
    a13a:	80 93 43 09 	sts	0x0943, r24
}
    a13e:	df 91       	pop	r29
    a140:	cf 91       	pop	r28
    a142:	08 95       	ret

0000a144 <GPRS_RemoteDisplayControl>:

// -----                      
void GPRS_RemoteDisplayControl(void){
	StartTimer8(TD_GPRS_RemoteDisplay,15);
    a144:	6f e0       	ldi	r22, 0x0F	; 15
    a146:	80 e0       	ldi	r24, 0x00	; 0
    a148:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
	GPRS_Flags |= (1<<GPRS_flg_RemoteDispalyRQ);
    a14c:	80 91 69 09 	lds	r24, 0x0969
    a150:	84 60       	ori	r24, 0x04	; 4
    a152:	80 93 69 09 	sts	0x0969, r24
    a156:	08 95       	ret

0000a158 <GPRS_SendDisplay>:
#ifdef RKEY
	if ( (GPRS_Data_In[9]<=6) && (GPRS_Data_In[9]!=0) ) *RKEY = 1<<(GPRS_Data_In[9]-1);
#endif
}
void GPRS_SendDisplay(void){
	GPRS_Data_Out[0] = 5;	//    
    a158:	85 e0       	ldi	r24, 0x05	; 5
    a15a:	80 93 39 0b 	sts	0x0B39, r24
	GPRS_Data_Out[1] = 1;	//   
    a15e:	81 e0       	ldi	r24, 0x01	; 1
    a160:	80 93 3a 0b 	sts	0x0B3A, r24
    a164:	8c e0       	ldi	r24, 0x0C	; 12
    a166:	91 e0       	ldi	r25, 0x01	; 1
    a168:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_Data_Out[2] = erw(&Vega_SN)>>8;
    a16c:	90 93 3b 0b 	sts	0x0B3B, r25
    a170:	8c e0       	ldi	r24, 0x0C	; 12
    a172:	91 e0       	ldi	r25, 0x01	; 1
    a174:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_Data_Out[3] = (uint8_t)erw(&Vega_SN);
    a178:	80 93 3c 0b 	sts	0x0B3C, r24
	GPRS_Data_Out[4] = 3;
    a17c:	83 e0       	ldi	r24, 0x03	; 3
    a17e:	80 93 3d 0b 	sts	0x0B3D, r24
	GPRS_Data_Out[5] = 34;
    a182:	82 e2       	ldi	r24, 0x22	; 34
    a184:	80 93 3e 0b 	sts	0x0B3E, r24
	GPRS_Data_Out[6] = 10;
    a188:	8a e0       	ldi	r24, 0x0A	; 10
    a18a:	80 93 3f 0b 	sts	0x0B3F, r24
	GPRS_Data_Out[7] = R_PLC_Type;
    a18e:	80 93 40 0b 	sts	0x0B40, r24
#ifdef RMON
	memcpy(GPRS_Data_Out+8, RMON, 32);
#endif
	GPRS_FlgSz_Out = 40;
    a192:	88 e2       	ldi	r24, 0x28	; 40
    a194:	80 93 43 09 	sts	0x0943, r24
    a198:	08 95       	ret

0000a19a <GPRS_SendChange>:
void GPRS_Reg(void){
}
// -----                     
// --  /    

void GPRS_SendChange(uint8_t Size){
    a19a:	cf 93       	push	r28
    a19c:	c8 2f       	mov	r28, r24
	memcpy(GPRS_Data_Out,GPRS_ChangeData,Size);
    a19e:	48 2f       	mov	r20, r24
    a1a0:	50 e0       	ldi	r21, 0x00	; 0
    a1a2:	6d e3       	ldi	r22, 0x3D	; 61
    a1a4:	76 e0       	ldi	r23, 0x06	; 6
    a1a6:	89 e3       	ldi	r24, 0x39	; 57
    a1a8:	9b e0       	ldi	r25, 0x0B	; 11
    a1aa:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
	GPRS_FlgSz_Out = Size;					//    .     
    a1ae:	c0 93 43 09 	sts	0x0943, r28
}
    a1b2:	cf 91       	pop	r28
    a1b4:	08 95       	ret

0000a1b6 <GPRS_ReadParamReply>:
void GPRS_ReadParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t ParamSize){
    a1b6:	1f 93       	push	r17
    a1b8:	cf 93       	push	r28
    a1ba:	df 93       	push	r29
    a1bc:	00 d0       	rcall	.+0      	; 0xa1be <GPRS_ReadParamReply+0x8>
    a1be:	cd b7       	in	r28, 0x3d	; 61
    a1c0:	de b7       	in	r29, 0x3e	; 62
    a1c2:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a1c4:	85 e0       	ldi	r24, 0x05	; 5
    a1c6:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a1ca:	81 e0       	ldi	r24, 0x01	; 1
    a1cc:	80 93 3e 06 	sts	0x063E, r24
    a1d0:	8c e0       	ldi	r24, 0x0C	; 12
    a1d2:	91 e0       	ldi	r25, 0x01	; 1
    a1d4:	4a 83       	std	Y+2, r20	; 0x02
    a1d6:	69 83       	std	Y+1, r22	; 0x01
    a1d8:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a1dc:	90 93 3f 06 	sts	0x063F, r25
    a1e0:	8c e0       	ldi	r24, 0x0C	; 12
    a1e2:	91 e0       	ldi	r25, 0x01	; 1
    a1e4:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a1e8:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a1ec:	83 e0       	ldi	r24, 0x03	; 3
    a1ee:	80 93 41 06 	sts	0x0641, r24
	GPRS_ChangeData[5] = ParamSize + 3;	// -       
    a1f2:	4a 81       	ldd	r20, Y+2	; 0x02
    a1f4:	4d 5f       	subi	r20, 0xFD	; 253
    a1f6:	40 93 42 06 	sts	0x0642, r20
	GPRS_ChangeData[6] = 7;
    a1fa:	87 e0       	ldi	r24, 0x07	; 7
    a1fc:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a200:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;
    a204:	69 81       	ldd	r22, Y+1	; 0x01
    a206:	60 93 45 06 	sts	0x0645, r22
}
    a20a:	0f 90       	pop	r0
    a20c:	0f 90       	pop	r0
    a20e:	df 91       	pop	r29
    a210:	cf 91       	pop	r28
    a212:	1f 91       	pop	r17
    a214:	08 95       	ret

0000a216 <GPRS_WriteParamReply>:
void GPRS_WriteParamReply(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo){
    a216:	1f 93       	push	r17
    a218:	cf 93       	push	r28
    a21a:	df 93       	push	r29
    a21c:	1f 92       	push	r1
    a21e:	cd b7       	in	r28, 0x3d	; 61
    a220:	de b7       	in	r29, 0x3e	; 62
    a222:	18 2f       	mov	r17, r24
	GPRS_ChangeData[0] = 5;	
    a224:	85 e0       	ldi	r24, 0x05	; 5
    a226:	80 93 3d 06 	sts	0x063D, r24
	GPRS_ChangeData[1] = 1;	
    a22a:	81 e0       	ldi	r24, 0x01	; 1
    a22c:	80 93 3e 06 	sts	0x063E, r24
    a230:	8c e0       	ldi	r24, 0x0C	; 12
    a232:	91 e0       	ldi	r25, 0x01	; 1
    a234:	69 83       	std	Y+1, r22	; 0x01
    a236:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_ChangeData[2] = erw(&Vega_SN)>>8;
    a23a:	90 93 3f 06 	sts	0x063F, r25
    a23e:	8c e0       	ldi	r24, 0x0C	; 12
    a240:	91 e0       	ldi	r25, 0x01	; 1
    a242:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
	GPRS_ChangeData[3] = (uint8_t)erw(&Vega_SN);		
    a246:	80 93 40 06 	sts	0x0640, r24
	GPRS_ChangeData[4] = GPRS_CONTROL;
    a24a:	93 e0       	ldi	r25, 0x03	; 3
    a24c:	90 93 41 06 	sts	0x0641, r25
	GPRS_ChangeData[5] = 3;	// -       
    a250:	90 93 42 06 	sts	0x0642, r25
	GPRS_ChangeData[6] = 8;
    a254:	88 e0       	ldi	r24, 0x08	; 8
    a256:	80 93 43 06 	sts	0x0643, r24
	GPRS_ChangeData[7] = ParamID_Hi;
    a25a:	10 93 44 06 	sts	0x0644, r17
	GPRS_ChangeData[8] = ParamID_Lo;	
    a25e:	69 81       	ldd	r22, Y+1	; 0x01
    a260:	60 93 45 06 	sts	0x0645, r22
}
    a264:	0f 90       	pop	r0
    a266:	df 91       	pop	r29
    a268:	cf 91       	pop	r28
    a26a:	1f 91       	pop	r17
    a26c:	08 95       	ret

0000a26e <GPRS_Param>:

void GPRS_Param(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, void* param, uint8_t param_size,
	const uint8_t Cmd, const uint8_t MemCopy, const uint8_t RAM){
    a26e:	cf 92       	push	r12
    a270:	ef 92       	push	r14
    a272:	0f 93       	push	r16
    a274:	1f 93       	push	r17
    a276:	cf 93       	push	r28
    a278:	df 93       	push	r29
    a27a:	d8 2f       	mov	r29, r24
    a27c:	16 2f       	mov	r17, r22
    a27e:	ca 01       	movw	r24, r20
    a280:	c2 2f       	mov	r28, r18
	if(Cmd==READ_PARAM ){
    a282:	01 3c       	cpi	r16, 0xC1	; 193
    a284:	b9 f4       	brne	.+46     	; 0xa2b4 <GPRS_Param+0x46>
		if(MemCopy){
    a286:	ee 20       	and	r14, r14
    a288:	61 f0       	breq	.+24     	; 0xa2a2 <GPRS_Param+0x34>
    a28a:	42 2f       	mov	r20, r18
    a28c:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(GPRS_ChangeData + 9, param, param_size);
    a28e:	bc 01       	movw	r22, r24
    a290:	86 e4       	ldi	r24, 0x46	; 70
    a292:	96 e0       	ldi	r25, 0x06	; 6
    a294:	cc 20       	and	r12, r12
    a296:	19 f0       	breq	.+6      	; 0xa29e <GPRS_Param+0x30>
    a298:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
    a29c:	02 c0       	rjmp	.+4      	; 0xa2a2 <GPRS_Param+0x34>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    a29e:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
			else erbl(GPRS_ChangeData + 9, param, param_size);
		}
		GPRS_ReadParamReply(ParamID_Hi, ParamID_Lo, param_size);
    a2a2:	4c 2f       	mov	r20, r28
    a2a4:	61 2f       	mov	r22, r17
    a2a6:	8d 2f       	mov	r24, r29
    a2a8:	0e 94 db 50 	call	0xa1b6	; 0xa1b6 <GPRS_ReadParamReply>
		GPRS_ChangeReplySize = param_size + 9;
    a2ac:	c7 5f       	subi	r28, 0xF7	; 247
    a2ae:	c0 93 11 06 	sts	0x0611, r28
    a2b2:	19 c0       	rjmp	.+50     	; 0xa2e6 <GPRS_Param+0x78>
	}
	if(Cmd==WRITE_PARAM){
    a2b4:	0c 34       	cpi	r16, 0x4C	; 76
    a2b6:	b9 f4       	brne	.+46     	; 0xa2e6 <GPRS_Param+0x78>
		if(MemCopy){
    a2b8:	ee 20       	and	r14, r14
    a2ba:	71 f0       	breq	.+28     	; 0xa2d8 <GPRS_Param+0x6a>
    a2bc:	42 2f       	mov	r20, r18
    a2be:	50 e0       	ldi	r21, 0x00	; 0
			if(RAM) memcpy(param, &GPRS_Data_In[11], param_size);
    a2c0:	cc 20       	and	r12, r12
    a2c2:	29 f0       	breq	.+10     	; 0xa2ce <GPRS_Param+0x60>
    a2c4:	68 e4       	ldi	r22, 0x48	; 72
    a2c6:	78 e0       	ldi	r23, 0x08	; 8
    a2c8:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
    a2cc:	05 c0       	rjmp	.+10     	; 0xa2d8 <GPRS_Param+0x6a>
			else ewbl(&GPRS_Data_In[11], param, param_size);
    a2ce:	bc 01       	movw	r22, r24
    a2d0:	88 e4       	ldi	r24, 0x48	; 72
    a2d2:	98 e0       	ldi	r25, 0x08	; 8
    a2d4:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
		}
		GPRS_WriteParamReply(ParamID_Hi, ParamID_Lo);
    a2d8:	61 2f       	mov	r22, r17
    a2da:	8d 2f       	mov	r24, r29
    a2dc:	0e 94 0b 51 	call	0xa216	; 0xa216 <GPRS_WriteParamReply>
		GPRS_ChangeReplySize = 9;
    a2e0:	89 e0       	ldi	r24, 0x09	; 9
    a2e2:	80 93 11 06 	sts	0x0611, r24
	}		
	GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a2e6:	80 91 5c 09 	lds	r24, 0x095C
    a2ea:	88 60       	ori	r24, 0x08	; 8
    a2ec:	80 93 5c 09 	sts	0x095C, r24
}
    a2f0:	df 91       	pop	r29
    a2f2:	cf 91       	pop	r28
    a2f4:	1f 91       	pop	r17
    a2f6:	0f 91       	pop	r16
    a2f8:	ef 90       	pop	r14
    a2fa:	cf 90       	pop	r12
    a2fc:	08 95       	ret

0000a2fe <GPRS_CriticalCMD_Process>:

void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
    a2fe:	80 91 e3 03 	lds	r24, 0x03E3
    a302:	88 23       	and	r24, r24
    a304:	f9 f0       	breq	.+62     	; 0xa344 <GPRS_CriticalCMD_Process+0x46>
    a306:	80 91 0c 0b 	lds	r24, 0x0B0C
    a30a:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    a30e:	88 23       	and	r24, r24
    a310:	c9 f0       	breq	.+50     	; 0xa344 <GPRS_CriticalCMD_Process+0x46>
		switch(GPRS_CriticalCMD){
    a312:	80 91 e3 03 	lds	r24, 0x03E3
    a316:	82 30       	cpi	r24, 0x02	; 2
    a318:	69 f0       	breq	.+26     	; 0xa334 <GPRS_CriticalCMD_Process+0x36>
    a31a:	20 f4       	brcc	.+8      	; 0xa324 <GPRS_CriticalCMD_Process+0x26>
    a31c:	81 30       	cpi	r24, 0x01	; 1
    a31e:	81 f4       	brne	.+32     	; 0xa340 <GPRS_CriticalCMD_Process+0x42>
void ApplInit(void);
void ApplCycle(void);

// ~~~~~~~~~~~~~~
void Reboot(void){
	cli();
    a320:	f8 94       	cli
    a322:	07 c0       	rjmp	.+14     	; 0xa332 <GPRS_CriticalCMD_Process+0x34>
    a324:	83 30       	cpi	r24, 0x03	; 3
    a326:	51 f0       	breq	.+20     	; 0xa33c <GPRS_CriticalCMD_Process+0x3e>
    a328:	84 30       	cpi	r24, 0x04	; 4
    a32a:	51 f4       	brne	.+20     	; 0xa340 <GPRS_CriticalCMD_Process+0x42>
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
			case GPRS_UPDATER:		Start_Updater(); break;
    a32c:	0e 94 01 29 	call	0x5202	; 0x5202 <Start_Updater>
    a330:	07 c0       	rjmp	.+14     	; 0xa340 <GPRS_CriticalCMD_Process+0x42>
    a332:	ff cf       	rjmp	.-2      	; 0xa332 <GPRS_CriticalCMD_Process+0x34>
	while(1){}
}
void ResetGSMState(void){
	GSM_State = GSM_ReStart1;
    a334:	8a e5       	ldi	r24, 0x5A	; 90
    a336:	80 93 27 06 	sts	0x0627, r24
    a33a:	02 c0       	rjmp	.+4      	; 0xa340 <GPRS_CriticalCMD_Process+0x42>
void GPRS_CriticalCMD_Process(void){
	if(GPRS_CriticalCMD && Timer16Stopp(GPRS_TD_CriticalCMD)){
		switch(GPRS_CriticalCMD){
			case GPRS_REBOOT:		Reboot();	break;
			case GPRS_REBOOT_MODEM:	ResetGSMState();	break;
			case GPRS_BOOTLOADER:	Start_Bootloader(); break;
    a33c:	0e 94 ce 29 	call	0x539c	; 0x539c <Start_Bootloader>
			case GPRS_UPDATER:		Start_Updater(); break;
		}
		GPRS_CriticalCMD = 0;
    a340:	10 92 e3 03 	sts	0x03E3, r1
    a344:	08 95       	ret

0000a346 <GPRS_Param00>:
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
    a346:	cf 92       	push	r12
    a348:	ef 92       	push	r14
    a34a:	0f 93       	push	r16
    a34c:	cf 93       	push	r28
    a34e:	c8 2f       	mov	r28, r24
    a350:	06 2f       	mov	r16, r22
	uint8_t param_size = 0;

	switch(ParamID_Lo){
    a352:	84 30       	cpi	r24, 0x04	; 4
    a354:	61 f1       	breq	.+88     	; 0xa3ae <GPRS_Param00+0x68>
    a356:	28 f4       	brcc	.+10     	; 0xa362 <GPRS_Param00+0x1c>
    a358:	81 30       	cpi	r24, 0x01	; 1
    a35a:	49 f0       	breq	.+18     	; 0xa36e <GPRS_Param00+0x28>
    a35c:	82 30       	cpi	r24, 0x02	; 2
    a35e:	89 f0       	breq	.+34     	; 0xa382 <GPRS_Param00+0x3c>
    a360:	50 c0       	rjmp	.+160    	; 0xa402 <GPRS_Param00+0xbc>
    a362:	86 30       	cpi	r24, 0x06	; 6
    a364:	a1 f1       	breq	.+104    	; 0xa3ce <GPRS_Param00+0x88>
    a366:	58 f1       	brcs	.+86     	; 0xa3be <GPRS_Param00+0x78>
    a368:	87 30       	cpi	r24, 0x07	; 7
    a36a:	c9 f1       	breq	.+114    	; 0xa3de <GPRS_Param00+0x98>
    a36c:	4a c0       	rjmp	.+148    	; 0xa402 <GPRS_Param00+0xbc>
		case 1:	if(Cmd==READ_PARAM){
    a36e:	61 3c       	cpi	r22, 0xC1	; 193
    a370:	09 f0       	breq	.+2      	; 0xa374 <GPRS_Param00+0x2e>
    a372:	47 c0       	rjmp	.+142    	; 0xa402 <GPRS_Param00+0xbc>
					GPRS_ChangeData[9] = SW_VERSION;
    a374:	83 e0       	ldi	r24, 0x03	; 3
    a376:	80 93 46 06 	sts	0x0646, r24
					GPRS_ChangeData[10] = SW_SUBVERSION;
    a37a:	87 e0       	ldi	r24, 0x07	; 7
    a37c:	80 93 47 06 	sts	0x0647, r24
    a380:	3e c0       	rjmp	.+124    	; 0xa3fe <GPRS_Param00+0xb8>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
    a382:	61 3c       	cpi	r22, 0xC1	; 193
    a384:	49 f4       	brne	.+18     	; 0xa398 <GPRS_Param00+0x52>
    a386:	42 e0       	ldi	r20, 0x02	; 2
    a388:	50 e0       	ldi	r21, 0x00	; 0
    a38a:	6c e0       	ldi	r22, 0x0C	; 12
    a38c:	71 e0       	ldi	r23, 0x01	; 1
    a38e:	86 e4       	ldi	r24, 0x46	; 70
    a390:	96 e0       	ldi	r25, 0x06	; 6
    a392:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a396:	33 c0       	rjmp	.+102    	; 0xa3fe <GPRS_Param00+0xb8>
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
    a398:	6c 34       	cpi	r22, 0x4C	; 76
    a39a:	89 f5       	brne	.+98     	; 0xa3fe <GPRS_Param00+0xb8>
    a39c:	42 e0       	ldi	r20, 0x02	; 2
    a39e:	50 e0       	ldi	r21, 0x00	; 0
    a3a0:	6c e0       	ldi	r22, 0x0C	; 12
    a3a2:	71 e0       	ldi	r23, 0x01	; 1
    a3a4:	88 e4       	ldi	r24, 0x48	; 72
    a3a6:	98 e0       	ldi	r25, 0x08	; 8
    a3a8:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
    a3ac:	28 c0       	rjmp	.+80     	; 0xa3fe <GPRS_Param00+0xb8>
				param_size = sizeof(Vega_SN);
			break;
		case 4:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){ 
    a3ae:	6c 34       	cpi	r22, 0x4C	; 76
    a3b0:	41 f5       	brne	.+80     	; 0xa402 <GPRS_Param00+0xbc>
    a3b2:	80 91 48 08 	lds	r24, 0x0848
    a3b6:	88 23       	and	r24, r24
    a3b8:	21 f1       	breq	.+72     	; 0xa402 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT;	 //Reboot();
    a3ba:	81 e0       	ldi	r24, 0x01	; 1
    a3bc:	17 c0       	rjmp	.+46     	; 0xa3ec <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 5:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3be:	6c 34       	cpi	r22, 0x4C	; 76
    a3c0:	01 f5       	brne	.+64     	; 0xa402 <GPRS_Param00+0xbc>
    a3c2:	80 91 48 08 	lds	r24, 0x0848
    a3c6:	88 23       	and	r24, r24
    a3c8:	e1 f0       	breq	.+56     	; 0xa402 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_REBOOT_MODEM; //ResetGSMState();
    a3ca:	82 e0       	ldi	r24, 0x02	; 2
    a3cc:	0f c0       	rjmp	.+30     	; 0xa3ec <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 6:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3ce:	6c 34       	cpi	r22, 0x4C	; 76
    a3d0:	c1 f4       	brne	.+48     	; 0xa402 <GPRS_Param00+0xbc>
    a3d2:	80 91 48 08 	lds	r24, 0x0848
    a3d6:	88 23       	and	r24, r24
    a3d8:	a1 f0       	breq	.+40     	; 0xa402 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_BOOTLOADER;	//Menu_Bootloader_Enter();
    a3da:	83 e0       	ldi	r24, 0x03	; 3
    a3dc:	07 c0       	rjmp	.+14     	; 0xa3ec <GPRS_Param00+0xa6>
					StartTimer16(GPRS_TD_CriticalCMD, 400);
				}
			break;
		case 7:
				if( (Cmd==WRITE_PARAM) && GPRS_Data_In[11] ){
    a3de:	6c 34       	cpi	r22, 0x4C	; 76
    a3e0:	81 f4       	brne	.+32     	; 0xa402 <GPRS_Param00+0xbc>
    a3e2:	80 91 48 08 	lds	r24, 0x0848
    a3e6:	88 23       	and	r24, r24
    a3e8:	61 f0       	breq	.+24     	; 0xa402 <GPRS_Param00+0xbc>
					GPRS_CriticalCMD = GPRS_UPDATER;	//Menu_Updater_Enter();
    a3ea:	84 e0       	ldi	r24, 0x04	; 4
    a3ec:	80 93 e3 03 	sts	0x03E3, r24
					StartTimer16(GPRS_TD_CriticalCMD, 400);
    a3f0:	60 e9       	ldi	r22, 0x90	; 144
    a3f2:	71 e0       	ldi	r23, 0x01	; 1
    a3f4:	80 91 0c 0b 	lds	r24, 0x0B0C
    a3f8:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    a3fc:	02 c0       	rjmp	.+4      	; 0xa402 <GPRS_Param00+0xbc>
					param_size = 2;
				}
			break;
		case 2:	if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Vega_SN, sizeof(Vega_SN));}
				if(Cmd==WRITE_PARAM){ ewbl(&GPRS_Data_In[11], &Vega_SN, sizeof(Vega_SN));}
				param_size = sizeof(Vega_SN);
    a3fe:	22 e0       	ldi	r18, 0x02	; 2
    a400:	01 c0       	rjmp	.+2      	; 0xa404 <GPRS_Param00+0xbe>
		GPRS_CriticalCMD = 0;
	}
}

void GPRS_Param00(const uint8_t ParamID_Lo, uint8_t const Cmd){
	uint8_t param_size = 0;
    a402:	20 e0       	ldi	r18, 0x00	; 0
		case 13:if(Cmd==READ_PARAM){ erbl(GPRS_ChangeData + 9, &Magic2, sizeof(Magic2));}
				param_size = sizeof(Magic2);
			break;*/
	}	
	//GPRS_Param(0, 0, 0);
	GPRS_Param(0, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a404:	c1 2c       	mov	r12, r1
    a406:	e1 2c       	mov	r14, r1
    a408:	40 e0       	ldi	r20, 0x00	; 0
    a40a:	50 e0       	ldi	r21, 0x00	; 0
    a40c:	6c 2f       	mov	r22, r28
    a40e:	80 e0       	ldi	r24, 0x00	; 0
    a410:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a414:	cf 91       	pop	r28
    a416:	0f 91       	pop	r16
    a418:	ef 90       	pop	r14
    a41a:	cf 90       	pop	r12
    a41c:	08 95       	ret

0000a41e <GPRS_Param01>:
void GPRS_Param01( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a41e:	cf 92       	push	r12
    a420:	ef 92       	push	r14
    a422:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) eww(&A1_EEP.Config, erw(&A1_EEP.Config) | (1<<cfg_Contactor) );
			}
			break;*/
	}
	//GPRS_Param(1, 0, 0);
	GPRS_Param(1, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a424:	c1 2c       	mov	r12, r1
    a426:	e1 2c       	mov	r14, r1
    a428:	06 2f       	mov	r16, r22
    a42a:	20 e0       	ldi	r18, 0x00	; 0
    a42c:	40 e0       	ldi	r20, 0x00	; 0
    a42e:	50 e0       	ldi	r21, 0x00	; 0
    a430:	68 2f       	mov	r22, r24
    a432:	81 e0       	ldi	r24, 0x01	; 1
    a434:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a438:	0f 91       	pop	r16
    a43a:	ef 90       	pop	r14
    a43c:	cf 90       	pop	r12
    a43e:	08 95       	ret

0000a440 <GPRS_Param02>:
void GPRS_Param02( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a440:	cf 92       	push	r12
    a442:	ef 92       	push	r14
    a444:	0f 93       	push	r16
				if(GPRS_Data_In[11]==1) ewb(&DI_Invers[0], erb(&DI_Invers[0]) & ~(1<<DI_Contact) );
			}
			break;
	}*/
	//GPRS_Param(2, 0, 0);
	GPRS_Param(2, ParamID_Lo, NULL, 1, Cmd, 0, 0);
    a446:	c1 2c       	mov	r12, r1
    a448:	e1 2c       	mov	r14, r1
    a44a:	06 2f       	mov	r16, r22
    a44c:	21 e0       	ldi	r18, 0x01	; 1
    a44e:	40 e0       	ldi	r20, 0x00	; 0
    a450:	50 e0       	ldi	r21, 0x00	; 0
    a452:	68 2f       	mov	r22, r24
    a454:	82 e0       	ldi	r24, 0x02	; 2
    a456:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a45a:	0f 91       	pop	r16
    a45c:	ef 90       	pop	r14
    a45e:	cf 90       	pop	r12
    a460:	08 95       	ret

0000a462 <GPRS_Param03>:
void GPRS_Param03( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a462:	cf 92       	push	r12
    a464:	ef 92       	push	r14
    a466:	0f 93       	push	r16
		case 3:	param = &A1_EEP.td_FanCrash;	param_size = sizeof(A1_EEP.td_FanCrash);	break;
		case 4:	param = &A1_EEP.td_TRoomHigh;	param_size = sizeof(A1_EEP.td_TRoomHigh);	break;
		case 5:	param = &A1_EEP.td_Electro;		param_size = sizeof(A1_EEP.td_Electro);		break;
	}*/
	//GPRS_Param(3, 1, 0);
	GPRS_Param(3, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a468:	c1 2c       	mov	r12, r1
    a46a:	ee 24       	eor	r14, r14
    a46c:	e3 94       	inc	r14
    a46e:	06 2f       	mov	r16, r22
    a470:	20 e0       	ldi	r18, 0x00	; 0
    a472:	40 e0       	ldi	r20, 0x00	; 0
    a474:	50 e0       	ldi	r21, 0x00	; 0
    a476:	68 2f       	mov	r22, r24
    a478:	83 e0       	ldi	r24, 0x03	; 3
    a47a:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a47e:	0f 91       	pop	r16
    a480:	ef 90       	pop	r14
    a482:	cf 90       	pop	r12
    a484:	08 95       	ret

0000a486 <GPRS_Param04>:

void GPRS_Param04( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a486:	cf 92       	push	r12
    a488:	ef 92       	push	r14
    a48a:	0f 93       	push	r16
		case 4:	param = &A1_EEP.t_ConditionerOperation;	param_size = sizeof(A1_EEP.t_ConditionerOperation);break;
		case 5:	param = &A1_EEP.t_CondStartingMax;		param_size = sizeof(A1_EEP.t_CondStartingMax);		break;
		case 6:	param = &A1_EEP.t_IncTfree2cond;		param_size = sizeof(A1_EEP.t_IncTfree2cond);		break;
	}*/
	//GPRS_Param(4, 1, 0);
	GPRS_Param(4, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a48c:	c1 2c       	mov	r12, r1
    a48e:	ee 24       	eor	r14, r14
    a490:	e3 94       	inc	r14
    a492:	06 2f       	mov	r16, r22
    a494:	20 e0       	ldi	r18, 0x00	; 0
    a496:	40 e0       	ldi	r20, 0x00	; 0
    a498:	50 e0       	ldi	r21, 0x00	; 0
    a49a:	68 2f       	mov	r22, r24
    a49c:	84 e0       	ldi	r24, 0x04	; 4
    a49e:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a4a2:	0f 91       	pop	r16
    a4a4:	ef 90       	pop	r14
    a4a6:	cf 90       	pop	r12
    a4a8:	08 95       	ret

0000a4aa <GPRS_Param05>:

void GPRS_Param05( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4aa:	cf 92       	push	r12
    a4ac:	ef 92       	push	r14
    a4ae:	0f 93       	push	r16
		case 8:	param = &A1_EEP.CondDownRate;	param_size = sizeof(A1_EEP.CondDownRate);	break;
		case 9:	param = &A1_EEP.TAirLimit; 		param_size = sizeof(A1_EEP.TAirLimit);		break;
		case 10:param = &A1_EEP.TAirNormaliz;	param_size = sizeof(A1_EEP.TAirNormaliz);	break;
	}*/
	//GPRS_Param(5, 1, 0);
	GPRS_Param(5, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a4b0:	c1 2c       	mov	r12, r1
    a4b2:	ee 24       	eor	r14, r14
    a4b4:	e3 94       	inc	r14
    a4b6:	06 2f       	mov	r16, r22
    a4b8:	20 e0       	ldi	r18, 0x00	; 0
    a4ba:	40 e0       	ldi	r20, 0x00	; 0
    a4bc:	50 e0       	ldi	r21, 0x00	; 0
    a4be:	68 2f       	mov	r22, r24
    a4c0:	85 e0       	ldi	r24, 0x05	; 5
    a4c2:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a4c6:	0f 91       	pop	r16
    a4c8:	ef 90       	pop	r14
    a4ca:	cf 90       	pop	r12
    a4cc:	08 95       	ret

0000a4ce <GPRS_Param06>:

void GPRS_Param06( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a4ce:	cf 92       	push	r12
    a4d0:	ef 92       	push	r14
    a4d2:	0f 93       	push	r16
    a4d4:	2f ef       	ldi	r18, 0xFF	; 255
    a4d6:	28 0f       	add	r18, r24
    a4d8:	27 30       	cpi	r18, 0x07	; 7
    a4da:	68 f4       	brcc	.+26     	; 0xa4f6 <GPRS_Param06+0x28>
    a4dc:	30 e0       	ldi	r19, 0x00	; 0
    a4de:	f9 01       	movw	r30, r18
    a4e0:	ee 0f       	add	r30, r30
    a4e2:	ff 1f       	adc	r31, r31
    a4e4:	e4 51       	subi	r30, 0x14	; 20
    a4e6:	fe 4f       	sbci	r31, 0xFE	; 254
    a4e8:	40 81       	ld	r20, Z
    a4ea:	51 81       	ldd	r21, Z+1	; 0x01
    a4ec:	f9 01       	movw	r30, r18
    a4ee:	eb 51       	subi	r30, 0x1B	; 27
    a4f0:	fe 4f       	sbci	r31, 0xFE	; 254
    a4f2:	20 81       	ld	r18, Z
    a4f4:	03 c0       	rjmp	.+6      	; 0xa4fc <GPRS_Param06+0x2e>
    a4f6:	20 e0       	ldi	r18, 0x00	; 0
    a4f8:	40 e0       	ldi	r20, 0x00	; 0
    a4fa:	50 e0       	ldi	r21, 0x00	; 0
		case 1:	param = &ThermType[0]; 		param_size = sizeof(ThermType[0]);		break;
		case 4:	param = &ThermCorr[0].D;	param_size = sizeof(ThermCorr[0].D);	break;
		case 7:	param = &ThermCorr[0].A;	param_size = sizeof(ThermCorr[0].A);	break;
	}
	//GPRS_Param(6, 1, 0);
	GPRS_Param(6, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a4fc:	c1 2c       	mov	r12, r1
    a4fe:	ee 24       	eor	r14, r14
    a500:	e3 94       	inc	r14
    a502:	06 2f       	mov	r16, r22
    a504:	68 2f       	mov	r22, r24
    a506:	86 e0       	ldi	r24, 0x06	; 6
    a508:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a50c:	0f 91       	pop	r16
    a50e:	ef 90       	pop	r14
    a510:	cf 90       	pop	r12
    a512:	08 95       	ret

0000a514 <GPRS_Param07>:
void GPRS_Param07( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a514:	cf 92       	push	r12
    a516:	ef 92       	push	r14
    a518:	0f 93       	push	r16
		case 5:	param = &A1_EEP.FanSpeed_Start;			param_size = sizeof(A1_EEP.FanSpeed_Start);			break;
		case 6:	param = &A1_EEP.FanSpeed_Normalization; param_size = sizeof(A1_EEP.FanSpeed_Normalization);	break;
		case 7:	param = &A1_EEP.FanCheckLuft;			param_size = sizeof(A1_EEP.FanCheckLuft);			break;
	}*/
	//GPRS_Param(7, 1, 0);
	GPRS_Param(7, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a51a:	c1 2c       	mov	r12, r1
    a51c:	ee 24       	eor	r14, r14
    a51e:	e3 94       	inc	r14
    a520:	06 2f       	mov	r16, r22
    a522:	20 e0       	ldi	r18, 0x00	; 0
    a524:	40 e0       	ldi	r20, 0x00	; 0
    a526:	50 e0       	ldi	r21, 0x00	; 0
    a528:	68 2f       	mov	r22, r24
    a52a:	87 e0       	ldi	r24, 0x07	; 7
    a52c:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a530:	0f 91       	pop	r16
    a532:	ef 90       	pop	r14
    a534:	cf 90       	pop	r12
    a536:	08 95       	ret

0000a538 <GPRS_Param08>:

void GPRS_Param08( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a538:	cf 92       	push	r12
    a53a:	ef 92       	push	r14
    a53c:	0f 93       	push	r16
		case 7:	param = &PID_T_EEP.Ki;		param_size = sizeof(PID_T_EEP.Ki);		break;
		case 8:	param = &PID_T_EEP.Kd;		param_size = sizeof(PID_T_EEP.Kd);		break;
		case 9:	param = &PID_T_EEP.Deadband;param_size = sizeof(PID_T_EEP.Deadband);break;
	}*/
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
    a53e:	c1 2c       	mov	r12, r1
    a540:	ee 24       	eor	r14, r14
    a542:	e3 94       	inc	r14
    a544:	06 2f       	mov	r16, r22
    a546:	20 e0       	ldi	r18, 0x00	; 0
    a548:	40 e0       	ldi	r20, 0x00	; 0
    a54a:	50 e0       	ldi	r21, 0x00	; 0
    a54c:	68 2f       	mov	r22, r24
    a54e:	88 e0       	ldi	r24, 0x08	; 8
    a550:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a554:	0f 91       	pop	r16
    a556:	ef 90       	pop	r14
    a558:	cf 90       	pop	r12
    a55a:	08 95       	ret

0000a55c <GPRS_Param09>:

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a55c:	cf 92       	push	r12
    a55e:	ef 92       	push	r14
    a560:	0f 93       	push	r16
    a562:	06 2f       	mov	r16, r22
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a564:	48 2f       	mov	r20, r24
    a566:	50 e0       	ldi	r21, 0x00	; 0
    a568:	fa 01       	movw	r30, r20
    a56a:	31 97       	sbiw	r30, 0x01	; 1
    a56c:	e6 31       	cpi	r30, 0x16	; 22
    a56e:	f1 05       	cpc	r31, r1
    a570:	08 f0       	brcs	.+2      	; 0xa574 <GPRS_Param09+0x18>
    a572:	78 c0       	rjmp	.+240    	; 0xa664 <GPRS_Param09+0x108>
    a574:	e2 55       	subi	r30, 0x52	; 82
    a576:	ff 4f       	sbci	r31, 0xFF	; 255
    a578:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
    a57c:	23 e1       	ldi	r18, 0x13	; 19
    a57e:	44 e5       	ldi	r20, 0x54	; 84
    a580:	51 e0       	ldi	r21, 0x01	; 1
    a582:	7b c0       	rjmp	.+246    	; 0xa67a <GPRS_Param09+0x11e>
void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:
			if(Cmd==READ_PARAM){
    a584:	61 3c       	cpi	r22, 0xC1	; 193
    a586:	91 f4       	brne	.+36     	; 0xa5ac <GPRS_Param09+0x50>
    a588:	4f e0       	ldi	r20, 0x0F	; 15
    a58a:	50 e0       	ldi	r21, 0x00	; 0
    a58c:	6c e7       	ldi	r22, 0x7C	; 124
    a58e:	71 e0       	ldi	r23, 0x01	; 1
    a590:	86 e4       	ldi	r24, 0x46	; 70
    a592:	96 e0       	ldi	r25, 0x06	; 6
    a594:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a598:	4f e0       	ldi	r20, 0x0F	; 15
    a59a:	50 e0       	ldi	r21, 0x00	; 0
    a59c:	6a e9       	ldi	r22, 0x9A	; 154
    a59e:	71 e0       	ldi	r23, 0x01	; 1
    a5a0:	85 e5       	ldi	r24, 0x55	; 85
    a5a2:	96 e0       	ldi	r25, 0x06	; 6
    a5a4:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
				erbl(GPRS_ChangeData + 9, &GPRS_apn, 15);
				erbl(GPRS_ChangeData + 9 + 15, &GPRS_apn+1, 15);
				param_size = 30;
    a5a8:	2e e1       	ldi	r18, 0x1E	; 30
    a5aa:	5f c0       	rjmp	.+190    	; 0xa66a <GPRS_Param09+0x10e>
			}
			if(Cmd==WRITE_PARAM){
    a5ac:	6c 34       	cpi	r22, 0x4C	; 76
    a5ae:	09 f0       	breq	.+2      	; 0xa5b2 <GPRS_Param09+0x56>
    a5b0:	6f c0       	rjmp	.+222    	; 0xa690 <GPRS_Param09+0x134>
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
    a5b2:	4f e0       	ldi	r20, 0x0F	; 15
    a5b4:	50 e0       	ldi	r21, 0x00	; 0
    a5b6:	6c e7       	ldi	r22, 0x7C	; 124
    a5b8:	71 e0       	ldi	r23, 0x01	; 1
    a5ba:	88 e4       	ldi	r24, 0x48	; 72
    a5bc:	98 e0       	ldi	r25, 0x08	; 8
    a5be:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
    a5c2:	4f e0       	ldi	r20, 0x0F	; 15
    a5c4:	50 e0       	ldi	r21, 0x00	; 0
    a5c6:	6e e3       	ldi	r22, 0x3E	; 62
    a5c8:	73 e0       	ldi	r23, 0x03	; 3
    a5ca:	87 e5       	ldi	r24, 0x57	; 87
    a5cc:	98 e0       	ldi	r25, 0x08	; 8
    a5ce:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
    a5d2:	5e c0       	rjmp	.+188    	; 0xa690 <GPRS_Param09+0x134>
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
		case 5:		param = &UDP_ServerIP[1];		param_size = sizeof(UDP_ServerIP[1]);			break;
    a5d4:	24 e0       	ldi	r18, 0x04	; 4
    a5d6:	46 e4       	ldi	r20, 0x46	; 70
    a5d8:	51 e0       	ldi	r21, 0x01	; 1
    a5da:	4f c0       	rjmp	.+158    	; 0xa67a <GPRS_Param09+0x11e>
		case 6:		param = &UDP_ServerIP[2];		param_size = sizeof(UDP_ServerIP[2]);			break;
    a5dc:	24 e0       	ldi	r18, 0x04	; 4
    a5de:	4a e4       	ldi	r20, 0x4A	; 74
    a5e0:	51 e0       	ldi	r21, 0x01	; 1
    a5e2:	4b c0       	rjmp	.+150    	; 0xa67a <GPRS_Param09+0x11e>
		case 7:		param = &UDP_ServerIP[3];		param_size = sizeof(UDP_ServerIP[3]);			break;
    a5e4:	24 e0       	ldi	r18, 0x04	; 4
    a5e6:	4e e4       	ldi	r20, 0x4E	; 78
    a5e8:	51 e0       	ldi	r21, 0x01	; 1
    a5ea:	47 c0       	rjmp	.+142    	; 0xa67a <GPRS_Param09+0x11e>
		case 8:		param = &UDP_ServerPort[0];		param_size = sizeof(UDP_ServerPort[0]);			break;
    a5ec:	22 e0       	ldi	r18, 0x02	; 2
    a5ee:	4a e2       	ldi	r20, 0x2A	; 42
    a5f0:	51 e0       	ldi	r21, 0x01	; 1
    a5f2:	43 c0       	rjmp	.+134    	; 0xa67a <GPRS_Param09+0x11e>
		case 9:		param = &UDP_ServerPort[1];		param_size = sizeof(UDP_ServerPort[1]);			break;
    a5f4:	22 e0       	ldi	r18, 0x02	; 2
    a5f6:	4c e2       	ldi	r20, 0x2C	; 44
    a5f8:	51 e0       	ldi	r21, 0x01	; 1
    a5fa:	3f c0       	rjmp	.+126    	; 0xa67a <GPRS_Param09+0x11e>
		case 10:	param = &UDP_ServerPort[2];		param_size = sizeof(UDP_ServerPort[2]);			break;
    a5fc:	22 e0       	ldi	r18, 0x02	; 2
    a5fe:	4e e2       	ldi	r20, 0x2E	; 46
    a600:	51 e0       	ldi	r21, 0x01	; 1
    a602:	3b c0       	rjmp	.+118    	; 0xa67a <GPRS_Param09+0x11e>
		case 11:	param = &UDP_ServerPort[3];		param_size = sizeof(UDP_ServerPort[3]);			break;
    a604:	22 e0       	ldi	r18, 0x02	; 2
    a606:	40 e3       	ldi	r20, 0x30	; 48
    a608:	51 e0       	ldi	r21, 0x01	; 1
    a60a:	37 c0       	rjmp	.+110    	; 0xa67a <GPRS_Param09+0x11e>
		case 12:	param = &TCP_ClientIP[0]; 		param_size = sizeof(TCP_ClientIP[0]);			break;
    a60c:	24 e0       	ldi	r18, 0x04	; 4
    a60e:	40 e1       	ldi	r20, 0x10	; 16
    a610:	51 e0       	ldi	r21, 0x01	; 1
    a612:	33 c0       	rjmp	.+102    	; 0xa67a <GPRS_Param09+0x11e>
		case 13:	param = &TCP_ClientIP[1]; 		param_size = sizeof(TCP_ClientIP[1]);			break;
    a614:	24 e0       	ldi	r18, 0x04	; 4
    a616:	44 e1       	ldi	r20, 0x14	; 20
    a618:	51 e0       	ldi	r21, 0x01	; 1
    a61a:	2f c0       	rjmp	.+94     	; 0xa67a <GPRS_Param09+0x11e>
		case 14:	param = &TCP_ClientIP[2]; 		param_size = sizeof(TCP_ClientIP[2]);			break;
    a61c:	24 e0       	ldi	r18, 0x04	; 4
    a61e:	48 e1       	ldi	r20, 0x18	; 24
    a620:	51 e0       	ldi	r21, 0x01	; 1
    a622:	2b c0       	rjmp	.+86     	; 0xa67a <GPRS_Param09+0x11e>
		case 15:	param = &TCP_ClientIP[3]; 		param_size = sizeof(TCP_ClientIP[3]);			break;
    a624:	24 e0       	ldi	r18, 0x04	; 4
    a626:	4c e1       	ldi	r20, 0x1C	; 28
    a628:	51 e0       	ldi	r21, 0x01	; 1
    a62a:	27 c0       	rjmp	.+78     	; 0xa67a <GPRS_Param09+0x11e>
		case 16:	param = &TCP_ListenPort;		param_size = sizeof(TCP_ListenPort);			break;
    a62c:	22 e0       	ldi	r18, 0x02	; 2
    a62e:	40 e2       	ldi	r20, 0x20	; 32
    a630:	51 e0       	ldi	r21, 0x01	; 1
    a632:	23 c0       	rjmp	.+70     	; 0xa67a <GPRS_Param09+0x11e>
		case 17:	param = &TCP_CONNECT_timeout;	param_size = sizeof(TCP_CONNECT_timeout);		break;
    a634:	22 e0       	ldi	r18, 0x02	; 2
    a636:	4e e0       	ldi	r20, 0x0E	; 14
    a638:	51 e0       	ldi	r21, 0x01	; 1
    a63a:	1f c0       	rjmp	.+62     	; 0xa67a <GPRS_Param09+0x11e>
		case 18:	param = &SMS_On;				param_size = sizeof(SMS_On);					break;
    a63c:	21 e0       	ldi	r18, 0x01	; 1
    a63e:	40 e6       	ldi	r20, 0x60	; 96
    a640:	50 e0       	ldi	r21, 0x00	; 0
    a642:	1b c0       	rjmp	.+54     	; 0xa67a <GPRS_Param09+0x11e>
		case 19:	param = &SMS_Number[0];			param_size = MaxTelephN-1;						break;
    a644:	2c e0       	ldi	r18, 0x0C	; 12
    a646:	43 ee       	ldi	r20, 0xE3	; 227
    a648:	50 e0       	ldi	r21, 0x00	; 0
    a64a:	17 c0       	rjmp	.+46     	; 0xa67a <GPRS_Param09+0x11e>
		case 20:	param = &SMS_Number[1];			param_size = MaxTelephN-1;						break;
    a64c:	2c e0       	ldi	r18, 0x0C	; 12
    a64e:	40 ef       	ldi	r20, 0xF0	; 240
    a650:	50 e0       	ldi	r21, 0x00	; 0
    a652:	13 c0       	rjmp	.+38     	; 0xa67a <GPRS_Param09+0x11e>
		case 21:	param = &SMS_Number[2]; 		param_size = MaxTelephN-1;						break;
    a654:	2c e0       	ldi	r18, 0x0C	; 12
    a656:	4d ef       	ldi	r20, 0xFD	; 253
    a658:	50 e0       	ldi	r21, 0x00	; 0
    a65a:	0f c0       	rjmp	.+30     	; 0xa67a <GPRS_Param09+0x11e>
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;
    a65c:	22 e0       	ldi	r18, 0x02	; 2
    a65e:	48 e0       	ldi	r20, 0x08	; 8
    a660:	50 e0       	ldi	r21, 0x00	; 0
    a662:	0b c0       	rjmp	.+22     	; 0xa67a <GPRS_Param09+0x11e>
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a664:	20 e0       	ldi	r18, 0x00	; 0
		case 22:	param = &CurrDataPeriod;		param_size = sizeof(CurrDataPeriod);			break;

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
    a666:	81 30       	cpi	r24, 0x01	; 1
    a668:	31 f4       	brne	.+12     	; 0xa676 <GPRS_Param09+0x11a>
    a66a:	c1 2c       	mov	r12, r1
    a66c:	e1 2c       	mov	r14, r1
    a66e:	40 e0       	ldi	r20, 0x00	; 0
    a670:	50 e0       	ldi	r21, 0x00	; 0
    a672:	61 e0       	ldi	r22, 0x01	; 1
    a674:	06 c0       	rjmp	.+12     	; 0xa682 <GPRS_Param09+0x126>
	//GPRS_Param(8, 1, RAM);
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a676:	40 e0       	ldi	r20, 0x00	; 0
    a678:	50 e0       	ldi	r21, 0x00	; 0

	}
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a67a:	c1 2c       	mov	r12, r1
    a67c:	ee 24       	eor	r14, r14
    a67e:	e3 94       	inc	r14
    a680:	68 2f       	mov	r22, r24
    a682:	89 e0       	ldi	r24, 0x09	; 9
    a684:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a688:	0f 91       	pop	r16
    a68a:	ef 90       	pop	r14
    a68c:	cf 90       	pop	r12
    a68e:	08 95       	ret
	GPRS_Param(8, ParamID_Lo, param, param_size, Cmd, 1, RAM);
}

void GPRS_Param09( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a690:	20 e0       	ldi	r18, 0x00	; 0
    a692:	eb cf       	rjmp	.-42     	; 0xa66a <GPRS_Param09+0x10e>
			if(Cmd==WRITE_PARAM){
				ewbl(GPRS_Data_In + 11, &GPRS_apn, 15);
				ewbl(GPRS_Data_In + 11 + 15, &GPRS_apn+15, 15);
			}
			break;
		case 2:		param = &GPRS_apn_user_name;	param_size = sizeof(GPRS_apn_user_name)-1;		break;
    a694:	23 e1       	ldi	r18, 0x13	; 19
    a696:	48 e6       	ldi	r20, 0x68	; 104
    a698:	51 e0       	ldi	r21, 0x01	; 1
    a69a:	ef cf       	rjmp	.-34     	; 0xa67a <GPRS_Param09+0x11e>
		case 3:		param = &GPRS_apn_psw;			param_size = sizeof(GPRS_apn_psw)-1;			break;
		case 4:		param = &UDP_ServerIP[0];		param_size = sizeof(UDP_ServerIP[0]);			break;
    a69c:	24 e0       	ldi	r18, 0x04	; 4
    a69e:	42 e4       	ldi	r20, 0x42	; 66
    a6a0:	51 e0       	ldi	r21, 0x01	; 1
    a6a2:	eb cf       	rjmp	.-42     	; 0xa67a <GPRS_Param09+0x11e>

0000a6a4 <GPRS_Param10>:
//	if(ParamID_Lo == 1) GPRS_Param(9, 0, 0);
//	else  GPRS_Param(9, 1, 0);
	if(ParamID_Lo == 1) GPRS_Param(9, ParamID_Lo, NULL, param_size, Cmd, 0, 0);
	else GPRS_Param(9, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param10( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a6a4:	cf 92       	push	r12
    a6a6:	ef 92       	push	r14
    a6a8:	0f 93       	push	r16
    a6aa:	ef ef       	ldi	r30, 0xFF	; 255
    a6ac:	e8 0f       	add	r30, r24
    a6ae:	e5 30       	cpi	r30, 0x05	; 5
    a6b0:	48 f4       	brcc	.+18     	; 0xa6c4 <GPRS_Param10+0x20>
    a6b2:	f0 e0       	ldi	r31, 0x00	; 0
    a6b4:	ee 0f       	add	r30, r30
    a6b6:	ff 1f       	adc	r31, r31
    a6b8:	e5 52       	subi	r30, 0x25	; 37
    a6ba:	fe 4f       	sbci	r31, 0xFE	; 254
    a6bc:	40 81       	ld	r20, Z
    a6be:	51 81       	ldd	r21, Z+1	; 0x01
    a6c0:	22 e0       	ldi	r18, 0x02	; 2
    a6c2:	03 c0       	rjmp	.+6      	; 0xa6ca <GPRS_Param10+0x26>
    a6c4:	20 e0       	ldi	r18, 0x00	; 0
    a6c6:	40 e0       	ldi	r20, 0x00	; 0
    a6c8:	50 e0       	ldi	r21, 0x00	; 0
		case 3:	param = &Password[1];		param_size = sizeof(Password[1]);	break;
		case 4:	param = &Password[2];		param_size = sizeof(Password[2]);	break;
		case 5:	param = &Password[3];		param_size = sizeof(Password[3]);	break;
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6ca:	c1 2c       	mov	r12, r1
    a6cc:	ee 24       	eor	r14, r14
    a6ce:	e3 94       	inc	r14
    a6d0:	06 2f       	mov	r16, r22
    a6d2:	68 2f       	mov	r22, r24
    a6d4:	8a e0       	ldi	r24, 0x0A	; 10
    a6d6:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
}
    a6da:	0f 91       	pop	r16
    a6dc:	ef 90       	pop	r14
    a6de:	cf 90       	pop	r12
    a6e0:	08 95       	ret

0000a6e2 <GPRS_Param11>:
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
    a6e2:	cf 92       	push	r12
    a6e4:	ef 92       	push	r14
    a6e6:	0f 93       	push	r16
    a6e8:	cf 93       	push	r28
    a6ea:	c8 2f       	mov	r28, r24
	void *param=NULL;
	uint8_t param_size=0;
	switch(ParamID_Lo){	
    a6ec:	81 30       	cpi	r24, 0x01	; 1
    a6ee:	21 f4       	brne	.+8      	; 0xa6f8 <GPRS_Param11+0x16>
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
    a6f0:	21 e0       	ldi	r18, 0x01	; 1
    a6f2:	49 e2       	ldi	r20, 0x29	; 41
    a6f4:	50 e0       	ldi	r21, 0x00	; 0
    a6f6:	03 c0       	rjmp	.+6      	; 0xa6fe <GPRS_Param11+0x1c>
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
	uint8_t param_size=0;
    a6f8:	20 e0       	ldi	r18, 0x00	; 0
	}
	//GPRS_Param(10, 1, 0);
	GPRS_Param(10, ParamID_Lo, param, param_size, Cmd, 1, 0);
}
void GPRS_Param11( const uint8_t ParamID_Lo, uint8_t const Cmd){
	void *param=NULL;
    a6fa:	40 e0       	ldi	r20, 0x00	; 0
    a6fc:	50 e0       	ldi	r21, 0x00	; 0
	uint8_t param_size=0;
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
    a6fe:	c1 2c       	mov	r12, r1
    a700:	ee 24       	eor	r14, r14
    a702:	e3 94       	inc	r14
    a704:	06 2f       	mov	r16, r22
    a706:	6c 2f       	mov	r22, r28
    a708:	8b e0       	ldi	r24, 0x0B	; 11
    a70a:	0e 94 37 51 	call	0xa26e	; 0xa26e <GPRS_Param>
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a70e:	c1 30       	cpi	r28, 0x01	; 1
    a710:	31 f4       	brne	.+12     	; 0xa71e <GPRS_Param11+0x3c>
#endif
}
    a712:	cf 91       	pop	r28
    a714:	0f 91       	pop	r16
    a716:	ef 90       	pop	r14
    a718:	cf 90       	pop	r12
	switch(ParamID_Lo){	
		case 1:	param = &EMeterType; 		param_size = sizeof(EMeterType);			break;
	}
	GPRS_Param(11, ParamID_Lo, param, param_size, Cmd, 1, 0);
#ifdef E_METER	
	if(ParamID_Lo==1) EMeter_ReInit();	// 
    a71a:	0c 94 ba 4b 	jmp	0x9774	; 0x9774 <EMeter_ReInit>
#endif
}
    a71e:	cf 91       	pop	r28
    a720:	0f 91       	pop	r16
    a722:	ef 90       	pop	r14
    a724:	cf 90       	pop	r12
    a726:	08 95       	ret

0000a728 <GPRS_Parameter>:

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
    a728:	0f 93       	push	r16
    a72a:	1f 93       	push	r17
    a72c:	08 2f       	mov	r16, r24
    a72e:	86 2f       	mov	r24, r22
    a730:	64 2f       	mov	r22, r20
	switch(ParamID_Hi){
    a732:	10 e0       	ldi	r17, 0x00	; 0
    a734:	0c 30       	cpi	r16, 0x0C	; 12
    a736:	11 05       	cpc	r17, r1
    a738:	a8 f5       	brcc	.+106    	; 0xa7a4 <GPRS_Parameter+0x7c>
    a73a:	f8 01       	movw	r30, r16
    a73c:	ec 53       	subi	r30, 0x3C	; 60
    a73e:	ff 4f       	sbci	r31, 0xFF	; 255
    a740:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a744:	1f 91       	pop	r17
    a746:	0f 91       	pop	r16
#endif
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
    a748:	0c 94 a3 51 	jmp	0xa346	; 0xa346 <GPRS_Param00>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a74c:	1f 91       	pop	r17
    a74e:	0f 91       	pop	r16
}

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
    a750:	0c 94 0f 52 	jmp	0xa41e	; 0xa41e <GPRS_Param01>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a754:	1f 91       	pop	r17
    a756:	0f 91       	pop	r16

void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
    a758:	0c 94 20 52 	jmp	0xa440	; 0xa440 <GPRS_Param02>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a75c:	1f 91       	pop	r17
    a75e:	0f 91       	pop	r16
void GPRS_Parameter(const uint8_t ParamID_Hi, const uint8_t ParamID_Lo, uint8_t const Cmd){
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
    a760:	0c 94 31 52 	jmp	0xa462	; 0xa462 <GPRS_Param03>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a764:	1f 91       	pop	r17
    a766:	0f 91       	pop	r16
	switch(ParamID_Hi){
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
    a768:	0c 94 43 52 	jmp	0xa486	; 0xa486 <GPRS_Param04>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a76c:	1f 91       	pop	r17
    a76e:	0f 91       	pop	r16
		case 0:GPRS_Param00(ParamID_Lo, Cmd);break;			
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
    a770:	0c 94 55 52 	jmp	0xa4aa	; 0xa4aa <GPRS_Param05>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a774:	1f 91       	pop	r17
    a776:	0f 91       	pop	r16
		case 1:GPRS_Param01(ParamID_Lo, Cmd);break;			
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
    a778:	0c 94 67 52 	jmp	0xa4ce	; 0xa4ce <GPRS_Param06>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a77c:	1f 91       	pop	r17
    a77e:	0f 91       	pop	r16
		case 2:GPRS_Param02(ParamID_Lo, Cmd);break;			
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
    a780:	0c 94 8a 52 	jmp	0xa514	; 0xa514 <GPRS_Param07>
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a784:	1f 91       	pop	r17
    a786:	0f 91       	pop	r16
		case 3:GPRS_Param03(ParamID_Lo, Cmd);break;
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
    a788:	0c 94 9c 52 	jmp	0xa538	; 0xa538 <GPRS_Param08>
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a78c:	1f 91       	pop	r17
    a78e:	0f 91       	pop	r16
		case 4:GPRS_Param04(ParamID_Lo, Cmd);break;
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
    a790:	0c 94 ae 52 	jmp	0xa55c	; 0xa55c <GPRS_Param09>
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a794:	1f 91       	pop	r17
    a796:	0f 91       	pop	r16
		case 5:GPRS_Param05(ParamID_Lo, Cmd);break;
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
    a798:	0c 94 52 53 	jmp	0xa6a4	; 0xa6a4 <GPRS_Param10>
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
	}
}
    a79c:	1f 91       	pop	r17
    a79e:	0f 91       	pop	r16
		case 6:GPRS_Param06(ParamID_Lo, Cmd);break;
		case 7:GPRS_Param07(ParamID_Lo, Cmd);break;
		case 8:GPRS_Param08(ParamID_Lo, Cmd);break;
		case 9:GPRS_Param09(ParamID_Lo, Cmd);break;
		case 10:GPRS_Param10(ParamID_Lo, Cmd);break;
		case 11:GPRS_Param11(ParamID_Lo, Cmd);break;
    a7a0:	0c 94 71 53 	jmp	0xa6e2	; 0xa6e2 <GPRS_Param11>
	}
}
    a7a4:	1f 91       	pop	r17
    a7a6:	0f 91       	pop	r16
    a7a8:	08 95       	ret

0000a7aa <ReadParamBlock>:

void GPRS_ParamWrite(void){

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){
    a7aa:	cf 93       	push	r28
    a7ac:	c8 2f       	mov	r28, r24
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
		GPRS_ChangeReplySize = blocksize;
	}*/

	if(Block == 2){
    a7ae:	82 30       	cpi	r24, 0x02	; 2
    a7b0:	09 f0       	breq	.+2      	; 0xa7b4 <ReadParamBlock+0xa>
    a7b2:	80 c0       	rjmp	.+256    	; 0xa8b4 <ReadParamBlock+0x10a>
    a7b4:	4f e0       	ldi	r20, 0x0F	; 15
    a7b6:	50 e0       	ldi	r21, 0x00	; 0
    a7b8:	6c e7       	ldi	r22, 0x7C	; 124
    a7ba:	71 e0       	ldi	r23, 0x01	; 1
    a7bc:	85 e4       	ldi	r24, 0x45	; 69
    a7be:	96 e0       	ldi	r25, 0x06	; 6
    a7c0:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a7c4:	4f e0       	ldi	r20, 0x0F	; 15
    a7c6:	50 e0       	ldi	r21, 0x00	; 0
    a7c8:	6e e3       	ldi	r22, 0x3E	; 62
    a7ca:	73 e0       	ldi	r23, 0x03	; 3
    a7cc:	84 e5       	ldi	r24, 0x54	; 84
    a7ce:	96 e0       	ldi	r25, 0x06	; 6
    a7d0:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a7d4:	43 e1       	ldi	r20, 0x13	; 19
    a7d6:	50 e0       	ldi	r21, 0x00	; 0
    a7d8:	68 e6       	ldi	r22, 0x68	; 104
    a7da:	71 e0       	ldi	r23, 0x01	; 1
    a7dc:	83 e6       	ldi	r24, 0x63	; 99
    a7de:	96 e0       	ldi	r25, 0x06	; 6
    a7e0:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a7e4:	44 e1       	ldi	r20, 0x14	; 20
    a7e6:	50 e0       	ldi	r21, 0x00	; 0
    a7e8:	64 e5       	ldi	r22, 0x54	; 84
    a7ea:	71 e0       	ldi	r23, 0x01	; 1
    a7ec:	86 e7       	ldi	r24, 0x76	; 118
    a7ee:	96 e0       	ldi	r25, 0x06	; 6
    a7f0:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a7f4:	40 e1       	ldi	r20, 0x10	; 16
    a7f6:	50 e0       	ldi	r21, 0x00	; 0
    a7f8:	62 e4       	ldi	r22, 0x42	; 66
    a7fa:	71 e0       	ldi	r23, 0x01	; 1
    a7fc:	89 e8       	ldi	r24, 0x89	; 137
    a7fe:	96 e0       	ldi	r25, 0x06	; 6
    a800:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a804:	48 e0       	ldi	r20, 0x08	; 8
    a806:	50 e0       	ldi	r21, 0x00	; 0
    a808:	6a e2       	ldi	r22, 0x2A	; 42
    a80a:	71 e0       	ldi	r23, 0x01	; 1
    a80c:	89 e9       	ldi	r24, 0x99	; 153
    a80e:	96 e0       	ldi	r25, 0x06	; 6
    a810:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a814:	40 e1       	ldi	r20, 0x10	; 16
    a816:	50 e0       	ldi	r21, 0x00	; 0
    a818:	60 e1       	ldi	r22, 0x10	; 16
    a81a:	71 e0       	ldi	r23, 0x01	; 1
    a81c:	81 ea       	ldi	r24, 0xA1	; 161
    a81e:	96 e0       	ldi	r25, 0x06	; 6
    a820:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a824:	42 e0       	ldi	r20, 0x02	; 2
    a826:	50 e0       	ldi	r21, 0x00	; 0
    a828:	60 e2       	ldi	r22, 0x20	; 32
    a82a:	71 e0       	ldi	r23, 0x01	; 1
    a82c:	81 eb       	ldi	r24, 0xB1	; 177
    a82e:	96 e0       	ldi	r25, 0x06	; 6
    a830:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a834:	42 e0       	ldi	r20, 0x02	; 2
    a836:	50 e0       	ldi	r21, 0x00	; 0
    a838:	6e e0       	ldi	r22, 0x0E	; 14
    a83a:	71 e0       	ldi	r23, 0x01	; 1
    a83c:	83 eb       	ldi	r24, 0xB3	; 179
    a83e:	96 e0       	ldi	r25, 0x06	; 6
    a840:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a844:	41 e0       	ldi	r20, 0x01	; 1
    a846:	50 e0       	ldi	r21, 0x00	; 0
    a848:	60 e6       	ldi	r22, 0x60	; 96
    a84a:	70 e0       	ldi	r23, 0x00	; 0
    a84c:	85 eb       	ldi	r24, 0xB5	; 181
    a84e:	96 e0       	ldi	r25, 0x06	; 6
    a850:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a854:	4c e0       	ldi	r20, 0x0C	; 12
    a856:	50 e0       	ldi	r21, 0x00	; 0
    a858:	63 ee       	ldi	r22, 0xE3	; 227
    a85a:	70 e0       	ldi	r23, 0x00	; 0
    a85c:	86 eb       	ldi	r24, 0xB6	; 182
    a85e:	96 e0       	ldi	r25, 0x06	; 6
    a860:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a864:	4c e0       	ldi	r20, 0x0C	; 12
    a866:	50 e0       	ldi	r21, 0x00	; 0
    a868:	60 ef       	ldi	r22, 0xF0	; 240
    a86a:	70 e0       	ldi	r23, 0x00	; 0
    a86c:	82 ec       	ldi	r24, 0xC2	; 194
    a86e:	96 e0       	ldi	r25, 0x06	; 6
    a870:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a874:	4c e0       	ldi	r20, 0x0C	; 12
    a876:	50 e0       	ldi	r21, 0x00	; 0
    a878:	6d ef       	ldi	r22, 0xFD	; 253
    a87a:	70 e0       	ldi	r23, 0x00	; 0
    a87c:	8e ec       	ldi	r24, 0xCE	; 206
    a87e:	96 e0       	ldi	r25, 0x06	; 6
    a880:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
    a884:	42 e0       	ldi	r20, 0x02	; 2
    a886:	50 e0       	ldi	r21, 0x00	; 0
    a888:	68 e0       	ldi	r22, 0x08	; 8
    a88a:	70 e0       	ldi	r23, 0x00	; 0
    a88c:	8a ed       	ldi	r24, 0xDA	; 218
    a88e:	96 e0       	ldi	r25, 0x06	; 6
    a890:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[0][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[1][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &SMS_Number[2][0], 	MaxTelephN-1);					blocksize += MaxTelephN-1;
		erbl(GPRS_ChangeData + blocksize, &CurrDataPeriod, 		sizeof(CurrDataPeriod));		blocksize += sizeof(CurrDataPeriod);
								
		GPRS_ChangeData[7] = Block;
    a894:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a898:	29 e9       	ldi	r18, 0x99	; 153
    a89a:	41 e1       	ldi	r20, 0x11	; 17
    a89c:	63 e0       	ldi	r22, 0x03	; 3
    a89e:	8d e3       	ldi	r24, 0x3D	; 61
    a8a0:	96 e0       	ldi	r25, 0x06	; 6
    a8a2:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a8a6:	80 91 5c 09 	lds	r24, 0x095C
    a8aa:	88 60       	ori	r24, 0x08	; 8
    a8ac:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a8b0:	8f e9       	ldi	r24, 0x9F	; 159
    a8b2:	17 c0       	rjmp	.+46     	; 0xa8e2 <ReadParamBlock+0x138>
	}

	if(Block == 3){
    a8b4:	83 30       	cpi	r24, 0x03	; 3
    a8b6:	c1 f4       	brne	.+48     	; 0xa8e8 <ReadParamBlock+0x13e>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    a8b8:	89 e2       	ldi	r24, 0x29	; 41
    a8ba:	90 e0       	ldi	r25, 0x00	; 0
    a8bc:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
	//---
		GPRS_ChangeData[blocksize++] = erb(&EMeterType);		
    a8c0:	80 93 45 06 	sts	0x0645, r24

		GPRS_ChangeData[7] = Block;
    a8c4:	c0 93 44 06 	sts	0x0644, r28
		GPRS_AddHeader(GPRS_ChangeData, GPRS_CONTROL, 17, blocksize - 8  + 2);
    a8c8:	23 e0       	ldi	r18, 0x03	; 3
    a8ca:	41 e1       	ldi	r20, 0x11	; 17
    a8cc:	63 e0       	ldi	r22, 0x03	; 3
    a8ce:	8d e3       	ldi	r24, 0x3D	; 61
    a8d0:	96 e0       	ldi	r25, 0x06	; 6
    a8d2:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <GPRS_AddHeader>
		GPRS_SendRQ |= (1<<GPRS_RQ_Change);	//    	
    a8d6:	80 91 5c 09 	lds	r24, 0x095C
    a8da:	88 60       	ori	r24, 0x08	; 8
    a8dc:	80 93 5c 09 	sts	0x095C, r24
		GPRS_ChangeReplySize = blocksize;
    a8e0:	89 e0       	ldi	r24, 0x09	; 9
    a8e2:	80 93 11 06 	sts	0x0611, r24
    a8e6:	01 c0       	rjmp	.+2      	; 0xa8ea <ReadParamBlock+0x140>

}
//---   
uint8_t ReadParamBlock(const uint8_t Block){

	uint8_t blocksize=8;
    a8e8:	88 e0       	ldi	r24, 0x08	; 8
		GPRS_ChangeReplySize = blocksize;
	}

	return blocksize;
	
}
    a8ea:	cf 91       	pop	r28
    a8ec:	08 95       	ret

0000a8ee <GPRS_ReciveData>:

// -----              
void GPRS_ReciveData(void){
    a8ee:	cf 93       	push	r28

	if(GPRS_FlgSz_In /*&& (erb(&GPRS_Config)&(1<<cfg_GPRS_RemoteControl) )*/ ){
    a8f0:	c0 91 5e 09 	lds	r28, 0x095E
    a8f4:	cc 23       	and	r28, r28
    a8f6:	09 f4       	brne	.+2      	; 0xa8fa <GPRS_ReciveData+0xc>
    a8f8:	8a c0       	rjmp	.+276    	; 0xaa0e <GPRS_ReciveData+0x120>

		if( (GPRS_Data_In[0]!=5) || (GPRS_Data_In[1]!=1) ){ GPRS_FlgSz_In = 0; return; }
    a8fa:	80 91 3d 08 	lds	r24, 0x083D
    a8fe:	85 30       	cpi	r24, 0x05	; 5
    a900:	09 f0       	breq	.+2      	; 0xa904 <GPRS_ReciveData+0x16>
    a902:	85 c0       	rjmp	.+266    	; 0xaa0e <GPRS_ReciveData+0x120>
    a904:	80 91 3e 08 	lds	r24, 0x083E
    a908:	81 30       	cpi	r24, 0x01	; 1
    a90a:	09 f0       	breq	.+2      	; 0xa90e <GPRS_ReciveData+0x20>
    a90c:	80 c0       	rjmp	.+256    	; 0xaa0e <GPRS_ReciveData+0x120>
		
		//if( (((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3]) != GSM_PASSWORD){ 
		uint16_t Psw = ((uint16_t)GPRS_Data_In[2]<<8) + GPRS_Data_In[3];
    a90e:	80 91 3f 08 	lds	r24, 0x083F
    a912:	90 e0       	ldi	r25, 0x00	; 0
    a914:	98 2f       	mov	r25, r24
    a916:	88 27       	eor	r24, r24
    a918:	20 91 40 08 	lds	r18, 0x0840
		if(GPRS_Check_PSW(Psw) == 0){
    a91c:	82 0f       	add	r24, r18
    a91e:	91 1d       	adc	r25, r1
    a920:	0e 94 44 50 	call	0xa088	; 0xa088 <GPRS_Check_PSW>
    a924:	81 11       	cpse	r24, r1
    a926:	06 c0       	rjmp	.+12     	; 0xa934 <GPRS_ReciveData+0x46>
			GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a928:	80 91 69 09 	lds	r24, 0x0969
    a92c:	88 60       	ori	r24, 0x08	; 8
    a92e:	80 93 69 09 	sts	0x0969, r24
    a932:	1b c0       	rjmp	.+54     	; 0xa96a <GPRS_ReciveData+0x7c>
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
			GPRS_FlgSz_In = 0;
			return;
		}

		if(GPRS_Data_In[4] == GPRS_GET_SESSION_ID){
    a934:	80 91 41 08 	lds	r24, 0x0841
    a938:	84 30       	cpi	r24, 0x04	; 4
    a93a:	d9 f4       	brne	.+54     	; 0xa972 <GPRS_ReciveData+0x84>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    a93c:	8c e0       	ldi	r24, 0x0C	; 12
    a93e:	91 e0       	ldi	r25, 0x01	; 1
    a940:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
			if( erw(&Vega_SN) == (((uint16_t)GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) GPRS_Flags &= ~(1<<GPRS_flg_NoAccess);
    a944:	20 91 42 08 	lds	r18, 0x0842
    a948:	30 e0       	ldi	r19, 0x00	; 0
    a94a:	32 2f       	mov	r19, r18
    a94c:	22 27       	eor	r18, r18
    a94e:	40 91 43 08 	lds	r20, 0x0843
    a952:	24 0f       	add	r18, r20
    a954:	31 1d       	adc	r19, r1
    a956:	40 91 69 09 	lds	r20, 0x0969
    a95a:	82 17       	cp	r24, r18
    a95c:	93 07       	cpc	r25, r19
    a95e:	11 f4       	brne	.+4      	; 0xa964 <GPRS_ReciveData+0x76>
    a960:	47 7f       	andi	r20, 0xF7	; 247
    a962:	01 c0       	rjmp	.+2      	; 0xa966 <GPRS_ReciveData+0x78>
			else GPRS_Flags |= (1<<GPRS_flg_NoAccess);
    a964:	48 60       	ori	r20, 0x08	; 8
    a966:	40 93 69 09 	sts	0x0969, r20
			GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
    a96a:	80 91 5c 09 	lds	r24, 0x095C
    a96e:	80 61       	ori	r24, 0x10	; 16
    a970:	2e c0       	rjmp	.+92     	; 0xa9ce <GPRS_ReciveData+0xe0>
					}
				}
			}
		}*/

		if(GPRS_Data_In[4] == GPRS_CONTROL){
    a972:	83 30       	cpi	r24, 0x03	; 3
    a974:	09 f0       	breq	.+2      	; 0xa978 <GPRS_ReciveData+0x8a>
    a976:	4b c0       	rjmp	.+150    	; 0xaa0e <GPRS_ReciveData+0x120>

			if( (GPRS_Session_ID==0) || (GPRS_Session_ID != ( (uint16_t)(GPRS_Data_In[5]<<8) + GPRS_Data_In[6]) ) ){
    a978:	20 91 10 0b 	lds	r18, 0x0B10
    a97c:	30 91 11 0b 	lds	r19, 0x0B11
    a980:	21 15       	cp	r18, r1
    a982:	31 05       	cpc	r19, r1
    a984:	89 f2       	breq	.-94     	; 0xa928 <GPRS_ReciveData+0x3a>
    a986:	80 91 42 08 	lds	r24, 0x0842
    a98a:	90 e0       	ldi	r25, 0x00	; 0
    a98c:	98 2f       	mov	r25, r24
    a98e:	88 27       	eor	r24, r24
    a990:	40 91 43 08 	lds	r20, 0x0843
    a994:	84 0f       	add	r24, r20
    a996:	91 1d       	adc	r25, r1
    a998:	28 17       	cp	r18, r24
    a99a:	39 07       	cpc	r19, r25
    a99c:	29 f6       	brne	.-118    	; 0xa928 <GPRS_ReciveData+0x3a>
				GPRS_SendRQ |= (1 << GPRS_RQ_SessionID);
				GPRS_FlgSz_In = 0; 
				return;
			}

			uint8_t DataLength = GPRS_Data_In[7];
    a99e:	90 91 44 08 	lds	r25, 0x0844
			
			switch(GPRS_Data_In[8]){
    a9a2:	80 91 45 08 	lds	r24, 0x0845
    a9a6:	88 30       	cpi	r24, 0x08	; 8
    a9a8:	d9 f0       	breq	.+54     	; 0xa9e0 <GPRS_ReciveData+0xf2>
    a9aa:	28 f4       	brcc	.+10     	; 0xa9b6 <GPRS_ReciveData+0xc8>
    a9ac:	81 30       	cpi	r24, 0x01	; 1
    a9ae:	41 f0       	breq	.+16     	; 0xa9c0 <GPRS_ReciveData+0xd2>
    a9b0:	87 30       	cpi	r24, 0x07	; 7
    a9b2:	81 f0       	breq	.+32     	; 0xa9d4 <GPRS_ReciveData+0xe6>
    a9b4:	2c c0       	rjmp	.+88     	; 0xaa0e <GPRS_ReciveData+0x120>
    a9b6:	8a 30       	cpi	r24, 0x0A	; 10
    a9b8:	d9 f0       	breq	.+54     	; 0xa9f0 <GPRS_ReciveData+0x102>
    a9ba:	81 31       	cpi	r24, 0x11	; 17
    a9bc:	01 f1       	breq	.+64     	; 0xa9fe <GPRS_ReciveData+0x110>
    a9be:	27 c0       	rjmp	.+78     	; 0xaa0e <GPRS_ReciveData+0x120>
	   		case 1:		//  
				if ( DataLength == 1 && (GPRS_FlgSz_In == 9) ) // - 
    a9c0:	91 30       	cpi	r25, 0x01	; 1
    a9c2:	29 f5       	brne	.+74     	; 0xaa0e <GPRS_ReciveData+0x120>
    a9c4:	c9 30       	cpi	r28, 0x09	; 9
    a9c6:	19 f5       	brne	.+70     	; 0xaa0e <GPRS_ReciveData+0x120>
					GPRS_SendRQ |= (1<<GPRS_RQ_CurDataTCP);	//    
    a9c8:	80 91 5c 09 	lds	r24, 0x095C
    a9cc:	82 60       	ori	r24, 0x02	; 2
    a9ce:	80 93 5c 09 	sts	0x095C, r24
    a9d2:	1d c0       	rjmp	.+58     	; 0xaa0e <GPRS_ReciveData+0x120>
	   		case 6:
				if ( (DataLength == 5) && (GPRS_FlgSz_In == 11) ) // - 
	   			GPRS_Reg();		//   
	        	break;
	   		case 7:	//read param
				if ( (DataLength == 3) && (GPRS_FlgSz_In == 11) ) // - 
    a9d4:	93 30       	cpi	r25, 0x03	; 3
    a9d6:	d9 f4       	brne	.+54     	; 0xaa0e <GPRS_ReciveData+0x120>
    a9d8:	cb 30       	cpi	r28, 0x0B	; 11
    a9da:	c9 f4       	brne	.+50     	; 0xaa0e <GPRS_ReciveData+0x120>
	   				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], READ_PARAM);
    a9dc:	41 ec       	ldi	r20, 0xC1	; 193
    a9de:	01 c0       	rjmp	.+2      	; 0xa9e2 <GPRS_ReciveData+0xf4>
	        	break;				
	   		case 8: //write param
				GPRS_Parameter(GPRS_Data_In[9], GPRS_Data_In[10], WRITE_PARAM);
    a9e0:	4c e4       	ldi	r20, 0x4C	; 76
    a9e2:	60 91 47 08 	lds	r22, 0x0847
    a9e6:	80 91 46 08 	lds	r24, 0x0846
    a9ea:	0e 94 94 53 	call	0xa728	; 0xa728 <GPRS_Parameter>
				break;
    a9ee:	0f c0       	rjmp	.+30     	; 0xaa0e <GPRS_ReciveData+0x120>
	   		case 10:	// Remote Display
				if ( (DataLength==2) && (GPRS_FlgSz_In == 10) ) // - 
    a9f0:	92 30       	cpi	r25, 0x02	; 2
    a9f2:	69 f4       	brne	.+26     	; 0xaa0e <GPRS_ReciveData+0x120>
    a9f4:	ca 30       	cpi	r28, 0x0A	; 10
    a9f6:	59 f4       	brne	.+22     	; 0xaa0e <GPRS_ReciveData+0x120>
					GPRS_RemoteDisplayControl();
    a9f8:	0e 94 a2 50 	call	0xa144	; 0xa144 <GPRS_RemoteDisplayControl>
    a9fc:	08 c0       	rjmp	.+16     	; 0xaa0e <GPRS_ReciveData+0x120>
	        	break;
			case 17:	//read param block
				if ( (DataLength == 2) && (GPRS_FlgSz_In == 10) ) // - 
    a9fe:	92 30       	cpi	r25, 0x02	; 2
    aa00:	31 f4       	brne	.+12     	; 0xaa0e <GPRS_ReciveData+0x120>
    aa02:	ca 30       	cpi	r28, 0x0A	; 10
    aa04:	21 f4       	brne	.+8      	; 0xaa0e <GPRS_ReciveData+0x120>
					ReadParamBlock	(GPRS_Data_In[9]);
    aa06:	80 91 46 08 	lds	r24, 0x0846
    aa0a:	0e 94 d5 53 	call	0xa7aa	; 0xa7aa <ReadParamBlock>
				break;
			}
		}
		GPRS_FlgSz_In = 0;
    aa0e:	10 92 5e 09 	sts	0x095E, r1
	}//   
	else GPRS_FlgSz_In = 0;
}
    aa12:	cf 91       	pop	r28
    aa14:	08 95       	ret

0000aa16 <GPRS_Arbitr>:
// -----                  
void GPRS_Arbitr(void){
	
	if(GPRS_SendRQ & (1<<GPRS_RQ_NewCrash)){
    aa16:	80 91 5c 09 	lds	r24, 0x095C
    aa1a:	86 ff       	sbrs	r24, 6
    aa1c:	06 c0       	rjmp	.+12     	; 0xaa2a <GPRS_Arbitr+0x14>
		GPRS_SendNewCrash();
    aa1e:	0e 94 21 50 	call	0xa042	; 0xa042 <GPRS_SendNewCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_NewCrash);
    aa22:	80 91 5c 09 	lds	r24, 0x095C
    aa26:	8f 7b       	andi	r24, 0xBF	; 191
    aa28:	3d c0       	rjmp	.+122    	; 0xaaa4 <GPRS_Arbitr+0x8e>
		GPRS_Protocol_Out = UDP;
		IP_SendMask = 0;	//   IP
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_RepCrash)){
    aa2a:	85 ff       	sbrs	r24, 5
    aa2c:	0d c0       	rjmp	.+26     	; 0xaa48 <GPRS_Arbitr+0x32>
		GPRS_SendRepCrash();
    aa2e:	0e 94 31 50 	call	0xa062	; 0xa062 <GPRS_SendRepCrash>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_RepCrash);
    aa32:	80 91 5c 09 	lds	r24, 0x095C
    aa36:	8f 7d       	andi	r24, 0xDF	; 223
    aa38:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aa3c:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0b11111110;	//   IP1
    aa40:	8e ef       	ldi	r24, 0xFE	; 254
    aa42:	80 93 6f 08 	sts	0x086F, r24
    aa46:	34 c0       	rjmp	.+104    	; 0xaab0 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_SessionID)){
    aa48:	84 ff       	sbrs	r24, 4
    aa4a:	06 c0       	rjmp	.+12     	; 0xaa58 <GPRS_Arbitr+0x42>
		GPRS_Get_Session_ID();
    aa4c:	0e 94 62 50 	call	0xa0c4	; 0xa0c4 <GPRS_Get_Session_ID>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_SessionID);
    aa50:	80 91 5c 09 	lds	r24, 0x095C
    aa54:	8f 7e       	andi	r24, 0xEF	; 239
    aa56:	19 c0       	rjmp	.+50     	; 0xaa8a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Change)){
    aa58:	83 ff       	sbrs	r24, 3
    aa5a:	08 c0       	rjmp	.+16     	; 0xaa6c <GPRS_Arbitr+0x56>
		GPRS_SendChange(GPRS_ChangeReplySize);
    aa5c:	80 91 11 06 	lds	r24, 0x0611
    aa60:	0e 94 cd 50 	call	0xa19a	; 0xa19a <GPRS_SendChange>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Change);
    aa64:	80 91 5c 09 	lds	r24, 0x095C
    aa68:	87 7f       	andi	r24, 0xF7	; 247
    aa6a:	0f c0       	rjmp	.+30     	; 0xaa8a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_Remote)){
    aa6c:	82 ff       	sbrs	r24, 2
    aa6e:	06 c0       	rjmp	.+12     	; 0xaa7c <GPRS_Arbitr+0x66>
		GPRS_SendDisplay();
    aa70:	0e 94 ac 50 	call	0xa158	; 0xa158 <GPRS_SendDisplay>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_Remote);
    aa74:	80 91 5c 09 	lds	r24, 0x095C
    aa78:	8b 7f       	andi	r24, 0xFB	; 251
    aa7a:	07 c0       	rjmp	.+14     	; 0xaa8a <GPRS_Arbitr+0x74>
		GPRS_Protocol_Out = TCP;
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataTCP)){
    aa7c:	81 ff       	sbrs	r24, 1
    aa7e:	0b c0       	rjmp	.+22     	; 0xaa96 <GPRS_Arbitr+0x80>
		GPRS_CurDataSend();
    aa80:	0e 94 40 4d 	call	0x9a80	; 0x9a80 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataTCP);
    aa84:	80 91 5c 09 	lds	r24, 0x095C
    aa88:	8d 7f       	andi	r24, 0xFD	; 253
    aa8a:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = TCP;
    aa8e:	81 e0       	ldi	r24, 0x01	; 1
    aa90:	80 93 7c 09 	sts	0x097C, r24
    aa94:	0d c0       	rjmp	.+26     	; 0xaab0 <GPRS_Arbitr+0x9a>
		GPRSOutLen = GPRS_FlgSz_Out;
		return;
	}
	if(GPRS_SendRQ & (1<<GPRS_RQ_CurDataUDP)){
    aa96:	80 ff       	sbrs	r24, 0
    aa98:	0f c0       	rjmp	.+30     	; 0xaab8 <GPRS_Arbitr+0xa2>
		GPRS_CurDataSend();
    aa9a:	0e 94 40 4d 	call	0x9a80	; 0x9a80 <GPRS_CurDataSend>
		GPRS_SendRQ &= ~(1 << GPRS_RQ_CurDataUDP);
    aa9e:	80 91 5c 09 	lds	r24, 0x095C
    aaa2:	8e 7f       	andi	r24, 0xFE	; 254
    aaa4:	80 93 5c 09 	sts	0x095C, r24
		GPRS_Protocol_Out = UDP;
    aaa8:	10 92 7c 09 	sts	0x097C, r1
		IP_SendMask = 0;	//   IP
    aaac:	10 92 6f 08 	sts	0x086F, r1
		GPRSOutLen = GPRS_FlgSz_Out;
    aab0:	80 91 43 09 	lds	r24, 0x0943
    aab4:	80 93 7b 09 	sts	0x097B, r24
    aab8:	08 95       	ret

0000aaba <GPRS_App>:
		return;
	}
}
// -----   ApplCycle
void GPRS_App(void){
    aaba:	cf 93       	push	r28
    aabc:	df 93       	push	r29

	if(GetTimer16(GPRS_TD_SessionIDGenerator)<200) StartTimer16(GPRS_TD_SessionIDGenerator, 0xFFFF);
    aabe:	c0 91 4e 09 	lds	r28, 0x094E

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    aac2:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint16_t Time = Timer16[TimerN];
    aac6:	ec 2f       	mov	r30, r28
    aac8:	f0 e0       	ldi	r31, 0x00	; 0
    aaca:	ee 0f       	add	r30, r30
    aacc:	ff 1f       	adc	r31, r31
    aace:	ea 5d       	subi	r30, 0xDA	; 218
    aad0:	fc 4f       	sbci	r31, 0xFC	; 252
    aad2:	c0 81       	ld	r28, Z
    aad4:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    aad6:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
    aada:	c8 3c       	cpi	r28, 0xC8	; 200
    aadc:	d1 05       	cpc	r29, r1
    aade:	30 f4       	brcc	.+12     	; 0xaaec <GPRS_App+0x32>
    aae0:	6f ef       	ldi	r22, 0xFF	; 255
    aae2:	7f ef       	ldi	r23, 0xFF	; 255
    aae4:	80 91 4e 09 	lds	r24, 0x094E
    aae8:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
	if(GSM_ActiveConnection == NO_CONNECTION){
    aaec:	80 91 07 01 	lds	r24, 0x0107
    aaf0:	8f 3f       	cpi	r24, 0xFF	; 255
    aaf2:	31 f4       	brne	.+12     	; 0xab00 <GPRS_App+0x46>
		GPRS_Session_ID = 0;
    aaf4:	10 92 11 0b 	sts	0x0B11, r1
    aaf8:	10 92 10 0b 	sts	0x0B10, r1
		GPRS_LoginLevel = 0;
    aafc:	10 92 d5 08 	sts	0x08D5, r1
	}

	GPRS_RetryTimer = GetTimer16(GPRS_TD_CrashSendRetry);
    ab00:	c0 91 0f 06 	lds	r28, 0x060F

// ~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
GetTimer16(uint8_t TimerN)
{
	IntOff();
    ab04:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint16_t Time = Timer16[TimerN];
    ab08:	ec 2f       	mov	r30, r28
    ab0a:	f0 e0       	ldi	r31, 0x00	; 0
    ab0c:	ee 0f       	add	r30, r30
    ab0e:	ff 1f       	adc	r31, r31
    ab10:	ea 5d       	subi	r30, 0xDA	; 218
    ab12:	fc 4f       	sbci	r31, 0xFC	; 252
    ab14:	c0 81       	ld	r28, Z
    ab16:	d1 81       	ldd	r29, Z+1	; 0x01
	IntOn();
    ab18:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
    ab1c:	d0 93 00 06 	sts	0x0600, r29
    ab20:	c0 93 ff 05 	sts	0x05FF, r28

	if(!(GPRS_Flags & (1<<GPRS_flg_Fail))){
    ab24:	80 91 69 09 	lds	r24, 0x0969
    ab28:	80 fd       	sbrc	r24, 0
    ab2a:	1b c0       	rjmp	.+54     	; 0xab62 <GPRS_App+0xa8>
			if(Timer16Stopp(GPRS_TD_CrashSendRetry)){
				GPRS_SendRQ |= (1<<GPRS_RQ_RepCrash);		//     
				StartTimer16(GPRS_TD_CrashSendRetry,12000);	//   
			}
		}*/
		GPRS_ReciveData();
    ab2c:	0e 94 77 54 	call	0xa8ee	; 0xa8ee <GPRS_ReciveData>
		//   Remote Display
		if(Timer8Stopp(TD_GPRS_RemoteDisplay) && ( GPRS_Flags & (1<<GPRS_flg_RemoteDispalyRQ) ) ){
    ab30:	80 e0       	ldi	r24, 0x00	; 0
    ab32:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    ab36:	88 23       	and	r24, r24
    ab38:	61 f0       	breq	.+24     	; 0xab52 <GPRS_App+0x98>
    ab3a:	90 91 69 09 	lds	r25, 0x0969
    ab3e:	92 ff       	sbrs	r25, 2
    ab40:	08 c0       	rjmp	.+16     	; 0xab52 <GPRS_App+0x98>
			GPRS_SendRQ |= (1<<GPRS_RQ_Remote);
    ab42:	80 91 5c 09 	lds	r24, 0x095C
    ab46:	84 60       	ori	r24, 0x04	; 4
    ab48:	80 93 5c 09 	sts	0x095C, r24
			GPRS_Flags &= ~(1<<GPRS_flg_RemoteDispalyRQ);
    ab4c:	9b 7f       	andi	r25, 0xFB	; 251
    ab4e:	90 93 69 09 	sts	0x0969, r25
		}
		//     GPRS  5 
		GPRS_SendData();
    ab52:	0e 94 5c 4f 	call	0x9eb8	; 0x9eb8 <GPRS_SendData>
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
    ab56:	80 91 43 09 	lds	r24, 0x0943
    ab5a:	81 11       	cpse	r24, r1
    ab5c:	02 c0       	rjmp	.+4      	; 0xab62 <GPRS_App+0xa8>
    ab5e:	0e 94 0b 55 	call	0xaa16	; 0xaa16 <GPRS_Arbitr>
	}

	GPRS_CriticalCMD_Process();
}
    ab62:	df 91       	pop	r29
    ab64:	cf 91       	pop	r28
		GPRS_SendData();
		//   GPRS
		if(!GPRS_FlgSz_Out) GPRS_Arbitr();
	}

	GPRS_CriticalCMD_Process();
    ab66:	0c 94 7f 51 	jmp	0xa2fe	; 0xa2fe <GPRS_CriticalCMD_Process>

0000ab6a <GSMApply>:
}

void 
GSMApply(void){//=====================================================   GSM

	ewbl(&MBHoldReg1[1], &GPRS_apn, sizeof(GPRS_apn));
    ab6a:	4e e1       	ldi	r20, 0x1E	; 30
    ab6c:	50 e0       	ldi	r21, 0x00	; 0
    ab6e:	6c e7       	ldi	r22, 0x7C	; 124
    ab70:	71 e0       	ldi	r23, 0x01	; 1
    ab72:	8e e7       	ldi	r24, 0x7E	; 126
    ab74:	98 e0       	ldi	r25, 0x08	; 8
    ab76:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
	wdt_reset();
    ab7a:	a8 95       	wdr
	ewbl(&MBHoldReg1[16], &GPRS_apn_user_name, sizeof(GPRS_apn_user_name));
    ab7c:	44 e1       	ldi	r20, 0x14	; 20
    ab7e:	50 e0       	ldi	r21, 0x00	; 0
    ab80:	68 e6       	ldi	r22, 0x68	; 104
    ab82:	71 e0       	ldi	r23, 0x01	; 1
    ab84:	8c e9       	ldi	r24, 0x9C	; 156
    ab86:	98 e0       	ldi	r25, 0x08	; 8
    ab88:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
	wdt_reset();
    ab8c:	a8 95       	wdr
	ewbl(&MBHoldReg1[26], &GPRS_apn_psw, sizeof(GPRS_apn_psw));
    ab8e:	44 e1       	ldi	r20, 0x14	; 20
    ab90:	50 e0       	ldi	r21, 0x00	; 0
    ab92:	64 e5       	ldi	r22, 0x54	; 84
    ab94:	71 e0       	ldi	r23, 0x01	; 1
    ab96:	80 eb       	ldi	r24, 0xB0	; 176
    ab98:	98 e0       	ldi	r25, 0x08	; 8
    ab9a:	0e 94 dd 29 	call	0x53ba	; 0x53ba <ewbl>
	wdt_reset();
    ab9e:	a8 95       	wdr
	eww(&TCP_ListenPort, MBHoldReg1[36]);
    aba0:	60 91 c4 08 	lds	r22, 0x08C4
    aba4:	70 91 c5 08 	lds	r23, 0x08C5
    aba8:	80 e2       	ldi	r24, 0x20	; 32
    abaa:	91 e0       	ldi	r25, 0x01	; 1
    abac:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>
	eww(&TCP_CONNECT_timeout, MBHoldReg1[37]);
    abb0:	60 91 c6 08 	lds	r22, 0x08C6
    abb4:	70 91 c7 08 	lds	r23, 0x08C7
    abb8:	8e e0       	ldi	r24, 0x0E	; 14
    abba:	91 e0       	ldi	r25, 0x01	; 1
    abbc:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>

	ewb(&TCP_ServerIP->IP1, MBHoldReg1[38]);
    abc0:	60 91 c8 08 	lds	r22, 0x08C8
    abc4:	82 e3       	ldi	r24, 0x32	; 50
    abc6:	91 e0       	ldi	r25, 0x01	; 1
    abc8:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
	ewb(&TCP_ServerIP->IP2, MBHoldReg1[39]);
    abcc:	60 91 ca 08 	lds	r22, 0x08CA
    abd0:	83 e3       	ldi	r24, 0x33	; 51
    abd2:	91 e0       	ldi	r25, 0x01	; 1
    abd4:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
	ewb(&TCP_ServerIP->IP3, MBHoldReg1[40]);
    abd8:	60 91 cc 08 	lds	r22, 0x08CC
    abdc:	84 e3       	ldi	r24, 0x34	; 52
    abde:	91 e0       	ldi	r25, 0x01	; 1
    abe0:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
	ewb(&TCP_ServerIP->IP4, MBHoldReg1[41]);
    abe4:	60 91 ce 08 	lds	r22, 0x08CE
    abe8:	85 e3       	ldi	r24, 0x35	; 53
    abea:	91 e0       	ldi	r25, 0x01	; 1
    abec:	0e 94 ca 29 	call	0x5394	; 0x5394 <ewb>
	eww(&TCP_ServerPort[0], MBHoldReg1[42]);
    abf0:	60 91 d0 08 	lds	r22, 0x08D0
    abf4:	70 91 d1 08 	lds	r23, 0x08D1
    abf8:	82 e2       	ldi	r24, 0x22	; 34
    abfa:	91 e0       	ldi	r25, 0x01	; 1
    abfc:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>
	eww(&SerialNum, MBHoldReg1[43]);
    ac00:	60 91 d2 08 	lds	r22, 0x08D2
    ac04:	70 91 d3 08 	lds	r23, 0x08D3
    ac08:	82 e5       	ldi	r24, 0x52	; 82
    ac0a:	91 e0       	ldi	r25, 0x01	; 1
    ac0c:	0c 94 d5 29 	jmp	0x53aa	; 0x53aa <eww>

0000ac10 <Modbus_App>:
	MBHoldReg1[43] = erw(&SerialNum);
	IntOn();
}

// ~~~~~~~~~~~
void Modbus_App(void){
    ac10:	cf 93       	push	r28
    ac12:	df 93       	push	r29

	IntOff();
    ac14:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	MBInput1[0] = DigInput.State[0];
    ac18:	80 91 d6 08 	lds	r24, 0x08D6
    ac1c:	80 93 f6 03 	sts	0x03F6, r24

	MBInReg1[0]  = (SW_VERSION << 8) + 	SW_SUBVERSION;
    ac20:	87 e0       	ldi	r24, 0x07	; 7
    ac22:	93 e0       	ldi	r25, 0x03	; 3
    ac24:	90 93 79 0a 	sts	0x0A79, r25
    ac28:	80 93 78 0a 	sts	0x0A78, r24
	MBInReg1[1]  = MemFail;
    ac2c:	80 91 77 0a 	lds	r24, 0x0A77
    ac30:	90 e0       	ldi	r25, 0x00	; 0
    ac32:	90 93 7b 0a 	sts	0x0A7B, r25
    ac36:	80 93 7a 0a 	sts	0x0A7A, r24
	MBInReg1[2]  = (uint16_t)(LiveTime & 0x0000FFFF);
    ac3a:	80 91 63 09 	lds	r24, 0x0963
    ac3e:	90 91 64 09 	lds	r25, 0x0964
    ac42:	a0 91 65 09 	lds	r26, 0x0965
    ac46:	b0 91 66 09 	lds	r27, 0x0966
    ac4a:	90 93 7d 0a 	sts	0x0A7D, r25
    ac4e:	80 93 7c 0a 	sts	0x0A7C, r24
	MBInReg1[3]  = (uint16_t)(LiveTime>>16);
    ac52:	80 91 63 09 	lds	r24, 0x0963
    ac56:	90 91 64 09 	lds	r25, 0x0964
    ac5a:	a0 91 65 09 	lds	r26, 0x0965
    ac5e:	b0 91 66 09 	lds	r27, 0x0966
    ac62:	b0 93 7f 0a 	sts	0x0A7F, r27
    ac66:	a0 93 7e 0a 	sts	0x0A7E, r26
	MBInReg1[4]  = (uint16_t)Temperature[0];	
    ac6a:	80 91 f2 05 	lds	r24, 0x05F2
    ac6e:	90 91 f3 05 	lds	r25, 0x05F3
    ac72:	90 93 81 0a 	sts	0x0A81, r25
    ac76:	80 93 80 0a 	sts	0x0A80, r24
	MBInReg1[5]  = (uint16_t)GSM_State;
    ac7a:	80 91 27 06 	lds	r24, 0x0627
    ac7e:	90 e0       	ldi	r25, 0x00	; 0
    ac80:	90 93 83 0a 	sts	0x0A83, r25
    ac84:	80 93 82 0a 	sts	0x0A82, r24
	MBInReg1[6]  = GSM_MyIP.IP1;
    ac88:	80 91 1c 0b 	lds	r24, 0x0B1C
    ac8c:	90 e0       	ldi	r25, 0x00	; 0
    ac8e:	90 93 85 0a 	sts	0x0A85, r25
    ac92:	80 93 84 0a 	sts	0x0A84, r24
	MBInReg1[7]  = GSM_MyIP.IP2;
    ac96:	80 91 1d 0b 	lds	r24, 0x0B1D
    ac9a:	90 e0       	ldi	r25, 0x00	; 0
    ac9c:	90 93 87 0a 	sts	0x0A87, r25
    aca0:	80 93 86 0a 	sts	0x0A86, r24
	MBInReg1[8]  = GSM_MyIP.IP3;
    aca4:	80 91 1e 0b 	lds	r24, 0x0B1E
    aca8:	90 e0       	ldi	r25, 0x00	; 0
    acaa:	90 93 89 0a 	sts	0x0A89, r25
    acae:	80 93 88 0a 	sts	0x0A88, r24
	MBInReg1[9]  = GSM_MyIP.IP4;
    acb2:	80 91 1f 0b 	lds	r24, 0x0B1F
    acb6:	90 e0       	ldi	r25, 0x00	; 0
    acb8:	90 93 8b 0a 	sts	0x0A8B, r25
    acbc:	80 93 8a 0a 	sts	0x0A8A, r24
	MBInReg1[10] = GSM_ClientIP.IP1;
    acc0:	80 91 3a 0d 	lds	r24, 0x0D3A
    acc4:	90 e0       	ldi	r25, 0x00	; 0
    acc6:	90 93 8d 0a 	sts	0x0A8D, r25
    acca:	80 93 8c 0a 	sts	0x0A8C, r24
	MBInReg1[11] = GSM_ClientIP.IP2;
    acce:	80 91 3b 0d 	lds	r24, 0x0D3B
    acd2:	90 e0       	ldi	r25, 0x00	; 0
    acd4:	90 93 8f 0a 	sts	0x0A8F, r25
    acd8:	80 93 8e 0a 	sts	0x0A8E, r24
	MBInReg1[12] = GSM_ClientIP.IP3;
    acdc:	80 91 3c 0d 	lds	r24, 0x0D3C
    ace0:	90 e0       	ldi	r25, 0x00	; 0
    ace2:	90 93 91 0a 	sts	0x0A91, r25
    ace6:	80 93 90 0a 	sts	0x0A90, r24
	MBInReg1[13] = GSM_ClientIP.IP4;
    acea:	80 91 3d 0d 	lds	r24, 0x0D3D
    acee:	90 e0       	ldi	r25, 0x00	; 0
    acf0:	90 93 93 0a 	sts	0x0A93, r25
    acf4:	80 93 92 0a 	sts	0x0A92, r24
	MBInReg1[14] = GSM_RX_FIFOMax;
    acf8:	80 91 0d 0b 	lds	r24, 0x0B0D
    acfc:	90 e0       	ldi	r25, 0x00	; 0
    acfe:	90 93 95 0a 	sts	0x0A95, r25
    ad02:	80 93 94 0a 	sts	0x0A94, r24
	MBInReg1[15] = GSM_RX_FIFOMax_Transp;
    ad06:	80 91 7f 09 	lds	r24, 0x097F
    ad0a:	90 e0       	ldi	r25, 0x00	; 0
    ad0c:	90 93 97 0a 	sts	0x0A97, r25
    ad10:	80 93 96 0a 	sts	0x0A96, r24
	MBInReg1[16] = EM_RX_FIFOMax;
    ad14:	80 91 6e 0a 	lds	r24, 0x0A6E
    ad18:	90 e0       	ldi	r25, 0x00	; 0
    ad1a:	90 93 99 0a 	sts	0x0A99, r25
    ad1e:	80 93 98 0a 	sts	0x0A98, r24
	uint64_t *ptr64 = (uint64_t*)&MBInReg1[17];
	ptr64[0] = ICCID;
    ad22:	80 91 73 09 	lds	r24, 0x0973
    ad26:	80 93 9a 0a 	sts	0x0A9A, r24
    ad2a:	80 91 74 09 	lds	r24, 0x0974
    ad2e:	80 93 9b 0a 	sts	0x0A9B, r24
    ad32:	80 91 75 09 	lds	r24, 0x0975
    ad36:	80 93 9c 0a 	sts	0x0A9C, r24
    ad3a:	80 91 76 09 	lds	r24, 0x0976
    ad3e:	80 93 9d 0a 	sts	0x0A9D, r24
    ad42:	80 91 77 09 	lds	r24, 0x0977
    ad46:	80 93 9e 0a 	sts	0x0A9E, r24
    ad4a:	80 91 78 09 	lds	r24, 0x0978
    ad4e:	80 93 9f 0a 	sts	0x0A9F, r24
    ad52:	80 91 79 09 	lds	r24, 0x0979
    ad56:	80 93 a0 0a 	sts	0x0AA0, r24
    ad5a:	80 91 7a 09 	lds	r24, 0x097A
    ad5e:	80 93 a1 0a 	sts	0x0AA1, r24
	MBInReg1[21] = (uint16_t)GSM_StateBeforeReset;
    ad62:	80 91 5b 09 	lds	r24, 0x095B
    ad66:	90 e0       	ldi	r25, 0x00	; 0
    ad68:	90 93 a3 0a 	sts	0x0AA3, r25
    ad6c:	80 93 a2 0a 	sts	0x0AA2, r24
	MBInReg1[22] = (uint16_t)Web_POST;
    ad70:	80 91 6d 09 	lds	r24, 0x096D
    ad74:	90 e0       	ldi	r25, 0x00	; 0
    ad76:	90 93 a5 0a 	sts	0x0AA5, r25
    ad7a:	80 93 a4 0a 	sts	0x0AA4, r24
	MBInReg1[23] = (uint16_t)AppProtocol;
    ad7e:	80 91 f4 09 	lds	r24, 0x09F4
    ad82:	90 e0       	ldi	r25, 0x00	; 0
    ad84:	90 93 a7 0a 	sts	0x0AA7, r25
    ad88:	80 93 a6 0a 	sts	0x0AA6, r24
	MBInReg1[24] = (uint16_t)WebSession;
    ad8c:	80 91 7e 09 	lds	r24, 0x097E
    ad90:	90 e0       	ldi	r25, 0x00	; 0
    ad92:	90 93 a9 0a 	sts	0x0AA9, r25
    ad96:	80 93 a8 0a 	sts	0x0AA8, r24
	MBInReg1[25] = (uint16_t)WebMode;
    ad9a:	80 91 06 01 	lds	r24, 0x0106
    ad9e:	90 e0       	ldi	r25, 0x00	; 0
    ada0:	90 93 ab 0a 	sts	0x0AAB, r25
    ada4:	80 93 aa 0a 	sts	0x0AAA, r24
	MBInReg1[26] = (uint16_t)WebStrLen;
    ada8:	80 91 70 08 	lds	r24, 0x0870
    adac:	90 e0       	ldi	r25, 0x00	; 0
    adae:	90 93 ad 0a 	sts	0x0AAD, r25
    adb2:	80 93 ac 0a 	sts	0x0AAC, r24

	IntOn();
    adb6:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
	
	//   GSM
	if(MBCoil1[0] & (1<<0)){
    adba:	80 91 df 03 	lds	r24, 0x03DF
    adbe:	80 ff       	sbrs	r24, 0
    adc0:	10 c0       	rjmp	.+32     	; 0xade2 <Modbus_App+0x1d2>
		GSMApply();						//  MB RAM  EEPROM
    adc2:	0e 94 b5 55 	call	0xab6a	; 0xab6a <GSMApply>
		Modbus_ReadHoldReg();			//  EEPROM   MB
    adc6:	0e 94 25 2a 	call	0x544a	; 0x544a <Modbus_ReadHoldReg>
    adca:	8a e5       	ldi	r24, 0x5A	; 90
    adcc:	80 93 27 06 	sts	0x0627, r24
		ResetGSMState();				// 
		IntOff();
    add0:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
		MBCoil1[0] &= ~(1<<0); 			//    Modbus
    add4:	80 91 df 03 	lds	r24, 0x03DF
    add8:	8e 7f       	andi	r24, 0xFE	; 254
    adda:	80 93 df 03 	sts	0x03DF, r24
		IntOn();
    adde:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
	}
	
	IntOff();
    ade2:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
    ade6:	c0 91 7c 08 	lds	r28, 0x087C
    adea:	d0 91 7d 08 	lds	r29, 0x087D
    adee:	87 e2       	ldi	r24, 0x27	; 39
    adf0:	90 e0       	ldi	r25, 0x00	; 0
    adf2:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    adf6:	c8 17       	cp	r28, r24
    adf8:	d9 07       	cpc	r29, r25
    adfa:	29 f0       	breq	.+10     	; 0xae06 <Modbus_App+0x1f6>
		eww(&EM_UART_Param, MBHoldReg1[0]);
    adfc:	be 01       	movw	r22, r28
    adfe:	87 e2       	ldi	r24, 0x27	; 39
    ae00:	90 e0       	ldi	r25, 0x00	; 0
    ae02:	0e 94 d5 29 	call	0x53aa	; 0x53aa <eww>
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
}
    ae06:	df 91       	pop	r29
    ae08:	cf 91       	pop	r28
	IntOff();
	if(MBHoldReg1[0] != erw(&EM_UART_Param)){
		eww(&EM_UART_Param, MBHoldReg1[0]);
		//EM_SetUARTParam(erw(&EM_UART_Param));	//  UART
	}
	IntOn();
    ae0a:	0c 94 1d 2a 	jmp	0x543a	; 0x543a <IntOn>

0000ae0e <StartDebug>:
/*
	  GSM_DebugMode=1     RS232/485 19200,8, E,1
*/

void StartDebug(void){
	GSM_DebugMode = 1;
    ae0e:	81 e0       	ldi	r24, 0x01	; 1
    ae10:	80 93 f2 09 	sts	0x09F2, r24
	ModbusMode = 0;
    ae14:	10 92 e0 03 	sts	0x03E0, r1
	EM_InitFIFO();
    ae18:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_InitFIFO>
	cli();
    ae1c:	f8 94       	cli
	PORTD |= (1<<PD4);	//RS485 Tx_on	
    ae1e:	94 9a       	sbi	0x12, 4	; 18
	UCSR_EMETER_A = (0<<U2X_EMETER) | (0<<MPCM_EMETER);
    ae20:	10 92 9b 00 	sts	0x009B, r1
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    ae24:	88 e0       	ldi	r24, 0x08	; 8
    ae26:	80 93 9a 00 	sts	0x009A, r24
	EM_SetUARTParam(5 + (1<<8) + (0<<10) + (3<<11)); //    19200,8,E,1
    ae2a:	85 e0       	ldi	r24, 0x05	; 5
    ae2c:	99 e1       	ldi	r25, 0x19	; 25
    ae2e:	0e 94 f9 4a 	call	0x95f2	; 0x95f2 <EM_SetUARTParam>
	sei();	
    ae32:	78 94       	sei
    ae34:	08 95       	ret

0000ae36 <StopDebug>:
}

void StopDebug(void){
	GSM_DebugMode = 0;
    ae36:	10 92 f2 09 	sts	0x09F2, r1
	ModbusMode = 1;
    ae3a:	81 e0       	ldi	r24, 0x01	; 1
    ae3c:	80 93 e0 03 	sts	0x03E0, r24
	cli();
    ae40:	f8 94       	cli
	MB_Init();
    ae42:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <MB_Init>
	sei();
    ae46:	78 94       	sei
    ae48:	08 95       	ret

0000ae4a <SendDebug>:
}

//  ISR
void SendDebug(uint8_t Char){
	//---FIFO
	EM_RX_FIFO_Begin++;
    ae4a:	90 91 70 09 	lds	r25, 0x0970
    ae4e:	9f 5f       	subi	r25, 0xFF	; 255
    ae50:	90 93 70 09 	sts	0x0970, r25
	if(EM_RX_FIFO_Begin >= EM_RX_FIFO_SIZE) EM_RX_FIFO_Begin = 0;
    ae54:	90 91 70 09 	lds	r25, 0x0970
    ae58:	9f 3f       	cpi	r25, 0xFF	; 255
    ae5a:	11 f4       	brne	.+4      	; 0xae60 <SendDebug+0x16>
    ae5c:	10 92 70 09 	sts	0x0970, r1
	EM_RX_FIFO[EM_RX_FIFO_Begin] = Char;
    ae60:	e0 91 70 09 	lds	r30, 0x0970
    ae64:	f0 e0       	ldi	r31, 0x00	; 0
    ae66:	e7 50       	subi	r30, 0x07	; 7
    ae68:	fc 4f       	sbci	r31, 0xFC	; 252
    ae6a:	80 83       	st	Z, r24
	if(EM_RX_FIFO_Begin == EM_RX_FIFO_End){
    ae6c:	90 91 70 09 	lds	r25, 0x0970
    ae70:	80 91 38 0d 	lds	r24, 0x0D38
    ae74:	98 13       	cpse	r25, r24
    ae76:	06 c0       	rjmp	.+12     	; 0xae84 <SendDebug+0x3a>
		EM_RX_FIFOOverFlow = 1;
    ae78:	81 e0       	ldi	r24, 0x01	; 1
    ae7a:	80 93 24 0b 	sts	0x0B24, r24
		EM_RX_FIFOMax = EM_RX_FIFO_SIZE;
    ae7e:	8f ef       	ldi	r24, 0xFF	; 255
    ae80:	80 93 6e 0a 	sts	0x0A6E, r24
    ae84:	08 95       	ret

0000ae86 <GSM_RX>:

}
// ~~~~~~~~~
void
GSM_RX(void)
{
    ae86:	cf 93       	push	r28
	char Char = UDR_GSM;
    ae88:	cc b1       	in	r28, 0x0c	; 12

	//---FIFO
	GSM_RX_FIFO_Begin++;
    ae8a:	90 91 7b 08 	lds	r25, 0x087B
    ae8e:	9f 5f       	subi	r25, 0xFF	; 255
    ae90:	90 93 7b 08 	sts	0x087B, r25
	if(GSM_RX_FIFO_Begin >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_Begin = 0;
    ae94:	80 91 7b 08 	lds	r24, 0x087B
    ae98:	8a 3f       	cpi	r24, 0xFA	; 250
    ae9a:	10 f0       	brcs	.+4      	; 0xaea0 <GSM_RX+0x1a>
    ae9c:	10 92 7b 08 	sts	0x087B, r1
	GSM_RX_FIFO[GSM_RX_FIFO_Begin] = Char;
    aea0:	e0 91 7b 08 	lds	r30, 0x087B
    aea4:	f0 e0       	ldi	r31, 0x00	; 0
    aea6:	e8 50       	subi	r30, 0x08	; 8
    aea8:	fb 4f       	sbci	r31, 0xFB	; 251
    aeaa:	c0 83       	st	Z, r28
	if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End){
    aeac:	90 91 7b 08 	lds	r25, 0x087B
    aeb0:	80 91 05 06 	lds	r24, 0x0605
    aeb4:	98 13       	cpse	r25, r24
    aeb6:	06 c0       	rjmp	.+12     	; 0xaec4 <GSM_RX+0x3e>
		GSM_RX_FIFOOverFlow = 1;
    aeb8:	81 e0       	ldi	r24, 0x01	; 1
    aeba:	80 93 6d 0a 	sts	0x0A6D, r24
		GSM_RX_FIFOMax = GSM_RX_FIFO_SIZE;
    aebe:	8a ef       	ldi	r24, 0xFA	; 250
    aec0:	80 93 0d 0b 	sts	0x0B0D, r24
	}

	//---In Transparent Mode
	if(Transparent){
    aec4:	80 91 76 0a 	lds	r24, 0x0A76
    aec8:	88 23       	and	r24, r24
    aeca:	e1 f0       	breq	.+56     	; 0xaf04 <GSM_RX+0x7e>
		// enable DRE interrupt for UDR1
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    aecc:	88 eb       	ldi	r24, 0xB8	; 184
    aece:	80 93 9a 00 	sts	0x009A, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    aed2:	90 91 9b 00 	lds	r25, 0x009B
    aed6:	90 64       	ori	r25, 0x40	; 64
    aed8:	90 93 9b 00 	sts	0x009B, r25

		if(GSM_RX_FIFO_Begin == GSM_RX_FIFO_End_Transp){
    aedc:	90 91 7b 08 	lds	r25, 0x087B
    aee0:	80 91 f8 0a 	lds	r24, 0x0AF8
    aee4:	98 13       	cpse	r25, r24
    aee6:	06 c0       	rjmp	.+12     	; 0xaef4 <GSM_RX+0x6e>
			GSM_RX_FIFOOverFlow_Transp = 1;
    aee8:	81 e0       	ldi	r24, 0x01	; 1
    aeea:	80 93 4a 0e 	sts	0x0E4A, r24
			GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE;
    aeee:	8a ef       	ldi	r24, 0xFA	; 250
    aef0:	80 93 7f 09 	sts	0x097F, r24
		}
		StartTimer16(TCP_CONNECT_check_timer, Connection_check_period );
    aef4:	60 91 0b 01 	lds	r22, 0x010B
    aef8:	70 91 0c 01 	lds	r23, 0x010C
    aefc:	80 91 40 0d 	lds	r24, 0x0D40
    af00:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
	}

	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(Char);
	#endif
	if(GSM_DebugMode){
    af04:	80 91 f2 09 	lds	r24, 0x09F2
    af08:	88 23       	and	r24, r24
    af0a:	31 f0       	breq	.+12     	; 0xaf18 <GSM_RX+0x92>
		SendDebug(Char);
    af0c:	8c 2f       	mov	r24, r28
    af0e:	0e 94 25 57 	call	0xae4a	; 0xae4a <SendDebug>
	}
}
inline void SetDebug_DRE_ISR(void){
	// enable DRE interrupt
	UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (1<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);		
    af12:	88 e2       	ldi	r24, 0x28	; 40
    af14:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
	}

}
    af18:	cf 91       	pop	r28
    af1a:	08 95       	ret

0000af1c <__vector_18>:
}
ISR(USART0_TX_vect){
	GSM_TX();
	GSM_LED = 1;
}
ISR(USART0_RX_vect){
    af1c:	1f 92       	push	r1
    af1e:	0f 92       	push	r0
    af20:	0f b6       	in	r0, 0x3f	; 63
    af22:	0f 92       	push	r0
    af24:	11 24       	eor	r1, r1
    af26:	0b b6       	in	r0, 0x3b	; 59
    af28:	0f 92       	push	r0
    af2a:	2f 93       	push	r18
    af2c:	3f 93       	push	r19
    af2e:	4f 93       	push	r20
    af30:	5f 93       	push	r21
    af32:	6f 93       	push	r22
    af34:	7f 93       	push	r23
    af36:	8f 93       	push	r24
    af38:	9f 93       	push	r25
    af3a:	af 93       	push	r26
    af3c:	bf 93       	push	r27
    af3e:	ef 93       	push	r30
    af40:	ff 93       	push	r31
	GSM_RX();
    af42:	0e 94 43 57 	call	0xae86	; 0xae86 <GSM_RX>
	GSM_LED = 1;
    af46:	81 e0       	ldi	r24, 0x01	; 1
    af48:	80 93 0a 06 	sts	0x060A, r24
}
    af4c:	ff 91       	pop	r31
    af4e:	ef 91       	pop	r30
    af50:	bf 91       	pop	r27
    af52:	af 91       	pop	r26
    af54:	9f 91       	pop	r25
    af56:	8f 91       	pop	r24
    af58:	7f 91       	pop	r23
    af5a:	6f 91       	pop	r22
    af5c:	5f 91       	pop	r21
    af5e:	4f 91       	pop	r20
    af60:	3f 91       	pop	r19
    af62:	2f 91       	pop	r18
    af64:	0f 90       	pop	r0
    af66:	0b be       	out	0x3b, r0	; 59
    af68:	0f 90       	pop	r0
    af6a:	0f be       	out	0x3f, r0	; 63
    af6c:	0f 90       	pop	r0
    af6e:	1f 90       	pop	r1
    af70:	18 95       	reti

0000af72 <GSM_SendFirstChar>:
	else return 0;
}
// ~~~~~~~~~
void GSM_SendFirstChar(void){

	UDR_GSM = GSM_TxStr[0];
    af72:	80 91 39 0c 	lds	r24, 0x0C39
    af76:	8c b9       	out	0x0c, r24	; 12
	#ifdef GSM_DEBUG
		GPRS_TerminalProcess(GSM_TxStr[0]);
	#endif
	if(GSM_DebugMode){
    af78:	80 91 f2 09 	lds	r24, 0x09F2
    af7c:	88 23       	and	r24, r24
    af7e:	49 f0       	breq	.+18     	; 0xaf92 <GSM_SendFirstChar+0x20>
		SendDebug(GSM_TxStr[0]);
    af80:	80 91 39 0c 	lds	r24, 0x0C39
    af84:	0e 94 25 57 	call	0xae4a	; 0xae4a <SendDebug>
		cli();
    af88:	f8 94       	cli
    af8a:	88 e2       	ldi	r24, 0x28	; 40
    af8c:	80 93 9a 00 	sts	0x009A, r24
		SetDebug_DRE_ISR();
		sei();
    af90:	78 94       	sei
	}

	GSM_TxCharN = 1;
    af92:	81 e0       	ldi	r24, 0x01	; 1
    af94:	80 93 46 0d 	sts	0x0D46, r24
	cli();
    af98:	f8 94       	cli
	GSM_Flag &=~(1<<flg_TxCStr);	
    af9a:	80 91 08 01 	lds	r24, 0x0108
    af9e:	8e 7f       	andi	r24, 0xFE	; 254
    afa0:	80 93 08 01 	sts	0x0108, r24
	sei();
    afa4:	78 94       	sei
	cli();
    afa6:	f8 94       	cli
	#if defined (__AVR_ATxmega128A1__)
		USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_DREINTLVL_HI_gc;
	#else
		UCSR_GSM_B =  (1<<RXCIE_GSM) | (0<<TXCIE_GSM) | (1<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    afa8:	88 eb       	ldi	r24, 0xB8	; 184
    afaa:	8a b9       	out	0x0a, r24	; 10
	#endif
	
	sei();	
    afac:	78 94       	sei
    afae:	08 95       	ret

0000afb0 <GSM_SendCR>:
}
// ~~~~~~~~~
//   + CR
void GSM_SendCR(prog_char *Str_P){
    afb0:	cf 93       	push	r28
    afb2:	df 93       	push	r29
    afb4:	ec 01       	movw	r28, r24


__attribute__((__always_inline__)) static inline size_t strlen_P(const char * s);
static inline size_t strlen_P(const char *s) {
  return __builtin_constant_p(__builtin_strlen(s))
     ? __builtin_strlen(s) : __strlen_P(s);
    afb6:	0e 94 8c 6c 	call	0xd918	; 0xd918 <__strlen_P>
	GSMTxSz = strlen_P(Str_P);
    afba:	80 93 57 09 	sts	0x0957, r24
	sprintf_P(GSM_TxStr, Str_P);
    afbe:	df 93       	push	r29
    afc0:	cf 93       	push	r28
    afc2:	89 e3       	ldi	r24, 0x39	; 57
    afc4:	9c e0       	ldi	r25, 0x0C	; 12
    afc6:	9f 93       	push	r25
    afc8:	8f 93       	push	r24
    afca:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
	sprintf(GSM_TxStr + GSMTxSz, "\r");
    afce:	80 91 57 09 	lds	r24, 0x0957
    afd2:	90 e0       	ldi	r25, 0x00	; 0
    afd4:	69 ec       	ldi	r22, 0xC9	; 201
    afd6:	71 e0       	ldi	r23, 0x01	; 1
    afd8:	87 5c       	subi	r24, 0xC7	; 199
    afda:	93 4f       	sbci	r25, 0xF3	; 243
    afdc:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
	GSMTxSz++;
    afe0:	80 91 57 09 	lds	r24, 0x0957
    afe4:	8f 5f       	subi	r24, 0xFF	; 255
    afe6:	80 93 57 09 	sts	0x0957, r24
	GSM_SendFirstChar();
    afea:	0f 90       	pop	r0
    afec:	0f 90       	pop	r0
    afee:	0f 90       	pop	r0
    aff0:	0f 90       	pop	r0
}
    aff2:	df 91       	pop	r29
    aff4:	cf 91       	pop	r28
void GSM_SendCR(prog_char *Str_P){
	GSMTxSz = strlen_P(Str_P);
	sprintf_P(GSM_TxStr, Str_P);
	sprintf(GSM_TxStr + GSMTxSz, "\r");
	GSMTxSz++;
	GSM_SendFirstChar();
    aff6:	0c 94 b9 57 	jmp	0xaf72	; 0xaf72 <GSM_SendFirstChar>

0000affa <GSM_Execute_Command>:
	GSMTxSz = Size;
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
	GSM_SendFirstChar();
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
    affa:	cf 93       	push	r28
    affc:	df 93       	push	r29
    affe:	00 d0       	rcall	.+0      	; 0xb000 <GSM_Execute_Command+0x6>
    b000:	cd b7       	in	r28, 0x3d	; 61
    b002:	de b7       	in	r29, 0x3e	; 62
	if(GSM_Flag & (1<<flg_TxCStr)){
    b004:	20 91 08 01 	lds	r18, 0x0108
    b008:	20 ff       	sbrs	r18, 0
    b00a:	0e c0       	rjmp	.+28     	; 0xb028 <GSM_Execute_Command+0x2e>
		GSM_SendCR(Str_P);
    b00c:	69 83       	std	Y+1, r22	; 0x01
    b00e:	7a 83       	std	Y+2, r23	; 0x02
    b010:	0e 94 d8 57 	call	0xafb0	; 0xafb0 <GSM_SendCR>
		StartTimer16(TD_GSM, Timeout);
    b014:	69 81       	ldd	r22, Y+1	; 0x01
    b016:	7a 81       	ldd	r23, Y+2	; 0x02
    b018:	80 91 5a 02 	lds	r24, 0x025A
	}
}
    b01c:	0f 90       	pop	r0
    b01e:	0f 90       	pop	r0
    b020:	df 91       	pop	r29
    b022:	cf 91       	pop	r28
}
// ~~~~~~~~~
void GSM_Execute_Command(prog_char *Str_P, uint16_t Timeout){
	if(GSM_Flag & (1<<flg_TxCStr)){
		GSM_SendCR(Str_P);
		StartTimer16(TD_GSM, Timeout);
    b024:	0c 94 d4 2a 	jmp	0x55a8	; 0x55a8 <StartTimer16>
	}
}
    b028:	0f 90       	pop	r0
    b02a:	0f 90       	pop	r0
    b02c:	df 91       	pop	r29
    b02e:	cf 91       	pop	r28
    b030:	08 95       	ret

0000b032 <GSM_AddHeaderSendData>:
	GSM_SendFirstChar();
}
// ~~~~~~~~~
//   + CntrZ
void GSM_AddHeaderSendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b032:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b036:	40 91 57 09 	lds	r20, 0x0957
    b03a:	50 e0       	ldi	r21, 0x00	; 0
    b03c:	bc 01       	movw	r22, r24
    b03e:	89 e3       	ldi	r24, 0x39	; 57
    b040:	9c e0       	ldi	r25, 0x0C	; 12
    b042:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
	GSM_SendFirstChar();
    b046:	0c 94 b9 57 	jmp	0xaf72	; 0xaf72 <GSM_SendFirstChar>

0000b04a <GSM_SendData>:
}
// ~~~~~~~~~
void GSM_SendData(uint8_t *Data_Out, uint8_t Size){
	GSMTxSz = Size;
    b04a:	60 93 57 09 	sts	0x0957, r22
	memcpy(GSM_TxStr, Data_Out, GSMTxSz);
    b04e:	40 91 57 09 	lds	r20, 0x0957
    b052:	50 e0       	ldi	r21, 0x00	; 0
    b054:	bc 01       	movw	r22, r24
    b056:	89 e3       	ldi	r24, 0x39	; 57
    b058:	9c e0       	ldi	r25, 0x0C	; 12
    b05a:	0e 94 bd 6c 	call	0xd97a	; 0xd97a <memcpy>
	GSM_SendFirstChar();
    b05e:	0c 94 b9 57 	jmp	0xaf72	; 0xaf72 <GSM_SendFirstChar>

0000b062 <GSM_Cycle>:
	}//switch
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
void
GSM_Cycle(void)
{
    b062:	2f 92       	push	r2
    b064:	3f 92       	push	r3
    b066:	4f 92       	push	r4
    b068:	5f 92       	push	r5
    b06a:	6f 92       	push	r6
    b06c:	7f 92       	push	r7
    b06e:	8f 92       	push	r8
    b070:	9f 92       	push	r9
    b072:	af 92       	push	r10
    b074:	bf 92       	push	r11
    b076:	cf 92       	push	r12
    b078:	df 92       	push	r13
    b07a:	ef 92       	push	r14
    b07c:	ff 92       	push	r15
    b07e:	0f 93       	push	r16
    b080:	1f 93       	push	r17
    b082:	cf 93       	push	r28
    b084:	df 93       	push	r29
    b086:	cd b7       	in	r28, 0x3d	; 61
    b088:	de b7       	in	r29, 0x3e	; 62
    b08a:	2e 97       	sbiw	r28, 0x0e	; 14
    b08c:	0f b6       	in	r0, 0x3f	; 63
    b08e:	f8 94       	cli
    b090:	de bf       	out	0x3e, r29	; 62
    b092:	0f be       	out	0x3f, r0	; 63
    b094:	cd bf       	out	0x3d, r28	; 61
	switch(GSM_Control){
    b096:	80 91 7d 09 	lds	r24, 0x097D
    b09a:	88 23       	and	r24, r24
    b09c:	31 f0       	breq	.+12     	; 0xb0aa <GSM_Cycle+0x48>
    b09e:	82 30       	cpi	r24, 0x02	; 2
    b0a0:	11 f4       	brne	.+4      	; 0xb0a6 <GSM_Cycle+0x44>
    b0a2:	0c 94 75 64 	jmp	0xc8ea	; 0xc8ea <GSM_Cycle+0x1888>
    b0a6:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
	IntOn();*/
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Auto(){

	switch(GSM_State){
    b0aa:	80 91 27 06 	lds	r24, 0x0627
    b0ae:	90 e0       	ldi	r25, 0x00	; 0
    b0b0:	8b 36       	cpi	r24, 0x6B	; 107
    b0b2:	91 05       	cpc	r25, r1
    b0b4:	10 f0       	brcs	.+4      	; 0xb0ba <GSM_Cycle+0x58>
    b0b6:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b0ba:	fc 01       	movw	r30, r24
    b0bc:	e0 53       	subi	r30, 0x30	; 48
    b0be:	ff 4f       	sbci	r31, 0xFF	; 255
    b0c0:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>

		case GSM_PowerOn:
		    Transparent_Application_state = INIT;
    b0c4:	10 92 52 09 	sts	0x0952, r1
			StartTimer16(TD_GSM,2000*GSM_DEBUG_DELAY);
    b0c8:	60 ed       	ldi	r22, 0xD0	; 208
    b0ca:	77 e0       	ldi	r23, 0x07	; 7
    b0cc:	80 91 5a 02 	lds	r24, 0x025A
    b0d0:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			StartTimer32(TD_GSM_Reset, 24UL*60UL*6000);	//    24 
    b0d4:	40 e0       	ldi	r20, 0x00	; 0
    b0d6:	56 ed       	ldi	r21, 0xD6	; 214
    b0d8:	63 e8       	ldi	r22, 0x83	; 131
    b0da:	70 e0       	ldi	r23, 0x00	; 0
    b0dc:	80 91 57 02 	lds	r24, 0x0257
    b0e0:	0e 94 15 2c 	call	0x582a	; 0x582a <StartTimer32>
			GSM_PWRCNTRL_ON();
    b0e4:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GSM_PWRCNTRL_ON>
			InitFIFO();
    b0e8:	0e 94 07 3a 	call	0x740e	; 0x740e <InitFIFO>
			GSM_Modem = NOT_RECOGNIZED;
    b0ec:	10 92 71 08 	sts	0x0871, r1
			GSM_State = GSM_WAIT_RDY;
    b0f0:	81 e0       	ldi	r24, 0x01	; 1
    b0f2:	80 93 27 06 	sts	0x0627, r24
    b0f6:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_WAIT_RDY:
			if(GSM_Wait_Response_P(URC_RDY, GSM_ReStart1)) GSM_State++;
    b0fa:	6a e5       	ldi	r22, 0x5A	; 90
    b0fc:	8a e7       	ldi	r24, 0x7A	; 122
    b0fe:	9f e4       	ldi	r25, 0x4F	; 79
    b100:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b104:	88 23       	and	r24, r24
    b106:	11 f4       	brne	.+4      	; 0xb10c <GSM_Cycle+0xaa>
    b108:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b10c:	80 91 27 06 	lds	r24, 0x0627
    b110:	8f 5f       	subi	r24, 0xFF	; 255
    b112:	80 93 27 06 	sts	0x0627, r24
    b116:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_CGMM:
			GSM_Execute_Command(AT_CGMM,5000*GSM_DEBUG_DELAY); GSM_State++;
    b11a:	68 e8       	ldi	r22, 0x88	; 136
    b11c:	73 e1       	ldi	r23, 0x13	; 19
    b11e:	83 e8       	ldi	r24, 0x83	; 131
    b120:	9e e4       	ldi	r25, 0x4E	; 78
    b122:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b126:	80 91 27 06 	lds	r24, 0x0627
    b12a:	8f 5f       	subi	r24, 0xFF	; 255
    b12c:	80 93 27 06 	sts	0x0627, r24
    b130:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CGMM_READ:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b134:	80 91 5a 02 	lds	r24, 0x025A
    b138:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    b13c:	88 23       	and	r24, r24
    b13e:	19 f0       	breq	.+6      	; 0xb146 <GSM_Cycle+0xe4>
    b140:	8a e5       	ldi	r24, 0x5A	; 90
    b142:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b146:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    b14a:	88 23       	and	r24, r24
    b14c:	e9 f0       	breq	.+58     	; 0xb188 <GSM_Cycle+0x126>
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM900R)) GSM_Modem = SIMCOM_SIM900R;
    b14e:	6c e8       	ldi	r22, 0x8C	; 140
    b150:	7f e4       	ldi	r23, 0x4F	; 79
    b152:	89 e8       	ldi	r24, 0x89	; 137
    b154:	99 e0       	ldi	r25, 0x09	; 9
    b156:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    b15a:	89 2b       	or	r24, r25
    b15c:	19 f4       	brne	.+6      	; 0xb164 <GSM_Cycle+0x102>
    b15e:	81 e0       	ldi	r24, 0x01	; 1
    b160:	80 93 71 08 	sts	0x0871, r24
				if(!strcmp_P(GSM_RxStr, GSM_SIMCOM_SIM800)) GSM_Modem = SIMCOM_SIM800;
    b164:	6e e7       	ldi	r22, 0x7E	; 126
    b166:	7f e4       	ldi	r23, 0x4F	; 79
    b168:	89 e8       	ldi	r24, 0x89	; 137
    b16a:	99 e0       	ldi	r25, 0x09	; 9
    b16c:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    b170:	89 2b       	or	r24, r25
    b172:	19 f4       	brne	.+6      	; 0xb17a <GSM_Cycle+0x118>
    b174:	82 e0       	ldi	r24, 0x02	; 2
    b176:	80 93 71 08 	sts	0x0871, r24
				//Add here new model GSM-modem
				if(GSM_Modem != NOT_RECOGNIZED) GSM_State = GSM_WAIT_CALL_READY;
    b17a:	80 91 71 08 	lds	r24, 0x0871
    b17e:	88 23       	and	r24, r24
    b180:	19 f0       	breq	.+6      	; 0xb188 <GSM_Cycle+0x126>
    b182:	86 e0       	ldi	r24, 0x06	; 6
    b184:	80 93 27 06 	sts	0x0627, r24
		case GSM_WAIT_CPIN_READY:
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		case GSM_WAIT_CALL_READY:
			if(GSM_Wait_Response_P(URC_CALL_READY, GSM_ReStart1)){
    b188:	6a e5       	ldi	r22, 0x5A	; 90
    b18a:	8f e6       	ldi	r24, 0x6F	; 111
    b18c:	9f e4       	ldi	r25, 0x4F	; 79
    b18e:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b192:	88 23       	and	r24, r24
    b194:	11 f4       	brne	.+4      	; 0xb19a <GSM_Cycle+0x138>
    b196:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				if(GSM_Modem == SIMCOM_SIM800) GSM_State = GSM_WAIT_SMS_READY;
    b19a:	80 91 71 08 	lds	r24, 0x0871
    b19e:	82 30       	cpi	r24, 0x02	; 2
    b1a0:	29 f4       	brne	.+10     	; 0xb1ac <GSM_Cycle+0x14a>
    b1a2:	87 e0       	ldi	r24, 0x07	; 7
    b1a4:	80 93 27 06 	sts	0x0627, r24
    b1a8:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				else GSM_State = GSM_SEND_E0;
    b1ac:	88 e0       	ldi	r24, 0x08	; 8
    b1ae:	80 93 27 06 	sts	0x0627, r24
    b1b2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_WAIT_SMS_READY:
			if(GSM_Wait_Response_P(URC_SMS_READY, GSM_ReStart1))GSM_State++;
    b1b6:	6a e5       	ldi	r22, 0x5A	; 90
    b1b8:	85 e6       	ldi	r24, 0x65	; 101
    b1ba:	9f e4       	ldi	r25, 0x4F	; 79
    b1bc:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b1c0:	88 23       	and	r24, r24
    b1c2:	11 f4       	brne	.+4      	; 0xb1c8 <GSM_Cycle+0x166>
    b1c4:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b1c8:	80 91 27 06 	lds	r24, 0x0627
    b1cc:	8f 5f       	subi	r24, 0xFF	; 255
    b1ce:	80 93 27 06 	sts	0x0627, r24
    b1d2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			if(GSM_Wait_Response_P(URC_CPIN_READY, GSM_ReStart1)) GSM_State++;
			break;*/

		//------------------------
		case GSM_SEND_E0:
			GSM_Execute_Command(AT_E0,100*GSM_DEBUG_DELAY); GSM_State++;
    b1d6:	64 e6       	ldi	r22, 0x64	; 100
    b1d8:	70 e0       	ldi	r23, 0x00	; 0
    b1da:	8b e8       	ldi	r24, 0x8B	; 139
    b1dc:	9e e4       	ldi	r25, 0x4E	; 78
    b1de:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b1e2:	80 91 27 06 	lds	r24, 0x0627
    b1e6:	8f 5f       	subi	r24, 0xFF	; 255
    b1e8:	80 93 27 06 	sts	0x0627, r24
    b1ec:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_E0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b1f0:	6a e5       	ldi	r22, 0x5A	; 90
    b1f2:	82 e2       	ldi	r24, 0x22	; 34
    b1f4:	9f e4       	ldi	r25, 0x4F	; 79
    b1f6:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b1fa:	88 23       	and	r24, r24
    b1fc:	11 f4       	brne	.+4      	; 0xb202 <GSM_Cycle+0x1a0>
    b1fe:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b202:	80 91 27 06 	lds	r24, 0x0627
    b206:	8f 5f       	subi	r24, 0xFF	; 255
    b208:	80 93 27 06 	sts	0x0627, r24
    b20c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_CLIP:
			GSM_Execute_Command(AT_CLIP,100*GSM_DEBUG_DELAY); GSM_State++;
    b210:	64 e6       	ldi	r22, 0x64	; 100
    b212:	70 e0       	ldi	r23, 0x00	; 0
    b214:	89 e7       	ldi	r24, 0x79	; 121
    b216:	9e e4       	ldi	r25, 0x4E	; 78
    b218:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b21c:	80 91 27 06 	lds	r24, 0x0627
    b220:	8f 5f       	subi	r24, 0xFF	; 255
    b222:	80 93 27 06 	sts	0x0627, r24
    b226:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CLIP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b22a:	6a e5       	ldi	r22, 0x5A	; 90
    b22c:	82 e2       	ldi	r24, 0x22	; 34
    b22e:	9f e4       	ldi	r25, 0x4F	; 79
    b230:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b234:	88 23       	and	r24, r24
    b236:	11 f4       	brne	.+4      	; 0xb23c <GSM_Cycle+0x1da>
    b238:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b23c:	80 91 27 06 	lds	r24, 0x0627
    b240:	8f 5f       	subi	r24, 0xFF	; 255
    b242:	80 93 27 06 	sts	0x0627, r24
    b246:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_CCID:
			GSM_RxStr[19] = 0;
    b24a:	10 92 9c 09 	sts	0x099C, r1
			GSM_Execute_Command(AT_CCID,300*GSM_DEBUG_DELAY); GSM_State++;
    b24e:	6c e2       	ldi	r22, 0x2C	; 44
    b250:	71 e0       	ldi	r23, 0x01	; 1
    b252:	81 e7       	ldi	r24, 0x71	; 113
    b254:	9e e4       	ldi	r25, 0x4E	; 78
    b256:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b25a:	80 91 27 06 	lds	r24, 0x0627
    b25e:	8f 5f       	subi	r24, 0xFF	; 255
    b260:	80 93 27 06 	sts	0x0627, r24
    b264:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CCID_READ:
			//8938001300106446004F
			if(GetStringFromFIFO() && ((GSM_RxStr[19] == 'F')||(GSM_RxStr[19] == 'f')) ){
    b268:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    b26c:	88 23       	and	r24, r24
    b26e:	11 f4       	brne	.+4      	; 0xb274 <GSM_Cycle+0x212>
    b270:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b274:	80 91 9c 09 	lds	r24, 0x099C
    b278:	8f 7d       	andi	r24, 0xDF	; 223
    b27a:	86 34       	cpi	r24, 0x46	; 70
    b27c:	11 f0       	breq	.+4      	; 0xb282 <GSM_Cycle+0x220>
    b27e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>



				GSM_RxStr[18] = ' ';
    b282:	10 e2       	ldi	r17, 0x20	; 32
    b284:	10 93 9b 09 	sts	0x099B, r17
				sscanf_P(GSM_RxStr+9,PSTR("%lud"), (long unsigned int*)&ICCID2);
    b288:	82 e1       	ldi	r24, 0x12	; 18
    b28a:	96 e0       	ldi	r25, 0x06	; 6
    b28c:	9f 93       	push	r25
    b28e:	8f 93       	push	r24
    b290:	81 e8       	ldi	r24, 0x81	; 129
    b292:	93 e0       	ldi	r25, 0x03	; 3
    b294:	9f 93       	push	r25
    b296:	8f 93       	push	r24
    b298:	82 e9       	ldi	r24, 0x92	; 146
    b29a:	99 e0       	ldi	r25, 0x09	; 9
    b29c:	9f 93       	push	r25
    b29e:	8f 93       	push	r24
    b2a0:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				GSM_RxStr[9] = ' ';
    b2a4:	10 93 92 09 	sts	0x0992, r17
				sscanf_P(GSM_RxStr+5,PSTR("%u"), (unsigned int*)&ICCID1);
    b2a8:	87 e2       	ldi	r24, 0x27	; 39
    b2aa:	9b e0       	ldi	r25, 0x0B	; 11
    b2ac:	9f 93       	push	r25
    b2ae:	8f 93       	push	r24
    b2b0:	8e e7       	ldi	r24, 0x7E	; 126
    b2b2:	93 e0       	ldi	r25, 0x03	; 3
    b2b4:	9f 93       	push	r25
    b2b6:	8f 93       	push	r24
    b2b8:	8e e8       	ldi	r24, 0x8E	; 142
    b2ba:	99 e0       	ldi	r25, 0x09	; 9
    b2bc:	9f 93       	push	r25
    b2be:	8f 93       	push	r24
    b2c0:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				if((ICCID1 == 0) || (ICCID2==0)) GSM_State = GSM_ReStart1;
    b2c4:	40 91 27 0b 	lds	r20, 0x0B27
    b2c8:	50 91 28 0b 	lds	r21, 0x0B28
    b2cc:	0f b6       	in	r0, 0x3f	; 63
    b2ce:	f8 94       	cli
    b2d0:	de bf       	out	0x3e, r29	; 62
    b2d2:	0f be       	out	0x3f, r0	; 63
    b2d4:	cd bf       	out	0x3d, r28	; 61
    b2d6:	41 15       	cp	r20, r1
    b2d8:	51 05       	cpc	r21, r1
    b2da:	69 f0       	breq	.+26     	; 0xb2f6 <GSM_Cycle+0x294>
    b2dc:	40 90 12 06 	lds	r4, 0x0612
    b2e0:	50 90 13 06 	lds	r5, 0x0613
    b2e4:	60 90 14 06 	lds	r6, 0x0614
    b2e8:	70 90 15 06 	lds	r7, 0x0615
    b2ec:	41 14       	cp	r4, r1
    b2ee:	51 04       	cpc	r5, r1
    b2f0:	61 04       	cpc	r6, r1
    b2f2:	71 04       	cpc	r7, r1
    b2f4:	29 f4       	brne	.+10     	; 0xb300 <GSM_Cycle+0x29e>
    b2f6:	8a e5       	ldi	r24, 0x5A	; 90
    b2f8:	80 93 27 06 	sts	0x0627, r24
    b2fc:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				else{
					ICCID = (uint64_t)ICCID1 * 1000000000UL + (uint64_t)ICCID2;
    b300:	a1 2c       	mov	r10, r1
    b302:	6a ec       	ldi	r22, 0xCA	; 202
    b304:	b6 2e       	mov	r11, r22
    b306:	7a e9       	ldi	r23, 0x9A	; 154
    b308:	c7 2e       	mov	r12, r23
    b30a:	eb e3       	ldi	r30, 0x3B	; 59
    b30c:	de 2e       	mov	r13, r30
    b30e:	e1 2c       	mov	r14, r1
    b310:	f1 2c       	mov	r15, r1
    b312:	00 e0       	ldi	r16, 0x00	; 0
    b314:	10 e0       	ldi	r17, 0x00	; 0
    b316:	9a 01       	movw	r18, r20
    b318:	40 e0       	ldi	r20, 0x00	; 0
    b31a:	50 e0       	ldi	r21, 0x00	; 0
    b31c:	60 e0       	ldi	r22, 0x00	; 0
    b31e:	70 e0       	ldi	r23, 0x00	; 0
    b320:	80 e0       	ldi	r24, 0x00	; 0
    b322:	90 e0       	ldi	r25, 0x00	; 0
    b324:	0e 94 c8 75 	call	0xeb90	; 0xeb90 <__muldi3>
    b328:	12 01       	movw	r2, r4
    b32a:	23 01       	movw	r4, r6
    b32c:	51 01       	movw	r10, r2
    b32e:	62 01       	movw	r12, r4
    b330:	0e 94 21 76 	call	0xec42	; 0xec42 <__adddi3>
    b334:	20 93 73 09 	sts	0x0973, r18
    b338:	30 93 74 09 	sts	0x0974, r19
    b33c:	40 93 75 09 	sts	0x0975, r20
    b340:	50 93 76 09 	sts	0x0976, r21
    b344:	60 93 77 09 	sts	0x0977, r22
    b348:	70 93 78 09 	sts	0x0978, r23
    b34c:	80 93 79 09 	sts	0x0979, r24
    b350:	90 93 7a 09 	sts	0x097A, r25
					GSM_State++;
    b354:	80 91 27 06 	lds	r24, 0x0627
    b358:	8f 5f       	subi	r24, 0xFF	; 255
    b35a:	80 93 27 06 	sts	0x0627, r24
    b35e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				}
			}
			break;
		case GSM_WAIT_CCID_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b362:	6a e5       	ldi	r22, 0x5A	; 90
    b364:	82 e2       	ldi	r24, 0x22	; 34
    b366:	9f e4       	ldi	r25, 0x4F	; 79
    b368:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b36c:	88 23       	and	r24, r24
    b36e:	11 f4       	brne	.+4      	; 0xb374 <GSM_Cycle+0x312>
    b370:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b374:	80 91 27 06 	lds	r24, 0x0627
    b378:	8f 5f       	subi	r24, 0xFF	; 255
    b37a:	80 93 27 06 	sts	0x0627, r24
    b37e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_IFC_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
			break;*/
		case GSM_SEND_CMGF:
			GSM_Execute_Command(AT_CMGF,100*GSM_DEBUG_DELAY); GSM_State++;
    b382:	64 e6       	ldi	r22, 0x64	; 100
    b384:	70 e0       	ldi	r23, 0x00	; 0
    b386:	87 e6       	ldi	r24, 0x67	; 103
    b388:	9e e4       	ldi	r25, 0x4E	; 78
    b38a:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b38e:	80 91 27 06 	lds	r24, 0x0627
    b392:	8f 5f       	subi	r24, 0xFF	; 255
    b394:	80 93 27 06 	sts	0x0627, r24
    b398:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CMGF_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b39c:	6a e5       	ldi	r22, 0x5A	; 90
    b39e:	82 e2       	ldi	r24, 0x22	; 34
    b3a0:	9f e4       	ldi	r25, 0x4F	; 79
    b3a2:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b3a6:	88 23       	and	r24, r24
    b3a8:	11 f4       	brne	.+4      	; 0xb3ae <GSM_Cycle+0x34c>
    b3aa:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b3ae:	80 91 27 06 	lds	r24, 0x0627
    b3b2:	8f 5f       	subi	r24, 0xFF	; 255
    b3b4:	80 93 27 06 	sts	0x0627, r24
    b3b8:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_CSMP:
			GSM_Execute_Command(AT_CSMP, 100*GSM_DEBUG_DELAY); GSM_State++;
    b3bc:	64 e6       	ldi	r22, 0x64	; 100
    b3be:	70 e0       	ldi	r23, 0x00	; 0
    b3c0:	84 e5       	ldi	r24, 0x54	; 84
    b3c2:	9e e4       	ldi	r25, 0x4E	; 78
    b3c4:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b3c8:	80 91 27 06 	lds	r24, 0x0627
    b3cc:	8f 5f       	subi	r24, 0xFF	; 255
    b3ce:	80 93 27 06 	sts	0x0627, r24
    b3d2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CSMP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b3d6:	6a e5       	ldi	r22, 0x5A	; 90
    b3d8:	82 e2       	ldi	r24, 0x22	; 34
    b3da:	9f e4       	ldi	r25, 0x4F	; 79
    b3dc:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b3e0:	88 23       	and	r24, r24
    b3e2:	11 f4       	brne	.+4      	; 0xb3e8 <GSM_Cycle+0x386>
    b3e4:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b3e8:	80 91 27 06 	lds	r24, 0x0627
    b3ec:	8f 5f       	subi	r24, 0xFF	; 255
    b3ee:	80 93 27 06 	sts	0x0627, r24
    b3f2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		//------------------------
		case GSM_SEND_CIPMUX:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMUX_1, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMUX_0, 100*GSM_DEBUG_DELAY);
    b3f6:	64 e6       	ldi	r22, 0x64	; 100
    b3f8:	70 e0       	ldi	r23, 0x00	; 0
    b3fa:	80 e3       	ldi	r24, 0x30	; 48
    b3fc:	9e e4       	ldi	r25, 0x4E	; 78
    b3fe:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
			GSM_State++; 
    b402:	80 91 27 06 	lds	r24, 0x0627
    b406:	8f 5f       	subi	r24, 0xFF	; 255
    b408:	80 93 27 06 	sts	0x0627, r24
    b40c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPMUX_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b410:	6a e5       	ldi	r22, 0x5A	; 90
    b412:	82 e2       	ldi	r24, 0x22	; 34
    b414:	9f e4       	ldi	r25, 0x4F	; 79
    b416:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b41a:	88 23       	and	r24, r24
    b41c:	11 f4       	brne	.+4      	; 0xb422 <GSM_Cycle+0x3c0>
    b41e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
					GSM_State = GSM_WAIT_1;
					// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
					StartTimer16(TD_GSM, 1000);
				}
				else GSM_State++;*/
				GSM_State++;
    b422:	80 91 27 06 	lds	r24, 0x0627
    b426:	8f 5f       	subi	r24, 0xFF	; 255
    b428:	80 93 27 06 	sts	0x0627, r24
    b42c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SEND_CIPMODE:
			/*if(GSM_MultiCon) GSM_Execute_Command(AT_CIPMODE_0, 100*GSM_DEBUG_DELAY);
			else GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);*/
			GSM_Execute_Command(AT_CIPMODE_1, 100*GSM_DEBUG_DELAY);
    b430:	64 e6       	ldi	r22, 0x64	; 100
    b432:	70 e0       	ldi	r23, 0x00	; 0
    b434:	8c e3       	ldi	r24, 0x3C	; 60
    b436:	9e e4       	ldi	r25, 0x4E	; 78
    b438:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
			GSM_State++;
    b43c:	80 91 27 06 	lds	r24, 0x0627
    b440:	8f 5f       	subi	r24, 0xFF	; 255
    b442:	80 93 27 06 	sts	0x0627, r24
    b446:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPMODE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    b44a:	6a e5       	ldi	r22, 0x5A	; 90
    b44c:	82 e2       	ldi	r24, 0x22	; 34
    b44e:	9f e4       	ldi	r25, 0x4F	; 79
    b450:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b454:	88 23       	and	r24, r24
    b456:	11 f4       	brne	.+4      	; 0xb45c <GSM_Cycle+0x3fa>
    b458:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				GSM_State++;
    b45c:	80 91 27 06 	lds	r24, 0x0627
    b460:	8f 5f       	subi	r24, 0xFF	; 255
    b462:	80 93 27 06 	sts	0x0627, r24
				// between "Call Ready" and "+CMGS"; 8 sec min needs; for kyivstar vpni only
				StartTimer16(TD_GSM, 1000);
    b466:	68 ee       	ldi	r22, 0xE8	; 232
    b468:	73 e0       	ldi	r23, 0x03	; 3
    b46a:	80 91 5a 02 	lds	r24, 0x025A
    b46e:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    b472:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SEND_CIPTKA:
			GSM_Execute_Command(AT_CIPTKA, 100*GSM_DEBUG_DELAY); GSM_State++;
    b476:	64 e6       	ldi	r22, 0x64	; 100
    b478:	70 e0       	ldi	r23, 0x00	; 0
    b47a:	8c e1       	ldi	r24, 0x1C	; 28
    b47c:	9e e4       	ldi	r25, 0x4E	; 78
    b47e:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b482:	80 91 27 06 	lds	r24, 0x0627
    b486:	8f 5f       	subi	r24, 0xFF	; 255
    b488:	80 93 27 06 	sts	0x0627, r24
    b48c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPTKA_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b490:	6a e5       	ldi	r22, 0x5A	; 90
    b492:	82 e2       	ldi	r24, 0x22	; 34
    b494:	9f e4       	ldi	r25, 0x4F	; 79
    b496:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b49a:	88 23       	and	r24, r24
    b49c:	11 f4       	brne	.+4      	; 0xb4a2 <GSM_Cycle+0x440>
    b49e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b4a2:	80 91 27 06 	lds	r24, 0x0627
    b4a6:	8f 5f       	subi	r24, 0xFF	; 255
    b4a8:	80 93 27 06 	sts	0x0627, r24
    b4ac:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
/*			GetStringFromFIFO();		//     FIFO
			if(Timer16Stopp(TD_GSM)){
				GSM_State++;
				GSM_Temp = 0;
			}*/
			GSM_Temp = 0;
    b4b0:	10 92 e6 03 	sts	0x03E6, r1
			GSM_State++;
    b4b4:	80 91 27 06 	lds	r24, 0x0627
    b4b8:	8f 5f       	subi	r24, 0xFF	; 255
    b4ba:	80 93 27 06 	sts	0x0627, r24
    b4be:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_SEND_CGATT:
			GSM_Execute_Command(AT_CGATT, 500*GSM_DEBUG_DELAY); GSM_Temp++; GSM_State++;
    b4c2:	64 ef       	ldi	r22, 0xF4	; 244
    b4c4:	71 e0       	ldi	r23, 0x01	; 1
    b4c6:	81 e1       	ldi	r24, 0x11	; 17
    b4c8:	9e e4       	ldi	r25, 0x4E	; 78
    b4ca:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b4ce:	80 91 e6 03 	lds	r24, 0x03E6
    b4d2:	8f 5f       	subi	r24, 0xFF	; 255
    b4d4:	80 93 e6 03 	sts	0x03E6, r24
    b4d8:	80 91 27 06 	lds	r24, 0x0627
    b4dc:	8f 5f       	subi	r24, 0xFF	; 255
    b4de:	80 93 27 06 	sts	0x0627, r24
    b4e2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CGATT_OK:
			if(GSM_Temp>20) GSM_State = GSM_ReStart1;
    b4e6:	80 91 e6 03 	lds	r24, 0x03E6
    b4ea:	85 31       	cpi	r24, 0x15	; 21
    b4ec:	18 f0       	brcs	.+6      	; 0xb4f4 <GSM_Cycle+0x492>
    b4ee:	8a e5       	ldi	r24, 0x5A	; 90
    b4f0:	80 93 27 06 	sts	0x0627, r24
			if(GSM_Wait_Response_P(RESP_OK, GSM_SEND_CGATT)) GSM_State++;
    b4f4:	6a e1       	ldi	r22, 0x1A	; 26
    b4f6:	82 e2       	ldi	r24, 0x22	; 34
    b4f8:	9f e4       	ldi	r25, 0x4F	; 79
    b4fa:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b4fe:	88 23       	and	r24, r24
    b500:	11 f4       	brne	.+4      	; 0xb506 <GSM_Cycle+0x4a4>
    b502:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b506:	80 91 27 06 	lds	r24, 0x0627
    b50a:	8f 5f       	subi	r24, 0xFF	; 255
    b50c:	80 93 27 06 	sts	0x0627, r24
    b510:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_SEND_CIPCSGP:
			//GSM_Execute_Command(AT_CIPCSGP, 300*GSM_DEBUG_DELAY); GSM_State++;
			if(GSM_Flag & (1<<flg_TxCStr)){
    b514:	80 91 08 01 	lds	r24, 0x0108
    b518:	80 ff       	sbrs	r24, 0
    b51a:	6d c0       	rjmp	.+218    	; 0xb5f6 <GSM_Cycle+0x594>
				sprintf_P(GSM_TxStr, AT_CIPCSGP);	GSMTxSz = strlen_P(AT_CIPCSGP);
    b51c:	82 e0       	ldi	r24, 0x02	; 2
    b51e:	9e e4       	ldi	r25, 0x4E	; 78
    b520:	9f 93       	push	r25
    b522:	8f 93       	push	r24
    b524:	89 e3       	ldi	r24, 0x39	; 57
    b526:	9c e0       	ldi	r25, 0x0C	; 12
    b528:	9f 93       	push	r25
    b52a:	8f 93       	push	r24
    b52c:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
    b530:	8e e0       	ldi	r24, 0x0E	; 14
    b532:	80 93 57 09 	sts	0x0957, r24
				#if LCDXSz==40
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn);
    b536:	10 91 57 09 	lds	r17, 0x0957
    b53a:	80 91 57 09 	lds	r24, 0x0957
    b53e:	90 e0       	ldi	r25, 0x00	; 0
    b540:	6c e7       	ldi	r22, 0x7C	; 124
    b542:	71 e0       	ldi	r23, 0x01	; 1
    b544:	87 5c       	subi	r24, 0xC7	; 199
    b546:	93 4f       	sbci	r25, 0xF3	; 243
    b548:	0e 94 ca 3a 	call	0x7594	; 0x7594 <strcpy_EE>
    b54c:	81 0f       	add	r24, r17
    b54e:	80 93 57 09 	sts	0x0957, r24
				#else
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn1);
					GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn2);
				#endif
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;				
    b552:	80 91 57 09 	lds	r24, 0x0957
    b556:	90 e0       	ldi	r25, 0x00	; 0
    b558:	63 eb       	ldi	r22, 0xB3	; 179
    b55a:	71 e0       	ldi	r23, 0x01	; 1
    b55c:	87 5c       	subi	r24, 0xC7	; 199
    b55e:	93 4f       	sbci	r25, 0xF3	; 243
    b560:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
    b564:	80 91 57 09 	lds	r24, 0x0957
    b568:	8d 5f       	subi	r24, 0xFD	; 253
    b56a:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_user_name);
    b56e:	10 91 57 09 	lds	r17, 0x0957
    b572:	80 91 57 09 	lds	r24, 0x0957
    b576:	90 e0       	ldi	r25, 0x00	; 0
    b578:	68 e6       	ldi	r22, 0x68	; 104
    b57a:	71 e0       	ldi	r23, 0x01	; 1
    b57c:	87 5c       	subi	r24, 0xC7	; 199
    b57e:	93 4f       	sbci	r25, 0xF3	; 243
    b580:	0e 94 ca 3a 	call	0x7594	; 0x7594 <strcpy_EE>
    b584:	81 0f       	add	r24, r17
    b586:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\",\"");	GSMTxSz = GSMTxSz+3;
    b58a:	80 91 57 09 	lds	r24, 0x0957
    b58e:	90 e0       	ldi	r25, 0x00	; 0
    b590:	63 eb       	ldi	r22, 0xB3	; 179
    b592:	71 e0       	ldi	r23, 0x01	; 1
    b594:	87 5c       	subi	r24, 0xC7	; 199
    b596:	93 4f       	sbci	r25, 0xF3	; 243
    b598:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
    b59c:	80 91 57 09 	lds	r24, 0x0957
    b5a0:	8d 5f       	subi	r24, 0xFD	; 253
    b5a2:	80 93 57 09 	sts	0x0957, r24
				GSMTxSz += strcpy_EE(&GSM_TxStr[GSMTxSz],GPRS_apn_psw);
    b5a6:	10 91 57 09 	lds	r17, 0x0957
    b5aa:	80 91 57 09 	lds	r24, 0x0957
    b5ae:	90 e0       	ldi	r25, 0x00	; 0
    b5b0:	64 e5       	ldi	r22, 0x54	; 84
    b5b2:	71 e0       	ldi	r23, 0x01	; 1
    b5b4:	87 5c       	subi	r24, 0xC7	; 199
    b5b6:	93 4f       	sbci	r25, 0xF3	; 243
    b5b8:	0e 94 ca 3a 	call	0x7594	; 0x7594 <strcpy_EE>
    b5bc:	81 0f       	add	r24, r17
    b5be:	80 93 57 09 	sts	0x0957, r24
				sprintf(GSM_TxStr + GSMTxSz, "\"\r");	GSMTxSz = GSMTxSz+2;
    b5c2:	80 91 57 09 	lds	r24, 0x0957
    b5c6:	90 e0       	ldi	r25, 0x00	; 0
    b5c8:	68 ec       	ldi	r22, 0xC8	; 200
    b5ca:	71 e0       	ldi	r23, 0x01	; 1
    b5cc:	87 5c       	subi	r24, 0xC7	; 199
    b5ce:	93 4f       	sbci	r25, 0xF3	; 243
    b5d0:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
    b5d4:	80 91 57 09 	lds	r24, 0x0957
    b5d8:	8e 5f       	subi	r24, 0xFE	; 254
    b5da:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b5de:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 300*GSM_DEBUG_DELAY);
    b5e2:	6c e2       	ldi	r22, 0x2C	; 44
    b5e4:	71 e0       	ldi	r23, 0x01	; 1
    b5e6:	80 91 5a 02 	lds	r24, 0x025A
    b5ea:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    b5ee:	0f 90       	pop	r0
    b5f0:	0f 90       	pop	r0
    b5f2:	0f 90       	pop	r0
    b5f4:	0f 90       	pop	r0
			}
			GSM_State++;
    b5f6:	80 91 27 06 	lds	r24, 0x0627
    b5fa:	8f 5f       	subi	r24, 0xFF	; 255
    b5fc:	80 93 27 06 	sts	0x0627, r24
    b600:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPCSGP_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b604:	6a e5       	ldi	r22, 0x5A	; 90
    b606:	82 e2       	ldi	r24, 0x22	; 34
    b608:	9f e4       	ldi	r25, 0x4F	; 79
    b60a:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b60e:	88 23       	and	r24, r24
    b610:	11 f4       	brne	.+4      	; 0xb616 <GSM_Cycle+0x5b4>
    b612:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b616:	80 91 27 06 	lds	r24, 0x0627
    b61a:	8f 5f       	subi	r24, 0xFF	; 255
    b61c:	80 93 27 06 	sts	0x0627, r24
    b620:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_SEND_CSTT:
			GSM_Execute_Command(AT_CSTT, 300*GSM_DEBUG_DELAY); GSM_State++;
    b624:	6c e2       	ldi	r22, 0x2C	; 44
    b626:	71 e0       	ldi	r23, 0x01	; 1
    b628:	8a ef       	ldi	r24, 0xFA	; 250
    b62a:	9d e4       	ldi	r25, 0x4D	; 77
    b62c:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b630:	80 91 27 06 	lds	r24, 0x0627
    b634:	8f 5f       	subi	r24, 0xFF	; 255
    b636:	80 93 27 06 	sts	0x0627, r24
    b63a:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CSTT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b63e:	6a e5       	ldi	r22, 0x5A	; 90
    b640:	82 e2       	ldi	r24, 0x22	; 34
    b642:	9f e4       	ldi	r25, 0x4F	; 79
    b644:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b648:	88 23       	and	r24, r24
    b64a:	11 f4       	brne	.+4      	; 0xb650 <GSM_Cycle+0x5ee>
    b64c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b650:	80 91 27 06 	lds	r24, 0x0627
    b654:	8f 5f       	subi	r24, 0xFF	; 255
    b656:	80 93 27 06 	sts	0x0627, r24
    b65a:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_SEND_CIICR:
			GSM_Execute_Command(AT_CIICR, 12000*GSM_DEBUG_DELAY); GSM_State++;
    b65e:	60 ee       	ldi	r22, 0xE0	; 224
    b660:	7e e2       	ldi	r23, 0x2E	; 46
    b662:	81 ef       	ldi	r24, 0xF1	; 241
    b664:	9d e4       	ldi	r25, 0x4D	; 77
    b666:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b66a:	80 91 27 06 	lds	r24, 0x0627
    b66e:	8f 5f       	subi	r24, 0xFF	; 255
    b670:	80 93 27 06 	sts	0x0627, r24
    b674:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIICR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    b678:	6a e5       	ldi	r22, 0x5A	; 90
    b67a:	82 e2       	ldi	r24, 0x22	; 34
    b67c:	9f e4       	ldi	r25, 0x4F	; 79
    b67e:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b682:	88 23       	and	r24, r24
    b684:	11 f4       	brne	.+4      	; 0xb68a <GSM_Cycle+0x628>
    b686:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b68a:	80 91 27 06 	lds	r24, 0x0627
    b68e:	8f 5f       	subi	r24, 0xFF	; 255
    b690:	80 93 27 06 	sts	0x0627, r24
    b694:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_SEND_CIFSR:
			GSM_Execute_Command(AT_CIFSR, 1000*GSM_DEBUG_DELAY); GSM_State++;
    b698:	68 ee       	ldi	r22, 0xE8	; 232
    b69a:	73 e0       	ldi	r23, 0x03	; 3
    b69c:	88 ee       	ldi	r24, 0xE8	; 232
    b69e:	9d e4       	ldi	r25, 0x4D	; 77
    b6a0:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b6a4:	80 91 27 06 	lds	r24, 0x0627
    b6a8:	8f 5f       	subi	r24, 0xFF	; 255
    b6aa:	80 93 27 06 	sts	0x0627, r24
    b6ae:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    b6b2:	80 91 5a 02 	lds	r24, 0x025A
    b6b6:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    b6ba:	88 23       	and	r24, r24
    b6bc:	19 f0       	breq	.+6      	; 0xb6c4 <GSM_Cycle+0x662>
    b6be:	8a e5       	ldi	r24, 0x5A	; 90
    b6c0:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    b6c4:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    b6c8:	88 23       	and	r24, r24
    b6ca:	11 f4       	brne	.+4      	; 0xb6d0 <GSM_Cycle+0x66e>
    b6cc:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    b6d0:	10 92 1c 0b 	sts	0x0B1C, r1
	IP->IP2 = IP2;
    b6d4:	10 92 1d 0b 	sts	0x0B1D, r1
	IP->IP3 = IP3;
    b6d8:	10 92 1e 0b 	sts	0x0B1E, r1
	IP->IP4 = IP4;
    b6dc:	10 92 1f 0b 	sts	0x0B1F, r1
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b6e0:	40 e0       	ldi	r20, 0x00	; 0
    b6e2:	a9 e8       	ldi	r26, 0x89	; 137
    b6e4:	b9 e0       	ldi	r27, 0x09	; 9
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b6e6:	50 e2       	ldi	r21, 0x20	; 32
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b6e8:	89 e8       	ldi	r24, 0x89	; 137
    b6ea:	99 e0       	ldi	r25, 0x09	; 9
    b6ec:	fd 01       	movw	r30, r26
    b6ee:	01 90       	ld	r0, Z+
    b6f0:	00 20       	and	r0, r0
    b6f2:	e9 f7       	brne	.-6      	; 0xb6ee <GSM_Cycle+0x68c>
    b6f4:	31 97       	sbiw	r30, 0x01	; 1
    b6f6:	e9 58       	subi	r30, 0x89	; 137
    b6f8:	f9 40       	sbci	r31, 0x09	; 9
    b6fa:	24 2f       	mov	r18, r20
    b6fc:	30 e0       	ldi	r19, 0x00	; 0
    b6fe:	2e 17       	cp	r18, r30
    b700:	3f 07       	cpc	r19, r31
    b702:	58 f4       	brcc	.+22     	; 0xb71a <GSM_Cycle+0x6b8>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
    b704:	f9 01       	movw	r30, r18
    b706:	e7 57       	subi	r30, 0x77	; 119
    b708:	f6 4f       	sbci	r31, 0xF6	; 246
    b70a:	80 81       	ld	r24, Z
    b70c:	90 e0       	ldi	r25, 0x00	; 0
    b70e:	c0 97       	sbiw	r24, 0x30	; 48
    b710:	0a 97       	sbiw	r24, 0x0a	; 10
    b712:	08 f0       	brcs	.+2      	; 0xb716 <GSM_Cycle+0x6b4>
    b714:	50 83       	st	Z, r21
			break;
		case GSM_WAIT_CIFSR_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(GetStringFromFIFO()){
				SetIP(&GSM_MyIP,0,0,0,0);
				for(uint8_t i=0; i<strlen(GSM_RxStr); i++)
    b716:	4f 5f       	subi	r20, 0xFF	; 255
    b718:	e7 cf       	rjmp	.-50     	; 0xb6e8 <GSM_Cycle+0x686>
					if(!isdigit(GSM_RxStr[i])) GSM_RxStr[i] = ' ';
				sscanf_P(GSM_RxStr,PSTR("%hhu %hhu %hhu %hhu"), (unsigned char*)&GSM_MyIP.IP1, (unsigned char*)&GSM_MyIP.IP2, (unsigned char*)&GSM_MyIP.IP3, (unsigned char*)&GSM_MyIP.IP4);
    b71a:	2f e1       	ldi	r18, 0x1F	; 31
    b71c:	3b e0       	ldi	r19, 0x0B	; 11
    b71e:	3f 93       	push	r19
    b720:	2f 93       	push	r18
    b722:	2e e1       	ldi	r18, 0x1E	; 30
    b724:	3b e0       	ldi	r19, 0x0B	; 11
    b726:	3f 93       	push	r19
    b728:	2f 93       	push	r18
    b72a:	2d e1       	ldi	r18, 0x1D	; 29
    b72c:	3b e0       	ldi	r19, 0x0B	; 11
    b72e:	3f 93       	push	r19
    b730:	2f 93       	push	r18
    b732:	2c e1       	ldi	r18, 0x1C	; 28
    b734:	3b e0       	ldi	r19, 0x0B	; 11
    b736:	3f 93       	push	r19
    b738:	2f 93       	push	r18
    b73a:	2a e6       	ldi	r18, 0x6A	; 106
    b73c:	33 e0       	ldi	r19, 0x03	; 3
    b73e:	3f 93       	push	r19
    b740:	2f 93       	push	r18
    b742:	9f 93       	push	r25
    b744:	8f 93       	push	r24
    b746:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				if(!IP_compare_Const(&GSM_MyIP,0,0,0,0)){
    b74a:	00 e0       	ldi	r16, 0x00	; 0
    b74c:	20 e0       	ldi	r18, 0x00	; 0
    b74e:	40 e0       	ldi	r20, 0x00	; 0
    b750:	60 e0       	ldi	r22, 0x00	; 0
    b752:	8c e1       	ldi	r24, 0x1C	; 28
    b754:	9b e0       	ldi	r25, 0x0B	; 11
    b756:	0e 94 c6 39 	call	0x738c	; 0x738c <IP_compare_Const>
    b75a:	0f b6       	in	r0, 0x3f	; 63
    b75c:	f8 94       	cli
    b75e:	de bf       	out	0x3e, r29	; 62
    b760:	0f be       	out	0x3f, r0	; 63
    b762:	cd bf       	out	0x3d, r28	; 61
    b764:	81 11       	cpse	r24, r1
    b766:	03 c0       	rjmp	.+6      	; 0xb76e <GSM_Cycle+0x70c>
				/*	if(GSM_MultiCon) GSM_State++;
					else GSM_State = GSM_SEND_CIPSERVER;*/
					GSM_State=GSM_SEND_CIPSTART_TCP;
    b768:	84 e2       	ldi	r24, 0x24	; 36
    b76a:	80 93 27 06 	sts	0x0627, r24
				}
				TempNum=0;	//
    b76e:	10 92 e7 03 	sts	0x03E7, r1
    b772:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}			
			break;
		//------------------------
		case GSM_SEND_CIPSTART_TCP:	
			if(GSM_Flag & (1<<flg_TxCStr)){
    b776:	80 91 08 01 	lds	r24, 0x0108
    b77a:	80 fd       	sbrc	r24, 0
    b77c:	02 c0       	rjmp	.+4      	; 0xb782 <GSM_Cycle+0x720>
    b77e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				GSMTxSz = strlen_P(AT_CIPSTART_TCP);
    b782:	82 e1       	ldi	r24, 0x12	; 18
    b784:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSTART_TCP);
    b788:	80 ec       	ldi	r24, 0xC0	; 192
    b78a:	9d e4       	ldi	r25, 0x4D	; 77
    b78c:	9f 93       	push	r25
    b78e:	8f 93       	push	r24
    b790:	09 e3       	ldi	r16, 0x39	; 57
    b792:	1c e0       	ldi	r17, 0x0C	; 12
    b794:	1f 93       	push	r17
    b796:	0f 93       	push	r16
    b798:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
    b79c:	82 e2       	ldi	r24, 0x22	; 34
    b79e:	91 e0       	ldi	r25, 0x01	; 1
    b7a0:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    b7a4:	68 2e       	mov	r6, r24
    b7a6:	59 2e       	mov	r5, r25
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    b7a8:	85 e3       	ldi	r24, 0x35	; 53
    b7aa:	91 e0       	ldi	r25, 0x01	; 1
    b7ac:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    b7b0:	78 2e       	mov	r7, r24
    b7b2:	84 e3       	ldi	r24, 0x34	; 52
    b7b4:	91 e0       	ldi	r25, 0x01	; 1
    b7b6:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    b7ba:	88 2e       	mov	r8, r24
    b7bc:	83 e3       	ldi	r24, 0x33	; 51
    b7be:	91 e0       	ldi	r25, 0x01	; 1
    b7c0:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    b7c4:	98 2e       	mov	r9, r24
    b7c6:	82 e3       	ldi	r24, 0x32	; 50
    b7c8:	91 e0       	ldi	r25, 0x01	; 1
    b7ca:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
				
				sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&TCP_ServerIP[0].IP1), (unsigned int)erb(&TCP_ServerIP[0].IP2),
    b7ce:	90 91 57 09 	lds	r25, 0x0957
    b7d2:	5f 92       	push	r5
    b7d4:	6f 92       	push	r6
    b7d6:	1f 92       	push	r1
    b7d8:	7f 92       	push	r7
    b7da:	1f 92       	push	r1
    b7dc:	8f 92       	push	r8
    b7de:	1f 92       	push	r1
    b7e0:	9f 92       	push	r9
    b7e2:	1f 92       	push	r1
    b7e4:	8f 93       	push	r24
    b7e6:	27 eb       	ldi	r18, 0xB7	; 183
    b7e8:	31 e0       	ldi	r19, 0x01	; 1
    b7ea:	3f 93       	push	r19
    b7ec:	2f 93       	push	r18
    b7ee:	89 2f       	mov	r24, r25
    b7f0:	90 e0       	ldi	r25, 0x00	; 0
    b7f2:	87 5c       	subi	r24, 0xC7	; 199
    b7f4:	93 4f       	sbci	r25, 0xF3	; 243
    b7f6:	9f 93       	push	r25
    b7f8:	8f 93       	push	r24
    b7fa:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
				(unsigned int)erb(&TCP_ServerIP[0].IP3), (unsigned int)erb(&TCP_ServerIP[0].IP4), (unsigned int)erw(&TCP_ServerPort[0]));
				GSMTxSz = strlen(GSM_TxStr);
    b7fe:	f8 01       	movw	r30, r16
    b800:	01 90       	ld	r0, Z+
    b802:	00 20       	and	r0, r0
    b804:	e9 f7       	brne	.-6      	; 0xb800 <GSM_Cycle+0x79e>
    b806:	31 97       	sbiw	r30, 0x01	; 1
    b808:	e9 53       	subi	r30, 0x39	; 57
    b80a:	fc 40       	sbci	r31, 0x0C	; 12
    b80c:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    b810:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 1000*GSM_DEBUG_DELAY);
    b814:	68 ee       	ldi	r22, 0xE8	; 232
    b816:	73 e0       	ldi	r23, 0x03	; 3
    b818:	80 91 5a 02 	lds	r24, 0x025A
    b81c:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State=GSM_WAIT_CIPSTART_TCP_OK;
    b820:	85 e2       	ldi	r24, 0x25	; 37
    b822:	80 93 27 06 	sts	0x0627, r24
    b826:	0f b6       	in	r0, 0x3f	; 63
    b828:	f8 94       	cli
    b82a:	de bf       	out	0x3e, r29	; 62
    b82c:	0f be       	out	0x3f, r0	; 63
    b82e:	cd bf       	out	0x3d, r28	; 61
    b830:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}		
			break;
		case GSM_WAIT_CIPSTART_TCP_OK:
	
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State=GSM_WAIT_CIPSTART_TCP_CONNECT;
    b834:	6a e5       	ldi	r22, 0x5A	; 90
    b836:	82 e2       	ldi	r24, 0x22	; 34
    b838:	9f e4       	ldi	r25, 0x4F	; 79
    b83a:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b83e:	88 23       	and	r24, r24
    b840:	11 f4       	brne	.+4      	; 0xb846 <GSM_Cycle+0x7e4>
    b842:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b846:	86 e2       	ldi	r24, 0x26	; 38
    b848:	80 93 27 06 	sts	0x0627, r24
    b84c:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			if(GetStringFromFIFO()){
			SetDigOut(2);*/
			/*	char RightAnswer[sizeof(RESP_CONNECT)];
				strcpy_P(RightAnswer, RESP_CONNECT);*/
				//RightAnswer[0] = 0x30+TempNum;
				if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b850:	6a e5       	ldi	r22, 0x5A	; 90
    b852:	8a e1       	ldi	r24, 0x1A	; 26
    b854:	9f e4       	ldi	r25, 0x4F	; 79
    b856:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b85a:	88 23       	and	r24, r24
    b85c:	11 f4       	brne	.+4      	; 0xb862 <GSM_Cycle+0x800>
    b85e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				/*	if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
					else GSM_State = GSM_SEND_CIPSTART;*/
					GSM_State = GSM_SEND_IDENTIFICATION;
    b862:	87 e2       	ldi	r24, 0x27	; 39
    b864:	80 93 27 06 	sts	0x0627, r24
    b868:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				}
		//	}
			break;
		case GSM_SEND_IDENTIFICATION:
			if(GSM_Flag & (1<<flg_TxCStr)){
    b86c:	80 91 08 01 	lds	r24, 0x0108
    b870:	80 fd       	sbrc	r24, 0
    b872:	02 c0       	rjmp	.+4      	; 0xb878 <GSM_Cycle+0x816>
    b874:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    b878:	82 e5       	ldi	r24, 0x52	; 82
    b87a:	91 e0       	ldi	r25, 0x01	; 1
    b87c:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
				GSMTxSz = sprintf(GSM_TxStr, "Modem=%u",(unsigned int)erw(&SerialNum));
    b880:	9f 93       	push	r25
    b882:	8f 93       	push	r24
    b884:	8b ec       	ldi	r24, 0xCB	; 203
    b886:	91 e0       	ldi	r25, 0x01	; 1
    b888:	9f 93       	push	r25
    b88a:	8f 93       	push	r24
    b88c:	89 e3       	ldi	r24, 0x39	; 57
    b88e:	9c e0       	ldi	r25, 0x0C	; 12
    b890:	9f 93       	push	r25
    b892:	8f 93       	push	r24
    b894:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    b898:	80 93 57 09 	sts	0x0957, r24
				GSM_SendFirstChar();
    b89c:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    b8a0:	64 ef       	ldi	r22, 0xF4	; 244
    b8a2:	71 e0       	ldi	r23, 0x01	; 1
    b8a4:	80 91 5a 02 	lds	r24, 0x025A
    b8a8:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State++;
    b8ac:	80 91 27 06 	lds	r24, 0x0627
    b8b0:	8f 5f       	subi	r24, 0xFF	; 255
    b8b2:	80 93 27 06 	sts	0x0627, r24
    b8b6:	0f 90       	pop	r0
    b8b8:	0f 90       	pop	r0
    b8ba:	0f 90       	pop	r0
    b8bc:	0f 90       	pop	r0
    b8be:	0f 90       	pop	r0
    b8c0:	0f 90       	pop	r0
    b8c2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_WAIT_IDENTIFICATION_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1))
    b8c6:	6a e5       	ldi	r22, 0x5A	; 90
    b8c8:	82 e2       	ldi	r24, 0x22	; 34
    b8ca:	9f e4       	ldi	r25, 0x4F	; 79
    b8cc:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b8d0:	88 23       	and	r24, r24
    b8d2:	11 f4       	brne	.+4      	; 0xb8d8 <GSM_Cycle+0x876>
    b8d4:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			{
				EM_InitFIFO(); 
    b8d8:	0e 94 ed 4a 	call	0x95da	; 0x95da <EM_InitFIFO>
				InitFIFO();
    b8dc:	0e 94 07 3a 	call	0x740e	; 0x740e <InitFIFO>
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b8e0:	80 91 05 06 	lds	r24, 0x0605
    b8e4:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State=GSM_ProtocolMode;
    b8e8:	81 e6       	ldi	r24, 0x61	; 97
    b8ea:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b8ee:	60 91 0b 01 	lds	r22, 0x010B
    b8f2:	70 91 0c 01 	lds	r23, 0x010C
    b8f6:	80 91 40 0d 	lds	r24, 0x0D40
    b8fa:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b8fe:	60 91 09 01 	lds	r22, 0x0109
    b902:	70 91 0a 01 	lds	r23, 0x010A
    b906:	80 91 0b 06 	lds	r24, 0x060B
    b90a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    b90e:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SEND_CIPSTATUS:
			GSM_Execute_Command(AT_CIPSTATUS, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_STATE_CONNECT_OK;			
    b912:	64 ef       	ldi	r22, 0xF4	; 244
    b914:	71 e0       	ldi	r23, 0x01	; 1
    b916:	84 e9       	ldi	r24, 0x94	; 148
    b918:	9d e4       	ldi	r25, 0x4D	; 77
    b91a:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b91e:	8a e2       	ldi	r24, 0x2A	; 42
    b920:	80 93 27 06 	sts	0x0627, r24
    b924:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_STATE_CONNECT_OK:
			if(GSM_Wait_Response_P(RESP_STATE_CONNECT_OK, GSM_ReStart1)){
    b928:	6a e5       	ldi	r22, 0x5A	; 90
    b92a:	88 ea       	ldi	r24, 0xA8	; 168
    b92c:	9e e4       	ldi	r25, 0x4E	; 78
    b92e:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b932:	88 23       	and	r24, r24
    b934:	11 f4       	brne	.+4      	; 0xb93a <GSM_Cycle+0x8d8>
    b936:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				GSM_State = GSM_SEND_ATO;
    b93a:	8b e2       	ldi	r24, 0x2B	; 43
    b93c:	80 93 27 06 	sts	0x0627, r24
    b940:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SEND_ATO:
			GSM_Execute_Command(AT_ATO, 500*GSM_DEBUG_DELAY); GSM_State=GSM_WAIT_ATO_CONNECT;
    b944:	64 ef       	ldi	r22, 0xF4	; 244
    b946:	71 e0       	ldi	r23, 0x01	; 1
    b948:	80 e9       	ldi	r24, 0x90	; 144
    b94a:	9d e4       	ldi	r25, 0x4D	; 77
    b94c:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    b950:	8c e2       	ldi	r24, 0x2C	; 44
    b952:	80 93 27 06 	sts	0x0627, r24
    b956:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_ATO_CONNECT:
			if(GSM_Wait_Response_P(RESP_CONNECT, GSM_ReStart1)){
    b95a:	6a e5       	ldi	r22, 0x5A	; 90
    b95c:	8a e1       	ldi	r24, 0x1A	; 26
    b95e:	9f e4       	ldi	r25, 0x4F	; 79
    b960:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    b964:	88 23       	and	r24, r24
    b966:	11 f4       	brne	.+4      	; 0xb96c <GSM_Cycle+0x90a>
    b968:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
				switch(Transparent_Application_state){
    b96c:	80 91 52 09 	lds	r24, 0x0952
    b970:	82 30       	cpi	r24, 0x02	; 2
    b972:	49 f0       	breq	.+18     	; 0xb986 <GSM_Cycle+0x924>
    b974:	83 30       	cpi	r24, 0x03	; 3
    b976:	b9 f4       	brne	.+46     	; 0xb9a6 <GSM_Cycle+0x944>
					case CHECK_CONNECTION_STATE:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b978:	60 91 0b 01 	lds	r22, 0x010B
    b97c:	70 91 0c 01 	lds	r23, 0x010C
    b980:	80 91 40 0d 	lds	r24, 0x0D40
    b984:	0e c0       	rjmp	.+28     	; 0xb9a2 <GSM_Cycle+0x940>
						break;
					case RECONNECT:
						StartTimer16(TCP_CONNECT_check_timer, Connection_check_period);
    b986:	60 91 0b 01 	lds	r22, 0x010B
    b98a:	70 91 0c 01 	lds	r23, 0x010C
    b98e:	80 91 40 0d 	lds	r24, 0x0D40
    b992:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
						StartTimer16(GPRS_RECONNECT_timer, GPRS_RECONNECT_period);
    b996:	60 91 09 01 	lds	r22, 0x0109
    b99a:	70 91 0a 01 	lds	r23, 0x010A
    b99e:	80 91 0b 06 	lds	r24, 0x060B
    b9a2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
						break;
					default:break;
				}
				GSM_RX_FIFO_End_Transp = GSM_RX_FIFO_End;
    b9a6:	80 91 05 06 	lds	r24, 0x0605
    b9aa:	80 93 f8 0a 	sts	0x0AF8, r24
				GSM_State = GSM_ProtocolMode;
    b9ae:	81 e6       	ldi	r24, 0x61	; 97
    b9b0:	80 93 27 06 	sts	0x0627, r24
    b9b4:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		//------------------------
		case GSM_SEND_CIPSTART:
			if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0)){
    b9b8:	10 91 e7 03 	lds	r17, 0x03E7
    b9bc:	34 e0       	ldi	r19, 0x04	; 4
    b9be:	13 9f       	mul	r17, r19
    b9c0:	c0 01       	movw	r24, r0
    b9c2:	11 24       	eor	r1, r1
    b9c4:	00 e0       	ldi	r16, 0x00	; 0
    b9c6:	20 e0       	ldi	r18, 0x00	; 0
    b9c8:	40 e0       	ldi	r20, 0x00	; 0
    b9ca:	60 e0       	ldi	r22, 0x00	; 0
    b9cc:	8e 5b       	subi	r24, 0xBE	; 190
    b9ce:	9e 4f       	sbci	r25, 0xFE	; 254
    b9d0:	0e 94 d7 39 	call	0x73ae	; 0x73ae <IP_E_compare_Const>
    b9d4:	88 23       	and	r24, r24
    b9d6:	61 f0       	breq	.+24     	; 0xb9f0 <GSM_Cycle+0x98e>
				TempNum++;
    b9d8:	1f 5f       	subi	r17, 0xFF	; 255
    b9da:	10 93 e7 03 	sts	0x03E7, r17
				if(TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_SEND_CIPSERVER;
    b9de:	14 30       	cpi	r17, 0x04	; 4
    b9e0:	10 f4       	brcc	.+4      	; 0xb9e6 <GSM_Cycle+0x984>
    b9e2:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
    b9e6:	83 e3       	ldi	r24, 0x33	; 51
    b9e8:	80 93 27 06 	sts	0x0627, r24
    b9ec:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
    b9f0:	80 91 08 01 	lds	r24, 0x0108
    b9f4:	80 fd       	sbrc	r24, 0
    b9f6:	02 c0       	rjmp	.+4      	; 0xb9fc <GSM_Cycle+0x99a>
    b9f8:	0c 94 fb 64 	jmp	0xc9f6	; 0xc9f6 <GSM_Cycle+0x1994>
					GSMTxSz = strlen_P(AT_CIPSTART);
    b9fc:	84 e1       	ldi	r24, 0x14	; 20
    b9fe:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSTART);
    ba02:	83 ed       	ldi	r24, 0xD3	; 211
    ba04:	9d e4       	ldi	r25, 0x4D	; 77
    ba06:	9f 93       	push	r25
    ba08:	8f 93       	push	r24
    ba0a:	89 e3       	ldi	r24, 0x39	; 57
    ba0c:	88 2e       	mov	r8, r24
    ba0e:	8c e0       	ldi	r24, 0x0C	; 12
    ba10:	98 2e       	mov	r9, r24
    ba12:	9f 92       	push	r9
    ba14:	8f 92       	push	r8
    ba16:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
					GSM_TxStr[12] = 0x30+TempNum;
    ba1a:	00 91 e7 03 	lds	r16, 0x03E7
    ba1e:	80 e3       	ldi	r24, 0x30	; 48
    ba20:	80 0f       	add	r24, r16
    ba22:	80 93 45 0c 	sts	0x0C45, r24
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
    ba26:	10 e0       	ldi	r17, 0x00	; 0
    ba28:	c8 01       	movw	r24, r16
    ba2a:	88 0f       	add	r24, r24
    ba2c:	99 1f       	adc	r25, r25
    ba2e:	86 5d       	subi	r24, 0xD6	; 214
    ba30:	9e 4f       	sbci	r25, 0xFE	; 254
    ba32:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
    ba36:	48 2e       	mov	r4, r24
    ba38:	39 2e       	mov	r3, r25
    ba3a:	00 0f       	add	r16, r16
    ba3c:	11 1f       	adc	r17, r17
    ba3e:	00 0f       	add	r16, r16
    ba40:	11 1f       	adc	r17, r17
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    ba42:	c8 01       	movw	r24, r16
    ba44:	8b 5b       	subi	r24, 0xBB	; 187
    ba46:	9e 4f       	sbci	r25, 0xFE	; 254
    ba48:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    ba4c:	58 2e       	mov	r5, r24
    ba4e:	c8 01       	movw	r24, r16
    ba50:	8c 5b       	subi	r24, 0xBC	; 188
    ba52:	9e 4f       	sbci	r25, 0xFE	; 254
    ba54:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    ba58:	68 2e       	mov	r6, r24
    ba5a:	c8 01       	movw	r24, r16
    ba5c:	8d 5b       	subi	r24, 0xBD	; 189
    ba5e:	9e 4f       	sbci	r25, 0xFE	; 254
    ba60:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    ba64:	78 2e       	mov	r7, r24
    ba66:	c8 01       	movw	r24, r16
    ba68:	8e 5b       	subi	r24, 0xBE	; 190
    ba6a:	9e 4f       	sbci	r25, 0xFE	; 254
    ba6c:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
			else{
				if(GSM_Flag & (1<<flg_TxCStr)){
					GSMTxSz = strlen_P(AT_CIPSTART);
					sprintf_P(GSM_TxStr, AT_CIPSTART);
					GSM_TxStr[12] = 0x30+TempNum;
					sprintf(GSM_TxStr + GSMTxSz, "\"%u.%u.%u.%u\",\"%u\"\r",(unsigned int)erb(&UDP_ServerIP[TempNum].IP1), (unsigned int)erb(&UDP_ServerIP[TempNum].IP2), 
    ba70:	90 91 57 09 	lds	r25, 0x0957
    ba74:	3f 92       	push	r3
    ba76:	4f 92       	push	r4
    ba78:	1f 92       	push	r1
    ba7a:	5f 92       	push	r5
    ba7c:	1f 92       	push	r1
    ba7e:	6f 92       	push	r6
    ba80:	1f 92       	push	r1
    ba82:	7f 92       	push	r7
    ba84:	1f 92       	push	r1
    ba86:	8f 93       	push	r24
    ba88:	27 eb       	ldi	r18, 0xB7	; 183
    ba8a:	31 e0       	ldi	r19, 0x01	; 1
    ba8c:	3f 93       	push	r19
    ba8e:	2f 93       	push	r18
    ba90:	89 2f       	mov	r24, r25
    ba92:	90 e0       	ldi	r25, 0x00	; 0
    ba94:	87 5c       	subi	r24, 0xC7	; 199
    ba96:	93 4f       	sbci	r25, 0xF3	; 243
    ba98:	9f 93       	push	r25
    ba9a:	8f 93       	push	r24
    ba9c:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
						(unsigned int)erb(&UDP_ServerIP[TempNum].IP3), (unsigned int)erb(&UDP_ServerIP[TempNum].IP4), (unsigned int)erw(&UDP_ServerPort[TempNum]));
					GSMTxSz = strlen(GSM_TxStr);
    baa0:	f4 01       	movw	r30, r8
    baa2:	01 90       	ld	r0, Z+
    baa4:	00 20       	and	r0, r0
    baa6:	e9 f7       	brne	.-6      	; 0xbaa2 <GSM_Cycle+0xa40>
    baa8:	31 97       	sbiw	r30, 0x01	; 1
    baaa:	e9 53       	subi	r30, 0x39	; 57
    baac:	fc 40       	sbci	r31, 0x0C	; 12
    baae:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    bab2:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bab6:	64 ef       	ldi	r22, 0xF4	; 244
    bab8:	71 e0       	ldi	r23, 0x01	; 1
    baba:	80 91 5a 02 	lds	r24, 0x025A
    babe:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					GSM_State++;
    bac2:	80 91 27 06 	lds	r24, 0x0627
    bac6:	8f 5f       	subi	r24, 0xFF	; 255
    bac8:	80 93 27 06 	sts	0x0627, r24
    bacc:	0f b6       	in	r0, 0x3f	; 63
    bace:	f8 94       	cli
    bad0:	de bf       	out	0x3e, r29	; 62
    bad2:	0f be       	out	0x3f, r0	; 63
    bad4:	cd bf       	out	0x3d, r28	; 61
    bad6:	8f c7       	rjmp	.+3870   	; 0xc9f6 <GSM_Cycle+0x1994>
				}
			}
			break;
		case GSM_WAIT_CIPSTART_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    bad8:	6a e5       	ldi	r22, 0x5A	; 90
    bada:	82 e2       	ldi	r24, 0x22	; 34
    badc:	9f e4       	ldi	r25, 0x4F	; 79
    bade:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    bae2:	88 23       	and	r24, r24
    bae4:	09 f4       	brne	.+2      	; 0xbae8 <GSM_Cycle+0xa86>
    bae6:	87 c7       	rjmp	.+3854   	; 0xc9f6 <GSM_Cycle+0x1994>
    bae8:	80 91 27 06 	lds	r24, 0x0627
    baec:	8f 5f       	subi	r24, 0xFF	; 255
    baee:	80 93 27 06 	sts	0x0627, r24
    baf2:	81 c7       	rjmp	.+3842   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPSTART_CONNECT_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    baf4:	80 91 5a 02 	lds	r24, 0x025A
    baf8:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    bafc:	88 23       	and	r24, r24
    bafe:	19 f0       	breq	.+6      	; 0xbb06 <GSM_Cycle+0xaa4>
    bb00:	8a e5       	ldi	r24, 0x5A	; 90
    bb02:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    bb06:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    bb0a:	88 23       	and	r24, r24
    bb0c:	09 f4       	brne	.+2      	; 0xbb10 <GSM_Cycle+0xaae>
    bb0e:	73 c7       	rjmp	.+3814   	; 0xc9f6 <GSM_Cycle+0x1994>
				char RightAnswer[sizeof(RESP_CONNECT_OK)];
				strcpy_P(RightAnswer, RESP_CONNECT_OK);
    bb10:	6c e0       	ldi	r22, 0x0C	; 12
    bb12:	7f e4       	ldi	r23, 0x4F	; 79
    bb14:	ce 01       	movw	r24, r28
    bb16:	01 96       	adiw	r24, 0x01	; 1
    bb18:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
				RightAnswer[0] = 0x30+TempNum;
    bb1c:	10 91 e7 03 	lds	r17, 0x03E7
    bb20:	80 e3       	ldi	r24, 0x30	; 48
    bb22:	81 0f       	add	r24, r17
    bb24:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    bb26:	6a e5       	ldi	r22, 0x5A	; 90
    bb28:	ce 01       	movw	r24, r28
    bb2a:	01 96       	adiw	r24, 0x01	; 1
    bb2c:	0e 94 21 3b 	call	0x7642	; 0x7642 <GSM_Wait_Response>
    bb30:	88 23       	and	r24, r24
    bb32:	09 f4       	brne	.+2      	; 0xbb36 <GSM_Cycle+0xad4>
    bb34:	60 c7       	rjmp	.+3776   	; 0xc9f6 <GSM_Cycle+0x1994>
					if(++TempNum>3) GSM_State = GSM_ServerIdle;	//GSM_State++;
    bb36:	1f 5f       	subi	r17, 0xFF	; 255
    bb38:	10 93 e7 03 	sts	0x03E7, r17
    bb3c:	14 30       	cpi	r17, 0x04	; 4
    bb3e:	20 f0       	brcs	.+8      	; 0xbb48 <GSM_Cycle+0xae6>
    bb40:	83 e3       	ldi	r24, 0x33	; 51
    bb42:	80 93 27 06 	sts	0x0627, r24
    bb46:	57 c7       	rjmp	.+3758   	; 0xc9f6 <GSM_Cycle+0x1994>
					else GSM_State = GSM_SEND_CIPSTART;
    bb48:	8d e2       	ldi	r24, 0x2D	; 45
    bb4a:	80 93 27 06 	sts	0x0627, r24
    bb4e:	53 c7       	rjmp	.+3750   	; 0xc9f6 <GSM_Cycle+0x1994>
				}
			}
			break;

		case GSM_SEND_CIPSERVER:
			if(GSM_Flag & (1<<flg_TxCStr)){
    bb50:	80 91 08 01 	lds	r24, 0x0108
    bb54:	80 ff       	sbrs	r24, 0
    bb56:	4f c7       	rjmp	.+3742   	; 0xc9f6 <GSM_Cycle+0x1994>
				GSMTxSz = strlen_P(AT_CIPSERVER);
    bb58:	8f e0       	ldi	r24, 0x0F	; 15
    bb5a:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPSERVER);
    bb5e:	80 eb       	ldi	r24, 0xB0	; 176
    bb60:	9d e4       	ldi	r25, 0x4D	; 77
    bb62:	9f 93       	push	r25
    bb64:	8f 93       	push	r24
    bb66:	09 e3       	ldi	r16, 0x39	; 57
    bb68:	1c e0       	ldi	r17, 0x0C	; 12
    bb6a:	1f 93       	push	r17
    bb6c:	0f 93       	push	r16
    bb6e:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    bb72:	80 e2       	ldi	r24, 0x20	; 32
    bb74:	91 e0       	ldi	r25, 0x01	; 1
    bb76:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
				sprintf(GSM_TxStr + GSMTxSz,"%u\r",(unsigned int)erw(&TCP_ListenPort));
    bb7a:	40 91 57 09 	lds	r20, 0x0957
    bb7e:	9f 93       	push	r25
    bb80:	8f 93       	push	r24
    bb82:	27 ed       	ldi	r18, 0xD7	; 215
    bb84:	31 e0       	ldi	r19, 0x01	; 1
    bb86:	3f 93       	push	r19
    bb88:	2f 93       	push	r18
    bb8a:	84 2f       	mov	r24, r20
    bb8c:	90 e0       	ldi	r25, 0x00	; 0
    bb8e:	87 5c       	subi	r24, 0xC7	; 199
    bb90:	93 4f       	sbci	r25, 0xF3	; 243
    bb92:	9f 93       	push	r25
    bb94:	8f 93       	push	r24
    bb96:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
				GSMTxSz = strlen(GSM_TxStr);
    bb9a:	f8 01       	movw	r30, r16
    bb9c:	01 90       	ld	r0, Z+
    bb9e:	00 20       	and	r0, r0
    bba0:	e9 f7       	brne	.-6      	; 0xbb9c <GSM_Cycle+0xb3a>
    bba2:	31 97       	sbiw	r30, 0x01	; 1
    bba4:	e9 53       	subi	r30, 0x39	; 57
    bba6:	fc 40       	sbci	r31, 0x0C	; 12
    bba8:	e0 93 57 09 	sts	0x0957, r30
				GSM_SendFirstChar();
    bbac:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bbb0:	64 ef       	ldi	r22, 0xF4	; 244
    bbb2:	71 e0       	ldi	r23, 0x01	; 1
    bbb4:	80 91 5a 02 	lds	r24, 0x025A
    bbb8:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State++;
    bbbc:	80 91 27 06 	lds	r24, 0x0627
    bbc0:	8f 5f       	subi	r24, 0xFF	; 255
    bbc2:	80 93 27 06 	sts	0x0627, r24
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    bbc6:	6f ef       	ldi	r22, 0xFF	; 255
    bbc8:	7f ef       	ldi	r23, 0xFF	; 255
    bbca:	80 91 59 02 	lds	r24, 0x0259
    bbce:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    bbd2:	0f b6       	in	r0, 0x3f	; 63
    bbd4:	f8 94       	cli
    bbd6:	de bf       	out	0x3e, r29	; 62
    bbd8:	0f be       	out	0x3f, r0	; 63
    bbda:	cd bf       	out	0x3d, r28	; 61
    bbdc:	0c c7       	rjmp	.+3608   	; 0xc9f6 <GSM_Cycle+0x1994>
			}			
			break;
		case GSM_WAIT_CIPSERVER_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    bbde:	6a e5       	ldi	r22, 0x5A	; 90
    bbe0:	82 e2       	ldi	r24, 0x22	; 34
    bbe2:	9f e4       	ldi	r25, 0x4F	; 79
    bbe4:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    bbe8:	88 23       	and	r24, r24
    bbea:	09 f4       	brne	.+2      	; 0xbbee <GSM_Cycle+0xb8c>
    bbec:	04 c7       	rjmp	.+3592   	; 0xc9f6 <GSM_Cycle+0x1994>
    bbee:	80 91 27 06 	lds	r24, 0x0627
    bbf2:	8f 5f       	subi	r24, 0xFF	; 255
    bbf4:	80 93 27 06 	sts	0x0627, r24
    bbf8:	fe c6       	rjmp	.+3580   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPSERVER_SERVER_OK:
			if(GSM_Wait_Response_P(RESP_SERVER_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    bbfa:	6a e5       	ldi	r22, 0x5A	; 90
    bbfc:	82 e0       	ldi	r24, 0x02	; 2
    bbfe:	9f e4       	ldi	r25, 0x4F	; 79
    bc00:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    bc04:	88 23       	and	r24, r24
    bc06:	09 f4       	brne	.+2      	; 0xbc0a <GSM_Cycle+0xba8>
    bc08:	f6 c6       	rjmp	.+3564   	; 0xc9f6 <GSM_Cycle+0x1994>
    bc0a:	83 e3       	ldi	r24, 0x33	; 51
    bc0c:	80 93 27 06 	sts	0x0627, r24
    bc10:	f2 c6       	rjmp	.+3556   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		//------------------------
		case GSM_ServerIdle:
			if(!IsWebSession()){
    bc12:	80 91 7e 09 	lds	r24, 0x097E
    bc16:	81 11       	cpse	r24, r1
    bc18:	3c c0       	rjmp	.+120    	; 0xbc92 <GSM_Cycle+0xc30>
				if( GPRS_FlgSz_Out && (GPRS_FlgSz_Out <= GPRS_Out_MaxSz) ){
    bc1a:	80 91 43 09 	lds	r24, 0x0943
    bc1e:	88 23       	and	r24, r24
    bc20:	41 f1       	breq	.+80     	; 0xbc72 <GSM_Cycle+0xc10>
					if(GSM_MultiCon == 1){
    bc22:	80 91 4b 0e 	lds	r24, 0x0E4B
    bc26:	81 30       	cpi	r24, 0x01	; 1
    bc28:	e9 f4       	brne	.+58     	; 0xbc64 <GSM_Cycle+0xc02>
						if(GPRS_Protocol_Out == UDP){
    bc2a:	80 91 7c 09 	lds	r24, 0x097C
    bc2e:	81 11       	cpse	r24, r1
    bc30:	09 c0       	rjmp	.+18     	; 0xbc44 <GSM_Cycle+0xbe2>
							TempNum = 0;
    bc32:	10 92 e7 03 	sts	0x03E7, r1
							GSM_State = GSM_SEND_CIPSEND;
    bc36:	85 e3       	ldi	r24, 0x35	; 53
    bc38:	80 93 27 06 	sts	0x0627, r24
							ResetTimer16(TD_GSM);
    bc3c:	80 91 5a 02 	lds	r24, 0x025A
    bc40:	0e 94 c1 2c 	call	0x5982	; 0x5982 <ResetTimer16>
						}
						if(GPRS_Protocol_Out == TCP){
    bc44:	80 91 7c 09 	lds	r24, 0x097C
    bc48:	81 30       	cpi	r24, 0x01	; 1
    bc4a:	09 f0       	breq	.+2      	; 0xbc4e <GSM_Cycle+0xbec>
    bc4c:	d4 c6       	rjmp	.+3496   	; 0xc9f6 <GSM_Cycle+0x1994>
							if(GSM_ActiveConnection == NO_CONNECTION){
    bc4e:	80 91 07 01 	lds	r24, 0x0107
    bc52:	8f 3f       	cpi	r24, 0xFF	; 255
    bc54:	19 f4       	brne	.+6      	; 0xbc5c <GSM_Cycle+0xbfa>
								GPRS_FlgSz_Out = 0;
    bc56:	10 92 43 09 	sts	0x0943, r1
    bc5a:	cd c6       	rjmp	.+3482   	; 0xc9f6 <GSM_Cycle+0x1994>
							}
							else GSM_State = GSM_SEND_CIPSEND;
    bc5c:	85 e3       	ldi	r24, 0x35	; 53
    bc5e:	80 93 27 06 	sts	0x0627, r24
    bc62:	c9 c6       	rjmp	.+3474   	; 0xc9f6 <GSM_Cycle+0x1994>
						}
					}
					else{
						GSM_MultiCon = 1;
    bc64:	81 e0       	ldi	r24, 0x01	; 1
    bc66:	80 93 4b 0e 	sts	0x0E4B, r24
						GSM_State = GSM_CIPSHUT;
    bc6a:	82 e5       	ldi	r24, 0x52	; 82
    bc6c:	80 93 27 06 	sts	0x0627, r24
    bc70:	c2 c6       	rjmp	.+3460   	; 0xc9f6 <GSM_Cycle+0x1994>
					}
					break;
				}

				if(SMS_FlgSz_Out && erb(&SMS_On)){
    bc72:	80 91 67 09 	lds	r24, 0x0967
    bc76:	88 23       	and	r24, r24
    bc78:	61 f0       	breq	.+24     	; 0xbc92 <GSM_Cycle+0xc30>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    bc7a:	80 e6       	ldi	r24, 0x60	; 96
    bc7c:	90 e0       	ldi	r25, 0x00	; 0
    bc7e:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    bc82:	88 23       	and	r24, r24
    bc84:	31 f0       	breq	.+12     	; 0xbc92 <GSM_Cycle+0xc30>
					GSM_State = GSM_SEND_CMGS;
    bc86:	8a e3       	ldi	r24, 0x3A	; 58
    bc88:	80 93 27 06 	sts	0x0627, r24
					TempNum = 0;
    bc8c:	10 92 e7 03 	sts	0x03E7, r1
    bc90:	b2 c6       	rjmp	.+3428   	; 0xc9f6 <GSM_Cycle+0x1994>
					break;
				}
			}

			if(GetStringFromFIFO()){
    bc92:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    bc96:	88 23       	and	r24, r24
    bc98:	31 f0       	breq	.+12     	; 0xbca6 <GSM_Cycle+0xc44>
				GSM_State = GSM_AnalyzeURC;
    bc9a:	84 e3       	ldi	r24, 0x34	; 52
    bc9c:	80 93 27 06 	sts	0x0627, r24
				TempNum = 0;
    bca0:	10 92 e7 03 	sts	0x03E7, r1
    bca4:	a8 c6       	rjmp	.+3408   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			if(!IsWebSession()){
    bca6:	80 91 7e 09 	lds	r24, 0x097E
    bcaa:	81 11       	cpse	r24, r1
    bcac:	a4 c6       	rjmp	.+3400   	; 0xc9f6 <GSM_Cycle+0x1994>
				if(Timer16Stopp(TD_TCP_Connect) ){
    bcae:	80 91 59 02 	lds	r24, 0x0259
    bcb2:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    bcb6:	88 23       	and	r24, r24
    bcb8:	21 f0       	breq	.+8      	; 0xbcc2 <GSM_Cycle+0xc60>
					GSM_State = GSM_CIPSHUT;
    bcba:	82 e5       	ldi	r24, 0x52	; 82
    bcbc:	80 93 27 06 	sts	0x0627, r24
    bcc0:	9a c6       	rjmp	.+3380   	; 0xc9f6 <GSM_Cycle+0x1994>
						GSM_State = GSM_TCP_CLIENT_DISCONNECT;
						break;				
					}*/
				}
			
				if(Timer16Stopp(TD_RSSI)){
    bcc2:	80 91 58 02 	lds	r24, 0x0258
    bcc6:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    bcca:	88 23       	and	r24, r24
    bccc:	21 f0       	breq	.+8      	; 0xbcd6 <GSM_Cycle+0xc74>
					GSM_State = GSM_SEND_CSQ;
    bcce:	8f e5       	ldi	r24, 0x5F	; 95
    bcd0:	80 93 27 06 	sts	0x0627, r24
    bcd4:	90 c6       	rjmp	.+3360   	; 0xc9f6 <GSM_Cycle+0x1994>
					break;
				}

				if(Timer32Stopp(TD_GSM_Reset)){
    bcd6:	80 91 57 02 	lds	r24, 0x0257
    bcda:	0e 94 96 2c 	call	0x592c	; 0x592c <Timer32Stopp>
    bcde:	88 23       	and	r24, r24
    bce0:	09 f4       	brne	.+2      	; 0xbce4 <GSM_Cycle+0xc82>
    bce2:	89 c6       	rjmp	.+3346   	; 0xc9f6 <GSM_Cycle+0x1994>
					GSM_State = GSM_ReStart1;
    bce4:	8a e5       	ldi	r24, 0x5A	; 90
    bce6:	80 93 27 06 	sts	0x0627, r24
    bcea:	85 c6       	rjmp	.+3338   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		case GSM_AnalyzeURC:			//  

			//  
			if( (strstr_P(GSM_RxStr, URC_REMOTE_IP) != NULL) ){
    bcec:	6b e5       	ldi	r22, 0x5B	; 91
    bcee:	7f e4       	ldi	r23, 0x4F	; 79
    bcf0:	89 e8       	ldi	r24, 0x89	; 137
    bcf2:	99 e0       	ldi	r25, 0x09	; 9
    bcf4:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bcf8:	89 2b       	or	r24, r25
    bcfa:	21 f0       	breq	.+8      	; 0xbd04 <GSM_Cycle+0xca2>
				GSM_State = GSM_TCP_CLIENT_CONNECT;
    bcfc:	8e e3       	ldi	r24, 0x3E	; 62
    bcfe:	80 93 27 06 	sts	0x0627, r24
    bd02:	79 c6       	rjmp	.+3314   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			//  
			if( (strstr_P(GSM_RxStr, URC_CONNECT) != NULL) ){
    bd04:	63 e5       	ldi	r22, 0x53	; 83
    bd06:	7f e4       	ldi	r23, 0x4F	; 79
    bd08:	89 e8       	ldi	r24, 0x89	; 137
    bd0a:	99 e0       	ldi	r25, 0x09	; 9
    bd0c:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bd10:	89 2b       	or	r24, r25
    bd12:	61 f0       	breq	.+24     	; 0xbd2c <GSM_Cycle+0xcca>
				StartTimer16(TD_TCP_Connect, 1000);	//   
    bd14:	68 ee       	ldi	r22, 0xE8	; 232
    bd16:	73 e0       	ldi	r23, 0x03	; 3
    bd18:	80 91 59 02 	lds	r24, 0x0259
    bd1c:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_CSD = 0;
    bd20:	10 92 4b 09 	sts	0x094B, r1
				GSM_State = GSM_ProtocolMode;
    bd24:	81 e6       	ldi	r24, 0x61	; 97
    bd26:	80 93 27 06 	sts	0x0627, r24
    bd2a:	65 c6       	rjmp	.+3274   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			//   
			if( (strstr_P(GSM_RxStr, URC_RING) != NULL) ){
    bd2c:	60 e3       	ldi	r22, 0x30	; 48
    bd2e:	7f e4       	ldi	r23, 0x4F	; 79
    bd30:	89 e8       	ldi	r24, 0x89	; 137
    bd32:	99 e0       	ldi	r25, 0x09	; 9
    bd34:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bd38:	89 2b       	or	r24, r25
    bd3a:	51 f0       	breq	.+20     	; 0xbd50 <GSM_Cycle+0xcee>
				StartTimer16(TD_GSM, 150);
    bd3c:	66 e9       	ldi	r22, 0x96	; 150
    bd3e:	70 e0       	ldi	r23, 0x00	; 0
    bd40:	80 91 5a 02 	lds	r24, 0x025A
    bd44:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State = GSM_CheckNumber;	//    
    bd48:	86 e6       	ldi	r24, 0x66	; 102
    bd4a:	80 93 27 06 	sts	0x0627, r24
    bd4e:	53 c6       	rjmp	.+3238   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			//  
			if(strstr_P(GSM_RxStr, URC_CLOSED) != NULL){
    bd50:	60 e4       	ldi	r22, 0x40	; 64
    bd52:	7f e4       	ldi	r23, 0x4F	; 79
    bd54:	89 e8       	ldi	r24, 0x89	; 137
    bd56:	99 e0       	ldi	r25, 0x09	; 9
    bd58:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bd5c:	89 2b       	or	r24, r25
    bd5e:	49 f1       	breq	.+82     	; 0xbdb2 <GSM_Cycle+0xd50>
				//  
				sscanf_P(GSM_RxStr,PSTR("%hhu, CLOSED"),(unsigned char*)&TempNum);
    bd60:	87 ee       	ldi	r24, 0xE7	; 231
    bd62:	93 e0       	ldi	r25, 0x03	; 3
    bd64:	9f 93       	push	r25
    bd66:	8f 93       	push	r24
    bd68:	8d e5       	ldi	r24, 0x5D	; 93
    bd6a:	93 e0       	ldi	r25, 0x03	; 3
    bd6c:	9f 93       	push	r25
    bd6e:	8f 93       	push	r24
    bd70:	89 e8       	ldi	r24, 0x89	; 137
    bd72:	99 e0       	ldi	r25, 0x09	; 9
    bd74:	9f 93       	push	r25
    bd76:	8f 93       	push	r24
    bd78:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				if(GSM_ActiveConnection == TempNum){
    bd7c:	0f 90       	pop	r0
    bd7e:	0f 90       	pop	r0
    bd80:	0f 90       	pop	r0
    bd82:	0f 90       	pop	r0
    bd84:	0f 90       	pop	r0
    bd86:	0f 90       	pop	r0
    bd88:	90 91 07 01 	lds	r25, 0x0107
    bd8c:	80 91 e7 03 	lds	r24, 0x03E7
    bd90:	98 13       	cpse	r25, r24
    bd92:	0b c0       	rjmp	.+22     	; 0xbdaa <GSM_Cycle+0xd48>
					GSM_ActiveConnection = NO_CONNECTION;
    bd94:	8f ef       	ldi	r24, 0xFF	; 255
    bd96:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    bd9a:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    bd9e:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    bda2:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    bda6:	10 92 3d 0d 	sts	0x0D3D, r1
					SetIP(&GSM_ClientIP,0,0,0,0);
				}
				GSM_State = GSM_ServerIdle;
    bdaa:	83 e3       	ldi	r24, 0x33	; 51
    bdac:	80 93 27 06 	sts	0x0627, r24
    bdb0:	22 c6       	rjmp	.+3140   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			// +PDP DEACT
			if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    bdb2:	65 e3       	ldi	r22, 0x35	; 53
    bdb4:	7f e4       	ldi	r23, 0x4F	; 79
    bdb6:	89 e8       	ldi	r24, 0x89	; 137
    bdb8:	99 e0       	ldi	r25, 0x09	; 9
    bdba:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bdbe:	89 2b       	or	r24, r25
    bdc0:	21 f0       	breq	.+8      	; 0xbdca <GSM_Cycle+0xd68>
				GSM_State = GSM_SEND_E0;
    bdc2:	88 e0       	ldi	r24, 0x08	; 8
    bdc4:	80 93 27 06 	sts	0x0627, r24
    bdc8:	16 c6       	rjmp	.+3116   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			//        
			if((strstr_P(GSM_RxStr, URC_RECEIVE) != NULL) && (!GPRS_FlgSz_In) ){
    bdca:	69 e4       	ldi	r22, 0x49	; 73
    bdcc:	7f e4       	ldi	r23, 0x4F	; 79
    bdce:	89 e8       	ldi	r24, 0x89	; 137
    bdd0:	99 e0       	ldi	r25, 0x09	; 9
    bdd2:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bdd6:	89 2b       	or	r24, r25
    bdd8:	41 f0       	breq	.+16     	; 0xbdea <GSM_Cycle+0xd88>
    bdda:	80 91 5e 09 	lds	r24, 0x095E
    bdde:	81 11       	cpse	r24, r1
    bde0:	04 c0       	rjmp	.+8      	; 0xbdea <GSM_Cycle+0xd88>
					//   
					// 
				GSM_State = GSM_RECIEVE;
    bde2:	81 e4       	ldi	r24, 0x41	; 65
    bde4:	80 93 27 06 	sts	0x0627, r24
    bde8:	06 c6       	rjmp	.+3084   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			//      
			if(strstr_P(GSM_RxStr, RESP_CSQ) != NULL ){
    bdea:	6f ec       	ldi	r22, 0xCF	; 207
    bdec:	7e e4       	ldi	r23, 0x4E	; 78
    bdee:	89 e8       	ldi	r24, 0x89	; 137
    bdf0:	99 e0       	ldi	r25, 0x09	; 9
    bdf2:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    bdf6:	89 2b       	or	r24, r25
    bdf8:	21 f0       	breq	.+8      	; 0xbe02 <GSM_Cycle+0xda0>
				GSM_State = GSM_WAIT_CSQ;
    bdfa:	80 e6       	ldi	r24, 0x60	; 96
    bdfc:	80 93 27 06 	sts	0x0627, r24
    be00:	fa c5       	rjmp	.+3060   	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}

			// 
			GSM_State = GSM_ServerIdle;
    be02:	83 e3       	ldi	r24, 0x33	; 51
    be04:	80 93 27 06 	sts	0x0627, r24
    be08:	f6 c5       	rjmp	.+3052   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		//------------------------

		case GSM_SEND_CIPSEND:
			if(GPRS_Protocol_Out == UDP){
    be0a:	80 91 7c 09 	lds	r24, 0x097C
    be0e:	81 11       	cpse	r24, r1
    be10:	74 c0       	rjmp	.+232    	; 0xbefa <GSM_Cycle+0xe98>
				if(IP_E_compare_Const(&UDP_ServerIP[TempNum],0,0,0,0) || (IP_SendMask & (1<<TempNum)) ){
    be12:	10 91 e7 03 	lds	r17, 0x03E7
    be16:	f4 e0       	ldi	r31, 0x04	; 4
    be18:	1f 9f       	mul	r17, r31
    be1a:	c0 01       	movw	r24, r0
    be1c:	11 24       	eor	r1, r1
    be1e:	00 e0       	ldi	r16, 0x00	; 0
    be20:	20 e0       	ldi	r18, 0x00	; 0
    be22:	40 e0       	ldi	r20, 0x00	; 0
    be24:	60 e0       	ldi	r22, 0x00	; 0
    be26:	8e 5b       	subi	r24, 0xBE	; 190
    be28:	9e 4f       	sbci	r25, 0xFE	; 254
    be2a:	0e 94 d7 39 	call	0x73ae	; 0x73ae <IP_E_compare_Const>
    be2e:	81 11       	cpse	r24, r1
    be30:	0b c0       	rjmp	.+22     	; 0xbe48 <GSM_Cycle+0xde6>
    be32:	80 91 6f 08 	lds	r24, 0x086F
    be36:	90 e0       	ldi	r25, 0x00	; 0
    be38:	01 2e       	mov	r0, r17
    be3a:	02 c0       	rjmp	.+4      	; 0xbe40 <GSM_Cycle+0xdde>
    be3c:	95 95       	asr	r25
    be3e:	87 95       	ror	r24
    be40:	0a 94       	dec	r0
    be42:	e2 f7       	brpl	.-8      	; 0xbe3c <GSM_Cycle+0xdda>
    be44:	80 ff       	sbrs	r24, 0
    be46:	12 c0       	rjmp	.+36     	; 0xbe6c <GSM_Cycle+0xe0a>
					TempNum++;
    be48:	1f 5f       	subi	r17, 0xFF	; 255
    be4a:	10 93 e7 03 	sts	0x03E7, r17
					if(TempNum>3){
    be4e:	14 30       	cpi	r17, 0x04	; 4
    be50:	08 f4       	brcc	.+2      	; 0xbe54 <GSM_Cycle+0xdf2>
    be52:	53 c0       	rjmp	.+166    	; 0xbefa <GSM_Cycle+0xe98>
						StartTimer16(TD_GSM,150);
    be54:	66 e9       	ldi	r22, 0x96	; 150
    be56:	70 e0       	ldi	r23, 0x00	; 0
    be58:	80 91 5a 02 	lds	r24, 0x025A
    be5c:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
						GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    be60:	89 e3       	ldi	r24, 0x39	; 57
    be62:	80 93 27 06 	sts	0x0627, r24
						GPRS_FlgSz_Out = 0;
    be66:	10 92 43 09 	sts	0x0943, r1
    be6a:	47 c0       	rjmp	.+142    	; 0xbefa <GSM_Cycle+0xe98>
					}
				}
				else{
					if(GSM_Flag & (1<<flg_TxCStr)){
    be6c:	80 91 08 01 	lds	r24, 0x0108
    be70:	80 ff       	sbrs	r24, 0
    be72:	43 c0       	rjmp	.+134    	; 0xbefa <GSM_Cycle+0xe98>
						if(Timer16Stopp(TD_GSM)){	//     UDP
    be74:	80 91 5a 02 	lds	r24, 0x025A
    be78:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    be7c:	88 23       	and	r24, r24
    be7e:	e9 f1       	breq	.+122    	; 0xbefa <GSM_Cycle+0xe98>
							GSMTxSz = strlen_P(AT_CIPSEND);
    be80:	8b e0       	ldi	r24, 0x0B	; 11
    be82:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, AT_CIPSEND);
    be86:	84 e8       	ldi	r24, 0x84	; 132
    be88:	9d e4       	ldi	r25, 0x4D	; 77
    be8a:	9f 93       	push	r25
    be8c:	8f 93       	push	r24
    be8e:	09 e3       	ldi	r16, 0x39	; 57
    be90:	1c e0       	ldi	r17, 0x0C	; 12
    be92:	1f 93       	push	r17
    be94:	0f 93       	push	r16
    be96:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
							sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)TempNum, (unsigned int)(GPRS_FlgSz_Out));
    be9a:	80 91 57 09 	lds	r24, 0x0957
    be9e:	90 91 43 09 	lds	r25, 0x0943
    bea2:	1f 92       	push	r1
    bea4:	9f 93       	push	r25
    bea6:	90 91 e7 03 	lds	r25, 0x03E7
    beaa:	1f 92       	push	r1
    beac:	9f 93       	push	r25
    beae:	24 ed       	ldi	r18, 0xD4	; 212
    beb0:	31 e0       	ldi	r19, 0x01	; 1
    beb2:	3f 93       	push	r19
    beb4:	2f 93       	push	r18
    beb6:	90 e0       	ldi	r25, 0x00	; 0
    beb8:	87 5c       	subi	r24, 0xC7	; 199
    beba:	93 4f       	sbci	r25, 0xF3	; 243
    bebc:	9f 93       	push	r25
    bebe:	8f 93       	push	r24
    bec0:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
							GSMTxSz = strlen(GSM_TxStr);
    bec4:	f8 01       	movw	r30, r16
    bec6:	01 90       	ld	r0, Z+
    bec8:	00 20       	and	r0, r0
    beca:	e9 f7       	brne	.-6      	; 0xbec6 <GSM_Cycle+0xe64>
    becc:	31 97       	sbiw	r30, 0x01	; 1
    bece:	e9 53       	subi	r30, 0x39	; 57
    bed0:	fc 40       	sbci	r31, 0x0C	; 12
    bed2:	e0 93 57 09 	sts	0x0957, r30
							GSM_SendFirstChar();
    bed6:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    beda:	64 ef       	ldi	r22, 0xF4	; 244
    bedc:	71 e0       	ldi	r23, 0x01	; 1
    bede:	80 91 5a 02 	lds	r24, 0x025A
    bee2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
							GSM_State++;
    bee6:	80 91 27 06 	lds	r24, 0x0627
    beea:	8f 5f       	subi	r24, 0xFF	; 255
    beec:	80 93 27 06 	sts	0x0627, r24
    bef0:	0f b6       	in	r0, 0x3f	; 63
    bef2:	f8 94       	cli
    bef4:	de bf       	out	0x3e, r29	; 62
    bef6:	0f be       	out	0x3f, r0	; 63
    bef8:	cd bf       	out	0x3d, r28	; 61
						}
					}
				}
			}
			if(GPRS_Protocol_Out == TCP){
    befa:	80 91 7c 09 	lds	r24, 0x097C
    befe:	81 30       	cpi	r24, 0x01	; 1
    bf00:	09 f0       	breq	.+2      	; 0xbf04 <GSM_Cycle+0xea2>
    bf02:	79 c5       	rjmp	.+2802   	; 0xc9f6 <GSM_Cycle+0x1994>
				if(GSM_Flag & (1<<flg_TxCStr)){
    bf04:	80 91 08 01 	lds	r24, 0x0108
    bf08:	80 ff       	sbrs	r24, 0
    bf0a:	75 c5       	rjmp	.+2794   	; 0xc9f6 <GSM_Cycle+0x1994>
					GSMTxSz = strlen_P(AT_CIPSEND);
    bf0c:	8b e0       	ldi	r24, 0x0B	; 11
    bf0e:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CIPSEND);
    bf12:	84 e8       	ldi	r24, 0x84	; 132
    bf14:	9d e4       	ldi	r25, 0x4D	; 77
    bf16:	9f 93       	push	r25
    bf18:	8f 93       	push	r24
    bf1a:	09 e3       	ldi	r16, 0x39	; 57
    bf1c:	1c e0       	ldi	r17, 0x0C	; 12
    bf1e:	1f 93       	push	r17
    bf20:	0f 93       	push	r16
    bf22:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
					sprintf(GSM_TxStr + GSMTxSz, "%u,%u\r",(unsigned int)GSM_ActiveConnection, (unsigned int)(GPRS_FlgSz_Out));
    bf26:	80 91 57 09 	lds	r24, 0x0957
    bf2a:	90 91 43 09 	lds	r25, 0x0943
    bf2e:	1f 92       	push	r1
    bf30:	9f 93       	push	r25
    bf32:	90 91 07 01 	lds	r25, 0x0107
    bf36:	1f 92       	push	r1
    bf38:	9f 93       	push	r25
    bf3a:	24 ed       	ldi	r18, 0xD4	; 212
    bf3c:	31 e0       	ldi	r19, 0x01	; 1
    bf3e:	3f 93       	push	r19
    bf40:	2f 93       	push	r18
    bf42:	90 e0       	ldi	r25, 0x00	; 0
    bf44:	87 5c       	subi	r24, 0xC7	; 199
    bf46:	93 4f       	sbci	r25, 0xF3	; 243
    bf48:	9f 93       	push	r25
    bf4a:	8f 93       	push	r24
    bf4c:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
					GSMTxSz = strlen(GSM_TxStr);
    bf50:	f8 01       	movw	r30, r16
    bf52:	01 90       	ld	r0, Z+
    bf54:	00 20       	and	r0, r0
    bf56:	e9 f7       	brne	.-6      	; 0xbf52 <GSM_Cycle+0xef0>
    bf58:	31 97       	sbiw	r30, 0x01	; 1
    bf5a:	e9 53       	subi	r30, 0x39	; 57
    bf5c:	fc 40       	sbci	r31, 0x0C	; 12
    bf5e:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    bf62:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    bf66:	64 ef       	ldi	r22, 0xF4	; 244
    bf68:	71 e0       	ldi	r23, 0x01	; 1
    bf6a:	80 91 5a 02 	lds	r24, 0x025A
    bf6e:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					GSM_State++;
    bf72:	80 91 27 06 	lds	r24, 0x0627
    bf76:	8f 5f       	subi	r24, 0xFF	; 255
    bf78:	80 93 27 06 	sts	0x0627, r24
    bf7c:	0f b6       	in	r0, 0x3f	; 63
    bf7e:	f8 94       	cli
    bf80:	de bf       	out	0x3e, r29	; 62
    bf82:	0f be       	out	0x3f, r0	; 63
    bf84:	cd bf       	out	0x3d, r28	; 61
    bf86:	37 c5       	rjmp	.+2670   	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_WAIT_Inv:
			//if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;

			if(GSM_Wait_Char('>', GSM_ServerIdle)) GSM_State++;
    bf88:	63 e3       	ldi	r22, 0x33	; 51
    bf8a:	8e e3       	ldi	r24, 0x3E	; 62
    bf8c:	0e 94 55 3b 	call	0x76aa	; 0x76aa <GSM_Wait_Char>
    bf90:	88 23       	and	r24, r24
    bf92:	29 f0       	breq	.+10     	; 0xbf9e <GSM_Cycle+0xf3c>
    bf94:	80 91 27 06 	lds	r24, 0x0627
    bf98:	8f 5f       	subi	r24, 0xFF	; 255
    bf9a:	80 93 27 06 	sts	0x0627, r24
			if(GSM_State == GSM_ServerIdle) GPRS_FlgSz_Out = 0;			
    bf9e:	80 91 27 06 	lds	r24, 0x0627
    bfa2:	83 33       	cpi	r24, 0x33	; 51
    bfa4:	09 f0       	breq	.+2      	; 0xbfa8 <GSM_Cycle+0xf46>
    bfa6:	27 c5       	rjmp	.+2638   	; 0xc9f6 <GSM_Cycle+0x1994>
    bfa8:	10 92 43 09 	sts	0x0943, r1
    bfac:	24 c5       	rjmp	.+2632   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_DATA:
			//	memcpy (void  dest, const void  src, size_t len)
			GSM_AddHeaderSendData(GPRS_Data_Out, GPRS_FlgSz_Out);
    bfae:	60 91 43 09 	lds	r22, 0x0943
    bfb2:	89 e3       	ldi	r24, 0x39	; 57
    bfb4:	9b e0       	ldi	r25, 0x0B	; 11
    bfb6:	0e 94 19 58 	call	0xb032	; 0xb032 <GSM_AddHeaderSendData>
			GSM_State++;
    bfba:	80 91 27 06 	lds	r24, 0x0627
    bfbe:	8f 5f       	subi	r24, 0xFF	; 255
    bfc0:	80 93 27 06 	sts	0x0627, r24
    bfc4:	18 c5       	rjmp	.+2608   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPSEND_SEND_OK:
//			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
			if(Timer16Stopp(TD_GSM)){
    bfc6:	80 91 5a 02 	lds	r24, 0x025A
    bfca:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    bfce:	88 23       	and	r24, r24
    bfd0:	29 f0       	breq	.+10     	; 0xbfdc <GSM_Cycle+0xf7a>
				GSM_State = GSM_ServerIdle;
    bfd2:	83 e3       	ldi	r24, 0x33	; 51
    bfd4:	80 93 27 06 	sts	0x0627, r24
				GPRS_FlgSz_Out = 0;
    bfd8:	10 92 43 09 	sts	0x0943, r1
			}

			if(GetStringFromFIFO()){
    bfdc:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    bfe0:	88 23       	and	r24, r24
    bfe2:	09 f4       	brne	.+2      	; 0xbfe6 <GSM_Cycle+0xf84>
    bfe4:	08 c5       	rjmp	.+2576   	; 0xc9f6 <GSM_Cycle+0x1994>
				if(GPRS_Protocol_Out == UDP){
    bfe6:	80 91 7c 09 	lds	r24, 0x097C
    bfea:	81 11       	cpse	r24, r1
    bfec:	27 c0       	rjmp	.+78     	; 0xc03c <GSM_Cycle+0xfda>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    bfee:	6a ee       	ldi	r22, 0xEA	; 234
    bff0:	7e e4       	ldi	r23, 0x4E	; 78
    bff2:	ce 01       	movw	r24, r28
    bff4:	01 96       	adiw	r24, 0x01	; 1
    bff6:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
					RightAnswer[0] = 0x30+TempNum;
    bffa:	80 91 e7 03 	lds	r24, 0x03E7
    bffe:	80 5d       	subi	r24, 0xD0	; 208
    c000:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c002:	6a e5       	ldi	r22, 0x5A	; 90
    c004:	ce 01       	movw	r24, r28
    c006:	01 96       	adiw	r24, 0x01	; 1
    c008:	0e 94 21 3b 	call	0x7642	; 0x7642 <GSM_Wait_Response>
    c00c:	88 23       	and	r24, r24
    c00e:	b1 f0       	breq	.+44     	; 0xc03c <GSM_Cycle+0xfda>
						StartTimer16(TD_GSM,500);//min~ 2 sec
    c010:	64 ef       	ldi	r22, 0xF4	; 244
    c012:	71 e0       	ldi	r23, 0x01	; 1
    c014:	80 91 5a 02 	lds	r24, 0x025A
    c018:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
						if(++TempNum>3){
    c01c:	80 91 e7 03 	lds	r24, 0x03E7
    c020:	8f 5f       	subi	r24, 0xFF	; 255
    c022:	80 93 e7 03 	sts	0x03E7, r24
    c026:	84 30       	cpi	r24, 0x04	; 4
    c028:	30 f0       	brcs	.+12     	; 0xc036 <GSM_Cycle+0xfd4>
							GSM_State = GSM_WAIT_CIPSEND_PAUSE;
    c02a:	89 e3       	ldi	r24, 0x39	; 57
    c02c:	80 93 27 06 	sts	0x0627, r24
							GPRS_FlgSz_Out = 0;
    c030:	10 92 43 09 	sts	0x0943, r1
    c034:	03 c0       	rjmp	.+6      	; 0xc03c <GSM_Cycle+0xfda>
						}
						else GSM_State = GSM_SEND_CIPSEND;
    c036:	85 e3       	ldi	r24, 0x35	; 53
    c038:	80 93 27 06 	sts	0x0627, r24
					}
				}
				if(GPRS_Protocol_Out == TCP){
    c03c:	80 91 7c 09 	lds	r24, 0x097C
    c040:	81 30       	cpi	r24, 0x01	; 1
    c042:	09 f0       	breq	.+2      	; 0xc046 <GSM_Cycle+0xfe4>
    c044:	d8 c4       	rjmp	.+2480   	; 0xc9f6 <GSM_Cycle+0x1994>
					char RightAnswer[sizeof(RESP_SEND_OK)];
					strcpy_P(RightAnswer, RESP_SEND_OK);
    c046:	6a ee       	ldi	r22, 0xEA	; 234
    c048:	7e e4       	ldi	r23, 0x4E	; 78
    c04a:	ce 01       	movw	r24, r28
    c04c:	01 96       	adiw	r24, 0x01	; 1
    c04e:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
					RightAnswer[0] = 0x30+GSM_ActiveConnection;
    c052:	80 91 07 01 	lds	r24, 0x0107
    c056:	80 5d       	subi	r24, 0xD0	; 208
    c058:	89 83       	std	Y+1, r24	; 0x01
					if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c05a:	6a e5       	ldi	r22, 0x5A	; 90
    c05c:	ce 01       	movw	r24, r28
    c05e:	01 96       	adiw	r24, 0x01	; 1
    c060:	0e 94 21 3b 	call	0x7642	; 0x7642 <GSM_Wait_Response>
    c064:	88 23       	and	r24, r24
    c066:	09 f4       	brne	.+2      	; 0xc06a <GSM_Cycle+0x1008>
    c068:	c6 c4       	rjmp	.+2444   	; 0xc9f6 <GSM_Cycle+0x1994>
						GPRS_FlgSz_Out = 0;
    c06a:	10 92 43 09 	sts	0x0943, r1
    c06e:	c3 c4       	rjmp	.+2438   	; 0xc9f6 <GSM_Cycle+0x1994>
					}
				}
			}	
			break;
		case GSM_WAIT_CIPSEND_PAUSE://        SMS
			if(Timer16Stopp(TD_GSM)){
    c070:	80 91 5a 02 	lds	r24, 0x025A
    c074:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c078:	88 23       	and	r24, r24
    c07a:	09 f4       	brne	.+2      	; 0xc07e <GSM_Cycle+0x101c>
    c07c:	bc c4       	rjmp	.+2424   	; 0xc9f6 <GSM_Cycle+0x1994>
				//GSM_State = GSM_ServerIdle;
				GSM_MultiCon = 0;
    c07e:	10 92 4b 0e 	sts	0x0E4B, r1
				if(sendsWithoutReconnect<3)
    c082:	80 91 5b 02 	lds	r24, 0x025B
    c086:	83 30       	cpi	r24, 0x03	; 3
    c088:	10 f4       	brcc	.+4      	; 0xc08e <GSM_Cycle+0x102c>
				{
					GSM_State = GSM_CIPSHUT;
    c08a:	82 e5       	ldi	r24, 0x52	; 82
    c08c:	03 c0       	rjmp	.+6      	; 0xc094 <GSM_Cycle+0x1032>
				}
				else{
					sendsWithoutReconnect=0;
    c08e:	10 92 5b 02 	sts	0x025B, r1
					GSM_State = GSM_CIPSHUT_;
    c092:	84 e5       	ldi	r24, 0x54	; 84
    c094:	80 93 27 06 	sts	0x0627, r24
				}
				sendsWithoutReconnect++;
    c098:	80 91 5b 02 	lds	r24, 0x025B
    c09c:	8f 5f       	subi	r24, 0xFF	; 255
    c09e:	80 93 5b 02 	sts	0x025B, r24
    c0a2:	a9 c4       	rjmp	.+2386   	; 0xc9f6 <GSM_Cycle+0x1994>

			}
			break;
		//------------------------
		case GSM_CIPSHUT:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c0a4:	68 ee       	ldi	r22, 0xE8	; 232
    c0a6:	73 e0       	ldi	r23, 0x03	; 3
    c0a8:	8b e5       	ldi	r24, 0x5B	; 91
    c0aa:	9d e4       	ldi	r25, 0x4D	; 77
    c0ac:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c0b0:	80 91 27 06 	lds	r24, 0x0627
    c0b4:	8f 5f       	subi	r24, 0xFF	; 255
    c0b6:	80 93 27 06 	sts	0x0627, r24
    c0ba:	9d c4       	rjmp	.+2362   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_ShutWait:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State = GSM_SEND_CIPMUX;
    c0bc:	6a e5       	ldi	r22, 0x5A	; 90
    c0be:	87 ec       	ldi	r24, 0xC7	; 199
    c0c0:	9e e4       	ldi	r25, 0x4E	; 78
    c0c2:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c0c6:	88 23       	and	r24, r24
    c0c8:	09 f4       	brne	.+2      	; 0xc0cc <GSM_Cycle+0x106a>
    c0ca:	95 c4       	rjmp	.+2346   	; 0xc9f6 <GSM_Cycle+0x1994>
    c0cc:	83 e1       	ldi	r24, 0x13	; 19
    c0ce:	80 93 27 06 	sts	0x0627, r24
    c0d2:	91 c4       	rjmp	.+2338   	; 0xc9f6 <GSM_Cycle+0x1994>
		//------------------------


				//------------------------  GPRS
		case GSM_CIPSHUT_:
			GSM_Execute_Command(AT_CIPSHUT, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c0d4:	68 ee       	ldi	r22, 0xE8	; 232
    c0d6:	73 e0       	ldi	r23, 0x03	; 3
    c0d8:	8b e5       	ldi	r24, 0x5B	; 91
    c0da:	9d e4       	ldi	r25, 0x4D	; 77
    c0dc:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c0e0:	80 91 27 06 	lds	r24, 0x0627
    c0e4:	8f 5f       	subi	r24, 0xFF	; 255
    c0e6:	80 93 27 06 	sts	0x0627, r24
    c0ea:	85 c4       	rjmp	.+2314   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_ShutWait_:
			if(GSM_Wait_Response_P(RESP_SHUT_OK, GSM_ReStart1)) GSM_State++;
    c0ec:	6a e5       	ldi	r22, 0x5A	; 90
    c0ee:	87 ec       	ldi	r24, 0xC7	; 199
    c0f0:	9e e4       	ldi	r25, 0x4E	; 78
    c0f2:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c0f6:	88 23       	and	r24, r24
    c0f8:	09 f4       	brne	.+2      	; 0xc0fc <GSM_Cycle+0x109a>
    c0fa:	7d c4       	rjmp	.+2298   	; 0xc9f6 <GSM_Cycle+0x1994>
    c0fc:	80 91 27 06 	lds	r24, 0x0627
    c100:	8f 5f       	subi	r24, 0xFF	; 255
    c102:	80 93 27 06 	sts	0x0627, r24
    c106:	77 c4       	rjmp	.+2286   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_CGATT0:
			GSM_Execute_Command(AT_CGATT_0, 1000*GSM_DEBUG_DELAY); GSM_State++;
    c108:	68 ee       	ldi	r22, 0xE8	; 232
    c10a:	73 e0       	ldi	r23, 0x03	; 3
    c10c:	80 e5       	ldi	r24, 0x50	; 80
    c10e:	9d e4       	ldi	r25, 0x4D	; 77
    c110:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c114:	80 91 27 06 	lds	r24, 0x0627
    c118:	8f 5f       	subi	r24, 0xFF	; 255
    c11a:	80 93 27 06 	sts	0x0627, r24
    c11e:	6b c4       	rjmp	.+2262   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CGATT0_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c120:	6a e5       	ldi	r22, 0x5A	; 90
    c122:	82 e2       	ldi	r24, 0x22	; 34
    c124:	9f e4       	ldi	r25, 0x4F	; 79
    c126:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c12a:	88 23       	and	r24, r24
    c12c:	09 f4       	brne	.+2      	; 0xc130 <GSM_Cycle+0x10ce>
    c12e:	63 c4       	rjmp	.+2246   	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_GSM, 1000);
    c130:	68 ee       	ldi	r22, 0xE8	; 232
    c132:	73 e0       	ldi	r23, 0x03	; 3
    c134:	80 91 5a 02 	lds	r24, 0x025A
    c138:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			 	GSM_State = GSM_SEND_CIPMUX;
    c13c:	83 e1       	ldi	r24, 0x13	; 19
    c13e:	80 93 27 06 	sts	0x0627, r24
    c142:	59 c4       	rjmp	.+2226   	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;

		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
    c144:	80 91 08 01 	lds	r24, 0x0108
    c148:	80 ff       	sbrs	r24, 0
    c14a:	55 c4       	rjmp	.+2218   	; 0xc9f6 <GSM_Cycle+0x1994>
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
    c14c:	60 91 e7 03 	lds	r22, 0x03E7
    c150:	9d e0       	ldi	r25, 0x0D	; 13
    c152:	69 9f       	mul	r22, r25
    c154:	b0 01       	movw	r22, r0
    c156:	11 24       	eor	r1, r1
    c158:	6d 51       	subi	r22, 0x1D	; 29
    c15a:	7f 4f       	sbci	r23, 0xFF	; 255
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    c15c:	4d e0       	ldi	r20, 0x0D	; 13
    c15e:	50 e0       	ldi	r21, 0x00	; 0
    c160:	89 e3       	ldi	r24, 0x39	; 57
    c162:	9c e0       	ldi	r25, 0x0C	; 12
    c164:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
				GSMTxSz = strlen(GSM_TxStr);
    c168:	e9 e3       	ldi	r30, 0x39	; 57
    c16a:	fc e0       	ldi	r31, 0x0C	; 12
    c16c:	01 90       	ld	r0, Z+
    c16e:	00 20       	and	r0, r0
    c170:	e9 f7       	brne	.-6      	; 0xc16c <GSM_Cycle+0x110a>
    c172:	31 97       	sbiw	r30, 0x01	; 1
    c174:	e9 53       	subi	r30, 0x39	; 57
    c176:	fc 40       	sbci	r31, 0x0C	; 12
    c178:	e0 93 57 09 	sts	0x0957, r30
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c17c:	80 e0       	ldi	r24, 0x00	; 0
		//------------------------
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
    c17e:	90 e0       	ldi	r25, 0x00	; 0
				for(uint8_t i=0; i<GSMTxSz; i++)
    c180:	20 91 57 09 	lds	r18, 0x0957
    c184:	82 17       	cp	r24, r18
    c186:	50 f4       	brcc	.+20     	; 0xc19c <GSM_Cycle+0x113a>
					if(GSM_TxStr[i] != '0') j++;
    c188:	e8 2f       	mov	r30, r24
    c18a:	f0 e0       	ldi	r31, 0x00	; 0
    c18c:	e7 5c       	subi	r30, 0xC7	; 199
    c18e:	f3 4f       	sbci	r31, 0xF3	; 243
    c190:	20 81       	ld	r18, Z
    c192:	20 33       	cpi	r18, 0x30	; 48
    c194:	09 f0       	breq	.+2      	; 0xc198 <GSM_Cycle+0x1136>
    c196:	9f 5f       	subi	r25, 0xFF	; 255
		case GSM_SEND_CMGS:
			if(GSM_Flag & (1<<flg_TxCStr)){			
				erbl(GSM_TxStr, SMS_Number+TempNum, MaxTelephN);
				GSMTxSz = strlen(GSM_TxStr);
				uint8_t j=0;
				for(uint8_t i=0; i<GSMTxSz; i++)
    c198:	8f 5f       	subi	r24, 0xFF	; 255
    c19a:	f2 cf       	rjmp	.-28     	; 0xc180 <GSM_Cycle+0x111e>
					if(GSM_TxStr[i] != '0') j++;
				if(j){
    c19c:	99 23       	and	r25, r25
    c19e:	09 f4       	brne	.+2      	; 0xc1a2 <GSM_Cycle+0x1140>
    c1a0:	4b c0       	rjmp	.+150    	; 0xc238 <GSM_Cycle+0x11d6>
					GSMTxSz = strlen_P(AT_CMGS);
    c1a2:	8a e0       	ldi	r24, 0x0A	; 10
    c1a4:	80 93 57 09 	sts	0x0957, r24
					sprintf_P(GSM_TxStr, AT_CMGS);
    c1a8:	89 e4       	ldi	r24, 0x49	; 73
    c1aa:	9e e4       	ldi	r25, 0x4E	; 78
    c1ac:	9f 93       	push	r25
    c1ae:	8f 93       	push	r24
    c1b0:	09 e3       	ldi	r16, 0x39	; 57
    c1b2:	1c e0       	ldi	r17, 0x0C	; 12
    c1b4:	1f 93       	push	r17
    c1b6:	0f 93       	push	r16
    c1b8:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
					erbl(GSM_TxStr+GSMTxSz, SMS_Number+TempNum, MaxTelephN);
    c1bc:	60 91 e7 03 	lds	r22, 0x03E7
    c1c0:	80 91 57 09 	lds	r24, 0x0957
    c1c4:	ed e0       	ldi	r30, 0x0D	; 13
    c1c6:	6e 9f       	mul	r22, r30
    c1c8:	b0 01       	movw	r22, r0
    c1ca:	11 24       	eor	r1, r1
    c1cc:	6d 51       	subi	r22, 0x1D	; 29
    c1ce:	7f 4f       	sbci	r23, 0xFF	; 255
    c1d0:	90 e0       	ldi	r25, 0x00	; 0
    c1d2:	4d e0       	ldi	r20, 0x0D	; 13
    c1d4:	50 e0       	ldi	r21, 0x00	; 0
    c1d6:	87 5c       	subi	r24, 0xC7	; 199
    c1d8:	93 4f       	sbci	r25, 0xF3	; 243
    c1da:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
					GSMTxSz = strlen(GSM_TxStr);
    c1de:	d8 01       	movw	r26, r16
    c1e0:	0d 90       	ld	r0, X+
    c1e2:	00 20       	and	r0, r0
    c1e4:	e9 f7       	brne	.-6      	; 0xc1e0 <GSM_Cycle+0x117e>
    c1e6:	11 97       	sbiw	r26, 0x01	; 1
    c1e8:	a9 53       	subi	r26, 0x39	; 57
    c1ea:	bc 40       	sbci	r27, 0x0C	; 12
    c1ec:	a0 93 57 09 	sts	0x0957, r26
					sprintf(GSM_TxStr + GSMTxSz, "\"\r");
    c1f0:	80 91 57 09 	lds	r24, 0x0957
    c1f4:	90 e0       	ldi	r25, 0x00	; 0
    c1f6:	68 ec       	ldi	r22, 0xC8	; 200
    c1f8:	71 e0       	ldi	r23, 0x01	; 1
    c1fa:	87 5c       	subi	r24, 0xC7	; 199
    c1fc:	93 4f       	sbci	r25, 0xF3	; 243
    c1fe:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
					GSMTxSz = strlen(GSM_TxStr);
    c202:	f8 01       	movw	r30, r16
    c204:	01 90       	ld	r0, Z+
    c206:	00 20       	and	r0, r0
    c208:	e9 f7       	brne	.-6      	; 0xc204 <GSM_Cycle+0x11a2>
    c20a:	31 97       	sbiw	r30, 0x01	; 1
    c20c:	e9 53       	subi	r30, 0x39	; 57
    c20e:	fc 40       	sbci	r31, 0x0C	; 12
    c210:	e0 93 57 09 	sts	0x0957, r30
					GSM_SendFirstChar();
    c214:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c218:	64 ef       	ldi	r22, 0xF4	; 244
    c21a:	71 e0       	ldi	r23, 0x01	; 1
    c21c:	80 91 5a 02 	lds	r24, 0x025A
    c220:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					GSM_State++;
    c224:	80 91 27 06 	lds	r24, 0x0627
    c228:	8f 5f       	subi	r24, 0xFF	; 255
    c22a:	80 93 27 06 	sts	0x0627, r24
    c22e:	0f 90       	pop	r0
    c230:	0f 90       	pop	r0
    c232:	0f 90       	pop	r0
    c234:	0f 90       	pop	r0
    c236:	df c3       	rjmp	.+1982   	; 0xc9f6 <GSM_Cycle+0x1994>
				}
				else{
					TempNum++;
    c238:	80 91 e7 03 	lds	r24, 0x03E7
    c23c:	8f 5f       	subi	r24, 0xFF	; 255
    c23e:	80 93 e7 03 	sts	0x03E7, r24
					if(TempNum>=MaxTelephDirSz){
    c242:	83 30       	cpi	r24, 0x03	; 3
    c244:	08 f4       	brcc	.+2      	; 0xc248 <GSM_Cycle+0x11e6>
    c246:	d7 c3       	rjmp	.+1966   	; 0xc9f6 <GSM_Cycle+0x1994>
						//StartTimer16(TD_GSM,150);
						GSM_State = GSM_ServerIdle;
    c248:	83 e3       	ldi	r24, 0x33	; 51
    c24a:	80 93 27 06 	sts	0x0627, r24
						SMS_FlgSz_Out = 0;
    c24e:	10 92 67 09 	sts	0x0967, r1
    c252:	d1 c3       	rjmp	.+1954   	; 0xc9f6 <GSM_Cycle+0x1994>
					}					
				}
			}
			break;
		case GSM_WAIT_SMS_Inv:
			if(GSM_Wait_Char('>', GSM_ReStart1)) GSM_State++;
    c254:	6a e5       	ldi	r22, 0x5A	; 90
    c256:	8e e3       	ldi	r24, 0x3E	; 62
    c258:	0e 94 55 3b 	call	0x76aa	; 0x76aa <GSM_Wait_Char>
    c25c:	88 23       	and	r24, r24
    c25e:	09 f4       	brne	.+2      	; 0xc262 <GSM_Cycle+0x1200>
    c260:	ca c3       	rjmp	.+1940   	; 0xc9f6 <GSM_Cycle+0x1994>
    c262:	80 91 27 06 	lds	r24, 0x0627
    c266:	8f 5f       	subi	r24, 0xFF	; 255
    c268:	80 93 27 06 	sts	0x0627, r24
    c26c:	c4 c3       	rjmp	.+1928   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_SEND_SMS_DATA:
			SMS_Data_Out[SMS_FlgSz_Out] = 0x1A;	// SMS Data end - char Ctrl-Z
    c26e:	60 91 67 09 	lds	r22, 0x0967
    c272:	e6 2f       	mov	r30, r22
    c274:	f0 e0       	ldi	r31, 0x00	; 0
    c276:	e6 52       	subi	r30, 0x26	; 38
    c278:	f7 4f       	sbci	r31, 0xF7	; 247
    c27a:	8a e1       	ldi	r24, 0x1A	; 26
    c27c:	80 83       	st	Z, r24
			GSM_SendData((uint8_t *)SMS_Data_Out, SMS_FlgSz_Out+1);
    c27e:	6f 5f       	subi	r22, 0xFF	; 255
    c280:	8a ed       	ldi	r24, 0xDA	; 218
    c282:	98 e0       	ldi	r25, 0x08	; 8
    c284:	0e 94 25 58 	call	0xb04a	; 0xb04a <GSM_SendData>
			GSM_State++;
    c288:	80 91 27 06 	lds	r24, 0x0627
    c28c:	8f 5f       	subi	r24, 0xFF	; 255
    c28e:	80 93 27 06 	sts	0x0627, r24
    c292:	b1 c3       	rjmp	.+1890   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;		
		case GSM_WAIT_CMGS_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c294:	6a e5       	ldi	r22, 0x5A	; 90
    c296:	82 e2       	ldi	r24, 0x22	; 34
    c298:	9f e4       	ldi	r25, 0x4F	; 79
    c29a:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c29e:	88 23       	and	r24, r24
    c2a0:	09 f4       	brne	.+2      	; 0xc2a4 <GSM_Cycle+0x1242>
    c2a2:	a9 c3       	rjmp	.+1874   	; 0xc9f6 <GSM_Cycle+0x1994>
				if(++TempNum>=MaxTelephDirSz){
    c2a4:	80 91 e7 03 	lds	r24, 0x03E7
    c2a8:	8f 5f       	subi	r24, 0xFF	; 255
    c2aa:	80 93 e7 03 	sts	0x03E7, r24
    c2ae:	83 30       	cpi	r24, 0x03	; 3
    c2b0:	30 f0       	brcs	.+12     	; 0xc2be <GSM_Cycle+0x125c>
					GSM_State = GSM_ServerIdle;
    c2b2:	83 e3       	ldi	r24, 0x33	; 51
    c2b4:	80 93 27 06 	sts	0x0627, r24
					SMS_FlgSz_Out = 0;
    c2b8:	10 92 67 09 	sts	0x0967, r1
    c2bc:	9c c3       	rjmp	.+1848   	; 0xc9f6 <GSM_Cycle+0x1994>
					//StartTimer16(TD_GSM,150);
				}
				else GSM_State = GSM_SEND_CMGS;
    c2be:	8a e3       	ldi	r24, 0x3A	; 58
    c2c0:	80 93 27 06 	sts	0x0627, r24
    c2c4:	98 c3       	rjmp	.+1840   	; 0xc9f6 <GSM_Cycle+0x1994>
			}			
			break;
		//------------------------		
		case GSM_TCP_CLIENT_CONNECT: 
			//    IP			
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
    c2c6:	8d e3       	ldi	r24, 0x3D	; 61
    c2c8:	9d e0       	ldi	r25, 0x0D	; 13
    c2ca:	9f 93       	push	r25
    c2cc:	8f 93       	push	r24
    c2ce:	8c e3       	ldi	r24, 0x3C	; 60
    c2d0:	9d e0       	ldi	r25, 0x0D	; 13
    c2d2:	9f 93       	push	r25
    c2d4:	8f 93       	push	r24
    c2d6:	8b e3       	ldi	r24, 0x3B	; 59
    c2d8:	9d e0       	ldi	r25, 0x0D	; 13
    c2da:	9f 93       	push	r25
    c2dc:	8f 93       	push	r24
    c2de:	8a e3       	ldi	r24, 0x3A	; 58
    c2e0:	9d e0       	ldi	r25, 0x0D	; 13
    c2e2:	9f 93       	push	r25
    c2e4:	8f 93       	push	r24
    c2e6:	8f e3       	ldi	r24, 0x3F	; 63
    c2e8:	93 e0       	ldi	r25, 0x03	; 3
    c2ea:	9f 93       	push	r25
    c2ec:	8f 93       	push	r24
    c2ee:	89 e8       	ldi	r24, 0x89	; 137
    c2f0:	99 e0       	ldi	r25, 0x09	; 9
    c2f2:	9f 93       	push	r25
    c2f4:	8f 93       	push	r24
    c2f6:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
    c2fa:	10 92 e7 03 	sts	0x03E7, r1
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
					TempNum = 1;
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c2fe:	10 91 3d 0d 	lds	r17, 0x0D3D
    c302:	70 90 3c 0d 	lds	r7, 0x0D3C
    c306:	60 90 3b 0d 	lds	r6, 0x0D3B
    c30a:	50 90 3a 0d 	lds	r5, 0x0D3A
    c30e:	00 e1       	ldi	r16, 0x10	; 16
    c310:	80 2e       	mov	r8, r16
    c312:	01 e0       	ldi	r16, 0x01	; 1
    c314:	90 2e       	mov	r9, r16
    c316:	0f b6       	in	r0, 0x3f	; 63
    c318:	f8 94       	cli
    c31a:	de bf       	out	0x3e, r29	; 62
    c31c:	0f be       	out	0x3f, r0	; 63
    c31e:	cd bf       	out	0x3d, r28	; 61
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
				if(IP_E_compare_Const(&TCP_ClientIP[i],255,255,255,255)){	// Anybody may coonect
    c320:	0f ef       	ldi	r16, 0xFF	; 255
    c322:	2f ef       	ldi	r18, 0xFF	; 255
    c324:	4f ef       	ldi	r20, 0xFF	; 255
    c326:	6f ef       	ldi	r22, 0xFF	; 255
    c328:	c4 01       	movw	r24, r8
    c32a:	0e 94 d7 39 	call	0x73ae	; 0x73ae <IP_E_compare_Const>
    c32e:	88 23       	and	r24, r24
    c330:	21 f0       	breq	.+8      	; 0xc33a <GSM_Cycle+0x12d8>
					TempNum = 1;
    c332:	81 e0       	ldi	r24, 0x01	; 1
    c334:	80 93 e7 03 	sts	0x03E7, r24
    c338:	1a c0       	rjmp	.+52     	; 0xc36e <GSM_Cycle+0x130c>
					break;
				}
				if(!IP_E_compare_Const(&TCP_ClientIP[i],0,0,0,0)){
    c33a:	00 e0       	ldi	r16, 0x00	; 0
    c33c:	20 e0       	ldi	r18, 0x00	; 0
    c33e:	40 e0       	ldi	r20, 0x00	; 0
    c340:	60 e0       	ldi	r22, 0x00	; 0
    c342:	c4 01       	movw	r24, r8
    c344:	0e 94 d7 39 	call	0x73ae	; 0x73ae <IP_E_compare_Const>
    c348:	81 11       	cpse	r24, r1
    c34a:	09 c0       	rjmp	.+18     	; 0xc35e <GSM_Cycle+0x12fc>
					if(IP_E_compare_Const(&TCP_ClientIP[i], GSM_ClientIP.IP1, GSM_ClientIP.IP2, GSM_ClientIP.IP3, GSM_ClientIP.IP4)){
    c34c:	01 2f       	mov	r16, r17
    c34e:	27 2d       	mov	r18, r7
    c350:	46 2d       	mov	r20, r6
    c352:	65 2d       	mov	r22, r5
    c354:	c4 01       	movw	r24, r8
    c356:	0e 94 d7 39 	call	0x73ae	; 0x73ae <IP_E_compare_Const>
    c35a:	81 11       	cpse	r24, r1
    c35c:	ea cf       	rjmp	.-44     	; 0xc332 <GSM_Cycle+0x12d0>
    c35e:	34 e0       	ldi	r19, 0x04	; 4
    c360:	83 0e       	add	r8, r19
    c362:	91 1c       	adc	r9, r1
			sscanf_P(GSM_RxStr,PSTR("REMOTE IP:%hhu.%hhu.%hhu.%hhu"),
				(unsigned char*)&GSM_ClientIP.IP1, (unsigned char*)&GSM_ClientIP.IP2, (unsigned char*)&GSM_ClientIP.IP3, (unsigned char*)&GSM_ClientIP.IP4);
			
			//  IP   
			TempNum = 0;
			for(uint8_t i=0; i<4; i++){
    c364:	80 e2       	ldi	r24, 0x20	; 32
    c366:	88 16       	cp	r8, r24
    c368:	81 e0       	ldi	r24, 0x01	; 1
    c36a:	98 06       	cpc	r9, r24
    c36c:	c9 f6       	brne	.-78     	; 0xc320 <GSM_Cycle+0x12be>
						TempNum = 1;
						break;
					}
				}
			}
			if(TempNum){
    c36e:	80 91 e7 03 	lds	r24, 0x03E7
    c372:	88 23       	and	r24, r24
    c374:	89 f0       	breq	.+34     	; 0xc398 <GSM_Cycle+0x1336>
				GSM_State = GSM_ServerIdle;
    c376:	83 e3       	ldi	r24, 0x33	; 51
    c378:	80 93 27 06 	sts	0x0627, r24
				GSM_ActiveConnection = GSM_Temp;
    c37c:	80 91 e6 03 	lds	r24, 0x03E6
    c380:	80 93 07 01 	sts	0x0107, r24
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    c384:	8e e0       	ldi	r24, 0x0E	; 14
    c386:	91 e0       	ldi	r25, 0x01	; 1
    c388:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c38c:	bc 01       	movw	r22, r24
    c38e:	80 91 59 02 	lds	r24, 0x0259
    c392:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
    c396:	2f c3       	rjmp	.+1630   	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			else GSM_State = GSM_TCP_CLIENT_DISCONNECT;
    c398:	8f e3       	ldi	r24, 0x3F	; 63
    c39a:	80 93 27 06 	sts	0x0627, r24
    c39e:	2b c3       	rjmp	.+1622   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_TCP_CLIENT_DISCONNECT:
			// Not allowaeble Client IP			
			if(GSM_Flag & (1<<flg_TxCStr)){
    c3a0:	80 91 08 01 	lds	r24, 0x0108
    c3a4:	80 ff       	sbrs	r24, 0
    c3a6:	27 c3       	rjmp	.+1614   	; 0xc9f6 <GSM_Cycle+0x1994>
				GSMTxSz = strlen_P(AT_CIPCLOSE_1);
    c3a8:	8f e0       	ldi	r24, 0x0F	; 15
    c3aa:	80 93 57 09 	sts	0x0957, r24
				sprintf_P(GSM_TxStr, AT_CIPCLOSE_1);
    c3ae:	84 e7       	ldi	r24, 0x74	; 116
    c3b0:	9d e4       	ldi	r25, 0x4D	; 77
    c3b2:	9f 93       	push	r25
    c3b4:	8f 93       	push	r24
    c3b6:	89 e3       	ldi	r24, 0x39	; 57
    c3b8:	9c e0       	ldi	r25, 0x0C	; 12
    c3ba:	9f 93       	push	r25
    c3bc:	8f 93       	push	r24
    c3be:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
				sprintf(GSM_TxStr + GSMTxSz, "\r");
    c3c2:	80 91 57 09 	lds	r24, 0x0957
    c3c6:	90 e0       	ldi	r25, 0x00	; 0
    c3c8:	69 ec       	ldi	r22, 0xC9	; 201
    c3ca:	71 e0       	ldi	r23, 0x01	; 1
    c3cc:	87 5c       	subi	r24, 0xC7	; 199
    c3ce:	93 4f       	sbci	r25, 0xF3	; 243
    c3d0:	0e 94 da 6c 	call	0xd9b4	; 0xd9b4 <strcpy>
				GSMTxSz++;
    c3d4:	80 91 57 09 	lds	r24, 0x0957
    c3d8:	8f 5f       	subi	r24, 0xFF	; 255
    c3da:	80 93 57 09 	sts	0x0957, r24
				GSM_TxStr[12] = 0x30 + GSM_Temp;
    c3de:	80 91 e6 03 	lds	r24, 0x03E6
    c3e2:	80 5d       	subi	r24, 0xD0	; 208
    c3e4:	80 93 45 0c 	sts	0x0C45, r24
				GSM_SendFirstChar();
    c3e8:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
				StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c3ec:	64 ef       	ldi	r22, 0xF4	; 244
    c3ee:	71 e0       	ldi	r23, 0x01	; 1
    c3f0:	80 91 5a 02 	lds	r24, 0x025A
    c3f4:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State++;
    c3f8:	80 91 27 06 	lds	r24, 0x0627
    c3fc:	8f 5f       	subi	r24, 0xFF	; 255
    c3fe:	80 93 27 06 	sts	0x0627, r24
    c402:	0f 90       	pop	r0
    c404:	0f 90       	pop	r0
    c406:	0f 90       	pop	r0
    c408:	0f 90       	pop	r0
    c40a:	f5 c2       	rjmp	.+1514   	; 0xc9f6 <GSM_Cycle+0x1994>
			}			 
			break;			
		case GSM_WAIT_CLIENT_CIPCLOSED:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c40c:	80 91 5a 02 	lds	r24, 0x025A
    c410:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c414:	88 23       	and	r24, r24
    c416:	19 f0       	breq	.+6      	; 0xc41e <GSM_Cycle+0x13bc>
    c418:	8a e5       	ldi	r24, 0x5A	; 90
    c41a:	80 93 27 06 	sts	0x0627, r24
			if(GetStringFromFIFO()){
    c41e:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    c422:	88 23       	and	r24, r24
    c424:	09 f4       	brne	.+2      	; 0xc428 <GSM_Cycle+0x13c6>
    c426:	e7 c2       	rjmp	.+1486   	; 0xc9f6 <GSM_Cycle+0x1994>
				char RightAnswer[sizeof(RESP_CLOSE_OK_FAST)];
				strcpy_P(RightAnswer, RESP_CLOSE_OK_FAST);
    c428:	65 ed       	ldi	r22, 0xD5	; 213
    c42a:	7e e4       	ldi	r23, 0x4E	; 78
    c42c:	ce 01       	movw	r24, r28
    c42e:	01 96       	adiw	r24, 0x01	; 1
    c430:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
				RightAnswer[0] = 0x30+GSM_Temp;
    c434:	80 91 e6 03 	lds	r24, 0x03E6
    c438:	80 5d       	subi	r24, 0xD0	; 208
    c43a:	89 83       	std	Y+1, r24	; 0x01
				if(GSM_Wait_Response(RightAnswer, GSM_ReStart1)){
    c43c:	6a e5       	ldi	r22, 0x5A	; 90
    c43e:	ce 01       	movw	r24, r28
    c440:	01 96       	adiw	r24, 0x01	; 1
    c442:	0e 94 21 3b 	call	0x7642	; 0x7642 <GSM_Wait_Response>
    c446:	88 23       	and	r24, r24
    c448:	09 f4       	brne	.+2      	; 0xc44c <GSM_Cycle+0x13ea>
    c44a:	d5 c2       	rjmp	.+1450   	; 0xc9f6 <GSM_Cycle+0x1994>
					GSM_State = GSM_ServerIdle;
    c44c:	83 e3       	ldi	r24, 0x33	; 51
    c44e:	80 93 27 06 	sts	0x0627, r24
					if( (GSM_ActiveConnection != NO_CONNECTION) && Timer16Stopp(TD_TCP_Connect) ){	// -  
    c452:	80 91 07 01 	lds	r24, 0x0107
    c456:	8f 3f       	cpi	r24, 0xFF	; 255
    c458:	09 f4       	brne	.+2      	; 0xc45c <GSM_Cycle+0x13fa>
    c45a:	cd c2       	rjmp	.+1434   	; 0xc9f6 <GSM_Cycle+0x1994>
    c45c:	80 91 59 02 	lds	r24, 0x0259
    c460:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c464:	88 23       	and	r24, r24
    c466:	09 f4       	brne	.+2      	; 0xc46a <GSM_Cycle+0x1408>
    c468:	c6 c2       	rjmp	.+1420   	; 0xc9f6 <GSM_Cycle+0x1994>
						GSM_ActiveConnection = NO_CONNECTION;
    c46a:	8f ef       	ldi	r24, 0xFF	; 255
    c46c:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c470:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c474:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c478:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c47c:	10 92 3d 0d 	sts	0x0D3D, r1
    c480:	ba c2       	rjmp	.+1396   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		//------------------------
		case GSM_RECIEVE:
			{ 
				uint8_t TempConnect;
				sscanf_P(GSM_RxStr,PSTR("+RECEIVE,%hhu,%hhu"),(unsigned char*)&TempConnect, (unsigned char*)&GSM_Temp);
    c482:	86 ee       	ldi	r24, 0xE6	; 230
    c484:	93 e0       	ldi	r25, 0x03	; 3
    c486:	9f 93       	push	r25
    c488:	8f 93       	push	r24
    c48a:	ce 01       	movw	r24, r28
    c48c:	01 96       	adiw	r24, 0x01	; 1
    c48e:	9f 93       	push	r25
    c490:	8f 93       	push	r24
    c492:	8c e2       	ldi	r24, 0x2C	; 44
    c494:	93 e0       	ldi	r25, 0x03	; 3
    c496:	9f 93       	push	r25
    c498:	8f 93       	push	r24
    c49a:	89 e8       	ldi	r24, 0x89	; 137
    c49c:	99 e0       	ldi	r25, 0x09	; 9
    c49e:	9f 93       	push	r25
    c4a0:	8f 93       	push	r24
    c4a2:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
				//     GSM_ActiveConnection //    
				if( (TempConnect == GSM_ActiveConnection) /*&& (GSM_Temp <= GPRS_In_MaxSz) && (GSM_Temp >= 7)*/ ){
    c4a6:	0f b6       	in	r0, 0x3f	; 63
    c4a8:	f8 94       	cli
    c4aa:	de bf       	out	0x3e, r29	; 62
    c4ac:	0f be       	out	0x3f, r0	; 63
    c4ae:	cd bf       	out	0x3d, r28	; 61
    c4b0:	99 81       	ldd	r25, Y+1	; 0x01
    c4b2:	80 91 07 01 	lds	r24, 0x0107
    c4b6:	98 13       	cpse	r25, r24
    c4b8:	0c c0       	rjmp	.+24     	; 0xc4d2 <GSM_Cycle+0x1470>
					StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c4ba:	64 ef       	ldi	r22, 0xF4	; 244
    c4bc:	71 e0       	ldi	r23, 0x01	; 1
    c4be:	80 91 5a 02 	lds	r24, 0x025A
    c4c2:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					GSM_State++;
    c4c6:	80 91 27 06 	lds	r24, 0x0627
    c4ca:	8f 5f       	subi	r24, 0xFF	; 255
    c4cc:	80 93 27 06 	sts	0x0627, r24
    c4d0:	92 c2       	rjmp	.+1316   	; 0xc9f6 <GSM_Cycle+0x1994>
					break;
				}
				GSM_State = GSM_ServerIdle;
    c4d2:	83 e3       	ldi	r24, 0x33	; 51
    c4d4:	80 93 27 06 	sts	0x0627, r24
    c4d8:	8e c2       	rjmp	.+1308   	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_RECIEVE_DATA:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;			
    c4da:	80 91 5a 02 	lds	r24, 0x025A
    c4de:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c4e2:	88 23       	and	r24, r24
    c4e4:	19 f0       	breq	.+6      	; 0xc4ec <GSM_Cycle+0x148a>
    c4e6:	8a e5       	ldi	r24, 0x5A	; 90
    c4e8:	80 93 27 06 	sts	0x0627, r24
				memcpy(GPRS_Data_In, GSM_RxStr, GPRS_FlgSz_In);
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   

				GSM_State = GSM_ServerIdle;
			}*/
			GPRS_FlgSz_In = GSM_Temp;
    c4ec:	80 91 e6 03 	lds	r24, 0x03E6
    c4f0:	80 93 5e 09 	sts	0x095E, r24

			GSM_State = GSM_ServerIdle;
    c4f4:	83 e3       	ldi	r24, 0x33	; 51
    c4f6:	80 93 27 06 	sts	0x0627, r24
    c4fa:	7d c2       	rjmp	.+1274   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		//------------------------
		case GSM_SEND_CIPCLOSE:
			GSM_Execute_Command(AT_CIPCLOSE, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c4fc:	60 e7       	ldi	r22, 0x70	; 112
    c4fe:	77 e1       	ldi	r23, 0x17	; 23
    c500:	86 e6       	ldi	r24, 0x66	; 102
    c502:	9d e4       	ldi	r25, 0x4D	; 77
    c504:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c508:	80 91 27 06 	lds	r24, 0x0627
    c50c:	8f 5f       	subi	r24, 0xFF	; 255
    c50e:	80 93 27 06 	sts	0x0627, r24
    c512:	71 c2       	rjmp	.+1250   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CIPCLOSE_OK:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_ReStart1;
    c514:	80 91 5a 02 	lds	r24, 0x025A
    c518:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c51c:	88 23       	and	r24, r24
    c51e:	19 f0       	breq	.+6      	; 0xc526 <GSM_Cycle+0x14c4>
    c520:	8a e5       	ldi	r24, 0x5A	; 90
    c522:	80 93 27 06 	sts	0x0627, r24
			//  
			if(GetStringFromFIFO()){
    c526:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    c52a:	88 23       	and	r24, r24
    c52c:	09 f4       	brne	.+2      	; 0xc530 <GSM_Cycle+0x14ce>
    c52e:	63 c2       	rjmp	.+1222   	; 0xc9f6 <GSM_Cycle+0x1994>
				if(!strcmp_P(GSM_RxStr, RESP_CLOSE_OK) || !strcmp_P(GSM_RxStr, URC_CLOSED + 2)){
    c530:	61 ee       	ldi	r22, 0xE1	; 225
    c532:	7e e4       	ldi	r23, 0x4E	; 78
    c534:	89 e8       	ldi	r24, 0x89	; 137
    c536:	99 e0       	ldi	r25, 0x09	; 9
    c538:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    c53c:	89 2b       	or	r24, r25
    c53e:	49 f0       	breq	.+18     	; 0xc552 <GSM_Cycle+0x14f0>
    c540:	62 e4       	ldi	r22, 0x42	; 66
    c542:	7f e4       	ldi	r23, 0x4F	; 79
    c544:	89 e8       	ldi	r24, 0x89	; 137
    c546:	99 e0       	ldi	r25, 0x09	; 9
    c548:	0e 94 68 6c 	call	0xd8d0	; 0xd8d0 <strcmp_P>
    c54c:	89 2b       	or	r24, r25
    c54e:	09 f0       	breq	.+2      	; 0xc552 <GSM_Cycle+0x14f0>
    c550:	52 c2       	rjmp	.+1188   	; 0xc9f6 <GSM_Cycle+0x1994>
					GSM_State = GSM_ServerIdle;
    c552:	83 e3       	ldi	r24, 0x33	; 51
    c554:	80 93 27 06 	sts	0x0627, r24
					GPRS_FlgSz_Out = 0;						
    c558:	10 92 43 09 	sts	0x0943, r1
    c55c:	4c c2       	rjmp	.+1176   	; 0xc9f6 <GSM_Cycle+0x1994>
		//------------------------

		/*NEW COMMIT*/
		//------------------------
		case GSM_ReStart1:
			GSM_PWRCNTRL_OFF();
    c55e:	0e 94 d6 2e 	call	0x5dac	; 0x5dac <GSM_PWRCNTRL_OFF>
			StartTimer16(TD_GSM,1000);
    c562:	68 ee       	ldi	r22, 0xE8	; 232
    c564:	73 e0       	ldi	r23, 0x03	; 3
    c566:	80 91 5a 02 	lds	r24, 0x025A
    c56a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			RxBufOverFlow = 0;
    c56e:	10 92 39 0d 	sts	0x0D39, r1
//			InitFIFO();
			SMS_FlgSz_Out = 0;	// ..          -  
    c572:	10 92 67 09 	sts	0x0967, r1
			GSM_ActiveConnection = NO_CONNECTION;
    c576:	8f ef       	ldi	r24, 0xFF	; 255
    c578:	80 93 07 01 	sts	0x0107, r24
	uint8_t IP4;
} IP_Addr;

//~~~~~~~~~~~~~~
void SetIP(IP_Addr* IP, uint8_t IP1, uint8_t IP2, uint8_t IP3, uint8_t IP4){
	IP->IP1 = IP1;
    c57c:	10 92 3a 0d 	sts	0x0D3A, r1
	IP->IP2 = IP2;
    c580:	10 92 3b 0d 	sts	0x0D3B, r1
	IP->IP3 = IP3;
    c584:	10 92 3c 0d 	sts	0x0D3C, r1
	IP->IP4 = IP4;
    c588:	10 92 3d 0d 	sts	0x0D3D, r1
			SetIP(&GSM_ClientIP,0,0,0,0);
			GSM_Flag |=(1<<flg_TxCStr);
    c58c:	80 91 08 01 	lds	r24, 0x0108
    c590:	81 60       	ori	r24, 0x01	; 1
    c592:	80 93 08 01 	sts	0x0108, r24
			GSM_State++;
    c596:	80 91 27 06 	lds	r24, 0x0627
    c59a:	8f 5f       	subi	r24, 0xFF	; 255
    c59c:	80 93 27 06 	sts	0x0627, r24
    c5a0:	2a c2       	rjmp	.+1108   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_ReStart2:
			if(Timer16Stopp(TD_GSM)){
    c5a2:	80 91 5a 02 	lds	r24, 0x025A
    c5a6:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c5aa:	88 23       	and	r24, r24
    c5ac:	09 f4       	brne	.+2      	; 0xc5b0 <GSM_Cycle+0x154e>
    c5ae:	23 c2       	rjmp	.+1094   	; 0xc9f6 <GSM_Cycle+0x1994>
				GSM_State = GSM_PowerOn;
    c5b0:	10 92 27 06 	sts	0x0627, r1
    c5b4:	20 c2       	rjmp	.+1088   	; 0xc9f6 <GSM_Cycle+0x1994>
		//------------------------


		//------------------------  
		case GSM_SEND_SERVERCLOSE:
			GSM_Execute_Command(AT_SERVERCLOSE, 500*GSM_DEBUG_DELAY); GSM_State++;
    c5b6:	64 ef       	ldi	r22, 0xF4	; 244
    c5b8:	71 e0       	ldi	r23, 0x01	; 1
    c5ba:	81 ea       	ldi	r24, 0xA1	; 161
    c5bc:	9d e4       	ldi	r25, 0x4D	; 77
    c5be:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c5c2:	80 91 27 06 	lds	r24, 0x0627
    c5c6:	8f 5f       	subi	r24, 0xFF	; 255
    c5c8:	80 93 27 06 	sts	0x0627, r24
    c5cc:	14 c2       	rjmp	.+1064   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_SERVERCLOSE_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State++;
    c5ce:	6a e5       	ldi	r22, 0x5A	; 90
    c5d0:	82 e2       	ldi	r24, 0x22	; 34
    c5d2:	9f e4       	ldi	r25, 0x4F	; 79
    c5d4:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c5d8:	88 23       	and	r24, r24
    c5da:	09 f4       	brne	.+2      	; 0xc5de <GSM_Cycle+0x157c>
    c5dc:	0c c2       	rjmp	.+1048   	; 0xc9f6 <GSM_Cycle+0x1994>
    c5de:	80 91 27 06 	lds	r24, 0x0627
    c5e2:	8f 5f       	subi	r24, 0xFF	; 255
    c5e4:	80 93 27 06 	sts	0x0627, r24
    c5e8:	06 c2       	rjmp	.+1036   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_SERVER_CLOSE:
			if(GSM_Wait_Response_P(RESP_SERVER_CLOSE, GSM_ReStart1)) GSM_State = GSM_SEND_CIPSERVER;
    c5ea:	6a e5       	ldi	r22, 0x5A	; 90
    c5ec:	85 ef       	ldi	r24, 0xF5	; 245
    c5ee:	9e e4       	ldi	r25, 0x4E	; 78
    c5f0:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c5f4:	88 23       	and	r24, r24
    c5f6:	09 f4       	brne	.+2      	; 0xc5fa <GSM_Cycle+0x1598>
    c5f8:	fe c1       	rjmp	.+1020   	; 0xc9f6 <GSM_Cycle+0x1994>
    c5fa:	80 e3       	ldi	r24, 0x30	; 48
    c5fc:	80 93 27 06 	sts	0x0627, r24
    c600:	fa c1       	rjmp	.+1012   	; 0xc9f6 <GSM_Cycle+0x1994>
			break;

		//------------------------   GSM-
		case GSM_SEND_CSQ:
			GSM_Execute_Command(AT_CSQ, 500*GSM_DEBUG_DELAY); 
    c602:	64 ef       	ldi	r22, 0xF4	; 244
    c604:	71 e0       	ldi	r23, 0x01	; 1
    c606:	89 e4       	ldi	r24, 0x49	; 73
    c608:	9d e4       	ldi	r25, 0x4D	; 77
    c60a:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
			StartTimer16(TD_RSSI, 6000);
    c60e:	60 e7       	ldi	r22, 0x70	; 112
    c610:	77 e1       	ldi	r23, 0x17	; 23
    c612:	80 91 58 02 	lds	r24, 0x0258
    c616:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			GSM_State = GSM_ServerIdle;
    c61a:	83 e3       	ldi	r24, 0x33	; 51
    c61c:	80 93 27 06 	sts	0x0627, r24
    c620:	ea c1       	rjmp	.+980    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CSQ:
			GSM_RSSI = 255; GSM_BER = 255;
    c622:	8f ef       	ldi	r24, 0xFF	; 255
    c624:	80 93 25 06 	sts	0x0625, r24
    c628:	80 93 6c 09 	sts	0x096C, r24
			sscanf_P(GSM_RxStr,PSTR("+CSQ: %hhu,%hhu"), (unsigned char*)&GSM_RSSI, (unsigned char*)&GSM_BER);
    c62c:	8c e6       	ldi	r24, 0x6C	; 108
    c62e:	99 e0       	ldi	r25, 0x09	; 9
    c630:	9f 93       	push	r25
    c632:	8f 93       	push	r24
    c634:	85 e2       	ldi	r24, 0x25	; 37
    c636:	96 e0       	ldi	r25, 0x06	; 6
    c638:	9f 93       	push	r25
    c63a:	8f 93       	push	r24
    c63c:	8c e1       	ldi	r24, 0x1C	; 28
    c63e:	93 e0       	ldi	r25, 0x03	; 3
    c640:	9f 93       	push	r25
    c642:	8f 93       	push	r24
    c644:	89 e8       	ldi	r24, 0x89	; 137
    c646:	99 e0       	ldi	r25, 0x09	; 9
    c648:	9f 93       	push	r25
    c64a:	8f 93       	push	r24
    c64c:	0e 94 6f 6d 	call	0xdade	; 0xdade <sscanf_P>
			GSM_State = GSM_ServerIdle;
    c650:	83 e3       	ldi	r24, 0x33	; 51
    c652:	80 93 27 06 	sts	0x0627, r24
    c656:	0f b6       	in	r0, 0x3f	; 63
    c658:	f8 94       	cli
    c65a:	de bf       	out	0x3e, r29	; 62
    c65c:	0f be       	out	0x3f, r0	; 63
    c65e:	cd bf       	out	0x3d, r28	; 61
    c660:	ca c1       	rjmp	.+916    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		//------------------------

		case GSM_ProtocolMode:	//   4 
			Transparent_Application_state = WAIT_REQUEST;
    c662:	81 e0       	ldi	r24, 0x01	; 1
    c664:	80 93 52 09 	sts	0x0952, r24
			if(!UART_Soft){Transparent = 1;}else{Transparent = 0;}
    c668:	90 91 75 0a 	lds	r25, 0x0A75
    c66c:	91 11       	cpse	r25, r1
    c66e:	03 c0       	rjmp	.+6      	; 0xc676 <GSM_Cycle+0x1614>
    c670:	80 93 76 0a 	sts	0x0A76, r24
    c674:	02 c0       	rjmp	.+4      	; 0xc67a <GSM_Cycle+0x1618>
    c676:	10 92 76 0a 	sts	0x0A76, r1
				GSM_State = GSM_Swtch2CommandMode;
				Transparent_Application_state = RECONNECT;
				Transparent = 0;
				break;
			}*/
			if(Timer16Stopp(TCP_CONNECT_check_timer)){
    c67a:	80 91 40 0d 	lds	r24, 0x0D40
    c67e:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c682:	88 23       	and	r24, r24
    c684:	09 f4       	brne	.+2      	; 0xc688 <GSM_Cycle+0x1626>
    c686:	b7 c1       	rjmp	.+878    	; 0xc9f6 <GSM_Cycle+0x1994>
				GSM_State = GSM_Swtch2CommandMode;
    c688:	83 e6       	ldi	r24, 0x63	; 99
    c68a:	80 93 27 06 	sts	0x0627, r24
				Transparent_Application_state = CHECK_CONNECTION_STATE;
    c68e:	83 e0       	ldi	r24, 0x03	; 3
    c690:	80 93 52 09 	sts	0x0952, r24
				Transparent = 0;
    c694:	10 92 76 0a 	sts	0x0A76, r1
    c698:	ae c1       	rjmp	.+860    	; 0xc9f6 <GSM_Cycle+0x1994>

		case GSM_DataMode:
		
	
			// -----    
			if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End){	// if FIFO not empty
    c69a:	90 91 7b 08 	lds	r25, 0x087B
    c69e:	80 91 05 06 	lds	r24, 0x0605
    c6a2:	98 17       	cp	r25, r24
    c6a4:	49 f0       	breq	.+18     	; 0xc6b8 <GSM_Cycle+0x1656>
    c6a6:	8e e0       	ldi	r24, 0x0E	; 14
    c6a8:	91 e0       	ldi	r25, 0x01	; 1
    c6aa:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
				StartTimer16(TD_TCP_Connect, erw(&TCP_CONNECT_timeout));	//   
    c6ae:	bc 01       	movw	r22, r24
    c6b0:	80 91 59 02 	lds	r24, 0x0259
    c6b4:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			}
			if(AppProtocol != _HTTP){	//   HTTP    
    c6b8:	80 91 f4 09 	lds	r24, 0x09F4
    c6bc:	81 30       	cpi	r24, 0x01	; 1
    c6be:	71 f1       	breq	.+92     	; 0xc71c <GSM_Cycle+0x16ba>
				if(GetStringFromFIFO()){
    c6c0:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    c6c4:	88 23       	and	r24, r24
    c6c6:	51 f1       	breq	.+84     	; 0xc71c <GSM_Cycle+0x16ba>
								
					//  URC 
					//  
					if( (strstr_P(GSM_RxStr, URC_CLOSED+2) != NULL) ){
    c6c8:	62 e4       	ldi	r22, 0x42	; 66
    c6ca:	7f e4       	ldi	r23, 0x4F	; 79
    c6cc:	89 e8       	ldi	r24, 0x89	; 137
    c6ce:	99 e0       	ldi	r25, 0x09	; 9
    c6d0:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    c6d4:	89 2b       	or	r24, r25
    c6d6:	31 f0       	breq	.+12     	; 0xc6e4 <GSM_Cycle+0x1682>
						GSM_State = GSM_ServerIdle;
    c6d8:	83 e3       	ldi	r24, 0x33	; 51
    c6da:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c6de:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <GSM_CloseTransparent>
    c6e2:	89 c1       	rjmp	.+786    	; 0xc9f6 <GSM_Cycle+0x1994>
						break;
					}
					//    CSD
					if( (strstr_P(GSM_RxStr, URC_NO_CARRIER) != NULL) ){
    c6e4:	65 e2       	ldi	r22, 0x25	; 37
    c6e6:	7f e4       	ldi	r23, 0x4F	; 79
    c6e8:	89 e8       	ldi	r24, 0x89	; 137
    c6ea:	99 e0       	ldi	r25, 0x09	; 9
    c6ec:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    c6f0:	89 2b       	or	r24, r25
    c6f2:	31 f0       	breq	.+12     	; 0xc700 <GSM_Cycle+0x169e>
						GSM_State = GSM_ServerIdle;
    c6f4:	83 e3       	ldi	r24, 0x33	; 51
    c6f6:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c6fa:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <GSM_CloseTransparent>
    c6fe:	7b c1       	rjmp	.+758    	; 0xc9f6 <GSM_Cycle+0x1994>
						break;
					}
					// +PDP DEACT
					if( (strstr_P(GSM_RxStr, URC_PDPDEACT) != NULL) ){
    c700:	65 e3       	ldi	r22, 0x35	; 53
    c702:	7f e4       	ldi	r23, 0x4F	; 79
    c704:	89 e8       	ldi	r24, 0x89	; 137
    c706:	99 e0       	ldi	r25, 0x09	; 9
    c708:	0e 94 a3 6c 	call	0xd946	; 0xd946 <strstr_P>
    c70c:	89 2b       	or	r24, r25
    c70e:	31 f0       	breq	.+12     	; 0xc71c <GSM_Cycle+0x16ba>
						GSM_State = GSM_SEND_E0;
    c710:	88 e0       	ldi	r24, 0x08	; 8
    c712:	80 93 27 06 	sts	0x0627, r24
						GSM_CloseTransparent();
    c716:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <GSM_CloseTransparent>
    c71a:	6d c1       	rjmp	.+730    	; 0xc9f6 <GSM_Cycle+0x1994>
						break;
					}
				}
			}
			// ----- 
			if(Timer16Stopp(TD_TCP_Connect)){	//        CommandMode
    c71c:	80 91 59 02 	lds	r24, 0x0259
    c720:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c724:	88 23       	and	r24, r24
    c726:	09 f4       	brne	.+2      	; 0xc72a <GSM_Cycle+0x16c8>
    c728:	66 c1       	rjmp	.+716    	; 0xc9f6 <GSM_Cycle+0x1994>
				GSM_State = GSM_Swtch2CommandMode;
    c72a:	83 e6       	ldi	r24, 0x63	; 99
    c72c:	80 93 27 06 	sts	0x0627, r24
				GSM_CloseTransparent();
    c730:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <GSM_CloseTransparent>
    c734:	60 c1       	rjmp	.+704    	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}
			break;

		case GSM_Swtch2CommandMode:
			StartTimer16(TD_GSM,110);	// min 1000ms before +++
    c736:	6e e6       	ldi	r22, 0x6E	; 110
    c738:	70 e0       	ldi	r23, 0x00	; 0
    c73a:	80 91 5a 02 	lds	r24, 0x025A
    c73e:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			//WebClose();
			GSM_State++;
    c742:	80 91 27 06 	lds	r24, 0x0627
    c746:	8f 5f       	subi	r24, 0xFF	; 255
    c748:	80 93 27 06 	sts	0x0627, r24
    c74c:	54 c1       	rjmp	.+680    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_Swtch2CommandModePlus:
			if(Timer16Stopp(TD_GSM)){
    c74e:	80 91 5a 02 	lds	r24, 0x025A
    c752:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c756:	88 23       	and	r24, r24
    c758:	09 f4       	brne	.+2      	; 0xc75c <GSM_Cycle+0x16fa>
    c75a:	4d c1       	rjmp	.+666    	; 0xc9f6 <GSM_Cycle+0x1994>
						if(GSM_Flag & (1<<flg_TxCStr)){
    c75c:	80 91 08 01 	lds	r24, 0x0108
    c760:	80 ff       	sbrs	r24, 0
    c762:	49 c1       	rjmp	.+658    	; 0xc9f6 <GSM_Cycle+0x1994>
							GSMTxSz = strlen_P(ESC_SEQ);
    c764:	83 e0       	ldi	r24, 0x03	; 3
    c766:	80 93 57 09 	sts	0x0957, r24
							sprintf_P(GSM_TxStr, ESC_SEQ);
    c76a:	84 ea       	ldi	r24, 0xA4	; 164
    c76c:	9e e4       	ldi	r25, 0x4E	; 78
    c76e:	9f 93       	push	r25
    c770:	8f 93       	push	r24
    c772:	89 e3       	ldi	r24, 0x39	; 57
    c774:	9c e0       	ldi	r25, 0x0C	; 12
    c776:	9f 93       	push	r25
    c778:	8f 93       	push	r24
    c77a:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
							GSM_SendFirstChar();
    c77e:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
							StartTimer16(TD_GSM, 500*GSM_DEBUG_DELAY);
    c782:	64 ef       	ldi	r22, 0xF4	; 244
    c784:	71 e0       	ldi	r23, 0x01	; 1
    c786:	80 91 5a 02 	lds	r24, 0x025A
    c78a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
							GSM_State++;
    c78e:	80 91 27 06 	lds	r24, 0x0627
    c792:	8f 5f       	subi	r24, 0xFF	; 255
    c794:	80 93 27 06 	sts	0x0627, r24
    c798:	0f 90       	pop	r0
    c79a:	0f 90       	pop	r0
    c79c:	0f 90       	pop	r0
    c79e:	0f 90       	pop	r0
    c7a0:	2a c1       	rjmp	.+596    	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_GSM,1000);	// min 500ms after +++
				GSM_State++;*/
			}
			break;
		case GSM_WAIT_D2C_SWITCH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)){
    c7a2:	6a e5       	ldi	r22, 0x5A	; 90
    c7a4:	82 e2       	ldi	r24, 0x22	; 34
    c7a6:	9f e4       	ldi	r25, 0x4F	; 79
    c7a8:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c7ac:	88 23       	and	r24, r24
    c7ae:	09 f4       	brne	.+2      	; 0xc7b2 <GSM_Cycle+0x1750>
    c7b0:	22 c1       	rjmp	.+580    	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_TCP_Connect, 65535);	//    655,35 
    c7b2:	6f ef       	ldi	r22, 0xFF	; 255
    c7b4:	7f ef       	ldi	r23, 0xFF	; 255
    c7b6:	80 91 59 02 	lds	r24, 0x0259
    c7ba:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				/*if(GSM_CSD==1) GSM_State = GSM_SEND_ATH;
				else GSM_State = GSM_SEND_CIPCLOSE;*/
				switch(Transparent_Application_state){
    c7be:	80 91 52 09 	lds	r24, 0x0952
    c7c2:	82 30       	cpi	r24, 0x02	; 2
    c7c4:	41 f0       	breq	.+16     	; 0xc7d6 <GSM_Cycle+0x1774>
    c7c6:	83 30       	cpi	r24, 0x03	; 3
    c7c8:	51 f4       	brne	.+20     	; 0xc7de <GSM_Cycle+0x177c>
					case CHECK_CONNECTION_STATE:
						GSM_State = GSM_SEND_CIPSTATUS;
    c7ca:	89 e2       	ldi	r24, 0x29	; 41
    c7cc:	80 93 27 06 	sts	0x0627, r24
						InitFIFO();
    c7d0:	0e 94 07 3a 	call	0x740e	; 0x740e <InitFIFO>
    c7d4:	10 c1       	rjmp	.+544    	; 0xc9f6 <GSM_Cycle+0x1994>
						break;
					case RECONNECT:
						GSM_State = GSM_CIPSHUT_;
    c7d6:	84 e5       	ldi	r24, 0x54	; 84
    c7d8:	80 93 27 06 	sts	0x0627, r24
    c7dc:	0c c1       	rjmp	.+536    	; 0xc9f6 <GSM_Cycle+0x1994>
						break;
					default:GSM_State = GSM_ReStart1;
    c7de:	8a e5       	ldi	r24, 0x5A	; 90
    c7e0:	80 93 27 06 	sts	0x0627, r24
    c7e4:	08 c1       	rjmp	.+528    	; 0xc9f6 <GSM_Cycle+0x1994>
		//------------------------ CSD
//RING
//
//+CLIP: "+380976969029",145,"",,"",0
		case GSM_CheckNumber:
			if(Timer16Stopp(TD_GSM)) GSM_State = GSM_SEND_ATH;
    c7e6:	80 91 5a 02 	lds	r24, 0x025A
    c7ea:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c7ee:	88 23       	and	r24, r24
    c7f0:	19 f0       	breq	.+6      	; 0xc7f8 <GSM_Cycle+0x1796>
    c7f2:	89 e6       	ldi	r24, 0x69	; 105
    c7f4:	80 93 27 06 	sts	0x0627, r24
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    c7f8:	8f e5       	ldi	r24, 0x5F	; 95
    c7fa:	90 e0       	ldi	r25, 0x00	; 0
    c7fc:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
			if(!erb(&CLIP_On)){
    c800:	81 11       	cpse	r24, r1
    c802:	04 c0       	rjmp	.+8      	; 0xc80c <GSM_Cycle+0x17aa>
				GSM_State = GSM_SEND_ATA;
    c804:	87 e6       	ldi	r24, 0x67	; 103
    c806:	80 93 27 06 	sts	0x0627, r24
    c80a:	f5 c0       	rjmp	.+490    	; 0xc9f6 <GSM_Cycle+0x1994>
				break;
			}
			if(GetStringFromFIFO() > 25){
    c80c:	0e 94 6e 3a 	call	0x74dc	; 0x74dc <GetStringFromFIFO>
    c810:	8a 31       	cpi	r24, 0x1A	; 26
    c812:	08 f4       	brcc	.+2      	; 0xc816 <GSM_Cycle+0x17b4>
    c814:	f0 c0       	rjmp	.+480    	; 0xc9f6 <GSM_Cycle+0x1994>
				char *qoute_open = strchr(GSM_RxStr,'"');
    c816:	62 e2       	ldi	r22, 0x22	; 34
    c818:	70 e0       	ldi	r23, 0x00	; 0
    c81a:	89 e8       	ldi	r24, 0x89	; 137
    c81c:	99 e0       	ldi	r25, 0x09	; 9
    c81e:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
    c822:	4c 01       	movw	r8, r24
				char *qoute_clos = strchr(qoute_open+1,'"');
    c824:	62 e2       	ldi	r22, 0x22	; 34
    c826:	70 e0       	ldi	r23, 0x00	; 0
    c828:	01 96       	adiw	r24, 0x01	; 1
    c82a:	0e 94 c6 6c 	call	0xd98c	; 0xd98c <strchr>
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
    c82e:	81 14       	cp	r8, r1
    c830:	91 04       	cpc	r9, r1
    c832:	11 f0       	breq	.+4      	; 0xc838 <GSM_Cycle+0x17d6>
    c834:	00 97       	sbiw	r24, 0x00	; 0
    c836:	21 f4       	brne	.+8      	; 0xc840 <GSM_Cycle+0x17de>
					GSM_State = GSM_SEND_ATH;
    c838:	89 e6       	ldi	r24, 0x69	; 105
    c83a:	80 93 27 06 	sts	0x0627, r24
    c83e:	db c0       	rjmp	.+438    	; 0xc9f6 <GSM_Cycle+0x1994>
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
    c840:	fc 01       	movw	r30, r24
    c842:	10 82       	st	Z, r1
    c844:	01 e6       	ldi	r16, 0x61	; 97
    c846:	10 e0       	ldi	r17, 0x00	; 0
				for(uint8_t i = 0; i<10; i++){
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
    c848:	f2 e0       	ldi	r31, 0x02	; 2
    c84a:	8f 0e       	add	r8, r31
    c84c:	91 1c       	adc	r9, r1
    c84e:	b9 e6       	ldi	r27, 0x69	; 105
    c850:	7b 2e       	mov	r7, r27
    c852:	b8 01       	movw	r22, r16
    c854:	c4 01       	movw	r24, r8
    c856:	0e 94 79 47 	call	0x8ef2	; 0x8ef2 <strcmp_E>
    c85a:	88 23       	and	r24, r24
    c85c:	49 f0       	breq	.+18     	; 0xc870 <GSM_Cycle+0x180e>
    c85e:	70 92 27 06 	sts	0x0627, r7
    c862:	03 5f       	subi	r16, 0xF3	; 243
    c864:	1f 4f       	sbci	r17, 0xFF	; 255
				if( (qoute_open == NULL) || (qoute_clos == NULL)){
					GSM_State = GSM_SEND_ATH;
					break;
				}
				*qoute_clos = '\0';	//for strcmp_E
				for(uint8_t i = 0; i<10; i++){
    c866:	20 e0       	ldi	r18, 0x00	; 0
    c868:	03 3e       	cpi	r16, 0xE3	; 227
    c86a:	12 07       	cpc	r17, r18
    c86c:	91 f7       	brne	.-28     	; 0xc852 <GSM_Cycle+0x17f0>
    c86e:	c3 c0       	rjmp	.+390    	; 0xc9f6 <GSM_Cycle+0x1994>
					if( strcmp_E(qoute_open + 2, CSD_AllowedNumbers[i]) ) GSM_State = GSM_SEND_ATH;
					else { GSM_State = GSM_SEND_ATA; break;}
    c870:	87 e6       	ldi	r24, 0x67	; 103
    c872:	80 93 27 06 	sts	0x0627, r24
    c876:	bf c0       	rjmp	.+382    	; 0xc9f6 <GSM_Cycle+0x1994>
				}
			}
			break;
		case GSM_SEND_ATA:
			GSM_Execute_Command(AT_ATA, 6000*GSM_DEBUG_DELAY); GSM_State++;
    c878:	60 e7       	ldi	r22, 0x70	; 112
    c87a:	77 e1       	ldi	r23, 0x17	; 23
    c87c:	85 e4       	ldi	r24, 0x45	; 69
    c87e:	9d e4       	ldi	r25, 0x4D	; 77
    c880:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c884:	80 91 27 06 	lds	r24, 0x0627
    c888:	8f 5f       	subi	r24, 0xFF	; 255
    c88a:	80 93 27 06 	sts	0x0627, r24
    c88e:	b3 c0       	rjmp	.+358    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_CONNECT_9600:
			if(GSM_Wait_Response_P(RESP_CONNECT_9600, GSM_SEND_ATH)){
    c890:	69 e6       	ldi	r22, 0x69	; 105
    c892:	8a eb       	ldi	r24, 0xBA	; 186
    c894:	9e e4       	ldi	r25, 0x4E	; 78
    c896:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c89a:	88 23       	and	r24, r24
    c89c:	09 f4       	brne	.+2      	; 0xc8a0 <GSM_Cycle+0x183e>
    c89e:	ab c0       	rjmp	.+342    	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_TCP_Connect, 500);	//   
    c8a0:	64 ef       	ldi	r22, 0xF4	; 244
    c8a2:	71 e0       	ldi	r23, 0x01	; 1
    c8a4:	80 91 59 02 	lds	r24, 0x0259
    c8a8:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_CSD = 1;
    c8ac:	81 e0       	ldi	r24, 0x01	; 1
    c8ae:	80 93 4b 09 	sts	0x094B, r24
				GSM_State = GSM_ProtocolMode;
    c8b2:	81 e6       	ldi	r24, 0x61	; 97
    c8b4:	80 93 27 06 	sts	0x0627, r24
    c8b8:	9e c0       	rjmp	.+316    	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SEND_ATH:
			GSM_Execute_Command(AT_ATH, 300*GSM_DEBUG_DELAY); GSM_State++;
    c8ba:	6c e2       	ldi	r22, 0x2C	; 44
    c8bc:	71 e0       	ldi	r23, 0x01	; 1
    c8be:	81 e4       	ldi	r24, 0x41	; 65
    c8c0:	9d e4       	ldi	r25, 0x4D	; 77
    c8c2:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c8c6:	80 91 27 06 	lds	r24, 0x0627
    c8ca:	8f 5f       	subi	r24, 0xFF	; 255
    c8cc:	80 93 27 06 	sts	0x0627, r24
    c8d0:	92 c0       	rjmp	.+292    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_WAIT_ATH_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_ReStart1)) GSM_State = GSM_ServerIdle;
    c8d2:	6a e5       	ldi	r22, 0x5A	; 90
    c8d4:	82 e2       	ldi	r24, 0x22	; 34
    c8d6:	9f e4       	ldi	r25, 0x4F	; 79
    c8d8:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c8dc:	88 23       	and	r24, r24
    c8de:	09 f4       	brne	.+2      	; 0xc8e2 <GSM_Cycle+0x1880>
    c8e0:	8a c0       	rjmp	.+276    	; 0xc9f6 <GSM_Cycle+0x1994>
    c8e2:	83 e3       	ldi	r24, 0x33	; 51
    c8e4:	80 93 27 06 	sts	0x0627, r24
    c8e8:	86 c0       	rjmp	.+268    	; 0xc9f6 <GSM_Cycle+0x1994>
}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Manual(){}
// ~~~~~~~~~~~~~~~~~~~~~~~~
inline static void GSM_Config(){
	switch(GSM_State){
    c8ea:	80 91 27 06 	lds	r24, 0x0627
    c8ee:	90 e0       	ldi	r25, 0x00	; 0
    c8f0:	89 30       	cpi	r24, 0x09	; 9
    c8f2:	91 05       	cpc	r25, r1
    c8f4:	08 f0       	brcs	.+2      	; 0xc8f8 <GSM_Cycle+0x1896>
    c8f6:	7d c0       	rjmp	.+250    	; 0xc9f2 <GSM_Cycle+0x1990>
    c8f8:	fc 01       	movw	r30, r24
    c8fa:	e5 5c       	subi	r30, 0xC5	; 197
    c8fc:	fe 4f       	sbci	r31, 0xFE	; 254
    c8fe:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
		case GSM_CFG_START:
			StartTimer16(TD_GSM,200);
    c902:	68 ec       	ldi	r22, 0xC8	; 200
    c904:	70 e0       	ldi	r23, 0x00	; 0
    c906:	80 91 5a 02 	lds	r24, 0x025A
    c90a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
			GSM_PWRCNTRL_ON();
    c90e:	0e 94 da 2e 	call	0x5db4	; 0x5db4 <GSM_PWRCNTRL_ON>
			GSM_State++;
    c912:	80 91 27 06 	lds	r24, 0x0627
    c916:	8f 5f       	subi	r24, 0xFF	; 255
    c918:	80 93 27 06 	sts	0x0627, r24
    c91c:	6c c0       	rjmp	.+216    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_CFG_SEND_AT:
			if(Timer16Stopp(TD_GSM)) GSM_Execute_Command(AT_AT, 100); GSM_State++;
    c91e:	80 91 5a 02 	lds	r24, 0x025A
    c922:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c926:	88 23       	and	r24, r24
    c928:	31 f0       	breq	.+12     	; 0xc936 <GSM_Cycle+0x18d4>
    c92a:	64 e6       	ldi	r22, 0x64	; 100
    c92c:	70 e0       	ldi	r23, 0x00	; 0
    c92e:	81 ea       	ldi	r24, 0xA1	; 161
    c930:	9e e4       	ldi	r25, 0x4E	; 78
    c932:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c936:	80 91 27 06 	lds	r24, 0x0627
    c93a:	8f 5f       	subi	r24, 0xFF	; 255
    c93c:	80 93 27 06 	sts	0x0627, r24
    c940:	5a c0       	rjmp	.+180    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_CFG_WAIT_AT_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)) GSM_State++;
    c942:	61 e0       	ldi	r22, 0x01	; 1
    c944:	82 e2       	ldi	r24, 0x22	; 34
    c946:	9f e4       	ldi	r25, 0x4F	; 79
    c948:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c94c:	88 23       	and	r24, r24
    c94e:	09 f4       	brne	.+2      	; 0xc952 <GSM_Cycle+0x18f0>
    c950:	52 c0       	rjmp	.+164    	; 0xc9f6 <GSM_Cycle+0x1994>
    c952:	80 91 27 06 	lds	r24, 0x0627
    c956:	8f 5f       	subi	r24, 0xFF	; 255
    c958:	80 93 27 06 	sts	0x0627, r24
    c95c:	4c c0       	rjmp	.+152    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_CFG_SEND_IPR:
			GSM_Execute_Command(AT_IPR9600, 100); GSM_State++;
    c95e:	64 e6       	ldi	r22, 0x64	; 100
    c960:	70 e0       	ldi	r23, 0x00	; 0
    c962:	85 e9       	ldi	r24, 0x95	; 149
    c964:	9e e4       	ldi	r25, 0x4E	; 78
    c966:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c96a:	80 91 27 06 	lds	r24, 0x0627
    c96e:	8f 5f       	subi	r24, 0xFF	; 255
    c970:	80 93 27 06 	sts	0x0627, r24
    c974:	40 c0       	rjmp	.+128    	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_CFG_WAIT_IPR_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c976:	61 e0       	ldi	r22, 0x01	; 1
    c978:	82 e2       	ldi	r24, 0x22	; 34
    c97a:	9f e4       	ldi	r25, 0x4F	; 79
    c97c:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c980:	88 23       	and	r24, r24
    c982:	c9 f1       	breq	.+114    	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_GSM,200);
    c984:	68 ec       	ldi	r22, 0xC8	; 200
    c986:	70 e0       	ldi	r23, 0x00	; 0
    c988:	80 91 5a 02 	lds	r24, 0x025A
    c98c:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State++;
    c990:	80 91 27 06 	lds	r24, 0x0627
    c994:	8f 5f       	subi	r24, 0xFF	; 255
    c996:	80 93 27 06 	sts	0x0627, r24
    c99a:	2d c0       	rjmp	.+90     	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_CFG_SEND_ATW:
			GSM_Execute_Command(AT_W, 100); GSM_State++;
    c99c:	64 e6       	ldi	r22, 0x64	; 100
    c99e:	70 e0       	ldi	r23, 0x00	; 0
    c9a0:	80 e9       	ldi	r24, 0x90	; 144
    c9a2:	9e e4       	ldi	r25, 0x4E	; 78
    c9a4:	0e 94 fd 57 	call	0xaffa	; 0xaffa <GSM_Execute_Command>
    c9a8:	80 91 27 06 	lds	r24, 0x0627
    c9ac:	8f 5f       	subi	r24, 0xFF	; 255
    c9ae:	80 93 27 06 	sts	0x0627, r24
    c9b2:	21 c0       	rjmp	.+66     	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_CFG_WAIT_ATW_OK:
			if(GSM_Wait_Response_P(RESP_OK, GSM_CFG_SEND_AT)){
    c9b4:	61 e0       	ldi	r22, 0x01	; 1
    c9b6:	82 e2       	ldi	r24, 0x22	; 34
    c9b8:	9f e4       	ldi	r25, 0x4F	; 79
    c9ba:	0e 94 2c 3b 	call	0x7658	; 0x7658 <GSM_Wait_Response_P>
    c9be:	88 23       	and	r24, r24
    c9c0:	d1 f0       	breq	.+52     	; 0xc9f6 <GSM_Cycle+0x1994>
				StartTimer16(TD_GSM,200);
    c9c2:	68 ec       	ldi	r22, 0xC8	; 200
    c9c4:	70 e0       	ldi	r23, 0x00	; 0
    c9c6:	80 91 5a 02 	lds	r24, 0x025A
    c9ca:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				GSM_State++;
    c9ce:	80 91 27 06 	lds	r24, 0x0627
    c9d2:	8f 5f       	subi	r24, 0xFF	; 255
    c9d4:	80 93 27 06 	sts	0x0627, r24
    c9d8:	0e c0       	rjmp	.+28     	; 0xc9f6 <GSM_Cycle+0x1994>
			}
			break;
		case GSM_SAVE_IPR:
			if(Timer16Stopp(TD_GSM)) GSM_State++;
    c9da:	80 91 5a 02 	lds	r24, 0x025A
    c9de:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    c9e2:	88 23       	and	r24, r24
    c9e4:	41 f0       	breq	.+16     	; 0xc9f6 <GSM_Cycle+0x1994>
    c9e6:	80 91 27 06 	lds	r24, 0x0627
    c9ea:	8f 5f       	subi	r24, 0xFF	; 255
    c9ec:	80 93 27 06 	sts	0x0627, r24
    c9f0:	02 c0       	rjmp	.+4      	; 0xc9f6 <GSM_Cycle+0x1994>
			break;
		case GSM_FINISH:			
			break;
		default:
			GSM_State = GSM_CFG_START;
    c9f2:	10 92 27 06 	sts	0x0627, r1
			break;	
		case GSM_CNTL_CONFIG:
			GSM_Config();
			break;								
	}
	if((GSM_State != GSM_ReStart1) && (GSM_State != GSM_ReStart2)) GSM_StateBeforeReset = GSM_State;
    c9f6:	80 91 27 06 	lds	r24, 0x0627
    c9fa:	8a 35       	cpi	r24, 0x5A	; 90
    c9fc:	41 f0       	breq	.+16     	; 0xca0e <GSM_Cycle+0x19ac>
    c9fe:	80 91 27 06 	lds	r24, 0x0627
    ca02:	8b 35       	cpi	r24, 0x5B	; 91
    ca04:	21 f0       	breq	.+8      	; 0xca0e <GSM_Cycle+0x19ac>
    ca06:	80 91 27 06 	lds	r24, 0x0627
    ca0a:	80 93 5b 09 	sts	0x095B, r24
}
    ca0e:	2e 96       	adiw	r28, 0x0e	; 14
    ca10:	0f b6       	in	r0, 0x3f	; 63
    ca12:	f8 94       	cli
    ca14:	de bf       	out	0x3e, r29	; 62
    ca16:	0f be       	out	0x3f, r0	; 63
    ca18:	cd bf       	out	0x3d, r28	; 61
    ca1a:	df 91       	pop	r29
    ca1c:	cf 91       	pop	r28
    ca1e:	1f 91       	pop	r17
    ca20:	0f 91       	pop	r16
    ca22:	ff 90       	pop	r15
    ca24:	ef 90       	pop	r14
    ca26:	df 90       	pop	r13
    ca28:	cf 90       	pop	r12
    ca2a:	bf 90       	pop	r11
    ca2c:	af 90       	pop	r10
    ca2e:	9f 90       	pop	r9
    ca30:	8f 90       	pop	r8
    ca32:	7f 90       	pop	r7
    ca34:	6f 90       	pop	r6
    ca36:	5f 90       	pop	r5
    ca38:	4f 90       	pop	r4
    ca3a:	3f 90       	pop	r3
    ca3c:	2f 90       	pop	r2
    ca3e:	08 95       	ret

0000ca40 <USART_Cycle>:
// ~~~~~~~~~~~~~~
void
USART_Cycle(void)
{		
	// UART_Soft   100
	if(UART_Soft){
    ca40:	80 91 75 0a 	lds	r24, 0x0A75
    ca44:	88 23       	and	r24, r24
    ca46:	b9 f0       	breq	.+46     	; 0xca76 <USART_Cycle+0x36>

		if(ModbusMode) MB_Cycle();
    ca48:	80 91 e0 03 	lds	r24, 0x03E0
    ca4c:	81 11       	cpse	r24, r1
    ca4e:	0e 94 a4 39 	call	0x7348	; 0x7348 <MB_Cycle>

		if(!(PINA & (1<<PA0)))	StartTimer8(TD_UART_Soft,10);
    ca52:	c8 9b       	sbis	0x19, 0	; 25
    ca54:	22 c0       	rjmp	.+68     	; 0xca9a <USART_Cycle+0x5a>
		else{
			if(Timer8Stopp(TD_UART_Soft)){
    ca56:	80 91 4c 09 	lds	r24, 0x094C
    ca5a:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    ca5e:	88 23       	and	r24, r24
    ca60:	09 f1       	breq	.+66     	; 0xcaa4 <USART_Cycle+0x64>
				cli();
    ca62:	f8 94       	cli
				EMeter_ReInit();
    ca64:	0e 94 ba 4b 	call	0x9774	; 0x9774 <EMeter_ReInit>
				UART_Soft = 0;
    ca68:	10 92 75 0a 	sts	0x0A75, r1
				ModbusMode = 0;				
    ca6c:	10 92 e0 03 	sts	0x03E0, r1
				GSM_DebugMode = 0;	
    ca70:	10 92 f2 09 	sts	0x09F2, r1
    ca74:	10 c0       	rjmp	.+32     	; 0xca96 <USART_Cycle+0x56>
			}
		}
	}
	else{
	//	EMeter_Cycle();
		if(!(PINA & (1<<PA0))){
    ca76:	c8 99       	sbic	0x19, 0	; 25
    ca78:	10 c0       	rjmp	.+32     	; 0xca9a <USART_Cycle+0x5a>
			if(Timer8Stopp(TD_UART_Soft)){
    ca7a:	80 91 4c 09 	lds	r24, 0x094C
    ca7e:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    ca82:	88 23       	and	r24, r24
    ca84:	79 f0       	breq	.+30     	; 0xcaa4 <USART_Cycle+0x64>
				//if(Transparent) GSM_Transparent2Modbus();	//  Modbus -    Transparent
				cli();
    ca86:	f8 94       	cli
				MB_Init();
    ca88:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <MB_Init>
				UART_Soft = 1;
    ca8c:	81 e0       	ldi	r24, 0x01	; 1
    ca8e:	80 93 75 0a 	sts	0x0A75, r24
				ModbusMode = 1;
    ca92:	80 93 e0 03 	sts	0x03E0, r24
				sei();
    ca96:	78 94       	sei
    ca98:	05 c0       	rjmp	.+10     	; 0xcaa4 <USART_Cycle+0x64>
			}
		}			
		else StartTimer8(TD_UART_Soft,10);
    ca9a:	6a e0       	ldi	r22, 0x0A	; 10
    ca9c:	80 91 4c 09 	lds	r24, 0x094C
    caa0:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
	}

	#ifdef GSM
		GSM_Cycle();
    caa4:	0c 94 31 58 	jmp	0xb062	; 0xb062 <GSM_Cycle>

0000caa8 <WebServer>:
uint8_t IsWebSession(void){
	return WebSession;
}
// ~~~~~~~~~~~~~~~~~~
//void WebServer(const prog_char *Str1_P, InField *IF_List, const uint8_t SiteSize){
void WebServer(const WebPage **ptrSite, const uint8_t SiteSize){
    caa8:	2f 92       	push	r2
    caaa:	3f 92       	push	r3
    caac:	4f 92       	push	r4
    caae:	5f 92       	push	r5
    cab0:	6f 92       	push	r6
    cab2:	7f 92       	push	r7
    cab4:	8f 92       	push	r8
    cab6:	9f 92       	push	r9
    cab8:	af 92       	push	r10
    caba:	bf 92       	push	r11
    cabc:	cf 92       	push	r12
    cabe:	df 92       	push	r13
    cac0:	ef 92       	push	r14
    cac2:	ff 92       	push	r15
    cac4:	0f 93       	push	r16
    cac6:	1f 93       	push	r17
    cac8:	cf 93       	push	r28
    caca:	df 93       	push	r29
    cacc:	cd b7       	in	r28, 0x3d	; 61
    cace:	de b7       	in	r29, 0x3e	; 62
    cad0:	2c 97       	sbiw	r28, 0x0c	; 12
    cad2:	0f b6       	in	r0, 0x3f	; 63
    cad4:	f8 94       	cli
    cad6:	de bf       	out	0x3e, r29	; 62
    cad8:	0f be       	out	0x3f, r0	; 63
    cada:	cd bf       	out	0x3d, r28	; 61
    cadc:	8c 01       	movw	r16, r24
    cade:	b6 2e       	mov	r11, r22
	}
	else{
		StartTimeoutWaitRequest = 0;
	}

}
    cae0:	2d b6       	in	r2, 0x3d	; 61
    cae2:	3e b6       	in	r3, 0x3e	; 62
	static uint16_t PacketByteCount;
	static uint8_t StartTimeoutWaitRequest;
	//static uint8_t Web_POST;

//--Session
	if(GetTimer32(TD_WebSeedGenerator)<200) StartTimer32(TD_WebSeedGenerator, 0xFFFFFFFF);
    cae4:	f0 90 1c 06 	lds	r15, 0x061C

// ~~~~~~~~~~~~~~~~~~~~~~~
uint32_t
GetTimer32(uint8_t TimerN)
{
	IntOff();
    cae8:	0e 94 15 2a 	call	0x542a	; 0x542a <IntOff>
	uint32_t Time = Timer32[TimerN];
    caec:	24 e0       	ldi	r18, 0x04	; 4
    caee:	f2 9e       	mul	r15, r18
    caf0:	f0 01       	movw	r30, r0
    caf2:	11 24       	eor	r1, r1
    caf4:	ea 57       	subi	r30, 0x7A	; 122
    caf6:	fd 4f       	sbci	r31, 0xFD	; 253
    caf8:	c0 80       	ld	r12, Z
    cafa:	d1 80       	ldd	r13, Z+1	; 0x01
    cafc:	e2 80       	ldd	r14, Z+2	; 0x02
    cafe:	f3 80       	ldd	r15, Z+3	; 0x03
	IntOn();
    cb00:	0e 94 1d 2a 	call	0x543a	; 0x543a <IntOn>
    cb04:	38 ec       	ldi	r19, 0xC8	; 200
    cb06:	c3 16       	cp	r12, r19
    cb08:	d1 04       	cpc	r13, r1
    cb0a:	e1 04       	cpc	r14, r1
    cb0c:	f1 04       	cpc	r15, r1
    cb0e:	38 f4       	brcc	.+14     	; 0xcb1e <WebServer+0x76>
    cb10:	4f ef       	ldi	r20, 0xFF	; 255
    cb12:	5f ef       	ldi	r21, 0xFF	; 255
    cb14:	ba 01       	movw	r22, r20
    cb16:	80 91 1c 06 	lds	r24, 0x061C
    cb1a:	0e 94 15 2c 	call	0x582a	; 0x582a <StartTimer32>
	if(Timer32Stopp(TD_WebSessTimeout)) WebSession = 0;
    cb1e:	80 91 68 09 	lds	r24, 0x0968
    cb22:	0e 94 96 2c 	call	0x592c	; 0x592c <Timer32Stopp>
    cb26:	81 11       	cpse	r24, r1
    cb28:	10 92 7e 09 	sts	0x097E, r1
//------

	if( (GSM_State == GSM_DataMode) && (AppProtocol == _HTTP)){
    cb2c:	80 91 27 06 	lds	r24, 0x0627
    cb30:	82 36       	cpi	r24, 0x62	; 98
    cb32:	09 f0       	breq	.+2      	; 0xcb36 <WebServer+0x8e>
    cb34:	e1 c3       	rjmp	.+1986   	; 0xd2f8 <WebServer+0x850>
    cb36:	80 91 f4 09 	lds	r24, 0x09F4
    cb3a:	81 30       	cpi	r24, 0x01	; 1
    cb3c:	09 f0       	breq	.+2      	; 0xcb40 <WebServer+0x98>
    cb3e:	dc c3       	rjmp	.+1976   	; 0xd2f8 <WebServer+0x850>
		
		// 
		if(WebMode == 254){
    cb40:	80 91 06 01 	lds	r24, 0x0106
    cb44:	8e 3f       	cpi	r24, 0xFE	; 254
    cb46:	71 f5       	brne	.+92     	; 0xcba4 <WebServer+0xfc>
			ptrPage = WebRequest(ptrSite, SiteSize);
    cb48:	6b 2d       	mov	r22, r11
    cb4a:	c8 01       	movw	r24, r16
    cb4c:	0e 94 e1 48 	call	0x91c2	; 0x91c2 <WebRequest>
    cb50:	90 93 40 02 	sts	0x0240, r25
    cb54:	80 93 3f 02 	sts	0x023F, r24
			if(ptrPage != NULL){
    cb58:	89 2b       	or	r24, r25
    cb5a:	41 f0       	breq	.+16     	; 0xcb6c <WebServer+0xc4>
				WebMode = 255;
    cb5c:	8f ef       	ldi	r24, 0xFF	; 255
    cb5e:	80 93 06 01 	sts	0x0106, r24
				//StartTimer8(TD_WaitLCDRefresh,200);
				StartTimer8(TD_WaitLCDRefresh, WEB_VARS_REFRESH_TIME);
    cb62:	64 e1       	ldi	r22, 0x14	; 20
    cb64:	80 91 44 09 	lds	r24, 0x0944
    cb68:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
			}

			//    10    
			if(StartTimeoutWaitRequest){
    cb6c:	80 91 3e 02 	lds	r24, 0x023E
    cb70:	88 23       	and	r24, r24
    cb72:	79 f0       	breq	.+30     	; 0xcb92 <WebServer+0xea>
				if(Timer16Stopp(TD_WaitReqTimout)){
    cb74:	80 91 6a 09 	lds	r24, 0x096A
    cb78:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    cb7c:	88 23       	and	r24, r24
    cb7e:	91 f0       	breq	.+36     	; 0xcba4 <WebServer+0xfc>
					GSM_State = GSM_Swtch2CommandMode;
    cb80:	83 e6       	ldi	r24, 0x63	; 99
    cb82:	80 93 27 06 	sts	0x0627, r24
					Web_POST = 0;
    cb86:	10 92 6d 09 	sts	0x096D, r1
					WebMode = 254;
    cb8a:	8e ef       	ldi	r24, 0xFE	; 254
    cb8c:	80 93 06 01 	sts	0x0106, r24
					return;				
    cb90:	b5 c3       	rjmp	.+1898   	; 0xd2fc <WebServer+0x854>
				}
			}
			else{
				StartTimer16(TD_WaitReqTimout,1000);
    cb92:	68 ee       	ldi	r22, 0xE8	; 232
    cb94:	73 e0       	ldi	r23, 0x03	; 3
    cb96:	80 91 6a 09 	lds	r24, 0x096A
    cb9a:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				StartTimeoutWaitRequest = 1;
    cb9e:	81 e0       	ldi	r24, 0x01	; 1
    cba0:	80 93 3e 02 	sts	0x023E, r24
			}
		}


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){
    cba4:	80 91 08 01 	lds	r24, 0x0108
    cba8:	80 ff       	sbrs	r24, 0
    cbaa:	a8 c3       	rjmp	.+1872   	; 0xd2fc <WebServer+0x854>
    cbac:	80 91 4f 09 	lds	r24, 0x094F
    cbb0:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    cbb4:	88 23       	and	r24, r24
    cbb6:	09 f4       	brne	.+2      	; 0xcbba <WebServer+0x112>
    cbb8:	a1 c3       	rjmp	.+1858   	; 0xd2fc <WebServer+0x854>

			uint16_t i=0;
			
			// 
			if(WebMode == 255){
    cbba:	80 91 06 01 	lds	r24, 0x0106
    cbbe:	8f 3f       	cpi	r24, 0xFF	; 255
    cbc0:	39 f4       	brne	.+14     	; 0xcbd0 <WebServer+0x128>
				if(Timer8Stopp(TD_WaitLCDRefresh)){
    cbc2:	80 91 44 09 	lds	r24, 0x0944
    cbc6:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    cbca:	81 11       	cpse	r24, r1
					WebMode = 0;
    cbcc:	10 92 06 01 	sts	0x0106, r1
				}
			}

			// 
			if(WebMode == 2){
    cbd0:	80 91 06 01 	lds	r24, 0x0106
    cbd4:	82 30       	cpi	r24, 0x02	; 2
    cbd6:	59 f4       	brne	.+22     	; 0xcbee <WebServer+0x146>
				GSM_State = GSM_Swtch2CommandMode;
    cbd8:	83 e6       	ldi	r24, 0x63	; 99
    cbda:	80 93 27 06 	sts	0x0627, r24
				WebMode = 254;
    cbde:	8e ef       	ldi	r24, 0xFE	; 254
    cbe0:	80 93 06 01 	sts	0x0106, r24
				Web_Login_Code = 0;
    cbe4:	10 92 09 06 	sts	0x0609, r1
				Web_POST = 0;
    cbe8:	10 92 6d 09 	sts	0x096D, r1
				return;
    cbec:	87 c3       	rjmp	.+1806   	; 0xd2fc <WebServer+0x854>
			}
			
			//   
			if(WebMode == 0){
    cbee:	81 11       	cpse	r24, r1
    cbf0:	df c0       	rjmp	.+446    	; 0xcdb0 <WebServer+0x308>
				//Not Found
				if(ptrPage == &Web_error_page){
    cbf2:	80 91 3f 02 	lds	r24, 0x023F
    cbf6:	90 91 40 02 	lds	r25, 0x0240
    cbfa:	80 5c       	subi	r24, 0xC0	; 192
    cbfc:	9b 44       	sbci	r25, 0x4B	; 75
    cbfe:	b9 f4       	brne	.+46     	; 0xcc2e <WebServer+0x186>
					memcpy_P(GSM_TxStr, error_page, sizeof(error_page)-1);						
    cc00:	44 e7       	ldi	r20, 0x74	; 116
    cc02:	50 e0       	ldi	r21, 0x00	; 0
    cc04:	6d ec       	ldi	r22, 0xCD	; 205
    cc06:	7b e4       	ldi	r23, 0x4B	; 75
    cc08:	89 e3       	ldi	r24, 0x39	; 57
    cc0a:	9c e0       	ldi	r25, 0x0C	; 12
    cc0c:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
					GSMTxSz = sizeof(error_page)-1;
    cc10:	84 e7       	ldi	r24, 0x74	; 116
    cc12:	80 93 57 09 	sts	0x0957, r24
					GSM_SendFirstChar();
    cc16:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
					StartTimer16(TD_FlowDelay, EndPacketDelay);
    cc1a:	68 ec       	ldi	r22, 0xC8	; 200
    cc1c:	70 e0       	ldi	r23, 0x00	; 0
    cc1e:	80 91 4f 09 	lds	r24, 0x094F
    cc22:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
					WebMode = 2;
    cc26:	82 e0       	ldi	r24, 0x02	; 2
    cc28:	80 93 06 01 	sts	0x0106, r24
    cc2c:	c1 c0       	rjmp	.+386    	; 0xcdb0 <WebServer+0x308>
					//"Connection: close\r\n"
					//"\r\n"

					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
    cc2e:	41 e1       	ldi	r20, 0x11	; 17
    cc30:	50 e0       	ldi	r21, 0x00	; 0
    cc32:	69 ee       	ldi	r22, 0xE9	; 233
    cc34:	7c e4       	ldi	r23, 0x4C	; 76
    cc36:	89 e3       	ldi	r24, 0x39	; 57
    cc38:	9c e0       	ldi	r25, 0x0C	; 12
    cc3a:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
    cc3e:	4e e0       	ldi	r20, 0x0E	; 14
    cc40:	50 e0       	ldi	r21, 0x00	; 0
    cc42:	6a ed       	ldi	r22, 0xDA	; 218
    cc44:	7c e4       	ldi	r23, 0x4C	; 76
    cc46:	8a e4       	ldi	r24, 0x4A	; 74
    cc48:	9c e0       	ldi	r25, 0x0C	; 12
    cc4a:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cc4e:	e0 91 3f 02 	lds	r30, 0x023F
    cc52:	f0 91 40 02 	lds	r31, 0x0240
    cc56:	85 91       	lpm	r24, Z+
    cc58:	94 91       	lpm	r25, Z
					i += sizeof(Content_Type)-1;
					
					const prog_char* ext_point_ptr = strchr_P((prog_char*)prp(&ptrPage->Name),'.');
    cc5a:	6e e2       	ldi	r22, 0x2E	; 46
    cc5c:	70 e0       	ldi	r23, 0x00	; 0
    cc5e:	0e 94 5d 6c 	call	0xd8ba	; 0xd8ba <strchr_P>
					if(ext_point_ptr){ 
    cc62:	00 97       	sbiw	r24, 0x00	; 0
    cc64:	09 f4       	brne	.+2      	; 0xcc68 <WebServer+0x1c0>
    cc66:	89 c0       	rjmp	.+274    	; 0xcd7a <WebServer+0x2d2>
						
						// - html 
						if(!strcmp_PP(html_str,ext_point_ptr+1)){
    cc68:	7c 01       	movw	r14, r24
    cc6a:	5f ef       	ldi	r21, 0xFF	; 255
    cc6c:	e5 1a       	sub	r14, r21
    cc6e:	f5 0a       	sbc	r15, r21
    cc70:	b7 01       	movw	r22, r14
    cc72:	89 e9       	ldi	r24, 0x99	; 153
    cc74:	9c e4       	ldi	r25, 0x4C	; 76
    cc76:	0e 94 5b 47 	call	0x8eb6	; 0x8eb6 <strcmp_PP>
    cc7a:	81 11       	cpse	r24, r1
    cc7c:	0b c0       	rjmp	.+22     	; 0xcc94 <WebServer+0x1ec>
							memcpy_P(GSM_TxStr+i, html_cp1251_str, sizeof(html_cp1251_str)-1);
    cc7e:	41 e2       	ldi	r20, 0x21	; 33
    cc80:	50 e0       	ldi	r21, 0x00	; 0
    cc82:	65 ea       	ldi	r22, 0xA5	; 165
    cc84:	7c e4       	ldi	r23, 0x4C	; 76
    cc86:	88 e5       	ldi	r24, 0x58	; 88
    cc88:	9c e0       	ldi	r25, 0x0C	; 12
    cc8a:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
							i += sizeof(html_cp1251_str)-1;
    cc8e:	00 e4       	ldi	r16, 0x40	; 64
    cc90:	10 e0       	ldi	r17, 0x00	; 0
    cc92:	67 c0       	rjmp	.+206    	; 0xcd62 <WebServer+0x2ba>
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
    cc94:	46 e0       	ldi	r20, 0x06	; 6
    cc96:	50 e0       	ldi	r21, 0x00	; 0
    cc98:	6e e9       	ldi	r22, 0x9E	; 158
    cc9a:	7c e4       	ldi	r23, 0x4C	; 76
    cc9c:	88 e5       	ldi	r24, 0x58	; 88
    cc9e:	9c e0       	ldi	r25, 0x0C	; 12
    cca0:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
							i += sizeof(image_str)-1;
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
    cca4:	b7 01       	movw	r22, r14
    cca6:	85 e9       	ldi	r24, 0x95	; 149
    cca8:	9c e4       	ldi	r25, 0x4C	; 76
    ccaa:	0e 94 5b 47 	call	0x8eb6	; 0x8eb6 <strcmp_PP>
    ccae:	81 11       	cpse	r24, r1
    ccb0:	0b c0       	rjmp	.+22     	; 0xccc8 <WebServer+0x220>
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
    ccb2:	43 e0       	ldi	r20, 0x03	; 3
    ccb4:	50 e0       	ldi	r21, 0x00	; 0
    ccb6:	65 e9       	ldi	r22, 0x95	; 149
    ccb8:	7c e4       	ldi	r23, 0x4C	; 76
    ccba:	8e e5       	ldi	r24, 0x5E	; 94
    ccbc:	9c e0       	ldi	r25, 0x0C	; 12
    ccbe:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
								i += sizeof(ico_str)-1;
    ccc2:	08 e2       	ldi	r16, 0x28	; 40
    ccc4:	10 e0       	ldi	r17, 0x00	; 0
    ccc6:	02 c0       	rjmp	.+4      	; 0xcccc <WebServer+0x224>
							i += sizeof(html_cp1251_str)-1;
						}
						// 
						else{
							memcpy_P(GSM_TxStr+i, image_str, sizeof(image_str)-1);
							i += sizeof(image_str)-1;
    ccc8:	05 e2       	ldi	r16, 0x25	; 37
    ccca:	10 e0       	ldi	r17, 0x00	; 0
							if(!strcmp_PP(ico_str,ext_point_ptr+1)){
								memcpy_P(GSM_TxStr+i, ico_str, sizeof(ico_str)-1);
								i += sizeof(ico_str)-1;
							}
							if(!strcmp_PP(gif_str,ext_point_ptr+1)){
    cccc:	b7 01       	movw	r22, r14
    ccce:	81 e9       	ldi	r24, 0x91	; 145
    ccd0:	9c e4       	ldi	r25, 0x4C	; 76
    ccd2:	0e 94 5b 47 	call	0x8eb6	; 0x8eb6 <strcmp_PP>
    ccd6:	81 11       	cpse	r24, r1
    ccd8:	0b c0       	rjmp	.+22     	; 0xccf0 <WebServer+0x248>
								memcpy_P(GSM_TxStr+i, gif_str, sizeof(gif_str)-1);
    ccda:	43 e0       	ldi	r20, 0x03	; 3
    ccdc:	50 e0       	ldi	r21, 0x00	; 0
    ccde:	61 e9       	ldi	r22, 0x91	; 145
    cce0:	7c e4       	ldi	r23, 0x4C	; 76
    cce2:	c8 01       	movw	r24, r16
    cce4:	87 5c       	subi	r24, 0xC7	; 199
    cce6:	93 4f       	sbci	r25, 0xF3	; 243
    cce8:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
								i += sizeof(gif_str)-1;								
    ccec:	0d 5f       	subi	r16, 0xFD	; 253
    ccee:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							if(!strcmp_PP(jpeg_str,ext_point_ptr+1)){
    ccf0:	b7 01       	movw	r22, r14
    ccf2:	8c e8       	ldi	r24, 0x8C	; 140
    ccf4:	9c e4       	ldi	r25, 0x4C	; 76
    ccf6:	0e 94 5b 47 	call	0x8eb6	; 0x8eb6 <strcmp_PP>
    ccfa:	81 11       	cpse	r24, r1
    ccfc:	0b c0       	rjmp	.+22     	; 0xcd14 <WebServer+0x26c>
								memcpy_P(GSM_TxStr+i, jpeg_str, sizeof(jpeg_str)-1);
    ccfe:	44 e0       	ldi	r20, 0x04	; 4
    cd00:	50 e0       	ldi	r21, 0x00	; 0
    cd02:	6c e8       	ldi	r22, 0x8C	; 140
    cd04:	7c e4       	ldi	r23, 0x4C	; 76
    cd06:	c8 01       	movw	r24, r16
    cd08:	87 5c       	subi	r24, 0xC7	; 199
    cd0a:	93 4f       	sbci	r25, 0xF3	; 243
    cd0c:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
								i += sizeof(jpeg_str)-1;
    cd10:	0c 5f       	subi	r16, 0xFC	; 252
    cd12:	1f 4f       	sbci	r17, 0xFF	; 255
							}
							memcpy_P(GSM_TxStr+i, Content_Length, sizeof(Content_Length)-1);
    cd14:	42 e1       	ldi	r20, 0x12	; 18
    cd16:	50 e0       	ldi	r21, 0x00	; 0
    cd18:	67 ec       	ldi	r22, 0xC7	; 199
    cd1a:	7c e4       	ldi	r23, 0x4C	; 76
    cd1c:	c8 01       	movw	r24, r16
    cd1e:	87 5c       	subi	r24, 0xC7	; 199
    cd20:	93 4f       	sbci	r25, 0xF3	; 243
    cd22:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
							i += sizeof(Content_Length)-1;
    cd26:	0e 5e       	subi	r16, 0xEE	; 238
    cd28:	1f 4f       	sbci	r17, 0xFF	; 255
							i += sprintf_P(GSM_TxStr+i,PSTR("%u\r\n"), (unsigned int)prw(&ptrPage->ContentSz));
    cd2a:	e0 91 3f 02 	lds	r30, 0x023F
    cd2e:	f0 91 40 02 	lds	r31, 0x0240
    cd32:	38 96       	adiw	r30, 0x08	; 8

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cd34:	85 91       	lpm	r24, Z+
    cd36:	94 91       	lpm	r25, Z
    cd38:	9f 93       	push	r25
    cd3a:	8f 93       	push	r24
    cd3c:	89 e0       	ldi	r24, 0x09	; 9
    cd3e:	93 e0       	ldi	r25, 0x03	; 3
    cd40:	9f 93       	push	r25
    cd42:	8f 93       	push	r24
    cd44:	c8 01       	movw	r24, r16
    cd46:	87 5c       	subi	r24, 0xC7	; 199
    cd48:	93 4f       	sbci	r25, 0xF3	; 243
    cd4a:	9f 93       	push	r25
    cd4c:	8f 93       	push	r24
    cd4e:	0e 94 1e 6d 	call	0xda3c	; 0xda3c <sprintf_P>
    cd52:	08 0f       	add	r16, r24
    cd54:	19 1f       	adc	r17, r25
    cd56:	0f 90       	pop	r0
    cd58:	0f 90       	pop	r0
    cd5a:	0f 90       	pop	r0
    cd5c:	0f 90       	pop	r0
    cd5e:	0f 90       	pop	r0
    cd60:	0f 90       	pop	r0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
    cd62:	45 e1       	ldi	r20, 0x15	; 21
    cd64:	50 e0       	ldi	r21, 0x00	; 0
    cd66:	66 e7       	ldi	r22, 0x76	; 118
    cd68:	7c e4       	ldi	r23, 0x4C	; 76
    cd6a:	c8 01       	movw	r24, r16
    cd6c:	87 5c       	subi	r24, 0xC7	; 199
    cd6e:	93 4f       	sbci	r25, 0xF3	; 243
    cd70:	0e 94 54 6c 	call	0xd8a8	; 0xd8a8 <memcpy_P>
						i += sizeof(Connection_Close)-1;
    cd74:	0b 5e       	subi	r16, 0xEB	; 235
    cd76:	1f 4f       	sbci	r17, 0xFF	; 255
    cd78:	02 c0       	rjmp	.+4      	; 0xcd7e <WebServer+0x2d6>
					//  
		 			i = sizeof(HTTP_200_OK)-1;
					memcpy_P(GSM_TxStr, HTTP_200_OK, sizeof(HTTP_200_OK)-1);
					//  Content-Type
					memcpy_P(GSM_TxStr+i, Content_Type, sizeof(Content_Type)-1);
					i += sizeof(Content_Type)-1;
    cd7a:	0f e1       	ldi	r16, 0x1F	; 31
    cd7c:	10 e0       	ldi	r17, 0x00	; 0
						}
						memcpy_P(GSM_TxStr+i, Connection_Close, sizeof(Connection_Close)-1);
						i += sizeof(Connection_Close)-1;

					}
					WebDataCnt = 0;
    cd7e:	10 92 f1 03 	sts	0x03F1, r1
    cd82:	10 92 f0 03 	sts	0x03F0, r1
					WebInputHiddenCnt = 0;
    cd86:	10 92 e9 03 	sts	0x03E9, r1
					WebHrefHiddenCnt = 0;
    cd8a:	10 92 28 06 	sts	0x0628, r1
					WebImgSrcHiddenCnt = 0;
    cd8e:	10 92 e8 03 	sts	0x03E8, r1
					ptrIF = prp(&ptrPage->IF_List);
    cd92:	e0 91 3f 02 	lds	r30, 0x023F
    cd96:	f0 91 40 02 	lds	r31, 0x0240
    cd9a:	32 96       	adiw	r30, 0x02	; 2

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cd9c:	85 91       	lpm	r24, Z+
    cd9e:	94 91       	lpm	r25, Z
    cda0:	90 93 3d 02 	sts	0x023D, r25
    cda4:	80 93 3c 02 	sts	0x023C, r24
					WebMode = 1;
    cda8:	81 e0       	ldi	r24, 0x01	; 1
    cdaa:	80 93 06 01 	sts	0x0106, r24
    cdae:	02 c0       	rjmp	.+4      	; 0xcdb4 <WebServer+0x30c>


		//
		if( (GSM_Flag & (1<<flg_TxCStr))  && Timer16Stopp(TD_FlowDelay) ){

			uint16_t i=0;
    cdb0:	00 e0       	ldi	r16, 0x00	; 0
    cdb2:	10 e0       	ldi	r17, 0x00	; 0
					WebMode = 1;
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
    cdb4:	80 91 06 01 	lds	r24, 0x0106
    cdb8:	81 30       	cpi	r24, 0x01	; 1
    cdba:	09 f0       	breq	.+2      	; 0xcdbe <WebServer+0x316>
    cdbc:	9f c2       	rjmp	.+1342   	; 0xd2fc <WebServer+0x854>
							WebHrefHiddenCnt = 1;
							i--;
							WebDataCnt--;
						}
						if(SeekTagIMG_SRC(ch)){ 
							WebImgSrcHiddenCnt = 1;
    cdbe:	bb 24       	eor	r11, r11
    cdc0:	b3 94       	inc	r11
				}
			}
			
			// HTML- 			
			if(WebMode == 1){
				while(i<sizeof(GSM_TxStr)){
    cdc2:	0f 3f       	cpi	r16, 0xFF	; 255
    cdc4:	11 05       	cpc	r17, r1
    cdc6:	08 f0       	brcs	.+2      	; 0xcdca <WebServer+0x322>
    cdc8:	b0 c0       	rjmp	.+352    	; 0xcf2a <WebServer+0x482>
					char ch;
					if(WebImgSrcHiddenCnt){
    cdca:	80 91 e8 03 	lds	r24, 0x03E8
    cdce:	c0 90 3f 02 	lds	r12, 0x023F
    cdd2:	d0 90 40 02 	lds	r13, 0x0240
    cdd6:	88 23       	and	r24, r24
    cdd8:	a1 f0       	breq	.+40     	; 0xce02 <WebServer+0x35a>
    cdda:	e8 2f       	mov	r30, r24
    cddc:	f0 e0       	ldi	r31, 0x00	; 0
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
    cdde:	89 30       	cpi	r24, 0x09	; 9
    cde0:	20 f0       	brcs	.+8      	; 0xcdea <WebServer+0x342>
    cde2:	e0 5e       	subi	r30, 0xE0	; 224
    cde4:	f9 4f       	sbci	r31, 0xF9	; 249
    cde6:	a0 80       	ld	r10, Z
    cde8:	03 c0       	rjmp	.+6      	; 0xcdf0 <WebServer+0x348>
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
    cdea:	ef 5b       	subi	r30, 0xBF	; 191
    cdec:	f3 4b       	sbci	r31, 0xB3	; 179

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cdee:	a4 90       	lpm	r10, Z
						WebImgSrcHiddenCnt++ ;
    cdf0:	8f 5f       	subi	r24, 0xFF	; 255
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    cdf2:	89 31       	cpi	r24, 0x19	; 25
    cdf4:	18 f4       	brcc	.+6      	; 0xcdfc <WebServer+0x354>
					char ch;
					if(WebImgSrcHiddenCnt){
						//       
						if(WebImgSrcHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebImgSrcHiddenCnt - sizeof(SESSID_pstr)];
						else ch = prc( SESSID_pstr + WebImgSrcHiddenCnt - 1);
						WebImgSrcHiddenCnt++ ;
    cdf6:	80 93 e8 03 	sts	0x03E8, r24
    cdfa:	46 c0       	rjmp	.+140    	; 0xce88 <WebServer+0x3e0>
						if(WebImgSrcHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebImgSrcHiddenCnt=0;
    cdfc:	10 92 e8 03 	sts	0x03E8, r1
    ce00:	43 c0       	rjmp	.+134    	; 0xce88 <WebServer+0x3e0>
					}
					else{
						if(WebHrefHiddenCnt){
    ce02:	80 91 28 06 	lds	r24, 0x0628
    ce06:	88 23       	and	r24, r24
    ce08:	a1 f0       	breq	.+40     	; 0xce32 <WebServer+0x38a>
    ce0a:	e8 2f       	mov	r30, r24
    ce0c:	f0 e0       	ldi	r31, 0x00	; 0
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
    ce0e:	89 30       	cpi	r24, 0x09	; 9
    ce10:	20 f0       	brcs	.+8      	; 0xce1a <WebServer+0x372>
    ce12:	e0 5e       	subi	r30, 0xE0	; 224
    ce14:	f9 4f       	sbci	r31, 0xF9	; 249
    ce16:	a0 80       	ld	r10, Z
    ce18:	03 c0       	rjmp	.+6      	; 0xce20 <WebServer+0x378>
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
    ce1a:	ef 5b       	subi	r30, 0xBF	; 191
    ce1c:	f3 4b       	sbci	r31, 0xB3	; 179
    ce1e:	a4 90       	lpm	r10, Z
							WebHrefHiddenCnt++ ;
    ce20:	8f 5f       	subi	r24, 0xFF	; 255
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    ce22:	89 31       	cpi	r24, 0x19	; 25
    ce24:	18 f4       	brcc	.+6      	; 0xce2c <WebServer+0x384>
					else{
						if(WebHrefHiddenCnt){
							//       
							if(WebHrefHiddenCnt >= sizeof(SESSID_pstr) ) ch = SESSID_Str[WebHrefHiddenCnt - sizeof(SESSID_pstr)];
							else ch = prc( SESSID_pstr + WebHrefHiddenCnt - 1);
							WebHrefHiddenCnt++ ;
    ce26:	80 93 28 06 	sts	0x0628, r24
    ce2a:	2e c0       	rjmp	.+92     	; 0xce88 <WebServer+0x3e0>
							if(WebHrefHiddenCnt > (sizeof(SESSID_pstr) + sizeof(SESSID_Str)-3 - 2) ) WebHrefHiddenCnt=0;
    ce2c:	10 92 28 06 	sts	0x0628, r1
    ce30:	2b c0       	rjmp	.+86     	; 0xce88 <WebServer+0x3e0>
						}
						else{
							if(WebInputHiddenCnt){
    ce32:	80 91 e9 03 	lds	r24, 0x03E9
    ce36:	88 23       	and	r24, r24
    ce38:	a1 f0       	breq	.+40     	; 0xce62 <WebServer+0x3ba>
    ce3a:	e8 2f       	mov	r30, r24
    ce3c:	f0 e0       	ldi	r31, 0x00	; 0
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
    ce3e:	8b 32       	cpi	r24, 0x2B	; 43
    ce40:	20 f0       	brcs	.+8      	; 0xce4a <WebServer+0x3a2>
    ce42:	e2 50       	subi	r30, 0x02	; 2
    ce44:	fa 4f       	sbci	r31, 0xFA	; 250
    ce46:	a0 80       	ld	r10, Z
    ce48:	03 c0       	rjmp	.+6      	; 0xce50 <WebServer+0x3a8>
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
    ce4a:	e6 5b       	subi	r30, 0xB6	; 182
    ce4c:	f3 4b       	sbci	r31, 0xB3	; 179
    ce4e:	a4 90       	lpm	r10, Z
								WebInputHiddenCnt++ ;
    ce50:	8f 5f       	subi	r24, 0xFF	; 255
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    ce52:	8e 33       	cpi	r24, 0x3E	; 62
    ce54:	18 f4       	brcc	.+6      	; 0xce5c <WebServer+0x3b4>
						else{
							if(WebInputHiddenCnt){
								//     .   
								if(WebInputHiddenCnt >= sizeof(inputSESSID_Str) ) ch = SESSID_Str[WebInputHiddenCnt - sizeof(inputSESSID_Str)];
								else ch = prc( inputSESSID_Str + WebInputHiddenCnt - 1);
								WebInputHiddenCnt++ ;
    ce56:	80 93 e9 03 	sts	0x03E9, r24
    ce5a:	16 c0       	rjmp	.+44     	; 0xce88 <WebServer+0x3e0>
								if(WebInputHiddenCnt > (sizeof(inputSESSID_Str) + sizeof(SESSID_Str) - 2) ) WebInputHiddenCnt=0;
    ce5c:	10 92 e9 03 	sts	0x03E9, r1
    ce60:	13 c0       	rjmp	.+38     	; 0xce88 <WebServer+0x3e0>
							}
							else{
								ch= prc( prp(&ptrPage->Content) + WebDataCnt++);
    ce62:	f6 01       	movw	r30, r12
    ce64:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    ce66:	25 91       	lpm	r18, Z+
    ce68:	34 91       	lpm	r19, Z
    ce6a:	80 91 f0 03 	lds	r24, 0x03F0
    ce6e:	90 91 f1 03 	lds	r25, 0x03F1
    ce72:	ac 01       	movw	r20, r24
    ce74:	4f 5f       	subi	r20, 0xFF	; 255
    ce76:	5f 4f       	sbci	r21, 0xFF	; 255
    ce78:	50 93 f1 03 	sts	0x03F1, r21
    ce7c:	40 93 f0 03 	sts	0x03F0, r20
    ce80:	f9 01       	movw	r30, r18
    ce82:	e8 0f       	add	r30, r24
    ce84:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    ce86:	a4 90       	lpm	r10, Z
							}
						}
					}

					GSM_TxStr[i++] = ch;
    ce88:	78 01       	movw	r14, r16
    ce8a:	8f ef       	ldi	r24, 0xFF	; 255
    ce8c:	e8 1a       	sub	r14, r24
    ce8e:	f8 0a       	sbc	r15, r24
    ce90:	d8 01       	movw	r26, r16
    ce92:	a7 5c       	subi	r26, 0xC7	; 199
    ce94:	b3 4f       	sbci	r27, 0xF3	; 243
    ce96:	ac 92       	st	X, r10
					if(ptrPage != &Web_login){	//  login.html   !
    ce98:	99 e9       	ldi	r25, 0x99	; 153
    ce9a:	c9 16       	cp	r12, r25
    ce9c:	98 e4       	ldi	r25, 0x48	; 72
    ce9e:	d9 06       	cpc	r13, r25
    cea0:	59 f1       	breq	.+86     	; 0xcef8 <WebServer+0x450>
						if(SeekTagFORM(ch)) WebInputHiddenCnt = 1;
    cea2:	8a 2d       	mov	r24, r10
    cea4:	0e 94 9d 47 	call	0x8f3a	; 0x8f3a <SeekTagFORM>
    cea8:	81 11       	cpse	r24, r1
    ceaa:	b0 92 e9 03 	sts	0x03E9, r11
						if(SeekTagA_HREF(ch)){ 
    ceae:	8a 2d       	mov	r24, r10
    ceb0:	0e 94 d9 47 	call	0x8fb2	; 0x8fb2 <SeekTagA_HREF>
    ceb4:	88 23       	and	r24, r24
    ceb6:	69 f0       	breq	.+26     	; 0xced2 <WebServer+0x42a>
							WebHrefHiddenCnt = 1;
    ceb8:	b0 92 28 06 	sts	0x0628, r11
							i--;
							WebDataCnt--;
    cebc:	20 91 f0 03 	lds	r18, 0x03F0
    cec0:	30 91 f1 03 	lds	r19, 0x03F1
    cec4:	21 50       	subi	r18, 0x01	; 1
    cec6:	31 09       	sbc	r19, r1
    cec8:	30 93 f1 03 	sts	0x03F1, r19
    cecc:	20 93 f0 03 	sts	0x03F0, r18
    ced0:	78 01       	movw	r14, r16
						}
						if(SeekTagIMG_SRC(ch)){ 
    ced2:	8a 2d       	mov	r24, r10
    ced4:	0e 94 15 48 	call	0x902a	; 0x902a <SeekTagIMG_SRC>
    ced8:	88 23       	and	r24, r24
    ceda:	71 f0       	breq	.+28     	; 0xcef8 <WebServer+0x450>
							WebImgSrcHiddenCnt = 1;
    cedc:	b0 92 e8 03 	sts	0x03E8, r11
							i--;
    cee0:	e1 e0       	ldi	r30, 0x01	; 1
    cee2:	ee 1a       	sub	r14, r30
    cee4:	f1 08       	sbc	r15, r1
							WebDataCnt--;
    cee6:	80 91 f0 03 	lds	r24, 0x03F0
    ceea:	90 91 f1 03 	lds	r25, 0x03F1
    ceee:	01 97       	sbiw	r24, 0x01	; 1
    cef0:	90 93 f1 03 	sts	0x03F1, r25
    cef4:	80 93 f0 03 	sts	0x03F0, r24
						}						
					}

					if(WebDataCnt >= prw(&ptrPage->ContentSz)){
    cef8:	f8 e0       	ldi	r31, 0x08	; 8
    cefa:	cf 0e       	add	r12, r31
    cefc:	d1 1c       	adc	r13, r1

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
uint16_t
prw(const prog_uint16_t *addr)
{
	return pgm_read_word(addr);
    cefe:	f6 01       	movw	r30, r12
    cf00:	85 91       	lpm	r24, Z+
    cf02:	94 91       	lpm	r25, Z
    cf04:	20 91 f0 03 	lds	r18, 0x03F0
    cf08:	30 91 f1 03 	lds	r19, 0x03F1
    cf0c:	28 17       	cp	r18, r24
    cf0e:	39 07       	cpc	r19, r25
    cf10:	10 f4       	brcc	.+4      	; 0xcf16 <WebServer+0x46e>
    cf12:	87 01       	movw	r16, r14
    cf14:	56 cf       	rjmp	.-340    	; 0xcdc2 <WebServer+0x31a>
						StartTimer16(TD_FlowDelay, EndPacketDelay);
    cf16:	68 ec       	ldi	r22, 0xC8	; 200
    cf18:	70 e0       	ldi	r23, 0x00	; 0
    cf1a:	80 91 4f 09 	lds	r24, 0x094F
    cf1e:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
						WebMode = 2;
    cf22:	82 e0       	ldi	r24, 0x02	; 2
    cf24:	80 93 06 01 	sts	0x0106, r24
						break;
    cf28:	87 01       	movw	r16, r14
					}
				}
				//
				if(ptrIF != NULL){
    cf2a:	c0 90 3c 02 	lds	r12, 0x023C
    cf2e:	d0 90 3d 02 	lds	r13, 0x023D
    cf32:	c1 14       	cp	r12, r1
    cf34:	d1 04       	cpc	r13, r1
    cf36:	09 f4       	brne	.+2      	; 0xcf3a <WebServer+0x492>
    cf38:	be c1       	rjmp	.+892    	; 0xd2b6 <WebServer+0x80e>
					//   
					if(prc(prp( &ptrPage->Content) + WebDataCnt ) == '{'){
    cf3a:	e0 91 3f 02 	lds	r30, 0x023F
    cf3e:	f0 91 40 02 	lds	r31, 0x0240
    cf42:	3a 96       	adiw	r30, 0x0a	; 10

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cf44:	25 91       	lpm	r18, Z+
    cf46:	34 91       	lpm	r19, Z
    cf48:	80 91 f0 03 	lds	r24, 0x03F0
    cf4c:	90 91 f1 03 	lds	r25, 0x03F1
    cf50:	f9 01       	movw	r30, r18
    cf52:	e8 0f       	add	r30, r24
    cf54:	f9 1f       	adc	r31, r25

// ~~~~~~~~~~~~
char
prc(PGM_P addr)
{
	return pgm_read_byte(addr);
    cf56:	24 91       	lpm	r18, Z
    cf58:	2b 37       	cpi	r18, 0x7B	; 123
    cf5a:	a1 f4       	brne	.+40     	; 0xcf84 <WebServer+0x4dc>
    cf5c:	80 1b       	sub	r24, r16
    cf5e:	91 0b       	sbc	r25, r17
    cf60:	ac 01       	movw	r20, r24
    cf62:	40 0f       	add	r20, r16
    cf64:	51 1f       	adc	r21, r17
						while(GSM_TxStr[i-1] == '{'){
    cf66:	98 01       	movw	r18, r16
    cf68:	21 50       	subi	r18, 0x01	; 1
    cf6a:	31 09       	sbc	r19, r1
    cf6c:	f9 01       	movw	r30, r18
    cf6e:	e7 5c       	subi	r30, 0xC7	; 199
    cf70:	f3 4f       	sbci	r31, 0xF3	; 243
    cf72:	60 81       	ld	r22, Z
    cf74:	6b 37       	cpi	r22, 0x7B	; 123
    cf76:	11 f4       	brne	.+4      	; 0xcf7c <WebServer+0x4d4>
							WebDataCnt--;
							i--;
    cf78:	89 01       	movw	r16, r18
    cf7a:	f2 cf       	rjmp	.-28     	; 0xcf60 <WebServer+0x4b8>
    cf7c:	50 93 f1 03 	sts	0x03F1, r21
    cf80:	40 93 f0 03 	sts	0x03F0, r20
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    cf84:	0b 87       	std	Y+11, r16	; 0x0b
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    cf86:	61 2c       	mov	r6, r1
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    cf88:	aa 24       	eor	r10, r10
    cf8a:	a3 94       	inc	r10
    cf8c:	b1 2c       	mov	r11, r1
void
Put_zVal_h(uint32_t Val, char Type, T_Param *Param)
{
	if(Type=='b') sprintf(Param->Pos, "%02hx", (uint8_t)Val);
	if(Type=='w') sprintf(Param->Pos, "%04x", (uint16_t)Val);
	if(Type=='l') sprintf(Param->Pos, "%08lx", Val);
    cf8e:	ab e3       	ldi	r26, 0x3B	; 59
    cf90:	4a 2e       	mov	r4, r26
    cf92:	a1 e0       	ldi	r26, 0x01	; 1
    cf94:	5a 2e       	mov	r5, r26
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    cf96:	4b 85       	ldd	r20, Y+11	; 0x0b
    cf98:	64 16       	cp	r6, r20
    cf9a:	08 f0       	brcs	.+2      	; 0xcf9e <WebServer+0x4f6>
    cf9c:	88 c1       	rjmp	.+784    	; 0xd2ae <WebServer+0x806>
		char Char;
		T_Param Param;
		Param.Pos = &GSM_TxStr[X];
    cf9e:	e6 2c       	mov	r14, r6
    cfa0:	f1 2c       	mov	r15, r1
    cfa2:	97 01       	movw	r18, r14
    cfa4:	27 5c       	subi	r18, 0xC7	; 199
    cfa6:	33 4f       	sbci	r19, 0xF3	; 243
    cfa8:	79 01       	movw	r14, r18
    cfaa:	3a 83       	std	Y+2, r19	; 0x02
    cfac:	29 83       	std	Y+1, r18	; 0x01
		Param.Size = 0;
    cfae:	1c 82       	std	Y+4, r1	; 0x04
		switch(Char=GSM_TxStr[X]) {
    cfb0:	f9 01       	movw	r30, r18
    cfb2:	70 80       	ld	r7, Z
    cfb4:	fb e7       	ldi	r31, 0x7B	; 123
    cfb6:	7f 12       	cpse	r7, r31
    cfb8:	6f c1       	rjmp	.+734    	; 0xd298 <WebServer+0x7f0>
    cfba:	80 e0       	ldi	r24, 0x00	; 0
		case '{':
			while((Char = GSM_TxStr[X + ++Param.Size])=='{');
    cfbc:	8f 5f       	subi	r24, 0xFF	; 255
    cfbe:	48 2f       	mov	r20, r24
    cfc0:	50 e0       	ldi	r21, 0x00	; 0
    cfc2:	f7 01       	movw	r30, r14
    cfc4:	e4 0f       	add	r30, r20
    cfc6:	f5 1f       	adc	r31, r21
    cfc8:	70 80       	ld	r7, Z
    cfca:	2b e7       	ldi	r18, 0x7B	; 123
    cfcc:	72 16       	cp	r7, r18
    cfce:	b1 f3       	breq	.-20     	; 0xcfbc <WebServer+0x514>
    cfd0:	8c 83       	std	Y+4, r24	; 0x04
			Param.Prec = prb(&IF->Prec);
    cfd2:	f6 01       	movw	r30, r12
    cfd4:	35 96       	adiw	r30, 0x05	; 5

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cfd6:	e4 91       	lpm	r30, Z
    cfd8:	eb 83       	std	Y+3, r30	; 0x03
			Param.Txt = prp(&IF->EnumList);
    cfda:	f6 01       	movw	r30, r12
    cfdc:	33 96       	adiw	r30, 0x03	; 3

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    cfde:	85 90       	lpm	r8, Z+
    cfe0:	94 90       	lpm	r9, Z
    cfe2:	9e 82       	std	Y+6, r9	; 0x06
    cfe4:	8d 82       	std	Y+5, r8	; 0x05
			WebPutField(prb(&IF->Type), prp(&IF->Var), &Param);
    cfe6:	f6 01       	movw	r30, r12
    cfe8:	31 96       	adiw	r30, 0x01	; 1
    cfea:	a5 91       	lpm	r26, Z+
    cfec:	b4 91       	lpm	r27, Z

// ~~~~~~~~~~~~~~~~~~~~~~~~~~
uint8_t
prb(const prog_uint8_t *addr)
{
	return pgm_read_byte(addr);
    cfee:	f6 01       	movw	r30, r12
    cff0:	64 91       	lpm	r22, Z
static void
WebPutField(uint8_t Type, void *Var, T_Param *Param)
{
	float fTemp;

	switch(Type) {
    cff2:	70 e0       	ldi	r23, 0x00	; 0
    cff4:	63 32       	cpi	r22, 0x23	; 35
    cff6:	71 05       	cpc	r23, r1
    cff8:	08 f0       	brcs	.+2      	; 0xcffc <WebServer+0x554>
    cffa:	4b c1       	rjmp	.+662    	; 0xd292 <WebServer+0x7ea>
    cffc:	fb 01       	movw	r30, r22
    cffe:	ec 5b       	subi	r30, 0xBC	; 188
    d000:	fe 4f       	sbci	r31, 0xFE	; 254
    d002:	0c 94 af 75 	jmp	0xeb5e	; 0xeb5e <__tablejump2__>
	case Byte:
		PutVal(*(uint8_t*)Var, 'b', Param);
    d006:	8c 91       	ld	r24, X
    d008:	03 c0       	rjmp	.+6      	; 0xd010 <WebServer+0x568>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d00a:	cd 01       	movw	r24, r26
    d00c:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		break;
	case EE_Byte:
		PutVal(erb((uint8_t*)Var), 'b', Param);
    d010:	ae 01       	movw	r20, r28
    d012:	4f 5f       	subi	r20, 0xFF	; 255
    d014:	5f 4f       	sbci	r21, 0xFF	; 255
    d016:	62 e6       	ldi	r22, 0x62	; 98
    d018:	90 e0       	ldi	r25, 0x00	; 0
    d01a:	0e 94 a3 3e 	call	0x7d46	; 0x7d46 <PutVal>
    d01e:	39 c1       	rjmp	.+626    	; 0xd292 <WebServer+0x7ea>
		break;
	case s_Byte:
		Put_sVal(*(int8_t*)Var, 'b', Param);
    d020:	8c 91       	ld	r24, X
    d022:	03 c0       	rjmp	.+6      	; 0xd02a <WebServer+0x582>
    d024:	cd 01       	movw	r24, r26
    d026:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		break;
	case s_EE_Byte:
		Put_sVal((int8_t)erb((uint8_t*)Var), 'b', Param);
    d02a:	ae 01       	movw	r20, r28
    d02c:	4f 5f       	subi	r20, 0xFF	; 255
    d02e:	5f 4f       	sbci	r21, 0xFF	; 255
    d030:	62 e6       	ldi	r22, 0x62	; 98
    d032:	99 27       	eor	r25, r25
    d034:	87 fd       	sbrc	r24, 7
    d036:	90 95       	com	r25
    d038:	0e 94 1e 3f 	call	0x7e3c	; 0x7e3c <Put_sVal>
    d03c:	2a c1       	rjmp	.+596    	; 0xd292 <WebServer+0x7ea>
		break;
	case z_Byte:
		Put_zVal(*(uint8_t*)Var, 'b', Param);
    d03e:	8c 91       	ld	r24, X
    d040:	03 c0       	rjmp	.+6      	; 0xd048 <WebServer+0x5a0>
    d042:	cd 01       	movw	r24, r26
    d044:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		break;
	case z_EE_Byte:
		Put_zVal(erb((uint8_t*)Var), 'b', Param);
    d048:	ae 01       	movw	r20, r28
    d04a:	4f 5f       	subi	r20, 0xFF	; 255
    d04c:	5f 4f       	sbci	r21, 0xFF	; 255
    d04e:	62 e6       	ldi	r22, 0x62	; 98
    d050:	90 e0       	ldi	r25, 0x00	; 0
    d052:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <Put_zVal>
    d056:	1d c1       	rjmp	.+570    	; 0xd292 <WebServer+0x7ea>
		break;

	case zh_Byte:
		Put_zVal_h(*(uint8_t*)Var, 'b', Param);
    d058:	6c 91       	ld	r22, X
    d05a:	70 e0       	ldi	r23, 0x00	; 0
    d05c:	80 e0       	ldi	r24, 0x00	; 0
    d05e:	90 e0       	ldi	r25, 0x00	; 0
    d060:	9e 01       	movw	r18, r28
    d062:	2f 5f       	subi	r18, 0xFF	; 255
    d064:	3f 4f       	sbci	r19, 0xFF	; 255
    d066:	42 e6       	ldi	r20, 0x62	; 98
    d068:	08 c0       	rjmp	.+16     	; 0xd07a <WebServer+0x5d2>
		break;
	case zh_Word:
		Put_zVal_h(*(uint16_t*)Var, 'w', Param);
    d06a:	6d 91       	ld	r22, X+
    d06c:	7c 91       	ld	r23, X
    d06e:	80 e0       	ldi	r24, 0x00	; 0
    d070:	90 e0       	ldi	r25, 0x00	; 0
    d072:	9e 01       	movw	r18, r28
    d074:	2f 5f       	subi	r18, 0xFF	; 255
    d076:	3f 4f       	sbci	r19, 0xFF	; 255
    d078:	47 e7       	ldi	r20, 0x77	; 119
    d07a:	0e 94 43 40 	call	0x8086	; 0x8086 <Put_zVal_h>
    d07e:	09 c1       	rjmp	.+530    	; 0xd292 <WebServer+0x7ea>
    d080:	13 96       	adiw	r26, 0x03	; 3
    d082:	8c 91       	ld	r24, X
    d084:	13 97       	sbiw	r26, 0x03	; 3
    d086:	8f 93       	push	r24
    d088:	12 96       	adiw	r26, 0x02	; 2
    d08a:	8c 91       	ld	r24, X
    d08c:	12 97       	sbiw	r26, 0x02	; 2
    d08e:	8f 93       	push	r24
    d090:	11 96       	adiw	r26, 0x01	; 1
    d092:	8c 91       	ld	r24, X
    d094:	11 97       	sbiw	r26, 0x01	; 1
    d096:	8f 93       	push	r24
    d098:	8c 91       	ld	r24, X
    d09a:	8f 93       	push	r24
    d09c:	5f 92       	push	r5
    d09e:	4f 92       	push	r4
    d0a0:	ff 92       	push	r15
    d0a2:	ef 92       	push	r14
    d0a4:	0e 94 ef 6c 	call	0xd9de	; 0xd9de <sprintf>
    d0a8:	2d b7       	in	r18, 0x3d	; 61
    d0aa:	3e b7       	in	r19, 0x3e	; 62
    d0ac:	28 5f       	subi	r18, 0xF8	; 248
    d0ae:	3f 4f       	sbci	r19, 0xFF	; 255
    d0b0:	0f b6       	in	r0, 0x3f	; 63
    d0b2:	f8 94       	cli
    d0b4:	3e bf       	out	0x3e, r19	; 62
    d0b6:	0f be       	out	0x3f, r0	; 63
    d0b8:	2d bf       	out	0x3d, r18	; 61
    d0ba:	eb c0       	rjmp	.+470    	; 0xd292 <WebServer+0x7ea>
	case zh_Longint:
		Put_zVal_h(*(uint32_t*)Var, 'l', Param);
		break;

	case Word: case c_Word:
		PutVal(*(uint16_t*)Var, 'w', Param);
    d0bc:	ae 01       	movw	r20, r28
    d0be:	4f 5f       	subi	r20, 0xFF	; 255
    d0c0:	5f 4f       	sbci	r21, 0xFF	; 255
    d0c2:	67 e7       	ldi	r22, 0x77	; 119
    d0c4:	8d 91       	ld	r24, X+
    d0c6:	9c 91       	ld	r25, X
    d0c8:	a8 cf       	rjmp	.-176    	; 0xd01a <WebServer+0x572>
// ~~~~~~~~~~~~~~~~~~~~~~
uint16_t
erw(const uint16_t *addr)
{
	//IntOff();
	uint16_t word = eeprom_read_word(addr);
    d0ca:	cd 01       	movw	r24, r26
    d0cc:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		break;
	case EE_Word:
		PutVal(erw((uint16_t*)Var), 'w', Param);
    d0d0:	ae 01       	movw	r20, r28
    d0d2:	4f 5f       	subi	r20, 0xFF	; 255
    d0d4:	5f 4f       	sbci	r21, 0xFF	; 255
    d0d6:	67 e7       	ldi	r22, 0x77	; 119
    d0d8:	a0 cf       	rjmp	.-192    	; 0xd01a <WebServer+0x572>
		break;
	case s_Word:
		Put_sVal(*(int16_t*)Var, 'w', Param);
    d0da:	ae 01       	movw	r20, r28
    d0dc:	4f 5f       	subi	r20, 0xFF	; 255
    d0de:	5f 4f       	sbci	r21, 0xFF	; 255
    d0e0:	67 e7       	ldi	r22, 0x77	; 119
    d0e2:	8d 91       	ld	r24, X+
    d0e4:	9c 91       	ld	r25, X
    d0e6:	a8 cf       	rjmp	.-176    	; 0xd038 <WebServer+0x590>
    d0e8:	cd 01       	movw	r24, r26
    d0ea:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		break;
	case s_EE_Word:
		Put_sVal((int16_t)erw((uint16_t*)Var), 'w', Param);
    d0ee:	ae 01       	movw	r20, r28
    d0f0:	4f 5f       	subi	r20, 0xFF	; 255
    d0f2:	5f 4f       	sbci	r21, 0xFF	; 255
    d0f4:	67 e7       	ldi	r22, 0x77	; 119
    d0f6:	a0 cf       	rjmp	.-192    	; 0xd038 <WebServer+0x590>
		break;
	case z_Word: case zc_Word:
		Put_zVal(*(uint16_t*)Var, 'w', Param);
    d0f8:	ae 01       	movw	r20, r28
    d0fa:	4f 5f       	subi	r20, 0xFF	; 255
    d0fc:	5f 4f       	sbci	r21, 0xFF	; 255
    d0fe:	67 e7       	ldi	r22, 0x77	; 119
    d100:	8d 91       	ld	r24, X+
    d102:	9c 91       	ld	r25, X
    d104:	a6 cf       	rjmp	.-180    	; 0xd052 <WebServer+0x5aa>
    d106:	cd 01       	movw	r24, r26
    d108:	0e 94 08 74 	call	0xe810	; 0xe810 <__eerd_word_m128>
		break;
	case z_EE_Word:
		Put_zVal(erw((uint16_t*)Var), 'w', Param);
    d10c:	ae 01       	movw	r20, r28
    d10e:	4f 5f       	subi	r20, 0xFF	; 255
    d110:	5f 4f       	sbci	r21, 0xFF	; 255
    d112:	67 e7       	ldi	r22, 0x77	; 119
    d114:	9e cf       	rjmp	.-196    	; 0xd052 <WebServer+0x5aa>
		break;


	case Longint: case c_Longint:
		PutDVal(*(uint32_t*)Var, Param);
    d116:	6d 91       	ld	r22, X+
    d118:	7d 91       	ld	r23, X+
    d11a:	8d 91       	ld	r24, X+
    d11c:	9c 91       	ld	r25, X
    d11e:	03 c0       	rjmp	.+6      	; 0xd126 <WebServer+0x67e>
// ~~~~~~~~~~~~~~~~~~~~~~
uint32_t
erd(const uint32_t *addr)
{
	//IntOff();
	uint32_t word = eeprom_read_dword(addr);
    d120:	cd 01       	movw	r24, r26
    d122:	0e 94 02 74 	call	0xe804	; 0xe804 <__eerd_dword_m128>
		break;
	case EE_Longint:
		PutDVal(erd((uint32_t*)Var), Param);
    d126:	ae 01       	movw	r20, r28
    d128:	4f 5f       	subi	r20, 0xFF	; 255
    d12a:	5f 4f       	sbci	r21, 0xFF	; 255
    d12c:	0e 94 79 40 	call	0x80f2	; 0x80f2 <PutDVal>
    d130:	b0 c0       	rjmp	.+352    	; 0xd292 <WebServer+0x7ea>
		break;
	case s_Longint:
		Put_sDVal(*(int32_t*)Var, Param);
    d132:	6d 91       	ld	r22, X+
    d134:	7d 91       	ld	r23, X+
    d136:	8d 91       	ld	r24, X+
    d138:	9c 91       	ld	r25, X
    d13a:	03 c0       	rjmp	.+6      	; 0xd142 <WebServer+0x69a>
    d13c:	cd 01       	movw	r24, r26
    d13e:	0e 94 02 74 	call	0xe804	; 0xe804 <__eerd_dword_m128>
		break;
	case s_EE_Longint:
		Put_sDVal((int32_t)erd((uint32_t*)Var), Param);
    d142:	ae 01       	movw	r20, r28
    d144:	4f 5f       	subi	r20, 0xFF	; 255
    d146:	5f 4f       	sbci	r21, 0xFF	; 255
    d148:	0e 94 0c 41 	call	0x8218	; 0x8218 <Put_sDVal>
    d14c:	a2 c0       	rjmp	.+324    	; 0xd292 <WebServer+0x7ea>
		break;
	case z_Longint: case zc_Longint:
		Put_zDVal(*(uint32_t*)Var, Param);
    d14e:	6d 91       	ld	r22, X+
    d150:	7d 91       	ld	r23, X+
    d152:	8d 91       	ld	r24, X+
    d154:	9c 91       	ld	r25, X
    d156:	03 c0       	rjmp	.+6      	; 0xd15e <WebServer+0x6b6>
    d158:	cd 01       	movw	r24, r26
    d15a:	0e 94 02 74 	call	0xe804	; 0xe804 <__eerd_dword_m128>
		break;
	case z_EE_Longint:
		Put_zDVal(erd((uint32_t*)Var), Param);
    d15e:	ae 01       	movw	r20, r28
    d160:	4f 5f       	subi	r20, 0xFF	; 255
    d162:	5f 4f       	sbci	r21, 0xFF	; 255
    d164:	0e 94 04 42 	call	0x8408	; 0x8408 <Put_zDVal>
    d168:	94 c0       	rjmp	.+296    	; 0xd292 <WebServer+0x7ea>
		break;

		
	case FFloat:
		Put_FFVal(*(float*)Var, Param);
    d16a:	6d 91       	ld	r22, X+
    d16c:	7d 91       	ld	r23, X+
    d16e:	8d 91       	ld	r24, X+
    d170:	9c 91       	ld	r25, X
    d172:	0b c0       	rjmp	.+22     	; 0xd18a <WebServer+0x6e2>
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d174:	44 e0       	ldi	r20, 0x04	; 4
    d176:	50 e0       	ldi	r21, 0x00	; 0
    d178:	bd 01       	movw	r22, r26
    d17a:	ce 01       	movw	r24, r28
    d17c:	07 96       	adiw	r24, 0x07	; 7
    d17e:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
		break;			
	case EE_FFloat:
		erbl(&fTemp, Var, 4);
		Put_FFVal(fTemp, Param);
    d182:	6f 81       	ldd	r22, Y+7	; 0x07
    d184:	78 85       	ldd	r23, Y+8	; 0x08
    d186:	89 85       	ldd	r24, Y+9	; 0x09
    d188:	9a 85       	ldd	r25, Y+10	; 0x0a
    d18a:	ae 01       	movw	r20, r28
    d18c:	4f 5f       	subi	r20, 0xFF	; 255
    d18e:	5f 4f       	sbci	r21, 0xFF	; 255
    d190:	0e 94 97 42 	call	0x852e	; 0x852e <Put_FFVal>
    d194:	7e c0       	rjmp	.+252    	; 0xd292 <WebServer+0x7ea>
		break;
	case GFloat:
		Put_GFVal(*(float*)Var, Param);
    d196:	6d 91       	ld	r22, X+
    d198:	7d 91       	ld	r23, X+
    d19a:	8d 91       	ld	r24, X+
    d19c:	9c 91       	ld	r25, X
    d19e:	0b c0       	rjmp	.+22     	; 0xd1b6 <WebServer+0x70e>
    d1a0:	44 e0       	ldi	r20, 0x04	; 4
    d1a2:	50 e0       	ldi	r21, 0x00	; 0
    d1a4:	bd 01       	movw	r22, r26
    d1a6:	ce 01       	movw	r24, r28
    d1a8:	07 96       	adiw	r24, 0x07	; 7
    d1aa:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
		break;			
	case EE_GFloat:
		erbl(&fTemp, Var, 4);
		Put_GFVal(fTemp, Param);
    d1ae:	6f 81       	ldd	r22, Y+7	; 0x07
    d1b0:	78 85       	ldd	r23, Y+8	; 0x08
    d1b2:	89 85       	ldd	r24, Y+9	; 0x09
    d1b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    d1b6:	ae 01       	movw	r20, r28
    d1b8:	4f 5f       	subi	r20, 0xFF	; 255
    d1ba:	5f 4f       	sbci	r21, 0xFF	; 255
    d1bc:	0e 94 d5 42 	call	0x85aa	; 0x85aa <Put_GFVal>
    d1c0:	68 c0       	rjmp	.+208    	; 0xd292 <WebServer+0x7ea>
		break;


	case Enum:
		Param->Txt += *(uint8_t*)Var;
    d1c2:	8c 91       	ld	r24, X
    d1c4:	03 c0       	rjmp	.+6      	; 0xd1cc <WebServer+0x724>
// ~~~~~~~~~~~~~~~~~~~~~
uint8_t
erb(const uint8_t *addr)
{
	//IntOff();
	uint8_t byte = eeprom_read_byte(addr);
    d1c6:	cd 01       	movw	r24, r26
    d1c8:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
		PutEnum(Param);
		break;
	case EE_Enum:
		Param->Txt += erb((uint8_t*)Var);
    d1cc:	88 0e       	add	r8, r24
    d1ce:	91 1c       	adc	r9, r1
    d1d0:	88 0e       	add	r8, r24
    d1d2:	91 1c       	adc	r9, r1
    d1d4:	9e 82       	std	Y+6, r9	; 0x06
    d1d6:	8d 82       	std	Y+5, r8	; 0x05
		PutEnum(Param);
    d1d8:	ce 01       	movw	r24, r28
    d1da:	01 96       	adiw	r24, 0x01	; 1
    d1dc:	0e 94 7d 3e 	call	0x7cfa	; 0x7cfa <PutEnum>
    d1e0:	58 c0       	rjmp	.+176    	; 0xd292 <WebServer+0x7ea>
		break;
	case Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((*((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1e2:	2b 81       	ldd	r18, Y+3	; 0x03
    d1e4:	82 2f       	mov	r24, r18
    d1e6:	86 95       	lsr	r24
    d1e8:	86 95       	lsr	r24
    d1ea:	86 95       	lsr	r24
    d1ec:	a8 0f       	add	r26, r24
    d1ee:	b1 1d       	adc	r27, r1
    d1f0:	8c 91       	ld	r24, X
    d1f2:	90 e0       	ldi	r25, 0x00	; 0
    d1f4:	0e c0       	rjmp	.+28     	; 0xd212 <WebServer+0x76a>
		break;
	case EE_Bit:
		strcpy_P(Param->Pos, prp(Param->Txt+((erb((uint8_t*)Var+Param->Prec/8) &(1<<Param->Prec%8))>0)));
    d1f6:	2b 81       	ldd	r18, Y+3	; 0x03
    d1f8:	82 2f       	mov	r24, r18
    d1fa:	86 95       	lsr	r24
    d1fc:	86 95       	lsr	r24
    d1fe:	86 95       	lsr	r24
    d200:	fd 01       	movw	r30, r26
    d202:	e8 0f       	add	r30, r24
    d204:	f1 1d       	adc	r31, r1
    d206:	cf 01       	movw	r24, r30
    d208:	2c 87       	std	Y+12, r18	; 0x0c
    d20a:	0e 94 fa 73 	call	0xe7f4	; 0xe7f4 <__eerd_byte_m128>
    d20e:	90 e0       	ldi	r25, 0x00	; 0
    d210:	2c 85       	ldd	r18, Y+12	; 0x0c
    d212:	27 70       	andi	r18, 0x07	; 7
    d214:	a5 01       	movw	r20, r10
    d216:	02 c0       	rjmp	.+4      	; 0xd21c <WebServer+0x774>
    d218:	44 0f       	add	r20, r20
    d21a:	55 1f       	adc	r21, r21
    d21c:	2a 95       	dec	r18
    d21e:	e2 f7       	brpl	.-8      	; 0xd218 <WebServer+0x770>
    d220:	84 23       	and	r24, r20
    d222:	95 23       	and	r25, r21
    d224:	89 2b       	or	r24, r25
    d226:	19 f0       	breq	.+6      	; 0xd22e <WebServer+0x786>
    d228:	e2 e0       	ldi	r30, 0x02	; 2
    d22a:	f0 e0       	ldi	r31, 0x00	; 0
    d22c:	02 c0       	rjmp	.+4      	; 0xd232 <WebServer+0x78a>
    d22e:	e0 e0       	ldi	r30, 0x00	; 0
    d230:	f0 e0       	ldi	r31, 0x00	; 0
    d232:	e8 0d       	add	r30, r8
    d234:	f9 1d       	adc	r31, r9

// ~~~~~~~~~~~~~~~~~
void *
prp(PGM_VOID_P addr)
{
	return (void*)pgm_read_word(addr);
    d236:	65 91       	lpm	r22, Z+
    d238:	74 91       	lpm	r23, Z
    d23a:	c7 01       	movw	r24, r14
    d23c:	0e 94 71 6c 	call	0xd8e2	; 0xd8e2 <strcpy_P>
    d240:	28 c0       	rjmp	.+80     	; 0xd292 <WebServer+0x7ea>
		break;

	case Text:
		
		Put_TextValAlignLeft(Var, Param);
    d242:	be 01       	movw	r22, r28
    d244:	6f 5f       	subi	r22, 0xFF	; 255
    d246:	7f 4f       	sbci	r23, 0xFF	; 255
    d248:	cd 01       	movw	r24, r26
    d24a:	0e 94 28 43 	call	0x8650	; 0x8650 <Put_TextValAlignLeft>
    d24e:	21 c0       	rjmp	.+66     	; 0xd292 <WebServer+0x7ea>
    d250:	8d b6       	in	r8, 0x3d	; 61
    d252:	9e b6       	in	r9, 0x3e	; 62
		break;
	case EE_Text:{
			//char TempStr[LCDXSz+1];
			char TempStr[Param->Size+1];
    d254:	ca 01       	movw	r24, r20
    d256:	01 96       	adiw	r24, 0x01	; 1
    d258:	ed b7       	in	r30, 0x3d	; 61
    d25a:	fe b7       	in	r31, 0x3e	; 62
    d25c:	e8 1b       	sub	r30, r24
    d25e:	f9 0b       	sbc	r31, r25
    d260:	0f b6       	in	r0, 0x3f	; 63
    d262:	f8 94       	cli
    d264:	fe bf       	out	0x3e, r31	; 62
    d266:	0f be       	out	0x3f, r0	; 63
    d268:	ed bf       	out	0x3d, r30	; 61
    d26a:	2d b7       	in	r18, 0x3d	; 61
    d26c:	3e b7       	in	r19, 0x3e	; 62
    d26e:	2f 5f       	subi	r18, 0xFF	; 255
    d270:	3f 4f       	sbci	r19, 0xFF	; 255
    d272:	79 01       	movw	r14, r18
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
erbl(void *dst, const void *src, size_t n)
{
	//IntOff();
	eeprom_read_block(dst, src, n);
    d274:	bd 01       	movw	r22, r26
    d276:	c9 01       	movw	r24, r18
    d278:	0e 94 ea 73 	call	0xe7d4	; 0xe7d4 <__eerd_block_m128>
			erbl(TempStr, Var, Param->Size);
			Put_TextValAlignLeft(TempStr, Param);
    d27c:	be 01       	movw	r22, r28
    d27e:	6f 5f       	subi	r22, 0xFF	; 255
    d280:	7f 4f       	sbci	r23, 0xFF	; 255
    d282:	c7 01       	movw	r24, r14
    d284:	0e 94 28 43 	call	0x8650	; 0x8650 <Put_TextValAlignLeft>
    d288:	0f b6       	in	r0, 0x3f	; 63
    d28a:	f8 94       	cli
    d28c:	9e be       	out	0x3e, r9	; 62
    d28e:	0f be       	out	0x3f, r0	; 63
    d290:	8d be       	out	0x3d, r8	; 61
				if(prp(&IF->Var) == &LCD_Buf[0][0] && CurrLCD==0) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[1][0] && CurrLCD==1) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[2][0] && CurrLCD==2) GSM_TxStr[X] = '>';
				if(prp(&IF->Var) == &LCD_Buf[3][0] && CurrLCD==3) GSM_TxStr[X] = '>';
			#endif
			IF++;
    d292:	36 e0       	ldi	r19, 0x06	; 6
    d294:	c3 0e       	add	r12, r19
    d296:	d1 1c       	adc	r13, r1
			break;
		}
		GSM_TxStr[X+=Param.Size] = Char;
    d298:	8c 81       	ldd	r24, Y+4	; 0x04
    d29a:	86 0d       	add	r24, r6
    d29c:	e8 2f       	mov	r30, r24
    d29e:	f0 e0       	ldi	r31, 0x00	; 0
    d2a0:	e7 5c       	subi	r30, 0xC7	; 199
    d2a2:	f3 4f       	sbci	r31, 0xF3	; 243
    d2a4:	70 82       	st	Z, r7
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
static InField*
PutWebLine(InField *IF, const uint8_t Size)
{
	uint8_t X;
	for(X=0; X<Size; X++){
    d2a6:	66 24       	eor	r6, r6
    d2a8:	63 94       	inc	r6
    d2aa:	68 0e       	add	r6, r24
    d2ac:	74 ce       	rjmp	.-792    	; 0xcf96 <WebServer+0x4ee>
						while(GSM_TxStr[i-1] == '{'){
							WebDataCnt--;
							i--;
						}
					}
					ptrIF = PutWebLine(ptrIF, i);
    d2ae:	d0 92 3d 02 	sts	0x023D, r13
    d2b2:	c0 92 3c 02 	sts	0x023C, r12
				}
				GSMTxSz = i;
    d2b6:	00 93 57 09 	sts	0x0957, r16
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d2ba:	20 91 57 09 	lds	r18, 0x0957
    d2be:	80 91 3a 02 	lds	r24, 0x023A
    d2c2:	90 91 3b 02 	lds	r25, 0x023B
    d2c6:	82 0f       	add	r24, r18
    d2c8:	91 1d       	adc	r25, r1
				if(PacketByteCount >= MaxPacketSz){
    d2ca:	81 15       	cp	r24, r1
    d2cc:	54 e0       	ldi	r21, 0x04	; 4
    d2ce:	95 07       	cpc	r25, r21
    d2d0:	28 f4       	brcc	.+10     	; 0xd2dc <WebServer+0x834>
					}
					ptrIF = PutWebLine(ptrIF, i);
				}
				GSMTxSz = i;
				//flowcontrol
				PacketByteCount += GSMTxSz;
    d2d2:	90 93 3b 02 	sts	0x023B, r25
    d2d6:	80 93 3a 02 	sts	0x023A, r24
    d2da:	0b c0       	rjmp	.+22     	; 0xd2f2 <WebServer+0x84a>
				if(PacketByteCount >= MaxPacketSz){
					PacketByteCount -= MaxPacketSz;
    d2dc:	94 50       	subi	r25, 0x04	; 4
    d2de:	90 93 3b 02 	sts	0x023B, r25
    d2e2:	80 93 3a 02 	sts	0x023A, r24
					StartTimer16(TD_FlowDelay, InterPacketDelay);
    d2e6:	68 ec       	ldi	r22, 0xC8	; 200
    d2e8:	70 e0       	ldi	r23, 0x00	; 0
    d2ea:	80 91 4f 09 	lds	r24, 0x094F
    d2ee:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
				}
				GSM_SendFirstChar();
    d2f2:	0e 94 b9 57 	call	0xaf72	; 0xaf72 <GSM_SendFirstChar>
    d2f6:	02 c0       	rjmp	.+4      	; 0xd2fc <WebServer+0x854>

		}

	}
	else{
		StartTimeoutWaitRequest = 0;
    d2f8:	10 92 3e 02 	sts	0x023E, r1
	}

}
    d2fc:	0f b6       	in	r0, 0x3f	; 63
    d2fe:	f8 94       	cli
    d300:	3e be       	out	0x3e, r3	; 62
    d302:	0f be       	out	0x3f, r0	; 63
    d304:	2d be       	out	0x3d, r2	; 61
    d306:	2c 96       	adiw	r28, 0x0c	; 12
    d308:	0f b6       	in	r0, 0x3f	; 63
    d30a:	f8 94       	cli
    d30c:	de bf       	out	0x3e, r29	; 62
    d30e:	0f be       	out	0x3f, r0	; 63
    d310:	cd bf       	out	0x3d, r28	; 61
    d312:	df 91       	pop	r29
    d314:	cf 91       	pop	r28
    d316:	1f 91       	pop	r17
    d318:	0f 91       	pop	r16
    d31a:	ff 90       	pop	r15
    d31c:	ef 90       	pop	r14
    d31e:	df 90       	pop	r13
    d320:	cf 90       	pop	r12
    d322:	bf 90       	pop	r11
    d324:	af 90       	pop	r10
    d326:	9f 90       	pop	r9
    d328:	8f 90       	pop	r8
    d32a:	7f 90       	pop	r7
    d32c:	6f 90       	pop	r6
    d32e:	5f 90       	pop	r5
    d330:	4f 90       	pop	r4
    d332:	3f 90       	pop	r3
    d334:	2f 90       	pop	r2
    d336:	08 95       	ret

0000d338 <GSM_DRE>:
	}
}
// ~~~~~~~~~
void GSM_DRE(void){

	if(Transparent){
    d338:	80 91 76 0a 	lds	r24, 0x0A76
    d33c:	88 23       	and	r24, r24
    d33e:	09 f4       	brne	.+2      	; 0xd342 <GSM_DRE+0xa>
    d340:	55 c0       	rjmp	.+170    	; 0xd3ec <GSM_DRE+0xb4>
	return EMeter_RxCharN;
}
// ~~~~~~~~~~~
inline void GetByteFromEM_FIFO_Transp(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d342:	90 91 70 09 	lds	r25, 0x0970
    d346:	80 91 38 0d 	lds	r24, 0x0D38
    d34a:	98 17       	cp	r25, r24
    d34c:	a1 f0       	breq	.+40     	; 0xd376 <GSM_DRE+0x3e>
		EM_RX_FIFO_End++;
    d34e:	80 91 38 0d 	lds	r24, 0x0D38
    d352:	8f 5f       	subi	r24, 0xFF	; 255
    d354:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d358:	80 91 38 0d 	lds	r24, 0x0D38
    d35c:	8f 3f       	cpi	r24, 0xFF	; 255
    d35e:	11 f4       	brne	.+4      	; 0xd364 <GSM_DRE+0x2c>
    d360:	10 92 38 0d 	sts	0x0D38, r1
		UDR_GSM = EM_RX_FIFO[EM_RX_FIFO_End];
    d364:	e0 91 38 0d 	lds	r30, 0x0D38
    d368:	f0 e0       	ldi	r31, 0x00	; 0
    d36a:	e7 50       	subi	r30, 0x07	; 7
    d36c:	fc 4f       	sbci	r31, 0xFC	; 252
    d36e:	80 81       	ld	r24, Z
    d370:	8c b9       	out	0x0c, r24	; 12
		UCSR_GSM_A |= (1<<TXC0);	//Clear TxC pending interrupt
    d372:	5e 9a       	sbi	0x0b, 6	; 11
    d374:	02 c0       	rjmp	.+4      	; 0xd37a <GSM_DRE+0x42>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_GSM_B = (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d376:	88 ed       	ldi	r24, 0xD8	; 216
    d378:	8a b9       	out	0x0a, r24	; 10

	}

	//--- Calculate EM_RX_FIFOMax
	if(EM_RX_FIFO_Begin > EM_RX_FIFO_End){
    d37a:	90 91 70 09 	lds	r25, 0x0970
    d37e:	80 91 38 0d 	lds	r24, 0x0D38
    d382:	89 17       	cp	r24, r25
    d384:	a0 f4       	brcc	.+40     	; 0xd3ae <GSM_DRE+0x76>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_Begin - EM_RX_FIFO_End))
    d386:	20 91 6e 0a 	lds	r18, 0x0A6E
    d38a:	80 91 70 09 	lds	r24, 0x0970
    d38e:	40 91 38 0d 	lds	r20, 0x0D38
    d392:	30 e0       	ldi	r19, 0x00	; 0
    d394:	90 e0       	ldi	r25, 0x00	; 0
    d396:	84 1b       	sub	r24, r20
    d398:	91 09       	sbc	r25, r1
    d39a:	28 17       	cp	r18, r24
    d39c:	39 07       	cpc	r19, r25
    d39e:	3c f4       	brge	.+14     	; 0xd3ae <GSM_DRE+0x76>
				EM_RX_FIFOMax =  EM_RX_FIFO_Begin - EM_RX_FIFO_End;
    d3a0:	80 91 70 09 	lds	r24, 0x0970
    d3a4:	90 91 38 0d 	lds	r25, 0x0D38
    d3a8:	89 1b       	sub	r24, r25
    d3aa:	80 93 6e 0a 	sts	0x0A6E, r24
	}
	if(EM_RX_FIFO_End > EM_RX_FIFO_Begin){
    d3ae:	90 91 38 0d 	lds	r25, 0x0D38
    d3b2:	80 91 70 09 	lds	r24, 0x0970
    d3b6:	89 17       	cp	r24, r25
    d3b8:	e8 f5       	brcc	.+122    	; 0xd434 <GSM_DRE+0xfc>
			if(EM_RX_FIFOMax < (EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin))
    d3ba:	20 91 6e 0a 	lds	r18, 0x0A6E
    d3be:	50 91 38 0d 	lds	r21, 0x0D38
    d3c2:	40 91 70 09 	lds	r20, 0x0970
    d3c6:	30 e0       	ldi	r19, 0x00	; 0
    d3c8:	8f ef       	ldi	r24, 0xFF	; 255
    d3ca:	90 e0       	ldi	r25, 0x00	; 0
    d3cc:	85 1b       	sub	r24, r21
    d3ce:	91 09       	sbc	r25, r1
    d3d0:	84 0f       	add	r24, r20
    d3d2:	91 1d       	adc	r25, r1
    d3d4:	28 17       	cp	r18, r24
    d3d6:	39 07       	cpc	r19, r25
    d3d8:	6c f5       	brge	.+90     	; 0xd434 <GSM_DRE+0xfc>
				EM_RX_FIFOMax = EM_RX_FIFO_SIZE - EM_RX_FIFO_End + EM_RX_FIFO_Begin;
    d3da:	80 91 70 09 	lds	r24, 0x0970
    d3de:	90 91 38 0d 	lds	r25, 0x0D38
    d3e2:	81 50       	subi	r24, 0x01	; 1
    d3e4:	89 1b       	sub	r24, r25
    d3e6:	80 93 6e 0a 	sts	0x0A6E, r24
    d3ea:	08 95       	ret
		GetByteFromEM_FIFO_Transp();
	}	
	else{
		if(GSM_TxCharN < GSMTxSz){
    d3ec:	90 91 46 0d 	lds	r25, 0x0D46
    d3f0:	80 91 57 09 	lds	r24, 0x0957
    d3f4:	98 17       	cp	r25, r24
    d3f6:	e0 f4       	brcc	.+56     	; 0xd430 <GSM_DRE+0xf8>
			UDR_GSM = GSM_TxStr[GSM_TxCharN];
    d3f8:	e0 91 46 0d 	lds	r30, 0x0D46
    d3fc:	f0 e0       	ldi	r31, 0x00	; 0
    d3fe:	e7 5c       	subi	r30, 0xC7	; 199
    d400:	f3 4f       	sbci	r31, 0xF3	; 243
    d402:	80 81       	ld	r24, Z
    d404:	8c b9       	out	0x0c, r24	; 12
			#ifdef GSM_DEBUG
				GPRS_TerminalProcess(GSM_TxStr[GSM_TxCharN]);
			#endif
			if(GSM_DebugMode){
    d406:	80 91 f2 09 	lds	r24, 0x09F2
    d40a:	88 23       	and	r24, r24
    d40c:	59 f0       	breq	.+22     	; 0xd424 <GSM_DRE+0xec>
				SendDebug(GSM_TxStr[GSM_TxCharN]);
    d40e:	e0 91 46 0d 	lds	r30, 0x0D46
    d412:	f0 e0       	ldi	r31, 0x00	; 0
    d414:	e7 5c       	subi	r30, 0xC7	; 199
    d416:	f3 4f       	sbci	r31, 0xF3	; 243
    d418:	80 81       	ld	r24, Z
    d41a:	0e 94 25 57 	call	0xae4a	; 0xae4a <SendDebug>
    d41e:	88 e2       	ldi	r24, 0x28	; 40
    d420:	80 93 9a 00 	sts	0x009A, r24
				SetDebug_DRE_ISR();
			}

			GSM_TxCharN++;
    d424:	80 91 46 0d 	lds	r24, 0x0D46
    d428:	8f 5f       	subi	r24, 0xFF	; 255
    d42a:	80 93 46 0d 	sts	0x0D46, r24
    d42e:	08 95       	ret
		}
		else{
			#if defined (__AVR_ATxmega128A1__)
				USART_GSM.CTRLA = USART_RXCINTLVL_HI_gc | USART_TXCINTLVL_HI_gc;
			#else
				UCSR_GSM_B =  (1<<RXCIE_GSM) | (1<<TXCIE_GSM) | (0<<UDRIE_GSM) | (1<<RXEN_GSM) | (0<<UCSZ_GSM_2) | (1<<TXEN_GSM);
    d430:	88 ed       	ldi	r24, 0xD8	; 216
    d432:	8a b9       	out	0x0a, r24	; 10
    d434:	08 95       	ret

0000d436 <__vector_19>:
}

// ~~~~~~~~~~
// USART0 - PORT0

ISR(USART0_UDRE_vect){
    d436:	1f 92       	push	r1
    d438:	0f 92       	push	r0
    d43a:	0f b6       	in	r0, 0x3f	; 63
    d43c:	0f 92       	push	r0
    d43e:	11 24       	eor	r1, r1
    d440:	0b b6       	in	r0, 0x3b	; 59
    d442:	0f 92       	push	r0
    d444:	2f 93       	push	r18
    d446:	3f 93       	push	r19
    d448:	4f 93       	push	r20
    d44a:	5f 93       	push	r21
    d44c:	6f 93       	push	r22
    d44e:	7f 93       	push	r23
    d450:	8f 93       	push	r24
    d452:	9f 93       	push	r25
    d454:	af 93       	push	r26
    d456:	bf 93       	push	r27
    d458:	ef 93       	push	r30
    d45a:	ff 93       	push	r31
	GSM_DRE();
    d45c:	0e 94 9c 69 	call	0xd338	; 0xd338 <GSM_DRE>
	GSM_LED = 1;
    d460:	81 e0       	ldi	r24, 0x01	; 1
    d462:	80 93 0a 06 	sts	0x060A, r24
}
    d466:	ff 91       	pop	r31
    d468:	ef 91       	pop	r30
    d46a:	bf 91       	pop	r27
    d46c:	af 91       	pop	r26
    d46e:	9f 91       	pop	r25
    d470:	8f 91       	pop	r24
    d472:	7f 91       	pop	r23
    d474:	6f 91       	pop	r22
    d476:	5f 91       	pop	r21
    d478:	4f 91       	pop	r20
    d47a:	3f 91       	pop	r19
    d47c:	2f 91       	pop	r18
    d47e:	0f 90       	pop	r0
    d480:	0b be       	out	0x3b, r0	; 59
    d482:	0f 90       	pop	r0
    d484:	0f be       	out	0x3f, r0	; 63
    d486:	0f 90       	pop	r0
    d488:	1f 90       	pop	r1
    d48a:	18 95       	reti

0000d48c <Debug_DRE>:
}

//  ISR
inline void Debug_DRE(void){

	if(EM_RX_FIFO_Begin != EM_RX_FIFO_End){
    d48c:	90 91 70 09 	lds	r25, 0x0970
    d490:	80 91 38 0d 	lds	r24, 0x0D38
    d494:	98 17       	cp	r25, r24
    d496:	a1 f0       	breq	.+40     	; 0xd4c0 <Debug_DRE+0x34>
		EM_RX_FIFO_End++;
    d498:	80 91 38 0d 	lds	r24, 0x0D38
    d49c:	8f 5f       	subi	r24, 0xFF	; 255
    d49e:	80 93 38 0d 	sts	0x0D38, r24
		if(EM_RX_FIFO_End >= EM_RX_FIFO_SIZE) EM_RX_FIFO_End = 0;
    d4a2:	80 91 38 0d 	lds	r24, 0x0D38
    d4a6:	8f 3f       	cpi	r24, 0xFF	; 255
    d4a8:	11 f4       	brne	.+4      	; 0xd4ae <Debug_DRE+0x22>
    d4aa:	10 92 38 0d 	sts	0x0D38, r1
		UDR_EMETER = EM_RX_FIFO[EM_RX_FIFO_End];
    d4ae:	e0 91 38 0d 	lds	r30, 0x0D38
    d4b2:	f0 e0       	ldi	r31, 0x00	; 0
    d4b4:	e7 50       	subi	r30, 0x07	; 7
    d4b6:	fc 4f       	sbci	r31, 0xFC	; 252
    d4b8:	80 81       	ld	r24, Z
    d4ba:	80 93 9c 00 	sts	0x009C, r24
    d4be:	08 95       	ret
	}
	else{
		// disable DRE interrupt
		UCSR_EMETER_B = (0<<RXCIE_EMETER) | (0<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (0<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);	
    d4c0:	88 e0       	ldi	r24, 0x08	; 8
    d4c2:	80 93 9a 00 	sts	0x009A, r24
    d4c6:	08 95       	ret

0000d4c8 <EMeter_DRE>:
	}*/
	//-----
}
// ~~~~~~~~~
void EMeter_DRE(void){
	if(GSM_DebugMode) Debug_DRE();
    d4c8:	80 91 f2 09 	lds	r24, 0x09F2
    d4cc:	81 11       	cpse	r24, r1
    d4ce:	0c 94 46 6a 	jmp	0xd48c	; 0xd48c <Debug_DRE>
	else{
		if(Transparent){
    d4d2:	80 91 76 0a 	lds	r24, 0x0A76
    d4d6:	88 23       	and	r24, r24
    d4d8:	09 f4       	brne	.+2      	; 0xd4dc <EMeter_DRE+0x14>
    d4da:	5e c0       	rjmp	.+188    	; 0xd598 <EMeter_DRE+0xd0>
	}
}
// ~~~~~~~~~~~
inline void GetByteFromGSM_FIFO_Transp(void){

	if(GSM_RX_FIFO_Begin != GSM_RX_FIFO_End_Transp){
    d4dc:	90 91 7b 08 	lds	r25, 0x087B
    d4e0:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4e4:	98 17       	cp	r25, r24
    d4e6:	d1 f0       	breq	.+52     	; 0xd51c <EMeter_DRE+0x54>
		GSM_RX_FIFO_End_Transp++;
    d4e8:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4ec:	8f 5f       	subi	r24, 0xFF	; 255
    d4ee:	80 93 f8 0a 	sts	0x0AF8, r24
		if(GSM_RX_FIFO_End_Transp >= GSM_RX_FIFO_SIZE) GSM_RX_FIFO_End_Transp = 0;
    d4f2:	80 91 f8 0a 	lds	r24, 0x0AF8
    d4f6:	8a 3f       	cpi	r24, 0xFA	; 250
    d4f8:	10 f0       	brcs	.+4      	; 0xd4fe <EMeter_DRE+0x36>
    d4fa:	10 92 f8 0a 	sts	0x0AF8, r1
		PORTD |= (1<<PD4);	//RS485 Tx_on
    d4fe:	94 9a       	sbi	0x12, 4	; 18
		UDR_EMETER = GSM_RX_FIFO[GSM_RX_FIFO_End_Transp];
    d500:	e0 91 f8 0a 	lds	r30, 0x0AF8
    d504:	f0 e0       	ldi	r31, 0x00	; 0
    d506:	e8 50       	subi	r30, 0x08	; 8
    d508:	fb 4f       	sbci	r31, 0xFB	; 251
    d50a:	80 81       	ld	r24, Z
    d50c:	80 93 9c 00 	sts	0x009C, r24
		UCSR_EMETER_A |= (1<<TXC_EMETER);	//Clear TxC pending interrupt
    d510:	80 91 9b 00 	lds	r24, 0x009B
    d514:	80 64       	ori	r24, 0x40	; 64
    d516:	80 93 9b 00 	sts	0x009B, r24
    d51a:	03 c0       	rjmp	.+6      	; 0xd522 <EMeter_DRE+0x5a>
	}
	else{
		// disable DRE interrupt & enable TxC interrupt
		UCSR_EMETER_B = (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d51c:	88 ed       	ldi	r24, 0xD8	; 216
    d51e:	80 93 9a 00 	sts	0x009A, r24

	}

	//--- Calculate GSM_RX_FIFOMax_Transp
	if(GSM_RX_FIFO_Begin > GSM_RX_FIFO_End_Transp){
    d522:	90 91 7b 08 	lds	r25, 0x087B
    d526:	80 91 f8 0a 	lds	r24, 0x0AF8
    d52a:	89 17       	cp	r24, r25
    d52c:	a0 f4       	brcc	.+40     	; 0xd556 <EMeter_DRE+0x8e>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp))
    d52e:	20 91 7f 09 	lds	r18, 0x097F
    d532:	80 91 7b 08 	lds	r24, 0x087B
    d536:	40 91 f8 0a 	lds	r20, 0x0AF8
    d53a:	30 e0       	ldi	r19, 0x00	; 0
    d53c:	90 e0       	ldi	r25, 0x00	; 0
    d53e:	84 1b       	sub	r24, r20
    d540:	91 09       	sbc	r25, r1
    d542:	28 17       	cp	r18, r24
    d544:	39 07       	cpc	r19, r25
    d546:	3c f4       	brge	.+14     	; 0xd556 <EMeter_DRE+0x8e>
				GSM_RX_FIFOMax_Transp =  GSM_RX_FIFO_Begin - GSM_RX_FIFO_End_Transp;
    d548:	80 91 7b 08 	lds	r24, 0x087B
    d54c:	90 91 f8 0a 	lds	r25, 0x0AF8
    d550:	89 1b       	sub	r24, r25
    d552:	80 93 7f 09 	sts	0x097F, r24
	}
	if(GSM_RX_FIFO_End_Transp > GSM_RX_FIFO_Begin){
    d556:	90 91 f8 0a 	lds	r25, 0x0AF8
    d55a:	80 91 7b 08 	lds	r24, 0x087B
    d55e:	89 17       	cp	r24, r25
    d560:	c0 f4       	brcc	.+48     	; 0xd592 <EMeter_DRE+0xca>
			if(GSM_RX_FIFOMax_Transp < (GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin))
    d562:	20 91 7f 09 	lds	r18, 0x097F
    d566:	50 91 f8 0a 	lds	r21, 0x0AF8
    d56a:	40 91 7b 08 	lds	r20, 0x087B
    d56e:	30 e0       	ldi	r19, 0x00	; 0
    d570:	8a ef       	ldi	r24, 0xFA	; 250
    d572:	90 e0       	ldi	r25, 0x00	; 0
    d574:	85 1b       	sub	r24, r21
    d576:	91 09       	sbc	r25, r1
    d578:	84 0f       	add	r24, r20
    d57a:	91 1d       	adc	r25, r1
    d57c:	28 17       	cp	r18, r24
    d57e:	39 07       	cpc	r19, r25
    d580:	44 f4       	brge	.+16     	; 0xd592 <EMeter_DRE+0xca>
				GSM_RX_FIFOMax_Transp = GSM_RX_FIFO_SIZE - GSM_RX_FIFO_End_Transp  + GSM_RX_FIFO_Begin;
    d582:	80 91 7b 08 	lds	r24, 0x087B
    d586:	90 91 f8 0a 	lds	r25, 0x0AF8
    d58a:	86 50       	subi	r24, 0x06	; 6
    d58c:	89 1b       	sub	r24, r25
    d58e:	80 93 7f 09 	sts	0x097F, r24
			GetByteFromGSM_FIFO_Transp();
			EMeterIsLink=0;
    d592:	10 92 5d 09 	sts	0x095D, r1
    d596:	08 95       	ret
		}
		else{
			if(EMeter_TxCharN < EMeter_TxSz){
    d598:	90 91 51 09 	lds	r25, 0x0951
    d59c:	80 91 47 0d 	lds	r24, 0x0D47
    d5a0:	98 17       	cp	r25, r24
    d5a2:	70 f4       	brcc	.+28     	; 0xd5c0 <EMeter_DRE+0xf8>
				UDR_EMETER = EMeter_TxStr[EMeter_TxCharN];
    d5a4:	e0 91 51 09 	lds	r30, 0x0951
    d5a8:	f0 e0       	ldi	r31, 0x00	; 0
    d5aa:	e7 50       	subi	r30, 0x07	; 7
    d5ac:	f5 4f       	sbci	r31, 0xF5	; 245
    d5ae:	80 81       	ld	r24, Z
    d5b0:	80 93 9c 00 	sts	0x009C, r24
				EMeter_TxCharN++;
    d5b4:	80 91 51 09 	lds	r24, 0x0951
    d5b8:	8f 5f       	subi	r24, 0xFF	; 255
    d5ba:	80 93 51 09 	sts	0x0951, r24
    d5be:	08 95       	ret
			}
			else{
				UCSR_EMETER_B =  (1<<RXCIE_EMETER) | (1<<TXCIE_EMETER) | (0<<UDRIE_EMETER) | (1<<RXEN_EMETER) | (0<<UCSZ_EMETER_2) | (1<<TXEN_EMETER);
    d5c0:	88 ed       	ldi	r24, 0xD8	; 216
    d5c2:	80 93 9a 00 	sts	0x009A, r24
    d5c6:	08 95       	ret

0000d5c8 <__vector_31>:
}

// ~~~~~~~~~~
// USART1 - PORT1

ISR(USART1_UDRE_vect){
    d5c8:	1f 92       	push	r1
    d5ca:	0f 92       	push	r0
    d5cc:	0f b6       	in	r0, 0x3f	; 63
    d5ce:	0f 92       	push	r0
    d5d0:	11 24       	eor	r1, r1
    d5d2:	0b b6       	in	r0, 0x3b	; 59
    d5d4:	0f 92       	push	r0
    d5d6:	2f 93       	push	r18
    d5d8:	3f 93       	push	r19
    d5da:	4f 93       	push	r20
    d5dc:	5f 93       	push	r21
    d5de:	6f 93       	push	r22
    d5e0:	7f 93       	push	r23
    d5e2:	8f 93       	push	r24
    d5e4:	9f 93       	push	r25
    d5e6:	af 93       	push	r26
    d5e8:	bf 93       	push	r27
    d5ea:	ef 93       	push	r30
    d5ec:	ff 93       	push	r31
	if(ModbusMode) Modbus_TX(&UDR1);
    d5ee:	80 91 e0 03 	lds	r24, 0x03E0
    d5f2:	88 23       	and	r24, r24
    d5f4:	29 f0       	breq	.+10     	; 0xd600 <__vector_31+0x38>
    d5f6:	8c e9       	ldi	r24, 0x9C	; 156
    d5f8:	90 e0       	ldi	r25, 0x00	; 0
    d5fa:	0e 94 83 38 	call	0x7106	; 0x7106 <Modbus_TX>
    d5fe:	02 c0       	rjmp	.+4      	; 0xd604 <__vector_31+0x3c>
	else EMeter_DRE();
    d600:	0e 94 64 6a 	call	0xd4c8	; 0xd4c8 <EMeter_DRE>
	COMM_LED = 1;
    d604:	81 e0       	ldi	r24, 0x01	; 1
    d606:	80 93 10 06 	sts	0x0610, r24
}
    d60a:	ff 91       	pop	r31
    d60c:	ef 91       	pop	r30
    d60e:	bf 91       	pop	r27
    d610:	af 91       	pop	r26
    d612:	9f 91       	pop	r25
    d614:	8f 91       	pop	r24
    d616:	7f 91       	pop	r23
    d618:	6f 91       	pop	r22
    d61a:	5f 91       	pop	r21
    d61c:	4f 91       	pop	r20
    d61e:	3f 91       	pop	r19
    d620:	2f 91       	pop	r18
    d622:	0f 90       	pop	r0
    d624:	0b be       	out	0x3b, r0	; 59
    d626:	0f 90       	pop	r0
    d628:	0f be       	out	0x3f, r0	; 63
    d62a:	0f 90       	pop	r0
    d62c:	1f 90       	pop	r1
    d62e:	18 95       	reti

0000d630 <ToggleLED>:

//#include "web.h"
#include "web_vem_levels.h"

void ToggleLED(uint8_t DO){
	if((uint8_t)LiveTime & (1<<2)) ResDigOut(DO);
    d630:	40 91 63 09 	lds	r20, 0x0963
    d634:	50 91 64 09 	lds	r21, 0x0964
    d638:	60 91 65 09 	lds	r22, 0x0965
    d63c:	70 91 66 09 	lds	r23, 0x0966
    d640:	42 fd       	sbrc	r20, 2
    d642:	0c 94 2e 3c 	jmp	0x785c	; 0x785c <ResDigOut>
	else SetDigOut(DO);
    d646:	0c 94 1c 3c 	jmp	0x7838	; 0x7838 <SetDigOut>

0000d64a <ApplInit>:
void Modbus_ReadHoldReg(void);

// ~~~~~~~~~~~
void Modbus_App_Init(void){

	Modbus_ReadHoldReg();
    d64a:	0e 94 25 2a 	call	0x544a	; 0x544a <Modbus_ReadHoldReg>
ApplInit(){

	Modbus_App_Init();

	#ifdef GSM
		GPRS_AppInit();
    d64e:	0e 94 f9 4c 	call	0x99f2	; 0x99f2 <GPRS_AppInit>
	#endif

	WebInit();
    d652:	0c 94 79 43 	jmp	0x86f2	; 0x86f2 <WebInit>

0000d656 <ApplCycle>:
ApplCycle()
{

//	if(FixBug(1)) Reboot();

	WebServer((WebPage **)&WebSite, sizeof(WebSite)/sizeof(WebPage*));
    d656:	69 e0       	ldi	r22, 0x09	; 9
    d658:	86 e8       	ldi	r24, 0x86	; 134
    d65a:	95 e0       	ldi	r25, 0x05	; 5
    d65c:	0e 94 54 65 	call	0xcaa8	; 0xcaa8 <WebServer>

//,   GPRS
	#ifdef GSM
		GPRS_App();
    d660:	0e 94 5d 55 	call	0xaaba	; 0xaaba <GPRS_App>
	#endif
	
	#ifdef MODBUS
		Modbus_App();
    d664:	0e 94 08 56 	call	0xac10	; 0xac10 <Modbus_App>
		}
	*/	


	// GSM_DebugMode
	if(UART_Soft){
    d668:	80 91 75 0a 	lds	r24, 0x0A75
    d66c:	88 23       	and	r24, r24
    d66e:	09 f1       	breq	.+66     	; 0xd6b2 <ApplCycle+0x5c>
		if(GSM_DebugMode){
    d670:	80 91 f2 09 	lds	r24, 0x09F2
    d674:	88 23       	and	r24, r24
    d676:	81 f0       	breq	.+32     	; 0xd698 <ApplCycle+0x42>
			if( DI_State(DI_BL) ){
    d678:	83 e0       	ldi	r24, 0x03	; 3
    d67a:	0e 94 ad 3b 	call	0x775a	; 0x775a <DI_State>
    d67e:	88 23       	and	r24, r24
    d680:	41 f0       	breq	.+16     	; 0xd692 <ApplCycle+0x3c>
				if(Timer16Stopp(TD_GotoDebug)){
    d682:	81 e0       	ldi	r24, 0x01	; 1
    d684:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    d688:	88 23       	and	r24, r24
    d68a:	51 f1       	breq	.+84     	; 0xd6e0 <ApplCycle+0x8a>
					StopDebug();
    d68c:	0e 94 1b 57 	call	0xae36	; 0xae36 <StopDebug>
    d690:	22 c0       	rjmp	.+68     	; 0xd6d6 <ApplCycle+0x80>
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,50);
    d692:	62 e3       	ldi	r22, 0x32	; 50
    d694:	70 e0       	ldi	r23, 0x00	; 0
    d696:	21 c0       	rjmp	.+66     	; 0xd6da <ApplCycle+0x84>
		}
		else{
			if( DI_State(DI_BL) ){
    d698:	83 e0       	ldi	r24, 0x03	; 3
    d69a:	0e 94 ad 3b 	call	0x775a	; 0x775a <DI_State>
    d69e:	88 23       	and	r24, r24
    d6a0:	69 f0       	breq	.+26     	; 0xd6bc <ApplCycle+0x66>
				if(Timer16Stopp(TD_GotoDebug)){
    d6a2:	81 e0       	ldi	r24, 0x01	; 1
    d6a4:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    d6a8:	88 23       	and	r24, r24
    d6aa:	d1 f0       	breq	.+52     	; 0xd6e0 <ApplCycle+0x8a>
					StartDebug();
    d6ac:	0e 94 07 57 	call	0xae0e	; 0xae0e <StartDebug>
    d6b0:	12 c0       	rjmp	.+36     	; 0xd6d6 <ApplCycle+0x80>
			}
			else StartTimer16(TD_GotoDebug,100);
		}
	}
	else{
		if( DI_State(DI_BL) ){
    d6b2:	83 e0       	ldi	r24, 0x03	; 3
    d6b4:	0e 94 ad 3b 	call	0x775a	; 0x775a <DI_State>
    d6b8:	81 11       	cpse	r24, r1
    d6ba:	03 c0       	rjmp	.+6      	; 0xd6c2 <ApplCycle+0x6c>
				if(Timer16Stopp(TD_GotoDebug)){
					StartDebug();
					StartTimer16(TD_GotoDebug,500);
				}
			}
			else StartTimer16(TD_GotoDebug,100);
    d6bc:	64 e6       	ldi	r22, 0x64	; 100
    d6be:	70 e0       	ldi	r23, 0x00	; 0
    d6c0:	0c c0       	rjmp	.+24     	; 0xd6da <ApplCycle+0x84>
		}
	}
	else{
		if( DI_State(DI_BL) ){
			if(Timer16Stopp(TD_GotoDebug)){
    d6c2:	81 e0       	ldi	r24, 0x01	; 1
    d6c4:	0e 94 6f 2c 	call	0x58de	; 0x58de <Timer16Stopp>
    d6c8:	88 23       	and	r24, r24
    d6ca:	51 f0       	breq	.+20     	; 0xd6e0 <ApplCycle+0x8a>
				GPRS_NewMsg(GPRS_INFO, TestMsg_str);
    d6cc:	6c ef       	ldi	r22, 0xFC	; 252
    d6ce:	7c e4       	ldi	r23, 0x4C	; 76
    d6d0:	82 e0       	ldi	r24, 0x02	; 2
    d6d2:	0e 94 c1 4f 	call	0x9f82	; 0x9f82 <GPRS_NewMsg>
				StartTimer16(TD_GotoDebug,500);
    d6d6:	64 ef       	ldi	r22, 0xF4	; 244
    d6d8:	71 e0       	ldi	r23, 0x01	; 1
    d6da:	81 e0       	ldi	r24, 0x01	; 1
    d6dc:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <StartTimer16>
		}
	}
	else ResDigOut(DO_BL);*/

	//----   GSM_LED  /  UART0
	if(GSM_LED == 1){
    d6e0:	80 91 0a 06 	lds	r24, 0x060A
    d6e4:	81 30       	cpi	r24, 0x01	; 1
    d6e6:	39 f4       	brne	.+14     	; 0xd6f6 <ApplCycle+0xa0>
		StartTimer8(TD_GSM_LED,5);
    d6e8:	65 e0       	ldi	r22, 0x05	; 5
    d6ea:	83 e0       	ldi	r24, 0x03	; 3
    d6ec:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
		GSM_LED = 2;
    d6f0:	82 e0       	ldi	r24, 0x02	; 2
    d6f2:	80 93 0a 06 	sts	0x060A, r24
	}
	if(GSM_LED ==2){
    d6f6:	80 91 0a 06 	lds	r24, 0x060A
    d6fa:	82 30       	cpi	r24, 0x02	; 2
    d6fc:	31 f4       	brne	.+12     	; 0xd70a <ApplCycle+0xb4>
		if(Timer8Stopp(TD_GSM_LED)) GSM_LED = 0;
    d6fe:	83 e0       	ldi	r24, 0x03	; 3
    d700:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    d704:	81 11       	cpse	r24, r1
    d706:	10 92 0a 06 	sts	0x060A, r1
	}
	//   DO_GSM
	if(GSM_State == GSM_ProtocolMode){
    d70a:	80 91 27 06 	lds	r24, 0x0627
    d70e:	81 36       	cpi	r24, 0x61	; 97
    d710:	81 f4       	brne	.+32     	; 0xd732 <ApplCycle+0xdc>
		if(GSM_LED||UART_Soft) ToggleLED(DO_GSM);
    d712:	80 91 0a 06 	lds	r24, 0x060A
    d716:	81 11       	cpse	r24, r1
    d718:	04 c0       	rjmp	.+8      	; 0xd722 <ApplCycle+0xcc>
    d71a:	80 91 75 0a 	lds	r24, 0x0A75
    d71e:	88 23       	and	r24, r24
    d720:	21 f0       	breq	.+8      	; 0xd72a <ApplCycle+0xd4>
    d722:	80 e0       	ldi	r24, 0x00	; 0
    d724:	0e 94 18 6b 	call	0xd630	; 0xd630 <ToggleLED>
    d728:	0a c0       	rjmp	.+20     	; 0xd73e <ApplCycle+0xe8>
		else SetDigOut(DO_GSM);
    d72a:	80 e0       	ldi	r24, 0x00	; 0
    d72c:	0e 94 1c 3c 	call	0x7838	; 0x7838 <SetDigOut>
    d730:	06 c0       	rjmp	.+12     	; 0xd73e <ApplCycle+0xe8>
	}
	else{
		if(GSM_LED) ToggleLED(DO_GSM);
    d732:	80 91 0a 06 	lds	r24, 0x060A
    d736:	81 11       	cpse	r24, r1
    d738:	f4 cf       	rjmp	.-24     	; 0xd722 <ApplCycle+0xcc>
		else ResDigOut(DO_GSM);
    d73a:	0e 94 2e 3c 	call	0x785c	; 0x785c <ResDigOut>
	}


	//----   COMM_LED  /  UART1
	if(COMM_LED == 1){
    d73e:	80 91 10 06 	lds	r24, 0x0610
    d742:	81 30       	cpi	r24, 0x01	; 1
    d744:	39 f4       	brne	.+14     	; 0xd754 <ApplCycle+0xfe>
		StartTimer8(TD_COMM_LED,5);
    d746:	65 e0       	ldi	r22, 0x05	; 5
    d748:	82 e0       	ldi	r24, 0x02	; 2
    d74a:	0e 94 a6 2a 	call	0x554c	; 0x554c <StartTimer8>
		COMM_LED = 2;
    d74e:	82 e0       	ldi	r24, 0x02	; 2
    d750:	80 93 10 06 	sts	0x0610, r24
	}
	if(COMM_LED ==2){
    d754:	80 91 10 06 	lds	r24, 0x0610
    d758:	82 30       	cpi	r24, 0x02	; 2
    d75a:	29 f4       	brne	.+10     	; 0xd766 <ApplCycle+0x110>
		if(Timer8Stopp(TD_COMM_LED)) COMM_LED = 0;
    d75c:	0e 94 54 2c 	call	0x58a8	; 0x58a8 <Timer8Stopp>
    d760:	81 11       	cpse	r24, r1
    d762:	10 92 10 06 	sts	0x0610, r1
	}
	//   COMM_LED 
	//if(EMeter_Link()){
	if(EMeterIsLink){
    d766:	80 91 5d 09 	lds	r24, 0x095D
    d76a:	88 23       	and	r24, r24
    d76c:	51 f0       	breq	.+20     	; 0xd782 <ApplCycle+0x12c>
		if(COMM_LED) ToggleLED(DO_RS);
    d76e:	80 91 10 06 	lds	r24, 0x0610
    d772:	88 23       	and	r24, r24
    d774:	19 f0       	breq	.+6      	; 0xd77c <ApplCycle+0x126>
    d776:	81 e0       	ldi	r24, 0x01	; 1
    d778:	0c 94 18 6b 	jmp	0xd630	; 0xd630 <ToggleLED>
		else SetDigOut(DO_RS);
    d77c:	81 e0       	ldi	r24, 0x01	; 1
    d77e:	0c 94 1c 3c 	jmp	0x7838	; 0x7838 <SetDigOut>
	}
	else{
		if(COMM_LED) ToggleLED(DO_RS);
    d782:	80 91 10 06 	lds	r24, 0x0610
    d786:	81 11       	cpse	r24, r1
    d788:	f6 cf       	rjmp	.-20     	; 0xd776 <ApplCycle+0x120>
		else ResDigOut(DO_RS);
    d78a:	81 e0       	ldi	r24, 0x01	; 1
    d78c:	0c 94 2e 3c 	jmp	0x785c	; 0x785c <ResDigOut>

0000d790 <main>:
*/
// ~~~~~~~
int
main(void)
{
	TimersInc();
    d790:	0e 94 84 2d 	call	0x5b08	; 0x5b08 <TimersInc>
	TimeInit();
    d794:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <TimeInit>
	MemCheckInit();
    d798:	0e 94 fb 29 	call	0x53f6	; 0x53f6 <MemCheckInit>

// ~~~~~~~~~~
void
DI_Init(void)
{
	DI_Init_Hard();
    d79c:	0e 94 da 28 	call	0x51b4	; 0x51b4 <DI_Init_Hard>
	LED_Init();
	DigitInit();
    d7a0:	0e 94 74 3c 	call	0x78e8	; 0x78e8 <DO_Init>
	OneWire_Init();
    d7a4:	0e 94 19 3d 	call	0x7a32	; 0x7a32 <OneWire_Init>
	USART_Init();
    d7a8:	0e 94 0e 4c 	call	0x981c	; 0x981c <USART_Init>
InterruInit(void)
{
	#ifdef PMIC
		PMIC.CTRL = (uint8_t)(~PMIC_RREN_bm &~PMIC_IVSEL_bm) |PMIC_HILVLEN_bm |PMIC_MEDLVLEN_bm |PMIC_LOLVLEN_bm;
	#endif
	sei();
    d7ac:	78 94       	sei
	InterruInit();	// <-sei();

	//   ApplInit()
	do {TimersInc();
    d7ae:	0e 94 84 2d 	call	0x5b08	; 0x5b08 <TimersInc>
		wdt_reset();
    d7b2:	a8 95       	wdr
		DigitIn();
    d7b4:	0e 94 d1 3b 	call	0x77a2	; 0x77a2 <DigitIn>
		DS18B20();
    d7b8:	0e 94 54 3e 	call	0x7ca8	; 0x7ca8 <DS18B20>
	} while(DS18B20_Mode != DS18B20_END_CYCLE);
    d7bc:	80 91 56 02 	lds	r24, 0x0256
    d7c0:	87 30       	cpi	r24, 0x07	; 7
    d7c2:	a9 f7       	brne	.-22     	; 0xd7ae <main+0x1e>

//	MemCheckMsg();

	ApplInit();
    d7c4:	0e 94 25 6b 	call	0xd64a	; 0xd64a <ApplInit>
	
	ScanCycleInit();
    d7c8:	0e 94 2e 2d 	call	0x5a5c	; 0x5a5c <ScanCycleInit>

	for(;;) {TimersInc();
    d7cc:	0e 94 84 2d 	call	0x5b08	; 0x5b08 <TimersInc>
		sei();
    d7d0:	78 94       	sei

		TimeCycle();
    d7d2:	0e 94 80 2e 	call	0x5d00	; 0x5d00 <TimeCycle>
		DigitIn();
    d7d6:	0e 94 d1 3b 	call	0x77a2	; 0x77a2 <DigitIn>
		DS18B20();
    d7da:	0e 94 54 3e 	call	0x7ca8	; 0x7ca8 <DS18B20>
		USART_Cycle();
    d7de:	0e 94 20 65 	call	0xca40	; 0xca40 <USART_Cycle>

		ApplCycle();
    d7e2:	0e 94 2b 6b 	call	0xd656	; 0xd656 <ApplCycle>

		DigitOut();
    d7e6:	0e 94 41 3c 	call	0x7882	; 0x7882 <DigitOut>
    d7ea:	f0 cf       	rjmp	.-32     	; 0xd7cc <main+0x3c>

0000d7ec <do_random>:
    d7ec:	8f 92       	push	r8
    d7ee:	9f 92       	push	r9
    d7f0:	af 92       	push	r10
    d7f2:	bf 92       	push	r11
    d7f4:	cf 92       	push	r12
    d7f6:	df 92       	push	r13
    d7f8:	ef 92       	push	r14
    d7fa:	ff 92       	push	r15
    d7fc:	cf 93       	push	r28
    d7fe:	df 93       	push	r29
    d800:	ec 01       	movw	r28, r24
    d802:	68 81       	ld	r22, Y
    d804:	79 81       	ldd	r23, Y+1	; 0x01
    d806:	8a 81       	ldd	r24, Y+2	; 0x02
    d808:	9b 81       	ldd	r25, Y+3	; 0x03
    d80a:	61 15       	cp	r22, r1
    d80c:	71 05       	cpc	r23, r1
    d80e:	81 05       	cpc	r24, r1
    d810:	91 05       	cpc	r25, r1
    d812:	21 f4       	brne	.+8      	; 0xd81c <do_random+0x30>
    d814:	64 e2       	ldi	r22, 0x24	; 36
    d816:	79 ed       	ldi	r23, 0xD9	; 217
    d818:	8b e5       	ldi	r24, 0x5B	; 91
    d81a:	97 e0       	ldi	r25, 0x07	; 7
    d81c:	2d e1       	ldi	r18, 0x1D	; 29
    d81e:	33 ef       	ldi	r19, 0xF3	; 243
    d820:	41 e0       	ldi	r20, 0x01	; 1
    d822:	50 e0       	ldi	r21, 0x00	; 0
    d824:	0e 94 90 75 	call	0xeb20	; 0xeb20 <__divmodsi4>
    d828:	49 01       	movw	r8, r18
    d82a:	5a 01       	movw	r10, r20
    d82c:	9b 01       	movw	r18, r22
    d82e:	ac 01       	movw	r20, r24
    d830:	a7 ea       	ldi	r26, 0xA7	; 167
    d832:	b1 e4       	ldi	r27, 0x41	; 65
    d834:	0e 94 b5 75 	call	0xeb6a	; 0xeb6a <__muluhisi3>
    d838:	6b 01       	movw	r12, r22
    d83a:	7c 01       	movw	r14, r24
    d83c:	ac ee       	ldi	r26, 0xEC	; 236
    d83e:	b4 ef       	ldi	r27, 0xF4	; 244
    d840:	a5 01       	movw	r20, r10
    d842:	94 01       	movw	r18, r8
    d844:	0e 94 c3 75 	call	0xeb86	; 0xeb86 <__mulohisi3>
    d848:	c6 0e       	add	r12, r22
    d84a:	d7 1e       	adc	r13, r23
    d84c:	e8 1e       	adc	r14, r24
    d84e:	f9 1e       	adc	r15, r25
    d850:	f7 fe       	sbrs	r15, 7
    d852:	06 c0       	rjmp	.+12     	; 0xd860 <do_random+0x74>
    d854:	81 e0       	ldi	r24, 0x01	; 1
    d856:	c8 1a       	sub	r12, r24
    d858:	d1 08       	sbc	r13, r1
    d85a:	e1 08       	sbc	r14, r1
    d85c:	80 e8       	ldi	r24, 0x80	; 128
    d85e:	f8 0a       	sbc	r15, r24
    d860:	c8 82       	st	Y, r12
    d862:	d9 82       	std	Y+1, r13	; 0x01
    d864:	ea 82       	std	Y+2, r14	; 0x02
    d866:	fb 82       	std	Y+3, r15	; 0x03
    d868:	c7 01       	movw	r24, r14
    d86a:	b6 01       	movw	r22, r12
    d86c:	9f 77       	andi	r25, 0x7F	; 127
    d86e:	df 91       	pop	r29
    d870:	cf 91       	pop	r28
    d872:	ff 90       	pop	r15
    d874:	ef 90       	pop	r14
    d876:	df 90       	pop	r13
    d878:	cf 90       	pop	r12
    d87a:	bf 90       	pop	r11
    d87c:	af 90       	pop	r10
    d87e:	9f 90       	pop	r9
    d880:	8f 90       	pop	r8
    d882:	08 95       	ret

0000d884 <random_r>:
    d884:	0c 94 f6 6b 	jmp	0xd7ec	; 0xd7ec <do_random>

0000d888 <random>:
    d888:	80 e0       	ldi	r24, 0x00	; 0
    d88a:	91 e0       	ldi	r25, 0x01	; 1
    d88c:	0c 94 f6 6b 	jmp	0xd7ec	; 0xd7ec <do_random>

0000d890 <srandom>:
    d890:	60 93 00 01 	sts	0x0100, r22
    d894:	70 93 01 01 	sts	0x0101, r23
    d898:	80 93 02 01 	sts	0x0102, r24
    d89c:	90 93 03 01 	sts	0x0103, r25
    d8a0:	08 95       	ret

0000d8a2 <exit>:
    d8a2:	f8 94       	cli
    d8a4:	0c 94 39 76 	jmp	0xec72	; 0xec72 <_exit>

0000d8a8 <memcpy_P>:
    d8a8:	fb 01       	movw	r30, r22
    d8aa:	dc 01       	movw	r26, r24
    d8ac:	02 c0       	rjmp	.+4      	; 0xd8b2 <memcpy_P+0xa>
    d8ae:	05 90       	lpm	r0, Z+
    d8b0:	0d 92       	st	X+, r0
    d8b2:	41 50       	subi	r20, 0x01	; 1
    d8b4:	50 40       	sbci	r21, 0x00	; 0
    d8b6:	d8 f7       	brcc	.-10     	; 0xd8ae <memcpy_P+0x6>
    d8b8:	08 95       	ret

0000d8ba <strchr_P>:
    d8ba:	fc 01       	movw	r30, r24
    d8bc:	05 90       	lpm	r0, Z+
    d8be:	06 16       	cp	r0, r22
    d8c0:	21 f0       	breq	.+8      	; 0xd8ca <strchr_P+0x10>
    d8c2:	00 20       	and	r0, r0
    d8c4:	d9 f7       	brne	.-10     	; 0xd8bc <strchr_P+0x2>
    d8c6:	c0 01       	movw	r24, r0
    d8c8:	08 95       	ret
    d8ca:	31 97       	sbiw	r30, 0x01	; 1
    d8cc:	cf 01       	movw	r24, r30
    d8ce:	08 95       	ret

0000d8d0 <strcmp_P>:
    d8d0:	fb 01       	movw	r30, r22
    d8d2:	dc 01       	movw	r26, r24
    d8d4:	8d 91       	ld	r24, X+
    d8d6:	05 90       	lpm	r0, Z+
    d8d8:	80 19       	sub	r24, r0
    d8da:	01 10       	cpse	r0, r1
    d8dc:	d9 f3       	breq	.-10     	; 0xd8d4 <strcmp_P+0x4>
    d8de:	99 0b       	sbc	r25, r25
    d8e0:	08 95       	ret

0000d8e2 <strcpy_P>:
    d8e2:	fb 01       	movw	r30, r22
    d8e4:	dc 01       	movw	r26, r24
    d8e6:	05 90       	lpm	r0, Z+
    d8e8:	0d 92       	st	X+, r0
    d8ea:	00 20       	and	r0, r0
    d8ec:	e1 f7       	brne	.-8      	; 0xd8e6 <strcpy_P+0x4>
    d8ee:	08 95       	ret

0000d8f0 <strlcpy_P>:
    d8f0:	dc 01       	movw	r26, r24
    d8f2:	fb 01       	movw	r30, r22
    d8f4:	41 50       	subi	r20, 0x01	; 1
    d8f6:	50 40       	sbci	r21, 0x00	; 0
    d8f8:	58 f0       	brcs	.+22     	; 0xd910 <strlcpy_P+0x20>
    d8fa:	49 f0       	breq	.+18     	; 0xd90e <strlcpy_P+0x1e>
    d8fc:	05 90       	lpm	r0, Z+
    d8fe:	0d 92       	st	X+, r0
    d900:	00 20       	and	r0, r0
    d902:	c1 f7       	brne	.-16     	; 0xd8f4 <strlcpy_P+0x4>
    d904:	e6 1b       	sub	r30, r22
    d906:	f7 0b       	sbc	r31, r23
    d908:	31 97       	sbiw	r30, 0x01	; 1
    d90a:	cf 01       	movw	r24, r30
    d90c:	08 95       	ret
    d90e:	1c 92       	st	X, r1
    d910:	05 90       	lpm	r0, Z+
    d912:	00 20       	and	r0, r0
    d914:	e9 f7       	brne	.-6      	; 0xd910 <strlcpy_P+0x20>
    d916:	f6 cf       	rjmp	.-20     	; 0xd904 <strlcpy_P+0x14>

0000d918 <__strlen_P>:
    d918:	fc 01       	movw	r30, r24
    d91a:	05 90       	lpm	r0, Z+
    d91c:	00 20       	and	r0, r0
    d91e:	e9 f7       	brne	.-6      	; 0xd91a <__strlen_P+0x2>
    d920:	80 95       	com	r24
    d922:	90 95       	com	r25
    d924:	8e 0f       	add	r24, r30
    d926:	9f 1f       	adc	r25, r31
    d928:	08 95       	ret

0000d92a <strncmp_P>:
    d92a:	fb 01       	movw	r30, r22
    d92c:	dc 01       	movw	r26, r24
    d92e:	41 50       	subi	r20, 0x01	; 1
    d930:	50 40       	sbci	r21, 0x00	; 0
    d932:	30 f0       	brcs	.+12     	; 0xd940 <strncmp_P+0x16>
    d934:	8d 91       	ld	r24, X+
    d936:	05 90       	lpm	r0, Z+
    d938:	80 19       	sub	r24, r0
    d93a:	19 f4       	brne	.+6      	; 0xd942 <strncmp_P+0x18>
    d93c:	00 20       	and	r0, r0
    d93e:	b9 f7       	brne	.-18     	; 0xd92e <strncmp_P+0x4>
    d940:	88 1b       	sub	r24, r24
    d942:	99 0b       	sbc	r25, r25
    d944:	08 95       	ret

0000d946 <strstr_P>:
    d946:	fb 01       	movw	r30, r22
    d948:	55 91       	lpm	r21, Z+
    d94a:	55 23       	and	r21, r21
    d94c:	a9 f0       	breq	.+42     	; 0xd978 <strstr_P+0x32>
    d94e:	bf 01       	movw	r22, r30
    d950:	dc 01       	movw	r26, r24
    d952:	4d 91       	ld	r20, X+
    d954:	45 17       	cp	r20, r21
    d956:	41 11       	cpse	r20, r1
    d958:	e1 f7       	brne	.-8      	; 0xd952 <strstr_P+0xc>
    d95a:	59 f4       	brne	.+22     	; 0xd972 <strstr_P+0x2c>
    d95c:	cd 01       	movw	r24, r26
    d95e:	05 90       	lpm	r0, Z+
    d960:	00 20       	and	r0, r0
    d962:	49 f0       	breq	.+18     	; 0xd976 <strstr_P+0x30>
    d964:	4d 91       	ld	r20, X+
    d966:	40 15       	cp	r20, r0
    d968:	41 11       	cpse	r20, r1
    d96a:	c9 f3       	breq	.-14     	; 0xd95e <strstr_P+0x18>
    d96c:	fb 01       	movw	r30, r22
    d96e:	41 11       	cpse	r20, r1
    d970:	ef cf       	rjmp	.-34     	; 0xd950 <strstr_P+0xa>
    d972:	81 e0       	ldi	r24, 0x01	; 1
    d974:	90 e0       	ldi	r25, 0x00	; 0
    d976:	01 97       	sbiw	r24, 0x01	; 1
    d978:	08 95       	ret

0000d97a <memcpy>:
    d97a:	fb 01       	movw	r30, r22
    d97c:	dc 01       	movw	r26, r24
    d97e:	02 c0       	rjmp	.+4      	; 0xd984 <memcpy+0xa>
    d980:	01 90       	ld	r0, Z+
    d982:	0d 92       	st	X+, r0
    d984:	41 50       	subi	r20, 0x01	; 1
    d986:	50 40       	sbci	r21, 0x00	; 0
    d988:	d8 f7       	brcc	.-10     	; 0xd980 <memcpy+0x6>
    d98a:	08 95       	ret

0000d98c <strchr>:
    d98c:	fc 01       	movw	r30, r24
    d98e:	81 91       	ld	r24, Z+
    d990:	86 17       	cp	r24, r22
    d992:	21 f0       	breq	.+8      	; 0xd99c <strchr+0x10>
    d994:	88 23       	and	r24, r24
    d996:	d9 f7       	brne	.-10     	; 0xd98e <strchr+0x2>
    d998:	99 27       	eor	r25, r25
    d99a:	08 95       	ret
    d99c:	31 97       	sbiw	r30, 0x01	; 1
    d99e:	cf 01       	movw	r24, r30
    d9a0:	08 95       	ret

0000d9a2 <strcmp>:
    d9a2:	fb 01       	movw	r30, r22
    d9a4:	dc 01       	movw	r26, r24
    d9a6:	8d 91       	ld	r24, X+
    d9a8:	01 90       	ld	r0, Z+
    d9aa:	80 19       	sub	r24, r0
    d9ac:	01 10       	cpse	r0, r1
    d9ae:	d9 f3       	breq	.-10     	; 0xd9a6 <strcmp+0x4>
    d9b0:	99 0b       	sbc	r25, r25
    d9b2:	08 95       	ret

0000d9b4 <strcpy>:
    d9b4:	fb 01       	movw	r30, r22
    d9b6:	dc 01       	movw	r26, r24
    d9b8:	01 90       	ld	r0, Z+
    d9ba:	0d 92       	st	X+, r0
    d9bc:	00 20       	and	r0, r0
    d9be:	e1 f7       	brne	.-8      	; 0xd9b8 <strcpy+0x4>
    d9c0:	08 95       	ret

0000d9c2 <strncmp>:
    d9c2:	fb 01       	movw	r30, r22
    d9c4:	dc 01       	movw	r26, r24
    d9c6:	41 50       	subi	r20, 0x01	; 1
    d9c8:	50 40       	sbci	r21, 0x00	; 0
    d9ca:	30 f0       	brcs	.+12     	; 0xd9d8 <strncmp+0x16>
    d9cc:	8d 91       	ld	r24, X+
    d9ce:	01 90       	ld	r0, Z+
    d9d0:	80 19       	sub	r24, r0
    d9d2:	19 f4       	brne	.+6      	; 0xd9da <strncmp+0x18>
    d9d4:	00 20       	and	r0, r0
    d9d6:	b9 f7       	brne	.-18     	; 0xd9c6 <strncmp+0x4>
    d9d8:	88 1b       	sub	r24, r24
    d9da:	99 0b       	sbc	r25, r25
    d9dc:	08 95       	ret

0000d9de <sprintf>:
    d9de:	0f 93       	push	r16
    d9e0:	1f 93       	push	r17
    d9e2:	cf 93       	push	r28
    d9e4:	df 93       	push	r29
    d9e6:	cd b7       	in	r28, 0x3d	; 61
    d9e8:	de b7       	in	r29, 0x3e	; 62
    d9ea:	2e 97       	sbiw	r28, 0x0e	; 14
    d9ec:	0f b6       	in	r0, 0x3f	; 63
    d9ee:	f8 94       	cli
    d9f0:	de bf       	out	0x3e, r29	; 62
    d9f2:	0f be       	out	0x3f, r0	; 63
    d9f4:	cd bf       	out	0x3d, r28	; 61
    d9f6:	0d 89       	ldd	r16, Y+21	; 0x15
    d9f8:	1e 89       	ldd	r17, Y+22	; 0x16
    d9fa:	86 e0       	ldi	r24, 0x06	; 6
    d9fc:	8c 83       	std	Y+4, r24	; 0x04
    d9fe:	1a 83       	std	Y+2, r17	; 0x02
    da00:	09 83       	std	Y+1, r16	; 0x01
    da02:	8f ef       	ldi	r24, 0xFF	; 255
    da04:	9f e7       	ldi	r25, 0x7F	; 127
    da06:	9e 83       	std	Y+6, r25	; 0x06
    da08:	8d 83       	std	Y+5, r24	; 0x05
    da0a:	ae 01       	movw	r20, r28
    da0c:	47 5e       	subi	r20, 0xE7	; 231
    da0e:	5f 4f       	sbci	r21, 0xFF	; 255
    da10:	6f 89       	ldd	r22, Y+23	; 0x17
    da12:	78 8d       	ldd	r23, Y+24	; 0x18
    da14:	ce 01       	movw	r24, r28
    da16:	01 96       	adiw	r24, 0x01	; 1
    da18:	0e 94 1b 6f 	call	0xde36	; 0xde36 <vfprintf>
    da1c:	ef 81       	ldd	r30, Y+7	; 0x07
    da1e:	f8 85       	ldd	r31, Y+8	; 0x08
    da20:	e0 0f       	add	r30, r16
    da22:	f1 1f       	adc	r31, r17
    da24:	10 82       	st	Z, r1
    da26:	2e 96       	adiw	r28, 0x0e	; 14
    da28:	0f b6       	in	r0, 0x3f	; 63
    da2a:	f8 94       	cli
    da2c:	de bf       	out	0x3e, r29	; 62
    da2e:	0f be       	out	0x3f, r0	; 63
    da30:	cd bf       	out	0x3d, r28	; 61
    da32:	df 91       	pop	r29
    da34:	cf 91       	pop	r28
    da36:	1f 91       	pop	r17
    da38:	0f 91       	pop	r16
    da3a:	08 95       	ret

0000da3c <sprintf_P>:
    da3c:	0f 93       	push	r16
    da3e:	1f 93       	push	r17
    da40:	cf 93       	push	r28
    da42:	df 93       	push	r29
    da44:	cd b7       	in	r28, 0x3d	; 61
    da46:	de b7       	in	r29, 0x3e	; 62
    da48:	2e 97       	sbiw	r28, 0x0e	; 14
    da4a:	0f b6       	in	r0, 0x3f	; 63
    da4c:	f8 94       	cli
    da4e:	de bf       	out	0x3e, r29	; 62
    da50:	0f be       	out	0x3f, r0	; 63
    da52:	cd bf       	out	0x3d, r28	; 61
    da54:	0d 89       	ldd	r16, Y+21	; 0x15
    da56:	1e 89       	ldd	r17, Y+22	; 0x16
    da58:	8e e0       	ldi	r24, 0x0E	; 14
    da5a:	8c 83       	std	Y+4, r24	; 0x04
    da5c:	1a 83       	std	Y+2, r17	; 0x02
    da5e:	09 83       	std	Y+1, r16	; 0x01
    da60:	8f ef       	ldi	r24, 0xFF	; 255
    da62:	9f e7       	ldi	r25, 0x7F	; 127
    da64:	9e 83       	std	Y+6, r25	; 0x06
    da66:	8d 83       	std	Y+5, r24	; 0x05
    da68:	ae 01       	movw	r20, r28
    da6a:	47 5e       	subi	r20, 0xE7	; 231
    da6c:	5f 4f       	sbci	r21, 0xFF	; 255
    da6e:	6f 89       	ldd	r22, Y+23	; 0x17
    da70:	78 8d       	ldd	r23, Y+24	; 0x18
    da72:	ce 01       	movw	r24, r28
    da74:	01 96       	adiw	r24, 0x01	; 1
    da76:	0e 94 1b 6f 	call	0xde36	; 0xde36 <vfprintf>
    da7a:	ef 81       	ldd	r30, Y+7	; 0x07
    da7c:	f8 85       	ldd	r31, Y+8	; 0x08
    da7e:	e0 0f       	add	r30, r16
    da80:	f1 1f       	adc	r31, r17
    da82:	10 82       	st	Z, r1
    da84:	2e 96       	adiw	r28, 0x0e	; 14
    da86:	0f b6       	in	r0, 0x3f	; 63
    da88:	f8 94       	cli
    da8a:	de bf       	out	0x3e, r29	; 62
    da8c:	0f be       	out	0x3f, r0	; 63
    da8e:	cd bf       	out	0x3d, r28	; 61
    da90:	df 91       	pop	r29
    da92:	cf 91       	pop	r28
    da94:	1f 91       	pop	r17
    da96:	0f 91       	pop	r16
    da98:	08 95       	ret

0000da9a <sscanf>:
    da9a:	cf 93       	push	r28
    da9c:	df 93       	push	r29
    da9e:	cd b7       	in	r28, 0x3d	; 61
    daa0:	de b7       	in	r29, 0x3e	; 62
    daa2:	2e 97       	sbiw	r28, 0x0e	; 14
    daa4:	0f b6       	in	r0, 0x3f	; 63
    daa6:	f8 94       	cli
    daa8:	de bf       	out	0x3e, r29	; 62
    daaa:	0f be       	out	0x3f, r0	; 63
    daac:	cd bf       	out	0x3d, r28	; 61
    daae:	85 e0       	ldi	r24, 0x05	; 5
    dab0:	8c 83       	std	Y+4, r24	; 0x04
    dab2:	8b 89       	ldd	r24, Y+19	; 0x13
    dab4:	9c 89       	ldd	r25, Y+20	; 0x14
    dab6:	9a 83       	std	Y+2, r25	; 0x02
    dab8:	89 83       	std	Y+1, r24	; 0x01
    daba:	ae 01       	movw	r20, r28
    dabc:	49 5e       	subi	r20, 0xE9	; 233
    dabe:	5f 4f       	sbci	r21, 0xFF	; 255
    dac0:	6d 89       	ldd	r22, Y+21	; 0x15
    dac2:	7e 89       	ldd	r23, Y+22	; 0x16
    dac4:	ce 01       	movw	r24, r28
    dac6:	01 96       	adiw	r24, 0x01	; 1
    dac8:	0e 94 b3 72 	call	0xe566	; 0xe566 <vfscanf>
    dacc:	2e 96       	adiw	r28, 0x0e	; 14
    dace:	0f b6       	in	r0, 0x3f	; 63
    dad0:	f8 94       	cli
    dad2:	de bf       	out	0x3e, r29	; 62
    dad4:	0f be       	out	0x3f, r0	; 63
    dad6:	cd bf       	out	0x3d, r28	; 61
    dad8:	df 91       	pop	r29
    dada:	cf 91       	pop	r28
    dadc:	08 95       	ret

0000dade <sscanf_P>:
    dade:	cf 93       	push	r28
    dae0:	df 93       	push	r29
    dae2:	cd b7       	in	r28, 0x3d	; 61
    dae4:	de b7       	in	r29, 0x3e	; 62
    dae6:	2e 97       	sbiw	r28, 0x0e	; 14
    dae8:	0f b6       	in	r0, 0x3f	; 63
    daea:	f8 94       	cli
    daec:	de bf       	out	0x3e, r29	; 62
    daee:	0f be       	out	0x3f, r0	; 63
    daf0:	cd bf       	out	0x3d, r28	; 61
    daf2:	8d e0       	ldi	r24, 0x0D	; 13
    daf4:	8c 83       	std	Y+4, r24	; 0x04
    daf6:	8b 89       	ldd	r24, Y+19	; 0x13
    daf8:	9c 89       	ldd	r25, Y+20	; 0x14
    dafa:	9a 83       	std	Y+2, r25	; 0x02
    dafc:	89 83       	std	Y+1, r24	; 0x01
    dafe:	ae 01       	movw	r20, r28
    db00:	49 5e       	subi	r20, 0xE9	; 233
    db02:	5f 4f       	sbci	r21, 0xFF	; 255
    db04:	6d 89       	ldd	r22, Y+21	; 0x15
    db06:	7e 89       	ldd	r23, Y+22	; 0x16
    db08:	ce 01       	movw	r24, r28
    db0a:	01 96       	adiw	r24, 0x01	; 1
    db0c:	0e 94 b3 72 	call	0xe566	; 0xe566 <vfscanf>
    db10:	2e 96       	adiw	r28, 0x0e	; 14
    db12:	0f b6       	in	r0, 0x3f	; 63
    db14:	f8 94       	cli
    db16:	de bf       	out	0x3e, r29	; 62
    db18:	0f be       	out	0x3f, r0	; 63
    db1a:	cd bf       	out	0x3d, r28	; 61
    db1c:	df 91       	pop	r29
    db1e:	cf 91       	pop	r28
    db20:	08 95       	ret

0000db22 <__divsf3>:
    db22:	0c d0       	rcall	.+24     	; 0xdb3c <__divsf3x>
    db24:	eb c0       	rjmp	.+470    	; 0xdcfc <__fp_round>
    db26:	e3 d0       	rcall	.+454    	; 0xdcee <__fp_pscB>
    db28:	40 f0       	brcs	.+16     	; 0xdb3a <__divsf3+0x18>
    db2a:	da d0       	rcall	.+436    	; 0xdce0 <__fp_pscA>
    db2c:	30 f0       	brcs	.+12     	; 0xdb3a <__divsf3+0x18>
    db2e:	21 f4       	brne	.+8      	; 0xdb38 <__divsf3+0x16>
    db30:	5f 3f       	cpi	r21, 0xFF	; 255
    db32:	19 f0       	breq	.+6      	; 0xdb3a <__divsf3+0x18>
    db34:	cc c0       	rjmp	.+408    	; 0xdcce <__fp_inf>
    db36:	51 11       	cpse	r21, r1
    db38:	15 c1       	rjmp	.+554    	; 0xdd64 <__fp_szero>
    db3a:	cf c0       	rjmp	.+414    	; 0xdcda <__fp_nan>

0000db3c <__divsf3x>:
    db3c:	f0 d0       	rcall	.+480    	; 0xdd1e <__fp_split3>
    db3e:	98 f3       	brcs	.-26     	; 0xdb26 <__divsf3+0x4>

0000db40 <__divsf3_pse>:
    db40:	99 23       	and	r25, r25
    db42:	c9 f3       	breq	.-14     	; 0xdb36 <__divsf3+0x14>
    db44:	55 23       	and	r21, r21
    db46:	b1 f3       	breq	.-20     	; 0xdb34 <__divsf3+0x12>
    db48:	95 1b       	sub	r25, r21
    db4a:	55 0b       	sbc	r21, r21
    db4c:	bb 27       	eor	r27, r27
    db4e:	aa 27       	eor	r26, r26
    db50:	62 17       	cp	r22, r18
    db52:	73 07       	cpc	r23, r19
    db54:	84 07       	cpc	r24, r20
    db56:	38 f0       	brcs	.+14     	; 0xdb66 <__divsf3_pse+0x26>
    db58:	9f 5f       	subi	r25, 0xFF	; 255
    db5a:	5f 4f       	sbci	r21, 0xFF	; 255
    db5c:	22 0f       	add	r18, r18
    db5e:	33 1f       	adc	r19, r19
    db60:	44 1f       	adc	r20, r20
    db62:	aa 1f       	adc	r26, r26
    db64:	a9 f3       	breq	.-22     	; 0xdb50 <__divsf3_pse+0x10>
    db66:	33 d0       	rcall	.+102    	; 0xdbce <__divsf3_pse+0x8e>
    db68:	0e 2e       	mov	r0, r30
    db6a:	3a f0       	brmi	.+14     	; 0xdb7a <__divsf3_pse+0x3a>
    db6c:	e0 e8       	ldi	r30, 0x80	; 128
    db6e:	30 d0       	rcall	.+96     	; 0xdbd0 <__divsf3_pse+0x90>
    db70:	91 50       	subi	r25, 0x01	; 1
    db72:	50 40       	sbci	r21, 0x00	; 0
    db74:	e6 95       	lsr	r30
    db76:	00 1c       	adc	r0, r0
    db78:	ca f7       	brpl	.-14     	; 0xdb6c <__divsf3_pse+0x2c>
    db7a:	29 d0       	rcall	.+82     	; 0xdbce <__divsf3_pse+0x8e>
    db7c:	fe 2f       	mov	r31, r30
    db7e:	27 d0       	rcall	.+78     	; 0xdbce <__divsf3_pse+0x8e>
    db80:	66 0f       	add	r22, r22
    db82:	77 1f       	adc	r23, r23
    db84:	88 1f       	adc	r24, r24
    db86:	bb 1f       	adc	r27, r27
    db88:	26 17       	cp	r18, r22
    db8a:	37 07       	cpc	r19, r23
    db8c:	48 07       	cpc	r20, r24
    db8e:	ab 07       	cpc	r26, r27
    db90:	b0 e8       	ldi	r27, 0x80	; 128
    db92:	09 f0       	breq	.+2      	; 0xdb96 <__divsf3_pse+0x56>
    db94:	bb 0b       	sbc	r27, r27
    db96:	80 2d       	mov	r24, r0
    db98:	bf 01       	movw	r22, r30
    db9a:	ff 27       	eor	r31, r31
    db9c:	93 58       	subi	r25, 0x83	; 131
    db9e:	5f 4f       	sbci	r21, 0xFF	; 255
    dba0:	2a f0       	brmi	.+10     	; 0xdbac <__divsf3_pse+0x6c>
    dba2:	9e 3f       	cpi	r25, 0xFE	; 254
    dba4:	51 05       	cpc	r21, r1
    dba6:	68 f0       	brcs	.+26     	; 0xdbc2 <__divsf3_pse+0x82>
    dba8:	92 c0       	rjmp	.+292    	; 0xdcce <__fp_inf>
    dbaa:	dc c0       	rjmp	.+440    	; 0xdd64 <__fp_szero>
    dbac:	5f 3f       	cpi	r21, 0xFF	; 255
    dbae:	ec f3       	brlt	.-6      	; 0xdbaa <__divsf3_pse+0x6a>
    dbb0:	98 3e       	cpi	r25, 0xE8	; 232
    dbb2:	dc f3       	brlt	.-10     	; 0xdbaa <__divsf3_pse+0x6a>
    dbb4:	86 95       	lsr	r24
    dbb6:	77 95       	ror	r23
    dbb8:	67 95       	ror	r22
    dbba:	b7 95       	ror	r27
    dbbc:	f7 95       	ror	r31
    dbbe:	9f 5f       	subi	r25, 0xFF	; 255
    dbc0:	c9 f7       	brne	.-14     	; 0xdbb4 <__divsf3_pse+0x74>
    dbc2:	88 0f       	add	r24, r24
    dbc4:	91 1d       	adc	r25, r1
    dbc6:	96 95       	lsr	r25
    dbc8:	87 95       	ror	r24
    dbca:	97 f9       	bld	r25, 7
    dbcc:	08 95       	ret
    dbce:	e1 e0       	ldi	r30, 0x01	; 1
    dbd0:	66 0f       	add	r22, r22
    dbd2:	77 1f       	adc	r23, r23
    dbd4:	88 1f       	adc	r24, r24
    dbd6:	bb 1f       	adc	r27, r27
    dbd8:	62 17       	cp	r22, r18
    dbda:	73 07       	cpc	r23, r19
    dbdc:	84 07       	cpc	r24, r20
    dbde:	ba 07       	cpc	r27, r26
    dbe0:	20 f0       	brcs	.+8      	; 0xdbea <__divsf3_pse+0xaa>
    dbe2:	62 1b       	sub	r22, r18
    dbe4:	73 0b       	sbc	r23, r19
    dbe6:	84 0b       	sbc	r24, r20
    dbe8:	ba 0b       	sbc	r27, r26
    dbea:	ee 1f       	adc	r30, r30
    dbec:	88 f7       	brcc	.-30     	; 0xdbd0 <__divsf3_pse+0x90>
    dbee:	e0 95       	com	r30
    dbf0:	08 95       	ret

0000dbf2 <__fixsfsi>:
    dbf2:	04 d0       	rcall	.+8      	; 0xdbfc <__fixunssfsi>
    dbf4:	68 94       	set
    dbf6:	b1 11       	cpse	r27, r1
    dbf8:	b5 c0       	rjmp	.+362    	; 0xdd64 <__fp_szero>
    dbfa:	08 95       	ret

0000dbfc <__fixunssfsi>:
    dbfc:	98 d0       	rcall	.+304    	; 0xdd2e <__fp_splitA>
    dbfe:	88 f0       	brcs	.+34     	; 0xdc22 <__fixunssfsi+0x26>
    dc00:	9f 57       	subi	r25, 0x7F	; 127
    dc02:	90 f0       	brcs	.+36     	; 0xdc28 <__fixunssfsi+0x2c>
    dc04:	b9 2f       	mov	r27, r25
    dc06:	99 27       	eor	r25, r25
    dc08:	b7 51       	subi	r27, 0x17	; 23
    dc0a:	a0 f0       	brcs	.+40     	; 0xdc34 <__fixunssfsi+0x38>
    dc0c:	d1 f0       	breq	.+52     	; 0xdc42 <__fixunssfsi+0x46>
    dc0e:	66 0f       	add	r22, r22
    dc10:	77 1f       	adc	r23, r23
    dc12:	88 1f       	adc	r24, r24
    dc14:	99 1f       	adc	r25, r25
    dc16:	1a f0       	brmi	.+6      	; 0xdc1e <__fixunssfsi+0x22>
    dc18:	ba 95       	dec	r27
    dc1a:	c9 f7       	brne	.-14     	; 0xdc0e <__fixunssfsi+0x12>
    dc1c:	12 c0       	rjmp	.+36     	; 0xdc42 <__fixunssfsi+0x46>
    dc1e:	b1 30       	cpi	r27, 0x01	; 1
    dc20:	81 f0       	breq	.+32     	; 0xdc42 <__fixunssfsi+0x46>
    dc22:	9f d0       	rcall	.+318    	; 0xdd62 <__fp_zero>
    dc24:	b1 e0       	ldi	r27, 0x01	; 1
    dc26:	08 95       	ret
    dc28:	9c c0       	rjmp	.+312    	; 0xdd62 <__fp_zero>
    dc2a:	67 2f       	mov	r22, r23
    dc2c:	78 2f       	mov	r23, r24
    dc2e:	88 27       	eor	r24, r24
    dc30:	b8 5f       	subi	r27, 0xF8	; 248
    dc32:	39 f0       	breq	.+14     	; 0xdc42 <__fixunssfsi+0x46>
    dc34:	b9 3f       	cpi	r27, 0xF9	; 249
    dc36:	cc f3       	brlt	.-14     	; 0xdc2a <__fixunssfsi+0x2e>
    dc38:	86 95       	lsr	r24
    dc3a:	77 95       	ror	r23
    dc3c:	67 95       	ror	r22
    dc3e:	b3 95       	inc	r27
    dc40:	d9 f7       	brne	.-10     	; 0xdc38 <__fixunssfsi+0x3c>
    dc42:	3e f4       	brtc	.+14     	; 0xdc52 <__fixunssfsi+0x56>
    dc44:	90 95       	com	r25
    dc46:	80 95       	com	r24
    dc48:	70 95       	com	r23
    dc4a:	61 95       	neg	r22
    dc4c:	7f 4f       	sbci	r23, 0xFF	; 255
    dc4e:	8f 4f       	sbci	r24, 0xFF	; 255
    dc50:	9f 4f       	sbci	r25, 0xFF	; 255
    dc52:	08 95       	ret

0000dc54 <__floatunsisf>:
    dc54:	e8 94       	clt
    dc56:	09 c0       	rjmp	.+18     	; 0xdc6a <__floatsisf+0x12>

0000dc58 <__floatsisf>:
    dc58:	97 fb       	bst	r25, 7
    dc5a:	3e f4       	brtc	.+14     	; 0xdc6a <__floatsisf+0x12>
    dc5c:	90 95       	com	r25
    dc5e:	80 95       	com	r24
    dc60:	70 95       	com	r23
    dc62:	61 95       	neg	r22
    dc64:	7f 4f       	sbci	r23, 0xFF	; 255
    dc66:	8f 4f       	sbci	r24, 0xFF	; 255
    dc68:	9f 4f       	sbci	r25, 0xFF	; 255
    dc6a:	99 23       	and	r25, r25
    dc6c:	a9 f0       	breq	.+42     	; 0xdc98 <__floatsisf+0x40>
    dc6e:	f9 2f       	mov	r31, r25
    dc70:	96 e9       	ldi	r25, 0x96	; 150
    dc72:	bb 27       	eor	r27, r27
    dc74:	93 95       	inc	r25
    dc76:	f6 95       	lsr	r31
    dc78:	87 95       	ror	r24
    dc7a:	77 95       	ror	r23
    dc7c:	67 95       	ror	r22
    dc7e:	b7 95       	ror	r27
    dc80:	f1 11       	cpse	r31, r1
    dc82:	f8 cf       	rjmp	.-16     	; 0xdc74 <__floatsisf+0x1c>
    dc84:	fa f4       	brpl	.+62     	; 0xdcc4 <__floatsisf+0x6c>
    dc86:	bb 0f       	add	r27, r27
    dc88:	11 f4       	brne	.+4      	; 0xdc8e <__floatsisf+0x36>
    dc8a:	60 ff       	sbrs	r22, 0
    dc8c:	1b c0       	rjmp	.+54     	; 0xdcc4 <__floatsisf+0x6c>
    dc8e:	6f 5f       	subi	r22, 0xFF	; 255
    dc90:	7f 4f       	sbci	r23, 0xFF	; 255
    dc92:	8f 4f       	sbci	r24, 0xFF	; 255
    dc94:	9f 4f       	sbci	r25, 0xFF	; 255
    dc96:	16 c0       	rjmp	.+44     	; 0xdcc4 <__floatsisf+0x6c>
    dc98:	88 23       	and	r24, r24
    dc9a:	11 f0       	breq	.+4      	; 0xdca0 <__floatsisf+0x48>
    dc9c:	96 e9       	ldi	r25, 0x96	; 150
    dc9e:	11 c0       	rjmp	.+34     	; 0xdcc2 <__floatsisf+0x6a>
    dca0:	77 23       	and	r23, r23
    dca2:	21 f0       	breq	.+8      	; 0xdcac <__floatsisf+0x54>
    dca4:	9e e8       	ldi	r25, 0x8E	; 142
    dca6:	87 2f       	mov	r24, r23
    dca8:	76 2f       	mov	r23, r22
    dcaa:	05 c0       	rjmp	.+10     	; 0xdcb6 <__floatsisf+0x5e>
    dcac:	66 23       	and	r22, r22
    dcae:	71 f0       	breq	.+28     	; 0xdccc <__floatsisf+0x74>
    dcb0:	96 e8       	ldi	r25, 0x86	; 134
    dcb2:	86 2f       	mov	r24, r22
    dcb4:	70 e0       	ldi	r23, 0x00	; 0
    dcb6:	60 e0       	ldi	r22, 0x00	; 0
    dcb8:	2a f0       	brmi	.+10     	; 0xdcc4 <__floatsisf+0x6c>
    dcba:	9a 95       	dec	r25
    dcbc:	66 0f       	add	r22, r22
    dcbe:	77 1f       	adc	r23, r23
    dcc0:	88 1f       	adc	r24, r24
    dcc2:	da f7       	brpl	.-10     	; 0xdcba <__floatsisf+0x62>
    dcc4:	88 0f       	add	r24, r24
    dcc6:	96 95       	lsr	r25
    dcc8:	87 95       	ror	r24
    dcca:	97 f9       	bld	r25, 7
    dccc:	08 95       	ret

0000dcce <__fp_inf>:
    dcce:	97 f9       	bld	r25, 7
    dcd0:	9f 67       	ori	r25, 0x7F	; 127
    dcd2:	80 e8       	ldi	r24, 0x80	; 128
    dcd4:	70 e0       	ldi	r23, 0x00	; 0
    dcd6:	60 e0       	ldi	r22, 0x00	; 0
    dcd8:	08 95       	ret

0000dcda <__fp_nan>:
    dcda:	9f ef       	ldi	r25, 0xFF	; 255
    dcdc:	80 ec       	ldi	r24, 0xC0	; 192
    dcde:	08 95       	ret

0000dce0 <__fp_pscA>:
    dce0:	00 24       	eor	r0, r0
    dce2:	0a 94       	dec	r0
    dce4:	16 16       	cp	r1, r22
    dce6:	17 06       	cpc	r1, r23
    dce8:	18 06       	cpc	r1, r24
    dcea:	09 06       	cpc	r0, r25
    dcec:	08 95       	ret

0000dcee <__fp_pscB>:
    dcee:	00 24       	eor	r0, r0
    dcf0:	0a 94       	dec	r0
    dcf2:	12 16       	cp	r1, r18
    dcf4:	13 06       	cpc	r1, r19
    dcf6:	14 06       	cpc	r1, r20
    dcf8:	05 06       	cpc	r0, r21
    dcfa:	08 95       	ret

0000dcfc <__fp_round>:
    dcfc:	09 2e       	mov	r0, r25
    dcfe:	03 94       	inc	r0
    dd00:	00 0c       	add	r0, r0
    dd02:	11 f4       	brne	.+4      	; 0xdd08 <__fp_round+0xc>
    dd04:	88 23       	and	r24, r24
    dd06:	52 f0       	brmi	.+20     	; 0xdd1c <__fp_round+0x20>
    dd08:	bb 0f       	add	r27, r27
    dd0a:	40 f4       	brcc	.+16     	; 0xdd1c <__fp_round+0x20>
    dd0c:	bf 2b       	or	r27, r31
    dd0e:	11 f4       	brne	.+4      	; 0xdd14 <__fp_round+0x18>
    dd10:	60 ff       	sbrs	r22, 0
    dd12:	04 c0       	rjmp	.+8      	; 0xdd1c <__fp_round+0x20>
    dd14:	6f 5f       	subi	r22, 0xFF	; 255
    dd16:	7f 4f       	sbci	r23, 0xFF	; 255
    dd18:	8f 4f       	sbci	r24, 0xFF	; 255
    dd1a:	9f 4f       	sbci	r25, 0xFF	; 255
    dd1c:	08 95       	ret

0000dd1e <__fp_split3>:
    dd1e:	57 fd       	sbrc	r21, 7
    dd20:	90 58       	subi	r25, 0x80	; 128
    dd22:	44 0f       	add	r20, r20
    dd24:	55 1f       	adc	r21, r21
    dd26:	59 f0       	breq	.+22     	; 0xdd3e <__fp_splitA+0x10>
    dd28:	5f 3f       	cpi	r21, 0xFF	; 255
    dd2a:	71 f0       	breq	.+28     	; 0xdd48 <__fp_splitA+0x1a>
    dd2c:	47 95       	ror	r20

0000dd2e <__fp_splitA>:
    dd2e:	88 0f       	add	r24, r24
    dd30:	97 fb       	bst	r25, 7
    dd32:	99 1f       	adc	r25, r25
    dd34:	61 f0       	breq	.+24     	; 0xdd4e <__fp_splitA+0x20>
    dd36:	9f 3f       	cpi	r25, 0xFF	; 255
    dd38:	79 f0       	breq	.+30     	; 0xdd58 <__fp_splitA+0x2a>
    dd3a:	87 95       	ror	r24
    dd3c:	08 95       	ret
    dd3e:	12 16       	cp	r1, r18
    dd40:	13 06       	cpc	r1, r19
    dd42:	14 06       	cpc	r1, r20
    dd44:	55 1f       	adc	r21, r21
    dd46:	f2 cf       	rjmp	.-28     	; 0xdd2c <__fp_split3+0xe>
    dd48:	46 95       	lsr	r20
    dd4a:	f1 df       	rcall	.-30     	; 0xdd2e <__fp_splitA>
    dd4c:	08 c0       	rjmp	.+16     	; 0xdd5e <__fp_splitA+0x30>
    dd4e:	16 16       	cp	r1, r22
    dd50:	17 06       	cpc	r1, r23
    dd52:	18 06       	cpc	r1, r24
    dd54:	99 1f       	adc	r25, r25
    dd56:	f1 cf       	rjmp	.-30     	; 0xdd3a <__fp_splitA+0xc>
    dd58:	86 95       	lsr	r24
    dd5a:	71 05       	cpc	r23, r1
    dd5c:	61 05       	cpc	r22, r1
    dd5e:	08 94       	sec
    dd60:	08 95       	ret

0000dd62 <__fp_zero>:
    dd62:	e8 94       	clt

0000dd64 <__fp_szero>:
    dd64:	bb 27       	eor	r27, r27
    dd66:	66 27       	eor	r22, r22
    dd68:	77 27       	eor	r23, r23
    dd6a:	cb 01       	movw	r24, r22
    dd6c:	97 f9       	bld	r25, 7
    dd6e:	08 95       	ret

0000dd70 <__mulsf3>:
    dd70:	0b d0       	rcall	.+22     	; 0xdd88 <__mulsf3x>
    dd72:	c4 cf       	rjmp	.-120    	; 0xdcfc <__fp_round>
    dd74:	b5 df       	rcall	.-150    	; 0xdce0 <__fp_pscA>
    dd76:	28 f0       	brcs	.+10     	; 0xdd82 <__mulsf3+0x12>
    dd78:	ba df       	rcall	.-140    	; 0xdcee <__fp_pscB>
    dd7a:	18 f0       	brcs	.+6      	; 0xdd82 <__mulsf3+0x12>
    dd7c:	95 23       	and	r25, r21
    dd7e:	09 f0       	breq	.+2      	; 0xdd82 <__mulsf3+0x12>
    dd80:	a6 cf       	rjmp	.-180    	; 0xdcce <__fp_inf>
    dd82:	ab cf       	rjmp	.-170    	; 0xdcda <__fp_nan>
    dd84:	11 24       	eor	r1, r1
    dd86:	ee cf       	rjmp	.-36     	; 0xdd64 <__fp_szero>

0000dd88 <__mulsf3x>:
    dd88:	ca df       	rcall	.-108    	; 0xdd1e <__fp_split3>
    dd8a:	a0 f3       	brcs	.-24     	; 0xdd74 <__mulsf3+0x4>

0000dd8c <__mulsf3_pse>:
    dd8c:	95 9f       	mul	r25, r21
    dd8e:	d1 f3       	breq	.-12     	; 0xdd84 <__mulsf3+0x14>
    dd90:	95 0f       	add	r25, r21
    dd92:	50 e0       	ldi	r21, 0x00	; 0
    dd94:	55 1f       	adc	r21, r21
    dd96:	62 9f       	mul	r22, r18
    dd98:	f0 01       	movw	r30, r0
    dd9a:	72 9f       	mul	r23, r18
    dd9c:	bb 27       	eor	r27, r27
    dd9e:	f0 0d       	add	r31, r0
    dda0:	b1 1d       	adc	r27, r1
    dda2:	63 9f       	mul	r22, r19
    dda4:	aa 27       	eor	r26, r26
    dda6:	f0 0d       	add	r31, r0
    dda8:	b1 1d       	adc	r27, r1
    ddaa:	aa 1f       	adc	r26, r26
    ddac:	64 9f       	mul	r22, r20
    ddae:	66 27       	eor	r22, r22
    ddb0:	b0 0d       	add	r27, r0
    ddb2:	a1 1d       	adc	r26, r1
    ddb4:	66 1f       	adc	r22, r22
    ddb6:	82 9f       	mul	r24, r18
    ddb8:	22 27       	eor	r18, r18
    ddba:	b0 0d       	add	r27, r0
    ddbc:	a1 1d       	adc	r26, r1
    ddbe:	62 1f       	adc	r22, r18
    ddc0:	73 9f       	mul	r23, r19
    ddc2:	b0 0d       	add	r27, r0
    ddc4:	a1 1d       	adc	r26, r1
    ddc6:	62 1f       	adc	r22, r18
    ddc8:	83 9f       	mul	r24, r19
    ddca:	a0 0d       	add	r26, r0
    ddcc:	61 1d       	adc	r22, r1
    ddce:	22 1f       	adc	r18, r18
    ddd0:	74 9f       	mul	r23, r20
    ddd2:	33 27       	eor	r19, r19
    ddd4:	a0 0d       	add	r26, r0
    ddd6:	61 1d       	adc	r22, r1
    ddd8:	23 1f       	adc	r18, r19
    ddda:	84 9f       	mul	r24, r20
    dddc:	60 0d       	add	r22, r0
    ddde:	21 1d       	adc	r18, r1
    dde0:	82 2f       	mov	r24, r18
    dde2:	76 2f       	mov	r23, r22
    dde4:	6a 2f       	mov	r22, r26
    dde6:	11 24       	eor	r1, r1
    dde8:	9f 57       	subi	r25, 0x7F	; 127
    ddea:	50 40       	sbci	r21, 0x00	; 0
    ddec:	8a f0       	brmi	.+34     	; 0xde10 <__mulsf3_pse+0x84>
    ddee:	e1 f0       	breq	.+56     	; 0xde28 <__mulsf3_pse+0x9c>
    ddf0:	88 23       	and	r24, r24
    ddf2:	4a f0       	brmi	.+18     	; 0xde06 <__mulsf3_pse+0x7a>
    ddf4:	ee 0f       	add	r30, r30
    ddf6:	ff 1f       	adc	r31, r31
    ddf8:	bb 1f       	adc	r27, r27
    ddfa:	66 1f       	adc	r22, r22
    ddfc:	77 1f       	adc	r23, r23
    ddfe:	88 1f       	adc	r24, r24
    de00:	91 50       	subi	r25, 0x01	; 1
    de02:	50 40       	sbci	r21, 0x00	; 0
    de04:	a9 f7       	brne	.-22     	; 0xddf0 <__mulsf3_pse+0x64>
    de06:	9e 3f       	cpi	r25, 0xFE	; 254
    de08:	51 05       	cpc	r21, r1
    de0a:	70 f0       	brcs	.+28     	; 0xde28 <__mulsf3_pse+0x9c>
    de0c:	60 cf       	rjmp	.-320    	; 0xdcce <__fp_inf>
    de0e:	aa cf       	rjmp	.-172    	; 0xdd64 <__fp_szero>
    de10:	5f 3f       	cpi	r21, 0xFF	; 255
    de12:	ec f3       	brlt	.-6      	; 0xde0e <__mulsf3_pse+0x82>
    de14:	98 3e       	cpi	r25, 0xE8	; 232
    de16:	dc f3       	brlt	.-10     	; 0xde0e <__mulsf3_pse+0x82>
    de18:	86 95       	lsr	r24
    de1a:	77 95       	ror	r23
    de1c:	67 95       	ror	r22
    de1e:	b7 95       	ror	r27
    de20:	f7 95       	ror	r31
    de22:	e7 95       	ror	r30
    de24:	9f 5f       	subi	r25, 0xFF	; 255
    de26:	c1 f7       	brne	.-16     	; 0xde18 <__mulsf3_pse+0x8c>
    de28:	fe 2b       	or	r31, r30
    de2a:	88 0f       	add	r24, r24
    de2c:	91 1d       	adc	r25, r1
    de2e:	96 95       	lsr	r25
    de30:	87 95       	ror	r24
    de32:	97 f9       	bld	r25, 7
    de34:	08 95       	ret

0000de36 <vfprintf>:
    de36:	2f 92       	push	r2
    de38:	3f 92       	push	r3
    de3a:	4f 92       	push	r4
    de3c:	5f 92       	push	r5
    de3e:	6f 92       	push	r6
    de40:	7f 92       	push	r7
    de42:	8f 92       	push	r8
    de44:	9f 92       	push	r9
    de46:	af 92       	push	r10
    de48:	bf 92       	push	r11
    de4a:	cf 92       	push	r12
    de4c:	df 92       	push	r13
    de4e:	ef 92       	push	r14
    de50:	ff 92       	push	r15
    de52:	0f 93       	push	r16
    de54:	1f 93       	push	r17
    de56:	cf 93       	push	r28
    de58:	df 93       	push	r29
    de5a:	cd b7       	in	r28, 0x3d	; 61
    de5c:	de b7       	in	r29, 0x3e	; 62
    de5e:	2c 97       	sbiw	r28, 0x0c	; 12
    de60:	0f b6       	in	r0, 0x3f	; 63
    de62:	f8 94       	cli
    de64:	de bf       	out	0x3e, r29	; 62
    de66:	0f be       	out	0x3f, r0	; 63
    de68:	cd bf       	out	0x3d, r28	; 61
    de6a:	7c 01       	movw	r14, r24
    de6c:	6b 01       	movw	r12, r22
    de6e:	8a 01       	movw	r16, r20
    de70:	fc 01       	movw	r30, r24
    de72:	17 82       	std	Z+7, r1	; 0x07
    de74:	16 82       	std	Z+6, r1	; 0x06
    de76:	83 81       	ldd	r24, Z+3	; 0x03
    de78:	81 ff       	sbrs	r24, 1
    de7a:	bd c1       	rjmp	.+890    	; 0xe1f6 <vfprintf+0x3c0>
    de7c:	ce 01       	movw	r24, r28
    de7e:	01 96       	adiw	r24, 0x01	; 1
    de80:	4c 01       	movw	r8, r24
    de82:	f7 01       	movw	r30, r14
    de84:	93 81       	ldd	r25, Z+3	; 0x03
    de86:	f6 01       	movw	r30, r12
    de88:	93 fd       	sbrc	r25, 3
    de8a:	85 91       	lpm	r24, Z+
    de8c:	93 ff       	sbrs	r25, 3
    de8e:	81 91       	ld	r24, Z+
    de90:	6f 01       	movw	r12, r30
    de92:	88 23       	and	r24, r24
    de94:	09 f4       	brne	.+2      	; 0xde98 <vfprintf+0x62>
    de96:	ab c1       	rjmp	.+854    	; 0xe1ee <vfprintf+0x3b8>
    de98:	85 32       	cpi	r24, 0x25	; 37
    de9a:	39 f4       	brne	.+14     	; 0xdeaa <vfprintf+0x74>
    de9c:	93 fd       	sbrc	r25, 3
    de9e:	85 91       	lpm	r24, Z+
    dea0:	93 ff       	sbrs	r25, 3
    dea2:	81 91       	ld	r24, Z+
    dea4:	6f 01       	movw	r12, r30
    dea6:	85 32       	cpi	r24, 0x25	; 37
    dea8:	29 f4       	brne	.+10     	; 0xdeb4 <vfprintf+0x7e>
    deaa:	b7 01       	movw	r22, r14
    deac:	90 e0       	ldi	r25, 0x00	; 0
    deae:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    deb2:	e7 cf       	rjmp	.-50     	; 0xde82 <vfprintf+0x4c>
    deb4:	51 2c       	mov	r5, r1
    deb6:	31 2c       	mov	r3, r1
    deb8:	20 e0       	ldi	r18, 0x00	; 0
    deba:	20 32       	cpi	r18, 0x20	; 32
    debc:	a0 f4       	brcc	.+40     	; 0xdee6 <vfprintf+0xb0>
    debe:	8b 32       	cpi	r24, 0x2B	; 43
    dec0:	69 f0       	breq	.+26     	; 0xdedc <vfprintf+0xa6>
    dec2:	30 f4       	brcc	.+12     	; 0xded0 <vfprintf+0x9a>
    dec4:	80 32       	cpi	r24, 0x20	; 32
    dec6:	59 f0       	breq	.+22     	; 0xdede <vfprintf+0xa8>
    dec8:	83 32       	cpi	r24, 0x23	; 35
    deca:	69 f4       	brne	.+26     	; 0xdee6 <vfprintf+0xb0>
    decc:	20 61       	ori	r18, 0x10	; 16
    dece:	2c c0       	rjmp	.+88     	; 0xdf28 <vfprintf+0xf2>
    ded0:	8d 32       	cpi	r24, 0x2D	; 45
    ded2:	39 f0       	breq	.+14     	; 0xdee2 <vfprintf+0xac>
    ded4:	80 33       	cpi	r24, 0x30	; 48
    ded6:	39 f4       	brne	.+14     	; 0xdee6 <vfprintf+0xb0>
    ded8:	21 60       	ori	r18, 0x01	; 1
    deda:	26 c0       	rjmp	.+76     	; 0xdf28 <vfprintf+0xf2>
    dedc:	22 60       	ori	r18, 0x02	; 2
    dede:	24 60       	ori	r18, 0x04	; 4
    dee0:	23 c0       	rjmp	.+70     	; 0xdf28 <vfprintf+0xf2>
    dee2:	28 60       	ori	r18, 0x08	; 8
    dee4:	21 c0       	rjmp	.+66     	; 0xdf28 <vfprintf+0xf2>
    dee6:	27 fd       	sbrc	r18, 7
    dee8:	27 c0       	rjmp	.+78     	; 0xdf38 <vfprintf+0x102>
    deea:	30 ed       	ldi	r19, 0xD0	; 208
    deec:	38 0f       	add	r19, r24
    deee:	3a 30       	cpi	r19, 0x0A	; 10
    def0:	78 f4       	brcc	.+30     	; 0xdf10 <vfprintf+0xda>
    def2:	26 ff       	sbrs	r18, 6
    def4:	06 c0       	rjmp	.+12     	; 0xdf02 <vfprintf+0xcc>
    def6:	fa e0       	ldi	r31, 0x0A	; 10
    def8:	5f 9e       	mul	r5, r31
    defa:	30 0d       	add	r19, r0
    defc:	11 24       	eor	r1, r1
    defe:	53 2e       	mov	r5, r19
    df00:	13 c0       	rjmp	.+38     	; 0xdf28 <vfprintf+0xf2>
    df02:	8a e0       	ldi	r24, 0x0A	; 10
    df04:	38 9e       	mul	r3, r24
    df06:	30 0d       	add	r19, r0
    df08:	11 24       	eor	r1, r1
    df0a:	33 2e       	mov	r3, r19
    df0c:	20 62       	ori	r18, 0x20	; 32
    df0e:	0c c0       	rjmp	.+24     	; 0xdf28 <vfprintf+0xf2>
    df10:	8e 32       	cpi	r24, 0x2E	; 46
    df12:	21 f4       	brne	.+8      	; 0xdf1c <vfprintf+0xe6>
    df14:	26 fd       	sbrc	r18, 6
    df16:	6b c1       	rjmp	.+726    	; 0xe1ee <vfprintf+0x3b8>
    df18:	20 64       	ori	r18, 0x40	; 64
    df1a:	06 c0       	rjmp	.+12     	; 0xdf28 <vfprintf+0xf2>
    df1c:	8c 36       	cpi	r24, 0x6C	; 108
    df1e:	11 f4       	brne	.+4      	; 0xdf24 <vfprintf+0xee>
    df20:	20 68       	ori	r18, 0x80	; 128
    df22:	02 c0       	rjmp	.+4      	; 0xdf28 <vfprintf+0xf2>
    df24:	88 36       	cpi	r24, 0x68	; 104
    df26:	41 f4       	brne	.+16     	; 0xdf38 <vfprintf+0x102>
    df28:	f6 01       	movw	r30, r12
    df2a:	93 fd       	sbrc	r25, 3
    df2c:	85 91       	lpm	r24, Z+
    df2e:	93 ff       	sbrs	r25, 3
    df30:	81 91       	ld	r24, Z+
    df32:	6f 01       	movw	r12, r30
    df34:	81 11       	cpse	r24, r1
    df36:	c1 cf       	rjmp	.-126    	; 0xdeba <vfprintf+0x84>
    df38:	98 2f       	mov	r25, r24
    df3a:	9f 7d       	andi	r25, 0xDF	; 223
    df3c:	95 54       	subi	r25, 0x45	; 69
    df3e:	93 30       	cpi	r25, 0x03	; 3
    df40:	28 f4       	brcc	.+10     	; 0xdf4c <vfprintf+0x116>
    df42:	0c 5f       	subi	r16, 0xFC	; 252
    df44:	1f 4f       	sbci	r17, 0xFF	; 255
    df46:	ff e3       	ldi	r31, 0x3F	; 63
    df48:	f9 83       	std	Y+1, r31	; 0x01
    df4a:	0d c0       	rjmp	.+26     	; 0xdf66 <vfprintf+0x130>
    df4c:	83 36       	cpi	r24, 0x63	; 99
    df4e:	31 f0       	breq	.+12     	; 0xdf5c <vfprintf+0x126>
    df50:	83 37       	cpi	r24, 0x73	; 115
    df52:	71 f0       	breq	.+28     	; 0xdf70 <vfprintf+0x13a>
    df54:	83 35       	cpi	r24, 0x53	; 83
    df56:	09 f0       	breq	.+2      	; 0xdf5a <vfprintf+0x124>
    df58:	5b c0       	rjmp	.+182    	; 0xe010 <vfprintf+0x1da>
    df5a:	22 c0       	rjmp	.+68     	; 0xdfa0 <vfprintf+0x16a>
    df5c:	f8 01       	movw	r30, r16
    df5e:	80 81       	ld	r24, Z
    df60:	89 83       	std	Y+1, r24	; 0x01
    df62:	0e 5f       	subi	r16, 0xFE	; 254
    df64:	1f 4f       	sbci	r17, 0xFF	; 255
    df66:	44 24       	eor	r4, r4
    df68:	43 94       	inc	r4
    df6a:	51 2c       	mov	r5, r1
    df6c:	54 01       	movw	r10, r8
    df6e:	15 c0       	rjmp	.+42     	; 0xdf9a <vfprintf+0x164>
    df70:	38 01       	movw	r6, r16
    df72:	f2 e0       	ldi	r31, 0x02	; 2
    df74:	6f 0e       	add	r6, r31
    df76:	71 1c       	adc	r7, r1
    df78:	f8 01       	movw	r30, r16
    df7a:	a0 80       	ld	r10, Z
    df7c:	b1 80       	ldd	r11, Z+1	; 0x01
    df7e:	26 ff       	sbrs	r18, 6
    df80:	03 c0       	rjmp	.+6      	; 0xdf88 <vfprintf+0x152>
    df82:	65 2d       	mov	r22, r5
    df84:	70 e0       	ldi	r23, 0x00	; 0
    df86:	02 c0       	rjmp	.+4      	; 0xdf8c <vfprintf+0x156>
    df88:	6f ef       	ldi	r22, 0xFF	; 255
    df8a:	7f ef       	ldi	r23, 0xFF	; 255
    df8c:	c5 01       	movw	r24, r10
    df8e:	2c 87       	std	Y+12, r18	; 0x0c
    df90:	0e 94 45 74 	call	0xe88a	; 0xe88a <strnlen>
    df94:	2c 01       	movw	r4, r24
    df96:	83 01       	movw	r16, r6
    df98:	2c 85       	ldd	r18, Y+12	; 0x0c
    df9a:	2f 77       	andi	r18, 0x7F	; 127
    df9c:	22 2e       	mov	r2, r18
    df9e:	17 c0       	rjmp	.+46     	; 0xdfce <vfprintf+0x198>
    dfa0:	38 01       	movw	r6, r16
    dfa2:	f2 e0       	ldi	r31, 0x02	; 2
    dfa4:	6f 0e       	add	r6, r31
    dfa6:	71 1c       	adc	r7, r1
    dfa8:	f8 01       	movw	r30, r16
    dfaa:	a0 80       	ld	r10, Z
    dfac:	b1 80       	ldd	r11, Z+1	; 0x01
    dfae:	26 ff       	sbrs	r18, 6
    dfb0:	03 c0       	rjmp	.+6      	; 0xdfb8 <vfprintf+0x182>
    dfb2:	65 2d       	mov	r22, r5
    dfb4:	70 e0       	ldi	r23, 0x00	; 0
    dfb6:	02 c0       	rjmp	.+4      	; 0xdfbc <vfprintf+0x186>
    dfb8:	6f ef       	ldi	r22, 0xFF	; 255
    dfba:	7f ef       	ldi	r23, 0xFF	; 255
    dfbc:	c5 01       	movw	r24, r10
    dfbe:	2c 87       	std	Y+12, r18	; 0x0c
    dfc0:	0e 94 3a 74 	call	0xe874	; 0xe874 <strnlen_P>
    dfc4:	2c 01       	movw	r4, r24
    dfc6:	2c 85       	ldd	r18, Y+12	; 0x0c
    dfc8:	20 68       	ori	r18, 0x80	; 128
    dfca:	22 2e       	mov	r2, r18
    dfcc:	83 01       	movw	r16, r6
    dfce:	23 fc       	sbrc	r2, 3
    dfd0:	1b c0       	rjmp	.+54     	; 0xe008 <vfprintf+0x1d2>
    dfd2:	83 2d       	mov	r24, r3
    dfd4:	90 e0       	ldi	r25, 0x00	; 0
    dfd6:	48 16       	cp	r4, r24
    dfd8:	59 06       	cpc	r5, r25
    dfda:	b0 f4       	brcc	.+44     	; 0xe008 <vfprintf+0x1d2>
    dfdc:	b7 01       	movw	r22, r14
    dfde:	80 e2       	ldi	r24, 0x20	; 32
    dfe0:	90 e0       	ldi	r25, 0x00	; 0
    dfe2:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    dfe6:	3a 94       	dec	r3
    dfe8:	f4 cf       	rjmp	.-24     	; 0xdfd2 <vfprintf+0x19c>
    dfea:	f5 01       	movw	r30, r10
    dfec:	27 fc       	sbrc	r2, 7
    dfee:	85 91       	lpm	r24, Z+
    dff0:	27 fe       	sbrs	r2, 7
    dff2:	81 91       	ld	r24, Z+
    dff4:	5f 01       	movw	r10, r30
    dff6:	b7 01       	movw	r22, r14
    dff8:	90 e0       	ldi	r25, 0x00	; 0
    dffa:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    dffe:	31 10       	cpse	r3, r1
    e000:	3a 94       	dec	r3
    e002:	f1 e0       	ldi	r31, 0x01	; 1
    e004:	4f 1a       	sub	r4, r31
    e006:	51 08       	sbc	r5, r1
    e008:	41 14       	cp	r4, r1
    e00a:	51 04       	cpc	r5, r1
    e00c:	71 f7       	brne	.-36     	; 0xdfea <vfprintf+0x1b4>
    e00e:	e5 c0       	rjmp	.+458    	; 0xe1da <vfprintf+0x3a4>
    e010:	84 36       	cpi	r24, 0x64	; 100
    e012:	11 f0       	breq	.+4      	; 0xe018 <vfprintf+0x1e2>
    e014:	89 36       	cpi	r24, 0x69	; 105
    e016:	39 f5       	brne	.+78     	; 0xe066 <vfprintf+0x230>
    e018:	f8 01       	movw	r30, r16
    e01a:	27 ff       	sbrs	r18, 7
    e01c:	07 c0       	rjmp	.+14     	; 0xe02c <vfprintf+0x1f6>
    e01e:	60 81       	ld	r22, Z
    e020:	71 81       	ldd	r23, Z+1	; 0x01
    e022:	82 81       	ldd	r24, Z+2	; 0x02
    e024:	93 81       	ldd	r25, Z+3	; 0x03
    e026:	0c 5f       	subi	r16, 0xFC	; 252
    e028:	1f 4f       	sbci	r17, 0xFF	; 255
    e02a:	08 c0       	rjmp	.+16     	; 0xe03c <vfprintf+0x206>
    e02c:	60 81       	ld	r22, Z
    e02e:	71 81       	ldd	r23, Z+1	; 0x01
    e030:	88 27       	eor	r24, r24
    e032:	77 fd       	sbrc	r23, 7
    e034:	80 95       	com	r24
    e036:	98 2f       	mov	r25, r24
    e038:	0e 5f       	subi	r16, 0xFE	; 254
    e03a:	1f 4f       	sbci	r17, 0xFF	; 255
    e03c:	2f 76       	andi	r18, 0x6F	; 111
    e03e:	b2 2e       	mov	r11, r18
    e040:	97 ff       	sbrs	r25, 7
    e042:	09 c0       	rjmp	.+18     	; 0xe056 <vfprintf+0x220>
    e044:	90 95       	com	r25
    e046:	80 95       	com	r24
    e048:	70 95       	com	r23
    e04a:	61 95       	neg	r22
    e04c:	7f 4f       	sbci	r23, 0xFF	; 255
    e04e:	8f 4f       	sbci	r24, 0xFF	; 255
    e050:	9f 4f       	sbci	r25, 0xFF	; 255
    e052:	20 68       	ori	r18, 0x80	; 128
    e054:	b2 2e       	mov	r11, r18
    e056:	2a e0       	ldi	r18, 0x0A	; 10
    e058:	30 e0       	ldi	r19, 0x00	; 0
    e05a:	a4 01       	movw	r20, r8
    e05c:	0e 94 d9 74 	call	0xe9b2	; 0xe9b2 <__ultoa_invert>
    e060:	a8 2e       	mov	r10, r24
    e062:	a8 18       	sub	r10, r8
    e064:	44 c0       	rjmp	.+136    	; 0xe0ee <vfprintf+0x2b8>
    e066:	85 37       	cpi	r24, 0x75	; 117
    e068:	29 f4       	brne	.+10     	; 0xe074 <vfprintf+0x23e>
    e06a:	2f 7e       	andi	r18, 0xEF	; 239
    e06c:	b2 2e       	mov	r11, r18
    e06e:	2a e0       	ldi	r18, 0x0A	; 10
    e070:	30 e0       	ldi	r19, 0x00	; 0
    e072:	25 c0       	rjmp	.+74     	; 0xe0be <vfprintf+0x288>
    e074:	f2 2f       	mov	r31, r18
    e076:	f9 7f       	andi	r31, 0xF9	; 249
    e078:	bf 2e       	mov	r11, r31
    e07a:	8f 36       	cpi	r24, 0x6F	; 111
    e07c:	c1 f0       	breq	.+48     	; 0xe0ae <vfprintf+0x278>
    e07e:	18 f4       	brcc	.+6      	; 0xe086 <vfprintf+0x250>
    e080:	88 35       	cpi	r24, 0x58	; 88
    e082:	79 f0       	breq	.+30     	; 0xe0a2 <vfprintf+0x26c>
    e084:	b4 c0       	rjmp	.+360    	; 0xe1ee <vfprintf+0x3b8>
    e086:	80 37       	cpi	r24, 0x70	; 112
    e088:	19 f0       	breq	.+6      	; 0xe090 <vfprintf+0x25a>
    e08a:	88 37       	cpi	r24, 0x78	; 120
    e08c:	21 f0       	breq	.+8      	; 0xe096 <vfprintf+0x260>
    e08e:	af c0       	rjmp	.+350    	; 0xe1ee <vfprintf+0x3b8>
    e090:	2f 2f       	mov	r18, r31
    e092:	20 61       	ori	r18, 0x10	; 16
    e094:	b2 2e       	mov	r11, r18
    e096:	b4 fe       	sbrs	r11, 4
    e098:	0d c0       	rjmp	.+26     	; 0xe0b4 <vfprintf+0x27e>
    e09a:	8b 2d       	mov	r24, r11
    e09c:	84 60       	ori	r24, 0x04	; 4
    e09e:	b8 2e       	mov	r11, r24
    e0a0:	09 c0       	rjmp	.+18     	; 0xe0b4 <vfprintf+0x27e>
    e0a2:	24 ff       	sbrs	r18, 4
    e0a4:	0a c0       	rjmp	.+20     	; 0xe0ba <vfprintf+0x284>
    e0a6:	9f 2f       	mov	r25, r31
    e0a8:	96 60       	ori	r25, 0x06	; 6
    e0aa:	b9 2e       	mov	r11, r25
    e0ac:	06 c0       	rjmp	.+12     	; 0xe0ba <vfprintf+0x284>
    e0ae:	28 e0       	ldi	r18, 0x08	; 8
    e0b0:	30 e0       	ldi	r19, 0x00	; 0
    e0b2:	05 c0       	rjmp	.+10     	; 0xe0be <vfprintf+0x288>
    e0b4:	20 e1       	ldi	r18, 0x10	; 16
    e0b6:	30 e0       	ldi	r19, 0x00	; 0
    e0b8:	02 c0       	rjmp	.+4      	; 0xe0be <vfprintf+0x288>
    e0ba:	20 e1       	ldi	r18, 0x10	; 16
    e0bc:	32 e0       	ldi	r19, 0x02	; 2
    e0be:	f8 01       	movw	r30, r16
    e0c0:	b7 fe       	sbrs	r11, 7
    e0c2:	07 c0       	rjmp	.+14     	; 0xe0d2 <vfprintf+0x29c>
    e0c4:	60 81       	ld	r22, Z
    e0c6:	71 81       	ldd	r23, Z+1	; 0x01
    e0c8:	82 81       	ldd	r24, Z+2	; 0x02
    e0ca:	93 81       	ldd	r25, Z+3	; 0x03
    e0cc:	0c 5f       	subi	r16, 0xFC	; 252
    e0ce:	1f 4f       	sbci	r17, 0xFF	; 255
    e0d0:	06 c0       	rjmp	.+12     	; 0xe0de <vfprintf+0x2a8>
    e0d2:	60 81       	ld	r22, Z
    e0d4:	71 81       	ldd	r23, Z+1	; 0x01
    e0d6:	80 e0       	ldi	r24, 0x00	; 0
    e0d8:	90 e0       	ldi	r25, 0x00	; 0
    e0da:	0e 5f       	subi	r16, 0xFE	; 254
    e0dc:	1f 4f       	sbci	r17, 0xFF	; 255
    e0de:	a4 01       	movw	r20, r8
    e0e0:	0e 94 d9 74 	call	0xe9b2	; 0xe9b2 <__ultoa_invert>
    e0e4:	a8 2e       	mov	r10, r24
    e0e6:	a8 18       	sub	r10, r8
    e0e8:	fb 2d       	mov	r31, r11
    e0ea:	ff 77       	andi	r31, 0x7F	; 127
    e0ec:	bf 2e       	mov	r11, r31
    e0ee:	b6 fe       	sbrs	r11, 6
    e0f0:	0b c0       	rjmp	.+22     	; 0xe108 <vfprintf+0x2d2>
    e0f2:	2b 2d       	mov	r18, r11
    e0f4:	2e 7f       	andi	r18, 0xFE	; 254
    e0f6:	a5 14       	cp	r10, r5
    e0f8:	50 f4       	brcc	.+20     	; 0xe10e <vfprintf+0x2d8>
    e0fa:	b4 fe       	sbrs	r11, 4
    e0fc:	0a c0       	rjmp	.+20     	; 0xe112 <vfprintf+0x2dc>
    e0fe:	b2 fc       	sbrc	r11, 2
    e100:	08 c0       	rjmp	.+16     	; 0xe112 <vfprintf+0x2dc>
    e102:	2b 2d       	mov	r18, r11
    e104:	2e 7e       	andi	r18, 0xEE	; 238
    e106:	05 c0       	rjmp	.+10     	; 0xe112 <vfprintf+0x2dc>
    e108:	7a 2c       	mov	r7, r10
    e10a:	2b 2d       	mov	r18, r11
    e10c:	03 c0       	rjmp	.+6      	; 0xe114 <vfprintf+0x2de>
    e10e:	7a 2c       	mov	r7, r10
    e110:	01 c0       	rjmp	.+2      	; 0xe114 <vfprintf+0x2de>
    e112:	75 2c       	mov	r7, r5
    e114:	24 ff       	sbrs	r18, 4
    e116:	0d c0       	rjmp	.+26     	; 0xe132 <vfprintf+0x2fc>
    e118:	fe 01       	movw	r30, r28
    e11a:	ea 0d       	add	r30, r10
    e11c:	f1 1d       	adc	r31, r1
    e11e:	80 81       	ld	r24, Z
    e120:	80 33       	cpi	r24, 0x30	; 48
    e122:	11 f4       	brne	.+4      	; 0xe128 <vfprintf+0x2f2>
    e124:	29 7e       	andi	r18, 0xE9	; 233
    e126:	09 c0       	rjmp	.+18     	; 0xe13a <vfprintf+0x304>
    e128:	22 ff       	sbrs	r18, 2
    e12a:	06 c0       	rjmp	.+12     	; 0xe138 <vfprintf+0x302>
    e12c:	73 94       	inc	r7
    e12e:	73 94       	inc	r7
    e130:	04 c0       	rjmp	.+8      	; 0xe13a <vfprintf+0x304>
    e132:	82 2f       	mov	r24, r18
    e134:	86 78       	andi	r24, 0x86	; 134
    e136:	09 f0       	breq	.+2      	; 0xe13a <vfprintf+0x304>
    e138:	73 94       	inc	r7
    e13a:	23 fd       	sbrc	r18, 3
    e13c:	13 c0       	rjmp	.+38     	; 0xe164 <vfprintf+0x32e>
    e13e:	20 ff       	sbrs	r18, 0
    e140:	06 c0       	rjmp	.+12     	; 0xe14e <vfprintf+0x318>
    e142:	5a 2c       	mov	r5, r10
    e144:	73 14       	cp	r7, r3
    e146:	18 f4       	brcc	.+6      	; 0xe14e <vfprintf+0x318>
    e148:	53 0c       	add	r5, r3
    e14a:	57 18       	sub	r5, r7
    e14c:	73 2c       	mov	r7, r3
    e14e:	73 14       	cp	r7, r3
    e150:	68 f4       	brcc	.+26     	; 0xe16c <vfprintf+0x336>
    e152:	b7 01       	movw	r22, r14
    e154:	80 e2       	ldi	r24, 0x20	; 32
    e156:	90 e0       	ldi	r25, 0x00	; 0
    e158:	2c 87       	std	Y+12, r18	; 0x0c
    e15a:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e15e:	73 94       	inc	r7
    e160:	2c 85       	ldd	r18, Y+12	; 0x0c
    e162:	f5 cf       	rjmp	.-22     	; 0xe14e <vfprintf+0x318>
    e164:	73 14       	cp	r7, r3
    e166:	10 f4       	brcc	.+4      	; 0xe16c <vfprintf+0x336>
    e168:	37 18       	sub	r3, r7
    e16a:	01 c0       	rjmp	.+2      	; 0xe16e <vfprintf+0x338>
    e16c:	31 2c       	mov	r3, r1
    e16e:	24 ff       	sbrs	r18, 4
    e170:	12 c0       	rjmp	.+36     	; 0xe196 <vfprintf+0x360>
    e172:	b7 01       	movw	r22, r14
    e174:	80 e3       	ldi	r24, 0x30	; 48
    e176:	90 e0       	ldi	r25, 0x00	; 0
    e178:	2c 87       	std	Y+12, r18	; 0x0c
    e17a:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e17e:	2c 85       	ldd	r18, Y+12	; 0x0c
    e180:	22 ff       	sbrs	r18, 2
    e182:	17 c0       	rjmp	.+46     	; 0xe1b2 <vfprintf+0x37c>
    e184:	21 ff       	sbrs	r18, 1
    e186:	03 c0       	rjmp	.+6      	; 0xe18e <vfprintf+0x358>
    e188:	88 e5       	ldi	r24, 0x58	; 88
    e18a:	90 e0       	ldi	r25, 0x00	; 0
    e18c:	02 c0       	rjmp	.+4      	; 0xe192 <vfprintf+0x35c>
    e18e:	88 e7       	ldi	r24, 0x78	; 120
    e190:	90 e0       	ldi	r25, 0x00	; 0
    e192:	b7 01       	movw	r22, r14
    e194:	0c c0       	rjmp	.+24     	; 0xe1ae <vfprintf+0x378>
    e196:	82 2f       	mov	r24, r18
    e198:	86 78       	andi	r24, 0x86	; 134
    e19a:	59 f0       	breq	.+22     	; 0xe1b2 <vfprintf+0x37c>
    e19c:	21 fd       	sbrc	r18, 1
    e19e:	02 c0       	rjmp	.+4      	; 0xe1a4 <vfprintf+0x36e>
    e1a0:	80 e2       	ldi	r24, 0x20	; 32
    e1a2:	01 c0       	rjmp	.+2      	; 0xe1a6 <vfprintf+0x370>
    e1a4:	8b e2       	ldi	r24, 0x2B	; 43
    e1a6:	27 fd       	sbrc	r18, 7
    e1a8:	8d e2       	ldi	r24, 0x2D	; 45
    e1aa:	b7 01       	movw	r22, r14
    e1ac:	90 e0       	ldi	r25, 0x00	; 0
    e1ae:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e1b2:	a5 14       	cp	r10, r5
    e1b4:	38 f4       	brcc	.+14     	; 0xe1c4 <vfprintf+0x38e>
    e1b6:	b7 01       	movw	r22, r14
    e1b8:	80 e3       	ldi	r24, 0x30	; 48
    e1ba:	90 e0       	ldi	r25, 0x00	; 0
    e1bc:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e1c0:	5a 94       	dec	r5
    e1c2:	f7 cf       	rjmp	.-18     	; 0xe1b2 <vfprintf+0x37c>
    e1c4:	aa 94       	dec	r10
    e1c6:	f4 01       	movw	r30, r8
    e1c8:	ea 0d       	add	r30, r10
    e1ca:	f1 1d       	adc	r31, r1
    e1cc:	80 81       	ld	r24, Z
    e1ce:	b7 01       	movw	r22, r14
    e1d0:	90 e0       	ldi	r25, 0x00	; 0
    e1d2:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e1d6:	a1 10       	cpse	r10, r1
    e1d8:	f5 cf       	rjmp	.-22     	; 0xe1c4 <vfprintf+0x38e>
    e1da:	33 20       	and	r3, r3
    e1dc:	09 f4       	brne	.+2      	; 0xe1e0 <vfprintf+0x3aa>
    e1de:	51 ce       	rjmp	.-862    	; 0xde82 <vfprintf+0x4c>
    e1e0:	b7 01       	movw	r22, r14
    e1e2:	80 e2       	ldi	r24, 0x20	; 32
    e1e4:	90 e0       	ldi	r25, 0x00	; 0
    e1e6:	0e 94 8e 74 	call	0xe91c	; 0xe91c <fputc>
    e1ea:	3a 94       	dec	r3
    e1ec:	f6 cf       	rjmp	.-20     	; 0xe1da <vfprintf+0x3a4>
    e1ee:	f7 01       	movw	r30, r14
    e1f0:	86 81       	ldd	r24, Z+6	; 0x06
    e1f2:	97 81       	ldd	r25, Z+7	; 0x07
    e1f4:	02 c0       	rjmp	.+4      	; 0xe1fa <vfprintf+0x3c4>
    e1f6:	8f ef       	ldi	r24, 0xFF	; 255
    e1f8:	9f ef       	ldi	r25, 0xFF	; 255
    e1fa:	2c 96       	adiw	r28, 0x0c	; 12
    e1fc:	0f b6       	in	r0, 0x3f	; 63
    e1fe:	f8 94       	cli
    e200:	de bf       	out	0x3e, r29	; 62
    e202:	0f be       	out	0x3f, r0	; 63
    e204:	cd bf       	out	0x3d, r28	; 61
    e206:	df 91       	pop	r29
    e208:	cf 91       	pop	r28
    e20a:	1f 91       	pop	r17
    e20c:	0f 91       	pop	r16
    e20e:	ff 90       	pop	r15
    e210:	ef 90       	pop	r14
    e212:	df 90       	pop	r13
    e214:	cf 90       	pop	r12
    e216:	bf 90       	pop	r11
    e218:	af 90       	pop	r10
    e21a:	9f 90       	pop	r9
    e21c:	8f 90       	pop	r8
    e21e:	7f 90       	pop	r7
    e220:	6f 90       	pop	r6
    e222:	5f 90       	pop	r5
    e224:	4f 90       	pop	r4
    e226:	3f 90       	pop	r3
    e228:	2f 90       	pop	r2
    e22a:	08 95       	ret

0000e22c <putval>:
    e22c:	20 fd       	sbrc	r18, 0
    e22e:	09 c0       	rjmp	.+18     	; 0xe242 <putval+0x16>
    e230:	fc 01       	movw	r30, r24
    e232:	23 fd       	sbrc	r18, 3
    e234:	05 c0       	rjmp	.+10     	; 0xe240 <putval+0x14>
    e236:	22 ff       	sbrs	r18, 2
    e238:	02 c0       	rjmp	.+4      	; 0xe23e <putval+0x12>
    e23a:	73 83       	std	Z+3, r23	; 0x03
    e23c:	62 83       	std	Z+2, r22	; 0x02
    e23e:	51 83       	std	Z+1, r21	; 0x01
    e240:	40 83       	st	Z, r20
    e242:	08 95       	ret

0000e244 <mulacc>:
    e244:	44 fd       	sbrc	r20, 4
    e246:	10 c0       	rjmp	.+32     	; 0xe268 <mulacc+0x24>
    e248:	46 fd       	sbrc	r20, 6
    e24a:	10 c0       	rjmp	.+32     	; 0xe26c <mulacc+0x28>
    e24c:	db 01       	movw	r26, r22
    e24e:	fc 01       	movw	r30, r24
    e250:	aa 0f       	add	r26, r26
    e252:	bb 1f       	adc	r27, r27
    e254:	ee 1f       	adc	r30, r30
    e256:	ff 1f       	adc	r31, r31
    e258:	10 94       	com	r1
    e25a:	d1 f7       	brne	.-12     	; 0xe250 <mulacc+0xc>
    e25c:	6a 0f       	add	r22, r26
    e25e:	7b 1f       	adc	r23, r27
    e260:	8e 1f       	adc	r24, r30
    e262:	9f 1f       	adc	r25, r31
    e264:	31 e0       	ldi	r19, 0x01	; 1
    e266:	03 c0       	rjmp	.+6      	; 0xe26e <mulacc+0x2a>
    e268:	33 e0       	ldi	r19, 0x03	; 3
    e26a:	01 c0       	rjmp	.+2      	; 0xe26e <mulacc+0x2a>
    e26c:	34 e0       	ldi	r19, 0x04	; 4
    e26e:	66 0f       	add	r22, r22
    e270:	77 1f       	adc	r23, r23
    e272:	88 1f       	adc	r24, r24
    e274:	99 1f       	adc	r25, r25
    e276:	31 50       	subi	r19, 0x01	; 1
    e278:	d1 f7       	brne	.-12     	; 0xe26e <mulacc+0x2a>
    e27a:	62 0f       	add	r22, r18
    e27c:	71 1d       	adc	r23, r1
    e27e:	81 1d       	adc	r24, r1
    e280:	91 1d       	adc	r25, r1
    e282:	08 95       	ret

0000e284 <skip_spaces>:
    e284:	0f 93       	push	r16
    e286:	1f 93       	push	r17
    e288:	cf 93       	push	r28
    e28a:	df 93       	push	r29
    e28c:	8c 01       	movw	r16, r24
    e28e:	c8 01       	movw	r24, r16
    e290:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e294:	ec 01       	movw	r28, r24
    e296:	97 fd       	sbrc	r25, 7
    e298:	08 c0       	rjmp	.+16     	; 0xe2aa <skip_spaces+0x26>
    e29a:	0e 94 32 74 	call	0xe864	; 0xe864 <isspace>
    e29e:	89 2b       	or	r24, r25
    e2a0:	b1 f7       	brne	.-20     	; 0xe28e <skip_spaces+0xa>
    e2a2:	b8 01       	movw	r22, r16
    e2a4:	ce 01       	movw	r24, r28
    e2a6:	0e 94 c0 74 	call	0xe980	; 0xe980 <ungetc>
    e2aa:	ce 01       	movw	r24, r28
    e2ac:	df 91       	pop	r29
    e2ae:	cf 91       	pop	r28
    e2b0:	1f 91       	pop	r17
    e2b2:	0f 91       	pop	r16
    e2b4:	08 95       	ret

0000e2b6 <conv_int>:
    e2b6:	8f 92       	push	r8
    e2b8:	9f 92       	push	r9
    e2ba:	af 92       	push	r10
    e2bc:	cf 92       	push	r12
    e2be:	df 92       	push	r13
    e2c0:	ef 92       	push	r14
    e2c2:	ff 92       	push	r15
    e2c4:	0f 93       	push	r16
    e2c6:	1f 93       	push	r17
    e2c8:	cf 93       	push	r28
    e2ca:	df 93       	push	r29
    e2cc:	ec 01       	movw	r28, r24
    e2ce:	a6 2e       	mov	r10, r22
    e2d0:	4a 01       	movw	r8, r20
    e2d2:	02 2f       	mov	r16, r18
    e2d4:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e2d8:	ac 01       	movw	r20, r24
    e2da:	55 27       	eor	r21, r21
    e2dc:	4b 32       	cpi	r20, 0x2B	; 43
    e2de:	51 05       	cpc	r21, r1
    e2e0:	21 f0       	breq	.+8      	; 0xe2ea <conv_int+0x34>
    e2e2:	4d 32       	cpi	r20, 0x2D	; 45
    e2e4:	51 05       	cpc	r21, r1
    e2e6:	51 f4       	brne	.+20     	; 0xe2fc <conv_int+0x46>
    e2e8:	00 68       	ori	r16, 0x80	; 128
    e2ea:	aa 94       	dec	r10
    e2ec:	11 f4       	brne	.+4      	; 0xe2f2 <conv_int+0x3c>
    e2ee:	80 e0       	ldi	r24, 0x00	; 0
    e2f0:	67 c0       	rjmp	.+206    	; 0xe3c0 <conv_int+0x10a>
    e2f2:	ce 01       	movw	r24, r28
    e2f4:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e2f8:	97 fd       	sbrc	r25, 7
    e2fa:	f9 cf       	rjmp	.-14     	; 0xe2ee <conv_int+0x38>
    e2fc:	10 2f       	mov	r17, r16
    e2fe:	1d 7f       	andi	r17, 0xFD	; 253
    e300:	30 2f       	mov	r19, r16
    e302:	30 73       	andi	r19, 0x30	; 48
    e304:	01 f5       	brne	.+64     	; 0xe346 <conv_int+0x90>
    e306:	80 33       	cpi	r24, 0x30	; 48
    e308:	f1 f4       	brne	.+60     	; 0xe346 <conv_int+0x90>
    e30a:	ff 24       	eor	r15, r15
    e30c:	fa 94       	dec	r15
    e30e:	fa 0c       	add	r15, r10
    e310:	09 f4       	brne	.+2      	; 0xe314 <conv_int+0x5e>
    e312:	42 c0       	rjmp	.+132    	; 0xe398 <conv_int+0xe2>
    e314:	ce 01       	movw	r24, r28
    e316:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e31a:	97 fd       	sbrc	r25, 7
    e31c:	3d c0       	rjmp	.+122    	; 0xe398 <conv_int+0xe2>
    e31e:	38 2f       	mov	r19, r24
    e320:	3f 7d       	andi	r19, 0xDF	; 223
    e322:	38 35       	cpi	r19, 0x58	; 88
    e324:	51 f4       	brne	.+20     	; 0xe33a <conv_int+0x84>
    e326:	12 64       	ori	r17, 0x42	; 66
    e328:	aa 94       	dec	r10
    e32a:	aa 94       	dec	r10
    e32c:	a9 f1       	breq	.+106    	; 0xe398 <conv_int+0xe2>
    e32e:	ce 01       	movw	r24, r28
    e330:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e334:	97 ff       	sbrs	r25, 7
    e336:	07 c0       	rjmp	.+14     	; 0xe346 <conv_int+0x90>
    e338:	2f c0       	rjmp	.+94     	; 0xe398 <conv_int+0xe2>
    e33a:	06 ff       	sbrs	r16, 6
    e33c:	02 c0       	rjmp	.+4      	; 0xe342 <conv_int+0x8c>
    e33e:	12 60       	ori	r17, 0x02	; 2
    e340:	01 c0       	rjmp	.+2      	; 0xe344 <conv_int+0x8e>
    e342:	12 61       	ori	r17, 0x12	; 18
    e344:	af 2c       	mov	r10, r15
    e346:	c1 2c       	mov	r12, r1
    e348:	d1 2c       	mov	r13, r1
    e34a:	76 01       	movw	r14, r12
    e34c:	20 ed       	ldi	r18, 0xD0	; 208
    e34e:	28 0f       	add	r18, r24
    e350:	28 30       	cpi	r18, 0x08	; 8
    e352:	80 f0       	brcs	.+32     	; 0xe374 <conv_int+0xbe>
    e354:	14 ff       	sbrs	r17, 4
    e356:	04 c0       	rjmp	.+8      	; 0xe360 <conv_int+0xaa>
    e358:	be 01       	movw	r22, r28
    e35a:	0e 94 c0 74 	call	0xe980	; 0xe980 <ungetc>
    e35e:	19 c0       	rjmp	.+50     	; 0xe392 <conv_int+0xdc>
    e360:	2a 30       	cpi	r18, 0x0A	; 10
    e362:	40 f0       	brcs	.+16     	; 0xe374 <conv_int+0xbe>
    e364:	16 ff       	sbrs	r17, 6
    e366:	f8 cf       	rjmp	.-16     	; 0xe358 <conv_int+0xa2>
    e368:	2f 7d       	andi	r18, 0xDF	; 223
    e36a:	3f ee       	ldi	r19, 0xEF	; 239
    e36c:	32 0f       	add	r19, r18
    e36e:	36 30       	cpi	r19, 0x06	; 6
    e370:	98 f7       	brcc	.-26     	; 0xe358 <conv_int+0xa2>
    e372:	27 50       	subi	r18, 0x07	; 7
    e374:	41 2f       	mov	r20, r17
    e376:	c7 01       	movw	r24, r14
    e378:	b6 01       	movw	r22, r12
    e37a:	0e 94 22 71 	call	0xe244	; 0xe244 <mulacc>
    e37e:	6b 01       	movw	r12, r22
    e380:	7c 01       	movw	r14, r24
    e382:	12 60       	ori	r17, 0x02	; 2
    e384:	aa 94       	dec	r10
    e386:	59 f0       	breq	.+22     	; 0xe39e <conv_int+0xe8>
    e388:	ce 01       	movw	r24, r28
    e38a:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e38e:	97 ff       	sbrs	r25, 7
    e390:	dd cf       	rjmp	.-70     	; 0xe34c <conv_int+0x96>
    e392:	11 fd       	sbrc	r17, 1
    e394:	04 c0       	rjmp	.+8      	; 0xe39e <conv_int+0xe8>
    e396:	ab cf       	rjmp	.-170    	; 0xe2ee <conv_int+0x38>
    e398:	c1 2c       	mov	r12, r1
    e39a:	d1 2c       	mov	r13, r1
    e39c:	76 01       	movw	r14, r12
    e39e:	17 ff       	sbrs	r17, 7
    e3a0:	08 c0       	rjmp	.+16     	; 0xe3b2 <conv_int+0xfc>
    e3a2:	f0 94       	com	r15
    e3a4:	e0 94       	com	r14
    e3a6:	d0 94       	com	r13
    e3a8:	c0 94       	com	r12
    e3aa:	c1 1c       	adc	r12, r1
    e3ac:	d1 1c       	adc	r13, r1
    e3ae:	e1 1c       	adc	r14, r1
    e3b0:	f1 1c       	adc	r15, r1
    e3b2:	21 2f       	mov	r18, r17
    e3b4:	b7 01       	movw	r22, r14
    e3b6:	a6 01       	movw	r20, r12
    e3b8:	c4 01       	movw	r24, r8
    e3ba:	0e 94 16 71 	call	0xe22c	; 0xe22c <putval>
    e3be:	81 e0       	ldi	r24, 0x01	; 1
    e3c0:	df 91       	pop	r29
    e3c2:	cf 91       	pop	r28
    e3c4:	1f 91       	pop	r17
    e3c6:	0f 91       	pop	r16
    e3c8:	ff 90       	pop	r15
    e3ca:	ef 90       	pop	r14
    e3cc:	df 90       	pop	r13
    e3ce:	cf 90       	pop	r12
    e3d0:	af 90       	pop	r10
    e3d2:	9f 90       	pop	r9
    e3d4:	8f 90       	pop	r8
    e3d6:	08 95       	ret

0000e3d8 <conv_brk>:
    e3d8:	7f 92       	push	r7
    e3da:	8f 92       	push	r8
    e3dc:	9f 92       	push	r9
    e3de:	af 92       	push	r10
    e3e0:	bf 92       	push	r11
    e3e2:	cf 92       	push	r12
    e3e4:	df 92       	push	r13
    e3e6:	ef 92       	push	r14
    e3e8:	ff 92       	push	r15
    e3ea:	0f 93       	push	r16
    e3ec:	1f 93       	push	r17
    e3ee:	cf 93       	push	r28
    e3f0:	df 93       	push	r29
    e3f2:	cd b7       	in	r28, 0x3d	; 61
    e3f4:	de b7       	in	r29, 0x3e	; 62
    e3f6:	a1 97       	sbiw	r28, 0x21	; 33
    e3f8:	0f b6       	in	r0, 0x3f	; 63
    e3fa:	f8 94       	cli
    e3fc:	de bf       	out	0x3e, r29	; 62
    e3fe:	0f be       	out	0x3f, r0	; 63
    e400:	cd bf       	out	0x3d, r28	; 61
    e402:	5c 01       	movw	r10, r24
    e404:	7a 01       	movw	r14, r20
    e406:	8e 01       	movw	r16, r28
    e408:	0f 5f       	subi	r16, 0xFF	; 255
    e40a:	1f 4f       	sbci	r17, 0xFF	; 255
    e40c:	68 01       	movw	r12, r16
    e40e:	80 e2       	ldi	r24, 0x20	; 32
    e410:	d8 01       	movw	r26, r16
    e412:	1d 92       	st	X+, r1
    e414:	8a 95       	dec	r24
    e416:	e9 f7       	brne	.-6      	; 0xe412 <conv_brk+0x3a>
    e418:	f5 01       	movw	r30, r10
    e41a:	73 80       	ldd	r7, Z+3	; 0x03
    e41c:	40 e0       	ldi	r20, 0x00	; 0
    e41e:	50 e0       	ldi	r21, 0x00	; 0
    e420:	81 2c       	mov	r8, r1
    e422:	b0 e0       	ldi	r27, 0x00	; 0
    e424:	91 2c       	mov	r9, r1
    e426:	81 e0       	ldi	r24, 0x01	; 1
    e428:	90 e0       	ldi	r25, 0x00	; 0
    e42a:	f9 01       	movw	r30, r18
    e42c:	73 fc       	sbrc	r7, 3
    e42e:	a5 91       	lpm	r26, Z+
    e430:	73 fe       	sbrs	r7, 3
    e432:	a1 91       	ld	r26, Z+
    e434:	8f 01       	movw	r16, r30
    e436:	7a 2f       	mov	r23, r26
    e438:	9f 01       	movw	r18, r30
    e43a:	a1 11       	cpse	r26, r1
    e43c:	03 c0       	rjmp	.+6      	; 0xe444 <conv_brk+0x6c>
    e43e:	80 e0       	ldi	r24, 0x00	; 0
    e440:	90 e0       	ldi	r25, 0x00	; 0
    e442:	7d c0       	rjmp	.+250    	; 0xe53e <conv_brk+0x166>
    e444:	ae 35       	cpi	r26, 0x5E	; 94
    e446:	19 f4       	brne	.+6      	; 0xe44e <conv_brk+0x76>
    e448:	41 15       	cp	r20, r1
    e44a:	51 05       	cpc	r21, r1
    e44c:	59 f1       	breq	.+86     	; 0xe4a4 <conv_brk+0xcc>
    e44e:	e9 2d       	mov	r30, r9
    e450:	f0 e0       	ldi	r31, 0x00	; 0
    e452:	e4 17       	cp	r30, r20
    e454:	f5 07       	cpc	r31, r21
    e456:	3c f4       	brge	.+14     	; 0xe466 <conv_brk+0x8e>
    e458:	ad 35       	cpi	r26, 0x5D	; 93
    e45a:	69 f1       	breq	.+90     	; 0xe4b6 <conv_brk+0xde>
    e45c:	ad 32       	cpi	r26, 0x2D	; 45
    e45e:	19 f4       	brne	.+6      	; 0xe466 <conv_brk+0x8e>
    e460:	bb 23       	and	r27, r27
    e462:	19 f1       	breq	.+70     	; 0xe4aa <conv_brk+0xd2>
    e464:	03 c0       	rjmp	.+6      	; 0xe46c <conv_brk+0x94>
    e466:	b1 11       	cpse	r27, r1
    e468:	01 c0       	rjmp	.+2      	; 0xe46c <conv_brk+0x94>
    e46a:	8a 2e       	mov	r8, r26
    e46c:	e7 2f       	mov	r30, r23
    e46e:	e6 95       	lsr	r30
    e470:	e6 95       	lsr	r30
    e472:	e6 95       	lsr	r30
    e474:	86 01       	movw	r16, r12
    e476:	0e 0f       	add	r16, r30
    e478:	11 1d       	adc	r17, r1
    e47a:	f8 01       	movw	r30, r16
    e47c:	a7 2f       	mov	r26, r23
    e47e:	a7 70       	andi	r26, 0x07	; 7
    e480:	8c 01       	movw	r16, r24
    e482:	02 c0       	rjmp	.+4      	; 0xe488 <conv_brk+0xb0>
    e484:	00 0f       	add	r16, r16
    e486:	11 1f       	adc	r17, r17
    e488:	aa 95       	dec	r26
    e48a:	e2 f7       	brpl	.-8      	; 0xe484 <conv_brk+0xac>
    e48c:	d8 01       	movw	r26, r16
    e48e:	b0 81       	ld	r27, Z
    e490:	ba 2b       	or	r27, r26
    e492:	b0 83       	st	Z, r27
    e494:	78 15       	cp	r23, r8
    e496:	59 f0       	breq	.+22     	; 0xe4ae <conv_brk+0xd6>
    e498:	78 15       	cp	r23, r8
    e49a:	10 f4       	brcc	.+4      	; 0xe4a0 <conv_brk+0xc8>
    e49c:	7f 5f       	subi	r23, 0xFF	; 255
    e49e:	e6 cf       	rjmp	.-52     	; 0xe46c <conv_brk+0x94>
    e4a0:	71 50       	subi	r23, 0x01	; 1
    e4a2:	e4 cf       	rjmp	.-56     	; 0xe46c <conv_brk+0x94>
    e4a4:	99 24       	eor	r9, r9
    e4a6:	93 94       	inc	r9
    e4a8:	03 c0       	rjmp	.+6      	; 0xe4b0 <conv_brk+0xd8>
    e4aa:	b1 e0       	ldi	r27, 0x01	; 1
    e4ac:	01 c0       	rjmp	.+2      	; 0xe4b0 <conv_brk+0xd8>
    e4ae:	b0 e0       	ldi	r27, 0x00	; 0
    e4b0:	4f 5f       	subi	r20, 0xFF	; 255
    e4b2:	5f 4f       	sbci	r21, 0xFF	; 255
    e4b4:	ba cf       	rjmp	.-140    	; 0xe42a <conv_brk+0x52>
    e4b6:	bb 23       	and	r27, r27
    e4b8:	19 f0       	breq	.+6      	; 0xe4c0 <conv_brk+0xe8>
    e4ba:	8e 81       	ldd	r24, Y+6	; 0x06
    e4bc:	80 62       	ori	r24, 0x20	; 32
    e4be:	8e 83       	std	Y+6, r24	; 0x06
    e4c0:	91 10       	cpse	r9, r1
    e4c2:	03 c0       	rjmp	.+6      	; 0xe4ca <conv_brk+0xf2>
    e4c4:	99 24       	eor	r9, r9
    e4c6:	93 94       	inc	r9
    e4c8:	15 c0       	rjmp	.+42     	; 0xe4f4 <conv_brk+0x11c>
    e4ca:	f6 01       	movw	r30, r12
    e4cc:	ce 01       	movw	r24, r28
    e4ce:	81 96       	adiw	r24, 0x21	; 33
    e4d0:	20 81       	ld	r18, Z
    e4d2:	20 95       	com	r18
    e4d4:	21 93       	st	Z+, r18
    e4d6:	e8 17       	cp	r30, r24
    e4d8:	f9 07       	cpc	r31, r25
    e4da:	d1 f7       	brne	.-12     	; 0xe4d0 <conv_brk+0xf8>
    e4dc:	f3 cf       	rjmp	.-26     	; 0xe4c4 <conv_brk+0xec>
    e4de:	e1 14       	cp	r14, r1
    e4e0:	f1 04       	cpc	r15, r1
    e4e2:	29 f0       	breq	.+10     	; 0xe4ee <conv_brk+0x116>
    e4e4:	d7 01       	movw	r26, r14
    e4e6:	8c 93       	st	X, r24
    e4e8:	f7 01       	movw	r30, r14
    e4ea:	31 96       	adiw	r30, 0x01	; 1
    e4ec:	7f 01       	movw	r14, r30
    e4ee:	61 50       	subi	r22, 0x01	; 1
    e4f0:	01 f1       	breq	.+64     	; 0xe532 <conv_brk+0x15a>
    e4f2:	91 2c       	mov	r9, r1
    e4f4:	c5 01       	movw	r24, r10
    e4f6:	69 a3       	std	Y+33, r22	; 0x21
    e4f8:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e4fc:	69 a1       	ldd	r22, Y+33	; 0x21
    e4fe:	97 fd       	sbrc	r25, 7
    e500:	16 c0       	rjmp	.+44     	; 0xe52e <conv_brk+0x156>
    e502:	28 2f       	mov	r18, r24
    e504:	26 95       	lsr	r18
    e506:	26 95       	lsr	r18
    e508:	26 95       	lsr	r18
    e50a:	f6 01       	movw	r30, r12
    e50c:	e2 0f       	add	r30, r18
    e50e:	f1 1d       	adc	r31, r1
    e510:	20 81       	ld	r18, Z
    e512:	30 e0       	ldi	r19, 0x00	; 0
    e514:	ac 01       	movw	r20, r24
    e516:	47 70       	andi	r20, 0x07	; 7
    e518:	55 27       	eor	r21, r21
    e51a:	02 c0       	rjmp	.+4      	; 0xe520 <conv_brk+0x148>
    e51c:	35 95       	asr	r19
    e51e:	27 95       	ror	r18
    e520:	4a 95       	dec	r20
    e522:	e2 f7       	brpl	.-8      	; 0xe51c <conv_brk+0x144>
    e524:	20 fd       	sbrc	r18, 0
    e526:	db cf       	rjmp	.-74     	; 0xe4de <conv_brk+0x106>
    e528:	b5 01       	movw	r22, r10
    e52a:	0e 94 c0 74 	call	0xe980	; 0xe980 <ungetc>
    e52e:	91 10       	cpse	r9, r1
    e530:	86 cf       	rjmp	.-244    	; 0xe43e <conv_brk+0x66>
    e532:	e1 14       	cp	r14, r1
    e534:	f1 04       	cpc	r15, r1
    e536:	11 f0       	breq	.+4      	; 0xe53c <conv_brk+0x164>
    e538:	d7 01       	movw	r26, r14
    e53a:	1c 92       	st	X, r1
    e53c:	c8 01       	movw	r24, r16
    e53e:	a1 96       	adiw	r28, 0x21	; 33
    e540:	0f b6       	in	r0, 0x3f	; 63
    e542:	f8 94       	cli
    e544:	de bf       	out	0x3e, r29	; 62
    e546:	0f be       	out	0x3f, r0	; 63
    e548:	cd bf       	out	0x3d, r28	; 61
    e54a:	df 91       	pop	r29
    e54c:	cf 91       	pop	r28
    e54e:	1f 91       	pop	r17
    e550:	0f 91       	pop	r16
    e552:	ff 90       	pop	r15
    e554:	ef 90       	pop	r14
    e556:	df 90       	pop	r13
    e558:	cf 90       	pop	r12
    e55a:	bf 90       	pop	r11
    e55c:	af 90       	pop	r10
    e55e:	9f 90       	pop	r9
    e560:	8f 90       	pop	r8
    e562:	7f 90       	pop	r7
    e564:	08 95       	ret

0000e566 <vfscanf>:
    e566:	4f 92       	push	r4
    e568:	5f 92       	push	r5
    e56a:	7f 92       	push	r7
    e56c:	8f 92       	push	r8
    e56e:	9f 92       	push	r9
    e570:	af 92       	push	r10
    e572:	bf 92       	push	r11
    e574:	cf 92       	push	r12
    e576:	df 92       	push	r13
    e578:	ef 92       	push	r14
    e57a:	ff 92       	push	r15
    e57c:	0f 93       	push	r16
    e57e:	1f 93       	push	r17
    e580:	cf 93       	push	r28
    e582:	df 93       	push	r29
    e584:	1f 92       	push	r1
    e586:	cd b7       	in	r28, 0x3d	; 61
    e588:	de b7       	in	r29, 0x3e	; 62
    e58a:	8c 01       	movw	r16, r24
    e58c:	2b 01       	movw	r4, r22
    e58e:	7a 01       	movw	r14, r20
    e590:	fc 01       	movw	r30, r24
    e592:	17 82       	std	Z+7, r1	; 0x07
    e594:	16 82       	std	Z+6, r1	; 0x06
    e596:	a1 2c       	mov	r10, r1
    e598:	f8 01       	movw	r30, r16
    e59a:	d3 80       	ldd	r13, Z+3	; 0x03
    e59c:	f2 01       	movw	r30, r4
    e59e:	d3 fc       	sbrc	r13, 3
    e5a0:	85 91       	lpm	r24, Z+
    e5a2:	d3 fe       	sbrs	r13, 3
    e5a4:	81 91       	ld	r24, Z+
    e5a6:	38 2f       	mov	r19, r24
    e5a8:	2f 01       	movw	r4, r30
    e5aa:	88 23       	and	r24, r24
    e5ac:	09 f4       	brne	.+2      	; 0xe5b0 <vfscanf+0x4a>
    e5ae:	fc c0       	rjmp	.+504    	; 0xe7a8 <vfscanf+0x242>
    e5b0:	90 e0       	ldi	r25, 0x00	; 0
    e5b2:	39 83       	std	Y+1, r19	; 0x01
    e5b4:	0e 94 32 74 	call	0xe864	; 0xe864 <isspace>
    e5b8:	39 81       	ldd	r19, Y+1	; 0x01
    e5ba:	89 2b       	or	r24, r25
    e5bc:	21 f0       	breq	.+8      	; 0xe5c6 <vfscanf+0x60>
    e5be:	c8 01       	movw	r24, r16
    e5c0:	0e 94 42 71 	call	0xe284	; 0xe284 <skip_spaces>
    e5c4:	e9 cf       	rjmp	.-46     	; 0xe598 <vfscanf+0x32>
    e5c6:	35 32       	cpi	r19, 0x25	; 37
    e5c8:	41 f4       	brne	.+16     	; 0xe5da <vfscanf+0x74>
    e5ca:	f2 01       	movw	r30, r4
    e5cc:	d3 fc       	sbrc	r13, 3
    e5ce:	35 91       	lpm	r19, Z+
    e5d0:	d3 fe       	sbrs	r13, 3
    e5d2:	31 91       	ld	r19, Z+
    e5d4:	2f 01       	movw	r4, r30
    e5d6:	35 32       	cpi	r19, 0x25	; 37
    e5d8:	69 f4       	brne	.+26     	; 0xe5f4 <vfscanf+0x8e>
    e5da:	c8 01       	movw	r24, r16
    e5dc:	39 83       	std	Y+1, r19	; 0x01
    e5de:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e5e2:	39 81       	ldd	r19, Y+1	; 0x01
    e5e4:	97 fd       	sbrc	r25, 7
    e5e6:	de c0       	rjmp	.+444    	; 0xe7a4 <vfscanf+0x23e>
    e5e8:	38 17       	cp	r19, r24
    e5ea:	b1 f2       	breq	.-84     	; 0xe598 <vfscanf+0x32>
    e5ec:	b8 01       	movw	r22, r16
    e5ee:	0e 94 c0 74 	call	0xe980	; 0xe980 <ungetc>
    e5f2:	da c0       	rjmp	.+436    	; 0xe7a8 <vfscanf+0x242>
    e5f4:	3a 32       	cpi	r19, 0x2A	; 42
    e5f6:	41 f4       	brne	.+16     	; 0xe608 <vfscanf+0xa2>
    e5f8:	d3 fc       	sbrc	r13, 3
    e5fa:	35 91       	lpm	r19, Z+
    e5fc:	d3 fe       	sbrs	r13, 3
    e5fe:	31 91       	ld	r19, Z+
    e600:	2f 01       	movw	r4, r30
    e602:	bb 24       	eor	r11, r11
    e604:	b3 94       	inc	r11
    e606:	01 c0       	rjmp	.+2      	; 0xe60a <vfscanf+0xa4>
    e608:	b1 2c       	mov	r11, r1
    e60a:	71 2c       	mov	r7, r1
    e60c:	20 ed       	ldi	r18, 0xD0	; 208
    e60e:	23 0f       	add	r18, r19
    e610:	2a 30       	cpi	r18, 0x0A	; 10
    e612:	90 f4       	brcc	.+36     	; 0xe638 <vfscanf+0xd2>
    e614:	fb 2d       	mov	r31, r11
    e616:	f2 60       	ori	r31, 0x02	; 2
    e618:	bf 2e       	mov	r11, r31
    e61a:	67 2d       	mov	r22, r7
    e61c:	70 e0       	ldi	r23, 0x00	; 0
    e61e:	80 e0       	ldi	r24, 0x00	; 0
    e620:	90 e0       	ldi	r25, 0x00	; 0
    e622:	40 e2       	ldi	r20, 0x20	; 32
    e624:	0e 94 22 71 	call	0xe244	; 0xe244 <mulacc>
    e628:	76 2e       	mov	r7, r22
    e62a:	f2 01       	movw	r30, r4
    e62c:	d3 fc       	sbrc	r13, 3
    e62e:	35 91       	lpm	r19, Z+
    e630:	d3 fe       	sbrs	r13, 3
    e632:	31 91       	ld	r19, Z+
    e634:	2f 01       	movw	r4, r30
    e636:	ea cf       	rjmp	.-44     	; 0xe60c <vfscanf+0xa6>
    e638:	b1 fe       	sbrs	r11, 1
    e63a:	03 c0       	rjmp	.+6      	; 0xe642 <vfscanf+0xdc>
    e63c:	71 10       	cpse	r7, r1
    e63e:	03 c0       	rjmp	.+6      	; 0xe646 <vfscanf+0xe0>
    e640:	b3 c0       	rjmp	.+358    	; 0xe7a8 <vfscanf+0x242>
    e642:	77 24       	eor	r7, r7
    e644:	7a 94       	dec	r7
    e646:	38 36       	cpi	r19, 0x68	; 104
    e648:	19 f0       	breq	.+6      	; 0xe650 <vfscanf+0xea>
    e64a:	3c 36       	cpi	r19, 0x6C	; 108
    e64c:	61 f0       	breq	.+24     	; 0xe666 <vfscanf+0x100>
    e64e:	14 c0       	rjmp	.+40     	; 0xe678 <vfscanf+0x112>
    e650:	f2 01       	movw	r30, r4
    e652:	d3 fc       	sbrc	r13, 3
    e654:	35 91       	lpm	r19, Z+
    e656:	d3 fe       	sbrs	r13, 3
    e658:	31 91       	ld	r19, Z+
    e65a:	2f 01       	movw	r4, r30
    e65c:	38 36       	cpi	r19, 0x68	; 104
    e65e:	61 f4       	brne	.+24     	; 0xe678 <vfscanf+0x112>
    e660:	fb 2d       	mov	r31, r11
    e662:	f8 60       	ori	r31, 0x08	; 8
    e664:	bf 2e       	mov	r11, r31
    e666:	8b 2d       	mov	r24, r11
    e668:	84 60       	ori	r24, 0x04	; 4
    e66a:	b8 2e       	mov	r11, r24
    e66c:	f2 01       	movw	r30, r4
    e66e:	d3 fc       	sbrc	r13, 3
    e670:	35 91       	lpm	r19, Z+
    e672:	d3 fe       	sbrs	r13, 3
    e674:	31 91       	ld	r19, Z+
    e676:	2f 01       	movw	r4, r30
    e678:	33 23       	and	r19, r19
    e67a:	09 f4       	brne	.+2      	; 0xe67e <vfscanf+0x118>
    e67c:	95 c0       	rjmp	.+298    	; 0xe7a8 <vfscanf+0x242>
    e67e:	63 2f       	mov	r22, r19
    e680:	70 e0       	ldi	r23, 0x00	; 0
    e682:	87 ee       	ldi	r24, 0xE7	; 231
    e684:	9f e4       	ldi	r25, 0x4F	; 79
    e686:	39 83       	std	Y+1, r19	; 0x01
    e688:	0e 94 5d 6c 	call	0xd8ba	; 0xd8ba <strchr_P>
    e68c:	39 81       	ldd	r19, Y+1	; 0x01
    e68e:	89 2b       	or	r24, r25
    e690:	09 f4       	brne	.+2      	; 0xe694 <vfscanf+0x12e>
    e692:	8a c0       	rjmp	.+276    	; 0xe7a8 <vfscanf+0x242>
    e694:	b0 fc       	sbrc	r11, 0
    e696:	07 c0       	rjmp	.+14     	; 0xe6a6 <vfscanf+0x140>
    e698:	f7 01       	movw	r30, r14
    e69a:	c0 80       	ld	r12, Z
    e69c:	d1 80       	ldd	r13, Z+1	; 0x01
    e69e:	c7 01       	movw	r24, r14
    e6a0:	02 96       	adiw	r24, 0x02	; 2
    e6a2:	7c 01       	movw	r14, r24
    e6a4:	02 c0       	rjmp	.+4      	; 0xe6aa <vfscanf+0x144>
    e6a6:	c1 2c       	mov	r12, r1
    e6a8:	d1 2c       	mov	r13, r1
    e6aa:	3e 36       	cpi	r19, 0x6E	; 110
    e6ac:	51 f4       	brne	.+20     	; 0xe6c2 <vfscanf+0x15c>
    e6ae:	f8 01       	movw	r30, r16
    e6b0:	46 81       	ldd	r20, Z+6	; 0x06
    e6b2:	57 81       	ldd	r21, Z+7	; 0x07
    e6b4:	60 e0       	ldi	r22, 0x00	; 0
    e6b6:	70 e0       	ldi	r23, 0x00	; 0
    e6b8:	2b 2d       	mov	r18, r11
    e6ba:	c6 01       	movw	r24, r12
    e6bc:	0e 94 16 71 	call	0xe22c	; 0xe22c <putval>
    e6c0:	6b cf       	rjmp	.-298    	; 0xe598 <vfscanf+0x32>
    e6c2:	33 36       	cpi	r19, 0x63	; 99
    e6c4:	a1 f4       	brne	.+40     	; 0xe6ee <vfscanf+0x188>
    e6c6:	b1 fc       	sbrc	r11, 1
    e6c8:	02 c0       	rjmp	.+4      	; 0xe6ce <vfscanf+0x168>
    e6ca:	77 24       	eor	r7, r7
    e6cc:	73 94       	inc	r7
    e6ce:	c8 01       	movw	r24, r16
    e6d0:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e6d4:	97 fd       	sbrc	r25, 7
    e6d6:	66 c0       	rjmp	.+204    	; 0xe7a4 <vfscanf+0x23e>
    e6d8:	c1 14       	cp	r12, r1
    e6da:	d1 04       	cpc	r13, r1
    e6dc:	29 f0       	breq	.+10     	; 0xe6e8 <vfscanf+0x182>
    e6de:	f6 01       	movw	r30, r12
    e6e0:	80 83       	st	Z, r24
    e6e2:	c6 01       	movw	r24, r12
    e6e4:	01 96       	adiw	r24, 0x01	; 1
    e6e6:	6c 01       	movw	r12, r24
    e6e8:	7a 94       	dec	r7
    e6ea:	89 f7       	brne	.-30     	; 0xe6ce <vfscanf+0x168>
    e6ec:	57 c0       	rjmp	.+174    	; 0xe79c <vfscanf+0x236>
    e6ee:	3b 35       	cpi	r19, 0x5B	; 91
    e6f0:	59 f4       	brne	.+22     	; 0xe708 <vfscanf+0x1a2>
    e6f2:	92 01       	movw	r18, r4
    e6f4:	a6 01       	movw	r20, r12
    e6f6:	67 2d       	mov	r22, r7
    e6f8:	c8 01       	movw	r24, r16
    e6fa:	0e 94 ec 71 	call	0xe3d8	; 0xe3d8 <conv_brk>
    e6fe:	2c 01       	movw	r4, r24
    e700:	00 97       	sbiw	r24, 0x00	; 0
    e702:	09 f0       	breq	.+2      	; 0xe706 <vfscanf+0x1a0>
    e704:	4b c0       	rjmp	.+150    	; 0xe79c <vfscanf+0x236>
    e706:	45 c0       	rjmp	.+138    	; 0xe792 <vfscanf+0x22c>
    e708:	c8 01       	movw	r24, r16
    e70a:	39 83       	std	Y+1, r19	; 0x01
    e70c:	0e 94 42 71 	call	0xe284	; 0xe284 <skip_spaces>
    e710:	39 81       	ldd	r19, Y+1	; 0x01
    e712:	97 fd       	sbrc	r25, 7
    e714:	47 c0       	rjmp	.+142    	; 0xe7a4 <vfscanf+0x23e>
    e716:	3f 36       	cpi	r19, 0x6F	; 111
    e718:	69 f1       	breq	.+90     	; 0xe774 <vfscanf+0x20e>
    e71a:	28 f4       	brcc	.+10     	; 0xe726 <vfscanf+0x1c0>
    e71c:	34 36       	cpi	r19, 0x64	; 100
    e71e:	31 f1       	breq	.+76     	; 0xe76c <vfscanf+0x206>
    e720:	39 36       	cpi	r19, 0x69	; 105
    e722:	79 f1       	breq	.+94     	; 0xe782 <vfscanf+0x21c>
    e724:	2b c0       	rjmp	.+86     	; 0xe77c <vfscanf+0x216>
    e726:	33 37       	cpi	r19, 0x73	; 115
    e728:	69 f0       	breq	.+26     	; 0xe744 <vfscanf+0x1de>
    e72a:	35 37       	cpi	r19, 0x75	; 117
    e72c:	f9 f0       	breq	.+62     	; 0xe76c <vfscanf+0x206>
    e72e:	26 c0       	rjmp	.+76     	; 0xe77c <vfscanf+0x216>
    e730:	c1 14       	cp	r12, r1
    e732:	d1 04       	cpc	r13, r1
    e734:	29 f0       	breq	.+10     	; 0xe740 <vfscanf+0x1da>
    e736:	f6 01       	movw	r30, r12
    e738:	80 82       	st	Z, r8
    e73a:	c6 01       	movw	r24, r12
    e73c:	01 96       	adiw	r24, 0x01	; 1
    e73e:	6c 01       	movw	r12, r24
    e740:	7a 94       	dec	r7
    e742:	71 f0       	breq	.+28     	; 0xe760 <vfscanf+0x1fa>
    e744:	c8 01       	movw	r24, r16
    e746:	0e 94 50 74 	call	0xe8a0	; 0xe8a0 <fgetc>
    e74a:	4c 01       	movw	r8, r24
    e74c:	97 fd       	sbrc	r25, 7
    e74e:	08 c0       	rjmp	.+16     	; 0xe760 <vfscanf+0x1fa>
    e750:	0e 94 32 74 	call	0xe864	; 0xe864 <isspace>
    e754:	89 2b       	or	r24, r25
    e756:	61 f3       	breq	.-40     	; 0xe730 <vfscanf+0x1ca>
    e758:	b8 01       	movw	r22, r16
    e75a:	c4 01       	movw	r24, r8
    e75c:	0e 94 c0 74 	call	0xe980	; 0xe980 <ungetc>
    e760:	c1 14       	cp	r12, r1
    e762:	d1 04       	cpc	r13, r1
    e764:	d9 f0       	breq	.+54     	; 0xe79c <vfscanf+0x236>
    e766:	f6 01       	movw	r30, r12
    e768:	10 82       	st	Z, r1
    e76a:	18 c0       	rjmp	.+48     	; 0xe79c <vfscanf+0x236>
    e76c:	fb 2d       	mov	r31, r11
    e76e:	f0 62       	ori	r31, 0x20	; 32
    e770:	bf 2e       	mov	r11, r31
    e772:	07 c0       	rjmp	.+14     	; 0xe782 <vfscanf+0x21c>
    e774:	8b 2d       	mov	r24, r11
    e776:	80 61       	ori	r24, 0x10	; 16
    e778:	b8 2e       	mov	r11, r24
    e77a:	03 c0       	rjmp	.+6      	; 0xe782 <vfscanf+0x21c>
    e77c:	9b 2d       	mov	r25, r11
    e77e:	90 64       	ori	r25, 0x40	; 64
    e780:	b9 2e       	mov	r11, r25
    e782:	2b 2d       	mov	r18, r11
    e784:	a6 01       	movw	r20, r12
    e786:	67 2d       	mov	r22, r7
    e788:	c8 01       	movw	r24, r16
    e78a:	0e 94 5b 71 	call	0xe2b6	; 0xe2b6 <conv_int>
    e78e:	81 11       	cpse	r24, r1
    e790:	05 c0       	rjmp	.+10     	; 0xe79c <vfscanf+0x236>
    e792:	f8 01       	movw	r30, r16
    e794:	83 81       	ldd	r24, Z+3	; 0x03
    e796:	80 73       	andi	r24, 0x30	; 48
    e798:	29 f4       	brne	.+10     	; 0xe7a4 <vfscanf+0x23e>
    e79a:	06 c0       	rjmp	.+12     	; 0xe7a8 <vfscanf+0x242>
    e79c:	b0 fc       	sbrc	r11, 0
    e79e:	fc ce       	rjmp	.-520    	; 0xe598 <vfscanf+0x32>
    e7a0:	a3 94       	inc	r10
    e7a2:	fa ce       	rjmp	.-524    	; 0xe598 <vfscanf+0x32>
    e7a4:	aa 20       	and	r10, r10
    e7a6:	19 f0       	breq	.+6      	; 0xe7ae <vfscanf+0x248>
    e7a8:	8a 2d       	mov	r24, r10
    e7aa:	90 e0       	ldi	r25, 0x00	; 0
    e7ac:	02 c0       	rjmp	.+4      	; 0xe7b2 <vfscanf+0x24c>
    e7ae:	8f ef       	ldi	r24, 0xFF	; 255
    e7b0:	9f ef       	ldi	r25, 0xFF	; 255
    e7b2:	0f 90       	pop	r0
    e7b4:	df 91       	pop	r29
    e7b6:	cf 91       	pop	r28
    e7b8:	1f 91       	pop	r17
    e7ba:	0f 91       	pop	r16
    e7bc:	ff 90       	pop	r15
    e7be:	ef 90       	pop	r14
    e7c0:	df 90       	pop	r13
    e7c2:	cf 90       	pop	r12
    e7c4:	bf 90       	pop	r11
    e7c6:	af 90       	pop	r10
    e7c8:	9f 90       	pop	r9
    e7ca:	8f 90       	pop	r8
    e7cc:	7f 90       	pop	r7
    e7ce:	5f 90       	pop	r5
    e7d0:	4f 90       	pop	r4
    e7d2:	08 95       	ret

0000e7d4 <__eerd_block_m128>:
    e7d4:	dc 01       	movw	r26, r24
    e7d6:	cb 01       	movw	r24, r22

0000e7d8 <__eerd_blraw_m128>:
    e7d8:	fc 01       	movw	r30, r24
    e7da:	e1 99       	sbic	0x1c, 1	; 28
    e7dc:	fe cf       	rjmp	.-4      	; 0xe7da <__eerd_blraw_m128+0x2>
    e7de:	06 c0       	rjmp	.+12     	; 0xe7ec <__eerd_blraw_m128+0x14>
    e7e0:	ff bb       	out	0x1f, r31	; 31
    e7e2:	ee bb       	out	0x1e, r30	; 30
    e7e4:	e0 9a       	sbi	0x1c, 0	; 28
    e7e6:	31 96       	adiw	r30, 0x01	; 1
    e7e8:	0d b2       	in	r0, 0x1d	; 29
    e7ea:	0d 92       	st	X+, r0
    e7ec:	41 50       	subi	r20, 0x01	; 1
    e7ee:	50 40       	sbci	r21, 0x00	; 0
    e7f0:	b8 f7       	brcc	.-18     	; 0xe7e0 <__eerd_blraw_m128+0x8>
    e7f2:	08 95       	ret

0000e7f4 <__eerd_byte_m128>:
    e7f4:	e1 99       	sbic	0x1c, 1	; 28
    e7f6:	fe cf       	rjmp	.-4      	; 0xe7f4 <__eerd_byte_m128>
    e7f8:	9f bb       	out	0x1f, r25	; 31
    e7fa:	8e bb       	out	0x1e, r24	; 30
    e7fc:	e0 9a       	sbi	0x1c, 0	; 28
    e7fe:	99 27       	eor	r25, r25
    e800:	8d b3       	in	r24, 0x1d	; 29
    e802:	08 95       	ret

0000e804 <__eerd_dword_m128>:
    e804:	a6 e1       	ldi	r26, 0x16	; 22
    e806:	b0 e0       	ldi	r27, 0x00	; 0
    e808:	44 e0       	ldi	r20, 0x04	; 4
    e80a:	50 e0       	ldi	r21, 0x00	; 0
    e80c:	0c 94 ec 73 	jmp	0xe7d8	; 0xe7d8 <__eerd_blraw_m128>

0000e810 <__eerd_word_m128>:
    e810:	a8 e1       	ldi	r26, 0x18	; 24
    e812:	b0 e0       	ldi	r27, 0x00	; 0
    e814:	42 e0       	ldi	r20, 0x02	; 2
    e816:	50 e0       	ldi	r21, 0x00	; 0
    e818:	0c 94 ec 73 	jmp	0xe7d8	; 0xe7d8 <__eerd_blraw_m128>

0000e81c <__eewr_block_m128>:
    e81c:	dc 01       	movw	r26, r24
    e81e:	cb 01       	movw	r24, r22
    e820:	03 c0       	rjmp	.+6      	; 0xe828 <__eewr_block_m128+0xc>
    e822:	2d 91       	ld	r18, X+
    e824:	0e 94 19 74 	call	0xe832	; 0xe832 <__eewr_r18_m128>
    e828:	41 50       	subi	r20, 0x01	; 1
    e82a:	50 40       	sbci	r21, 0x00	; 0
    e82c:	d0 f7       	brcc	.-12     	; 0xe822 <__eewr_block_m128+0x6>
    e82e:	08 95       	ret

0000e830 <__eewr_byte_m128>:
    e830:	26 2f       	mov	r18, r22

0000e832 <__eewr_r18_m128>:
    e832:	e1 99       	sbic	0x1c, 1	; 28
    e834:	fe cf       	rjmp	.-4      	; 0xe832 <__eewr_r18_m128>
    e836:	9f bb       	out	0x1f, r25	; 31
    e838:	8e bb       	out	0x1e, r24	; 30
    e83a:	2d bb       	out	0x1d, r18	; 29
    e83c:	0f b6       	in	r0, 0x3f	; 63
    e83e:	f8 94       	cli
    e840:	e2 9a       	sbi	0x1c, 2	; 28
    e842:	e1 9a       	sbi	0x1c, 1	; 28
    e844:	0f be       	out	0x3f, r0	; 63
    e846:	01 96       	adiw	r24, 0x01	; 1
    e848:	08 95       	ret

0000e84a <__eewr_dword_m128>:
    e84a:	24 2f       	mov	r18, r20
    e84c:	0e 94 19 74 	call	0xe832	; 0xe832 <__eewr_r18_m128>
    e850:	25 2f       	mov	r18, r21
    e852:	0e 94 19 74 	call	0xe832	; 0xe832 <__eewr_r18_m128>
    e856:	0c 94 2d 74 	jmp	0xe85a	; 0xe85a <__eewr_word_m128>

0000e85a <__eewr_word_m128>:
    e85a:	0e 94 18 74 	call	0xe830	; 0xe830 <__eewr_byte_m128>
    e85e:	27 2f       	mov	r18, r23
    e860:	0c 94 19 74 	jmp	0xe832	; 0xe832 <__eewr_r18_m128>

0000e864 <isspace>:
    e864:	91 11       	cpse	r25, r1
    e866:	03 c1       	rjmp	.+518    	; 0xea6e <__ctype_isfalse>
    e868:	80 32       	cpi	r24, 0x20	; 32
    e86a:	19 f0       	breq	.+6      	; 0xe872 <isspace+0xe>
    e86c:	89 50       	subi	r24, 0x09	; 9
    e86e:	85 50       	subi	r24, 0x05	; 5
    e870:	d0 f7       	brcc	.-12     	; 0xe866 <isspace+0x2>
    e872:	08 95       	ret

0000e874 <strnlen_P>:
    e874:	fc 01       	movw	r30, r24
    e876:	05 90       	lpm	r0, Z+
    e878:	61 50       	subi	r22, 0x01	; 1
    e87a:	70 40       	sbci	r23, 0x00	; 0
    e87c:	01 10       	cpse	r0, r1
    e87e:	d8 f7       	brcc	.-10     	; 0xe876 <strnlen_P+0x2>
    e880:	80 95       	com	r24
    e882:	90 95       	com	r25
    e884:	8e 0f       	add	r24, r30
    e886:	9f 1f       	adc	r25, r31
    e888:	08 95       	ret

0000e88a <strnlen>:
    e88a:	fc 01       	movw	r30, r24
    e88c:	61 50       	subi	r22, 0x01	; 1
    e88e:	70 40       	sbci	r23, 0x00	; 0
    e890:	01 90       	ld	r0, Z+
    e892:	01 10       	cpse	r0, r1
    e894:	d8 f7       	brcc	.-10     	; 0xe88c <strnlen+0x2>
    e896:	80 95       	com	r24
    e898:	90 95       	com	r25
    e89a:	8e 0f       	add	r24, r30
    e89c:	9f 1f       	adc	r25, r31
    e89e:	08 95       	ret

0000e8a0 <fgetc>:
    e8a0:	cf 93       	push	r28
    e8a2:	df 93       	push	r29
    e8a4:	ec 01       	movw	r28, r24
    e8a6:	2b 81       	ldd	r18, Y+3	; 0x03
    e8a8:	20 ff       	sbrs	r18, 0
    e8aa:	33 c0       	rjmp	.+102    	; 0xe912 <fgetc+0x72>
    e8ac:	26 ff       	sbrs	r18, 6
    e8ae:	0a c0       	rjmp	.+20     	; 0xe8c4 <fgetc+0x24>
    e8b0:	2f 7b       	andi	r18, 0xBF	; 191
    e8b2:	2b 83       	std	Y+3, r18	; 0x03
    e8b4:	8e 81       	ldd	r24, Y+6	; 0x06
    e8b6:	9f 81       	ldd	r25, Y+7	; 0x07
    e8b8:	01 96       	adiw	r24, 0x01	; 1
    e8ba:	9f 83       	std	Y+7, r25	; 0x07
    e8bc:	8e 83       	std	Y+6, r24	; 0x06
    e8be:	8a 81       	ldd	r24, Y+2	; 0x02
    e8c0:	90 e0       	ldi	r25, 0x00	; 0
    e8c2:	29 c0       	rjmp	.+82     	; 0xe916 <fgetc+0x76>
    e8c4:	22 ff       	sbrs	r18, 2
    e8c6:	0f c0       	rjmp	.+30     	; 0xe8e6 <fgetc+0x46>
    e8c8:	e8 81       	ld	r30, Y
    e8ca:	f9 81       	ldd	r31, Y+1	; 0x01
    e8cc:	80 81       	ld	r24, Z
    e8ce:	99 27       	eor	r25, r25
    e8d0:	87 fd       	sbrc	r24, 7
    e8d2:	90 95       	com	r25
    e8d4:	00 97       	sbiw	r24, 0x00	; 0
    e8d6:	19 f4       	brne	.+6      	; 0xe8de <fgetc+0x3e>
    e8d8:	20 62       	ori	r18, 0x20	; 32
    e8da:	2b 83       	std	Y+3, r18	; 0x03
    e8dc:	1a c0       	rjmp	.+52     	; 0xe912 <fgetc+0x72>
    e8de:	31 96       	adiw	r30, 0x01	; 1
    e8e0:	f9 83       	std	Y+1, r31	; 0x01
    e8e2:	e8 83       	st	Y, r30
    e8e4:	0e c0       	rjmp	.+28     	; 0xe902 <fgetc+0x62>
    e8e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    e8e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    e8ea:	09 95       	icall
    e8ec:	97 ff       	sbrs	r25, 7
    e8ee:	09 c0       	rjmp	.+18     	; 0xe902 <fgetc+0x62>
    e8f0:	2b 81       	ldd	r18, Y+3	; 0x03
    e8f2:	01 96       	adiw	r24, 0x01	; 1
    e8f4:	11 f4       	brne	.+4      	; 0xe8fa <fgetc+0x5a>
    e8f6:	80 e1       	ldi	r24, 0x10	; 16
    e8f8:	01 c0       	rjmp	.+2      	; 0xe8fc <fgetc+0x5c>
    e8fa:	80 e2       	ldi	r24, 0x20	; 32
    e8fc:	82 2b       	or	r24, r18
    e8fe:	8b 83       	std	Y+3, r24	; 0x03
    e900:	08 c0       	rjmp	.+16     	; 0xe912 <fgetc+0x72>
    e902:	2e 81       	ldd	r18, Y+6	; 0x06
    e904:	3f 81       	ldd	r19, Y+7	; 0x07
    e906:	2f 5f       	subi	r18, 0xFF	; 255
    e908:	3f 4f       	sbci	r19, 0xFF	; 255
    e90a:	3f 83       	std	Y+7, r19	; 0x07
    e90c:	2e 83       	std	Y+6, r18	; 0x06
    e90e:	99 27       	eor	r25, r25
    e910:	02 c0       	rjmp	.+4      	; 0xe916 <fgetc+0x76>
    e912:	8f ef       	ldi	r24, 0xFF	; 255
    e914:	9f ef       	ldi	r25, 0xFF	; 255
    e916:	df 91       	pop	r29
    e918:	cf 91       	pop	r28
    e91a:	08 95       	ret

0000e91c <fputc>:
    e91c:	0f 93       	push	r16
    e91e:	1f 93       	push	r17
    e920:	cf 93       	push	r28
    e922:	df 93       	push	r29
    e924:	18 2f       	mov	r17, r24
    e926:	09 2f       	mov	r16, r25
    e928:	eb 01       	movw	r28, r22
    e92a:	8b 81       	ldd	r24, Y+3	; 0x03
    e92c:	81 fd       	sbrc	r24, 1
    e92e:	03 c0       	rjmp	.+6      	; 0xe936 <fputc+0x1a>
    e930:	8f ef       	ldi	r24, 0xFF	; 255
    e932:	9f ef       	ldi	r25, 0xFF	; 255
    e934:	20 c0       	rjmp	.+64     	; 0xe976 <fputc+0x5a>
    e936:	82 ff       	sbrs	r24, 2
    e938:	10 c0       	rjmp	.+32     	; 0xe95a <fputc+0x3e>
    e93a:	4e 81       	ldd	r20, Y+6	; 0x06
    e93c:	5f 81       	ldd	r21, Y+7	; 0x07
    e93e:	2c 81       	ldd	r18, Y+4	; 0x04
    e940:	3d 81       	ldd	r19, Y+5	; 0x05
    e942:	42 17       	cp	r20, r18
    e944:	53 07       	cpc	r21, r19
    e946:	7c f4       	brge	.+30     	; 0xe966 <fputc+0x4a>
    e948:	e8 81       	ld	r30, Y
    e94a:	f9 81       	ldd	r31, Y+1	; 0x01
    e94c:	9f 01       	movw	r18, r30
    e94e:	2f 5f       	subi	r18, 0xFF	; 255
    e950:	3f 4f       	sbci	r19, 0xFF	; 255
    e952:	39 83       	std	Y+1, r19	; 0x01
    e954:	28 83       	st	Y, r18
    e956:	10 83       	st	Z, r17
    e958:	06 c0       	rjmp	.+12     	; 0xe966 <fputc+0x4a>
    e95a:	e8 85       	ldd	r30, Y+8	; 0x08
    e95c:	f9 85       	ldd	r31, Y+9	; 0x09
    e95e:	81 2f       	mov	r24, r17
    e960:	09 95       	icall
    e962:	89 2b       	or	r24, r25
    e964:	29 f7       	brne	.-54     	; 0xe930 <fputc+0x14>
    e966:	2e 81       	ldd	r18, Y+6	; 0x06
    e968:	3f 81       	ldd	r19, Y+7	; 0x07
    e96a:	2f 5f       	subi	r18, 0xFF	; 255
    e96c:	3f 4f       	sbci	r19, 0xFF	; 255
    e96e:	3f 83       	std	Y+7, r19	; 0x07
    e970:	2e 83       	std	Y+6, r18	; 0x06
    e972:	81 2f       	mov	r24, r17
    e974:	90 2f       	mov	r25, r16
    e976:	df 91       	pop	r29
    e978:	cf 91       	pop	r28
    e97a:	1f 91       	pop	r17
    e97c:	0f 91       	pop	r16
    e97e:	08 95       	ret

0000e980 <ungetc>:
    e980:	fb 01       	movw	r30, r22
    e982:	23 81       	ldd	r18, Z+3	; 0x03
    e984:	20 ff       	sbrs	r18, 0
    e986:	12 c0       	rjmp	.+36     	; 0xe9ac <ungetc+0x2c>
    e988:	26 fd       	sbrc	r18, 6
    e98a:	10 c0       	rjmp	.+32     	; 0xe9ac <ungetc+0x2c>
    e98c:	8f 3f       	cpi	r24, 0xFF	; 255
    e98e:	3f ef       	ldi	r19, 0xFF	; 255
    e990:	93 07       	cpc	r25, r19
    e992:	61 f0       	breq	.+24     	; 0xe9ac <ungetc+0x2c>
    e994:	82 83       	std	Z+2, r24	; 0x02
    e996:	2f 7d       	andi	r18, 0xDF	; 223
    e998:	20 64       	ori	r18, 0x40	; 64
    e99a:	23 83       	std	Z+3, r18	; 0x03
    e99c:	26 81       	ldd	r18, Z+6	; 0x06
    e99e:	37 81       	ldd	r19, Z+7	; 0x07
    e9a0:	21 50       	subi	r18, 0x01	; 1
    e9a2:	31 09       	sbc	r19, r1
    e9a4:	37 83       	std	Z+7, r19	; 0x07
    e9a6:	26 83       	std	Z+6, r18	; 0x06
    e9a8:	99 27       	eor	r25, r25
    e9aa:	08 95       	ret
    e9ac:	8f ef       	ldi	r24, 0xFF	; 255
    e9ae:	9f ef       	ldi	r25, 0xFF	; 255
    e9b0:	08 95       	ret

0000e9b2 <__ultoa_invert>:
    e9b2:	fa 01       	movw	r30, r20
    e9b4:	aa 27       	eor	r26, r26
    e9b6:	28 30       	cpi	r18, 0x08	; 8
    e9b8:	51 f1       	breq	.+84     	; 0xea0e <__ultoa_invert+0x5c>
    e9ba:	20 31       	cpi	r18, 0x10	; 16
    e9bc:	81 f1       	breq	.+96     	; 0xea1e <__ultoa_invert+0x6c>
    e9be:	e8 94       	clt
    e9c0:	6f 93       	push	r22
    e9c2:	6e 7f       	andi	r22, 0xFE	; 254
    e9c4:	6e 5f       	subi	r22, 0xFE	; 254
    e9c6:	7f 4f       	sbci	r23, 0xFF	; 255
    e9c8:	8f 4f       	sbci	r24, 0xFF	; 255
    e9ca:	9f 4f       	sbci	r25, 0xFF	; 255
    e9cc:	af 4f       	sbci	r26, 0xFF	; 255
    e9ce:	b1 e0       	ldi	r27, 0x01	; 1
    e9d0:	3e d0       	rcall	.+124    	; 0xea4e <__ultoa_invert+0x9c>
    e9d2:	b4 e0       	ldi	r27, 0x04	; 4
    e9d4:	3c d0       	rcall	.+120    	; 0xea4e <__ultoa_invert+0x9c>
    e9d6:	67 0f       	add	r22, r23
    e9d8:	78 1f       	adc	r23, r24
    e9da:	89 1f       	adc	r24, r25
    e9dc:	9a 1f       	adc	r25, r26
    e9de:	a1 1d       	adc	r26, r1
    e9e0:	68 0f       	add	r22, r24
    e9e2:	79 1f       	adc	r23, r25
    e9e4:	8a 1f       	adc	r24, r26
    e9e6:	91 1d       	adc	r25, r1
    e9e8:	a1 1d       	adc	r26, r1
    e9ea:	6a 0f       	add	r22, r26
    e9ec:	71 1d       	adc	r23, r1
    e9ee:	81 1d       	adc	r24, r1
    e9f0:	91 1d       	adc	r25, r1
    e9f2:	a1 1d       	adc	r26, r1
    e9f4:	20 d0       	rcall	.+64     	; 0xea36 <__ultoa_invert+0x84>
    e9f6:	09 f4       	brne	.+2      	; 0xe9fa <__ultoa_invert+0x48>
    e9f8:	68 94       	set
    e9fa:	3f 91       	pop	r19
    e9fc:	2a e0       	ldi	r18, 0x0A	; 10
    e9fe:	26 9f       	mul	r18, r22
    ea00:	11 24       	eor	r1, r1
    ea02:	30 19       	sub	r19, r0
    ea04:	30 5d       	subi	r19, 0xD0	; 208
    ea06:	31 93       	st	Z+, r19
    ea08:	de f6       	brtc	.-74     	; 0xe9c0 <__ultoa_invert+0xe>
    ea0a:	cf 01       	movw	r24, r30
    ea0c:	08 95       	ret
    ea0e:	46 2f       	mov	r20, r22
    ea10:	47 70       	andi	r20, 0x07	; 7
    ea12:	40 5d       	subi	r20, 0xD0	; 208
    ea14:	41 93       	st	Z+, r20
    ea16:	b3 e0       	ldi	r27, 0x03	; 3
    ea18:	0f d0       	rcall	.+30     	; 0xea38 <__ultoa_invert+0x86>
    ea1a:	c9 f7       	brne	.-14     	; 0xea0e <__ultoa_invert+0x5c>
    ea1c:	f6 cf       	rjmp	.-20     	; 0xea0a <__ultoa_invert+0x58>
    ea1e:	46 2f       	mov	r20, r22
    ea20:	4f 70       	andi	r20, 0x0F	; 15
    ea22:	40 5d       	subi	r20, 0xD0	; 208
    ea24:	4a 33       	cpi	r20, 0x3A	; 58
    ea26:	18 f0       	brcs	.+6      	; 0xea2e <__ultoa_invert+0x7c>
    ea28:	49 5d       	subi	r20, 0xD9	; 217
    ea2a:	31 fd       	sbrc	r19, 1
    ea2c:	40 52       	subi	r20, 0x20	; 32
    ea2e:	41 93       	st	Z+, r20
    ea30:	02 d0       	rcall	.+4      	; 0xea36 <__ultoa_invert+0x84>
    ea32:	a9 f7       	brne	.-22     	; 0xea1e <__ultoa_invert+0x6c>
    ea34:	ea cf       	rjmp	.-44     	; 0xea0a <__ultoa_invert+0x58>
    ea36:	b4 e0       	ldi	r27, 0x04	; 4
    ea38:	a6 95       	lsr	r26
    ea3a:	97 95       	ror	r25
    ea3c:	87 95       	ror	r24
    ea3e:	77 95       	ror	r23
    ea40:	67 95       	ror	r22
    ea42:	ba 95       	dec	r27
    ea44:	c9 f7       	brne	.-14     	; 0xea38 <__ultoa_invert+0x86>
    ea46:	00 97       	sbiw	r24, 0x00	; 0
    ea48:	61 05       	cpc	r22, r1
    ea4a:	71 05       	cpc	r23, r1
    ea4c:	08 95       	ret
    ea4e:	9b 01       	movw	r18, r22
    ea50:	ac 01       	movw	r20, r24
    ea52:	0a 2e       	mov	r0, r26
    ea54:	06 94       	lsr	r0
    ea56:	57 95       	ror	r21
    ea58:	47 95       	ror	r20
    ea5a:	37 95       	ror	r19
    ea5c:	27 95       	ror	r18
    ea5e:	ba 95       	dec	r27
    ea60:	c9 f7       	brne	.-14     	; 0xea54 <__ultoa_invert+0xa2>
    ea62:	62 0f       	add	r22, r18
    ea64:	73 1f       	adc	r23, r19
    ea66:	84 1f       	adc	r24, r20
    ea68:	95 1f       	adc	r25, r21
    ea6a:	a0 1d       	adc	r26, r0
    ea6c:	08 95       	ret

0000ea6e <__ctype_isfalse>:
    ea6e:	99 27       	eor	r25, r25
    ea70:	88 27       	eor	r24, r24

0000ea72 <__ctype_istrue>:
    ea72:	08 95       	ret

0000ea74 <__udivmodqi4>:
    ea74:	99 1b       	sub	r25, r25
    ea76:	79 e0       	ldi	r23, 0x09	; 9
    ea78:	04 c0       	rjmp	.+8      	; 0xea82 <__udivmodqi4_ep>

0000ea7a <__udivmodqi4_loop>:
    ea7a:	99 1f       	adc	r25, r25
    ea7c:	96 17       	cp	r25, r22
    ea7e:	08 f0       	brcs	.+2      	; 0xea82 <__udivmodqi4_ep>
    ea80:	96 1b       	sub	r25, r22

0000ea82 <__udivmodqi4_ep>:
    ea82:	88 1f       	adc	r24, r24
    ea84:	7a 95       	dec	r23
    ea86:	c9 f7       	brne	.-14     	; 0xea7a <__udivmodqi4_loop>
    ea88:	80 95       	com	r24
    ea8a:	08 95       	ret

0000ea8c <__udivmodhi4>:
    ea8c:	aa 1b       	sub	r26, r26
    ea8e:	bb 1b       	sub	r27, r27
    ea90:	51 e1       	ldi	r21, 0x11	; 17
    ea92:	07 c0       	rjmp	.+14     	; 0xeaa2 <__udivmodhi4_ep>

0000ea94 <__udivmodhi4_loop>:
    ea94:	aa 1f       	adc	r26, r26
    ea96:	bb 1f       	adc	r27, r27
    ea98:	a6 17       	cp	r26, r22
    ea9a:	b7 07       	cpc	r27, r23
    ea9c:	10 f0       	brcs	.+4      	; 0xeaa2 <__udivmodhi4_ep>
    ea9e:	a6 1b       	sub	r26, r22
    eaa0:	b7 0b       	sbc	r27, r23

0000eaa2 <__udivmodhi4_ep>:
    eaa2:	88 1f       	adc	r24, r24
    eaa4:	99 1f       	adc	r25, r25
    eaa6:	5a 95       	dec	r21
    eaa8:	a9 f7       	brne	.-22     	; 0xea94 <__udivmodhi4_loop>
    eaaa:	80 95       	com	r24
    eaac:	90 95       	com	r25
    eaae:	bc 01       	movw	r22, r24
    eab0:	cd 01       	movw	r24, r26
    eab2:	08 95       	ret

0000eab4 <__divmodhi4>:
    eab4:	97 fb       	bst	r25, 7
    eab6:	07 2e       	mov	r0, r23
    eab8:	16 f4       	brtc	.+4      	; 0xeabe <__divmodhi4+0xa>
    eaba:	00 94       	com	r0
    eabc:	07 d0       	rcall	.+14     	; 0xeacc <__divmodhi4_neg1>
    eabe:	77 fd       	sbrc	r23, 7
    eac0:	09 d0       	rcall	.+18     	; 0xead4 <__divmodhi4_neg2>
    eac2:	0e 94 46 75 	call	0xea8c	; 0xea8c <__udivmodhi4>
    eac6:	07 fc       	sbrc	r0, 7
    eac8:	05 d0       	rcall	.+10     	; 0xead4 <__divmodhi4_neg2>
    eaca:	3e f4       	brtc	.+14     	; 0xeada <__divmodhi4_exit>

0000eacc <__divmodhi4_neg1>:
    eacc:	90 95       	com	r25
    eace:	81 95       	neg	r24
    ead0:	9f 4f       	sbci	r25, 0xFF	; 255
    ead2:	08 95       	ret

0000ead4 <__divmodhi4_neg2>:
    ead4:	70 95       	com	r23
    ead6:	61 95       	neg	r22
    ead8:	7f 4f       	sbci	r23, 0xFF	; 255

0000eada <__divmodhi4_exit>:
    eada:	08 95       	ret

0000eadc <__udivmodsi4>:
    eadc:	a1 e2       	ldi	r26, 0x21	; 33
    eade:	1a 2e       	mov	r1, r26
    eae0:	aa 1b       	sub	r26, r26
    eae2:	bb 1b       	sub	r27, r27
    eae4:	fd 01       	movw	r30, r26
    eae6:	0d c0       	rjmp	.+26     	; 0xeb02 <__udivmodsi4_ep>

0000eae8 <__udivmodsi4_loop>:
    eae8:	aa 1f       	adc	r26, r26
    eaea:	bb 1f       	adc	r27, r27
    eaec:	ee 1f       	adc	r30, r30
    eaee:	ff 1f       	adc	r31, r31
    eaf0:	a2 17       	cp	r26, r18
    eaf2:	b3 07       	cpc	r27, r19
    eaf4:	e4 07       	cpc	r30, r20
    eaf6:	f5 07       	cpc	r31, r21
    eaf8:	20 f0       	brcs	.+8      	; 0xeb02 <__udivmodsi4_ep>
    eafa:	a2 1b       	sub	r26, r18
    eafc:	b3 0b       	sbc	r27, r19
    eafe:	e4 0b       	sbc	r30, r20
    eb00:	f5 0b       	sbc	r31, r21

0000eb02 <__udivmodsi4_ep>:
    eb02:	66 1f       	adc	r22, r22
    eb04:	77 1f       	adc	r23, r23
    eb06:	88 1f       	adc	r24, r24
    eb08:	99 1f       	adc	r25, r25
    eb0a:	1a 94       	dec	r1
    eb0c:	69 f7       	brne	.-38     	; 0xeae8 <__udivmodsi4_loop>
    eb0e:	60 95       	com	r22
    eb10:	70 95       	com	r23
    eb12:	80 95       	com	r24
    eb14:	90 95       	com	r25
    eb16:	9b 01       	movw	r18, r22
    eb18:	ac 01       	movw	r20, r24
    eb1a:	bd 01       	movw	r22, r26
    eb1c:	cf 01       	movw	r24, r30
    eb1e:	08 95       	ret

0000eb20 <__divmodsi4>:
    eb20:	05 2e       	mov	r0, r21
    eb22:	97 fb       	bst	r25, 7
    eb24:	1e f4       	brtc	.+6      	; 0xeb2c <__divmodsi4+0xc>
    eb26:	00 94       	com	r0
    eb28:	0e 94 a7 75 	call	0xeb4e	; 0xeb4e <__negsi2>
    eb2c:	57 fd       	sbrc	r21, 7
    eb2e:	07 d0       	rcall	.+14     	; 0xeb3e <__divmodsi4_neg2>
    eb30:	0e 94 6e 75 	call	0xeadc	; 0xeadc <__udivmodsi4>
    eb34:	07 fc       	sbrc	r0, 7
    eb36:	03 d0       	rcall	.+6      	; 0xeb3e <__divmodsi4_neg2>
    eb38:	4e f4       	brtc	.+18     	; 0xeb4c <__divmodsi4_exit>
    eb3a:	0c 94 a7 75 	jmp	0xeb4e	; 0xeb4e <__negsi2>

0000eb3e <__divmodsi4_neg2>:
    eb3e:	50 95       	com	r21
    eb40:	40 95       	com	r20
    eb42:	30 95       	com	r19
    eb44:	21 95       	neg	r18
    eb46:	3f 4f       	sbci	r19, 0xFF	; 255
    eb48:	4f 4f       	sbci	r20, 0xFF	; 255
    eb4a:	5f 4f       	sbci	r21, 0xFF	; 255

0000eb4c <__divmodsi4_exit>:
    eb4c:	08 95       	ret

0000eb4e <__negsi2>:
    eb4e:	90 95       	com	r25
    eb50:	80 95       	com	r24
    eb52:	70 95       	com	r23
    eb54:	61 95       	neg	r22
    eb56:	7f 4f       	sbci	r23, 0xFF	; 255
    eb58:	8f 4f       	sbci	r24, 0xFF	; 255
    eb5a:	9f 4f       	sbci	r25, 0xFF	; 255
    eb5c:	08 95       	ret

0000eb5e <__tablejump2__>:
    eb5e:	ee 0f       	add	r30, r30
    eb60:	ff 1f       	adc	r31, r31

0000eb62 <__tablejump__>:
    eb62:	05 90       	lpm	r0, Z+
    eb64:	f4 91       	lpm	r31, Z
    eb66:	e0 2d       	mov	r30, r0
    eb68:	09 94       	ijmp

0000eb6a <__muluhisi3>:
    eb6a:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    eb6e:	a5 9f       	mul	r26, r21
    eb70:	90 0d       	add	r25, r0
    eb72:	b4 9f       	mul	r27, r20
    eb74:	90 0d       	add	r25, r0
    eb76:	a4 9f       	mul	r26, r20
    eb78:	80 0d       	add	r24, r0
    eb7a:	91 1d       	adc	r25, r1
    eb7c:	11 24       	eor	r1, r1
    eb7e:	08 95       	ret

0000eb80 <__mulshisi3>:
    eb80:	b7 ff       	sbrs	r27, 7
    eb82:	0c 94 b5 75 	jmp	0xeb6a	; 0xeb6a <__muluhisi3>

0000eb86 <__mulohisi3>:
    eb86:	0e 94 b5 75 	call	0xeb6a	; 0xeb6a <__muluhisi3>
    eb8a:	82 1b       	sub	r24, r18
    eb8c:	93 0b       	sbc	r25, r19
    eb8e:	08 95       	ret

0000eb90 <__muldi3>:
    eb90:	df 93       	push	r29
    eb92:	cf 93       	push	r28
    eb94:	1f 93       	push	r17
    eb96:	0f 93       	push	r16
    eb98:	9a 9d       	mul	r25, r10
    eb9a:	f0 2d       	mov	r31, r0
    eb9c:	21 9f       	mul	r18, r17
    eb9e:	f0 0d       	add	r31, r0
    eba0:	8b 9d       	mul	r24, r11
    eba2:	f0 0d       	add	r31, r0
    eba4:	8a 9d       	mul	r24, r10
    eba6:	e0 2d       	mov	r30, r0
    eba8:	f1 0d       	add	r31, r1
    ebaa:	03 9f       	mul	r16, r19
    ebac:	f0 0d       	add	r31, r0
    ebae:	02 9f       	mul	r16, r18
    ebb0:	e0 0d       	add	r30, r0
    ebb2:	f1 1d       	adc	r31, r1
    ebb4:	4e 9d       	mul	r20, r14
    ebb6:	e0 0d       	add	r30, r0
    ebb8:	f1 1d       	adc	r31, r1
    ebba:	5e 9d       	mul	r21, r14
    ebbc:	f0 0d       	add	r31, r0
    ebbe:	4f 9d       	mul	r20, r15
    ebc0:	f0 0d       	add	r31, r0
    ebc2:	7f 93       	push	r23
    ebc4:	6f 93       	push	r22
    ebc6:	bf 92       	push	r11
    ebc8:	af 92       	push	r10
    ebca:	5f 93       	push	r21
    ebcc:	4f 93       	push	r20
    ebce:	d5 01       	movw	r26, r10
    ebd0:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ebd4:	8b 01       	movw	r16, r22
    ebd6:	ac 01       	movw	r20, r24
    ebd8:	d7 01       	movw	r26, r14
    ebda:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ebde:	eb 01       	movw	r28, r22
    ebe0:	e8 0f       	add	r30, r24
    ebe2:	f9 1f       	adc	r31, r25
    ebe4:	d6 01       	movw	r26, r12
    ebe6:	0e 94 18 76 	call	0xec30	; 0xec30 <__muldi3_6>
    ebea:	2f 91       	pop	r18
    ebec:	3f 91       	pop	r19
    ebee:	d6 01       	movw	r26, r12
    ebf0:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ebf4:	c6 0f       	add	r28, r22
    ebf6:	d7 1f       	adc	r29, r23
    ebf8:	e8 1f       	adc	r30, r24
    ebfa:	f9 1f       	adc	r31, r25
    ebfc:	af 91       	pop	r26
    ebfe:	bf 91       	pop	r27
    ec00:	0e 94 18 76 	call	0xec30	; 0xec30 <__muldi3_6>
    ec04:	2f 91       	pop	r18
    ec06:	3f 91       	pop	r19
    ec08:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ec0c:	c6 0f       	add	r28, r22
    ec0e:	d7 1f       	adc	r29, r23
    ec10:	e8 1f       	adc	r30, r24
    ec12:	f9 1f       	adc	r31, r25
    ec14:	d6 01       	movw	r26, r12
    ec16:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ec1a:	e6 0f       	add	r30, r22
    ec1c:	f7 1f       	adc	r31, r23
    ec1e:	98 01       	movw	r18, r16
    ec20:	be 01       	movw	r22, r28
    ec22:	cf 01       	movw	r24, r30
    ec24:	11 24       	eor	r1, r1
    ec26:	0f 91       	pop	r16
    ec28:	1f 91       	pop	r17
    ec2a:	cf 91       	pop	r28
    ec2c:	df 91       	pop	r29
    ec2e:	08 95       	ret

0000ec30 <__muldi3_6>:
    ec30:	0e 94 2a 76 	call	0xec54	; 0xec54 <__umulhisi3>
    ec34:	46 0f       	add	r20, r22
    ec36:	57 1f       	adc	r21, r23
    ec38:	c8 1f       	adc	r28, r24
    ec3a:	d9 1f       	adc	r29, r25
    ec3c:	08 f4       	brcc	.+2      	; 0xec40 <__muldi3_6+0x10>
    ec3e:	31 96       	adiw	r30, 0x01	; 1
    ec40:	08 95       	ret

0000ec42 <__adddi3>:
    ec42:	2a 0d       	add	r18, r10
    ec44:	3b 1d       	adc	r19, r11
    ec46:	4c 1d       	adc	r20, r12
    ec48:	5d 1d       	adc	r21, r13
    ec4a:	6e 1d       	adc	r22, r14
    ec4c:	7f 1d       	adc	r23, r15
    ec4e:	80 1f       	adc	r24, r16
    ec50:	91 1f       	adc	r25, r17
    ec52:	08 95       	ret

0000ec54 <__umulhisi3>:
    ec54:	a2 9f       	mul	r26, r18
    ec56:	b0 01       	movw	r22, r0
    ec58:	b3 9f       	mul	r27, r19
    ec5a:	c0 01       	movw	r24, r0
    ec5c:	a3 9f       	mul	r26, r19
    ec5e:	70 0d       	add	r23, r0
    ec60:	81 1d       	adc	r24, r1
    ec62:	11 24       	eor	r1, r1
    ec64:	91 1d       	adc	r25, r1
    ec66:	b2 9f       	mul	r27, r18
    ec68:	70 0d       	add	r23, r0
    ec6a:	81 1d       	adc	r24, r1
    ec6c:	11 24       	eor	r1, r1
    ec6e:	91 1d       	adc	r25, r1
    ec70:	08 95       	ret

0000ec72 <_exit>:
    ec72:	f8 94       	cli

0000ec74 <__stop_program>:
    ec74:	ff cf       	rjmp	.-2      	; 0xec74 <__stop_program>
